# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

### .include 'gen/nqp-grammar.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1300060177.262")
.annotate 'line', 0
    get_hll_global $P2379, ["NQP";"Regex"], "_block2378" 
    capture_lex $P2379
    get_hll_global $P14, ["NQP";"Grammar"], "_block13" 
    capture_lex $P14
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P14, ["NQP";"Grammar"], "_block13" 
    capture_lex $P14
    $P14()
.annotate 'line', 692
    get_hll_global $P2379, ["NQP";"Regex"], "_block2378" 
    capture_lex $P2379
    $P2481 = $P2379()
.annotate 'line', 1
    .return ($P2481)
    .const 'Sub' $P2483 = "404_1300060177.262" 
    .return ($P2483)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post405") :outer("10_1300060177.262")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1300060177.262" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P2487, "1300060171.714"
    isnull $I2488, $P2487
    if $I2488, if_2486
    nqp_get_sc_object $P2501, "1300060171.714", 0
    set_hll_global ["NQP"], "Grammar", $P2501
    nqp_get_sc_object $P2502, "1300060171.714", 1
    set_hll_global ["NQP"], "Regex", $P2502
    goto if_2486_end
  if_2486:
    nqp_dynop_setup 
    getinterp $P2489
    get_class $P2490, "LexPad"
    get_class $P2491, "NQPLexPad"
    $P2489."hll_map"($P2490, $P2491)
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P2492, "1300060171.714"
    .local pmc cur_sc
    set cur_sc, $P2492
    load_bytecode "SettingManager.pbc"
    get_hll_global $P2493, ["HLL"], "SettingManager"
    $P2494 = $P2493."load_setting"("NQPCORE")
    block."set_outer_ctx"($P2494)
    load_bytecode "P6Regex.pbc"
    get_hll_global $P2495, "NQPClassHOW"
    $P2496 = $P2495."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P2496, cur_sc
    nqp_set_sc_object "1300060171.714", 0, $P2496
    nqp_get_sc_object $P2497, "1300060171.714", 0
    set_hll_global ["NQP"], "Grammar", $P2497
    get_hll_global $P2498, "NQPClassHOW"
    $P2499 = $P2498."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P2499, cur_sc
    nqp_set_sc_object "1300060171.714", 1, $P2499
    nqp_get_sc_object $P2500, "1300060171.714", 1
    set_hll_global ["NQP"], "Regex", $P2500
  if_2486_end:
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block13"  :subid("11_1300060177.262") :outer("10_1300060177.262")
.annotate 'line', 3
    .const 'Sub' $P1660 = "381_1300060177.262" 
    capture_lex $P1660
    .const 'Sub' $P1647 = "380_1300060177.262" 
    capture_lex $P1647
    .const 'Sub' $P1641 = "378_1300060177.262" 
    capture_lex $P1641
    .const 'Sub' $P1635 = "376_1300060177.262" 
    capture_lex $P1635
    .const 'Sub' $P1629 = "374_1300060177.262" 
    capture_lex $P1629
    .const 'Sub' $P1623 = "372_1300060177.262" 
    capture_lex $P1623
    .const 'Sub' $P1611 = "369_1300060177.262" 
    capture_lex $P1611
    .const 'Sub' $P1604 = "367_1300060177.262" 
    capture_lex $P1604
    .const 'Sub' $P1597 = "365_1300060177.262" 
    capture_lex $P1597
    .const 'Sub' $P1590 = "363_1300060177.262" 
    capture_lex $P1590
    .const 'Sub' $P1583 = "361_1300060177.262" 
    capture_lex $P1583
    .const 'Sub' $P1577 = "359_1300060177.262" 
    capture_lex $P1577
    .const 'Sub' $P1570 = "357_1300060177.262" 
    capture_lex $P1570
    .const 'Sub' $P1563 = "355_1300060177.262" 
    capture_lex $P1563
    .const 'Sub' $P1556 = "353_1300060177.262" 
    capture_lex $P1556
    .const 'Sub' $P1549 = "351_1300060177.262" 
    capture_lex $P1549
    .const 'Sub' $P1542 = "349_1300060177.262" 
    capture_lex $P1542
    .const 'Sub' $P1535 = "347_1300060177.262" 
    capture_lex $P1535
    .const 'Sub' $P1528 = "345_1300060177.262" 
    capture_lex $P1528
    .const 'Sub' $P1521 = "343_1300060177.262" 
    capture_lex $P1521
    .const 'Sub' $P1514 = "341_1300060177.262" 
    capture_lex $P1514
    .const 'Sub' $P1507 = "339_1300060177.262" 
    capture_lex $P1507
    .const 'Sub' $P1500 = "337_1300060177.262" 
    capture_lex $P1500
    .const 'Sub' $P1493 = "335_1300060177.262" 
    capture_lex $P1493
    .const 'Sub' $P1486 = "333_1300060177.262" 
    capture_lex $P1486
    .const 'Sub' $P1479 = "331_1300060177.262" 
    capture_lex $P1479
    .const 'Sub' $P1472 = "329_1300060177.262" 
    capture_lex $P1472
    .const 'Sub' $P1465 = "327_1300060177.262" 
    capture_lex $P1465
    .const 'Sub' $P1458 = "325_1300060177.262" 
    capture_lex $P1458
    .const 'Sub' $P1451 = "323_1300060177.262" 
    capture_lex $P1451
    .const 'Sub' $P1444 = "321_1300060177.262" 
    capture_lex $P1444
    .const 'Sub' $P1437 = "319_1300060177.262" 
    capture_lex $P1437
    .const 'Sub' $P1430 = "317_1300060177.262" 
    capture_lex $P1430
    .const 'Sub' $P1423 = "315_1300060177.262" 
    capture_lex $P1423
    .const 'Sub' $P1416 = "313_1300060177.262" 
    capture_lex $P1416
    .const 'Sub' $P1409 = "311_1300060177.262" 
    capture_lex $P1409
    .const 'Sub' $P1402 = "309_1300060177.262" 
    capture_lex $P1402
    .const 'Sub' $P1395 = "307_1300060177.262" 
    capture_lex $P1395
    .const 'Sub' $P1388 = "305_1300060177.262" 
    capture_lex $P1388
    .const 'Sub' $P1381 = "303_1300060177.262" 
    capture_lex $P1381
    .const 'Sub' $P1374 = "301_1300060177.262" 
    capture_lex $P1374
    .const 'Sub' $P1368 = "299_1300060177.262" 
    capture_lex $P1368
    .const 'Sub' $P1361 = "297_1300060177.262" 
    capture_lex $P1361
    .const 'Sub' $P1354 = "295_1300060177.262" 
    capture_lex $P1354
    .const 'Sub' $P1347 = "293_1300060177.262" 
    capture_lex $P1347
    .const 'Sub' $P1340 = "291_1300060177.262" 
    capture_lex $P1340
    .const 'Sub' $P1333 = "289_1300060177.262" 
    capture_lex $P1333
    .const 'Sub' $P1326 = "287_1300060177.262" 
    capture_lex $P1326
    .const 'Sub' $P1319 = "285_1300060177.262" 
    capture_lex $P1319
    .const 'Sub' $P1313 = "283_1300060177.262" 
    capture_lex $P1313
    .const 'Sub' $P1307 = "281_1300060177.262" 
    capture_lex $P1307
    .const 'Sub' $P1302 = "279_1300060177.262" 
    capture_lex $P1302
    .const 'Sub' $P1296 = "277_1300060177.262" 
    capture_lex $P1296
    .const 'Sub' $P1290 = "275_1300060177.262" 
    capture_lex $P1290
    .const 'Sub' $P1285 = "273_1300060177.262" 
    capture_lex $P1285
    .const 'Sub' $P1280 = "271_1300060177.262" 
    capture_lex $P1280
    .const 'Sub' $P1264 = "270_1300060177.262" 
    capture_lex $P1264
    .const 'Sub' $P1255 = "268_1300060177.262" 
    capture_lex $P1255
    .const 'Sub' $P1246 = "266_1300060177.262" 
    capture_lex $P1246
    .const 'Sub' $P1241 = "264_1300060177.262" 
    capture_lex $P1241
    .const 'Sub' $P1236 = "262_1300060177.262" 
    capture_lex $P1236
    .const 'Sub' $P1231 = "260_1300060177.262" 
    capture_lex $P1231
    .const 'Sub' $P1223 = "258_1300060177.262" 
    capture_lex $P1223
    .const 'Sub' $P1215 = "256_1300060177.262" 
    capture_lex $P1215
    .const 'Sub' $P1210 = "254_1300060177.262" 
    capture_lex $P1210
    .const 'Sub' $P1205 = "252_1300060177.262" 
    capture_lex $P1205
    .const 'Sub' $P1200 = "250_1300060177.262" 
    capture_lex $P1200
    .const 'Sub' $P1194 = "248_1300060177.262" 
    capture_lex $P1194
    .const 'Sub' $P1188 = "246_1300060177.262" 
    capture_lex $P1188
    .const 'Sub' $P1182 = "244_1300060177.262" 
    capture_lex $P1182
    .const 'Sub' $P1176 = "242_1300060177.262" 
    capture_lex $P1176
    .const 'Sub' $P1170 = "240_1300060177.262" 
    capture_lex $P1170
    .const 'Sub' $P1165 = "238_1300060177.262" 
    capture_lex $P1165
    .const 'Sub' $P1160 = "236_1300060177.262" 
    capture_lex $P1160
    .const 'Sub' $P1146 = "232_1300060177.262" 
    capture_lex $P1146
    .const 'Sub' $P1138 = "230_1300060177.262" 
    capture_lex $P1138
    .const 'Sub' $P1132 = "228_1300060177.262" 
    capture_lex $P1132
    .const 'Sub' $P1125 = "226_1300060177.262" 
    capture_lex $P1125
    .const 'Sub' $P1119 = "224_1300060177.262" 
    capture_lex $P1119
    .const 'Sub' $P1105 = "221_1300060177.262" 
    capture_lex $P1105
    .const 'Sub' $P1097 = "219_1300060177.262" 
    capture_lex $P1097
    .const 'Sub' $P1089 = "217_1300060177.262" 
    capture_lex $P1089
    .const 'Sub' $P1083 = "215_1300060177.262" 
    capture_lex $P1083
    .const 'Sub' $P1077 = "213_1300060177.262" 
    capture_lex $P1077
    .const 'Sub' $P1061 = "209_1300060177.262" 
    capture_lex $P1061
    .const 'Sub' $P1020 = "207_1300060177.262" 
    capture_lex $P1020
    .const 'Sub' $P1009 = "205_1300060177.262" 
    capture_lex $P1009
    .const 'Sub' $P995 = "201_1300060177.262" 
    capture_lex $P995
    .const 'Sub' $P986 = "199_1300060177.262" 
    capture_lex $P986
    .const 'Sub' $P980 = "197_1300060177.262" 
    capture_lex $P980
    .const 'Sub' $P970 = "195_1300060177.262" 
    capture_lex $P970
    .const 'Sub' $P955 = "193_1300060177.262" 
    capture_lex $P955
    .const 'Sub' $P941 = "190_1300060177.262" 
    capture_lex $P941
    .const 'Sub' $P933 = "188_1300060177.262" 
    capture_lex $P933
    .const 'Sub' $P923 = "186_1300060177.262" 
    capture_lex $P923
    .const 'Sub' $P913 = "184_1300060177.262" 
    capture_lex $P913
    .const 'Sub' $P894 = "179_1300060177.262" 
    capture_lex $P894
    .const 'Sub' $P850 = "176_1300060177.262" 
    capture_lex $P850
    .const 'Sub' $P816 = "174_1300060177.262" 
    capture_lex $P816
    .const 'Sub' $P809 = "172_1300060177.262" 
    capture_lex $P809
    .const 'Sub' $P802 = "170_1300060177.262" 
    capture_lex $P802
    .const 'Sub' $P785 = "166_1300060177.262" 
    capture_lex $P785
    .const 'Sub' $P777 = "164_1300060177.262" 
    capture_lex $P777
    .const 'Sub' $P771 = "162_1300060177.262" 
    capture_lex $P771
    .const 'Sub' $P755 = "160_1300060177.262" 
    capture_lex $P755
    .const 'Sub' $P748 = "158_1300060177.262" 
    capture_lex $P748
    .const 'Sub' $P741 = "156_1300060177.262" 
    capture_lex $P741
    .const 'Sub' $P734 = "154_1300060177.262" 
    capture_lex $P734
    .const 'Sub' $P656 = "149_1300060177.262" 
    capture_lex $P656
    .const 'Sub' $P644 = "147_1300060177.262" 
    capture_lex $P644
    .const 'Sub' $P632 = "145_1300060177.262" 
    capture_lex $P632
    .const 'Sub' $P620 = "143_1300060177.262" 
    capture_lex $P620
    .const 'Sub' $P608 = "141_1300060177.262" 
    capture_lex $P608
    .const 'Sub' $P596 = "139_1300060177.262" 
    capture_lex $P596
    .const 'Sub' $P584 = "137_1300060177.262" 
    capture_lex $P584
    .const 'Sub' $P573 = "133_1300060177.262" 
    capture_lex $P573
    .const 'Sub' $P568 = "131_1300060177.262" 
    capture_lex $P568
    .const 'Sub' $P556 = "129_1300060177.262" 
    capture_lex $P556
    .const 'Sub' $P544 = "127_1300060177.262" 
    capture_lex $P544
    .const 'Sub' $P537 = "125_1300060177.262" 
    capture_lex $P537
    .const 'Sub' $P532 = "123_1300060177.262" 
    capture_lex $P532
    .const 'Sub' $P526 = "121_1300060177.262" 
    capture_lex $P526
    .const 'Sub' $P520 = "119_1300060177.262" 
    capture_lex $P520
    .const 'Sub' $P505 = "115_1300060177.262" 
    capture_lex $P505
    .const 'Sub' $P499 = "113_1300060177.262" 
    capture_lex $P499
    .const 'Sub' $P493 = "111_1300060177.262" 
    capture_lex $P493
    .const 'Sub' $P487 = "109_1300060177.262" 
    capture_lex $P487
    .const 'Sub' $P481 = "107_1300060177.262" 
    capture_lex $P481
    .const 'Sub' $P475 = "105_1300060177.262" 
    capture_lex $P475
    .const 'Sub' $P469 = "103_1300060177.262" 
    capture_lex $P469
    .const 'Sub' $P460 = "101_1300060177.262" 
    capture_lex $P460
    .const 'Sub' $P451 = "99_1300060177.262" 
    capture_lex $P451
    .const 'Sub' $P442 = "97_1300060177.262" 
    capture_lex $P442
    .const 'Sub' $P427 = "93_1300060177.262" 
    capture_lex $P427
    .const 'Sub' $P418 = "91_1300060177.262" 
    capture_lex $P418
    .const 'Sub' $P406 = "87_1300060177.262" 
    capture_lex $P406
    .const 'Sub' $P399 = "85_1300060177.262" 
    capture_lex $P399
    .const 'Sub' $P392 = "83_1300060177.262" 
    capture_lex $P392
    .const 'Sub' $P378 = "79_1300060177.262" 
    capture_lex $P378
    .const 'Sub' $P370 = "77_1300060177.262" 
    capture_lex $P370
    .const 'Sub' $P362 = "75_1300060177.262" 
    capture_lex $P362
    .const 'Sub' $P342 = "73_1300060177.262" 
    capture_lex $P342
    .const 'Sub' $P333 = "71_1300060177.262" 
    capture_lex $P333
    .const 'Sub' $P315 = "68_1300060177.262" 
    capture_lex $P315
    .const 'Sub' $P297 = "66_1300060177.262" 
    capture_lex $P297
    .const 'Sub' $P289 = "64_1300060177.262" 
    capture_lex $P289
    .const 'Sub' $P278 = "60_1300060177.262" 
    capture_lex $P278
    .const 'Sub' $P273 = "58_1300060177.262" 
    capture_lex $P273
    .const 'Sub' $P262 = "54_1300060177.262" 
    capture_lex $P262
    .const 'Sub' $P257 = "52_1300060177.262" 
    capture_lex $P257
    .const 'Sub' $P252 = "50_1300060177.262" 
    capture_lex $P252
    .const 'Sub' $P247 = "48_1300060177.262" 
    capture_lex $P247
    .const 'Sub' $P237 = "46_1300060177.262" 
    capture_lex $P237
    .const 'Sub' $P230 = "44_1300060177.262" 
    capture_lex $P230
    .const 'Sub' $P224 = "42_1300060177.262" 
    capture_lex $P224
    .const 'Sub' $P216 = "40_1300060177.262" 
    capture_lex $P216
    .const 'Sub' $P210 = "38_1300060177.262" 
    capture_lex $P210
    .const 'Sub' $P204 = "36_1300060177.262" 
    capture_lex $P204
    .const 'Sub' $P189 = "33_1300060177.262" 
    capture_lex $P189
    .const 'Sub' $P175 = "31_1300060177.262" 
    capture_lex $P175
    .const 'Sub' $P164 = "29_1300060177.262" 
    capture_lex $P164
    .const 'Sub' $P125 = "26_1300060177.262" 
    capture_lex $P125
    .const 'Sub' $P110 = "23_1300060177.262" 
    capture_lex $P110
    .const 'Sub' $P99 = "21_1300060177.262" 
    capture_lex $P99
    .const 'Sub' $P87 = "19_1300060177.262" 
    capture_lex $P87
    .const 'Sub' $P79 = "17_1300060177.262" 
    capture_lex $P79
    .const 'Sub' $P72 = "15_1300060177.262" 
    capture_lex $P72
    .const 'Sub' $P65 = "13_1300060177.262" 
    capture_lex $P65
    .const 'Sub' $P16 = "12_1300060177.262" 
    capture_lex $P16
    get_global $P15, "$?CLASS"
.annotate 'line', 4
    .const 'Sub' $P1264 = "270_1300060177.262" 
    capture_lex $P1264
    $P1264()
.annotate 'line', 686
    .const 'Sub' $P1647 = "380_1300060177.262" 
    newclosure $P1658, $P1647
.annotate 'line', 3
    .return ($P1658)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post406") :outer("11_1300060177.262")
.annotate 'line', 3
    get_hll_global $P14, ["NQP";"Grammar"], "_block13" 
    .local pmc block
    set block, $P14
    .const 'Sub' $P1660 = "381_1300060177.262" 
    capture_lex $P1660
    $P1660()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1659"  :anon :subid("381_1300060177.262") :outer("11_1300060177.262")
.annotate 'line', 3
    nqp_get_sc_object $P1661, "1300060171.714", 0
    .local pmc type_obj
    set type_obj, $P1661
    set_global "$?CLASS", type_obj
    get_how $P1662, type_obj
    .const 'Sub' $P1663 = "12_1300060177.262" 
    $P1662."add_method"(type_obj, "TOP", $P1663)
    get_how $P1664, type_obj
    .const 'Sub' $P1665 = "13_1300060177.262" 
    $P1664."add_method"(type_obj, "identifier", $P1665)
    get_how $P1666, type_obj
    get_global $P1667, "!PREFIX__identifier"
    $P1666."add_method"(type_obj, "!PREFIX__identifier", $P1667)
    get_how $P1668, type_obj
    .const 'Sub' $P1669 = "15_1300060177.262" 
    $P1668."add_method"(type_obj, "name", $P1669)
    get_how $P1670, type_obj
    get_global $P1671, "!PREFIX__name"
    $P1670."add_method"(type_obj, "!PREFIX__name", $P1671)
    get_how $P1672, type_obj
    .const 'Sub' $P1673 = "17_1300060177.262" 
    $P1672."add_method"(type_obj, "deflongname", $P1673)
    get_how $P1674, type_obj
    get_global $P1675, "!PREFIX__deflongname"
    $P1674."add_method"(type_obj, "!PREFIX__deflongname", $P1675)
    get_how $P1676, type_obj
    .const 'Sub' $P1677 = "19_1300060177.262" 
    $P1676."add_method"(type_obj, "ENDSTMT", $P1677)
    get_how $P1678, type_obj
    get_global $P1679, "!PREFIX__ENDSTMT"
    $P1678."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1679)
    get_how $P1680, type_obj
    .const 'Sub' $P1681 = "21_1300060177.262" 
    $P1680."add_method"(type_obj, "ws", $P1681)
    get_how $P1682, type_obj
    get_global $P1683, "!PREFIX__ws"
    $P1682."add_method"(type_obj, "!PREFIX__ws", $P1683)
    get_how $P1684, type_obj
    .const 'Sub' $P1685 = "23_1300060177.262" 
    $P1684."add_method"(type_obj, "unv", $P1685)
    get_how $P1686, type_obj
    get_global $P1687, "!PREFIX__unv"
    $P1686."add_method"(type_obj, "!PREFIX__unv", $P1687)
    get_how $P1688, type_obj
    .const 'Sub' $P1689 = "26_1300060177.262" 
    $P1688."add_method"(type_obj, "pod_comment", $P1689)
    get_how $P1690, type_obj
    get_global $P1691, "!PREFIX__pod_comment"
    $P1690."add_method"(type_obj, "!PREFIX__pod_comment", $P1691)
    get_how $P1692, type_obj
    .const 'Sub' $P1693 = "29_1300060177.262" 
    $P1692."add_method"(type_obj, "comp_unit", $P1693)
    get_how $P1694, type_obj
    get_global $P1695, "!PREFIX__comp_unit"
    $P1694."add_method"(type_obj, "!PREFIX__comp_unit", $P1695)
    get_how $P1696, type_obj
    .const 'Sub' $P1697 = "31_1300060177.262" 
    $P1696."add_method"(type_obj, "statementlist", $P1697)
    get_how $P1698, type_obj
    get_global $P1699, "!PREFIX__statementlist"
    $P1698."add_method"(type_obj, "!PREFIX__statementlist", $P1699)
    get_how $P1700, type_obj
    .const 'Sub' $P1701 = "33_1300060177.262" 
    $P1700."add_method"(type_obj, "statement", $P1701)
    get_how $P1702, type_obj
    get_global $P1703, "!PREFIX__statement"
    $P1702."add_method"(type_obj, "!PREFIX__statement", $P1703)
    get_how $P1704, type_obj
    .const 'Sub' $P1705 = "36_1300060177.262" 
    $P1704."add_method"(type_obj, "eat_terminator", $P1705)
    get_how $P1706, type_obj
    get_global $P1707, "!PREFIX__eat_terminator"
    $P1706."add_method"(type_obj, "!PREFIX__eat_terminator", $P1707)
    get_how $P1708, type_obj
    .const 'Sub' $P1709 = "38_1300060177.262" 
    $P1708."add_method"(type_obj, "xblock", $P1709)
    get_how $P1710, type_obj
    get_global $P1711, "!PREFIX__xblock"
    $P1710."add_method"(type_obj, "!PREFIX__xblock", $P1711)
    get_how $P1712, type_obj
    .const 'Sub' $P1713 = "40_1300060177.262" 
    $P1712."add_method"(type_obj, "pblock", $P1713)
    get_how $P1714, type_obj
    get_global $P1715, "!PREFIX__pblock"
    $P1714."add_method"(type_obj, "!PREFIX__pblock", $P1715)
    get_how $P1716, type_obj
    .const 'Sub' $P1717 = "42_1300060177.262" 
    $P1716."add_method"(type_obj, "lambda", $P1717)
    get_how $P1718, type_obj
    get_global $P1719, "!PREFIX__lambda"
    $P1718."add_method"(type_obj, "!PREFIX__lambda", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "44_1300060177.262" 
    $P1720."add_method"(type_obj, "block", $P1721)
    get_how $P1722, type_obj
    get_global $P1723, "!PREFIX__block"
    $P1722."add_method"(type_obj, "!PREFIX__block", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "46_1300060177.262" 
    $P1724."add_method"(type_obj, "blockoid", $P1725)
    get_how $P1726, type_obj
    get_global $P1727, "!PREFIX__blockoid"
    $P1726."add_method"(type_obj, "!PREFIX__blockoid", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "48_1300060177.262" 
    $P1728."add_method"(type_obj, "newpad", $P1729)
    get_how $P1730, type_obj
    get_global $P1731, "!PREFIX__newpad"
    $P1730."add_method"(type_obj, "!PREFIX__newpad", $P1731)
    get_how $P1732, type_obj
    .const 'Sub' $P1733 = "50_1300060177.262" 
    $P1732."add_method"(type_obj, "outerctx", $P1733)
    get_how $P1734, type_obj
    get_global $P1735, "!PREFIX__outerctx"
    $P1734."add_method"(type_obj, "!PREFIX__outerctx", $P1735)
    get_how $P1736, type_obj
    .const 'Sub' $P1737 = "52_1300060177.262" 
    $P1736."add_method"(type_obj, "finishpad", $P1737)
    get_how $P1738, type_obj
    get_global $P1739, "!PREFIX__finishpad"
    $P1738."add_method"(type_obj, "!PREFIX__finishpad", $P1739)
    get_how $P1740, type_obj
    .const 'Sub' $P1741 = "54_1300060177.262" 
    $P1740."add_method"(type_obj, "you_are_here", $P1741)
    get_how $P1742, type_obj
    get_global $P1743, "!PREFIX__you_are_here"
    $P1742."add_method"(type_obj, "!PREFIX__you_are_here", $P1743)
    get_how $P1744, type_obj
    .const 'Sub' $P1745 = "56_1300060177.262" 
    $P1744."add_method"(type_obj, "terminator", $P1745)
    get_how $P1746, type_obj
    .const 'Sub' $P1747 = "57_1300060177.262" 
    $P1746."add_method"(type_obj, "!PREFIX__terminator", $P1747)
    get_how $P1748, type_obj
    .const 'Sub' $P1749 = "58_1300060177.262" 
    $P1748."add_method"(type_obj, "terminator:sym<;>", $P1749)
    get_how $P1750, type_obj
    get_global $P1751, "!PREFIX__terminator:sym<;>"
    $P1750."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1751)
    get_how $P1752, type_obj
    .const 'Sub' $P1753 = "60_1300060177.262" 
    $P1752."add_method"(type_obj, "terminator:sym<}>", $P1753)
    get_how $P1754, type_obj
    get_global $P1755, "!PREFIX__terminator:sym<}>"
    $P1754."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1755)
    get_how $P1756, type_obj
    .const 'Sub' $P1757 = "62_1300060177.262" 
    $P1756."add_method"(type_obj, "statement_control", $P1757)
    get_how $P1758, type_obj
    .const 'Sub' $P1759 = "63_1300060177.262" 
    $P1758."add_method"(type_obj, "!PREFIX__statement_control", $P1759)
    get_how $P1760, type_obj
    .const 'Sub' $P1761 = "64_1300060177.262" 
    $P1760."add_method"(type_obj, "statement_control:sym<use>", $P1761)
    get_how $P1762, type_obj
    get_global $P1763, "!PREFIX__statement_control:sym<use>"
    $P1762."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1763)
    get_how $P1764, type_obj
    .const 'Sub' $P1765 = "66_1300060177.262" 
    $P1764."add_method"(type_obj, "statement_control:sym<if>", $P1765)
    get_how $P1766, type_obj
    get_global $P1767, "!PREFIX__statement_control:sym<if>"
    $P1766."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1767)
    get_how $P1768, type_obj
    .const 'Sub' $P1769 = "68_1300060177.262" 
    $P1768."add_method"(type_obj, "statement_control:sym<unless>", $P1769)
    get_how $P1770, type_obj
    get_global $P1771, "!PREFIX__statement_control:sym<unless>"
    $P1770."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1771)
    get_how $P1772, type_obj
    .const 'Sub' $P1773 = "71_1300060177.262" 
    $P1772."add_method"(type_obj, "statement_control:sym<while>", $P1773)
    get_how $P1774, type_obj
    get_global $P1775, "!PREFIX__statement_control:sym<while>"
    $P1774."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "73_1300060177.262" 
    $P1776."add_method"(type_obj, "statement_control:sym<repeat>", $P1777)
    get_how $P1778, type_obj
    get_global $P1779, "!PREFIX__statement_control:sym<repeat>"
    $P1778."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "75_1300060177.262" 
    $P1780."add_method"(type_obj, "statement_control:sym<for>", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__statement_control:sym<for>"
    $P1782."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "77_1300060177.262" 
    $P1784."add_method"(type_obj, "statement_control:sym<CATCH>", $P1785)
    get_how $P1786, type_obj
    get_global $P1787, "!PREFIX__statement_control:sym<CATCH>"
    $P1786."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "79_1300060177.262" 
    $P1788."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1789)
    get_how $P1790, type_obj
    get_global $P1791, "!PREFIX__statement_control:sym<CONTROL>"
    $P1790."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "81_1300060177.262" 
    $P1792."add_method"(type_obj, "statement_prefix", $P1793)
    get_how $P1794, type_obj
    .const 'Sub' $P1795 = "82_1300060177.262" 
    $P1794."add_method"(type_obj, "!PREFIX__statement_prefix", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "83_1300060177.262" 
    $P1796."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1797)
    get_how $P1798, type_obj
    get_global $P1799, "!PREFIX__statement_prefix:sym<INIT>"
    $P1798."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "85_1300060177.262" 
    $P1800."add_method"(type_obj, "statement_prefix:sym<try>", $P1801)
    get_how $P1802, type_obj
    get_global $P1803, "!PREFIX__statement_prefix:sym<try>"
    $P1802."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "87_1300060177.262" 
    $P1804."add_method"(type_obj, "blorst", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__blorst"
    $P1806."add_method"(type_obj, "!PREFIX__blorst", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "89_1300060177.262" 
    $P1808."add_method"(type_obj, "statement_mod_cond", $P1809)
    get_how $P1810, type_obj
    .const 'Sub' $P1811 = "90_1300060177.262" 
    $P1810."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "91_1300060177.262" 
    $P1812."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1813)
    get_how $P1814, type_obj
    get_global $P1815, "!PREFIX__statement_mod_cond:sym<if>"
    $P1814."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "93_1300060177.262" 
    $P1816."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1817)
    get_how $P1818, type_obj
    get_global $P1819, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1818."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "95_1300060177.262" 
    $P1820."add_method"(type_obj, "statement_mod_loop", $P1821)
    get_how $P1822, type_obj
    .const 'Sub' $P1823 = "96_1300060177.262" 
    $P1822."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "97_1300060177.262" 
    $P1824."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__statement_mod_loop:sym<while>"
    $P1826."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "99_1300060177.262" 
    $P1828."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1829)
    get_how $P1830, type_obj
    get_global $P1831, "!PREFIX__statement_mod_loop:sym<until>"
    $P1830."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "101_1300060177.262" 
    $P1832."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1833)
    get_how $P1834, type_obj
    get_global $P1835, "!PREFIX__statement_mod_loop:sym<for>"
    $P1834."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "103_1300060177.262" 
    $P1836."add_method"(type_obj, "term:sym<fatarrow>", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__term:sym<fatarrow>"
    $P1838."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "105_1300060177.262" 
    $P1840."add_method"(type_obj, "term:sym<colonpair>", $P1841)
    get_how $P1842, type_obj
    get_global $P1843, "!PREFIX__term:sym<colonpair>"
    $P1842."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "107_1300060177.262" 
    $P1844."add_method"(type_obj, "term:sym<variable>", $P1845)
    get_how $P1846, type_obj
    get_global $P1847, "!PREFIX__term:sym<variable>"
    $P1846."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "109_1300060177.262" 
    $P1848."add_method"(type_obj, "term:sym<package_declarator>", $P1849)
    get_how $P1850, type_obj
    get_global $P1851, "!PREFIX__term:sym<package_declarator>"
    $P1850."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "111_1300060177.262" 
    $P1852."add_method"(type_obj, "term:sym<scope_declarator>", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__term:sym<scope_declarator>"
    $P1854."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "113_1300060177.262" 
    $P1856."add_method"(type_obj, "term:sym<routine_declarator>", $P1857)
    get_how $P1858, type_obj
    get_global $P1859, "!PREFIX__term:sym<routine_declarator>"
    $P1858."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "115_1300060177.262" 
    $P1860."add_method"(type_obj, "term:sym<multi_declarator>", $P1861)
    get_how $P1862, type_obj
    get_global $P1863, "!PREFIX__term:sym<multi_declarator>"
    $P1862."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "119_1300060177.262" 
    $P1864."add_method"(type_obj, "term:sym<regex_declarator>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__term:sym<regex_declarator>"
    $P1866."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "121_1300060177.262" 
    $P1868."add_method"(type_obj, "term:sym<statement_prefix>", $P1869)
    get_how $P1870, type_obj
    get_global $P1871, "!PREFIX__term:sym<statement_prefix>"
    $P1870."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "123_1300060177.262" 
    $P1872."add_method"(type_obj, "term:sym<lambda>", $P1873)
    get_how $P1874, type_obj
    get_global $P1875, "!PREFIX__term:sym<lambda>"
    $P1874."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "125_1300060177.262" 
    $P1876."add_method"(type_obj, "fatarrow", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__fatarrow"
    $P1878."add_method"(type_obj, "!PREFIX__fatarrow", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "127_1300060177.262" 
    $P1880."add_method"(type_obj, "colonpair", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__colonpair"
    $P1882."add_method"(type_obj, "!PREFIX__colonpair", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "129_1300060177.262" 
    $P1884."add_method"(type_obj, "variable", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__variable"
    $P1886."add_method"(type_obj, "!PREFIX__variable", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "131_1300060177.262" 
    $P1888."add_method"(type_obj, "sigil", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__sigil"
    $P1890."add_method"(type_obj, "!PREFIX__sigil", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "133_1300060177.262" 
    $P1892."add_method"(type_obj, "twigil", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__twigil"
    $P1894."add_method"(type_obj, "!PREFIX__twigil", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "135_1300060177.262" 
    $P1896."add_method"(type_obj, "package_declarator", $P1897)
    get_how $P1898, type_obj
    .const 'Sub' $P1899 = "136_1300060177.262" 
    $P1898."add_method"(type_obj, "!PREFIX__package_declarator", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "137_1300060177.262" 
    $P1900."add_method"(type_obj, "package_declarator:sym<module>", $P1901)
    get_how $P1902, type_obj
    get_global $P1903, "!PREFIX__package_declarator:sym<module>"
    $P1902."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "139_1300060177.262" 
    $P1904."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__package_declarator:sym<knowhow>"
    $P1906."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "141_1300060177.262" 
    $P1908."add_method"(type_obj, "package_declarator:sym<class>", $P1909)
    get_how $P1910, type_obj
    get_global $P1911, "!PREFIX__package_declarator:sym<class>"
    $P1910."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "143_1300060177.262" 
    $P1912."add_method"(type_obj, "package_declarator:sym<grammar>", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__package_declarator:sym<grammar>"
    $P1914."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "145_1300060177.262" 
    $P1916."add_method"(type_obj, "package_declarator:sym<role>", $P1917)
    get_how $P1918, type_obj
    get_global $P1919, "!PREFIX__package_declarator:sym<role>"
    $P1918."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "147_1300060177.262" 
    $P1920."add_method"(type_obj, "package_declarator:sym<native>", $P1921)
    get_how $P1922, type_obj
    get_global $P1923, "!PREFIX__package_declarator:sym<native>"
    $P1922."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "149_1300060177.262" 
    $P1924."add_method"(type_obj, "package_def", $P1925)
    get_how $P1926, type_obj
    get_global $P1927, "!PREFIX__package_def"
    $P1926."add_method"(type_obj, "!PREFIX__package_def", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "152_1300060177.262" 
    $P1928."add_method"(type_obj, "scope_declarator", $P1929)
    get_how $P1930, type_obj
    .const 'Sub' $P1931 = "153_1300060177.262" 
    $P1930."add_method"(type_obj, "!PREFIX__scope_declarator", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "154_1300060177.262" 
    $P1932."add_method"(type_obj, "scope_declarator:sym<my>", $P1933)
    get_how $P1934, type_obj
    get_global $P1935, "!PREFIX__scope_declarator:sym<my>"
    $P1934."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "156_1300060177.262" 
    $P1936."add_method"(type_obj, "scope_declarator:sym<our>", $P1937)
    get_how $P1938, type_obj
    get_global $P1939, "!PREFIX__scope_declarator:sym<our>"
    $P1938."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "158_1300060177.262" 
    $P1940."add_method"(type_obj, "scope_declarator:sym<has>", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__scope_declarator:sym<has>"
    $P1942."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "160_1300060177.262" 
    $P1944."add_method"(type_obj, "scoped", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__scoped"
    $P1946."add_method"(type_obj, "!PREFIX__scoped", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "162_1300060177.262" 
    $P1948."add_method"(type_obj, "typename", $P1949)
    get_how $P1950, type_obj
    get_global $P1951, "!PREFIX__typename"
    $P1950."add_method"(type_obj, "!PREFIX__typename", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "164_1300060177.262" 
    $P1952."add_method"(type_obj, "declarator", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__declarator"
    $P1954."add_method"(type_obj, "!PREFIX__declarator", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "166_1300060177.262" 
    $P1956."add_method"(type_obj, "variable_declarator", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__variable_declarator"
    $P1958."add_method"(type_obj, "!PREFIX__variable_declarator", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "168_1300060177.262" 
    $P1960."add_method"(type_obj, "routine_declarator", $P1961)
    get_how $P1962, type_obj
    .const 'Sub' $P1963 = "169_1300060177.262" 
    $P1962."add_method"(type_obj, "!PREFIX__routine_declarator", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "170_1300060177.262" 
    $P1964."add_method"(type_obj, "routine_declarator:sym<sub>", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__routine_declarator:sym<sub>"
    $P1966."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "172_1300060177.262" 
    $P1968."add_method"(type_obj, "routine_declarator:sym<method>", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__routine_declarator:sym<method>"
    $P1970."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "174_1300060177.262" 
    $P1972."add_method"(type_obj, "routine_def", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__routine_def"
    $P1974."add_method"(type_obj, "!PREFIX__routine_def", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "176_1300060177.262" 
    $P1976."add_method"(type_obj, "method_def", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__method_def"
    $P1978."add_method"(type_obj, "!PREFIX__method_def", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "179_1300060177.262" 
    $P1980."add_method"(type_obj, "onlystar", $P1981)
    get_how $P1982, type_obj
    get_global $P1983, "!PREFIX__onlystar"
    $P1982."add_method"(type_obj, "!PREFIX__onlystar", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "182_1300060177.262" 
    $P1984."add_method"(type_obj, "multi_declarator", $P1985)
    get_how $P1986, type_obj
    .const 'Sub' $P1987 = "183_1300060177.262" 
    $P1986."add_method"(type_obj, "!PREFIX__multi_declarator", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "184_1300060177.262" 
    $P1988."add_method"(type_obj, "multi_declarator:sym<multi>", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__multi_declarator:sym<multi>"
    $P1990."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "186_1300060177.262" 
    $P1992."add_method"(type_obj, "multi_declarator:sym<proto>", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__multi_declarator:sym<proto>"
    $P1994."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "188_1300060177.262" 
    $P1996."add_method"(type_obj, "multi_declarator:sym<null>", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__multi_declarator:sym<null>"
    $P1998."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "190_1300060177.262" 
    $P2000."add_method"(type_obj, "signature", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__signature"
    $P2002."add_method"(type_obj, "!PREFIX__signature", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "193_1300060177.262" 
    $P2004."add_method"(type_obj, "parameter", $P2005)
    get_how $P2006, type_obj
    get_global $P2007, "!PREFIX__parameter"
    $P2006."add_method"(type_obj, "!PREFIX__parameter", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "195_1300060177.262" 
    $P2008."add_method"(type_obj, "param_var", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__param_var"
    $P2010."add_method"(type_obj, "!PREFIX__param_var", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "197_1300060177.262" 
    $P2012."add_method"(type_obj, "named_param", $P2013)
    get_how $P2014, type_obj
    get_global $P2015, "!PREFIX__named_param"
    $P2014."add_method"(type_obj, "!PREFIX__named_param", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "199_1300060177.262" 
    $P2016."add_method"(type_obj, "default_value", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__default_value"
    $P2018."add_method"(type_obj, "!PREFIX__default_value", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "201_1300060177.262" 
    $P2020."add_method"(type_obj, "trait", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__trait"
    $P2022."add_method"(type_obj, "!PREFIX__trait", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "203_1300060177.262" 
    $P2024."add_method"(type_obj, "trait_mod", $P2025)
    get_how $P2026, type_obj
    .const 'Sub' $P2027 = "204_1300060177.262" 
    $P2026."add_method"(type_obj, "!PREFIX__trait_mod", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "205_1300060177.262" 
    $P2028."add_method"(type_obj, "trait_mod:sym<is>", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__trait_mod:sym<is>"
    $P2030."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "207_1300060177.262" 
    $P2032."add_method"(type_obj, "regex_declarator", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__regex_declarator"
    $P2034."add_method"(type_obj, "!PREFIX__regex_declarator", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "209_1300060177.262" 
    $P2036."add_method"(type_obj, "dotty", $P2037)
    get_how $P2038, type_obj
    get_global $P2039, "!PREFIX__dotty"
    $P2038."add_method"(type_obj, "!PREFIX__dotty", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "211_1300060177.262" 
    $P2040."add_method"(type_obj, "term", $P2041)
    get_how $P2042, type_obj
    .const 'Sub' $P2043 = "212_1300060177.262" 
    $P2042."add_method"(type_obj, "!PREFIX__term", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "213_1300060177.262" 
    $P2044."add_method"(type_obj, "term:sym<self>", $P2045)
    get_how $P2046, type_obj
    get_global $P2047, "!PREFIX__term:sym<self>"
    $P2046."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "215_1300060177.262" 
    $P2048."add_method"(type_obj, "term:sym<identifier>", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__term:sym<identifier>"
    $P2050."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "217_1300060177.262" 
    $P2052."add_method"(type_obj, "term:sym<name>", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__term:sym<name>"
    $P2054."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "219_1300060177.262" 
    $P2056."add_method"(type_obj, "term:sym<pir::op>", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__term:sym<pir::op>"
    $P2058."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "221_1300060177.262" 
    $P2060."add_method"(type_obj, "term:sym<onlystar>", $P2061)
    get_how $P2062, type_obj
    get_global $P2063, "!PREFIX__term:sym<onlystar>"
    $P2062."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "224_1300060177.262" 
    $P2064."add_method"(type_obj, "args", $P2065)
    get_how $P2066, type_obj
    get_global $P2067, "!PREFIX__args"
    $P2066."add_method"(type_obj, "!PREFIX__args", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "226_1300060177.262" 
    $P2068."add_method"(type_obj, "arglist", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__arglist"
    $P2070."add_method"(type_obj, "!PREFIX__arglist", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "228_1300060177.262" 
    $P2072."add_method"(type_obj, "term:sym<value>", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__term:sym<value>"
    $P2074."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "230_1300060177.262" 
    $P2076."add_method"(type_obj, "value", $P2077)
    get_how $P2078, type_obj
    get_global $P2079, "!PREFIX__value"
    $P2078."add_method"(type_obj, "!PREFIX__value", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "232_1300060177.262" 
    $P2080."add_method"(type_obj, "number", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__number"
    $P2082."add_method"(type_obj, "!PREFIX__number", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "234_1300060177.262" 
    $P2084."add_method"(type_obj, "quote", $P2085)
    get_how $P2086, type_obj
    .const 'Sub' $P2087 = "235_1300060177.262" 
    $P2086."add_method"(type_obj, "!PREFIX__quote", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "236_1300060177.262" 
    $P2088."add_method"(type_obj, "quote:sym<apos>", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__quote:sym<apos>"
    $P2090."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "238_1300060177.262" 
    $P2092."add_method"(type_obj, "quote:sym<dblq>", $P2093)
    get_how $P2094, type_obj
    get_global $P2095, "!PREFIX__quote:sym<dblq>"
    $P2094."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "240_1300060177.262" 
    $P2096."add_method"(type_obj, "quote:sym<q>", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__quote:sym<q>"
    $P2098."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "242_1300060177.262" 
    $P2100."add_method"(type_obj, "quote:sym<qq>", $P2101)
    get_how $P2102, type_obj
    get_global $P2103, "!PREFIX__quote:sym<qq>"
    $P2102."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "244_1300060177.262" 
    $P2104."add_method"(type_obj, "quote:sym<Q>", $P2105)
    get_how $P2106, type_obj
    get_global $P2107, "!PREFIX__quote:sym<Q>"
    $P2106."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "246_1300060177.262" 
    $P2108."add_method"(type_obj, "quote:sym<Q:PIR>", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__quote:sym<Q:PIR>"
    $P2110."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "248_1300060177.262" 
    $P2112."add_method"(type_obj, "quote:sym</ />", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__quote:sym</ />"
    $P2114."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "250_1300060177.262" 
    $P2116."add_method"(type_obj, "quote_escape:sym<$>", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__quote_escape:sym<$>"
    $P2118."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "252_1300060177.262" 
    $P2120."add_method"(type_obj, "quote_escape:sym<{ }>", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__quote_escape:sym<{ }>"
    $P2122."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "254_1300060177.262" 
    $P2124."add_method"(type_obj, "quote_escape:sym<esc>", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__quote_escape:sym<esc>"
    $P2126."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "256_1300060177.262" 
    $P2128."add_method"(type_obj, "circumfix:sym<( )>", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__circumfix:sym<( )>"
    $P2130."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "258_1300060177.262" 
    $P2132."add_method"(type_obj, "circumfix:sym<[ ]>", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__circumfix:sym<[ ]>"
    $P2134."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "260_1300060177.262" 
    $P2136."add_method"(type_obj, "circumfix:sym<ang>", $P2137)
    get_how $P2138, type_obj
    get_global $P2139, "!PREFIX__circumfix:sym<ang>"
    $P2138."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "262_1300060177.262" 
    $P2140."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2142."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "264_1300060177.262" 
    $P2144."add_method"(type_obj, "circumfix:sym<{ }>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__circumfix:sym<{ }>"
    $P2146."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "266_1300060177.262" 
    $P2148."add_method"(type_obj, "circumfix:sym<sigil>", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__circumfix:sym<sigil>"
    $P2150."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "268_1300060177.262" 
    $P2152."add_method"(type_obj, "semilist", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__semilist"
    $P2154."add_method"(type_obj, "!PREFIX__semilist", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "271_1300060177.262" 
    $P2156."add_method"(type_obj, "infixish", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__infixish"
    $P2158."add_method"(type_obj, "!PREFIX__infixish", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "273_1300060177.262" 
    $P2160."add_method"(type_obj, "infixstopper", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, "!PREFIX__infixstopper"
    $P2162."add_method"(type_obj, "!PREFIX__infixstopper", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "275_1300060177.262" 
    $P2164."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2166."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "277_1300060177.262" 
    $P2168."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__postcircumfix:sym<{ }>"
    $P2170."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "279_1300060177.262" 
    $P2172."add_method"(type_obj, "postcircumfix:sym<ang>", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__postcircumfix:sym<ang>"
    $P2174."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "281_1300060177.262" 
    $P2176."add_method"(type_obj, "postcircumfix:sym<( )>", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, "!PREFIX__postcircumfix:sym<( )>"
    $P2178."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "283_1300060177.262" 
    $P2180."add_method"(type_obj, "postfix:sym<.>", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__postfix:sym<.>"
    $P2182."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "285_1300060177.262" 
    $P2184."add_method"(type_obj, "prefix:sym<++>", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__prefix:sym<++>"
    $P2186."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "287_1300060177.262" 
    $P2188."add_method"(type_obj, "prefix:sym<-->", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__prefix:sym<-->"
    $P2190."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "289_1300060177.262" 
    $P2192."add_method"(type_obj, "postfix:sym<++>", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, "!PREFIX__postfix:sym<++>"
    $P2194."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "291_1300060177.262" 
    $P2196."add_method"(type_obj, "postfix:sym<-->", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__postfix:sym<-->"
    $P2198."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "293_1300060177.262" 
    $P2200."add_method"(type_obj, "infix:sym<**>", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__infix:sym<**>"
    $P2202."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "295_1300060177.262" 
    $P2204."add_method"(type_obj, "prefix:sym<+>", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__prefix:sym<+>"
    $P2206."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "297_1300060177.262" 
    $P2208."add_method"(type_obj, "prefix:sym<~>", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__prefix:sym<~>"
    $P2210."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "299_1300060177.262" 
    $P2212."add_method"(type_obj, "prefix:sym<->", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__prefix:sym<->"
    $P2214."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "301_1300060177.262" 
    $P2216."add_method"(type_obj, "prefix:sym<?>", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__prefix:sym<?>"
    $P2218."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "303_1300060177.262" 
    $P2220."add_method"(type_obj, "prefix:sym<!>", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__prefix:sym<!>"
    $P2222."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "305_1300060177.262" 
    $P2224."add_method"(type_obj, "prefix:sym<|>", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__prefix:sym<|>"
    $P2226."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "307_1300060177.262" 
    $P2228."add_method"(type_obj, "infix:sym<*>", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__infix:sym<*>"
    $P2230."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "309_1300060177.262" 
    $P2232."add_method"(type_obj, "infix:sym</>", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__infix:sym</>"
    $P2234."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "311_1300060177.262" 
    $P2236."add_method"(type_obj, "infix:sym<%>", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__infix:sym<%>"
    $P2238."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "313_1300060177.262" 
    $P2240."add_method"(type_obj, "infix:sym<+&>", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__infix:sym<+&>"
    $P2242."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "315_1300060177.262" 
    $P2244."add_method"(type_obj, "infix:sym<+>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__infix:sym<+>"
    $P2246."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "317_1300060177.262" 
    $P2248."add_method"(type_obj, "infix:sym<->", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__infix:sym<->"
    $P2250."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "319_1300060177.262" 
    $P2252."add_method"(type_obj, "infix:sym<+|>", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__infix:sym<+|>"
    $P2254."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "321_1300060177.262" 
    $P2256."add_method"(type_obj, "infix:sym<+^>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__infix:sym<+^>"
    $P2258."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "323_1300060177.262" 
    $P2260."add_method"(type_obj, "infix:sym<~>", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__infix:sym<~>"
    $P2262."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "325_1300060177.262" 
    $P2264."add_method"(type_obj, "infix:sym<==>", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__infix:sym<==>"
    $P2266."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "327_1300060177.262" 
    $P2268."add_method"(type_obj, "infix:sym<!=>", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__infix:sym<!=>"
    $P2270."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "329_1300060177.262" 
    $P2272."add_method"(type_obj, "infix:sym<<=>", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__infix:sym<<=>"
    $P2274."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "331_1300060177.262" 
    $P2276."add_method"(type_obj, "infix:sym<>=>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__infix:sym<>=>"
    $P2278."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "333_1300060177.262" 
    $P2280."add_method"(type_obj, "infix:sym<<>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__infix:sym<<>"
    $P2282."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "335_1300060177.262" 
    $P2284."add_method"(type_obj, "infix:sym<>>", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__infix:sym<>>"
    $P2286."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "337_1300060177.262" 
    $P2288."add_method"(type_obj, "infix:sym<eq>", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__infix:sym<eq>"
    $P2290."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "339_1300060177.262" 
    $P2292."add_method"(type_obj, "infix:sym<ne>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__infix:sym<ne>"
    $P2294."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "341_1300060177.262" 
    $P2296."add_method"(type_obj, "infix:sym<le>", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__infix:sym<le>"
    $P2298."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "343_1300060177.262" 
    $P2300."add_method"(type_obj, "infix:sym<ge>", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__infix:sym<ge>"
    $P2302."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "345_1300060177.262" 
    $P2304."add_method"(type_obj, "infix:sym<lt>", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__infix:sym<lt>"
    $P2306."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "347_1300060177.262" 
    $P2308."add_method"(type_obj, "infix:sym<gt>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__infix:sym<gt>"
    $P2310."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "349_1300060177.262" 
    $P2312."add_method"(type_obj, "infix:sym<=:=>", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__infix:sym<=:=>"
    $P2314."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "351_1300060177.262" 
    $P2316."add_method"(type_obj, "infix:sym<~~>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__infix:sym<~~>"
    $P2318."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "353_1300060177.262" 
    $P2320."add_method"(type_obj, "infix:sym<&&>", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__infix:sym<&&>"
    $P2322."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "355_1300060177.262" 
    $P2324."add_method"(type_obj, "infix:sym<||>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__infix:sym<||>"
    $P2326."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "357_1300060177.262" 
    $P2328."add_method"(type_obj, "infix:sym<//>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__infix:sym<//>"
    $P2330."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "359_1300060177.262" 
    $P2332."add_method"(type_obj, "infix:sym<?? !!>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__infix:sym<?? !!>"
    $P2334."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "361_1300060177.262" 
    $P2336."add_method"(type_obj, "infix:sym<=>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__infix:sym<=>"
    $P2338."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "363_1300060177.262" 
    $P2340."add_method"(type_obj, "infix:sym<:=>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__infix:sym<:=>"
    $P2342."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "365_1300060177.262" 
    $P2344."add_method"(type_obj, "infix:sym<::=>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<::=>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "367_1300060177.262" 
    $P2348."add_method"(type_obj, "infix:sym<,>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym<,>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "369_1300060177.262" 
    $P2352."add_method"(type_obj, "prefix:sym<return>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__prefix:sym<return>"
    $P2354."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "372_1300060177.262" 
    $P2356."add_method"(type_obj, "prefix:sym<make>", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__prefix:sym<make>"
    $P2358."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "374_1300060177.262" 
    $P2360."add_method"(type_obj, "term:sym<last>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__term:sym<last>"
    $P2362."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "376_1300060177.262" 
    $P2364."add_method"(type_obj, "term:sym<next>", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__term:sym<next>"
    $P2366."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "378_1300060177.262" 
    $P2368."add_method"(type_obj, "term:sym<redo>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__term:sym<redo>"
    $P2370."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "380_1300060177.262" 
    $P2372."add_method"(type_obj, "smartmatch", $P2373)
    get_how $P2374, type_obj
    get_hll_global $P2375, ["HLL"], "Grammar"
    $P2374."add_parent"(type_obj, $P2375)
    get_how $P2376, type_obj
    $P2377 = $P2376."compose"(type_obj)
    .return ($P2377)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1300060177.262") :outer("11_1300060177.262")
    .param pmc param_17
.annotate 'line', 4
    .lex "self", param_17
.annotate 'line', 6
    $P18 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P18
.annotate 'line', 13
    $P19 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P19
.annotate 'line', 22
    new $P20, "Undef"
    .lex "$*DEFAULT-METAATTR", $P20
.annotate 'line', 23
    $P21 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P21
.annotate 'line', 29
    new $P22, "Undef"
    .lex "$*SC", $P22
.annotate 'line', 33
    new $P23, "Undef"
    .lex "$*SCOPE", $P23
.annotate 'line', 34
    new $P24, "Undef"
    .lex "$*MULTINESS", $P24
.annotate 'line', 35
    new $P25, "Undef"
    .lex "$*INVOCANT_OK", $P25
.annotate 'line', 36
    new $P26, "Undef"
    .lex "$*RETURN_USED", $P26
.annotate 'line', 37
    new $P27, "Undef"
    .lex "$*PACKAGE-SETUP", $P27
.annotate 'line', 4
    find_lex $P28, "%*LANG"
    unless_null $P28, vivify_407
    get_hll_global $P28, "%LANG"
    unless_null $P28, vivify_408
    die "Contextual %*LANG not found"
  vivify_408:
  vivify_407:
.annotate 'line', 7
    get_hll_global $P29, ["NQP"], "Regex"
    find_lex $P30, "%*LANG"
    unless_null $P30, vivify_409
    get_hll_global $P30, "%LANG"
    unless_null $P30, vivify_410
    die "Contextual %*LANG not found"
  vivify_410:
    store_lex "%*LANG", $P30
  vivify_409:
    set $P30["Regex"], $P29
.annotate 'line', 8
    get_hll_global $P31, ["NQP"], "RegexActions"
    find_lex $P32, "%*LANG"
    unless_null $P32, vivify_411
    get_hll_global $P32, "%LANG"
    unless_null $P32, vivify_412
    die "Contextual %*LANG not found"
  vivify_412:
    store_lex "%*LANG", $P32
  vivify_411:
    set $P32["Regex-actions"], $P31
.annotate 'line', 9
    get_hll_global $P33, ["NQP"], "Grammar"
    find_lex $P34, "%*LANG"
    unless_null $P34, vivify_413
    get_hll_global $P34, "%LANG"
    unless_null $P34, vivify_414
    die "Contextual %*LANG not found"
  vivify_414:
    store_lex "%*LANG", $P34
  vivify_413:
    set $P34["MAIN"], $P33
.annotate 'line', 10
    get_hll_global $P35, ["NQP"], "Actions"
    find_lex $P36, "%*LANG"
    unless_null $P36, vivify_415
    get_hll_global $P36, "%LANG"
    unless_null $P36, vivify_416
    die "Contextual %*LANG not found"
  vivify_416:
    store_lex "%*LANG", $P36
  vivify_415:
    set $P36["MAIN-actions"], $P35
    find_lex $P37, "%*HOW"
    unless_null $P37, vivify_417
    get_hll_global $P37, "%HOW"
    unless_null $P37, vivify_418
    die "Contextual %*HOW not found"
  vivify_418:
  vivify_417:
.annotate 'line', 14
    get_hll_global $P38, "KnowHOW"
    find_lex $P39, "%*HOW"
    unless_null $P39, vivify_419
    get_hll_global $P39, "%HOW"
    unless_null $P39, vivify_420
    die "Contextual %*HOW not found"
  vivify_420:
    store_lex "%*HOW", $P39
  vivify_419:
    set $P39["knowhow"], $P38
.annotate 'line', 15
    get_hll_global $P40, "NQPModuleHOW"
    find_lex $P41, "%*HOW"
    unless_null $P41, vivify_421
    get_hll_global $P41, "%HOW"
    unless_null $P41, vivify_422
    die "Contextual %*HOW not found"
  vivify_422:
    store_lex "%*HOW", $P41
  vivify_421:
    set $P41["module"], $P40
.annotate 'line', 16
    get_hll_global $P42, "NQPClassHOW"
    find_lex $P43, "%*HOW"
    unless_null $P43, vivify_423
    get_hll_global $P43, "%HOW"
    unless_null $P43, vivify_424
    die "Contextual %*HOW not found"
  vivify_424:
    store_lex "%*HOW", $P43
  vivify_423:
    set $P43["class"], $P42
.annotate 'line', 17
    get_hll_global $P44, "NQPClassHOW"
    find_lex $P45, "%*HOW"
    unless_null $P45, vivify_425
    get_hll_global $P45, "%HOW"
    unless_null $P45, vivify_426
    die "Contextual %*HOW not found"
  vivify_426:
    store_lex "%*HOW", $P45
  vivify_425:
    set $P45["grammar"], $P44
.annotate 'line', 18
    get_hll_global $P46, "NQPParametricRoleHOW"
    find_lex $P47, "%*HOW"
    unless_null $P47, vivify_427
    get_hll_global $P47, "%HOW"
    unless_null $P47, vivify_428
    die "Contextual %*HOW not found"
  vivify_428:
    store_lex "%*HOW", $P47
  vivify_427:
    set $P47["role"], $P46
.annotate 'line', 19
    get_hll_global $P48, "NQPNativeHOW"
    find_lex $P49, "%*HOW"
    unless_null $P49, vivify_429
    get_hll_global $P49, "%HOW"
    unless_null $P49, vivify_430
    die "Contextual %*HOW not found"
  vivify_430:
    store_lex "%*HOW", $P49
  vivify_429:
    set $P49["native"], $P48
.annotate 'line', 22
    new $P50, "String"
    assign $P50, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P50
    find_lex $P51, "%*HOW-METAATTR"
    unless_null $P51, vivify_431
    get_hll_global $P51, "%HOW-METAATTR"
    unless_null $P51, vivify_432
    die "Contextual %*HOW-METAATTR not found"
  vivify_432:
  vivify_431:
.annotate 'line', 24
    new $P52, "String"
    assign $P52, "KnowHOWAttribute"
    find_lex $P53, "%*HOW-METAATTR"
    unless_null $P53, vivify_433
    get_hll_global $P53, "%HOW-METAATTR"
    unless_null $P53, vivify_434
    die "Contextual %*HOW-METAATTR not found"
  vivify_434:
    store_lex "%*HOW-METAATTR", $P53
  vivify_433:
    set $P53["knowhow"], $P52
.annotate 'line', 29
    get_hll_global $P54, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 31
    time $N55
    set $S56, $N55
    $P57 = $P54."new"($S56 :named("handle"))
.annotate 'line', 29
    store_lex "$*SC", $P57
.annotate 'line', 33
    new $P58, "String"
    assign $P58, ""
    store_lex "$*SCOPE", $P58
.annotate 'line', 34
    new $P59, "String"
    assign $P59, ""
    store_lex "$*MULTINESS", $P59
.annotate 'line', 35
    new $P60, "Integer"
    assign $P60, 0
    store_lex "$*INVOCANT_OK", $P60
.annotate 'line', 36
    new $P61, "Integer"
    assign $P61, 0
    store_lex "$*RETURN_USED", $P61
    find_lex $P62, "$*PACKAGE-SETUP"
    unless_null $P62, vivify_435
    get_hll_global $P62, "$PACKAGE-SETUP"
    unless_null $P62, vivify_436
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_436:
  vivify_435:
.annotate 'line', 38
    find_lex $P63, "self"
    $P64 = $P63."comp_unit"()
.annotate 'line', 4
    .return ($P64)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx66_tgt
    .local int rx66_pos
    .local int rx66_off
    .local int rx66_eos
    .local int rx66_rep
    .local pmc rx66_cur
    .local pmc rx66_debug
    (rx66_cur, rx66_pos, rx66_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx66_cur
    .local pmc match
    .lex "$/", match
    length rx66_eos, rx66_tgt
    gt rx66_pos, rx66_eos, rx66_done
    set rx66_off, 0
    lt rx66_pos, 2, rx66_start
    sub rx66_off, rx66_pos, 1
    substr rx66_tgt, rx66_tgt, rx66_off
  rx66_start:
    eq $I10, 1, rx66_restart
    if_null rx66_debug, debug_437
    rx66_cur."!cursor_debug"("START", "identifier")
  debug_437:
    $I10 = self.'from'()
    ne $I10, -1, rxscan70_done
    goto rxscan70_scan
  rxscan70_loop:
    (rx66_pos) = rx66_cur."from"()
    inc rx66_pos
    rx66_cur."!cursor_from"(rx66_pos)
    ge rx66_pos, rx66_eos, rxscan70_done
  rxscan70_scan:
    set_addr $I10, rxscan70_loop
    rx66_cur."!mark_push"(0, rx66_pos, $I10)
  rxscan70_done:
.annotate 'line', 43
  # rx subrule "ident" subtype=method negate=
    rx66_cur."!cursor_pos"(rx66_pos)
    $P10 = rx66_cur."ident"()
    unless $P10, rx66_fail
    rx66_pos = $P10."pos"()
  # rx rxquantr71 ** 0..*
    set_addr $I10, rxquantr71_done
    rx66_cur."!mark_push"(0, rx66_pos, $I10)
  rxquantr71_loop:
  # rx enumcharlist negate=0 
    ge rx66_pos, rx66_eos, rx66_fail
    sub $I10, rx66_pos, rx66_off
    substr $S10, rx66_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx66_fail
    inc rx66_pos
  # rx subrule "ident" subtype=method negate=
    rx66_cur."!cursor_pos"(rx66_pos)
    $P10 = rx66_cur."ident"()
    unless $P10, rx66_fail
    rx66_pos = $P10."pos"()
    set_addr $I10, rxquantr71_done
    (rx66_rep) = rx66_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr71_done
    rx66_cur."!mark_push"(rx66_rep, rx66_pos, $I10)
    goto rxquantr71_loop
  rxquantr71_done:
  # rx pass
    rx66_cur."!cursor_pass"(rx66_pos, "identifier")
    if_null rx66_debug, debug_438
    rx66_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx66_pos)
  debug_438:
    .return (rx66_cur)
  rx66_restart:
.annotate 'line', 4
    if_null rx66_debug, debug_439
    rx66_cur."!cursor_debug"("NEXT", "identifier")
  debug_439:
  rx66_fail:
    (rx66_rep, rx66_pos, $I10, $P10) = rx66_cur."!mark_fail"(0)
    lt rx66_pos, -1, rx66_done
    eq rx66_pos, -1, rx66_fail
    jump $I10
  rx66_done:
    rx66_cur."!cursor_fail"()
    if_null rx66_debug, debug_440
    rx66_cur."!cursor_debug"("FAIL", "identifier")
  debug_440:
    .return (rx66_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1300060177.262") :method
.annotate 'line', 4
    $P68 = self."!PREFIX__!subrule"("ident", "")
    new $P69, "ResizablePMCArray"
    push $P69, $P68
    .return ($P69)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx73_tgt
    .local int rx73_pos
    .local int rx73_off
    .local int rx73_eos
    .local int rx73_rep
    .local pmc rx73_cur
    .local pmc rx73_debug
    (rx73_cur, rx73_pos, rx73_tgt, $I10) = self."!cursor_start"()
    rx73_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx73_cur
    .local pmc match
    .lex "$/", match
    length rx73_eos, rx73_tgt
    gt rx73_pos, rx73_eos, rx73_done
    set rx73_off, 0
    lt rx73_pos, 2, rx73_start
    sub rx73_off, rx73_pos, 1
    substr rx73_tgt, rx73_tgt, rx73_off
  rx73_start:
    eq $I10, 1, rx73_restart
    if_null rx73_debug, debug_441
    rx73_cur."!cursor_debug"("START", "name")
  debug_441:
    $I10 = self.'from'()
    ne $I10, -1, rxscan76_done
    goto rxscan76_scan
  rxscan76_loop:
    (rx73_pos) = rx73_cur."from"()
    inc rx73_pos
    rx73_cur."!cursor_from"(rx73_pos)
    ge rx73_pos, rx73_eos, rxscan76_done
  rxscan76_scan:
    set_addr $I10, rxscan76_loop
    rx73_cur."!mark_push"(0, rx73_pos, $I10)
  rxscan76_done:
.annotate 'line', 45
  # rx rxquantr77 ** 1..*
    set_addr $I10, rxquantr77_done
    rx73_cur."!mark_push"(0, -1, $I10)
  rxquantr77_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx73_cur."!cursor_pos"(rx73_pos)
    $P10 = rx73_cur."identifier"()
    unless $P10, rx73_fail
    goto rxsubrule78_pass
  rxsubrule78_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx73_fail
  rxsubrule78_pass:
    set_addr $I10, rxsubrule78_back
    rx73_cur."!mark_push"(0, rx73_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx73_pos = $P10."pos"()
    set_addr $I10, rxquantr77_done
    (rx73_rep) = rx73_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr77_done
    rx73_cur."!mark_push"(rx73_rep, rx73_pos, $I10)
  # rx literal  "::"
    add $I11, rx73_pos, 2
    gt $I11, rx73_eos, rx73_fail
    sub $I11, rx73_pos, rx73_off
    substr $S10, rx73_tgt, $I11, 2
    ne $S10, "::", rx73_fail
    add rx73_pos, 2
    goto rxquantr77_loop
  rxquantr77_done:
  # rx pass
    rx73_cur."!cursor_pass"(rx73_pos, "name")
    if_null rx73_debug, debug_442
    rx73_cur."!cursor_debug"("PASS", "name", " at pos=", rx73_pos)
  debug_442:
    .return (rx73_cur)
  rx73_restart:
.annotate 'line', 4
    if_null rx73_debug, debug_443
    rx73_cur."!cursor_debug"("NEXT", "name")
  debug_443:
  rx73_fail:
    (rx73_rep, rx73_pos, $I10, $P10) = rx73_cur."!mark_fail"(0)
    lt rx73_pos, -1, rx73_done
    eq rx73_pos, -1, rx73_fail
    jump $I10
  rx73_done:
    rx73_cur."!cursor_fail"()
    if_null rx73_debug, debug_444
    rx73_cur."!cursor_debug"("FAIL", "name")
  debug_444:
    .return (rx73_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1300060177.262") :method
.annotate 'line', 4
    new $P75, "ResizablePMCArray"
    push $P75, ""
    .return ($P75)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx80_tgt
    .local int rx80_pos
    .local int rx80_off
    .local int rx80_eos
    .local int rx80_rep
    .local pmc rx80_cur
    .local pmc rx80_debug
    (rx80_cur, rx80_pos, rx80_tgt, $I10) = self."!cursor_start"()
    rx80_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx80_cur
    .local pmc match
    .lex "$/", match
    length rx80_eos, rx80_tgt
    gt rx80_pos, rx80_eos, rx80_done
    set rx80_off, 0
    lt rx80_pos, 2, rx80_start
    sub rx80_off, rx80_pos, 1
    substr rx80_tgt, rx80_tgt, rx80_off
  rx80_start:
    eq $I10, 1, rx80_restart
    if_null rx80_debug, debug_445
    rx80_cur."!cursor_debug"("START", "deflongname")
  debug_445:
    $I10 = self.'from'()
    ne $I10, -1, rxscan84_done
    goto rxscan84_scan
  rxscan84_loop:
    (rx80_pos) = rx80_cur."from"()
    inc rx80_pos
    rx80_cur."!cursor_from"(rx80_pos)
    ge rx80_pos, rx80_eos, rxscan84_done
  rxscan84_scan:
    set_addr $I10, rxscan84_loop
    rx80_cur."!mark_push"(0, rx80_pos, $I10)
  rxscan84_done:
.annotate 'line', 48
  # rx subrule "identifier" subtype=capture negate=
    rx80_cur."!cursor_pos"(rx80_pos)
    $P10 = rx80_cur."identifier"()
    unless $P10, rx80_fail
    rx80_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx80_pos = $P10."pos"()
  # rx rxquantr85 ** 0..1
    set_addr $I10, rxquantr85_done
    rx80_cur."!mark_push"(0, rx80_pos, $I10)
  rxquantr85_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx80_cur."!cursor_pos"(rx80_pos)
    $P10 = rx80_cur."colonpair"()
    unless $P10, rx80_fail
    goto rxsubrule86_pass
  rxsubrule86_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx80_fail
  rxsubrule86_pass:
    set_addr $I10, rxsubrule86_back
    rx80_cur."!mark_push"(0, rx80_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx80_pos = $P10."pos"()
    set_addr $I10, rxquantr85_done
    (rx80_rep) = rx80_cur."!mark_commit"($I10)
  rxquantr85_done:
.annotate 'line', 47
  # rx pass
    rx80_cur."!cursor_pass"(rx80_pos, "deflongname")
    if_null rx80_debug, debug_446
    rx80_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx80_pos)
  debug_446:
    .return (rx80_cur)
  rx80_restart:
.annotate 'line', 4
    if_null rx80_debug, debug_447
    rx80_cur."!cursor_debug"("NEXT", "deflongname")
  debug_447:
  rx80_fail:
    (rx80_rep, rx80_pos, $I10, $P10) = rx80_cur."!mark_fail"(0)
    lt rx80_pos, -1, rx80_done
    eq rx80_pos, -1, rx80_fail
    jump $I10
  rx80_done:
    rx80_cur."!cursor_fail"()
    if_null rx80_debug, debug_448
    rx80_cur."!cursor_debug"("FAIL", "deflongname")
  debug_448:
    .return (rx80_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1300060177.262") :method
.annotate 'line', 4
    $P82 = self."!PREFIX__!subrule"("identifier", "")
    new $P83, "ResizablePMCArray"
    push $P83, $P82
    .return ($P83)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx88_tgt
    .local int rx88_pos
    .local int rx88_off
    .local int rx88_eos
    .local int rx88_rep
    .local pmc rx88_cur
    .local pmc rx88_debug
    (rx88_cur, rx88_pos, rx88_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx88_cur
    .local pmc match
    .lex "$/", match
    length rx88_eos, rx88_tgt
    gt rx88_pos, rx88_eos, rx88_done
    set rx88_off, 0
    lt rx88_pos, 2, rx88_start
    sub rx88_off, rx88_pos, 1
    substr rx88_tgt, rx88_tgt, rx88_off
  rx88_start:
    eq $I10, 1, rx88_restart
    if_null rx88_debug, debug_449
    rx88_cur."!cursor_debug"("START", "ENDSTMT")
  debug_449:
    $I10 = self.'from'()
    ne $I10, -1, rxscan91_done
    goto rxscan91_scan
  rxscan91_loop:
    (rx88_pos) = rx88_cur."from"()
    inc rx88_pos
    rx88_cur."!cursor_from"(rx88_pos)
    ge rx88_pos, rx88_eos, rxscan91_done
  rxscan91_scan:
    set_addr $I10, rxscan91_loop
    rx88_cur."!mark_push"(0, rx88_pos, $I10)
  rxscan91_done:
.annotate 'line', 55
  # rx rxquantr92 ** 0..1
    set_addr $I10, rxquantr92_done
    rx88_cur."!mark_push"(0, rx88_pos, $I10)
  rxquantr92_loop:
  alt93_0:
.annotate 'line', 52
    set_addr $I10, alt93_1
    rx88_cur."!mark_push"(0, rx88_pos, $I10)
.annotate 'line', 53
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx88_pos, rx88_off
    set rx88_rep, 0
    sub $I12, rx88_eos, rx88_pos
  rxenumcharlistq94_loop:
    le $I12, 0, rxenumcharlistq94_done
    substr $S10, rx88_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq94_done
    inc rx88_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq94_loop
  rxenumcharlistq94_done:
    add rx88_pos, rx88_pos, rx88_rep
  # rxanchor eol
    sub $I10, rx88_pos, rx88_off
    is_cclass $I11, 4096, rx88_tgt, $I10
    if $I11, rxanchor95_done
    ne rx88_pos, rx88_eos, rx88_fail
    eq rx88_pos, 0, rxanchor95_done
    dec $I10
    is_cclass $I11, 4096, rx88_tgt, $I10
    if $I11, rx88_fail
  rxanchor95_done:
  # rx subrule "ws" subtype=method negate=
    rx88_cur."!cursor_pos"(rx88_pos)
    $P10 = rx88_cur."ws"()
    unless $P10, rx88_fail
    rx88_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx88_cur."!cursor_pos"(rx88_pos)
    $P10 = rx88_cur."MARKER"("endstmt")
    unless $P10, rx88_fail
    goto alt93_end
  alt93_1:
.annotate 'line', 54
  # rx rxquantr96 ** 0..1
    set_addr $I10, rxquantr96_done
    rx88_cur."!mark_push"(0, rx88_pos, $I10)
  rxquantr96_loop:
  # rx subrule "unv" subtype=method negate=
    rx88_cur."!cursor_pos"(rx88_pos)
    $P10 = rx88_cur."unv"()
    unless $P10, rx88_fail
    goto rxsubrule97_pass
  rxsubrule97_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx88_fail
  rxsubrule97_pass:
    set_addr $I10, rxsubrule97_back
    rx88_cur."!mark_push"(0, rx88_pos, $I10, $P10)
    rx88_pos = $P10."pos"()
    set_addr $I10, rxquantr96_done
    (rx88_rep) = rx88_cur."!mark_commit"($I10)
  rxquantr96_done:
  # rxanchor eol
    sub $I10, rx88_pos, rx88_off
    is_cclass $I11, 4096, rx88_tgt, $I10
    if $I11, rxanchor98_done
    ne rx88_pos, rx88_eos, rx88_fail
    eq rx88_pos, 0, rxanchor98_done
    dec $I10
    is_cclass $I11, 4096, rx88_tgt, $I10
    if $I11, rx88_fail
  rxanchor98_done:
  # rx subrule "ws" subtype=method negate=
    rx88_cur."!cursor_pos"(rx88_pos)
    $P10 = rx88_cur."ws"()
    unless $P10, rx88_fail
    rx88_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx88_cur."!cursor_pos"(rx88_pos)
    $P10 = rx88_cur."MARKER"("endstmt")
    unless $P10, rx88_fail
  alt93_end:
.annotate 'line', 55
    set_addr $I10, rxquantr92_done
    (rx88_rep) = rx88_cur."!mark_commit"($I10)
  rxquantr92_done:
.annotate 'line', 51
  # rx pass
    rx88_cur."!cursor_pass"(rx88_pos, "ENDSTMT")
    if_null rx88_debug, debug_450
    rx88_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx88_pos)
  debug_450:
    .return (rx88_cur)
  rx88_restart:
.annotate 'line', 4
    if_null rx88_debug, debug_451
    rx88_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_451:
  rx88_fail:
    (rx88_rep, rx88_pos, $I10, $P10) = rx88_cur."!mark_fail"(0)
    lt rx88_pos, -1, rx88_done
    eq rx88_pos, -1, rx88_fail
    jump $I10
  rx88_done:
    rx88_cur."!cursor_fail"()
    if_null rx88_debug, debug_452
    rx88_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_452:
    .return (rx88_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1300060177.262") :method
.annotate 'line', 4
    new $P90, "ResizablePMCArray"
    push $P90, ""
    .return ($P90)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx100_tgt
    .local int rx100_pos
    .local int rx100_off
    .local int rx100_eos
    .local int rx100_rep
    .local pmc rx100_cur
    .local pmc rx100_debug
    (rx100_cur, rx100_pos, rx100_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx100_cur
    .local pmc match
    .lex "$/", match
    length rx100_eos, rx100_tgt
    gt rx100_pos, rx100_eos, rx100_done
    set rx100_off, 0
    lt rx100_pos, 2, rx100_start
    sub rx100_off, rx100_pos, 1
    substr rx100_tgt, rx100_tgt, rx100_off
  rx100_start:
    eq $I10, 1, rx100_restart
    if_null rx100_debug, debug_453
    rx100_cur."!cursor_debug"("START", "ws")
  debug_453:
    $I10 = self.'from'()
    ne $I10, -1, rxscan103_done
    goto rxscan103_scan
  rxscan103_loop:
    (rx100_pos) = rx100_cur."from"()
    inc rx100_pos
    rx100_cur."!cursor_from"(rx100_pos)
    ge rx100_pos, rx100_eos, rxscan103_done
  rxscan103_scan:
    set_addr $I10, rxscan103_loop
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
  rxscan103_done:
  alt104_0:
.annotate 'line', 58
    set_addr $I10, alt104_1
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
.annotate 'line', 59
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx100_cur."!cursor_pos"(rx100_pos)
    $P10 = rx100_cur."MARKED"("ws")
    unless $P10, rx100_fail
    goto alt104_end
  alt104_1:
.annotate 'line', 60
  # rx subrule "ww" subtype=zerowidth negate=1
    rx100_cur."!cursor_pos"(rx100_pos)
    $P10 = rx100_cur."ww"()
    if $P10, rx100_fail
.annotate 'line', 65
  # rx rxquantr105 ** 0..*
    set_addr $I10, rxquantr105_done
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
  rxquantr105_loop:
  alt106_0:
.annotate 'line', 61
    set_addr $I10, alt106_1
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx100_pos, rx100_off
    set rx100_rep, 0
    sub $I12, rx100_eos, rx100_pos
  rxenumcharlistq107_loop:
    le $I12, 0, rxenumcharlistq107_done
    substr $S10, rx100_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq107_done
    inc rx100_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq107_loop
  rxenumcharlistq107_done:
    lt rx100_rep, 1, rx100_fail
    add rx100_pos, rx100_pos, rx100_rep
    goto alt106_end
  alt106_1:
    set_addr $I10, alt106_2
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
.annotate 'line', 62
  # rx literal  "#"
    add $I11, rx100_pos, 1
    gt $I11, rx100_eos, rx100_fail
    sub $I11, rx100_pos, rx100_off
    ord $I11, rx100_tgt, $I11
    ne $I11, 35, rx100_fail
    add rx100_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx100_pos, rx100_off
    find_cclass $I11, 4096, rx100_tgt, $I10, rx100_eos
    add rx100_pos, rx100_off, $I11
    goto alt106_end
  alt106_2:
    set_addr $I10, alt106_3
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
.annotate 'line', 63
  # rxanchor bol
    eq rx100_pos, 0, rxanchor108_done
    ge rx100_pos, rx100_eos, rx100_fail
    sub $I10, rx100_pos, rx100_off
    dec $I10
    is_cclass $I11, 4096, rx100_tgt, $I10
    unless $I11, rx100_fail
  rxanchor108_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx100_cur."!cursor_pos"(rx100_pos)
    $P10 = rx100_cur."pod_comment"()
    unless $P10, rx100_fail
    rx100_pos = $P10."pos"()
    goto alt106_end
  alt106_3:
.annotate 'line', 64
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx100_pos, rx100_off
    set rx100_rep, 0
    sub $I12, rx100_eos, rx100_pos
  rxenumcharlistq109_loop:
    le $I12, 0, rxenumcharlistq109_done
    substr $S10, rx100_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq109_done
    inc rx100_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq109_loop
  rxenumcharlistq109_done:
    lt rx100_rep, 1, rx100_fail
    add rx100_pos, rx100_pos, rx100_rep
  alt106_end:
.annotate 'line', 65
    set_addr $I10, rxquantr105_done
    (rx100_rep) = rx100_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr105_done
    rx100_cur."!mark_push"(rx100_rep, rx100_pos, $I10)
    goto rxquantr105_loop
  rxquantr105_done:
.annotate 'line', 66
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx100_cur."!cursor_pos"(rx100_pos)
    $P10 = rx100_cur."MARKER"("ws")
    unless $P10, rx100_fail
  alt104_end:
.annotate 'line', 58
  # rx pass
    rx100_cur."!cursor_pass"(rx100_pos, "ws")
    if_null rx100_debug, debug_454
    rx100_cur."!cursor_debug"("PASS", "ws", " at pos=", rx100_pos)
  debug_454:
    .return (rx100_cur)
  rx100_restart:
.annotate 'line', 4
    if_null rx100_debug, debug_455
    rx100_cur."!cursor_debug"("NEXT", "ws")
  debug_455:
  rx100_fail:
    (rx100_rep, rx100_pos, $I10, $P10) = rx100_cur."!mark_fail"(0)
    lt rx100_pos, -1, rx100_done
    eq rx100_pos, -1, rx100_fail
    jump $I10
  rx100_done:
    rx100_cur."!cursor_fail"()
    if_null rx100_debug, debug_456
    rx100_cur."!cursor_debug"("FAIL", "ws")
  debug_456:
    .return (rx100_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1300060177.262") :method
.annotate 'line', 4
    new $P102, "ResizablePMCArray"
    push $P102, ""
    push $P102, ""
    .return ($P102)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P118 = "25_1300060177.262" 
    capture_lex $P118
    .local string rx111_tgt
    .local int rx111_pos
    .local int rx111_off
    .local int rx111_eos
    .local int rx111_rep
    .local pmc rx111_cur
    .local pmc rx111_debug
    (rx111_cur, rx111_pos, rx111_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx111_cur
    .local pmc match
    .lex "$/", match
    length rx111_eos, rx111_tgt
    gt rx111_pos, rx111_eos, rx111_done
    set rx111_off, 0
    lt rx111_pos, 2, rx111_start
    sub rx111_off, rx111_pos, 1
    substr rx111_tgt, rx111_tgt, rx111_off
  rx111_start:
    eq $I10, 1, rx111_restart
    if_null rx111_debug, debug_457
    rx111_cur."!cursor_debug"("START", "unv")
  debug_457:
    $I10 = self.'from'()
    ne $I10, -1, rxscan114_done
    goto rxscan114_scan
  rxscan114_loop:
    (rx111_pos) = rx111_cur."from"()
    inc rx111_pos
    rx111_cur."!cursor_from"(rx111_pos)
    ge rx111_pos, rx111_eos, rxscan114_done
  rxscan114_scan:
    set_addr $I10, rxscan114_loop
    rx111_cur."!mark_push"(0, rx111_pos, $I10)
  rxscan114_done:
  alt115_0:
.annotate 'line', 71
    set_addr $I10, alt115_1
    rx111_cur."!mark_push"(0, rx111_pos, $I10)
.annotate 'line', 72
  # rxanchor bol
    eq rx111_pos, 0, rxanchor116_done
    ge rx111_pos, rx111_eos, rx111_fail
    sub $I10, rx111_pos, rx111_off
    dec $I10
    is_cclass $I11, 4096, rx111_tgt, $I10
    unless $I11, rx111_fail
  rxanchor116_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx111_cur."!cursor_pos"(rx111_pos)
    .const 'Sub' $P118 = "25_1300060177.262" 
    capture_lex $P118
    $P10 = rx111_cur."before"($P118)
    unless $P10, rx111_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx111_cur."!cursor_pos"(rx111_pos)
    $P10 = rx111_cur."pod_comment"()
    unless $P10, rx111_fail
    rx111_pos = $P10."pos"()
    goto alt115_end
  alt115_1:
    set_addr $I10, alt115_2
    rx111_cur."!mark_push"(0, rx111_pos, $I10)
.annotate 'line', 73
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx111_pos, rx111_off
    set rx111_rep, 0
    sub $I12, rx111_eos, rx111_pos
  rxenumcharlistq123_loop:
    le $I12, 0, rxenumcharlistq123_done
    substr $S10, rx111_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq123_done
    inc rx111_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq123_loop
  rxenumcharlistq123_done:
    add rx111_pos, rx111_pos, rx111_rep
  # rx literal  "#"
    add $I11, rx111_pos, 1
    gt $I11, rx111_eos, rx111_fail
    sub $I11, rx111_pos, rx111_off
    ord $I11, rx111_tgt, $I11
    ne $I11, 35, rx111_fail
    add rx111_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx111_pos, rx111_off
    find_cclass $I11, 4096, rx111_tgt, $I10, rx111_eos
    add rx111_pos, rx111_off, $I11
    goto alt115_end
  alt115_2:
.annotate 'line', 74
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx111_pos, rx111_off
    set rx111_rep, 0
    sub $I12, rx111_eos, rx111_pos
  rxenumcharlistq124_loop:
    le $I12, 0, rxenumcharlistq124_done
    substr $S10, rx111_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq124_done
    inc rx111_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq124_loop
  rxenumcharlistq124_done:
    lt rx111_rep, 1, rx111_fail
    add rx111_pos, rx111_pos, rx111_rep
  alt115_end:
.annotate 'line', 69
  # rx pass
    rx111_cur."!cursor_pass"(rx111_pos, "unv")
    if_null rx111_debug, debug_462
    rx111_cur."!cursor_debug"("PASS", "unv", " at pos=", rx111_pos)
  debug_462:
    .return (rx111_cur)
  rx111_restart:
.annotate 'line', 4
    if_null rx111_debug, debug_463
    rx111_cur."!cursor_debug"("NEXT", "unv")
  debug_463:
  rx111_fail:
    (rx111_rep, rx111_pos, $I10, $P10) = rx111_cur."!mark_fail"(0)
    lt rx111_pos, -1, rx111_done
    eq rx111_pos, -1, rx111_fail
    jump $I10
  rx111_done:
    rx111_cur."!cursor_fail"()
    if_null rx111_debug, debug_464
    rx111_cur."!cursor_debug"("FAIL", "unv")
  debug_464:
    .return (rx111_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1300060177.262") :method
.annotate 'line', 4
    new $P113, "ResizablePMCArray"
    push $P113, ""
    push $P113, ""
    push $P113, ""
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block117"  :anon :subid("25_1300060177.262") :method :outer("23_1300060177.262")
.annotate 'line', 72
    .local string rx119_tgt
    .local int rx119_pos
    .local int rx119_off
    .local int rx119_eos
    .local int rx119_rep
    .local pmc rx119_cur
    .local pmc rx119_debug
    (rx119_cur, rx119_pos, rx119_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx119_cur
    .local pmc match
    .lex "$/", match
    length rx119_eos, rx119_tgt
    gt rx119_pos, rx119_eos, rx119_done
    set rx119_off, 0
    lt rx119_pos, 2, rx119_start
    sub rx119_off, rx119_pos, 1
    substr rx119_tgt, rx119_tgt, rx119_off
  rx119_start:
    eq $I10, 1, rx119_restart
    if_null rx119_debug, debug_458
    rx119_cur."!cursor_debug"("START", "")
  debug_458:
    $I10 = self.'from'()
    ne $I10, -1, rxscan120_done
    goto rxscan120_scan
  rxscan120_loop:
    (rx119_pos) = rx119_cur."from"()
    inc rx119_pos
    rx119_cur."!cursor_from"(rx119_pos)
    ge rx119_pos, rx119_eos, rxscan120_done
  rxscan120_scan:
    set_addr $I10, rxscan120_loop
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  rxscan120_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq121_loop:
    le $I12, 0, rxenumcharlistq121_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq121_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq121_loop
  rxenumcharlistq121_done:
    add rx119_pos, rx119_pos, rx119_rep
  # rx literal  "="
    add $I11, rx119_pos, 1
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    ord $I11, rx119_tgt, $I11
    ne $I11, 61, rx119_fail
    add rx119_pos, 1
  alt122_0:
    set_addr $I10, alt122_1
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  # rx charclass w
    ge rx119_pos, rx119_eos, rx119_fail
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 8192, rx119_tgt, $I10
    unless $I11, rx119_fail
    inc rx119_pos
    goto alt122_end
  alt122_1:
  # rx literal  "\\"
    add $I11, rx119_pos, 1
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    ord $I11, rx119_tgt, $I11
    ne $I11, 92, rx119_fail
    add rx119_pos, 1
  alt122_end:
  # rx pass
    rx119_cur."!cursor_pass"(rx119_pos, "")
    if_null rx119_debug, debug_459
    rx119_cur."!cursor_debug"("PASS", "", " at pos=", rx119_pos)
  debug_459:
    .return (rx119_cur)
  rx119_restart:
    if_null rx119_debug, debug_460
    rx119_cur."!cursor_debug"("NEXT", "")
  debug_460:
  rx119_fail:
    (rx119_rep, rx119_pos, $I10, $P10) = rx119_cur."!mark_fail"(0)
    lt rx119_pos, -1, rx119_done
    eq rx119_pos, -1, rx119_fail
    jump $I10
  rx119_done:
    rx119_cur."!cursor_fail"()
    if_null rx119_debug, debug_461
    rx119_cur."!cursor_debug"("FAIL", "")
  debug_461:
    .return (rx119_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P157 = "28_1300060177.262" 
    capture_lex $P157
    .local string rx126_tgt
    .local int rx126_pos
    .local int rx126_off
    .local int rx126_eos
    .local int rx126_rep
    .local pmc rx126_cur
    .local pmc rx126_debug
    (rx126_cur, rx126_pos, rx126_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx126_cur
    .local pmc match
    .lex "$/", match
    length rx126_eos, rx126_tgt
    gt rx126_pos, rx126_eos, rx126_done
    set rx126_off, 0
    lt rx126_pos, 2, rx126_start
    sub rx126_off, rx126_pos, 1
    substr rx126_tgt, rx126_tgt, rx126_off
  rx126_start:
    eq $I10, 1, rx126_restart
    if_null rx126_debug, debug_465
    rx126_cur."!cursor_debug"("START", "pod_comment")
  debug_465:
    $I10 = self.'from'()
    ne $I10, -1, rxscan129_done
    goto rxscan129_scan
  rxscan129_loop:
    (rx126_pos) = rx126_cur."from"()
    inc rx126_pos
    rx126_cur."!cursor_from"(rx126_pos)
    ge rx126_pos, rx126_eos, rxscan129_done
  rxscan129_scan:
    set_addr $I10, rxscan129_loop
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  rxscan129_done:
.annotate 'line', 79
  # rxanchor bol
    eq rx126_pos, 0, rxanchor130_done
    ge rx126_pos, rx126_eos, rx126_fail
    sub $I10, rx126_pos, rx126_off
    dec $I10
    is_cclass $I11, 4096, rx126_tgt, $I10
    unless $I11, rx126_fail
  rxanchor130_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq131_loop:
    le $I12, 0, rxenumcharlistq131_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq131_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq131_loop
  rxenumcharlistq131_done:
    add rx126_pos, rx126_pos, rx126_rep
  # rx literal  "="
    add $I11, rx126_pos, 1
    gt $I11, rx126_eos, rx126_fail
    sub $I11, rx126_pos, rx126_off
    ord $I11, rx126_tgt, $I11
    ne $I11, 61, rx126_fail
    add rx126_pos, 1
  alt132_0:
.annotate 'line', 80
    set_addr $I10, alt132_1
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
.annotate 'line', 81
  # rx literal  "begin"
    add $I11, rx126_pos, 5
    gt $I11, rx126_eos, rx126_fail
    sub $I11, rx126_pos, rx126_off
    substr $S10, rx126_tgt, $I11, 5
    ne $S10, "begin", rx126_fail
    add rx126_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq133_loop:
    le $I12, 0, rxenumcharlistq133_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq133_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq133_loop
  rxenumcharlistq133_done:
    lt rx126_rep, 1, rx126_fail
    add rx126_pos, rx126_pos, rx126_rep
  # rx literal  "END"
    add $I11, rx126_pos, 3
    gt $I11, rx126_eos, rx126_fail
    sub $I11, rx126_pos, rx126_off
    substr $S10, rx126_tgt, $I11, 3
    ne $S10, "END", rx126_fail
    add rx126_pos, 3
  # rxanchor rwb
    le rx126_pos, 0, rx126_fail
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 8192, rx126_tgt, $I10
    if $I11, rx126_fail
    dec $I10
    is_cclass $I11, 8192, rx126_tgt, $I10
    unless $I11, rx126_fail
  alt134_0:
.annotate 'line', 82
    set_addr $I10, alt134_1
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  # rx rxquantf135 ** 0..*
    set_addr $I10, rxquantf135_loop
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
    goto rxquantf135_done
  rxquantf135_loop:
  # rx charclass .
    ge rx126_pos, rx126_eos, rx126_fail
    inc rx126_pos
    set_addr $I10, rxquantf135_loop
    rx126_cur."!mark_push"(rx126_rep, rx126_pos, $I10)
  rxquantf135_done:
  # rx charclass nl
    ge rx126_pos, rx126_eos, rx126_fail
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 4096, rx126_tgt, $I10
    unless $I11, rx126_fail
    substr $S10, rx126_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx126_pos, $I11
    inc rx126_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq137_loop:
    le $I12, 0, rxenumcharlistq137_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq137_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq137_loop
  rxenumcharlistq137_done:
    add rx126_pos, rx126_pos, rx126_rep
  # rx literal  "=end"
    add $I11, rx126_pos, 4
    gt $I11, rx126_eos, rx126_fail
    sub $I11, rx126_pos, rx126_off
    substr $S10, rx126_tgt, $I11, 4
    ne $S10, "=end", rx126_fail
    add rx126_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq138_loop:
    le $I12, 0, rxenumcharlistq138_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq138_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq138_loop
  rxenumcharlistq138_done:
    lt rx126_rep, 1, rx126_fail
    add rx126_pos, rx126_pos, rx126_rep
  # rx literal  "END"
    add $I11, rx126_pos, 3
    gt $I11, rx126_eos, rx126_fail
    sub $I11, rx126_pos, rx126_off
    substr $S10, rx126_tgt, $I11, 3
    ne $S10, "END", rx126_fail
    add rx126_pos, 3
  # rxanchor rwb
    le rx126_pos, 0, rx126_fail
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 8192, rx126_tgt, $I10
    if $I11, rx126_fail
    dec $I10
    is_cclass $I11, 8192, rx126_tgt, $I10
    unless $I11, rx126_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx126_pos, rx126_off
    find_cclass $I11, 4096, rx126_tgt, $I10, rx126_eos
    add rx126_pos, rx126_off, $I11
    goto alt134_end
  alt134_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx126_pos, rx126_off
    find_not_cclass $I11, 65535, rx126_tgt, $I10, rx126_eos
    add rx126_pos, rx126_off, $I11
  alt134_end:
.annotate 'line', 81
    goto alt132_end
  alt132_1:
    set_addr $I10, alt132_2
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
.annotate 'line', 83
  # rx literal  "begin"
    add $I11, rx126_pos, 5
    gt $I11, rx126_eos, rx126_fail
    sub $I11, rx126_pos, rx126_off
    substr $S10, rx126_tgt, $I11, 5
    ne $S10, "begin", rx126_fail
    add rx126_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq139_loop:
    le $I12, 0, rxenumcharlistq139_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq139_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq139_loop
  rxenumcharlistq139_done:
    lt rx126_rep, 1, rx126_fail
    add rx126_pos, rx126_pos, rx126_rep
  # rx subrule "identifier" subtype=capture negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."identifier"()
    unless $P10, rx126_fail
    rx126_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx126_pos = $P10."pos"()
  alt140_0:
.annotate 'line', 84
    set_addr $I10, alt140_1
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
.annotate 'line', 85
  # rx rxquantf141 ** 0..*
    set_addr $I10, rxquantf141_loop
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
    goto rxquantf141_done
  rxquantf141_loop:
  # rx charclass .
    ge rx126_pos, rx126_eos, rx126_fail
    inc rx126_pos
    set_addr $I10, rxquantf141_loop
    rx126_cur."!mark_push"(rx126_rep, rx126_pos, $I10)
  rxquantf141_done:
  # rx charclass nl
    ge rx126_pos, rx126_eos, rx126_fail
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 4096, rx126_tgt, $I10
    unless $I11, rx126_fail
    substr $S10, rx126_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx126_pos, $I11
    inc rx126_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx126_pos, rx126_pos, rx126_rep
  # rx literal  "=end"
    add $I11, rx126_pos, 4
    gt $I11, rx126_eos, rx126_fail
    sub $I11, rx126_pos, rx126_off
    substr $S10, rx126_tgt, $I11, 4
    ne $S10, "=end", rx126_fail
    add rx126_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq144_loop:
    le $I12, 0, rxenumcharlistq144_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq144_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq144_loop
  rxenumcharlistq144_done:
    lt rx126_rep, 1, rx126_fail
    add rx126_pos, rx126_pos, rx126_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."!BACKREF"("identifier")
    unless $P10, rx126_fail
    rx126_pos = $P10."pos"()
  # rxanchor rwb
    le rx126_pos, 0, rx126_fail
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 8192, rx126_tgt, $I10
    if $I11, rx126_fail
    dec $I10
    is_cclass $I11, 8192, rx126_tgt, $I10
    unless $I11, rx126_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx126_pos, rx126_off
    find_cclass $I11, 4096, rx126_tgt, $I10, rx126_eos
    add rx126_pos, rx126_off, $I11
    goto alt140_end
  alt140_1:
.annotate 'line', 86
  # rx subrule "panic" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."panic"("=begin without matching =end")
    unless $P10, rx126_fail
    rx126_pos = $P10."pos"()
  alt140_end:
.annotate 'line', 83
    goto alt132_end
  alt132_2:
    set_addr $I10, alt132_3
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
.annotate 'line', 88
  # rx literal  "begin"
    add $I11, rx126_pos, 5
    gt $I11, rx126_eos, rx126_fail
    sub $I11, rx126_pos, rx126_off
    substr $S10, rx126_tgt, $I11, 5
    ne $S10, "begin", rx126_fail
    add rx126_pos, 5
  # rxanchor rwb
    le rx126_pos, 0, rx126_fail
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 8192, rx126_tgt, $I10
    if $I11, rx126_fail
    dec $I10
    is_cclass $I11, 8192, rx126_tgt, $I10
    unless $I11, rx126_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq146_loop:
    le $I12, 0, rxenumcharlistq146_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq146_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq146_loop
  rxenumcharlistq146_done:
    add rx126_pos, rx126_pos, rx126_rep
  alt147_0:
.annotate 'line', 89
    set_addr $I10, alt147_1
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  # rxanchor eol
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 4096, rx126_tgt, $I10
    if $I11, rxanchor148_done
    ne rx126_pos, rx126_eos, rx126_fail
    eq rx126_pos, 0, rxanchor148_done
    dec $I10
    is_cclass $I11, 4096, rx126_tgt, $I10
    if $I11, rx126_fail
  rxanchor148_done:
    goto alt147_end
  alt147_1:
    set_addr $I10, alt147_2
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  # rx literal  "#"
    add $I11, rx126_pos, 1
    gt $I11, rx126_eos, rx126_fail
    sub $I11, rx126_pos, rx126_off
    ord $I11, rx126_tgt, $I11
    ne $I11, 35, rx126_fail
    add rx126_pos, 1
    goto alt147_end
  alt147_2:
  # rx subrule "panic" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx126_fail
    rx126_pos = $P10."pos"()
  alt147_end:
  alt149_0:
.annotate 'line', 90
    set_addr $I10, alt149_1
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
.annotate 'line', 91
  # rx rxquantf150 ** 0..*
    set_addr $I10, rxquantf150_loop
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
    goto rxquantf150_done
  rxquantf150_loop:
  # rx charclass .
    ge rx126_pos, rx126_eos, rx126_fail
    inc rx126_pos
    set_addr $I10, rxquantf150_loop
    rx126_cur."!mark_push"(rx126_rep, rx126_pos, $I10)
  rxquantf150_done:
  # rx charclass nl
    ge rx126_pos, rx126_eos, rx126_fail
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 4096, rx126_tgt, $I10
    unless $I11, rx126_fail
    substr $S10, rx126_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx126_pos, $I11
    inc rx126_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq152_loop:
    le $I12, 0, rxenumcharlistq152_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq152_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq152_loop
  rxenumcharlistq152_done:
    add rx126_pos, rx126_pos, rx126_rep
  # rx literal  "=end"
    add $I11, rx126_pos, 4
    gt $I11, rx126_eos, rx126_fail
    sub $I11, rx126_pos, rx126_off
    substr $S10, rx126_tgt, $I11, 4
    ne $S10, "=end", rx126_fail
    add rx126_pos, 4
  # rxanchor rwb
    le rx126_pos, 0, rx126_fail
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 8192, rx126_tgt, $I10
    if $I11, rx126_fail
    dec $I10
    is_cclass $I11, 8192, rx126_tgt, $I10
    unless $I11, rx126_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx126_pos, rx126_off
    find_cclass $I11, 4096, rx126_tgt, $I10, rx126_eos
    add rx126_pos, rx126_off, $I11
    goto alt149_end
  alt149_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."panic"("=begin without matching =end")
    unless $P10, rx126_fail
    rx126_pos = $P10."pos"()
  alt149_end:
.annotate 'line', 88
    goto alt132_end
  alt132_3:
    set_addr $I10, alt132_4
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
.annotate 'line', 94
  # rx subrule "identifier" subtype=capture negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."identifier"()
    unless $P10, rx126_fail
    rx126_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx126_pos = $P10."pos"()
.annotate 'line', 95
  # rx rxquantf153 ** 0..*
    set_addr $I10, rxquantf153_loop
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
    goto rxquantf153_done
  rxquantf153_loop:
  # rx charclass .
    ge rx126_pos, rx126_eos, rx126_fail
    inc rx126_pos
    set_addr $I10, rxquantf153_loop
    rx126_cur."!mark_push"(rx126_rep, rx126_pos, $I10)
  rxquantf153_done:
  # rxanchor bol
    eq rx126_pos, 0, rxanchor155_done
    ge rx126_pos, rx126_eos, rx126_fail
    sub $I10, rx126_pos, rx126_off
    dec $I10
    is_cclass $I11, 4096, rx126_tgt, $I10
    unless $I11, rx126_fail
  rxanchor155_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    .const 'Sub' $P157 = "28_1300060177.262" 
    capture_lex $P157
    $P10 = rx126_cur."before"($P157)
    unless $P10, rx126_fail
.annotate 'line', 94
    goto alt132_end
  alt132_4:
  alt163_0:
.annotate 'line', 101
    set_addr $I10, alt163_1
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  # rx charclass s
    ge rx126_pos, rx126_eos, rx126_fail
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 32, rx126_tgt, $I10
    unless $I11, rx126_fail
    inc rx126_pos
    goto alt163_end
  alt163_1:
  # rx subrule "panic" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."panic"("Illegal pod directive")
    unless $P10, rx126_fail
    rx126_pos = $P10."pos"()
  alt163_end:
.annotate 'line', 102
  # rx charclass_q N r 0..-1
    sub $I10, rx126_pos, rx126_off
    find_cclass $I11, 4096, rx126_tgt, $I10, rx126_eos
    add rx126_pos, rx126_off, $I11
  alt132_end:
.annotate 'line', 78
  # rx pass
    rx126_cur."!cursor_pass"(rx126_pos, "pod_comment")
    if_null rx126_debug, debug_470
    rx126_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx126_pos)
  debug_470:
    .return (rx126_cur)
  rx126_restart:
.annotate 'line', 4
    if_null rx126_debug, debug_471
    rx126_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_471:
  rx126_fail:
    (rx126_rep, rx126_pos, $I10, $P10) = rx126_cur."!mark_fail"(0)
    lt rx126_pos, -1, rx126_done
    eq rx126_pos, -1, rx126_fail
    jump $I10
  rx126_done:
    rx126_cur."!cursor_fail"()
    if_null rx126_debug, debug_472
    rx126_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_472:
    .return (rx126_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1300060177.262") :method
.annotate 'line', 4
    new $P128, "ResizablePMCArray"
    push $P128, ""
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block156"  :anon :subid("28_1300060177.262") :method :outer("26_1300060177.262")
.annotate 'line', 95
    .local string rx158_tgt
    .local int rx158_pos
    .local int rx158_off
    .local int rx158_eos
    .local int rx158_rep
    .local pmc rx158_cur
    .local pmc rx158_debug
    (rx158_cur, rx158_pos, rx158_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx158_cur
    .local pmc match
    .lex "$/", match
    length rx158_eos, rx158_tgt
    gt rx158_pos, rx158_eos, rx158_done
    set rx158_off, 0
    lt rx158_pos, 2, rx158_start
    sub rx158_off, rx158_pos, 1
    substr rx158_tgt, rx158_tgt, rx158_off
  rx158_start:
    eq $I10, 1, rx158_restart
    if_null rx158_debug, debug_466
    rx158_cur."!cursor_debug"("START", "")
  debug_466:
    $I10 = self.'from'()
    ne $I10, -1, rxscan159_done
    goto rxscan159_scan
  rxscan159_loop:
    (rx158_pos) = rx158_cur."from"()
    inc rx158_pos
    rx158_cur."!cursor_from"(rx158_pos)
    ge rx158_pos, rx158_eos, rxscan159_done
  rxscan159_scan:
    set_addr $I10, rxscan159_loop
    rx158_cur."!mark_push"(0, rx158_pos, $I10)
  rxscan159_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx158_pos, rx158_off
    set rx158_rep, 0
    sub $I12, rx158_eos, rx158_pos
  rxenumcharlistq160_loop:
    le $I12, 0, rxenumcharlistq160_done
    substr $S10, rx158_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq160_done
    inc rx158_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq160_loop
  rxenumcharlistq160_done:
    add rx158_pos, rx158_pos, rx158_rep
  alt161_0:
    set_addr $I10, alt161_1
    rx158_cur."!mark_push"(0, rx158_pos, $I10)
.annotate 'line', 96
  # rx literal  "="
    add $I11, rx158_pos, 1
    gt $I11, rx158_eos, rx158_fail
    sub $I11, rx158_pos, rx158_off
    ord $I11, rx158_tgt, $I11
    ne $I11, 61, rx158_fail
    add rx158_pos, 1
.annotate 'line', 98
  # rx rxquantr162 ** 0..1
    set_addr $I10, rxquantr162_done
    rx158_cur."!mark_push"(0, rx158_pos, $I10)
  rxquantr162_loop:
.annotate 'line', 97
  # rx literal  "cut"
    add $I11, rx158_pos, 3
    gt $I11, rx158_eos, rx158_fail
    sub $I11, rx158_pos, rx158_off
    substr $S10, rx158_tgt, $I11, 3
    ne $S10, "cut", rx158_fail
    add rx158_pos, 3
  # rxanchor rwb
    le rx158_pos, 0, rx158_fail
    sub $I10, rx158_pos, rx158_off
    is_cclass $I11, 8192, rx158_tgt, $I10
    if $I11, rx158_fail
    dec $I10
    is_cclass $I11, 8192, rx158_tgt, $I10
    unless $I11, rx158_fail
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx158_cur."!cursor_pos"(rx158_pos)
    $P10 = rx158_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx158_fail
    rx158_pos = $P10."pos"()
    set_addr $I10, rxquantr162_done
    (rx158_rep) = rx158_cur."!mark_commit"($I10)
  rxquantr162_done:
.annotate 'line', 95
    goto alt161_end
  alt161_1:
.annotate 'line', 99
  # rx charclass nl
    ge rx158_pos, rx158_eos, rx158_fail
    sub $I10, rx158_pos, rx158_off
    is_cclass $I11, 4096, rx158_tgt, $I10
    unless $I11, rx158_fail
    substr $S10, rx158_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx158_pos, $I11
    inc rx158_pos
  alt161_end:
.annotate 'line', 95
  # rx pass
    rx158_cur."!cursor_pass"(rx158_pos, "")
    if_null rx158_debug, debug_467
    rx158_cur."!cursor_debug"("PASS", "", " at pos=", rx158_pos)
  debug_467:
    .return (rx158_cur)
  rx158_restart:
    if_null rx158_debug, debug_468
    rx158_cur."!cursor_debug"("NEXT", "")
  debug_468:
  rx158_fail:
    (rx158_rep, rx158_pos, $I10, $P10) = rx158_cur."!mark_fail"(0)
    lt rx158_pos, -1, rx158_done
    eq rx158_pos, -1, rx158_fail
    jump $I10
  rx158_done:
    rx158_cur."!cursor_fail"()
    if_null rx158_debug, debug_469
    rx158_cur."!cursor_debug"("FAIL", "")
  debug_469:
    .return (rx158_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 110
    new $P165, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P165
.annotate 'line', 111
    new $P166, "Undef"
    .lex "$*MAIN_SUB", $P166
.annotate 'line', 4
    .local string rx167_tgt
    .local int rx167_pos
    .local int rx167_off
    .local int rx167_eos
    .local int rx167_rep
    .local pmc rx167_cur
    .local pmc rx167_debug
    (rx167_cur, rx167_pos, rx167_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx167_cur
    .local pmc match
    .lex "$/", match
    length rx167_eos, rx167_tgt
    gt rx167_pos, rx167_eos, rx167_done
    set rx167_off, 0
    lt rx167_pos, 2, rx167_start
    sub rx167_off, rx167_pos, 1
    substr rx167_tgt, rx167_tgt, rx167_off
  rx167_start:
    eq $I10, 1, rx167_restart
    if_null rx167_debug, debug_473
    rx167_cur."!cursor_debug"("START", "comp_unit")
  debug_473:
    $I10 = self.'from'()
    ne $I10, -1, rxscan171_done
    goto rxscan171_scan
  rxscan171_loop:
    (rx167_pos) = rx167_cur."from"()
    inc rx167_pos
    rx167_cur."!cursor_from"(rx167_pos)
    ge rx167_pos, rx167_eos, rxscan171_done
  rxscan171_scan:
    set_addr $I10, rxscan171_loop
    rx167_cur."!mark_push"(0, rx167_pos, $I10)
  rxscan171_done:
.annotate 'line', 110
    rx167_cur."!cursor_pos"(rx167_pos)
    new $P172, "Integer"
    assign $P172, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P172
.annotate 'line', 111
    rx167_cur."!cursor_pos"(rx167_pos)
    find_lex $P173, "$*MAIN_SUB"
    unless_null $P173, vivify_474
    get_hll_global $P173, "$MAIN_SUB"
    unless_null $P173, vivify_475
    die "Contextual $*MAIN_SUB not found"
  vivify_475:
  vivify_474:
.annotate 'line', 112
  # rx subrule "newpad" subtype=method negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."newpad"()
    unless $P10, rx167_fail
    rx167_pos = $P10."pos"()
.annotate 'line', 113
  # rx subrule "outerctx" subtype=method negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."outerctx"()
    unless $P10, rx167_fail
    rx167_pos = $P10."pos"()
.annotate 'line', 114
  # rx subrule "statementlist" subtype=capture negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."statementlist"()
    unless $P10, rx167_fail
    rx167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx167_pos = $P10."pos"()
  alt174_0:
.annotate 'line', 115
    set_addr $I10, alt174_1
    rx167_cur."!mark_push"(0, rx167_pos, $I10)
  # rxanchor eos
    ne rx167_pos, rx167_eos, rx167_fail
    goto alt174_end
  alt174_1:
  # rx subrule "panic" subtype=method negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."panic"("Confused")
    unless $P10, rx167_fail
    rx167_pos = $P10."pos"()
  alt174_end:
.annotate 'line', 109
  # rx pass
    rx167_cur."!cursor_pass"(rx167_pos, "comp_unit")
    if_null rx167_debug, debug_476
    rx167_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx167_pos)
  debug_476:
    .return (rx167_cur)
  rx167_restart:
.annotate 'line', 4
    if_null rx167_debug, debug_477
    rx167_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_477:
  rx167_fail:
    (rx167_rep, rx167_pos, $I10, $P10) = rx167_cur."!mark_fail"(0)
    lt rx167_pos, -1, rx167_done
    eq rx167_pos, -1, rx167_fail
    jump $I10
  rx167_done:
    rx167_cur."!cursor_fail"()
    if_null rx167_debug, debug_478
    rx167_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_478:
    .return (rx167_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1300060177.262") :method
.annotate 'line', 4
    $P169 = self."!PREFIX__!subrule"("newpad", "")
    new $P170, "ResizablePMCArray"
    push $P170, $P169
    .return ($P170)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx176_tgt
    .local int rx176_pos
    .local int rx176_off
    .local int rx176_eos
    .local int rx176_rep
    .local pmc rx176_cur
    .local pmc rx176_debug
    (rx176_cur, rx176_pos, rx176_tgt, $I10) = self."!cursor_start"()
    rx176_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx176_cur
    .local pmc match
    .lex "$/", match
    length rx176_eos, rx176_tgt
    gt rx176_pos, rx176_eos, rx176_done
    set rx176_off, 0
    lt rx176_pos, 2, rx176_start
    sub rx176_off, rx176_pos, 1
    substr rx176_tgt, rx176_tgt, rx176_off
  rx176_start:
    eq $I10, 1, rx176_restart
    if_null rx176_debug, debug_479
    rx176_cur."!cursor_debug"("START", "statementlist")
  debug_479:
    $I10 = self.'from'()
    ne $I10, -1, rxscan181_done
    goto rxscan181_scan
  rxscan181_loop:
    (rx176_pos) = rx176_cur."from"()
    inc rx176_pos
    rx176_cur."!cursor_from"(rx176_pos)
    ge rx176_pos, rx176_eos, rxscan181_done
  rxscan181_scan:
    set_addr $I10, rxscan181_loop
    rx176_cur."!mark_push"(0, rx176_pos, $I10)
  rxscan181_done:
  alt182_0:
.annotate 'line', 118
    set_addr $I10, alt182_1
    rx176_cur."!mark_push"(0, rx176_pos, $I10)
.annotate 'line', 119
  # rx subrule "ws" subtype=method negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."ws"()
    unless $P10, rx176_fail
    rx176_pos = $P10."pos"()
  # rxanchor eos
    ne rx176_pos, rx176_eos, rx176_fail
  # rx subrule "ws" subtype=method negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."ws"()
    unless $P10, rx176_fail
    rx176_pos = $P10."pos"()
    goto alt182_end
  alt182_1:
.annotate 'line', 120
  # rx subrule "ws" subtype=method negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."ws"()
    unless $P10, rx176_fail
    rx176_pos = $P10."pos"()
  # rx rxquantr186 ** 0..*
    set_addr $I10, rxquantr186_done
    rx176_cur."!mark_push"(0, rx176_pos, $I10)
  rxquantr186_loop:
  # rx subrule "statement" subtype=capture negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."statement"()
    unless $P10, rx176_fail
    rx176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx176_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."eat_terminator"()
    unless $P10, rx176_fail
    rx176_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."ws"()
    unless $P10, rx176_fail
    rx176_pos = $P10."pos"()
    set_addr $I10, rxquantr186_done
    (rx176_rep) = rx176_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr186_done
    rx176_cur."!mark_push"(rx176_rep, rx176_pos, $I10)
    goto rxquantr186_loop
  rxquantr186_done:
  # rx subrule "ws" subtype=method negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."ws"()
    unless $P10, rx176_fail
    rx176_pos = $P10."pos"()
  alt182_end:
.annotate 'line', 118
  # rx pass
    rx176_cur."!cursor_pass"(rx176_pos, "statementlist")
    if_null rx176_debug, debug_480
    rx176_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx176_pos)
  debug_480:
    .return (rx176_cur)
  rx176_restart:
.annotate 'line', 4
    if_null rx176_debug, debug_481
    rx176_cur."!cursor_debug"("NEXT", "statementlist")
  debug_481:
  rx176_fail:
    (rx176_rep, rx176_pos, $I10, $P10) = rx176_cur."!mark_fail"(0)
    lt rx176_pos, -1, rx176_done
    eq rx176_pos, -1, rx176_fail
    jump $I10
  rx176_done:
    rx176_cur."!cursor_fail"()
    if_null rx176_debug, debug_482
    rx176_cur."!cursor_debug"("FAIL", "statementlist")
  debug_482:
    .return (rx176_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1300060177.262") :method
.annotate 'line', 4
    $P178 = self."!PREFIX__!subrule"("ws", "")
    $P179 = self."!PREFIX__!subrule"("ws", "")
    new $P180, "ResizablePMCArray"
    push $P180, $P178
    push $P180, $P179
    .return ($P180)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P195 = "35_1300060177.262" 
    capture_lex $P195
    .local string rx190_tgt
    .local int rx190_pos
    .local int rx190_off
    .local int rx190_eos
    .local int rx190_rep
    .local pmc rx190_cur
    .local pmc rx190_debug
    (rx190_cur, rx190_pos, rx190_tgt, $I10) = self."!cursor_start"()
    rx190_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx190_cur
    .local pmc match
    .lex "$/", match
    length rx190_eos, rx190_tgt
    gt rx190_pos, rx190_eos, rx190_done
    set rx190_off, 0
    lt rx190_pos, 2, rx190_start
    sub rx190_off, rx190_pos, 1
    substr rx190_tgt, rx190_tgt, rx190_off
  rx190_start:
    eq $I10, 1, rx190_restart
    if_null rx190_debug, debug_483
    rx190_cur."!cursor_debug"("START", "statement")
  debug_483:
    $I10 = self.'from'()
    ne $I10, -1, rxscan193_done
    goto rxscan193_scan
  rxscan193_loop:
    (rx190_pos) = rx190_cur."from"()
    inc rx190_pos
    rx190_cur."!cursor_from"(rx190_pos)
    ge rx190_pos, rx190_eos, rxscan193_done
  rxscan193_scan:
    set_addr $I10, rxscan193_loop
    rx190_cur."!mark_push"(0, rx190_pos, $I10)
  rxscan193_done:
.annotate 'line', 124
  # rx subrule "before" subtype=zerowidth negate=1
    rx190_cur."!cursor_pos"(rx190_pos)
    .const 'Sub' $P195 = "35_1300060177.262" 
    capture_lex $P195
    $P10 = rx190_cur."before"($P195)
    if $P10, rx190_fail
  alt199_0:
.annotate 'line', 125
    set_addr $I10, alt199_1
    rx190_cur."!mark_push"(0, rx190_pos, $I10)
.annotate 'line', 126
  # rx subrule "statement_control" subtype=capture negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."statement_control"()
    unless $P10, rx190_fail
    rx190_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx190_pos = $P10."pos"()
    goto alt199_end
  alt199_1:
.annotate 'line', 127
  # rx subrule "EXPR" subtype=capture negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."EXPR"()
    unless $P10, rx190_fail
    rx190_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx190_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."ws"()
    unless $P10, rx190_fail
    rx190_pos = $P10."pos"()
.annotate 'line', 132
  # rx rxquantr200 ** 0..1
    set_addr $I10, rxquantr200_done
    rx190_cur."!mark_push"(0, rx190_pos, $I10)
  rxquantr200_loop:
  alt201_0:
.annotate 'line', 128
    set_addr $I10, alt201_1
    rx190_cur."!mark_push"(0, rx190_pos, $I10)
.annotate 'line', 129
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."MARKED"("endstmt")
    unless $P10, rx190_fail
    goto alt201_end
  alt201_1:
    set_addr $I10, alt201_2
    rx190_cur."!mark_push"(0, rx190_pos, $I10)
.annotate 'line', 130
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."statement_mod_cond"()
    unless $P10, rx190_fail
    rx190_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx190_pos = $P10."pos"()
  # rx rxquantr202 ** 0..1
    set_addr $I10, rxquantr202_done
    rx190_cur."!mark_push"(0, rx190_pos, $I10)
  rxquantr202_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."statement_mod_loop"()
    unless $P10, rx190_fail
    goto rxsubrule203_pass
  rxsubrule203_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx190_fail
  rxsubrule203_pass:
    set_addr $I10, rxsubrule203_back
    rx190_cur."!mark_push"(0, rx190_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx190_pos = $P10."pos"()
    set_addr $I10, rxquantr202_done
    (rx190_rep) = rx190_cur."!mark_commit"($I10)
  rxquantr202_done:
    goto alt201_end
  alt201_2:
.annotate 'line', 131
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx190_cur."!cursor_pos"(rx190_pos)
    $P10 = rx190_cur."statement_mod_loop"()
    unless $P10, rx190_fail
    rx190_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx190_pos = $P10."pos"()
  alt201_end:
.annotate 'line', 132
    set_addr $I10, rxquantr200_done
    (rx190_rep) = rx190_cur."!mark_commit"($I10)
  rxquantr200_done:
  alt199_end:
.annotate 'line', 123
  # rx pass
    rx190_cur."!cursor_pass"(rx190_pos, "statement")
    if_null rx190_debug, debug_488
    rx190_cur."!cursor_debug"("PASS", "statement", " at pos=", rx190_pos)
  debug_488:
    .return (rx190_cur)
  rx190_restart:
.annotate 'line', 4
    if_null rx190_debug, debug_489
    rx190_cur."!cursor_debug"("NEXT", "statement")
  debug_489:
  rx190_fail:
    (rx190_rep, rx190_pos, $I10, $P10) = rx190_cur."!mark_fail"(0)
    lt rx190_pos, -1, rx190_done
    eq rx190_pos, -1, rx190_fail
    jump $I10
  rx190_done:
    rx190_cur."!cursor_fail"()
    if_null rx190_debug, debug_490
    rx190_cur."!cursor_debug"("FAIL", "statement")
  debug_490:
    .return (rx190_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1300060177.262") :method
.annotate 'line', 4
    new $P192, "ResizablePMCArray"
    push $P192, ""
    .return ($P192)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block194"  :anon :subid("35_1300060177.262") :method :outer("33_1300060177.262")
.annotate 'line', 124
    .local string rx196_tgt
    .local int rx196_pos
    .local int rx196_off
    .local int rx196_eos
    .local int rx196_rep
    .local pmc rx196_cur
    .local pmc rx196_debug
    (rx196_cur, rx196_pos, rx196_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx196_cur
    .local pmc match
    .lex "$/", match
    length rx196_eos, rx196_tgt
    gt rx196_pos, rx196_eos, rx196_done
    set rx196_off, 0
    lt rx196_pos, 2, rx196_start
    sub rx196_off, rx196_pos, 1
    substr rx196_tgt, rx196_tgt, rx196_off
  rx196_start:
    eq $I10, 1, rx196_restart
    if_null rx196_debug, debug_484
    rx196_cur."!cursor_debug"("START", "")
  debug_484:
    $I10 = self.'from'()
    ne $I10, -1, rxscan197_done
    goto rxscan197_scan
  rxscan197_loop:
    (rx196_pos) = rx196_cur."from"()
    inc rx196_pos
    rx196_cur."!cursor_from"(rx196_pos)
    ge rx196_pos, rx196_eos, rxscan197_done
  rxscan197_scan:
    set_addr $I10, rxscan197_loop
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxscan197_done:
  alt198_0:
    set_addr $I10, alt198_1
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx196_pos, rx196_eos, rx196_fail
    sub $I10, rx196_pos, rx196_off
    substr $S10, rx196_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx196_fail
    inc rx196_pos
    goto alt198_end
  alt198_1:
  # rxanchor eos
    ne rx196_pos, rx196_eos, rx196_fail
  alt198_end:
  # rx pass
    rx196_cur."!cursor_pass"(rx196_pos, "")
    if_null rx196_debug, debug_485
    rx196_cur."!cursor_debug"("PASS", "", " at pos=", rx196_pos)
  debug_485:
    .return (rx196_cur)
  rx196_restart:
    if_null rx196_debug, debug_486
    rx196_cur."!cursor_debug"("NEXT", "")
  debug_486:
  rx196_fail:
    (rx196_rep, rx196_pos, $I10, $P10) = rx196_cur."!mark_fail"(0)
    lt rx196_pos, -1, rx196_done
    eq rx196_pos, -1, rx196_fail
    jump $I10
  rx196_done:
    rx196_cur."!cursor_fail"()
    if_null rx196_debug, debug_487
    rx196_cur."!cursor_debug"("FAIL", "")
  debug_487:
    .return (rx196_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx205_tgt
    .local int rx205_pos
    .local int rx205_off
    .local int rx205_eos
    .local int rx205_rep
    .local pmc rx205_cur
    .local pmc rx205_debug
    (rx205_cur, rx205_pos, rx205_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx205_cur
    .local pmc match
    .lex "$/", match
    length rx205_eos, rx205_tgt
    gt rx205_pos, rx205_eos, rx205_done
    set rx205_off, 0
    lt rx205_pos, 2, rx205_start
    sub rx205_off, rx205_pos, 1
    substr rx205_tgt, rx205_tgt, rx205_off
  rx205_start:
    eq $I10, 1, rx205_restart
    if_null rx205_debug, debug_491
    rx205_cur."!cursor_debug"("START", "eat_terminator")
  debug_491:
    $I10 = self.'from'()
    ne $I10, -1, rxscan208_done
    goto rxscan208_scan
  rxscan208_loop:
    (rx205_pos) = rx205_cur."from"()
    inc rx205_pos
    rx205_cur."!cursor_from"(rx205_pos)
    ge rx205_pos, rx205_eos, rxscan208_done
  rxscan208_scan:
    set_addr $I10, rxscan208_loop
    rx205_cur."!mark_push"(0, rx205_pos, $I10)
  rxscan208_done:
  alt209_0:
.annotate 'line', 136
    set_addr $I10, alt209_1
    rx205_cur."!mark_push"(0, rx205_pos, $I10)
.annotate 'line', 137
  # rx literal  ";"
    add $I11, rx205_pos, 1
    gt $I11, rx205_eos, rx205_fail
    sub $I11, rx205_pos, rx205_off
    ord $I11, rx205_tgt, $I11
    ne $I11, 59, rx205_fail
    add rx205_pos, 1
    goto alt209_end
  alt209_1:
    set_addr $I10, alt209_2
    rx205_cur."!mark_push"(0, rx205_pos, $I10)
.annotate 'line', 138
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx205_cur."!cursor_pos"(rx205_pos)
    $P10 = rx205_cur."MARKED"("endstmt")
    unless $P10, rx205_fail
    goto alt209_end
  alt209_2:
    set_addr $I10, alt209_3
    rx205_cur."!mark_push"(0, rx205_pos, $I10)
.annotate 'line', 139
  # rx subrule "terminator" subtype=zerowidth negate=
    rx205_cur."!cursor_pos"(rx205_pos)
    $P10 = rx205_cur."terminator"()
    unless $P10, rx205_fail
    goto alt209_end
  alt209_3:
.annotate 'line', 140
  # rxanchor eos
    ne rx205_pos, rx205_eos, rx205_fail
  alt209_end:
.annotate 'line', 136
  # rx pass
    rx205_cur."!cursor_pass"(rx205_pos, "eat_terminator")
    if_null rx205_debug, debug_492
    rx205_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx205_pos)
  debug_492:
    .return (rx205_cur)
  rx205_restart:
.annotate 'line', 4
    if_null rx205_debug, debug_493
    rx205_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_493:
  rx205_fail:
    (rx205_rep, rx205_pos, $I10, $P10) = rx205_cur."!mark_fail"(0)
    lt rx205_pos, -1, rx205_done
    eq rx205_pos, -1, rx205_fail
    jump $I10
  rx205_done:
    rx205_cur."!cursor_fail"()
    if_null rx205_debug, debug_494
    rx205_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_494:
    .return (rx205_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1300060177.262") :method
.annotate 'line', 4
    new $P207, "ResizablePMCArray"
    push $P207, ""
    push $P207, ""
    push $P207, ""
    push $P207, ";"
    .return ($P207)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx211_tgt
    .local int rx211_pos
    .local int rx211_off
    .local int rx211_eos
    .local int rx211_rep
    .local pmc rx211_cur
    .local pmc rx211_debug
    (rx211_cur, rx211_pos, rx211_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx211_cur
    .local pmc match
    .lex "$/", match
    length rx211_eos, rx211_tgt
    gt rx211_pos, rx211_eos, rx211_done
    set rx211_off, 0
    lt rx211_pos, 2, rx211_start
    sub rx211_off, rx211_pos, 1
    substr rx211_tgt, rx211_tgt, rx211_off
  rx211_start:
    eq $I10, 1, rx211_restart
    if_null rx211_debug, debug_495
    rx211_cur."!cursor_debug"("START", "xblock")
  debug_495:
    $I10 = self.'from'()
    ne $I10, -1, rxscan215_done
    goto rxscan215_scan
  rxscan215_loop:
    (rx211_pos) = rx211_cur."from"()
    inc rx211_pos
    rx211_cur."!cursor_from"(rx211_pos)
    ge rx211_pos, rx211_eos, rxscan215_done
  rxscan215_scan:
    set_addr $I10, rxscan215_loop
    rx211_cur."!mark_push"(0, rx211_pos, $I10)
  rxscan215_done:
.annotate 'line', 144
  # rx subrule "EXPR" subtype=capture negate=
    rx211_cur."!cursor_pos"(rx211_pos)
    $P10 = rx211_cur."EXPR"()
    unless $P10, rx211_fail
    rx211_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx211_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx211_cur."!cursor_pos"(rx211_pos)
    $P10 = rx211_cur."ws"()
    unless $P10, rx211_fail
    rx211_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx211_cur."!cursor_pos"(rx211_pos)
    $P10 = rx211_cur."pblock"()
    unless $P10, rx211_fail
    rx211_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx211_pos = $P10."pos"()
.annotate 'line', 143
  # rx pass
    rx211_cur."!cursor_pass"(rx211_pos, "xblock")
    if_null rx211_debug, debug_496
    rx211_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx211_pos)
  debug_496:
    .return (rx211_cur)
  rx211_restart:
.annotate 'line', 4
    if_null rx211_debug, debug_497
    rx211_cur."!cursor_debug"("NEXT", "xblock")
  debug_497:
  rx211_fail:
    (rx211_rep, rx211_pos, $I10, $P10) = rx211_cur."!mark_fail"(0)
    lt rx211_pos, -1, rx211_done
    eq rx211_pos, -1, rx211_fail
    jump $I10
  rx211_done:
    rx211_cur."!cursor_fail"()
    if_null rx211_debug, debug_498
    rx211_cur."!cursor_debug"("FAIL", "xblock")
  debug_498:
    .return (rx211_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1300060177.262") :method
.annotate 'line', 4
    $P213 = self."!PREFIX__!subrule"("EXPR", "")
    new $P214, "ResizablePMCArray"
    push $P214, $P213
    .return ($P214)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx217_tgt
    .local int rx217_pos
    .local int rx217_off
    .local int rx217_eos
    .local int rx217_rep
    .local pmc rx217_cur
    .local pmc rx217_debug
    (rx217_cur, rx217_pos, rx217_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx217_cur
    .local pmc match
    .lex "$/", match
    length rx217_eos, rx217_tgt
    gt rx217_pos, rx217_eos, rx217_done
    set rx217_off, 0
    lt rx217_pos, 2, rx217_start
    sub rx217_off, rx217_pos, 1
    substr rx217_tgt, rx217_tgt, rx217_off
  rx217_start:
    eq $I10, 1, rx217_restart
    if_null rx217_debug, debug_499
    rx217_cur."!cursor_debug"("START", "pblock")
  debug_499:
    $I10 = self.'from'()
    ne $I10, -1, rxscan222_done
    goto rxscan222_scan
  rxscan222_loop:
    (rx217_pos) = rx217_cur."from"()
    inc rx217_pos
    rx217_cur."!cursor_from"(rx217_pos)
    ge rx217_pos, rx217_eos, rxscan222_done
  rxscan222_scan:
    set_addr $I10, rxscan222_loop
    rx217_cur."!mark_push"(0, rx217_pos, $I10)
  rxscan222_done:
  alt223_0:
.annotate 'line', 147
    set_addr $I10, alt223_1
    rx217_cur."!mark_push"(0, rx217_pos, $I10)
.annotate 'line', 148
  # rx subrule "lambda" subtype=method negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."lambda"()
    unless $P10, rx217_fail
    rx217_pos = $P10."pos"()
.annotate 'line', 149
  # rx subrule "newpad" subtype=method negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."newpad"()
    unless $P10, rx217_fail
    rx217_pos = $P10."pos"()
.annotate 'line', 150
  # rx subrule "signature" subtype=capture negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."signature"()
    unless $P10, rx217_fail
    rx217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx217_pos = $P10."pos"()
.annotate 'line', 151
  # rx subrule "blockoid" subtype=capture negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."blockoid"()
    unless $P10, rx217_fail
    rx217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx217_pos = $P10."pos"()
.annotate 'line', 148
    goto alt223_end
  alt223_1:
    set_addr $I10, alt223_2
    rx217_cur."!mark_push"(0, rx217_pos, $I10)
.annotate 'line', 152
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx217_pos, rx217_off
    substr $S10, rx217_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx217_fail
.annotate 'line', 153
  # rx subrule "newpad" subtype=method negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."newpad"()
    unless $P10, rx217_fail
    rx217_pos = $P10."pos"()
.annotate 'line', 154
  # rx subrule "blockoid" subtype=capture negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."blockoid"()
    unless $P10, rx217_fail
    rx217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx217_pos = $P10."pos"()
.annotate 'line', 152
    goto alt223_end
  alt223_2:
.annotate 'line', 155
  # rx subrule "panic" subtype=method negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."panic"("Missing block")
    unless $P10, rx217_fail
    rx217_pos = $P10."pos"()
  alt223_end:
.annotate 'line', 147
  # rx pass
    rx217_cur."!cursor_pass"(rx217_pos, "pblock")
    if_null rx217_debug, debug_500
    rx217_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx217_pos)
  debug_500:
    .return (rx217_cur)
  rx217_restart:
.annotate 'line', 4
    if_null rx217_debug, debug_501
    rx217_cur."!cursor_debug"("NEXT", "pblock")
  debug_501:
  rx217_fail:
    (rx217_rep, rx217_pos, $I10, $P10) = rx217_cur."!mark_fail"(0)
    lt rx217_pos, -1, rx217_done
    eq rx217_pos, -1, rx217_fail
    jump $I10
  rx217_done:
    rx217_cur."!cursor_fail"()
    if_null rx217_debug, debug_502
    rx217_cur."!cursor_debug"("FAIL", "pblock")
  debug_502:
    .return (rx217_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1300060177.262") :method
.annotate 'line', 4
    $P219 = self."!PREFIX__!subrule"("panic", "")
    $P220 = self."!PREFIX__!subrule"("lambda", "")
    new $P221, "ResizablePMCArray"
    push $P221, $P219
    push $P221, "{"
    push $P221, $P220
    .return ($P221)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx225_tgt
    .local int rx225_pos
    .local int rx225_off
    .local int rx225_eos
    .local int rx225_rep
    .local pmc rx225_cur
    .local pmc rx225_debug
    (rx225_cur, rx225_pos, rx225_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx225_cur
    .local pmc match
    .lex "$/", match
    length rx225_eos, rx225_tgt
    gt rx225_pos, rx225_eos, rx225_done
    set rx225_off, 0
    lt rx225_pos, 2, rx225_start
    sub rx225_off, rx225_pos, 1
    substr rx225_tgt, rx225_tgt, rx225_off
  rx225_start:
    eq $I10, 1, rx225_restart
    if_null rx225_debug, debug_503
    rx225_cur."!cursor_debug"("START", "lambda")
  debug_503:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    (rx225_pos) = rx225_cur."from"()
    inc rx225_pos
    rx225_cur."!cursor_from"(rx225_pos)
    ge rx225_pos, rx225_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
  rxscan228_done:
  alt229_0:
.annotate 'line', 158
    set_addr $I10, alt229_1
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
  # rx literal  "->"
    add $I11, rx225_pos, 2
    gt $I11, rx225_eos, rx225_fail
    sub $I11, rx225_pos, rx225_off
    substr $S10, rx225_tgt, $I11, 2
    ne $S10, "->", rx225_fail
    add rx225_pos, 2
    goto alt229_end
  alt229_1:
  # rx literal  "<->"
    add $I11, rx225_pos, 3
    gt $I11, rx225_eos, rx225_fail
    sub $I11, rx225_pos, rx225_off
    substr $S10, rx225_tgt, $I11, 3
    ne $S10, "<->", rx225_fail
    add rx225_pos, 3
  alt229_end:
  # rx pass
    rx225_cur."!cursor_pass"(rx225_pos, "lambda")
    if_null rx225_debug, debug_504
    rx225_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx225_pos)
  debug_504:
    .return (rx225_cur)
  rx225_restart:
.annotate 'line', 4
    if_null rx225_debug, debug_505
    rx225_cur."!cursor_debug"("NEXT", "lambda")
  debug_505:
  rx225_fail:
    (rx225_rep, rx225_pos, $I10, $P10) = rx225_cur."!mark_fail"(0)
    lt rx225_pos, -1, rx225_done
    eq rx225_pos, -1, rx225_fail
    jump $I10
  rx225_done:
    rx225_cur."!cursor_fail"()
    if_null rx225_debug, debug_506
    rx225_cur."!cursor_debug"("FAIL", "lambda")
  debug_506:
    .return (rx225_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1300060177.262") :method
.annotate 'line', 4
    new $P227, "ResizablePMCArray"
    push $P227, "<->"
    push $P227, "->"
    .return ($P227)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_507
    rx231_cur."!cursor_debug"("START", "block")
  debug_507:
    $I10 = self.'from'()
    ne $I10, -1, rxscan235_done
    goto rxscan235_scan
  rxscan235_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan235_done
  rxscan235_scan:
    set_addr $I10, rxscan235_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan235_done:
  alt236_0:
.annotate 'line', 161
    set_addr $I10, alt236_1
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx231_pos, rx231_off
    substr $S10, rx231_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx231_fail
    goto alt236_end
  alt236_1:
  # rx subrule "panic" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."panic"("Missing block")
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
  alt236_end:
.annotate 'line', 162
  # rx subrule "newpad" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."newpad"()
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
.annotate 'line', 163
  # rx subrule "blockoid" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."blockoid"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx231_pos = $P10."pos"()
.annotate 'line', 160
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "block")
    if_null rx231_debug, debug_508
    rx231_cur."!cursor_debug"("PASS", "block", " at pos=", rx231_pos)
  debug_508:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 4
    if_null rx231_debug, debug_509
    rx231_cur."!cursor_debug"("NEXT", "block")
  debug_509:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_510
    rx231_cur."!cursor_debug"("FAIL", "block")
  debug_510:
    .return (rx231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1300060177.262") :method
.annotate 'line', 4
    $P233 = self."!PREFIX__!subrule"("panic", "")
    new $P234, "ResizablePMCArray"
    push $P234, $P233
    push $P234, "{"
    .return ($P234)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx238_tgt
    .local int rx238_pos
    .local int rx238_off
    .local int rx238_eos
    .local int rx238_rep
    .local pmc rx238_cur
    .local pmc rx238_debug
    (rx238_cur, rx238_pos, rx238_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx238_cur
    .local pmc match
    .lex "$/", match
    length rx238_eos, rx238_tgt
    gt rx238_pos, rx238_eos, rx238_done
    set rx238_off, 0
    lt rx238_pos, 2, rx238_start
    sub rx238_off, rx238_pos, 1
    substr rx238_tgt, rx238_tgt, rx238_off
  rx238_start:
    eq $I10, 1, rx238_restart
    if_null rx238_debug, debug_511
    rx238_cur."!cursor_debug"("START", "blockoid")
  debug_511:
    $I10 = self.'from'()
    ne $I10, -1, rxscan242_done
    goto rxscan242_scan
  rxscan242_loop:
    (rx238_pos) = rx238_cur."from"()
    inc rx238_pos
    rx238_cur."!cursor_from"(rx238_pos)
    ge rx238_pos, rx238_eos, rxscan242_done
  rxscan242_scan:
    set_addr $I10, rxscan242_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  rxscan242_done:
.annotate 'line', 167
  # rx subrule "finishpad" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."finishpad"()
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  alt243_0:
.annotate 'line', 168
    set_addr $I10, alt243_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 169
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx238_pos, 14
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx238_fail
    add rx238_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."you_are_here"()
    unless $P10, rx238_fail
    rx238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx238_pos = $P10."pos"()
    goto alt243_end
  alt243_1:
.annotate 'line', 170
  # rx literal  "{"
    add $I11, rx238_pos, 1
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    ord $I11, rx238_tgt, $I11
    ne $I11, 123, rx238_fail
    add rx238_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."statementlist"()
    unless $P10, rx238_fail
    rx238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx238_pos = $P10."pos"()
  alt244_0:
    set_addr $I10, alt244_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rx literal  "}"
    add $I11, rx238_pos, 1
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    ord $I11, rx238_tgt, $I11
    ne $I11, 125, rx238_fail
    add rx238_pos, 1
    goto alt244_end
  alt244_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."FAILGOAL"("'}'")
    unless $P10, rx238_fail
    goto rxsubrule246_pass
  rxsubrule246_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx238_fail
  rxsubrule246_pass:
    set_addr $I10, rxsubrule246_back
    rx238_cur."!mark_push"(0, rx238_pos, $I10, $P10)
    rx238_pos = $P10."pos"()
  alt244_end:
  alt243_end:
.annotate 'line', 172
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."ENDSTMT"()
    unless $P10, rx238_fail
.annotate 'line', 166
  # rx pass
    rx238_cur."!cursor_pass"(rx238_pos, "blockoid")
    if_null rx238_debug, debug_512
    rx238_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx238_pos)
  debug_512:
    .return (rx238_cur)
  rx238_restart:
.annotate 'line', 4
    if_null rx238_debug, debug_513
    rx238_cur."!cursor_debug"("NEXT", "blockoid")
  debug_513:
  rx238_fail:
    (rx238_rep, rx238_pos, $I10, $P10) = rx238_cur."!mark_fail"(0)
    lt rx238_pos, -1, rx238_done
    eq rx238_pos, -1, rx238_fail
    jump $I10
  rx238_done:
    rx238_cur."!cursor_fail"()
    if_null rx238_debug, debug_514
    rx238_cur."!cursor_debug"("FAIL", "blockoid")
  debug_514:
    .return (rx238_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1300060177.262") :method
.annotate 'line', 4
    $P240 = self."!PREFIX__!subrule"("finishpad", "")
    new $P241, "ResizablePMCArray"
    push $P241, $P240
    .return ($P241)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx248_tgt
    .local int rx248_pos
    .local int rx248_off
    .local int rx248_eos
    .local int rx248_rep
    .local pmc rx248_cur
    .local pmc rx248_debug
    (rx248_cur, rx248_pos, rx248_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx248_cur
    .local pmc match
    .lex "$/", match
    length rx248_eos, rx248_tgt
    gt rx248_pos, rx248_eos, rx248_done
    set rx248_off, 0
    lt rx248_pos, 2, rx248_start
    sub rx248_off, rx248_pos, 1
    substr rx248_tgt, rx248_tgt, rx248_off
  rx248_start:
    eq $I10, 1, rx248_restart
    if_null rx248_debug, debug_515
    rx248_cur."!cursor_debug"("START", "newpad")
  debug_515:
    $I10 = self.'from'()
    ne $I10, -1, rxscan251_done
    goto rxscan251_scan
  rxscan251_loop:
    (rx248_pos) = rx248_cur."from"()
    inc rx248_pos
    rx248_cur."!cursor_from"(rx248_pos)
    ge rx248_pos, rx248_eos, rxscan251_done
  rxscan251_scan:
    set_addr $I10, rxscan251_loop
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
  rxscan251_done:
.annotate 'line', 175
  # rx pass
    rx248_cur."!cursor_pass"(rx248_pos, "newpad")
    if_null rx248_debug, debug_516
    rx248_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx248_pos)
  debug_516:
    .return (rx248_cur)
  rx248_restart:
.annotate 'line', 4
    if_null rx248_debug, debug_517
    rx248_cur."!cursor_debug"("NEXT", "newpad")
  debug_517:
  rx248_fail:
    (rx248_rep, rx248_pos, $I10, $P10) = rx248_cur."!mark_fail"(0)
    lt rx248_pos, -1, rx248_done
    eq rx248_pos, -1, rx248_fail
    jump $I10
  rx248_done:
    rx248_cur."!cursor_fail"()
    if_null rx248_debug, debug_518
    rx248_cur."!cursor_debug"("FAIL", "newpad")
  debug_518:
    .return (rx248_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1300060177.262") :method
.annotate 'line', 4
    new $P250, "ResizablePMCArray"
    push $P250, ""
    .return ($P250)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx253_tgt
    .local int rx253_pos
    .local int rx253_off
    .local int rx253_eos
    .local int rx253_rep
    .local pmc rx253_cur
    .local pmc rx253_debug
    (rx253_cur, rx253_pos, rx253_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx253_cur
    .local pmc match
    .lex "$/", match
    length rx253_eos, rx253_tgt
    gt rx253_pos, rx253_eos, rx253_done
    set rx253_off, 0
    lt rx253_pos, 2, rx253_start
    sub rx253_off, rx253_pos, 1
    substr rx253_tgt, rx253_tgt, rx253_off
  rx253_start:
    eq $I10, 1, rx253_restart
    if_null rx253_debug, debug_519
    rx253_cur."!cursor_debug"("START", "outerctx")
  debug_519:
    $I10 = self.'from'()
    ne $I10, -1, rxscan256_done
    goto rxscan256_scan
  rxscan256_loop:
    (rx253_pos) = rx253_cur."from"()
    inc rx253_pos
    rx253_cur."!cursor_from"(rx253_pos)
    ge rx253_pos, rx253_eos, rxscan256_done
  rxscan256_scan:
    set_addr $I10, rxscan256_loop
    rx253_cur."!mark_push"(0, rx253_pos, $I10)
  rxscan256_done:
.annotate 'line', 176
  # rx pass
    rx253_cur."!cursor_pass"(rx253_pos, "outerctx")
    if_null rx253_debug, debug_520
    rx253_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx253_pos)
  debug_520:
    .return (rx253_cur)
  rx253_restart:
.annotate 'line', 4
    if_null rx253_debug, debug_521
    rx253_cur."!cursor_debug"("NEXT", "outerctx")
  debug_521:
  rx253_fail:
    (rx253_rep, rx253_pos, $I10, $P10) = rx253_cur."!mark_fail"(0)
    lt rx253_pos, -1, rx253_done
    eq rx253_pos, -1, rx253_fail
    jump $I10
  rx253_done:
    rx253_cur."!cursor_fail"()
    if_null rx253_debug, debug_522
    rx253_cur."!cursor_debug"("FAIL", "outerctx")
  debug_522:
    .return (rx253_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1300060177.262") :method
.annotate 'line', 4
    new $P255, "ResizablePMCArray"
    push $P255, ""
    .return ($P255)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx258_tgt
    .local int rx258_pos
    .local int rx258_off
    .local int rx258_eos
    .local int rx258_rep
    .local pmc rx258_cur
    .local pmc rx258_debug
    (rx258_cur, rx258_pos, rx258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx258_cur
    .local pmc match
    .lex "$/", match
    length rx258_eos, rx258_tgt
    gt rx258_pos, rx258_eos, rx258_done
    set rx258_off, 0
    lt rx258_pos, 2, rx258_start
    sub rx258_off, rx258_pos, 1
    substr rx258_tgt, rx258_tgt, rx258_off
  rx258_start:
    eq $I10, 1, rx258_restart
    if_null rx258_debug, debug_523
    rx258_cur."!cursor_debug"("START", "finishpad")
  debug_523:
    $I10 = self.'from'()
    ne $I10, -1, rxscan261_done
    goto rxscan261_scan
  rxscan261_loop:
    (rx258_pos) = rx258_cur."from"()
    inc rx258_pos
    rx258_cur."!cursor_from"(rx258_pos)
    ge rx258_pos, rx258_eos, rxscan261_done
  rxscan261_scan:
    set_addr $I10, rxscan261_loop
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
  rxscan261_done:
.annotate 'line', 177
  # rx pass
    rx258_cur."!cursor_pass"(rx258_pos, "finishpad")
    if_null rx258_debug, debug_524
    rx258_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx258_pos)
  debug_524:
    .return (rx258_cur)
  rx258_restart:
.annotate 'line', 4
    if_null rx258_debug, debug_525
    rx258_cur."!cursor_debug"("NEXT", "finishpad")
  debug_525:
  rx258_fail:
    (rx258_rep, rx258_pos, $I10, $P10) = rx258_cur."!mark_fail"(0)
    lt rx258_pos, -1, rx258_done
    eq rx258_pos, -1, rx258_fail
    jump $I10
  rx258_done:
    rx258_cur."!cursor_fail"()
    if_null rx258_debug, debug_526
    rx258_cur."!cursor_debug"("FAIL", "finishpad")
  debug_526:
    .return (rx258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1300060177.262") :method
.annotate 'line', 4
    new $P260, "ResizablePMCArray"
    push $P260, ""
    .return ($P260)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("54_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx263_tgt
    .local int rx263_pos
    .local int rx263_off
    .local int rx263_eos
    .local int rx263_rep
    .local pmc rx263_cur
    .local pmc rx263_debug
    (rx263_cur, rx263_pos, rx263_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx263_cur
    .local pmc match
    .lex "$/", match
    length rx263_eos, rx263_tgt
    gt rx263_pos, rx263_eos, rx263_done
    set rx263_off, 0
    lt rx263_pos, 2, rx263_start
    sub rx263_off, rx263_pos, 1
    substr rx263_tgt, rx263_tgt, rx263_off
  rx263_start:
    eq $I10, 1, rx263_restart
    if_null rx263_debug, debug_527
    rx263_cur."!cursor_debug"("START", "you_are_here")
  debug_527:
    $I10 = self.'from'()
    ne $I10, -1, rxscan266_done
    goto rxscan266_scan
  rxscan266_loop:
    (rx263_pos) = rx263_cur."from"()
    inc rx263_pos
    rx263_cur."!cursor_from"(rx263_pos)
    ge rx263_pos, rx263_eos, rxscan266_done
  rxscan266_scan:
    set_addr $I10, rxscan266_loop
    rx263_cur."!mark_push"(0, rx263_pos, $I10)
  rxscan266_done:
.annotate 'line', 178
  # rx pass
    rx263_cur."!cursor_pass"(rx263_pos, "you_are_here")
    if_null rx263_debug, debug_528
    rx263_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx263_pos)
  debug_528:
    .return (rx263_cur)
  rx263_restart:
.annotate 'line', 4
    if_null rx263_debug, debug_529
    rx263_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_529:
  rx263_fail:
    (rx263_rep, rx263_pos, $I10, $P10) = rx263_cur."!mark_fail"(0)
    lt rx263_pos, -1, rx263_done
    eq rx263_pos, -1, rx263_fail
    jump $I10
  rx263_done:
    rx263_cur."!cursor_fail"()
    if_null rx263_debug, debug_530
    rx263_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_530:
    .return (rx263_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("55_1300060177.262") :method
.annotate 'line', 4
    new $P265, "ResizablePMCArray"
    push $P265, ""
    .return ($P265)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("56_1300060177.262")
    .param pmc param_268
.annotate 'line', 180
    .lex "self", param_268
    $P269 = param_268."!protoregex"("terminator")
    .return ($P269)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("57_1300060177.262")
    .param pmc param_271
.annotate 'line', 180
    .lex "self", param_271
    $P272 = param_271."!PREFIX__!protoregex"("terminator")
    .return ($P272)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("58_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx274_tgt
    .local int rx274_pos
    .local int rx274_off
    .local int rx274_eos
    .local int rx274_rep
    .local pmc rx274_cur
    .local pmc rx274_debug
    (rx274_cur, rx274_pos, rx274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx274_cur
    .local pmc match
    .lex "$/", match
    length rx274_eos, rx274_tgt
    gt rx274_pos, rx274_eos, rx274_done
    set rx274_off, 0
    lt rx274_pos, 2, rx274_start
    sub rx274_off, rx274_pos, 1
    substr rx274_tgt, rx274_tgt, rx274_off
  rx274_start:
    eq $I10, 1, rx274_restart
    if_null rx274_debug, debug_531
    rx274_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_531:
    $I10 = self.'from'()
    ne $I10, -1, rxscan277_done
    goto rxscan277_scan
  rxscan277_loop:
    (rx274_pos) = rx274_cur."from"()
    inc rx274_pos
    rx274_cur."!cursor_from"(rx274_pos)
    ge rx274_pos, rx274_eos, rxscan277_done
  rxscan277_scan:
    set_addr $I10, rxscan277_loop
    rx274_cur."!mark_push"(0, rx274_pos, $I10)
  rxscan277_done:
.annotate 'line', 182
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx274_pos, rx274_off
    substr $S10, rx274_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx274_fail
  # rx pass
    rx274_cur."!cursor_pass"(rx274_pos, "terminator:sym<;>")
    if_null rx274_debug, debug_532
    rx274_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx274_pos)
  debug_532:
    .return (rx274_cur)
  rx274_restart:
.annotate 'line', 4
    if_null rx274_debug, debug_533
    rx274_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_533:
  rx274_fail:
    (rx274_rep, rx274_pos, $I10, $P10) = rx274_cur."!mark_fail"(0)
    lt rx274_pos, -1, rx274_done
    eq rx274_pos, -1, rx274_fail
    jump $I10
  rx274_done:
    rx274_cur."!cursor_fail"()
    if_null rx274_debug, debug_534
    rx274_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_534:
    .return (rx274_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("59_1300060177.262") :method
.annotate 'line', 4
    new $P276, "ResizablePMCArray"
    push $P276, ";"
    .return ($P276)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("60_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx279_tgt
    .local int rx279_pos
    .local int rx279_off
    .local int rx279_eos
    .local int rx279_rep
    .local pmc rx279_cur
    .local pmc rx279_debug
    (rx279_cur, rx279_pos, rx279_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx279_cur
    .local pmc match
    .lex "$/", match
    length rx279_eos, rx279_tgt
    gt rx279_pos, rx279_eos, rx279_done
    set rx279_off, 0
    lt rx279_pos, 2, rx279_start
    sub rx279_off, rx279_pos, 1
    substr rx279_tgt, rx279_tgt, rx279_off
  rx279_start:
    eq $I10, 1, rx279_restart
    if_null rx279_debug, debug_535
    rx279_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_535:
    $I10 = self.'from'()
    ne $I10, -1, rxscan282_done
    goto rxscan282_scan
  rxscan282_loop:
    (rx279_pos) = rx279_cur."from"()
    inc rx279_pos
    rx279_cur."!cursor_from"(rx279_pos)
    ge rx279_pos, rx279_eos, rxscan282_done
  rxscan282_scan:
    set_addr $I10, rxscan282_loop
    rx279_cur."!mark_push"(0, rx279_pos, $I10)
  rxscan282_done:
.annotate 'line', 183
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx279_pos, rx279_off
    substr $S10, rx279_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx279_fail
  # rx pass
    rx279_cur."!cursor_pass"(rx279_pos, "terminator:sym<}>")
    if_null rx279_debug, debug_536
    rx279_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx279_pos)
  debug_536:
    .return (rx279_cur)
  rx279_restart:
.annotate 'line', 4
    if_null rx279_debug, debug_537
    rx279_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_537:
  rx279_fail:
    (rx279_rep, rx279_pos, $I10, $P10) = rx279_cur."!mark_fail"(0)
    lt rx279_pos, -1, rx279_done
    eq rx279_pos, -1, rx279_fail
    jump $I10
  rx279_done:
    rx279_cur."!cursor_fail"()
    if_null rx279_debug, debug_538
    rx279_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_538:
    .return (rx279_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("61_1300060177.262") :method
.annotate 'line', 4
    new $P281, "ResizablePMCArray"
    push $P281, "}"
    .return ($P281)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("62_1300060177.262")
    .param pmc param_284
.annotate 'line', 187
    .lex "self", param_284
    $P285 = param_284."!protoregex"("statement_control")
    .return ($P285)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("63_1300060177.262")
    .param pmc param_287
.annotate 'line', 187
    .lex "self", param_287
    $P288 = param_287."!PREFIX__!protoregex"("statement_control")
    .return ($P288)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("64_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx290_tgt
    .local int rx290_pos
    .local int rx290_off
    .local int rx290_eos
    .local int rx290_rep
    .local pmc rx290_cur
    .local pmc rx290_debug
    (rx290_cur, rx290_pos, rx290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx290_cur
    .local pmc match
    .lex "$/", match
    length rx290_eos, rx290_tgt
    gt rx290_pos, rx290_eos, rx290_done
    set rx290_off, 0
    lt rx290_pos, 2, rx290_start
    sub rx290_off, rx290_pos, 1
    substr rx290_tgt, rx290_tgt, rx290_off
  rx290_start:
    eq $I10, 1, rx290_restart
    if_null rx290_debug, debug_539
    rx290_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_539:
    $I10 = self.'from'()
    ne $I10, -1, rxscan293_done
    goto rxscan293_scan
  rxscan293_loop:
    (rx290_pos) = rx290_cur."from"()
    inc rx290_pos
    rx290_cur."!cursor_from"(rx290_pos)
    ge rx290_pos, rx290_eos, rxscan293_done
  rxscan293_scan:
    set_addr $I10, rxscan293_loop
    rx290_cur."!mark_push"(0, rx290_pos, $I10)
  rxscan293_done:
.annotate 'line', 190
  # rx subcapture "sym"
    set_addr $I10, rxcap_294_fail
    rx290_cur."!mark_push"(0, rx290_pos, $I10)
  # rx literal  "use"
    add $I11, rx290_pos, 3
    gt $I11, rx290_eos, rx290_fail
    sub $I11, rx290_pos, rx290_off
    substr $S10, rx290_tgt, $I11, 3
    ne $S10, "use", rx290_fail
    add rx290_pos, 3
    set_addr $I10, rxcap_294_fail
    ($I12, $I11) = rx290_cur."!mark_peek"($I10)
    rx290_cur."!cursor_pos"($I11)
    ($P10) = rx290_cur."!cursor_start"()
    $P10."!cursor_pass"(rx290_pos, "")
    rx290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_294_done
  rxcap_294_fail:
    goto rx290_fail
  rxcap_294_done:
  # rx charclass s
    ge rx290_pos, rx290_eos, rx290_fail
    sub $I10, rx290_pos, rx290_off
    is_cclass $I11, 32, rx290_tgt, $I10
    unless $I11, rx290_fail
    inc rx290_pos
  # rx subrule "ws" subtype=method negate=
    rx290_cur."!cursor_pos"(rx290_pos)
    $P10 = rx290_cur."ws"()
    unless $P10, rx290_fail
    rx290_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx290_cur."!cursor_pos"(rx290_pos)
    $P10 = rx290_cur."name"()
    unless $P10, rx290_fail
    rx290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx290_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx290_cur."!cursor_pos"(rx290_pos)
    $P10 = rx290_cur."ws"()
    unless $P10, rx290_fail
    rx290_pos = $P10."pos"()
.annotate 'line', 189
  # rx pass
    rx290_cur."!cursor_pass"(rx290_pos, "statement_control:sym<use>")
    if_null rx290_debug, debug_540
    rx290_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx290_pos)
  debug_540:
    .return (rx290_cur)
  rx290_restart:
.annotate 'line', 4
    if_null rx290_debug, debug_541
    rx290_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_541:
  rx290_fail:
    (rx290_rep, rx290_pos, $I10, $P10) = rx290_cur."!mark_fail"(0)
    lt rx290_pos, -1, rx290_done
    eq rx290_pos, -1, rx290_fail
    jump $I10
  rx290_done:
    rx290_cur."!cursor_fail"()
    if_null rx290_debug, debug_542
    rx290_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_542:
    .return (rx290_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("65_1300060177.262") :method
.annotate 'line', 4
    new $P292, "ResizablePMCArray"
    push $P292, "use"
    .return ($P292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("66_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx298_tgt
    .local int rx298_pos
    .local int rx298_off
    .local int rx298_eos
    .local int rx298_rep
    .local pmc rx298_cur
    .local pmc rx298_debug
    (rx298_cur, rx298_pos, rx298_tgt, $I10) = self."!cursor_start"()
    rx298_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx298_cur
    .local pmc match
    .lex "$/", match
    length rx298_eos, rx298_tgt
    gt rx298_pos, rx298_eos, rx298_done
    set rx298_off, 0
    lt rx298_pos, 2, rx298_start
    sub rx298_off, rx298_pos, 1
    substr rx298_tgt, rx298_tgt, rx298_off
  rx298_start:
    eq $I10, 1, rx298_restart
    if_null rx298_debug, debug_543
    rx298_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_543:
    $I10 = self.'from'()
    ne $I10, -1, rxscan301_done
    goto rxscan301_scan
  rxscan301_loop:
    (rx298_pos) = rx298_cur."from"()
    inc rx298_pos
    rx298_cur."!cursor_from"(rx298_pos)
    ge rx298_pos, rx298_eos, rxscan301_done
  rxscan301_scan:
    set_addr $I10, rxscan301_loop
    rx298_cur."!mark_push"(0, rx298_pos, $I10)
  rxscan301_done:
.annotate 'line', 194
  # rx subcapture "sym"
    set_addr $I10, rxcap_302_fail
    rx298_cur."!mark_push"(0, rx298_pos, $I10)
  # rx literal  "if"
    add $I11, rx298_pos, 2
    gt $I11, rx298_eos, rx298_fail
    sub $I11, rx298_pos, rx298_off
    substr $S10, rx298_tgt, $I11, 2
    ne $S10, "if", rx298_fail
    add rx298_pos, 2
    set_addr $I10, rxcap_302_fail
    ($I12, $I11) = rx298_cur."!mark_peek"($I10)
    rx298_cur."!cursor_pos"($I11)
    ($P10) = rx298_cur."!cursor_start"()
    $P10."!cursor_pass"(rx298_pos, "")
    rx298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_302_done
  rxcap_302_fail:
    goto rx298_fail
  rxcap_302_done:
  # rx charclass s
    ge rx298_pos, rx298_eos, rx298_fail
    sub $I10, rx298_pos, rx298_off
    is_cclass $I11, 32, rx298_tgt, $I10
    unless $I11, rx298_fail
    inc rx298_pos
  # rx subrule "ws" subtype=method negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."ws"()
    unless $P10, rx298_fail
    rx298_pos = $P10."pos"()
.annotate 'line', 195
  # rx subrule "xblock" subtype=capture negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."xblock"()
    unless $P10, rx298_fail
    rx298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx298_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."ws"()
    unless $P10, rx298_fail
    rx298_pos = $P10."pos"()
.annotate 'line', 196
  # rx rxquantr305 ** 0..*
    set_addr $I10, rxquantr305_done
    rx298_cur."!mark_push"(0, rx298_pos, $I10)
  rxquantr305_loop:
  # rx subrule "ws" subtype=method negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."ws"()
    unless $P10, rx298_fail
    rx298_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx298_pos, 5
    gt $I11, rx298_eos, rx298_fail
    sub $I11, rx298_pos, rx298_off
    substr $S10, rx298_tgt, $I11, 5
    ne $S10, "elsif", rx298_fail
    add rx298_pos, 5
  # rx charclass s
    ge rx298_pos, rx298_eos, rx298_fail
    sub $I10, rx298_pos, rx298_off
    is_cclass $I11, 32, rx298_tgt, $I10
    unless $I11, rx298_fail
    inc rx298_pos
  # rx subrule "ws" subtype=method negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."ws"()
    unless $P10, rx298_fail
    rx298_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."xblock"()
    unless $P10, rx298_fail
    rx298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx298_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."ws"()
    unless $P10, rx298_fail
    rx298_pos = $P10."pos"()
    set_addr $I10, rxquantr305_done
    (rx298_rep) = rx298_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr305_done
    rx298_cur."!mark_push"(rx298_rep, rx298_pos, $I10)
    goto rxquantr305_loop
  rxquantr305_done:
  # rx subrule "ws" subtype=method negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."ws"()
    unless $P10, rx298_fail
    rx298_pos = $P10."pos"()
.annotate 'line', 197
  # rx rxquantr310 ** 0..1
    set_addr $I10, rxquantr310_done
    rx298_cur."!mark_push"(0, rx298_pos, $I10)
  rxquantr310_loop:
  # rx subrule "ws" subtype=method negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."ws"()
    unless $P10, rx298_fail
    rx298_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx298_pos, 4
    gt $I11, rx298_eos, rx298_fail
    sub $I11, rx298_pos, rx298_off
    substr $S10, rx298_tgt, $I11, 4
    ne $S10, "else", rx298_fail
    add rx298_pos, 4
  # rx charclass s
    ge rx298_pos, rx298_eos, rx298_fail
    sub $I10, rx298_pos, rx298_off
    is_cclass $I11, 32, rx298_tgt, $I10
    unless $I11, rx298_fail
    inc rx298_pos
  # rx subrule "ws" subtype=method negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."ws"()
    unless $P10, rx298_fail
    rx298_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."pblock"()
    unless $P10, rx298_fail
    rx298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx298_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."ws"()
    unless $P10, rx298_fail
    rx298_pos = $P10."pos"()
    set_addr $I10, rxquantr310_done
    (rx298_rep) = rx298_cur."!mark_commit"($I10)
  rxquantr310_done:
  # rx subrule "ws" subtype=method negate=
    rx298_cur."!cursor_pos"(rx298_pos)
    $P10 = rx298_cur."ws"()
    unless $P10, rx298_fail
    rx298_pos = $P10."pos"()
.annotate 'line', 193
  # rx pass
    rx298_cur."!cursor_pass"(rx298_pos, "statement_control:sym<if>")
    if_null rx298_debug, debug_544
    rx298_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx298_pos)
  debug_544:
    .return (rx298_cur)
  rx298_restart:
.annotate 'line', 4
    if_null rx298_debug, debug_545
    rx298_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_545:
  rx298_fail:
    (rx298_rep, rx298_pos, $I10, $P10) = rx298_cur."!mark_fail"(0)
    lt rx298_pos, -1, rx298_done
    eq rx298_pos, -1, rx298_fail
    jump $I10
  rx298_done:
    rx298_cur."!cursor_fail"()
    if_null rx298_debug, debug_546
    rx298_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_546:
    .return (rx298_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("67_1300060177.262") :method
.annotate 'line', 4
    new $P300, "ResizablePMCArray"
    push $P300, "if"
    .return ($P300)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("68_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P326 = "70_1300060177.262" 
    capture_lex $P326
    .local string rx316_tgt
    .local int rx316_pos
    .local int rx316_off
    .local int rx316_eos
    .local int rx316_rep
    .local pmc rx316_cur
    .local pmc rx316_debug
    (rx316_cur, rx316_pos, rx316_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx316_cur
    .local pmc match
    .lex "$/", match
    length rx316_eos, rx316_tgt
    gt rx316_pos, rx316_eos, rx316_done
    set rx316_off, 0
    lt rx316_pos, 2, rx316_start
    sub rx316_off, rx316_pos, 1
    substr rx316_tgt, rx316_tgt, rx316_off
  rx316_start:
    eq $I10, 1, rx316_restart
    if_null rx316_debug, debug_547
    rx316_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_547:
    $I10 = self.'from'()
    ne $I10, -1, rxscan319_done
    goto rxscan319_scan
  rxscan319_loop:
    (rx316_pos) = rx316_cur."from"()
    inc rx316_pos
    rx316_cur."!cursor_from"(rx316_pos)
    ge rx316_pos, rx316_eos, rxscan319_done
  rxscan319_scan:
    set_addr $I10, rxscan319_loop
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
  rxscan319_done:
.annotate 'line', 201
  # rx subcapture "sym"
    set_addr $I10, rxcap_320_fail
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
  # rx literal  "unless"
    add $I11, rx316_pos, 6
    gt $I11, rx316_eos, rx316_fail
    sub $I11, rx316_pos, rx316_off
    substr $S10, rx316_tgt, $I11, 6
    ne $S10, "unless", rx316_fail
    add rx316_pos, 6
    set_addr $I10, rxcap_320_fail
    ($I12, $I11) = rx316_cur."!mark_peek"($I10)
    rx316_cur."!cursor_pos"($I11)
    ($P10) = rx316_cur."!cursor_start"()
    $P10."!cursor_pass"(rx316_pos, "")
    rx316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_320_done
  rxcap_320_fail:
    goto rx316_fail
  rxcap_320_done:
  # rx charclass s
    ge rx316_pos, rx316_eos, rx316_fail
    sub $I10, rx316_pos, rx316_off
    is_cclass $I11, 32, rx316_tgt, $I10
    unless $I11, rx316_fail
    inc rx316_pos
  # rx subrule "ws" subtype=method negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."ws"()
    unless $P10, rx316_fail
    rx316_pos = $P10."pos"()
.annotate 'line', 202
  # rx subrule "xblock" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."xblock"()
    unless $P10, rx316_fail
    rx316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx316_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."ws"()
    unless $P10, rx316_fail
    rx316_pos = $P10."pos"()
  alt323_0:
.annotate 'line', 203
    set_addr $I10, alt323_1
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."ws"()
    unless $P10, rx316_fail
    rx316_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx316_cur."!cursor_pos"(rx316_pos)
    .const 'Sub' $P326 = "70_1300060177.262" 
    capture_lex $P326
    $P10 = rx316_cur."before"($P326)
    if $P10, rx316_fail
  # rx subrule "ws" subtype=method negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."ws"()
    unless $P10, rx316_fail
    rx316_pos = $P10."pos"()
    goto alt323_end
  alt323_1:
  # rx subrule "ws" subtype=method negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."ws"()
    unless $P10, rx316_fail
    rx316_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx316_fail
    rx316_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."ws"()
    unless $P10, rx316_fail
    rx316_pos = $P10."pos"()
  alt323_end:
  # rx subrule "ws" subtype=method negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."ws"()
    unless $P10, rx316_fail
    rx316_pos = $P10."pos"()
.annotate 'line', 200
  # rx pass
    rx316_cur."!cursor_pass"(rx316_pos, "statement_control:sym<unless>")
    if_null rx316_debug, debug_552
    rx316_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx316_pos)
  debug_552:
    .return (rx316_cur)
  rx316_restart:
.annotate 'line', 4
    if_null rx316_debug, debug_553
    rx316_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_553:
  rx316_fail:
    (rx316_rep, rx316_pos, $I10, $P10) = rx316_cur."!mark_fail"(0)
    lt rx316_pos, -1, rx316_done
    eq rx316_pos, -1, rx316_fail
    jump $I10
  rx316_done:
    rx316_cur."!cursor_fail"()
    if_null rx316_debug, debug_554
    rx316_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_554:
    .return (rx316_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("69_1300060177.262") :method
.annotate 'line', 4
    new $P318, "ResizablePMCArray"
    push $P318, "unless"
    .return ($P318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block325"  :anon :subid("70_1300060177.262") :method :outer("68_1300060177.262")
.annotate 'line', 203
    .local string rx327_tgt
    .local int rx327_pos
    .local int rx327_off
    .local int rx327_eos
    .local int rx327_rep
    .local pmc rx327_cur
    .local pmc rx327_debug
    (rx327_cur, rx327_pos, rx327_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx327_cur
    .local pmc match
    .lex "$/", match
    length rx327_eos, rx327_tgt
    gt rx327_pos, rx327_eos, rx327_done
    set rx327_off, 0
    lt rx327_pos, 2, rx327_start
    sub rx327_off, rx327_pos, 1
    substr rx327_tgt, rx327_tgt, rx327_off
  rx327_start:
    eq $I10, 1, rx327_restart
    if_null rx327_debug, debug_548
    rx327_cur."!cursor_debug"("START", "")
  debug_548:
    $I10 = self.'from'()
    ne $I10, -1, rxscan328_done
    goto rxscan328_scan
  rxscan328_loop:
    (rx327_pos) = rx327_cur."from"()
    inc rx327_pos
    rx327_cur."!cursor_from"(rx327_pos)
    ge rx327_pos, rx327_eos, rxscan328_done
  rxscan328_scan:
    set_addr $I10, rxscan328_loop
    rx327_cur."!mark_push"(0, rx327_pos, $I10)
  rxscan328_done:
  # rx literal  "else"
    add $I11, rx327_pos, 4
    gt $I11, rx327_eos, rx327_fail
    sub $I11, rx327_pos, rx327_off
    substr $S10, rx327_tgt, $I11, 4
    ne $S10, "else", rx327_fail
    add rx327_pos, 4
  # rx pass
    rx327_cur."!cursor_pass"(rx327_pos, "")
    if_null rx327_debug, debug_549
    rx327_cur."!cursor_debug"("PASS", "", " at pos=", rx327_pos)
  debug_549:
    .return (rx327_cur)
  rx327_restart:
    if_null rx327_debug, debug_550
    rx327_cur."!cursor_debug"("NEXT", "")
  debug_550:
  rx327_fail:
    (rx327_rep, rx327_pos, $I10, $P10) = rx327_cur."!mark_fail"(0)
    lt rx327_pos, -1, rx327_done
    eq rx327_pos, -1, rx327_fail
    jump $I10
  rx327_done:
    rx327_cur."!cursor_fail"()
    if_null rx327_debug, debug_551
    rx327_cur."!cursor_debug"("FAIL", "")
  debug_551:
    .return (rx327_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("71_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx334_tgt
    .local int rx334_pos
    .local int rx334_off
    .local int rx334_eos
    .local int rx334_rep
    .local pmc rx334_cur
    .local pmc rx334_debug
    (rx334_cur, rx334_pos, rx334_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx334_cur
    .local pmc match
    .lex "$/", match
    length rx334_eos, rx334_tgt
    gt rx334_pos, rx334_eos, rx334_done
    set rx334_off, 0
    lt rx334_pos, 2, rx334_start
    sub rx334_off, rx334_pos, 1
    substr rx334_tgt, rx334_tgt, rx334_off
  rx334_start:
    eq $I10, 1, rx334_restart
    if_null rx334_debug, debug_555
    rx334_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_555:
    $I10 = self.'from'()
    ne $I10, -1, rxscan337_done
    goto rxscan337_scan
  rxscan337_loop:
    (rx334_pos) = rx334_cur."from"()
    inc rx334_pos
    rx334_cur."!cursor_from"(rx334_pos)
    ge rx334_pos, rx334_eos, rxscan337_done
  rxscan337_scan:
    set_addr $I10, rxscan337_loop
    rx334_cur."!mark_push"(0, rx334_pos, $I10)
  rxscan337_done:
.annotate 'line', 207
  # rx subcapture "sym"
    set_addr $I10, rxcap_339_fail
    rx334_cur."!mark_push"(0, rx334_pos, $I10)
  alt338_0:
    set_addr $I10, alt338_1
    rx334_cur."!mark_push"(0, rx334_pos, $I10)
  # rx literal  "while"
    add $I11, rx334_pos, 5
    gt $I11, rx334_eos, rx334_fail
    sub $I11, rx334_pos, rx334_off
    substr $S10, rx334_tgt, $I11, 5
    ne $S10, "while", rx334_fail
    add rx334_pos, 5
    goto alt338_end
  alt338_1:
  # rx literal  "until"
    add $I11, rx334_pos, 5
    gt $I11, rx334_eos, rx334_fail
    sub $I11, rx334_pos, rx334_off
    substr $S10, rx334_tgt, $I11, 5
    ne $S10, "until", rx334_fail
    add rx334_pos, 5
  alt338_end:
    set_addr $I10, rxcap_339_fail
    ($I12, $I11) = rx334_cur."!mark_peek"($I10)
    rx334_cur."!cursor_pos"($I11)
    ($P10) = rx334_cur."!cursor_start"()
    $P10."!cursor_pass"(rx334_pos, "")
    rx334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_339_done
  rxcap_339_fail:
    goto rx334_fail
  rxcap_339_done:
  # rx charclass s
    ge rx334_pos, rx334_eos, rx334_fail
    sub $I10, rx334_pos, rx334_off
    is_cclass $I11, 32, rx334_tgt, $I10
    unless $I11, rx334_fail
    inc rx334_pos
  # rx subrule "ws" subtype=method negate=
    rx334_cur."!cursor_pos"(rx334_pos)
    $P10 = rx334_cur."ws"()
    unless $P10, rx334_fail
    rx334_pos = $P10."pos"()
.annotate 'line', 208
  # rx subrule "xblock" subtype=capture negate=
    rx334_cur."!cursor_pos"(rx334_pos)
    $P10 = rx334_cur."xblock"()
    unless $P10, rx334_fail
    rx334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx334_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx334_cur."!cursor_pos"(rx334_pos)
    $P10 = rx334_cur."ws"()
    unless $P10, rx334_fail
    rx334_pos = $P10."pos"()
.annotate 'line', 206
  # rx pass
    rx334_cur."!cursor_pass"(rx334_pos, "statement_control:sym<while>")
    if_null rx334_debug, debug_556
    rx334_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx334_pos)
  debug_556:
    .return (rx334_cur)
  rx334_restart:
.annotate 'line', 4
    if_null rx334_debug, debug_557
    rx334_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_557:
  rx334_fail:
    (rx334_rep, rx334_pos, $I10, $P10) = rx334_cur."!mark_fail"(0)
    lt rx334_pos, -1, rx334_done
    eq rx334_pos, -1, rx334_fail
    jump $I10
  rx334_done:
    rx334_cur."!cursor_fail"()
    if_null rx334_debug, debug_558
    rx334_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_558:
    .return (rx334_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("72_1300060177.262") :method
.annotate 'line', 4
    new $P336, "ResizablePMCArray"
    push $P336, "until"
    push $P336, "while"
    .return ($P336)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("73_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx343_tgt
    .local int rx343_pos
    .local int rx343_off
    .local int rx343_eos
    .local int rx343_rep
    .local pmc rx343_cur
    .local pmc rx343_debug
    (rx343_cur, rx343_pos, rx343_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx343_cur
    .local pmc match
    .lex "$/", match
    length rx343_eos, rx343_tgt
    gt rx343_pos, rx343_eos, rx343_done
    set rx343_off, 0
    lt rx343_pos, 2, rx343_start
    sub rx343_off, rx343_pos, 1
    substr rx343_tgt, rx343_tgt, rx343_off
  rx343_start:
    eq $I10, 1, rx343_restart
    if_null rx343_debug, debug_559
    rx343_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_559:
    $I10 = self.'from'()
    ne $I10, -1, rxscan346_done
    goto rxscan346_scan
  rxscan346_loop:
    (rx343_pos) = rx343_cur."from"()
    inc rx343_pos
    rx343_cur."!cursor_from"(rx343_pos)
    ge rx343_pos, rx343_eos, rxscan346_done
  rxscan346_scan:
    set_addr $I10, rxscan346_loop
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
  rxscan346_done:
.annotate 'line', 212
  # rx subcapture "sym"
    set_addr $I10, rxcap_347_fail
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx343_pos, 6
    gt $I11, rx343_eos, rx343_fail
    sub $I11, rx343_pos, rx343_off
    substr $S10, rx343_tgt, $I11, 6
    ne $S10, "repeat", rx343_fail
    add rx343_pos, 6
    set_addr $I10, rxcap_347_fail
    ($I12, $I11) = rx343_cur."!mark_peek"($I10)
    rx343_cur."!cursor_pos"($I11)
    ($P10) = rx343_cur."!cursor_start"()
    $P10."!cursor_pass"(rx343_pos, "")
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_347_done
  rxcap_347_fail:
    goto rx343_fail
  rxcap_347_done:
  # rx charclass s
    ge rx343_pos, rx343_eos, rx343_fail
    sub $I10, rx343_pos, rx343_off
    is_cclass $I11, 32, rx343_tgt, $I10
    unless $I11, rx343_fail
    inc rx343_pos
  # rx subrule "ws" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."ws"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
  alt349_0:
.annotate 'line', 213
    set_addr $I10, alt349_1
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
.annotate 'line', 214
  # rx subrule "ws" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."ws"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_352_fail
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
  alt351_0:
    set_addr $I10, alt351_1
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
  # rx literal  "while"
    add $I11, rx343_pos, 5
    gt $I11, rx343_eos, rx343_fail
    sub $I11, rx343_pos, rx343_off
    substr $S10, rx343_tgt, $I11, 5
    ne $S10, "while", rx343_fail
    add rx343_pos, 5
    goto alt351_end
  alt351_1:
  # rx literal  "until"
    add $I11, rx343_pos, 5
    gt $I11, rx343_eos, rx343_fail
    sub $I11, rx343_pos, rx343_off
    substr $S10, rx343_tgt, $I11, 5
    ne $S10, "until", rx343_fail
    add rx343_pos, 5
  alt351_end:
    set_addr $I10, rxcap_352_fail
    ($I12, $I11) = rx343_cur."!mark_peek"($I10)
    rx343_cur."!cursor_pos"($I11)
    ($P10) = rx343_cur."!cursor_start"()
    $P10."!cursor_pass"(rx343_pos, "")
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_352_done
  rxcap_352_fail:
    goto rx343_fail
  rxcap_352_done:
  # rx charclass s
    ge rx343_pos, rx343_eos, rx343_fail
    sub $I10, rx343_pos, rx343_off
    is_cclass $I11, 32, rx343_tgt, $I10
    unless $I11, rx343_fail
    inc rx343_pos
  # rx subrule "ws" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."ws"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."xblock"()
    unless $P10, rx343_fail
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx343_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."ws"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
    goto alt349_end
  alt349_1:
.annotate 'line', 215
  # rx subrule "ws" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."ws"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."pblock"()
    unless $P10, rx343_fail
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx343_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."ws"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_358_fail
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
  alt357_0:
    set_addr $I10, alt357_1
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
  # rx literal  "while"
    add $I11, rx343_pos, 5
    gt $I11, rx343_eos, rx343_fail
    sub $I11, rx343_pos, rx343_off
    substr $S10, rx343_tgt, $I11, 5
    ne $S10, "while", rx343_fail
    add rx343_pos, 5
    goto alt357_end
  alt357_1:
  # rx literal  "until"
    add $I11, rx343_pos, 5
    gt $I11, rx343_eos, rx343_fail
    sub $I11, rx343_pos, rx343_off
    substr $S10, rx343_tgt, $I11, 5
    ne $S10, "until", rx343_fail
    add rx343_pos, 5
  alt357_end:
    set_addr $I10, rxcap_358_fail
    ($I12, $I11) = rx343_cur."!mark_peek"($I10)
    rx343_cur."!cursor_pos"($I11)
    ($P10) = rx343_cur."!cursor_start"()
    $P10."!cursor_pass"(rx343_pos, "")
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_358_done
  rxcap_358_fail:
    goto rx343_fail
  rxcap_358_done:
  # rx charclass s
    ge rx343_pos, rx343_eos, rx343_fail
    sub $I10, rx343_pos, rx343_off
    is_cclass $I11, 32, rx343_tgt, $I10
    unless $I11, rx343_fail
    inc rx343_pos
  # rx subrule "ws" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."ws"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."EXPR"()
    unless $P10, rx343_fail
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx343_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."ws"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
  alt349_end:
.annotate 'line', 216
  # rx subrule "ws" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."ws"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
.annotate 'line', 211
  # rx pass
    rx343_cur."!cursor_pass"(rx343_pos, "statement_control:sym<repeat>")
    if_null rx343_debug, debug_560
    rx343_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx343_pos)
  debug_560:
    .return (rx343_cur)
  rx343_restart:
.annotate 'line', 4
    if_null rx343_debug, debug_561
    rx343_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_561:
  rx343_fail:
    (rx343_rep, rx343_pos, $I10, $P10) = rx343_cur."!mark_fail"(0)
    lt rx343_pos, -1, rx343_done
    eq rx343_pos, -1, rx343_fail
    jump $I10
  rx343_done:
    rx343_cur."!cursor_fail"()
    if_null rx343_debug, debug_562
    rx343_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_562:
    .return (rx343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("74_1300060177.262") :method
.annotate 'line', 4
    new $P345, "ResizablePMCArray"
    push $P345, "repeat"
    .return ($P345)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("75_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx363_tgt
    .local int rx363_pos
    .local int rx363_off
    .local int rx363_eos
    .local int rx363_rep
    .local pmc rx363_cur
    .local pmc rx363_debug
    (rx363_cur, rx363_pos, rx363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx363_cur
    .local pmc match
    .lex "$/", match
    length rx363_eos, rx363_tgt
    gt rx363_pos, rx363_eos, rx363_done
    set rx363_off, 0
    lt rx363_pos, 2, rx363_start
    sub rx363_off, rx363_pos, 1
    substr rx363_tgt, rx363_tgt, rx363_off
  rx363_start:
    eq $I10, 1, rx363_restart
    if_null rx363_debug, debug_563
    rx363_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_563:
    $I10 = self.'from'()
    ne $I10, -1, rxscan366_done
    goto rxscan366_scan
  rxscan366_loop:
    (rx363_pos) = rx363_cur."from"()
    inc rx363_pos
    rx363_cur."!cursor_from"(rx363_pos)
    ge rx363_pos, rx363_eos, rxscan366_done
  rxscan366_scan:
    set_addr $I10, rxscan366_loop
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  rxscan366_done:
.annotate 'line', 220
  # rx subcapture "sym"
    set_addr $I10, rxcap_367_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "for"
    add $I11, rx363_pos, 3
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 3
    ne $S10, "for", rx363_fail
    add rx363_pos, 3
    set_addr $I10, rxcap_367_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_367_done
  rxcap_367_fail:
    goto rx363_fail
  rxcap_367_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 221
  # rx subrule "xblock" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."xblock"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 219
  # rx pass
    rx363_cur."!cursor_pass"(rx363_pos, "statement_control:sym<for>")
    if_null rx363_debug, debug_564
    rx363_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx363_pos)
  debug_564:
    .return (rx363_cur)
  rx363_restart:
.annotate 'line', 4
    if_null rx363_debug, debug_565
    rx363_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_565:
  rx363_fail:
    (rx363_rep, rx363_pos, $I10, $P10) = rx363_cur."!mark_fail"(0)
    lt rx363_pos, -1, rx363_done
    eq rx363_pos, -1, rx363_fail
    jump $I10
  rx363_done:
    rx363_cur."!cursor_fail"()
    if_null rx363_debug, debug_566
    rx363_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_566:
    .return (rx363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("76_1300060177.262") :method
.annotate 'line', 4
    new $P365, "ResizablePMCArray"
    push $P365, "for"
    .return ($P365)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("77_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx371_tgt
    .local int rx371_pos
    .local int rx371_off
    .local int rx371_eos
    .local int rx371_rep
    .local pmc rx371_cur
    .local pmc rx371_debug
    (rx371_cur, rx371_pos, rx371_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx371_cur
    .local pmc match
    .lex "$/", match
    length rx371_eos, rx371_tgt
    gt rx371_pos, rx371_eos, rx371_done
    set rx371_off, 0
    lt rx371_pos, 2, rx371_start
    sub rx371_off, rx371_pos, 1
    substr rx371_tgt, rx371_tgt, rx371_off
  rx371_start:
    eq $I10, 1, rx371_restart
    if_null rx371_debug, debug_567
    rx371_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_567:
    $I10 = self.'from'()
    ne $I10, -1, rxscan374_done
    goto rxscan374_scan
  rxscan374_loop:
    (rx371_pos) = rx371_cur."from"()
    inc rx371_pos
    rx371_cur."!cursor_from"(rx371_pos)
    ge rx371_pos, rx371_eos, rxscan374_done
  rxscan374_scan:
    set_addr $I10, rxscan374_loop
    rx371_cur."!mark_push"(0, rx371_pos, $I10)
  rxscan374_done:
.annotate 'line', 225
  # rx subcapture "sym"
    set_addr $I10, rxcap_375_fail
    rx371_cur."!mark_push"(0, rx371_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx371_pos, 5
    gt $I11, rx371_eos, rx371_fail
    sub $I11, rx371_pos, rx371_off
    substr $S10, rx371_tgt, $I11, 5
    ne $S10, "CATCH", rx371_fail
    add rx371_pos, 5
    set_addr $I10, rxcap_375_fail
    ($I12, $I11) = rx371_cur."!mark_peek"($I10)
    rx371_cur."!cursor_pos"($I11)
    ($P10) = rx371_cur."!cursor_start"()
    $P10."!cursor_pass"(rx371_pos, "")
    rx371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_375_done
  rxcap_375_fail:
    goto rx371_fail
  rxcap_375_done:
  # rx charclass s
    ge rx371_pos, rx371_eos, rx371_fail
    sub $I10, rx371_pos, rx371_off
    is_cclass $I11, 32, rx371_tgt, $I10
    unless $I11, rx371_fail
    inc rx371_pos
  # rx subrule "ws" subtype=method negate=
    rx371_cur."!cursor_pos"(rx371_pos)
    $P10 = rx371_cur."ws"()
    unless $P10, rx371_fail
    rx371_pos = $P10."pos"()
.annotate 'line', 226
  # rx subrule "block" subtype=capture negate=
    rx371_cur."!cursor_pos"(rx371_pos)
    $P10 = rx371_cur."block"()
    unless $P10, rx371_fail
    rx371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx371_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx371_cur."!cursor_pos"(rx371_pos)
    $P10 = rx371_cur."ws"()
    unless $P10, rx371_fail
    rx371_pos = $P10."pos"()
.annotate 'line', 224
  # rx pass
    rx371_cur."!cursor_pass"(rx371_pos, "statement_control:sym<CATCH>")
    if_null rx371_debug, debug_568
    rx371_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx371_pos)
  debug_568:
    .return (rx371_cur)
  rx371_restart:
.annotate 'line', 4
    if_null rx371_debug, debug_569
    rx371_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_569:
  rx371_fail:
    (rx371_rep, rx371_pos, $I10, $P10) = rx371_cur."!mark_fail"(0)
    lt rx371_pos, -1, rx371_done
    eq rx371_pos, -1, rx371_fail
    jump $I10
  rx371_done:
    rx371_cur."!cursor_fail"()
    if_null rx371_debug, debug_570
    rx371_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_570:
    .return (rx371_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("78_1300060177.262") :method
.annotate 'line', 4
    new $P373, "ResizablePMCArray"
    push $P373, "CATCH"
    .return ($P373)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("79_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx379_tgt
    .local int rx379_pos
    .local int rx379_off
    .local int rx379_eos
    .local int rx379_rep
    .local pmc rx379_cur
    .local pmc rx379_debug
    (rx379_cur, rx379_pos, rx379_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx379_cur
    .local pmc match
    .lex "$/", match
    length rx379_eos, rx379_tgt
    gt rx379_pos, rx379_eos, rx379_done
    set rx379_off, 0
    lt rx379_pos, 2, rx379_start
    sub rx379_off, rx379_pos, 1
    substr rx379_tgt, rx379_tgt, rx379_off
  rx379_start:
    eq $I10, 1, rx379_restart
    if_null rx379_debug, debug_571
    rx379_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_571:
    $I10 = self.'from'()
    ne $I10, -1, rxscan382_done
    goto rxscan382_scan
  rxscan382_loop:
    (rx379_pos) = rx379_cur."from"()
    inc rx379_pos
    rx379_cur."!cursor_from"(rx379_pos)
    ge rx379_pos, rx379_eos, rxscan382_done
  rxscan382_scan:
    set_addr $I10, rxscan382_loop
    rx379_cur."!mark_push"(0, rx379_pos, $I10)
  rxscan382_done:
.annotate 'line', 230
  # rx subcapture "sym"
    set_addr $I10, rxcap_383_fail
    rx379_cur."!mark_push"(0, rx379_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx379_pos, 7
    gt $I11, rx379_eos, rx379_fail
    sub $I11, rx379_pos, rx379_off
    substr $S10, rx379_tgt, $I11, 7
    ne $S10, "CONTROL", rx379_fail
    add rx379_pos, 7
    set_addr $I10, rxcap_383_fail
    ($I12, $I11) = rx379_cur."!mark_peek"($I10)
    rx379_cur."!cursor_pos"($I11)
    ($P10) = rx379_cur."!cursor_start"()
    $P10."!cursor_pass"(rx379_pos, "")
    rx379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_383_done
  rxcap_383_fail:
    goto rx379_fail
  rxcap_383_done:
  # rx charclass s
    ge rx379_pos, rx379_eos, rx379_fail
    sub $I10, rx379_pos, rx379_off
    is_cclass $I11, 32, rx379_tgt, $I10
    unless $I11, rx379_fail
    inc rx379_pos
  # rx subrule "ws" subtype=method negate=
    rx379_cur."!cursor_pos"(rx379_pos)
    $P10 = rx379_cur."ws"()
    unless $P10, rx379_fail
    rx379_pos = $P10."pos"()
.annotate 'line', 231
  # rx subrule "block" subtype=capture negate=
    rx379_cur."!cursor_pos"(rx379_pos)
    $P10 = rx379_cur."block"()
    unless $P10, rx379_fail
    rx379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx379_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx379_cur."!cursor_pos"(rx379_pos)
    $P10 = rx379_cur."ws"()
    unless $P10, rx379_fail
    rx379_pos = $P10."pos"()
.annotate 'line', 229
  # rx pass
    rx379_cur."!cursor_pass"(rx379_pos, "statement_control:sym<CONTROL>")
    if_null rx379_debug, debug_572
    rx379_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx379_pos)
  debug_572:
    .return (rx379_cur)
  rx379_restart:
.annotate 'line', 4
    if_null rx379_debug, debug_573
    rx379_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_573:
  rx379_fail:
    (rx379_rep, rx379_pos, $I10, $P10) = rx379_cur."!mark_fail"(0)
    lt rx379_pos, -1, rx379_done
    eq rx379_pos, -1, rx379_fail
    jump $I10
  rx379_done:
    rx379_cur."!cursor_fail"()
    if_null rx379_debug, debug_574
    rx379_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_574:
    .return (rx379_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("80_1300060177.262") :method
.annotate 'line', 4
    new $P381, "ResizablePMCArray"
    push $P381, "CONTROL"
    .return ($P381)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("81_1300060177.262")
    .param pmc param_387
.annotate 'line', 234
    .lex "self", param_387
    $P388 = param_387."!protoregex"("statement_prefix")
    .return ($P388)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("82_1300060177.262")
    .param pmc param_390
.annotate 'line', 234
    .lex "self", param_390
    $P391 = param_390."!PREFIX__!protoregex"("statement_prefix")
    .return ($P391)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("83_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx393_tgt
    .local int rx393_pos
    .local int rx393_off
    .local int rx393_eos
    .local int rx393_rep
    .local pmc rx393_cur
    .local pmc rx393_debug
    (rx393_cur, rx393_pos, rx393_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx393_cur
    .local pmc match
    .lex "$/", match
    length rx393_eos, rx393_tgt
    gt rx393_pos, rx393_eos, rx393_done
    set rx393_off, 0
    lt rx393_pos, 2, rx393_start
    sub rx393_off, rx393_pos, 1
    substr rx393_tgt, rx393_tgt, rx393_off
  rx393_start:
    eq $I10, 1, rx393_restart
    if_null rx393_debug, debug_575
    rx393_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_575:
    $I10 = self.'from'()
    ne $I10, -1, rxscan397_done
    goto rxscan397_scan
  rxscan397_loop:
    (rx393_pos) = rx393_cur."from"()
    inc rx393_pos
    rx393_cur."!cursor_from"(rx393_pos)
    ge rx393_pos, rx393_eos, rxscan397_done
  rxscan397_scan:
    set_addr $I10, rxscan397_loop
    rx393_cur."!mark_push"(0, rx393_pos, $I10)
  rxscan397_done:
.annotate 'line', 235
  # rx subcapture "sym"
    set_addr $I10, rxcap_398_fail
    rx393_cur."!mark_push"(0, rx393_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx393_pos, 4
    gt $I11, rx393_eos, rx393_fail
    sub $I11, rx393_pos, rx393_off
    substr $S10, rx393_tgt, $I11, 4
    ne $S10, "INIT", rx393_fail
    add rx393_pos, 4
    set_addr $I10, rxcap_398_fail
    ($I12, $I11) = rx393_cur."!mark_peek"($I10)
    rx393_cur."!cursor_pos"($I11)
    ($P10) = rx393_cur."!cursor_start"()
    $P10."!cursor_pass"(rx393_pos, "")
    rx393_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_398_done
  rxcap_398_fail:
    goto rx393_fail
  rxcap_398_done:
  # rx subrule "blorst" subtype=capture negate=
    rx393_cur."!cursor_pos"(rx393_pos)
    $P10 = rx393_cur."blorst"()
    unless $P10, rx393_fail
    rx393_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx393_pos = $P10."pos"()
  # rx pass
    rx393_cur."!cursor_pass"(rx393_pos, "statement_prefix:sym<INIT>")
    if_null rx393_debug, debug_576
    rx393_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx393_pos)
  debug_576:
    .return (rx393_cur)
  rx393_restart:
.annotate 'line', 4
    if_null rx393_debug, debug_577
    rx393_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_577:
  rx393_fail:
    (rx393_rep, rx393_pos, $I10, $P10) = rx393_cur."!mark_fail"(0)
    lt rx393_pos, -1, rx393_done
    eq rx393_pos, -1, rx393_fail
    jump $I10
  rx393_done:
    rx393_cur."!cursor_fail"()
    if_null rx393_debug, debug_578
    rx393_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_578:
    .return (rx393_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("84_1300060177.262") :method
.annotate 'line', 4
    $P395 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P396, "ResizablePMCArray"
    push $P396, $P395
    .return ($P396)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("85_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx400_tgt
    .local int rx400_pos
    .local int rx400_off
    .local int rx400_eos
    .local int rx400_rep
    .local pmc rx400_cur
    .local pmc rx400_debug
    (rx400_cur, rx400_pos, rx400_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx400_cur
    .local pmc match
    .lex "$/", match
    length rx400_eos, rx400_tgt
    gt rx400_pos, rx400_eos, rx400_done
    set rx400_off, 0
    lt rx400_pos, 2, rx400_start
    sub rx400_off, rx400_pos, 1
    substr rx400_tgt, rx400_tgt, rx400_off
  rx400_start:
    eq $I10, 1, rx400_restart
    if_null rx400_debug, debug_579
    rx400_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_579:
    $I10 = self.'from'()
    ne $I10, -1, rxscan404_done
    goto rxscan404_scan
  rxscan404_loop:
    (rx400_pos) = rx400_cur."from"()
    inc rx400_pos
    rx400_cur."!cursor_from"(rx400_pos)
    ge rx400_pos, rx400_eos, rxscan404_done
  rxscan404_scan:
    set_addr $I10, rxscan404_loop
    rx400_cur."!mark_push"(0, rx400_pos, $I10)
  rxscan404_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_405_fail
    rx400_cur."!mark_push"(0, rx400_pos, $I10)
  # rx literal  "try"
    add $I11, rx400_pos, 3
    gt $I11, rx400_eos, rx400_fail
    sub $I11, rx400_pos, rx400_off
    substr $S10, rx400_tgt, $I11, 3
    ne $S10, "try", rx400_fail
    add rx400_pos, 3
    set_addr $I10, rxcap_405_fail
    ($I12, $I11) = rx400_cur."!mark_peek"($I10)
    rx400_cur."!cursor_pos"($I11)
    ($P10) = rx400_cur."!cursor_start"()
    $P10."!cursor_pass"(rx400_pos, "")
    rx400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_405_done
  rxcap_405_fail:
    goto rx400_fail
  rxcap_405_done:
.annotate 'line', 239
  # rx subrule "blorst" subtype=capture negate=
    rx400_cur."!cursor_pos"(rx400_pos)
    $P10 = rx400_cur."blorst"()
    unless $P10, rx400_fail
    rx400_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx400_pos = $P10."pos"()
.annotate 'line', 237
  # rx pass
    rx400_cur."!cursor_pass"(rx400_pos, "statement_prefix:sym<try>")
    if_null rx400_debug, debug_580
    rx400_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx400_pos)
  debug_580:
    .return (rx400_cur)
  rx400_restart:
.annotate 'line', 4
    if_null rx400_debug, debug_581
    rx400_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_581:
  rx400_fail:
    (rx400_rep, rx400_pos, $I10, $P10) = rx400_cur."!mark_fail"(0)
    lt rx400_pos, -1, rx400_done
    eq rx400_pos, -1, rx400_fail
    jump $I10
  rx400_done:
    rx400_cur."!cursor_fail"()
    if_null rx400_debug, debug_582
    rx400_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_582:
    .return (rx400_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("86_1300060177.262") :method
.annotate 'line', 4
    $P402 = self."!PREFIX__!subrule"("blorst", "try")
    new $P403, "ResizablePMCArray"
    push $P403, $P402
    .return ($P403)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("87_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx407_tgt
    .local int rx407_pos
    .local int rx407_off
    .local int rx407_eos
    .local int rx407_rep
    .local pmc rx407_cur
    .local pmc rx407_debug
    (rx407_cur, rx407_pos, rx407_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx407_cur
    .local pmc match
    .lex "$/", match
    length rx407_eos, rx407_tgt
    gt rx407_pos, rx407_eos, rx407_done
    set rx407_off, 0
    lt rx407_pos, 2, rx407_start
    sub rx407_off, rx407_pos, 1
    substr rx407_tgt, rx407_tgt, rx407_off
  rx407_start:
    eq $I10, 1, rx407_restart
    if_null rx407_debug, debug_583
    rx407_cur."!cursor_debug"("START", "blorst")
  debug_583:
    $I10 = self.'from'()
    ne $I10, -1, rxscan410_done
    goto rxscan410_scan
  rxscan410_loop:
    (rx407_pos) = rx407_cur."from"()
    inc rx407_pos
    rx407_cur."!cursor_from"(rx407_pos)
    ge rx407_pos, rx407_eos, rxscan410_done
  rxscan410_scan:
    set_addr $I10, rxscan410_loop
    rx407_cur."!mark_push"(0, rx407_pos, $I10)
  rxscan410_done:
.annotate 'line', 243
  # rx charclass s
    ge rx407_pos, rx407_eos, rx407_fail
    sub $I10, rx407_pos, rx407_off
    is_cclass $I11, 32, rx407_tgt, $I10
    unless $I11, rx407_fail
    inc rx407_pos
  # rx subrule "ws" subtype=method negate=
    rx407_cur."!cursor_pos"(rx407_pos)
    $P10 = rx407_cur."ws"()
    unless $P10, rx407_fail
    rx407_pos = $P10."pos"()
  alt411_0:
    set_addr $I10, alt411_1
    rx407_cur."!mark_push"(0, rx407_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx407_pos, rx407_off
    substr $S10, rx407_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx407_fail
  # rx subrule "block" subtype=capture negate=
    rx407_cur."!cursor_pos"(rx407_pos)
    $P10 = rx407_cur."block"()
    unless $P10, rx407_fail
    rx407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx407_pos = $P10."pos"()
    goto alt411_end
  alt411_1:
  # rx subrule "statement" subtype=capture negate=
    rx407_cur."!cursor_pos"(rx407_pos)
    $P10 = rx407_cur."statement"()
    unless $P10, rx407_fail
    rx407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx407_pos = $P10."pos"()
  alt411_end:
.annotate 'line', 242
  # rx pass
    rx407_cur."!cursor_pass"(rx407_pos, "blorst")
    if_null rx407_debug, debug_584
    rx407_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx407_pos)
  debug_584:
    .return (rx407_cur)
  rx407_restart:
.annotate 'line', 4
    if_null rx407_debug, debug_585
    rx407_cur."!cursor_debug"("NEXT", "blorst")
  debug_585:
  rx407_fail:
    (rx407_rep, rx407_pos, $I10, $P10) = rx407_cur."!mark_fail"(0)
    lt rx407_pos, -1, rx407_done
    eq rx407_pos, -1, rx407_fail
    jump $I10
  rx407_done:
    rx407_cur."!cursor_fail"()
    if_null rx407_debug, debug_586
    rx407_cur."!cursor_debug"("FAIL", "blorst")
  debug_586:
    .return (rx407_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("88_1300060177.262") :method
.annotate 'line', 4
    new $P409, "ResizablePMCArray"
    push $P409, ""
    .return ($P409)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("89_1300060177.262")
    .param pmc param_413
.annotate 'line', 248
    .lex "self", param_413
    $P414 = param_413."!protoregex"("statement_mod_cond")
    .return ($P414)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("90_1300060177.262")
    .param pmc param_416
.annotate 'line', 248
    .lex "self", param_416
    $P417 = param_416."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P417)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("91_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx419_tgt
    .local int rx419_pos
    .local int rx419_off
    .local int rx419_eos
    .local int rx419_rep
    .local pmc rx419_cur
    .local pmc rx419_debug
    (rx419_cur, rx419_pos, rx419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx419_cur
    .local pmc match
    .lex "$/", match
    length rx419_eos, rx419_tgt
    gt rx419_pos, rx419_eos, rx419_done
    set rx419_off, 0
    lt rx419_pos, 2, rx419_start
    sub rx419_off, rx419_pos, 1
    substr rx419_tgt, rx419_tgt, rx419_off
  rx419_start:
    eq $I10, 1, rx419_restart
    if_null rx419_debug, debug_587
    rx419_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_587:
    $I10 = self.'from'()
    ne $I10, -1, rxscan423_done
    goto rxscan423_scan
  rxscan423_loop:
    (rx419_pos) = rx419_cur."from"()
    inc rx419_pos
    rx419_cur."!cursor_from"(rx419_pos)
    ge rx419_pos, rx419_eos, rxscan423_done
  rxscan423_scan:
    set_addr $I10, rxscan423_loop
    rx419_cur."!mark_push"(0, rx419_pos, $I10)
  rxscan423_done:
.annotate 'line', 250
  # rx subcapture "sym"
    set_addr $I10, rxcap_424_fail
    rx419_cur."!mark_push"(0, rx419_pos, $I10)
  # rx literal  "if"
    add $I11, rx419_pos, 2
    gt $I11, rx419_eos, rx419_fail
    sub $I11, rx419_pos, rx419_off
    substr $S10, rx419_tgt, $I11, 2
    ne $S10, "if", rx419_fail
    add rx419_pos, 2
    set_addr $I10, rxcap_424_fail
    ($I12, $I11) = rx419_cur."!mark_peek"($I10)
    rx419_cur."!cursor_pos"($I11)
    ($P10) = rx419_cur."!cursor_start"()
    $P10."!cursor_pass"(rx419_pos, "")
    rx419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_424_done
  rxcap_424_fail:
    goto rx419_fail
  rxcap_424_done:
  # rx subrule "ws" subtype=method negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."ws"()
    unless $P10, rx419_fail
    rx419_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."EXPR"()
    unless $P10, rx419_fail
    rx419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx419_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."ws"()
    unless $P10, rx419_fail
    rx419_pos = $P10."pos"()
  # rx pass
    rx419_cur."!cursor_pass"(rx419_pos, "statement_mod_cond:sym<if>")
    if_null rx419_debug, debug_588
    rx419_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx419_pos)
  debug_588:
    .return (rx419_cur)
  rx419_restart:
.annotate 'line', 4
    if_null rx419_debug, debug_589
    rx419_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_589:
  rx419_fail:
    (rx419_rep, rx419_pos, $I10, $P10) = rx419_cur."!mark_fail"(0)
    lt rx419_pos, -1, rx419_done
    eq rx419_pos, -1, rx419_fail
    jump $I10
  rx419_done:
    rx419_cur."!cursor_fail"()
    if_null rx419_debug, debug_590
    rx419_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_590:
    .return (rx419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("92_1300060177.262") :method
.annotate 'line', 4
    $P421 = self."!PREFIX__!subrule"("ws", "if")
    new $P422, "ResizablePMCArray"
    push $P422, $P421
    .return ($P422)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("93_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx428_tgt
    .local int rx428_pos
    .local int rx428_off
    .local int rx428_eos
    .local int rx428_rep
    .local pmc rx428_cur
    .local pmc rx428_debug
    (rx428_cur, rx428_pos, rx428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx428_cur
    .local pmc match
    .lex "$/", match
    length rx428_eos, rx428_tgt
    gt rx428_pos, rx428_eos, rx428_done
    set rx428_off, 0
    lt rx428_pos, 2, rx428_start
    sub rx428_off, rx428_pos, 1
    substr rx428_tgt, rx428_tgt, rx428_off
  rx428_start:
    eq $I10, 1, rx428_restart
    if_null rx428_debug, debug_591
    rx428_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_591:
    $I10 = self.'from'()
    ne $I10, -1, rxscan432_done
    goto rxscan432_scan
  rxscan432_loop:
    (rx428_pos) = rx428_cur."from"()
    inc rx428_pos
    rx428_cur."!cursor_from"(rx428_pos)
    ge rx428_pos, rx428_eos, rxscan432_done
  rxscan432_scan:
    set_addr $I10, rxscan432_loop
    rx428_cur."!mark_push"(0, rx428_pos, $I10)
  rxscan432_done:
.annotate 'line', 251
  # rx subcapture "sym"
    set_addr $I10, rxcap_433_fail
    rx428_cur."!mark_push"(0, rx428_pos, $I10)
  # rx literal  "unless"
    add $I11, rx428_pos, 6
    gt $I11, rx428_eos, rx428_fail
    sub $I11, rx428_pos, rx428_off
    substr $S10, rx428_tgt, $I11, 6
    ne $S10, "unless", rx428_fail
    add rx428_pos, 6
    set_addr $I10, rxcap_433_fail
    ($I12, $I11) = rx428_cur."!mark_peek"($I10)
    rx428_cur."!cursor_pos"($I11)
    ($P10) = rx428_cur."!cursor_start"()
    $P10."!cursor_pass"(rx428_pos, "")
    rx428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_433_done
  rxcap_433_fail:
    goto rx428_fail
  rxcap_433_done:
  # rx subrule "ws" subtype=method negate=
    rx428_cur."!cursor_pos"(rx428_pos)
    $P10 = rx428_cur."ws"()
    unless $P10, rx428_fail
    rx428_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx428_cur."!cursor_pos"(rx428_pos)
    $P10 = rx428_cur."EXPR"()
    unless $P10, rx428_fail
    rx428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx428_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx428_cur."!cursor_pos"(rx428_pos)
    $P10 = rx428_cur."ws"()
    unless $P10, rx428_fail
    rx428_pos = $P10."pos"()
  # rx pass
    rx428_cur."!cursor_pass"(rx428_pos, "statement_mod_cond:sym<unless>")
    if_null rx428_debug, debug_592
    rx428_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx428_pos)
  debug_592:
    .return (rx428_cur)
  rx428_restart:
.annotate 'line', 4
    if_null rx428_debug, debug_593
    rx428_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_593:
  rx428_fail:
    (rx428_rep, rx428_pos, $I10, $P10) = rx428_cur."!mark_fail"(0)
    lt rx428_pos, -1, rx428_done
    eq rx428_pos, -1, rx428_fail
    jump $I10
  rx428_done:
    rx428_cur."!cursor_fail"()
    if_null rx428_debug, debug_594
    rx428_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_594:
    .return (rx428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("94_1300060177.262") :method
.annotate 'line', 4
    $P430 = self."!PREFIX__!subrule"("ws", "unless")
    new $P431, "ResizablePMCArray"
    push $P431, $P430
    .return ($P431)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("95_1300060177.262")
    .param pmc param_437
.annotate 'line', 253
    .lex "self", param_437
    $P438 = param_437."!protoregex"("statement_mod_loop")
    .return ($P438)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("96_1300060177.262")
    .param pmc param_440
.annotate 'line', 253
    .lex "self", param_440
    $P441 = param_440."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P441)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("97_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx443_tgt
    .local int rx443_pos
    .local int rx443_off
    .local int rx443_eos
    .local int rx443_rep
    .local pmc rx443_cur
    .local pmc rx443_debug
    (rx443_cur, rx443_pos, rx443_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx443_cur
    .local pmc match
    .lex "$/", match
    length rx443_eos, rx443_tgt
    gt rx443_pos, rx443_eos, rx443_done
    set rx443_off, 0
    lt rx443_pos, 2, rx443_start
    sub rx443_off, rx443_pos, 1
    substr rx443_tgt, rx443_tgt, rx443_off
  rx443_start:
    eq $I10, 1, rx443_restart
    if_null rx443_debug, debug_595
    rx443_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_595:
    $I10 = self.'from'()
    ne $I10, -1, rxscan447_done
    goto rxscan447_scan
  rxscan447_loop:
    (rx443_pos) = rx443_cur."from"()
    inc rx443_pos
    rx443_cur."!cursor_from"(rx443_pos)
    ge rx443_pos, rx443_eos, rxscan447_done
  rxscan447_scan:
    set_addr $I10, rxscan447_loop
    rx443_cur."!mark_push"(0, rx443_pos, $I10)
  rxscan447_done:
.annotate 'line', 255
  # rx subcapture "sym"
    set_addr $I10, rxcap_448_fail
    rx443_cur."!mark_push"(0, rx443_pos, $I10)
  # rx literal  "while"
    add $I11, rx443_pos, 5
    gt $I11, rx443_eos, rx443_fail
    sub $I11, rx443_pos, rx443_off
    substr $S10, rx443_tgt, $I11, 5
    ne $S10, "while", rx443_fail
    add rx443_pos, 5
    set_addr $I10, rxcap_448_fail
    ($I12, $I11) = rx443_cur."!mark_peek"($I10)
    rx443_cur."!cursor_pos"($I11)
    ($P10) = rx443_cur."!cursor_start"()
    $P10."!cursor_pass"(rx443_pos, "")
    rx443_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_448_done
  rxcap_448_fail:
    goto rx443_fail
  rxcap_448_done:
  # rx subrule "ws" subtype=method negate=
    rx443_cur."!cursor_pos"(rx443_pos)
    $P10 = rx443_cur."ws"()
    unless $P10, rx443_fail
    rx443_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx443_cur."!cursor_pos"(rx443_pos)
    $P10 = rx443_cur."EXPR"()
    unless $P10, rx443_fail
    rx443_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx443_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx443_cur."!cursor_pos"(rx443_pos)
    $P10 = rx443_cur."ws"()
    unless $P10, rx443_fail
    rx443_pos = $P10."pos"()
  # rx pass
    rx443_cur."!cursor_pass"(rx443_pos, "statement_mod_loop:sym<while>")
    if_null rx443_debug, debug_596
    rx443_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx443_pos)
  debug_596:
    .return (rx443_cur)
  rx443_restart:
.annotate 'line', 4
    if_null rx443_debug, debug_597
    rx443_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_597:
  rx443_fail:
    (rx443_rep, rx443_pos, $I10, $P10) = rx443_cur."!mark_fail"(0)
    lt rx443_pos, -1, rx443_done
    eq rx443_pos, -1, rx443_fail
    jump $I10
  rx443_done:
    rx443_cur."!cursor_fail"()
    if_null rx443_debug, debug_598
    rx443_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_598:
    .return (rx443_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("98_1300060177.262") :method
.annotate 'line', 4
    $P445 = self."!PREFIX__!subrule"("ws", "while")
    new $P446, "ResizablePMCArray"
    push $P446, $P445
    .return ($P446)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("99_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx452_tgt
    .local int rx452_pos
    .local int rx452_off
    .local int rx452_eos
    .local int rx452_rep
    .local pmc rx452_cur
    .local pmc rx452_debug
    (rx452_cur, rx452_pos, rx452_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx452_cur
    .local pmc match
    .lex "$/", match
    length rx452_eos, rx452_tgt
    gt rx452_pos, rx452_eos, rx452_done
    set rx452_off, 0
    lt rx452_pos, 2, rx452_start
    sub rx452_off, rx452_pos, 1
    substr rx452_tgt, rx452_tgt, rx452_off
  rx452_start:
    eq $I10, 1, rx452_restart
    if_null rx452_debug, debug_599
    rx452_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_599:
    $I10 = self.'from'()
    ne $I10, -1, rxscan456_done
    goto rxscan456_scan
  rxscan456_loop:
    (rx452_pos) = rx452_cur."from"()
    inc rx452_pos
    rx452_cur."!cursor_from"(rx452_pos)
    ge rx452_pos, rx452_eos, rxscan456_done
  rxscan456_scan:
    set_addr $I10, rxscan456_loop
    rx452_cur."!mark_push"(0, rx452_pos, $I10)
  rxscan456_done:
.annotate 'line', 256
  # rx subcapture "sym"
    set_addr $I10, rxcap_457_fail
    rx452_cur."!mark_push"(0, rx452_pos, $I10)
  # rx literal  "until"
    add $I11, rx452_pos, 5
    gt $I11, rx452_eos, rx452_fail
    sub $I11, rx452_pos, rx452_off
    substr $S10, rx452_tgt, $I11, 5
    ne $S10, "until", rx452_fail
    add rx452_pos, 5
    set_addr $I10, rxcap_457_fail
    ($I12, $I11) = rx452_cur."!mark_peek"($I10)
    rx452_cur."!cursor_pos"($I11)
    ($P10) = rx452_cur."!cursor_start"()
    $P10."!cursor_pass"(rx452_pos, "")
    rx452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_457_done
  rxcap_457_fail:
    goto rx452_fail
  rxcap_457_done:
  # rx subrule "ws" subtype=method negate=
    rx452_cur."!cursor_pos"(rx452_pos)
    $P10 = rx452_cur."ws"()
    unless $P10, rx452_fail
    rx452_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx452_cur."!cursor_pos"(rx452_pos)
    $P10 = rx452_cur."EXPR"()
    unless $P10, rx452_fail
    rx452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx452_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx452_cur."!cursor_pos"(rx452_pos)
    $P10 = rx452_cur."ws"()
    unless $P10, rx452_fail
    rx452_pos = $P10."pos"()
  # rx pass
    rx452_cur."!cursor_pass"(rx452_pos, "statement_mod_loop:sym<until>")
    if_null rx452_debug, debug_600
    rx452_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx452_pos)
  debug_600:
    .return (rx452_cur)
  rx452_restart:
.annotate 'line', 4
    if_null rx452_debug, debug_601
    rx452_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_601:
  rx452_fail:
    (rx452_rep, rx452_pos, $I10, $P10) = rx452_cur."!mark_fail"(0)
    lt rx452_pos, -1, rx452_done
    eq rx452_pos, -1, rx452_fail
    jump $I10
  rx452_done:
    rx452_cur."!cursor_fail"()
    if_null rx452_debug, debug_602
    rx452_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_602:
    .return (rx452_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("100_1300060177.262") :method
.annotate 'line', 4
    $P454 = self."!PREFIX__!subrule"("ws", "until")
    new $P455, "ResizablePMCArray"
    push $P455, $P454
    .return ($P455)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("101_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx461_tgt
    .local int rx461_pos
    .local int rx461_off
    .local int rx461_eos
    .local int rx461_rep
    .local pmc rx461_cur
    .local pmc rx461_debug
    (rx461_cur, rx461_pos, rx461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx461_cur
    .local pmc match
    .lex "$/", match
    length rx461_eos, rx461_tgt
    gt rx461_pos, rx461_eos, rx461_done
    set rx461_off, 0
    lt rx461_pos, 2, rx461_start
    sub rx461_off, rx461_pos, 1
    substr rx461_tgt, rx461_tgt, rx461_off
  rx461_start:
    eq $I10, 1, rx461_restart
    if_null rx461_debug, debug_603
    rx461_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_603:
    $I10 = self.'from'()
    ne $I10, -1, rxscan465_done
    goto rxscan465_scan
  rxscan465_loop:
    (rx461_pos) = rx461_cur."from"()
    inc rx461_pos
    rx461_cur."!cursor_from"(rx461_pos)
    ge rx461_pos, rx461_eos, rxscan465_done
  rxscan465_scan:
    set_addr $I10, rxscan465_loop
    rx461_cur."!mark_push"(0, rx461_pos, $I10)
  rxscan465_done:
.annotate 'line', 257
  # rx subcapture "sym"
    set_addr $I10, rxcap_466_fail
    rx461_cur."!mark_push"(0, rx461_pos, $I10)
  # rx literal  "for"
    add $I11, rx461_pos, 3
    gt $I11, rx461_eos, rx461_fail
    sub $I11, rx461_pos, rx461_off
    substr $S10, rx461_tgt, $I11, 3
    ne $S10, "for", rx461_fail
    add rx461_pos, 3
    set_addr $I10, rxcap_466_fail
    ($I12, $I11) = rx461_cur."!mark_peek"($I10)
    rx461_cur."!cursor_pos"($I11)
    ($P10) = rx461_cur."!cursor_start"()
    $P10."!cursor_pass"(rx461_pos, "")
    rx461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_466_done
  rxcap_466_fail:
    goto rx461_fail
  rxcap_466_done:
  # rx subrule "ws" subtype=method negate=
    rx461_cur."!cursor_pos"(rx461_pos)
    $P10 = rx461_cur."ws"()
    unless $P10, rx461_fail
    rx461_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx461_cur."!cursor_pos"(rx461_pos)
    $P10 = rx461_cur."EXPR"()
    unless $P10, rx461_fail
    rx461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx461_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx461_cur."!cursor_pos"(rx461_pos)
    $P10 = rx461_cur."ws"()
    unless $P10, rx461_fail
    rx461_pos = $P10."pos"()
  # rx pass
    rx461_cur."!cursor_pass"(rx461_pos, "statement_mod_loop:sym<for>")
    if_null rx461_debug, debug_604
    rx461_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx461_pos)
  debug_604:
    .return (rx461_cur)
  rx461_restart:
.annotate 'line', 4
    if_null rx461_debug, debug_605
    rx461_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_605:
  rx461_fail:
    (rx461_rep, rx461_pos, $I10, $P10) = rx461_cur."!mark_fail"(0)
    lt rx461_pos, -1, rx461_done
    eq rx461_pos, -1, rx461_fail
    jump $I10
  rx461_done:
    rx461_cur."!cursor_fail"()
    if_null rx461_debug, debug_606
    rx461_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_606:
    .return (rx461_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("102_1300060177.262") :method
.annotate 'line', 4
    $P463 = self."!PREFIX__!subrule"("ws", "for")
    new $P464, "ResizablePMCArray"
    push $P464, $P463
    .return ($P464)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("103_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx470_tgt
    .local int rx470_pos
    .local int rx470_off
    .local int rx470_eos
    .local int rx470_rep
    .local pmc rx470_cur
    .local pmc rx470_debug
    (rx470_cur, rx470_pos, rx470_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx470_cur
    .local pmc match
    .lex "$/", match
    length rx470_eos, rx470_tgt
    gt rx470_pos, rx470_eos, rx470_done
    set rx470_off, 0
    lt rx470_pos, 2, rx470_start
    sub rx470_off, rx470_pos, 1
    substr rx470_tgt, rx470_tgt, rx470_off
  rx470_start:
    eq $I10, 1, rx470_restart
    if_null rx470_debug, debug_607
    rx470_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_607:
    $I10 = self.'from'()
    ne $I10, -1, rxscan474_done
    goto rxscan474_scan
  rxscan474_loop:
    (rx470_pos) = rx470_cur."from"()
    inc rx470_pos
    rx470_cur."!cursor_from"(rx470_pos)
    ge rx470_pos, rx470_eos, rxscan474_done
  rxscan474_scan:
    set_addr $I10, rxscan474_loop
    rx470_cur."!mark_push"(0, rx470_pos, $I10)
  rxscan474_done:
.annotate 'line', 261
  # rx subrule "fatarrow" subtype=capture negate=
    rx470_cur."!cursor_pos"(rx470_pos)
    $P10 = rx470_cur."fatarrow"()
    unless $P10, rx470_fail
    rx470_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx470_pos = $P10."pos"()
  # rx pass
    rx470_cur."!cursor_pass"(rx470_pos, "term:sym<fatarrow>")
    if_null rx470_debug, debug_608
    rx470_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx470_pos)
  debug_608:
    .return (rx470_cur)
  rx470_restart:
.annotate 'line', 4
    if_null rx470_debug, debug_609
    rx470_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_609:
  rx470_fail:
    (rx470_rep, rx470_pos, $I10, $P10) = rx470_cur."!mark_fail"(0)
    lt rx470_pos, -1, rx470_done
    eq rx470_pos, -1, rx470_fail
    jump $I10
  rx470_done:
    rx470_cur."!cursor_fail"()
    if_null rx470_debug, debug_610
    rx470_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_610:
    .return (rx470_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("104_1300060177.262") :method
.annotate 'line', 4
    $P472 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P473, "ResizablePMCArray"
    push $P473, $P472
    .return ($P473)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("105_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx476_tgt
    .local int rx476_pos
    .local int rx476_off
    .local int rx476_eos
    .local int rx476_rep
    .local pmc rx476_cur
    .local pmc rx476_debug
    (rx476_cur, rx476_pos, rx476_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx476_cur
    .local pmc match
    .lex "$/", match
    length rx476_eos, rx476_tgt
    gt rx476_pos, rx476_eos, rx476_done
    set rx476_off, 0
    lt rx476_pos, 2, rx476_start
    sub rx476_off, rx476_pos, 1
    substr rx476_tgt, rx476_tgt, rx476_off
  rx476_start:
    eq $I10, 1, rx476_restart
    if_null rx476_debug, debug_611
    rx476_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_611:
    $I10 = self.'from'()
    ne $I10, -1, rxscan480_done
    goto rxscan480_scan
  rxscan480_loop:
    (rx476_pos) = rx476_cur."from"()
    inc rx476_pos
    rx476_cur."!cursor_from"(rx476_pos)
    ge rx476_pos, rx476_eos, rxscan480_done
  rxscan480_scan:
    set_addr $I10, rxscan480_loop
    rx476_cur."!mark_push"(0, rx476_pos, $I10)
  rxscan480_done:
.annotate 'line', 262
  # rx subrule "colonpair" subtype=capture negate=
    rx476_cur."!cursor_pos"(rx476_pos)
    $P10 = rx476_cur."colonpair"()
    unless $P10, rx476_fail
    rx476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx476_pos = $P10."pos"()
  # rx pass
    rx476_cur."!cursor_pass"(rx476_pos, "term:sym<colonpair>")
    if_null rx476_debug, debug_612
    rx476_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx476_pos)
  debug_612:
    .return (rx476_cur)
  rx476_restart:
.annotate 'line', 4
    if_null rx476_debug, debug_613
    rx476_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_613:
  rx476_fail:
    (rx476_rep, rx476_pos, $I10, $P10) = rx476_cur."!mark_fail"(0)
    lt rx476_pos, -1, rx476_done
    eq rx476_pos, -1, rx476_fail
    jump $I10
  rx476_done:
    rx476_cur."!cursor_fail"()
    if_null rx476_debug, debug_614
    rx476_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_614:
    .return (rx476_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("106_1300060177.262") :method
.annotate 'line', 4
    $P478 = self."!PREFIX__!subrule"("colonpair", "")
    new $P479, "ResizablePMCArray"
    push $P479, $P478
    .return ($P479)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("107_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx482_tgt
    .local int rx482_pos
    .local int rx482_off
    .local int rx482_eos
    .local int rx482_rep
    .local pmc rx482_cur
    .local pmc rx482_debug
    (rx482_cur, rx482_pos, rx482_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx482_cur
    .local pmc match
    .lex "$/", match
    length rx482_eos, rx482_tgt
    gt rx482_pos, rx482_eos, rx482_done
    set rx482_off, 0
    lt rx482_pos, 2, rx482_start
    sub rx482_off, rx482_pos, 1
    substr rx482_tgt, rx482_tgt, rx482_off
  rx482_start:
    eq $I10, 1, rx482_restart
    if_null rx482_debug, debug_615
    rx482_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_615:
    $I10 = self.'from'()
    ne $I10, -1, rxscan486_done
    goto rxscan486_scan
  rxscan486_loop:
    (rx482_pos) = rx482_cur."from"()
    inc rx482_pos
    rx482_cur."!cursor_from"(rx482_pos)
    ge rx482_pos, rx482_eos, rxscan486_done
  rxscan486_scan:
    set_addr $I10, rxscan486_loop
    rx482_cur."!mark_push"(0, rx482_pos, $I10)
  rxscan486_done:
.annotate 'line', 263
  # rx subrule "variable" subtype=capture negate=
    rx482_cur."!cursor_pos"(rx482_pos)
    $P10 = rx482_cur."variable"()
    unless $P10, rx482_fail
    rx482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx482_pos = $P10."pos"()
  # rx pass
    rx482_cur."!cursor_pass"(rx482_pos, "term:sym<variable>")
    if_null rx482_debug, debug_616
    rx482_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx482_pos)
  debug_616:
    .return (rx482_cur)
  rx482_restart:
.annotate 'line', 4
    if_null rx482_debug, debug_617
    rx482_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_617:
  rx482_fail:
    (rx482_rep, rx482_pos, $I10, $P10) = rx482_cur."!mark_fail"(0)
    lt rx482_pos, -1, rx482_done
    eq rx482_pos, -1, rx482_fail
    jump $I10
  rx482_done:
    rx482_cur."!cursor_fail"()
    if_null rx482_debug, debug_618
    rx482_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_618:
    .return (rx482_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("108_1300060177.262") :method
.annotate 'line', 4
    $P484 = self."!PREFIX__!subrule"("variable", "")
    new $P485, "ResizablePMCArray"
    push $P485, $P484
    .return ($P485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("109_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx488_tgt
    .local int rx488_pos
    .local int rx488_off
    .local int rx488_eos
    .local int rx488_rep
    .local pmc rx488_cur
    .local pmc rx488_debug
    (rx488_cur, rx488_pos, rx488_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx488_cur
    .local pmc match
    .lex "$/", match
    length rx488_eos, rx488_tgt
    gt rx488_pos, rx488_eos, rx488_done
    set rx488_off, 0
    lt rx488_pos, 2, rx488_start
    sub rx488_off, rx488_pos, 1
    substr rx488_tgt, rx488_tgt, rx488_off
  rx488_start:
    eq $I10, 1, rx488_restart
    if_null rx488_debug, debug_619
    rx488_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_619:
    $I10 = self.'from'()
    ne $I10, -1, rxscan492_done
    goto rxscan492_scan
  rxscan492_loop:
    (rx488_pos) = rx488_cur."from"()
    inc rx488_pos
    rx488_cur."!cursor_from"(rx488_pos)
    ge rx488_pos, rx488_eos, rxscan492_done
  rxscan492_scan:
    set_addr $I10, rxscan492_loop
    rx488_cur."!mark_push"(0, rx488_pos, $I10)
  rxscan492_done:
.annotate 'line', 264
  # rx subrule "package_declarator" subtype=capture negate=
    rx488_cur."!cursor_pos"(rx488_pos)
    $P10 = rx488_cur."package_declarator"()
    unless $P10, rx488_fail
    rx488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx488_pos = $P10."pos"()
  # rx pass
    rx488_cur."!cursor_pass"(rx488_pos, "term:sym<package_declarator>")
    if_null rx488_debug, debug_620
    rx488_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx488_pos)
  debug_620:
    .return (rx488_cur)
  rx488_restart:
.annotate 'line', 4
    if_null rx488_debug, debug_621
    rx488_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_621:
  rx488_fail:
    (rx488_rep, rx488_pos, $I10, $P10) = rx488_cur."!mark_fail"(0)
    lt rx488_pos, -1, rx488_done
    eq rx488_pos, -1, rx488_fail
    jump $I10
  rx488_done:
    rx488_cur."!cursor_fail"()
    if_null rx488_debug, debug_622
    rx488_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_622:
    .return (rx488_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("110_1300060177.262") :method
.annotate 'line', 4
    $P490 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P491, "ResizablePMCArray"
    push $P491, $P490
    .return ($P491)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("111_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx494_tgt
    .local int rx494_pos
    .local int rx494_off
    .local int rx494_eos
    .local int rx494_rep
    .local pmc rx494_cur
    .local pmc rx494_debug
    (rx494_cur, rx494_pos, rx494_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx494_cur
    .local pmc match
    .lex "$/", match
    length rx494_eos, rx494_tgt
    gt rx494_pos, rx494_eos, rx494_done
    set rx494_off, 0
    lt rx494_pos, 2, rx494_start
    sub rx494_off, rx494_pos, 1
    substr rx494_tgt, rx494_tgt, rx494_off
  rx494_start:
    eq $I10, 1, rx494_restart
    if_null rx494_debug, debug_623
    rx494_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan498_done
    goto rxscan498_scan
  rxscan498_loop:
    (rx494_pos) = rx494_cur."from"()
    inc rx494_pos
    rx494_cur."!cursor_from"(rx494_pos)
    ge rx494_pos, rx494_eos, rxscan498_done
  rxscan498_scan:
    set_addr $I10, rxscan498_loop
    rx494_cur."!mark_push"(0, rx494_pos, $I10)
  rxscan498_done:
.annotate 'line', 265
  # rx subrule "scope_declarator" subtype=capture negate=
    rx494_cur."!cursor_pos"(rx494_pos)
    $P10 = rx494_cur."scope_declarator"()
    unless $P10, rx494_fail
    rx494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx494_pos = $P10."pos"()
  # rx pass
    rx494_cur."!cursor_pass"(rx494_pos, "term:sym<scope_declarator>")
    if_null rx494_debug, debug_624
    rx494_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx494_pos)
  debug_624:
    .return (rx494_cur)
  rx494_restart:
.annotate 'line', 4
    if_null rx494_debug, debug_625
    rx494_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_625:
  rx494_fail:
    (rx494_rep, rx494_pos, $I10, $P10) = rx494_cur."!mark_fail"(0)
    lt rx494_pos, -1, rx494_done
    eq rx494_pos, -1, rx494_fail
    jump $I10
  rx494_done:
    rx494_cur."!cursor_fail"()
    if_null rx494_debug, debug_626
    rx494_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_626:
    .return (rx494_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("112_1300060177.262") :method
.annotate 'line', 4
    $P496 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P497, "ResizablePMCArray"
    push $P497, $P496
    .return ($P497)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("113_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx500_tgt
    .local int rx500_pos
    .local int rx500_off
    .local int rx500_eos
    .local int rx500_rep
    .local pmc rx500_cur
    .local pmc rx500_debug
    (rx500_cur, rx500_pos, rx500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx500_cur
    .local pmc match
    .lex "$/", match
    length rx500_eos, rx500_tgt
    gt rx500_pos, rx500_eos, rx500_done
    set rx500_off, 0
    lt rx500_pos, 2, rx500_start
    sub rx500_off, rx500_pos, 1
    substr rx500_tgt, rx500_tgt, rx500_off
  rx500_start:
    eq $I10, 1, rx500_restart
    if_null rx500_debug, debug_627
    rx500_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_627:
    $I10 = self.'from'()
    ne $I10, -1, rxscan504_done
    goto rxscan504_scan
  rxscan504_loop:
    (rx500_pos) = rx500_cur."from"()
    inc rx500_pos
    rx500_cur."!cursor_from"(rx500_pos)
    ge rx500_pos, rx500_eos, rxscan504_done
  rxscan504_scan:
    set_addr $I10, rxscan504_loop
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  rxscan504_done:
.annotate 'line', 266
  # rx subrule "routine_declarator" subtype=capture negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."routine_declarator"()
    unless $P10, rx500_fail
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx500_pos = $P10."pos"()
  # rx pass
    rx500_cur."!cursor_pass"(rx500_pos, "term:sym<routine_declarator>")
    if_null rx500_debug, debug_628
    rx500_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx500_pos)
  debug_628:
    .return (rx500_cur)
  rx500_restart:
.annotate 'line', 4
    if_null rx500_debug, debug_629
    rx500_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_629:
  rx500_fail:
    (rx500_rep, rx500_pos, $I10, $P10) = rx500_cur."!mark_fail"(0)
    lt rx500_pos, -1, rx500_done
    eq rx500_pos, -1, rx500_fail
    jump $I10
  rx500_done:
    rx500_cur."!cursor_fail"()
    if_null rx500_debug, debug_630
    rx500_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_630:
    .return (rx500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("114_1300060177.262") :method
.annotate 'line', 4
    $P502 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P503, "ResizablePMCArray"
    push $P503, $P502
    .return ($P503)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("115_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P516 = "118_1300060177.262" 
    capture_lex $P516
    .const 'Sub' $P511 = "117_1300060177.262" 
    capture_lex $P511
    .local string rx506_tgt
    .local int rx506_pos
    .local int rx506_off
    .local int rx506_eos
    .local int rx506_rep
    .local pmc rx506_cur
    .local pmc rx506_debug
    (rx506_cur, rx506_pos, rx506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx506_cur
    .local pmc match
    .lex "$/", match
    length rx506_eos, rx506_tgt
    gt rx506_pos, rx506_eos, rx506_done
    set rx506_off, 0
    lt rx506_pos, 2, rx506_start
    sub rx506_off, rx506_pos, 1
    substr rx506_tgt, rx506_tgt, rx506_off
  rx506_start:
    eq $I10, 1, rx506_restart
    if_null rx506_debug, debug_631
    rx506_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_631:
    $I10 = self.'from'()
    ne $I10, -1, rxscan509_done
    goto rxscan509_scan
  rxscan509_loop:
    (rx506_pos) = rx506_cur."from"()
    inc rx506_pos
    rx506_cur."!cursor_from"(rx506_pos)
    ge rx506_pos, rx506_eos, rxscan509_done
  rxscan509_scan:
    set_addr $I10, rxscan509_loop
    rx506_cur."!mark_push"(0, rx506_pos, $I10)
  rxscan509_done:
.annotate 'line', 268
  # rx subrule "before" subtype=zerowidth negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    .const 'Sub' $P511 = "117_1300060177.262" 
    capture_lex $P511
    $P10 = rx506_cur."before"($P511)
    unless $P10, rx506_fail
.annotate 'line', 269
  # rx subrule "before" subtype=zerowidth negate=1
    rx506_cur."!cursor_pos"(rx506_pos)
    .const 'Sub' $P516 = "118_1300060177.262" 
    capture_lex $P516
    $P10 = rx506_cur."before"($P516)
    if $P10, rx506_fail
.annotate 'line', 270
  # rx subrule "multi_declarator" subtype=capture negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."multi_declarator"()
    unless $P10, rx506_fail
    rx506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx506_pos = $P10."pos"()
.annotate 'line', 267
  # rx pass
    rx506_cur."!cursor_pass"(rx506_pos, "term:sym<multi_declarator>")
    if_null rx506_debug, debug_640
    rx506_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx506_pos)
  debug_640:
    .return (rx506_cur)
  rx506_restart:
.annotate 'line', 4
    if_null rx506_debug, debug_641
    rx506_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_641:
  rx506_fail:
    (rx506_rep, rx506_pos, $I10, $P10) = rx506_cur."!mark_fail"(0)
    lt rx506_pos, -1, rx506_done
    eq rx506_pos, -1, rx506_fail
    jump $I10
  rx506_done:
    rx506_cur."!cursor_fail"()
    if_null rx506_debug, debug_642
    rx506_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_642:
    .return (rx506_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("116_1300060177.262") :method
.annotate 'line', 4
    new $P508, "ResizablePMCArray"
    push $P508, ""
    .return ($P508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block510"  :anon :subid("117_1300060177.262") :method :outer("115_1300060177.262")
.annotate 'line', 268
    .local string rx512_tgt
    .local int rx512_pos
    .local int rx512_off
    .local int rx512_eos
    .local int rx512_rep
    .local pmc rx512_cur
    .local pmc rx512_debug
    (rx512_cur, rx512_pos, rx512_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx512_cur
    .local pmc match
    .lex "$/", match
    length rx512_eos, rx512_tgt
    gt rx512_pos, rx512_eos, rx512_done
    set rx512_off, 0
    lt rx512_pos, 2, rx512_start
    sub rx512_off, rx512_pos, 1
    substr rx512_tgt, rx512_tgt, rx512_off
  rx512_start:
    eq $I10, 1, rx512_restart
    if_null rx512_debug, debug_632
    rx512_cur."!cursor_debug"("START", "")
  debug_632:
    $I10 = self.'from'()
    ne $I10, -1, rxscan513_done
    goto rxscan513_scan
  rxscan513_loop:
    (rx512_pos) = rx512_cur."from"()
    inc rx512_pos
    rx512_cur."!cursor_from"(rx512_pos)
    ge rx512_pos, rx512_eos, rxscan513_done
  rxscan513_scan:
    set_addr $I10, rxscan513_loop
    rx512_cur."!mark_push"(0, rx512_pos, $I10)
  rxscan513_done:
  alt514_0:
    set_addr $I10, alt514_1
    rx512_cur."!mark_push"(0, rx512_pos, $I10)
  # rx literal  "multi"
    add $I11, rx512_pos, 5
    gt $I11, rx512_eos, rx512_fail
    sub $I11, rx512_pos, rx512_off
    substr $S10, rx512_tgt, $I11, 5
    ne $S10, "multi", rx512_fail
    add rx512_pos, 5
    goto alt514_end
  alt514_1:
    set_addr $I10, alt514_2
    rx512_cur."!mark_push"(0, rx512_pos, $I10)
  # rx literal  "proto"
    add $I11, rx512_pos, 5
    gt $I11, rx512_eos, rx512_fail
    sub $I11, rx512_pos, rx512_off
    substr $S10, rx512_tgt, $I11, 5
    ne $S10, "proto", rx512_fail
    add rx512_pos, 5
    goto alt514_end
  alt514_2:
  # rx literal  "only"
    add $I11, rx512_pos, 4
    gt $I11, rx512_eos, rx512_fail
    sub $I11, rx512_pos, rx512_off
    substr $S10, rx512_tgt, $I11, 4
    ne $S10, "only", rx512_fail
    add rx512_pos, 4
  alt514_end:
  # rx pass
    rx512_cur."!cursor_pass"(rx512_pos, "")
    if_null rx512_debug, debug_633
    rx512_cur."!cursor_debug"("PASS", "", " at pos=", rx512_pos)
  debug_633:
    .return (rx512_cur)
  rx512_restart:
    if_null rx512_debug, debug_634
    rx512_cur."!cursor_debug"("NEXT", "")
  debug_634:
  rx512_fail:
    (rx512_rep, rx512_pos, $I10, $P10) = rx512_cur."!mark_fail"(0)
    lt rx512_pos, -1, rx512_done
    eq rx512_pos, -1, rx512_fail
    jump $I10
  rx512_done:
    rx512_cur."!cursor_fail"()
    if_null rx512_debug, debug_635
    rx512_cur."!cursor_debug"("FAIL", "")
  debug_635:
    .return (rx512_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block515"  :anon :subid("118_1300060177.262") :method :outer("115_1300060177.262")
.annotate 'line', 269
    .local string rx517_tgt
    .local int rx517_pos
    .local int rx517_off
    .local int rx517_eos
    .local int rx517_rep
    .local pmc rx517_cur
    .local pmc rx517_debug
    (rx517_cur, rx517_pos, rx517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx517_cur
    .local pmc match
    .lex "$/", match
    length rx517_eos, rx517_tgt
    gt rx517_pos, rx517_eos, rx517_done
    set rx517_off, 0
    lt rx517_pos, 2, rx517_start
    sub rx517_off, rx517_pos, 1
    substr rx517_tgt, rx517_tgt, rx517_off
  rx517_start:
    eq $I10, 1, rx517_restart
    if_null rx517_debug, debug_636
    rx517_cur."!cursor_debug"("START", "")
  debug_636:
    $I10 = self.'from'()
    ne $I10, -1, rxscan518_done
    goto rxscan518_scan
  rxscan518_loop:
    (rx517_pos) = rx517_cur."from"()
    inc rx517_pos
    rx517_cur."!cursor_from"(rx517_pos)
    ge rx517_pos, rx517_eos, rxscan518_done
  rxscan518_scan:
    set_addr $I10, rxscan518_loop
    rx517_cur."!mark_push"(0, rx517_pos, $I10)
  rxscan518_done:
  # rx literal  "proto"
    add $I11, rx517_pos, 5
    gt $I11, rx517_eos, rx517_fail
    sub $I11, rx517_pos, rx517_off
    substr $S10, rx517_tgt, $I11, 5
    ne $S10, "proto", rx517_fail
    add rx517_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx517_cur."!cursor_pos"(rx517_pos)
    $P10 = rx517_cur."ws"()
    unless $P10, rx517_fail
    rx517_pos = $P10."pos"()
  alt519_0:
    set_addr $I10, alt519_1
    rx517_cur."!mark_push"(0, rx517_pos, $I10)
  # rx literal  "regex"
    add $I11, rx517_pos, 5
    gt $I11, rx517_eos, rx517_fail
    sub $I11, rx517_pos, rx517_off
    substr $S10, rx517_tgt, $I11, 5
    ne $S10, "regex", rx517_fail
    add rx517_pos, 5
    goto alt519_end
  alt519_1:
    set_addr $I10, alt519_2
    rx517_cur."!mark_push"(0, rx517_pos, $I10)
  # rx literal  "token"
    add $I11, rx517_pos, 5
    gt $I11, rx517_eos, rx517_fail
    sub $I11, rx517_pos, rx517_off
    substr $S10, rx517_tgt, $I11, 5
    ne $S10, "token", rx517_fail
    add rx517_pos, 5
    goto alt519_end
  alt519_2:
  # rx literal  "rule"
    add $I11, rx517_pos, 4
    gt $I11, rx517_eos, rx517_fail
    sub $I11, rx517_pos, rx517_off
    substr $S10, rx517_tgt, $I11, 4
    ne $S10, "rule", rx517_fail
    add rx517_pos, 4
  alt519_end:
  # rx pass
    rx517_cur."!cursor_pass"(rx517_pos, "")
    if_null rx517_debug, debug_637
    rx517_cur."!cursor_debug"("PASS", "", " at pos=", rx517_pos)
  debug_637:
    .return (rx517_cur)
  rx517_restart:
    if_null rx517_debug, debug_638
    rx517_cur."!cursor_debug"("NEXT", "")
  debug_638:
  rx517_fail:
    (rx517_rep, rx517_pos, $I10, $P10) = rx517_cur."!mark_fail"(0)
    lt rx517_pos, -1, rx517_done
    eq rx517_pos, -1, rx517_fail
    jump $I10
  rx517_done:
    rx517_cur."!cursor_fail"()
    if_null rx517_debug, debug_639
    rx517_cur."!cursor_debug"("FAIL", "")
  debug_639:
    .return (rx517_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("119_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx521_tgt
    .local int rx521_pos
    .local int rx521_off
    .local int rx521_eos
    .local int rx521_rep
    .local pmc rx521_cur
    .local pmc rx521_debug
    (rx521_cur, rx521_pos, rx521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx521_cur
    .local pmc match
    .lex "$/", match
    length rx521_eos, rx521_tgt
    gt rx521_pos, rx521_eos, rx521_done
    set rx521_off, 0
    lt rx521_pos, 2, rx521_start
    sub rx521_off, rx521_pos, 1
    substr rx521_tgt, rx521_tgt, rx521_off
  rx521_start:
    eq $I10, 1, rx521_restart
    if_null rx521_debug, debug_643
    rx521_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_643:
    $I10 = self.'from'()
    ne $I10, -1, rxscan525_done
    goto rxscan525_scan
  rxscan525_loop:
    (rx521_pos) = rx521_cur."from"()
    inc rx521_pos
    rx521_cur."!cursor_from"(rx521_pos)
    ge rx521_pos, rx521_eos, rxscan525_done
  rxscan525_scan:
    set_addr $I10, rxscan525_loop
    rx521_cur."!mark_push"(0, rx521_pos, $I10)
  rxscan525_done:
.annotate 'line', 272
  # rx subrule "regex_declarator" subtype=capture negate=
    rx521_cur."!cursor_pos"(rx521_pos)
    $P10 = rx521_cur."regex_declarator"()
    unless $P10, rx521_fail
    rx521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx521_pos = $P10."pos"()
  # rx pass
    rx521_cur."!cursor_pass"(rx521_pos, "term:sym<regex_declarator>")
    if_null rx521_debug, debug_644
    rx521_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx521_pos)
  debug_644:
    .return (rx521_cur)
  rx521_restart:
.annotate 'line', 4
    if_null rx521_debug, debug_645
    rx521_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_645:
  rx521_fail:
    (rx521_rep, rx521_pos, $I10, $P10) = rx521_cur."!mark_fail"(0)
    lt rx521_pos, -1, rx521_done
    eq rx521_pos, -1, rx521_fail
    jump $I10
  rx521_done:
    rx521_cur."!cursor_fail"()
    if_null rx521_debug, debug_646
    rx521_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_646:
    .return (rx521_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("120_1300060177.262") :method
.annotate 'line', 4
    $P523 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P524, "ResizablePMCArray"
    push $P524, $P523
    .return ($P524)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("121_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx527_tgt
    .local int rx527_pos
    .local int rx527_off
    .local int rx527_eos
    .local int rx527_rep
    .local pmc rx527_cur
    .local pmc rx527_debug
    (rx527_cur, rx527_pos, rx527_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx527_cur
    .local pmc match
    .lex "$/", match
    length rx527_eos, rx527_tgt
    gt rx527_pos, rx527_eos, rx527_done
    set rx527_off, 0
    lt rx527_pos, 2, rx527_start
    sub rx527_off, rx527_pos, 1
    substr rx527_tgt, rx527_tgt, rx527_off
  rx527_start:
    eq $I10, 1, rx527_restart
    if_null rx527_debug, debug_647
    rx527_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_647:
    $I10 = self.'from'()
    ne $I10, -1, rxscan531_done
    goto rxscan531_scan
  rxscan531_loop:
    (rx527_pos) = rx527_cur."from"()
    inc rx527_pos
    rx527_cur."!cursor_from"(rx527_pos)
    ge rx527_pos, rx527_eos, rxscan531_done
  rxscan531_scan:
    set_addr $I10, rxscan531_loop
    rx527_cur."!mark_push"(0, rx527_pos, $I10)
  rxscan531_done:
.annotate 'line', 273
  # rx subrule "statement_prefix" subtype=capture negate=
    rx527_cur."!cursor_pos"(rx527_pos)
    $P10 = rx527_cur."statement_prefix"()
    unless $P10, rx527_fail
    rx527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx527_pos = $P10."pos"()
  # rx pass
    rx527_cur."!cursor_pass"(rx527_pos, "term:sym<statement_prefix>")
    if_null rx527_debug, debug_648
    rx527_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx527_pos)
  debug_648:
    .return (rx527_cur)
  rx527_restart:
.annotate 'line', 4
    if_null rx527_debug, debug_649
    rx527_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_649:
  rx527_fail:
    (rx527_rep, rx527_pos, $I10, $P10) = rx527_cur."!mark_fail"(0)
    lt rx527_pos, -1, rx527_done
    eq rx527_pos, -1, rx527_fail
    jump $I10
  rx527_done:
    rx527_cur."!cursor_fail"()
    if_null rx527_debug, debug_650
    rx527_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_650:
    .return (rx527_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("122_1300060177.262") :method
.annotate 'line', 4
    $P529 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P530, "ResizablePMCArray"
    push $P530, $P529
    .return ($P530)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("123_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx533_tgt
    .local int rx533_pos
    .local int rx533_off
    .local int rx533_eos
    .local int rx533_rep
    .local pmc rx533_cur
    .local pmc rx533_debug
    (rx533_cur, rx533_pos, rx533_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx533_cur
    .local pmc match
    .lex "$/", match
    length rx533_eos, rx533_tgt
    gt rx533_pos, rx533_eos, rx533_done
    set rx533_off, 0
    lt rx533_pos, 2, rx533_start
    sub rx533_off, rx533_pos, 1
    substr rx533_tgt, rx533_tgt, rx533_off
  rx533_start:
    eq $I10, 1, rx533_restart
    if_null rx533_debug, debug_651
    rx533_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_651:
    $I10 = self.'from'()
    ne $I10, -1, rxscan536_done
    goto rxscan536_scan
  rxscan536_loop:
    (rx533_pos) = rx533_cur."from"()
    inc rx533_pos
    rx533_cur."!cursor_from"(rx533_pos)
    ge rx533_pos, rx533_eos, rxscan536_done
  rxscan536_scan:
    set_addr $I10, rxscan536_loop
    rx533_cur."!mark_push"(0, rx533_pos, $I10)
  rxscan536_done:
.annotate 'line', 274
  # rx subrule "lambda" subtype=zerowidth negate=
    rx533_cur."!cursor_pos"(rx533_pos)
    $P10 = rx533_cur."lambda"()
    unless $P10, rx533_fail
  # rx subrule "pblock" subtype=capture negate=
    rx533_cur."!cursor_pos"(rx533_pos)
    $P10 = rx533_cur."pblock"()
    unless $P10, rx533_fail
    rx533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx533_pos = $P10."pos"()
  # rx pass
    rx533_cur."!cursor_pass"(rx533_pos, "term:sym<lambda>")
    if_null rx533_debug, debug_652
    rx533_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx533_pos)
  debug_652:
    .return (rx533_cur)
  rx533_restart:
.annotate 'line', 4
    if_null rx533_debug, debug_653
    rx533_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_653:
  rx533_fail:
    (rx533_rep, rx533_pos, $I10, $P10) = rx533_cur."!mark_fail"(0)
    lt rx533_pos, -1, rx533_done
    eq rx533_pos, -1, rx533_fail
    jump $I10
  rx533_done:
    rx533_cur."!cursor_fail"()
    if_null rx533_debug, debug_654
    rx533_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_654:
    .return (rx533_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("124_1300060177.262") :method
.annotate 'line', 4
    new $P535, "ResizablePMCArray"
    push $P535, ""
    .return ($P535)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("125_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx538_tgt
    .local int rx538_pos
    .local int rx538_off
    .local int rx538_eos
    .local int rx538_rep
    .local pmc rx538_cur
    .local pmc rx538_debug
    (rx538_cur, rx538_pos, rx538_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx538_cur
    .local pmc match
    .lex "$/", match
    length rx538_eos, rx538_tgt
    gt rx538_pos, rx538_eos, rx538_done
    set rx538_off, 0
    lt rx538_pos, 2, rx538_start
    sub rx538_off, rx538_pos, 1
    substr rx538_tgt, rx538_tgt, rx538_off
  rx538_start:
    eq $I10, 1, rx538_restart
    if_null rx538_debug, debug_655
    rx538_cur."!cursor_debug"("START", "fatarrow")
  debug_655:
    $I10 = self.'from'()
    ne $I10, -1, rxscan542_done
    goto rxscan542_scan
  rxscan542_loop:
    (rx538_pos) = rx538_cur."from"()
    inc rx538_pos
    rx538_cur."!cursor_from"(rx538_pos)
    ge rx538_pos, rx538_eos, rxscan542_done
  rxscan542_scan:
    set_addr $I10, rxscan542_loop
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  rxscan542_done:
.annotate 'line', 277
  # rx subrule "identifier" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."identifier"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx538_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx538_pos, rx538_off
    set rx538_rep, 0
    sub $I12, rx538_eos, rx538_pos
  rxenumcharlistq543_loop:
    le $I12, 0, rxenumcharlistq543_done
    substr $S10, rx538_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq543_done
    inc rx538_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq543_loop
  rxenumcharlistq543_done:
    add rx538_pos, rx538_pos, rx538_rep
  # rx literal  "=>"
    add $I11, rx538_pos, 2
    gt $I11, rx538_eos, rx538_fail
    sub $I11, rx538_pos, rx538_off
    substr $S10, rx538_tgt, $I11, 2
    ne $S10, "=>", rx538_fail
    add rx538_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."EXPR"("i=")
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx538_pos = $P10."pos"()
.annotate 'line', 276
  # rx pass
    rx538_cur."!cursor_pass"(rx538_pos, "fatarrow")
    if_null rx538_debug, debug_656
    rx538_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx538_pos)
  debug_656:
    .return (rx538_cur)
  rx538_restart:
.annotate 'line', 4
    if_null rx538_debug, debug_657
    rx538_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_657:
  rx538_fail:
    (rx538_rep, rx538_pos, $I10, $P10) = rx538_cur."!mark_fail"(0)
    lt rx538_pos, -1, rx538_done
    eq rx538_pos, -1, rx538_fail
    jump $I10
  rx538_done:
    rx538_cur."!cursor_fail"()
    if_null rx538_debug, debug_658
    rx538_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_658:
    .return (rx538_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("126_1300060177.262") :method
.annotate 'line', 4
    $P540 = self."!PREFIX__!subrule"("identifier", "")
    new $P541, "ResizablePMCArray"
    push $P541, $P540
    .return ($P541)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("127_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx545_tgt
    .local int rx545_pos
    .local int rx545_off
    .local int rx545_eos
    .local int rx545_rep
    .local pmc rx545_cur
    .local pmc rx545_debug
    (rx545_cur, rx545_pos, rx545_tgt, $I10) = self."!cursor_start"()
    rx545_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx545_cur
    .local pmc match
    .lex "$/", match
    length rx545_eos, rx545_tgt
    gt rx545_pos, rx545_eos, rx545_done
    set rx545_off, 0
    lt rx545_pos, 2, rx545_start
    sub rx545_off, rx545_pos, 1
    substr rx545_tgt, rx545_tgt, rx545_off
  rx545_start:
    eq $I10, 1, rx545_restart
    if_null rx545_debug, debug_659
    rx545_cur."!cursor_debug"("START", "colonpair")
  debug_659:
    $I10 = self.'from'()
    ne $I10, -1, rxscan551_done
    goto rxscan551_scan
  rxscan551_loop:
    (rx545_pos) = rx545_cur."from"()
    inc rx545_pos
    rx545_cur."!cursor_from"(rx545_pos)
    ge rx545_pos, rx545_eos, rxscan551_done
  rxscan551_scan:
    set_addr $I10, rxscan551_loop
    rx545_cur."!mark_push"(0, rx545_pos, $I10)
  rxscan551_done:
.annotate 'line', 281
  # rx literal  ":"
    add $I11, rx545_pos, 1
    gt $I11, rx545_eos, rx545_fail
    sub $I11, rx545_pos, rx545_off
    ord $I11, rx545_tgt, $I11
    ne $I11, 58, rx545_fail
    add rx545_pos, 1
  alt552_0:
.annotate 'line', 282
    set_addr $I10, alt552_1
    rx545_cur."!mark_push"(0, rx545_pos, $I10)
.annotate 'line', 283
  # rx subcapture "not"
    set_addr $I10, rxcap_553_fail
    rx545_cur."!mark_push"(0, rx545_pos, $I10)
  # rx literal  "!"
    add $I11, rx545_pos, 1
    gt $I11, rx545_eos, rx545_fail
    sub $I11, rx545_pos, rx545_off
    ord $I11, rx545_tgt, $I11
    ne $I11, 33, rx545_fail
    add rx545_pos, 1
    set_addr $I10, rxcap_553_fail
    ($I12, $I11) = rx545_cur."!mark_peek"($I10)
    rx545_cur."!cursor_pos"($I11)
    ($P10) = rx545_cur."!cursor_start"()
    $P10."!cursor_pass"(rx545_pos, "")
    rx545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_553_done
  rxcap_553_fail:
    goto rx545_fail
  rxcap_553_done:
  # rx subrule "identifier" subtype=capture negate=
    rx545_cur."!cursor_pos"(rx545_pos)
    $P10 = rx545_cur."identifier"()
    unless $P10, rx545_fail
    rx545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx545_pos = $P10."pos"()
    goto alt552_end
  alt552_1:
    set_addr $I10, alt552_2
    rx545_cur."!mark_push"(0, rx545_pos, $I10)
.annotate 'line', 284
  # rx subrule "identifier" subtype=capture negate=
    rx545_cur."!cursor_pos"(rx545_pos)
    $P10 = rx545_cur."identifier"()
    unless $P10, rx545_fail
    rx545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx545_pos = $P10."pos"()
  # rx rxquantr554 ** 0..1
    set_addr $I10, rxquantr554_done
    rx545_cur."!mark_push"(0, rx545_pos, $I10)
  rxquantr554_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx545_cur."!cursor_pos"(rx545_pos)
    $P10 = rx545_cur."circumfix"()
    unless $P10, rx545_fail
    goto rxsubrule555_pass
  rxsubrule555_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx545_fail
  rxsubrule555_pass:
    set_addr $I10, rxsubrule555_back
    rx545_cur."!mark_push"(0, rx545_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx545_pos = $P10."pos"()
    set_addr $I10, rxquantr554_done
    (rx545_rep) = rx545_cur."!mark_commit"($I10)
  rxquantr554_done:
    goto alt552_end
  alt552_2:
.annotate 'line', 285
  # rx subrule "circumfix" subtype=capture negate=
    rx545_cur."!cursor_pos"(rx545_pos)
    $P10 = rx545_cur."circumfix"()
    unless $P10, rx545_fail
    rx545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx545_pos = $P10."pos"()
  alt552_end:
.annotate 'line', 280
  # rx pass
    rx545_cur."!cursor_pass"(rx545_pos, "colonpair")
    if_null rx545_debug, debug_660
    rx545_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx545_pos)
  debug_660:
    .return (rx545_cur)
  rx545_restart:
.annotate 'line', 4
    if_null rx545_debug, debug_661
    rx545_cur."!cursor_debug"("NEXT", "colonpair")
  debug_661:
  rx545_fail:
    (rx545_rep, rx545_pos, $I10, $P10) = rx545_cur."!mark_fail"(0)
    lt rx545_pos, -1, rx545_done
    eq rx545_pos, -1, rx545_fail
    jump $I10
  rx545_done:
    rx545_cur."!cursor_fail"()
    if_null rx545_debug, debug_662
    rx545_cur."!cursor_debug"("FAIL", "colonpair")
  debug_662:
    .return (rx545_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("128_1300060177.262") :method
.annotate 'line', 4
    $P547 = self."!PREFIX__!subrule"("circumfix", ":")
    $P548 = self."!PREFIX__!subrule"("identifier", ":")
    $P549 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P550, "ResizablePMCArray"
    push $P550, $P547
    push $P550, $P548
    push $P550, $P549
    .return ($P550)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("129_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx557_tgt
    .local int rx557_pos
    .local int rx557_off
    .local int rx557_eos
    .local int rx557_rep
    .local pmc rx557_cur
    .local pmc rx557_debug
    (rx557_cur, rx557_pos, rx557_tgt, $I10) = self."!cursor_start"()
    rx557_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx557_cur
    .local pmc match
    .lex "$/", match
    length rx557_eos, rx557_tgt
    gt rx557_pos, rx557_eos, rx557_done
    set rx557_off, 0
    lt rx557_pos, 2, rx557_start
    sub rx557_off, rx557_pos, 1
    substr rx557_tgt, rx557_tgt, rx557_off
  rx557_start:
    eq $I10, 1, rx557_restart
    if_null rx557_debug, debug_663
    rx557_cur."!cursor_debug"("START", "variable")
  debug_663:
    $I10 = self.'from'()
    ne $I10, -1, rxscan562_done
    goto rxscan562_scan
  rxscan562_loop:
    (rx557_pos) = rx557_cur."from"()
    inc rx557_pos
    rx557_cur."!cursor_from"(rx557_pos)
    ge rx557_pos, rx557_eos, rxscan562_done
  rxscan562_scan:
    set_addr $I10, rxscan562_loop
    rx557_cur."!mark_push"(0, rx557_pos, $I10)
  rxscan562_done:
  alt563_0:
.annotate 'line', 289
    set_addr $I10, alt563_1
    rx557_cur."!mark_push"(0, rx557_pos, $I10)
.annotate 'line', 290
  # rx subrule "sigil" subtype=capture negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."sigil"()
    unless $P10, rx557_fail
    rx557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx557_pos = $P10."pos"()
  # rx rxquantr564 ** 0..1
    set_addr $I10, rxquantr564_done
    rx557_cur."!mark_push"(0, rx557_pos, $I10)
  rxquantr564_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."twigil"()
    unless $P10, rx557_fail
    goto rxsubrule565_pass
  rxsubrule565_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx557_fail
  rxsubrule565_pass:
    set_addr $I10, rxsubrule565_back
    rx557_cur."!mark_push"(0, rx557_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx557_pos = $P10."pos"()
    set_addr $I10, rxquantr564_done
    (rx557_rep) = rx557_cur."!mark_commit"($I10)
  rxquantr564_done:
  # rx subrule "name" subtype=capture negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."name"()
    unless $P10, rx557_fail
    rx557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx557_pos = $P10."pos"()
    goto alt563_end
  alt563_1:
    set_addr $I10, alt563_2
    rx557_cur."!mark_push"(0, rx557_pos, $I10)
.annotate 'line', 291
  # rx subrule "sigil" subtype=capture negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."sigil"()
    unless $P10, rx557_fail
    rx557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx557_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx557_pos, rx557_off
    substr $S10, rx557_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx557_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."postcircumfix"()
    unless $P10, rx557_fail
    rx557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx557_pos = $P10."pos"()
    goto alt563_end
  alt563_2:
.annotate 'line', 292
  # rx subcapture "sigil"
    set_addr $I10, rxcap_566_fail
    rx557_cur."!mark_push"(0, rx557_pos, $I10)
  # rx literal  "$"
    add $I11, rx557_pos, 1
    gt $I11, rx557_eos, rx557_fail
    sub $I11, rx557_pos, rx557_off
    ord $I11, rx557_tgt, $I11
    ne $I11, 36, rx557_fail
    add rx557_pos, 1
    set_addr $I10, rxcap_566_fail
    ($I12, $I11) = rx557_cur."!mark_peek"($I10)
    rx557_cur."!cursor_pos"($I11)
    ($P10) = rx557_cur."!cursor_start"()
    $P10."!cursor_pass"(rx557_pos, "")
    rx557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_566_done
  rxcap_566_fail:
    goto rx557_fail
  rxcap_566_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_567_fail
    rx557_cur."!mark_push"(0, rx557_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx557_pos, rx557_eos, rx557_fail
    sub $I10, rx557_pos, rx557_off
    substr $S10, rx557_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx557_fail
    inc rx557_pos
    set_addr $I10, rxcap_567_fail
    ($I12, $I11) = rx557_cur."!mark_peek"($I10)
    rx557_cur."!cursor_pos"($I11)
    ($P10) = rx557_cur."!cursor_start"()
    $P10."!cursor_pass"(rx557_pos, "")
    rx557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_567_done
  rxcap_567_fail:
    goto rx557_fail
  rxcap_567_done:
  alt563_end:
.annotate 'line', 289
  # rx pass
    rx557_cur."!cursor_pass"(rx557_pos, "variable")
    if_null rx557_debug, debug_664
    rx557_cur."!cursor_debug"("PASS", "variable", " at pos=", rx557_pos)
  debug_664:
    .return (rx557_cur)
  rx557_restart:
.annotate 'line', 4
    if_null rx557_debug, debug_665
    rx557_cur."!cursor_debug"("NEXT", "variable")
  debug_665:
  rx557_fail:
    (rx557_rep, rx557_pos, $I10, $P10) = rx557_cur."!mark_fail"(0)
    lt rx557_pos, -1, rx557_done
    eq rx557_pos, -1, rx557_fail
    jump $I10
  rx557_done:
    rx557_cur."!cursor_fail"()
    if_null rx557_debug, debug_666
    rx557_cur."!cursor_debug"("FAIL", "variable")
  debug_666:
    .return (rx557_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("130_1300060177.262") :method
.annotate 'line', 4
    $P559 = self."!PREFIX__!subrule"("sigil", "")
    $P560 = self."!PREFIX__!subrule"("sigil", "")
    new $P561, "ResizablePMCArray"
    push $P561, "$!"
    push $P561, "$_"
    push $P561, "$/"
    push $P561, $P559
    push $P561, $P560
    .return ($P561)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("131_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx569_tgt
    .local int rx569_pos
    .local int rx569_off
    .local int rx569_eos
    .local int rx569_rep
    .local pmc rx569_cur
    .local pmc rx569_debug
    (rx569_cur, rx569_pos, rx569_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx569_cur
    .local pmc match
    .lex "$/", match
    length rx569_eos, rx569_tgt
    gt rx569_pos, rx569_eos, rx569_done
    set rx569_off, 0
    lt rx569_pos, 2, rx569_start
    sub rx569_off, rx569_pos, 1
    substr rx569_tgt, rx569_tgt, rx569_off
  rx569_start:
    eq $I10, 1, rx569_restart
    if_null rx569_debug, debug_667
    rx569_cur."!cursor_debug"("START", "sigil")
  debug_667:
    $I10 = self.'from'()
    ne $I10, -1, rxscan572_done
    goto rxscan572_scan
  rxscan572_loop:
    (rx569_pos) = rx569_cur."from"()
    inc rx569_pos
    rx569_cur."!cursor_from"(rx569_pos)
    ge rx569_pos, rx569_eos, rxscan572_done
  rxscan572_scan:
    set_addr $I10, rxscan572_loop
    rx569_cur."!mark_push"(0, rx569_pos, $I10)
  rxscan572_done:
.annotate 'line', 295
  # rx enumcharlist negate=0 
    ge rx569_pos, rx569_eos, rx569_fail
    sub $I10, rx569_pos, rx569_off
    substr $S10, rx569_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx569_fail
    inc rx569_pos
  # rx pass
    rx569_cur."!cursor_pass"(rx569_pos, "sigil")
    if_null rx569_debug, debug_668
    rx569_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx569_pos)
  debug_668:
    .return (rx569_cur)
  rx569_restart:
.annotate 'line', 4
    if_null rx569_debug, debug_669
    rx569_cur."!cursor_debug"("NEXT", "sigil")
  debug_669:
  rx569_fail:
    (rx569_rep, rx569_pos, $I10, $P10) = rx569_cur."!mark_fail"(0)
    lt rx569_pos, -1, rx569_done
    eq rx569_pos, -1, rx569_fail
    jump $I10
  rx569_done:
    rx569_cur."!cursor_fail"()
    if_null rx569_debug, debug_670
    rx569_cur."!cursor_debug"("FAIL", "sigil")
  debug_670:
    .return (rx569_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("132_1300060177.262") :method
.annotate 'line', 4
    new $P571, "ResizablePMCArray"
    push $P571, "&"
    push $P571, "%"
    push $P571, "@"
    push $P571, "$"
    .return ($P571)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("133_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx574_tgt
    .local int rx574_pos
    .local int rx574_off
    .local int rx574_eos
    .local int rx574_rep
    .local pmc rx574_cur
    .local pmc rx574_debug
    (rx574_cur, rx574_pos, rx574_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx574_cur
    .local pmc match
    .lex "$/", match
    length rx574_eos, rx574_tgt
    gt rx574_pos, rx574_eos, rx574_done
    set rx574_off, 0
    lt rx574_pos, 2, rx574_start
    sub rx574_off, rx574_pos, 1
    substr rx574_tgt, rx574_tgt, rx574_off
  rx574_start:
    eq $I10, 1, rx574_restart
    if_null rx574_debug, debug_671
    rx574_cur."!cursor_debug"("START", "twigil")
  debug_671:
    $I10 = self.'from'()
    ne $I10, -1, rxscan577_done
    goto rxscan577_scan
  rxscan577_loop:
    (rx574_pos) = rx574_cur."from"()
    inc rx574_pos
    rx574_cur."!cursor_from"(rx574_pos)
    ge rx574_pos, rx574_eos, rxscan577_done
  rxscan577_scan:
    set_addr $I10, rxscan577_loop
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  rxscan577_done:
.annotate 'line', 297
  # rx enumcharlist negate=0 
    ge rx574_pos, rx574_eos, rx574_fail
    sub $I10, rx574_pos, rx574_off
    substr $S10, rx574_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx574_fail
    inc rx574_pos
  # rx pass
    rx574_cur."!cursor_pass"(rx574_pos, "twigil")
    if_null rx574_debug, debug_672
    rx574_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx574_pos)
  debug_672:
    .return (rx574_cur)
  rx574_restart:
.annotate 'line', 4
    if_null rx574_debug, debug_673
    rx574_cur."!cursor_debug"("NEXT", "twigil")
  debug_673:
  rx574_fail:
    (rx574_rep, rx574_pos, $I10, $P10) = rx574_cur."!mark_fail"(0)
    lt rx574_pos, -1, rx574_done
    eq rx574_pos, -1, rx574_fail
    jump $I10
  rx574_done:
    rx574_cur."!cursor_fail"()
    if_null rx574_debug, debug_674
    rx574_cur."!cursor_debug"("FAIL", "twigil")
  debug_674:
    .return (rx574_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("134_1300060177.262") :method
.annotate 'line', 4
    new $P576, "ResizablePMCArray"
    push $P576, "?"
    push $P576, "!"
    push $P576, "*"
    .return ($P576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("135_1300060177.262")
    .param pmc param_579
.annotate 'line', 299
    .lex "self", param_579
    $P580 = param_579."!protoregex"("package_declarator")
    .return ($P580)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("136_1300060177.262")
    .param pmc param_582
.annotate 'line', 299
    .lex "self", param_582
    $P583 = param_582."!PREFIX__!protoregex"("package_declarator")
    .return ($P583)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("137_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 301
    new $P585, "Undef"
    .lex "$*PACKAGE-SETUP", $P585
.annotate 'line', 302
    new $P586, "Undef"
    .lex "$*PKGDECL", $P586
.annotate 'line', 4
    .local string rx587_tgt
    .local int rx587_pos
    .local int rx587_off
    .local int rx587_eos
    .local int rx587_rep
    .local pmc rx587_cur
    .local pmc rx587_debug
    (rx587_cur, rx587_pos, rx587_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx587_cur
    .local pmc match
    .lex "$/", match
    length rx587_eos, rx587_tgt
    gt rx587_pos, rx587_eos, rx587_done
    set rx587_off, 0
    lt rx587_pos, 2, rx587_start
    sub rx587_off, rx587_pos, 1
    substr rx587_tgt, rx587_tgt, rx587_off
  rx587_start:
    eq $I10, 1, rx587_restart
    if_null rx587_debug, debug_675
    rx587_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_675:
    $I10 = self.'from'()
    ne $I10, -1, rxscan591_done
    goto rxscan591_scan
  rxscan591_loop:
    (rx587_pos) = rx587_cur."from"()
    inc rx587_pos
    rx587_cur."!cursor_from"(rx587_pos)
    ge rx587_pos, rx587_eos, rxscan591_done
  rxscan591_scan:
    set_addr $I10, rxscan591_loop
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  rxscan591_done:
.annotate 'line', 301
    rx587_cur."!cursor_pos"(rx587_pos)
    get_hll_global $P592, ["PAST"], "Stmts"
    $P593 = $P592."new"()
    store_lex "$*PACKAGE-SETUP", $P593
.annotate 'line', 302
    rx587_cur."!cursor_pos"(rx587_pos)
    new $P594, "String"
    assign $P594, "module"
    store_lex "$*PKGDECL", $P594
.annotate 'line', 303
  # rx subcapture "sym"
    set_addr $I10, rxcap_595_fail
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  # rx literal  "module"
    add $I11, rx587_pos, 6
    gt $I11, rx587_eos, rx587_fail
    sub $I11, rx587_pos, rx587_off
    substr $S10, rx587_tgt, $I11, 6
    ne $S10, "module", rx587_fail
    add rx587_pos, 6
    set_addr $I10, rxcap_595_fail
    ($I12, $I11) = rx587_cur."!mark_peek"($I10)
    rx587_cur."!cursor_pos"($I11)
    ($P10) = rx587_cur."!cursor_start"()
    $P10."!cursor_pass"(rx587_pos, "")
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_595_done
  rxcap_595_fail:
    goto rx587_fail
  rxcap_595_done:
  # rx subrule "package_def" subtype=capture negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."package_def"()
    unless $P10, rx587_fail
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx587_pos = $P10."pos"()
.annotate 'line', 300
  # rx pass
    rx587_cur."!cursor_pass"(rx587_pos, "package_declarator:sym<module>")
    if_null rx587_debug, debug_676
    rx587_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx587_pos)
  debug_676:
    .return (rx587_cur)
  rx587_restart:
.annotate 'line', 4
    if_null rx587_debug, debug_677
    rx587_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_677:
  rx587_fail:
    (rx587_rep, rx587_pos, $I10, $P10) = rx587_cur."!mark_fail"(0)
    lt rx587_pos, -1, rx587_done
    eq rx587_pos, -1, rx587_fail
    jump $I10
  rx587_done:
    rx587_cur."!cursor_fail"()
    if_null rx587_debug, debug_678
    rx587_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_678:
    .return (rx587_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("138_1300060177.262") :method
.annotate 'line', 4
    $P589 = self."!PREFIX__!subrule"("package_def", "module")
    new $P590, "ResizablePMCArray"
    push $P590, $P589
    .return ($P590)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("139_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 306
    new $P597, "Undef"
    .lex "$*PACKAGE-SETUP", $P597
.annotate 'line', 307
    new $P598, "Undef"
    .lex "$*PKGDECL", $P598
.annotate 'line', 4
    .local string rx599_tgt
    .local int rx599_pos
    .local int rx599_off
    .local int rx599_eos
    .local int rx599_rep
    .local pmc rx599_cur
    .local pmc rx599_debug
    (rx599_cur, rx599_pos, rx599_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx599_cur
    .local pmc match
    .lex "$/", match
    length rx599_eos, rx599_tgt
    gt rx599_pos, rx599_eos, rx599_done
    set rx599_off, 0
    lt rx599_pos, 2, rx599_start
    sub rx599_off, rx599_pos, 1
    substr rx599_tgt, rx599_tgt, rx599_off
  rx599_start:
    eq $I10, 1, rx599_restart
    if_null rx599_debug, debug_679
    rx599_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_679:
    $I10 = self.'from'()
    ne $I10, -1, rxscan603_done
    goto rxscan603_scan
  rxscan603_loop:
    (rx599_pos) = rx599_cur."from"()
    inc rx599_pos
    rx599_cur."!cursor_from"(rx599_pos)
    ge rx599_pos, rx599_eos, rxscan603_done
  rxscan603_scan:
    set_addr $I10, rxscan603_loop
    rx599_cur."!mark_push"(0, rx599_pos, $I10)
  rxscan603_done:
.annotate 'line', 306
    rx599_cur."!cursor_pos"(rx599_pos)
    get_hll_global $P604, ["PAST"], "Stmts"
    $P605 = $P604."new"()
    store_lex "$*PACKAGE-SETUP", $P605
.annotate 'line', 307
    rx599_cur."!cursor_pos"(rx599_pos)
    new $P606, "String"
    assign $P606, "knowhow"
    store_lex "$*PKGDECL", $P606
.annotate 'line', 308
  # rx subcapture "sym"
    set_addr $I10, rxcap_607_fail
    rx599_cur."!mark_push"(0, rx599_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx599_pos, 7
    gt $I11, rx599_eos, rx599_fail
    sub $I11, rx599_pos, rx599_off
    substr $S10, rx599_tgt, $I11, 7
    ne $S10, "knowhow", rx599_fail
    add rx599_pos, 7
    set_addr $I10, rxcap_607_fail
    ($I12, $I11) = rx599_cur."!mark_peek"($I10)
    rx599_cur."!cursor_pos"($I11)
    ($P10) = rx599_cur."!cursor_start"()
    $P10."!cursor_pass"(rx599_pos, "")
    rx599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_607_done
  rxcap_607_fail:
    goto rx599_fail
  rxcap_607_done:
  # rx subrule "package_def" subtype=capture negate=
    rx599_cur."!cursor_pos"(rx599_pos)
    $P10 = rx599_cur."package_def"()
    unless $P10, rx599_fail
    rx599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx599_pos = $P10."pos"()
.annotate 'line', 305
  # rx pass
    rx599_cur."!cursor_pass"(rx599_pos, "package_declarator:sym<knowhow>")
    if_null rx599_debug, debug_680
    rx599_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx599_pos)
  debug_680:
    .return (rx599_cur)
  rx599_restart:
.annotate 'line', 4
    if_null rx599_debug, debug_681
    rx599_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_681:
  rx599_fail:
    (rx599_rep, rx599_pos, $I10, $P10) = rx599_cur."!mark_fail"(0)
    lt rx599_pos, -1, rx599_done
    eq rx599_pos, -1, rx599_fail
    jump $I10
  rx599_done:
    rx599_cur."!cursor_fail"()
    if_null rx599_debug, debug_682
    rx599_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_682:
    .return (rx599_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("140_1300060177.262") :method
.annotate 'line', 4
    $P601 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P602, "ResizablePMCArray"
    push $P602, $P601
    .return ($P602)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("141_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 311
    new $P609, "Undef"
    .lex "$*PACKAGE-SETUP", $P609
.annotate 'line', 312
    new $P610, "Undef"
    .lex "$*PKGDECL", $P610
.annotate 'line', 4
    .local string rx611_tgt
    .local int rx611_pos
    .local int rx611_off
    .local int rx611_eos
    .local int rx611_rep
    .local pmc rx611_cur
    .local pmc rx611_debug
    (rx611_cur, rx611_pos, rx611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx611_cur
    .local pmc match
    .lex "$/", match
    length rx611_eos, rx611_tgt
    gt rx611_pos, rx611_eos, rx611_done
    set rx611_off, 0
    lt rx611_pos, 2, rx611_start
    sub rx611_off, rx611_pos, 1
    substr rx611_tgt, rx611_tgt, rx611_off
  rx611_start:
    eq $I10, 1, rx611_restart
    if_null rx611_debug, debug_683
    rx611_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_683:
    $I10 = self.'from'()
    ne $I10, -1, rxscan615_done
    goto rxscan615_scan
  rxscan615_loop:
    (rx611_pos) = rx611_cur."from"()
    inc rx611_pos
    rx611_cur."!cursor_from"(rx611_pos)
    ge rx611_pos, rx611_eos, rxscan615_done
  rxscan615_scan:
    set_addr $I10, rxscan615_loop
    rx611_cur."!mark_push"(0, rx611_pos, $I10)
  rxscan615_done:
.annotate 'line', 311
    rx611_cur."!cursor_pos"(rx611_pos)
    get_hll_global $P616, ["PAST"], "Stmts"
    $P617 = $P616."new"()
    store_lex "$*PACKAGE-SETUP", $P617
.annotate 'line', 312
    rx611_cur."!cursor_pos"(rx611_pos)
    new $P618, "String"
    assign $P618, "class"
    store_lex "$*PKGDECL", $P618
.annotate 'line', 313
  # rx subcapture "sym"
    set_addr $I10, rxcap_619_fail
    rx611_cur."!mark_push"(0, rx611_pos, $I10)
  # rx literal  "class"
    add $I11, rx611_pos, 5
    gt $I11, rx611_eos, rx611_fail
    sub $I11, rx611_pos, rx611_off
    substr $S10, rx611_tgt, $I11, 5
    ne $S10, "class", rx611_fail
    add rx611_pos, 5
    set_addr $I10, rxcap_619_fail
    ($I12, $I11) = rx611_cur."!mark_peek"($I10)
    rx611_cur."!cursor_pos"($I11)
    ($P10) = rx611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx611_pos, "")
    rx611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_619_done
  rxcap_619_fail:
    goto rx611_fail
  rxcap_619_done:
  # rx subrule "package_def" subtype=capture negate=
    rx611_cur."!cursor_pos"(rx611_pos)
    $P10 = rx611_cur."package_def"()
    unless $P10, rx611_fail
    rx611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx611_pos = $P10."pos"()
.annotate 'line', 310
  # rx pass
    rx611_cur."!cursor_pass"(rx611_pos, "package_declarator:sym<class>")
    if_null rx611_debug, debug_684
    rx611_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx611_pos)
  debug_684:
    .return (rx611_cur)
  rx611_restart:
.annotate 'line', 4
    if_null rx611_debug, debug_685
    rx611_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_685:
  rx611_fail:
    (rx611_rep, rx611_pos, $I10, $P10) = rx611_cur."!mark_fail"(0)
    lt rx611_pos, -1, rx611_done
    eq rx611_pos, -1, rx611_fail
    jump $I10
  rx611_done:
    rx611_cur."!cursor_fail"()
    if_null rx611_debug, debug_686
    rx611_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_686:
    .return (rx611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("142_1300060177.262") :method
.annotate 'line', 4
    $P613 = self."!PREFIX__!subrule"("package_def", "class")
    new $P614, "ResizablePMCArray"
    push $P614, $P613
    .return ($P614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("143_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 316
    new $P621, "Undef"
    .lex "$*PACKAGE-SETUP", $P621
.annotate 'line', 317
    new $P622, "Undef"
    .lex "$*PKGDECL", $P622
.annotate 'line', 4
    .local string rx623_tgt
    .local int rx623_pos
    .local int rx623_off
    .local int rx623_eos
    .local int rx623_rep
    .local pmc rx623_cur
    .local pmc rx623_debug
    (rx623_cur, rx623_pos, rx623_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx623_cur
    .local pmc match
    .lex "$/", match
    length rx623_eos, rx623_tgt
    gt rx623_pos, rx623_eos, rx623_done
    set rx623_off, 0
    lt rx623_pos, 2, rx623_start
    sub rx623_off, rx623_pos, 1
    substr rx623_tgt, rx623_tgt, rx623_off
  rx623_start:
    eq $I10, 1, rx623_restart
    if_null rx623_debug, debug_687
    rx623_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_687:
    $I10 = self.'from'()
    ne $I10, -1, rxscan627_done
    goto rxscan627_scan
  rxscan627_loop:
    (rx623_pos) = rx623_cur."from"()
    inc rx623_pos
    rx623_cur."!cursor_from"(rx623_pos)
    ge rx623_pos, rx623_eos, rxscan627_done
  rxscan627_scan:
    set_addr $I10, rxscan627_loop
    rx623_cur."!mark_push"(0, rx623_pos, $I10)
  rxscan627_done:
.annotate 'line', 316
    rx623_cur."!cursor_pos"(rx623_pos)
    get_hll_global $P628, ["PAST"], "Stmts"
    $P629 = $P628."new"()
    store_lex "$*PACKAGE-SETUP", $P629
.annotate 'line', 317
    rx623_cur."!cursor_pos"(rx623_pos)
    new $P630, "String"
    assign $P630, "grammar"
    store_lex "$*PKGDECL", $P630
.annotate 'line', 318
  # rx subcapture "sym"
    set_addr $I10, rxcap_631_fail
    rx623_cur."!mark_push"(0, rx623_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx623_pos, 7
    gt $I11, rx623_eos, rx623_fail
    sub $I11, rx623_pos, rx623_off
    substr $S10, rx623_tgt, $I11, 7
    ne $S10, "grammar", rx623_fail
    add rx623_pos, 7
    set_addr $I10, rxcap_631_fail
    ($I12, $I11) = rx623_cur."!mark_peek"($I10)
    rx623_cur."!cursor_pos"($I11)
    ($P10) = rx623_cur."!cursor_start"()
    $P10."!cursor_pass"(rx623_pos, "")
    rx623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_631_done
  rxcap_631_fail:
    goto rx623_fail
  rxcap_631_done:
  # rx subrule "package_def" subtype=capture negate=
    rx623_cur."!cursor_pos"(rx623_pos)
    $P10 = rx623_cur."package_def"()
    unless $P10, rx623_fail
    rx623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx623_pos = $P10."pos"()
.annotate 'line', 315
  # rx pass
    rx623_cur."!cursor_pass"(rx623_pos, "package_declarator:sym<grammar>")
    if_null rx623_debug, debug_688
    rx623_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx623_pos)
  debug_688:
    .return (rx623_cur)
  rx623_restart:
.annotate 'line', 4
    if_null rx623_debug, debug_689
    rx623_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_689:
  rx623_fail:
    (rx623_rep, rx623_pos, $I10, $P10) = rx623_cur."!mark_fail"(0)
    lt rx623_pos, -1, rx623_done
    eq rx623_pos, -1, rx623_fail
    jump $I10
  rx623_done:
    rx623_cur."!cursor_fail"()
    if_null rx623_debug, debug_690
    rx623_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_690:
    .return (rx623_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("144_1300060177.262") :method
.annotate 'line', 4
    $P625 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P626, "ResizablePMCArray"
    push $P626, $P625
    .return ($P626)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("145_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 321
    new $P633, "Undef"
    .lex "$*PACKAGE-SETUP", $P633
.annotate 'line', 322
    new $P634, "Undef"
    .lex "$*PKGDECL", $P634
.annotate 'line', 4
    .local string rx635_tgt
    .local int rx635_pos
    .local int rx635_off
    .local int rx635_eos
    .local int rx635_rep
    .local pmc rx635_cur
    .local pmc rx635_debug
    (rx635_cur, rx635_pos, rx635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx635_cur
    .local pmc match
    .lex "$/", match
    length rx635_eos, rx635_tgt
    gt rx635_pos, rx635_eos, rx635_done
    set rx635_off, 0
    lt rx635_pos, 2, rx635_start
    sub rx635_off, rx635_pos, 1
    substr rx635_tgt, rx635_tgt, rx635_off
  rx635_start:
    eq $I10, 1, rx635_restart
    if_null rx635_debug, debug_691
    rx635_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_691:
    $I10 = self.'from'()
    ne $I10, -1, rxscan639_done
    goto rxscan639_scan
  rxscan639_loop:
    (rx635_pos) = rx635_cur."from"()
    inc rx635_pos
    rx635_cur."!cursor_from"(rx635_pos)
    ge rx635_pos, rx635_eos, rxscan639_done
  rxscan639_scan:
    set_addr $I10, rxscan639_loop
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  rxscan639_done:
.annotate 'line', 321
    rx635_cur."!cursor_pos"(rx635_pos)
    get_hll_global $P640, ["PAST"], "Stmts"
    $P641 = $P640."new"()
    store_lex "$*PACKAGE-SETUP", $P641
.annotate 'line', 322
    rx635_cur."!cursor_pos"(rx635_pos)
    new $P642, "String"
    assign $P642, "role"
    store_lex "$*PKGDECL", $P642
.annotate 'line', 323
  # rx subcapture "sym"
    set_addr $I10, rxcap_643_fail
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  # rx literal  "role"
    add $I11, rx635_pos, 4
    gt $I11, rx635_eos, rx635_fail
    sub $I11, rx635_pos, rx635_off
    substr $S10, rx635_tgt, $I11, 4
    ne $S10, "role", rx635_fail
    add rx635_pos, 4
    set_addr $I10, rxcap_643_fail
    ($I12, $I11) = rx635_cur."!mark_peek"($I10)
    rx635_cur."!cursor_pos"($I11)
    ($P10) = rx635_cur."!cursor_start"()
    $P10."!cursor_pass"(rx635_pos, "")
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_643_done
  rxcap_643_fail:
    goto rx635_fail
  rxcap_643_done:
  # rx subrule "package_def" subtype=capture negate=
    rx635_cur."!cursor_pos"(rx635_pos)
    $P10 = rx635_cur."package_def"()
    unless $P10, rx635_fail
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx635_pos = $P10."pos"()
.annotate 'line', 320
  # rx pass
    rx635_cur."!cursor_pass"(rx635_pos, "package_declarator:sym<role>")
    if_null rx635_debug, debug_692
    rx635_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx635_pos)
  debug_692:
    .return (rx635_cur)
  rx635_restart:
.annotate 'line', 4
    if_null rx635_debug, debug_693
    rx635_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_693:
  rx635_fail:
    (rx635_rep, rx635_pos, $I10, $P10) = rx635_cur."!mark_fail"(0)
    lt rx635_pos, -1, rx635_done
    eq rx635_pos, -1, rx635_fail
    jump $I10
  rx635_done:
    rx635_cur."!cursor_fail"()
    if_null rx635_debug, debug_694
    rx635_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_694:
    .return (rx635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("146_1300060177.262") :method
.annotate 'line', 4
    $P637 = self."!PREFIX__!subrule"("package_def", "role")
    new $P638, "ResizablePMCArray"
    push $P638, $P637
    .return ($P638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("147_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 326
    new $P645, "Undef"
    .lex "$*PACKAGE-SETUP", $P645
.annotate 'line', 327
    new $P646, "Undef"
    .lex "$*PKGDECL", $P646
.annotate 'line', 4
    .local string rx647_tgt
    .local int rx647_pos
    .local int rx647_off
    .local int rx647_eos
    .local int rx647_rep
    .local pmc rx647_cur
    .local pmc rx647_debug
    (rx647_cur, rx647_pos, rx647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx647_cur
    .local pmc match
    .lex "$/", match
    length rx647_eos, rx647_tgt
    gt rx647_pos, rx647_eos, rx647_done
    set rx647_off, 0
    lt rx647_pos, 2, rx647_start
    sub rx647_off, rx647_pos, 1
    substr rx647_tgt, rx647_tgt, rx647_off
  rx647_start:
    eq $I10, 1, rx647_restart
    if_null rx647_debug, debug_695
    rx647_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_695:
    $I10 = self.'from'()
    ne $I10, -1, rxscan651_done
    goto rxscan651_scan
  rxscan651_loop:
    (rx647_pos) = rx647_cur."from"()
    inc rx647_pos
    rx647_cur."!cursor_from"(rx647_pos)
    ge rx647_pos, rx647_eos, rxscan651_done
  rxscan651_scan:
    set_addr $I10, rxscan651_loop
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  rxscan651_done:
.annotate 'line', 326
    rx647_cur."!cursor_pos"(rx647_pos)
    get_hll_global $P652, ["PAST"], "Stmts"
    $P653 = $P652."new"()
    store_lex "$*PACKAGE-SETUP", $P653
.annotate 'line', 327
    rx647_cur."!cursor_pos"(rx647_pos)
    new $P654, "String"
    assign $P654, "native"
    store_lex "$*PKGDECL", $P654
.annotate 'line', 328
  # rx subcapture "sym"
    set_addr $I10, rxcap_655_fail
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  # rx literal  "native"
    add $I11, rx647_pos, 6
    gt $I11, rx647_eos, rx647_fail
    sub $I11, rx647_pos, rx647_off
    substr $S10, rx647_tgt, $I11, 6
    ne $S10, "native", rx647_fail
    add rx647_pos, 6
    set_addr $I10, rxcap_655_fail
    ($I12, $I11) = rx647_cur."!mark_peek"($I10)
    rx647_cur."!cursor_pos"($I11)
    ($P10) = rx647_cur."!cursor_start"()
    $P10."!cursor_pass"(rx647_pos, "")
    rx647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_655_done
  rxcap_655_fail:
    goto rx647_fail
  rxcap_655_done:
  # rx subrule "package_def" subtype=capture negate=
    rx647_cur."!cursor_pos"(rx647_pos)
    $P10 = rx647_cur."package_def"()
    unless $P10, rx647_fail
    rx647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx647_pos = $P10."pos"()
.annotate 'line', 325
  # rx pass
    rx647_cur."!cursor_pass"(rx647_pos, "package_declarator:sym<native>")
    if_null rx647_debug, debug_696
    rx647_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx647_pos)
  debug_696:
    .return (rx647_cur)
  rx647_restart:
.annotate 'line', 4
    if_null rx647_debug, debug_697
    rx647_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_697:
  rx647_fail:
    (rx647_rep, rx647_pos, $I10, $P10) = rx647_cur."!mark_fail"(0)
    lt rx647_pos, -1, rx647_done
    eq rx647_pos, -1, rx647_fail
    jump $I10
  rx647_done:
    rx647_cur."!cursor_fail"()
    if_null rx647_debug, debug_698
    rx647_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_698:
    .return (rx647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("148_1300060177.262") :method
.annotate 'line', 4
    $P649 = self."!PREFIX__!subrule"("package_def", "native")
    new $P650, "ResizablePMCArray"
    push $P650, $P649
    .return ($P650)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("149_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P680 = "151_1300060177.262" 
    capture_lex $P680
.annotate 'line', 332
    new $P657, "Undef"
    .lex "$*PKGMETA", $P657
.annotate 'line', 333
    $P658 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P658
.annotate 'line', 4
    .local string rx659_tgt
    .local int rx659_pos
    .local int rx659_off
    .local int rx659_eos
    .local int rx659_rep
    .local pmc rx659_cur
    .local pmc rx659_debug
    (rx659_cur, rx659_pos, rx659_tgt, $I10) = self."!cursor_start"()
    rx659_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx659_cur
    .local pmc match
    .lex "$/", match
    length rx659_eos, rx659_tgt
    gt rx659_pos, rx659_eos, rx659_done
    set rx659_off, 0
    lt rx659_pos, 2, rx659_start
    sub rx659_off, rx659_pos, 1
    substr rx659_tgt, rx659_tgt, rx659_off
  rx659_start:
    eq $I10, 1, rx659_restart
    if_null rx659_debug, debug_699
    rx659_cur."!cursor_debug"("START", "package_def")
  debug_699:
    $I10 = self.'from'()
    ne $I10, -1, rxscan663_done
    goto rxscan663_scan
  rxscan663_loop:
    (rx659_pos) = rx659_cur."from"()
    inc rx659_pos
    rx659_cur."!cursor_from"(rx659_pos)
    ge rx659_pos, rx659_eos, rxscan663_done
  rxscan663_scan:
    set_addr $I10, rxscan663_loop
    rx659_cur."!mark_push"(0, rx659_pos, $I10)
  rxscan663_done:
.annotate 'line', 331
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
.annotate 'line', 332
    rx659_cur."!cursor_pos"(rx659_pos)
    find_lex $P665, "$*PKGMETA"
    unless_null $P665, vivify_700
    get_hll_global $P665, "$PKGMETA"
    unless_null $P665, vivify_701
    die "Contextual $*PKGMETA not found"
  vivify_701:
  vivify_700:
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
.annotate 'line', 333
    rx659_cur."!cursor_pos"(rx659_pos)
    find_lex $P667, "%*ATTR-CHECK"
    unless_null $P667, vivify_702
    get_hll_global $P667, "%ATTR-CHECK"
    unless_null $P667, vivify_703
    die "Contextual %*ATTR-CHECK not found"
  vivify_703:
  vivify_702:
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
.annotate 'line', 335
  # rx subrule "name" subtype=capture negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."name"()
    unless $P10, rx659_fail
    rx659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx659_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
.annotate 'line', 336
  # rx rxquantr670 ** 0..1
    set_addr $I10, rxquantr670_done
    rx659_cur."!mark_push"(0, rx659_pos, $I10)
  rxquantr670_loop:
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx659_pos, 2
    gt $I11, rx659_eos, rx659_fail
    sub $I11, rx659_pos, rx659_off
    substr $S10, rx659_tgt, $I11, 2
    ne $S10, "is", rx659_fail
    add rx659_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx659_pos, 5
    gt $I11, rx659_eos, rx659_fail
    sub $I11, rx659_pos, rx659_off
    substr $S10, rx659_tgt, $I11, 5
    ne $S10, "repr(", rx659_fail
    add rx659_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."quote_EXPR"()
    unless $P10, rx659_fail
    rx659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx659_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx659_pos, 1
    gt $I11, rx659_eos, rx659_fail
    sub $I11, rx659_pos, rx659_off
    ord $I11, rx659_tgt, $I11
    ne $I11, 41, rx659_fail
    add rx659_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
    set_addr $I10, rxquantr670_done
    (rx659_rep) = rx659_cur."!mark_commit"($I10)
  rxquantr670_done:
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
.annotate 'line', 338
    rx659_cur."!cursor_pos"(rx659_pos)
    find_lex $P677, unicode:"$\x{a2}"
    $P678 = $P677."MATCH"()
    store_lex "$/", $P678
    .const 'Sub' $P680 = "151_1300060177.262" 
    capture_lex $P680
    $P706 = $P680()
.annotate 'line', 347
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
.annotate 'line', 349
  # rx rxquantr708 ** 0..1
    set_addr $I10, rxquantr708_done
    rx659_cur."!mark_push"(0, rx659_pos, $I10)
  rxquantr708_loop:
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx659_pos, 2
    gt $I11, rx659_eos, rx659_fail
    sub $I11, rx659_pos, rx659_off
    substr $S10, rx659_tgt, $I11, 2
    ne $S10, "is", rx659_fail
    add rx659_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."name"()
    unless $P10, rx659_fail
    rx659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx659_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
    set_addr $I10, rxquantr708_done
    (rx659_rep) = rx659_cur."!mark_commit"($I10)
  rxquantr708_done:
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
.annotate 'line', 350
  # rx rxquantr713 ** 0..*
    set_addr $I10, rxquantr713_done
    rx659_cur."!mark_push"(0, rx659_pos, $I10)
  rxquantr713_loop:
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx659_pos, 4
    gt $I11, rx659_eos, rx659_fail
    sub $I11, rx659_pos, rx659_off
    substr $S10, rx659_tgt, $I11, 4
    ne $S10, "does", rx659_fail
    add rx659_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."name"()
    unless $P10, rx659_fail
    rx659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx659_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
    set_addr $I10, rxquantr713_done
    (rx659_rep) = rx659_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr713_done
    rx659_cur."!mark_push"(rx659_rep, rx659_pos, $I10)
    goto rxquantr713_loop
  rxquantr713_done:
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  alt718_0:
.annotate 'line', 351
    set_addr $I10, alt718_1
    rx659_cur."!mark_push"(0, rx659_pos, $I10)
.annotate 'line', 352
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx659_pos, 1
    gt $I11, rx659_eos, rx659_fail
    sub $I11, rx659_pos, rx659_off
    ord $I11, rx659_tgt, $I11
    ne $I11, 59, rx659_fail
    add rx659_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."comp_unit"()
    unless $P10, rx659_fail
    rx659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx659_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
    goto alt718_end
  alt718_1:
    set_addr $I10, alt718_2
    rx659_cur."!mark_push"(0, rx659_pos, $I10)
.annotate 'line', 353
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx659_pos, rx659_off
    substr $S10, rx659_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx659_fail
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."block"()
    unless $P10, rx659_fail
    rx659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx659_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
    goto alt718_end
  alt718_2:
.annotate 'line', 354
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."panic"("Malformed package declaration")
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
  alt718_end:
.annotate 'line', 355
  # rx subrule "ws" subtype=method negate=
    rx659_cur."!cursor_pos"(rx659_pos)
    $P10 = rx659_cur."ws"()
    unless $P10, rx659_fail
    rx659_pos = $P10."pos"()
.annotate 'line', 331
  # rx pass
    rx659_cur."!cursor_pass"(rx659_pos, "package_def")
    if_null rx659_debug, debug_723
    rx659_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx659_pos)
  debug_723:
    .return (rx659_cur)
  rx659_restart:
.annotate 'line', 4
    if_null rx659_debug, debug_724
    rx659_cur."!cursor_debug"("NEXT", "package_def")
  debug_724:
  rx659_fail:
    (rx659_rep, rx659_pos, $I10, $P10) = rx659_cur."!mark_fail"(0)
    lt rx659_pos, -1, rx659_done
    eq rx659_pos, -1, rx659_fail
    jump $I10
  rx659_done:
    rx659_cur."!cursor_fail"()
    if_null rx659_debug, debug_725
    rx659_cur."!cursor_debug"("FAIL", "package_def")
  debug_725:
    .return (rx659_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("150_1300060177.262") :method
.annotate 'line', 4
    $P661 = self."!PREFIX__!subrule"("ws", "")
    new $P662, "ResizablePMCArray"
    push $P662, $P661
    .return ($P662)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block679"  :anon :subid("151_1300060177.262") :outer("149_1300060177.262")
.annotate 'line', 341
    $P681 = root_new ['parrot';'Hash']
    .lex "%args", $P681
.annotate 'line', 338
    find_lex $P682, "%args"
.annotate 'line', 342
    find_lex $P683, "$/"
    unless_null $P683, vivify_704
    $P683 = root_new ['parrot';'Hash']
  vivify_704:
    set $P684, $P683["name"]
    unless_null $P684, vivify_705
    new $P684, "Undef"
  vivify_705:
    set $S685, $P684
    new $P686, 'String'
    set $P686, $S685
    find_lex $P687, "%args"
    unless_null $P687, vivify_706
    $P687 = root_new ['parrot';'Hash']
    store_lex "%args", $P687
  vivify_706:
    set $P687["name"], $P686
.annotate 'line', 343
    find_lex $P689, "$/"
    unless_null $P689, vivify_707
    $P689 = root_new ['parrot';'Hash']
  vivify_707:
    set $P690, $P689["repr"]
    unless_null $P690, vivify_708
    new $P690, "Undef"
  vivify_708:
    unless $P690, if_688_end
.annotate 'line', 344
    find_lex $P691, "$/"
    unless_null $P691, vivify_709
    $P691 = root_new ['parrot';'Hash']
  vivify_709:
    set $P692, $P691["repr"]
    unless_null $P692, vivify_710
    $P692 = root_new ['parrot';'ResizablePMCArray']
  vivify_710:
    set $P693, $P692[0]
    unless_null $P693, vivify_711
    $P693 = root_new ['parrot';'Hash']
  vivify_711:
    set $P694, $P693["quote_delimited"]
    unless_null $P694, vivify_712
    $P694 = root_new ['parrot';'Hash']
  vivify_712:
    set $P695, $P694["quote_atom"]
    unless_null $P695, vivify_713
    $P695 = root_new ['parrot';'ResizablePMCArray']
  vivify_713:
    set $P696, $P695[0]
    unless_null $P696, vivify_714
    new $P696, "Undef"
  vivify_714:
    set $S697, $P696
    new $P698, 'String'
    set $P698, $S697
    find_lex $P699, "%args"
    unless_null $P699, vivify_715
    $P699 = root_new ['parrot';'Hash']
    store_lex "%args", $P699
  vivify_715:
    set $P699["repr"], $P698
  if_688_end:
.annotate 'line', 346
    find_dynamic_lex $P700, "$*SC"
    unless_null $P700, vivify_716
    get_hll_global $P700, "$SC"
    unless_null $P700, vivify_717
    die "Contextual $*SC not found"
  vivify_717:
  vivify_716:
    find_dynamic_lex $P701, "$*PKGDECL"
    unless_null $P701, vivify_718
    get_hll_global $P701, "$PKGDECL"
    unless_null $P701, vivify_719
    die "Contextual $*PKGDECL not found"
  vivify_719:
  vivify_718:
    find_dynamic_lex $P702, "%*HOW"
    unless_null $P702, vivify_720
    get_hll_global $P702, "%HOW"
    unless_null $P702, vivify_721
    die "Contextual %*HOW not found"
  vivify_721:
  vivify_720:
    set $P703, $P702[$P701]
    unless_null $P703, vivify_722
    new $P703, "Undef"
  vivify_722:
    find_lex $P704, "%args"
    $P705 = $P700."pkg_create_mo"($P703, $P704 :flat)
    store_dynamic_lex "$*PKGMETA", $P705
.annotate 'line', 338
    .return ($P705)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("152_1300060177.262")
    .param pmc param_729
.annotate 'line', 358
    .lex "self", param_729
    $P730 = param_729."!protoregex"("scope_declarator")
    .return ($P730)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("153_1300060177.262")
    .param pmc param_732
.annotate 'line', 358
    .lex "self", param_732
    $P733 = param_732."!PREFIX__!protoregex"("scope_declarator")
    .return ($P733)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("154_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx735_tgt
    .local int rx735_pos
    .local int rx735_off
    .local int rx735_eos
    .local int rx735_rep
    .local pmc rx735_cur
    .local pmc rx735_debug
    (rx735_cur, rx735_pos, rx735_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx735_cur
    .local pmc match
    .lex "$/", match
    length rx735_eos, rx735_tgt
    gt rx735_pos, rx735_eos, rx735_done
    set rx735_off, 0
    lt rx735_pos, 2, rx735_start
    sub rx735_off, rx735_pos, 1
    substr rx735_tgt, rx735_tgt, rx735_off
  rx735_start:
    eq $I10, 1, rx735_restart
    if_null rx735_debug, debug_726
    rx735_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_726:
    $I10 = self.'from'()
    ne $I10, -1, rxscan739_done
    goto rxscan739_scan
  rxscan739_loop:
    (rx735_pos) = rx735_cur."from"()
    inc rx735_pos
    rx735_cur."!cursor_from"(rx735_pos)
    ge rx735_pos, rx735_eos, rxscan739_done
  rxscan739_scan:
    set_addr $I10, rxscan739_loop
    rx735_cur."!mark_push"(0, rx735_pos, $I10)
  rxscan739_done:
.annotate 'line', 359
  # rx subcapture "sym"
    set_addr $I10, rxcap_740_fail
    rx735_cur."!mark_push"(0, rx735_pos, $I10)
  # rx literal  "my"
    add $I11, rx735_pos, 2
    gt $I11, rx735_eos, rx735_fail
    sub $I11, rx735_pos, rx735_off
    substr $S10, rx735_tgt, $I11, 2
    ne $S10, "my", rx735_fail
    add rx735_pos, 2
    set_addr $I10, rxcap_740_fail
    ($I12, $I11) = rx735_cur."!mark_peek"($I10)
    rx735_cur."!cursor_pos"($I11)
    ($P10) = rx735_cur."!cursor_start"()
    $P10."!cursor_pass"(rx735_pos, "")
    rx735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_740_done
  rxcap_740_fail:
    goto rx735_fail
  rxcap_740_done:
  # rx subrule "scoped" subtype=capture negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."scoped"("my")
    unless $P10, rx735_fail
    rx735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx735_pos = $P10."pos"()
  # rx pass
    rx735_cur."!cursor_pass"(rx735_pos, "scope_declarator:sym<my>")
    if_null rx735_debug, debug_727
    rx735_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx735_pos)
  debug_727:
    .return (rx735_cur)
  rx735_restart:
.annotate 'line', 4
    if_null rx735_debug, debug_728
    rx735_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_728:
  rx735_fail:
    (rx735_rep, rx735_pos, $I10, $P10) = rx735_cur."!mark_fail"(0)
    lt rx735_pos, -1, rx735_done
    eq rx735_pos, -1, rx735_fail
    jump $I10
  rx735_done:
    rx735_cur."!cursor_fail"()
    if_null rx735_debug, debug_729
    rx735_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_729:
    .return (rx735_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("155_1300060177.262") :method
.annotate 'line', 4
    $P737 = self."!PREFIX__!subrule"("scoped", "my")
    new $P738, "ResizablePMCArray"
    push $P738, $P737
    .return ($P738)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("156_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx742_tgt
    .local int rx742_pos
    .local int rx742_off
    .local int rx742_eos
    .local int rx742_rep
    .local pmc rx742_cur
    .local pmc rx742_debug
    (rx742_cur, rx742_pos, rx742_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx742_cur
    .local pmc match
    .lex "$/", match
    length rx742_eos, rx742_tgt
    gt rx742_pos, rx742_eos, rx742_done
    set rx742_off, 0
    lt rx742_pos, 2, rx742_start
    sub rx742_off, rx742_pos, 1
    substr rx742_tgt, rx742_tgt, rx742_off
  rx742_start:
    eq $I10, 1, rx742_restart
    if_null rx742_debug, debug_730
    rx742_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_730:
    $I10 = self.'from'()
    ne $I10, -1, rxscan746_done
    goto rxscan746_scan
  rxscan746_loop:
    (rx742_pos) = rx742_cur."from"()
    inc rx742_pos
    rx742_cur."!cursor_from"(rx742_pos)
    ge rx742_pos, rx742_eos, rxscan746_done
  rxscan746_scan:
    set_addr $I10, rxscan746_loop
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  rxscan746_done:
.annotate 'line', 360
  # rx subcapture "sym"
    set_addr $I10, rxcap_747_fail
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  # rx literal  "our"
    add $I11, rx742_pos, 3
    gt $I11, rx742_eos, rx742_fail
    sub $I11, rx742_pos, rx742_off
    substr $S10, rx742_tgt, $I11, 3
    ne $S10, "our", rx742_fail
    add rx742_pos, 3
    set_addr $I10, rxcap_747_fail
    ($I12, $I11) = rx742_cur."!mark_peek"($I10)
    rx742_cur."!cursor_pos"($I11)
    ($P10) = rx742_cur."!cursor_start"()
    $P10."!cursor_pass"(rx742_pos, "")
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_747_done
  rxcap_747_fail:
    goto rx742_fail
  rxcap_747_done:
  # rx subrule "scoped" subtype=capture negate=
    rx742_cur."!cursor_pos"(rx742_pos)
    $P10 = rx742_cur."scoped"("our")
    unless $P10, rx742_fail
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx742_pos = $P10."pos"()
  # rx pass
    rx742_cur."!cursor_pass"(rx742_pos, "scope_declarator:sym<our>")
    if_null rx742_debug, debug_731
    rx742_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx742_pos)
  debug_731:
    .return (rx742_cur)
  rx742_restart:
.annotate 'line', 4
    if_null rx742_debug, debug_732
    rx742_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_732:
  rx742_fail:
    (rx742_rep, rx742_pos, $I10, $P10) = rx742_cur."!mark_fail"(0)
    lt rx742_pos, -1, rx742_done
    eq rx742_pos, -1, rx742_fail
    jump $I10
  rx742_done:
    rx742_cur."!cursor_fail"()
    if_null rx742_debug, debug_733
    rx742_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_733:
    .return (rx742_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("157_1300060177.262") :method
.annotate 'line', 4
    $P744 = self."!PREFIX__!subrule"("scoped", "our")
    new $P745, "ResizablePMCArray"
    push $P745, $P744
    .return ($P745)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("158_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx749_tgt
    .local int rx749_pos
    .local int rx749_off
    .local int rx749_eos
    .local int rx749_rep
    .local pmc rx749_cur
    .local pmc rx749_debug
    (rx749_cur, rx749_pos, rx749_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx749_cur
    .local pmc match
    .lex "$/", match
    length rx749_eos, rx749_tgt
    gt rx749_pos, rx749_eos, rx749_done
    set rx749_off, 0
    lt rx749_pos, 2, rx749_start
    sub rx749_off, rx749_pos, 1
    substr rx749_tgt, rx749_tgt, rx749_off
  rx749_start:
    eq $I10, 1, rx749_restart
    if_null rx749_debug, debug_734
    rx749_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_734:
    $I10 = self.'from'()
    ne $I10, -1, rxscan753_done
    goto rxscan753_scan
  rxscan753_loop:
    (rx749_pos) = rx749_cur."from"()
    inc rx749_pos
    rx749_cur."!cursor_from"(rx749_pos)
    ge rx749_pos, rx749_eos, rxscan753_done
  rxscan753_scan:
    set_addr $I10, rxscan753_loop
    rx749_cur."!mark_push"(0, rx749_pos, $I10)
  rxscan753_done:
.annotate 'line', 361
  # rx subcapture "sym"
    set_addr $I10, rxcap_754_fail
    rx749_cur."!mark_push"(0, rx749_pos, $I10)
  # rx literal  "has"
    add $I11, rx749_pos, 3
    gt $I11, rx749_eos, rx749_fail
    sub $I11, rx749_pos, rx749_off
    substr $S10, rx749_tgt, $I11, 3
    ne $S10, "has", rx749_fail
    add rx749_pos, 3
    set_addr $I10, rxcap_754_fail
    ($I12, $I11) = rx749_cur."!mark_peek"($I10)
    rx749_cur."!cursor_pos"($I11)
    ($P10) = rx749_cur."!cursor_start"()
    $P10."!cursor_pass"(rx749_pos, "")
    rx749_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_754_done
  rxcap_754_fail:
    goto rx749_fail
  rxcap_754_done:
  # rx subrule "scoped" subtype=capture negate=
    rx749_cur."!cursor_pos"(rx749_pos)
    $P10 = rx749_cur."scoped"("has")
    unless $P10, rx749_fail
    rx749_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx749_pos = $P10."pos"()
  # rx pass
    rx749_cur."!cursor_pass"(rx749_pos, "scope_declarator:sym<has>")
    if_null rx749_debug, debug_735
    rx749_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx749_pos)
  debug_735:
    .return (rx749_cur)
  rx749_restart:
.annotate 'line', 4
    if_null rx749_debug, debug_736
    rx749_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_736:
  rx749_fail:
    (rx749_rep, rx749_pos, $I10, $P10) = rx749_cur."!mark_fail"(0)
    lt rx749_pos, -1, rx749_done
    eq rx749_pos, -1, rx749_fail
    jump $I10
  rx749_done:
    rx749_cur."!cursor_fail"()
    if_null rx749_debug, debug_737
    rx749_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_737:
    .return (rx749_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("159_1300060177.262") :method
.annotate 'line', 4
    $P751 = self."!PREFIX__!subrule"("scoped", "has")
    new $P752, "ResizablePMCArray"
    push $P752, $P751
    .return ($P752)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("160_1300060177.262") :method :outer("11_1300060177.262")
    .param pmc param_756
.annotate 'line', 363
    .lex "$*SCOPE", param_756
.annotate 'line', 4
    .local string rx757_tgt
    .local int rx757_pos
    .local int rx757_off
    .local int rx757_eos
    .local int rx757_rep
    .local pmc rx757_cur
    .local pmc rx757_debug
    (rx757_cur, rx757_pos, rx757_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx757_cur
    .local pmc match
    .lex "$/", match
    length rx757_eos, rx757_tgt
    gt rx757_pos, rx757_eos, rx757_done
    set rx757_off, 0
    lt rx757_pos, 2, rx757_start
    sub rx757_off, rx757_pos, 1
    substr rx757_tgt, rx757_tgt, rx757_off
  rx757_start:
    eq $I10, 1, rx757_restart
    if_null rx757_debug, debug_738
    rx757_cur."!cursor_debug"("START", "scoped")
  debug_738:
    $I10 = self.'from'()
    ne $I10, -1, rxscan763_done
    goto rxscan763_scan
  rxscan763_loop:
    (rx757_pos) = rx757_cur."from"()
    inc rx757_pos
    rx757_cur."!cursor_from"(rx757_pos)
    ge rx757_pos, rx757_eos, rxscan763_done
  rxscan763_scan:
    set_addr $I10, rxscan763_loop
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxscan763_done:
  alt764_0:
.annotate 'line', 363
    set_addr $I10, alt764_1
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
.annotate 'line', 364
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."declarator"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
    goto alt764_end
  alt764_1:
    set_addr $I10, alt764_2
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
.annotate 'line', 365
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."multi_declarator"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
    goto alt764_end
  alt764_2:
.annotate 'line', 366
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."package_declarator"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  alt764_end:
.annotate 'line', 363
  # rx pass
    rx757_cur."!cursor_pass"(rx757_pos, "scoped")
    if_null rx757_debug, debug_739
    rx757_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx757_pos)
  debug_739:
    .return (rx757_cur)
  rx757_restart:
.annotate 'line', 4
    if_null rx757_debug, debug_740
    rx757_cur."!cursor_debug"("NEXT", "scoped")
  debug_740:
  rx757_fail:
    (rx757_rep, rx757_pos, $I10, $P10) = rx757_cur."!mark_fail"(0)
    lt rx757_pos, -1, rx757_done
    eq rx757_pos, -1, rx757_fail
    jump $I10
  rx757_done:
    rx757_cur."!cursor_fail"()
    if_null rx757_debug, debug_741
    rx757_cur."!cursor_debug"("FAIL", "scoped")
  debug_741:
    .return (rx757_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("161_1300060177.262") :method
.annotate 'line', 4
    $P759 = self."!PREFIX__!subrule"("ws", "")
    $P760 = self."!PREFIX__!subrule"("ws", "")
    $P761 = self."!PREFIX__!subrule"("ws", "")
    new $P762, "ResizablePMCArray"
    push $P762, $P759
    push $P762, $P760
    push $P762, $P761
    .return ($P762)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("162_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx772_tgt
    .local int rx772_pos
    .local int rx772_off
    .local int rx772_eos
    .local int rx772_rep
    .local pmc rx772_cur
    .local pmc rx772_debug
    (rx772_cur, rx772_pos, rx772_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx772_cur
    .local pmc match
    .lex "$/", match
    length rx772_eos, rx772_tgt
    gt rx772_pos, rx772_eos, rx772_done
    set rx772_off, 0
    lt rx772_pos, 2, rx772_start
    sub rx772_off, rx772_pos, 1
    substr rx772_tgt, rx772_tgt, rx772_off
  rx772_start:
    eq $I10, 1, rx772_restart
    if_null rx772_debug, debug_742
    rx772_cur."!cursor_debug"("START", "typename")
  debug_742:
    $I10 = self.'from'()
    ne $I10, -1, rxscan776_done
    goto rxscan776_scan
  rxscan776_loop:
    (rx772_pos) = rx772_cur."from"()
    inc rx772_pos
    rx772_cur."!cursor_from"(rx772_pos)
    ge rx772_pos, rx772_eos, rxscan776_done
  rxscan776_scan:
    set_addr $I10, rxscan776_loop
    rx772_cur."!mark_push"(0, rx772_pos, $I10)
  rxscan776_done:
.annotate 'line', 369
  # rx subrule "name" subtype=capture negate=
    rx772_cur."!cursor_pos"(rx772_pos)
    $P10 = rx772_cur."name"()
    unless $P10, rx772_fail
    rx772_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx772_pos = $P10."pos"()
  # rx pass
    rx772_cur."!cursor_pass"(rx772_pos, "typename")
    if_null rx772_debug, debug_743
    rx772_cur."!cursor_debug"("PASS", "typename", " at pos=", rx772_pos)
  debug_743:
    .return (rx772_cur)
  rx772_restart:
.annotate 'line', 4
    if_null rx772_debug, debug_744
    rx772_cur."!cursor_debug"("NEXT", "typename")
  debug_744:
  rx772_fail:
    (rx772_rep, rx772_pos, $I10, $P10) = rx772_cur."!mark_fail"(0)
    lt rx772_pos, -1, rx772_done
    eq rx772_pos, -1, rx772_fail
    jump $I10
  rx772_done:
    rx772_cur."!cursor_fail"()
    if_null rx772_debug, debug_745
    rx772_cur."!cursor_debug"("FAIL", "typename")
  debug_745:
    .return (rx772_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("163_1300060177.262") :method
.annotate 'line', 4
    $P774 = self."!PREFIX__!subrule"("name", "")
    new $P775, "ResizablePMCArray"
    push $P775, $P774
    .return ($P775)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("164_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx778_tgt
    .local int rx778_pos
    .local int rx778_off
    .local int rx778_eos
    .local int rx778_rep
    .local pmc rx778_cur
    .local pmc rx778_debug
    (rx778_cur, rx778_pos, rx778_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx778_cur
    .local pmc match
    .lex "$/", match
    length rx778_eos, rx778_tgt
    gt rx778_pos, rx778_eos, rx778_done
    set rx778_off, 0
    lt rx778_pos, 2, rx778_start
    sub rx778_off, rx778_pos, 1
    substr rx778_tgt, rx778_tgt, rx778_off
  rx778_start:
    eq $I10, 1, rx778_restart
    if_null rx778_debug, debug_746
    rx778_cur."!cursor_debug"("START", "declarator")
  debug_746:
    $I10 = self.'from'()
    ne $I10, -1, rxscan783_done
    goto rxscan783_scan
  rxscan783_loop:
    (rx778_pos) = rx778_cur."from"()
    inc rx778_pos
    rx778_cur."!cursor_from"(rx778_pos)
    ge rx778_pos, rx778_eos, rxscan783_done
  rxscan783_scan:
    set_addr $I10, rxscan783_loop
    rx778_cur."!mark_push"(0, rx778_pos, $I10)
  rxscan783_done:
  alt784_0:
.annotate 'line', 371
    set_addr $I10, alt784_1
    rx778_cur."!mark_push"(0, rx778_pos, $I10)
.annotate 'line', 372
  # rx subrule "variable_declarator" subtype=capture negate=
    rx778_cur."!cursor_pos"(rx778_pos)
    $P10 = rx778_cur."variable_declarator"()
    unless $P10, rx778_fail
    rx778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx778_pos = $P10."pos"()
    goto alt784_end
  alt784_1:
.annotate 'line', 373
  # rx subrule "routine_declarator" subtype=capture negate=
    rx778_cur."!cursor_pos"(rx778_pos)
    $P10 = rx778_cur."routine_declarator"()
    unless $P10, rx778_fail
    rx778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx778_pos = $P10."pos"()
  alt784_end:
.annotate 'line', 371
  # rx pass
    rx778_cur."!cursor_pass"(rx778_pos, "declarator")
    if_null rx778_debug, debug_747
    rx778_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx778_pos)
  debug_747:
    .return (rx778_cur)
  rx778_restart:
.annotate 'line', 4
    if_null rx778_debug, debug_748
    rx778_cur."!cursor_debug"("NEXT", "declarator")
  debug_748:
  rx778_fail:
    (rx778_rep, rx778_pos, $I10, $P10) = rx778_cur."!mark_fail"(0)
    lt rx778_pos, -1, rx778_done
    eq rx778_pos, -1, rx778_fail
    jump $I10
  rx778_done:
    rx778_cur."!cursor_fail"()
    if_null rx778_debug, debug_749
    rx778_cur."!cursor_debug"("FAIL", "declarator")
  debug_749:
    .return (rx778_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("165_1300060177.262") :method
.annotate 'line', 4
    $P780 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P781 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P782, "ResizablePMCArray"
    push $P782, $P780
    push $P782, $P781
    .return ($P782)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("166_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx786_tgt
    .local int rx786_pos
    .local int rx786_off
    .local int rx786_eos
    .local int rx786_rep
    .local pmc rx786_cur
    .local pmc rx786_debug
    (rx786_cur, rx786_pos, rx786_tgt, $I10) = self."!cursor_start"()
    rx786_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx786_cur
    .local pmc match
    .lex "$/", match
    length rx786_eos, rx786_tgt
    gt rx786_pos, rx786_eos, rx786_done
    set rx786_off, 0
    lt rx786_pos, 2, rx786_start
    sub rx786_off, rx786_pos, 1
    substr rx786_tgt, rx786_tgt, rx786_off
  rx786_start:
    eq $I10, 1, rx786_restart
    if_null rx786_debug, debug_750
    rx786_cur."!cursor_debug"("START", "variable_declarator")
  debug_750:
    $I10 = self.'from'()
    ne $I10, -1, rxscan790_done
    goto rxscan790_scan
  rxscan790_loop:
    (rx786_pos) = rx786_cur."from"()
    inc rx786_pos
    rx786_cur."!cursor_from"(rx786_pos)
    ge rx786_pos, rx786_eos, rxscan790_done
  rxscan790_scan:
    set_addr $I10, rxscan790_loop
    rx786_cur."!mark_push"(0, rx786_pos, $I10)
  rxscan790_done:
.annotate 'line', 376
  # rx subrule "ws" subtype=method negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."ws"()
    unless $P10, rx786_fail
    rx786_pos = $P10."pos"()
  # rx rxquantr792 ** 0..1
    set_addr $I10, rxquantr792_done
    rx786_cur."!mark_push"(0, rx786_pos, $I10)
  rxquantr792_loop:
  # rx subrule "typename" subtype=capture negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."typename"()
    unless $P10, rx786_fail
    goto rxsubrule793_pass
  rxsubrule793_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx786_fail
  rxsubrule793_pass:
    set_addr $I10, rxsubrule793_back
    rx786_cur."!mark_push"(0, rx786_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx786_pos = $P10."pos"()
    set_addr $I10, rxquantr792_done
    (rx786_rep) = rx786_cur."!mark_commit"($I10)
  rxquantr792_done:
  # rx subrule "ws" subtype=method negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."ws"()
    unless $P10, rx786_fail
    rx786_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."variable"()
    unless $P10, rx786_fail
    rx786_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx786_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx786_cur."!cursor_pos"(rx786_pos)
    $P10 = rx786_cur."ws"()
    unless $P10, rx786_fail
    rx786_pos = $P10."pos"()
  # rx pass
    rx786_cur."!cursor_pass"(rx786_pos, "variable_declarator")
    if_null rx786_debug, debug_751
    rx786_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx786_pos)
  debug_751:
    .return (rx786_cur)
  rx786_restart:
.annotate 'line', 4
    if_null rx786_debug, debug_752
    rx786_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_752:
  rx786_fail:
    (rx786_rep, rx786_pos, $I10, $P10) = rx786_cur."!mark_fail"(0)
    lt rx786_pos, -1, rx786_done
    eq rx786_pos, -1, rx786_fail
    jump $I10
  rx786_done:
    rx786_cur."!cursor_fail"()
    if_null rx786_debug, debug_753
    rx786_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_753:
    .return (rx786_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("167_1300060177.262") :method
.annotate 'line', 4
    $P788 = self."!PREFIX__!subrule"("ws", "")
    new $P789, "ResizablePMCArray"
    push $P789, $P788
    .return ($P789)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("168_1300060177.262")
    .param pmc param_797
.annotate 'line', 378
    .lex "self", param_797
    $P798 = param_797."!protoregex"("routine_declarator")
    .return ($P798)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("169_1300060177.262")
    .param pmc param_800
.annotate 'line', 378
    .lex "self", param_800
    $P801 = param_800."!PREFIX__!protoregex"("routine_declarator")
    .return ($P801)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("170_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx803_tgt
    .local int rx803_pos
    .local int rx803_off
    .local int rx803_eos
    .local int rx803_rep
    .local pmc rx803_cur
    .local pmc rx803_debug
    (rx803_cur, rx803_pos, rx803_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx803_cur
    .local pmc match
    .lex "$/", match
    length rx803_eos, rx803_tgt
    gt rx803_pos, rx803_eos, rx803_done
    set rx803_off, 0
    lt rx803_pos, 2, rx803_start
    sub rx803_off, rx803_pos, 1
    substr rx803_tgt, rx803_tgt, rx803_off
  rx803_start:
    eq $I10, 1, rx803_restart
    if_null rx803_debug, debug_754
    rx803_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_754:
    $I10 = self.'from'()
    ne $I10, -1, rxscan807_done
    goto rxscan807_scan
  rxscan807_loop:
    (rx803_pos) = rx803_cur."from"()
    inc rx803_pos
    rx803_cur."!cursor_from"(rx803_pos)
    ge rx803_pos, rx803_eos, rxscan807_done
  rxscan807_scan:
    set_addr $I10, rxscan807_loop
    rx803_cur."!mark_push"(0, rx803_pos, $I10)
  rxscan807_done:
.annotate 'line', 379
  # rx subcapture "sym"
    set_addr $I10, rxcap_808_fail
    rx803_cur."!mark_push"(0, rx803_pos, $I10)
  # rx literal  "sub"
    add $I11, rx803_pos, 3
    gt $I11, rx803_eos, rx803_fail
    sub $I11, rx803_pos, rx803_off
    substr $S10, rx803_tgt, $I11, 3
    ne $S10, "sub", rx803_fail
    add rx803_pos, 3
    set_addr $I10, rxcap_808_fail
    ($I12, $I11) = rx803_cur."!mark_peek"($I10)
    rx803_cur."!cursor_pos"($I11)
    ($P10) = rx803_cur."!cursor_start"()
    $P10."!cursor_pass"(rx803_pos, "")
    rx803_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_808_done
  rxcap_808_fail:
    goto rx803_fail
  rxcap_808_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx803_cur."!cursor_pos"(rx803_pos)
    $P10 = rx803_cur."routine_def"()
    unless $P10, rx803_fail
    rx803_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx803_pos = $P10."pos"()
  # rx pass
    rx803_cur."!cursor_pass"(rx803_pos, "routine_declarator:sym<sub>")
    if_null rx803_debug, debug_755
    rx803_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx803_pos)
  debug_755:
    .return (rx803_cur)
  rx803_restart:
.annotate 'line', 4
    if_null rx803_debug, debug_756
    rx803_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_756:
  rx803_fail:
    (rx803_rep, rx803_pos, $I10, $P10) = rx803_cur."!mark_fail"(0)
    lt rx803_pos, -1, rx803_done
    eq rx803_pos, -1, rx803_fail
    jump $I10
  rx803_done:
    rx803_cur."!cursor_fail"()
    if_null rx803_debug, debug_757
    rx803_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_757:
    .return (rx803_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("171_1300060177.262") :method
.annotate 'line', 4
    $P805 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P806, "ResizablePMCArray"
    push $P806, $P805
    .return ($P806)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("172_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx810_tgt
    .local int rx810_pos
    .local int rx810_off
    .local int rx810_eos
    .local int rx810_rep
    .local pmc rx810_cur
    .local pmc rx810_debug
    (rx810_cur, rx810_pos, rx810_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx810_cur
    .local pmc match
    .lex "$/", match
    length rx810_eos, rx810_tgt
    gt rx810_pos, rx810_eos, rx810_done
    set rx810_off, 0
    lt rx810_pos, 2, rx810_start
    sub rx810_off, rx810_pos, 1
    substr rx810_tgt, rx810_tgt, rx810_off
  rx810_start:
    eq $I10, 1, rx810_restart
    if_null rx810_debug, debug_758
    rx810_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_758:
    $I10 = self.'from'()
    ne $I10, -1, rxscan814_done
    goto rxscan814_scan
  rxscan814_loop:
    (rx810_pos) = rx810_cur."from"()
    inc rx810_pos
    rx810_cur."!cursor_from"(rx810_pos)
    ge rx810_pos, rx810_eos, rxscan814_done
  rxscan814_scan:
    set_addr $I10, rxscan814_loop
    rx810_cur."!mark_push"(0, rx810_pos, $I10)
  rxscan814_done:
.annotate 'line', 380
  # rx subcapture "sym"
    set_addr $I10, rxcap_815_fail
    rx810_cur."!mark_push"(0, rx810_pos, $I10)
  # rx literal  "method"
    add $I11, rx810_pos, 6
    gt $I11, rx810_eos, rx810_fail
    sub $I11, rx810_pos, rx810_off
    substr $S10, rx810_tgt, $I11, 6
    ne $S10, "method", rx810_fail
    add rx810_pos, 6
    set_addr $I10, rxcap_815_fail
    ($I12, $I11) = rx810_cur."!mark_peek"($I10)
    rx810_cur."!cursor_pos"($I11)
    ($P10) = rx810_cur."!cursor_start"()
    $P10."!cursor_pass"(rx810_pos, "")
    rx810_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_815_done
  rxcap_815_fail:
    goto rx810_fail
  rxcap_815_done:
  # rx subrule "method_def" subtype=capture negate=
    rx810_cur."!cursor_pos"(rx810_pos)
    $P10 = rx810_cur."method_def"()
    unless $P10, rx810_fail
    rx810_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx810_pos = $P10."pos"()
  # rx pass
    rx810_cur."!cursor_pass"(rx810_pos, "routine_declarator:sym<method>")
    if_null rx810_debug, debug_759
    rx810_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx810_pos)
  debug_759:
    .return (rx810_cur)
  rx810_restart:
.annotate 'line', 4
    if_null rx810_debug, debug_760
    rx810_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_760:
  rx810_fail:
    (rx810_rep, rx810_pos, $I10, $P10) = rx810_cur."!mark_fail"(0)
    lt rx810_pos, -1, rx810_done
    eq rx810_pos, -1, rx810_fail
    jump $I10
  rx810_done:
    rx810_cur."!cursor_fail"()
    if_null rx810_debug, debug_761
    rx810_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_761:
    .return (rx810_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("173_1300060177.262") :method
.annotate 'line', 4
    $P812 = self."!PREFIX__!subrule"("method_def", "method")
    new $P813, "ResizablePMCArray"
    push $P813, $P812
    .return ($P813)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("174_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 383
    new $P817, "Undef"
    .lex "$*RETURN_USED", $P817
.annotate 'line', 4
    .local string rx818_tgt
    .local int rx818_pos
    .local int rx818_off
    .local int rx818_eos
    .local int rx818_rep
    .local pmc rx818_cur
    .local pmc rx818_debug
    (rx818_cur, rx818_pos, rx818_tgt, $I10) = self."!cursor_start"()
    rx818_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx818_cur
    .local pmc match
    .lex "$/", match
    length rx818_eos, rx818_tgt
    gt rx818_pos, rx818_eos, rx818_done
    set rx818_off, 0
    lt rx818_pos, 2, rx818_start
    sub rx818_off, rx818_pos, 1
    substr rx818_tgt, rx818_tgt, rx818_off
  rx818_start:
    eq $I10, 1, rx818_restart
    if_null rx818_debug, debug_762
    rx818_cur."!cursor_debug"("START", "routine_def")
  debug_762:
    $I10 = self.'from'()
    ne $I10, -1, rxscan822_done
    goto rxscan822_scan
  rxscan822_loop:
    (rx818_pos) = rx818_cur."from"()
    inc rx818_pos
    rx818_cur."!cursor_from"(rx818_pos)
    ge rx818_pos, rx818_eos, rxscan822_done
  rxscan822_scan:
    set_addr $I10, rxscan822_loop
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  rxscan822_done:
.annotate 'line', 382
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
.annotate 'line', 383
    rx818_cur."!cursor_pos"(rx818_pos)
    new $P824, "Integer"
    assign $P824, 0
    store_lex "$*RETURN_USED", $P824
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
.annotate 'line', 384
  # rx rxquantr826 ** 0..1
    set_addr $I10, rxquantr826_done
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  rxquantr826_loop:
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_829_fail
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  # rx rxquantr828 ** 0..1
    set_addr $I10, rxquantr828_done
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  rxquantr828_loop:
  # rx literal  "&"
    add $I11, rx818_pos, 1
    gt $I11, rx818_eos, rx818_fail
    sub $I11, rx818_pos, rx818_off
    ord $I11, rx818_tgt, $I11
    ne $I11, 38, rx818_fail
    add rx818_pos, 1
    set_addr $I10, rxquantr828_done
    (rx818_rep) = rx818_cur."!mark_commit"($I10)
  rxquantr828_done:
    set_addr $I10, rxcap_829_fail
    ($I12, $I11) = rx818_cur."!mark_peek"($I10)
    rx818_cur."!cursor_pos"($I11)
    ($P10) = rx818_cur."!cursor_start"()
    $P10."!cursor_pass"(rx818_pos, "")
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_829_done
  rxcap_829_fail:
    goto rx818_fail
  rxcap_829_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."deflongname"()
    unless $P10, rx818_fail
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx818_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
    set_addr $I10, rxquantr826_done
    (rx818_rep) = rx818_cur."!mark_commit"($I10)
  rxquantr826_done:
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
.annotate 'line', 385
  # rx subrule "newpad" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."newpad"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  alt833_0:
.annotate 'line', 386
    set_addr $I10, alt833_1
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx818_pos, 1
    gt $I11, rx818_eos, rx818_fail
    sub $I11, rx818_pos, rx818_off
    ord $I11, rx818_tgt, $I11
    ne $I11, 40, rx818_fail
    add rx818_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."signature"()
    unless $P10, rx818_fail
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx818_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx818_pos, 1
    gt $I11, rx818_eos, rx818_fail
    sub $I11, rx818_pos, rx818_off
    ord $I11, rx818_tgt, $I11
    ne $I11, 41, rx818_fail
    add rx818_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
    goto alt833_end
  alt833_1:
.annotate 'line', 387
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  alt833_end:
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
.annotate 'line', 388
  # rx rxquantr841 ** 0..*
    set_addr $I10, rxquantr841_done
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  rxquantr841_loop:
  # rx subrule "trait" subtype=capture negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."trait"()
    unless $P10, rx818_fail
    goto rxsubrule842_pass
  rxsubrule842_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx818_fail
  rxsubrule842_pass:
    set_addr $I10, rxsubrule842_back
    rx818_cur."!mark_push"(0, rx818_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx818_pos = $P10."pos"()
    set_addr $I10, rxquantr841_done
    (rx818_rep) = rx818_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr841_done
    rx818_cur."!mark_push"(rx818_rep, rx818_pos, $I10)
    goto rxquantr841_loop
  rxquantr841_done:
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  alt844_0:
.annotate 'line', 389
    set_addr $I10, alt844_1
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
.annotate 'line', 390
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."onlystar"()
    unless $P10, rx818_fail
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx818_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
    goto alt844_end
  alt844_1:
.annotate 'line', 391
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."blockoid"()
    unless $P10, rx818_fail
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx818_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
  alt844_end:
.annotate 'line', 392
  # rx subrule "ws" subtype=method negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."ws"()
    unless $P10, rx818_fail
    rx818_pos = $P10."pos"()
.annotate 'line', 382
  # rx pass
    rx818_cur."!cursor_pass"(rx818_pos, "routine_def")
    if_null rx818_debug, debug_763
    rx818_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx818_pos)
  debug_763:
    .return (rx818_cur)
  rx818_restart:
.annotate 'line', 4
    if_null rx818_debug, debug_764
    rx818_cur."!cursor_debug"("NEXT", "routine_def")
  debug_764:
  rx818_fail:
    (rx818_rep, rx818_pos, $I10, $P10) = rx818_cur."!mark_fail"(0)
    lt rx818_pos, -1, rx818_done
    eq rx818_pos, -1, rx818_fail
    jump $I10
  rx818_done:
    rx818_cur."!cursor_fail"()
    if_null rx818_debug, debug_765
    rx818_cur."!cursor_debug"("FAIL", "routine_def")
  debug_765:
    .return (rx818_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("175_1300060177.262") :method
.annotate 'line', 4
    $P820 = self."!PREFIX__!subrule"("ws", "")
    new $P821, "ResizablePMCArray"
    push $P821, $P820
    .return ($P821)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("176_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P881 = "178_1300060177.262" 
    capture_lex $P881
.annotate 'line', 396
    new $P851, "Undef"
    .lex "$*RETURN_USED", $P851
.annotate 'line', 397
    new $P852, "Undef"
    .lex "$*INVOCANT_OK", $P852
.annotate 'line', 4
    .local string rx853_tgt
    .local int rx853_pos
    .local int rx853_off
    .local int rx853_eos
    .local int rx853_rep
    .local pmc rx853_cur
    .local pmc rx853_debug
    (rx853_cur, rx853_pos, rx853_tgt, $I10) = self."!cursor_start"()
    rx853_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx853_cur
    .local pmc match
    .lex "$/", match
    length rx853_eos, rx853_tgt
    gt rx853_pos, rx853_eos, rx853_done
    set rx853_off, 0
    lt rx853_pos, 2, rx853_start
    sub rx853_off, rx853_pos, 1
    substr rx853_tgt, rx853_tgt, rx853_off
  rx853_start:
    eq $I10, 1, rx853_restart
    if_null rx853_debug, debug_766
    rx853_cur."!cursor_debug"("START", "method_def")
  debug_766:
    $I10 = self.'from'()
    ne $I10, -1, rxscan857_done
    goto rxscan857_scan
  rxscan857_loop:
    (rx853_pos) = rx853_cur."from"()
    inc rx853_pos
    rx853_cur."!cursor_from"(rx853_pos)
    ge rx853_pos, rx853_eos, rxscan857_done
  rxscan857_scan:
    set_addr $I10, rxscan857_loop
    rx853_cur."!mark_push"(0, rx853_pos, $I10)
  rxscan857_done:
.annotate 'line', 395
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
.annotate 'line', 396
    rx853_cur."!cursor_pos"(rx853_pos)
    new $P859, "Integer"
    assign $P859, 0
    store_lex "$*RETURN_USED", $P859
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
.annotate 'line', 397
    rx853_cur."!cursor_pos"(rx853_pos)
    new $P861, "Integer"
    assign $P861, 1
    store_lex "$*INVOCANT_OK", $P861
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
.annotate 'line', 398
  # rx subcapture "private"
    set_addr $I10, rxcap_864_fail
    rx853_cur."!mark_push"(0, rx853_pos, $I10)
  # rx rxquantr863 ** 0..1
    set_addr $I10, rxquantr863_done
    rx853_cur."!mark_push"(0, rx853_pos, $I10)
  rxquantr863_loop:
  # rx literal  "!"
    add $I11, rx853_pos, 1
    gt $I11, rx853_eos, rx853_fail
    sub $I11, rx853_pos, rx853_off
    ord $I11, rx853_tgt, $I11
    ne $I11, 33, rx853_fail
    add rx853_pos, 1
    set_addr $I10, rxquantr863_done
    (rx853_rep) = rx853_cur."!mark_commit"($I10)
  rxquantr863_done:
    set_addr $I10, rxcap_864_fail
    ($I12, $I11) = rx853_cur."!mark_peek"($I10)
    rx853_cur."!cursor_pos"($I11)
    ($P10) = rx853_cur."!cursor_start"()
    $P10."!cursor_pass"(rx853_pos, "")
    rx853_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_864_done
  rxcap_864_fail:
    goto rx853_fail
  rxcap_864_done:
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
.annotate 'line', 399
  # rx rxquantr866 ** 0..1
    set_addr $I10, rxquantr866_done
    rx853_cur."!mark_push"(0, rx853_pos, $I10)
  rxquantr866_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."deflongname"()
    unless $P10, rx853_fail
    goto rxsubrule867_pass
  rxsubrule867_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx853_fail
  rxsubrule867_pass:
    set_addr $I10, rxsubrule867_back
    rx853_cur."!mark_push"(0, rx853_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx853_pos = $P10."pos"()
    set_addr $I10, rxquantr866_done
    (rx853_rep) = rx853_cur."!mark_commit"($I10)
  rxquantr866_done:
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
.annotate 'line', 400
  # rx subrule "newpad" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."newpad"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  alt870_0:
.annotate 'line', 401
    set_addr $I10, alt870_1
    rx853_cur."!mark_push"(0, rx853_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx853_pos, 1
    gt $I11, rx853_eos, rx853_fail
    sub $I11, rx853_pos, rx853_off
    ord $I11, rx853_tgt, $I11
    ne $I11, 40, rx853_fail
    add rx853_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."signature"()
    unless $P10, rx853_fail
    rx853_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx853_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx853_pos, 1
    gt $I11, rx853_eos, rx853_fail
    sub $I11, rx853_pos, rx853_off
    ord $I11, rx853_tgt, $I11
    ne $I11, 41, rx853_fail
    add rx853_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
    goto alt870_end
  alt870_1:
.annotate 'line', 402
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  alt870_end:
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
.annotate 'line', 403
    rx853_cur."!cursor_pos"(rx853_pos)
    find_lex $P878, unicode:"$\x{a2}"
    $P879 = $P878."MATCH"()
    store_lex "$/", $P879
    .const 'Sub' $P881 = "178_1300060177.262" 
    capture_lex $P881
    $P883 = $P881()
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
.annotate 'line', 404
  # rx rxquantr885 ** 0..*
    set_addr $I10, rxquantr885_done
    rx853_cur."!mark_push"(0, rx853_pos, $I10)
  rxquantr885_loop:
  # rx subrule "trait" subtype=capture negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."trait"()
    unless $P10, rx853_fail
    goto rxsubrule886_pass
  rxsubrule886_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx853_fail
  rxsubrule886_pass:
    set_addr $I10, rxsubrule886_back
    rx853_cur."!mark_push"(0, rx853_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx853_pos = $P10."pos"()
    set_addr $I10, rxquantr885_done
    (rx853_rep) = rx853_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr885_done
    rx853_cur."!mark_push"(rx853_rep, rx853_pos, $I10)
    goto rxquantr885_loop
  rxquantr885_done:
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  alt888_0:
.annotate 'line', 405
    set_addr $I10, alt888_1
    rx853_cur."!mark_push"(0, rx853_pos, $I10)
.annotate 'line', 406
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."onlystar"()
    unless $P10, rx853_fail
    rx853_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx853_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
    goto alt888_end
  alt888_1:
.annotate 'line', 407
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."blockoid"()
    unless $P10, rx853_fail
    rx853_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx853_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
  alt888_end:
.annotate 'line', 408
  # rx subrule "ws" subtype=method negate=
    rx853_cur."!cursor_pos"(rx853_pos)
    $P10 = rx853_cur."ws"()
    unless $P10, rx853_fail
    rx853_pos = $P10."pos"()
.annotate 'line', 395
  # rx pass
    rx853_cur."!cursor_pass"(rx853_pos, "method_def")
    if_null rx853_debug, debug_767
    rx853_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx853_pos)
  debug_767:
    .return (rx853_cur)
  rx853_restart:
.annotate 'line', 4
    if_null rx853_debug, debug_768
    rx853_cur."!cursor_debug"("NEXT", "method_def")
  debug_768:
  rx853_fail:
    (rx853_rep, rx853_pos, $I10, $P10) = rx853_cur."!mark_fail"(0)
    lt rx853_pos, -1, rx853_done
    eq rx853_pos, -1, rx853_fail
    jump $I10
  rx853_done:
    rx853_cur."!cursor_fail"()
    if_null rx853_debug, debug_769
    rx853_cur."!cursor_debug"("FAIL", "method_def")
  debug_769:
    .return (rx853_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("177_1300060177.262") :method
.annotate 'line', 4
    $P855 = self."!PREFIX__!subrule"("ws", "")
    new $P856, "ResizablePMCArray"
    push $P856, $P855
    .return ($P856)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block880"  :anon :subid("178_1300060177.262") :outer("176_1300060177.262")
.annotate 'line', 403
    new $P882, "Integer"
    assign $P882, 0
    store_dynamic_lex "$*INVOCANT_OK", $P882
    .return ($P882)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("179_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P902 = "181_1300060177.262" 
    capture_lex $P902
    .local string rx895_tgt
    .local int rx895_pos
    .local int rx895_off
    .local int rx895_eos
    .local int rx895_rep
    .local pmc rx895_cur
    .local pmc rx895_debug
    (rx895_cur, rx895_pos, rx895_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx895_cur
    .local pmc match
    .lex "$/", match
    length rx895_eos, rx895_tgt
    gt rx895_pos, rx895_eos, rx895_done
    set rx895_off, 0
    lt rx895_pos, 2, rx895_start
    sub rx895_off, rx895_pos, 1
    substr rx895_tgt, rx895_tgt, rx895_off
  rx895_start:
    eq $I10, 1, rx895_restart
    if_null rx895_debug, debug_770
    rx895_cur."!cursor_debug"("START", "onlystar")
  debug_770:
    $I10 = self.'from'()
    ne $I10, -1, rxscan898_done
    goto rxscan898_scan
  rxscan898_loop:
    (rx895_pos) = rx895_cur."from"()
    inc rx895_pos
    rx895_cur."!cursor_from"(rx895_pos)
    ge rx895_pos, rx895_eos, rxscan898_done
  rxscan898_scan:
    set_addr $I10, rxscan898_loop
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxscan898_done:
.annotate 'line', 412
    rx895_cur."!cursor_pos"(rx895_pos)
    find_lex $P899, unicode:"$\x{a2}"
    $P900 = $P899."MATCH"()
    store_lex "$/", $P900
    .const 'Sub' $P902 = "181_1300060177.262" 
    capture_lex $P902
    $P906 = $P902()
    unless $P906, rx895_fail
.annotate 'line', 413
  # rx literal  "{"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 123, rx895_fail
    add rx895_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 42, rx895_fail
    add rx895_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 125, rx895_fail
    add rx895_pos, 1
.annotate 'line', 414
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ENDSTMT"()
    unless $P10, rx895_fail
.annotate 'line', 415
  # rx subrule "finishpad" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."finishpad"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
.annotate 'line', 411
  # rx pass
    rx895_cur."!cursor_pass"(rx895_pos, "onlystar")
    if_null rx895_debug, debug_773
    rx895_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx895_pos)
  debug_773:
    .return (rx895_cur)
  rx895_restart:
.annotate 'line', 4
    if_null rx895_debug, debug_774
    rx895_cur."!cursor_debug"("NEXT", "onlystar")
  debug_774:
  rx895_fail:
    (rx895_rep, rx895_pos, $I10, $P10) = rx895_cur."!mark_fail"(0)
    lt rx895_pos, -1, rx895_done
    eq rx895_pos, -1, rx895_fail
    jump $I10
  rx895_done:
    rx895_cur."!cursor_fail"()
    if_null rx895_debug, debug_775
    rx895_cur."!cursor_debug"("FAIL", "onlystar")
  debug_775:
    .return (rx895_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("180_1300060177.262") :method
.annotate 'line', 4
    new $P897, "ResizablePMCArray"
    push $P897, ""
    .return ($P897)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block901"  :anon :subid("181_1300060177.262") :outer("179_1300060177.262")
.annotate 'line', 412
    find_dynamic_lex $P903, "$*MULTINESS"
    unless_null $P903, vivify_771
    get_hll_global $P903, "$MULTINESS"
    unless_null $P903, vivify_772
    die "Contextual $*MULTINESS not found"
  vivify_772:
  vivify_771:
    set $S904, $P903
    iseq $I905, $S904, "proto"
    .return ($I905)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("182_1300060177.262")
    .param pmc param_908
.annotate 'line', 418
    .lex "self", param_908
    $P909 = param_908."!protoregex"("multi_declarator")
    .return ($P909)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("183_1300060177.262")
    .param pmc param_911
.annotate 'line', 418
    .lex "self", param_911
    $P912 = param_911."!PREFIX__!protoregex"("multi_declarator")
    .return ($P912)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("184_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 420
    new $P914, "Undef"
    .lex "$*MULTINESS", $P914
.annotate 'line', 4
    .local string rx915_tgt
    .local int rx915_pos
    .local int rx915_off
    .local int rx915_eos
    .local int rx915_rep
    .local pmc rx915_cur
    .local pmc rx915_debug
    (rx915_cur, rx915_pos, rx915_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx915_cur
    .local pmc match
    .lex "$/", match
    length rx915_eos, rx915_tgt
    gt rx915_pos, rx915_eos, rx915_done
    set rx915_off, 0
    lt rx915_pos, 2, rx915_start
    sub rx915_off, rx915_pos, 1
    substr rx915_tgt, rx915_tgt, rx915_off
  rx915_start:
    eq $I10, 1, rx915_restart
    if_null rx915_debug, debug_776
    rx915_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan919_done
    goto rxscan919_scan
  rxscan919_loop:
    (rx915_pos) = rx915_cur."from"()
    inc rx915_pos
    rx915_cur."!cursor_from"(rx915_pos)
    ge rx915_pos, rx915_eos, rxscan919_done
  rxscan919_scan:
    set_addr $I10, rxscan919_loop
    rx915_cur."!mark_push"(0, rx915_pos, $I10)
  rxscan919_done:
.annotate 'line', 420
    rx915_cur."!cursor_pos"(rx915_pos)
    new $P920, "String"
    assign $P920, "multi"
    store_lex "$*MULTINESS", $P920
.annotate 'line', 421
  # rx subcapture "sym"
    set_addr $I10, rxcap_921_fail
    rx915_cur."!mark_push"(0, rx915_pos, $I10)
  # rx literal  "multi"
    add $I11, rx915_pos, 5
    gt $I11, rx915_eos, rx915_fail
    sub $I11, rx915_pos, rx915_off
    substr $S10, rx915_tgt, $I11, 5
    ne $S10, "multi", rx915_fail
    add rx915_pos, 5
    set_addr $I10, rxcap_921_fail
    ($I12, $I11) = rx915_cur."!mark_peek"($I10)
    rx915_cur."!cursor_pos"($I11)
    ($P10) = rx915_cur."!cursor_start"()
    $P10."!cursor_pass"(rx915_pos, "")
    rx915_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_921_done
  rxcap_921_fail:
    goto rx915_fail
  rxcap_921_done:
.annotate 'line', 422
  # rx subrule "ws" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."ws"()
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
  alt922_0:
    set_addr $I10, alt922_1
    rx915_cur."!mark_push"(0, rx915_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."declarator"()
    unless $P10, rx915_fail
    rx915_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx915_pos = $P10."pos"()
    goto alt922_end
  alt922_1:
    set_addr $I10, alt922_2
    rx915_cur."!mark_push"(0, rx915_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."routine_def"()
    unless $P10, rx915_fail
    rx915_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx915_pos = $P10."pos"()
    goto alt922_end
  alt922_2:
  # rx subrule "panic" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."panic"("Malformed multi")
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
  alt922_end:
.annotate 'line', 419
  # rx pass
    rx915_cur."!cursor_pass"(rx915_pos, "multi_declarator:sym<multi>")
    if_null rx915_debug, debug_777
    rx915_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx915_pos)
  debug_777:
    .return (rx915_cur)
  rx915_restart:
.annotate 'line', 4
    if_null rx915_debug, debug_778
    rx915_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_778:
  rx915_fail:
    (rx915_rep, rx915_pos, $I10, $P10) = rx915_cur."!mark_fail"(0)
    lt rx915_pos, -1, rx915_done
    eq rx915_pos, -1, rx915_fail
    jump $I10
  rx915_done:
    rx915_cur."!cursor_fail"()
    if_null rx915_debug, debug_779
    rx915_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_779:
    .return (rx915_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("185_1300060177.262") :method
.annotate 'line', 4
    $P917 = self."!PREFIX__!subrule"("ws", "multi")
    new $P918, "ResizablePMCArray"
    push $P918, $P917
    .return ($P918)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("186_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 425
    new $P924, "Undef"
    .lex "$*MULTINESS", $P924
.annotate 'line', 4
    .local string rx925_tgt
    .local int rx925_pos
    .local int rx925_off
    .local int rx925_eos
    .local int rx925_rep
    .local pmc rx925_cur
    .local pmc rx925_debug
    (rx925_cur, rx925_pos, rx925_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx925_cur
    .local pmc match
    .lex "$/", match
    length rx925_eos, rx925_tgt
    gt rx925_pos, rx925_eos, rx925_done
    set rx925_off, 0
    lt rx925_pos, 2, rx925_start
    sub rx925_off, rx925_pos, 1
    substr rx925_tgt, rx925_tgt, rx925_off
  rx925_start:
    eq $I10, 1, rx925_restart
    if_null rx925_debug, debug_780
    rx925_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan929_done
    goto rxscan929_scan
  rxscan929_loop:
    (rx925_pos) = rx925_cur."from"()
    inc rx925_pos
    rx925_cur."!cursor_from"(rx925_pos)
    ge rx925_pos, rx925_eos, rxscan929_done
  rxscan929_scan:
    set_addr $I10, rxscan929_loop
    rx925_cur."!mark_push"(0, rx925_pos, $I10)
  rxscan929_done:
.annotate 'line', 425
    rx925_cur."!cursor_pos"(rx925_pos)
    new $P930, "String"
    assign $P930, "proto"
    store_lex "$*MULTINESS", $P930
.annotate 'line', 426
  # rx subcapture "sym"
    set_addr $I10, rxcap_931_fail
    rx925_cur."!mark_push"(0, rx925_pos, $I10)
  # rx literal  "proto"
    add $I11, rx925_pos, 5
    gt $I11, rx925_eos, rx925_fail
    sub $I11, rx925_pos, rx925_off
    substr $S10, rx925_tgt, $I11, 5
    ne $S10, "proto", rx925_fail
    add rx925_pos, 5
    set_addr $I10, rxcap_931_fail
    ($I12, $I11) = rx925_cur."!mark_peek"($I10)
    rx925_cur."!cursor_pos"($I11)
    ($P10) = rx925_cur."!cursor_start"()
    $P10."!cursor_pass"(rx925_pos, "")
    rx925_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_931_done
  rxcap_931_fail:
    goto rx925_fail
  rxcap_931_done:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx925_cur."!cursor_pos"(rx925_pos)
    $P10 = rx925_cur."ws"()
    unless $P10, rx925_fail
    rx925_pos = $P10."pos"()
  alt932_0:
    set_addr $I10, alt932_1
    rx925_cur."!mark_push"(0, rx925_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx925_cur."!cursor_pos"(rx925_pos)
    $P10 = rx925_cur."declarator"()
    unless $P10, rx925_fail
    rx925_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx925_pos = $P10."pos"()
    goto alt932_end
  alt932_1:
    set_addr $I10, alt932_2
    rx925_cur."!mark_push"(0, rx925_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx925_cur."!cursor_pos"(rx925_pos)
    $P10 = rx925_cur."routine_def"()
    unless $P10, rx925_fail
    rx925_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx925_pos = $P10."pos"()
    goto alt932_end
  alt932_2:
  # rx subrule "panic" subtype=method negate=
    rx925_cur."!cursor_pos"(rx925_pos)
    $P10 = rx925_cur."panic"("Malformed proto")
    unless $P10, rx925_fail
    rx925_pos = $P10."pos"()
  alt932_end:
.annotate 'line', 424
  # rx pass
    rx925_cur."!cursor_pass"(rx925_pos, "multi_declarator:sym<proto>")
    if_null rx925_debug, debug_781
    rx925_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx925_pos)
  debug_781:
    .return (rx925_cur)
  rx925_restart:
.annotate 'line', 4
    if_null rx925_debug, debug_782
    rx925_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_782:
  rx925_fail:
    (rx925_rep, rx925_pos, $I10, $P10) = rx925_cur."!mark_fail"(0)
    lt rx925_pos, -1, rx925_done
    eq rx925_pos, -1, rx925_fail
    jump $I10
  rx925_done:
    rx925_cur."!cursor_fail"()
    if_null rx925_debug, debug_783
    rx925_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_783:
    .return (rx925_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("187_1300060177.262") :method
.annotate 'line', 4
    $P927 = self."!PREFIX__!subrule"("ws", "proto")
    new $P928, "ResizablePMCArray"
    push $P928, $P927
    .return ($P928)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("188_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 430
    new $P934, "Undef"
    .lex "$*MULTINESS", $P934
.annotate 'line', 4
    .local string rx935_tgt
    .local int rx935_pos
    .local int rx935_off
    .local int rx935_eos
    .local int rx935_rep
    .local pmc rx935_cur
    .local pmc rx935_debug
    (rx935_cur, rx935_pos, rx935_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx935_cur
    .local pmc match
    .lex "$/", match
    length rx935_eos, rx935_tgt
    gt rx935_pos, rx935_eos, rx935_done
    set rx935_off, 0
    lt rx935_pos, 2, rx935_start
    sub rx935_off, rx935_pos, 1
    substr rx935_tgt, rx935_tgt, rx935_off
  rx935_start:
    eq $I10, 1, rx935_restart
    if_null rx935_debug, debug_784
    rx935_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan939_done
    goto rxscan939_scan
  rxscan939_loop:
    (rx935_pos) = rx935_cur."from"()
    inc rx935_pos
    rx935_cur."!cursor_from"(rx935_pos)
    ge rx935_pos, rx935_eos, rxscan939_done
  rxscan939_scan:
    set_addr $I10, rxscan939_loop
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  rxscan939_done:
.annotate 'line', 430
    rx935_cur."!cursor_pos"(rx935_pos)
    new $P940, "String"
    assign $P940, ""
    store_lex "$*MULTINESS", $P940
.annotate 'line', 431
  # rx subrule "declarator" subtype=capture negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."declarator"()
    unless $P10, rx935_fail
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx935_pos = $P10."pos"()
.annotate 'line', 429
  # rx pass
    rx935_cur."!cursor_pass"(rx935_pos, "multi_declarator:sym<null>")
    if_null rx935_debug, debug_785
    rx935_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx935_pos)
  debug_785:
    .return (rx935_cur)
  rx935_restart:
.annotate 'line', 4
    if_null rx935_debug, debug_786
    rx935_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_786:
  rx935_fail:
    (rx935_rep, rx935_pos, $I10, $P10) = rx935_cur."!mark_fail"(0)
    lt rx935_pos, -1, rx935_done
    eq rx935_pos, -1, rx935_fail
    jump $I10
  rx935_done:
    rx935_cur."!cursor_fail"()
    if_null rx935_debug, debug_787
    rx935_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_787:
    .return (rx935_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("189_1300060177.262") :method
.annotate 'line', 4
    $P937 = self."!PREFIX__!subrule"("declarator", "")
    new $P938, "ResizablePMCArray"
    push $P938, $P937
    .return ($P938)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("190_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P950 = "192_1300060177.262" 
    capture_lex $P950
    .local string rx942_tgt
    .local int rx942_pos
    .local int rx942_off
    .local int rx942_eos
    .local int rx942_rep
    .local pmc rx942_cur
    .local pmc rx942_debug
    (rx942_cur, rx942_pos, rx942_tgt, $I10) = self."!cursor_start"()
    rx942_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx942_cur
    .local pmc match
    .lex "$/", match
    length rx942_eos, rx942_tgt
    gt rx942_pos, rx942_eos, rx942_done
    set rx942_off, 0
    lt rx942_pos, 2, rx942_start
    sub rx942_off, rx942_pos, 1
    substr rx942_tgt, rx942_tgt, rx942_off
  rx942_start:
    eq $I10, 1, rx942_restart
    if_null rx942_debug, debug_788
    rx942_cur."!cursor_debug"("START", "signature")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan945_done
    goto rxscan945_scan
  rxscan945_loop:
    (rx942_pos) = rx942_cur."from"()
    inc rx942_pos
    rx942_cur."!cursor_from"(rx942_pos)
    ge rx942_pos, rx942_eos, rxscan945_done
  rxscan945_scan:
    set_addr $I10, rxscan945_loop
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxscan945_done:
.annotate 'line', 435
  # rx rxquantr946 ** 0..1
    set_addr $I10, rxquantr946_done
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxquantr946_loop:
    rx942_cur."!cursor_pos"(rx942_pos)
    find_lex $P947, unicode:"$\x{a2}"
    $P948 = $P947."MATCH"()
    store_lex "$/", $P948
    .const 'Sub' $P950 = "192_1300060177.262" 
    capture_lex $P950
    $P952 = $P950()
    unless $P952, rx942_fail
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."parameter"()
    unless $P10, rx942_fail
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx942_pos, 1
    gt $I11, rx942_eos, rx942_fail
    sub $I11, rx942_pos, rx942_off
    ord $I11, rx942_tgt, $I11
    ne $I11, 58, rx942_fail
    add rx942_pos, 1
    set_addr $I10, rxquantr946_done
    (rx942_rep) = rx942_cur."!mark_commit"($I10)
  rxquantr946_done:
.annotate 'line', 436
  # rx rxquantr953 ** 0..1
    set_addr $I10, rxquantr953_done
    rx942_cur."!mark_push"(0, rx942_pos, $I10)
  rxquantr953_loop:
  # rx rxquantr954 ** 1..*
    set_addr $I10, rxquantr954_done
    rx942_cur."!mark_push"(0, -1, $I10)
  rxquantr954_loop:
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."parameter"()
    unless $P10, rx942_fail
    rx942_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx942_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx942_cur."!cursor_pos"(rx942_pos)
    $P10 = rx942_cur."ws"()
    unless $P10, rx942_fail
    rx942_pos = $P10."pos"()
    set_addr $I10, rxquantr954_done
    (rx942_rep) = rx942_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr954_done
    rx942_cur."!mark_push"(rx942_rep, rx942_pos, $I10)
  # rx literal  ","
    add $I11, rx942_pos, 1
    gt $I11, rx942_eos, rx942_fail
    sub $I11, rx942_pos, rx942_off
    ord $I11, rx942_tgt, $I11
    ne $I11, 44, rx942_fail
    add rx942_pos, 1
    goto rxquantr954_loop
  rxquantr954_done:
    set_addr $I10, rxquantr953_done
    (rx942_rep) = rx942_cur."!mark_commit"($I10)
  rxquantr953_done:
.annotate 'line', 434
  # rx pass
    rx942_cur."!cursor_pass"(rx942_pos, "signature")
    if_null rx942_debug, debug_791
    rx942_cur."!cursor_debug"("PASS", "signature", " at pos=", rx942_pos)
  debug_791:
    .return (rx942_cur)
  rx942_restart:
.annotate 'line', 4
    if_null rx942_debug, debug_792
    rx942_cur."!cursor_debug"("NEXT", "signature")
  debug_792:
  rx942_fail:
    (rx942_rep, rx942_pos, $I10, $P10) = rx942_cur."!mark_fail"(0)
    lt rx942_pos, -1, rx942_done
    eq rx942_pos, -1, rx942_fail
    jump $I10
  rx942_done:
    rx942_cur."!cursor_fail"()
    if_null rx942_debug, debug_793
    rx942_cur."!cursor_debug"("FAIL", "signature")
  debug_793:
    .return (rx942_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("191_1300060177.262") :method
.annotate 'line', 4
    new $P944, "ResizablePMCArray"
    push $P944, ""
    .return ($P944)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block949"  :anon :subid("192_1300060177.262") :outer("190_1300060177.262")
.annotate 'line', 435
    find_dynamic_lex $P951, "$*INVOCANT_OK"
    unless_null $P951, vivify_789
    get_hll_global $P951, "$INVOCANT_OK"
    unless_null $P951, vivify_790
    die "Contextual $*INVOCANT_OK not found"
  vivify_790:
  vivify_789:
    .return ($P951)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("193_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx956_tgt
    .local int rx956_pos
    .local int rx956_off
    .local int rx956_eos
    .local int rx956_rep
    .local pmc rx956_cur
    .local pmc rx956_debug
    (rx956_cur, rx956_pos, rx956_tgt, $I10) = self."!cursor_start"()
    rx956_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx956_cur
    .local pmc match
    .lex "$/", match
    length rx956_eos, rx956_tgt
    gt rx956_pos, rx956_eos, rx956_done
    set rx956_off, 0
    lt rx956_pos, 2, rx956_start
    sub rx956_off, rx956_pos, 1
    substr rx956_tgt, rx956_tgt, rx956_off
  rx956_start:
    eq $I10, 1, rx956_restart
    if_null rx956_debug, debug_794
    rx956_cur."!cursor_debug"("START", "parameter")
  debug_794:
    $I10 = self.'from'()
    ne $I10, -1, rxscan959_done
    goto rxscan959_scan
  rxscan959_loop:
    (rx956_pos) = rx956_cur."from"()
    inc rx956_pos
    rx956_cur."!cursor_from"(rx956_pos)
    ge rx956_pos, rx956_eos, rxscan959_done
  rxscan959_scan:
    set_addr $I10, rxscan959_loop
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
  rxscan959_done:
.annotate 'line', 440
  # rx rxquantr960 ** 0..*
    set_addr $I10, rxquantr960_done
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
  rxquantr960_loop:
  # rx subrule "typename" subtype=capture negate=
    rx956_cur."!cursor_pos"(rx956_pos)
    $P10 = rx956_cur."typename"()
    unless $P10, rx956_fail
    rx956_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx956_pos = $P10."pos"()
  # rx rxquantr961 ** 0..1
    set_addr $I10, rxquantr961_done
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
  rxquantr961_loop:
  # rx literal  ":"
    add $I11, rx956_pos, 1
    gt $I11, rx956_eos, rx956_fail
    sub $I11, rx956_pos, rx956_off
    ord $I11, rx956_tgt, $I11
    ne $I11, 58, rx956_fail
    add rx956_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_962_fail
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx956_pos, rx956_eos, rx956_fail
    sub $I10, rx956_pos, rx956_off
    substr $S10, rx956_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx956_fail
    inc rx956_pos
    set_addr $I10, rxcap_962_fail
    ($I12, $I11) = rx956_cur."!mark_peek"($I10)
    rx956_cur."!cursor_pos"($I11)
    ($P10) = rx956_cur."!cursor_start"()
    $P10."!cursor_pass"(rx956_pos, "")
    rx956_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_962_done
  rxcap_962_fail:
    goto rx956_fail
  rxcap_962_done:
    set_addr $I10, rxquantr961_done
    (rx956_rep) = rx956_cur."!mark_commit"($I10)
  rxquantr961_done:
  # rx subrule "ws" subtype=method negate=
    rx956_cur."!cursor_pos"(rx956_pos)
    $P10 = rx956_cur."ws"()
    unless $P10, rx956_fail
    rx956_pos = $P10."pos"()
    set_addr $I10, rxquantr960_done
    (rx956_rep) = rx956_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr960_done
    rx956_cur."!mark_push"(rx956_rep, rx956_pos, $I10)
    goto rxquantr960_loop
  rxquantr960_done:
  alt963_0:
.annotate 'line', 441
    set_addr $I10, alt963_1
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
.annotate 'line', 442
  # rx subcapture "quant"
    set_addr $I10, rxcap_964_fail
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
  # rx literal  "*"
    add $I11, rx956_pos, 1
    gt $I11, rx956_eos, rx956_fail
    sub $I11, rx956_pos, rx956_off
    ord $I11, rx956_tgt, $I11
    ne $I11, 42, rx956_fail
    add rx956_pos, 1
    set_addr $I10, rxcap_964_fail
    ($I12, $I11) = rx956_cur."!mark_peek"($I10)
    rx956_cur."!cursor_pos"($I11)
    ($P10) = rx956_cur."!cursor_start"()
    $P10."!cursor_pass"(rx956_pos, "")
    rx956_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_964_done
  rxcap_964_fail:
    goto rx956_fail
  rxcap_964_done:
  # rx subrule "param_var" subtype=capture negate=
    rx956_cur."!cursor_pos"(rx956_pos)
    $P10 = rx956_cur."param_var"()
    unless $P10, rx956_fail
    rx956_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx956_pos = $P10."pos"()
    goto alt963_end
  alt963_1:
  alt965_0:
.annotate 'line', 443
    set_addr $I10, alt965_1
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx956_cur."!cursor_pos"(rx956_pos)
    $P10 = rx956_cur."param_var"()
    unless $P10, rx956_fail
    rx956_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx956_pos = $P10."pos"()
    goto alt965_end
  alt965_1:
  # rx subrule "named_param" subtype=capture negate=
    rx956_cur."!cursor_pos"(rx956_pos)
    $P10 = rx956_cur."named_param"()
    unless $P10, rx956_fail
    rx956_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx956_pos = $P10."pos"()
  alt965_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_967_fail
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
  alt966_0:
    set_addr $I10, alt966_1
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
  # rx literal  "?"
    add $I11, rx956_pos, 1
    gt $I11, rx956_eos, rx956_fail
    sub $I11, rx956_pos, rx956_off
    ord $I11, rx956_tgt, $I11
    ne $I11, 63, rx956_fail
    add rx956_pos, 1
    goto alt966_end
  alt966_1:
    set_addr $I10, alt966_2
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
  # rx literal  "!"
    add $I11, rx956_pos, 1
    gt $I11, rx956_eos, rx956_fail
    sub $I11, rx956_pos, rx956_off
    ord $I11, rx956_tgt, $I11
    ne $I11, 33, rx956_fail
    add rx956_pos, 1
    goto alt966_end
  alt966_2:
  alt966_end:
    set_addr $I10, rxcap_967_fail
    ($I12, $I11) = rx956_cur."!mark_peek"($I10)
    rx956_cur."!cursor_pos"($I11)
    ($P10) = rx956_cur."!cursor_start"()
    $P10."!cursor_pass"(rx956_pos, "")
    rx956_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_967_done
  rxcap_967_fail:
    goto rx956_fail
  rxcap_967_done:
  alt963_end:
.annotate 'line', 445
  # rx rxquantr968 ** 0..1
    set_addr $I10, rxquantr968_done
    rx956_cur."!mark_push"(0, rx956_pos, $I10)
  rxquantr968_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx956_cur."!cursor_pos"(rx956_pos)
    $P10 = rx956_cur."default_value"()
    unless $P10, rx956_fail
    goto rxsubrule969_pass
  rxsubrule969_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx956_fail
  rxsubrule969_pass:
    set_addr $I10, rxsubrule969_back
    rx956_cur."!mark_push"(0, rx956_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx956_pos = $P10."pos"()
    set_addr $I10, rxquantr968_done
    (rx956_rep) = rx956_cur."!mark_commit"($I10)
  rxquantr968_done:
.annotate 'line', 439
  # rx pass
    rx956_cur."!cursor_pass"(rx956_pos, "parameter")
    if_null rx956_debug, debug_795
    rx956_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx956_pos)
  debug_795:
    .return (rx956_cur)
  rx956_restart:
.annotate 'line', 4
    if_null rx956_debug, debug_796
    rx956_cur."!cursor_debug"("NEXT", "parameter")
  debug_796:
  rx956_fail:
    (rx956_rep, rx956_pos, $I10, $P10) = rx956_cur."!mark_fail"(0)
    lt rx956_pos, -1, rx956_done
    eq rx956_pos, -1, rx956_fail
    jump $I10
  rx956_done:
    rx956_cur."!cursor_fail"()
    if_null rx956_debug, debug_797
    rx956_cur."!cursor_debug"("FAIL", "parameter")
  debug_797:
    .return (rx956_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("194_1300060177.262") :method
.annotate 'line', 4
    new $P958, "ResizablePMCArray"
    push $P958, ""
    .return ($P958)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("195_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx971_tgt
    .local int rx971_pos
    .local int rx971_off
    .local int rx971_eos
    .local int rx971_rep
    .local pmc rx971_cur
    .local pmc rx971_debug
    (rx971_cur, rx971_pos, rx971_tgt, $I10) = self."!cursor_start"()
    rx971_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx971_cur
    .local pmc match
    .lex "$/", match
    length rx971_eos, rx971_tgt
    gt rx971_pos, rx971_eos, rx971_done
    set rx971_off, 0
    lt rx971_pos, 2, rx971_start
    sub rx971_off, rx971_pos, 1
    substr rx971_tgt, rx971_tgt, rx971_off
  rx971_start:
    eq $I10, 1, rx971_restart
    if_null rx971_debug, debug_798
    rx971_cur."!cursor_debug"("START", "param_var")
  debug_798:
    $I10 = self.'from'()
    ne $I10, -1, rxscan975_done
    goto rxscan975_scan
  rxscan975_loop:
    (rx971_pos) = rx971_cur."from"()
    inc rx971_pos
    rx971_cur."!cursor_from"(rx971_pos)
    ge rx971_pos, rx971_eos, rxscan975_done
  rxscan975_scan:
    set_addr $I10, rxscan975_loop
    rx971_cur."!mark_push"(0, rx971_pos, $I10)
  rxscan975_done:
.annotate 'line', 449
  # rx subrule "sigil" subtype=capture negate=
    rx971_cur."!cursor_pos"(rx971_pos)
    $P10 = rx971_cur."sigil"()
    unless $P10, rx971_fail
    rx971_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx971_pos = $P10."pos"()
  # rx rxquantr976 ** 0..1
    set_addr $I10, rxquantr976_done
    rx971_cur."!mark_push"(0, rx971_pos, $I10)
  rxquantr976_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx971_cur."!cursor_pos"(rx971_pos)
    $P10 = rx971_cur."twigil"()
    unless $P10, rx971_fail
    goto rxsubrule977_pass
  rxsubrule977_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx971_fail
  rxsubrule977_pass:
    set_addr $I10, rxsubrule977_back
    rx971_cur."!mark_push"(0, rx971_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx971_pos = $P10."pos"()
    set_addr $I10, rxquantr976_done
    (rx971_rep) = rx971_cur."!mark_commit"($I10)
  rxquantr976_done:
  alt978_0:
.annotate 'line', 450
    set_addr $I10, alt978_1
    rx971_cur."!mark_push"(0, rx971_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx971_cur."!cursor_pos"(rx971_pos)
    $P10 = rx971_cur."ident"()
    unless $P10, rx971_fail
    rx971_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx971_pos = $P10."pos"()
    goto alt978_end
  alt978_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_979_fail
    rx971_cur."!mark_push"(0, rx971_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx971_pos, rx971_eos, rx971_fail
    sub $I10, rx971_pos, rx971_off
    substr $S10, rx971_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx971_fail
    inc rx971_pos
    set_addr $I10, rxcap_979_fail
    ($I12, $I11) = rx971_cur."!mark_peek"($I10)
    rx971_cur."!cursor_pos"($I11)
    ($P10) = rx971_cur."!cursor_start"()
    $P10."!cursor_pass"(rx971_pos, "")
    rx971_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_979_done
  rxcap_979_fail:
    goto rx971_fail
  rxcap_979_done:
  alt978_end:
.annotate 'line', 448
  # rx pass
    rx971_cur."!cursor_pass"(rx971_pos, "param_var")
    if_null rx971_debug, debug_799
    rx971_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx971_pos)
  debug_799:
    .return (rx971_cur)
  rx971_restart:
.annotate 'line', 4
    if_null rx971_debug, debug_800
    rx971_cur."!cursor_debug"("NEXT", "param_var")
  debug_800:
  rx971_fail:
    (rx971_rep, rx971_pos, $I10, $P10) = rx971_cur."!mark_fail"(0)
    lt rx971_pos, -1, rx971_done
    eq rx971_pos, -1, rx971_fail
    jump $I10
  rx971_done:
    rx971_cur."!cursor_fail"()
    if_null rx971_debug, debug_801
    rx971_cur."!cursor_debug"("FAIL", "param_var")
  debug_801:
    .return (rx971_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("196_1300060177.262") :method
.annotate 'line', 4
    $P973 = self."!PREFIX__!subrule"("sigil", "")
    new $P974, "ResizablePMCArray"
    push $P974, $P973
    .return ($P974)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("197_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx981_tgt
    .local int rx981_pos
    .local int rx981_off
    .local int rx981_eos
    .local int rx981_rep
    .local pmc rx981_cur
    .local pmc rx981_debug
    (rx981_cur, rx981_pos, rx981_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx981_cur
    .local pmc match
    .lex "$/", match
    length rx981_eos, rx981_tgt
    gt rx981_pos, rx981_eos, rx981_done
    set rx981_off, 0
    lt rx981_pos, 2, rx981_start
    sub rx981_off, rx981_pos, 1
    substr rx981_tgt, rx981_tgt, rx981_off
  rx981_start:
    eq $I10, 1, rx981_restart
    if_null rx981_debug, debug_802
    rx981_cur."!cursor_debug"("START", "named_param")
  debug_802:
    $I10 = self.'from'()
    ne $I10, -1, rxscan985_done
    goto rxscan985_scan
  rxscan985_loop:
    (rx981_pos) = rx981_cur."from"()
    inc rx981_pos
    rx981_cur."!cursor_from"(rx981_pos)
    ge rx981_pos, rx981_eos, rxscan985_done
  rxscan985_scan:
    set_addr $I10, rxscan985_loop
    rx981_cur."!mark_push"(0, rx981_pos, $I10)
  rxscan985_done:
.annotate 'line', 454
  # rx literal  ":"
    add $I11, rx981_pos, 1
    gt $I11, rx981_eos, rx981_fail
    sub $I11, rx981_pos, rx981_off
    ord $I11, rx981_tgt, $I11
    ne $I11, 58, rx981_fail
    add rx981_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx981_cur."!cursor_pos"(rx981_pos)
    $P10 = rx981_cur."param_var"()
    unless $P10, rx981_fail
    rx981_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx981_pos = $P10."pos"()
.annotate 'line', 453
  # rx pass
    rx981_cur."!cursor_pass"(rx981_pos, "named_param")
    if_null rx981_debug, debug_803
    rx981_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx981_pos)
  debug_803:
    .return (rx981_cur)
  rx981_restart:
.annotate 'line', 4
    if_null rx981_debug, debug_804
    rx981_cur."!cursor_debug"("NEXT", "named_param")
  debug_804:
  rx981_fail:
    (rx981_rep, rx981_pos, $I10, $P10) = rx981_cur."!mark_fail"(0)
    lt rx981_pos, -1, rx981_done
    eq rx981_pos, -1, rx981_fail
    jump $I10
  rx981_done:
    rx981_cur."!cursor_fail"()
    if_null rx981_debug, debug_805
    rx981_cur."!cursor_debug"("FAIL", "named_param")
  debug_805:
    .return (rx981_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("198_1300060177.262") :method
.annotate 'line', 4
    $P983 = self."!PREFIX__!subrule"("param_var", ":")
    new $P984, "ResizablePMCArray"
    push $P984, $P983
    .return ($P984)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("199_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx987_tgt
    .local int rx987_pos
    .local int rx987_off
    .local int rx987_eos
    .local int rx987_rep
    .local pmc rx987_cur
    .local pmc rx987_debug
    (rx987_cur, rx987_pos, rx987_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx987_cur
    .local pmc match
    .lex "$/", match
    length rx987_eos, rx987_tgt
    gt rx987_pos, rx987_eos, rx987_done
    set rx987_off, 0
    lt rx987_pos, 2, rx987_start
    sub rx987_off, rx987_pos, 1
    substr rx987_tgt, rx987_tgt, rx987_off
  rx987_start:
    eq $I10, 1, rx987_restart
    if_null rx987_debug, debug_806
    rx987_cur."!cursor_debug"("START", "default_value")
  debug_806:
    $I10 = self.'from'()
    ne $I10, -1, rxscan991_done
    goto rxscan991_scan
  rxscan991_loop:
    (rx987_pos) = rx987_cur."from"()
    inc rx987_pos
    rx987_cur."!cursor_from"(rx987_pos)
    ge rx987_pos, rx987_eos, rxscan991_done
  rxscan991_scan:
    set_addr $I10, rxscan991_loop
    rx987_cur."!mark_push"(0, rx987_pos, $I10)
  rxscan991_done:
.annotate 'line', 457
  # rx subrule "ws" subtype=method negate=
    rx987_cur."!cursor_pos"(rx987_pos)
    $P10 = rx987_cur."ws"()
    unless $P10, rx987_fail
    rx987_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx987_pos, 1
    gt $I11, rx987_eos, rx987_fail
    sub $I11, rx987_pos, rx987_off
    ord $I11, rx987_tgt, $I11
    ne $I11, 61, rx987_fail
    add rx987_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx987_cur."!cursor_pos"(rx987_pos)
    $P10 = rx987_cur."ws"()
    unless $P10, rx987_fail
    rx987_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx987_cur."!cursor_pos"(rx987_pos)
    $P10 = rx987_cur."EXPR"("i=")
    unless $P10, rx987_fail
    rx987_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx987_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx987_cur."!cursor_pos"(rx987_pos)
    $P10 = rx987_cur."ws"()
    unless $P10, rx987_fail
    rx987_pos = $P10."pos"()
  # rx pass
    rx987_cur."!cursor_pass"(rx987_pos, "default_value")
    if_null rx987_debug, debug_807
    rx987_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx987_pos)
  debug_807:
    .return (rx987_cur)
  rx987_restart:
.annotate 'line', 4
    if_null rx987_debug, debug_808
    rx987_cur."!cursor_debug"("NEXT", "default_value")
  debug_808:
  rx987_fail:
    (rx987_rep, rx987_pos, $I10, $P10) = rx987_cur."!mark_fail"(0)
    lt rx987_pos, -1, rx987_done
    eq rx987_pos, -1, rx987_fail
    jump $I10
  rx987_done:
    rx987_cur."!cursor_fail"()
    if_null rx987_debug, debug_809
    rx987_cur."!cursor_debug"("FAIL", "default_value")
  debug_809:
    .return (rx987_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("200_1300060177.262") :method
.annotate 'line', 4
    $P989 = self."!PREFIX__!subrule"("ws", "")
    new $P990, "ResizablePMCArray"
    push $P990, $P989
    .return ($P990)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("201_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx996_tgt
    .local int rx996_pos
    .local int rx996_off
    .local int rx996_eos
    .local int rx996_rep
    .local pmc rx996_cur
    .local pmc rx996_debug
    (rx996_cur, rx996_pos, rx996_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx996_cur
    .local pmc match
    .lex "$/", match
    length rx996_eos, rx996_tgt
    gt rx996_pos, rx996_eos, rx996_done
    set rx996_off, 0
    lt rx996_pos, 2, rx996_start
    sub rx996_off, rx996_pos, 1
    substr rx996_tgt, rx996_tgt, rx996_off
  rx996_start:
    eq $I10, 1, rx996_restart
    if_null rx996_debug, debug_810
    rx996_cur."!cursor_debug"("START", "trait")
  debug_810:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1000_done
    goto rxscan1000_scan
  rxscan1000_loop:
    (rx996_pos) = rx996_cur."from"()
    inc rx996_pos
    rx996_cur."!cursor_from"(rx996_pos)
    ge rx996_pos, rx996_eos, rxscan1000_done
  rxscan1000_scan:
    set_addr $I10, rxscan1000_loop
    rx996_cur."!mark_push"(0, rx996_pos, $I10)
  rxscan1000_done:
.annotate 'line', 459
  # rx subrule "ws" subtype=method negate=
    rx996_cur."!cursor_pos"(rx996_pos)
    $P10 = rx996_cur."ws"()
    unless $P10, rx996_fail
    rx996_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx996_cur."!cursor_pos"(rx996_pos)
    $P10 = rx996_cur."trait_mod"()
    unless $P10, rx996_fail
    rx996_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx996_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx996_cur."!cursor_pos"(rx996_pos)
    $P10 = rx996_cur."ws"()
    unless $P10, rx996_fail
    rx996_pos = $P10."pos"()
  # rx pass
    rx996_cur."!cursor_pass"(rx996_pos, "trait")
    if_null rx996_debug, debug_811
    rx996_cur."!cursor_debug"("PASS", "trait", " at pos=", rx996_pos)
  debug_811:
    .return (rx996_cur)
  rx996_restart:
.annotate 'line', 4
    if_null rx996_debug, debug_812
    rx996_cur."!cursor_debug"("NEXT", "trait")
  debug_812:
  rx996_fail:
    (rx996_rep, rx996_pos, $I10, $P10) = rx996_cur."!mark_fail"(0)
    lt rx996_pos, -1, rx996_done
    eq rx996_pos, -1, rx996_fail
    jump $I10
  rx996_done:
    rx996_cur."!cursor_fail"()
    if_null rx996_debug, debug_813
    rx996_cur."!cursor_debug"("FAIL", "trait")
  debug_813:
    .return (rx996_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("202_1300060177.262") :method
.annotate 'line', 4
    $P998 = self."!PREFIX__!subrule"("ws", "")
    new $P999, "ResizablePMCArray"
    push $P999, $P998
    .return ($P999)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("203_1300060177.262")
    .param pmc param_1004
.annotate 'line', 461
    .lex "self", param_1004
    $P1005 = param_1004."!protoregex"("trait_mod")
    .return ($P1005)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("204_1300060177.262")
    .param pmc param_1007
.annotate 'line', 461
    .lex "self", param_1007
    $P1008 = param_1007."!PREFIX__!protoregex"("trait_mod")
    .return ($P1008)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("205_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1010_tgt
    .local int rx1010_pos
    .local int rx1010_off
    .local int rx1010_eos
    .local int rx1010_rep
    .local pmc rx1010_cur
    .local pmc rx1010_debug
    (rx1010_cur, rx1010_pos, rx1010_tgt, $I10) = self."!cursor_start"()
    rx1010_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1010_cur
    .local pmc match
    .lex "$/", match
    length rx1010_eos, rx1010_tgt
    gt rx1010_pos, rx1010_eos, rx1010_done
    set rx1010_off, 0
    lt rx1010_pos, 2, rx1010_start
    sub rx1010_off, rx1010_pos, 1
    substr rx1010_tgt, rx1010_tgt, rx1010_off
  rx1010_start:
    eq $I10, 1, rx1010_restart
    if_null rx1010_debug, debug_814
    rx1010_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_814:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1014_done
    goto rxscan1014_scan
  rxscan1014_loop:
    (rx1010_pos) = rx1010_cur."from"()
    inc rx1010_pos
    rx1010_cur."!cursor_from"(rx1010_pos)
    ge rx1010_pos, rx1010_eos, rxscan1014_done
  rxscan1014_scan:
    set_addr $I10, rxscan1014_loop
    rx1010_cur."!mark_push"(0, rx1010_pos, $I10)
  rxscan1014_done:
.annotate 'line', 462
  # rx subcapture "sym"
    set_addr $I10, rxcap_1015_fail
    rx1010_cur."!mark_push"(0, rx1010_pos, $I10)
  # rx literal  "is"
    add $I11, rx1010_pos, 2
    gt $I11, rx1010_eos, rx1010_fail
    sub $I11, rx1010_pos, rx1010_off
    substr $S10, rx1010_tgt, $I11, 2
    ne $S10, "is", rx1010_fail
    add rx1010_pos, 2
    set_addr $I10, rxcap_1015_fail
    ($I12, $I11) = rx1010_cur."!mark_peek"($I10)
    rx1010_cur."!cursor_pos"($I11)
    ($P10) = rx1010_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1010_pos, "")
    rx1010_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1015_done
  rxcap_1015_fail:
    goto rx1010_fail
  rxcap_1015_done:
  # rx subrule "ws" subtype=method negate=
    rx1010_cur."!cursor_pos"(rx1010_pos)
    $P10 = rx1010_cur."ws"()
    unless $P10, rx1010_fail
    rx1010_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1010_cur."!cursor_pos"(rx1010_pos)
    $P10 = rx1010_cur."deflongname"()
    unless $P10, rx1010_fail
    rx1010_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1010_pos = $P10."pos"()
  # rx rxquantr1017 ** 0..1
    set_addr $I10, rxquantr1017_done
    rx1010_cur."!mark_push"(0, rx1010_pos, $I10)
  rxquantr1017_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1010_cur."!cursor_pos"(rx1010_pos)
    $P10 = rx1010_cur."circumfix"()
    unless $P10, rx1010_fail
    goto rxsubrule1018_pass
  rxsubrule1018_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1010_fail
  rxsubrule1018_pass:
    set_addr $I10, rxsubrule1018_back
    rx1010_cur."!mark_push"(0, rx1010_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1010_pos = $P10."pos"()
    set_addr $I10, rxquantr1017_done
    (rx1010_rep) = rx1010_cur."!mark_commit"($I10)
  rxquantr1017_done:
  # rx subrule "ws" subtype=method negate=
    rx1010_cur."!cursor_pos"(rx1010_pos)
    $P10 = rx1010_cur."ws"()
    unless $P10, rx1010_fail
    rx1010_pos = $P10."pos"()
  # rx pass
    rx1010_cur."!cursor_pass"(rx1010_pos, "trait_mod:sym<is>")
    if_null rx1010_debug, debug_815
    rx1010_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1010_pos)
  debug_815:
    .return (rx1010_cur)
  rx1010_restart:
.annotate 'line', 4
    if_null rx1010_debug, debug_816
    rx1010_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_816:
  rx1010_fail:
    (rx1010_rep, rx1010_pos, $I10, $P10) = rx1010_cur."!mark_fail"(0)
    lt rx1010_pos, -1, rx1010_done
    eq rx1010_pos, -1, rx1010_fail
    jump $I10
  rx1010_done:
    rx1010_cur."!cursor_fail"()
    if_null rx1010_debug, debug_817
    rx1010_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_817:
    .return (rx1010_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("206_1300060177.262") :method
.annotate 'line', 4
    $P1012 = self."!PREFIX__!subrule"("ws", "is")
    new $P1013, "ResizablePMCArray"
    push $P1013, $P1012
    .return ($P1013)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("207_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1021_tgt
    .local int rx1021_pos
    .local int rx1021_off
    .local int rx1021_eos
    .local int rx1021_rep
    .local pmc rx1021_cur
    .local pmc rx1021_debug
    (rx1021_cur, rx1021_pos, rx1021_tgt, $I10) = self."!cursor_start"()
    rx1021_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1021_cur
    .local pmc match
    .lex "$/", match
    length rx1021_eos, rx1021_tgt
    gt rx1021_pos, rx1021_eos, rx1021_done
    set rx1021_off, 0
    lt rx1021_pos, 2, rx1021_start
    sub rx1021_off, rx1021_pos, 1
    substr rx1021_tgt, rx1021_tgt, rx1021_off
  rx1021_start:
    eq $I10, 1, rx1021_restart
    if_null rx1021_debug, debug_818
    rx1021_cur."!cursor_debug"("START", "regex_declarator")
  debug_818:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1025_done
    goto rxscan1025_scan
  rxscan1025_loop:
    (rx1021_pos) = rx1021_cur."from"()
    inc rx1021_pos
    rx1021_cur."!cursor_from"(rx1021_pos)
    ge rx1021_pos, rx1021_eos, rxscan1025_done
  rxscan1025_scan:
    set_addr $I10, rxscan1025_loop
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  rxscan1025_done:
.annotate 'line', 464
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  alt1027_0:
.annotate 'line', 465
    set_addr $I10, alt1027_1
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
.annotate 'line', 466
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1029_fail
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1021_pos, 5
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    substr $S10, rx1021_tgt, $I11, 5
    ne $S10, "proto", rx1021_fail
    add rx1021_pos, 5
    set_addr $I10, rxcap_1029_fail
    ($I12, $I11) = rx1021_cur."!mark_peek"($I10)
    rx1021_cur."!cursor_pos"($I11)
    ($P10) = rx1021_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1021_pos, "")
    rx1021_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1029_done
  rxcap_1029_fail:
    goto rx1021_fail
  rxcap_1029_done:
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  alt1031_0:
    set_addr $I10, alt1031_1
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1021_pos, 5
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    substr $S10, rx1021_tgt, $I11, 5
    ne $S10, "regex", rx1021_fail
    add rx1021_pos, 5
    goto alt1031_end
  alt1031_1:
    set_addr $I10, alt1031_2
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  # rx literal  "token"
    add $I11, rx1021_pos, 5
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    substr $S10, rx1021_tgt, $I11, 5
    ne $S10, "token", rx1021_fail
    add rx1021_pos, 5
    goto alt1031_end
  alt1031_2:
  # rx literal  "rule"
    add $I11, rx1021_pos, 4
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    substr $S10, rx1021_tgt, $I11, 4
    ne $S10, "rule", rx1021_fail
    add rx1021_pos, 4
  alt1031_end:
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
.annotate 'line', 467
  # rx subrule "deflongname" subtype=capture negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."deflongname"()
    unless $P10, rx1021_fail
    rx1021_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1021_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  alt1034_0:
.annotate 'line', 468
    set_addr $I10, alt1034_1
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
.annotate 'line', 469
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1021_pos, 1
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    ord $I11, rx1021_tgt, $I11
    ne $I11, 123, rx1021_fail
    add rx1021_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1021_pos, 5
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    substr $S10, rx1021_tgt, $I11, 5
    ne $S10, "<...>", rx1021_fail
    add rx1021_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1021_pos, 1
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    ord $I11, rx1021_tgt, $I11
    ne $I11, 125, rx1021_fail
    add rx1021_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ENDSTMT"()
    unless $P10, rx1021_fail
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
    goto alt1034_end
  alt1034_1:
    set_addr $I10, alt1034_2
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
.annotate 'line', 470
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1021_pos, 1
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    ord $I11, rx1021_tgt, $I11
    ne $I11, 123, rx1021_fail
    add rx1021_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1021_pos, 3
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    substr $S10, rx1021_tgt, $I11, 3
    ne $S10, "<*>", rx1021_fail
    add rx1021_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1021_pos, 1
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    ord $I11, rx1021_tgt, $I11
    ne $I11, 125, rx1021_fail
    add rx1021_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ENDSTMT"()
    unless $P10, rx1021_fail
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
    goto alt1034_end
  alt1034_2:
.annotate 'line', 471
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  alt1034_end:
.annotate 'line', 472
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
.annotate 'line', 466
    goto alt1027_end
  alt1027_1:
.annotate 'line', 473
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1048_fail
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  alt1047_0:
    set_addr $I10, alt1047_1
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1021_pos, 5
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    substr $S10, rx1021_tgt, $I11, 5
    ne $S10, "regex", rx1021_fail
    add rx1021_pos, 5
    goto alt1047_end
  alt1047_1:
    set_addr $I10, alt1047_2
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  # rx literal  "token"
    add $I11, rx1021_pos, 5
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    substr $S10, rx1021_tgt, $I11, 5
    ne $S10, "token", rx1021_fail
    add rx1021_pos, 5
    goto alt1047_end
  alt1047_2:
  # rx literal  "rule"
    add $I11, rx1021_pos, 4
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    substr $S10, rx1021_tgt, $I11, 4
    ne $S10, "rule", rx1021_fail
    add rx1021_pos, 4
  alt1047_end:
    set_addr $I10, rxcap_1048_fail
    ($I12, $I11) = rx1021_cur."!mark_peek"($I10)
    rx1021_cur."!cursor_pos"($I11)
    ($P10) = rx1021_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1021_pos, "")
    rx1021_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1048_done
  rxcap_1048_fail:
    goto rx1021_fail
  rxcap_1048_done:
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
.annotate 'line', 474
  # rx subrule "deflongname" subtype=capture negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."deflongname"()
    unless $P10, rx1021_fail
    rx1021_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1021_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
.annotate 'line', 475
  # rx subrule "newpad" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."newpad"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
.annotate 'line', 476
  # rx rxquantr1052 ** 0..1
    set_addr $I10, rxquantr1052_done
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  rxquantr1052_loop:
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1021_pos, 1
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    ord $I11, rx1021_tgt, $I11
    ne $I11, 40, rx1021_fail
    add rx1021_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."signature"()
    unless $P10, rx1021_fail
    rx1021_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1021_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1021_pos, 1
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    ord $I11, rx1021_tgt, $I11
    ne $I11, 41, rx1021_fail
    add rx1021_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
    set_addr $I10, rxquantr1052_done
    (rx1021_rep) = rx1021_cur."!mark_commit"($I10)
  rxquantr1052_done:
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
.annotate 'line', 477
  # rx reduce name="regex_declarator" key="open"
    rx1021_cur."!cursor_pos"(rx1021_pos)
    rx1021_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
.annotate 'line', 478
  # rx literal  "{"
    add $I11, rx1021_pos, 1
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    ord $I11, rx1021_tgt, $I11
    ne $I11, 123, rx1021_fail
    add rx1021_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1021_fail
    rx1021_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1021_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1021_pos, 1
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    ord $I11, rx1021_tgt, $I11
    ne $I11, 125, rx1021_fail
    add rx1021_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ENDSTMT"()
    unless $P10, rx1021_fail
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
  alt1027_end:
.annotate 'line', 479
  # rx subrule "ws" subtype=method negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."ws"()
    unless $P10, rx1021_fail
    rx1021_pos = $P10."pos"()
.annotate 'line', 464
  # rx pass
    rx1021_cur."!cursor_pass"(rx1021_pos, "regex_declarator")
    if_null rx1021_debug, debug_819
    rx1021_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1021_pos)
  debug_819:
    .return (rx1021_cur)
  rx1021_restart:
.annotate 'line', 4
    if_null rx1021_debug, debug_820
    rx1021_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_820:
  rx1021_fail:
    (rx1021_rep, rx1021_pos, $I10, $P10) = rx1021_cur."!mark_fail"(0)
    lt rx1021_pos, -1, rx1021_done
    eq rx1021_pos, -1, rx1021_fail
    jump $I10
  rx1021_done:
    rx1021_cur."!cursor_fail"()
    if_null rx1021_debug, debug_821
    rx1021_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_821:
    .return (rx1021_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("208_1300060177.262") :method
.annotate 'line', 4
    $P1023 = self."!PREFIX__!subrule"("ws", "")
    new $P1024, "ResizablePMCArray"
    push $P1024, $P1023
    .return ($P1024)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("209_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1062_tgt
    .local int rx1062_pos
    .local int rx1062_off
    .local int rx1062_eos
    .local int rx1062_rep
    .local pmc rx1062_cur
    .local pmc rx1062_debug
    (rx1062_cur, rx1062_pos, rx1062_tgt, $I10) = self."!cursor_start"()
    rx1062_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1062_cur
    .local pmc match
    .lex "$/", match
    length rx1062_eos, rx1062_tgt
    gt rx1062_pos, rx1062_eos, rx1062_done
    set rx1062_off, 0
    lt rx1062_pos, 2, rx1062_start
    sub rx1062_off, rx1062_pos, 1
    substr rx1062_tgt, rx1062_tgt, rx1062_off
  rx1062_start:
    eq $I10, 1, rx1062_restart
    if_null rx1062_debug, debug_822
    rx1062_cur."!cursor_debug"("START", "dotty")
  debug_822:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1066_done
    goto rxscan1066_scan
  rxscan1066_loop:
    (rx1062_pos) = rx1062_cur."from"()
    inc rx1062_pos
    rx1062_cur."!cursor_from"(rx1062_pos)
    ge rx1062_pos, rx1062_eos, rxscan1066_done
  rxscan1066_scan:
    set_addr $I10, rxscan1066_loop
    rx1062_cur."!mark_push"(0, rx1062_pos, $I10)
  rxscan1066_done:
.annotate 'line', 483
  # rx literal  "."
    add $I11, rx1062_pos, 1
    gt $I11, rx1062_eos, rx1062_fail
    sub $I11, rx1062_pos, rx1062_off
    ord $I11, rx1062_tgt, $I11
    ne $I11, 46, rx1062_fail
    add rx1062_pos, 1
  alt1067_0:
.annotate 'line', 484
    set_addr $I10, alt1067_1
    rx1062_cur."!mark_push"(0, rx1062_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1062_cur."!cursor_pos"(rx1062_pos)
    $P10 = rx1062_cur."deflongname"()
    unless $P10, rx1062_fail
    rx1062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1062_pos = $P10."pos"()
    goto alt1067_end
  alt1067_1:
.annotate 'line', 485
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1062_pos, rx1062_off
    substr $S10, rx1062_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1062_fail
  # rx subrule "quote" subtype=capture negate=
    rx1062_cur."!cursor_pos"(rx1062_pos)
    $P10 = rx1062_cur."quote"()
    unless $P10, rx1062_fail
    rx1062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1062_pos = $P10."pos"()
  alt1068_0:
.annotate 'line', 486
    set_addr $I10, alt1068_1
    rx1062_cur."!mark_push"(0, rx1062_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1062_pos, rx1062_off
    substr $S10, rx1062_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1062_fail
    goto alt1068_end
  alt1068_1:
  # rx subrule "panic" subtype=method negate=
    rx1062_cur."!cursor_pos"(rx1062_pos)
    $P10 = rx1062_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1062_fail
    rx1062_pos = $P10."pos"()
  alt1068_end:
  alt1067_end:
.annotate 'line', 492
  # rx rxquantr1069 ** 0..1
    set_addr $I10, rxquantr1069_done
    rx1062_cur."!mark_push"(0, rx1062_pos, $I10)
  rxquantr1069_loop:
  alt1070_0:
.annotate 'line', 489
    set_addr $I10, alt1070_1
    rx1062_cur."!mark_push"(0, rx1062_pos, $I10)
.annotate 'line', 490
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1062_pos, rx1062_off
    substr $S10, rx1062_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1062_fail
  # rx subrule "args" subtype=capture negate=
    rx1062_cur."!cursor_pos"(rx1062_pos)
    $P10 = rx1062_cur."args"()
    unless $P10, rx1062_fail
    rx1062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1062_pos = $P10."pos"()
    goto alt1070_end
  alt1070_1:
.annotate 'line', 491
  # rx literal  ":"
    add $I11, rx1062_pos, 1
    gt $I11, rx1062_eos, rx1062_fail
    sub $I11, rx1062_pos, rx1062_off
    ord $I11, rx1062_tgt, $I11
    ne $I11, 58, rx1062_fail
    add rx1062_pos, 1
  # rx charclass s
    ge rx1062_pos, rx1062_eos, rx1062_fail
    sub $I10, rx1062_pos, rx1062_off
    is_cclass $I11, 32, rx1062_tgt, $I10
    unless $I11, rx1062_fail
    inc rx1062_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1062_cur."!cursor_pos"(rx1062_pos)
    $P10 = rx1062_cur."arglist"()
    unless $P10, rx1062_fail
    rx1062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1062_pos = $P10."pos"()
  alt1070_end:
.annotate 'line', 492
    set_addr $I10, rxquantr1069_done
    (rx1062_rep) = rx1062_cur."!mark_commit"($I10)
  rxquantr1069_done:
.annotate 'line', 482
  # rx pass
    rx1062_cur."!cursor_pass"(rx1062_pos, "dotty")
    if_null rx1062_debug, debug_823
    rx1062_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1062_pos)
  debug_823:
    .return (rx1062_cur)
  rx1062_restart:
.annotate 'line', 4
    if_null rx1062_debug, debug_824
    rx1062_cur."!cursor_debug"("NEXT", "dotty")
  debug_824:
  rx1062_fail:
    (rx1062_rep, rx1062_pos, $I10, $P10) = rx1062_cur."!mark_fail"(0)
    lt rx1062_pos, -1, rx1062_done
    eq rx1062_pos, -1, rx1062_fail
    jump $I10
  rx1062_done:
    rx1062_cur."!cursor_fail"()
    if_null rx1062_debug, debug_825
    rx1062_cur."!cursor_debug"("FAIL", "dotty")
  debug_825:
    .return (rx1062_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("210_1300060177.262") :method
.annotate 'line', 4
    $P1064 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1065, "ResizablePMCArray"
    push $P1065, "'"
    push $P1065, "\""
    push $P1065, $P1064
    .return ($P1065)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("211_1300060177.262")
    .param pmc param_1072
.annotate 'line', 496
    .lex "self", param_1072
    $P1073 = param_1072."!protoregex"("term")
    .return ($P1073)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("212_1300060177.262")
    .param pmc param_1075
.annotate 'line', 496
    .lex "self", param_1075
    $P1076 = param_1075."!PREFIX__!protoregex"("term")
    .return ($P1076)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("213_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1078_tgt
    .local int rx1078_pos
    .local int rx1078_off
    .local int rx1078_eos
    .local int rx1078_rep
    .local pmc rx1078_cur
    .local pmc rx1078_debug
    (rx1078_cur, rx1078_pos, rx1078_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1078_cur
    .local pmc match
    .lex "$/", match
    length rx1078_eos, rx1078_tgt
    gt rx1078_pos, rx1078_eos, rx1078_done
    set rx1078_off, 0
    lt rx1078_pos, 2, rx1078_start
    sub rx1078_off, rx1078_pos, 1
    substr rx1078_tgt, rx1078_tgt, rx1078_off
  rx1078_start:
    eq $I10, 1, rx1078_restart
    if_null rx1078_debug, debug_826
    rx1078_cur."!cursor_debug"("START", "term:sym<self>")
  debug_826:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1081_done
    goto rxscan1081_scan
  rxscan1081_loop:
    (rx1078_pos) = rx1078_cur."from"()
    inc rx1078_pos
    rx1078_cur."!cursor_from"(rx1078_pos)
    ge rx1078_pos, rx1078_eos, rxscan1081_done
  rxscan1081_scan:
    set_addr $I10, rxscan1081_loop
    rx1078_cur."!mark_push"(0, rx1078_pos, $I10)
  rxscan1081_done:
.annotate 'line', 498
  # rx subcapture "sym"
    set_addr $I10, rxcap_1082_fail
    rx1078_cur."!mark_push"(0, rx1078_pos, $I10)
  # rx literal  "self"
    add $I11, rx1078_pos, 4
    gt $I11, rx1078_eos, rx1078_fail
    sub $I11, rx1078_pos, rx1078_off
    substr $S10, rx1078_tgt, $I11, 4
    ne $S10, "self", rx1078_fail
    add rx1078_pos, 4
    set_addr $I10, rxcap_1082_fail
    ($I12, $I11) = rx1078_cur."!mark_peek"($I10)
    rx1078_cur."!cursor_pos"($I11)
    ($P10) = rx1078_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1078_pos, "")
    rx1078_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1082_done
  rxcap_1082_fail:
    goto rx1078_fail
  rxcap_1082_done:
  # rxanchor rwb
    le rx1078_pos, 0, rx1078_fail
    sub $I10, rx1078_pos, rx1078_off
    is_cclass $I11, 8192, rx1078_tgt, $I10
    if $I11, rx1078_fail
    dec $I10
    is_cclass $I11, 8192, rx1078_tgt, $I10
    unless $I11, rx1078_fail
  # rx pass
    rx1078_cur."!cursor_pass"(rx1078_pos, "term:sym<self>")
    if_null rx1078_debug, debug_827
    rx1078_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1078_pos)
  debug_827:
    .return (rx1078_cur)
  rx1078_restart:
.annotate 'line', 4
    if_null rx1078_debug, debug_828
    rx1078_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_828:
  rx1078_fail:
    (rx1078_rep, rx1078_pos, $I10, $P10) = rx1078_cur."!mark_fail"(0)
    lt rx1078_pos, -1, rx1078_done
    eq rx1078_pos, -1, rx1078_fail
    jump $I10
  rx1078_done:
    rx1078_cur."!cursor_fail"()
    if_null rx1078_debug, debug_829
    rx1078_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_829:
    .return (rx1078_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("214_1300060177.262") :method
.annotate 'line', 4
    new $P1080, "ResizablePMCArray"
    push $P1080, "self"
    .return ($P1080)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("215_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1084_tgt
    .local int rx1084_pos
    .local int rx1084_off
    .local int rx1084_eos
    .local int rx1084_rep
    .local pmc rx1084_cur
    .local pmc rx1084_debug
    (rx1084_cur, rx1084_pos, rx1084_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1084_cur
    .local pmc match
    .lex "$/", match
    length rx1084_eos, rx1084_tgt
    gt rx1084_pos, rx1084_eos, rx1084_done
    set rx1084_off, 0
    lt rx1084_pos, 2, rx1084_start
    sub rx1084_off, rx1084_pos, 1
    substr rx1084_tgt, rx1084_tgt, rx1084_off
  rx1084_start:
    eq $I10, 1, rx1084_restart
    if_null rx1084_debug, debug_830
    rx1084_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_830:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1088_done
    goto rxscan1088_scan
  rxscan1088_loop:
    (rx1084_pos) = rx1084_cur."from"()
    inc rx1084_pos
    rx1084_cur."!cursor_from"(rx1084_pos)
    ge rx1084_pos, rx1084_eos, rxscan1088_done
  rxscan1088_scan:
    set_addr $I10, rxscan1088_loop
    rx1084_cur."!mark_push"(0, rx1084_pos, $I10)
  rxscan1088_done:
.annotate 'line', 501
  # rx subrule "deflongname" subtype=capture negate=
    rx1084_cur."!cursor_pos"(rx1084_pos)
    $P10 = rx1084_cur."deflongname"()
    unless $P10, rx1084_fail
    rx1084_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1084_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1084_pos, rx1084_off
    substr $S10, rx1084_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1084_fail
  # rx subrule "args" subtype=capture negate=
    rx1084_cur."!cursor_pos"(rx1084_pos)
    $P10 = rx1084_cur."args"()
    unless $P10, rx1084_fail
    rx1084_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1084_pos = $P10."pos"()
.annotate 'line', 500
  # rx pass
    rx1084_cur."!cursor_pass"(rx1084_pos, "term:sym<identifier>")
    if_null rx1084_debug, debug_831
    rx1084_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1084_pos)
  debug_831:
    .return (rx1084_cur)
  rx1084_restart:
.annotate 'line', 4
    if_null rx1084_debug, debug_832
    rx1084_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_832:
  rx1084_fail:
    (rx1084_rep, rx1084_pos, $I10, $P10) = rx1084_cur."!mark_fail"(0)
    lt rx1084_pos, -1, rx1084_done
    eq rx1084_pos, -1, rx1084_fail
    jump $I10
  rx1084_done:
    rx1084_cur."!cursor_fail"()
    if_null rx1084_debug, debug_833
    rx1084_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_833:
    .return (rx1084_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("216_1300060177.262") :method
.annotate 'line', 4
    $P1086 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1087, "ResizablePMCArray"
    push $P1087, $P1086
    .return ($P1087)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("217_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1090_tgt
    .local int rx1090_pos
    .local int rx1090_off
    .local int rx1090_eos
    .local int rx1090_rep
    .local pmc rx1090_cur
    .local pmc rx1090_debug
    (rx1090_cur, rx1090_pos, rx1090_tgt, $I10) = self."!cursor_start"()
    rx1090_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1090_cur
    .local pmc match
    .lex "$/", match
    length rx1090_eos, rx1090_tgt
    gt rx1090_pos, rx1090_eos, rx1090_done
    set rx1090_off, 0
    lt rx1090_pos, 2, rx1090_start
    sub rx1090_off, rx1090_pos, 1
    substr rx1090_tgt, rx1090_tgt, rx1090_off
  rx1090_start:
    eq $I10, 1, rx1090_restart
    if_null rx1090_debug, debug_834
    rx1090_cur."!cursor_debug"("START", "term:sym<name>")
  debug_834:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1094_done
    goto rxscan1094_scan
  rxscan1094_loop:
    (rx1090_pos) = rx1090_cur."from"()
    inc rx1090_pos
    rx1090_cur."!cursor_from"(rx1090_pos)
    ge rx1090_pos, rx1090_eos, rxscan1094_done
  rxscan1094_scan:
    set_addr $I10, rxscan1094_loop
    rx1090_cur."!mark_push"(0, rx1090_pos, $I10)
  rxscan1094_done:
.annotate 'line', 505
  # rx subrule "name" subtype=capture negate=
    rx1090_cur."!cursor_pos"(rx1090_pos)
    $P10 = rx1090_cur."name"()
    unless $P10, rx1090_fail
    rx1090_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1090_pos = $P10."pos"()
  # rx rxquantr1095 ** 0..1
    set_addr $I10, rxquantr1095_done
    rx1090_cur."!mark_push"(0, rx1090_pos, $I10)
  rxquantr1095_loop:
  # rx subrule "args" subtype=capture negate=
    rx1090_cur."!cursor_pos"(rx1090_pos)
    $P10 = rx1090_cur."args"()
    unless $P10, rx1090_fail
    goto rxsubrule1096_pass
  rxsubrule1096_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1090_fail
  rxsubrule1096_pass:
    set_addr $I10, rxsubrule1096_back
    rx1090_cur."!mark_push"(0, rx1090_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1090_pos = $P10."pos"()
    set_addr $I10, rxquantr1095_done
    (rx1090_rep) = rx1090_cur."!mark_commit"($I10)
  rxquantr1095_done:
.annotate 'line', 504
  # rx pass
    rx1090_cur."!cursor_pass"(rx1090_pos, "term:sym<name>")
    if_null rx1090_debug, debug_835
    rx1090_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1090_pos)
  debug_835:
    .return (rx1090_cur)
  rx1090_restart:
.annotate 'line', 4
    if_null rx1090_debug, debug_836
    rx1090_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_836:
  rx1090_fail:
    (rx1090_rep, rx1090_pos, $I10, $P10) = rx1090_cur."!mark_fail"(0)
    lt rx1090_pos, -1, rx1090_done
    eq rx1090_pos, -1, rx1090_fail
    jump $I10
  rx1090_done:
    rx1090_cur."!cursor_fail"()
    if_null rx1090_debug, debug_837
    rx1090_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_837:
    .return (rx1090_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("218_1300060177.262") :method
.annotate 'line', 4
    $P1092 = self."!PREFIX__!subrule"("name", "")
    new $P1093, "ResizablePMCArray"
    push $P1093, $P1092
    .return ($P1093)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("219_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1098_tgt
    .local int rx1098_pos
    .local int rx1098_off
    .local int rx1098_eos
    .local int rx1098_rep
    .local pmc rx1098_cur
    .local pmc rx1098_debug
    (rx1098_cur, rx1098_pos, rx1098_tgt, $I10) = self."!cursor_start"()
    rx1098_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1098_cur
    .local pmc match
    .lex "$/", match
    length rx1098_eos, rx1098_tgt
    gt rx1098_pos, rx1098_eos, rx1098_done
    set rx1098_off, 0
    lt rx1098_pos, 2, rx1098_start
    sub rx1098_off, rx1098_pos, 1
    substr rx1098_tgt, rx1098_tgt, rx1098_off
  rx1098_start:
    eq $I10, 1, rx1098_restart
    if_null rx1098_debug, debug_838
    rx1098_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_838:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1101_done
    goto rxscan1101_scan
  rxscan1101_loop:
    (rx1098_pos) = rx1098_cur."from"()
    inc rx1098_pos
    rx1098_cur."!cursor_from"(rx1098_pos)
    ge rx1098_pos, rx1098_eos, rxscan1101_done
  rxscan1101_scan:
    set_addr $I10, rxscan1101_loop
    rx1098_cur."!mark_push"(0, rx1098_pos, $I10)
  rxscan1101_done:
.annotate 'line', 509
  # rx literal  "pir::"
    add $I11, rx1098_pos, 5
    gt $I11, rx1098_eos, rx1098_fail
    sub $I11, rx1098_pos, rx1098_off
    substr $S10, rx1098_tgt, $I11, 5
    ne $S10, "pir::", rx1098_fail
    add rx1098_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1102_fail
    rx1098_cur."!mark_push"(0, rx1098_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1098_pos, rx1098_off
    find_not_cclass $I11, 8192, rx1098_tgt, $I10, rx1098_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1098_fail
    add rx1098_pos, rx1098_off, $I11
    set_addr $I10, rxcap_1102_fail
    ($I12, $I11) = rx1098_cur."!mark_peek"($I10)
    rx1098_cur."!cursor_pos"($I11)
    ($P10) = rx1098_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1098_pos, "")
    rx1098_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1102_done
  rxcap_1102_fail:
    goto rx1098_fail
  rxcap_1102_done:
  # rx rxquantr1103 ** 0..1
    set_addr $I10, rxquantr1103_done
    rx1098_cur."!mark_push"(0, rx1098_pos, $I10)
  rxquantr1103_loop:
  # rx subrule "args" subtype=capture negate=
    rx1098_cur."!cursor_pos"(rx1098_pos)
    $P10 = rx1098_cur."args"()
    unless $P10, rx1098_fail
    goto rxsubrule1104_pass
  rxsubrule1104_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1098_fail
  rxsubrule1104_pass:
    set_addr $I10, rxsubrule1104_back
    rx1098_cur."!mark_push"(0, rx1098_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1098_pos = $P10."pos"()
    set_addr $I10, rxquantr1103_done
    (rx1098_rep) = rx1098_cur."!mark_commit"($I10)
  rxquantr1103_done:
.annotate 'line', 508
  # rx pass
    rx1098_cur."!cursor_pass"(rx1098_pos, "term:sym<pir::op>")
    if_null rx1098_debug, debug_839
    rx1098_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1098_pos)
  debug_839:
    .return (rx1098_cur)
  rx1098_restart:
.annotate 'line', 4
    if_null rx1098_debug, debug_840
    rx1098_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_840:
  rx1098_fail:
    (rx1098_rep, rx1098_pos, $I10, $P10) = rx1098_cur."!mark_fail"(0)
    lt rx1098_pos, -1, rx1098_done
    eq rx1098_pos, -1, rx1098_fail
    jump $I10
  rx1098_done:
    rx1098_cur."!cursor_fail"()
    if_null rx1098_debug, debug_841
    rx1098_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_841:
    .return (rx1098_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("220_1300060177.262") :method
.annotate 'line', 4
    new $P1100, "ResizablePMCArray"
    push $P1100, "pir::"
    .return ($P1100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("221_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P1114 = "223_1300060177.262" 
    capture_lex $P1114
    .local string rx1106_tgt
    .local int rx1106_pos
    .local int rx1106_off
    .local int rx1106_eos
    .local int rx1106_rep
    .local pmc rx1106_cur
    .local pmc rx1106_debug
    (rx1106_cur, rx1106_pos, rx1106_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1106_cur
    .local pmc match
    .lex "$/", match
    length rx1106_eos, rx1106_tgt
    gt rx1106_pos, rx1106_eos, rx1106_done
    set rx1106_off, 0
    lt rx1106_pos, 2, rx1106_start
    sub rx1106_off, rx1106_pos, 1
    substr rx1106_tgt, rx1106_tgt, rx1106_off
  rx1106_start:
    eq $I10, 1, rx1106_restart
    if_null rx1106_debug, debug_842
    rx1106_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_842:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1109_done
    goto rxscan1109_scan
  rxscan1109_loop:
    (rx1106_pos) = rx1106_cur."from"()
    inc rx1106_pos
    rx1106_cur."!cursor_from"(rx1106_pos)
    ge rx1106_pos, rx1106_eos, rxscan1109_done
  rxscan1109_scan:
    set_addr $I10, rxscan1109_loop
    rx1106_cur."!mark_push"(0, rx1106_pos, $I10)
  rxscan1109_done:
.annotate 'line', 513
  # rx literal  "{*}"
    add $I11, rx1106_pos, 3
    gt $I11, rx1106_eos, rx1106_fail
    sub $I11, rx1106_pos, rx1106_off
    substr $S10, rx1106_tgt, $I11, 3
    ne $S10, "{*}", rx1106_fail
    add rx1106_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."ENDSTMT"()
    unless $P10, rx1106_fail
  alt1110_0:
.annotate 'line', 514
    set_addr $I10, alt1110_1
    rx1106_cur."!mark_push"(0, rx1106_pos, $I10)
    rx1106_cur."!cursor_pos"(rx1106_pos)
    find_lex $P1111, unicode:"$\x{a2}"
    $P1112 = $P1111."MATCH"()
    store_lex "$/", $P1112
    .const 'Sub' $P1114 = "223_1300060177.262" 
    capture_lex $P1114
    $P1118 = $P1114()
    unless $P1118, rx1106_fail
    goto alt1110_end
  alt1110_1:
  # rx subrule "panic" subtype=method negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1106_fail
    rx1106_pos = $P10."pos"()
  alt1110_end:
.annotate 'line', 512
  # rx pass
    rx1106_cur."!cursor_pass"(rx1106_pos, "term:sym<onlystar>")
    if_null rx1106_debug, debug_845
    rx1106_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1106_pos)
  debug_845:
    .return (rx1106_cur)
  rx1106_restart:
.annotate 'line', 4
    if_null rx1106_debug, debug_846
    rx1106_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_846:
  rx1106_fail:
    (rx1106_rep, rx1106_pos, $I10, $P10) = rx1106_cur."!mark_fail"(0)
    lt rx1106_pos, -1, rx1106_done
    eq rx1106_pos, -1, rx1106_fail
    jump $I10
  rx1106_done:
    rx1106_cur."!cursor_fail"()
    if_null rx1106_debug, debug_847
    rx1106_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_847:
    .return (rx1106_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("222_1300060177.262") :method
.annotate 'line', 4
    new $P1108, "ResizablePMCArray"
    push $P1108, "{*}"
    .return ($P1108)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1113"  :anon :subid("223_1300060177.262") :outer("221_1300060177.262")
.annotate 'line', 514
    find_dynamic_lex $P1115, "$*MULTINESS"
    unless_null $P1115, vivify_843
    get_hll_global $P1115, "$MULTINESS"
    unless_null $P1115, vivify_844
    die "Contextual $*MULTINESS not found"
  vivify_844:
  vivify_843:
    set $S1116, $P1115
    iseq $I1117, $S1116, "proto"
    .return ($I1117)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("224_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1120_tgt
    .local int rx1120_pos
    .local int rx1120_off
    .local int rx1120_eos
    .local int rx1120_rep
    .local pmc rx1120_cur
    .local pmc rx1120_debug
    (rx1120_cur, rx1120_pos, rx1120_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1120_cur
    .local pmc match
    .lex "$/", match
    length rx1120_eos, rx1120_tgt
    gt rx1120_pos, rx1120_eos, rx1120_done
    set rx1120_off, 0
    lt rx1120_pos, 2, rx1120_start
    sub rx1120_off, rx1120_pos, 1
    substr rx1120_tgt, rx1120_tgt, rx1120_off
  rx1120_start:
    eq $I10, 1, rx1120_restart
    if_null rx1120_debug, debug_848
    rx1120_cur."!cursor_debug"("START", "args")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1124_done
    goto rxscan1124_scan
  rxscan1124_loop:
    (rx1120_pos) = rx1120_cur."from"()
    inc rx1120_pos
    rx1120_cur."!cursor_from"(rx1120_pos)
    ge rx1120_pos, rx1120_eos, rxscan1124_done
  rxscan1124_scan:
    set_addr $I10, rxscan1124_loop
    rx1120_cur."!mark_push"(0, rx1120_pos, $I10)
  rxscan1124_done:
.annotate 'line', 518
  # rx literal  "("
    add $I11, rx1120_pos, 1
    gt $I11, rx1120_eos, rx1120_fail
    sub $I11, rx1120_pos, rx1120_off
    ord $I11, rx1120_tgt, $I11
    ne $I11, 40, rx1120_fail
    add rx1120_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."arglist"()
    unless $P10, rx1120_fail
    rx1120_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1120_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1120_pos, 1
    gt $I11, rx1120_eos, rx1120_fail
    sub $I11, rx1120_pos, rx1120_off
    ord $I11, rx1120_tgt, $I11
    ne $I11, 41, rx1120_fail
    add rx1120_pos, 1
  # rx pass
    rx1120_cur."!cursor_pass"(rx1120_pos, "args")
    if_null rx1120_debug, debug_849
    rx1120_cur."!cursor_debug"("PASS", "args", " at pos=", rx1120_pos)
  debug_849:
    .return (rx1120_cur)
  rx1120_restart:
.annotate 'line', 4
    if_null rx1120_debug, debug_850
    rx1120_cur."!cursor_debug"("NEXT", "args")
  debug_850:
  rx1120_fail:
    (rx1120_rep, rx1120_pos, $I10, $P10) = rx1120_cur."!mark_fail"(0)
    lt rx1120_pos, -1, rx1120_done
    eq rx1120_pos, -1, rx1120_fail
    jump $I10
  rx1120_done:
    rx1120_cur."!cursor_fail"()
    if_null rx1120_debug, debug_851
    rx1120_cur."!cursor_debug"("FAIL", "args")
  debug_851:
    .return (rx1120_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("225_1300060177.262") :method
.annotate 'line', 4
    $P1122 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1123, "ResizablePMCArray"
    push $P1123, $P1122
    .return ($P1123)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("226_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1126_tgt
    .local int rx1126_pos
    .local int rx1126_off
    .local int rx1126_eos
    .local int rx1126_rep
    .local pmc rx1126_cur
    .local pmc rx1126_debug
    (rx1126_cur, rx1126_pos, rx1126_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1126_cur
    .local pmc match
    .lex "$/", match
    length rx1126_eos, rx1126_tgt
    gt rx1126_pos, rx1126_eos, rx1126_done
    set rx1126_off, 0
    lt rx1126_pos, 2, rx1126_start
    sub rx1126_off, rx1126_pos, 1
    substr rx1126_tgt, rx1126_tgt, rx1126_off
  rx1126_start:
    eq $I10, 1, rx1126_restart
    if_null rx1126_debug, debug_852
    rx1126_cur."!cursor_debug"("START", "arglist")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1130_done
    goto rxscan1130_scan
  rxscan1130_loop:
    (rx1126_pos) = rx1126_cur."from"()
    inc rx1126_pos
    rx1126_cur."!cursor_from"(rx1126_pos)
    ge rx1126_pos, rx1126_eos, rxscan1130_done
  rxscan1130_scan:
    set_addr $I10, rxscan1130_loop
    rx1126_cur."!mark_push"(0, rx1126_pos, $I10)
  rxscan1130_done:
.annotate 'line', 522
  # rx subrule "ws" subtype=method negate=
    rx1126_cur."!cursor_pos"(rx1126_pos)
    $P10 = rx1126_cur."ws"()
    unless $P10, rx1126_fail
    rx1126_pos = $P10."pos"()
  alt1131_0:
.annotate 'line', 523
    set_addr $I10, alt1131_1
    rx1126_cur."!mark_push"(0, rx1126_pos, $I10)
.annotate 'line', 524
  # rx subrule "EXPR" subtype=capture negate=
    rx1126_cur."!cursor_pos"(rx1126_pos)
    $P10 = rx1126_cur."EXPR"("f=")
    unless $P10, rx1126_fail
    rx1126_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1126_pos = $P10."pos"()
    goto alt1131_end
  alt1131_1:
  alt1131_end:
.annotate 'line', 521
  # rx pass
    rx1126_cur."!cursor_pass"(rx1126_pos, "arglist")
    if_null rx1126_debug, debug_853
    rx1126_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1126_pos)
  debug_853:
    .return (rx1126_cur)
  rx1126_restart:
.annotate 'line', 4
    if_null rx1126_debug, debug_854
    rx1126_cur."!cursor_debug"("NEXT", "arglist")
  debug_854:
  rx1126_fail:
    (rx1126_rep, rx1126_pos, $I10, $P10) = rx1126_cur."!mark_fail"(0)
    lt rx1126_pos, -1, rx1126_done
    eq rx1126_pos, -1, rx1126_fail
    jump $I10
  rx1126_done:
    rx1126_cur."!cursor_fail"()
    if_null rx1126_debug, debug_855
    rx1126_cur."!cursor_debug"("FAIL", "arglist")
  debug_855:
    .return (rx1126_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("227_1300060177.262") :method
.annotate 'line', 4
    $P1128 = self."!PREFIX__!subrule"("ws", "")
    new $P1129, "ResizablePMCArray"
    push $P1129, $P1128
    .return ($P1129)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("228_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1133_tgt
    .local int rx1133_pos
    .local int rx1133_off
    .local int rx1133_eos
    .local int rx1133_rep
    .local pmc rx1133_cur
    .local pmc rx1133_debug
    (rx1133_cur, rx1133_pos, rx1133_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1133_cur
    .local pmc match
    .lex "$/", match
    length rx1133_eos, rx1133_tgt
    gt rx1133_pos, rx1133_eos, rx1133_done
    set rx1133_off, 0
    lt rx1133_pos, 2, rx1133_start
    sub rx1133_off, rx1133_pos, 1
    substr rx1133_tgt, rx1133_tgt, rx1133_off
  rx1133_start:
    eq $I10, 1, rx1133_restart
    if_null rx1133_debug, debug_856
    rx1133_cur."!cursor_debug"("START", "term:sym<value>")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1137_done
    goto rxscan1137_scan
  rxscan1137_loop:
    (rx1133_pos) = rx1133_cur."from"()
    inc rx1133_pos
    rx1133_cur."!cursor_from"(rx1133_pos)
    ge rx1133_pos, rx1133_eos, rxscan1137_done
  rxscan1137_scan:
    set_addr $I10, rxscan1137_loop
    rx1133_cur."!mark_push"(0, rx1133_pos, $I10)
  rxscan1137_done:
.annotate 'line', 530
  # rx subrule "value" subtype=capture negate=
    rx1133_cur."!cursor_pos"(rx1133_pos)
    $P10 = rx1133_cur."value"()
    unless $P10, rx1133_fail
    rx1133_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1133_pos = $P10."pos"()
  # rx pass
    rx1133_cur."!cursor_pass"(rx1133_pos, "term:sym<value>")
    if_null rx1133_debug, debug_857
    rx1133_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1133_pos)
  debug_857:
    .return (rx1133_cur)
  rx1133_restart:
.annotate 'line', 4
    if_null rx1133_debug, debug_858
    rx1133_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_858:
  rx1133_fail:
    (rx1133_rep, rx1133_pos, $I10, $P10) = rx1133_cur."!mark_fail"(0)
    lt rx1133_pos, -1, rx1133_done
    eq rx1133_pos, -1, rx1133_fail
    jump $I10
  rx1133_done:
    rx1133_cur."!cursor_fail"()
    if_null rx1133_debug, debug_859
    rx1133_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_859:
    .return (rx1133_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("229_1300060177.262") :method
.annotate 'line', 4
    $P1135 = self."!PREFIX__!subrule"("value", "")
    new $P1136, "ResizablePMCArray"
    push $P1136, $P1135
    .return ($P1136)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("230_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1139_tgt
    .local int rx1139_pos
    .local int rx1139_off
    .local int rx1139_eos
    .local int rx1139_rep
    .local pmc rx1139_cur
    .local pmc rx1139_debug
    (rx1139_cur, rx1139_pos, rx1139_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1139_cur
    .local pmc match
    .lex "$/", match
    length rx1139_eos, rx1139_tgt
    gt rx1139_pos, rx1139_eos, rx1139_done
    set rx1139_off, 0
    lt rx1139_pos, 2, rx1139_start
    sub rx1139_off, rx1139_pos, 1
    substr rx1139_tgt, rx1139_tgt, rx1139_off
  rx1139_start:
    eq $I10, 1, rx1139_restart
    if_null rx1139_debug, debug_860
    rx1139_cur."!cursor_debug"("START", "value")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1144_done
    goto rxscan1144_scan
  rxscan1144_loop:
    (rx1139_pos) = rx1139_cur."from"()
    inc rx1139_pos
    rx1139_cur."!cursor_from"(rx1139_pos)
    ge rx1139_pos, rx1139_eos, rxscan1144_done
  rxscan1144_scan:
    set_addr $I10, rxscan1144_loop
    rx1139_cur."!mark_push"(0, rx1139_pos, $I10)
  rxscan1144_done:
  alt1145_0:
.annotate 'line', 532
    set_addr $I10, alt1145_1
    rx1139_cur."!mark_push"(0, rx1139_pos, $I10)
.annotate 'line', 533
  # rx subrule "quote" subtype=capture negate=
    rx1139_cur."!cursor_pos"(rx1139_pos)
    $P10 = rx1139_cur."quote"()
    unless $P10, rx1139_fail
    rx1139_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1139_pos = $P10."pos"()
    goto alt1145_end
  alt1145_1:
.annotate 'line', 534
  # rx subrule "number" subtype=capture negate=
    rx1139_cur."!cursor_pos"(rx1139_pos)
    $P10 = rx1139_cur."number"()
    unless $P10, rx1139_fail
    rx1139_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1139_pos = $P10."pos"()
  alt1145_end:
.annotate 'line', 532
  # rx pass
    rx1139_cur."!cursor_pass"(rx1139_pos, "value")
    if_null rx1139_debug, debug_861
    rx1139_cur."!cursor_debug"("PASS", "value", " at pos=", rx1139_pos)
  debug_861:
    .return (rx1139_cur)
  rx1139_restart:
.annotate 'line', 4
    if_null rx1139_debug, debug_862
    rx1139_cur."!cursor_debug"("NEXT", "value")
  debug_862:
  rx1139_fail:
    (rx1139_rep, rx1139_pos, $I10, $P10) = rx1139_cur."!mark_fail"(0)
    lt rx1139_pos, -1, rx1139_done
    eq rx1139_pos, -1, rx1139_fail
    jump $I10
  rx1139_done:
    rx1139_cur."!cursor_fail"()
    if_null rx1139_debug, debug_863
    rx1139_cur."!cursor_debug"("FAIL", "value")
  debug_863:
    .return (rx1139_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("231_1300060177.262") :method
.annotate 'line', 4
    $P1141 = self."!PREFIX__!subrule"("number", "")
    $P1142 = self."!PREFIX__!subrule"("quote", "")
    new $P1143, "ResizablePMCArray"
    push $P1143, $P1141
    push $P1143, $P1142
    .return ($P1143)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("232_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1147_tgt
    .local int rx1147_pos
    .local int rx1147_off
    .local int rx1147_eos
    .local int rx1147_rep
    .local pmc rx1147_cur
    .local pmc rx1147_debug
    (rx1147_cur, rx1147_pos, rx1147_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1147_cur
    .local pmc match
    .lex "$/", match
    length rx1147_eos, rx1147_tgt
    gt rx1147_pos, rx1147_eos, rx1147_done
    set rx1147_off, 0
    lt rx1147_pos, 2, rx1147_start
    sub rx1147_off, rx1147_pos, 1
    substr rx1147_tgt, rx1147_tgt, rx1147_off
  rx1147_start:
    eq $I10, 1, rx1147_restart
    if_null rx1147_debug, debug_864
    rx1147_cur."!cursor_debug"("START", "number")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1150_done
    goto rxscan1150_scan
  rxscan1150_loop:
    (rx1147_pos) = rx1147_cur."from"()
    inc rx1147_pos
    rx1147_cur."!cursor_from"(rx1147_pos)
    ge rx1147_pos, rx1147_eos, rxscan1150_done
  rxscan1150_scan:
    set_addr $I10, rxscan1150_loop
    rx1147_cur."!mark_push"(0, rx1147_pos, $I10)
  rxscan1150_done:
.annotate 'line', 538
  # rx subcapture "sign"
    set_addr $I10, rxcap_1152_fail
    rx1147_cur."!mark_push"(0, rx1147_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1147_pos, rx1147_off
    set rx1147_rep, 0
    sub $I12, rx1147_eos, rx1147_pos
    le $I12, 1, rxenumcharlistq1151_loop
    set $I12, 1
  rxenumcharlistq1151_loop:
    le $I12, 0, rxenumcharlistq1151_done
    substr $S10, rx1147_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1151_done
    inc rx1147_rep
  rxenumcharlistq1151_done:
    add rx1147_pos, rx1147_pos, rx1147_rep
    set_addr $I10, rxcap_1152_fail
    ($I12, $I11) = rx1147_cur."!mark_peek"($I10)
    rx1147_cur."!cursor_pos"($I11)
    ($P10) = rx1147_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1147_pos, "")
    rx1147_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1152_done
  rxcap_1152_fail:
    goto rx1147_fail
  rxcap_1152_done:
  alt1153_0:
.annotate 'line', 539
    set_addr $I10, alt1153_1
    rx1147_cur."!mark_push"(0, rx1147_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1147_cur."!cursor_pos"(rx1147_pos)
    $P10 = rx1147_cur."dec_number"()
    unless $P10, rx1147_fail
    rx1147_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1147_pos = $P10."pos"()
    goto alt1153_end
  alt1153_1:
  # rx subrule "integer" subtype=capture negate=
    rx1147_cur."!cursor_pos"(rx1147_pos)
    $P10 = rx1147_cur."integer"()
    unless $P10, rx1147_fail
    rx1147_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1147_pos = $P10."pos"()
  alt1153_end:
.annotate 'line', 537
  # rx pass
    rx1147_cur."!cursor_pass"(rx1147_pos, "number")
    if_null rx1147_debug, debug_865
    rx1147_cur."!cursor_debug"("PASS", "number", " at pos=", rx1147_pos)
  debug_865:
    .return (rx1147_cur)
  rx1147_restart:
.annotate 'line', 4
    if_null rx1147_debug, debug_866
    rx1147_cur."!cursor_debug"("NEXT", "number")
  debug_866:
  rx1147_fail:
    (rx1147_rep, rx1147_pos, $I10, $P10) = rx1147_cur."!mark_fail"(0)
    lt rx1147_pos, -1, rx1147_done
    eq rx1147_pos, -1, rx1147_fail
    jump $I10
  rx1147_done:
    rx1147_cur."!cursor_fail"()
    if_null rx1147_debug, debug_867
    rx1147_cur."!cursor_debug"("FAIL", "number")
  debug_867:
    .return (rx1147_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("233_1300060177.262") :method
.annotate 'line', 4
    new $P1149, "ResizablePMCArray"
    push $P1149, ""
    .return ($P1149)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("234_1300060177.262")
    .param pmc param_1155
.annotate 'line', 542
    .lex "self", param_1155
    $P1156 = param_1155."!protoregex"("quote")
    .return ($P1156)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("235_1300060177.262")
    .param pmc param_1158
.annotate 'line', 542
    .lex "self", param_1158
    $P1159 = param_1158."!PREFIX__!protoregex"("quote")
    .return ($P1159)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("236_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1161_tgt
    .local int rx1161_pos
    .local int rx1161_off
    .local int rx1161_eos
    .local int rx1161_rep
    .local pmc rx1161_cur
    .local pmc rx1161_debug
    (rx1161_cur, rx1161_pos, rx1161_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1161_cur
    .local pmc match
    .lex "$/", match
    length rx1161_eos, rx1161_tgt
    gt rx1161_pos, rx1161_eos, rx1161_done
    set rx1161_off, 0
    lt rx1161_pos, 2, rx1161_start
    sub rx1161_off, rx1161_pos, 1
    substr rx1161_tgt, rx1161_tgt, rx1161_off
  rx1161_start:
    eq $I10, 1, rx1161_restart
    if_null rx1161_debug, debug_868
    rx1161_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1164_done
    goto rxscan1164_scan
  rxscan1164_loop:
    (rx1161_pos) = rx1161_cur."from"()
    inc rx1161_pos
    rx1161_cur."!cursor_from"(rx1161_pos)
    ge rx1161_pos, rx1161_eos, rxscan1164_done
  rxscan1164_scan:
    set_addr $I10, rxscan1164_loop
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10)
  rxscan1164_done:
.annotate 'line', 543
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1161_pos, rx1161_off
    substr $S10, rx1161_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1161_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1161_cur."!cursor_pos"(rx1161_pos)
    $P10 = rx1161_cur."quote_EXPR"(":q")
    unless $P10, rx1161_fail
    rx1161_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1161_pos = $P10."pos"()
  # rx pass
    rx1161_cur."!cursor_pass"(rx1161_pos, "quote:sym<apos>")
    if_null rx1161_debug, debug_869
    rx1161_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1161_pos)
  debug_869:
    .return (rx1161_cur)
  rx1161_restart:
.annotate 'line', 4
    if_null rx1161_debug, debug_870
    rx1161_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_870:
  rx1161_fail:
    (rx1161_rep, rx1161_pos, $I10, $P10) = rx1161_cur."!mark_fail"(0)
    lt rx1161_pos, -1, rx1161_done
    eq rx1161_pos, -1, rx1161_fail
    jump $I10
  rx1161_done:
    rx1161_cur."!cursor_fail"()
    if_null rx1161_debug, debug_871
    rx1161_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_871:
    .return (rx1161_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("237_1300060177.262") :method
.annotate 'line', 4
    new $P1163, "ResizablePMCArray"
    push $P1163, "'"
    .return ($P1163)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("238_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1166_tgt
    .local int rx1166_pos
    .local int rx1166_off
    .local int rx1166_eos
    .local int rx1166_rep
    .local pmc rx1166_cur
    .local pmc rx1166_debug
    (rx1166_cur, rx1166_pos, rx1166_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1166_cur
    .local pmc match
    .lex "$/", match
    length rx1166_eos, rx1166_tgt
    gt rx1166_pos, rx1166_eos, rx1166_done
    set rx1166_off, 0
    lt rx1166_pos, 2, rx1166_start
    sub rx1166_off, rx1166_pos, 1
    substr rx1166_tgt, rx1166_tgt, rx1166_off
  rx1166_start:
    eq $I10, 1, rx1166_restart
    if_null rx1166_debug, debug_872
    rx1166_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1169_done
    goto rxscan1169_scan
  rxscan1169_loop:
    (rx1166_pos) = rx1166_cur."from"()
    inc rx1166_pos
    rx1166_cur."!cursor_from"(rx1166_pos)
    ge rx1166_pos, rx1166_eos, rxscan1169_done
  rxscan1169_scan:
    set_addr $I10, rxscan1169_loop
    rx1166_cur."!mark_push"(0, rx1166_pos, $I10)
  rxscan1169_done:
.annotate 'line', 544
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1166_pos, rx1166_off
    substr $S10, rx1166_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1166_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1166_cur."!cursor_pos"(rx1166_pos)
    $P10 = rx1166_cur."quote_EXPR"(":qq")
    unless $P10, rx1166_fail
    rx1166_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1166_pos = $P10."pos"()
  # rx pass
    rx1166_cur."!cursor_pass"(rx1166_pos, "quote:sym<dblq>")
    if_null rx1166_debug, debug_873
    rx1166_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1166_pos)
  debug_873:
    .return (rx1166_cur)
  rx1166_restart:
.annotate 'line', 4
    if_null rx1166_debug, debug_874
    rx1166_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_874:
  rx1166_fail:
    (rx1166_rep, rx1166_pos, $I10, $P10) = rx1166_cur."!mark_fail"(0)
    lt rx1166_pos, -1, rx1166_done
    eq rx1166_pos, -1, rx1166_fail
    jump $I10
  rx1166_done:
    rx1166_cur."!cursor_fail"()
    if_null rx1166_debug, debug_875
    rx1166_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_875:
    .return (rx1166_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("239_1300060177.262") :method
.annotate 'line', 4
    new $P1168, "ResizablePMCArray"
    push $P1168, "\""
    .return ($P1168)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("240_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1171_tgt
    .local int rx1171_pos
    .local int rx1171_off
    .local int rx1171_eos
    .local int rx1171_rep
    .local pmc rx1171_cur
    .local pmc rx1171_debug
    (rx1171_cur, rx1171_pos, rx1171_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1171_cur
    .local pmc match
    .lex "$/", match
    length rx1171_eos, rx1171_tgt
    gt rx1171_pos, rx1171_eos, rx1171_done
    set rx1171_off, 0
    lt rx1171_pos, 2, rx1171_start
    sub rx1171_off, rx1171_pos, 1
    substr rx1171_tgt, rx1171_tgt, rx1171_off
  rx1171_start:
    eq $I10, 1, rx1171_restart
    if_null rx1171_debug, debug_876
    rx1171_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1175_done
    goto rxscan1175_scan
  rxscan1175_loop:
    (rx1171_pos) = rx1171_cur."from"()
    inc rx1171_pos
    rx1171_cur."!cursor_from"(rx1171_pos)
    ge rx1171_pos, rx1171_eos, rxscan1175_done
  rxscan1175_scan:
    set_addr $I10, rxscan1175_loop
    rx1171_cur."!mark_push"(0, rx1171_pos, $I10)
  rxscan1175_done:
.annotate 'line', 545
  # rx literal  "q"
    add $I11, rx1171_pos, 1
    gt $I11, rx1171_eos, rx1171_fail
    sub $I11, rx1171_pos, rx1171_off
    ord $I11, rx1171_tgt, $I11
    ne $I11, 113, rx1171_fail
    add rx1171_pos, 1
  # rxanchor rwb
    le rx1171_pos, 0, rx1171_fail
    sub $I10, rx1171_pos, rx1171_off
    is_cclass $I11, 8192, rx1171_tgt, $I10
    if $I11, rx1171_fail
    dec $I10
    is_cclass $I11, 8192, rx1171_tgt, $I10
    unless $I11, rx1171_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1171_pos, rx1171_off
    substr $S10, rx1171_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1171_fail
  # rx subrule "ws" subtype=method negate=
    rx1171_cur."!cursor_pos"(rx1171_pos)
    $P10 = rx1171_cur."ws"()
    unless $P10, rx1171_fail
    rx1171_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1171_cur."!cursor_pos"(rx1171_pos)
    $P10 = rx1171_cur."quote_EXPR"(":q")
    unless $P10, rx1171_fail
    rx1171_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1171_pos = $P10."pos"()
  # rx pass
    rx1171_cur."!cursor_pass"(rx1171_pos, "quote:sym<q>")
    if_null rx1171_debug, debug_877
    rx1171_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1171_pos)
  debug_877:
    .return (rx1171_cur)
  rx1171_restart:
.annotate 'line', 4
    if_null rx1171_debug, debug_878
    rx1171_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_878:
  rx1171_fail:
    (rx1171_rep, rx1171_pos, $I10, $P10) = rx1171_cur."!mark_fail"(0)
    lt rx1171_pos, -1, rx1171_done
    eq rx1171_pos, -1, rx1171_fail
    jump $I10
  rx1171_done:
    rx1171_cur."!cursor_fail"()
    if_null rx1171_debug, debug_879
    rx1171_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_879:
    .return (rx1171_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("241_1300060177.262") :method
.annotate 'line', 4
    $P1173 = self."!PREFIX__!subrule"("ws", "q")
    new $P1174, "ResizablePMCArray"
    push $P1174, $P1173
    .return ($P1174)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("242_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1177_tgt
    .local int rx1177_pos
    .local int rx1177_off
    .local int rx1177_eos
    .local int rx1177_rep
    .local pmc rx1177_cur
    .local pmc rx1177_debug
    (rx1177_cur, rx1177_pos, rx1177_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1177_cur
    .local pmc match
    .lex "$/", match
    length rx1177_eos, rx1177_tgt
    gt rx1177_pos, rx1177_eos, rx1177_done
    set rx1177_off, 0
    lt rx1177_pos, 2, rx1177_start
    sub rx1177_off, rx1177_pos, 1
    substr rx1177_tgt, rx1177_tgt, rx1177_off
  rx1177_start:
    eq $I10, 1, rx1177_restart
    if_null rx1177_debug, debug_880
    rx1177_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_880:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1181_done
    goto rxscan1181_scan
  rxscan1181_loop:
    (rx1177_pos) = rx1177_cur."from"()
    inc rx1177_pos
    rx1177_cur."!cursor_from"(rx1177_pos)
    ge rx1177_pos, rx1177_eos, rxscan1181_done
  rxscan1181_scan:
    set_addr $I10, rxscan1181_loop
    rx1177_cur."!mark_push"(0, rx1177_pos, $I10)
  rxscan1181_done:
.annotate 'line', 546
  # rx literal  "qq"
    add $I11, rx1177_pos, 2
    gt $I11, rx1177_eos, rx1177_fail
    sub $I11, rx1177_pos, rx1177_off
    substr $S10, rx1177_tgt, $I11, 2
    ne $S10, "qq", rx1177_fail
    add rx1177_pos, 2
  # rxanchor rwb
    le rx1177_pos, 0, rx1177_fail
    sub $I10, rx1177_pos, rx1177_off
    is_cclass $I11, 8192, rx1177_tgt, $I10
    if $I11, rx1177_fail
    dec $I10
    is_cclass $I11, 8192, rx1177_tgt, $I10
    unless $I11, rx1177_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1177_pos, rx1177_off
    substr $S10, rx1177_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1177_fail
  # rx subrule "ws" subtype=method negate=
    rx1177_cur."!cursor_pos"(rx1177_pos)
    $P10 = rx1177_cur."ws"()
    unless $P10, rx1177_fail
    rx1177_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1177_cur."!cursor_pos"(rx1177_pos)
    $P10 = rx1177_cur."quote_EXPR"(":qq")
    unless $P10, rx1177_fail
    rx1177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1177_pos = $P10."pos"()
  # rx pass
    rx1177_cur."!cursor_pass"(rx1177_pos, "quote:sym<qq>")
    if_null rx1177_debug, debug_881
    rx1177_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1177_pos)
  debug_881:
    .return (rx1177_cur)
  rx1177_restart:
.annotate 'line', 4
    if_null rx1177_debug, debug_882
    rx1177_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_882:
  rx1177_fail:
    (rx1177_rep, rx1177_pos, $I10, $P10) = rx1177_cur."!mark_fail"(0)
    lt rx1177_pos, -1, rx1177_done
    eq rx1177_pos, -1, rx1177_fail
    jump $I10
  rx1177_done:
    rx1177_cur."!cursor_fail"()
    if_null rx1177_debug, debug_883
    rx1177_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_883:
    .return (rx1177_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("243_1300060177.262") :method
.annotate 'line', 4
    $P1179 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1180, "ResizablePMCArray"
    push $P1180, $P1179
    .return ($P1180)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("244_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1183_tgt
    .local int rx1183_pos
    .local int rx1183_off
    .local int rx1183_eos
    .local int rx1183_rep
    .local pmc rx1183_cur
    .local pmc rx1183_debug
    (rx1183_cur, rx1183_pos, rx1183_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1183_cur
    .local pmc match
    .lex "$/", match
    length rx1183_eos, rx1183_tgt
    gt rx1183_pos, rx1183_eos, rx1183_done
    set rx1183_off, 0
    lt rx1183_pos, 2, rx1183_start
    sub rx1183_off, rx1183_pos, 1
    substr rx1183_tgt, rx1183_tgt, rx1183_off
  rx1183_start:
    eq $I10, 1, rx1183_restart
    if_null rx1183_debug, debug_884
    rx1183_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1187_done
    goto rxscan1187_scan
  rxscan1187_loop:
    (rx1183_pos) = rx1183_cur."from"()
    inc rx1183_pos
    rx1183_cur."!cursor_from"(rx1183_pos)
    ge rx1183_pos, rx1183_eos, rxscan1187_done
  rxscan1187_scan:
    set_addr $I10, rxscan1187_loop
    rx1183_cur."!mark_push"(0, rx1183_pos, $I10)
  rxscan1187_done:
.annotate 'line', 547
  # rx literal  "Q"
    add $I11, rx1183_pos, 1
    gt $I11, rx1183_eos, rx1183_fail
    sub $I11, rx1183_pos, rx1183_off
    ord $I11, rx1183_tgt, $I11
    ne $I11, 81, rx1183_fail
    add rx1183_pos, 1
  # rxanchor rwb
    le rx1183_pos, 0, rx1183_fail
    sub $I10, rx1183_pos, rx1183_off
    is_cclass $I11, 8192, rx1183_tgt, $I10
    if $I11, rx1183_fail
    dec $I10
    is_cclass $I11, 8192, rx1183_tgt, $I10
    unless $I11, rx1183_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1183_pos, rx1183_off
    substr $S10, rx1183_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1183_fail
  # rx subrule "ws" subtype=method negate=
    rx1183_cur."!cursor_pos"(rx1183_pos)
    $P10 = rx1183_cur."ws"()
    unless $P10, rx1183_fail
    rx1183_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1183_cur."!cursor_pos"(rx1183_pos)
    $P10 = rx1183_cur."quote_EXPR"()
    unless $P10, rx1183_fail
    rx1183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1183_pos = $P10."pos"()
  # rx pass
    rx1183_cur."!cursor_pass"(rx1183_pos, "quote:sym<Q>")
    if_null rx1183_debug, debug_885
    rx1183_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1183_pos)
  debug_885:
    .return (rx1183_cur)
  rx1183_restart:
.annotate 'line', 4
    if_null rx1183_debug, debug_886
    rx1183_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_886:
  rx1183_fail:
    (rx1183_rep, rx1183_pos, $I10, $P10) = rx1183_cur."!mark_fail"(0)
    lt rx1183_pos, -1, rx1183_done
    eq rx1183_pos, -1, rx1183_fail
    jump $I10
  rx1183_done:
    rx1183_cur."!cursor_fail"()
    if_null rx1183_debug, debug_887
    rx1183_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_887:
    .return (rx1183_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("245_1300060177.262") :method
.annotate 'line', 4
    $P1185 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1186, "ResizablePMCArray"
    push $P1186, $P1185
    .return ($P1186)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("246_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1189_tgt
    .local int rx1189_pos
    .local int rx1189_off
    .local int rx1189_eos
    .local int rx1189_rep
    .local pmc rx1189_cur
    .local pmc rx1189_debug
    (rx1189_cur, rx1189_pos, rx1189_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1189_cur
    .local pmc match
    .lex "$/", match
    length rx1189_eos, rx1189_tgt
    gt rx1189_pos, rx1189_eos, rx1189_done
    set rx1189_off, 0
    lt rx1189_pos, 2, rx1189_start
    sub rx1189_off, rx1189_pos, 1
    substr rx1189_tgt, rx1189_tgt, rx1189_off
  rx1189_start:
    eq $I10, 1, rx1189_restart
    if_null rx1189_debug, debug_888
    rx1189_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_888:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1193_done
    goto rxscan1193_scan
  rxscan1193_loop:
    (rx1189_pos) = rx1189_cur."from"()
    inc rx1189_pos
    rx1189_cur."!cursor_from"(rx1189_pos)
    ge rx1189_pos, rx1189_eos, rxscan1193_done
  rxscan1193_scan:
    set_addr $I10, rxscan1193_loop
    rx1189_cur."!mark_push"(0, rx1189_pos, $I10)
  rxscan1193_done:
.annotate 'line', 548
  # rx literal  "Q:PIR"
    add $I11, rx1189_pos, 5
    gt $I11, rx1189_eos, rx1189_fail
    sub $I11, rx1189_pos, rx1189_off
    substr $S10, rx1189_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1189_fail
    add rx1189_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1189_cur."!cursor_pos"(rx1189_pos)
    $P10 = rx1189_cur."ws"()
    unless $P10, rx1189_fail
    rx1189_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1189_cur."!cursor_pos"(rx1189_pos)
    $P10 = rx1189_cur."quote_EXPR"()
    unless $P10, rx1189_fail
    rx1189_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1189_pos = $P10."pos"()
  # rx pass
    rx1189_cur."!cursor_pass"(rx1189_pos, "quote:sym<Q:PIR>")
    if_null rx1189_debug, debug_889
    rx1189_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1189_pos)
  debug_889:
    .return (rx1189_cur)
  rx1189_restart:
.annotate 'line', 4
    if_null rx1189_debug, debug_890
    rx1189_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_890:
  rx1189_fail:
    (rx1189_rep, rx1189_pos, $I10, $P10) = rx1189_cur."!mark_fail"(0)
    lt rx1189_pos, -1, rx1189_done
    eq rx1189_pos, -1, rx1189_fail
    jump $I10
  rx1189_done:
    rx1189_cur."!cursor_fail"()
    if_null rx1189_debug, debug_891
    rx1189_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_891:
    .return (rx1189_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("247_1300060177.262") :method
.annotate 'line', 4
    $P1191 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1192, "ResizablePMCArray"
    push $P1192, $P1191
    .return ($P1192)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("248_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1195_tgt
    .local int rx1195_pos
    .local int rx1195_off
    .local int rx1195_eos
    .local int rx1195_rep
    .local pmc rx1195_cur
    .local pmc rx1195_debug
    (rx1195_cur, rx1195_pos, rx1195_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1195_cur
    .local pmc match
    .lex "$/", match
    length rx1195_eos, rx1195_tgt
    gt rx1195_pos, rx1195_eos, rx1195_done
    set rx1195_off, 0
    lt rx1195_pos, 2, rx1195_start
    sub rx1195_off, rx1195_pos, 1
    substr rx1195_tgt, rx1195_tgt, rx1195_off
  rx1195_start:
    eq $I10, 1, rx1195_restart
    if_null rx1195_debug, debug_892
    rx1195_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_892:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1199_done
    goto rxscan1199_scan
  rxscan1199_loop:
    (rx1195_pos) = rx1195_cur."from"()
    inc rx1195_pos
    rx1195_cur."!cursor_from"(rx1195_pos)
    ge rx1195_pos, rx1195_eos, rxscan1199_done
  rxscan1199_scan:
    set_addr $I10, rxscan1199_loop
    rx1195_cur."!mark_push"(0, rx1195_pos, $I10)
  rxscan1199_done:
.annotate 'line', 550
  # rx literal  "/"
    add $I11, rx1195_pos, 1
    gt $I11, rx1195_eos, rx1195_fail
    sub $I11, rx1195_pos, rx1195_off
    ord $I11, rx1195_tgt, $I11
    ne $I11, 47, rx1195_fail
    add rx1195_pos, 1
.annotate 'line', 551
  # rx subrule "newpad" subtype=method negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."newpad"()
    unless $P10, rx1195_fail
    rx1195_pos = $P10."pos"()
.annotate 'line', 552
  # rx reduce name="quote:sym</ />" key="open"
    rx1195_cur."!cursor_pos"(rx1195_pos)
    rx1195_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 553
  # rx subrule "LANG" subtype=capture negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1195_fail
    rx1195_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1195_pos = $P10."pos"()
.annotate 'line', 554
  # rx literal  "/"
    add $I11, rx1195_pos, 1
    gt $I11, rx1195_eos, rx1195_fail
    sub $I11, rx1195_pos, rx1195_off
    ord $I11, rx1195_tgt, $I11
    ne $I11, 47, rx1195_fail
    add rx1195_pos, 1
.annotate 'line', 549
  # rx pass
    rx1195_cur."!cursor_pass"(rx1195_pos, "quote:sym</ />")
    if_null rx1195_debug, debug_893
    rx1195_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1195_pos)
  debug_893:
    .return (rx1195_cur)
  rx1195_restart:
.annotate 'line', 4
    if_null rx1195_debug, debug_894
    rx1195_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_894:
  rx1195_fail:
    (rx1195_rep, rx1195_pos, $I10, $P10) = rx1195_cur."!mark_fail"(0)
    lt rx1195_pos, -1, rx1195_done
    eq rx1195_pos, -1, rx1195_fail
    jump $I10
  rx1195_done:
    rx1195_cur."!cursor_fail"()
    if_null rx1195_debug, debug_895
    rx1195_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_895:
    .return (rx1195_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("249_1300060177.262") :method
.annotate 'line', 4
    $P1197 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1198, "ResizablePMCArray"
    push $P1198, $P1197
    .return ($P1198)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("250_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1201_tgt
    .local int rx1201_pos
    .local int rx1201_off
    .local int rx1201_eos
    .local int rx1201_rep
    .local pmc rx1201_cur
    .local pmc rx1201_debug
    (rx1201_cur, rx1201_pos, rx1201_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1201_cur
    .local pmc match
    .lex "$/", match
    length rx1201_eos, rx1201_tgt
    gt rx1201_pos, rx1201_eos, rx1201_done
    set rx1201_off, 0
    lt rx1201_pos, 2, rx1201_start
    sub rx1201_off, rx1201_pos, 1
    substr rx1201_tgt, rx1201_tgt, rx1201_off
  rx1201_start:
    eq $I10, 1, rx1201_restart
    if_null rx1201_debug, debug_896
    rx1201_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1204_done
    goto rxscan1204_scan
  rxscan1204_loop:
    (rx1201_pos) = rx1201_cur."from"()
    inc rx1201_pos
    rx1201_cur."!cursor_from"(rx1201_pos)
    ge rx1201_pos, rx1201_eos, rxscan1204_done
  rxscan1204_scan:
    set_addr $I10, rxscan1204_loop
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
  rxscan1204_done:
.annotate 'line', 557
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1201_pos, rx1201_off
    substr $S10, rx1201_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1201_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."quotemod_check"("s")
    unless $P10, rx1201_fail
  # rx subrule "variable" subtype=capture negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."variable"()
    unless $P10, rx1201_fail
    rx1201_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1201_pos = $P10."pos"()
  # rx pass
    rx1201_cur."!cursor_pass"(rx1201_pos, "quote_escape:sym<$>")
    if_null rx1201_debug, debug_897
    rx1201_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1201_pos)
  debug_897:
    .return (rx1201_cur)
  rx1201_restart:
.annotate 'line', 4
    if_null rx1201_debug, debug_898
    rx1201_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_898:
  rx1201_fail:
    (rx1201_rep, rx1201_pos, $I10, $P10) = rx1201_cur."!mark_fail"(0)
    lt rx1201_pos, -1, rx1201_done
    eq rx1201_pos, -1, rx1201_fail
    jump $I10
  rx1201_done:
    rx1201_cur."!cursor_fail"()
    if_null rx1201_debug, debug_899
    rx1201_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_899:
    .return (rx1201_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("251_1300060177.262") :method
.annotate 'line', 4
    new $P1203, "ResizablePMCArray"
    push $P1203, "$"
    .return ($P1203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("252_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1206_tgt
    .local int rx1206_pos
    .local int rx1206_off
    .local int rx1206_eos
    .local int rx1206_rep
    .local pmc rx1206_cur
    .local pmc rx1206_debug
    (rx1206_cur, rx1206_pos, rx1206_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1206_cur
    .local pmc match
    .lex "$/", match
    length rx1206_eos, rx1206_tgt
    gt rx1206_pos, rx1206_eos, rx1206_done
    set rx1206_off, 0
    lt rx1206_pos, 2, rx1206_start
    sub rx1206_off, rx1206_pos, 1
    substr rx1206_tgt, rx1206_tgt, rx1206_off
  rx1206_start:
    eq $I10, 1, rx1206_restart
    if_null rx1206_debug, debug_900
    rx1206_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_900:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1209_done
    goto rxscan1209_scan
  rxscan1209_loop:
    (rx1206_pos) = rx1206_cur."from"()
    inc rx1206_pos
    rx1206_cur."!cursor_from"(rx1206_pos)
    ge rx1206_pos, rx1206_eos, rxscan1209_done
  rxscan1209_scan:
    set_addr $I10, rxscan1209_loop
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
  rxscan1209_done:
.annotate 'line', 558
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1206_pos, rx1206_off
    substr $S10, rx1206_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1206_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1206_cur."!cursor_pos"(rx1206_pos)
    $P10 = rx1206_cur."quotemod_check"("c")
    unless $P10, rx1206_fail
  # rx subrule "block" subtype=capture negate=
    rx1206_cur."!cursor_pos"(rx1206_pos)
    $P10 = rx1206_cur."block"()
    unless $P10, rx1206_fail
    rx1206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1206_pos = $P10."pos"()
  # rx pass
    rx1206_cur."!cursor_pass"(rx1206_pos, "quote_escape:sym<{ }>")
    if_null rx1206_debug, debug_901
    rx1206_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1206_pos)
  debug_901:
    .return (rx1206_cur)
  rx1206_restart:
.annotate 'line', 4
    if_null rx1206_debug, debug_902
    rx1206_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_902:
  rx1206_fail:
    (rx1206_rep, rx1206_pos, $I10, $P10) = rx1206_cur."!mark_fail"(0)
    lt rx1206_pos, -1, rx1206_done
    eq rx1206_pos, -1, rx1206_fail
    jump $I10
  rx1206_done:
    rx1206_cur."!cursor_fail"()
    if_null rx1206_debug, debug_903
    rx1206_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_903:
    .return (rx1206_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("253_1300060177.262") :method
.annotate 'line', 4
    new $P1208, "ResizablePMCArray"
    push $P1208, "{"
    .return ($P1208)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("254_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1211_tgt
    .local int rx1211_pos
    .local int rx1211_off
    .local int rx1211_eos
    .local int rx1211_rep
    .local pmc rx1211_cur
    .local pmc rx1211_debug
    (rx1211_cur, rx1211_pos, rx1211_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1211_cur
    .local pmc match
    .lex "$/", match
    length rx1211_eos, rx1211_tgt
    gt rx1211_pos, rx1211_eos, rx1211_done
    set rx1211_off, 0
    lt rx1211_pos, 2, rx1211_start
    sub rx1211_off, rx1211_pos, 1
    substr rx1211_tgt, rx1211_tgt, rx1211_off
  rx1211_start:
    eq $I10, 1, rx1211_restart
    if_null rx1211_debug, debug_904
    rx1211_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_904:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1214_done
    goto rxscan1214_scan
  rxscan1214_loop:
    (rx1211_pos) = rx1211_cur."from"()
    inc rx1211_pos
    rx1211_cur."!cursor_from"(rx1211_pos)
    ge rx1211_pos, rx1211_eos, rxscan1214_done
  rxscan1214_scan:
    set_addr $I10, rxscan1214_loop
    rx1211_cur."!mark_push"(0, rx1211_pos, $I10)
  rxscan1214_done:
.annotate 'line', 559
  # rx literal  "\\e"
    add $I11, rx1211_pos, 2
    gt $I11, rx1211_eos, rx1211_fail
    sub $I11, rx1211_pos, rx1211_off
    substr $S10, rx1211_tgt, $I11, 2
    ne $S10, "\\e", rx1211_fail
    add rx1211_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1211_cur."!cursor_pos"(rx1211_pos)
    $P10 = rx1211_cur."quotemod_check"("b")
    unless $P10, rx1211_fail
  # rx pass
    rx1211_cur."!cursor_pass"(rx1211_pos, "quote_escape:sym<esc>")
    if_null rx1211_debug, debug_905
    rx1211_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1211_pos)
  debug_905:
    .return (rx1211_cur)
  rx1211_restart:
.annotate 'line', 4
    if_null rx1211_debug, debug_906
    rx1211_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_906:
  rx1211_fail:
    (rx1211_rep, rx1211_pos, $I10, $P10) = rx1211_cur."!mark_fail"(0)
    lt rx1211_pos, -1, rx1211_done
    eq rx1211_pos, -1, rx1211_fail
    jump $I10
  rx1211_done:
    rx1211_cur."!cursor_fail"()
    if_null rx1211_debug, debug_907
    rx1211_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_907:
    .return (rx1211_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("255_1300060177.262") :method
.annotate 'line', 4
    new $P1213, "ResizablePMCArray"
    push $P1213, "\\e"
    .return ($P1213)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("256_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1216_tgt
    .local int rx1216_pos
    .local int rx1216_off
    .local int rx1216_eos
    .local int rx1216_rep
    .local pmc rx1216_cur
    .local pmc rx1216_debug
    (rx1216_cur, rx1216_pos, rx1216_tgt, $I10) = self."!cursor_start"()
    rx1216_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1216_cur
    .local pmc match
    .lex "$/", match
    length rx1216_eos, rx1216_tgt
    gt rx1216_pos, rx1216_eos, rx1216_done
    set rx1216_off, 0
    lt rx1216_pos, 2, rx1216_start
    sub rx1216_off, rx1216_pos, 1
    substr rx1216_tgt, rx1216_tgt, rx1216_off
  rx1216_start:
    eq $I10, 1, rx1216_restart
    if_null rx1216_debug, debug_908
    rx1216_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_908:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1220_done
    goto rxscan1220_scan
  rxscan1220_loop:
    (rx1216_pos) = rx1216_cur."from"()
    inc rx1216_pos
    rx1216_cur."!cursor_from"(rx1216_pos)
    ge rx1216_pos, rx1216_eos, rxscan1220_done
  rxscan1220_scan:
    set_addr $I10, rxscan1220_loop
    rx1216_cur."!mark_push"(0, rx1216_pos, $I10)
  rxscan1220_done:
.annotate 'line', 561
  # rx literal  "("
    add $I11, rx1216_pos, 1
    gt $I11, rx1216_eos, rx1216_fail
    sub $I11, rx1216_pos, rx1216_off
    ord $I11, rx1216_tgt, $I11
    ne $I11, 40, rx1216_fail
    add rx1216_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1216_cur."!cursor_pos"(rx1216_pos)
    $P10 = rx1216_cur."ws"()
    unless $P10, rx1216_fail
    rx1216_pos = $P10."pos"()
  # rx rxquantr1221 ** 0..1
    set_addr $I10, rxquantr1221_done
    rx1216_cur."!mark_push"(0, rx1216_pos, $I10)
  rxquantr1221_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1216_cur."!cursor_pos"(rx1216_pos)
    $P10 = rx1216_cur."EXPR"()
    unless $P10, rx1216_fail
    goto rxsubrule1222_pass
  rxsubrule1222_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1216_fail
  rxsubrule1222_pass:
    set_addr $I10, rxsubrule1222_back
    rx1216_cur."!mark_push"(0, rx1216_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1216_pos = $P10."pos"()
    set_addr $I10, rxquantr1221_done
    (rx1216_rep) = rx1216_cur."!mark_commit"($I10)
  rxquantr1221_done:
  # rx literal  ")"
    add $I11, rx1216_pos, 1
    gt $I11, rx1216_eos, rx1216_fail
    sub $I11, rx1216_pos, rx1216_off
    ord $I11, rx1216_tgt, $I11
    ne $I11, 41, rx1216_fail
    add rx1216_pos, 1
  # rx pass
    rx1216_cur."!cursor_pass"(rx1216_pos, "circumfix:sym<( )>")
    if_null rx1216_debug, debug_909
    rx1216_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1216_pos)
  debug_909:
    .return (rx1216_cur)
  rx1216_restart:
.annotate 'line', 4
    if_null rx1216_debug, debug_910
    rx1216_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_910:
  rx1216_fail:
    (rx1216_rep, rx1216_pos, $I10, $P10) = rx1216_cur."!mark_fail"(0)
    lt rx1216_pos, -1, rx1216_done
    eq rx1216_pos, -1, rx1216_fail
    jump $I10
  rx1216_done:
    rx1216_cur."!cursor_fail"()
    if_null rx1216_debug, debug_911
    rx1216_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_911:
    .return (rx1216_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("257_1300060177.262") :method
.annotate 'line', 4
    $P1218 = self."!PREFIX__!subrule"("ws", "(")
    new $P1219, "ResizablePMCArray"
    push $P1219, $P1218
    .return ($P1219)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("258_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1224_tgt
    .local int rx1224_pos
    .local int rx1224_off
    .local int rx1224_eos
    .local int rx1224_rep
    .local pmc rx1224_cur
    .local pmc rx1224_debug
    (rx1224_cur, rx1224_pos, rx1224_tgt, $I10) = self."!cursor_start"()
    rx1224_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1224_cur
    .local pmc match
    .lex "$/", match
    length rx1224_eos, rx1224_tgt
    gt rx1224_pos, rx1224_eos, rx1224_done
    set rx1224_off, 0
    lt rx1224_pos, 2, rx1224_start
    sub rx1224_off, rx1224_pos, 1
    substr rx1224_tgt, rx1224_tgt, rx1224_off
  rx1224_start:
    eq $I10, 1, rx1224_restart
    if_null rx1224_debug, debug_912
    rx1224_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_912:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1228_done
    goto rxscan1228_scan
  rxscan1228_loop:
    (rx1224_pos) = rx1224_cur."from"()
    inc rx1224_pos
    rx1224_cur."!cursor_from"(rx1224_pos)
    ge rx1224_pos, rx1224_eos, rxscan1228_done
  rxscan1228_scan:
    set_addr $I10, rxscan1228_loop
    rx1224_cur."!mark_push"(0, rx1224_pos, $I10)
  rxscan1228_done:
.annotate 'line', 562
  # rx literal  "["
    add $I11, rx1224_pos, 1
    gt $I11, rx1224_eos, rx1224_fail
    sub $I11, rx1224_pos, rx1224_off
    ord $I11, rx1224_tgt, $I11
    ne $I11, 91, rx1224_fail
    add rx1224_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1224_cur."!cursor_pos"(rx1224_pos)
    $P10 = rx1224_cur."ws"()
    unless $P10, rx1224_fail
    rx1224_pos = $P10."pos"()
  # rx rxquantr1229 ** 0..1
    set_addr $I10, rxquantr1229_done
    rx1224_cur."!mark_push"(0, rx1224_pos, $I10)
  rxquantr1229_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1224_cur."!cursor_pos"(rx1224_pos)
    $P10 = rx1224_cur."EXPR"()
    unless $P10, rx1224_fail
    goto rxsubrule1230_pass
  rxsubrule1230_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1224_fail
  rxsubrule1230_pass:
    set_addr $I10, rxsubrule1230_back
    rx1224_cur."!mark_push"(0, rx1224_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1224_pos = $P10."pos"()
    set_addr $I10, rxquantr1229_done
    (rx1224_rep) = rx1224_cur."!mark_commit"($I10)
  rxquantr1229_done:
  # rx literal  "]"
    add $I11, rx1224_pos, 1
    gt $I11, rx1224_eos, rx1224_fail
    sub $I11, rx1224_pos, rx1224_off
    ord $I11, rx1224_tgt, $I11
    ne $I11, 93, rx1224_fail
    add rx1224_pos, 1
  # rx pass
    rx1224_cur."!cursor_pass"(rx1224_pos, "circumfix:sym<[ ]>")
    if_null rx1224_debug, debug_913
    rx1224_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1224_pos)
  debug_913:
    .return (rx1224_cur)
  rx1224_restart:
.annotate 'line', 4
    if_null rx1224_debug, debug_914
    rx1224_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_914:
  rx1224_fail:
    (rx1224_rep, rx1224_pos, $I10, $P10) = rx1224_cur."!mark_fail"(0)
    lt rx1224_pos, -1, rx1224_done
    eq rx1224_pos, -1, rx1224_fail
    jump $I10
  rx1224_done:
    rx1224_cur."!cursor_fail"()
    if_null rx1224_debug, debug_915
    rx1224_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_915:
    .return (rx1224_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("259_1300060177.262") :method
.annotate 'line', 4
    $P1226 = self."!PREFIX__!subrule"("ws", "[")
    new $P1227, "ResizablePMCArray"
    push $P1227, $P1226
    .return ($P1227)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("260_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1232_tgt
    .local int rx1232_pos
    .local int rx1232_off
    .local int rx1232_eos
    .local int rx1232_rep
    .local pmc rx1232_cur
    .local pmc rx1232_debug
    (rx1232_cur, rx1232_pos, rx1232_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1232_cur
    .local pmc match
    .lex "$/", match
    length rx1232_eos, rx1232_tgt
    gt rx1232_pos, rx1232_eos, rx1232_done
    set rx1232_off, 0
    lt rx1232_pos, 2, rx1232_start
    sub rx1232_off, rx1232_pos, 1
    substr rx1232_tgt, rx1232_tgt, rx1232_off
  rx1232_start:
    eq $I10, 1, rx1232_restart
    if_null rx1232_debug, debug_916
    rx1232_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_916:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1235_done
    goto rxscan1235_scan
  rxscan1235_loop:
    (rx1232_pos) = rx1232_cur."from"()
    inc rx1232_pos
    rx1232_cur."!cursor_from"(rx1232_pos)
    ge rx1232_pos, rx1232_eos, rxscan1235_done
  rxscan1235_scan:
    set_addr $I10, rxscan1235_loop
    rx1232_cur."!mark_push"(0, rx1232_pos, $I10)
  rxscan1235_done:
.annotate 'line', 563
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1232_pos, rx1232_off
    substr $S10, rx1232_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1232_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1232_cur."!cursor_pos"(rx1232_pos)
    $P10 = rx1232_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1232_fail
    rx1232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1232_pos = $P10."pos"()
  # rx pass
    rx1232_cur."!cursor_pass"(rx1232_pos, "circumfix:sym<ang>")
    if_null rx1232_debug, debug_917
    rx1232_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1232_pos)
  debug_917:
    .return (rx1232_cur)
  rx1232_restart:
.annotate 'line', 4
    if_null rx1232_debug, debug_918
    rx1232_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_918:
  rx1232_fail:
    (rx1232_rep, rx1232_pos, $I10, $P10) = rx1232_cur."!mark_fail"(0)
    lt rx1232_pos, -1, rx1232_done
    eq rx1232_pos, -1, rx1232_fail
    jump $I10
  rx1232_done:
    rx1232_cur."!cursor_fail"()
    if_null rx1232_debug, debug_919
    rx1232_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_919:
    .return (rx1232_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("261_1300060177.262") :method
.annotate 'line', 4
    new $P1234, "ResizablePMCArray"
    push $P1234, "<"
    .return ($P1234)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("262_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1237_tgt
    .local int rx1237_pos
    .local int rx1237_off
    .local int rx1237_eos
    .local int rx1237_rep
    .local pmc rx1237_cur
    .local pmc rx1237_debug
    (rx1237_cur, rx1237_pos, rx1237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1237_cur
    .local pmc match
    .lex "$/", match
    length rx1237_eos, rx1237_tgt
    gt rx1237_pos, rx1237_eos, rx1237_done
    set rx1237_off, 0
    lt rx1237_pos, 2, rx1237_start
    sub rx1237_off, rx1237_pos, 1
    substr rx1237_tgt, rx1237_tgt, rx1237_off
  rx1237_start:
    eq $I10, 1, rx1237_restart
    if_null rx1237_debug, debug_920
    rx1237_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_920:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1240_done
    goto rxscan1240_scan
  rxscan1240_loop:
    (rx1237_pos) = rx1237_cur."from"()
    inc rx1237_pos
    rx1237_cur."!cursor_from"(rx1237_pos)
    ge rx1237_pos, rx1237_eos, rxscan1240_done
  rxscan1240_scan:
    set_addr $I10, rxscan1240_loop
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxscan1240_done:
.annotate 'line', 564
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1237_pos, rx1237_off
    substr $S10, rx1237_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1237_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1237_pos = $P10."pos"()
  # rx pass
    rx1237_cur."!cursor_pass"(rx1237_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1237_debug, debug_921
    rx1237_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1237_pos)
  debug_921:
    .return (rx1237_cur)
  rx1237_restart:
.annotate 'line', 4
    if_null rx1237_debug, debug_922
    rx1237_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_922:
  rx1237_fail:
    (rx1237_rep, rx1237_pos, $I10, $P10) = rx1237_cur."!mark_fail"(0)
    lt rx1237_pos, -1, rx1237_done
    eq rx1237_pos, -1, rx1237_fail
    jump $I10
  rx1237_done:
    rx1237_cur."!cursor_fail"()
    if_null rx1237_debug, debug_923
    rx1237_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_923:
    .return (rx1237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("263_1300060177.262") :method
.annotate 'line', 4
    new $P1239, "ResizablePMCArray"
    push $P1239, unicode:"\x{ab}"
    .return ($P1239)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("264_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1242_tgt
    .local int rx1242_pos
    .local int rx1242_off
    .local int rx1242_eos
    .local int rx1242_rep
    .local pmc rx1242_cur
    .local pmc rx1242_debug
    (rx1242_cur, rx1242_pos, rx1242_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1242_cur
    .local pmc match
    .lex "$/", match
    length rx1242_eos, rx1242_tgt
    gt rx1242_pos, rx1242_eos, rx1242_done
    set rx1242_off, 0
    lt rx1242_pos, 2, rx1242_start
    sub rx1242_off, rx1242_pos, 1
    substr rx1242_tgt, rx1242_tgt, rx1242_off
  rx1242_start:
    eq $I10, 1, rx1242_restart
    if_null rx1242_debug, debug_924
    rx1242_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_924:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1245_done
    goto rxscan1245_scan
  rxscan1245_loop:
    (rx1242_pos) = rx1242_cur."from"()
    inc rx1242_pos
    rx1242_cur."!cursor_from"(rx1242_pos)
    ge rx1242_pos, rx1242_eos, rxscan1245_done
  rxscan1245_scan:
    set_addr $I10, rxscan1245_loop
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  rxscan1245_done:
.annotate 'line', 565
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1242_pos, rx1242_off
    substr $S10, rx1242_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1242_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."pblock"()
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1242_pos = $P10."pos"()
  # rx pass
    rx1242_cur."!cursor_pass"(rx1242_pos, "circumfix:sym<{ }>")
    if_null rx1242_debug, debug_925
    rx1242_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1242_pos)
  debug_925:
    .return (rx1242_cur)
  rx1242_restart:
.annotate 'line', 4
    if_null rx1242_debug, debug_926
    rx1242_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_926:
  rx1242_fail:
    (rx1242_rep, rx1242_pos, $I10, $P10) = rx1242_cur."!mark_fail"(0)
    lt rx1242_pos, -1, rx1242_done
    eq rx1242_pos, -1, rx1242_fail
    jump $I10
  rx1242_done:
    rx1242_cur."!cursor_fail"()
    if_null rx1242_debug, debug_927
    rx1242_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_927:
    .return (rx1242_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("265_1300060177.262") :method
.annotate 'line', 4
    new $P1244, "ResizablePMCArray"
    push $P1244, "{"
    .return ($P1244)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("266_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1247_tgt
    .local int rx1247_pos
    .local int rx1247_off
    .local int rx1247_eos
    .local int rx1247_rep
    .local pmc rx1247_cur
    .local pmc rx1247_debug
    (rx1247_cur, rx1247_pos, rx1247_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1247_cur
    .local pmc match
    .lex "$/", match
    length rx1247_eos, rx1247_tgt
    gt rx1247_pos, rx1247_eos, rx1247_done
    set rx1247_off, 0
    lt rx1247_pos, 2, rx1247_start
    sub rx1247_off, rx1247_pos, 1
    substr rx1247_tgt, rx1247_tgt, rx1247_off
  rx1247_start:
    eq $I10, 1, rx1247_restart
    if_null rx1247_debug, debug_928
    rx1247_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_928:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1251_done
    goto rxscan1251_scan
  rxscan1251_loop:
    (rx1247_pos) = rx1247_cur."from"()
    inc rx1247_pos
    rx1247_cur."!cursor_from"(rx1247_pos)
    ge rx1247_pos, rx1247_eos, rxscan1251_done
  rxscan1251_scan:
    set_addr $I10, rxscan1251_loop
    rx1247_cur."!mark_push"(0, rx1247_pos, $I10)
  rxscan1251_done:
.annotate 'line', 566
  # rx subrule "sigil" subtype=capture negate=
    rx1247_cur."!cursor_pos"(rx1247_pos)
    $P10 = rx1247_cur."sigil"()
    unless $P10, rx1247_fail
    rx1247_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1247_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1247_pos, 1
    gt $I11, rx1247_eos, rx1247_fail
    sub $I11, rx1247_pos, rx1247_off
    ord $I11, rx1247_tgt, $I11
    ne $I11, 40, rx1247_fail
    add rx1247_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1247_cur."!cursor_pos"(rx1247_pos)
    $P10 = rx1247_cur."semilist"()
    unless $P10, rx1247_fail
    rx1247_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1247_pos = $P10."pos"()
  alt1252_0:
    set_addr $I10, alt1252_1
    rx1247_cur."!mark_push"(0, rx1247_pos, $I10)
  # rx literal  ")"
    add $I11, rx1247_pos, 1
    gt $I11, rx1247_eos, rx1247_fail
    sub $I11, rx1247_pos, rx1247_off
    ord $I11, rx1247_tgt, $I11
    ne $I11, 41, rx1247_fail
    add rx1247_pos, 1
    goto alt1252_end
  alt1252_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1247_cur."!cursor_pos"(rx1247_pos)
    $P10 = rx1247_cur."FAILGOAL"("')'")
    unless $P10, rx1247_fail
    goto rxsubrule1254_pass
  rxsubrule1254_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1247_fail
  rxsubrule1254_pass:
    set_addr $I10, rxsubrule1254_back
    rx1247_cur."!mark_push"(0, rx1247_pos, $I10, $P10)
    rx1247_pos = $P10."pos"()
  alt1252_end:
  # rx pass
    rx1247_cur."!cursor_pass"(rx1247_pos, "circumfix:sym<sigil>")
    if_null rx1247_debug, debug_929
    rx1247_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1247_pos)
  debug_929:
    .return (rx1247_cur)
  rx1247_restart:
.annotate 'line', 4
    if_null rx1247_debug, debug_930
    rx1247_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_930:
  rx1247_fail:
    (rx1247_rep, rx1247_pos, $I10, $P10) = rx1247_cur."!mark_fail"(0)
    lt rx1247_pos, -1, rx1247_done
    eq rx1247_pos, -1, rx1247_fail
    jump $I10
  rx1247_done:
    rx1247_cur."!cursor_fail"()
    if_null rx1247_debug, debug_931
    rx1247_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_931:
    .return (rx1247_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("267_1300060177.262") :method
.annotate 'line', 4
    $P1249 = self."!PREFIX__!subrule"("sigil", "")
    new $P1250, "ResizablePMCArray"
    push $P1250, $P1249
    .return ($P1250)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("268_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1256_tgt
    .local int rx1256_pos
    .local int rx1256_off
    .local int rx1256_eos
    .local int rx1256_rep
    .local pmc rx1256_cur
    .local pmc rx1256_debug
    (rx1256_cur, rx1256_pos, rx1256_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1256_cur
    .local pmc match
    .lex "$/", match
    length rx1256_eos, rx1256_tgt
    gt rx1256_pos, rx1256_eos, rx1256_done
    set rx1256_off, 0
    lt rx1256_pos, 2, rx1256_start
    sub rx1256_off, rx1256_pos, 1
    substr rx1256_tgt, rx1256_tgt, rx1256_off
  rx1256_start:
    eq $I10, 1, rx1256_restart
    if_null rx1256_debug, debug_932
    rx1256_cur."!cursor_debug"("START", "semilist")
  debug_932:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1260_done
    goto rxscan1260_scan
  rxscan1260_loop:
    (rx1256_pos) = rx1256_cur."from"()
    inc rx1256_pos
    rx1256_cur."!cursor_from"(rx1256_pos)
    ge rx1256_pos, rx1256_eos, rxscan1260_done
  rxscan1260_scan:
    set_addr $I10, rxscan1260_loop
    rx1256_cur."!mark_push"(0, rx1256_pos, $I10)
  rxscan1260_done:
.annotate 'line', 568
  # rx subrule "ws" subtype=method negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."ws"()
    unless $P10, rx1256_fail
    rx1256_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."statement"()
    unless $P10, rx1256_fail
    rx1256_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1256_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1256_cur."!cursor_pos"(rx1256_pos)
    $P10 = rx1256_cur."ws"()
    unless $P10, rx1256_fail
    rx1256_pos = $P10."pos"()
  # rx pass
    rx1256_cur."!cursor_pass"(rx1256_pos, "semilist")
    if_null rx1256_debug, debug_933
    rx1256_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1256_pos)
  debug_933:
    .return (rx1256_cur)
  rx1256_restart:
.annotate 'line', 4
    if_null rx1256_debug, debug_934
    rx1256_cur."!cursor_debug"("NEXT", "semilist")
  debug_934:
  rx1256_fail:
    (rx1256_rep, rx1256_pos, $I10, $P10) = rx1256_cur."!mark_fail"(0)
    lt rx1256_pos, -1, rx1256_done
    eq rx1256_pos, -1, rx1256_fail
    jump $I10
  rx1256_done:
    rx1256_cur."!cursor_fail"()
    if_null rx1256_debug, debug_935
    rx1256_cur."!cursor_debug"("FAIL", "semilist")
  debug_935:
    .return (rx1256_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("269_1300060177.262") :method
.annotate 'line', 4
    $P1258 = self."!PREFIX__!subrule"("ws", "")
    new $P1259, "ResizablePMCArray"
    push $P1259, $P1258
    .return ($P1259)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1263"  :anon :subid("270_1300060177.262") :outer("11_1300060177.262")
.annotate 'line', 4
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post936") :outer("270_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P1264 = "270_1300060177.262" 
    .local pmc block
    set block, $P1264
.annotate 'line', 573
    get_hll_global $P1265, ["NQP"], "Grammar"
    $P1265."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 574
    get_hll_global $P1266, ["NQP"], "Grammar"
    $P1266."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 575
    get_hll_global $P1267, ["NQP"], "Grammar"
    $P1267."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 576
    get_hll_global $P1268, ["NQP"], "Grammar"
    $P1268."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 577
    get_hll_global $P1269, ["NQP"], "Grammar"
    $P1269."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 578
    get_hll_global $P1270, ["NQP"], "Grammar"
    $P1270."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 579
    get_hll_global $P1271, ["NQP"], "Grammar"
    $P1271."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 580
    get_hll_global $P1272, ["NQP"], "Grammar"
    $P1272."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 581
    get_hll_global $P1273, ["NQP"], "Grammar"
    $P1273."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 582
    get_hll_global $P1274, ["NQP"], "Grammar"
    $P1274."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 583
    get_hll_global $P1275, ["NQP"], "Grammar"
    $P1275."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 584
    get_hll_global $P1276, ["NQP"], "Grammar"
    $P1276."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 585
    get_hll_global $P1277, ["NQP"], "Grammar"
    $P1277."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 586
    get_hll_global $P1278, ["NQP"], "Grammar"
    $P1278."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 587
    get_hll_global $P1279, ["NQP"], "Grammar"
    $P1279."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("271_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1281_tgt
    .local int rx1281_pos
    .local int rx1281_off
    .local int rx1281_eos
    .local int rx1281_rep
    .local pmc rx1281_cur
    .local pmc rx1281_debug
    (rx1281_cur, rx1281_pos, rx1281_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1281_cur
    .local pmc match
    .lex "$/", match
    length rx1281_eos, rx1281_tgt
    gt rx1281_pos, rx1281_eos, rx1281_done
    set rx1281_off, 0
    lt rx1281_pos, 2, rx1281_start
    sub rx1281_off, rx1281_pos, 1
    substr rx1281_tgt, rx1281_tgt, rx1281_off
  rx1281_start:
    eq $I10, 1, rx1281_restart
    if_null rx1281_debug, debug_937
    rx1281_cur."!cursor_debug"("START", "infixish")
  debug_937:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1284_done
    goto rxscan1284_scan
  rxscan1284_loop:
    (rx1281_pos) = rx1281_cur."from"()
    inc rx1281_pos
    rx1281_cur."!cursor_from"(rx1281_pos)
    ge rx1281_pos, rx1281_eos, rxscan1284_done
  rxscan1284_scan:
    set_addr $I10, rxscan1284_loop
    rx1281_cur."!mark_push"(0, rx1281_pos, $I10)
  rxscan1284_done:
.annotate 'line', 591
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1281_cur."!cursor_pos"(rx1281_pos)
    $P10 = rx1281_cur."infixstopper"()
    if $P10, rx1281_fail
  # rx subrule "infix" subtype=capture negate=
    rx1281_cur."!cursor_pos"(rx1281_pos)
    $P10 = rx1281_cur."infix"()
    unless $P10, rx1281_fail
    rx1281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1281_pos = $P10."pos"()
  # rx pass
    rx1281_cur."!cursor_pass"(rx1281_pos, "infixish")
    if_null rx1281_debug, debug_938
    rx1281_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1281_pos)
  debug_938:
    .return (rx1281_cur)
  rx1281_restart:
.annotate 'line', 4
    if_null rx1281_debug, debug_939
    rx1281_cur."!cursor_debug"("NEXT", "infixish")
  debug_939:
  rx1281_fail:
    (rx1281_rep, rx1281_pos, $I10, $P10) = rx1281_cur."!mark_fail"(0)
    lt rx1281_pos, -1, rx1281_done
    eq rx1281_pos, -1, rx1281_fail
    jump $I10
  rx1281_done:
    rx1281_cur."!cursor_fail"()
    if_null rx1281_debug, debug_940
    rx1281_cur."!cursor_debug"("FAIL", "infixish")
  debug_940:
    .return (rx1281_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("272_1300060177.262") :method
.annotate 'line', 4
    new $P1283, "ResizablePMCArray"
    push $P1283, ""
    .return ($P1283)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("273_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1286_tgt
    .local int rx1286_pos
    .local int rx1286_off
    .local int rx1286_eos
    .local int rx1286_rep
    .local pmc rx1286_cur
    .local pmc rx1286_debug
    (rx1286_cur, rx1286_pos, rx1286_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1286_cur
    .local pmc match
    .lex "$/", match
    length rx1286_eos, rx1286_tgt
    gt rx1286_pos, rx1286_eos, rx1286_done
    set rx1286_off, 0
    lt rx1286_pos, 2, rx1286_start
    sub rx1286_off, rx1286_pos, 1
    substr rx1286_tgt, rx1286_tgt, rx1286_off
  rx1286_start:
    eq $I10, 1, rx1286_restart
    if_null rx1286_debug, debug_941
    rx1286_cur."!cursor_debug"("START", "infixstopper")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1289_done
    goto rxscan1289_scan
  rxscan1289_loop:
    (rx1286_pos) = rx1286_cur."from"()
    inc rx1286_pos
    rx1286_cur."!cursor_from"(rx1286_pos)
    ge rx1286_pos, rx1286_eos, rxscan1289_done
  rxscan1289_scan:
    set_addr $I10, rxscan1289_loop
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  rxscan1289_done:
.annotate 'line', 592
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."lambda"()
    unless $P10, rx1286_fail
  # rx pass
    rx1286_cur."!cursor_pass"(rx1286_pos, "infixstopper")
    if_null rx1286_debug, debug_942
    rx1286_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1286_pos)
  debug_942:
    .return (rx1286_cur)
  rx1286_restart:
.annotate 'line', 4
    if_null rx1286_debug, debug_943
    rx1286_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_943:
  rx1286_fail:
    (rx1286_rep, rx1286_pos, $I10, $P10) = rx1286_cur."!mark_fail"(0)
    lt rx1286_pos, -1, rx1286_done
    eq rx1286_pos, -1, rx1286_fail
    jump $I10
  rx1286_done:
    rx1286_cur."!cursor_fail"()
    if_null rx1286_debug, debug_944
    rx1286_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_944:
    .return (rx1286_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("274_1300060177.262") :method
.annotate 'line', 4
    new $P1288, "ResizablePMCArray"
    push $P1288, ""
    .return ($P1288)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("275_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1291_tgt
    .local int rx1291_pos
    .local int rx1291_off
    .local int rx1291_eos
    .local int rx1291_rep
    .local pmc rx1291_cur
    .local pmc rx1291_debug
    (rx1291_cur, rx1291_pos, rx1291_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1291_cur
    .local pmc match
    .lex "$/", match
    length rx1291_eos, rx1291_tgt
    gt rx1291_pos, rx1291_eos, rx1291_done
    set rx1291_off, 0
    lt rx1291_pos, 2, rx1291_start
    sub rx1291_off, rx1291_pos, 1
    substr rx1291_tgt, rx1291_tgt, rx1291_off
  rx1291_start:
    eq $I10, 1, rx1291_restart
    if_null rx1291_debug, debug_945
    rx1291_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1295_done
    goto rxscan1295_scan
  rxscan1295_loop:
    (rx1291_pos) = rx1291_cur."from"()
    inc rx1291_pos
    rx1291_cur."!cursor_from"(rx1291_pos)
    ge rx1291_pos, rx1291_eos, rxscan1295_done
  rxscan1295_scan:
    set_addr $I10, rxscan1295_loop
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  rxscan1295_done:
.annotate 'line', 595
  # rx literal  "["
    add $I11, rx1291_pos, 1
    gt $I11, rx1291_eos, rx1291_fail
    sub $I11, rx1291_pos, rx1291_off
    ord $I11, rx1291_tgt, $I11
    ne $I11, 91, rx1291_fail
    add rx1291_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."ws"()
    unless $P10, rx1291_fail
    rx1291_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."EXPR"()
    unless $P10, rx1291_fail
    rx1291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1291_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1291_pos, 1
    gt $I11, rx1291_eos, rx1291_fail
    sub $I11, rx1291_pos, rx1291_off
    ord $I11, rx1291_tgt, $I11
    ne $I11, 93, rx1291_fail
    add rx1291_pos, 1
.annotate 'line', 596
  # rx subrule "O" subtype=capture negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."O"("%methodop")
    unless $P10, rx1291_fail
    rx1291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1291_pos = $P10."pos"()
.annotate 'line', 594
  # rx pass
    rx1291_cur."!cursor_pass"(rx1291_pos, "postcircumfix:sym<[ ]>")
    if_null rx1291_debug, debug_946
    rx1291_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1291_pos)
  debug_946:
    .return (rx1291_cur)
  rx1291_restart:
.annotate 'line', 4
    if_null rx1291_debug, debug_947
    rx1291_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_947:
  rx1291_fail:
    (rx1291_rep, rx1291_pos, $I10, $P10) = rx1291_cur."!mark_fail"(0)
    lt rx1291_pos, -1, rx1291_done
    eq rx1291_pos, -1, rx1291_fail
    jump $I10
  rx1291_done:
    rx1291_cur."!cursor_fail"()
    if_null rx1291_debug, debug_948
    rx1291_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_948:
    .return (rx1291_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("276_1300060177.262") :method
.annotate 'line', 4
    $P1293 = self."!PREFIX__!subrule"("ws", "[")
    new $P1294, "ResizablePMCArray"
    push $P1294, $P1293
    .return ($P1294)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("277_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1297_tgt
    .local int rx1297_pos
    .local int rx1297_off
    .local int rx1297_eos
    .local int rx1297_rep
    .local pmc rx1297_cur
    .local pmc rx1297_debug
    (rx1297_cur, rx1297_pos, rx1297_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1297_cur
    .local pmc match
    .lex "$/", match
    length rx1297_eos, rx1297_tgt
    gt rx1297_pos, rx1297_eos, rx1297_done
    set rx1297_off, 0
    lt rx1297_pos, 2, rx1297_start
    sub rx1297_off, rx1297_pos, 1
    substr rx1297_tgt, rx1297_tgt, rx1297_off
  rx1297_start:
    eq $I10, 1, rx1297_restart
    if_null rx1297_debug, debug_949
    rx1297_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1301_done
    goto rxscan1301_scan
  rxscan1301_loop:
    (rx1297_pos) = rx1297_cur."from"()
    inc rx1297_pos
    rx1297_cur."!cursor_from"(rx1297_pos)
    ge rx1297_pos, rx1297_eos, rxscan1301_done
  rxscan1301_scan:
    set_addr $I10, rxscan1301_loop
    rx1297_cur."!mark_push"(0, rx1297_pos, $I10)
  rxscan1301_done:
.annotate 'line', 600
  # rx literal  "{"
    add $I11, rx1297_pos, 1
    gt $I11, rx1297_eos, rx1297_fail
    sub $I11, rx1297_pos, rx1297_off
    ord $I11, rx1297_tgt, $I11
    ne $I11, 123, rx1297_fail
    add rx1297_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1297_cur."!cursor_pos"(rx1297_pos)
    $P10 = rx1297_cur."ws"()
    unless $P10, rx1297_fail
    rx1297_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1297_cur."!cursor_pos"(rx1297_pos)
    $P10 = rx1297_cur."EXPR"()
    unless $P10, rx1297_fail
    rx1297_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1297_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1297_pos, 1
    gt $I11, rx1297_eos, rx1297_fail
    sub $I11, rx1297_pos, rx1297_off
    ord $I11, rx1297_tgt, $I11
    ne $I11, 125, rx1297_fail
    add rx1297_pos, 1
.annotate 'line', 601
  # rx subrule "O" subtype=capture negate=
    rx1297_cur."!cursor_pos"(rx1297_pos)
    $P10 = rx1297_cur."O"("%methodop")
    unless $P10, rx1297_fail
    rx1297_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1297_pos = $P10."pos"()
.annotate 'line', 599
  # rx pass
    rx1297_cur."!cursor_pass"(rx1297_pos, "postcircumfix:sym<{ }>")
    if_null rx1297_debug, debug_950
    rx1297_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1297_pos)
  debug_950:
    .return (rx1297_cur)
  rx1297_restart:
.annotate 'line', 4
    if_null rx1297_debug, debug_951
    rx1297_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_951:
  rx1297_fail:
    (rx1297_rep, rx1297_pos, $I10, $P10) = rx1297_cur."!mark_fail"(0)
    lt rx1297_pos, -1, rx1297_done
    eq rx1297_pos, -1, rx1297_fail
    jump $I10
  rx1297_done:
    rx1297_cur."!cursor_fail"()
    if_null rx1297_debug, debug_952
    rx1297_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_952:
    .return (rx1297_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("278_1300060177.262") :method
.annotate 'line', 4
    $P1299 = self."!PREFIX__!subrule"("ws", "{")
    new $P1300, "ResizablePMCArray"
    push $P1300, $P1299
    .return ($P1300)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("279_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1303_tgt
    .local int rx1303_pos
    .local int rx1303_off
    .local int rx1303_eos
    .local int rx1303_rep
    .local pmc rx1303_cur
    .local pmc rx1303_debug
    (rx1303_cur, rx1303_pos, rx1303_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1303_cur
    .local pmc match
    .lex "$/", match
    length rx1303_eos, rx1303_tgt
    gt rx1303_pos, rx1303_eos, rx1303_done
    set rx1303_off, 0
    lt rx1303_pos, 2, rx1303_start
    sub rx1303_off, rx1303_pos, 1
    substr rx1303_tgt, rx1303_tgt, rx1303_off
  rx1303_start:
    eq $I10, 1, rx1303_restart
    if_null rx1303_debug, debug_953
    rx1303_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1306_done
    goto rxscan1306_scan
  rxscan1306_loop:
    (rx1303_pos) = rx1303_cur."from"()
    inc rx1303_pos
    rx1303_cur."!cursor_from"(rx1303_pos)
    ge rx1303_pos, rx1303_eos, rxscan1306_done
  rxscan1306_scan:
    set_addr $I10, rxscan1306_loop
    rx1303_cur."!mark_push"(0, rx1303_pos, $I10)
  rxscan1306_done:
.annotate 'line', 605
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1303_pos, rx1303_off
    substr $S10, rx1303_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1303_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1303_cur."!cursor_pos"(rx1303_pos)
    $P10 = rx1303_cur."quote_EXPR"(":q")
    unless $P10, rx1303_fail
    rx1303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1303_pos = $P10."pos"()
.annotate 'line', 606
  # rx subrule "O" subtype=capture negate=
    rx1303_cur."!cursor_pos"(rx1303_pos)
    $P10 = rx1303_cur."O"("%methodop")
    unless $P10, rx1303_fail
    rx1303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1303_pos = $P10."pos"()
.annotate 'line', 604
  # rx pass
    rx1303_cur."!cursor_pass"(rx1303_pos, "postcircumfix:sym<ang>")
    if_null rx1303_debug, debug_954
    rx1303_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1303_pos)
  debug_954:
    .return (rx1303_cur)
  rx1303_restart:
.annotate 'line', 4
    if_null rx1303_debug, debug_955
    rx1303_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_955:
  rx1303_fail:
    (rx1303_rep, rx1303_pos, $I10, $P10) = rx1303_cur."!mark_fail"(0)
    lt rx1303_pos, -1, rx1303_done
    eq rx1303_pos, -1, rx1303_fail
    jump $I10
  rx1303_done:
    rx1303_cur."!cursor_fail"()
    if_null rx1303_debug, debug_956
    rx1303_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_956:
    .return (rx1303_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("280_1300060177.262") :method
.annotate 'line', 4
    new $P1305, "ResizablePMCArray"
    push $P1305, "<"
    .return ($P1305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("281_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1308_tgt
    .local int rx1308_pos
    .local int rx1308_off
    .local int rx1308_eos
    .local int rx1308_rep
    .local pmc rx1308_cur
    .local pmc rx1308_debug
    (rx1308_cur, rx1308_pos, rx1308_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1308_cur
    .local pmc match
    .lex "$/", match
    length rx1308_eos, rx1308_tgt
    gt rx1308_pos, rx1308_eos, rx1308_done
    set rx1308_off, 0
    lt rx1308_pos, 2, rx1308_start
    sub rx1308_off, rx1308_pos, 1
    substr rx1308_tgt, rx1308_tgt, rx1308_off
  rx1308_start:
    eq $I10, 1, rx1308_restart
    if_null rx1308_debug, debug_957
    rx1308_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_957:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1312_done
    goto rxscan1312_scan
  rxscan1312_loop:
    (rx1308_pos) = rx1308_cur."from"()
    inc rx1308_pos
    rx1308_cur."!cursor_from"(rx1308_pos)
    ge rx1308_pos, rx1308_eos, rxscan1312_done
  rxscan1312_scan:
    set_addr $I10, rxscan1312_loop
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  rxscan1312_done:
.annotate 'line', 610
  # rx literal  "("
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 40, rx1308_fail
    add rx1308_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."arglist"()
    unless $P10, rx1308_fail
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1308_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 41, rx1308_fail
    add rx1308_pos, 1
.annotate 'line', 611
  # rx subrule "O" subtype=capture negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."O"("%methodop")
    unless $P10, rx1308_fail
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1308_pos = $P10."pos"()
.annotate 'line', 609
  # rx pass
    rx1308_cur."!cursor_pass"(rx1308_pos, "postcircumfix:sym<( )>")
    if_null rx1308_debug, debug_958
    rx1308_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1308_pos)
  debug_958:
    .return (rx1308_cur)
  rx1308_restart:
.annotate 'line', 4
    if_null rx1308_debug, debug_959
    rx1308_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_959:
  rx1308_fail:
    (rx1308_rep, rx1308_pos, $I10, $P10) = rx1308_cur."!mark_fail"(0)
    lt rx1308_pos, -1, rx1308_done
    eq rx1308_pos, -1, rx1308_fail
    jump $I10
  rx1308_done:
    rx1308_cur."!cursor_fail"()
    if_null rx1308_debug, debug_960
    rx1308_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_960:
    .return (rx1308_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("282_1300060177.262") :method
.annotate 'line', 4
    $P1310 = self."!PREFIX__!subrule"("ws", "(")
    new $P1311, "ResizablePMCArray"
    push $P1311, $P1310
    .return ($P1311)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("283_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1314_tgt
    .local int rx1314_pos
    .local int rx1314_off
    .local int rx1314_eos
    .local int rx1314_rep
    .local pmc rx1314_cur
    .local pmc rx1314_debug
    (rx1314_cur, rx1314_pos, rx1314_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1314_cur
    .local pmc match
    .lex "$/", match
    length rx1314_eos, rx1314_tgt
    gt rx1314_pos, rx1314_eos, rx1314_done
    set rx1314_off, 0
    lt rx1314_pos, 2, rx1314_start
    sub rx1314_off, rx1314_pos, 1
    substr rx1314_tgt, rx1314_tgt, rx1314_off
  rx1314_start:
    eq $I10, 1, rx1314_restart
    if_null rx1314_debug, debug_961
    rx1314_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_961:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1318_done
    goto rxscan1318_scan
  rxscan1318_loop:
    (rx1314_pos) = rx1314_cur."from"()
    inc rx1314_pos
    rx1314_cur."!cursor_from"(rx1314_pos)
    ge rx1314_pos, rx1314_eos, rxscan1318_done
  rxscan1318_scan:
    set_addr $I10, rxscan1318_loop
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  rxscan1318_done:
.annotate 'line', 614
  # rx subrule "dotty" subtype=capture negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."dotty"()
    unless $P10, rx1314_fail
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1314_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."O"("%methodop")
    unless $P10, rx1314_fail
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1314_pos = $P10."pos"()
  # rx pass
    rx1314_cur."!cursor_pass"(rx1314_pos, "postfix:sym<.>")
    if_null rx1314_debug, debug_962
    rx1314_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1314_pos)
  debug_962:
    .return (rx1314_cur)
  rx1314_restart:
.annotate 'line', 4
    if_null rx1314_debug, debug_963
    rx1314_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_963:
  rx1314_fail:
    (rx1314_rep, rx1314_pos, $I10, $P10) = rx1314_cur."!mark_fail"(0)
    lt rx1314_pos, -1, rx1314_done
    eq rx1314_pos, -1, rx1314_fail
    jump $I10
  rx1314_done:
    rx1314_cur."!cursor_fail"()
    if_null rx1314_debug, debug_964
    rx1314_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_964:
    .return (rx1314_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("284_1300060177.262") :method
.annotate 'line', 4
    $P1316 = self."!PREFIX__!subrule"("dotty", "")
    new $P1317, "ResizablePMCArray"
    push $P1317, $P1316
    .return ($P1317)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("285_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1320_tgt
    .local int rx1320_pos
    .local int rx1320_off
    .local int rx1320_eos
    .local int rx1320_rep
    .local pmc rx1320_cur
    .local pmc rx1320_debug
    (rx1320_cur, rx1320_pos, rx1320_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1320_cur
    .local pmc match
    .lex "$/", match
    length rx1320_eos, rx1320_tgt
    gt rx1320_pos, rx1320_eos, rx1320_done
    set rx1320_off, 0
    lt rx1320_pos, 2, rx1320_start
    sub rx1320_off, rx1320_pos, 1
    substr rx1320_tgt, rx1320_tgt, rx1320_off
  rx1320_start:
    eq $I10, 1, rx1320_restart
    if_null rx1320_debug, debug_965
    rx1320_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_965:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1324_done
    goto rxscan1324_scan
  rxscan1324_loop:
    (rx1320_pos) = rx1320_cur."from"()
    inc rx1320_pos
    rx1320_cur."!cursor_from"(rx1320_pos)
    ge rx1320_pos, rx1320_eos, rxscan1324_done
  rxscan1324_scan:
    set_addr $I10, rxscan1324_loop
    rx1320_cur."!mark_push"(0, rx1320_pos, $I10)
  rxscan1324_done:
.annotate 'line', 616
  # rx subcapture "sym"
    set_addr $I10, rxcap_1325_fail
    rx1320_cur."!mark_push"(0, rx1320_pos, $I10)
  # rx literal  "++"
    add $I11, rx1320_pos, 2
    gt $I11, rx1320_eos, rx1320_fail
    sub $I11, rx1320_pos, rx1320_off
    substr $S10, rx1320_tgt, $I11, 2
    ne $S10, "++", rx1320_fail
    add rx1320_pos, 2
    set_addr $I10, rxcap_1325_fail
    ($I12, $I11) = rx1320_cur."!mark_peek"($I10)
    rx1320_cur."!cursor_pos"($I11)
    ($P10) = rx1320_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1320_pos, "")
    rx1320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1325_done
  rxcap_1325_fail:
    goto rx1320_fail
  rxcap_1325_done:
  # rx subrule "O" subtype=capture negate=
    rx1320_cur."!cursor_pos"(rx1320_pos)
    $P10 = rx1320_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1320_fail
    rx1320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1320_pos = $P10."pos"()
  # rx pass
    rx1320_cur."!cursor_pass"(rx1320_pos, "prefix:sym<++>")
    if_null rx1320_debug, debug_966
    rx1320_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1320_pos)
  debug_966:
    .return (rx1320_cur)
  rx1320_restart:
.annotate 'line', 4
    if_null rx1320_debug, debug_967
    rx1320_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_967:
  rx1320_fail:
    (rx1320_rep, rx1320_pos, $I10, $P10) = rx1320_cur."!mark_fail"(0)
    lt rx1320_pos, -1, rx1320_done
    eq rx1320_pos, -1, rx1320_fail
    jump $I10
  rx1320_done:
    rx1320_cur."!cursor_fail"()
    if_null rx1320_debug, debug_968
    rx1320_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_968:
    .return (rx1320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("286_1300060177.262") :method
.annotate 'line', 4
    $P1322 = self."!PREFIX__!subrule"("O", "++")
    new $P1323, "ResizablePMCArray"
    push $P1323, $P1322
    .return ($P1323)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("287_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1327_tgt
    .local int rx1327_pos
    .local int rx1327_off
    .local int rx1327_eos
    .local int rx1327_rep
    .local pmc rx1327_cur
    .local pmc rx1327_debug
    (rx1327_cur, rx1327_pos, rx1327_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1327_cur
    .local pmc match
    .lex "$/", match
    length rx1327_eos, rx1327_tgt
    gt rx1327_pos, rx1327_eos, rx1327_done
    set rx1327_off, 0
    lt rx1327_pos, 2, rx1327_start
    sub rx1327_off, rx1327_pos, 1
    substr rx1327_tgt, rx1327_tgt, rx1327_off
  rx1327_start:
    eq $I10, 1, rx1327_restart
    if_null rx1327_debug, debug_969
    rx1327_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_969:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1331_done
    goto rxscan1331_scan
  rxscan1331_loop:
    (rx1327_pos) = rx1327_cur."from"()
    inc rx1327_pos
    rx1327_cur."!cursor_from"(rx1327_pos)
    ge rx1327_pos, rx1327_eos, rxscan1331_done
  rxscan1331_scan:
    set_addr $I10, rxscan1331_loop
    rx1327_cur."!mark_push"(0, rx1327_pos, $I10)
  rxscan1331_done:
.annotate 'line', 617
  # rx subcapture "sym"
    set_addr $I10, rxcap_1332_fail
    rx1327_cur."!mark_push"(0, rx1327_pos, $I10)
  # rx literal  "--"
    add $I11, rx1327_pos, 2
    gt $I11, rx1327_eos, rx1327_fail
    sub $I11, rx1327_pos, rx1327_off
    substr $S10, rx1327_tgt, $I11, 2
    ne $S10, "--", rx1327_fail
    add rx1327_pos, 2
    set_addr $I10, rxcap_1332_fail
    ($I12, $I11) = rx1327_cur."!mark_peek"($I10)
    rx1327_cur."!cursor_pos"($I11)
    ($P10) = rx1327_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1327_pos, "")
    rx1327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1332_done
  rxcap_1332_fail:
    goto rx1327_fail
  rxcap_1332_done:
  # rx subrule "O" subtype=capture negate=
    rx1327_cur."!cursor_pos"(rx1327_pos)
    $P10 = rx1327_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1327_fail
    rx1327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1327_pos = $P10."pos"()
  # rx pass
    rx1327_cur."!cursor_pass"(rx1327_pos, "prefix:sym<-->")
    if_null rx1327_debug, debug_970
    rx1327_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1327_pos)
  debug_970:
    .return (rx1327_cur)
  rx1327_restart:
.annotate 'line', 4
    if_null rx1327_debug, debug_971
    rx1327_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_971:
  rx1327_fail:
    (rx1327_rep, rx1327_pos, $I10, $P10) = rx1327_cur."!mark_fail"(0)
    lt rx1327_pos, -1, rx1327_done
    eq rx1327_pos, -1, rx1327_fail
    jump $I10
  rx1327_done:
    rx1327_cur."!cursor_fail"()
    if_null rx1327_debug, debug_972
    rx1327_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_972:
    .return (rx1327_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("288_1300060177.262") :method
.annotate 'line', 4
    $P1329 = self."!PREFIX__!subrule"("O", "--")
    new $P1330, "ResizablePMCArray"
    push $P1330, $P1329
    .return ($P1330)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("289_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1334_tgt
    .local int rx1334_pos
    .local int rx1334_off
    .local int rx1334_eos
    .local int rx1334_rep
    .local pmc rx1334_cur
    .local pmc rx1334_debug
    (rx1334_cur, rx1334_pos, rx1334_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1334_cur
    .local pmc match
    .lex "$/", match
    length rx1334_eos, rx1334_tgt
    gt rx1334_pos, rx1334_eos, rx1334_done
    set rx1334_off, 0
    lt rx1334_pos, 2, rx1334_start
    sub rx1334_off, rx1334_pos, 1
    substr rx1334_tgt, rx1334_tgt, rx1334_off
  rx1334_start:
    eq $I10, 1, rx1334_restart
    if_null rx1334_debug, debug_973
    rx1334_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_973:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1338_done
    goto rxscan1338_scan
  rxscan1338_loop:
    (rx1334_pos) = rx1334_cur."from"()
    inc rx1334_pos
    rx1334_cur."!cursor_from"(rx1334_pos)
    ge rx1334_pos, rx1334_eos, rxscan1338_done
  rxscan1338_scan:
    set_addr $I10, rxscan1338_loop
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  rxscan1338_done:
.annotate 'line', 620
  # rx subcapture "sym"
    set_addr $I10, rxcap_1339_fail
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  # rx literal  "++"
    add $I11, rx1334_pos, 2
    gt $I11, rx1334_eos, rx1334_fail
    sub $I11, rx1334_pos, rx1334_off
    substr $S10, rx1334_tgt, $I11, 2
    ne $S10, "++", rx1334_fail
    add rx1334_pos, 2
    set_addr $I10, rxcap_1339_fail
    ($I12, $I11) = rx1334_cur."!mark_peek"($I10)
    rx1334_cur."!cursor_pos"($I11)
    ($P10) = rx1334_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1334_pos, "")
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1339_done
  rxcap_1339_fail:
    goto rx1334_fail
  rxcap_1339_done:
  # rx subrule "O" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."O"("%autoincrement")
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1334_pos = $P10."pos"()
  # rx pass
    rx1334_cur."!cursor_pass"(rx1334_pos, "postfix:sym<++>")
    if_null rx1334_debug, debug_974
    rx1334_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1334_pos)
  debug_974:
    .return (rx1334_cur)
  rx1334_restart:
.annotate 'line', 4
    if_null rx1334_debug, debug_975
    rx1334_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_975:
  rx1334_fail:
    (rx1334_rep, rx1334_pos, $I10, $P10) = rx1334_cur."!mark_fail"(0)
    lt rx1334_pos, -1, rx1334_done
    eq rx1334_pos, -1, rx1334_fail
    jump $I10
  rx1334_done:
    rx1334_cur."!cursor_fail"()
    if_null rx1334_debug, debug_976
    rx1334_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_976:
    .return (rx1334_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("290_1300060177.262") :method
.annotate 'line', 4
    $P1336 = self."!PREFIX__!subrule"("O", "++")
    new $P1337, "ResizablePMCArray"
    push $P1337, $P1336
    .return ($P1337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("291_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1341_tgt
    .local int rx1341_pos
    .local int rx1341_off
    .local int rx1341_eos
    .local int rx1341_rep
    .local pmc rx1341_cur
    .local pmc rx1341_debug
    (rx1341_cur, rx1341_pos, rx1341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1341_cur
    .local pmc match
    .lex "$/", match
    length rx1341_eos, rx1341_tgt
    gt rx1341_pos, rx1341_eos, rx1341_done
    set rx1341_off, 0
    lt rx1341_pos, 2, rx1341_start
    sub rx1341_off, rx1341_pos, 1
    substr rx1341_tgt, rx1341_tgt, rx1341_off
  rx1341_start:
    eq $I10, 1, rx1341_restart
    if_null rx1341_debug, debug_977
    rx1341_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1345_done
    goto rxscan1345_scan
  rxscan1345_loop:
    (rx1341_pos) = rx1341_cur."from"()
    inc rx1341_pos
    rx1341_cur."!cursor_from"(rx1341_pos)
    ge rx1341_pos, rx1341_eos, rxscan1345_done
  rxscan1345_scan:
    set_addr $I10, rxscan1345_loop
    rx1341_cur."!mark_push"(0, rx1341_pos, $I10)
  rxscan1345_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1346_fail
    rx1341_cur."!mark_push"(0, rx1341_pos, $I10)
  # rx literal  "--"
    add $I11, rx1341_pos, 2
    gt $I11, rx1341_eos, rx1341_fail
    sub $I11, rx1341_pos, rx1341_off
    substr $S10, rx1341_tgt, $I11, 2
    ne $S10, "--", rx1341_fail
    add rx1341_pos, 2
    set_addr $I10, rxcap_1346_fail
    ($I12, $I11) = rx1341_cur."!mark_peek"($I10)
    rx1341_cur."!cursor_pos"($I11)
    ($P10) = rx1341_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1341_pos, "")
    rx1341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1346_done
  rxcap_1346_fail:
    goto rx1341_fail
  rxcap_1346_done:
  # rx subrule "O" subtype=capture negate=
    rx1341_cur."!cursor_pos"(rx1341_pos)
    $P10 = rx1341_cur."O"("%autoincrement")
    unless $P10, rx1341_fail
    rx1341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1341_pos = $P10."pos"()
  # rx pass
    rx1341_cur."!cursor_pass"(rx1341_pos, "postfix:sym<-->")
    if_null rx1341_debug, debug_978
    rx1341_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1341_pos)
  debug_978:
    .return (rx1341_cur)
  rx1341_restart:
.annotate 'line', 4
    if_null rx1341_debug, debug_979
    rx1341_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_979:
  rx1341_fail:
    (rx1341_rep, rx1341_pos, $I10, $P10) = rx1341_cur."!mark_fail"(0)
    lt rx1341_pos, -1, rx1341_done
    eq rx1341_pos, -1, rx1341_fail
    jump $I10
  rx1341_done:
    rx1341_cur."!cursor_fail"()
    if_null rx1341_debug, debug_980
    rx1341_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_980:
    .return (rx1341_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("292_1300060177.262") :method
.annotate 'line', 4
    $P1343 = self."!PREFIX__!subrule"("O", "--")
    new $P1344, "ResizablePMCArray"
    push $P1344, $P1343
    .return ($P1344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("293_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1348_tgt
    .local int rx1348_pos
    .local int rx1348_off
    .local int rx1348_eos
    .local int rx1348_rep
    .local pmc rx1348_cur
    .local pmc rx1348_debug
    (rx1348_cur, rx1348_pos, rx1348_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1348_cur
    .local pmc match
    .lex "$/", match
    length rx1348_eos, rx1348_tgt
    gt rx1348_pos, rx1348_eos, rx1348_done
    set rx1348_off, 0
    lt rx1348_pos, 2, rx1348_start
    sub rx1348_off, rx1348_pos, 1
    substr rx1348_tgt, rx1348_tgt, rx1348_off
  rx1348_start:
    eq $I10, 1, rx1348_restart
    if_null rx1348_debug, debug_981
    rx1348_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1352_done
    goto rxscan1352_scan
  rxscan1352_loop:
    (rx1348_pos) = rx1348_cur."from"()
    inc rx1348_pos
    rx1348_cur."!cursor_from"(rx1348_pos)
    ge rx1348_pos, rx1348_eos, rxscan1352_done
  rxscan1352_scan:
    set_addr $I10, rxscan1352_loop
    rx1348_cur."!mark_push"(0, rx1348_pos, $I10)
  rxscan1352_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1353_fail
    rx1348_cur."!mark_push"(0, rx1348_pos, $I10)
  # rx literal  "**"
    add $I11, rx1348_pos, 2
    gt $I11, rx1348_eos, rx1348_fail
    sub $I11, rx1348_pos, rx1348_off
    substr $S10, rx1348_tgt, $I11, 2
    ne $S10, "**", rx1348_fail
    add rx1348_pos, 2
    set_addr $I10, rxcap_1353_fail
    ($I12, $I11) = rx1348_cur."!mark_peek"($I10)
    rx1348_cur."!cursor_pos"($I11)
    ($P10) = rx1348_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1348_pos, "")
    rx1348_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1353_done
  rxcap_1353_fail:
    goto rx1348_fail
  rxcap_1353_done:
  # rx subrule "O" subtype=capture negate=
    rx1348_cur."!cursor_pos"(rx1348_pos)
    $P10 = rx1348_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1348_fail
    rx1348_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1348_pos = $P10."pos"()
  # rx pass
    rx1348_cur."!cursor_pass"(rx1348_pos, "infix:sym<**>")
    if_null rx1348_debug, debug_982
    rx1348_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1348_pos)
  debug_982:
    .return (rx1348_cur)
  rx1348_restart:
.annotate 'line', 4
    if_null rx1348_debug, debug_983
    rx1348_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_983:
  rx1348_fail:
    (rx1348_rep, rx1348_pos, $I10, $P10) = rx1348_cur."!mark_fail"(0)
    lt rx1348_pos, -1, rx1348_done
    eq rx1348_pos, -1, rx1348_fail
    jump $I10
  rx1348_done:
    rx1348_cur."!cursor_fail"()
    if_null rx1348_debug, debug_984
    rx1348_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_984:
    .return (rx1348_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("294_1300060177.262") :method
.annotate 'line', 4
    $P1350 = self."!PREFIX__!subrule"("O", "**")
    new $P1351, "ResizablePMCArray"
    push $P1351, $P1350
    .return ($P1351)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("295_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1355_tgt
    .local int rx1355_pos
    .local int rx1355_off
    .local int rx1355_eos
    .local int rx1355_rep
    .local pmc rx1355_cur
    .local pmc rx1355_debug
    (rx1355_cur, rx1355_pos, rx1355_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1355_cur
    .local pmc match
    .lex "$/", match
    length rx1355_eos, rx1355_tgt
    gt rx1355_pos, rx1355_eos, rx1355_done
    set rx1355_off, 0
    lt rx1355_pos, 2, rx1355_start
    sub rx1355_off, rx1355_pos, 1
    substr rx1355_tgt, rx1355_tgt, rx1355_off
  rx1355_start:
    eq $I10, 1, rx1355_restart
    if_null rx1355_debug, debug_985
    rx1355_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1359_done
    goto rxscan1359_scan
  rxscan1359_loop:
    (rx1355_pos) = rx1355_cur."from"()
    inc rx1355_pos
    rx1355_cur."!cursor_from"(rx1355_pos)
    ge rx1355_pos, rx1355_eos, rxscan1359_done
  rxscan1359_scan:
    set_addr $I10, rxscan1359_loop
    rx1355_cur."!mark_push"(0, rx1355_pos, $I10)
  rxscan1359_done:
.annotate 'line', 625
  # rx subcapture "sym"
    set_addr $I10, rxcap_1360_fail
    rx1355_cur."!mark_push"(0, rx1355_pos, $I10)
  # rx literal  "+"
    add $I11, rx1355_pos, 1
    gt $I11, rx1355_eos, rx1355_fail
    sub $I11, rx1355_pos, rx1355_off
    ord $I11, rx1355_tgt, $I11
    ne $I11, 43, rx1355_fail
    add rx1355_pos, 1
    set_addr $I10, rxcap_1360_fail
    ($I12, $I11) = rx1355_cur."!mark_peek"($I10)
    rx1355_cur."!cursor_pos"($I11)
    ($P10) = rx1355_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1355_pos, "")
    rx1355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1360_done
  rxcap_1360_fail:
    goto rx1355_fail
  rxcap_1360_done:
  # rx subrule "O" subtype=capture negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1355_fail
    rx1355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1355_pos = $P10."pos"()
  # rx pass
    rx1355_cur."!cursor_pass"(rx1355_pos, "prefix:sym<+>")
    if_null rx1355_debug, debug_986
    rx1355_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1355_pos)
  debug_986:
    .return (rx1355_cur)
  rx1355_restart:
.annotate 'line', 4
    if_null rx1355_debug, debug_987
    rx1355_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_987:
  rx1355_fail:
    (rx1355_rep, rx1355_pos, $I10, $P10) = rx1355_cur."!mark_fail"(0)
    lt rx1355_pos, -1, rx1355_done
    eq rx1355_pos, -1, rx1355_fail
    jump $I10
  rx1355_done:
    rx1355_cur."!cursor_fail"()
    if_null rx1355_debug, debug_988
    rx1355_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_988:
    .return (rx1355_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("296_1300060177.262") :method
.annotate 'line', 4
    $P1357 = self."!PREFIX__!subrule"("O", "+")
    new $P1358, "ResizablePMCArray"
    push $P1358, $P1357
    .return ($P1358)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("297_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1362_tgt
    .local int rx1362_pos
    .local int rx1362_off
    .local int rx1362_eos
    .local int rx1362_rep
    .local pmc rx1362_cur
    .local pmc rx1362_debug
    (rx1362_cur, rx1362_pos, rx1362_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1362_cur
    .local pmc match
    .lex "$/", match
    length rx1362_eos, rx1362_tgt
    gt rx1362_pos, rx1362_eos, rx1362_done
    set rx1362_off, 0
    lt rx1362_pos, 2, rx1362_start
    sub rx1362_off, rx1362_pos, 1
    substr rx1362_tgt, rx1362_tgt, rx1362_off
  rx1362_start:
    eq $I10, 1, rx1362_restart
    if_null rx1362_debug, debug_989
    rx1362_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1366_done
    goto rxscan1366_scan
  rxscan1366_loop:
    (rx1362_pos) = rx1362_cur."from"()
    inc rx1362_pos
    rx1362_cur."!cursor_from"(rx1362_pos)
    ge rx1362_pos, rx1362_eos, rxscan1366_done
  rxscan1366_scan:
    set_addr $I10, rxscan1366_loop
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  rxscan1366_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1367_fail
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  # rx literal  "~"
    add $I11, rx1362_pos, 1
    gt $I11, rx1362_eos, rx1362_fail
    sub $I11, rx1362_pos, rx1362_off
    ord $I11, rx1362_tgt, $I11
    ne $I11, 126, rx1362_fail
    add rx1362_pos, 1
    set_addr $I10, rxcap_1367_fail
    ($I12, $I11) = rx1362_cur."!mark_peek"($I10)
    rx1362_cur."!cursor_pos"($I11)
    ($P10) = rx1362_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1362_pos, "")
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1367_done
  rxcap_1367_fail:
    goto rx1362_fail
  rxcap_1367_done:
  # rx subrule "O" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1362_fail
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1362_pos = $P10."pos"()
  # rx pass
    rx1362_cur."!cursor_pass"(rx1362_pos, "prefix:sym<~>")
    if_null rx1362_debug, debug_990
    rx1362_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1362_pos)
  debug_990:
    .return (rx1362_cur)
  rx1362_restart:
.annotate 'line', 4
    if_null rx1362_debug, debug_991
    rx1362_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_991:
  rx1362_fail:
    (rx1362_rep, rx1362_pos, $I10, $P10) = rx1362_cur."!mark_fail"(0)
    lt rx1362_pos, -1, rx1362_done
    eq rx1362_pos, -1, rx1362_fail
    jump $I10
  rx1362_done:
    rx1362_cur."!cursor_fail"()
    if_null rx1362_debug, debug_992
    rx1362_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_992:
    .return (rx1362_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("298_1300060177.262") :method
.annotate 'line', 4
    $P1364 = self."!PREFIX__!subrule"("O", "~")
    new $P1365, "ResizablePMCArray"
    push $P1365, $P1364
    .return ($P1365)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("299_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1369_tgt
    .local int rx1369_pos
    .local int rx1369_off
    .local int rx1369_eos
    .local int rx1369_rep
    .local pmc rx1369_cur
    .local pmc rx1369_debug
    (rx1369_cur, rx1369_pos, rx1369_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1369_cur
    .local pmc match
    .lex "$/", match
    length rx1369_eos, rx1369_tgt
    gt rx1369_pos, rx1369_eos, rx1369_done
    set rx1369_off, 0
    lt rx1369_pos, 2, rx1369_start
    sub rx1369_off, rx1369_pos, 1
    substr rx1369_tgt, rx1369_tgt, rx1369_off
  rx1369_start:
    eq $I10, 1, rx1369_restart
    if_null rx1369_debug, debug_993
    rx1369_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1372_done
    goto rxscan1372_scan
  rxscan1372_loop:
    (rx1369_pos) = rx1369_cur."from"()
    inc rx1369_pos
    rx1369_cur."!cursor_from"(rx1369_pos)
    ge rx1369_pos, rx1369_eos, rxscan1372_done
  rxscan1372_scan:
    set_addr $I10, rxscan1372_loop
    rx1369_cur."!mark_push"(0, rx1369_pos, $I10)
  rxscan1372_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1373_fail
    rx1369_cur."!mark_push"(0, rx1369_pos, $I10)
  # rx literal  "-"
    add $I11, rx1369_pos, 1
    gt $I11, rx1369_eos, rx1369_fail
    sub $I11, rx1369_pos, rx1369_off
    ord $I11, rx1369_tgt, $I11
    ne $I11, 45, rx1369_fail
    add rx1369_pos, 1
    set_addr $I10, rxcap_1373_fail
    ($I12, $I11) = rx1369_cur."!mark_peek"($I10)
    rx1369_cur."!cursor_pos"($I11)
    ($P10) = rx1369_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1369_pos, "")
    rx1369_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1373_done
  rxcap_1373_fail:
    goto rx1369_fail
  rxcap_1373_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1369_pos, rx1369_off
    substr $S10, rx1369_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1369_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1369_cur."!cursor_pos"(rx1369_pos)
    $P10 = rx1369_cur."number"()
    if $P10, rx1369_fail
  # rx subrule "O" subtype=capture negate=
    rx1369_cur."!cursor_pos"(rx1369_pos)
    $P10 = rx1369_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1369_fail
    rx1369_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1369_pos = $P10."pos"()
  # rx pass
    rx1369_cur."!cursor_pass"(rx1369_pos, "prefix:sym<->")
    if_null rx1369_debug, debug_994
    rx1369_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1369_pos)
  debug_994:
    .return (rx1369_cur)
  rx1369_restart:
.annotate 'line', 4
    if_null rx1369_debug, debug_995
    rx1369_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_995:
  rx1369_fail:
    (rx1369_rep, rx1369_pos, $I10, $P10) = rx1369_cur."!mark_fail"(0)
    lt rx1369_pos, -1, rx1369_done
    eq rx1369_pos, -1, rx1369_fail
    jump $I10
  rx1369_done:
    rx1369_cur."!cursor_fail"()
    if_null rx1369_debug, debug_996
    rx1369_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_996:
    .return (rx1369_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("300_1300060177.262") :method
.annotate 'line', 4
    new $P1371, "ResizablePMCArray"
    push $P1371, "-"
    .return ($P1371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("301_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1375_tgt
    .local int rx1375_pos
    .local int rx1375_off
    .local int rx1375_eos
    .local int rx1375_rep
    .local pmc rx1375_cur
    .local pmc rx1375_debug
    (rx1375_cur, rx1375_pos, rx1375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1375_cur
    .local pmc match
    .lex "$/", match
    length rx1375_eos, rx1375_tgt
    gt rx1375_pos, rx1375_eos, rx1375_done
    set rx1375_off, 0
    lt rx1375_pos, 2, rx1375_start
    sub rx1375_off, rx1375_pos, 1
    substr rx1375_tgt, rx1375_tgt, rx1375_off
  rx1375_start:
    eq $I10, 1, rx1375_restart
    if_null rx1375_debug, debug_997
    rx1375_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1379_done
    goto rxscan1379_scan
  rxscan1379_loop:
    (rx1375_pos) = rx1375_cur."from"()
    inc rx1375_pos
    rx1375_cur."!cursor_from"(rx1375_pos)
    ge rx1375_pos, rx1375_eos, rxscan1379_done
  rxscan1379_scan:
    set_addr $I10, rxscan1379_loop
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  rxscan1379_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1380_fail
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  # rx literal  "?"
    add $I11, rx1375_pos, 1
    gt $I11, rx1375_eos, rx1375_fail
    sub $I11, rx1375_pos, rx1375_off
    ord $I11, rx1375_tgt, $I11
    ne $I11, 63, rx1375_fail
    add rx1375_pos, 1
    set_addr $I10, rxcap_1380_fail
    ($I12, $I11) = rx1375_cur."!mark_peek"($I10)
    rx1375_cur."!cursor_pos"($I11)
    ($P10) = rx1375_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1375_pos, "")
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1380_done
  rxcap_1380_fail:
    goto rx1375_fail
  rxcap_1380_done:
  # rx subrule "O" subtype=capture negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1375_fail
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1375_pos = $P10."pos"()
  # rx pass
    rx1375_cur."!cursor_pass"(rx1375_pos, "prefix:sym<?>")
    if_null rx1375_debug, debug_998
    rx1375_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1375_pos)
  debug_998:
    .return (rx1375_cur)
  rx1375_restart:
.annotate 'line', 4
    if_null rx1375_debug, debug_999
    rx1375_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_999:
  rx1375_fail:
    (rx1375_rep, rx1375_pos, $I10, $P10) = rx1375_cur."!mark_fail"(0)
    lt rx1375_pos, -1, rx1375_done
    eq rx1375_pos, -1, rx1375_fail
    jump $I10
  rx1375_done:
    rx1375_cur."!cursor_fail"()
    if_null rx1375_debug, debug_1000
    rx1375_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1000:
    .return (rx1375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("302_1300060177.262") :method
.annotate 'line', 4
    $P1377 = self."!PREFIX__!subrule"("O", "?")
    new $P1378, "ResizablePMCArray"
    push $P1378, $P1377
    .return ($P1378)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("303_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1382_tgt
    .local int rx1382_pos
    .local int rx1382_off
    .local int rx1382_eos
    .local int rx1382_rep
    .local pmc rx1382_cur
    .local pmc rx1382_debug
    (rx1382_cur, rx1382_pos, rx1382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1382_cur
    .local pmc match
    .lex "$/", match
    length rx1382_eos, rx1382_tgt
    gt rx1382_pos, rx1382_eos, rx1382_done
    set rx1382_off, 0
    lt rx1382_pos, 2, rx1382_start
    sub rx1382_off, rx1382_pos, 1
    substr rx1382_tgt, rx1382_tgt, rx1382_off
  rx1382_start:
    eq $I10, 1, rx1382_restart
    if_null rx1382_debug, debug_1001
    rx1382_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1386_done
    goto rxscan1386_scan
  rxscan1386_loop:
    (rx1382_pos) = rx1382_cur."from"()
    inc rx1382_pos
    rx1382_cur."!cursor_from"(rx1382_pos)
    ge rx1382_pos, rx1382_eos, rxscan1386_done
  rxscan1386_scan:
    set_addr $I10, rxscan1386_loop
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  rxscan1386_done:
.annotate 'line', 629
  # rx subcapture "sym"
    set_addr $I10, rxcap_1387_fail
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  # rx literal  "!"
    add $I11, rx1382_pos, 1
    gt $I11, rx1382_eos, rx1382_fail
    sub $I11, rx1382_pos, rx1382_off
    ord $I11, rx1382_tgt, $I11
    ne $I11, 33, rx1382_fail
    add rx1382_pos, 1
    set_addr $I10, rxcap_1387_fail
    ($I12, $I11) = rx1382_cur."!mark_peek"($I10)
    rx1382_cur."!cursor_pos"($I11)
    ($P10) = rx1382_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1382_pos, "")
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1387_done
  rxcap_1387_fail:
    goto rx1382_fail
  rxcap_1387_done:
  # rx subrule "O" subtype=capture negate=
    rx1382_cur."!cursor_pos"(rx1382_pos)
    $P10 = rx1382_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1382_fail
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1382_pos = $P10."pos"()
  # rx pass
    rx1382_cur."!cursor_pass"(rx1382_pos, "prefix:sym<!>")
    if_null rx1382_debug, debug_1002
    rx1382_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1382_pos)
  debug_1002:
    .return (rx1382_cur)
  rx1382_restart:
.annotate 'line', 4
    if_null rx1382_debug, debug_1003
    rx1382_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1003:
  rx1382_fail:
    (rx1382_rep, rx1382_pos, $I10, $P10) = rx1382_cur."!mark_fail"(0)
    lt rx1382_pos, -1, rx1382_done
    eq rx1382_pos, -1, rx1382_fail
    jump $I10
  rx1382_done:
    rx1382_cur."!cursor_fail"()
    if_null rx1382_debug, debug_1004
    rx1382_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1004:
    .return (rx1382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("304_1300060177.262") :method
.annotate 'line', 4
    $P1384 = self."!PREFIX__!subrule"("O", "!")
    new $P1385, "ResizablePMCArray"
    push $P1385, $P1384
    .return ($P1385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("305_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1389_tgt
    .local int rx1389_pos
    .local int rx1389_off
    .local int rx1389_eos
    .local int rx1389_rep
    .local pmc rx1389_cur
    .local pmc rx1389_debug
    (rx1389_cur, rx1389_pos, rx1389_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1389_cur
    .local pmc match
    .lex "$/", match
    length rx1389_eos, rx1389_tgt
    gt rx1389_pos, rx1389_eos, rx1389_done
    set rx1389_off, 0
    lt rx1389_pos, 2, rx1389_start
    sub rx1389_off, rx1389_pos, 1
    substr rx1389_tgt, rx1389_tgt, rx1389_off
  rx1389_start:
    eq $I10, 1, rx1389_restart
    if_null rx1389_debug, debug_1005
    rx1389_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1393_done
    goto rxscan1393_scan
  rxscan1393_loop:
    (rx1389_pos) = rx1389_cur."from"()
    inc rx1389_pos
    rx1389_cur."!cursor_from"(rx1389_pos)
    ge rx1389_pos, rx1389_eos, rxscan1393_done
  rxscan1393_scan:
    set_addr $I10, rxscan1393_loop
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  rxscan1393_done:
.annotate 'line', 630
  # rx subcapture "sym"
    set_addr $I10, rxcap_1394_fail
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  # rx literal  "|"
    add $I11, rx1389_pos, 1
    gt $I11, rx1389_eos, rx1389_fail
    sub $I11, rx1389_pos, rx1389_off
    ord $I11, rx1389_tgt, $I11
    ne $I11, 124, rx1389_fail
    add rx1389_pos, 1
    set_addr $I10, rxcap_1394_fail
    ($I12, $I11) = rx1389_cur."!mark_peek"($I10)
    rx1389_cur."!cursor_pos"($I11)
    ($P10) = rx1389_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1389_pos, "")
    rx1389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1394_done
  rxcap_1394_fail:
    goto rx1389_fail
  rxcap_1394_done:
  # rx subrule "O" subtype=capture negate=
    rx1389_cur."!cursor_pos"(rx1389_pos)
    $P10 = rx1389_cur."O"("%symbolic_unary")
    unless $P10, rx1389_fail
    rx1389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1389_pos = $P10."pos"()
  # rx pass
    rx1389_cur."!cursor_pass"(rx1389_pos, "prefix:sym<|>")
    if_null rx1389_debug, debug_1006
    rx1389_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1389_pos)
  debug_1006:
    .return (rx1389_cur)
  rx1389_restart:
.annotate 'line', 4
    if_null rx1389_debug, debug_1007
    rx1389_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1007:
  rx1389_fail:
    (rx1389_rep, rx1389_pos, $I10, $P10) = rx1389_cur."!mark_fail"(0)
    lt rx1389_pos, -1, rx1389_done
    eq rx1389_pos, -1, rx1389_fail
    jump $I10
  rx1389_done:
    rx1389_cur."!cursor_fail"()
    if_null rx1389_debug, debug_1008
    rx1389_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1008:
    .return (rx1389_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("306_1300060177.262") :method
.annotate 'line', 4
    $P1391 = self."!PREFIX__!subrule"("O", "|")
    new $P1392, "ResizablePMCArray"
    push $P1392, $P1391
    .return ($P1392)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("307_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1396_tgt
    .local int rx1396_pos
    .local int rx1396_off
    .local int rx1396_eos
    .local int rx1396_rep
    .local pmc rx1396_cur
    .local pmc rx1396_debug
    (rx1396_cur, rx1396_pos, rx1396_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1396_cur
    .local pmc match
    .lex "$/", match
    length rx1396_eos, rx1396_tgt
    gt rx1396_pos, rx1396_eos, rx1396_done
    set rx1396_off, 0
    lt rx1396_pos, 2, rx1396_start
    sub rx1396_off, rx1396_pos, 1
    substr rx1396_tgt, rx1396_tgt, rx1396_off
  rx1396_start:
    eq $I10, 1, rx1396_restart
    if_null rx1396_debug, debug_1009
    rx1396_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1400_done
    goto rxscan1400_scan
  rxscan1400_loop:
    (rx1396_pos) = rx1396_cur."from"()
    inc rx1396_pos
    rx1396_cur."!cursor_from"(rx1396_pos)
    ge rx1396_pos, rx1396_eos, rxscan1400_done
  rxscan1400_scan:
    set_addr $I10, rxscan1400_loop
    rx1396_cur."!mark_push"(0, rx1396_pos, $I10)
  rxscan1400_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1401_fail
    rx1396_cur."!mark_push"(0, rx1396_pos, $I10)
  # rx literal  "*"
    add $I11, rx1396_pos, 1
    gt $I11, rx1396_eos, rx1396_fail
    sub $I11, rx1396_pos, rx1396_off
    ord $I11, rx1396_tgt, $I11
    ne $I11, 42, rx1396_fail
    add rx1396_pos, 1
    set_addr $I10, rxcap_1401_fail
    ($I12, $I11) = rx1396_cur."!mark_peek"($I10)
    rx1396_cur."!cursor_pos"($I11)
    ($P10) = rx1396_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1396_pos, "")
    rx1396_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1401_done
  rxcap_1401_fail:
    goto rx1396_fail
  rxcap_1401_done:
  # rx subrule "O" subtype=capture negate=
    rx1396_cur."!cursor_pos"(rx1396_pos)
    $P10 = rx1396_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1396_fail
    rx1396_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1396_pos = $P10."pos"()
  # rx pass
    rx1396_cur."!cursor_pass"(rx1396_pos, "infix:sym<*>")
    if_null rx1396_debug, debug_1010
    rx1396_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1396_pos)
  debug_1010:
    .return (rx1396_cur)
  rx1396_restart:
.annotate 'line', 4
    if_null rx1396_debug, debug_1011
    rx1396_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1011:
  rx1396_fail:
    (rx1396_rep, rx1396_pos, $I10, $P10) = rx1396_cur."!mark_fail"(0)
    lt rx1396_pos, -1, rx1396_done
    eq rx1396_pos, -1, rx1396_fail
    jump $I10
  rx1396_done:
    rx1396_cur."!cursor_fail"()
    if_null rx1396_debug, debug_1012
    rx1396_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1012:
    .return (rx1396_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("308_1300060177.262") :method
.annotate 'line', 4
    $P1398 = self."!PREFIX__!subrule"("O", "*")
    new $P1399, "ResizablePMCArray"
    push $P1399, $P1398
    .return ($P1399)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("309_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1403_tgt
    .local int rx1403_pos
    .local int rx1403_off
    .local int rx1403_eos
    .local int rx1403_rep
    .local pmc rx1403_cur
    .local pmc rx1403_debug
    (rx1403_cur, rx1403_pos, rx1403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1403_cur
    .local pmc match
    .lex "$/", match
    length rx1403_eos, rx1403_tgt
    gt rx1403_pos, rx1403_eos, rx1403_done
    set rx1403_off, 0
    lt rx1403_pos, 2, rx1403_start
    sub rx1403_off, rx1403_pos, 1
    substr rx1403_tgt, rx1403_tgt, rx1403_off
  rx1403_start:
    eq $I10, 1, rx1403_restart
    if_null rx1403_debug, debug_1013
    rx1403_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1407_done
    goto rxscan1407_scan
  rxscan1407_loop:
    (rx1403_pos) = rx1403_cur."from"()
    inc rx1403_pos
    rx1403_cur."!cursor_from"(rx1403_pos)
    ge rx1403_pos, rx1403_eos, rxscan1407_done
  rxscan1407_scan:
    set_addr $I10, rxscan1407_loop
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  rxscan1407_done:
.annotate 'line', 633
  # rx subcapture "sym"
    set_addr $I10, rxcap_1408_fail
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  # rx literal  "/"
    add $I11, rx1403_pos, 1
    gt $I11, rx1403_eos, rx1403_fail
    sub $I11, rx1403_pos, rx1403_off
    ord $I11, rx1403_tgt, $I11
    ne $I11, 47, rx1403_fail
    add rx1403_pos, 1
    set_addr $I10, rxcap_1408_fail
    ($I12, $I11) = rx1403_cur."!mark_peek"($I10)
    rx1403_cur."!cursor_pos"($I11)
    ($P10) = rx1403_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1403_pos, "")
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1408_done
  rxcap_1408_fail:
    goto rx1403_fail
  rxcap_1408_done:
  # rx subrule "O" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1403_pos = $P10."pos"()
  # rx pass
    rx1403_cur."!cursor_pass"(rx1403_pos, "infix:sym</>")
    if_null rx1403_debug, debug_1014
    rx1403_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1403_pos)
  debug_1014:
    .return (rx1403_cur)
  rx1403_restart:
.annotate 'line', 4
    if_null rx1403_debug, debug_1015
    rx1403_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1015:
  rx1403_fail:
    (rx1403_rep, rx1403_pos, $I10, $P10) = rx1403_cur."!mark_fail"(0)
    lt rx1403_pos, -1, rx1403_done
    eq rx1403_pos, -1, rx1403_fail
    jump $I10
  rx1403_done:
    rx1403_cur."!cursor_fail"()
    if_null rx1403_debug, debug_1016
    rx1403_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1016:
    .return (rx1403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("310_1300060177.262") :method
.annotate 'line', 4
    $P1405 = self."!PREFIX__!subrule"("O", "/")
    new $P1406, "ResizablePMCArray"
    push $P1406, $P1405
    .return ($P1406)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("311_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1410_tgt
    .local int rx1410_pos
    .local int rx1410_off
    .local int rx1410_eos
    .local int rx1410_rep
    .local pmc rx1410_cur
    .local pmc rx1410_debug
    (rx1410_cur, rx1410_pos, rx1410_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1410_cur
    .local pmc match
    .lex "$/", match
    length rx1410_eos, rx1410_tgt
    gt rx1410_pos, rx1410_eos, rx1410_done
    set rx1410_off, 0
    lt rx1410_pos, 2, rx1410_start
    sub rx1410_off, rx1410_pos, 1
    substr rx1410_tgt, rx1410_tgt, rx1410_off
  rx1410_start:
    eq $I10, 1, rx1410_restart
    if_null rx1410_debug, debug_1017
    rx1410_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1414_done
    goto rxscan1414_scan
  rxscan1414_loop:
    (rx1410_pos) = rx1410_cur."from"()
    inc rx1410_pos
    rx1410_cur."!cursor_from"(rx1410_pos)
    ge rx1410_pos, rx1410_eos, rxscan1414_done
  rxscan1414_scan:
    set_addr $I10, rxscan1414_loop
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  rxscan1414_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1415_fail
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  # rx literal  "%"
    add $I11, rx1410_pos, 1
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    ord $I11, rx1410_tgt, $I11
    ne $I11, 37, rx1410_fail
    add rx1410_pos, 1
    set_addr $I10, rxcap_1415_fail
    ($I12, $I11) = rx1410_cur."!mark_peek"($I10)
    rx1410_cur."!cursor_pos"($I11)
    ($P10) = rx1410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1410_pos, "")
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1415_done
  rxcap_1415_fail:
    goto rx1410_fail
  rxcap_1415_done:
  # rx subrule "O" subtype=capture negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1410_fail
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1410_pos = $P10."pos"()
  # rx pass
    rx1410_cur."!cursor_pass"(rx1410_pos, "infix:sym<%>")
    if_null rx1410_debug, debug_1018
    rx1410_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1410_pos)
  debug_1018:
    .return (rx1410_cur)
  rx1410_restart:
.annotate 'line', 4
    if_null rx1410_debug, debug_1019
    rx1410_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1019:
  rx1410_fail:
    (rx1410_rep, rx1410_pos, $I10, $P10) = rx1410_cur."!mark_fail"(0)
    lt rx1410_pos, -1, rx1410_done
    eq rx1410_pos, -1, rx1410_fail
    jump $I10
  rx1410_done:
    rx1410_cur."!cursor_fail"()
    if_null rx1410_debug, debug_1020
    rx1410_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1020:
    .return (rx1410_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("312_1300060177.262") :method
.annotate 'line', 4
    $P1412 = self."!PREFIX__!subrule"("O", "%")
    new $P1413, "ResizablePMCArray"
    push $P1413, $P1412
    .return ($P1413)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("313_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1417_tgt
    .local int rx1417_pos
    .local int rx1417_off
    .local int rx1417_eos
    .local int rx1417_rep
    .local pmc rx1417_cur
    .local pmc rx1417_debug
    (rx1417_cur, rx1417_pos, rx1417_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1417_cur
    .local pmc match
    .lex "$/", match
    length rx1417_eos, rx1417_tgt
    gt rx1417_pos, rx1417_eos, rx1417_done
    set rx1417_off, 0
    lt rx1417_pos, 2, rx1417_start
    sub rx1417_off, rx1417_pos, 1
    substr rx1417_tgt, rx1417_tgt, rx1417_off
  rx1417_start:
    eq $I10, 1, rx1417_restart
    if_null rx1417_debug, debug_1021
    rx1417_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1421_done
    goto rxscan1421_scan
  rxscan1421_loop:
    (rx1417_pos) = rx1417_cur."from"()
    inc rx1417_pos
    rx1417_cur."!cursor_from"(rx1417_pos)
    ge rx1417_pos, rx1417_eos, rxscan1421_done
  rxscan1421_scan:
    set_addr $I10, rxscan1421_loop
    rx1417_cur."!mark_push"(0, rx1417_pos, $I10)
  rxscan1421_done:
.annotate 'line', 635
  # rx subcapture "sym"
    set_addr $I10, rxcap_1422_fail
    rx1417_cur."!mark_push"(0, rx1417_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1417_pos, 2
    gt $I11, rx1417_eos, rx1417_fail
    sub $I11, rx1417_pos, rx1417_off
    substr $S10, rx1417_tgt, $I11, 2
    ne $S10, "+&", rx1417_fail
    add rx1417_pos, 2
    set_addr $I10, rxcap_1422_fail
    ($I12, $I11) = rx1417_cur."!mark_peek"($I10)
    rx1417_cur."!cursor_pos"($I11)
    ($P10) = rx1417_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1417_pos, "")
    rx1417_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1422_done
  rxcap_1422_fail:
    goto rx1417_fail
  rxcap_1422_done:
  # rx subrule "O" subtype=capture negate=
    rx1417_cur."!cursor_pos"(rx1417_pos)
    $P10 = rx1417_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1417_fail
    rx1417_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1417_pos = $P10."pos"()
  # rx pass
    rx1417_cur."!cursor_pass"(rx1417_pos, "infix:sym<+&>")
    if_null rx1417_debug, debug_1022
    rx1417_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1417_pos)
  debug_1022:
    .return (rx1417_cur)
  rx1417_restart:
.annotate 'line', 4
    if_null rx1417_debug, debug_1023
    rx1417_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1023:
  rx1417_fail:
    (rx1417_rep, rx1417_pos, $I10, $P10) = rx1417_cur."!mark_fail"(0)
    lt rx1417_pos, -1, rx1417_done
    eq rx1417_pos, -1, rx1417_fail
    jump $I10
  rx1417_done:
    rx1417_cur."!cursor_fail"()
    if_null rx1417_debug, debug_1024
    rx1417_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1024:
    .return (rx1417_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("314_1300060177.262") :method
.annotate 'line', 4
    $P1419 = self."!PREFIX__!subrule"("O", "+&")
    new $P1420, "ResizablePMCArray"
    push $P1420, $P1419
    .return ($P1420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("315_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1424_tgt
    .local int rx1424_pos
    .local int rx1424_off
    .local int rx1424_eos
    .local int rx1424_rep
    .local pmc rx1424_cur
    .local pmc rx1424_debug
    (rx1424_cur, rx1424_pos, rx1424_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1424_cur
    .local pmc match
    .lex "$/", match
    length rx1424_eos, rx1424_tgt
    gt rx1424_pos, rx1424_eos, rx1424_done
    set rx1424_off, 0
    lt rx1424_pos, 2, rx1424_start
    sub rx1424_off, rx1424_pos, 1
    substr rx1424_tgt, rx1424_tgt, rx1424_off
  rx1424_start:
    eq $I10, 1, rx1424_restart
    if_null rx1424_debug, debug_1025
    rx1424_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1428_done
    goto rxscan1428_scan
  rxscan1428_loop:
    (rx1424_pos) = rx1424_cur."from"()
    inc rx1424_pos
    rx1424_cur."!cursor_from"(rx1424_pos)
    ge rx1424_pos, rx1424_eos, rxscan1428_done
  rxscan1428_scan:
    set_addr $I10, rxscan1428_loop
    rx1424_cur."!mark_push"(0, rx1424_pos, $I10)
  rxscan1428_done:
.annotate 'line', 637
  # rx subcapture "sym"
    set_addr $I10, rxcap_1429_fail
    rx1424_cur."!mark_push"(0, rx1424_pos, $I10)
  # rx literal  "+"
    add $I11, rx1424_pos, 1
    gt $I11, rx1424_eos, rx1424_fail
    sub $I11, rx1424_pos, rx1424_off
    ord $I11, rx1424_tgt, $I11
    ne $I11, 43, rx1424_fail
    add rx1424_pos, 1
    set_addr $I10, rxcap_1429_fail
    ($I12, $I11) = rx1424_cur."!mark_peek"($I10)
    rx1424_cur."!cursor_pos"($I11)
    ($P10) = rx1424_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1424_pos, "")
    rx1424_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1429_done
  rxcap_1429_fail:
    goto rx1424_fail
  rxcap_1429_done:
  # rx subrule "O" subtype=capture negate=
    rx1424_cur."!cursor_pos"(rx1424_pos)
    $P10 = rx1424_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1424_fail
    rx1424_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1424_pos = $P10."pos"()
  # rx pass
    rx1424_cur."!cursor_pass"(rx1424_pos, "infix:sym<+>")
    if_null rx1424_debug, debug_1026
    rx1424_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1424_pos)
  debug_1026:
    .return (rx1424_cur)
  rx1424_restart:
.annotate 'line', 4
    if_null rx1424_debug, debug_1027
    rx1424_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1027:
  rx1424_fail:
    (rx1424_rep, rx1424_pos, $I10, $P10) = rx1424_cur."!mark_fail"(0)
    lt rx1424_pos, -1, rx1424_done
    eq rx1424_pos, -1, rx1424_fail
    jump $I10
  rx1424_done:
    rx1424_cur."!cursor_fail"()
    if_null rx1424_debug, debug_1028
    rx1424_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1028:
    .return (rx1424_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("316_1300060177.262") :method
.annotate 'line', 4
    $P1426 = self."!PREFIX__!subrule"("O", "+")
    new $P1427, "ResizablePMCArray"
    push $P1427, $P1426
    .return ($P1427)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("317_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1431_tgt
    .local int rx1431_pos
    .local int rx1431_off
    .local int rx1431_eos
    .local int rx1431_rep
    .local pmc rx1431_cur
    .local pmc rx1431_debug
    (rx1431_cur, rx1431_pos, rx1431_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1431_cur
    .local pmc match
    .lex "$/", match
    length rx1431_eos, rx1431_tgt
    gt rx1431_pos, rx1431_eos, rx1431_done
    set rx1431_off, 0
    lt rx1431_pos, 2, rx1431_start
    sub rx1431_off, rx1431_pos, 1
    substr rx1431_tgt, rx1431_tgt, rx1431_off
  rx1431_start:
    eq $I10, 1, rx1431_restart
    if_null rx1431_debug, debug_1029
    rx1431_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1435_done
    goto rxscan1435_scan
  rxscan1435_loop:
    (rx1431_pos) = rx1431_cur."from"()
    inc rx1431_pos
    rx1431_cur."!cursor_from"(rx1431_pos)
    ge rx1431_pos, rx1431_eos, rxscan1435_done
  rxscan1435_scan:
    set_addr $I10, rxscan1435_loop
    rx1431_cur."!mark_push"(0, rx1431_pos, $I10)
  rxscan1435_done:
.annotate 'line', 638
  # rx subcapture "sym"
    set_addr $I10, rxcap_1436_fail
    rx1431_cur."!mark_push"(0, rx1431_pos, $I10)
  # rx literal  "-"
    add $I11, rx1431_pos, 1
    gt $I11, rx1431_eos, rx1431_fail
    sub $I11, rx1431_pos, rx1431_off
    ord $I11, rx1431_tgt, $I11
    ne $I11, 45, rx1431_fail
    add rx1431_pos, 1
    set_addr $I10, rxcap_1436_fail
    ($I12, $I11) = rx1431_cur."!mark_peek"($I10)
    rx1431_cur."!cursor_pos"($I11)
    ($P10) = rx1431_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1431_pos, "")
    rx1431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1436_done
  rxcap_1436_fail:
    goto rx1431_fail
  rxcap_1436_done:
  # rx subrule "O" subtype=capture negate=
    rx1431_cur."!cursor_pos"(rx1431_pos)
    $P10 = rx1431_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1431_fail
    rx1431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1431_pos = $P10."pos"()
  # rx pass
    rx1431_cur."!cursor_pass"(rx1431_pos, "infix:sym<->")
    if_null rx1431_debug, debug_1030
    rx1431_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1431_pos)
  debug_1030:
    .return (rx1431_cur)
  rx1431_restart:
.annotate 'line', 4
    if_null rx1431_debug, debug_1031
    rx1431_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1031:
  rx1431_fail:
    (rx1431_rep, rx1431_pos, $I10, $P10) = rx1431_cur."!mark_fail"(0)
    lt rx1431_pos, -1, rx1431_done
    eq rx1431_pos, -1, rx1431_fail
    jump $I10
  rx1431_done:
    rx1431_cur."!cursor_fail"()
    if_null rx1431_debug, debug_1032
    rx1431_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1032:
    .return (rx1431_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("318_1300060177.262") :method
.annotate 'line', 4
    $P1433 = self."!PREFIX__!subrule"("O", "-")
    new $P1434, "ResizablePMCArray"
    push $P1434, $P1433
    .return ($P1434)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("319_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1438_tgt
    .local int rx1438_pos
    .local int rx1438_off
    .local int rx1438_eos
    .local int rx1438_rep
    .local pmc rx1438_cur
    .local pmc rx1438_debug
    (rx1438_cur, rx1438_pos, rx1438_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1438_cur
    .local pmc match
    .lex "$/", match
    length rx1438_eos, rx1438_tgt
    gt rx1438_pos, rx1438_eos, rx1438_done
    set rx1438_off, 0
    lt rx1438_pos, 2, rx1438_start
    sub rx1438_off, rx1438_pos, 1
    substr rx1438_tgt, rx1438_tgt, rx1438_off
  rx1438_start:
    eq $I10, 1, rx1438_restart
    if_null rx1438_debug, debug_1033
    rx1438_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1442_done
    goto rxscan1442_scan
  rxscan1442_loop:
    (rx1438_pos) = rx1438_cur."from"()
    inc rx1438_pos
    rx1438_cur."!cursor_from"(rx1438_pos)
    ge rx1438_pos, rx1438_eos, rxscan1442_done
  rxscan1442_scan:
    set_addr $I10, rxscan1442_loop
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  rxscan1442_done:
.annotate 'line', 639
  # rx subcapture "sym"
    set_addr $I10, rxcap_1443_fail
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1438_pos, 2
    gt $I11, rx1438_eos, rx1438_fail
    sub $I11, rx1438_pos, rx1438_off
    substr $S10, rx1438_tgt, $I11, 2
    ne $S10, "+|", rx1438_fail
    add rx1438_pos, 2
    set_addr $I10, rxcap_1443_fail
    ($I12, $I11) = rx1438_cur."!mark_peek"($I10)
    rx1438_cur."!cursor_pos"($I11)
    ($P10) = rx1438_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1438_pos, "")
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1443_done
  rxcap_1443_fail:
    goto rx1438_fail
  rxcap_1443_done:
  # rx subrule "O" subtype=capture negate=
    rx1438_cur."!cursor_pos"(rx1438_pos)
    $P10 = rx1438_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1438_fail
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1438_pos = $P10."pos"()
  # rx pass
    rx1438_cur."!cursor_pass"(rx1438_pos, "infix:sym<+|>")
    if_null rx1438_debug, debug_1034
    rx1438_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1438_pos)
  debug_1034:
    .return (rx1438_cur)
  rx1438_restart:
.annotate 'line', 4
    if_null rx1438_debug, debug_1035
    rx1438_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1035:
  rx1438_fail:
    (rx1438_rep, rx1438_pos, $I10, $P10) = rx1438_cur."!mark_fail"(0)
    lt rx1438_pos, -1, rx1438_done
    eq rx1438_pos, -1, rx1438_fail
    jump $I10
  rx1438_done:
    rx1438_cur."!cursor_fail"()
    if_null rx1438_debug, debug_1036
    rx1438_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1036:
    .return (rx1438_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("320_1300060177.262") :method
.annotate 'line', 4
    $P1440 = self."!PREFIX__!subrule"("O", "+|")
    new $P1441, "ResizablePMCArray"
    push $P1441, $P1440
    .return ($P1441)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("321_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1445_tgt
    .local int rx1445_pos
    .local int rx1445_off
    .local int rx1445_eos
    .local int rx1445_rep
    .local pmc rx1445_cur
    .local pmc rx1445_debug
    (rx1445_cur, rx1445_pos, rx1445_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1445_cur
    .local pmc match
    .lex "$/", match
    length rx1445_eos, rx1445_tgt
    gt rx1445_pos, rx1445_eos, rx1445_done
    set rx1445_off, 0
    lt rx1445_pos, 2, rx1445_start
    sub rx1445_off, rx1445_pos, 1
    substr rx1445_tgt, rx1445_tgt, rx1445_off
  rx1445_start:
    eq $I10, 1, rx1445_restart
    if_null rx1445_debug, debug_1037
    rx1445_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1449_done
    goto rxscan1449_scan
  rxscan1449_loop:
    (rx1445_pos) = rx1445_cur."from"()
    inc rx1445_pos
    rx1445_cur."!cursor_from"(rx1445_pos)
    ge rx1445_pos, rx1445_eos, rxscan1449_done
  rxscan1449_scan:
    set_addr $I10, rxscan1449_loop
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  rxscan1449_done:
.annotate 'line', 640
  # rx subcapture "sym"
    set_addr $I10, rxcap_1450_fail
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1445_pos, 2
    gt $I11, rx1445_eos, rx1445_fail
    sub $I11, rx1445_pos, rx1445_off
    substr $S10, rx1445_tgt, $I11, 2
    ne $S10, "+^", rx1445_fail
    add rx1445_pos, 2
    set_addr $I10, rxcap_1450_fail
    ($I12, $I11) = rx1445_cur."!mark_peek"($I10)
    rx1445_cur."!cursor_pos"($I11)
    ($P10) = rx1445_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1445_pos, "")
    rx1445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1450_done
  rxcap_1450_fail:
    goto rx1445_fail
  rxcap_1450_done:
  # rx subrule "O" subtype=capture negate=
    rx1445_cur."!cursor_pos"(rx1445_pos)
    $P10 = rx1445_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1445_fail
    rx1445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1445_pos = $P10."pos"()
  # rx pass
    rx1445_cur."!cursor_pass"(rx1445_pos, "infix:sym<+^>")
    if_null rx1445_debug, debug_1038
    rx1445_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1445_pos)
  debug_1038:
    .return (rx1445_cur)
  rx1445_restart:
.annotate 'line', 4
    if_null rx1445_debug, debug_1039
    rx1445_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1039:
  rx1445_fail:
    (rx1445_rep, rx1445_pos, $I10, $P10) = rx1445_cur."!mark_fail"(0)
    lt rx1445_pos, -1, rx1445_done
    eq rx1445_pos, -1, rx1445_fail
    jump $I10
  rx1445_done:
    rx1445_cur."!cursor_fail"()
    if_null rx1445_debug, debug_1040
    rx1445_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1040:
    .return (rx1445_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("322_1300060177.262") :method
.annotate 'line', 4
    $P1447 = self."!PREFIX__!subrule"("O", "+^")
    new $P1448, "ResizablePMCArray"
    push $P1448, $P1447
    .return ($P1448)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("323_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1452_tgt
    .local int rx1452_pos
    .local int rx1452_off
    .local int rx1452_eos
    .local int rx1452_rep
    .local pmc rx1452_cur
    .local pmc rx1452_debug
    (rx1452_cur, rx1452_pos, rx1452_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1452_cur
    .local pmc match
    .lex "$/", match
    length rx1452_eos, rx1452_tgt
    gt rx1452_pos, rx1452_eos, rx1452_done
    set rx1452_off, 0
    lt rx1452_pos, 2, rx1452_start
    sub rx1452_off, rx1452_pos, 1
    substr rx1452_tgt, rx1452_tgt, rx1452_off
  rx1452_start:
    eq $I10, 1, rx1452_restart
    if_null rx1452_debug, debug_1041
    rx1452_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1456_done
    goto rxscan1456_scan
  rxscan1456_loop:
    (rx1452_pos) = rx1452_cur."from"()
    inc rx1452_pos
    rx1452_cur."!cursor_from"(rx1452_pos)
    ge rx1452_pos, rx1452_eos, rxscan1456_done
  rxscan1456_scan:
    set_addr $I10, rxscan1456_loop
    rx1452_cur."!mark_push"(0, rx1452_pos, $I10)
  rxscan1456_done:
.annotate 'line', 642
  # rx subcapture "sym"
    set_addr $I10, rxcap_1457_fail
    rx1452_cur."!mark_push"(0, rx1452_pos, $I10)
  # rx literal  "~"
    add $I11, rx1452_pos, 1
    gt $I11, rx1452_eos, rx1452_fail
    sub $I11, rx1452_pos, rx1452_off
    ord $I11, rx1452_tgt, $I11
    ne $I11, 126, rx1452_fail
    add rx1452_pos, 1
    set_addr $I10, rxcap_1457_fail
    ($I12, $I11) = rx1452_cur."!mark_peek"($I10)
    rx1452_cur."!cursor_pos"($I11)
    ($P10) = rx1452_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1452_pos, "")
    rx1452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1457_done
  rxcap_1457_fail:
    goto rx1452_fail
  rxcap_1457_done:
  # rx subrule "O" subtype=capture negate=
    rx1452_cur."!cursor_pos"(rx1452_pos)
    $P10 = rx1452_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1452_fail
    rx1452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1452_pos = $P10."pos"()
  # rx pass
    rx1452_cur."!cursor_pass"(rx1452_pos, "infix:sym<~>")
    if_null rx1452_debug, debug_1042
    rx1452_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1452_pos)
  debug_1042:
    .return (rx1452_cur)
  rx1452_restart:
.annotate 'line', 4
    if_null rx1452_debug, debug_1043
    rx1452_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1043:
  rx1452_fail:
    (rx1452_rep, rx1452_pos, $I10, $P10) = rx1452_cur."!mark_fail"(0)
    lt rx1452_pos, -1, rx1452_done
    eq rx1452_pos, -1, rx1452_fail
    jump $I10
  rx1452_done:
    rx1452_cur."!cursor_fail"()
    if_null rx1452_debug, debug_1044
    rx1452_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1044:
    .return (rx1452_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("324_1300060177.262") :method
.annotate 'line', 4
    $P1454 = self."!PREFIX__!subrule"("O", "~")
    new $P1455, "ResizablePMCArray"
    push $P1455, $P1454
    .return ($P1455)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("325_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1459_tgt
    .local int rx1459_pos
    .local int rx1459_off
    .local int rx1459_eos
    .local int rx1459_rep
    .local pmc rx1459_cur
    .local pmc rx1459_debug
    (rx1459_cur, rx1459_pos, rx1459_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1459_cur
    .local pmc match
    .lex "$/", match
    length rx1459_eos, rx1459_tgt
    gt rx1459_pos, rx1459_eos, rx1459_done
    set rx1459_off, 0
    lt rx1459_pos, 2, rx1459_start
    sub rx1459_off, rx1459_pos, 1
    substr rx1459_tgt, rx1459_tgt, rx1459_off
  rx1459_start:
    eq $I10, 1, rx1459_restart
    if_null rx1459_debug, debug_1045
    rx1459_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1463_done
    goto rxscan1463_scan
  rxscan1463_loop:
    (rx1459_pos) = rx1459_cur."from"()
    inc rx1459_pos
    rx1459_cur."!cursor_from"(rx1459_pos)
    ge rx1459_pos, rx1459_eos, rxscan1463_done
  rxscan1463_scan:
    set_addr $I10, rxscan1463_loop
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  rxscan1463_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1464_fail
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  # rx literal  "=="
    add $I11, rx1459_pos, 2
    gt $I11, rx1459_eos, rx1459_fail
    sub $I11, rx1459_pos, rx1459_off
    substr $S10, rx1459_tgt, $I11, 2
    ne $S10, "==", rx1459_fail
    add rx1459_pos, 2
    set_addr $I10, rxcap_1464_fail
    ($I12, $I11) = rx1459_cur."!mark_peek"($I10)
    rx1459_cur."!cursor_pos"($I11)
    ($P10) = rx1459_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1459_pos, "")
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1464_done
  rxcap_1464_fail:
    goto rx1459_fail
  rxcap_1464_done:
  # rx subrule "O" subtype=capture negate=
    rx1459_cur."!cursor_pos"(rx1459_pos)
    $P10 = rx1459_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1459_fail
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1459_pos = $P10."pos"()
  # rx pass
    rx1459_cur."!cursor_pass"(rx1459_pos, "infix:sym<==>")
    if_null rx1459_debug, debug_1046
    rx1459_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1459_pos)
  debug_1046:
    .return (rx1459_cur)
  rx1459_restart:
.annotate 'line', 4
    if_null rx1459_debug, debug_1047
    rx1459_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1047:
  rx1459_fail:
    (rx1459_rep, rx1459_pos, $I10, $P10) = rx1459_cur."!mark_fail"(0)
    lt rx1459_pos, -1, rx1459_done
    eq rx1459_pos, -1, rx1459_fail
    jump $I10
  rx1459_done:
    rx1459_cur."!cursor_fail"()
    if_null rx1459_debug, debug_1048
    rx1459_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1048:
    .return (rx1459_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("326_1300060177.262") :method
.annotate 'line', 4
    $P1461 = self."!PREFIX__!subrule"("O", "==")
    new $P1462, "ResizablePMCArray"
    push $P1462, $P1461
    .return ($P1462)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("327_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1466_tgt
    .local int rx1466_pos
    .local int rx1466_off
    .local int rx1466_eos
    .local int rx1466_rep
    .local pmc rx1466_cur
    .local pmc rx1466_debug
    (rx1466_cur, rx1466_pos, rx1466_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1466_cur
    .local pmc match
    .lex "$/", match
    length rx1466_eos, rx1466_tgt
    gt rx1466_pos, rx1466_eos, rx1466_done
    set rx1466_off, 0
    lt rx1466_pos, 2, rx1466_start
    sub rx1466_off, rx1466_pos, 1
    substr rx1466_tgt, rx1466_tgt, rx1466_off
  rx1466_start:
    eq $I10, 1, rx1466_restart
    if_null rx1466_debug, debug_1049
    rx1466_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1470_done
    goto rxscan1470_scan
  rxscan1470_loop:
    (rx1466_pos) = rx1466_cur."from"()
    inc rx1466_pos
    rx1466_cur."!cursor_from"(rx1466_pos)
    ge rx1466_pos, rx1466_eos, rxscan1470_done
  rxscan1470_scan:
    set_addr $I10, rxscan1470_loop
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  rxscan1470_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1471_fail
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  # rx literal  "!="
    add $I11, rx1466_pos, 2
    gt $I11, rx1466_eos, rx1466_fail
    sub $I11, rx1466_pos, rx1466_off
    substr $S10, rx1466_tgt, $I11, 2
    ne $S10, "!=", rx1466_fail
    add rx1466_pos, 2
    set_addr $I10, rxcap_1471_fail
    ($I12, $I11) = rx1466_cur."!mark_peek"($I10)
    rx1466_cur."!cursor_pos"($I11)
    ($P10) = rx1466_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1466_pos, "")
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1471_done
  rxcap_1471_fail:
    goto rx1466_fail
  rxcap_1471_done:
  # rx subrule "O" subtype=capture negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1466_fail
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1466_pos = $P10."pos"()
  # rx pass
    rx1466_cur."!cursor_pass"(rx1466_pos, "infix:sym<!=>")
    if_null rx1466_debug, debug_1050
    rx1466_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1466_pos)
  debug_1050:
    .return (rx1466_cur)
  rx1466_restart:
.annotate 'line', 4
    if_null rx1466_debug, debug_1051
    rx1466_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1051:
  rx1466_fail:
    (rx1466_rep, rx1466_pos, $I10, $P10) = rx1466_cur."!mark_fail"(0)
    lt rx1466_pos, -1, rx1466_done
    eq rx1466_pos, -1, rx1466_fail
    jump $I10
  rx1466_done:
    rx1466_cur."!cursor_fail"()
    if_null rx1466_debug, debug_1052
    rx1466_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1052:
    .return (rx1466_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("328_1300060177.262") :method
.annotate 'line', 4
    $P1468 = self."!PREFIX__!subrule"("O", "!=")
    new $P1469, "ResizablePMCArray"
    push $P1469, $P1468
    .return ($P1469)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("329_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1473_tgt
    .local int rx1473_pos
    .local int rx1473_off
    .local int rx1473_eos
    .local int rx1473_rep
    .local pmc rx1473_cur
    .local pmc rx1473_debug
    (rx1473_cur, rx1473_pos, rx1473_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1473_cur
    .local pmc match
    .lex "$/", match
    length rx1473_eos, rx1473_tgt
    gt rx1473_pos, rx1473_eos, rx1473_done
    set rx1473_off, 0
    lt rx1473_pos, 2, rx1473_start
    sub rx1473_off, rx1473_pos, 1
    substr rx1473_tgt, rx1473_tgt, rx1473_off
  rx1473_start:
    eq $I10, 1, rx1473_restart
    if_null rx1473_debug, debug_1053
    rx1473_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1477_done
    goto rxscan1477_scan
  rxscan1477_loop:
    (rx1473_pos) = rx1473_cur."from"()
    inc rx1473_pos
    rx1473_cur."!cursor_from"(rx1473_pos)
    ge rx1473_pos, rx1473_eos, rxscan1477_done
  rxscan1477_scan:
    set_addr $I10, rxscan1477_loop
    rx1473_cur."!mark_push"(0, rx1473_pos, $I10)
  rxscan1477_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1478_fail
    rx1473_cur."!mark_push"(0, rx1473_pos, $I10)
  # rx literal  "<="
    add $I11, rx1473_pos, 2
    gt $I11, rx1473_eos, rx1473_fail
    sub $I11, rx1473_pos, rx1473_off
    substr $S10, rx1473_tgt, $I11, 2
    ne $S10, "<=", rx1473_fail
    add rx1473_pos, 2
    set_addr $I10, rxcap_1478_fail
    ($I12, $I11) = rx1473_cur."!mark_peek"($I10)
    rx1473_cur."!cursor_pos"($I11)
    ($P10) = rx1473_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1473_pos, "")
    rx1473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1478_done
  rxcap_1478_fail:
    goto rx1473_fail
  rxcap_1478_done:
  # rx subrule "O" subtype=capture negate=
    rx1473_cur."!cursor_pos"(rx1473_pos)
    $P10 = rx1473_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1473_fail
    rx1473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1473_pos = $P10."pos"()
  # rx pass
    rx1473_cur."!cursor_pass"(rx1473_pos, "infix:sym<<=>")
    if_null rx1473_debug, debug_1054
    rx1473_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1473_pos)
  debug_1054:
    .return (rx1473_cur)
  rx1473_restart:
.annotate 'line', 4
    if_null rx1473_debug, debug_1055
    rx1473_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1055:
  rx1473_fail:
    (rx1473_rep, rx1473_pos, $I10, $P10) = rx1473_cur."!mark_fail"(0)
    lt rx1473_pos, -1, rx1473_done
    eq rx1473_pos, -1, rx1473_fail
    jump $I10
  rx1473_done:
    rx1473_cur."!cursor_fail"()
    if_null rx1473_debug, debug_1056
    rx1473_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1056:
    .return (rx1473_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("330_1300060177.262") :method
.annotate 'line', 4
    $P1475 = self."!PREFIX__!subrule"("O", "<=")
    new $P1476, "ResizablePMCArray"
    push $P1476, $P1475
    .return ($P1476)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("331_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1480_tgt
    .local int rx1480_pos
    .local int rx1480_off
    .local int rx1480_eos
    .local int rx1480_rep
    .local pmc rx1480_cur
    .local pmc rx1480_debug
    (rx1480_cur, rx1480_pos, rx1480_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1480_cur
    .local pmc match
    .lex "$/", match
    length rx1480_eos, rx1480_tgt
    gt rx1480_pos, rx1480_eos, rx1480_done
    set rx1480_off, 0
    lt rx1480_pos, 2, rx1480_start
    sub rx1480_off, rx1480_pos, 1
    substr rx1480_tgt, rx1480_tgt, rx1480_off
  rx1480_start:
    eq $I10, 1, rx1480_restart
    if_null rx1480_debug, debug_1057
    rx1480_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1484_done
    goto rxscan1484_scan
  rxscan1484_loop:
    (rx1480_pos) = rx1480_cur."from"()
    inc rx1480_pos
    rx1480_cur."!cursor_from"(rx1480_pos)
    ge rx1480_pos, rx1480_eos, rxscan1484_done
  rxscan1484_scan:
    set_addr $I10, rxscan1484_loop
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  rxscan1484_done:
.annotate 'line', 647
  # rx subcapture "sym"
    set_addr $I10, rxcap_1485_fail
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  # rx literal  ">="
    add $I11, rx1480_pos, 2
    gt $I11, rx1480_eos, rx1480_fail
    sub $I11, rx1480_pos, rx1480_off
    substr $S10, rx1480_tgt, $I11, 2
    ne $S10, ">=", rx1480_fail
    add rx1480_pos, 2
    set_addr $I10, rxcap_1485_fail
    ($I12, $I11) = rx1480_cur."!mark_peek"($I10)
    rx1480_cur."!cursor_pos"($I11)
    ($P10) = rx1480_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1480_pos, "")
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1485_done
  rxcap_1485_fail:
    goto rx1480_fail
  rxcap_1485_done:
  # rx subrule "O" subtype=capture negate=
    rx1480_cur."!cursor_pos"(rx1480_pos)
    $P10 = rx1480_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1480_fail
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1480_pos = $P10."pos"()
  # rx pass
    rx1480_cur."!cursor_pass"(rx1480_pos, "infix:sym<>=>")
    if_null rx1480_debug, debug_1058
    rx1480_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1480_pos)
  debug_1058:
    .return (rx1480_cur)
  rx1480_restart:
.annotate 'line', 4
    if_null rx1480_debug, debug_1059
    rx1480_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1059:
  rx1480_fail:
    (rx1480_rep, rx1480_pos, $I10, $P10) = rx1480_cur."!mark_fail"(0)
    lt rx1480_pos, -1, rx1480_done
    eq rx1480_pos, -1, rx1480_fail
    jump $I10
  rx1480_done:
    rx1480_cur."!cursor_fail"()
    if_null rx1480_debug, debug_1060
    rx1480_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1060:
    .return (rx1480_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("332_1300060177.262") :method
.annotate 'line', 4
    $P1482 = self."!PREFIX__!subrule"("O", ">=")
    new $P1483, "ResizablePMCArray"
    push $P1483, $P1482
    .return ($P1483)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("333_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1487_tgt
    .local int rx1487_pos
    .local int rx1487_off
    .local int rx1487_eos
    .local int rx1487_rep
    .local pmc rx1487_cur
    .local pmc rx1487_debug
    (rx1487_cur, rx1487_pos, rx1487_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1487_cur
    .local pmc match
    .lex "$/", match
    length rx1487_eos, rx1487_tgt
    gt rx1487_pos, rx1487_eos, rx1487_done
    set rx1487_off, 0
    lt rx1487_pos, 2, rx1487_start
    sub rx1487_off, rx1487_pos, 1
    substr rx1487_tgt, rx1487_tgt, rx1487_off
  rx1487_start:
    eq $I10, 1, rx1487_restart
    if_null rx1487_debug, debug_1061
    rx1487_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1491_done
    goto rxscan1491_scan
  rxscan1491_loop:
    (rx1487_pos) = rx1487_cur."from"()
    inc rx1487_pos
    rx1487_cur."!cursor_from"(rx1487_pos)
    ge rx1487_pos, rx1487_eos, rxscan1491_done
  rxscan1491_scan:
    set_addr $I10, rxscan1491_loop
    rx1487_cur."!mark_push"(0, rx1487_pos, $I10)
  rxscan1491_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1492_fail
    rx1487_cur."!mark_push"(0, rx1487_pos, $I10)
  # rx literal  "<"
    add $I11, rx1487_pos, 1
    gt $I11, rx1487_eos, rx1487_fail
    sub $I11, rx1487_pos, rx1487_off
    ord $I11, rx1487_tgt, $I11
    ne $I11, 60, rx1487_fail
    add rx1487_pos, 1
    set_addr $I10, rxcap_1492_fail
    ($I12, $I11) = rx1487_cur."!mark_peek"($I10)
    rx1487_cur."!cursor_pos"($I11)
    ($P10) = rx1487_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1487_pos, "")
    rx1487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1492_done
  rxcap_1492_fail:
    goto rx1487_fail
  rxcap_1492_done:
  # rx subrule "O" subtype=capture negate=
    rx1487_cur."!cursor_pos"(rx1487_pos)
    $P10 = rx1487_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1487_fail
    rx1487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1487_pos = $P10."pos"()
  # rx pass
    rx1487_cur."!cursor_pass"(rx1487_pos, "infix:sym<<>")
    if_null rx1487_debug, debug_1062
    rx1487_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1487_pos)
  debug_1062:
    .return (rx1487_cur)
  rx1487_restart:
.annotate 'line', 4
    if_null rx1487_debug, debug_1063
    rx1487_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1063:
  rx1487_fail:
    (rx1487_rep, rx1487_pos, $I10, $P10) = rx1487_cur."!mark_fail"(0)
    lt rx1487_pos, -1, rx1487_done
    eq rx1487_pos, -1, rx1487_fail
    jump $I10
  rx1487_done:
    rx1487_cur."!cursor_fail"()
    if_null rx1487_debug, debug_1064
    rx1487_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1064:
    .return (rx1487_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("334_1300060177.262") :method
.annotate 'line', 4
    $P1489 = self."!PREFIX__!subrule"("O", "<")
    new $P1490, "ResizablePMCArray"
    push $P1490, $P1489
    .return ($P1490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("335_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1494_tgt
    .local int rx1494_pos
    .local int rx1494_off
    .local int rx1494_eos
    .local int rx1494_rep
    .local pmc rx1494_cur
    .local pmc rx1494_debug
    (rx1494_cur, rx1494_pos, rx1494_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1494_cur
    .local pmc match
    .lex "$/", match
    length rx1494_eos, rx1494_tgt
    gt rx1494_pos, rx1494_eos, rx1494_done
    set rx1494_off, 0
    lt rx1494_pos, 2, rx1494_start
    sub rx1494_off, rx1494_pos, 1
    substr rx1494_tgt, rx1494_tgt, rx1494_off
  rx1494_start:
    eq $I10, 1, rx1494_restart
    if_null rx1494_debug, debug_1065
    rx1494_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1498_done
    goto rxscan1498_scan
  rxscan1498_loop:
    (rx1494_pos) = rx1494_cur."from"()
    inc rx1494_pos
    rx1494_cur."!cursor_from"(rx1494_pos)
    ge rx1494_pos, rx1494_eos, rxscan1498_done
  rxscan1498_scan:
    set_addr $I10, rxscan1498_loop
    rx1494_cur."!mark_push"(0, rx1494_pos, $I10)
  rxscan1498_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1499_fail
    rx1494_cur."!mark_push"(0, rx1494_pos, $I10)
  # rx literal  ">"
    add $I11, rx1494_pos, 1
    gt $I11, rx1494_eos, rx1494_fail
    sub $I11, rx1494_pos, rx1494_off
    ord $I11, rx1494_tgt, $I11
    ne $I11, 62, rx1494_fail
    add rx1494_pos, 1
    set_addr $I10, rxcap_1499_fail
    ($I12, $I11) = rx1494_cur."!mark_peek"($I10)
    rx1494_cur."!cursor_pos"($I11)
    ($P10) = rx1494_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1494_pos, "")
    rx1494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1499_done
  rxcap_1499_fail:
    goto rx1494_fail
  rxcap_1499_done:
  # rx subrule "O" subtype=capture negate=
    rx1494_cur."!cursor_pos"(rx1494_pos)
    $P10 = rx1494_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1494_fail
    rx1494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1494_pos = $P10."pos"()
  # rx pass
    rx1494_cur."!cursor_pass"(rx1494_pos, "infix:sym<>>")
    if_null rx1494_debug, debug_1066
    rx1494_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1494_pos)
  debug_1066:
    .return (rx1494_cur)
  rx1494_restart:
.annotate 'line', 4
    if_null rx1494_debug, debug_1067
    rx1494_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1067:
  rx1494_fail:
    (rx1494_rep, rx1494_pos, $I10, $P10) = rx1494_cur."!mark_fail"(0)
    lt rx1494_pos, -1, rx1494_done
    eq rx1494_pos, -1, rx1494_fail
    jump $I10
  rx1494_done:
    rx1494_cur."!cursor_fail"()
    if_null rx1494_debug, debug_1068
    rx1494_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1068:
    .return (rx1494_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("336_1300060177.262") :method
.annotate 'line', 4
    $P1496 = self."!PREFIX__!subrule"("O", ">")
    new $P1497, "ResizablePMCArray"
    push $P1497, $P1496
    .return ($P1497)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("337_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1501_tgt
    .local int rx1501_pos
    .local int rx1501_off
    .local int rx1501_eos
    .local int rx1501_rep
    .local pmc rx1501_cur
    .local pmc rx1501_debug
    (rx1501_cur, rx1501_pos, rx1501_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1501_cur
    .local pmc match
    .lex "$/", match
    length rx1501_eos, rx1501_tgt
    gt rx1501_pos, rx1501_eos, rx1501_done
    set rx1501_off, 0
    lt rx1501_pos, 2, rx1501_start
    sub rx1501_off, rx1501_pos, 1
    substr rx1501_tgt, rx1501_tgt, rx1501_off
  rx1501_start:
    eq $I10, 1, rx1501_restart
    if_null rx1501_debug, debug_1069
    rx1501_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1505_done
    goto rxscan1505_scan
  rxscan1505_loop:
    (rx1501_pos) = rx1501_cur."from"()
    inc rx1501_pos
    rx1501_cur."!cursor_from"(rx1501_pos)
    ge rx1501_pos, rx1501_eos, rxscan1505_done
  rxscan1505_scan:
    set_addr $I10, rxscan1505_loop
    rx1501_cur."!mark_push"(0, rx1501_pos, $I10)
  rxscan1505_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1506_fail
    rx1501_cur."!mark_push"(0, rx1501_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1501_pos, 2
    gt $I11, rx1501_eos, rx1501_fail
    sub $I11, rx1501_pos, rx1501_off
    substr $S10, rx1501_tgt, $I11, 2
    ne $S10, "eq", rx1501_fail
    add rx1501_pos, 2
    set_addr $I10, rxcap_1506_fail
    ($I12, $I11) = rx1501_cur."!mark_peek"($I10)
    rx1501_cur."!cursor_pos"($I11)
    ($P10) = rx1501_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1501_pos, "")
    rx1501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1506_done
  rxcap_1506_fail:
    goto rx1501_fail
  rxcap_1506_done:
  # rx subrule "O" subtype=capture negate=
    rx1501_cur."!cursor_pos"(rx1501_pos)
    $P10 = rx1501_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1501_fail
    rx1501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1501_pos = $P10."pos"()
  # rx pass
    rx1501_cur."!cursor_pass"(rx1501_pos, "infix:sym<eq>")
    if_null rx1501_debug, debug_1070
    rx1501_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1501_pos)
  debug_1070:
    .return (rx1501_cur)
  rx1501_restart:
.annotate 'line', 4
    if_null rx1501_debug, debug_1071
    rx1501_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1071:
  rx1501_fail:
    (rx1501_rep, rx1501_pos, $I10, $P10) = rx1501_cur."!mark_fail"(0)
    lt rx1501_pos, -1, rx1501_done
    eq rx1501_pos, -1, rx1501_fail
    jump $I10
  rx1501_done:
    rx1501_cur."!cursor_fail"()
    if_null rx1501_debug, debug_1072
    rx1501_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1072:
    .return (rx1501_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("338_1300060177.262") :method
.annotate 'line', 4
    $P1503 = self."!PREFIX__!subrule"("O", "eq")
    new $P1504, "ResizablePMCArray"
    push $P1504, $P1503
    .return ($P1504)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("339_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1508_tgt
    .local int rx1508_pos
    .local int rx1508_off
    .local int rx1508_eos
    .local int rx1508_rep
    .local pmc rx1508_cur
    .local pmc rx1508_debug
    (rx1508_cur, rx1508_pos, rx1508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1508_cur
    .local pmc match
    .lex "$/", match
    length rx1508_eos, rx1508_tgt
    gt rx1508_pos, rx1508_eos, rx1508_done
    set rx1508_off, 0
    lt rx1508_pos, 2, rx1508_start
    sub rx1508_off, rx1508_pos, 1
    substr rx1508_tgt, rx1508_tgt, rx1508_off
  rx1508_start:
    eq $I10, 1, rx1508_restart
    if_null rx1508_debug, debug_1073
    rx1508_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1512_done
    goto rxscan1512_scan
  rxscan1512_loop:
    (rx1508_pos) = rx1508_cur."from"()
    inc rx1508_pos
    rx1508_cur."!cursor_from"(rx1508_pos)
    ge rx1508_pos, rx1508_eos, rxscan1512_done
  rxscan1512_scan:
    set_addr $I10, rxscan1512_loop
    rx1508_cur."!mark_push"(0, rx1508_pos, $I10)
  rxscan1512_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1513_fail
    rx1508_cur."!mark_push"(0, rx1508_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1508_pos, 2
    gt $I11, rx1508_eos, rx1508_fail
    sub $I11, rx1508_pos, rx1508_off
    substr $S10, rx1508_tgt, $I11, 2
    ne $S10, "ne", rx1508_fail
    add rx1508_pos, 2
    set_addr $I10, rxcap_1513_fail
    ($I12, $I11) = rx1508_cur."!mark_peek"($I10)
    rx1508_cur."!cursor_pos"($I11)
    ($P10) = rx1508_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1508_pos, "")
    rx1508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1513_done
  rxcap_1513_fail:
    goto rx1508_fail
  rxcap_1513_done:
  # rx subrule "O" subtype=capture negate=
    rx1508_cur."!cursor_pos"(rx1508_pos)
    $P10 = rx1508_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1508_fail
    rx1508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1508_pos = $P10."pos"()
  # rx pass
    rx1508_cur."!cursor_pass"(rx1508_pos, "infix:sym<ne>")
    if_null rx1508_debug, debug_1074
    rx1508_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1508_pos)
  debug_1074:
    .return (rx1508_cur)
  rx1508_restart:
.annotate 'line', 4
    if_null rx1508_debug, debug_1075
    rx1508_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1075:
  rx1508_fail:
    (rx1508_rep, rx1508_pos, $I10, $P10) = rx1508_cur."!mark_fail"(0)
    lt rx1508_pos, -1, rx1508_done
    eq rx1508_pos, -1, rx1508_fail
    jump $I10
  rx1508_done:
    rx1508_cur."!cursor_fail"()
    if_null rx1508_debug, debug_1076
    rx1508_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1076:
    .return (rx1508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("340_1300060177.262") :method
.annotate 'line', 4
    $P1510 = self."!PREFIX__!subrule"("O", "ne")
    new $P1511, "ResizablePMCArray"
    push $P1511, $P1510
    .return ($P1511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("341_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1515_tgt
    .local int rx1515_pos
    .local int rx1515_off
    .local int rx1515_eos
    .local int rx1515_rep
    .local pmc rx1515_cur
    .local pmc rx1515_debug
    (rx1515_cur, rx1515_pos, rx1515_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1515_cur
    .local pmc match
    .lex "$/", match
    length rx1515_eos, rx1515_tgt
    gt rx1515_pos, rx1515_eos, rx1515_done
    set rx1515_off, 0
    lt rx1515_pos, 2, rx1515_start
    sub rx1515_off, rx1515_pos, 1
    substr rx1515_tgt, rx1515_tgt, rx1515_off
  rx1515_start:
    eq $I10, 1, rx1515_restart
    if_null rx1515_debug, debug_1077
    rx1515_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1519_done
    goto rxscan1519_scan
  rxscan1519_loop:
    (rx1515_pos) = rx1515_cur."from"()
    inc rx1515_pos
    rx1515_cur."!cursor_from"(rx1515_pos)
    ge rx1515_pos, rx1515_eos, rxscan1519_done
  rxscan1519_scan:
    set_addr $I10, rxscan1519_loop
    rx1515_cur."!mark_push"(0, rx1515_pos, $I10)
  rxscan1519_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1520_fail
    rx1515_cur."!mark_push"(0, rx1515_pos, $I10)
  # rx literal  "le"
    add $I11, rx1515_pos, 2
    gt $I11, rx1515_eos, rx1515_fail
    sub $I11, rx1515_pos, rx1515_off
    substr $S10, rx1515_tgt, $I11, 2
    ne $S10, "le", rx1515_fail
    add rx1515_pos, 2
    set_addr $I10, rxcap_1520_fail
    ($I12, $I11) = rx1515_cur."!mark_peek"($I10)
    rx1515_cur."!cursor_pos"($I11)
    ($P10) = rx1515_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1515_pos, "")
    rx1515_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1520_done
  rxcap_1520_fail:
    goto rx1515_fail
  rxcap_1520_done:
  # rx subrule "O" subtype=capture negate=
    rx1515_cur."!cursor_pos"(rx1515_pos)
    $P10 = rx1515_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1515_fail
    rx1515_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1515_pos = $P10."pos"()
  # rx pass
    rx1515_cur."!cursor_pass"(rx1515_pos, "infix:sym<le>")
    if_null rx1515_debug, debug_1078
    rx1515_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1515_pos)
  debug_1078:
    .return (rx1515_cur)
  rx1515_restart:
.annotate 'line', 4
    if_null rx1515_debug, debug_1079
    rx1515_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1079:
  rx1515_fail:
    (rx1515_rep, rx1515_pos, $I10, $P10) = rx1515_cur."!mark_fail"(0)
    lt rx1515_pos, -1, rx1515_done
    eq rx1515_pos, -1, rx1515_fail
    jump $I10
  rx1515_done:
    rx1515_cur."!cursor_fail"()
    if_null rx1515_debug, debug_1080
    rx1515_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1080:
    .return (rx1515_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("342_1300060177.262") :method
.annotate 'line', 4
    $P1517 = self."!PREFIX__!subrule"("O", "le")
    new $P1518, "ResizablePMCArray"
    push $P1518, $P1517
    .return ($P1518)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("343_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1522_tgt
    .local int rx1522_pos
    .local int rx1522_off
    .local int rx1522_eos
    .local int rx1522_rep
    .local pmc rx1522_cur
    .local pmc rx1522_debug
    (rx1522_cur, rx1522_pos, rx1522_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1522_cur
    .local pmc match
    .lex "$/", match
    length rx1522_eos, rx1522_tgt
    gt rx1522_pos, rx1522_eos, rx1522_done
    set rx1522_off, 0
    lt rx1522_pos, 2, rx1522_start
    sub rx1522_off, rx1522_pos, 1
    substr rx1522_tgt, rx1522_tgt, rx1522_off
  rx1522_start:
    eq $I10, 1, rx1522_restart
    if_null rx1522_debug, debug_1081
    rx1522_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1526_done
    goto rxscan1526_scan
  rxscan1526_loop:
    (rx1522_pos) = rx1522_cur."from"()
    inc rx1522_pos
    rx1522_cur."!cursor_from"(rx1522_pos)
    ge rx1522_pos, rx1522_eos, rxscan1526_done
  rxscan1526_scan:
    set_addr $I10, rxscan1526_loop
    rx1522_cur."!mark_push"(0, rx1522_pos, $I10)
  rxscan1526_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1527_fail
    rx1522_cur."!mark_push"(0, rx1522_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1522_pos, 2
    gt $I11, rx1522_eos, rx1522_fail
    sub $I11, rx1522_pos, rx1522_off
    substr $S10, rx1522_tgt, $I11, 2
    ne $S10, "ge", rx1522_fail
    add rx1522_pos, 2
    set_addr $I10, rxcap_1527_fail
    ($I12, $I11) = rx1522_cur."!mark_peek"($I10)
    rx1522_cur."!cursor_pos"($I11)
    ($P10) = rx1522_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1522_pos, "")
    rx1522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1527_done
  rxcap_1527_fail:
    goto rx1522_fail
  rxcap_1527_done:
  # rx subrule "O" subtype=capture negate=
    rx1522_cur."!cursor_pos"(rx1522_pos)
    $P10 = rx1522_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1522_fail
    rx1522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1522_pos = $P10."pos"()
  # rx pass
    rx1522_cur."!cursor_pass"(rx1522_pos, "infix:sym<ge>")
    if_null rx1522_debug, debug_1082
    rx1522_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1522_pos)
  debug_1082:
    .return (rx1522_cur)
  rx1522_restart:
.annotate 'line', 4
    if_null rx1522_debug, debug_1083
    rx1522_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1083:
  rx1522_fail:
    (rx1522_rep, rx1522_pos, $I10, $P10) = rx1522_cur."!mark_fail"(0)
    lt rx1522_pos, -1, rx1522_done
    eq rx1522_pos, -1, rx1522_fail
    jump $I10
  rx1522_done:
    rx1522_cur."!cursor_fail"()
    if_null rx1522_debug, debug_1084
    rx1522_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1084:
    .return (rx1522_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("344_1300060177.262") :method
.annotate 'line', 4
    $P1524 = self."!PREFIX__!subrule"("O", "ge")
    new $P1525, "ResizablePMCArray"
    push $P1525, $P1524
    .return ($P1525)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("345_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1529_tgt
    .local int rx1529_pos
    .local int rx1529_off
    .local int rx1529_eos
    .local int rx1529_rep
    .local pmc rx1529_cur
    .local pmc rx1529_debug
    (rx1529_cur, rx1529_pos, rx1529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1529_cur
    .local pmc match
    .lex "$/", match
    length rx1529_eos, rx1529_tgt
    gt rx1529_pos, rx1529_eos, rx1529_done
    set rx1529_off, 0
    lt rx1529_pos, 2, rx1529_start
    sub rx1529_off, rx1529_pos, 1
    substr rx1529_tgt, rx1529_tgt, rx1529_off
  rx1529_start:
    eq $I10, 1, rx1529_restart
    if_null rx1529_debug, debug_1085
    rx1529_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1533_done
    goto rxscan1533_scan
  rxscan1533_loop:
    (rx1529_pos) = rx1529_cur."from"()
    inc rx1529_pos
    rx1529_cur."!cursor_from"(rx1529_pos)
    ge rx1529_pos, rx1529_eos, rxscan1533_done
  rxscan1533_scan:
    set_addr $I10, rxscan1533_loop
    rx1529_cur."!mark_push"(0, rx1529_pos, $I10)
  rxscan1533_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1534_fail
    rx1529_cur."!mark_push"(0, rx1529_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1529_pos, 2
    gt $I11, rx1529_eos, rx1529_fail
    sub $I11, rx1529_pos, rx1529_off
    substr $S10, rx1529_tgt, $I11, 2
    ne $S10, "lt", rx1529_fail
    add rx1529_pos, 2
    set_addr $I10, rxcap_1534_fail
    ($I12, $I11) = rx1529_cur."!mark_peek"($I10)
    rx1529_cur."!cursor_pos"($I11)
    ($P10) = rx1529_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1529_pos, "")
    rx1529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1534_done
  rxcap_1534_fail:
    goto rx1529_fail
  rxcap_1534_done:
  # rx subrule "O" subtype=capture negate=
    rx1529_cur."!cursor_pos"(rx1529_pos)
    $P10 = rx1529_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1529_fail
    rx1529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1529_pos = $P10."pos"()
  # rx pass
    rx1529_cur."!cursor_pass"(rx1529_pos, "infix:sym<lt>")
    if_null rx1529_debug, debug_1086
    rx1529_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1529_pos)
  debug_1086:
    .return (rx1529_cur)
  rx1529_restart:
.annotate 'line', 4
    if_null rx1529_debug, debug_1087
    rx1529_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1087:
  rx1529_fail:
    (rx1529_rep, rx1529_pos, $I10, $P10) = rx1529_cur."!mark_fail"(0)
    lt rx1529_pos, -1, rx1529_done
    eq rx1529_pos, -1, rx1529_fail
    jump $I10
  rx1529_done:
    rx1529_cur."!cursor_fail"()
    if_null rx1529_debug, debug_1088
    rx1529_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1088:
    .return (rx1529_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("346_1300060177.262") :method
.annotate 'line', 4
    $P1531 = self."!PREFIX__!subrule"("O", "lt")
    new $P1532, "ResizablePMCArray"
    push $P1532, $P1531
    .return ($P1532)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("347_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1536_tgt
    .local int rx1536_pos
    .local int rx1536_off
    .local int rx1536_eos
    .local int rx1536_rep
    .local pmc rx1536_cur
    .local pmc rx1536_debug
    (rx1536_cur, rx1536_pos, rx1536_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1536_cur
    .local pmc match
    .lex "$/", match
    length rx1536_eos, rx1536_tgt
    gt rx1536_pos, rx1536_eos, rx1536_done
    set rx1536_off, 0
    lt rx1536_pos, 2, rx1536_start
    sub rx1536_off, rx1536_pos, 1
    substr rx1536_tgt, rx1536_tgt, rx1536_off
  rx1536_start:
    eq $I10, 1, rx1536_restart
    if_null rx1536_debug, debug_1089
    rx1536_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1540_done
    goto rxscan1540_scan
  rxscan1540_loop:
    (rx1536_pos) = rx1536_cur."from"()
    inc rx1536_pos
    rx1536_cur."!cursor_from"(rx1536_pos)
    ge rx1536_pos, rx1536_eos, rxscan1540_done
  rxscan1540_scan:
    set_addr $I10, rxscan1540_loop
    rx1536_cur."!mark_push"(0, rx1536_pos, $I10)
  rxscan1540_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1541_fail
    rx1536_cur."!mark_push"(0, rx1536_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1536_pos, 2
    gt $I11, rx1536_eos, rx1536_fail
    sub $I11, rx1536_pos, rx1536_off
    substr $S10, rx1536_tgt, $I11, 2
    ne $S10, "gt", rx1536_fail
    add rx1536_pos, 2
    set_addr $I10, rxcap_1541_fail
    ($I12, $I11) = rx1536_cur."!mark_peek"($I10)
    rx1536_cur."!cursor_pos"($I11)
    ($P10) = rx1536_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1536_pos, "")
    rx1536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1541_done
  rxcap_1541_fail:
    goto rx1536_fail
  rxcap_1541_done:
  # rx subrule "O" subtype=capture negate=
    rx1536_cur."!cursor_pos"(rx1536_pos)
    $P10 = rx1536_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1536_fail
    rx1536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1536_pos = $P10."pos"()
  # rx pass
    rx1536_cur."!cursor_pass"(rx1536_pos, "infix:sym<gt>")
    if_null rx1536_debug, debug_1090
    rx1536_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1536_pos)
  debug_1090:
    .return (rx1536_cur)
  rx1536_restart:
.annotate 'line', 4
    if_null rx1536_debug, debug_1091
    rx1536_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1091:
  rx1536_fail:
    (rx1536_rep, rx1536_pos, $I10, $P10) = rx1536_cur."!mark_fail"(0)
    lt rx1536_pos, -1, rx1536_done
    eq rx1536_pos, -1, rx1536_fail
    jump $I10
  rx1536_done:
    rx1536_cur."!cursor_fail"()
    if_null rx1536_debug, debug_1092
    rx1536_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1092:
    .return (rx1536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("348_1300060177.262") :method
.annotate 'line', 4
    $P1538 = self."!PREFIX__!subrule"("O", "gt")
    new $P1539, "ResizablePMCArray"
    push $P1539, $P1538
    .return ($P1539)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("349_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1093
    rx1543_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1547_done
    goto rxscan1547_scan
  rxscan1547_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1547_done
  rxscan1547_scan:
    set_addr $I10, rxscan1547_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1547_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1548_fail
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1543_pos, 3
    gt $I11, rx1543_eos, rx1543_fail
    sub $I11, rx1543_pos, rx1543_off
    substr $S10, rx1543_tgt, $I11, 3
    ne $S10, "=:=", rx1543_fail
    add rx1543_pos, 3
    set_addr $I10, rxcap_1548_fail
    ($I12, $I11) = rx1543_cur."!mark_peek"($I10)
    rx1543_cur."!cursor_pos"($I11)
    ($P10) = rx1543_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1543_pos, "")
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1548_done
  rxcap_1548_fail:
    goto rx1543_fail
  rxcap_1548_done:
  # rx subrule "O" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "infix:sym<=:=>")
    if_null rx1543_debug, debug_1094
    rx1543_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1543_pos)
  debug_1094:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 4
    if_null rx1543_debug, debug_1095
    rx1543_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1095:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1096
    rx1543_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1096:
    .return (rx1543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("350_1300060177.262") :method
.annotate 'line', 4
    $P1545 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1546, "ResizablePMCArray"
    push $P1546, $P1545
    .return ($P1546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("351_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1550_tgt
    .local int rx1550_pos
    .local int rx1550_off
    .local int rx1550_eos
    .local int rx1550_rep
    .local pmc rx1550_cur
    .local pmc rx1550_debug
    (rx1550_cur, rx1550_pos, rx1550_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1550_cur
    .local pmc match
    .lex "$/", match
    length rx1550_eos, rx1550_tgt
    gt rx1550_pos, rx1550_eos, rx1550_done
    set rx1550_off, 0
    lt rx1550_pos, 2, rx1550_start
    sub rx1550_off, rx1550_pos, 1
    substr rx1550_tgt, rx1550_tgt, rx1550_off
  rx1550_start:
    eq $I10, 1, rx1550_restart
    if_null rx1550_debug, debug_1097
    rx1550_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1554_done
    goto rxscan1554_scan
  rxscan1554_loop:
    (rx1550_pos) = rx1550_cur."from"()
    inc rx1550_pos
    rx1550_cur."!cursor_from"(rx1550_pos)
    ge rx1550_pos, rx1550_eos, rxscan1554_done
  rxscan1554_scan:
    set_addr $I10, rxscan1554_loop
    rx1550_cur."!mark_push"(0, rx1550_pos, $I10)
  rxscan1554_done:
.annotate 'line', 657
  # rx subcapture "sym"
    set_addr $I10, rxcap_1555_fail
    rx1550_cur."!mark_push"(0, rx1550_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1550_pos, 2
    gt $I11, rx1550_eos, rx1550_fail
    sub $I11, rx1550_pos, rx1550_off
    substr $S10, rx1550_tgt, $I11, 2
    ne $S10, "~~", rx1550_fail
    add rx1550_pos, 2
    set_addr $I10, rxcap_1555_fail
    ($I12, $I11) = rx1550_cur."!mark_peek"($I10)
    rx1550_cur."!cursor_pos"($I11)
    ($P10) = rx1550_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1550_pos, "")
    rx1550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1555_done
  rxcap_1555_fail:
    goto rx1550_fail
  rxcap_1555_done:
  # rx subrule "O" subtype=capture negate=
    rx1550_cur."!cursor_pos"(rx1550_pos)
    $P10 = rx1550_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1550_fail
    rx1550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1550_pos = $P10."pos"()
  # rx pass
    rx1550_cur."!cursor_pass"(rx1550_pos, "infix:sym<~~>")
    if_null rx1550_debug, debug_1098
    rx1550_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1550_pos)
  debug_1098:
    .return (rx1550_cur)
  rx1550_restart:
.annotate 'line', 4
    if_null rx1550_debug, debug_1099
    rx1550_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1099:
  rx1550_fail:
    (rx1550_rep, rx1550_pos, $I10, $P10) = rx1550_cur."!mark_fail"(0)
    lt rx1550_pos, -1, rx1550_done
    eq rx1550_pos, -1, rx1550_fail
    jump $I10
  rx1550_done:
    rx1550_cur."!cursor_fail"()
    if_null rx1550_debug, debug_1100
    rx1550_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1100:
    .return (rx1550_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("352_1300060177.262") :method
.annotate 'line', 4
    $P1552 = self."!PREFIX__!subrule"("O", "~~")
    new $P1553, "ResizablePMCArray"
    push $P1553, $P1552
    .return ($P1553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("353_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1557_tgt
    .local int rx1557_pos
    .local int rx1557_off
    .local int rx1557_eos
    .local int rx1557_rep
    .local pmc rx1557_cur
    .local pmc rx1557_debug
    (rx1557_cur, rx1557_pos, rx1557_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1557_cur
    .local pmc match
    .lex "$/", match
    length rx1557_eos, rx1557_tgt
    gt rx1557_pos, rx1557_eos, rx1557_done
    set rx1557_off, 0
    lt rx1557_pos, 2, rx1557_start
    sub rx1557_off, rx1557_pos, 1
    substr rx1557_tgt, rx1557_tgt, rx1557_off
  rx1557_start:
    eq $I10, 1, rx1557_restart
    if_null rx1557_debug, debug_1101
    rx1557_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1101:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1561_done
    goto rxscan1561_scan
  rxscan1561_loop:
    (rx1557_pos) = rx1557_cur."from"()
    inc rx1557_pos
    rx1557_cur."!cursor_from"(rx1557_pos)
    ge rx1557_pos, rx1557_eos, rxscan1561_done
  rxscan1561_scan:
    set_addr $I10, rxscan1561_loop
    rx1557_cur."!mark_push"(0, rx1557_pos, $I10)
  rxscan1561_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1562_fail
    rx1557_cur."!mark_push"(0, rx1557_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1557_pos, 2
    gt $I11, rx1557_eos, rx1557_fail
    sub $I11, rx1557_pos, rx1557_off
    substr $S10, rx1557_tgt, $I11, 2
    ne $S10, "&&", rx1557_fail
    add rx1557_pos, 2
    set_addr $I10, rxcap_1562_fail
    ($I12, $I11) = rx1557_cur."!mark_peek"($I10)
    rx1557_cur."!cursor_pos"($I11)
    ($P10) = rx1557_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1557_pos, "")
    rx1557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1562_done
  rxcap_1562_fail:
    goto rx1557_fail
  rxcap_1562_done:
  # rx subrule "O" subtype=capture negate=
    rx1557_cur."!cursor_pos"(rx1557_pos)
    $P10 = rx1557_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1557_fail
    rx1557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1557_pos = $P10."pos"()
  # rx pass
    rx1557_cur."!cursor_pass"(rx1557_pos, "infix:sym<&&>")
    if_null rx1557_debug, debug_1102
    rx1557_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1557_pos)
  debug_1102:
    .return (rx1557_cur)
  rx1557_restart:
.annotate 'line', 4
    if_null rx1557_debug, debug_1103
    rx1557_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1103:
  rx1557_fail:
    (rx1557_rep, rx1557_pos, $I10, $P10) = rx1557_cur."!mark_fail"(0)
    lt rx1557_pos, -1, rx1557_done
    eq rx1557_pos, -1, rx1557_fail
    jump $I10
  rx1557_done:
    rx1557_cur."!cursor_fail"()
    if_null rx1557_debug, debug_1104
    rx1557_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1104:
    .return (rx1557_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("354_1300060177.262") :method
.annotate 'line', 4
    $P1559 = self."!PREFIX__!subrule"("O", "&&")
    new $P1560, "ResizablePMCArray"
    push $P1560, $P1559
    .return ($P1560)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("355_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1564_tgt
    .local int rx1564_pos
    .local int rx1564_off
    .local int rx1564_eos
    .local int rx1564_rep
    .local pmc rx1564_cur
    .local pmc rx1564_debug
    (rx1564_cur, rx1564_pos, rx1564_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1564_cur
    .local pmc match
    .lex "$/", match
    length rx1564_eos, rx1564_tgt
    gt rx1564_pos, rx1564_eos, rx1564_done
    set rx1564_off, 0
    lt rx1564_pos, 2, rx1564_start
    sub rx1564_off, rx1564_pos, 1
    substr rx1564_tgt, rx1564_tgt, rx1564_off
  rx1564_start:
    eq $I10, 1, rx1564_restart
    if_null rx1564_debug, debug_1105
    rx1564_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1105:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1568_done
    goto rxscan1568_scan
  rxscan1568_loop:
    (rx1564_pos) = rx1564_cur."from"()
    inc rx1564_pos
    rx1564_cur."!cursor_from"(rx1564_pos)
    ge rx1564_pos, rx1564_eos, rxscan1568_done
  rxscan1568_scan:
    set_addr $I10, rxscan1568_loop
    rx1564_cur."!mark_push"(0, rx1564_pos, $I10)
  rxscan1568_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1569_fail
    rx1564_cur."!mark_push"(0, rx1564_pos, $I10)
  # rx literal  "||"
    add $I11, rx1564_pos, 2
    gt $I11, rx1564_eos, rx1564_fail
    sub $I11, rx1564_pos, rx1564_off
    substr $S10, rx1564_tgt, $I11, 2
    ne $S10, "||", rx1564_fail
    add rx1564_pos, 2
    set_addr $I10, rxcap_1569_fail
    ($I12, $I11) = rx1564_cur."!mark_peek"($I10)
    rx1564_cur."!cursor_pos"($I11)
    ($P10) = rx1564_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1564_pos, "")
    rx1564_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1569_done
  rxcap_1569_fail:
    goto rx1564_fail
  rxcap_1569_done:
  # rx subrule "O" subtype=capture negate=
    rx1564_cur."!cursor_pos"(rx1564_pos)
    $P10 = rx1564_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1564_fail
    rx1564_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1564_pos = $P10."pos"()
  # rx pass
    rx1564_cur."!cursor_pass"(rx1564_pos, "infix:sym<||>")
    if_null rx1564_debug, debug_1106
    rx1564_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1564_pos)
  debug_1106:
    .return (rx1564_cur)
  rx1564_restart:
.annotate 'line', 4
    if_null rx1564_debug, debug_1107
    rx1564_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1107:
  rx1564_fail:
    (rx1564_rep, rx1564_pos, $I10, $P10) = rx1564_cur."!mark_fail"(0)
    lt rx1564_pos, -1, rx1564_done
    eq rx1564_pos, -1, rx1564_fail
    jump $I10
  rx1564_done:
    rx1564_cur."!cursor_fail"()
    if_null rx1564_debug, debug_1108
    rx1564_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1108:
    .return (rx1564_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("356_1300060177.262") :method
.annotate 'line', 4
    $P1566 = self."!PREFIX__!subrule"("O", "||")
    new $P1567, "ResizablePMCArray"
    push $P1567, $P1566
    .return ($P1567)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("357_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1571_tgt
    .local int rx1571_pos
    .local int rx1571_off
    .local int rx1571_eos
    .local int rx1571_rep
    .local pmc rx1571_cur
    .local pmc rx1571_debug
    (rx1571_cur, rx1571_pos, rx1571_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1571_cur
    .local pmc match
    .lex "$/", match
    length rx1571_eos, rx1571_tgt
    gt rx1571_pos, rx1571_eos, rx1571_done
    set rx1571_off, 0
    lt rx1571_pos, 2, rx1571_start
    sub rx1571_off, rx1571_pos, 1
    substr rx1571_tgt, rx1571_tgt, rx1571_off
  rx1571_start:
    eq $I10, 1, rx1571_restart
    if_null rx1571_debug, debug_1109
    rx1571_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1109:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1575_done
    goto rxscan1575_scan
  rxscan1575_loop:
    (rx1571_pos) = rx1571_cur."from"()
    inc rx1571_pos
    rx1571_cur."!cursor_from"(rx1571_pos)
    ge rx1571_pos, rx1571_eos, rxscan1575_done
  rxscan1575_scan:
    set_addr $I10, rxscan1575_loop
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  rxscan1575_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1576_fail
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  # rx literal  "//"
    add $I11, rx1571_pos, 2
    gt $I11, rx1571_eos, rx1571_fail
    sub $I11, rx1571_pos, rx1571_off
    substr $S10, rx1571_tgt, $I11, 2
    ne $S10, "//", rx1571_fail
    add rx1571_pos, 2
    set_addr $I10, rxcap_1576_fail
    ($I12, $I11) = rx1571_cur."!mark_peek"($I10)
    rx1571_cur."!cursor_pos"($I11)
    ($P10) = rx1571_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1571_pos, "")
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1576_done
  rxcap_1576_fail:
    goto rx1571_fail
  rxcap_1576_done:
  # rx subrule "O" subtype=capture negate=
    rx1571_cur."!cursor_pos"(rx1571_pos)
    $P10 = rx1571_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1571_fail
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1571_pos = $P10."pos"()
  # rx pass
    rx1571_cur."!cursor_pass"(rx1571_pos, "infix:sym<//>")
    if_null rx1571_debug, debug_1110
    rx1571_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1571_pos)
  debug_1110:
    .return (rx1571_cur)
  rx1571_restart:
.annotate 'line', 4
    if_null rx1571_debug, debug_1111
    rx1571_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1111:
  rx1571_fail:
    (rx1571_rep, rx1571_pos, $I10, $P10) = rx1571_cur."!mark_fail"(0)
    lt rx1571_pos, -1, rx1571_done
    eq rx1571_pos, -1, rx1571_fail
    jump $I10
  rx1571_done:
    rx1571_cur."!cursor_fail"()
    if_null rx1571_debug, debug_1112
    rx1571_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1112:
    .return (rx1571_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("358_1300060177.262") :method
.annotate 'line', 4
    $P1573 = self."!PREFIX__!subrule"("O", "//")
    new $P1574, "ResizablePMCArray"
    push $P1574, $P1573
    .return ($P1574)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("359_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1578_tgt
    .local int rx1578_pos
    .local int rx1578_off
    .local int rx1578_eos
    .local int rx1578_rep
    .local pmc rx1578_cur
    .local pmc rx1578_debug
    (rx1578_cur, rx1578_pos, rx1578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1578_cur
    .local pmc match
    .lex "$/", match
    length rx1578_eos, rx1578_tgt
    gt rx1578_pos, rx1578_eos, rx1578_done
    set rx1578_off, 0
    lt rx1578_pos, 2, rx1578_start
    sub rx1578_off, rx1578_pos, 1
    substr rx1578_tgt, rx1578_tgt, rx1578_off
  rx1578_start:
    eq $I10, 1, rx1578_restart
    if_null rx1578_debug, debug_1113
    rx1578_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1113:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1582_done
    goto rxscan1582_scan
  rxscan1582_loop:
    (rx1578_pos) = rx1578_cur."from"()
    inc rx1578_pos
    rx1578_cur."!cursor_from"(rx1578_pos)
    ge rx1578_pos, rx1578_eos, rxscan1582_done
  rxscan1582_scan:
    set_addr $I10, rxscan1582_loop
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  rxscan1582_done:
.annotate 'line', 665
  # rx literal  "??"
    add $I11, rx1578_pos, 2
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    substr $S10, rx1578_tgt, $I11, 2
    ne $S10, "??", rx1578_fail
    add rx1578_pos, 2
.annotate 'line', 666
  # rx subrule "ws" subtype=method negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."ws"()
    unless $P10, rx1578_fail
    rx1578_pos = $P10."pos"()
.annotate 'line', 667
  # rx subrule "EXPR" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."EXPR"("i=")
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1578_pos = $P10."pos"()
.annotate 'line', 668
  # rx literal  "!!"
    add $I11, rx1578_pos, 2
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    substr $S10, rx1578_tgt, $I11, 2
    ne $S10, "!!", rx1578_fail
    add rx1578_pos, 2
.annotate 'line', 669
  # rx subrule "O" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1578_pos = $P10."pos"()
.annotate 'line', 664
  # rx pass
    rx1578_cur."!cursor_pass"(rx1578_pos, "infix:sym<?? !!>")
    if_null rx1578_debug, debug_1114
    rx1578_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1578_pos)
  debug_1114:
    .return (rx1578_cur)
  rx1578_restart:
.annotate 'line', 4
    if_null rx1578_debug, debug_1115
    rx1578_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1115:
  rx1578_fail:
    (rx1578_rep, rx1578_pos, $I10, $P10) = rx1578_cur."!mark_fail"(0)
    lt rx1578_pos, -1, rx1578_done
    eq rx1578_pos, -1, rx1578_fail
    jump $I10
  rx1578_done:
    rx1578_cur."!cursor_fail"()
    if_null rx1578_debug, debug_1116
    rx1578_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1116:
    .return (rx1578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("360_1300060177.262") :method
.annotate 'line', 4
    $P1580 = self."!PREFIX__!subrule"("ws", "??")
    new $P1581, "ResizablePMCArray"
    push $P1581, $P1580
    .return ($P1581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("361_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1117
    rx1584_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1117:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1588_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1589_fail
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  # rx literal  "="
    add $I11, rx1584_pos, 1
    gt $I11, rx1584_eos, rx1584_fail
    sub $I11, rx1584_pos, rx1584_off
    ord $I11, rx1584_tgt, $I11
    ne $I11, 61, rx1584_fail
    add rx1584_pos, 1
    set_addr $I10, rxcap_1589_fail
    ($I12, $I11) = rx1584_cur."!mark_peek"($I10)
    rx1584_cur."!cursor_pos"($I11)
    ($P10) = rx1584_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1584_pos, "")
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1589_done
  rxcap_1589_fail:
    goto rx1584_fail
  rxcap_1589_done:
  # rx subrule "panic" subtype=method negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1584_fail
    rx1584_pos = $P10."pos"()
.annotate 'line', 672
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "infix:sym<=>")
    if_null rx1584_debug, debug_1118
    rx1584_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1584_pos)
  debug_1118:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 4
    if_null rx1584_debug, debug_1119
    rx1584_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1119:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1120
    rx1584_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1120:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("362_1300060177.262") :method
.annotate 'line', 4
    $P1586 = self."!PREFIX__!subrule"("panic", "=")
    new $P1587, "ResizablePMCArray"
    push $P1587, $P1586
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("363_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1591_tgt
    .local int rx1591_pos
    .local int rx1591_off
    .local int rx1591_eos
    .local int rx1591_rep
    .local pmc rx1591_cur
    .local pmc rx1591_debug
    (rx1591_cur, rx1591_pos, rx1591_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1591_cur
    .local pmc match
    .lex "$/", match
    length rx1591_eos, rx1591_tgt
    gt rx1591_pos, rx1591_eos, rx1591_done
    set rx1591_off, 0
    lt rx1591_pos, 2, rx1591_start
    sub rx1591_off, rx1591_pos, 1
    substr rx1591_tgt, rx1591_tgt, rx1591_off
  rx1591_start:
    eq $I10, 1, rx1591_restart
    if_null rx1591_debug, debug_1121
    rx1591_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1121:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1591_pos) = rx1591_cur."from"()
    inc rx1591_pos
    rx1591_cur."!cursor_from"(rx1591_pos)
    ge rx1591_pos, rx1591_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxscan1595_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1596_fail
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  # rx literal  ":="
    add $I11, rx1591_pos, 2
    gt $I11, rx1591_eos, rx1591_fail
    sub $I11, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I11, 2
    ne $S10, ":=", rx1591_fail
    add rx1591_pos, 2
    set_addr $I10, rxcap_1596_fail
    ($I12, $I11) = rx1591_cur."!mark_peek"($I10)
    rx1591_cur."!cursor_pos"($I11)
    ($P10) = rx1591_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1591_pos, "")
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1596_done
  rxcap_1596_fail:
    goto rx1591_fail
  rxcap_1596_done:
  # rx subrule "O" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1591_pos = $P10."pos"()
  # rx pass
    rx1591_cur."!cursor_pass"(rx1591_pos, "infix:sym<:=>")
    if_null rx1591_debug, debug_1122
    rx1591_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1591_pos)
  debug_1122:
    .return (rx1591_cur)
  rx1591_restart:
.annotate 'line', 4
    if_null rx1591_debug, debug_1123
    rx1591_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1123:
  rx1591_fail:
    (rx1591_rep, rx1591_pos, $I10, $P10) = rx1591_cur."!mark_fail"(0)
    lt rx1591_pos, -1, rx1591_done
    eq rx1591_pos, -1, rx1591_fail
    jump $I10
  rx1591_done:
    rx1591_cur."!cursor_fail"()
    if_null rx1591_debug, debug_1124
    rx1591_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1124:
    .return (rx1591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("364_1300060177.262") :method
.annotate 'line', 4
    $P1593 = self."!PREFIX__!subrule"("O", ":=")
    new $P1594, "ResizablePMCArray"
    push $P1594, $P1593
    .return ($P1594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("365_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1598_tgt
    .local int rx1598_pos
    .local int rx1598_off
    .local int rx1598_eos
    .local int rx1598_rep
    .local pmc rx1598_cur
    .local pmc rx1598_debug
    (rx1598_cur, rx1598_pos, rx1598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1598_cur
    .local pmc match
    .lex "$/", match
    length rx1598_eos, rx1598_tgt
    gt rx1598_pos, rx1598_eos, rx1598_done
    set rx1598_off, 0
    lt rx1598_pos, 2, rx1598_start
    sub rx1598_off, rx1598_pos, 1
    substr rx1598_tgt, rx1598_tgt, rx1598_off
  rx1598_start:
    eq $I10, 1, rx1598_restart
    if_null rx1598_debug, debug_1125
    rx1598_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1125:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1602_done
    goto rxscan1602_scan
  rxscan1602_loop:
    (rx1598_pos) = rx1598_cur."from"()
    inc rx1598_pos
    rx1598_cur."!cursor_from"(rx1598_pos)
    ge rx1598_pos, rx1598_eos, rxscan1602_done
  rxscan1602_scan:
    set_addr $I10, rxscan1602_loop
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  rxscan1602_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_1603_fail
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  # rx literal  "::="
    add $I11, rx1598_pos, 3
    gt $I11, rx1598_eos, rx1598_fail
    sub $I11, rx1598_pos, rx1598_off
    substr $S10, rx1598_tgt, $I11, 3
    ne $S10, "::=", rx1598_fail
    add rx1598_pos, 3
    set_addr $I10, rxcap_1603_fail
    ($I12, $I11) = rx1598_cur."!mark_peek"($I10)
    rx1598_cur."!cursor_pos"($I11)
    ($P10) = rx1598_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1598_pos, "")
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1603_done
  rxcap_1603_fail:
    goto rx1598_fail
  rxcap_1603_done:
  # rx subrule "O" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1598_pos = $P10."pos"()
  # rx pass
    rx1598_cur."!cursor_pass"(rx1598_pos, "infix:sym<::=>")
    if_null rx1598_debug, debug_1126
    rx1598_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1598_pos)
  debug_1126:
    .return (rx1598_cur)
  rx1598_restart:
.annotate 'line', 4
    if_null rx1598_debug, debug_1127
    rx1598_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1127:
  rx1598_fail:
    (rx1598_rep, rx1598_pos, $I10, $P10) = rx1598_cur."!mark_fail"(0)
    lt rx1598_pos, -1, rx1598_done
    eq rx1598_pos, -1, rx1598_fail
    jump $I10
  rx1598_done:
    rx1598_cur."!cursor_fail"()
    if_null rx1598_debug, debug_1128
    rx1598_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1128:
    .return (rx1598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("366_1300060177.262") :method
.annotate 'line', 4
    $P1600 = self."!PREFIX__!subrule"("O", "::=")
    new $P1601, "ResizablePMCArray"
    push $P1601, $P1600
    .return ($P1601)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("367_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1605_tgt
    .local int rx1605_pos
    .local int rx1605_off
    .local int rx1605_eos
    .local int rx1605_rep
    .local pmc rx1605_cur
    .local pmc rx1605_debug
    (rx1605_cur, rx1605_pos, rx1605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1605_cur
    .local pmc match
    .lex "$/", match
    length rx1605_eos, rx1605_tgt
    gt rx1605_pos, rx1605_eos, rx1605_done
    set rx1605_off, 0
    lt rx1605_pos, 2, rx1605_start
    sub rx1605_off, rx1605_pos, 1
    substr rx1605_tgt, rx1605_tgt, rx1605_off
  rx1605_start:
    eq $I10, 1, rx1605_restart
    if_null rx1605_debug, debug_1129
    rx1605_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1129:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1609_done
    goto rxscan1609_scan
  rxscan1609_loop:
    (rx1605_pos) = rx1605_cur."from"()
    inc rx1605_pos
    rx1605_cur."!cursor_from"(rx1605_pos)
    ge rx1605_pos, rx1605_eos, rxscan1609_done
  rxscan1609_scan:
    set_addr $I10, rxscan1609_loop
    rx1605_cur."!mark_push"(0, rx1605_pos, $I10)
  rxscan1609_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_1610_fail
    rx1605_cur."!mark_push"(0, rx1605_pos, $I10)
  # rx literal  ","
    add $I11, rx1605_pos, 1
    gt $I11, rx1605_eos, rx1605_fail
    sub $I11, rx1605_pos, rx1605_off
    ord $I11, rx1605_tgt, $I11
    ne $I11, 44, rx1605_fail
    add rx1605_pos, 1
    set_addr $I10, rxcap_1610_fail
    ($I12, $I11) = rx1605_cur."!mark_peek"($I10)
    rx1605_cur."!cursor_pos"($I11)
    ($P10) = rx1605_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1605_pos, "")
    rx1605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1610_done
  rxcap_1610_fail:
    goto rx1605_fail
  rxcap_1610_done:
  # rx subrule "O" subtype=capture negate=
    rx1605_cur."!cursor_pos"(rx1605_pos)
    $P10 = rx1605_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1605_fail
    rx1605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1605_pos = $P10."pos"()
  # rx pass
    rx1605_cur."!cursor_pass"(rx1605_pos, "infix:sym<,>")
    if_null rx1605_debug, debug_1130
    rx1605_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1605_pos)
  debug_1130:
    .return (rx1605_cur)
  rx1605_restart:
.annotate 'line', 4
    if_null rx1605_debug, debug_1131
    rx1605_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1131:
  rx1605_fail:
    (rx1605_rep, rx1605_pos, $I10, $P10) = rx1605_cur."!mark_fail"(0)
    lt rx1605_pos, -1, rx1605_done
    eq rx1605_pos, -1, rx1605_fail
    jump $I10
  rx1605_done:
    rx1605_cur."!cursor_fail"()
    if_null rx1605_debug, debug_1132
    rx1605_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1132:
    .return (rx1605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("368_1300060177.262") :method
.annotate 'line', 4
    $P1607 = self."!PREFIX__!subrule"("O", ",")
    new $P1608, "ResizablePMCArray"
    push $P1608, $P1607
    .return ($P1608)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("369_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .const 'Sub' $P1620 = "371_1300060177.262" 
    capture_lex $P1620
    .local string rx1612_tgt
    .local int rx1612_pos
    .local int rx1612_off
    .local int rx1612_eos
    .local int rx1612_rep
    .local pmc rx1612_cur
    .local pmc rx1612_debug
    (rx1612_cur, rx1612_pos, rx1612_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1612_cur
    .local pmc match
    .lex "$/", match
    length rx1612_eos, rx1612_tgt
    gt rx1612_pos, rx1612_eos, rx1612_done
    set rx1612_off, 0
    lt rx1612_pos, 2, rx1612_start
    sub rx1612_off, rx1612_pos, 1
    substr rx1612_tgt, rx1612_tgt, rx1612_off
  rx1612_start:
    eq $I10, 1, rx1612_restart
    if_null rx1612_debug, debug_1133
    rx1612_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1133:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1615_done
    goto rxscan1615_scan
  rxscan1615_loop:
    (rx1612_pos) = rx1612_cur."from"()
    inc rx1612_pos
    rx1612_cur."!cursor_from"(rx1612_pos)
    ge rx1612_pos, rx1612_eos, rxscan1615_done
  rxscan1615_scan:
    set_addr $I10, rxscan1615_loop
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  rxscan1615_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1616_fail
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  # rx literal  "return"
    add $I11, rx1612_pos, 6
    gt $I11, rx1612_eos, rx1612_fail
    sub $I11, rx1612_pos, rx1612_off
    substr $S10, rx1612_tgt, $I11, 6
    ne $S10, "return", rx1612_fail
    add rx1612_pos, 6
    set_addr $I10, rxcap_1616_fail
    ($I12, $I11) = rx1612_cur."!mark_peek"($I10)
    rx1612_cur."!cursor_pos"($I11)
    ($P10) = rx1612_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1612_pos, "")
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1616_done
  rxcap_1616_fail:
    goto rx1612_fail
  rxcap_1616_done:
  # rx charclass s
    ge rx1612_pos, rx1612_eos, rx1612_fail
    sub $I10, rx1612_pos, rx1612_off
    is_cclass $I11, 32, rx1612_tgt, $I10
    unless $I11, rx1612_fail
    inc rx1612_pos
  # rx subrule "O" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1612_pos = $P10."pos"()
    rx1612_cur."!cursor_pos"(rx1612_pos)
    find_lex $P1617, unicode:"$\x{a2}"
    $P1618 = $P1617."MATCH"()
    store_lex "$/", $P1618
    .const 'Sub' $P1620 = "371_1300060177.262" 
    capture_lex $P1620
    $P1622 = $P1620()
  # rx pass
    rx1612_cur."!cursor_pass"(rx1612_pos, "prefix:sym<return>")
    if_null rx1612_debug, debug_1134
    rx1612_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1612_pos)
  debug_1134:
    .return (rx1612_cur)
  rx1612_restart:
.annotate 'line', 4
    if_null rx1612_debug, debug_1135
    rx1612_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1135:
  rx1612_fail:
    (rx1612_rep, rx1612_pos, $I10, $P10) = rx1612_cur."!mark_fail"(0)
    lt rx1612_pos, -1, rx1612_done
    eq rx1612_pos, -1, rx1612_fail
    jump $I10
  rx1612_done:
    rx1612_cur."!cursor_fail"()
    if_null rx1612_debug, debug_1136
    rx1612_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1136:
    .return (rx1612_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("370_1300060177.262") :method
.annotate 'line', 4
    new $P1614, "ResizablePMCArray"
    push $P1614, "return"
    .return ($P1614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1619"  :anon :subid("371_1300060177.262") :outer("369_1300060177.262")
.annotate 'line', 680
    new $P1621, "Integer"
    assign $P1621, 1
    store_dynamic_lex "$*RETURN_USED", $P1621
    .return ($P1621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("372_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1624_tgt
    .local int rx1624_pos
    .local int rx1624_off
    .local int rx1624_eos
    .local int rx1624_rep
    .local pmc rx1624_cur
    .local pmc rx1624_debug
    (rx1624_cur, rx1624_pos, rx1624_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1624_cur
    .local pmc match
    .lex "$/", match
    length rx1624_eos, rx1624_tgt
    gt rx1624_pos, rx1624_eos, rx1624_done
    set rx1624_off, 0
    lt rx1624_pos, 2, rx1624_start
    sub rx1624_off, rx1624_pos, 1
    substr rx1624_tgt, rx1624_tgt, rx1624_off
  rx1624_start:
    eq $I10, 1, rx1624_restart
    if_null rx1624_debug, debug_1137
    rx1624_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1137:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1627_done
    goto rxscan1627_scan
  rxscan1627_loop:
    (rx1624_pos) = rx1624_cur."from"()
    inc rx1624_pos
    rx1624_cur."!cursor_from"(rx1624_pos)
    ge rx1624_pos, rx1624_eos, rxscan1627_done
  rxscan1627_scan:
    set_addr $I10, rxscan1627_loop
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  rxscan1627_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1628_fail
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  # rx literal  "make"
    add $I11, rx1624_pos, 4
    gt $I11, rx1624_eos, rx1624_fail
    sub $I11, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I11, 4
    ne $S10, "make", rx1624_fail
    add rx1624_pos, 4
    set_addr $I10, rxcap_1628_fail
    ($I12, $I11) = rx1624_cur."!mark_peek"($I10)
    rx1624_cur."!cursor_pos"($I11)
    ($P10) = rx1624_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1624_pos, "")
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1628_done
  rxcap_1628_fail:
    goto rx1624_fail
  rxcap_1628_done:
  # rx charclass s
    ge rx1624_pos, rx1624_eos, rx1624_fail
    sub $I10, rx1624_pos, rx1624_off
    is_cclass $I11, 32, rx1624_tgt, $I10
    unless $I11, rx1624_fail
    inc rx1624_pos
  # rx subrule "O" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."O"("%list_prefix")
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1624_pos = $P10."pos"()
  # rx pass
    rx1624_cur."!cursor_pass"(rx1624_pos, "prefix:sym<make>")
    if_null rx1624_debug, debug_1138
    rx1624_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1624_pos)
  debug_1138:
    .return (rx1624_cur)
  rx1624_restart:
.annotate 'line', 4
    if_null rx1624_debug, debug_1139
    rx1624_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1139:
  rx1624_fail:
    (rx1624_rep, rx1624_pos, $I10, $P10) = rx1624_cur."!mark_fail"(0)
    lt rx1624_pos, -1, rx1624_done
    eq rx1624_pos, -1, rx1624_fail
    jump $I10
  rx1624_done:
    rx1624_cur."!cursor_fail"()
    if_null rx1624_debug, debug_1140
    rx1624_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1140:
    .return (rx1624_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("373_1300060177.262") :method
.annotate 'line', 4
    new $P1626, "ResizablePMCArray"
    push $P1626, "make"
    .return ($P1626)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("374_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1630_tgt
    .local int rx1630_pos
    .local int rx1630_off
    .local int rx1630_eos
    .local int rx1630_rep
    .local pmc rx1630_cur
    .local pmc rx1630_debug
    (rx1630_cur, rx1630_pos, rx1630_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1630_cur
    .local pmc match
    .lex "$/", match
    length rx1630_eos, rx1630_tgt
    gt rx1630_pos, rx1630_eos, rx1630_done
    set rx1630_off, 0
    lt rx1630_pos, 2, rx1630_start
    sub rx1630_off, rx1630_pos, 1
    substr rx1630_tgt, rx1630_tgt, rx1630_off
  rx1630_start:
    eq $I10, 1, rx1630_restart
    if_null rx1630_debug, debug_1141
    rx1630_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1141:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1633_done
    goto rxscan1633_scan
  rxscan1633_loop:
    (rx1630_pos) = rx1630_cur."from"()
    inc rx1630_pos
    rx1630_cur."!cursor_from"(rx1630_pos)
    ge rx1630_pos, rx1630_eos, rxscan1633_done
  rxscan1633_scan:
    set_addr $I10, rxscan1633_loop
    rx1630_cur."!mark_push"(0, rx1630_pos, $I10)
  rxscan1633_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1634_fail
    rx1630_cur."!mark_push"(0, rx1630_pos, $I10)
  # rx literal  "last"
    add $I11, rx1630_pos, 4
    gt $I11, rx1630_eos, rx1630_fail
    sub $I11, rx1630_pos, rx1630_off
    substr $S10, rx1630_tgt, $I11, 4
    ne $S10, "last", rx1630_fail
    add rx1630_pos, 4
    set_addr $I10, rxcap_1634_fail
    ($I12, $I11) = rx1630_cur."!mark_peek"($I10)
    rx1630_cur."!cursor_pos"($I11)
    ($P10) = rx1630_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1630_pos, "")
    rx1630_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1634_done
  rxcap_1634_fail:
    goto rx1630_fail
  rxcap_1634_done:
  # rx pass
    rx1630_cur."!cursor_pass"(rx1630_pos, "term:sym<last>")
    if_null rx1630_debug, debug_1142
    rx1630_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1630_pos)
  debug_1142:
    .return (rx1630_cur)
  rx1630_restart:
.annotate 'line', 4
    if_null rx1630_debug, debug_1143
    rx1630_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1143:
  rx1630_fail:
    (rx1630_rep, rx1630_pos, $I10, $P10) = rx1630_cur."!mark_fail"(0)
    lt rx1630_pos, -1, rx1630_done
    eq rx1630_pos, -1, rx1630_fail
    jump $I10
  rx1630_done:
    rx1630_cur."!cursor_fail"()
    if_null rx1630_debug, debug_1144
    rx1630_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1144:
    .return (rx1630_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("375_1300060177.262") :method
.annotate 'line', 4
    new $P1632, "ResizablePMCArray"
    push $P1632, "last"
    .return ($P1632)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("376_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1636_tgt
    .local int rx1636_pos
    .local int rx1636_off
    .local int rx1636_eos
    .local int rx1636_rep
    .local pmc rx1636_cur
    .local pmc rx1636_debug
    (rx1636_cur, rx1636_pos, rx1636_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1636_cur
    .local pmc match
    .lex "$/", match
    length rx1636_eos, rx1636_tgt
    gt rx1636_pos, rx1636_eos, rx1636_done
    set rx1636_off, 0
    lt rx1636_pos, 2, rx1636_start
    sub rx1636_off, rx1636_pos, 1
    substr rx1636_tgt, rx1636_tgt, rx1636_off
  rx1636_start:
    eq $I10, 1, rx1636_restart
    if_null rx1636_debug, debug_1145
    rx1636_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1145:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1639_done
    goto rxscan1639_scan
  rxscan1639_loop:
    (rx1636_pos) = rx1636_cur."from"()
    inc rx1636_pos
    rx1636_cur."!cursor_from"(rx1636_pos)
    ge rx1636_pos, rx1636_eos, rxscan1639_done
  rxscan1639_scan:
    set_addr $I10, rxscan1639_loop
    rx1636_cur."!mark_push"(0, rx1636_pos, $I10)
  rxscan1639_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1640_fail
    rx1636_cur."!mark_push"(0, rx1636_pos, $I10)
  # rx literal  "next"
    add $I11, rx1636_pos, 4
    gt $I11, rx1636_eos, rx1636_fail
    sub $I11, rx1636_pos, rx1636_off
    substr $S10, rx1636_tgt, $I11, 4
    ne $S10, "next", rx1636_fail
    add rx1636_pos, 4
    set_addr $I10, rxcap_1640_fail
    ($I12, $I11) = rx1636_cur."!mark_peek"($I10)
    rx1636_cur."!cursor_pos"($I11)
    ($P10) = rx1636_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1636_pos, "")
    rx1636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1640_done
  rxcap_1640_fail:
    goto rx1636_fail
  rxcap_1640_done:
  # rx pass
    rx1636_cur."!cursor_pass"(rx1636_pos, "term:sym<next>")
    if_null rx1636_debug, debug_1146
    rx1636_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1636_pos)
  debug_1146:
    .return (rx1636_cur)
  rx1636_restart:
.annotate 'line', 4
    if_null rx1636_debug, debug_1147
    rx1636_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1147:
  rx1636_fail:
    (rx1636_rep, rx1636_pos, $I10, $P10) = rx1636_cur."!mark_fail"(0)
    lt rx1636_pos, -1, rx1636_done
    eq rx1636_pos, -1, rx1636_fail
    jump $I10
  rx1636_done:
    rx1636_cur."!cursor_fail"()
    if_null rx1636_debug, debug_1148
    rx1636_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1148:
    .return (rx1636_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("377_1300060177.262") :method
.annotate 'line', 4
    new $P1638, "ResizablePMCArray"
    push $P1638, "next"
    .return ($P1638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("378_1300060177.262") :method :outer("11_1300060177.262")
.annotate 'line', 4
    .local string rx1642_tgt
    .local int rx1642_pos
    .local int rx1642_off
    .local int rx1642_eos
    .local int rx1642_rep
    .local pmc rx1642_cur
    .local pmc rx1642_debug
    (rx1642_cur, rx1642_pos, rx1642_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1642_cur
    .local pmc match
    .lex "$/", match
    length rx1642_eos, rx1642_tgt
    gt rx1642_pos, rx1642_eos, rx1642_done
    set rx1642_off, 0
    lt rx1642_pos, 2, rx1642_start
    sub rx1642_off, rx1642_pos, 1
    substr rx1642_tgt, rx1642_tgt, rx1642_off
  rx1642_start:
    eq $I10, 1, rx1642_restart
    if_null rx1642_debug, debug_1149
    rx1642_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1149:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1645_done
    goto rxscan1645_scan
  rxscan1645_loop:
    (rx1642_pos) = rx1642_cur."from"()
    inc rx1642_pos
    rx1642_cur."!cursor_from"(rx1642_pos)
    ge rx1642_pos, rx1642_eos, rxscan1645_done
  rxscan1645_scan:
    set_addr $I10, rxscan1645_loop
    rx1642_cur."!mark_push"(0, rx1642_pos, $I10)
  rxscan1645_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1646_fail
    rx1642_cur."!mark_push"(0, rx1642_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1642_pos, 4
    gt $I11, rx1642_eos, rx1642_fail
    sub $I11, rx1642_pos, rx1642_off
    substr $S10, rx1642_tgt, $I11, 4
    ne $S10, "redo", rx1642_fail
    add rx1642_pos, 4
    set_addr $I10, rxcap_1646_fail
    ($I12, $I11) = rx1642_cur."!mark_peek"($I10)
    rx1642_cur."!cursor_pos"($I11)
    ($P10) = rx1642_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1642_pos, "")
    rx1642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1646_done
  rxcap_1646_fail:
    goto rx1642_fail
  rxcap_1646_done:
  # rx pass
    rx1642_cur."!cursor_pass"(rx1642_pos, "term:sym<redo>")
    if_null rx1642_debug, debug_1150
    rx1642_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1642_pos)
  debug_1150:
    .return (rx1642_cur)
  rx1642_restart:
.annotate 'line', 4
    if_null rx1642_debug, debug_1151
    rx1642_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1151:
  rx1642_fail:
    (rx1642_rep, rx1642_pos, $I10, $P10) = rx1642_cur."!mark_fail"(0)
    lt rx1642_pos, -1, rx1642_done
    eq rx1642_pos, -1, rx1642_fail
    jump $I10
  rx1642_done:
    rx1642_cur."!cursor_fail"()
    if_null rx1642_debug, debug_1152
    rx1642_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1152:
    .return (rx1642_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("379_1300060177.262") :method
.annotate 'line', 4
    new $P1644, "ResizablePMCArray"
    push $P1644, "redo"
    .return ($P1644)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("380_1300060177.262") :outer("11_1300060177.262")
    .param pmc param_1648
    .param pmc param_1649
.annotate 'line', 686
    .lex "self", param_1648
    .lex "$/", param_1649
.annotate 'line', 688
    new $P1650, "Undef"
    .lex "$t", $P1650
    find_lex $P1651, "$/"
    unless_null $P1651, vivify_1153
    $P1651 = root_new ['parrot';'ResizablePMCArray']
  vivify_1153:
    set $P1652, $P1651[0]
    unless_null $P1652, vivify_1154
    new $P1652, "Undef"
  vivify_1154:
    store_lex "$t", $P1652
    find_lex $P1653, "$/"
    unless_null $P1653, vivify_1155
    $P1653 = root_new ['parrot';'ResizablePMCArray']
  vivify_1155:
    set $P1654, $P1653[1]
    unless_null $P1654, vivify_1156
    new $P1654, "Undef"
  vivify_1156:
    find_lex $P1655, "$/"
    unless_null $P1655, vivify_1157
    $P1655 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1655
  vivify_1157:
    set $P1655[0], $P1654
    find_lex $P1656, "$t"
    find_lex $P1657, "$/"
    unless_null $P1657, vivify_1158
    $P1657 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1657
  vivify_1158:
    set $P1657[1], $P1656
.annotate 'line', 686
    .return ($P1656)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2378"  :subid("382_1300060177.262") :outer("10_1300060177.262")
.annotate 'line', 692
    .const 'Sub' $P2443 = "403_1300060177.262" 
    capture_lex $P2443
    .const 'Sub' $P2436 = "401_1300060177.262" 
    capture_lex $P2436
    .const 'Sub' $P2431 = "399_1300060177.262" 
    capture_lex $P2431
    .const 'Sub' $P2419 = "396_1300060177.262" 
    capture_lex $P2419
    .const 'Sub' $P2409 = "393_1300060177.262" 
    capture_lex $P2409
    .const 'Sub' $P2404 = "391_1300060177.262" 
    capture_lex $P2404
    .const 'Sub' $P2395 = "388_1300060177.262" 
    capture_lex $P2395
    .const 'Sub' $P2390 = "386_1300060177.262" 
    capture_lex $P2390
    .const 'Sub' $P2381 = "383_1300060177.262" 
    capture_lex $P2381
    get_global $P2380, "$?CLASS"
    .const 'Sub' $P2436 = "401_1300060177.262" 
    capture_lex $P2436
    .return ($P2436)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1159") :outer("382_1300060177.262")
.annotate 'line', 692
    get_hll_global $P2379, ["NQP";"Regex"], "_block2378" 
    .local pmc block
    set block, $P2379
    .const 'Sub' $P2443 = "403_1300060177.262" 
    capture_lex $P2443
    $P2443()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2442"  :anon :subid("403_1300060177.262") :outer("382_1300060177.262")
.annotate 'line', 692
    nqp_get_sc_object $P2444, "1300060171.714", 1
    .local pmc type_obj
    set type_obj, $P2444
    set_global "$?CLASS", type_obj
    get_how $P2445, type_obj
    .const 'Sub' $P2446 = "383_1300060177.262" 
    $P2445."add_method"(type_obj, "metachar:sym<:my>", $P2446)
    get_how $P2447, type_obj
    get_global $P2448, "!PREFIX__metachar:sym<:my>"
    $P2447."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2448)
    get_how $P2449, type_obj
    .const 'Sub' $P2450 = "386_1300060177.262" 
    $P2449."add_method"(type_obj, "metachar:sym<{ }>", $P2450)
    get_how $P2451, type_obj
    get_global $P2452, "!PREFIX__metachar:sym<{ }>"
    $P2451."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2452)
    get_how $P2453, type_obj
    .const 'Sub' $P2454 = "388_1300060177.262" 
    $P2453."add_method"(type_obj, "metachar:sym<nqpvar>", $P2454)
    get_how $P2455, type_obj
    get_global $P2456, "!PREFIX__metachar:sym<nqpvar>"
    $P2455."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2456)
    get_how $P2457, type_obj
    .const 'Sub' $P2458 = "391_1300060177.262" 
    $P2457."add_method"(type_obj, "assertion:sym<{ }>", $P2458)
    get_how $P2459, type_obj
    get_global $P2460, "!PREFIX__assertion:sym<{ }>"
    $P2459."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2460)
    get_how $P2461, type_obj
    .const 'Sub' $P2462 = "393_1300060177.262" 
    $P2461."add_method"(type_obj, "assertion:sym<?{ }>", $P2462)
    get_how $P2463, type_obj
    get_global $P2464, "!PREFIX__assertion:sym<?{ }>"
    $P2463."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2464)
    get_how $P2465, type_obj
    .const 'Sub' $P2466 = "396_1300060177.262" 
    $P2465."add_method"(type_obj, "assertion:sym<name>", $P2466)
    get_how $P2467, type_obj
    get_global $P2468, "!PREFIX__assertion:sym<name>"
    $P2467."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2468)
    get_how $P2469, type_obj
    .const 'Sub' $P2470 = "399_1300060177.262" 
    $P2469."add_method"(type_obj, "assertion:sym<var>", $P2470)
    get_how $P2471, type_obj
    get_global $P2472, "!PREFIX__assertion:sym<var>"
    $P2471."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2472)
    get_how $P2473, type_obj
    .const 'Sub' $P2474 = "401_1300060177.262" 
    $P2473."add_method"(type_obj, "codeblock", $P2474)
    get_how $P2475, type_obj
    get_global $P2476, "!PREFIX__codeblock"
    $P2475."add_method"(type_obj, "!PREFIX__codeblock", $P2476)
    get_how $P2477, type_obj
    get_hll_global $P2478, ["Regex";"P6Regex"], "Grammar"
    $P2477."add_parent"(type_obj, $P2478)
    get_how $P2479, type_obj
    $P2480 = $P2479."compose"(type_obj)
    .return ($P2480)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("383_1300060177.262") :method :outer("382_1300060177.262")
.annotate 'line', 692
    .const 'Sub' $P2387 = "385_1300060177.262" 
    capture_lex $P2387
    .local string rx2382_tgt
    .local int rx2382_pos
    .local int rx2382_off
    .local int rx2382_eos
    .local int rx2382_rep
    .local pmc rx2382_cur
    .local pmc rx2382_debug
    (rx2382_cur, rx2382_pos, rx2382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2382_cur
    .local pmc match
    .lex "$/", match
    length rx2382_eos, rx2382_tgt
    gt rx2382_pos, rx2382_eos, rx2382_done
    set rx2382_off, 0
    lt rx2382_pos, 2, rx2382_start
    sub rx2382_off, rx2382_pos, 1
    substr rx2382_tgt, rx2382_tgt, rx2382_off
  rx2382_start:
    eq $I10, 1, rx2382_restart
    if_null rx2382_debug, debug_1160
    rx2382_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2385_done
    goto rxscan2385_scan
  rxscan2385_loop:
    (rx2382_pos) = rx2382_cur."from"()
    inc rx2382_pos
    rx2382_cur."!cursor_from"(rx2382_pos)
    ge rx2382_pos, rx2382_eos, rxscan2385_done
  rxscan2385_scan:
    set_addr $I10, rxscan2385_loop
    rx2382_cur."!mark_push"(0, rx2382_pos, $I10)
  rxscan2385_done:
.annotate 'line', 694
  # rx literal  ":"
    add $I11, rx2382_pos, 1
    gt $I11, rx2382_eos, rx2382_fail
    sub $I11, rx2382_pos, rx2382_off
    ord $I11, rx2382_tgt, $I11
    ne $I11, 58, rx2382_fail
    add rx2382_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2382_cur."!cursor_pos"(rx2382_pos)
    .const 'Sub' $P2387 = "385_1300060177.262" 
    capture_lex $P2387
    $P10 = rx2382_cur."before"($P2387)
    unless $P10, rx2382_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2382_cur."!cursor_pos"(rx2382_pos)
    $P10 = rx2382_cur."LANG"("MAIN", "statement")
    unless $P10, rx2382_fail
    rx2382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2382_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2382_cur."!cursor_pos"(rx2382_pos)
    $P10 = rx2382_cur."ws"()
    unless $P10, rx2382_fail
    rx2382_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2382_pos, 1
    gt $I11, rx2382_eos, rx2382_fail
    sub $I11, rx2382_pos, rx2382_off
    ord $I11, rx2382_tgt, $I11
    ne $I11, 59, rx2382_fail
    add rx2382_pos, 1
.annotate 'line', 693
  # rx pass
    rx2382_cur."!cursor_pass"(rx2382_pos, "metachar:sym<:my>")
    if_null rx2382_debug, debug_1165
    rx2382_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2382_pos)
  debug_1165:
    .return (rx2382_cur)
  rx2382_restart:
.annotate 'line', 692
    if_null rx2382_debug, debug_1166
    rx2382_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1166:
  rx2382_fail:
    (rx2382_rep, rx2382_pos, $I10, $P10) = rx2382_cur."!mark_fail"(0)
    lt rx2382_pos, -1, rx2382_done
    eq rx2382_pos, -1, rx2382_fail
    jump $I10
  rx2382_done:
    rx2382_cur."!cursor_fail"()
    if_null rx2382_debug, debug_1167
    rx2382_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1167:
    .return (rx2382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("384_1300060177.262") :method
.annotate 'line', 692
    new $P2384, "ResizablePMCArray"
    push $P2384, ":"
    .return ($P2384)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2386"  :anon :subid("385_1300060177.262") :method :outer("383_1300060177.262")
.annotate 'line', 694
    .local string rx2388_tgt
    .local int rx2388_pos
    .local int rx2388_off
    .local int rx2388_eos
    .local int rx2388_rep
    .local pmc rx2388_cur
    .local pmc rx2388_debug
    (rx2388_cur, rx2388_pos, rx2388_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2388_cur
    .local pmc match
    .lex "$/", match
    length rx2388_eos, rx2388_tgt
    gt rx2388_pos, rx2388_eos, rx2388_done
    set rx2388_off, 0
    lt rx2388_pos, 2, rx2388_start
    sub rx2388_off, rx2388_pos, 1
    substr rx2388_tgt, rx2388_tgt, rx2388_off
  rx2388_start:
    eq $I10, 1, rx2388_restart
    if_null rx2388_debug, debug_1161
    rx2388_cur."!cursor_debug"("START", "")
  debug_1161:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2389_done
    goto rxscan2389_scan
  rxscan2389_loop:
    (rx2388_pos) = rx2388_cur."from"()
    inc rx2388_pos
    rx2388_cur."!cursor_from"(rx2388_pos)
    ge rx2388_pos, rx2388_eos, rxscan2389_done
  rxscan2389_scan:
    set_addr $I10, rxscan2389_loop
    rx2388_cur."!mark_push"(0, rx2388_pos, $I10)
  rxscan2389_done:
  # rx literal  "my"
    add $I11, rx2388_pos, 2
    gt $I11, rx2388_eos, rx2388_fail
    sub $I11, rx2388_pos, rx2388_off
    substr $S10, rx2388_tgt, $I11, 2
    ne $S10, "my", rx2388_fail
    add rx2388_pos, 2
  # rx pass
    rx2388_cur."!cursor_pass"(rx2388_pos, "")
    if_null rx2388_debug, debug_1162
    rx2388_cur."!cursor_debug"("PASS", "", " at pos=", rx2388_pos)
  debug_1162:
    .return (rx2388_cur)
  rx2388_restart:
    if_null rx2388_debug, debug_1163
    rx2388_cur."!cursor_debug"("NEXT", "")
  debug_1163:
  rx2388_fail:
    (rx2388_rep, rx2388_pos, $I10, $P10) = rx2388_cur."!mark_fail"(0)
    lt rx2388_pos, -1, rx2388_done
    eq rx2388_pos, -1, rx2388_fail
    jump $I10
  rx2388_done:
    rx2388_cur."!cursor_fail"()
    if_null rx2388_debug, debug_1164
    rx2388_cur."!cursor_debug"("FAIL", "")
  debug_1164:
    .return (rx2388_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("386_1300060177.262") :method :outer("382_1300060177.262")
.annotate 'line', 692
    .local string rx2391_tgt
    .local int rx2391_pos
    .local int rx2391_off
    .local int rx2391_eos
    .local int rx2391_rep
    .local pmc rx2391_cur
    .local pmc rx2391_debug
    (rx2391_cur, rx2391_pos, rx2391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2391_cur
    .local pmc match
    .lex "$/", match
    length rx2391_eos, rx2391_tgt
    gt rx2391_pos, rx2391_eos, rx2391_done
    set rx2391_off, 0
    lt rx2391_pos, 2, rx2391_start
    sub rx2391_off, rx2391_pos, 1
    substr rx2391_tgt, rx2391_tgt, rx2391_off
  rx2391_start:
    eq $I10, 1, rx2391_restart
    if_null rx2391_debug, debug_1168
    rx2391_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1168:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2394_done
    goto rxscan2394_scan
  rxscan2394_loop:
    (rx2391_pos) = rx2391_cur."from"()
    inc rx2391_pos
    rx2391_cur."!cursor_from"(rx2391_pos)
    ge rx2391_pos, rx2391_eos, rxscan2394_done
  rxscan2394_scan:
    set_addr $I10, rxscan2394_loop
    rx2391_cur."!mark_push"(0, rx2391_pos, $I10)
  rxscan2394_done:
.annotate 'line', 698
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2391_pos, rx2391_off
    substr $S10, rx2391_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2391_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2391_cur."!cursor_pos"(rx2391_pos)
    $P10 = rx2391_cur."codeblock"()
    unless $P10, rx2391_fail
    rx2391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2391_pos = $P10."pos"()
.annotate 'line', 697
  # rx pass
    rx2391_cur."!cursor_pass"(rx2391_pos, "metachar:sym<{ }>")
    if_null rx2391_debug, debug_1169
    rx2391_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2391_pos)
  debug_1169:
    .return (rx2391_cur)
  rx2391_restart:
.annotate 'line', 692
    if_null rx2391_debug, debug_1170
    rx2391_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1170:
  rx2391_fail:
    (rx2391_rep, rx2391_pos, $I10, $P10) = rx2391_cur."!mark_fail"(0)
    lt rx2391_pos, -1, rx2391_done
    eq rx2391_pos, -1, rx2391_fail
    jump $I10
  rx2391_done:
    rx2391_cur."!cursor_fail"()
    if_null rx2391_debug, debug_1171
    rx2391_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1171:
    .return (rx2391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("387_1300060177.262") :method
.annotate 'line', 692
    new $P2393, "ResizablePMCArray"
    push $P2393, "{"
    .return ($P2393)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("388_1300060177.262") :method :outer("382_1300060177.262")
.annotate 'line', 692
    .const 'Sub' $P2401 = "390_1300060177.262" 
    capture_lex $P2401
    .local string rx2396_tgt
    .local int rx2396_pos
    .local int rx2396_off
    .local int rx2396_eos
    .local int rx2396_rep
    .local pmc rx2396_cur
    .local pmc rx2396_debug
    (rx2396_cur, rx2396_pos, rx2396_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2396_cur
    .local pmc match
    .lex "$/", match
    length rx2396_eos, rx2396_tgt
    gt rx2396_pos, rx2396_eos, rx2396_done
    set rx2396_off, 0
    lt rx2396_pos, 2, rx2396_start
    sub rx2396_off, rx2396_pos, 1
    substr rx2396_tgt, rx2396_tgt, rx2396_off
  rx2396_start:
    eq $I10, 1, rx2396_restart
    if_null rx2396_debug, debug_1172
    rx2396_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1172:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2399_done
    goto rxscan2399_scan
  rxscan2399_loop:
    (rx2396_pos) = rx2396_cur."from"()
    inc rx2396_pos
    rx2396_cur."!cursor_from"(rx2396_pos)
    ge rx2396_pos, rx2396_eos, rxscan2399_done
  rxscan2399_scan:
    set_addr $I10, rxscan2399_loop
    rx2396_cur."!mark_push"(0, rx2396_pos, $I10)
  rxscan2399_done:
.annotate 'line', 702
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2396_pos, rx2396_off
    substr $S10, rx2396_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2396_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2396_cur."!cursor_pos"(rx2396_pos)
    .const 'Sub' $P2401 = "390_1300060177.262" 
    capture_lex $P2401
    $P10 = rx2396_cur."before"($P2401)
    unless $P10, rx2396_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2396_cur."!cursor_pos"(rx2396_pos)
    $P10 = rx2396_cur."LANG"("MAIN", "variable")
    unless $P10, rx2396_fail
    rx2396_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2396_pos = $P10."pos"()
.annotate 'line', 701
  # rx pass
    rx2396_cur."!cursor_pass"(rx2396_pos, "metachar:sym<nqpvar>")
    if_null rx2396_debug, debug_1177
    rx2396_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2396_pos)
  debug_1177:
    .return (rx2396_cur)
  rx2396_restart:
.annotate 'line', 692
    if_null rx2396_debug, debug_1178
    rx2396_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1178:
  rx2396_fail:
    (rx2396_rep, rx2396_pos, $I10, $P10) = rx2396_cur."!mark_fail"(0)
    lt rx2396_pos, -1, rx2396_done
    eq rx2396_pos, -1, rx2396_fail
    jump $I10
  rx2396_done:
    rx2396_cur."!cursor_fail"()
    if_null rx2396_debug, debug_1179
    rx2396_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1179:
    .return (rx2396_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("389_1300060177.262") :method
.annotate 'line', 692
    new $P2398, "ResizablePMCArray"
    push $P2398, "$"
    push $P2398, "@"
    .return ($P2398)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2400"  :anon :subid("390_1300060177.262") :method :outer("388_1300060177.262")
.annotate 'line', 702
    .local string rx2402_tgt
    .local int rx2402_pos
    .local int rx2402_off
    .local int rx2402_eos
    .local int rx2402_rep
    .local pmc rx2402_cur
    .local pmc rx2402_debug
    (rx2402_cur, rx2402_pos, rx2402_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2402_cur
    .local pmc match
    .lex "$/", match
    length rx2402_eos, rx2402_tgt
    gt rx2402_pos, rx2402_eos, rx2402_done
    set rx2402_off, 0
    lt rx2402_pos, 2, rx2402_start
    sub rx2402_off, rx2402_pos, 1
    substr rx2402_tgt, rx2402_tgt, rx2402_off
  rx2402_start:
    eq $I10, 1, rx2402_restart
    if_null rx2402_debug, debug_1173
    rx2402_cur."!cursor_debug"("START", "")
  debug_1173:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2403_done
    goto rxscan2403_scan
  rxscan2403_loop:
    (rx2402_pos) = rx2402_cur."from"()
    inc rx2402_pos
    rx2402_cur."!cursor_from"(rx2402_pos)
    ge rx2402_pos, rx2402_eos, rxscan2403_done
  rxscan2403_scan:
    set_addr $I10, rxscan2403_loop
    rx2402_cur."!mark_push"(0, rx2402_pos, $I10)
  rxscan2403_done:
  # rx charclass .
    ge rx2402_pos, rx2402_eos, rx2402_fail
    inc rx2402_pos
  # rx charclass w
    ge rx2402_pos, rx2402_eos, rx2402_fail
    sub $I10, rx2402_pos, rx2402_off
    is_cclass $I11, 8192, rx2402_tgt, $I10
    unless $I11, rx2402_fail
    inc rx2402_pos
  # rx pass
    rx2402_cur."!cursor_pass"(rx2402_pos, "")
    if_null rx2402_debug, debug_1174
    rx2402_cur."!cursor_debug"("PASS", "", " at pos=", rx2402_pos)
  debug_1174:
    .return (rx2402_cur)
  rx2402_restart:
    if_null rx2402_debug, debug_1175
    rx2402_cur."!cursor_debug"("NEXT", "")
  debug_1175:
  rx2402_fail:
    (rx2402_rep, rx2402_pos, $I10, $P10) = rx2402_cur."!mark_fail"(0)
    lt rx2402_pos, -1, rx2402_done
    eq rx2402_pos, -1, rx2402_fail
    jump $I10
  rx2402_done:
    rx2402_cur."!cursor_fail"()
    if_null rx2402_debug, debug_1176
    rx2402_cur."!cursor_debug"("FAIL", "")
  debug_1176:
    .return (rx2402_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("391_1300060177.262") :method :outer("382_1300060177.262")
.annotate 'line', 692
    .local string rx2405_tgt
    .local int rx2405_pos
    .local int rx2405_off
    .local int rx2405_eos
    .local int rx2405_rep
    .local pmc rx2405_cur
    .local pmc rx2405_debug
    (rx2405_cur, rx2405_pos, rx2405_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2405_cur
    .local pmc match
    .lex "$/", match
    length rx2405_eos, rx2405_tgt
    gt rx2405_pos, rx2405_eos, rx2405_done
    set rx2405_off, 0
    lt rx2405_pos, 2, rx2405_start
    sub rx2405_off, rx2405_pos, 1
    substr rx2405_tgt, rx2405_tgt, rx2405_off
  rx2405_start:
    eq $I10, 1, rx2405_restart
    if_null rx2405_debug, debug_1180
    rx2405_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1180:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2408_done
    goto rxscan2408_scan
  rxscan2408_loop:
    (rx2405_pos) = rx2405_cur."from"()
    inc rx2405_pos
    rx2405_cur."!cursor_from"(rx2405_pos)
    ge rx2405_pos, rx2405_eos, rxscan2408_done
  rxscan2408_scan:
    set_addr $I10, rxscan2408_loop
    rx2405_cur."!mark_push"(0, rx2405_pos, $I10)
  rxscan2408_done:
.annotate 'line', 706
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2405_pos, rx2405_off
    substr $S10, rx2405_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2405_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2405_cur."!cursor_pos"(rx2405_pos)
    $P10 = rx2405_cur."codeblock"()
    unless $P10, rx2405_fail
    rx2405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2405_pos = $P10."pos"()
.annotate 'line', 705
  # rx pass
    rx2405_cur."!cursor_pass"(rx2405_pos, "assertion:sym<{ }>")
    if_null rx2405_debug, debug_1181
    rx2405_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2405_pos)
  debug_1181:
    .return (rx2405_cur)
  rx2405_restart:
.annotate 'line', 692
    if_null rx2405_debug, debug_1182
    rx2405_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1182:
  rx2405_fail:
    (rx2405_rep, rx2405_pos, $I10, $P10) = rx2405_cur."!mark_fail"(0)
    lt rx2405_pos, -1, rx2405_done
    eq rx2405_pos, -1, rx2405_fail
    jump $I10
  rx2405_done:
    rx2405_cur."!cursor_fail"()
    if_null rx2405_debug, debug_1183
    rx2405_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1183:
    .return (rx2405_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("392_1300060177.262") :method
.annotate 'line', 692
    new $P2407, "ResizablePMCArray"
    push $P2407, "{"
    .return ($P2407)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("393_1300060177.262") :method :outer("382_1300060177.262")
.annotate 'line', 692
    .const 'Sub' $P2415 = "395_1300060177.262" 
    capture_lex $P2415
    .local string rx2410_tgt
    .local int rx2410_pos
    .local int rx2410_off
    .local int rx2410_eos
    .local int rx2410_rep
    .local pmc rx2410_cur
    .local pmc rx2410_debug
    (rx2410_cur, rx2410_pos, rx2410_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2410_cur
    .local pmc match
    .lex "$/", match
    length rx2410_eos, rx2410_tgt
    gt rx2410_pos, rx2410_eos, rx2410_done
    set rx2410_off, 0
    lt rx2410_pos, 2, rx2410_start
    sub rx2410_off, rx2410_pos, 1
    substr rx2410_tgt, rx2410_tgt, rx2410_off
  rx2410_start:
    eq $I10, 1, rx2410_restart
    if_null rx2410_debug, debug_1184
    rx2410_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1184:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2413_done
    goto rxscan2413_scan
  rxscan2413_loop:
    (rx2410_pos) = rx2410_cur."from"()
    inc rx2410_pos
    rx2410_cur."!cursor_from"(rx2410_pos)
    ge rx2410_pos, rx2410_eos, rxscan2413_done
  rxscan2413_scan:
    set_addr $I10, rxscan2413_loop
    rx2410_cur."!mark_push"(0, rx2410_pos, $I10)
  rxscan2413_done:
.annotate 'line', 710
  # rx subcapture "zw"
    set_addr $I10, rxcap_2418_fail
    rx2410_cur."!mark_push"(0, rx2410_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2410_pos, rx2410_eos, rx2410_fail
    sub $I10, rx2410_pos, rx2410_off
    substr $S10, rx2410_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2410_fail
    inc rx2410_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2410_cur."!cursor_pos"(rx2410_pos)
    .const 'Sub' $P2415 = "395_1300060177.262" 
    capture_lex $P2415
    $P10 = rx2410_cur."before"($P2415)
    unless $P10, rx2410_fail
    set_addr $I10, rxcap_2418_fail
    ($I12, $I11) = rx2410_cur."!mark_peek"($I10)
    rx2410_cur."!cursor_pos"($I11)
    ($P10) = rx2410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2410_pos, "")
    rx2410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2418_done
  rxcap_2418_fail:
    goto rx2410_fail
  rxcap_2418_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2410_cur."!cursor_pos"(rx2410_pos)
    $P10 = rx2410_cur."codeblock"()
    unless $P10, rx2410_fail
    rx2410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2410_pos = $P10."pos"()
.annotate 'line', 709
  # rx pass
    rx2410_cur."!cursor_pass"(rx2410_pos, "assertion:sym<?{ }>")
    if_null rx2410_debug, debug_1189
    rx2410_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2410_pos)
  debug_1189:
    .return (rx2410_cur)
  rx2410_restart:
.annotate 'line', 692
    if_null rx2410_debug, debug_1190
    rx2410_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1190:
  rx2410_fail:
    (rx2410_rep, rx2410_pos, $I10, $P10) = rx2410_cur."!mark_fail"(0)
    lt rx2410_pos, -1, rx2410_done
    eq rx2410_pos, -1, rx2410_fail
    jump $I10
  rx2410_done:
    rx2410_cur."!cursor_fail"()
    if_null rx2410_debug, debug_1191
    rx2410_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1191:
    .return (rx2410_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("394_1300060177.262") :method
.annotate 'line', 692
    new $P2412, "ResizablePMCArray"
    push $P2412, "!"
    push $P2412, "?"
    .return ($P2412)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2414"  :anon :subid("395_1300060177.262") :method :outer("393_1300060177.262")
.annotate 'line', 710
    .local string rx2416_tgt
    .local int rx2416_pos
    .local int rx2416_off
    .local int rx2416_eos
    .local int rx2416_rep
    .local pmc rx2416_cur
    .local pmc rx2416_debug
    (rx2416_cur, rx2416_pos, rx2416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2416_cur
    .local pmc match
    .lex "$/", match
    length rx2416_eos, rx2416_tgt
    gt rx2416_pos, rx2416_eos, rx2416_done
    set rx2416_off, 0
    lt rx2416_pos, 2, rx2416_start
    sub rx2416_off, rx2416_pos, 1
    substr rx2416_tgt, rx2416_tgt, rx2416_off
  rx2416_start:
    eq $I10, 1, rx2416_restart
    if_null rx2416_debug, debug_1185
    rx2416_cur."!cursor_debug"("START", "")
  debug_1185:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2417_done
    goto rxscan2417_scan
  rxscan2417_loop:
    (rx2416_pos) = rx2416_cur."from"()
    inc rx2416_pos
    rx2416_cur."!cursor_from"(rx2416_pos)
    ge rx2416_pos, rx2416_eos, rxscan2417_done
  rxscan2417_scan:
    set_addr $I10, rxscan2417_loop
    rx2416_cur."!mark_push"(0, rx2416_pos, $I10)
  rxscan2417_done:
  # rx literal  "{"
    add $I11, rx2416_pos, 1
    gt $I11, rx2416_eos, rx2416_fail
    sub $I11, rx2416_pos, rx2416_off
    ord $I11, rx2416_tgt, $I11
    ne $I11, 123, rx2416_fail
    add rx2416_pos, 1
  # rx pass
    rx2416_cur."!cursor_pass"(rx2416_pos, "")
    if_null rx2416_debug, debug_1186
    rx2416_cur."!cursor_debug"("PASS", "", " at pos=", rx2416_pos)
  debug_1186:
    .return (rx2416_cur)
  rx2416_restart:
    if_null rx2416_debug, debug_1187
    rx2416_cur."!cursor_debug"("NEXT", "")
  debug_1187:
  rx2416_fail:
    (rx2416_rep, rx2416_pos, $I10, $P10) = rx2416_cur."!mark_fail"(0)
    lt rx2416_pos, -1, rx2416_done
    eq rx2416_pos, -1, rx2416_fail
    jump $I10
  rx2416_done:
    rx2416_cur."!cursor_fail"()
    if_null rx2416_debug, debug_1188
    rx2416_cur."!cursor_debug"("FAIL", "")
  debug_1188:
    .return (rx2416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("396_1300060177.262") :method :outer("382_1300060177.262")
.annotate 'line', 692
    .const 'Sub' $P2428 = "398_1300060177.262" 
    capture_lex $P2428
    .local string rx2420_tgt
    .local int rx2420_pos
    .local int rx2420_off
    .local int rx2420_eos
    .local int rx2420_rep
    .local pmc rx2420_cur
    .local pmc rx2420_debug
    (rx2420_cur, rx2420_pos, rx2420_tgt, $I10) = self."!cursor_start"()
    rx2420_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2420_cur
    .local pmc match
    .lex "$/", match
    length rx2420_eos, rx2420_tgt
    gt rx2420_pos, rx2420_eos, rx2420_done
    set rx2420_off, 0
    lt rx2420_pos, 2, rx2420_start
    sub rx2420_off, rx2420_pos, 1
    substr rx2420_tgt, rx2420_tgt, rx2420_off
  rx2420_start:
    eq $I10, 1, rx2420_restart
    if_null rx2420_debug, debug_1192
    rx2420_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1192:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2424_done
    goto rxscan2424_scan
  rxscan2424_loop:
    (rx2420_pos) = rx2420_cur."from"()
    inc rx2420_pos
    rx2420_cur."!cursor_from"(rx2420_pos)
    ge rx2420_pos, rx2420_eos, rxscan2424_done
  rxscan2424_scan:
    set_addr $I10, rxscan2424_loop
    rx2420_cur."!mark_push"(0, rx2420_pos, $I10)
  rxscan2424_done:
.annotate 'line', 714
  # rx subrule "identifier" subtype=capture negate=
    rx2420_cur."!cursor_pos"(rx2420_pos)
    $P10 = rx2420_cur."identifier"()
    unless $P10, rx2420_fail
    rx2420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2420_pos = $P10."pos"()
.annotate 'line', 721
  # rx rxquantr2425 ** 0..1
    set_addr $I10, rxquantr2425_done
    rx2420_cur."!mark_push"(0, rx2420_pos, $I10)
  rxquantr2425_loop:
  alt2426_0:
.annotate 'line', 715
    set_addr $I10, alt2426_1
    rx2420_cur."!mark_push"(0, rx2420_pos, $I10)
.annotate 'line', 716
  # rx subrule "before" subtype=zerowidth negate=
    rx2420_cur."!cursor_pos"(rx2420_pos)
    .const 'Sub' $P2428 = "398_1300060177.262" 
    capture_lex $P2428
    $P10 = rx2420_cur."before"($P2428)
    unless $P10, rx2420_fail
    goto alt2426_end
  alt2426_1:
    set_addr $I10, alt2426_2
    rx2420_cur."!mark_push"(0, rx2420_pos, $I10)
.annotate 'line', 717
  # rx literal  "="
    add $I11, rx2420_pos, 1
    gt $I11, rx2420_eos, rx2420_fail
    sub $I11, rx2420_pos, rx2420_off
    ord $I11, rx2420_tgt, $I11
    ne $I11, 61, rx2420_fail
    add rx2420_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2420_cur."!cursor_pos"(rx2420_pos)
    $P10 = rx2420_cur."assertion"()
    unless $P10, rx2420_fail
    rx2420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2420_pos = $P10."pos"()
    goto alt2426_end
  alt2426_2:
    set_addr $I10, alt2426_3
    rx2420_cur."!mark_push"(0, rx2420_pos, $I10)
.annotate 'line', 718
  # rx literal  ":"
    add $I11, rx2420_pos, 1
    gt $I11, rx2420_eos, rx2420_fail
    sub $I11, rx2420_pos, rx2420_off
    ord $I11, rx2420_tgt, $I11
    ne $I11, 58, rx2420_fail
    add rx2420_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2420_cur."!cursor_pos"(rx2420_pos)
    $P10 = rx2420_cur."arglist"()
    unless $P10, rx2420_fail
    rx2420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2420_pos = $P10."pos"()
    goto alt2426_end
  alt2426_3:
    set_addr $I10, alt2426_4
    rx2420_cur."!mark_push"(0, rx2420_pos, $I10)
.annotate 'line', 719
  # rx literal  "("
    add $I11, rx2420_pos, 1
    gt $I11, rx2420_eos, rx2420_fail
    sub $I11, rx2420_pos, rx2420_off
    ord $I11, rx2420_tgt, $I11
    ne $I11, 40, rx2420_fail
    add rx2420_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2420_cur."!cursor_pos"(rx2420_pos)
    $P10 = rx2420_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2420_fail
    rx2420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2420_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2420_pos, 1
    gt $I11, rx2420_eos, rx2420_fail
    sub $I11, rx2420_pos, rx2420_off
    ord $I11, rx2420_tgt, $I11
    ne $I11, 41, rx2420_fail
    add rx2420_pos, 1
    goto alt2426_end
  alt2426_4:
.annotate 'line', 720
  # rx subrule "normspace" subtype=method negate=
    rx2420_cur."!cursor_pos"(rx2420_pos)
    $P10 = rx2420_cur."normspace"()
    unless $P10, rx2420_fail
    rx2420_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2420_cur."!cursor_pos"(rx2420_pos)
    $P10 = rx2420_cur."nibbler"()
    unless $P10, rx2420_fail
    rx2420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2420_pos = $P10."pos"()
  alt2426_end:
.annotate 'line', 721
    set_addr $I10, rxquantr2425_done
    (rx2420_rep) = rx2420_cur."!mark_commit"($I10)
  rxquantr2425_done:
.annotate 'line', 713
  # rx pass
    rx2420_cur."!cursor_pass"(rx2420_pos, "assertion:sym<name>")
    if_null rx2420_debug, debug_1197
    rx2420_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2420_pos)
  debug_1197:
    .return (rx2420_cur)
  rx2420_restart:
.annotate 'line', 692
    if_null rx2420_debug, debug_1198
    rx2420_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1198:
  rx2420_fail:
    (rx2420_rep, rx2420_pos, $I10, $P10) = rx2420_cur."!mark_fail"(0)
    lt rx2420_pos, -1, rx2420_done
    eq rx2420_pos, -1, rx2420_fail
    jump $I10
  rx2420_done:
    rx2420_cur."!cursor_fail"()
    if_null rx2420_debug, debug_1199
    rx2420_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1199:
    .return (rx2420_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("397_1300060177.262") :method
.annotate 'line', 692
    $P2422 = self."!PREFIX__!subrule"("identifier", "")
    new $P2423, "ResizablePMCArray"
    push $P2423, $P2422
    .return ($P2423)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2427"  :anon :subid("398_1300060177.262") :method :outer("396_1300060177.262")
.annotate 'line', 716
    .local string rx2429_tgt
    .local int rx2429_pos
    .local int rx2429_off
    .local int rx2429_eos
    .local int rx2429_rep
    .local pmc rx2429_cur
    .local pmc rx2429_debug
    (rx2429_cur, rx2429_pos, rx2429_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2429_cur
    .local pmc match
    .lex "$/", match
    length rx2429_eos, rx2429_tgt
    gt rx2429_pos, rx2429_eos, rx2429_done
    set rx2429_off, 0
    lt rx2429_pos, 2, rx2429_start
    sub rx2429_off, rx2429_pos, 1
    substr rx2429_tgt, rx2429_tgt, rx2429_off
  rx2429_start:
    eq $I10, 1, rx2429_restart
    if_null rx2429_debug, debug_1193
    rx2429_cur."!cursor_debug"("START", "")
  debug_1193:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2430_done
    goto rxscan2430_scan
  rxscan2430_loop:
    (rx2429_pos) = rx2429_cur."from"()
    inc rx2429_pos
    rx2429_cur."!cursor_from"(rx2429_pos)
    ge rx2429_pos, rx2429_eos, rxscan2430_done
  rxscan2430_scan:
    set_addr $I10, rxscan2430_loop
    rx2429_cur."!mark_push"(0, rx2429_pos, $I10)
  rxscan2430_done:
  # rx literal  ">"
    add $I11, rx2429_pos, 1
    gt $I11, rx2429_eos, rx2429_fail
    sub $I11, rx2429_pos, rx2429_off
    ord $I11, rx2429_tgt, $I11
    ne $I11, 62, rx2429_fail
    add rx2429_pos, 1
  # rx pass
    rx2429_cur."!cursor_pass"(rx2429_pos, "")
    if_null rx2429_debug, debug_1194
    rx2429_cur."!cursor_debug"("PASS", "", " at pos=", rx2429_pos)
  debug_1194:
    .return (rx2429_cur)
  rx2429_restart:
    if_null rx2429_debug, debug_1195
    rx2429_cur."!cursor_debug"("NEXT", "")
  debug_1195:
  rx2429_fail:
    (rx2429_rep, rx2429_pos, $I10, $P10) = rx2429_cur."!mark_fail"(0)
    lt rx2429_pos, -1, rx2429_done
    eq rx2429_pos, -1, rx2429_fail
    jump $I10
  rx2429_done:
    rx2429_cur."!cursor_fail"()
    if_null rx2429_debug, debug_1196
    rx2429_cur."!cursor_debug"("FAIL", "")
  debug_1196:
    .return (rx2429_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("399_1300060177.262") :method :outer("382_1300060177.262")
.annotate 'line', 692
    .local string rx2432_tgt
    .local int rx2432_pos
    .local int rx2432_off
    .local int rx2432_eos
    .local int rx2432_rep
    .local pmc rx2432_cur
    .local pmc rx2432_debug
    (rx2432_cur, rx2432_pos, rx2432_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2432_cur
    .local pmc match
    .lex "$/", match
    length rx2432_eos, rx2432_tgt
    gt rx2432_pos, rx2432_eos, rx2432_done
    set rx2432_off, 0
    lt rx2432_pos, 2, rx2432_start
    sub rx2432_off, rx2432_pos, 1
    substr rx2432_tgt, rx2432_tgt, rx2432_off
  rx2432_start:
    eq $I10, 1, rx2432_restart
    if_null rx2432_debug, debug_1200
    rx2432_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1200:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2435_done
    goto rxscan2435_scan
  rxscan2435_loop:
    (rx2432_pos) = rx2432_cur."from"()
    inc rx2432_pos
    rx2432_cur."!cursor_from"(rx2432_pos)
    ge rx2432_pos, rx2432_eos, rxscan2435_done
  rxscan2435_scan:
    set_addr $I10, rxscan2435_loop
    rx2432_cur."!mark_push"(0, rx2432_pos, $I10)
  rxscan2435_done:
.annotate 'line', 725
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2432_pos, rx2432_off
    substr $S10, rx2432_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2432_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2432_cur."!cursor_pos"(rx2432_pos)
    $P10 = rx2432_cur."LANG"("MAIN", "variable")
    unless $P10, rx2432_fail
    rx2432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2432_pos = $P10."pos"()
.annotate 'line', 724
  # rx pass
    rx2432_cur."!cursor_pass"(rx2432_pos, "assertion:sym<var>")
    if_null rx2432_debug, debug_1201
    rx2432_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2432_pos)
  debug_1201:
    .return (rx2432_cur)
  rx2432_restart:
.annotate 'line', 692
    if_null rx2432_debug, debug_1202
    rx2432_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1202:
  rx2432_fail:
    (rx2432_rep, rx2432_pos, $I10, $P10) = rx2432_cur."!mark_fail"(0)
    lt rx2432_pos, -1, rx2432_done
    eq rx2432_pos, -1, rx2432_fail
    jump $I10
  rx2432_done:
    rx2432_cur."!cursor_fail"()
    if_null rx2432_debug, debug_1203
    rx2432_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1203:
    .return (rx2432_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("400_1300060177.262") :method
.annotate 'line', 692
    new $P2434, "ResizablePMCArray"
    push $P2434, "$"
    push $P2434, "@"
    .return ($P2434)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("401_1300060177.262") :method :outer("382_1300060177.262")
.annotate 'line', 692
    .local string rx2437_tgt
    .local int rx2437_pos
    .local int rx2437_off
    .local int rx2437_eos
    .local int rx2437_rep
    .local pmc rx2437_cur
    .local pmc rx2437_debug
    (rx2437_cur, rx2437_pos, rx2437_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2437_cur
    .local pmc match
    .lex "$/", match
    length rx2437_eos, rx2437_tgt
    gt rx2437_pos, rx2437_eos, rx2437_done
    set rx2437_off, 0
    lt rx2437_pos, 2, rx2437_start
    sub rx2437_off, rx2437_pos, 1
    substr rx2437_tgt, rx2437_tgt, rx2437_off
  rx2437_start:
    eq $I10, 1, rx2437_restart
    if_null rx2437_debug, debug_1204
    rx2437_cur."!cursor_debug"("START", "codeblock")
  debug_1204:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2441_done
    goto rxscan2441_scan
  rxscan2441_loop:
    (rx2437_pos) = rx2437_cur."from"()
    inc rx2437_pos
    rx2437_cur."!cursor_from"(rx2437_pos)
    ge rx2437_pos, rx2437_eos, rxscan2441_done
  rxscan2441_scan:
    set_addr $I10, rxscan2441_loop
    rx2437_cur."!mark_push"(0, rx2437_pos, $I10)
  rxscan2441_done:
.annotate 'line', 729
  # rx subrule "LANG" subtype=capture negate=
    rx2437_cur."!cursor_pos"(rx2437_pos)
    $P10 = rx2437_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2437_fail
    rx2437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2437_pos = $P10."pos"()
.annotate 'line', 728
  # rx pass
    rx2437_cur."!cursor_pass"(rx2437_pos, "codeblock")
    if_null rx2437_debug, debug_1205
    rx2437_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2437_pos)
  debug_1205:
    .return (rx2437_cur)
  rx2437_restart:
.annotate 'line', 692
    if_null rx2437_debug, debug_1206
    rx2437_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1206:
  rx2437_fail:
    (rx2437_rep, rx2437_pos, $I10, $P10) = rx2437_cur."!mark_fail"(0)
    lt rx2437_pos, -1, rx2437_done
    eq rx2437_pos, -1, rx2437_fail
    jump $I10
  rx2437_done:
    rx2437_cur."!cursor_fail"()
    if_null rx2437_debug, debug_1207
    rx2437_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1207:
    .return (rx2437_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("402_1300060177.262") :method
.annotate 'line', 692
    $P2439 = self."!PREFIX__!subrule"("LANG", "")
    new $P2440, "ResizablePMCArray"
    push $P2440, $P2439
    .return ($P2440)
.end


.HLL "nqp"

.namespace []
.sub "_block2482" :load :anon :subid("404_1300060177.262")
.annotate 'line', 1
    .const 'Sub' $P2484 = "10_1300060177.262" 
    $P2485 = $P2484()
    .return ($P2485)
.end

### .include 'gen/nqp-actions.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1300060192.103")
.annotate 'line', 0
    get_hll_global $P3214, ["NQP";"RegexActions"], "_block3213" 
    capture_lex $P3214
    get_hll_global $P14, ["NQP";"Actions"], "_block13" 
    capture_lex $P14
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P14, ["NQP";"Actions"], "_block13" 
    capture_lex $P14
    $P14()
.annotate 'line', 1330
    get_hll_global $P3214, ["NQP";"RegexActions"], "_block3213" 
    capture_lex $P3214
    $P3333 = $P3214()
.annotate 'line', 1
    .return ($P3333)
    .const 'Sub' $P3335 = "173_1300060192.103" 
    .return ($P3335)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post174") :outer("10_1300060192.103")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1300060192.103" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P3339, "1300060181.184"
    isnull $I3340, $P3339
    if $I3340, if_3338
    nqp_get_sc_object $P3353, "1300060181.184", 0
    set_hll_global ["NQP"], "Actions", $P3353
    nqp_get_sc_object $P3354, "1300060181.184", 1
    set_hll_global ["NQP"], "RegexActions", $P3354
    goto if_3338_end
  if_3338:
    nqp_dynop_setup 
    getinterp $P3341
    get_class $P3342, "LexPad"
    get_class $P3343, "NQPLexPad"
    $P3341."hll_map"($P3342, $P3343)
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P3344, "1300060181.184"
    .local pmc cur_sc
    set cur_sc, $P3344
    load_bytecode "SettingManager.pbc"
    get_hll_global $P3345, ["HLL"], "SettingManager"
    $P3346 = $P3345."load_setting"("NQPCORE")
    block."set_outer_ctx"($P3346)
    get_hll_global $P3347, "NQPClassHOW"
    $P3348 = $P3347."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P3348, cur_sc
    nqp_set_sc_object "1300060181.184", 0, $P3348
    nqp_get_sc_object $P3349, "1300060181.184", 0
    set_hll_global ["NQP"], "Actions", $P3349
    get_hll_global $P3350, "NQPClassHOW"
    $P3351 = $P3350."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P3351, cur_sc
    nqp_set_sc_object "1300060181.184", 1, $P3351
    nqp_get_sc_object $P3352, "1300060181.184", 1
    set_hll_global ["NQP"], "RegexActions", $P3352
  if_3338_end:
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block13"  :subid("11_1300060192.103") :outer("10_1300060192.103")
.annotate 'line', 1
    .const 'Sub' $P2991 = "163_1300060192.103" 
    capture_lex $P2991
    .const 'Sub' $P2981 = "162_1300060192.103" 
    capture_lex $P2981
    .const 'Sub' $P2976 = "161_1300060192.103" 
    capture_lex $P2976
    .const 'Sub' $P2971 = "160_1300060192.103" 
    capture_lex $P2971
    .const 'Sub' $P2966 = "159_1300060192.103" 
    capture_lex $P2966
    .const 'Sub' $P2955 = "158_1300060192.103" 
    capture_lex $P2955
    .const 'Sub' $P2947 = "157_1300060192.103" 
    capture_lex $P2947
    .const 'Sub' $P2939 = "156_1300060192.103" 
    capture_lex $P2939
    .const 'Sub' $P2931 = "155_1300060192.103" 
    capture_lex $P2931
    .const 'Sub' $P2926 = "154_1300060192.103" 
    capture_lex $P2926
    .const 'Sub' $P2914 = "153_1300060192.103" 
    capture_lex $P2914
    .const 'Sub' $P2906 = "152_1300060192.103" 
    capture_lex $P2906
    .const 'Sub' $P2868 = "151_1300060192.103" 
    capture_lex $P2868
    .const 'Sub' $P2856 = "150_1300060192.103" 
    capture_lex $P2856
    .const 'Sub' $P2848 = "149_1300060192.103" 
    capture_lex $P2848
    .const 'Sub' $P2840 = "148_1300060192.103" 
    capture_lex $P2840
    .const 'Sub' $P2832 = "147_1300060192.103" 
    capture_lex $P2832
    .const 'Sub' $P2824 = "146_1300060192.103" 
    capture_lex $P2824
    .const 'Sub' $P2816 = "145_1300060192.103" 
    capture_lex $P2816
    .const 'Sub' $P2790 = "144_1300060192.103" 
    capture_lex $P2790
    .const 'Sub' $P2775 = "143_1300060192.103" 
    capture_lex $P2775
    .const 'Sub' $P2767 = "142_1300060192.103" 
    capture_lex $P2767
    .const 'Sub' $P2756 = "141_1300060192.103" 
    capture_lex $P2756
    .const 'Sub' $P2745 = "140_1300060192.103" 
    capture_lex $P2745
    .const 'Sub' $P2734 = "139_1300060192.103" 
    capture_lex $P2734
    .const 'Sub' $P2726 = "138_1300060192.103" 
    capture_lex $P2726
    .const 'Sub' $P2699 = "137_1300060192.103" 
    capture_lex $P2699
    .const 'Sub' $P2661 = "135_1300060192.103" 
    capture_lex $P2661
    .const 'Sub' $P2653 = "134_1300060192.103" 
    capture_lex $P2653
    .const 'Sub' $P2645 = "133_1300060192.103" 
    capture_lex $P2645
    .const 'Sub' $P2620 = "132_1300060192.103" 
    capture_lex $P2620
    .const 'Sub' $P2604 = "131_1300060192.103" 
    capture_lex $P2604
    .const 'Sub' $P2596 = "130_1300060192.103" 
    capture_lex $P2596
    .const 'Sub' $P2588 = "129_1300060192.103" 
    capture_lex $P2588
    .const 'Sub' $P2486 = "126_1300060192.103" 
    capture_lex $P2486
    .const 'Sub' $P2478 = "125_1300060192.103" 
    capture_lex $P2478
    .const 'Sub' $P2471 = "124_1300060192.103" 
    capture_lex $P2471
    .const 'Sub' $P2444 = "123_1300060192.103" 
    capture_lex $P2444
    .const 'Sub' $P2390 = "121_1300060192.103" 
    capture_lex $P2390
    .const 'Sub' $P2376 = "120_1300060192.103" 
    capture_lex $P2376
    .const 'Sub' $P2369 = "119_1300060192.103" 
    capture_lex $P2369
    .const 'Sub' $P2320 = "118_1300060192.103" 
    capture_lex $P2320
    .const 'Sub' $P2155 = "114_1300060192.103" 
    capture_lex $P2155
    .const 'Sub' $P2092 = "112_1300060192.103" 
    capture_lex $P2092
    .const 'Sub' $P2084 = "111_1300060192.103" 
    capture_lex $P2084
    .const 'Sub' $P2069 = "110_1300060192.103" 
    capture_lex $P2069
    .const 'Sub' $P2054 = "109_1300060192.103" 
    capture_lex $P2054
    .const 'Sub' $P2036 = "108_1300060192.103" 
    capture_lex $P2036
    .const 'Sub' $P1937 = "107_1300060192.103" 
    capture_lex $P1937
    .const 'Sub' $P1893 = "104_1300060192.103" 
    capture_lex $P1893
    .const 'Sub' $P1768 = "101_1300060192.103" 
    capture_lex $P1768
    .const 'Sub' $P1517 = "94_1300060192.103" 
    capture_lex $P1517
    .const 'Sub' $P1509 = "93_1300060192.103" 
    capture_lex $P1509
    .const 'Sub' $P1501 = "92_1300060192.103" 
    capture_lex $P1501
    .const 'Sub' $P1400 = "88_1300060192.103" 
    capture_lex $P1400
    .const 'Sub' $P1392 = "87_1300060192.103" 
    capture_lex $P1392
    .const 'Sub' $P1377 = "86_1300060192.103" 
    capture_lex $P1377
    .const 'Sub' $P1362 = "85_1300060192.103" 
    capture_lex $P1362
    .const 'Sub' $P1347 = "84_1300060192.103" 
    capture_lex $P1347
    .const 'Sub' $P1325 = "83_1300060192.103" 
    capture_lex $P1325
    .const 'Sub' $P1317 = "82_1300060192.103" 
    capture_lex $P1317
    .const 'Sub' $P1309 = "81_1300060192.103" 
    capture_lex $P1309
    .const 'Sub' $P1301 = "80_1300060192.103" 
    capture_lex $P1301
    .const 'Sub' $P1104 = "77_1300060192.103" 
    capture_lex $P1104
    .const 'Sub' $P1096 = "76_1300060192.103" 
    capture_lex $P1096
    .const 'Sub' $P1088 = "75_1300060192.103" 
    capture_lex $P1088
    .const 'Sub' $P1080 = "74_1300060192.103" 
    capture_lex $P1080
    .const 'Sub' $P1072 = "73_1300060192.103" 
    capture_lex $P1072
    .const 'Sub' $P1064 = "72_1300060192.103" 
    capture_lex $P1064
    .const 'Sub' $P1056 = "71_1300060192.103" 
    capture_lex $P1056
    .const 'Sub' $P966 = "69_1300060192.103" 
    capture_lex $P966
    .const 'Sub' $P942 = "68_1300060192.103" 
    capture_lex $P942
    .const 'Sub' $P928 = "67_1300060192.103" 
    capture_lex $P928
    .const 'Sub' $P920 = "66_1300060192.103" 
    capture_lex $P920
    .const 'Sub' $P912 = "65_1300060192.103" 
    capture_lex $P912
    .const 'Sub' $P904 = "64_1300060192.103" 
    capture_lex $P904
    .const 'Sub' $P896 = "63_1300060192.103" 
    capture_lex $P896
    .const 'Sub' $P888 = "62_1300060192.103" 
    capture_lex $P888
    .const 'Sub' $P880 = "61_1300060192.103" 
    capture_lex $P880
    .const 'Sub' $P872 = "60_1300060192.103" 
    capture_lex $P872
    .const 'Sub' $P864 = "59_1300060192.103" 
    capture_lex $P864
    .const 'Sub' $P856 = "58_1300060192.103" 
    capture_lex $P856
    .const 'Sub' $P848 = "57_1300060192.103" 
    capture_lex $P848
    .const 'Sub' $P840 = "56_1300060192.103" 
    capture_lex $P840
    .const 'Sub' $P832 = "55_1300060192.103" 
    capture_lex $P832
    .const 'Sub' $P824 = "54_1300060192.103" 
    capture_lex $P824
    .const 'Sub' $P808 = "53_1300060192.103" 
    capture_lex $P808
    .const 'Sub' $P775 = "52_1300060192.103" 
    capture_lex $P775
    .const 'Sub' $P761 = "51_1300060192.103" 
    capture_lex $P761
    .const 'Sub' $P742 = "50_1300060192.103" 
    capture_lex $P742
    .const 'Sub' $P724 = "49_1300060192.103" 
    capture_lex $P724
    .const 'Sub' $P700 = "48_1300060192.103" 
    capture_lex $P700
    .const 'Sub' $P666 = "47_1300060192.103" 
    capture_lex $P666
    .const 'Sub' $P651 = "46_1300060192.103" 
    capture_lex $P651
    .const 'Sub' $P639 = "45_1300060192.103" 
    capture_lex $P639
    .const 'Sub' $P588 = "43_1300060192.103" 
    capture_lex $P588
    .const 'Sub' $P577 = "42_1300060192.103" 
    capture_lex $P577
    .const 'Sub' $P570 = "41_1300060192.103" 
    capture_lex $P570
    .const 'Sub' $P548 = "40_1300060192.103" 
    capture_lex $P548
    .const 'Sub' $P537 = "39_1300060192.103" 
    capture_lex $P537
    .const 'Sub' $P502 = "37_1300060192.103" 
    capture_lex $P502
    .const 'Sub' $P494 = "36_1300060192.103" 
    capture_lex $P494
    .const 'Sub' $P486 = "35_1300060192.103" 
    capture_lex $P486
    .const 'Sub' $P472 = "34_1300060192.103" 
    capture_lex $P472
    .const 'Sub' $P391 = "32_1300060192.103" 
    capture_lex $P391
    .const 'Sub' $P350 = "30_1300060192.103" 
    capture_lex $P350
    .const 'Sub' $P299 = "29_1300060192.103" 
    capture_lex $P299
    .const 'Sub' $P268 = "28_1300060192.103" 
    capture_lex $P268
    .const 'Sub' $P260 = "27_1300060192.103" 
    capture_lex $P260
    .const 'Sub' $P252 = "25_1300060192.103" 
    capture_lex $P252
    .const 'Sub' $P238 = "24_1300060192.103" 
    capture_lex $P238
    .const 'Sub' $P212 = "22_1300060192.103" 
    capture_lex $P212
    .const 'Sub' $P147 = "20_1300060192.103" 
    capture_lex $P147
    .const 'Sub' $P137 = "19_1300060192.103" 
    capture_lex $P137
    .const 'Sub' $P89 = "18_1300060192.103" 
    capture_lex $P89
    .const 'Sub' $P76 = "17_1300060192.103" 
    capture_lex $P76
    .const 'Sub' $P58 = "16_1300060192.103" 
    capture_lex $P58
    .const 'Sub' $P25 = "13_1300060192.103" 
    capture_lex $P25
    .const 'Sub' $P17 = "12_1300060192.103" 
    capture_lex $P17
    get_global $P15, "$?CLASS"
.annotate 'line', 3
    get_global $P16, "@BLOCK"
    unless_null $P16, vivify_176
    $P16 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P16
  vivify_176:
.annotate 'line', 9
    .const 'Sub' $P17 = "12_1300060192.103" 
    newclosure $P24, $P17
    .lex "xblock_immediate", $P24
.annotate 'line', 14
    .const 'Sub' $P25 = "13_1300060192.103" 
    newclosure $P57, $P25
    .lex "block_immediate", $P57
.annotate 'line', 24
    .const 'Sub' $P58 = "16_1300060192.103" 
    newclosure $P75, $P58
    .lex "vivitype", $P75
.annotate 'line', 43
    .const 'Sub' $P76 = "17_1300060192.103" 
    newclosure $P88, $P76
    .lex "colonpair_str", $P88
.annotate 'line', 265
    .const 'Sub' $P89 = "18_1300060192.103" 
    newclosure $P136, $P89
    .lex "push_block_handler", $P136
.annotate 'line', 807
    .const 'Sub' $P137 = "19_1300060192.103" 
    newclosure $P146, $P137
    .lex "only_star_block", $P146
.annotate 'line', 816
    .const 'Sub' $P147 = "20_1300060192.103" 
    newclosure $P211, $P147
    .lex "attach_multi_signature", $P211
.annotate 'line', 1104
    .const 'Sub' $P212 = "22_1300060192.103" 
    newclosure $P237, $P212
    .lex "is_lexical", $P237
.annotate 'line', 1312
    .const 'Sub' $P238 = "24_1300060192.103" 
    newclosure $P249, $P238
    .lex "control", $P249
.annotate 'line', 1
    get_global $P250, "@BLOCK"
    .const 'Sub' $P252 = "25_1300060192.103" 
    capture_lex $P252
    $P252()
    find_lex $P257, "xblock_immediate"
    find_lex $P258, "block_immediate"
    find_lex $P259, "vivitype"
.annotate 'line', 35
    find_lex $P298, "colonpair_str"
.annotate 'line', 258
    find_lex $P760, "push_block_handler"
.annotate 'line', 735
    find_lex $P1891, "only_star_block"
    find_lex $P1892, "attach_multi_signature"
.annotate 'line', 1082
    find_lex $P2443, "is_lexical"
.annotate 'line', 1303
    find_lex $P2965, "control"
.annotate 'line', 1325
    .const 'Sub' $P2981 = "162_1300060192.103" 
    newclosure $P2989, $P2981
.annotate 'line', 1
    .return ($P2989)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post175") :outer("11_1300060192.103")
.annotate 'line', 1
    get_hll_global $P14, ["NQP";"Actions"], "_block13" 
    .local pmc block
    set block, $P14
    .const 'Sub' $P2991 = "163_1300060192.103" 
    capture_lex $P2991
    $P2991()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2990"  :anon :subid("163_1300060192.103") :outer("11_1300060192.103")
.annotate 'line', 1
    nqp_get_sc_object $P2992, "1300060181.184", 0
    .local pmc type_obj
    set type_obj, $P2992
    set_global "$?CLASS", type_obj
    get_how $P2993, type_obj
    .const 'Sub' $P2994 = "27_1300060192.103" 
    $P2993."add_method"(type_obj, "TOP", $P2994)
    get_how $P2995, type_obj
    .const 'Sub' $P2996 = "28_1300060192.103" 
    $P2995."add_method"(type_obj, "deflongname", $P2996)
    get_how $P2997, type_obj
    .const 'Sub' $P2998 = "29_1300060192.103" 
    $P2997."add_method"(type_obj, "comp_unit", $P2998)
    get_how $P2999, type_obj
    .const 'Sub' $P3000 = "30_1300060192.103" 
    $P2999."add_method"(type_obj, "statementlist", $P3000)
    get_how $P3001, type_obj
    .const 'Sub' $P3002 = "32_1300060192.103" 
    $P3001."add_method"(type_obj, "statement", $P3002)
    get_how $P3003, type_obj
    .const 'Sub' $P3004 = "34_1300060192.103" 
    $P3003."add_method"(type_obj, "xblock", $P3004)
    get_how $P3005, type_obj
    .const 'Sub' $P3006 = "35_1300060192.103" 
    $P3005."add_method"(type_obj, "pblock", $P3006)
    get_how $P3007, type_obj
    .const 'Sub' $P3008 = "36_1300060192.103" 
    $P3007."add_method"(type_obj, "block", $P3008)
    get_how $P3009, type_obj
    .const 'Sub' $P3010 = "37_1300060192.103" 
    $P3009."add_method"(type_obj, "blockoid", $P3010)
    get_how $P3011, type_obj
    .const 'Sub' $P3012 = "39_1300060192.103" 
    $P3011."add_method"(type_obj, "newpad", $P3012)
    get_how $P3013, type_obj
    .const 'Sub' $P3014 = "40_1300060192.103" 
    $P3013."add_method"(type_obj, "outerctx", $P3014)
    get_how $P3015, type_obj
    .const 'Sub' $P3016 = "41_1300060192.103" 
    $P3015."add_method"(type_obj, "you_are_here", $P3016)
    get_how $P3017, type_obj
    .const 'Sub' $P3018 = "42_1300060192.103" 
    $P3017."add_method"(type_obj, "statement_control:sym<use>", $P3018)
    get_how $P3019, type_obj
    .const 'Sub' $P3020 = "43_1300060192.103" 
    $P3019."add_method"(type_obj, "statement_control:sym<if>", $P3020)
    get_how $P3021, type_obj
    .const 'Sub' $P3022 = "45_1300060192.103" 
    $P3021."add_method"(type_obj, "statement_control:sym<unless>", $P3022)
    get_how $P3023, type_obj
    .const 'Sub' $P3024 = "46_1300060192.103" 
    $P3023."add_method"(type_obj, "statement_control:sym<while>", $P3024)
    get_how $P3025, type_obj
    .const 'Sub' $P3026 = "47_1300060192.103" 
    $P3025."add_method"(type_obj, "statement_control:sym<repeat>", $P3026)
    get_how $P3027, type_obj
    .const 'Sub' $P3028 = "48_1300060192.103" 
    $P3027."add_method"(type_obj, "statement_control:sym<for>", $P3028)
    get_how $P3029, type_obj
    .const 'Sub' $P3030 = "49_1300060192.103" 
    $P3029."add_method"(type_obj, "statement_control:sym<CATCH>", $P3030)
    get_how $P3031, type_obj
    .const 'Sub' $P3032 = "50_1300060192.103" 
    $P3031."add_method"(type_obj, "statement_control:sym<CONTROL>", $P3032)
    get_how $P3033, type_obj
    .const 'Sub' $P3034 = "51_1300060192.103" 
    $P3033."add_method"(type_obj, "statement_prefix:sym<INIT>", $P3034)
    get_how $P3035, type_obj
    .const 'Sub' $P3036 = "52_1300060192.103" 
    $P3035."add_method"(type_obj, "statement_prefix:sym<try>", $P3036)
    get_how $P3037, type_obj
    .const 'Sub' $P3038 = "53_1300060192.103" 
    $P3037."add_method"(type_obj, "blorst", $P3038)
    get_how $P3039, type_obj
    .const 'Sub' $P3040 = "54_1300060192.103" 
    $P3039."add_method"(type_obj, "statement_mod_cond:sym<if>", $P3040)
    get_how $P3041, type_obj
    .const 'Sub' $P3042 = "55_1300060192.103" 
    $P3041."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P3042)
    get_how $P3043, type_obj
    .const 'Sub' $P3044 = "56_1300060192.103" 
    $P3043."add_method"(type_obj, "statement_mod_loop:sym<while>", $P3044)
    get_how $P3045, type_obj
    .const 'Sub' $P3046 = "57_1300060192.103" 
    $P3045."add_method"(type_obj, "statement_mod_loop:sym<until>", $P3046)
    get_how $P3047, type_obj
    .const 'Sub' $P3048 = "58_1300060192.103" 
    $P3047."add_method"(type_obj, "term:sym<fatarrow>", $P3048)
    get_how $P3049, type_obj
    .const 'Sub' $P3050 = "59_1300060192.103" 
    $P3049."add_method"(type_obj, "term:sym<colonpair>", $P3050)
    get_how $P3051, type_obj
    .const 'Sub' $P3052 = "60_1300060192.103" 
    $P3051."add_method"(type_obj, "term:sym<variable>", $P3052)
    get_how $P3053, type_obj
    .const 'Sub' $P3054 = "61_1300060192.103" 
    $P3053."add_method"(type_obj, "term:sym<package_declarator>", $P3054)
    get_how $P3055, type_obj
    .const 'Sub' $P3056 = "62_1300060192.103" 
    $P3055."add_method"(type_obj, "term:sym<scope_declarator>", $P3056)
    get_how $P3057, type_obj
    .const 'Sub' $P3058 = "63_1300060192.103" 
    $P3057."add_method"(type_obj, "term:sym<routine_declarator>", $P3058)
    get_how $P3059, type_obj
    .const 'Sub' $P3060 = "64_1300060192.103" 
    $P3059."add_method"(type_obj, "term:sym<regex_declarator>", $P3060)
    get_how $P3061, type_obj
    .const 'Sub' $P3062 = "65_1300060192.103" 
    $P3061."add_method"(type_obj, "term:sym<statement_prefix>", $P3062)
    get_how $P3063, type_obj
    .const 'Sub' $P3064 = "66_1300060192.103" 
    $P3063."add_method"(type_obj, "term:sym<lambda>", $P3064)
    get_how $P3065, type_obj
    .const 'Sub' $P3066 = "67_1300060192.103" 
    $P3065."add_method"(type_obj, "fatarrow", $P3066)
    get_how $P3067, type_obj
    .const 'Sub' $P3068 = "68_1300060192.103" 
    $P3067."add_method"(type_obj, "colonpair", $P3068)
    get_how $P3069, type_obj
    .const 'Sub' $P3070 = "69_1300060192.103" 
    $P3069."add_method"(type_obj, "variable", $P3070)
    get_how $P3071, type_obj
    .const 'Sub' $P3072 = "71_1300060192.103" 
    $P3071."add_method"(type_obj, "package_declarator:sym<module>", $P3072)
    get_how $P3073, type_obj
    .const 'Sub' $P3074 = "72_1300060192.103" 
    $P3073."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3074)
    get_how $P3075, type_obj
    .const 'Sub' $P3076 = "73_1300060192.103" 
    $P3075."add_method"(type_obj, "package_declarator:sym<class>", $P3076)
    get_how $P3077, type_obj
    .const 'Sub' $P3078 = "74_1300060192.103" 
    $P3077."add_method"(type_obj, "package_declarator:sym<grammar>", $P3078)
    get_how $P3079, type_obj
    .const 'Sub' $P3080 = "75_1300060192.103" 
    $P3079."add_method"(type_obj, "package_declarator:sym<role>", $P3080)
    get_how $P3081, type_obj
    .const 'Sub' $P3082 = "76_1300060192.103" 
    $P3081."add_method"(type_obj, "package_declarator:sym<native>", $P3082)
    get_how $P3083, type_obj
    .const 'Sub' $P3084 = "77_1300060192.103" 
    $P3083."add_method"(type_obj, "package_def", $P3084)
    get_how $P3085, type_obj
    .const 'Sub' $P3086 = "80_1300060192.103" 
    $P3085."add_method"(type_obj, "scope_declarator:sym<my>", $P3086)
    get_how $P3087, type_obj
    .const 'Sub' $P3088 = "81_1300060192.103" 
    $P3087."add_method"(type_obj, "scope_declarator:sym<our>", $P3088)
    get_how $P3089, type_obj
    .const 'Sub' $P3090 = "82_1300060192.103" 
    $P3089."add_method"(type_obj, "scope_declarator:sym<has>", $P3090)
    get_how $P3091, type_obj
    .const 'Sub' $P3092 = "83_1300060192.103" 
    $P3091."add_method"(type_obj, "scoped", $P3092)
    get_how $P3093, type_obj
    .const 'Sub' $P3094 = "84_1300060192.103" 
    $P3093."add_method"(type_obj, "declarator", $P3094)
    get_how $P3095, type_obj
    .const 'Sub' $P3096 = "85_1300060192.103" 
    $P3095."add_method"(type_obj, "multi_declarator:sym<multi>", $P3096)
    get_how $P3097, type_obj
    .const 'Sub' $P3098 = "86_1300060192.103" 
    $P3097."add_method"(type_obj, "multi_declarator:sym<proto>", $P3098)
    get_how $P3099, type_obj
    .const 'Sub' $P3100 = "87_1300060192.103" 
    $P3099."add_method"(type_obj, "multi_declarator:sym<null>", $P3100)
    get_how $P3101, type_obj
    .const 'Sub' $P3102 = "88_1300060192.103" 
    $P3101."add_method"(type_obj, "variable_declarator", $P3102)
    get_how $P3103, type_obj
    .const 'Sub' $P3104 = "92_1300060192.103" 
    $P3103."add_method"(type_obj, "routine_declarator:sym<sub>", $P3104)
    get_how $P3105, type_obj
    .const 'Sub' $P3106 = "93_1300060192.103" 
    $P3105."add_method"(type_obj, "routine_declarator:sym<method>", $P3106)
    get_how $P3107, type_obj
    .const 'Sub' $P3108 = "94_1300060192.103" 
    $P3107."add_method"(type_obj, "routine_def", $P3108)
    get_how $P3109, type_obj
    .const 'Sub' $P3110 = "101_1300060192.103" 
    $P3109."add_method"(type_obj, "method_def", $P3110)
    get_how $P3111, type_obj
    .const 'Sub' $P3112 = "104_1300060192.103" 
    $P3111."add_method"(type_obj, "signature", $P3112)
    get_how $P3113, type_obj
    .const 'Sub' $P3114 = "107_1300060192.103" 
    $P3113."add_method"(type_obj, "parameter", $P3114)
    get_how $P3115, type_obj
    .const 'Sub' $P3116 = "108_1300060192.103" 
    $P3115."add_method"(type_obj, "param_var", $P3116)
    get_how $P3117, type_obj
    .const 'Sub' $P3118 = "109_1300060192.103" 
    $P3117."add_method"(type_obj, "named_param", $P3118)
    get_how $P3119, type_obj
    .const 'Sub' $P3120 = "110_1300060192.103" 
    $P3119."add_method"(type_obj, "typename", $P3120)
    get_how $P3121, type_obj
    .const 'Sub' $P3122 = "111_1300060192.103" 
    $P3121."add_method"(type_obj, "trait", $P3122)
    get_how $P3123, type_obj
    .const 'Sub' $P3124 = "112_1300060192.103" 
    $P3123."add_method"(type_obj, "trait_mod:sym<is>", $P3124)
    get_how $P3125, type_obj
    .const 'Sub' $P3126 = "114_1300060192.103" 
    $P3125."add_method"(type_obj, "regex_declarator", $P3126)
    get_how $P3127, type_obj
    .const 'Sub' $P3128 = "118_1300060192.103" 
    $P3127."add_method"(type_obj, "dotty", $P3128)
    get_how $P3129, type_obj
    .const 'Sub' $P3130 = "119_1300060192.103" 
    $P3129."add_method"(type_obj, "term:sym<self>", $P3130)
    get_how $P3131, type_obj
    .const 'Sub' $P3132 = "120_1300060192.103" 
    $P3131."add_method"(type_obj, "term:sym<identifier>", $P3132)
    get_how $P3133, type_obj
    .const 'Sub' $P3134 = "121_1300060192.103" 
    $P3133."add_method"(type_obj, "term:sym<name>", $P3134)
    get_how $P3135, type_obj
    .const 'Sub' $P3136 = "123_1300060192.103" 
    $P3135."add_method"(type_obj, "term:sym<pir::op>", $P3136)
    get_how $P3137, type_obj
    .const 'Sub' $P3138 = "124_1300060192.103" 
    $P3137."add_method"(type_obj, "term:sym<onlystar>", $P3138)
    get_how $P3139, type_obj
    .const 'Sub' $P3140 = "125_1300060192.103" 
    $P3139."add_method"(type_obj, "args", $P3140)
    get_how $P3141, type_obj
    .const 'Sub' $P3142 = "126_1300060192.103" 
    $P3141."add_method"(type_obj, "arglist", $P3142)
    get_how $P3143, type_obj
    .const 'Sub' $P3144 = "129_1300060192.103" 
    $P3143."add_method"(type_obj, "term:sym<multi_declarator>", $P3144)
    get_how $P3145, type_obj
    .const 'Sub' $P3146 = "130_1300060192.103" 
    $P3145."add_method"(type_obj, "term:sym<value>", $P3146)
    get_how $P3147, type_obj
    .const 'Sub' $P3148 = "131_1300060192.103" 
    $P3147."add_method"(type_obj, "circumfix:sym<( )>", $P3148)
    get_how $P3149, type_obj
    .const 'Sub' $P3150 = "132_1300060192.103" 
    $P3149."add_method"(type_obj, "circumfix:sym<[ ]>", $P3150)
    get_how $P3151, type_obj
    .const 'Sub' $P3152 = "133_1300060192.103" 
    $P3151."add_method"(type_obj, "circumfix:sym<ang>", $P3152)
    get_how $P3153, type_obj
    .const 'Sub' $P3154 = "134_1300060192.103" 
    $P3153."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3154)
    get_how $P3155, type_obj
    .const 'Sub' $P3156 = "135_1300060192.103" 
    $P3155."add_method"(type_obj, "circumfix:sym<{ }>", $P3156)
    get_how $P3157, type_obj
    .const 'Sub' $P3158 = "137_1300060192.103" 
    $P3157."add_method"(type_obj, "circumfix:sym<sigil>", $P3158)
    get_how $P3159, type_obj
    .const 'Sub' $P3160 = "138_1300060192.103" 
    $P3159."add_method"(type_obj, "semilist", $P3160)
    get_how $P3161, type_obj
    .const 'Sub' $P3162 = "139_1300060192.103" 
    $P3161."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3162)
    get_how $P3163, type_obj
    .const 'Sub' $P3164 = "140_1300060192.103" 
    $P3163."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3164)
    get_how $P3165, type_obj
    .const 'Sub' $P3166 = "141_1300060192.103" 
    $P3165."add_method"(type_obj, "postcircumfix:sym<ang>", $P3166)
    get_how $P3167, type_obj
    .const 'Sub' $P3168 = "142_1300060192.103" 
    $P3167."add_method"(type_obj, "postcircumfix:sym<( )>", $P3168)
    get_how $P3169, type_obj
    .const 'Sub' $P3170 = "143_1300060192.103" 
    $P3169."add_method"(type_obj, "value", $P3170)
    get_how $P3171, type_obj
    .const 'Sub' $P3172 = "144_1300060192.103" 
    $P3171."add_method"(type_obj, "number", $P3172)
    get_how $P3173, type_obj
    .const 'Sub' $P3174 = "145_1300060192.103" 
    $P3173."add_method"(type_obj, "quote:sym<apos>", $P3174)
    get_how $P3175, type_obj
    .const 'Sub' $P3176 = "146_1300060192.103" 
    $P3175."add_method"(type_obj, "quote:sym<dblq>", $P3176)
    get_how $P3177, type_obj
    .const 'Sub' $P3178 = "147_1300060192.103" 
    $P3177."add_method"(type_obj, "quote:sym<qq>", $P3178)
    get_how $P3179, type_obj
    .const 'Sub' $P3180 = "148_1300060192.103" 
    $P3179."add_method"(type_obj, "quote:sym<q>", $P3180)
    get_how $P3181, type_obj
    .const 'Sub' $P3182 = "149_1300060192.103" 
    $P3181."add_method"(type_obj, "quote:sym<Q>", $P3182)
    get_how $P3183, type_obj
    .const 'Sub' $P3184 = "150_1300060192.103" 
    $P3183."add_method"(type_obj, "quote:sym<Q:PIR>", $P3184)
    get_how $P3185, type_obj
    .const 'Sub' $P3186 = "151_1300060192.103" 
    $P3185."add_method"(type_obj, "quote:sym</ />", $P3186)
    get_how $P3187, type_obj
    .const 'Sub' $P3188 = "152_1300060192.103" 
    $P3187."add_method"(type_obj, "quote_escape:sym<$>", $P3188)
    get_how $P3189, type_obj
    .const 'Sub' $P3190 = "153_1300060192.103" 
    $P3189."add_method"(type_obj, "quote_escape:sym<{ }>", $P3190)
    get_how $P3191, type_obj
    .const 'Sub' $P3192 = "154_1300060192.103" 
    $P3191."add_method"(type_obj, "quote_escape:sym<esc>", $P3192)
    get_how $P3193, type_obj
    .const 'Sub' $P3194 = "155_1300060192.103" 
    $P3193."add_method"(type_obj, "postfix:sym<.>", $P3194)
    get_how $P3195, type_obj
    .const 'Sub' $P3196 = "156_1300060192.103" 
    $P3195."add_method"(type_obj, "postfix:sym<++>", $P3196)
    get_how $P3197, type_obj
    .const 'Sub' $P3198 = "157_1300060192.103" 
    $P3197."add_method"(type_obj, "postfix:sym<-->", $P3198)
    get_how $P3199, type_obj
    .const 'Sub' $P3200 = "158_1300060192.103" 
    $P3199."add_method"(type_obj, "prefix:sym<make>", $P3200)
    get_how $P3201, type_obj
    .const 'Sub' $P3202 = "159_1300060192.103" 
    $P3201."add_method"(type_obj, "term:sym<next>", $P3202)
    get_how $P3203, type_obj
    .const 'Sub' $P3204 = "160_1300060192.103" 
    $P3203."add_method"(type_obj, "term:sym<last>", $P3204)
    get_how $P3205, type_obj
    .const 'Sub' $P3206 = "161_1300060192.103" 
    $P3205."add_method"(type_obj, "term:sym<redo>", $P3206)
    get_how $P3207, type_obj
    .const 'Sub' $P3208 = "162_1300060192.103" 
    $P3207."add_method"(type_obj, "infix:sym<~~>", $P3208)
    get_how $P3209, type_obj
    get_hll_global $P3210, ["HLL"], "Actions"
    $P3209."add_parent"(type_obj, $P3210)
    get_how $P3211, type_obj
    $P3212 = $P3211."compose"(type_obj)
    .return ($P3212)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_18
.annotate 'line', 9
    .lex "$xblock", param_18
.annotate 'line', 10
    find_lex $P19, "$xblock"
    unless_null $P19, vivify_177
    $P19 = root_new ['parrot';'ResizablePMCArray']
  vivify_177:
    set $P20, $P19[1]
    unless_null $P20, vivify_178
    new $P20, "Undef"
  vivify_178:
    $P21 = "block_immediate"($P20)
    find_lex $P22, "$xblock"
    unless_null $P22, vivify_179
    $P22 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P22
  vivify_179:
    set $P22[1], $P21
    find_lex $P23, "$xblock"
.annotate 'line', 9
    .return ($P23)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_26
.annotate 'line', 14
    .const 'Sub' $P36 = "14_1300060192.103" 
    capture_lex $P36
    .lex "$block", param_26
.annotate 'line', 15
    find_lex $P27, "$block"
    $P27."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P31, "$block"
    $P32 = $P31."symtable"()
    unless $P32, unless_30
    set $P29, $P32
    goto unless_30_end
  unless_30:
    find_lex $P33, "$block"
    $P34 = $P33."handlers"()
    set $P29, $P34
  unless_30_end:
    if $P29, unless_28_end
    .const 'Sub' $P36 = "14_1300060192.103" 
    capture_lex $P36
    $P36()
  unless_28_end:
    find_lex $P56, "$block"
.annotate 'line', 14
    .return ($P56)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block35"  :anon :subid("14_1300060192.103") :outer("13_1300060192.103")
.annotate 'line', 16
    .const 'Sub' $P47 = "15_1300060192.103" 
    capture_lex $P47
.annotate 'line', 17
    new $P37, "Undef"
    .lex "$stmts", $P37
    get_hll_global $P38, ["PAST"], "Stmts"
    find_lex $P39, "$block"
    $P40 = $P38."new"($P39 :named("node"))
    store_lex "$stmts", $P40
.annotate 'line', 18
    find_lex $P42, "$block"
    $P43 = $P42."list"()
    defined $I44, $P43
    unless $I44, for_undef_180
    iter $P41, $P43
    new $P53, 'ExceptionHandler'
    set_label $P53, loop52_handler
    $P53."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P53
  loop52_test:
    unless $P41, loop52_done
    shift $P45, $P41
  loop52_redo:
    .const 'Sub' $P47 = "15_1300060192.103" 
    capture_lex $P47
    $P47($P45)
  loop52_next:
    goto loop52_test
  loop52_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P54, exception, 'type'
    eq $P54, .CONTROL_LOOP_NEXT, loop52_next
    eq $P54, .CONTROL_LOOP_REDO, loop52_redo
  loop52_done:
    pop_eh 
  for_undef_180:
.annotate 'line', 19
    find_lex $P55, "$stmts"
    store_lex "$block", $P55
.annotate 'line', 16
    .return ($P55)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block46"  :anon :subid("15_1300060192.103") :outer("14_1300060192.103")
    .param pmc param_48
.annotate 'line', 18
    .lex "$_", param_48
    find_lex $P49, "$stmts"
    find_lex $P50, "$_"
    $P51 = $P49."push"($P50)
    .return ($P51)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_59
.annotate 'line', 24
    .lex "$sigil", param_59
.annotate 'line', 25
    find_lex $P62, "$sigil"
    set $S63, $P62
    iseq $I64, $S63, "%"
    if $I64, if_61
.annotate 'line', 27
    find_lex $P69, "$sigil"
    set $S70, $P69
    iseq $I71, $S70, "@"
    if $I71, if_68
    new $P74, "String"
    assign $P74, "Undef"
    set $P67, $P74
    goto if_68_end
  if_68:
.annotate 'line', 28
    get_hll_global $P72, ["PAST"], "Op"
    $P73 = $P72."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P67, $P73
  if_68_end:
    set $P60, $P67
.annotate 'line', 25
    goto if_61_end
  if_61:
.annotate 'line', 26
    get_hll_global $P65, ["PAST"], "Op"
    $P66 = $P65."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P60, $P66
  if_61_end:
.annotate 'line', 24
    .return ($P60)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_77
.annotate 'line', 43
    .lex "$ast", param_77
.annotate 'line', 44
    get_hll_global $P80, ["PAST"], "Op"
    find_lex $P81, "$ast"
    $P82 = $P80."ACCEPTS"($P81)
    if $P82, if_79
.annotate 'line', 46
    find_lex $P86, "$ast"
    $P87 = $P86."value"()
    set $P78, $P87
.annotate 'line', 44
    goto if_79_end
  if_79:
.annotate 'line', 45
    find_lex $P83, "$ast"
    $P84 = $P83."list"()
    join $S85, " ", $P84
    new $P78, 'String'
    set $P78, $S85
  if_79_end:
.annotate 'line', 43
    .return ($P78)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_90
    .param pmc param_91
.annotate 'line', 265
    .lex "$/", param_90
    .lex "$block", param_91
.annotate 'line', 266
    get_global $P93, "@BLOCK"
    unless_null $P93, vivify_181
    $P93 = root_new ['parrot';'ResizablePMCArray']
  vivify_181:
    set $P94, $P93[0]
    unless_null $P94, vivify_182
    new $P94, "Undef"
  vivify_182:
    $P95 = $P94."handlers"()
    if $P95, unless_92_end
.annotate 'line', 267
    get_global $P96, "@BLOCK"
    unless_null $P96, vivify_183
    $P96 = root_new ['parrot';'ResizablePMCArray']
  vivify_183:
    set $P97, $P96[0]
    unless_null $P97, vivify_184
    new $P97, "Undef"
  vivify_184:
    new $P98, "ResizablePMCArray"
    $P97."handlers"($P98)
  unless_92_end:
.annotate 'line', 269
    find_lex $P100, "$block"
    $P101 = $P100."arity"()
    if $P101, unless_99_end
.annotate 'line', 270
    find_lex $P102, "$block"
.annotate 'line', 271
    get_hll_global $P103, ["PAST"], "Op"
.annotate 'line', 272
    get_hll_global $P104, ["PAST"], "Var"
    $P105 = $P104."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 273
    get_hll_global $P106, ["PAST"], "Var"
    $P107 = $P106."new"("lexical" :named("scope"), "$_" :named("name"))
    $P108 = $P103."new"($P105, $P107, "bind" :named("pasttype"))
.annotate 'line', 271
    $P102."unshift"($P108)
.annotate 'line', 276
    find_lex $P109, "$block"
    get_hll_global $P110, ["PAST"], "Var"
    $P111 = $P110."new"("$_" :named("name"), "parameter" :named("scope"))
    $P109."unshift"($P111)
.annotate 'line', 277
    find_lex $P112, "$block"
    $P112."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 278
    find_lex $P113, "$block"
    $P113."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 279
    find_lex $P114, "$block"
    $P114."arity"(1)
  unless_99_end:
.annotate 'line', 281
    find_lex $P115, "$block"
    $P115."blocktype"("declaration")
.annotate 'line', 282
    get_global $P116, "@BLOCK"
    unless_null $P116, vivify_185
    $P116 = root_new ['parrot';'ResizablePMCArray']
  vivify_185:
    set $P117, $P116[0]
    unless_null $P117, vivify_186
    new $P117, "Undef"
  vivify_186:
    $P118 = $P117."handlers"()
.annotate 'line', 283
    get_hll_global $P119, ["PAST"], "Control"
    find_lex $P120, "$/"
.annotate 'line', 285
    get_hll_global $P121, ["PAST"], "Stmts"
.annotate 'line', 286
    get_hll_global $P122, ["PAST"], "Op"
    find_lex $P123, "$block"
.annotate 'line', 288
    get_hll_global $P124, ["PAST"], "Var"
    $P125 = $P124."new"("register" :named("scope"), "exception" :named("name"))
    $P126 = $P122."new"($P123, $P125, "call" :named("pasttype"))
.annotate 'line', 290
    get_hll_global $P127, ["PAST"], "Op"
.annotate 'line', 291
    get_hll_global $P128, ["PAST"], "Var"
.annotate 'line', 292
    get_hll_global $P129, ["PAST"], "Var"
    $P130 = $P129."new"("register" :named("scope"), "exception" :named("name"))
    $P131 = $P128."new"($P130, "handled", "keyed" :named("scope"))
.annotate 'line', 291
    $P132 = $P127."new"($P131, 1, "bind" :named("pasttype"))
.annotate 'line', 290
    $P133 = $P121."new"($P126, $P132)
.annotate 'line', 285
    $P134 = $P119."new"($P133, $P120 :named("node"))
.annotate 'line', 283
    $P135 = $P118."unshift"($P134)
.annotate 'line', 265
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("19_1300060192.103") :outer("11_1300060192.103")
.annotate 'line', 808
    new $P138, "Undef"
    .lex "$past", $P138
    get_global $P139, "@BLOCK"
    $P140 = $P139."shift"()
    store_lex "$past", $P140
.annotate 'line', 809
    find_lex $P141, "$past"
    $P141."closure"(1)
.annotate 'line', 810
    find_lex $P142, "$past"
    get_hll_global $P143, ["PAST"], "Op"
    $P144 = $P143."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P142."push"($P144)
    find_lex $P145, "$past"
.annotate 'line', 807
    .return ($P145)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("20_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_148
.annotate 'line', 816
    .const 'Sub' $P162 = "21_1300060192.103" 
    capture_lex $P162
    .lex "$routine", param_148
.annotate 'line', 820
    new $P149, "Undef"
    .lex "$types", $P149
.annotate 'line', 821
    new $P150, "Undef"
    .lex "$definednesses", $P150
.annotate 'line', 820
    get_hll_global $P151, ["PAST"], "Op"
    $P152 = $P151."new"("list" :named("pasttype"))
    store_lex "$types", $P152
.annotate 'line', 821
    get_hll_global $P153, ["PAST"], "Op"
    $P154 = $P153."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P154
.annotate 'line', 822
    find_lex $P156, "$routine"
    unless_null $P156, vivify_187
    $P156 = root_new ['parrot';'ResizablePMCArray']
  vivify_187:
    set $P157, $P156[0]
    unless_null $P157, vivify_188
    new $P157, "Undef"
  vivify_188:
    $P158 = $P157."list"()
    defined $I159, $P158
    unless $I159, for_undef_189
    iter $P155, $P158
    new $P200, 'ExceptionHandler'
    set_label $P200, loop199_handler
    $P200."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P200
  loop199_test:
    unless $P155, loop199_done
    shift $P160, $P155
  loop199_redo:
    .const 'Sub' $P162 = "21_1300060192.103" 
    capture_lex $P162
    $P162($P160)
  loop199_next:
    goto loop199_test
  loop199_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P201, exception, 'type'
    eq $P201, .CONTROL_LOOP_NEXT, loop199_next
    eq $P201, .CONTROL_LOOP_REDO, loop199_redo
  loop199_done:
    pop_eh 
  for_undef_189:
.annotate 'line', 829
    find_lex $P202, "$routine"
    $P203 = $P202."loadinit"()
    get_hll_global $P204, ["PAST"], "Op"
.annotate 'line', 830
    get_hll_global $P205, ["PAST"], "Var"
    $P206 = $P205."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P207, "$types"
    find_lex $P208, "$definednesses"
    $P209 = $P204."new"($P206, $P207, $P208, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 829
    $P210 = $P203."push"($P209)
.annotate 'line', 816
    .return ($P210)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block161"  :anon :subid("21_1300060192.103") :outer("20_1300060192.103")
    .param pmc param_163
.annotate 'line', 822
    .lex "$_", param_163
.annotate 'line', 823
    get_hll_global $P168, ["PAST"], "Var"
    find_lex $P169, "$_"
    $P170 = $P168."ACCEPTS"($P169)
    if $P170, if_167
    set $P166, $P170
    goto if_167_end
  if_167:
    find_lex $P171, "$_"
    $S172 = $P171."scope"()
    iseq $I173, $S172, "parameter"
    new $P166, 'Integer'
    set $P166, $I173
  if_167_end:
    if $P166, if_165
    set $P164, $P166
    goto if_165_end
  if_165:
.annotate 'line', 824
    find_lex $P174, "$types"
    find_lex $P176, "$_"
    $P177 = $P176."multitype"()
    set $P175, $P177
    defined $I179, $P175
    if $I179, default_178
    get_hll_global $P180, ["PAST"], "Op"
    $P181 = $P180."new"("null P" :named("pirop"))
    set $P175, $P181
  default_178:
    $P174."push"($P175)
.annotate 'line', 825
    find_lex $P182, "$definednesses"
    find_lex $P185, "$_"
    unless_null $P185, vivify_190
    $P185 = root_new ['parrot';'Hash']
  vivify_190:
    set $P186, $P185["definedness"]
    unless_null $P186, vivify_191
    new $P186, "Undef"
  vivify_191:
    set $S187, $P186
    iseq $I188, $S187, "D"
    if $I188, if_184
.annotate 'line', 826
    find_lex $P192, "$_"
    unless_null $P192, vivify_192
    $P192 = root_new ['parrot';'Hash']
  vivify_192:
    set $P193, $P192["definedness"]
    unless_null $P193, vivify_193
    new $P193, "Undef"
  vivify_193:
    set $S194, $P193
    iseq $I195, $S194, "U"
    if $I195, if_191
    new $P197, "Integer"
    assign $P197, 0
    set $P190, $P197
    goto if_191_end
  if_191:
    new $P196, "Integer"
    assign $P196, 2
    set $P190, $P196
  if_191_end:
    set $P183, $P190
.annotate 'line', 825
    goto if_184_end
  if_184:
    new $P189, "Integer"
    assign $P189, 1
    set $P183, $P189
  if_184_end:
    $P198 = $P182."push"($P183)
.annotate 'line', 823
    set $P164, $P198
  if_165_end:
.annotate 'line', 822
    .return ($P164)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_lexical"  :subid("22_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_215
.annotate 'line', 1104
    .const 'Sub' $P221 = "23_1300060192.103" 
    capture_lex $P221
    new $P214, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P214, control_213
    push_eh $P214
    .lex "$name", param_215
.annotate 'line', 1105
    get_global $P217, "@BLOCK"
    defined $I218, $P217
    unless $I218, for_undef_194
    iter $P216, $P217
    new $P234, 'ExceptionHandler'
    set_label $P234, loop233_handler
    $P234."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P234
  loop233_test:
    unless $P216, loop233_done
    shift $P219, $P216
  loop233_redo:
    .const 'Sub' $P221 = "23_1300060192.103" 
    capture_lex $P221
    $P221($P219)
  loop233_next:
    goto loop233_test
  loop233_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P235, exception, 'type'
    eq $P235, .CONTROL_LOOP_NEXT, loop233_next
    eq $P235, .CONTROL_LOOP_REDO, loop233_redo
  loop233_done:
    pop_eh 
  for_undef_194:
.annotate 'line', 1104
    .return (0)
  control_213:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P236, exception, "payload"
    .return ($P236)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block220"  :anon :subid("23_1300060192.103") :outer("22_1300060192.103")
    .param pmc param_223
.annotate 'line', 1106
    $P222 = root_new ['parrot';'Hash']
    .lex "%sym", $P222
    .lex "$_", param_223
    find_lex $P224, "$_"
    find_lex $P225, "$name"
    $P226 = $P224."symbol"($P225)
    store_lex "%sym", $P226
.annotate 'line', 1107
    find_lex $P229, "%sym"
    set $N230, $P229
    if $N230, if_228
    new $P227, 'Float'
    set $P227, $N230
    goto if_228_end
  if_228:
.annotate 'line', 1108
    new $P231, "Exception"
    set $P231['type'], .CONTROL_RETURN
    new $P232, "Integer"
    assign $P232, 1
    setattribute $P231, 'payload', $P232
    throw $P231
  if_228_end:
.annotate 'line', 1105
    .return ($P227)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("24_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_239
    .param pmc param_240
.annotate 'line', 1312
    .lex "$/", param_239
    .lex "$type", param_240
.annotate 'line', 1313
    find_lex $P241, "$/"
    get_hll_global $P242, ["PAST"], "Op"
    find_lex $P243, "$/"
.annotate 'line', 1317
    get_hll_global $P244, ["PAST"], "Val"
    find_lex $P245, "$type"
    $P246 = $P244."new"($P245 :named("value"), "!except_types" :named("returns"))
    $P247 = $P242."new"(0, $P246, $P243 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1313
    $P248 = $P241."!make"($P247)
.annotate 'line', 1312
    .return ($P248)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block251"  :anon :subid("25_1300060192.103") :outer("11_1300060192.103")
.annotate 'line', 1
    .const 'Sub' $P254 = "26_1300060192.103" 
    capture_lex $P254
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post195") :outer("25_1300060192.103")
.annotate 'line', 1
    .const 'Sub' $P252 = "25_1300060192.103" 
    .local pmc block
    set block, $P252
.annotate 'line', 5
    .const 'Sub' $P254 = "26_1300060192.103" 
    capture_lex $P254
    $P254()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block253"  :anon :subid("26_1300060192.103") :outer("25_1300060192.103")
.annotate 'line', 6
    get_global $P255, "@BLOCK"
    unless_null $P255, vivify_196
    $P255 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P255
  vivify_196:
 $P256 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P256
.annotate 'line', 5
    .return ($P256)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("27_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_261
    .param pmc param_262
.annotate 'line', 33
    .lex "self", param_261
    .lex "$/", param_262
    find_lex $P263, "$/"
    find_lex $P264, "$/"
    unless_null $P264, vivify_197
    $P264 = root_new ['parrot';'Hash']
  vivify_197:
    set $P265, $P264["comp_unit"]
    unless_null $P265, vivify_198
    new $P265, "Undef"
  vivify_198:
    $P266 = $P265."ast"()
    $P267 = $P263."!make"($P266)
    .return ($P267)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("28_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_269
    .param pmc param_270
.annotate 'line', 35
    .lex "self", param_269
    .lex "$/", param_270
.annotate 'line', 36
    find_lex $P271, "$/"
.annotate 'line', 37
    find_lex $P274, "$/"
    unless_null $P274, vivify_199
    $P274 = root_new ['parrot';'Hash']
  vivify_199:
    set $P275, $P274["colonpair"]
    unless_null $P275, vivify_200
    new $P275, "Undef"
  vivify_200:
    if $P275, if_273
.annotate 'line', 39
    find_lex $P295, "$/"
    set $S296, $P295
    new $P272, 'String'
    set $P272, $S296
.annotate 'line', 37
    goto if_273_end
  if_273:
    find_lex $P276, "$/"
    unless_null $P276, vivify_201
    $P276 = root_new ['parrot';'Hash']
  vivify_201:
    set $P277, $P276["identifier"]
    unless_null $P277, vivify_202
    new $P277, "Undef"
  vivify_202:
    set $S278, $P277
    new $P279, 'String'
    set $P279, $S278
    concat $P280, $P279, ":"
    find_lex $P281, "$/"
    unless_null $P281, vivify_203
    $P281 = root_new ['parrot';'Hash']
  vivify_203:
    set $P282, $P281["colonpair"]
    unless_null $P282, vivify_204
    $P282 = root_new ['parrot';'ResizablePMCArray']
  vivify_204:
    set $P283, $P282[0]
    unless_null $P283, vivify_205
    new $P283, "Undef"
  vivify_205:
    $P284 = $P283."ast"()
    $S285 = $P284."named"()
    concat $P286, $P280, $S285
    concat $P287, $P286, "<"
.annotate 'line', 38
    find_lex $P288, "$/"
    unless_null $P288, vivify_206
    $P288 = root_new ['parrot';'Hash']
  vivify_206:
    set $P289, $P288["colonpair"]
    unless_null $P289, vivify_207
    $P289 = root_new ['parrot';'ResizablePMCArray']
  vivify_207:
    set $P290, $P289[0]
    unless_null $P290, vivify_208
    new $P290, "Undef"
  vivify_208:
    $P291 = $P290."ast"()
    $S292 = "colonpair_str"($P291)
    concat $P293, $P287, $S292
    concat $P294, $P293, ">"
    set $P272, $P294
  if_273_end:
.annotate 'line', 37
    $P297 = $P271."!make"($P272)
.annotate 'line', 35
    .return ($P297)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("29_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_300
    .param pmc param_301
.annotate 'line', 49
    .lex "self", param_300
    .lex "$/", param_301
.annotate 'line', 50
    new $P302, "Undef"
    .lex "$mainline", $P302
.annotate 'line', 51
    new $P303, "Undef"
    .lex "$unit", $P303
.annotate 'line', 50
    find_lex $P304, "$/"
    unless_null $P304, vivify_209
    $P304 = root_new ['parrot';'Hash']
  vivify_209:
    set $P305, $P304["statementlist"]
    unless_null $P305, vivify_210
    new $P305, "Undef"
  vivify_210:
    $P306 = $P305."ast"()
    store_lex "$mainline", $P306
.annotate 'line', 51
    get_global $P307, "@BLOCK"
    $P308 = $P307."shift"()
    store_lex "$unit", $P308
.annotate 'line', 55
    find_lex $P309, "$unit"
    $P310 = $P309."loadinit"()
    find_dynamic_lex $P311, "$*SC"
    unless_null $P311, vivify_211
    get_hll_global $P311, "$SC"
    unless_null $P311, vivify_212
    die "Contextual $*SC not found"
  vivify_212:
  vivify_211:
    $P312 = $P311."to_past"()
    $P310."push"($P312)
.annotate 'line', 60
    find_dynamic_lex $P314, "$*HAS_YOU_ARE_HERE"
    unless_null $P314, vivify_213
    get_hll_global $P314, "$HAS_YOU_ARE_HERE"
    unless_null $P314, vivify_214
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_214:
  vivify_213:
    if $P314, unless_313_end
.annotate 'line', 61
    find_lex $P315, "$unit"
    find_lex $P316, "self"
    $P317 = $P316."CTXSAVE"()
    $P315."push"($P317)
  unless_313_end:
.annotate 'line', 65
    find_lex $P318, "$unit"
    $P318."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 68
    find_dynamic_lex $P320, "$*MAIN_SUB"
    unless_null $P320, vivify_215
    get_hll_global $P320, "$MAIN_SUB"
    unless_null $P320, vivify_216
    die "Contextual $*MAIN_SUB not found"
  vivify_216:
  vivify_215:
    unless $P320, if_319_end
.annotate 'line', 69
    find_lex $P321, "$unit"
    get_hll_global $P322, ["PAST"], "Var"
    $P323 = $P322."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P321."unshift"($P323)
.annotate 'line', 70
    find_lex $P324, "$mainline"
    get_hll_global $P325, ["PAST"], "Op"
.annotate 'line', 71
    get_hll_global $P326, ["PAST"], "Val"
    find_dynamic_lex $P327, "$*MAIN_SUB"
    unless_null $P327, vivify_217
    get_hll_global $P327, "$MAIN_SUB"
    unless_null $P327, vivify_218
    die "Contextual $*MAIN_SUB not found"
  vivify_218:
  vivify_217:
    $P328 = $P326."new"($P327 :named("value"))
.annotate 'line', 72
    get_hll_global $P329, ["PAST"], "Var"
    $P330 = $P329."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P331 = $P325."new"($P328, $P330, "call" :named("pasttype"))
.annotate 'line', 70
    $P324."push"($P331)
  if_319_end:
.annotate 'line', 79
    find_lex $P332, "$unit"
.annotate 'line', 80
    get_hll_global $P333, ["PAST"], "Op"
    find_lex $P334, "$mainline"
    $P335 = $P333."new"($P334, "return" :named("pirop"))
    $P332."push"($P335)
.annotate 'line', 85
    find_lex $P336, "$unit"
.annotate 'line', 86
    get_hll_global $P337, ["PAST"], "Block"
.annotate 'line', 88
    get_hll_global $P338, ["PAST"], "Op"
    get_hll_global $P339, ["PAST"], "Val"
    find_lex $P340, "$unit"
    $P341 = $P339."new"($P340 :named("value"))
    $P342 = $P338."new"($P341, "call" :named("pasttype"))
    $P343 = $P337."new"($P342, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 86
    $P336."push"($P343)
.annotate 'line', 91
    find_lex $P344, "$unit"
    find_lex $P345, "$/"
    $P344."node"($P345)
.annotate 'line', 94
    find_lex $P346, "$unit"
    $P346."hll"("nqp")
.annotate 'line', 96
    find_lex $P347, "$/"
    find_lex $P348, "$unit"
    $P349 = $P347."!make"($P348)
.annotate 'line', 49
    .return ($P349)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("30_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_351
    .param pmc param_352
.annotate 'line', 99
    .const 'Sub' $P366 = "31_1300060192.103" 
    capture_lex $P366
    .lex "self", param_351
    .lex "$/", param_352
.annotate 'line', 100
    new $P353, "Undef"
    .lex "$past", $P353
    get_hll_global $P354, ["PAST"], "Stmts"
    find_lex $P355, "$/"
    $P356 = $P354."new"($P355 :named("node"))
    store_lex "$past", $P356
.annotate 'line', 101
    find_lex $P358, "$/"
    unless_null $P358, vivify_219
    $P358 = root_new ['parrot';'Hash']
  vivify_219:
    set $P359, $P358["statement"]
    unless_null $P359, vivify_220
    new $P359, "Undef"
  vivify_220:
    unless $P359, if_357_end
.annotate 'line', 102
    find_lex $P361, "$/"
    unless_null $P361, vivify_221
    $P361 = root_new ['parrot';'Hash']
  vivify_221:
    set $P362, $P361["statement"]
    unless_null $P362, vivify_222
    new $P362, "Undef"
  vivify_222:
    defined $I363, $P362
    unless $I363, for_undef_223
    iter $P360, $P362
    new $P386, 'ExceptionHandler'
    set_label $P386, loop385_handler
    $P386."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P386
  loop385_test:
    unless $P360, loop385_done
    shift $P364, $P360
  loop385_redo:
    .const 'Sub' $P366 = "31_1300060192.103" 
    capture_lex $P366
    $P366($P364)
  loop385_next:
    goto loop385_test
  loop385_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P387, exception, 'type'
    eq $P387, .CONTROL_LOOP_NEXT, loop385_next
    eq $P387, .CONTROL_LOOP_REDO, loop385_redo
  loop385_done:
    pop_eh 
  for_undef_223:
  if_357_end:
.annotate 'line', 109
    find_lex $P388, "$/"
    find_lex $P389, "$past"
    $P390 = $P388."!make"($P389)
.annotate 'line', 99
    .return ($P390)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block365"  :anon :subid("31_1300060192.103") :outer("30_1300060192.103")
    .param pmc param_368
.annotate 'line', 103
    new $P367, "Undef"
    .lex "$ast", $P367
    .lex "$_", param_368
    find_lex $P369, "$_"
    $P370 = $P369."ast"()
    store_lex "$ast", $P370
.annotate 'line', 104
    find_lex $P372, "$ast"
    unless_null $P372, vivify_224
    $P372 = root_new ['parrot';'Hash']
  vivify_224:
    set $P373, $P372["sink"]
    unless_null $P373, vivify_225
    new $P373, "Undef"
  vivify_225:
    defined $I374, $P373
    unless $I374, if_371_end
    find_lex $P375, "$ast"
    unless_null $P375, vivify_226
    $P375 = root_new ['parrot';'Hash']
  vivify_226:
    set $P376, $P375["sink"]
    unless_null $P376, vivify_227
    new $P376, "Undef"
  vivify_227:
    store_lex "$ast", $P376
  if_371_end:
.annotate 'line', 105
    find_lex $P378, "$ast"
    unless_null $P378, vivify_228
    $P378 = root_new ['parrot';'Hash']
  vivify_228:
    set $P379, $P378["bareblock"]
    unless_null $P379, vivify_229
    new $P379, "Undef"
  vivify_229:
    unless $P379, if_377_end
    find_lex $P380, "$ast"
    $P381 = "block_immediate"($P380)
    store_lex "$ast", $P381
  if_377_end:
.annotate 'line', 106
    find_lex $P382, "$past"
    find_lex $P383, "$ast"
    $P384 = $P382."push"($P383)
.annotate 'line', 102
    .return ($P384)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("32_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_392
    .param pmc param_393
    .param pmc param_394 :optional
    .param int has_param_394 :opt_flag
.annotate 'line', 112
    .const 'Sub' $P402 = "33_1300060192.103" 
    capture_lex $P402
    .lex "self", param_392
    .lex "$/", param_393
    if has_param_394, optparam_230
    new $P395, "Undef"
    set param_394, $P395
  optparam_230:
    .lex "$key", param_394
.annotate 'line', 113
    new $P396, "Undef"
    .lex "$past", $P396
.annotate 'line', 112
    find_lex $P397, "$past"
.annotate 'line', 114
    find_lex $P399, "$/"
    unless_null $P399, vivify_231
    $P399 = root_new ['parrot';'Hash']
  vivify_231:
    set $P400, $P399["EXPR"]
    unless_null $P400, vivify_232
    new $P400, "Undef"
  vivify_232:
    if $P400, if_398
.annotate 'line', 135
    find_lex $P463, "$/"
    unless_null $P463, vivify_233
    $P463 = root_new ['parrot';'Hash']
  vivify_233:
    set $P464, $P463["statement_control"]
    unless_null $P464, vivify_234
    new $P464, "Undef"
  vivify_234:
    if $P464, if_462
.annotate 'line', 136
    new $P468, "Integer"
    assign $P468, 0
    store_lex "$past", $P468
    goto if_462_end
  if_462:
.annotate 'line', 135
    find_lex $P465, "$/"
    unless_null $P465, vivify_235
    $P465 = root_new ['parrot';'Hash']
  vivify_235:
    set $P466, $P465["statement_control"]
    unless_null $P466, vivify_236
    new $P466, "Undef"
  vivify_236:
    $P467 = $P466."ast"()
    store_lex "$past", $P467
  if_462_end:
    goto if_398_end
  if_398:
.annotate 'line', 114
    .const 'Sub' $P402 = "33_1300060192.103" 
    capture_lex $P402
    $P402()
  if_398_end:
.annotate 'line', 137
    find_lex $P469, "$/"
    find_lex $P470, "$past"
    $P471 = $P469."!make"($P470)
.annotate 'line', 112
    .return ($P471)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block401"  :anon :subid("33_1300060192.103") :outer("32_1300060192.103")
.annotate 'line', 115
    new $P403, "Undef"
    .lex "$mc", $P403
.annotate 'line', 116
    new $P404, "Undef"
    .lex "$ml", $P404
.annotate 'line', 115
    find_lex $P405, "$/"
    unless_null $P405, vivify_237
    $P405 = root_new ['parrot';'Hash']
  vivify_237:
    set $P406, $P405["statement_mod_cond"]
    unless_null $P406, vivify_238
    $P406 = root_new ['parrot';'ResizablePMCArray']
  vivify_238:
    set $P407, $P406[0]
    unless_null $P407, vivify_239
    new $P407, "Undef"
  vivify_239:
    store_lex "$mc", $P407
.annotate 'line', 116
    find_lex $P408, "$/"
    unless_null $P408, vivify_240
    $P408 = root_new ['parrot';'Hash']
  vivify_240:
    set $P409, $P408["statement_mod_loop"]
    unless_null $P409, vivify_241
    $P409 = root_new ['parrot';'ResizablePMCArray']
  vivify_241:
    set $P410, $P409[0]
    unless_null $P410, vivify_242
    new $P410, "Undef"
  vivify_242:
    store_lex "$ml", $P410
.annotate 'line', 117
    find_lex $P411, "$/"
    unless_null $P411, vivify_243
    $P411 = root_new ['parrot';'Hash']
  vivify_243:
    set $P412, $P411["EXPR"]
    unless_null $P412, vivify_244
    new $P412, "Undef"
  vivify_244:
    $P413 = $P412."ast"()
    store_lex "$past", $P413
.annotate 'line', 118
    find_lex $P415, "$mc"
    unless $P415, if_414_end
.annotate 'line', 119
    get_hll_global $P416, ["PAST"], "Op"
    find_lex $P417, "$mc"
    unless_null $P417, vivify_245
    $P417 = root_new ['parrot';'Hash']
  vivify_245:
    set $P418, $P417["cond"]
    unless_null $P418, vivify_246
    new $P418, "Undef"
  vivify_246:
    $P419 = $P418."ast"()
    find_lex $P420, "$past"
    find_lex $P421, "$mc"
    unless_null $P421, vivify_247
    $P421 = root_new ['parrot';'Hash']
  vivify_247:
    set $P422, $P421["sym"]
    unless_null $P422, vivify_248
    new $P422, "Undef"
  vivify_248:
    set $S423, $P422
    find_lex $P424, "$/"
    $P425 = $P416."new"($P419, $P420, $S423 :named("pasttype"), $P424 :named("node"))
    store_lex "$past", $P425
  if_414_end:
.annotate 'line', 121
    find_lex $P428, "$ml"
    if $P428, if_427
    set $P426, $P428
    goto if_427_end
  if_427:
.annotate 'line', 122
    find_lex $P431, "$ml"
    unless_null $P431, vivify_249
    $P431 = root_new ['parrot';'Hash']
  vivify_249:
    set $P432, $P431["sym"]
    unless_null $P432, vivify_250
    new $P432, "Undef"
  vivify_250:
    set $S433, $P432
    iseq $I434, $S433, "for"
    if $I434, if_430
.annotate 'line', 131
    get_hll_global $P452, ["PAST"], "Op"
    find_lex $P453, "$ml"
    unless_null $P453, vivify_251
    $P453 = root_new ['parrot';'Hash']
  vivify_251:
    set $P454, $P453["cond"]
    unless_null $P454, vivify_252
    new $P454, "Undef"
  vivify_252:
    $P455 = $P454."ast"()
    find_lex $P456, "$past"
    find_lex $P457, "$ml"
    unless_null $P457, vivify_253
    $P457 = root_new ['parrot';'Hash']
  vivify_253:
    set $P458, $P457["sym"]
    unless_null $P458, vivify_254
    new $P458, "Undef"
  vivify_254:
    set $S459, $P458
    find_lex $P460, "$/"
    $P461 = $P452."new"($P455, $P456, $S459 :named("pasttype"), $P460 :named("node"))
    store_lex "$past", $P461
.annotate 'line', 130
    set $P429, $P461
.annotate 'line', 122
    goto if_430_end
  if_430:
.annotate 'line', 123
    get_hll_global $P435, ["PAST"], "Block"
.annotate 'line', 124
    get_hll_global $P436, ["PAST"], "Var"
    $P437 = $P436."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P438, "$past"
    $P439 = $P435."new"($P437, $P438, "immediate" :named("blocktype"))
.annotate 'line', 123
    store_lex "$past", $P439
.annotate 'line', 126
    find_lex $P440, "$past"
    $P440."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 127
    find_lex $P441, "$past"
    $P441."arity"(1)
.annotate 'line', 128
    get_hll_global $P442, ["PAST"], "Op"
    find_lex $P443, "$ml"
    unless_null $P443, vivify_255
    $P443 = root_new ['parrot';'Hash']
  vivify_255:
    set $P444, $P443["cond"]
    unless_null $P444, vivify_256
    new $P444, "Undef"
  vivify_256:
    $P445 = $P444."ast"()
    find_lex $P446, "$past"
    find_lex $P447, "$ml"
    unless_null $P447, vivify_257
    $P447 = root_new ['parrot';'Hash']
  vivify_257:
    set $P448, $P447["sym"]
    unless_null $P448, vivify_258
    new $P448, "Undef"
  vivify_258:
    set $S449, $P448
    find_lex $P450, "$/"
    $P451 = $P442."new"($P445, $P446, $S449 :named("pasttype"), $P450 :named("node"))
    store_lex "$past", $P451
.annotate 'line', 122
    set $P429, $P451
  if_430_end:
.annotate 'line', 121
    set $P426, $P429
  if_427_end:
.annotate 'line', 114
    .return ($P426)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("34_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_473
    .param pmc param_474
.annotate 'line', 140
    .lex "self", param_473
    .lex "$/", param_474
.annotate 'line', 141
    find_lex $P475, "$/"
    get_hll_global $P476, ["PAST"], "Op"
    find_lex $P477, "$/"
    unless_null $P477, vivify_259
    $P477 = root_new ['parrot';'Hash']
  vivify_259:
    set $P478, $P477["EXPR"]
    unless_null $P478, vivify_260
    new $P478, "Undef"
  vivify_260:
    $P479 = $P478."ast"()
    find_lex $P480, "$/"
    unless_null $P480, vivify_261
    $P480 = root_new ['parrot';'Hash']
  vivify_261:
    set $P481, $P480["pblock"]
    unless_null $P481, vivify_262
    new $P481, "Undef"
  vivify_262:
    $P482 = $P481."ast"()
    find_lex $P483, "$/"
    $P484 = $P476."new"($P479, $P482, "if" :named("pasttype"), $P483 :named("node"))
    $P485 = $P475."!make"($P484)
.annotate 'line', 140
    .return ($P485)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("35_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_487
    .param pmc param_488
.annotate 'line', 144
    .lex "self", param_487
    .lex "$/", param_488
.annotate 'line', 145
    find_lex $P489, "$/"
    find_lex $P490, "$/"
    unless_null $P490, vivify_263
    $P490 = root_new ['parrot';'Hash']
  vivify_263:
    set $P491, $P490["blockoid"]
    unless_null $P491, vivify_264
    new $P491, "Undef"
  vivify_264:
    $P492 = $P491."ast"()
    $P493 = $P489."!make"($P492)
.annotate 'line', 144
    .return ($P493)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("36_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_495
    .param pmc param_496
.annotate 'line', 148
    .lex "self", param_495
    .lex "$/", param_496
.annotate 'line', 149
    find_lex $P497, "$/"
    find_lex $P498, "$/"
    unless_null $P498, vivify_265
    $P498 = root_new ['parrot';'Hash']
  vivify_265:
    set $P499, $P498["blockoid"]
    unless_null $P499, vivify_266
    new $P499, "Undef"
  vivify_266:
    $P500 = $P499."ast"()
    $P501 = $P497."!make"($P500)
.annotate 'line', 148
    .return ($P501)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("37_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_503
    .param pmc param_504
.annotate 'line', 152
    .const 'Sub' $P513 = "38_1300060192.103" 
    capture_lex $P513
    .lex "self", param_503
    .lex "$/", param_504
.annotate 'line', 153
    new $P505, "Undef"
    .lex "$BLOCK", $P505
    get_global $P506, "@BLOCK"
    $P507 = $P506."shift"()
    store_lex "$BLOCK", $P507
.annotate 'line', 154
    find_lex $P510, "$/"
    unless_null $P510, vivify_267
    $P510 = root_new ['parrot';'Hash']
  vivify_267:
    set $P511, $P510["statementlist"]
    unless_null $P511, vivify_268
    new $P511, "Undef"
  vivify_268:
    if $P511, if_509
.annotate 'line', 162
    find_dynamic_lex $P528, "$*HAS_YOU_ARE_HERE"
    unless_null $P528, vivify_269
    get_hll_global $P528, "$HAS_YOU_ARE_HERE"
    unless_null $P528, vivify_270
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_270:
  vivify_269:
    unless $P528, if_527_end
.annotate 'line', 163
    find_lex $P529, "$/"
    $P530 = $P529."CURSOR"()
    $P530."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_527_end:
.annotate 'line', 165
    new $P531, "Integer"
    assign $P531, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P531
.annotate 'line', 166
    find_lex $P532, "$/"
    find_lex $P533, "$/"
    unless_null $P533, vivify_271
    $P533 = root_new ['parrot';'Hash']
  vivify_271:
    set $P534, $P533["you_are_here"]
    unless_null $P534, vivify_272
    new $P534, "Undef"
  vivify_272:
    $P535 = $P534."ast"()
    $P536 = $P532."!make"($P535)
.annotate 'line', 161
    set $P508, $P536
.annotate 'line', 154
    goto if_509_end
  if_509:
    .const 'Sub' $P513 = "38_1300060192.103" 
    capture_lex $P513
    $P526 = $P513()
    set $P508, $P526
  if_509_end:
.annotate 'line', 152
    .return ($P508)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block512"  :anon :subid("38_1300060192.103") :outer("37_1300060192.103")
.annotate 'line', 155
    new $P514, "Undef"
    .lex "$past", $P514
    find_lex $P515, "$/"
    unless_null $P515, vivify_273
    $P515 = root_new ['parrot';'Hash']
  vivify_273:
    set $P516, $P515["statementlist"]
    unless_null $P516, vivify_274
    new $P516, "Undef"
  vivify_274:
    $P517 = $P516."ast"()
    store_lex "$past", $P517
.annotate 'line', 156
    find_lex $P518, "$BLOCK"
    find_lex $P519, "$past"
    $P518."push"($P519)
.annotate 'line', 157
    find_lex $P520, "$BLOCK"
    find_lex $P521, "$/"
    $P520."node"($P521)
.annotate 'line', 158
    find_lex $P522, "$BLOCK"
    $P522."closure"(1)
.annotate 'line', 159
    find_dynamic_lex $P523, "$/"
    find_lex $P524, "$BLOCK"
    $P525 = $P523."!make"($P524)
.annotate 'line', 154
    .return ($P525)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("39_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_538
    .param pmc param_539
.annotate 'line', 170
    .lex "self", param_538
    .lex "$/", param_539
.annotate 'line', 171
    get_global $P540, "@BLOCK"
    unless_null $P540, vivify_275
    $P540 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P540
  vivify_275:
.annotate 'line', 170
    get_global $P541, "@BLOCK"
.annotate 'line', 172
    get_global $P542, "@BLOCK"
    get_hll_global $P543, ["PAST"], "Block"
    get_hll_global $P544, ["PAST"], "Stmts"
    $P545 = $P544."new"()
    $P546 = $P543."new"($P545)
    $P547 = $P542."unshift"($P546)
.annotate 'line', 170
    .return ($P547)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("40_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_549
    .param pmc param_550
.annotate 'line', 175
    .lex "self", param_549
    .lex "$/", param_550
.annotate 'line', 176
    get_global $P551, "@BLOCK"
    unless_null $P551, vivify_276
    $P551 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P551
  vivify_276:
.annotate 'line', 175
    get_global $P552, "@BLOCK"
.annotate 'line', 177
    find_dynamic_lex $P554, "%*COMPILING"
    unless_null $P554, vivify_277
    get_hll_global $P554, "%COMPILING"
    unless_null $P554, vivify_278
    die "Contextual %*COMPILING not found"
  vivify_278:
  vivify_277:
    set $P555, $P554["%?OPTIONS"]
    unless_null $P555, vivify_279
    $P555 = root_new ['parrot';'Hash']
  vivify_279:
    set $P556, $P555["outer_ctx"]
    unless_null $P556, vivify_280
    new $P556, "Undef"
  vivify_280:
    defined $I557, $P556
    if $I557, unless_553_end
.annotate 'line', 180
    find_dynamic_lex $P558, "$*SC"
    unless_null $P558, vivify_281
    get_hll_global $P558, "$SC"
    unless_null $P558, vivify_282
    die "Contextual $*SC not found"
  vivify_282:
  vivify_281:
    find_dynamic_lex $P560, "%*COMPILING"
    unless_null $P560, vivify_283
    get_hll_global $P560, "%COMPILING"
    unless_null $P560, vivify_284
    die "Contextual %*COMPILING not found"
  vivify_284:
  vivify_283:
    set $P561, $P560["%?OPTIONS"]
    unless_null $P561, vivify_285
    $P561 = root_new ['parrot';'Hash']
  vivify_285:
    set $P562, $P561["setting"]
    unless_null $P562, vivify_286
    new $P562, "Undef"
  vivify_286:
    set $P559, $P562
    defined $I564, $P559
    if $I564, default_563
    new $P565, "String"
    assign $P565, "NQPCORE"
    set $P559, $P565
  default_563:
    $P558."load_setting"($P559)
  unless_553_end:
.annotate 'line', 182
    find_lex $P566, "self"
    get_global $P567, "@BLOCK"
    unless_null $P567, vivify_287
    $P567 = root_new ['parrot';'ResizablePMCArray']
  vivify_287:
    set $P568, $P567[0]
    unless_null $P568, vivify_288
    new $P568, "Undef"
  vivify_288:
    $P569 = $P566."SET_BLOCK_OUTER_CTX"($P568)
.annotate 'line', 175
    .return ($P569)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("41_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_571
    .param pmc param_572
.annotate 'line', 185
    .lex "self", param_571
    .lex "$/", param_572
.annotate 'line', 186
    find_lex $P573, "$/"
    find_lex $P574, "self"
    $P575 = $P574."CTXSAVE"()
    $P576 = $P573."!make"($P575)
.annotate 'line', 185
    .return ($P576)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("42_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_578
    .param pmc param_579
.annotate 'line', 191
    .lex "self", param_578
    .lex "$/", param_579
.annotate 'line', 192
    find_dynamic_lex $P580, "$*SC"
    unless_null $P580, vivify_289
    get_hll_global $P580, "$SC"
    unless_null $P580, vivify_290
    die "Contextual $*SC not found"
  vivify_290:
  vivify_289:
    find_lex $P581, "$/"
    unless_null $P581, vivify_291
    $P581 = root_new ['parrot';'Hash']
  vivify_291:
    set $P582, $P581["name"]
    unless_null $P582, vivify_292
    new $P582, "Undef"
  vivify_292:
    set $S583, $P582
    $P580."load_module"($S583)
.annotate 'line', 193
    find_lex $P584, "$/"
    get_hll_global $P585, ["PAST"], "Stmts"
    $P586 = $P585."new"()
    $P587 = $P584."!make"($P586)
.annotate 'line', 191
    .return ($P587)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("43_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_589
    .param pmc param_590
.annotate 'line', 196
    .const 'Sub' $P618 = "44_1300060192.103" 
    capture_lex $P618
    .lex "self", param_589
    .lex "$/", param_590
.annotate 'line', 197
    new $P591, "Undef"
    .lex "$count", $P591
.annotate 'line', 198
    new $P592, "Undef"
    .lex "$past", $P592
.annotate 'line', 197
    find_lex $P593, "$/"
    unless_null $P593, vivify_293
    $P593 = root_new ['parrot';'Hash']
  vivify_293:
    set $P594, $P593["xblock"]
    unless_null $P594, vivify_294
    new $P594, "Undef"
  vivify_294:
    set $N595, $P594
    new $P596, 'Float'
    set $P596, $N595
    sub $P597, $P596, 1
    store_lex "$count", $P597
.annotate 'line', 198
    find_lex $P598, "$count"
    set $I599, $P598
    find_lex $P600, "$/"
    unless_null $P600, vivify_295
    $P600 = root_new ['parrot';'Hash']
  vivify_295:
    set $P601, $P600["xblock"]
    unless_null $P601, vivify_296
    $P601 = root_new ['parrot';'ResizablePMCArray']
  vivify_296:
    set $P602, $P601[$I599]
    unless_null $P602, vivify_297
    new $P602, "Undef"
  vivify_297:
    $P603 = $P602."ast"()
    $P604 = "xblock_immediate"($P603)
    store_lex "$past", $P604
.annotate 'line', 199
    find_lex $P606, "$/"
    unless_null $P606, vivify_298
    $P606 = root_new ['parrot';'Hash']
  vivify_298:
    set $P607, $P606["else"]
    unless_null $P607, vivify_299
    new $P607, "Undef"
  vivify_299:
    unless $P607, if_605_end
.annotate 'line', 200
    find_lex $P608, "$past"
    find_lex $P609, "$/"
    unless_null $P609, vivify_300
    $P609 = root_new ['parrot';'Hash']
  vivify_300:
    set $P610, $P609["else"]
    unless_null $P610, vivify_301
    $P610 = root_new ['parrot';'ResizablePMCArray']
  vivify_301:
    set $P611, $P610[0]
    unless_null $P611, vivify_302
    new $P611, "Undef"
  vivify_302:
    $P612 = $P611."ast"()
    $P613 = "block_immediate"($P612)
    $P608."push"($P613)
  if_605_end:
.annotate 'line', 203
    new $P634, 'ExceptionHandler'
    set_label $P634, loop633_handler
    $P634."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P634
  loop633_test:
    find_lex $P614, "$count"
    set $N615, $P614
    isgt $I616, $N615, 0.0
    unless $I616, loop633_done
  loop633_redo:
    .const 'Sub' $P618 = "44_1300060192.103" 
    capture_lex $P618
    $P618()
  loop633_next:
    goto loop633_test
  loop633_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P635, exception, 'type'
    eq $P635, .CONTROL_LOOP_NEXT, loop633_next
    eq $P635, .CONTROL_LOOP_REDO, loop633_redo
  loop633_done:
    pop_eh 
.annotate 'line', 209
    find_lex $P636, "$/"
    find_lex $P637, "$past"
    $P638 = $P636."!make"($P637)
.annotate 'line', 196
    .return ($P638)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block617"  :anon :subid("44_1300060192.103") :outer("43_1300060192.103")
.annotate 'line', 205
    new $P619, "Undef"
    .lex "$else", $P619
.annotate 'line', 203
    find_lex $P620, "$count"
    clone $P621, $P620
    dec $P620
.annotate 'line', 205
    find_lex $P622, "$past"
    store_lex "$else", $P622
.annotate 'line', 206
    find_lex $P623, "$count"
    set $I624, $P623
    find_lex $P625, "$/"
    unless_null $P625, vivify_303
    $P625 = root_new ['parrot';'Hash']
  vivify_303:
    set $P626, $P625["xblock"]
    unless_null $P626, vivify_304
    $P626 = root_new ['parrot';'ResizablePMCArray']
  vivify_304:
    set $P627, $P626[$I624]
    unless_null $P627, vivify_305
    new $P627, "Undef"
  vivify_305:
    $P628 = $P627."ast"()
    $P629 = "xblock_immediate"($P628)
    store_lex "$past", $P629
.annotate 'line', 207
    find_lex $P630, "$past"
    find_lex $P631, "$else"
    $P632 = $P630."push"($P631)
.annotate 'line', 203
    .return ($P632)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("45_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_640
    .param pmc param_641
.annotate 'line', 212
    .lex "self", param_640
    .lex "$/", param_641
.annotate 'line', 213
    new $P642, "Undef"
    .lex "$past", $P642
    find_lex $P643, "$/"
    unless_null $P643, vivify_306
    $P643 = root_new ['parrot';'Hash']
  vivify_306:
    set $P644, $P643["xblock"]
    unless_null $P644, vivify_307
    new $P644, "Undef"
  vivify_307:
    $P645 = $P644."ast"()
    $P646 = "xblock_immediate"($P645)
    store_lex "$past", $P646
.annotate 'line', 214
    find_lex $P647, "$past"
    $P647."pasttype"("unless")
.annotate 'line', 215
    find_lex $P648, "$/"
    find_lex $P649, "$past"
    $P650 = $P648."!make"($P649)
.annotate 'line', 212
    .return ($P650)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("46_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_652
    .param pmc param_653
.annotate 'line', 218
    .lex "self", param_652
    .lex "$/", param_653
.annotate 'line', 219
    new $P654, "Undef"
    .lex "$past", $P654
    find_lex $P655, "$/"
    unless_null $P655, vivify_308
    $P655 = root_new ['parrot';'Hash']
  vivify_308:
    set $P656, $P655["xblock"]
    unless_null $P656, vivify_309
    new $P656, "Undef"
  vivify_309:
    $P657 = $P656."ast"()
    $P658 = "xblock_immediate"($P657)
    store_lex "$past", $P658
.annotate 'line', 220
    find_lex $P659, "$past"
    find_lex $P660, "$/"
    unless_null $P660, vivify_310
    $P660 = root_new ['parrot';'Hash']
  vivify_310:
    set $P661, $P660["sym"]
    unless_null $P661, vivify_311
    new $P661, "Undef"
  vivify_311:
    set $S662, $P661
    $P659."pasttype"($S662)
.annotate 'line', 221
    find_lex $P663, "$/"
    find_lex $P664, "$past"
    $P665 = $P663."!make"($P664)
.annotate 'line', 218
    .return ($P665)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("47_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_667
    .param pmc param_668
.annotate 'line', 224
    .lex "self", param_667
    .lex "$/", param_668
.annotate 'line', 225
    new $P669, "Undef"
    .lex "$pasttype", $P669
.annotate 'line', 226
    new $P670, "Undef"
    .lex "$past", $P670
.annotate 'line', 225
    new $P671, "String"
    assign $P671, "repeat_"
    find_lex $P672, "$/"
    unless_null $P672, vivify_312
    $P672 = root_new ['parrot';'Hash']
  vivify_312:
    set $P673, $P672["wu"]
    unless_null $P673, vivify_313
    new $P673, "Undef"
  vivify_313:
    set $S674, $P673
    concat $P675, $P671, $S674
    store_lex "$pasttype", $P675
    find_lex $P676, "$past"
.annotate 'line', 227
    find_lex $P678, "$/"
    unless_null $P678, vivify_314
    $P678 = root_new ['parrot';'Hash']
  vivify_314:
    set $P679, $P678["xblock"]
    unless_null $P679, vivify_315
    new $P679, "Undef"
  vivify_315:
    if $P679, if_677
.annotate 'line', 232
    get_hll_global $P686, ["PAST"], "Op"
    find_lex $P687, "$/"
    unless_null $P687, vivify_316
    $P687 = root_new ['parrot';'Hash']
  vivify_316:
    set $P688, $P687["EXPR"]
    unless_null $P688, vivify_317
    new $P688, "Undef"
  vivify_317:
    $P689 = $P688."ast"()
    find_lex $P690, "$/"
    unless_null $P690, vivify_318
    $P690 = root_new ['parrot';'Hash']
  vivify_318:
    set $P691, $P690["pblock"]
    unless_null $P691, vivify_319
    new $P691, "Undef"
  vivify_319:
    $P692 = $P691."ast"()
    $P693 = "block_immediate"($P692)
    find_lex $P694, "$pasttype"
    find_lex $P695, "$/"
    $P696 = $P686."new"($P689, $P693, $P694 :named("pasttype"), $P695 :named("node"))
    store_lex "$past", $P696
.annotate 'line', 231
    goto if_677_end
  if_677:
.annotate 'line', 228
    find_lex $P680, "$/"
    unless_null $P680, vivify_320
    $P680 = root_new ['parrot';'Hash']
  vivify_320:
    set $P681, $P680["xblock"]
    unless_null $P681, vivify_321
    new $P681, "Undef"
  vivify_321:
    $P682 = $P681."ast"()
    $P683 = "xblock_immediate"($P682)
    store_lex "$past", $P683
.annotate 'line', 229
    find_lex $P684, "$past"
    find_lex $P685, "$pasttype"
    $P684."pasttype"($P685)
  if_677_end:
.annotate 'line', 235
    find_lex $P697, "$/"
    find_lex $P698, "$past"
    $P699 = $P697."!make"($P698)
.annotate 'line', 224
    .return ($P699)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("48_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_701
    .param pmc param_702
.annotate 'line', 238
    .lex "self", param_701
    .lex "$/", param_702
.annotate 'line', 239
    new $P703, "Undef"
    .lex "$past", $P703
.annotate 'line', 241
    new $P704, "Undef"
    .lex "$block", $P704
.annotate 'line', 239
    find_lex $P705, "$/"
    unless_null $P705, vivify_322
    $P705 = root_new ['parrot';'Hash']
  vivify_322:
    set $P706, $P705["xblock"]
    unless_null $P706, vivify_323
    new $P706, "Undef"
  vivify_323:
    $P707 = $P706."ast"()
    store_lex "$past", $P707
.annotate 'line', 240
    find_lex $P708, "$past"
    $P708."pasttype"("for")
.annotate 'line', 241
    find_lex $P709, "$past"
    unless_null $P709, vivify_324
    $P709 = root_new ['parrot';'ResizablePMCArray']
  vivify_324:
    set $P710, $P709[1]
    unless_null $P710, vivify_325
    new $P710, "Undef"
  vivify_325:
    store_lex "$block", $P710
.annotate 'line', 242
    find_lex $P712, "$block"
    $P713 = $P712."arity"()
    if $P713, unless_711_end
.annotate 'line', 243
    find_lex $P714, "$block"
    unless_null $P714, vivify_326
    $P714 = root_new ['parrot';'ResizablePMCArray']
  vivify_326:
    set $P715, $P714[0]
    unless_null $P715, vivify_327
    new $P715, "Undef"
  vivify_327:
    get_hll_global $P716, ["PAST"], "Var"
    $P717 = $P716."new"("$_" :named("name"), "parameter" :named("scope"))
    $P715."push"($P717)
.annotate 'line', 244
    find_lex $P718, "$block"
    $P718."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 245
    find_lex $P719, "$block"
    $P719."arity"(1)
  unless_711_end:
.annotate 'line', 247
    find_lex $P720, "$block"
    $P720."blocktype"("immediate")
.annotate 'line', 248
    find_lex $P721, "$/"
    find_lex $P722, "$past"
    $P723 = $P721."!make"($P722)
.annotate 'line', 238
    .return ($P723)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("49_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_725
    .param pmc param_726
.annotate 'line', 251
    .lex "self", param_725
    .lex "$/", param_726
.annotate 'line', 252
    new $P727, "Undef"
    .lex "$block", $P727
    find_lex $P728, "$/"
    unless_null $P728, vivify_328
    $P728 = root_new ['parrot';'Hash']
  vivify_328:
    set $P729, $P728["block"]
    unless_null $P729, vivify_329
    new $P729, "Undef"
  vivify_329:
    $P730 = $P729."ast"()
    store_lex "$block", $P730
.annotate 'line', 253
    find_lex $P731, "$/"
    find_lex $P732, "$block"
    "push_block_handler"($P731, $P732)
.annotate 'line', 254
    get_global $P733, "@BLOCK"
    unless_null $P733, vivify_330
    $P733 = root_new ['parrot';'ResizablePMCArray']
  vivify_330:
    set $P734, $P733[0]
    unless_null $P734, vivify_331
    new $P734, "Undef"
  vivify_331:
    $P735 = $P734."handlers"()
    set $P736, $P735[0]
    unless_null $P736, vivify_332
    new $P736, "Undef"
  vivify_332:
    $P736."handle_types_except"("CONTROL")
.annotate 'line', 255
    find_lex $P737, "$/"
    get_hll_global $P738, ["PAST"], "Stmts"
    find_lex $P739, "$/"
    $P740 = $P738."new"($P739 :named("node"))
    $P741 = $P737."!make"($P740)
.annotate 'line', 251
    .return ($P741)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("50_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_743
    .param pmc param_744
.annotate 'line', 258
    .lex "self", param_743
    .lex "$/", param_744
.annotate 'line', 259
    new $P745, "Undef"
    .lex "$block", $P745
    find_lex $P746, "$/"
    unless_null $P746, vivify_333
    $P746 = root_new ['parrot';'Hash']
  vivify_333:
    set $P747, $P746["block"]
    unless_null $P747, vivify_334
    new $P747, "Undef"
  vivify_334:
    $P748 = $P747."ast"()
    store_lex "$block", $P748
.annotate 'line', 260
    find_lex $P749, "$/"
    find_lex $P750, "$block"
    "push_block_handler"($P749, $P750)
.annotate 'line', 261
    get_global $P751, "@BLOCK"
    unless_null $P751, vivify_335
    $P751 = root_new ['parrot';'ResizablePMCArray']
  vivify_335:
    set $P752, $P751[0]
    unless_null $P752, vivify_336
    new $P752, "Undef"
  vivify_336:
    $P753 = $P752."handlers"()
    set $P754, $P753[0]
    unless_null $P754, vivify_337
    new $P754, "Undef"
  vivify_337:
    $P754."handle_types"("CONTROL")
.annotate 'line', 262
    find_lex $P755, "$/"
    get_hll_global $P756, ["PAST"], "Stmts"
    find_lex $P757, "$/"
    $P758 = $P756."new"($P757 :named("node"))
    $P759 = $P755."!make"($P758)
.annotate 'line', 258
    .return ($P759)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("51_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_762
    .param pmc param_763
.annotate 'line', 302
    .lex "self", param_762
    .lex "$/", param_763
.annotate 'line', 303
    new $P764, "Undef"
    .lex "$init_block", $P764
    get_hll_global $P765, ["PAST"], "Block"
    $P766 = $P765."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P766
.annotate 'line', 304
    find_lex $P767, "$init_block"
    $P768 = $P767."loadinit"()
    find_lex $P769, "$/"
    unless_null $P769, vivify_338
    $P769 = root_new ['parrot';'Hash']
  vivify_338:
    set $P770, $P769["blorst"]
    unless_null $P770, vivify_339
    new $P770, "Undef"
  vivify_339:
    $P771 = $P770."ast"()
    $P768."push"($P771)
.annotate 'line', 305
    find_lex $P772, "$/"
    find_lex $P773, "$init_block"
    $P774 = $P772."!make"($P773)
.annotate 'line', 302
    .return ($P774)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("52_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_776
    .param pmc param_777
.annotate 'line', 308
    .lex "self", param_776
    .lex "$/", param_777
.annotate 'line', 309
    new $P778, "Undef"
    .lex "$past", $P778
    find_lex $P779, "$/"
    unless_null $P779, vivify_340
    $P779 = root_new ['parrot';'Hash']
  vivify_340:
    set $P780, $P779["blorst"]
    unless_null $P780, vivify_341
    new $P780, "Undef"
  vivify_341:
    $P781 = $P780."ast"()
    store_lex "$past", $P781
.annotate 'line', 310
    get_hll_global $P783, ["PAST"], "Block"
    find_lex $P784, "$past"
    $P785 = $P783."ACCEPTS"($P784)
    if $P785, unless_782_end
.annotate 'line', 311
    get_hll_global $P786, ["PAST"], "Block"
    find_lex $P787, "$past"
    find_lex $P788, "$/"
    $P789 = $P786."new"($P787, "immediate" :named("blocktype"), $P788 :named("node"))
    store_lex "$past", $P789
  unless_782_end:
.annotate 'line', 313
    find_lex $P791, "$past"
    $P792 = $P791."handlers"()
    if $P792, unless_790_end
.annotate 'line', 314
    find_lex $P793, "$past"
    get_hll_global $P794, ["PAST"], "Control"
.annotate 'line', 316
    get_hll_global $P795, ["PAST"], "Stmts"
.annotate 'line', 317
    get_hll_global $P796, ["PAST"], "Op"
.annotate 'line', 318
    get_hll_global $P797, ["PAST"], "Var"
.annotate 'line', 319
    get_hll_global $P798, ["PAST"], "Var"
    $P799 = $P798."new"("register" :named("scope"), "exception" :named("name"))
    $P800 = $P797."new"($P799, "handled", "keyed" :named("scope"))
.annotate 'line', 318
    $P801 = $P796."new"($P800, 1, "bind" :named("pasttype"))
.annotate 'line', 317
    $P802 = $P795."new"($P801)
.annotate 'line', 316
    $P803 = $P794."new"($P802, "CONTROL" :named("handle_types_except"))
.annotate 'line', 314
    new $P804, "ResizablePMCArray"
    push $P804, $P803
    $P793."handlers"($P804)
  unless_790_end:
.annotate 'line', 328
    find_lex $P805, "$/"
    find_lex $P806, "$past"
    $P807 = $P805."!make"($P806)
.annotate 'line', 308
    .return ($P807)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("53_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_809
    .param pmc param_810
.annotate 'line', 331
    .lex "self", param_809
    .lex "$/", param_810
.annotate 'line', 332
    find_lex $P811, "$/"
.annotate 'line', 333
    find_lex $P814, "$/"
    unless_null $P814, vivify_342
    $P814 = root_new ['parrot';'Hash']
  vivify_342:
    set $P815, $P814["block"]
    unless_null $P815, vivify_343
    new $P815, "Undef"
  vivify_343:
    if $P815, if_813
.annotate 'line', 334
    find_lex $P820, "$/"
    unless_null $P820, vivify_344
    $P820 = root_new ['parrot';'Hash']
  vivify_344:
    set $P821, $P820["statement"]
    unless_null $P821, vivify_345
    new $P821, "Undef"
  vivify_345:
    $P822 = $P821."ast"()
    set $P812, $P822
.annotate 'line', 333
    goto if_813_end
  if_813:
    find_lex $P816, "$/"
    unless_null $P816, vivify_346
    $P816 = root_new ['parrot';'Hash']
  vivify_346:
    set $P817, $P816["block"]
    unless_null $P817, vivify_347
    new $P817, "Undef"
  vivify_347:
    $P818 = $P817."ast"()
    $P819 = "block_immediate"($P818)
    set $P812, $P819
  if_813_end:
    $P823 = $P811."!make"($P812)
.annotate 'line', 331
    .return ($P823)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("54_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_825
    .param pmc param_826
.annotate 'line', 339
    .lex "self", param_825
    .lex "$/", param_826
    find_lex $P827, "$/"
    find_lex $P828, "$/"
    unless_null $P828, vivify_348
    $P828 = root_new ['parrot';'Hash']
  vivify_348:
    set $P829, $P828["cond"]
    unless_null $P829, vivify_349
    new $P829, "Undef"
  vivify_349:
    $P830 = $P829."ast"()
    $P831 = $P827."!make"($P830)
    .return ($P831)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("55_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_833
    .param pmc param_834
.annotate 'line', 340
    .lex "self", param_833
    .lex "$/", param_834
    find_lex $P835, "$/"
    find_lex $P836, "$/"
    unless_null $P836, vivify_350
    $P836 = root_new ['parrot';'Hash']
  vivify_350:
    set $P837, $P836["cond"]
    unless_null $P837, vivify_351
    new $P837, "Undef"
  vivify_351:
    $P838 = $P837."ast"()
    $P839 = $P835."!make"($P838)
    .return ($P839)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("56_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_841
    .param pmc param_842
.annotate 'line', 342
    .lex "self", param_841
    .lex "$/", param_842
    find_lex $P843, "$/"
    find_lex $P844, "$/"
    unless_null $P844, vivify_352
    $P844 = root_new ['parrot';'Hash']
  vivify_352:
    set $P845, $P844["cond"]
    unless_null $P845, vivify_353
    new $P845, "Undef"
  vivify_353:
    $P846 = $P845."ast"()
    $P847 = $P843."!make"($P846)
    .return ($P847)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("57_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_849
    .param pmc param_850
.annotate 'line', 343
    .lex "self", param_849
    .lex "$/", param_850
    find_lex $P851, "$/"
    find_lex $P852, "$/"
    unless_null $P852, vivify_354
    $P852 = root_new ['parrot';'Hash']
  vivify_354:
    set $P853, $P852["cond"]
    unless_null $P853, vivify_355
    new $P853, "Undef"
  vivify_355:
    $P854 = $P853."ast"()
    $P855 = $P851."!make"($P854)
    .return ($P855)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("58_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_857
    .param pmc param_858
.annotate 'line', 347
    .lex "self", param_857
    .lex "$/", param_858
    find_lex $P859, "$/"
    find_lex $P860, "$/"
    unless_null $P860, vivify_356
    $P860 = root_new ['parrot';'Hash']
  vivify_356:
    set $P861, $P860["fatarrow"]
    unless_null $P861, vivify_357
    new $P861, "Undef"
  vivify_357:
    $P862 = $P861."ast"()
    $P863 = $P859."!make"($P862)
    .return ($P863)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("59_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_865
    .param pmc param_866
.annotate 'line', 348
    .lex "self", param_865
    .lex "$/", param_866
    find_lex $P867, "$/"
    find_lex $P868, "$/"
    unless_null $P868, vivify_358
    $P868 = root_new ['parrot';'Hash']
  vivify_358:
    set $P869, $P868["colonpair"]
    unless_null $P869, vivify_359
    new $P869, "Undef"
  vivify_359:
    $P870 = $P869."ast"()
    $P871 = $P867."!make"($P870)
    .return ($P871)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("60_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_873
    .param pmc param_874
.annotate 'line', 349
    .lex "self", param_873
    .lex "$/", param_874
    find_lex $P875, "$/"
    find_lex $P876, "$/"
    unless_null $P876, vivify_360
    $P876 = root_new ['parrot';'Hash']
  vivify_360:
    set $P877, $P876["variable"]
    unless_null $P877, vivify_361
    new $P877, "Undef"
  vivify_361:
    $P878 = $P877."ast"()
    $P879 = $P875."!make"($P878)
    .return ($P879)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("61_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_881
    .param pmc param_882
.annotate 'line', 350
    .lex "self", param_881
    .lex "$/", param_882
    find_lex $P883, "$/"
    find_lex $P884, "$/"
    unless_null $P884, vivify_362
    $P884 = root_new ['parrot';'Hash']
  vivify_362:
    set $P885, $P884["package_declarator"]
    unless_null $P885, vivify_363
    new $P885, "Undef"
  vivify_363:
    $P886 = $P885."ast"()
    $P887 = $P883."!make"($P886)
    .return ($P887)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("62_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_889
    .param pmc param_890
.annotate 'line', 351
    .lex "self", param_889
    .lex "$/", param_890
    find_lex $P891, "$/"
    find_lex $P892, "$/"
    unless_null $P892, vivify_364
    $P892 = root_new ['parrot';'Hash']
  vivify_364:
    set $P893, $P892["scope_declarator"]
    unless_null $P893, vivify_365
    new $P893, "Undef"
  vivify_365:
    $P894 = $P893."ast"()
    $P895 = $P891."!make"($P894)
    .return ($P895)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("63_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_897
    .param pmc param_898
.annotate 'line', 352
    .lex "self", param_897
    .lex "$/", param_898
    find_lex $P899, "$/"
    find_lex $P900, "$/"
    unless_null $P900, vivify_366
    $P900 = root_new ['parrot';'Hash']
  vivify_366:
    set $P901, $P900["routine_declarator"]
    unless_null $P901, vivify_367
    new $P901, "Undef"
  vivify_367:
    $P902 = $P901."ast"()
    $P903 = $P899."!make"($P902)
    .return ($P903)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("64_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_905
    .param pmc param_906
.annotate 'line', 353
    .lex "self", param_905
    .lex "$/", param_906
    find_lex $P907, "$/"
    find_lex $P908, "$/"
    unless_null $P908, vivify_368
    $P908 = root_new ['parrot';'Hash']
  vivify_368:
    set $P909, $P908["regex_declarator"]
    unless_null $P909, vivify_369
    new $P909, "Undef"
  vivify_369:
    $P910 = $P909."ast"()
    $P911 = $P907."!make"($P910)
    .return ($P911)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("65_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_913
    .param pmc param_914
.annotate 'line', 354
    .lex "self", param_913
    .lex "$/", param_914
    find_lex $P915, "$/"
    find_lex $P916, "$/"
    unless_null $P916, vivify_370
    $P916 = root_new ['parrot';'Hash']
  vivify_370:
    set $P917, $P916["statement_prefix"]
    unless_null $P917, vivify_371
    new $P917, "Undef"
  vivify_371:
    $P918 = $P917."ast"()
    $P919 = $P915."!make"($P918)
    .return ($P919)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("66_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_921
    .param pmc param_922
.annotate 'line', 355
    .lex "self", param_921
    .lex "$/", param_922
    find_lex $P923, "$/"
    find_lex $P924, "$/"
    unless_null $P924, vivify_372
    $P924 = root_new ['parrot';'Hash']
  vivify_372:
    set $P925, $P924["pblock"]
    unless_null $P925, vivify_373
    new $P925, "Undef"
  vivify_373:
    $P926 = $P925."ast"()
    $P927 = $P923."!make"($P926)
    .return ($P927)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("67_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_929
    .param pmc param_930
.annotate 'line', 357
    .lex "self", param_929
    .lex "$/", param_930
.annotate 'line', 358
    new $P931, "Undef"
    .lex "$past", $P931
    find_lex $P932, "$/"
    unless_null $P932, vivify_374
    $P932 = root_new ['parrot';'Hash']
  vivify_374:
    set $P933, $P932["val"]
    unless_null $P933, vivify_375
    new $P933, "Undef"
  vivify_375:
    $P934 = $P933."ast"()
    store_lex "$past", $P934
.annotate 'line', 359
    find_lex $P935, "$past"
    find_lex $P936, "$/"
    unless_null $P936, vivify_376
    $P936 = root_new ['parrot';'Hash']
  vivify_376:
    set $P937, $P936["key"]
    unless_null $P937, vivify_377
    new $P937, "Undef"
  vivify_377:
    $P938 = $P937."Str"()
    $P935."named"($P938)
.annotate 'line', 360
    find_lex $P939, "$/"
    find_lex $P940, "$past"
    $P941 = $P939."!make"($P940)
.annotate 'line', 357
    .return ($P941)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("68_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_943
    .param pmc param_944
.annotate 'line', 363
    .lex "self", param_943
    .lex "$/", param_944
.annotate 'line', 364
    new $P945, "Undef"
    .lex "$past", $P945
.annotate 'line', 365
    find_lex $P948, "$/"
    unless_null $P948, vivify_378
    $P948 = root_new ['parrot';'Hash']
  vivify_378:
    set $P949, $P948["circumfix"]
    unless_null $P949, vivify_379
    new $P949, "Undef"
  vivify_379:
    if $P949, if_947
.annotate 'line', 366
    get_hll_global $P954, ["PAST"], "Val"
    find_lex $P955, "$/"
    unless_null $P955, vivify_380
    $P955 = root_new ['parrot';'Hash']
  vivify_380:
    set $P956, $P955["not"]
    unless_null $P956, vivify_381
    new $P956, "Undef"
  vivify_381:
    isfalse $I957, $P956
    $P958 = $P954."new"($I957 :named("value"))
    set $P946, $P958
.annotate 'line', 365
    goto if_947_end
  if_947:
    find_lex $P950, "$/"
    unless_null $P950, vivify_382
    $P950 = root_new ['parrot';'Hash']
  vivify_382:
    set $P951, $P950["circumfix"]
    unless_null $P951, vivify_383
    $P951 = root_new ['parrot';'ResizablePMCArray']
  vivify_383:
    set $P952, $P951[0]
    unless_null $P952, vivify_384
    new $P952, "Undef"
  vivify_384:
    $P953 = $P952."ast"()
    set $P946, $P953
  if_947_end:
    store_lex "$past", $P946
.annotate 'line', 367
    find_lex $P959, "$past"
    find_lex $P960, "$/"
    unless_null $P960, vivify_385
    $P960 = root_new ['parrot';'Hash']
  vivify_385:
    set $P961, $P960["identifier"]
    unless_null $P961, vivify_386
    new $P961, "Undef"
  vivify_386:
    set $S962, $P961
    $P959."named"($S962)
.annotate 'line', 368
    find_lex $P963, "$/"
    find_lex $P964, "$past"
    $P965 = $P963."!make"($P964)
.annotate 'line', 363
    .return ($P965)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("69_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_967
    .param pmc param_968
.annotate 'line', 371
    .const 'Sub' $P981 = "70_1300060192.103" 
    capture_lex $P981
    .lex "self", param_967
    .lex "$/", param_968
.annotate 'line', 372
    new $P969, "Undef"
    .lex "$past", $P969
.annotate 'line', 371
    find_lex $P970, "$past"
.annotate 'line', 373
    find_lex $P972, "$/"
    unless_null $P972, vivify_387
    $P972 = root_new ['parrot';'Hash']
  vivify_387:
    set $P973, $P972["postcircumfix"]
    unless_null $P973, vivify_388
    new $P973, "Undef"
  vivify_388:
    if $P973, if_971
.annotate 'line', 377
    .const 'Sub' $P981 = "70_1300060192.103" 
    capture_lex $P981
    $P981()
    goto if_971_end
  if_971:
.annotate 'line', 374
    find_lex $P974, "$/"
    unless_null $P974, vivify_405
    $P974 = root_new ['parrot';'Hash']
  vivify_405:
    set $P975, $P974["postcircumfix"]
    unless_null $P975, vivify_406
    new $P975, "Undef"
  vivify_406:
    $P976 = $P975."ast"()
    store_lex "$past", $P976
.annotate 'line', 375
    find_lex $P977, "$past"
    get_hll_global $P978, ["PAST"], "Var"
    $P979 = $P978."new"("$/" :named("name"))
    $P977."unshift"($P979)
  if_971_end:
.annotate 'line', 407
    find_lex $P1053, "$/"
    find_lex $P1054, "$past"
    $P1055 = $P1053."!make"($P1054)
.annotate 'line', 371
    .return ($P1055)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block980"  :anon :subid("70_1300060192.103") :outer("69_1300060192.103")
.annotate 'line', 378
    $P982 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P982
    get_hll_global $P983, ["NQP"], "Compiler"
    find_lex $P984, "$/"
    set $S985, $P984
    $P986 = $P983."parse_name"($S985)
    store_lex "@name", $P986
.annotate 'line', 379
    get_hll_global $P987, ["PAST"], "Var"
    find_lex $P988, "@name"
    $P989 = $P988."pop"()
    set $S990, $P989
    $P991 = $P987."new"($S990 :named("name"))
    store_lex "$past", $P991
.annotate 'line', 380
    find_lex $P993, "@name"
    unless $P993, if_992_end
.annotate 'line', 381
    find_lex $P995, "@name"
    unless_null $P995, vivify_389
    $P995 = root_new ['parrot';'ResizablePMCArray']
  vivify_389:
    set $P996, $P995[0]
    unless_null $P996, vivify_390
    new $P996, "Undef"
  vivify_390:
    set $S997, $P996
    iseq $I998, $S997, "GLOBAL"
    unless $I998, if_994_end
    find_lex $P999, "@name"
    $P999."shift"()
  if_994_end:
.annotate 'line', 382
    find_lex $P1000, "$past"
    find_lex $P1001, "@name"
    $P1000."namespace"($P1001)
.annotate 'line', 383
    find_lex $P1002, "$past"
    $P1002."scope"("package")
.annotate 'line', 384
    find_lex $P1003, "$past"
    find_lex $P1004, "$/"
    unless_null $P1004, vivify_391
    $P1004 = root_new ['parrot';'Hash']
  vivify_391:
    set $P1005, $P1004["sigil"]
    unless_null $P1005, vivify_392
    new $P1005, "Undef"
  vivify_392:
    $P1006 = "vivitype"($P1005)
    $P1003."viviself"($P1006)
.annotate 'line', 385
    find_lex $P1007, "$past"
    $P1007."lvalue"(1)
  if_992_end:
.annotate 'line', 387
    find_lex $P1010, "$/"
    unless_null $P1010, vivify_393
    $P1010 = root_new ['parrot';'Hash']
  vivify_393:
    set $P1011, $P1010["twigil"]
    unless_null $P1011, vivify_394
    $P1011 = root_new ['parrot';'ResizablePMCArray']
  vivify_394:
    set $P1012, $P1011[0]
    unless_null $P1012, vivify_395
    new $P1012, "Undef"
  vivify_395:
    set $S1013, $P1012
    iseq $I1014, $S1013, "*"
    if $I1014, if_1009
.annotate 'line', 400
    find_lex $P1036, "$/"
    unless_null $P1036, vivify_396
    $P1036 = root_new ['parrot';'Hash']
  vivify_396:
    set $P1037, $P1036["twigil"]
    unless_null $P1037, vivify_397
    $P1037 = root_new ['parrot';'ResizablePMCArray']
  vivify_397:
    set $P1038, $P1037[0]
    unless_null $P1038, vivify_398
    new $P1038, "Undef"
  vivify_398:
    set $S1039, $P1038
    iseq $I1040, $S1039, "!"
    if $I1040, if_1035
    new $P1034, 'Integer'
    set $P1034, $I1040
    goto if_1035_end
  if_1035:
.annotate 'line', 401
    find_lex $P1041, "$past"
    get_hll_global $P1042, ["PAST"], "Var"
    $P1043 = $P1042."new"("self" :named("name"))
    $P1041."push"($P1043)
.annotate 'line', 402
    find_lex $P1044, "$past"
    $P1044."scope"("attribute")
.annotate 'line', 403
    find_lex $P1045, "$past"
    find_lex $P1046, "$/"
    unless_null $P1046, vivify_399
    $P1046 = root_new ['parrot';'Hash']
  vivify_399:
    set $P1047, $P1046["sigil"]
    unless_null $P1047, vivify_400
    new $P1047, "Undef"
  vivify_400:
    $P1048 = "vivitype"($P1047)
    $P1045."viviself"($P1048)
.annotate 'line', 404
    find_lex $P1049, "$past"
    get_hll_global $P1050, ["PAST"], "Var"
    $P1051 = $P1050."new"("$?CLASS" :named("name"))
    $P1052 = $P1049."push"($P1051)
.annotate 'line', 400
    set $P1034, $P1052
  if_1035_end:
    set $P1008, $P1034
.annotate 'line', 387
    goto if_1009_end
  if_1009:
.annotate 'line', 388
    find_lex $P1015, "$past"
    $P1015."scope"("contextual")
.annotate 'line', 389
    find_lex $P1016, "$past"
.annotate 'line', 390
    get_hll_global $P1017, ["PAST"], "Var"
.annotate 'line', 392
    find_lex $P1018, "$/"
    unless_null $P1018, vivify_401
    $P1018 = root_new ['parrot';'Hash']
  vivify_401:
    set $P1019, $P1018["sigil"]
    unless_null $P1019, vivify_402
    new $P1019, "Undef"
  vivify_402:
    set $S1020, $P1019
    new $P1021, 'String'
    set $P1021, $S1020
    find_lex $P1022, "$/"
    unless_null $P1022, vivify_403
    $P1022 = root_new ['parrot';'Hash']
  vivify_403:
    set $P1023, $P1022["desigilname"]
    unless_null $P1023, vivify_404
    new $P1023, "Undef"
  vivify_404:
    concat $P1024, $P1021, $P1023
.annotate 'line', 394
    get_hll_global $P1025, ["PAST"], "Op"
    new $P1026, "String"
    assign $P1026, "Contextual "
    find_lex $P1027, "$/"
    set $S1028, $P1027
    concat $P1029, $P1026, $S1028
    concat $P1030, $P1029, " not found"
    $P1031 = $P1025."new"($P1030, "die" :named("pirop"))
    $P1032 = $P1017."new"("package" :named("scope"), "" :named("namespace"), $P1024 :named("name"), $P1031 :named("viviself"))
.annotate 'line', 390
    $P1033 = $P1016."viviself"($P1032)
.annotate 'line', 387
    set $P1008, $P1033
  if_1009_end:
.annotate 'line', 377
    .return ($P1008)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("71_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1057
    .param pmc param_1058
.annotate 'line', 410
    .lex "self", param_1057
    .lex "$/", param_1058
    find_lex $P1059, "$/"
    find_lex $P1060, "$/"
    unless_null $P1060, vivify_407
    $P1060 = root_new ['parrot';'Hash']
  vivify_407:
    set $P1061, $P1060["package_def"]
    unless_null $P1061, vivify_408
    new $P1061, "Undef"
  vivify_408:
    $P1062 = $P1061."ast"()
    $P1063 = $P1059."!make"($P1062)
    .return ($P1063)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("72_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1065
    .param pmc param_1066
.annotate 'line', 411
    .lex "self", param_1065
    .lex "$/", param_1066
    find_lex $P1067, "$/"
    find_lex $P1068, "$/"
    unless_null $P1068, vivify_409
    $P1068 = root_new ['parrot';'Hash']
  vivify_409:
    set $P1069, $P1068["package_def"]
    unless_null $P1069, vivify_410
    new $P1069, "Undef"
  vivify_410:
    $P1070 = $P1069."ast"()
    $P1071 = $P1067."!make"($P1070)
    .return ($P1071)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("73_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1073
    .param pmc param_1074
.annotate 'line', 412
    .lex "self", param_1073
    .lex "$/", param_1074
    find_lex $P1075, "$/"
    find_lex $P1076, "$/"
    unless_null $P1076, vivify_411
    $P1076 = root_new ['parrot';'Hash']
  vivify_411:
    set $P1077, $P1076["package_def"]
    unless_null $P1077, vivify_412
    new $P1077, "Undef"
  vivify_412:
    $P1078 = $P1077."ast"()
    $P1079 = $P1075."!make"($P1078)
    .return ($P1079)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("74_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1081
    .param pmc param_1082
.annotate 'line', 413
    .lex "self", param_1081
    .lex "$/", param_1082
    find_lex $P1083, "$/"
    find_lex $P1084, "$/"
    unless_null $P1084, vivify_413
    $P1084 = root_new ['parrot';'Hash']
  vivify_413:
    set $P1085, $P1084["package_def"]
    unless_null $P1085, vivify_414
    new $P1085, "Undef"
  vivify_414:
    $P1086 = $P1085."ast"()
    $P1087 = $P1083."!make"($P1086)
    .return ($P1087)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("75_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1089
    .param pmc param_1090
.annotate 'line', 414
    .lex "self", param_1089
    .lex "$/", param_1090
    find_lex $P1091, "$/"
    find_lex $P1092, "$/"
    unless_null $P1092, vivify_415
    $P1092 = root_new ['parrot';'Hash']
  vivify_415:
    set $P1093, $P1092["package_def"]
    unless_null $P1093, vivify_416
    new $P1093, "Undef"
  vivify_416:
    $P1094 = $P1093."ast"()
    $P1095 = $P1091."!make"($P1094)
    .return ($P1095)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("76_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1097
    .param pmc param_1098
.annotate 'line', 415
    .lex "self", param_1097
    .lex "$/", param_1098
    find_lex $P1099, "$/"
    find_lex $P1100, "$/"
    unless_null $P1100, vivify_417
    $P1100 = root_new ['parrot';'Hash']
  vivify_417:
    set $P1101, $P1100["package_def"]
    unless_null $P1101, vivify_418
    new $P1101, "Undef"
  vivify_418:
    $P1102 = $P1101."ast"()
    $P1103 = $P1099."!make"($P1102)
    .return ($P1103)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("77_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1105
    .param pmc param_1106
.annotate 'line', 417
    .const 'Sub' $P1255 = "79_1300060192.103" 
    capture_lex $P1255
    .const 'Sub' $P1204 = "78_1300060192.103" 
    capture_lex $P1204
    .lex "self", param_1105
    .lex "$/", param_1106
.annotate 'line', 419
    $P1107 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1107
.annotate 'line', 420
    new $P1108, "Undef"
    .lex "$name", $P1108
.annotate 'line', 421
    new $P1109, "Undef"
    .lex "$how", $P1109
.annotate 'line', 424
    new $P1110, "Undef"
    .lex "$past", $P1110
.annotate 'line', 419
    find_lex $P1111, "$/"
    unless_null $P1111, vivify_419
    $P1111 = root_new ['parrot';'Hash']
  vivify_419:
    set $P1112, $P1111["name"]
    unless_null $P1112, vivify_420
    $P1112 = root_new ['parrot';'Hash']
  vivify_420:
    set $P1113, $P1112["identifier"]
    unless_null $P1113, vivify_421
    new $P1113, "Undef"
  vivify_421:
    clone $P1114, $P1113
    store_lex "@ns", $P1114
.annotate 'line', 420
    find_lex $P1115, "@ns"
    $P1116 = $P1115."pop"()
    set $S1117, $P1116
    new $P1118, 'String'
    set $P1118, $S1117
    store_lex "$name", $P1118
.annotate 'line', 421
    find_dynamic_lex $P1119, "$*PKGDECL"
    unless_null $P1119, vivify_422
    get_hll_global $P1119, "$PKGDECL"
    unless_null $P1119, vivify_423
    die "Contextual $*PKGDECL not found"
  vivify_423:
  vivify_422:
    find_dynamic_lex $P1120, "%*HOW"
    unless_null $P1120, vivify_424
    get_hll_global $P1120, "%HOW"
    unless_null $P1120, vivify_425
    die "Contextual %*HOW not found"
  vivify_425:
  vivify_424:
    set $P1121, $P1120[$P1119]
    unless_null $P1121, vivify_426
    new $P1121, "Undef"
  vivify_426:
    store_lex "$how", $P1121
.annotate 'line', 424
    find_lex $P1124, "$/"
    unless_null $P1124, vivify_427
    $P1124 = root_new ['parrot';'Hash']
  vivify_427:
    set $P1125, $P1124["block"]
    unless_null $P1125, vivify_428
    new $P1125, "Undef"
  vivify_428:
    if $P1125, if_1123
    find_lex $P1129, "$/"
    unless_null $P1129, vivify_429
    $P1129 = root_new ['parrot';'Hash']
  vivify_429:
    set $P1130, $P1129["comp_unit"]
    unless_null $P1130, vivify_430
    new $P1130, "Undef"
  vivify_430:
    $P1131 = $P1130."ast"()
    set $P1122, $P1131
    goto if_1123_end
  if_1123:
    find_lex $P1126, "$/"
    unless_null $P1126, vivify_431
    $P1126 = root_new ['parrot';'Hash']
  vivify_431:
    set $P1127, $P1126["block"]
    unless_null $P1127, vivify_432
    new $P1127, "Undef"
  vivify_432:
    $P1128 = $P1127."ast"()
    set $P1122, $P1128
  if_1123_end:
    store_lex "$past", $P1122
.annotate 'line', 427
    find_dynamic_lex $P1135, "$*SCOPE"
    unless_null $P1135, vivify_433
    get_hll_global $P1135, "$SCOPE"
    unless_null $P1135, vivify_434
    die "Contextual $*SCOPE not found"
  vivify_434:
  vivify_433:
    set $S1136, $P1135
    iseq $I1137, $S1136, "our"
    unless $I1137, unless_1134
    new $P1133, 'Integer'
    set $P1133, $I1137
    goto unless_1134_end
  unless_1134:
    find_dynamic_lex $P1138, "$*SCOPE"
    unless_null $P1138, vivify_435
    get_hll_global $P1138, "$SCOPE"
    unless_null $P1138, vivify_436
    die "Contextual $*SCOPE not found"
  vivify_436:
  vivify_435:
    set $S1139, $P1138
    iseq $I1140, $S1139, ""
    new $P1133, 'Integer'
    set $P1133, $I1140
  unless_1134_end:
    if $P1133, if_1132
.annotate 'line', 432
    find_lex $P1150, "$/"
    $P1151 = $P1150."CURSOR"()
    find_dynamic_lex $P1152, "$*SCOPE"
    unless_null $P1152, vivify_437
    get_hll_global $P1152, "$SCOPE"
    unless_null $P1152, vivify_438
    die "Contextual $*SCOPE not found"
  vivify_438:
  vivify_437:
    concat $P1153, $P1152, " scoped packages are not supported"
    $P1151."panic"($P1153)
.annotate 'line', 431
    goto if_1132_end
  if_1132:
.annotate 'line', 428
    find_lex $P1141, "$past"
    find_lex $P1142, "$/"
    unless_null $P1142, vivify_439
    $P1142 = root_new ['parrot';'Hash']
  vivify_439:
    set $P1143, $P1142["name"]
    unless_null $P1143, vivify_440
    $P1143 = root_new ['parrot';'Hash']
  vivify_440:
    set $P1144, $P1143["identifier"]
    unless_null $P1144, vivify_441
    new $P1144, "Undef"
  vivify_441:
    $P1141."namespace"($P1144)
.annotate 'line', 429
    find_dynamic_lex $P1145, "$*SC"
    unless_null $P1145, vivify_442
    get_hll_global $P1145, "$SC"
    unless_null $P1145, vivify_443
    die "Contextual $*SC not found"
  vivify_443:
  vivify_442:
    find_lex $P1146, "$/"
    unless_null $P1146, vivify_444
    $P1146 = root_new ['parrot';'Hash']
  vivify_444:
    set $P1147, $P1146["name"]
    unless_null $P1147, vivify_445
    $P1147 = root_new ['parrot';'Hash']
  vivify_445:
    set $P1148, $P1147["identifier"]
    unless_null $P1148, vivify_446
    new $P1148, "Undef"
  vivify_446:
    find_dynamic_lex $P1149, "$*PKGMETA"
    unless_null $P1149, vivify_447
    get_hll_global $P1149, "$PKGMETA"
    unless_null $P1149, vivify_448
    die "Contextual $*PKGMETA not found"
  vivify_448:
  vivify_447:
    $P1145."install_package_symbol"($P1148, $P1149)
  if_1132_end:
.annotate 'line', 436
    find_dynamic_lex $P1154, "$*PACKAGE-SETUP"
    unless_null $P1154, vivify_449
    get_hll_global $P1154, "$PACKAGE-SETUP"
    unless_null $P1154, vivify_450
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_450:
  vivify_449:
    get_hll_global $P1155, ["PAST"], "Stmts"
.annotate 'line', 437
    get_hll_global $P1156, ["PAST"], "Op"
.annotate 'line', 438
    get_hll_global $P1157, ["PAST"], "Var"
    $P1158 = $P1157."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 439
    find_dynamic_lex $P1159, "$*SC"
    unless_null $P1159, vivify_451
    get_hll_global $P1159, "$SC"
    unless_null $P1159, vivify_452
    die "Contextual $*SC not found"
  vivify_452:
  vivify_451:
    find_dynamic_lex $P1160, "$*PKGMETA"
    unless_null $P1160, vivify_453
    get_hll_global $P1160, "$PKGMETA"
    unless_null $P1160, vivify_454
    die "Contextual $*PKGMETA not found"
  vivify_454:
  vivify_453:
    $P1161 = $P1159."get_slot_past_for_object"($P1160)
    $P1162 = $P1156."new"($P1158, $P1161, "bind" :named("pasttype"))
.annotate 'line', 441
    get_hll_global $P1163, ["PAST"], "Op"
.annotate 'line', 442
    get_hll_global $P1164, ["PAST"], "Var"
    $P1165 = $P1164."new"("$?CLASS" :named("name"))
.annotate 'line', 443
    get_hll_global $P1166, ["PAST"], "Var"
    $P1167 = $P1166."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1168 = $P1163."new"($P1165, $P1167, "bind" :named("pasttype"))
.annotate 'line', 441
    $P1169 = $P1155."new"($P1162, $P1168)
.annotate 'line', 436
    $P1154."unshift"($P1169)
.annotate 'line', 452
    find_lex $P1173, "$how"
    can $I1174, $P1173, "parametric"
    if $I1174, if_1172
    new $P1171, 'Integer'
    set $P1171, $I1174
    goto if_1172_end
  if_1172:
    find_lex $P1175, "$how"
    find_lex $P1176, "$how"
    $P1177 = $P1175."parametric"($P1176)
    set $P1171, $P1177
  if_1172_end:
    if $P1171, if_1170
.annotate 'line', 468
    find_lex $P1195, "$past"
    $P1195."blocktype"("immediate")
.annotate 'line', 469
    find_lex $P1196, "$past"
    get_hll_global $P1197, ["PAST"], "Var"
    $P1198 = $P1197."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P1196."unshift"($P1198)
.annotate 'line', 470
    find_lex $P1199, "$past"
    $P1199."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 467
    goto if_1170_end
  if_1170:
.annotate 'line', 453
    find_lex $P1178, "$past"
    $P1178."blocktype"("declaration")
.annotate 'line', 454
    find_lex $P1179, "$past"
    get_hll_global $P1180, ["PAST"], "Var"
    $P1181 = $P1180."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P1179."unshift"($P1181)
.annotate 'line', 455
    find_lex $P1182, "$past"
    $P1182."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 456
    find_dynamic_lex $P1183, "$*PACKAGE-SETUP"
    unless_null $P1183, vivify_455
    get_hll_global $P1183, "$PACKAGE-SETUP"
    unless_null $P1183, vivify_456
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_456:
  vivify_455:
    get_hll_global $P1184, ["PAST"], "Op"
.annotate 'line', 458
    get_hll_global $P1185, ["PAST"], "Op"
.annotate 'line', 461
    get_hll_global $P1186, ["PAST"], "Var"
    $P1187 = $P1186."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1188 = $P1185."new"($P1187, "get_how PP" :named("pirop"))
.annotate 'line', 463
    get_hll_global $P1189, ["PAST"], "Var"
    $P1190 = $P1189."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 464
    get_hll_global $P1191, ["PAST"], "Val"
    find_lex $P1192, "$past"
    $P1193 = $P1191."new"($P1192 :named("value"))
    $P1194 = $P1184."new"($P1188, $P1190, $P1193, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 456
    $P1183."push"($P1194)
  if_1170_end:
.annotate 'line', 475
    find_lex $P1201, "$/"
    unless_null $P1201, vivify_457
    $P1201 = root_new ['parrot';'Hash']
  vivify_457:
    set $P1202, $P1201["parent"]
    unless_null $P1202, vivify_458
    new $P1202, "Undef"
  vivify_458:
    if $P1202, if_1200
.annotate 'line', 489
    find_dynamic_lex $P1232, "$*PKGDECL"
    unless_null $P1232, vivify_459
    get_hll_global $P1232, "$PKGDECL"
    unless_null $P1232, vivify_460
    die "Contextual $*PKGDECL not found"
  vivify_460:
  vivify_459:
    set $S1233, $P1232
    iseq $I1234, $S1233, "grammar"
    unless $I1234, if_1231_end
.annotate 'line', 490
    find_dynamic_lex $P1235, "$*PACKAGE-SETUP"
    unless_null $P1235, vivify_461
    get_hll_global $P1235, "$PACKAGE-SETUP"
    unless_null $P1235, vivify_462
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_462:
  vivify_461:
    get_hll_global $P1236, ["PAST"], "Op"
.annotate 'line', 492
    get_hll_global $P1237, ["PAST"], "Op"
.annotate 'line', 495
    get_hll_global $P1238, ["PAST"], "Var"
    $P1239 = $P1238."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1240 = $P1237."new"($P1239, "get_how PP" :named("pirop"))
.annotate 'line', 497
    get_hll_global $P1241, ["PAST"], "Var"
    $P1242 = $P1241."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 498
    get_hll_global $P1243, ["PAST"], "Var"
    $P1244 = $P1243."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P1245 = $P1236."new"($P1240, $P1242, $P1244, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 490
    $P1235."push"($P1245)
  if_1231_end:
.annotate 'line', 489
    goto if_1200_end
  if_1200:
.annotate 'line', 475
    .const 'Sub' $P1204 = "78_1300060192.103" 
    capture_lex $P1204
    $P1204()
  if_1200_end:
.annotate 'line', 503
    find_lex $P1247, "$/"
    unless_null $P1247, vivify_469
    $P1247 = root_new ['parrot';'Hash']
  vivify_469:
    set $P1248, $P1247["role"]
    unless_null $P1248, vivify_470
    new $P1248, "Undef"
  vivify_470:
    unless $P1248, if_1246_end
.annotate 'line', 504
    find_lex $P1250, "$/"
    unless_null $P1250, vivify_471
    $P1250 = root_new ['parrot';'Hash']
  vivify_471:
    set $P1251, $P1250["role"]
    unless_null $P1251, vivify_472
    new $P1251, "Undef"
  vivify_472:
    defined $I1252, $P1251
    unless $I1252, for_undef_473
    iter $P1249, $P1251
    new $P1282, 'ExceptionHandler'
    set_label $P1282, loop1281_handler
    $P1282."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1282
  loop1281_test:
    unless $P1249, loop1281_done
    shift $P1253, $P1249
  loop1281_redo:
    .const 'Sub' $P1255 = "79_1300060192.103" 
    capture_lex $P1255
    $P1255($P1253)
  loop1281_next:
    goto loop1281_test
  loop1281_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1283, exception, 'type'
    eq $P1283, .CONTROL_LOOP_NEXT, loop1281_next
    eq $P1283, .CONTROL_LOOP_REDO, loop1281_redo
  loop1281_done:
    pop_eh 
  for_undef_473:
  if_1246_end:
.annotate 'line', 521
    find_dynamic_lex $P1284, "$*PACKAGE-SETUP"
    unless_null $P1284, vivify_478
    get_hll_global $P1284, "$PACKAGE-SETUP"
    unless_null $P1284, vivify_479
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_479:
  vivify_478:
    get_hll_global $P1285, ["PAST"], "Op"
.annotate 'line', 523
    get_hll_global $P1286, ["PAST"], "Op"
.annotate 'line', 526
    get_hll_global $P1287, ["PAST"], "Var"
    $P1288 = $P1287."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1289 = $P1286."new"($P1288, "get_how PP" :named("pirop"))
.annotate 'line', 528
    get_hll_global $P1290, ["PAST"], "Var"
    $P1291 = $P1290."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1292 = $P1285."new"($P1289, $P1291, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 521
    $P1284."push"($P1292)
.annotate 'line', 532
    find_lex $P1293, "$past"
    $P1294 = $P1293."loadinit"()
    get_hll_global $P1295, ["PAST"], "Block"
    find_dynamic_lex $P1296, "$*PACKAGE-SETUP"
    unless_null $P1296, vivify_480
    get_hll_global $P1296, "$PACKAGE-SETUP"
    unless_null $P1296, vivify_481
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_481:
  vivify_480:
    $P1297 = $P1295."new"($P1296, "immediate" :named("blocktype"))
    $P1294."push"($P1297)
.annotate 'line', 534
    find_lex $P1298, "$/"
    find_lex $P1299, "$past"
    $P1300 = $P1298."!make"($P1299)
.annotate 'line', 417
    .return ($P1300)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1203"  :anon :subid("78_1300060192.103") :outer("77_1300060192.103")
.annotate 'line', 476
    $P1205 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1205
.annotate 'line', 477
    new $P1206, "Undef"
    .lex "$name", $P1206
.annotate 'line', 476
    find_lex $P1207, "$/"
    unless_null $P1207, vivify_463
    $P1207 = root_new ['parrot';'Hash']
  vivify_463:
    set $P1208, $P1207["parent"]
    unless_null $P1208, vivify_464
    $P1208 = root_new ['parrot';'ResizablePMCArray']
  vivify_464:
    set $P1209, $P1208[0]
    unless_null $P1209, vivify_465
    $P1209 = root_new ['parrot';'Hash']
  vivify_465:
    set $P1210, $P1209["identifier"]
    unless_null $P1210, vivify_466
    new $P1210, "Undef"
  vivify_466:
    clone $P1211, $P1210
    store_lex "@ns", $P1211
.annotate 'line', 477
    find_lex $P1212, "@ns"
    $P1213 = $P1212."pop"()
    set $S1214, $P1213
    new $P1215, 'String'
    set $P1215, $S1214
    store_lex "$name", $P1215
.annotate 'line', 478
    find_dynamic_lex $P1216, "$*PACKAGE-SETUP"
    unless_null $P1216, vivify_467
    get_hll_global $P1216, "$PACKAGE-SETUP"
    unless_null $P1216, vivify_468
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_468:
  vivify_467:
    get_hll_global $P1217, ["PAST"], "Op"
.annotate 'line', 480
    get_hll_global $P1218, ["PAST"], "Op"
.annotate 'line', 483
    get_hll_global $P1219, ["PAST"], "Var"
    $P1220 = $P1219."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1221 = $P1218."new"($P1220, "get_how PP" :named("pirop"))
.annotate 'line', 485
    get_hll_global $P1222, ["PAST"], "Var"
    $P1223 = $P1222."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 486
    get_hll_global $P1224, ["PAST"], "Var"
    find_lex $P1225, "$name"
    set $S1226, $P1225
    find_lex $P1227, "@ns"
    $P1228 = $P1224."new"($S1226 :named("name"), $P1227 :named("namespace"), "package" :named("scope"))
    $P1229 = $P1217."new"($P1221, $P1223, $P1228, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 478
    $P1230 = $P1216."push"($P1229)
.annotate 'line', 475
    .return ($P1230)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1254"  :anon :subid("79_1300060192.103") :outer("77_1300060192.103")
    .param pmc param_1258
.annotate 'line', 505
    $P1256 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1256
.annotate 'line', 506
    new $P1257, "Undef"
    .lex "$name", $P1257
    .lex "$_", param_1258
.annotate 'line', 505
    find_lex $P1259, "$_"
    unless_null $P1259, vivify_474
    $P1259 = root_new ['parrot';'Hash']
  vivify_474:
    set $P1260, $P1259["identifier"]
    unless_null $P1260, vivify_475
    new $P1260, "Undef"
  vivify_475:
    clone $P1261, $P1260
    store_lex "@ns", $P1261
.annotate 'line', 506
    find_lex $P1262, "@ns"
    $P1263 = $P1262."pop"()
    set $S1264, $P1263
    new $P1265, 'String'
    set $P1265, $S1264
    store_lex "$name", $P1265
.annotate 'line', 507
    find_dynamic_lex $P1266, "$*PACKAGE-SETUP"
    unless_null $P1266, vivify_476
    get_hll_global $P1266, "$PACKAGE-SETUP"
    unless_null $P1266, vivify_477
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_477:
  vivify_476:
    get_hll_global $P1267, ["PAST"], "Op"
.annotate 'line', 509
    get_hll_global $P1268, ["PAST"], "Op"
.annotate 'line', 512
    get_hll_global $P1269, ["PAST"], "Var"
    $P1270 = $P1269."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1271 = $P1268."new"($P1270, "get_how PP" :named("pirop"))
.annotate 'line', 514
    get_hll_global $P1272, ["PAST"], "Var"
    $P1273 = $P1272."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 515
    get_hll_global $P1274, ["PAST"], "Var"
    find_lex $P1275, "$name"
    set $S1276, $P1275
    find_lex $P1277, "@ns"
    $P1278 = $P1274."new"($S1276 :named("name"), $P1277 :named("namespace"), "package" :named("scope"))
    $P1279 = $P1267."new"($P1271, $P1273, $P1278, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 507
    $P1280 = $P1266."push"($P1279)
.annotate 'line', 504
    .return ($P1280)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("80_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1302
    .param pmc param_1303
.annotate 'line', 537
    .lex "self", param_1302
    .lex "$/", param_1303
    find_lex $P1304, "$/"
    find_lex $P1305, "$/"
    unless_null $P1305, vivify_482
    $P1305 = root_new ['parrot';'Hash']
  vivify_482:
    set $P1306, $P1305["scoped"]
    unless_null $P1306, vivify_483
    new $P1306, "Undef"
  vivify_483:
    $P1307 = $P1306."ast"()
    $P1308 = $P1304."!make"($P1307)
    .return ($P1308)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("81_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1310
    .param pmc param_1311
.annotate 'line', 538
    .lex "self", param_1310
    .lex "$/", param_1311
    find_lex $P1312, "$/"
    find_lex $P1313, "$/"
    unless_null $P1313, vivify_484
    $P1313 = root_new ['parrot';'Hash']
  vivify_484:
    set $P1314, $P1313["scoped"]
    unless_null $P1314, vivify_485
    new $P1314, "Undef"
  vivify_485:
    $P1315 = $P1314."ast"()
    $P1316 = $P1312."!make"($P1315)
    .return ($P1316)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("82_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1318
    .param pmc param_1319
.annotate 'line', 539
    .lex "self", param_1318
    .lex "$/", param_1319
    find_lex $P1320, "$/"
    find_lex $P1321, "$/"
    unless_null $P1321, vivify_486
    $P1321 = root_new ['parrot';'Hash']
  vivify_486:
    set $P1322, $P1321["scoped"]
    unless_null $P1322, vivify_487
    new $P1322, "Undef"
  vivify_487:
    $P1323 = $P1322."ast"()
    $P1324 = $P1320."!make"($P1323)
    .return ($P1324)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("83_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1326
    .param pmc param_1327
.annotate 'line', 541
    .lex "self", param_1326
    .lex "$/", param_1327
.annotate 'line', 542
    find_lex $P1328, "$/"
    find_lex $P1331, "$/"
    unless_null $P1331, vivify_488
    $P1331 = root_new ['parrot';'Hash']
  vivify_488:
    set $P1332, $P1331["declarator"]
    unless_null $P1332, vivify_489
    new $P1332, "Undef"
  vivify_489:
    if $P1332, if_1330
.annotate 'line', 543
    find_lex $P1338, "$/"
    unless_null $P1338, vivify_490
    $P1338 = root_new ['parrot';'Hash']
  vivify_490:
    set $P1339, $P1338["multi_declarator"]
    unless_null $P1339, vivify_491
    new $P1339, "Undef"
  vivify_491:
    if $P1339, if_1337
.annotate 'line', 544
    find_lex $P1343, "$/"
    unless_null $P1343, vivify_492
    $P1343 = root_new ['parrot';'Hash']
  vivify_492:
    set $P1344, $P1343["package_declarator"]
    unless_null $P1344, vivify_493
    new $P1344, "Undef"
  vivify_493:
    $P1345 = $P1344."ast"()
    set $P1336, $P1345
.annotate 'line', 543
    goto if_1337_end
  if_1337:
    find_lex $P1340, "$/"
    unless_null $P1340, vivify_494
    $P1340 = root_new ['parrot';'Hash']
  vivify_494:
    set $P1341, $P1340["multi_declarator"]
    unless_null $P1341, vivify_495
    new $P1341, "Undef"
  vivify_495:
    $P1342 = $P1341."ast"()
    set $P1336, $P1342
  if_1337_end:
    set $P1329, $P1336
.annotate 'line', 542
    goto if_1330_end
  if_1330:
    find_lex $P1333, "$/"
    unless_null $P1333, vivify_496
    $P1333 = root_new ['parrot';'Hash']
  vivify_496:
    set $P1334, $P1333["declarator"]
    unless_null $P1334, vivify_497
    new $P1334, "Undef"
  vivify_497:
    $P1335 = $P1334."ast"()
    set $P1329, $P1335
  if_1330_end:
    $P1346 = $P1328."!make"($P1329)
.annotate 'line', 541
    .return ($P1346)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("84_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1348
    .param pmc param_1349
.annotate 'line', 547
    .lex "self", param_1348
    .lex "$/", param_1349
.annotate 'line', 548
    find_lex $P1350, "$/"
.annotate 'line', 549
    find_lex $P1353, "$/"
    unless_null $P1353, vivify_498
    $P1353 = root_new ['parrot';'Hash']
  vivify_498:
    set $P1354, $P1353["routine_declarator"]
    unless_null $P1354, vivify_499
    new $P1354, "Undef"
  vivify_499:
    if $P1354, if_1352
.annotate 'line', 550
    find_lex $P1358, "$/"
    unless_null $P1358, vivify_500
    $P1358 = root_new ['parrot';'Hash']
  vivify_500:
    set $P1359, $P1358["variable_declarator"]
    unless_null $P1359, vivify_501
    new $P1359, "Undef"
  vivify_501:
    $P1360 = $P1359."ast"()
    set $P1351, $P1360
.annotate 'line', 549
    goto if_1352_end
  if_1352:
    find_lex $P1355, "$/"
    unless_null $P1355, vivify_502
    $P1355 = root_new ['parrot';'Hash']
  vivify_502:
    set $P1356, $P1355["routine_declarator"]
    unless_null $P1356, vivify_503
    new $P1356, "Undef"
  vivify_503:
    $P1357 = $P1356."ast"()
    set $P1351, $P1357
  if_1352_end:
    $P1361 = $P1350."!make"($P1351)
.annotate 'line', 547
    .return ($P1361)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("85_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1363
    .param pmc param_1364
.annotate 'line', 553
    .lex "self", param_1363
    .lex "$/", param_1364
    find_lex $P1365, "$/"
    find_lex $P1368, "$/"
    unless_null $P1368, vivify_504
    $P1368 = root_new ['parrot';'Hash']
  vivify_504:
    set $P1369, $P1368["declarator"]
    unless_null $P1369, vivify_505
    new $P1369, "Undef"
  vivify_505:
    if $P1369, if_1367
    find_lex $P1373, "$/"
    unless_null $P1373, vivify_506
    $P1373 = root_new ['parrot';'Hash']
  vivify_506:
    set $P1374, $P1373["routine_def"]
    unless_null $P1374, vivify_507
    new $P1374, "Undef"
  vivify_507:
    $P1375 = $P1374."ast"()
    set $P1366, $P1375
    goto if_1367_end
  if_1367:
    find_lex $P1370, "$/"
    unless_null $P1370, vivify_508
    $P1370 = root_new ['parrot';'Hash']
  vivify_508:
    set $P1371, $P1370["declarator"]
    unless_null $P1371, vivify_509
    new $P1371, "Undef"
  vivify_509:
    $P1372 = $P1371."ast"()
    set $P1366, $P1372
  if_1367_end:
    $P1376 = $P1365."!make"($P1366)
    .return ($P1376)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("86_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1378
    .param pmc param_1379
.annotate 'line', 554
    .lex "self", param_1378
    .lex "$/", param_1379
    find_lex $P1380, "$/"
    find_lex $P1383, "$/"
    unless_null $P1383, vivify_510
    $P1383 = root_new ['parrot';'Hash']
  vivify_510:
    set $P1384, $P1383["declarator"]
    unless_null $P1384, vivify_511
    new $P1384, "Undef"
  vivify_511:
    if $P1384, if_1382
    find_lex $P1388, "$/"
    unless_null $P1388, vivify_512
    $P1388 = root_new ['parrot';'Hash']
  vivify_512:
    set $P1389, $P1388["routine_def"]
    unless_null $P1389, vivify_513
    new $P1389, "Undef"
  vivify_513:
    $P1390 = $P1389."ast"()
    set $P1381, $P1390
    goto if_1382_end
  if_1382:
    find_lex $P1385, "$/"
    unless_null $P1385, vivify_514
    $P1385 = root_new ['parrot';'Hash']
  vivify_514:
    set $P1386, $P1385["declarator"]
    unless_null $P1386, vivify_515
    new $P1386, "Undef"
  vivify_515:
    $P1387 = $P1386."ast"()
    set $P1381, $P1387
  if_1382_end:
    $P1391 = $P1380."!make"($P1381)
    .return ($P1391)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("87_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1393
    .param pmc param_1394
.annotate 'line', 555
    .lex "self", param_1393
    .lex "$/", param_1394
    find_lex $P1395, "$/"
    find_lex $P1396, "$/"
    unless_null $P1396, vivify_516
    $P1396 = root_new ['parrot';'Hash']
  vivify_516:
    set $P1397, $P1396["declarator"]
    unless_null $P1397, vivify_517
    new $P1397, "Undef"
  vivify_517:
    $P1398 = $P1397."ast"()
    $P1399 = $P1395."!make"($P1398)
    .return ($P1399)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("88_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1401
    .param pmc param_1402
.annotate 'line', 558
    .const 'Sub' $P1474 = "91_1300060192.103" 
    capture_lex $P1474
    .const 'Sub' $P1429 = "89_1300060192.103" 
    capture_lex $P1429
    .lex "self", param_1401
    .lex "$/", param_1402
.annotate 'line', 559
    new $P1403, "Undef"
    .lex "$past", $P1403
.annotate 'line', 560
    new $P1404, "Undef"
    .lex "$sigil", $P1404
.annotate 'line', 561
    new $P1405, "Undef"
    .lex "$name", $P1405
.annotate 'line', 562
    new $P1406, "Undef"
    .lex "$BLOCK", $P1406
.annotate 'line', 559
    find_lex $P1407, "$/"
    unless_null $P1407, vivify_518
    $P1407 = root_new ['parrot';'Hash']
  vivify_518:
    set $P1408, $P1407["variable"]
    unless_null $P1408, vivify_519
    new $P1408, "Undef"
  vivify_519:
    $P1409 = $P1408."ast"()
    store_lex "$past", $P1409
.annotate 'line', 560
    find_lex $P1410, "$/"
    unless_null $P1410, vivify_520
    $P1410 = root_new ['parrot';'Hash']
  vivify_520:
    set $P1411, $P1410["variable"]
    unless_null $P1411, vivify_521
    $P1411 = root_new ['parrot';'Hash']
  vivify_521:
    set $P1412, $P1411["sigil"]
    unless_null $P1412, vivify_522
    new $P1412, "Undef"
  vivify_522:
    store_lex "$sigil", $P1412
.annotate 'line', 561
    find_lex $P1413, "$past"
    $P1414 = $P1413."name"()
    store_lex "$name", $P1414
.annotate 'line', 562
    get_global $P1415, "@BLOCK"
    unless_null $P1415, vivify_523
    $P1415 = root_new ['parrot';'ResizablePMCArray']
  vivify_523:
    set $P1416, $P1415[0]
    unless_null $P1416, vivify_524
    new $P1416, "Undef"
  vivify_524:
    store_lex "$BLOCK", $P1416
.annotate 'line', 563
    find_lex $P1418, "$BLOCK"
    find_lex $P1419, "$name"
    $P1420 = $P1418."symbol"($P1419)
    unless $P1420, if_1417_end
.annotate 'line', 564
    find_lex $P1421, "$/"
    $P1422 = $P1421."CURSOR"()
    find_lex $P1423, "$name"
    $P1422."panic"("Redeclaration of symbol ", $P1423)
  if_1417_end:
.annotate 'line', 566
    find_dynamic_lex $P1425, "$*SCOPE"
    unless_null $P1425, vivify_525
    get_hll_global $P1425, "$SCOPE"
    unless_null $P1425, vivify_526
    die "Contextual $*SCOPE not found"
  vivify_526:
  vivify_525:
    set $S1426, $P1425
    iseq $I1427, $S1426, "has"
    if $I1427, if_1424
.annotate 'line', 591
    .const 'Sub' $P1474 = "91_1300060192.103" 
    capture_lex $P1474
    $P1474()
    goto if_1424_end
  if_1424:
.annotate 'line', 566
    .const 'Sub' $P1429 = "89_1300060192.103" 
    capture_lex $P1429
    $P1429()
  if_1424_end:
.annotate 'line', 599
    find_lex $P1498, "$/"
    find_lex $P1499, "$past"
    $P1500 = $P1498."!make"($P1499)
.annotate 'line', 558
    .return ($P1500)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1473"  :anon :subid("91_1300060192.103") :outer("88_1300060192.103")
.annotate 'line', 592
    new $P1475, "Undef"
    .lex "$scope", $P1475
.annotate 'line', 593
    new $P1476, "Undef"
    .lex "$decl", $P1476
.annotate 'line', 592
    find_dynamic_lex $P1479, "$*SCOPE"
    unless_null $P1479, vivify_527
    get_hll_global $P1479, "$SCOPE"
    unless_null $P1479, vivify_528
    die "Contextual $*SCOPE not found"
  vivify_528:
  vivify_527:
    set $S1480, $P1479
    iseq $I1481, $S1480, "our"
    if $I1481, if_1478
    new $P1483, "String"
    assign $P1483, "lexical"
    set $P1477, $P1483
    goto if_1478_end
  if_1478:
    new $P1482, "String"
    assign $P1482, "package"
    set $P1477, $P1482
  if_1478_end:
    store_lex "$scope", $P1477
.annotate 'line', 593
    get_hll_global $P1484, ["PAST"], "Var"
    find_lex $P1485, "$name"
    find_lex $P1486, "$scope"
.annotate 'line', 594
    find_lex $P1487, "$sigil"
    $P1488 = "vivitype"($P1487)
    find_lex $P1489, "$/"
    $P1490 = $P1484."new"($P1485 :named("name"), $P1486 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1488 :named("viviself"), $P1489 :named("node"))
.annotate 'line', 593
    store_lex "$decl", $P1490
.annotate 'line', 596
    find_lex $P1491, "$BLOCK"
    find_lex $P1492, "$name"
    find_lex $P1493, "$scope"
    $P1491."symbol"($P1492, $P1493 :named("scope"))
.annotate 'line', 597
    find_lex $P1494, "$BLOCK"
    unless_null $P1494, vivify_529
    $P1494 = root_new ['parrot';'ResizablePMCArray']
  vivify_529:
    set $P1495, $P1494[0]
    unless_null $P1495, vivify_530
    new $P1495, "Undef"
  vivify_530:
    find_lex $P1496, "$decl"
    $P1497 = $P1495."push"($P1496)
.annotate 'line', 591
    .return ($P1497)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1428"  :anon :subid("89_1300060192.103") :outer("88_1300060192.103")
.annotate 'line', 566
    .const 'Sub' $P1459 = "90_1300060192.103" 
    capture_lex $P1459
.annotate 'line', 568
    new $P1430, "Undef"
    .lex "$meta-attr-type", $P1430
.annotate 'line', 576
    new $P1431, "Undef"
    .lex "$meta_args", $P1431
.annotate 'line', 568
    find_dynamic_lex $P1434, "$*PKGDECL"
    unless_null $P1434, vivify_531
    get_hll_global $P1434, "$PKGDECL"
    unless_null $P1434, vivify_532
    die "Contextual $*PKGDECL not found"
  vivify_532:
  vivify_531:
    find_dynamic_lex $P1435, "%*HOW-METAATTR"
    unless_null $P1435, vivify_533
    get_hll_global $P1435, "%HOW-METAATTR"
    unless_null $P1435, vivify_534
    die "Contextual %*HOW-METAATTR not found"
  vivify_534:
  vivify_533:
    set $P1436, $P1435[$P1434]
    unless_null $P1436, vivify_535
    new $P1436, "Undef"
  vivify_535:
    unless $P1436, unless_1433
    set $P1432, $P1436
    goto unless_1433_end
  unless_1433:
    find_dynamic_lex $P1437, "$*DEFAULT-METAATTR"
    unless_null $P1437, vivify_536
    get_hll_global $P1437, "$DEFAULT-METAATTR"
    unless_null $P1437, vivify_537
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_537:
  vivify_536:
    set $P1432, $P1437
  unless_1433_end:
    store_lex "$meta-attr-type", $P1432
.annotate 'line', 569
    find_dynamic_lex $P1438, "$*PACKAGE-SETUP"
    unless_null $P1438, vivify_538
    get_hll_global $P1438, "$PACKAGE-SETUP"
    unless_null $P1438, vivify_539
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_539:
  vivify_538:
    get_hll_global $P1439, ["PAST"], "Op"
.annotate 'line', 571
    get_hll_global $P1440, ["PAST"], "Op"
.annotate 'line', 573
    get_hll_global $P1441, ["PAST"], "Var"
    $P1442 = $P1441."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1443 = $P1440."new"($P1442, "get_how PP" :named("pirop"))
.annotate 'line', 575
    get_hll_global $P1444, ["PAST"], "Var"
    $P1445 = $P1444."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 576
    get_hll_global $P1446, ["PAST"], "Op"
.annotate 'line', 578
    get_hll_global $P1447, ["PAST"], "Var"
    find_lex $P1448, "$meta-attr-type"
    $P1449 = $P1447."new"($P1448 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 579
    get_hll_global $P1450, ["PAST"], "Val"
    find_lex $P1451, "$name"
    $P1452 = $P1450."new"($P1451 :named("value"), "name" :named("named"))
    $P1453 = $P1446."new"($P1449, $P1452, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 576
    store_lex "$meta_args", $P1453
    $P1454 = $P1439."new"($P1443, $P1445, $P1453, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 569
    $P1438."push"($P1454)
.annotate 'line', 582
    find_lex $P1456, "$/"
    unless_null $P1456, vivify_540
    $P1456 = root_new ['parrot';'Hash']
  vivify_540:
    set $P1457, $P1456["typename"]
    unless_null $P1457, vivify_541
    new $P1457, "Undef"
  vivify_541:
    unless $P1457, if_1455_end
    .const 'Sub' $P1459 = "90_1300060192.103" 
    capture_lex $P1459
    $P1459()
  if_1455_end:
.annotate 'line', 588
    find_lex $P1469, "$BLOCK"
    find_lex $P1470, "$name"
    $P1469."symbol"($P1470, "attribute" :named("scope"))
.annotate 'line', 589
    get_hll_global $P1471, ["PAST"], "Stmts"
    $P1472 = $P1471."new"()
    store_lex "$past", $P1472
.annotate 'line', 566
    .return ($P1472)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1458"  :anon :subid("90_1300060192.103") :outer("89_1300060192.103")
.annotate 'line', 583
    new $P1460, "Undef"
    .lex "$type", $P1460
    find_lex $P1461, "$/"
    unless_null $P1461, vivify_542
    $P1461 = root_new ['parrot';'Hash']
  vivify_542:
    set $P1462, $P1461["typename"]
    unless_null $P1462, vivify_543
    $P1462 = root_new ['parrot';'ResizablePMCArray']
  vivify_543:
    set $P1463, $P1462[0]
    unless_null $P1463, vivify_544
    new $P1463, "Undef"
  vivify_544:
    $P1464 = $P1463."ast"()
    store_lex "$type", $P1464
.annotate 'line', 584
    find_lex $P1465, "$type"
    $P1465."named"("type")
.annotate 'line', 585
    find_lex $P1466, "$meta_args"
    find_lex $P1467, "$type"
    $P1468 = $P1466."push"($P1467)
.annotate 'line', 582
    .return ($P1468)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("92_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1502
    .param pmc param_1503
.annotate 'line', 602
    .lex "self", param_1502
    .lex "$/", param_1503
    find_lex $P1504, "$/"
    find_lex $P1505, "$/"
    unless_null $P1505, vivify_545
    $P1505 = root_new ['parrot';'Hash']
  vivify_545:
    set $P1506, $P1505["routine_def"]
    unless_null $P1506, vivify_546
    new $P1506, "Undef"
  vivify_546:
    $P1507 = $P1506."ast"()
    $P1508 = $P1504."!make"($P1507)
    .return ($P1508)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("93_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1510
    .param pmc param_1511
.annotate 'line', 603
    .lex "self", param_1510
    .lex "$/", param_1511
    find_lex $P1512, "$/"
    find_lex $P1513, "$/"
    unless_null $P1513, vivify_547
    $P1513 = root_new ['parrot';'Hash']
  vivify_547:
    set $P1514, $P1513["method_def"]
    unless_null $P1514, vivify_548
    new $P1514, "Undef"
  vivify_548:
    $P1515 = $P1514."ast"()
    $P1516 = $P1512."!make"($P1515)
    .return ($P1516)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("94_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1518
    .param pmc param_1519
.annotate 'line', 605
    .const 'Sub' $P1756 = "100_1300060192.103" 
    capture_lex $P1756
    .const 'Sub' $P1539 = "95_1300060192.103" 
    capture_lex $P1539
    .lex "self", param_1518
    .lex "$/", param_1519
.annotate 'line', 608
    new $P1520, "Undef"
    .lex "$past", $P1520
.annotate 'line', 619
    new $P1521, "Undef"
    .lex "$block", $P1521
.annotate 'line', 605
    find_lex $P1522, "$past"
.annotate 'line', 609
    find_lex $P1524, "$/"
    unless_null $P1524, vivify_549
    $P1524 = root_new ['parrot';'Hash']
  vivify_549:
    set $P1525, $P1524["onlystar"]
    unless_null $P1525, vivify_550
    new $P1525, "Undef"
  vivify_550:
    if $P1525, if_1523
.annotate 'line', 613
    find_lex $P1527, "$/"
    unless_null $P1527, vivify_551
    $P1527 = root_new ['parrot';'Hash']
  vivify_551:
    set $P1528, $P1527["blockoid"]
    unless_null $P1528, vivify_552
    new $P1528, "Undef"
  vivify_552:
    $P1529 = $P1528."ast"()
    store_lex "$past", $P1529
.annotate 'line', 614
    find_lex $P1530, "$past"
    $P1530."blocktype"("declaration")
.annotate 'line', 615
    find_dynamic_lex $P1532, "$*RETURN_USED"
    unless_null $P1532, vivify_553
    get_hll_global $P1532, "$RETURN_USED"
    unless_null $P1532, vivify_554
    die "Contextual $*RETURN_USED not found"
  vivify_554:
  vivify_553:
    unless $P1532, if_1531_end
.annotate 'line', 616
    find_lex $P1533, "$past"
    $P1533."control"("return_pir")
  if_1531_end:
.annotate 'line', 612
    goto if_1523_end
  if_1523:
.annotate 'line', 610
    $P1526 = "only_star_block"()
    store_lex "$past", $P1526
  if_1523_end:
.annotate 'line', 619
    find_lex $P1534, "$past"
    store_lex "$block", $P1534
.annotate 'line', 621
    find_lex $P1536, "$/"
    unless_null $P1536, vivify_555
    $P1536 = root_new ['parrot';'Hash']
  vivify_555:
    set $P1537, $P1536["deflongname"]
    unless_null $P1537, vivify_556
    new $P1537, "Undef"
  vivify_556:
    unless $P1537, if_1535_end
    .const 'Sub' $P1539 = "95_1300060192.103" 
    capture_lex $P1539
    $P1539()
  if_1535_end:
.annotate 'line', 726
    find_lex $P1745, "$block"
    find_lex $P1746, "$past"
    unless_null $P1746, vivify_619
    $P1746 = root_new ['parrot';'Hash']
    store_lex "$past", $P1746
  vivify_619:
    set $P1746["block_past"], $P1745
.annotate 'line', 727
    find_lex $P1748, "$/"
    unless_null $P1748, vivify_620
    $P1748 = root_new ['parrot';'Hash']
  vivify_620:
    set $P1749, $P1748["trait"]
    unless_null $P1749, vivify_621
    new $P1749, "Undef"
  vivify_621:
    unless $P1749, if_1747_end
.annotate 'line', 728
    find_lex $P1751, "$/"
    unless_null $P1751, vivify_622
    $P1751 = root_new ['parrot';'Hash']
  vivify_622:
    set $P1752, $P1751["trait"]
    unless_null $P1752, vivify_623
    new $P1752, "Undef"
  vivify_623:
    defined $I1753, $P1752
    unless $I1753, for_undef_624
    iter $P1750, $P1752
    new $P1763, 'ExceptionHandler'
    set_label $P1763, loop1762_handler
    $P1763."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1763
  loop1762_test:
    unless $P1750, loop1762_done
    shift $P1754, $P1750
  loop1762_redo:
    .const 'Sub' $P1756 = "100_1300060192.103" 
    capture_lex $P1756
    $P1756($P1754)
  loop1762_next:
    goto loop1762_test
  loop1762_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1764, exception, 'type'
    eq $P1764, .CONTROL_LOOP_NEXT, loop1762_next
    eq $P1764, .CONTROL_LOOP_REDO, loop1762_redo
  loop1762_done:
    pop_eh 
  for_undef_624:
  if_1747_end:
.annotate 'line', 731
    find_lex $P1765, "$/"
    find_lex $P1766, "$past"
    $P1767 = $P1765."!make"($P1766)
.annotate 'line', 605
    .return ($P1767)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1538"  :anon :subid("95_1300060192.103") :outer("94_1300060192.103")
.annotate 'line', 621
    .const 'Sub' $P1661 = "99_1300060192.103" 
    capture_lex $P1661
    .const 'Sub' $P1572 = "96_1300060192.103" 
    capture_lex $P1572
.annotate 'line', 622
    new $P1540, "Undef"
    .lex "$name", $P1540
    find_lex $P1541, "$/"
    unless_null $P1541, vivify_557
    $P1541 = root_new ['parrot';'Hash']
  vivify_557:
    set $P1542, $P1541["sigil"]
    unless_null $P1542, vivify_558
    $P1542 = root_new ['parrot';'ResizablePMCArray']
  vivify_558:
    set $P1543, $P1542[0]
    unless_null $P1543, vivify_559
    new $P1543, "Undef"
  vivify_559:
    set $S1544, $P1543
    new $P1545, 'String'
    set $P1545, $S1544
    find_lex $P1546, "$/"
    unless_null $P1546, vivify_560
    $P1546 = root_new ['parrot';'Hash']
  vivify_560:
    set $P1547, $P1546["deflongname"]
    unless_null $P1547, vivify_561
    $P1547 = root_new ['parrot';'ResizablePMCArray']
  vivify_561:
    set $P1548, $P1547[0]
    unless_null $P1548, vivify_562
    new $P1548, "Undef"
  vivify_562:
    $S1549 = $P1548."ast"()
    concat $P1550, $P1545, $S1549
    store_lex "$name", $P1550
.annotate 'line', 623
    find_lex $P1551, "$past"
    find_lex $P1552, "$name"
    $P1551."name"($P1552)
.annotate 'line', 624
    find_dynamic_lex $P1558, "$*SCOPE"
    unless_null $P1558, vivify_563
    get_hll_global $P1558, "$SCOPE"
    unless_null $P1558, vivify_564
    die "Contextual $*SCOPE not found"
  vivify_564:
  vivify_563:
    set $S1559, $P1558
    iseq $I1560, $S1559, ""
    unless $I1560, unless_1557
    new $P1556, 'Integer'
    set $P1556, $I1560
    goto unless_1557_end
  unless_1557:
    find_dynamic_lex $P1561, "$*SCOPE"
    unless_null $P1561, vivify_565
    get_hll_global $P1561, "$SCOPE"
    unless_null $P1561, vivify_566
    die "Contextual $*SCOPE not found"
  vivify_566:
  vivify_565:
    set $S1562, $P1561
    iseq $I1563, $S1562, "my"
    new $P1556, 'Integer'
    set $P1556, $I1563
  unless_1557_end:
    unless $P1556, unless_1555
    set $P1554, $P1556
    goto unless_1555_end
  unless_1555:
    find_dynamic_lex $P1564, "$*SCOPE"
    unless_null $P1564, vivify_567
    get_hll_global $P1564, "$SCOPE"
    unless_null $P1564, vivify_568
    die "Contextual $*SCOPE not found"
  vivify_568:
  vivify_567:
    set $S1565, $P1564
    iseq $I1566, $S1565, "our"
    new $P1554, 'Integer'
    set $P1554, $I1566
  unless_1555_end:
    if $P1554, if_1553
.annotate 'line', 716
    find_lex $P1730, "$/"
    $P1731 = $P1730."CURSOR"()
    find_dynamic_lex $P1732, "$*SCOPE"
    unless_null $P1732, vivify_569
    get_hll_global $P1732, "$SCOPE"
    unless_null $P1732, vivify_570
    die "Contextual $*SCOPE not found"
  vivify_570:
  vivify_569:
    concat $P1733, $P1732, " scoped routines are not supported yet"
    $P1731."panic"($P1733)
.annotate 'line', 715
    goto if_1553_end
  if_1553:
.annotate 'line', 625
    find_dynamic_lex $P1568, "$*MULTINESS"
    unless_null $P1568, vivify_571
    get_hll_global $P1568, "$MULTINESS"
    unless_null $P1568, vivify_572
    die "Contextual $*MULTINESS not found"
  vivify_572:
  vivify_571:
    set $S1569, $P1568
    iseq $I1570, $S1569, "multi"
    if $I1570, if_1567
.annotate 'line', 676
    find_dynamic_lex $P1657, "$*MULTINESS"
    unless_null $P1657, vivify_573
    get_hll_global $P1657, "$MULTINESS"
    unless_null $P1657, vivify_574
    die "Contextual $*MULTINESS not found"
  vivify_574:
  vivify_573:
    set $S1658, $P1657
    iseq $I1659, $S1658, "proto"
    if $I1659, if_1656
.annotate 'line', 695
    get_global $P1691, "@BLOCK"
    unless_null $P1691, vivify_575
    $P1691 = root_new ['parrot';'ResizablePMCArray']
  vivify_575:
    set $P1692, $P1691[0]
    unless_null $P1692, vivify_576
    $P1692 = root_new ['parrot';'ResizablePMCArray']
  vivify_576:
    set $P1693, $P1692[0]
    unless_null $P1693, vivify_577
    new $P1693, "Undef"
  vivify_577:
    get_hll_global $P1694, ["PAST"], "Var"
    find_lex $P1695, "$name"
    find_lex $P1696, "$past"
    $P1697 = $P1694."new"($P1695 :named("name"), 1 :named("isdecl"), $P1696 :named("viviself"), "lexical" :named("scope"))
    $P1693."push"($P1697)
.annotate 'line', 697
    get_global $P1698, "@BLOCK"
    unless_null $P1698, vivify_578
    $P1698 = root_new ['parrot';'ResizablePMCArray']
  vivify_578:
    set $P1699, $P1698[0]
    unless_null $P1699, vivify_579
    new $P1699, "Undef"
  vivify_579:
    find_lex $P1700, "$name"
    $P1699."symbol"($P1700, "lexical" :named("scope"))
.annotate 'line', 698
    find_dynamic_lex $P1702, "$*SCOPE"
    unless_null $P1702, vivify_580
    get_hll_global $P1702, "$SCOPE"
    unless_null $P1702, vivify_581
    die "Contextual $*SCOPE not found"
  vivify_581:
  vivify_580:
    set $S1703, $P1702
    iseq $I1704, $S1703, "our"
    unless $I1704, if_1701_end
.annotate 'line', 701
    get_global $P1705, "@BLOCK"
    unless_null $P1705, vivify_582
    $P1705 = root_new ['parrot';'ResizablePMCArray']
  vivify_582:
    set $P1706, $P1705[0]
    unless_null $P1706, vivify_583
    $P1706 = root_new ['parrot';'ResizablePMCArray']
  vivify_583:
    set $P1707, $P1706[0]
    unless_null $P1707, vivify_584
    new $P1707, "Undef"
  vivify_584:
    get_hll_global $P1708, ["PAST"], "Op"
.annotate 'line', 703
    get_hll_global $P1709, ["PAST"], "Var"
    find_lex $P1710, "$name"
    $P1711 = $P1709."new"($P1710 :named("name"), "package" :named("scope"))
.annotate 'line', 704
    get_hll_global $P1712, ["PAST"], "Var"
    find_lex $P1713, "$name"
    $P1714 = $P1712."new"($P1713 :named("name"), "lexical" :named("scope"))
    $P1715 = $P1708."new"($P1711, $P1714, "bind" :named("pasttype"))
.annotate 'line', 701
    $P1707."push"($P1715)
.annotate 'line', 706
    get_global $P1716, "@BLOCK"
    unless_null $P1716, vivify_585
    $P1716 = root_new ['parrot';'ResizablePMCArray']
  vivify_585:
    set $P1717, $P1716[0]
    unless_null $P1717, vivify_586
    new $P1717, "Undef"
  vivify_586:
    $P1718 = $P1717."loadinit"()
    get_hll_global $P1719, ["PAST"], "Op"
.annotate 'line', 708
    get_hll_global $P1720, ["PAST"], "Var"
    find_lex $P1721, "$name"
    $P1722 = $P1720."new"($P1721 :named("name"), "package" :named("scope"))
.annotate 'line', 709
    get_hll_global $P1723, ["PAST"], "Val"
    find_lex $P1724, "$past"
    $P1725 = $P1723."new"($P1724 :named("value"))
    $P1726 = $P1719."new"($P1722, $P1725, "bind" :named("pasttype"))
.annotate 'line', 706
    $P1718."push"($P1726)
  if_1701_end:
.annotate 'line', 694
    goto if_1656_end
  if_1656:
.annotate 'line', 676
    .const 'Sub' $P1661 = "99_1300060192.103" 
    capture_lex $P1661
    $P1661()
  if_1656_end:
    goto if_1567_end
  if_1567:
.annotate 'line', 625
    .const 'Sub' $P1572 = "96_1300060192.103" 
    capture_lex $P1572
    $P1572()
  if_1567_end:
.annotate 'line', 713
    get_hll_global $P1727, ["PAST"], "Var"
    find_lex $P1728, "$name"
    $P1729 = $P1727."new"($P1728 :named("name"))
    store_lex "$past", $P1729
  if_1553_end:
.annotate 'line', 720
    find_lex $P1738, "$name"
    set $S1739, $P1738
    iseq $I1740, $S1739, "MAIN"
    if $I1740, if_1737
    new $P1736, 'Integer'
    set $P1736, $I1740
    goto if_1737_end
  if_1737:
    find_dynamic_lex $P1741, "$*MULTINESS"
    unless_null $P1741, vivify_617
    get_hll_global $P1741, "$MULTINESS"
    unless_null $P1741, vivify_618
    die "Contextual $*MULTINESS not found"
  vivify_618:
  vivify_617:
    set $S1742, $P1741
    isne $I1743, $S1742, "multi"
    new $P1736, 'Integer'
    set $P1736, $I1743
  if_1737_end:
    if $P1736, if_1735
    set $P1734, $P1736
    goto if_1735_end
  if_1735:
.annotate 'line', 721
    find_lex $P1744, "$block"
    store_dynamic_lex "$*MAIN_SUB", $P1744
.annotate 'line', 720
    set $P1734, $P1744
  if_1735_end:
.annotate 'line', 621
    .return ($P1734)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1660"  :anon :subid("99_1300060192.103") :outer("95_1300060192.103")
.annotate 'line', 681
    new $P1662, "Undef"
    .lex "$cholder", $P1662
.annotate 'line', 680
    find_dynamic_lex $P1664, "$*SCOPE"
    unless_null $P1664, vivify_587
    get_hll_global $P1664, "$SCOPE"
    unless_null $P1664, vivify_588
    die "Contextual $*SCOPE not found"
  vivify_588:
  vivify_587:
    set $S1665, $P1664
    iseq $I1666, $S1665, "our"
    unless $I1666, if_1663_end
    die "our-scoped protos not yet implemented"
  if_1663_end:
.annotate 'line', 681
    get_hll_global $P1667, ["PAST"], "Op"
    $P1668 = $P1667."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1668
.annotate 'line', 682
    get_global $P1669, "@BLOCK"
    unless_null $P1669, vivify_589
    $P1669 = root_new ['parrot';'ResizablePMCArray']
  vivify_589:
    set $P1670, $P1669[0]
    unless_null $P1670, vivify_590
    $P1670 = root_new ['parrot';'ResizablePMCArray']
  vivify_590:
    set $P1671, $P1670[0]
    unless_null $P1671, vivify_591
    new $P1671, "Undef"
  vivify_591:
    get_hll_global $P1672, ["PAST"], "Var"
    find_lex $P1673, "$name"
    find_lex $P1674, "$past"
    $P1675 = $P1672."new"($P1673 :named("name"), 1 :named("isdecl"), $P1674 :named("viviself"), "lexical" :named("scope"))
    $P1671."push"($P1675)
.annotate 'line', 684
    get_global $P1676, "@BLOCK"
    unless_null $P1676, vivify_592
    $P1676 = root_new ['parrot';'ResizablePMCArray']
  vivify_592:
    set $P1677, $P1676[0]
    unless_null $P1677, vivify_593
    $P1677 = root_new ['parrot';'ResizablePMCArray']
  vivify_593:
    set $P1678, $P1677[0]
    unless_null $P1678, vivify_594
    new $P1678, "Undef"
  vivify_594:
    get_hll_global $P1679, ["PAST"], "Op"
.annotate 'line', 686
    get_hll_global $P1680, ["PAST"], "Var"
    find_lex $P1681, "$name"
    $P1682 = $P1680."new"($P1681 :named("name"))
    find_lex $P1683, "$cholder"
    $P1684 = $P1679."new"($P1682, $P1683, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 684
    $P1678."push"($P1684)
.annotate 'line', 689
    get_global $P1685, "@BLOCK"
    unless_null $P1685, vivify_595
    $P1685 = root_new ['parrot';'ResizablePMCArray']
  vivify_595:
    set $P1686, $P1685[0]
    unless_null $P1686, vivify_596
    new $P1686, "Undef"
  vivify_596:
    find_lex $P1687, "$name"
    find_lex $P1688, "$cholder"
    $P1686."symbol"($P1687, "lexical" :named("scope"), 1 :named("proto"), $P1688 :named("cholder"))
.annotate 'line', 692
    find_lex $P1689, "$past"
    $P1690 = $P1689."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 676
    .return ($P1690)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1571"  :anon :subid("96_1300060192.103") :outer("95_1300060192.103")
.annotate 'line', 625
    .const 'Sub' $P1590 = "97_1300060192.103" 
    capture_lex $P1590
.annotate 'line', 628
    new $P1573, "Undef"
    .lex "$cholder", $P1573
.annotate 'line', 629
    $P1574 = root_new ['parrot';'Hash']
    .lex "%sym", $P1574
.annotate 'line', 627
    find_dynamic_lex $P1576, "$*SCOPE"
    unless_null $P1576, vivify_597
    get_hll_global $P1576, "$SCOPE"
    unless_null $P1576, vivify_598
    die "Contextual $*SCOPE not found"
  vivify_598:
  vivify_597:
    set $S1577, $P1576
    iseq $I1578, $S1577, "our"
    unless $I1578, if_1575_end
    die "our-scoped multis not yet implemented"
  if_1575_end:
    find_lex $P1579, "$cholder"
.annotate 'line', 629
    get_global $P1580, "@BLOCK"
    unless_null $P1580, vivify_599
    $P1580 = root_new ['parrot';'ResizablePMCArray']
  vivify_599:
    set $P1581, $P1580[0]
    unless_null $P1581, vivify_600
    new $P1581, "Undef"
  vivify_600:
    find_lex $P1582, "$name"
    $P1583 = $P1581."symbol"($P1582)
    store_lex "%sym", $P1583
.annotate 'line', 630
    find_lex $P1585, "%sym"
    unless_null $P1585, vivify_601
    $P1585 = root_new ['parrot';'Hash']
  vivify_601:
    set $P1586, $P1585["cholder"]
    unless_null $P1586, vivify_602
    new $P1586, "Undef"
  vivify_602:
    if $P1586, if_1584
.annotate 'line', 635
    .const 'Sub' $P1590 = "97_1300060192.103" 
    capture_lex $P1590
    $P1590()
    goto if_1584_end
  if_1584:
.annotate 'line', 631
    find_lex $P1587, "%sym"
    unless_null $P1587, vivify_615
    $P1587 = root_new ['parrot';'Hash']
  vivify_615:
    set $P1588, $P1587["cholder"]
    unless_null $P1588, vivify_616
    new $P1588, "Undef"
  vivify_616:
    store_lex "$cholder", $P1588
  if_1584_end:
.annotate 'line', 671
    find_lex $P1652, "$cholder"
    find_lex $P1653, "$past"
    $P1652."push"($P1653)
.annotate 'line', 674
    find_lex $P1654, "$past"
    $P1655 = "attach_multi_signature"($P1654)
.annotate 'line', 625
    .return ($P1655)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1589"  :anon :subid("97_1300060192.103") :outer("96_1300060192.103")
.annotate 'line', 635
    .const 'Sub' $P1604 = "98_1300060192.103" 
    capture_lex $P1604
.annotate 'line', 642
    new $P1591, "Undef"
    .lex "$found_proto", $P1591
.annotate 'line', 660
    new $P1592, "Undef"
    .lex "$dispatch_setup", $P1592
.annotate 'line', 637
    find_lex $P1594, "%sym"
    unless_null $P1594, vivify_603
    $P1594 = root_new ['parrot';'Hash']
  vivify_603:
    set $P1595, $P1594["proto"]
    unless_null $P1595, vivify_604
    new $P1595, "Undef"
  vivify_604:
    unless $P1595, if_1593_end
.annotate 'line', 640
    find_lex $P1596, "$/"
    $P1597 = $P1596."CURSOR"()
    $P1597."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1593_end:
.annotate 'line', 637
    find_lex $P1598, "$found_proto"
.annotate 'line', 643
    get_global $P1600, "@BLOCK"
    defined $I1601, $P1600
    unless $I1601, for_undef_605
    iter $P1599, $P1600
    new $P1626, 'ExceptionHandler'
    set_label $P1626, loop1625_handler
    $P1626."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1626
  loop1625_test:
    unless $P1599, loop1625_done
    shift $P1602, $P1599
  loop1625_redo:
    .const 'Sub' $P1604 = "98_1300060192.103" 
    capture_lex $P1604
    $P1604($P1602)
  loop1625_next:
    goto loop1625_test
  loop1625_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1627, exception, 'type'
    eq $P1627, .CONTROL_LOOP_NEXT, loop1625_next
    eq $P1627, .CONTROL_LOOP_REDO, loop1625_redo
  loop1625_done:
    pop_eh 
  for_undef_605:
.annotate 'line', 654
    find_lex $P1629, "$found_proto"
    if $P1629, unless_1628_end
.annotate 'line', 655
    find_lex $P1630, "$/"
    $P1631 = $P1630."CURSOR"()
    $P1631."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1628_end:
.annotate 'line', 659
    get_hll_global $P1632, ["PAST"], "Op"
    $P1633 = $P1632."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1633
.annotate 'line', 660
    get_hll_global $P1634, ["PAST"], "Op"
.annotate 'line', 662
    get_hll_global $P1635, ["PAST"], "Var"
    find_lex $P1636, "$name"
    $P1637 = $P1635."new"($P1636 :named("name"), "outer" :named("scope"))
    find_lex $P1638, "$cholder"
    $P1639 = $P1634."new"($P1637, $P1638, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 660
    store_lex "$dispatch_setup", $P1639
.annotate 'line', 665
    get_global $P1640, "@BLOCK"
    unless_null $P1640, vivify_610
    $P1640 = root_new ['parrot';'ResizablePMCArray']
  vivify_610:
    set $P1641, $P1640[0]
    unless_null $P1641, vivify_611
    $P1641 = root_new ['parrot';'ResizablePMCArray']
  vivify_611:
    set $P1642, $P1641[0]
    unless_null $P1642, vivify_612
    new $P1642, "Undef"
  vivify_612:
    get_hll_global $P1643, ["PAST"], "Var"
    find_lex $P1644, "$name"
    find_lex $P1645, "$dispatch_setup"
    $P1646 = $P1643."new"($P1644 :named("name"), 1 :named("isdecl"), $P1645 :named("viviself"), "lexical" :named("scope"))
    $P1642."push"($P1646)
.annotate 'line', 667
    get_global $P1647, "@BLOCK"
    unless_null $P1647, vivify_613
    $P1647 = root_new ['parrot';'ResizablePMCArray']
  vivify_613:
    set $P1648, $P1647[0]
    unless_null $P1648, vivify_614
    new $P1648, "Undef"
  vivify_614:
    find_lex $P1649, "$name"
    find_lex $P1650, "$cholder"
    $P1651 = $P1648."symbol"($P1649, "lexical" :named("scope"), $P1650 :named("cholder"))
.annotate 'line', 635
    .return ($P1651)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1603"  :anon :subid("98_1300060192.103") :outer("97_1300060192.103")
    .param pmc param_1606
.annotate 'line', 644
    $P1605 = root_new ['parrot';'Hash']
    .lex "%sym", $P1605
    .lex "$_", param_1606
    find_lex $P1607, "$_"
    find_lex $P1608, "$name"
    $P1609 = $P1607."symbol"($P1608)
    store_lex "%sym", $P1609
.annotate 'line', 645
    find_lex $P1614, "%sym"
    unless_null $P1614, vivify_606
    $P1614 = root_new ['parrot';'Hash']
  vivify_606:
    set $P1615, $P1614["proto"]
    unless_null $P1615, vivify_607
    new $P1615, "Undef"
  vivify_607:
    unless $P1615, unless_1613
    set $P1612, $P1615
    goto unless_1613_end
  unless_1613:
    find_lex $P1616, "%sym"
    unless_null $P1616, vivify_608
    $P1616 = root_new ['parrot';'Hash']
  vivify_608:
    set $P1617, $P1616["cholder"]
    unless_null $P1617, vivify_609
    new $P1617, "Undef"
  vivify_609:
    set $P1612, $P1617
  unless_1613_end:
    if $P1612, if_1611
.annotate 'line', 648
    find_lex $P1621, "%sym"
    if $P1621, if_1620
    set $P1619, $P1621
    goto if_1620_end
  if_1620:
.annotate 'line', 649
    find_lex $P1622, "$/"
    $P1623 = $P1622."CURSOR"()
    $P1624 = $P1623."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 648
    set $P1619, $P1624
  if_1620_end:
    set $P1610, $P1619
.annotate 'line', 645
    goto if_1611_end
  if_1611:
.annotate 'line', 646
    new $P1618, "Integer"
    assign $P1618, 1
    store_lex "$found_proto", $P1618
.annotate 'line', 645
    set $P1610, $P1618
  if_1611_end:
.annotate 'line', 643
    .return ($P1610)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1755"  :anon :subid("100_1300060192.103") :outer("94_1300060192.103")
    .param pmc param_1757
.annotate 'line', 728
    .lex "$_", param_1757
    find_lex $P1758, "$_"
    $P1759 = $P1758."ast"()
    find_lex $P1760, "$/"
    $P1761 = $P1759($P1760)
    .return ($P1761)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("101_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1769
    .param pmc param_1770
.annotate 'line', 735
    .const 'Sub' $P1882 = "103_1300060192.103" 
    capture_lex $P1882
    .const 'Sub' $P1798 = "102_1300060192.103" 
    capture_lex $P1798
    .lex "self", param_1769
    .lex "$/", param_1770
.annotate 'line', 738
    new $P1771, "Undef"
    .lex "$past", $P1771
.annotate 'line', 735
    find_lex $P1772, "$past"
.annotate 'line', 739
    find_lex $P1774, "$/"
    unless_null $P1774, vivify_625
    $P1774 = root_new ['parrot';'Hash']
  vivify_625:
    set $P1775, $P1774["onlystar"]
    unless_null $P1775, vivify_626
    new $P1775, "Undef"
  vivify_626:
    if $P1775, if_1773
.annotate 'line', 743
    find_lex $P1777, "$/"
    unless_null $P1777, vivify_627
    $P1777 = root_new ['parrot';'Hash']
  vivify_627:
    set $P1778, $P1777["blockoid"]
    unless_null $P1778, vivify_628
    new $P1778, "Undef"
  vivify_628:
    $P1779 = $P1778."ast"()
    store_lex "$past", $P1779
.annotate 'line', 744
    find_lex $P1780, "$past"
    $P1780."blocktype"("declaration")
.annotate 'line', 745
    find_dynamic_lex $P1782, "$*RETURN_USED"
    unless_null $P1782, vivify_629
    get_hll_global $P1782, "$RETURN_USED"
    unless_null $P1782, vivify_630
    die "Contextual $*RETURN_USED not found"
  vivify_630:
  vivify_629:
    unless $P1782, if_1781_end
.annotate 'line', 746
    find_lex $P1783, "$past"
    $P1783."control"("return_pir")
  if_1781_end:
.annotate 'line', 742
    goto if_1773_end
  if_1773:
.annotate 'line', 740
    $P1776 = "only_star_block"()
    store_lex "$past", $P1776
  if_1773_end:
.annotate 'line', 751
    find_lex $P1785, "$past"
    unless_null $P1785, vivify_631
    $P1785 = root_new ['parrot';'Hash']
  vivify_631:
    set $P1786, $P1785["signature_has_invocant"]
    unless_null $P1786, vivify_632
    new $P1786, "Undef"
  vivify_632:
    if $P1786, unless_1784_end
.annotate 'line', 752
    find_lex $P1787, "$past"
    unless_null $P1787, vivify_633
    $P1787 = root_new ['parrot';'ResizablePMCArray']
  vivify_633:
    set $P1788, $P1787[0]
    unless_null $P1788, vivify_634
    new $P1788, "Undef"
  vivify_634:
    get_hll_global $P1789, ["PAST"], "Var"
.annotate 'line', 754
    get_hll_global $P1790, ["PAST"], "Var"
    $P1791 = $P1790."new"("$?CLASS" :named("name"))
    $P1792 = $P1789."new"("self" :named("name"), "parameter" :named("scope"), $P1791 :named("multitype"))
.annotate 'line', 752
    $P1788."unshift"($P1792)
  unless_1784_end:
.annotate 'line', 757
    find_lex $P1793, "$past"
    $P1793."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 760
    find_lex $P1795, "$/"
    unless_null $P1795, vivify_635
    $P1795 = root_new ['parrot';'Hash']
  vivify_635:
    set $P1796, $P1795["deflongname"]
    unless_null $P1796, vivify_636
    new $P1796, "Undef"
  vivify_636:
    unless $P1796, if_1794_end
    .const 'Sub' $P1798 = "102_1300060192.103" 
    capture_lex $P1798
    $P1798()
  if_1794_end:
.annotate 'line', 795
    find_dynamic_lex $P1864, "$*SCOPE"
    unless_null $P1864, vivify_654
    get_hll_global $P1864, "$SCOPE"
    unless_null $P1864, vivify_655
    die "Contextual $*SCOPE not found"
  vivify_655:
  vivify_654:
    set $S1865, $P1864
    iseq $I1866, $S1865, "our"
    unless $I1866, if_1863_end
.annotate 'line', 796
    find_lex $P1867, "$past"
    $P1867."pirflags"(":nsentry")
  if_1863_end:
.annotate 'line', 800
    find_lex $P1868, "$/"
    find_lex $P1869, "$past"
    $P1868."!make"($P1869)
.annotate 'line', 801
    find_lex $P1870, "$past"
    find_lex $P1871, "$past"
    unless_null $P1871, vivify_656
    $P1871 = root_new ['parrot';'Hash']
    store_lex "$past", $P1871
  vivify_656:
    set $P1871["block_past"], $P1870
.annotate 'line', 802
    find_lex $P1874, "$/"
    unless_null $P1874, vivify_657
    $P1874 = root_new ['parrot';'Hash']
  vivify_657:
    set $P1875, $P1874["trait"]
    unless_null $P1875, vivify_658
    new $P1875, "Undef"
  vivify_658:
    if $P1875, if_1873
    set $P1872, $P1875
    goto if_1873_end
  if_1873:
.annotate 'line', 803
    find_lex $P1877, "$/"
    unless_null $P1877, vivify_659
    $P1877 = root_new ['parrot';'Hash']
  vivify_659:
    set $P1878, $P1877["trait"]
    unless_null $P1878, vivify_660
    new $P1878, "Undef"
  vivify_660:
    defined $I1879, $P1878
    unless $I1879, for_undef_661
    iter $P1876, $P1878
    new $P1889, 'ExceptionHandler'
    set_label $P1889, loop1888_handler
    $P1889."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1889
  loop1888_test:
    unless $P1876, loop1888_done
    shift $P1880, $P1876
  loop1888_redo:
    .const 'Sub' $P1882 = "103_1300060192.103" 
    capture_lex $P1882
    $P1882($P1880)
  loop1888_next:
    goto loop1888_test
  loop1888_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1890, exception, 'type'
    eq $P1890, .CONTROL_LOOP_NEXT, loop1888_next
    eq $P1890, .CONTROL_LOOP_REDO, loop1888_redo
  loop1888_done:
    pop_eh 
  for_undef_661:
.annotate 'line', 802
    set $P1872, $P1876
  if_1873_end:
.annotate 'line', 735
    .return ($P1872)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1797"  :anon :subid("102_1300060192.103") :outer("101_1300060192.103")
.annotate 'line', 762
    new $P1799, "Undef"
    .lex "$name", $P1799
.annotate 'line', 767
    new $P1800, "Undef"
    .lex "$to_add", $P1800
.annotate 'line', 762
    find_lex $P1801, "$/"
    unless_null $P1801, vivify_637
    $P1801 = root_new ['parrot';'Hash']
  vivify_637:
    set $P1802, $P1801["private"]
    unless_null $P1802, vivify_638
    new $P1802, "Undef"
  vivify_638:
    set $S1803, $P1802
    new $P1804, 'String'
    set $P1804, $S1803
    find_lex $P1805, "$/"
    unless_null $P1805, vivify_639
    $P1805 = root_new ['parrot';'Hash']
  vivify_639:
    set $P1806, $P1805["deflongname"]
    unless_null $P1806, vivify_640
    $P1806 = root_new ['parrot';'ResizablePMCArray']
  vivify_640:
    set $P1807, $P1806[0]
    unless_null $P1807, vivify_641
    new $P1807, "Undef"
  vivify_641:
    $P1808 = $P1807."ast"()
    set $S1809, $P1808
    concat $P1810, $P1804, $S1809
    store_lex "$name", $P1810
.annotate 'line', 763
    find_lex $P1811, "$past"
    find_lex $P1812, "$name"
    $P1811."name"($P1812)
.annotate 'line', 767
    find_dynamic_lex $P1815, "$*MULTINESS"
    unless_null $P1815, vivify_642
    get_hll_global $P1815, "$MULTINESS"
    unless_null $P1815, vivify_643
    die "Contextual $*MULTINESS not found"
  vivify_643:
  vivify_642:
    set $S1816, $P1815
    isne $I1817, $S1816, "proto"
    if $I1817, if_1814
.annotate 'line', 769
    get_hll_global $P1821, ["PAST"], "Op"
.annotate 'line', 771
    get_hll_global $P1822, ["PAST"], "Val"
    find_lex $P1823, "$past"
    $P1824 = $P1822."new"($P1823 :named("value"))
.annotate 'line', 772
    get_hll_global $P1825, ["PAST"], "Op"
    $P1826 = $P1825."new"("list" :named("pasttype"))
    $P1827 = $P1821."new"($P1824, $P1826, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 769
    set $P1813, $P1827
.annotate 'line', 767
    goto if_1814_end
  if_1814:
.annotate 'line', 768
    get_hll_global $P1818, ["PAST"], "Val"
    find_lex $P1819, "$past"
    $P1820 = $P1818."new"($P1819 :named("value"))
    set $P1813, $P1820
  if_1814_end:
.annotate 'line', 767
    store_lex "$to_add", $P1813
.annotate 'line', 774
    find_dynamic_lex $P1829, "$*MULTINESS"
    unless_null $P1829, vivify_644
    get_hll_global $P1829, "$MULTINESS"
    unless_null $P1829, vivify_645
    die "Contextual $*MULTINESS not found"
  vivify_645:
  vivify_644:
    set $S1830, $P1829
    iseq $I1831, $S1830, "proto"
    unless $I1831, if_1828_end
    find_lex $P1832, "$past"
    $P1832."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1828_end:
.annotate 'line', 778
    find_dynamic_lex $P1834, "$*MULTINESS"
    unless_null $P1834, vivify_646
    get_hll_global $P1834, "$MULTINESS"
    unless_null $P1834, vivify_647
    die "Contextual $*MULTINESS not found"
  vivify_647:
  vivify_646:
    set $S1835, $P1834
    iseq $I1836, $S1835, "multi"
    unless $I1836, if_1833_end
    find_lex $P1837, "$past"
    "attach_multi_signature"($P1837)
  if_1833_end:
.annotate 'line', 781
    find_dynamic_lex $P1840, "$*PACKAGE-SETUP"
    unless_null $P1840, vivify_648
    get_hll_global $P1840, "$PACKAGE-SETUP"
    unless_null $P1840, vivify_649
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_649:
  vivify_648:
    defined $I1841, $P1840
    if $I1841, if_1839
    new $P1838, 'Integer'
    set $P1838, $I1841
    goto if_1839_end
  if_1839:
.annotate 'line', 782
    find_dynamic_lex $P1842, "$*PACKAGE-SETUP"
    unless_null $P1842, vivify_650
    get_hll_global $P1842, "$PACKAGE-SETUP"
    unless_null $P1842, vivify_651
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_651:
  vivify_650:
    get_hll_global $P1843, ["PAST"], "Op"
.annotate 'line', 783
    find_dynamic_lex $P1846, "$*MULTINESS"
    unless_null $P1846, vivify_652
    get_hll_global $P1846, "$MULTINESS"
    unless_null $P1846, vivify_653
    die "Contextual $*MULTINESS not found"
  vivify_653:
  vivify_652:
    set $S1847, $P1846
    iseq $I1848, $S1847, "multi"
    if $I1848, if_1845
    new $P1850, "String"
    assign $P1850, "add_method"
    set $P1844, $P1850
    goto if_1845_end
  if_1845:
    new $P1849, "String"
    assign $P1849, "add_multi_method"
    set $P1844, $P1849
  if_1845_end:
.annotate 'line', 784
    get_hll_global $P1851, ["PAST"], "Op"
.annotate 'line', 787
    get_hll_global $P1852, ["PAST"], "Var"
    $P1853 = $P1852."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1854 = $P1851."new"($P1853, "get_how PP" :named("pirop"))
.annotate 'line', 789
    get_hll_global $P1855, ["PAST"], "Var"
    $P1856 = $P1855."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 790
    get_hll_global $P1857, ["PAST"], "Val"
    find_lex $P1858, "$name"
    $P1859 = $P1857."new"($P1858 :named("value"))
    find_lex $P1860, "$to_add"
    $P1861 = $P1843."new"($P1854, $P1856, $P1859, $P1860, "callmethod" :named("pasttype"), $P1844 :named("name"))
.annotate 'line', 782
    $P1862 = $P1842."push"($P1861)
.annotate 'line', 781
    set $P1838, $P1862
  if_1839_end:
.annotate 'line', 760
    .return ($P1838)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1881"  :anon :subid("103_1300060192.103") :outer("101_1300060192.103")
    .param pmc param_1883
.annotate 'line', 803
    .lex "$_", param_1883
    find_lex $P1884, "$_"
    $P1885 = $P1884."ast"()
    find_lex $P1886, "$/"
    $P1887 = $P1885($P1886)
    .return ($P1887)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("104_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1894
    .param pmc param_1895
.annotate 'line', 835
    .const 'Sub' $P1928 = "106_1300060192.103" 
    capture_lex $P1928
    .const 'Sub' $P1904 = "105_1300060192.103" 
    capture_lex $P1904
    .lex "self", param_1894
    .lex "$/", param_1895
.annotate 'line', 836
    new $P1896, "Undef"
    .lex "$BLOCKINIT", $P1896
    get_global $P1897, "@BLOCK"
    unless_null $P1897, vivify_662
    $P1897 = root_new ['parrot';'ResizablePMCArray']
  vivify_662:
    set $P1898, $P1897[0]
    unless_null $P1898, vivify_663
    $P1898 = root_new ['parrot';'ResizablePMCArray']
  vivify_663:
    set $P1899, $P1898[0]
    unless_null $P1899, vivify_664
    new $P1899, "Undef"
  vivify_664:
    store_lex "$BLOCKINIT", $P1899
.annotate 'line', 837
    find_lex $P1901, "$/"
    unless_null $P1901, vivify_665
    $P1901 = root_new ['parrot';'Hash']
  vivify_665:
    set $P1902, $P1901["invocant"]
    unless_null $P1902, vivify_666
    new $P1902, "Undef"
  vivify_666:
    unless $P1902, if_1900_end
    .const 'Sub' $P1904 = "105_1300060192.103" 
    capture_lex $P1904
    $P1904()
  if_1900_end:
.annotate 'line', 846
    find_lex $P1923, "$/"
    unless_null $P1923, vivify_672
    $P1923 = root_new ['parrot';'Hash']
  vivify_672:
    set $P1924, $P1923["parameter"]
    unless_null $P1924, vivify_673
    new $P1924, "Undef"
  vivify_673:
    defined $I1925, $P1924
    unless $I1925, for_undef_674
    iter $P1922, $P1924
    new $P1935, 'ExceptionHandler'
    set_label $P1935, loop1934_handler
    $P1935."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1935
  loop1934_test:
    unless $P1922, loop1934_done
    shift $P1926, $P1922
  loop1934_redo:
    .const 'Sub' $P1928 = "106_1300060192.103" 
    capture_lex $P1928
    $P1928($P1926)
  loop1934_next:
    goto loop1934_test
  loop1934_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1936, exception, 'type'
    eq $P1936, .CONTROL_LOOP_NEXT, loop1934_next
    eq $P1936, .CONTROL_LOOP_REDO, loop1934_redo
  loop1934_done:
    pop_eh 
  for_undef_674:
.annotate 'line', 835
    .return ($P1922)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1903"  :anon :subid("105_1300060192.103") :outer("104_1300060192.103")
.annotate 'line', 838
    new $P1905, "Undef"
    .lex "$inv", $P1905
    find_lex $P1906, "$/"
    unless_null $P1906, vivify_667
    $P1906 = root_new ['parrot';'Hash']
  vivify_667:
    set $P1907, $P1906["invocant"]
    unless_null $P1907, vivify_668
    $P1907 = root_new ['parrot';'ResizablePMCArray']
  vivify_668:
    set $P1908, $P1907[0]
    unless_null $P1908, vivify_669
    new $P1908, "Undef"
  vivify_669:
    $P1909 = $P1908."ast"()
    store_lex "$inv", $P1909
.annotate 'line', 839
    find_lex $P1910, "$BLOCKINIT"
    find_lex $P1911, "$inv"
    $P1910."push"($P1911)
.annotate 'line', 840
    find_lex $P1912, "$BLOCKINIT"
    get_hll_global $P1913, ["PAST"], "Var"
.annotate 'line', 842
    get_hll_global $P1914, ["PAST"], "Var"
    find_lex $P1915, "$inv"
    $P1916 = $P1915."name"()
    $P1917 = $P1914."new"("lexical" :named("scope"), $P1916 :named("name"))
    $P1918 = $P1913."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1917 :named("viviself"))
.annotate 'line', 840
    $P1912."push"($P1918)
.annotate 'line', 844
    new $P1919, "Integer"
    assign $P1919, 1
    get_global $P1920, "@BLOCK"
    unless_null $P1920, vivify_670
    $P1920 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1920
  vivify_670:
    set $P1921, $P1920[0]
    unless_null $P1921, vivify_671
    $P1921 = root_new ['parrot';'Hash']
    set $P1920[0], $P1921
  vivify_671:
    set $P1921["signature_has_invocant"], $P1919
.annotate 'line', 837
    .return ($P1919)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1927"  :anon :subid("106_1300060192.103") :outer("104_1300060192.103")
    .param pmc param_1929
.annotate 'line', 846
    .lex "$_", param_1929
    find_lex $P1930, "$BLOCKINIT"
    find_lex $P1931, "$_"
    $P1932 = $P1931."ast"()
    $P1933 = $P1930."push"($P1932)
    .return ($P1933)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("107_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_1938
    .param pmc param_1939
.annotate 'line', 849
    .lex "self", param_1938
    .lex "$/", param_1939
.annotate 'line', 850
    new $P1940, "Undef"
    .lex "$quant", $P1940
.annotate 'line', 851
    new $P1941, "Undef"
    .lex "$past", $P1941
.annotate 'line', 850
    find_lex $P1942, "$/"
    unless_null $P1942, vivify_675
    $P1942 = root_new ['parrot';'Hash']
  vivify_675:
    set $P1943, $P1942["quant"]
    unless_null $P1943, vivify_676
    new $P1943, "Undef"
  vivify_676:
    store_lex "$quant", $P1943
    find_lex $P1944, "$past"
.annotate 'line', 852
    find_lex $P1946, "$/"
    unless_null $P1946, vivify_677
    $P1946 = root_new ['parrot';'Hash']
  vivify_677:
    set $P1947, $P1946["named_param"]
    unless_null $P1947, vivify_678
    new $P1947, "Undef"
  vivify_678:
    if $P1947, if_1945
.annotate 'line', 859
    find_lex $P1961, "$/"
    unless_null $P1961, vivify_679
    $P1961 = root_new ['parrot';'Hash']
  vivify_679:
    set $P1962, $P1961["param_var"]
    unless_null $P1962, vivify_680
    new $P1962, "Undef"
  vivify_680:
    $P1963 = $P1962."ast"()
    store_lex "$past", $P1963
.annotate 'line', 860
    find_lex $P1965, "$quant"
    set $S1966, $P1965
    iseq $I1967, $S1966, "*"
    if $I1967, if_1964
.annotate 'line', 864
    find_lex $P1976, "$quant"
    set $S1977, $P1976
    iseq $I1978, $S1977, "?"
    unless $I1978, if_1975_end
.annotate 'line', 865
    find_lex $P1979, "$past"
    find_lex $P1980, "$/"
    unless_null $P1980, vivify_681
    $P1980 = root_new ['parrot';'Hash']
  vivify_681:
    set $P1981, $P1980["param_var"]
    unless_null $P1981, vivify_682
    $P1981 = root_new ['parrot';'Hash']
  vivify_682:
    set $P1982, $P1981["sigil"]
    unless_null $P1982, vivify_683
    new $P1982, "Undef"
  vivify_683:
    $P1983 = "vivitype"($P1982)
    $P1979."viviself"($P1983)
  if_1975_end:
.annotate 'line', 864
    goto if_1964_end
  if_1964:
.annotate 'line', 861
    find_lex $P1968, "$past"
    $P1968."slurpy"(1)
.annotate 'line', 862
    find_lex $P1969, "$past"
    find_lex $P1970, "$/"
    unless_null $P1970, vivify_684
    $P1970 = root_new ['parrot';'Hash']
  vivify_684:
    set $P1971, $P1970["param_var"]
    unless_null $P1971, vivify_685
    $P1971 = root_new ['parrot';'Hash']
  vivify_685:
    set $P1972, $P1971["sigil"]
    unless_null $P1972, vivify_686
    new $P1972, "Undef"
  vivify_686:
    set $S1973, $P1972
    iseq $I1974, $S1973, "%"
    $P1969."named"($I1974)
  if_1964_end:
.annotate 'line', 858
    goto if_1945_end
  if_1945:
.annotate 'line', 853
    find_lex $P1948, "$/"
    unless_null $P1948, vivify_687
    $P1948 = root_new ['parrot';'Hash']
  vivify_687:
    set $P1949, $P1948["named_param"]
    unless_null $P1949, vivify_688
    new $P1949, "Undef"
  vivify_688:
    $P1950 = $P1949."ast"()
    store_lex "$past", $P1950
.annotate 'line', 854
    find_lex $P1952, "$quant"
    set $S1953, $P1952
    isne $I1954, $S1953, "!"
    unless $I1954, if_1951_end
.annotate 'line', 855
    find_lex $P1955, "$past"
    find_lex $P1956, "$/"
    unless_null $P1956, vivify_689
    $P1956 = root_new ['parrot';'Hash']
  vivify_689:
    set $P1957, $P1956["named_param"]
    unless_null $P1957, vivify_690
    $P1957 = root_new ['parrot';'Hash']
  vivify_690:
    set $P1958, $P1957["param_var"]
    unless_null $P1958, vivify_691
    $P1958 = root_new ['parrot';'Hash']
  vivify_691:
    set $P1959, $P1958["sigil"]
    unless_null $P1959, vivify_692
    new $P1959, "Undef"
  vivify_692:
    $P1960 = "vivitype"($P1959)
    $P1955."viviself"($P1960)
  if_1951_end:
  if_1945_end:
.annotate 'line', 868
    find_lex $P1985, "$/"
    unless_null $P1985, vivify_693
    $P1985 = root_new ['parrot';'Hash']
  vivify_693:
    set $P1986, $P1985["default_value"]
    unless_null $P1986, vivify_694
    new $P1986, "Undef"
  vivify_694:
    unless $P1986, if_1984_end
.annotate 'line', 869
    find_lex $P1988, "$quant"
    set $S1989, $P1988
    iseq $I1990, $S1989, "*"
    unless $I1990, if_1987_end
.annotate 'line', 870
    find_lex $P1991, "$/"
    $P1992 = $P1991."CURSOR"()
    $P1992."panic"("Can't put default on slurpy parameter")
  if_1987_end:
.annotate 'line', 872
    find_lex $P1994, "$quant"
    set $S1995, $P1994
    iseq $I1996, $S1995, "!"
    unless $I1996, if_1993_end
.annotate 'line', 873
    find_lex $P1997, "$/"
    $P1998 = $P1997."CURSOR"()
    $P1998."panic"("Can't put default on required parameter")
  if_1993_end:
.annotate 'line', 875
    find_lex $P1999, "$past"
    find_lex $P2000, "$/"
    unless_null $P2000, vivify_695
    $P2000 = root_new ['parrot';'Hash']
  vivify_695:
    set $P2001, $P2000["default_value"]
    unless_null $P2001, vivify_696
    $P2001 = root_new ['parrot';'ResizablePMCArray']
  vivify_696:
    set $P2002, $P2001[0]
    unless_null $P2002, vivify_697
    $P2002 = root_new ['parrot';'Hash']
  vivify_697:
    set $P2003, $P2002["EXPR"]
    unless_null $P2003, vivify_698
    new $P2003, "Undef"
  vivify_698:
    $P2004 = $P2003."ast"()
    $P1999."viviself"($P2004)
  if_1984_end:
.annotate 'line', 877
    find_lex $P2006, "$past"
    $P2007 = $P2006."viviself"()
    if $P2007, unless_2005_end
    get_global $P2008, "@BLOCK"
    unless_null $P2008, vivify_699
    $P2008 = root_new ['parrot';'ResizablePMCArray']
  vivify_699:
    set $P2009, $P2008[0]
    unless_null $P2009, vivify_700
    new $P2009, "Undef"
  vivify_700:
    get_global $P2010, "@BLOCK"
    unless_null $P2010, vivify_701
    $P2010 = root_new ['parrot';'ResizablePMCArray']
  vivify_701:
    set $P2011, $P2010[0]
    unless_null $P2011, vivify_702
    new $P2011, "Undef"
  vivify_702:
    $P2012 = $P2011."arity"()
    set $N2013, $P2012
    new $P2014, 'Float'
    set $P2014, $N2013
    add $P2015, $P2014, 1
    $P2009."arity"($P2015)
  unless_2005_end:
.annotate 'line', 881
    find_lex $P2017, "$/"
    unless_null $P2017, vivify_703
    $P2017 = root_new ['parrot';'Hash']
  vivify_703:
    set $P2018, $P2017["typename"]
    unless_null $P2018, vivify_704
    new $P2018, "Undef"
  vivify_704:
    unless $P2018, if_2016_end
.annotate 'line', 882
    find_lex $P2019, "$past"
    find_lex $P2020, "$/"
    unless_null $P2020, vivify_705
    $P2020 = root_new ['parrot';'Hash']
  vivify_705:
    set $P2021, $P2020["typename"]
    unless_null $P2021, vivify_706
    $P2021 = root_new ['parrot';'ResizablePMCArray']
  vivify_706:
    set $P2022, $P2021[0]
    unless_null $P2022, vivify_707
    new $P2022, "Undef"
  vivify_707:
    $P2023 = $P2022."ast"()
    $P2019."multitype"($P2023)
  if_2016_end:
.annotate 'line', 886
    find_lex $P2025, "$/"
    unless_null $P2025, vivify_708
    $P2025 = root_new ['parrot';'Hash']
  vivify_708:
    set $P2026, $P2025["definedness"]
    unless_null $P2026, vivify_709
    new $P2026, "Undef"
  vivify_709:
    unless $P2026, if_2024_end
.annotate 'line', 887
    find_lex $P2027, "$/"
    unless_null $P2027, vivify_710
    $P2027 = root_new ['parrot';'Hash']
  vivify_710:
    set $P2028, $P2027["definedness"]
    unless_null $P2028, vivify_711
    $P2028 = root_new ['parrot';'ResizablePMCArray']
  vivify_711:
    set $P2029, $P2028[0]
    unless_null $P2029, vivify_712
    new $P2029, "Undef"
  vivify_712:
    set $S2030, $P2029
    new $P2031, 'String'
    set $P2031, $S2030
    find_lex $P2032, "$past"
    unless_null $P2032, vivify_713
    $P2032 = root_new ['parrot';'Hash']
    store_lex "$past", $P2032
  vivify_713:
    set $P2032["definedness"], $P2031
  if_2024_end:
.annotate 'line', 890
    find_lex $P2033, "$/"
    find_lex $P2034, "$past"
    $P2035 = $P2033."!make"($P2034)
.annotate 'line', 849
    .return ($P2035)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("108_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2037
    .param pmc param_2038
.annotate 'line', 893
    .lex "self", param_2037
    .lex "$/", param_2038
.annotate 'line', 894
    new $P2039, "Undef"
    .lex "$name", $P2039
.annotate 'line', 895
    new $P2040, "Undef"
    .lex "$past", $P2040
.annotate 'line', 894
    find_lex $P2041, "$/"
    set $S2042, $P2041
    new $P2043, 'String'
    set $P2043, $S2042
    store_lex "$name", $P2043
.annotate 'line', 895
    get_hll_global $P2044, ["PAST"], "Var"
    find_lex $P2045, "$name"
    find_lex $P2046, "$/"
    $P2047 = $P2044."new"($P2045 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P2046 :named("node"))
    store_lex "$past", $P2047
.annotate 'line', 897
    get_global $P2048, "@BLOCK"
    unless_null $P2048, vivify_714
    $P2048 = root_new ['parrot';'ResizablePMCArray']
  vivify_714:
    set $P2049, $P2048[0]
    unless_null $P2049, vivify_715
    new $P2049, "Undef"
  vivify_715:
    find_lex $P2050, "$name"
    $P2049."symbol"($P2050, "lexical" :named("scope"))
.annotate 'line', 898
    find_lex $P2051, "$/"
    find_lex $P2052, "$past"
    $P2053 = $P2051."!make"($P2052)
.annotate 'line', 893
    .return ($P2053)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("109_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2055
    .param pmc param_2056
.annotate 'line', 901
    .lex "self", param_2055
    .lex "$/", param_2056
.annotate 'line', 902
    new $P2057, "Undef"
    .lex "$past", $P2057
    find_lex $P2058, "$/"
    unless_null $P2058, vivify_716
    $P2058 = root_new ['parrot';'Hash']
  vivify_716:
    set $P2059, $P2058["param_var"]
    unless_null $P2059, vivify_717
    new $P2059, "Undef"
  vivify_717:
    $P2060 = $P2059."ast"()
    store_lex "$past", $P2060
.annotate 'line', 903
    find_lex $P2061, "$past"
    find_lex $P2062, "$/"
    unless_null $P2062, vivify_718
    $P2062 = root_new ['parrot';'Hash']
  vivify_718:
    set $P2063, $P2062["param_var"]
    unless_null $P2063, vivify_719
    $P2063 = root_new ['parrot';'Hash']
  vivify_719:
    set $P2064, $P2063["name"]
    unless_null $P2064, vivify_720
    new $P2064, "Undef"
  vivify_720:
    set $S2065, $P2064
    $P2061."named"($S2065)
.annotate 'line', 904
    find_lex $P2066, "$/"
    find_lex $P2067, "$past"
    $P2068 = $P2066."!make"($P2067)
.annotate 'line', 901
    .return ($P2068)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("110_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2070
    .param pmc param_2071
.annotate 'line', 907
    .lex "self", param_2070
    .lex "$/", param_2071
.annotate 'line', 908
    $P2072 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P2072
    get_hll_global $P2073, ["HLL"], "Compiler"
    find_lex $P2074, "$/"
    set $S2075, $P2074
    $P2076 = $P2073."parse_name"($S2075)
    store_lex "@name", $P2076
.annotate 'line', 909
    find_lex $P2077, "$/"
    get_hll_global $P2078, ["PAST"], "Var"
.annotate 'line', 910
    find_lex $P2079, "@name"
    $P2080 = $P2079."pop"()
    find_lex $P2081, "@name"
    $P2082 = $P2078."new"($P2080 :named("name"), $P2081 :named("namespace"), "package" :named("scope"))
.annotate 'line', 909
    $P2083 = $P2077."!make"($P2082)
.annotate 'line', 907
    .return ($P2083)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("111_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2085
    .param pmc param_2086
.annotate 'line', 916
    .lex "self", param_2085
    .lex "$/", param_2086
.annotate 'line', 917
    find_lex $P2087, "$/"
    find_lex $P2088, "$/"
    unless_null $P2088, vivify_721
    $P2088 = root_new ['parrot';'Hash']
  vivify_721:
    set $P2089, $P2088["trait_mod"]
    unless_null $P2089, vivify_722
    new $P2089, "Undef"
  vivify_722:
    $P2090 = $P2089."ast"()
    $P2091 = $P2087."!make"($P2090)
.annotate 'line', 916
    .return ($P2091)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("112_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2093
    .param pmc param_2094
.annotate 'line', 920
    .const 'Sub' $P2114 = "113_1300060192.103" 
    capture_lex $P2114
    .lex "self", param_2093
    .lex "$/", param_2094
.annotate 'line', 921
    new $P2095, "Undef"
    .lex "$cpast", $P2095
    find_lex $P2096, "$/"
    unless_null $P2096, vivify_723
    $P2096 = root_new ['parrot';'Hash']
  vivify_723:
    set $P2097, $P2096["circumfix"]
    unless_null $P2097, vivify_724
    $P2097 = root_new ['parrot';'ResizablePMCArray']
  vivify_724:
    set $P2098, $P2097[0]
    unless_null $P2098, vivify_725
    new $P2098, "Undef"
  vivify_725:
    $P2099 = $P2098."ast"()
    store_lex "$cpast", $P2099
.annotate 'line', 922
    find_lex $P2102, "$/"
    unless_null $P2102, vivify_726
    $P2102 = root_new ['parrot';'Hash']
  vivify_726:
    set $P2103, $P2102["longname"]
    unless_null $P2103, vivify_727
    new $P2103, "Undef"
  vivify_727:
    set $S2104, $P2103
    iseq $I2105, $S2104, "parrot_vtable"
    if $I2105, if_2101
.annotate 'line', 942
    find_lex $P2140, "$/"
    unless_null $P2140, vivify_728
    $P2140 = root_new ['parrot';'Hash']
  vivify_728:
    set $P2141, $P2140["longname"]
    unless_null $P2141, vivify_729
    new $P2141, "Undef"
  vivify_729:
    set $S2142, $P2141
    iseq $I2143, $S2142, "pirflags"
    if $I2143, if_2139
.annotate 'line', 946
    find_lex $P2147, "$/"
    $P2148 = $P2147."CURSOR"()
    new $P2149, 'String'
    set $P2149, "Trait '"
    find_lex $P2150, "$/"
    unless_null $P2150, vivify_730
    $P2150 = root_new ['parrot';'Hash']
  vivify_730:
    set $P2151, $P2150["longname"]
    unless_null $P2151, vivify_731
    new $P2151, "Undef"
  vivify_731:
    concat $P2152, $P2149, $P2151
    concat $P2153, $P2152, "' not implemented"
    $P2154 = $P2148."panic"($P2153)
.annotate 'line', 945
    set $P2138, $P2154
.annotate 'line', 942
    goto if_2139_end
  if_2139:
.annotate 'line', 943
    find_lex $P2144, "$/"
    $P2145 = $P2144."CURSOR"()
    $P2146 = $P2145."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 942
    set $P2138, $P2146
  if_2139_end:
    set $P2100, $P2138
.annotate 'line', 922
    goto if_2101_end
  if_2101:
.annotate 'line', 925
    get_hll_global $P2107, ["PAST"], "Val"
    find_lex $P2108, "$cpast"
    $P2109 = $P2107."ACCEPTS"($P2108)
    if $P2109, unless_2106_end
.annotate 'line', 924
    find_lex $P2110, "$/"
    $P2111 = $P2110."CURSOR"()
    $P2111."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_2106_end:
.annotate 'line', 926
    find_lex $P2112, "$/"
    .const 'Sub' $P2114 = "113_1300060192.103" 
    newclosure $P2136, $P2114
    $P2137 = $P2112."!make"($P2136)
.annotate 'line', 922
    set $P2100, $P2137
  if_2101_end:
.annotate 'line', 920
    .return ($P2100)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2113"  :anon :subid("113_1300060192.103") :outer("112_1300060192.103")
    .param pmc param_2115
.annotate 'line', 926
    .lex "$match", param_2115
.annotate 'line', 927
    new $P2116, "Undef"
    .lex "$meth", $P2116
    find_lex $P2117, "$match"
    $P2118 = $P2117."ast"()
    set $P2119, $P2118["block_past"]
    unless_null $P2119, vivify_732
    new $P2119, "Undef"
  vivify_732:
    store_lex "$meth", $P2119
.annotate 'line', 928
    find_dynamic_lex $P2122, "$*PACKAGE-SETUP"
    unless_null $P2122, vivify_733
    get_hll_global $P2122, "$PACKAGE-SETUP"
    unless_null $P2122, vivify_734
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_734:
  vivify_733:
    defined $I2123, $P2122
    if $I2123, if_2121
    new $P2120, 'Integer'
    set $P2120, $I2123
    goto if_2121_end
  if_2121:
.annotate 'line', 929
    find_dynamic_lex $P2124, "$*PACKAGE-SETUP"
    unless_null $P2124, vivify_735
    get_hll_global $P2124, "$PACKAGE-SETUP"
    unless_null $P2124, vivify_736
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_736:
  vivify_735:
    get_hll_global $P2125, ["PAST"], "Op"
.annotate 'line', 931
    get_hll_global $P2126, ["PAST"], "Op"
.annotate 'line', 934
    get_hll_global $P2127, ["PAST"], "Var"
    $P2128 = $P2127."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2129 = $P2126."new"($P2128, "get_how PP" :named("pirop"))
.annotate 'line', 936
    get_hll_global $P2130, ["PAST"], "Var"
    $P2131 = $P2130."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P2132, "$cpast"
    find_lex $P2133, "$meth"
    $P2134 = $P2125."new"($P2129, $P2131, $P2132, $P2133, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 929
    $P2135 = $P2124."push"($P2134)
.annotate 'line', 928
    set $P2120, $P2135
  if_2121_end:
.annotate 'line', 926
    .return ($P2120)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("114_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2158
    .param pmc param_2159
    .param pmc param_2160 :optional
    .param int has_param_2160 :opt_flag
.annotate 'line', 950
    .const 'Sub' $P2258 = "117_1300060192.103" 
    capture_lex $P2258
    .const 'Sub' $P2230 = "116_1300060192.103" 
    capture_lex $P2230
    .const 'Sub' $P2203 = "115_1300060192.103" 
    capture_lex $P2203
    new $P2157, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2157, control_2156
    push_eh $P2157
    .lex "self", param_2158
    .lex "$/", param_2159
    if has_param_2160, optparam_737
    new $P2161, "Undef"
    set param_2160, $P2161
  optparam_737:
    .lex "$key", param_2160
.annotate 'line', 951
    $P2162 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2162
.annotate 'line', 954
    new $P2163, "Undef"
    .lex "$name", $P2163
.annotate 'line', 955
    new $P2164, "Undef"
    .lex "$past", $P2164
.annotate 'line', 951

            $P2165 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
        
    store_lex "@MODIFIERS", $P2165
.annotate 'line', 954
    find_lex $P2166, "$/"
    unless_null $P2166, vivify_738
    $P2166 = root_new ['parrot';'Hash']
  vivify_738:
    set $P2167, $P2166["deflongname"]
    unless_null $P2167, vivify_739
    new $P2167, "Undef"
  vivify_739:
    $P2168 = $P2167."ast"()
    set $S2169, $P2168
    new $P2170, 'String'
    set $P2170, $S2169
    store_lex "$name", $P2170
    find_lex $P2171, "$past"
.annotate 'line', 956
    find_lex $P2173, "$/"
    unless_null $P2173, vivify_740
    $P2173 = root_new ['parrot';'Hash']
  vivify_740:
    set $P2174, $P2173["proto"]
    unless_null $P2174, vivify_741
    new $P2174, "Undef"
  vivify_741:
    if $P2174, if_2172
.annotate 'line', 995
    find_lex $P2226, "$key"
    set $S2227, $P2226
    iseq $I2228, $S2227, "open"
    if $I2228, if_2225
.annotate 'line', 1008
    .const 'Sub' $P2258 = "117_1300060192.103" 
    capture_lex $P2258
    $P2258()
    goto if_2225_end
  if_2225:
.annotate 'line', 995
    .const 'Sub' $P2230 = "116_1300060192.103" 
    capture_lex $P2230
    $P2230()
  if_2225_end:
    goto if_2172_end
  if_2172:
.annotate 'line', 958
    get_hll_global $P2175, ["PAST"], "Stmts"
.annotate 'line', 959
    get_hll_global $P2176, ["PAST"], "Block"
    find_lex $P2177, "$name"
.annotate 'line', 960
    get_hll_global $P2178, ["PAST"], "Op"
.annotate 'line', 961
    get_hll_global $P2179, ["PAST"], "Var"
    $P2180 = $P2179."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2181, "$name"
    $P2182 = $P2178."new"($P2180, $P2181, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 960
    find_lex $P2183, "$/"
    $P2184 = $P2176."new"($P2182, $P2177 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2183 :named("node"))
.annotate 'line', 970
    get_hll_global $P2185, ["PAST"], "Block"
    new $P2186, "String"
    assign $P2186, "!PREFIX__"
    find_lex $P2187, "$name"
    concat $P2188, $P2186, $P2187
.annotate 'line', 971
    get_hll_global $P2189, ["PAST"], "Op"
.annotate 'line', 972
    get_hll_global $P2190, ["PAST"], "Var"
    $P2191 = $P2190."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2192, "$name"
    $P2193 = $P2189."new"($P2191, $P2192, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 971
    find_lex $P2194, "$/"
    $P2195 = $P2185."new"($P2193, $P2188 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2194 :named("node"))
.annotate 'line', 970
    $P2196 = $P2175."new"($P2184, $P2195)
.annotate 'line', 958
    store_lex "$past", $P2196
.annotate 'line', 982
    find_lex $P2198, "$past"
    $P2199 = $P2198."list"()
    defined $I2200, $P2199
    unless $I2200, for_undef_762
    iter $P2197, $P2199
    new $P2223, 'ExceptionHandler'
    set_label $P2223, loop2222_handler
    $P2223."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2223
  loop2222_test:
    unless $P2197, loop2222_done
    shift $P2201, $P2197
  loop2222_redo:
    .const 'Sub' $P2203 = "115_1300060192.103" 
    capture_lex $P2203
    $P2203($P2201)
  loop2222_next:
    goto loop2222_test
  loop2222_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2224, exception, 'type'
    eq $P2224, .CONTROL_LOOP_NEXT, loop2222_next
    eq $P2224, .CONTROL_LOOP_REDO, loop2222_redo
  loop2222_done:
    pop_eh 
  for_undef_762:
  if_2172_end:
.annotate 'line', 1044
    find_lex $P2316, "$/"
    find_lex $P2317, "$past"
    $P2318 = $P2316."!make"($P2317)
.annotate 'line', 950
    .return ($P2318)
  control_2156:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2319, exception, "payload"
    .return ($P2319)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2257"  :anon :subid("117_1300060192.103") :outer("114_1300060192.103")
.annotate 'line', 1009
    new $P2259, "Undef"
    .lex "$regex", $P2259
.annotate 'line', 1010
    get_hll_global $P2260, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2261, "$/"
    unless_null $P2261, vivify_742
    $P2261 = root_new ['parrot';'Hash']
  vivify_742:
    set $P2262, $P2261["p6regex"]
    unless_null $P2262, vivify_743
    new $P2262, "Undef"
  vivify_743:
    $P2263 = $P2262."ast"()
    get_global $P2264, "@BLOCK"
    $P2265 = $P2264."shift"()
    $P2266 = $P2260($P2263, $P2265)
    store_lex "$regex", $P2266
.annotate 'line', 1011
    find_lex $P2267, "$regex"
    find_lex $P2268, "$name"
    $P2267."name"($P2268)
.annotate 'line', 1013
    get_hll_global $P2269, ["PAST"], "Op"
.annotate 'line', 1015
    get_hll_global $P2270, ["PAST"], "Var"
    new $P2271, "ResizablePMCArray"
    push $P2271, "Regex"
    $P2272 = $P2270."new"("Method" :named("name"), $P2271 :named("namespace"), "package" :named("scope"))
    find_lex $P2273, "$regex"
    $P2274 = $P2269."new"($P2272, $P2273, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1013
    store_lex "$past", $P2274
.annotate 'line', 1018
    find_dynamic_lex $P2276, "$*PACKAGE-SETUP"
    unless_null $P2276, vivify_744
    get_hll_global $P2276, "$PACKAGE-SETUP"
    unless_null $P2276, vivify_745
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_745:
  vivify_744:
    defined $I2277, $P2276
    unless $I2277, if_2275_end
.annotate 'line', 1019
    find_dynamic_lex $P2278, "$*PACKAGE-SETUP"
    unless_null $P2278, vivify_746
    get_hll_global $P2278, "$PACKAGE-SETUP"
    unless_null $P2278, vivify_747
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_747:
  vivify_746:
    get_hll_global $P2279, ["PAST"], "Op"
.annotate 'line', 1021
    get_hll_global $P2280, ["PAST"], "Op"
.annotate 'line', 1023
    get_hll_global $P2281, ["PAST"], "Var"
    $P2282 = $P2281."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2283 = $P2280."new"($P2282, "get_how PP" :named("pirop"))
.annotate 'line', 1025
    get_hll_global $P2284, ["PAST"], "Var"
    $P2285 = $P2284."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1026
    get_hll_global $P2286, ["PAST"], "Val"
    find_lex $P2287, "$name"
    $P2288 = $P2286."new"($P2287 :named("value"))
.annotate 'line', 1027
    get_hll_global $P2289, ["PAST"], "Val"
    find_lex $P2290, "$regex"
    $P2291 = $P2289."new"($P2290 :named("value"))
    $P2292 = $P2279."new"($P2283, $P2285, $P2288, $P2291, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1019
    $P2278."push"($P2292)
.annotate 'line', 1029
    find_dynamic_lex $P2293, "$*PACKAGE-SETUP"
    unless_null $P2293, vivify_748
    get_hll_global $P2293, "$PACKAGE-SETUP"
    unless_null $P2293, vivify_749
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_749:
  vivify_748:
    get_hll_global $P2294, ["PAST"], "Op"
.annotate 'line', 1031
    get_hll_global $P2295, ["PAST"], "Op"
.annotate 'line', 1033
    get_hll_global $P2296, ["PAST"], "Var"
    $P2297 = $P2296."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2298 = $P2295."new"($P2297, "get_how PP" :named("pirop"))
.annotate 'line', 1035
    get_hll_global $P2299, ["PAST"], "Var"
    $P2300 = $P2299."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1036
    get_hll_global $P2301, ["PAST"], "Val"
    new $P2302, "String"
    assign $P2302, "!PREFIX__"
    find_lex $P2303, "$name"
    concat $P2304, $P2302, $P2303
    $P2305 = $P2301."new"($P2304 :named("value"))
.annotate 'line', 1037
    get_hll_global $P2306, ["PAST"], "Var"
    new $P2307, "String"
    assign $P2307, "!PREFIX__"
    find_lex $P2308, "$name"
    concat $P2309, $P2307, $P2308
    $P2310 = $P2306."new"($P2309 :named("name"), "package" :named("scope"))
    $P2311 = $P2294."new"($P2298, $P2300, $P2305, $P2310, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1029
    $P2293."push"($P2311)
  if_2275_end:
.annotate 'line', 1041
    find_lex $P2312, "$regex"
    find_lex $P2313, "$past"
    unless_null $P2313, vivify_750
    $P2313 = root_new ['parrot';'Hash']
    store_lex "$past", $P2313
  vivify_750:
    set $P2313["sink"], $P2312
.annotate 'line', 1042
    find_lex $P2314, "@MODIFIERS"
    $P2315 = $P2314."shift"()
.annotate 'line', 1008
    .return ($P2315)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2229"  :anon :subid("116_1300060192.103") :outer("114_1300060192.103")
.annotate 'line', 996
    $P2231 = root_new ['parrot';'Hash']
    .lex "%h", $P2231
.annotate 'line', 995
    find_lex $P2232, "%h"
.annotate 'line', 997
    find_lex $P2234, "$/"
    unless_null $P2234, vivify_751
    $P2234 = root_new ['parrot';'Hash']
  vivify_751:
    set $P2235, $P2234["sym"]
    unless_null $P2235, vivify_752
    new $P2235, "Undef"
  vivify_752:
    set $S2236, $P2235
    iseq $I2237, $S2236, "token"
    unless $I2237, if_2233_end
    new $P2238, "Integer"
    assign $P2238, 1
    find_lex $P2239, "%h"
    unless_null $P2239, vivify_753
    $P2239 = root_new ['parrot';'Hash']
    store_lex "%h", $P2239
  vivify_753:
    set $P2239["r"], $P2238
  if_2233_end:
.annotate 'line', 998
    find_lex $P2241, "$/"
    unless_null $P2241, vivify_754
    $P2241 = root_new ['parrot';'Hash']
  vivify_754:
    set $P2242, $P2241["sym"]
    unless_null $P2242, vivify_755
    new $P2242, "Undef"
  vivify_755:
    set $S2243, $P2242
    iseq $I2244, $S2243, "rule"
    unless $I2244, if_2240_end
    new $P2245, "Integer"
    assign $P2245, 1
    find_lex $P2246, "%h"
    unless_null $P2246, vivify_756
    $P2246 = root_new ['parrot';'Hash']
    store_lex "%h", $P2246
  vivify_756:
    set $P2246["r"], $P2245
    new $P2247, "Integer"
    assign $P2247, 1
    find_lex $P2248, "%h"
    unless_null $P2248, vivify_757
    $P2248 = root_new ['parrot';'Hash']
    store_lex "%h", $P2248
  vivify_757:
    set $P2248["s"], $P2247
  if_2240_end:
.annotate 'line', 999
    find_lex $P2249, "@MODIFIERS"
    find_lex $P2250, "%h"
    $P2249."unshift"($P2250)
.annotate 'line', 1000

                $P0 = find_lex '$name'
                set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
            
.annotate 'line', 1004
    get_global $P2251, "@BLOCK"
    unless_null $P2251, vivify_758
    $P2251 = root_new ['parrot';'ResizablePMCArray']
  vivify_758:
    set $P2252, $P2251[0]
    unless_null $P2252, vivify_759
    new $P2252, "Undef"
  vivify_759:
    $P2252."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1005
    get_global $P2253, "@BLOCK"
    unless_null $P2253, vivify_760
    $P2253 = root_new ['parrot';'ResizablePMCArray']
  vivify_760:
    set $P2254, $P2253[0]
    unless_null $P2254, vivify_761
    new $P2254, "Undef"
  vivify_761:
    $P2254."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1006
    new $P2255, "Exception"
    set $P2255['type'], .CONTROL_RETURN
    new $P2256, "Integer"
    assign $P2256, 0
    setattribute $P2255, 'payload', $P2256
    throw $P2255
.annotate 'line', 995
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2202"  :anon :subid("115_1300060192.103") :outer("114_1300060192.103")
    .param pmc param_2204
.annotate 'line', 982
    .lex "$_", param_2204
.annotate 'line', 983
    find_dynamic_lex $P2205, "$*PACKAGE-SETUP"
    unless_null $P2205, vivify_763
    get_hll_global $P2205, "$PACKAGE-SETUP"
    unless_null $P2205, vivify_764
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_764:
  vivify_763:
    get_hll_global $P2206, ["PAST"], "Op"
.annotate 'line', 985
    get_hll_global $P2207, ["PAST"], "Op"
.annotate 'line', 987
    get_hll_global $P2208, ["PAST"], "Var"
    $P2209 = $P2208."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2210 = $P2207."new"($P2209, "get_how PP" :named("pirop"))
.annotate 'line', 989
    get_hll_global $P2211, ["PAST"], "Var"
    $P2212 = $P2211."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 990
    get_hll_global $P2213, ["PAST"], "Val"
    find_lex $P2214, "$_"
    $P2215 = $P2214."name"()
    $P2216 = $P2213."new"($P2215 :named("value"))
.annotate 'line', 991
    get_hll_global $P2217, ["PAST"], "Val"
    find_lex $P2218, "$_"
    $P2219 = $P2217."new"($P2218 :named("value"))
    $P2220 = $P2206."new"($P2210, $P2212, $P2216, $P2219, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 983
    $P2221 = $P2205."push"($P2220)
.annotate 'line', 982
    .return ($P2221)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("118_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2321
    .param pmc param_2322
.annotate 'line', 1048
    .lex "self", param_2321
    .lex "$/", param_2322
.annotate 'line', 1049
    new $P2323, "Undef"
    .lex "$past", $P2323
    find_lex $P2326, "$/"
    unless_null $P2326, vivify_765
    $P2326 = root_new ['parrot';'Hash']
  vivify_765:
    set $P2327, $P2326["args"]
    unless_null $P2327, vivify_766
    new $P2327, "Undef"
  vivify_766:
    if $P2327, if_2325
    get_hll_global $P2332, ["PAST"], "Op"
    find_lex $P2333, "$/"
    $P2334 = $P2332."new"($P2333 :named("node"))
    set $P2324, $P2334
    goto if_2325_end
  if_2325:
    find_lex $P2328, "$/"
    unless_null $P2328, vivify_767
    $P2328 = root_new ['parrot';'Hash']
  vivify_767:
    set $P2329, $P2328["args"]
    unless_null $P2329, vivify_768
    $P2329 = root_new ['parrot';'ResizablePMCArray']
  vivify_768:
    set $P2330, $P2329[0]
    unless_null $P2330, vivify_769
    new $P2330, "Undef"
  vivify_769:
    $P2331 = $P2330."ast"()
    set $P2324, $P2331
  if_2325_end:
    store_lex "$past", $P2324
.annotate 'line', 1050
    find_lex $P2336, "$/"
    unless_null $P2336, vivify_770
    $P2336 = root_new ['parrot';'Hash']
  vivify_770:
    set $P2337, $P2336["quote"]
    unless_null $P2337, vivify_771
    new $P2337, "Undef"
  vivify_771:
    if $P2337, if_2335
.annotate 'line', 1054
    find_lex $P2344, "$/"
    unless_null $P2344, vivify_772
    $P2344 = root_new ['parrot';'Hash']
  vivify_772:
    set $P2345, $P2344["longname"]
    unless_null $P2345, vivify_773
    new $P2345, "Undef"
  vivify_773:
    set $S2346, $P2345
    iseq $I2347, $S2346, "HOW"
    if $I2347, if_2343
.annotate 'line', 1057
    find_lex $P2350, "$/"
    unless_null $P2350, vivify_774
    $P2350 = root_new ['parrot';'Hash']
  vivify_774:
    set $P2351, $P2350["longname"]
    unless_null $P2351, vivify_775
    new $P2351, "Undef"
  vivify_775:
    set $S2352, $P2351
    iseq $I2353, $S2352, "WHAT"
    if $I2353, if_2349
.annotate 'line', 1060
    find_lex $P2356, "$/"
    unless_null $P2356, vivify_776
    $P2356 = root_new ['parrot';'Hash']
  vivify_776:
    set $P2357, $P2356["longname"]
    unless_null $P2357, vivify_777
    new $P2357, "Undef"
  vivify_777:
    set $S2358, $P2357
    iseq $I2359, $S2358, "WHO"
    if $I2359, if_2355
.annotate 'line', 1064
    find_lex $P2361, "$past"
    find_lex $P2362, "$/"
    unless_null $P2362, vivify_778
    $P2362 = root_new ['parrot';'Hash']
  vivify_778:
    set $P2363, $P2362["longname"]
    unless_null $P2363, vivify_779
    new $P2363, "Undef"
  vivify_779:
    set $S2364, $P2363
    $P2361."name"($S2364)
.annotate 'line', 1065
    find_lex $P2365, "$past"
    $P2365."pasttype"("callmethod")
.annotate 'line', 1063
    goto if_2355_end
  if_2355:
.annotate 'line', 1061
    find_lex $P2360, "$past"
    $P2360."pirop"("get_who PP")
  if_2355_end:
.annotate 'line', 1060
    goto if_2349_end
  if_2349:
.annotate 'line', 1058
    find_lex $P2354, "$past"
    $P2354."pirop"("get_what PP")
  if_2349_end:
.annotate 'line', 1057
    goto if_2343_end
  if_2343:
.annotate 'line', 1055
    find_lex $P2348, "$past"
    $P2348."pirop"("get_how PP")
  if_2343_end:
.annotate 'line', 1054
    goto if_2335_end
  if_2335:
.annotate 'line', 1051
    find_lex $P2338, "$past"
    find_lex $P2339, "$/"
    unless_null $P2339, vivify_780
    $P2339 = root_new ['parrot';'Hash']
  vivify_780:
    set $P2340, $P2339["quote"]
    unless_null $P2340, vivify_781
    new $P2340, "Undef"
  vivify_781:
    $P2341 = $P2340."ast"()
    $P2338."name"($P2341)
.annotate 'line', 1052
    find_lex $P2342, "$past"
    $P2342."pasttype"("callmethod")
  if_2335_end:
.annotate 'line', 1067
    find_lex $P2366, "$/"
    find_lex $P2367, "$past"
    $P2368 = $P2366."!make"($P2367)
.annotate 'line', 1048
    .return ($P2368)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("119_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2370
    .param pmc param_2371
.annotate 'line', 1072
    .lex "self", param_2370
    .lex "$/", param_2371
.annotate 'line', 1073
    find_lex $P2372, "$/"
    get_hll_global $P2373, ["PAST"], "Var"
    $P2374 = $P2373."new"("self" :named("name"))
    $P2375 = $P2372."!make"($P2374)
.annotate 'line', 1072
    .return ($P2375)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("120_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2377
    .param pmc param_2378
.annotate 'line', 1076
    .lex "self", param_2377
    .lex "$/", param_2378
.annotate 'line', 1077
    new $P2379, "Undef"
    .lex "$past", $P2379
    find_lex $P2380, "$/"
    unless_null $P2380, vivify_782
    $P2380 = root_new ['parrot';'Hash']
  vivify_782:
    set $P2381, $P2380["args"]
    unless_null $P2381, vivify_783
    new $P2381, "Undef"
  vivify_783:
    $P2382 = $P2381."ast"()
    store_lex "$past", $P2382
.annotate 'line', 1078
    find_lex $P2383, "$past"
    find_lex $P2384, "$/"
    unless_null $P2384, vivify_784
    $P2384 = root_new ['parrot';'Hash']
  vivify_784:
    set $P2385, $P2384["deflongname"]
    unless_null $P2385, vivify_785
    new $P2385, "Undef"
  vivify_785:
    set $S2386, $P2385
    $P2383."name"($S2386)
.annotate 'line', 1079
    find_lex $P2387, "$/"
    find_lex $P2388, "$past"
    $P2389 = $P2387."!make"($P2388)
.annotate 'line', 1076
    .return ($P2389)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("121_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2391
    .param pmc param_2392
.annotate 'line', 1082
    .const 'Sub' $P2407 = "122_1300060192.103" 
    capture_lex $P2407
    .lex "self", param_2391
    .lex "$/", param_2392
.annotate 'line', 1084
    new $P2393, "Undef"
    .lex "$var", $P2393
.annotate 'line', 1096
    new $P2394, "Undef"
    .lex "$past", $P2394
.annotate 'line', 1082
    find_lex $P2395, "$var"
.annotate 'line', 1085
    find_lex $P2397, "$/"
    unless_null $P2397, vivify_786
    $P2397 = root_new ['parrot';'Hash']
  vivify_786:
    set $P2398, $P2397["name"]
    unless_null $P2398, vivify_787
    new $P2398, "Undef"
  vivify_787:
    set $S2399, $P2398
    $P2400 = "is_lexical"($S2399)
    if $P2400, if_2396
.annotate 'line', 1088
    .const 'Sub' $P2407 = "122_1300060192.103" 
    capture_lex $P2407
    $P2407()
    goto if_2396_end
  if_2396:
.annotate 'line', 1086
    get_hll_global $P2401, ["PAST"], "Var"
    find_lex $P2402, "$/"
    unless_null $P2402, vivify_793
    $P2402 = root_new ['parrot';'Hash']
  vivify_793:
    set $P2403, $P2402["name"]
    unless_null $P2403, vivify_794
    new $P2403, "Undef"
  vivify_794:
    set $S2404, $P2403
    $P2405 = $P2401."new"($S2404 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P2405
  if_2396_end:
.annotate 'line', 1096
    find_lex $P2430, "$var"
    store_lex "$past", $P2430
.annotate 'line', 1097
    find_lex $P2432, "$/"
    unless_null $P2432, vivify_795
    $P2432 = root_new ['parrot';'Hash']
  vivify_795:
    set $P2433, $P2432["args"]
    unless_null $P2433, vivify_796
    new $P2433, "Undef"
  vivify_796:
    unless $P2433, if_2431_end
.annotate 'line', 1098
    find_lex $P2434, "$/"
    unless_null $P2434, vivify_797
    $P2434 = root_new ['parrot';'Hash']
  vivify_797:
    set $P2435, $P2434["args"]
    unless_null $P2435, vivify_798
    $P2435 = root_new ['parrot';'ResizablePMCArray']
  vivify_798:
    set $P2436, $P2435[0]
    unless_null $P2436, vivify_799
    new $P2436, "Undef"
  vivify_799:
    $P2437 = $P2436."ast"()
    store_lex "$past", $P2437
.annotate 'line', 1099
    find_lex $P2438, "$past"
    find_lex $P2439, "$var"
    $P2438."unshift"($P2439)
  if_2431_end:
.annotate 'line', 1101
    find_lex $P2440, "$/"
    find_lex $P2441, "$past"
    $P2442 = $P2440."!make"($P2441)
.annotate 'line', 1082
    .return ($P2442)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2406"  :anon :subid("122_1300060192.103") :outer("121_1300060192.103")
.annotate 'line', 1089
    $P2408 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2408
.annotate 'line', 1090
    new $P2409, "Undef"
    .lex "$name", $P2409
.annotate 'line', 1089
    find_lex $P2410, "$/"
    unless_null $P2410, vivify_788
    $P2410 = root_new ['parrot';'Hash']
  vivify_788:
    set $P2411, $P2410["name"]
    unless_null $P2411, vivify_789
    $P2411 = root_new ['parrot';'Hash']
  vivify_789:
    set $P2412, $P2411["identifier"]
    unless_null $P2412, vivify_790
    new $P2412, "Undef"
  vivify_790:
    clone $P2413, $P2412
    store_lex "@ns", $P2413
.annotate 'line', 1090
    find_lex $P2414, "@ns"
    $P2415 = $P2414."pop"()
    store_lex "$name", $P2415
.annotate 'line', 1091
    find_lex $P2419, "@ns"
    if $P2419, if_2418
    set $P2417, $P2419
    goto if_2418_end
  if_2418:
    find_lex $P2420, "@ns"
    unless_null $P2420, vivify_791
    $P2420 = root_new ['parrot';'ResizablePMCArray']
  vivify_791:
    set $P2421, $P2420[0]
    unless_null $P2421, vivify_792
    new $P2421, "Undef"
  vivify_792:
    set $S2422, $P2421
    iseq $I2423, $S2422, "GLOBAL"
    new $P2417, 'Integer'
    set $P2417, $I2423
  if_2418_end:
    unless $P2417, if_2416_end
    find_lex $P2424, "@ns"
    $P2424."shift"()
  if_2416_end:
.annotate 'line', 1092
    get_hll_global $P2425, ["PAST"], "Var"
    find_lex $P2426, "$name"
    set $S2427, $P2426
    find_lex $P2428, "@ns"
    $P2429 = $P2425."new"($S2427 :named("name"), $P2428 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2429
.annotate 'line', 1088
    .return ($P2429)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("123_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2445
    .param pmc param_2446
.annotate 'line', 1114
    .lex "self", param_2445
    .lex "$/", param_2446
.annotate 'line', 1115
    new $P2447, "Undef"
    .lex "$past", $P2447
.annotate 'line', 1116
    new $P2448, "Undef"
    .lex "$pirop", $P2448
.annotate 'line', 1115
    find_lex $P2451, "$/"
    unless_null $P2451, vivify_800
    $P2451 = root_new ['parrot';'Hash']
  vivify_800:
    set $P2452, $P2451["args"]
    unless_null $P2452, vivify_801
    new $P2452, "Undef"
  vivify_801:
    if $P2452, if_2450
    get_hll_global $P2457, ["PAST"], "Op"
    find_lex $P2458, "$/"
    $P2459 = $P2457."new"($P2458 :named("node"))
    set $P2449, $P2459
    goto if_2450_end
  if_2450:
    find_lex $P2453, "$/"
    unless_null $P2453, vivify_802
    $P2453 = root_new ['parrot';'Hash']
  vivify_802:
    set $P2454, $P2453["args"]
    unless_null $P2454, vivify_803
    $P2454 = root_new ['parrot';'ResizablePMCArray']
  vivify_803:
    set $P2455, $P2454[0]
    unless_null $P2455, vivify_804
    new $P2455, "Undef"
  vivify_804:
    $P2456 = $P2455."ast"()
    set $P2449, $P2456
  if_2450_end:
    store_lex "$past", $P2449
.annotate 'line', 1116
    find_lex $P2460, "$/"
    unless_null $P2460, vivify_805
    $P2460 = root_new ['parrot';'Hash']
  vivify_805:
    set $P2461, $P2460["op"]
    unless_null $P2461, vivify_806
    new $P2461, "Undef"
  vivify_806:
    set $S2462, $P2461
    new $P2463, 'String'
    set $P2463, $S2462
    store_lex "$pirop", $P2463
.annotate 'line', 1117

            $P0 = find_lex '$pirop'
            $S0 = $P0
            $P0 = split '__', $S0
            $S0 = join ' ', $P0
            $P2464 = box $S0
        
    store_lex "$pirop", $P2464
.annotate 'line', 1124
    find_lex $P2465, "$past"
    find_lex $P2466, "$pirop"
    $P2465."pirop"($P2466)
.annotate 'line', 1125
    find_lex $P2467, "$past"
    $P2467."pasttype"("pirop")
.annotate 'line', 1126
    find_lex $P2468, "$/"
    find_lex $P2469, "$past"
    $P2470 = $P2468."!make"($P2469)
.annotate 'line', 1114
    .return ($P2470)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("124_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2472
    .param pmc param_2473
.annotate 'line', 1129
    .lex "self", param_2472
    .lex "$/", param_2473
.annotate 'line', 1130
    find_lex $P2474, "$/"
    get_hll_global $P2475, ["PAST"], "Op"
    $P2476 = $P2475."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2477 = $P2474."!make"($P2476)
.annotate 'line', 1129
    .return ($P2477)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("125_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2479
    .param pmc param_2480
.annotate 'line', 1135
    .lex "self", param_2479
    .lex "$/", param_2480
    find_lex $P2481, "$/"
    find_lex $P2482, "$/"
    unless_null $P2482, vivify_807
    $P2482 = root_new ['parrot';'Hash']
  vivify_807:
    set $P2483, $P2482["arglist"]
    unless_null $P2483, vivify_808
    new $P2483, "Undef"
  vivify_808:
    $P2484 = $P2483."ast"()
    $P2485 = $P2481."!make"($P2484)
    .return ($P2485)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("126_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2487
    .param pmc param_2488
.annotate 'line', 1137
    .const 'Sub' $P2499 = "127_1300060192.103" 
    capture_lex $P2499
    .lex "self", param_2487
    .lex "$/", param_2488
.annotate 'line', 1138
    new $P2489, "Undef"
    .lex "$past", $P2489
.annotate 'line', 1146
    new $P2490, "Undef"
    .lex "$i", $P2490
.annotate 'line', 1147
    new $P2491, "Undef"
    .lex "$n", $P2491
.annotate 'line', 1138
    get_hll_global $P2492, ["PAST"], "Op"
    find_lex $P2493, "$/"
    $P2494 = $P2492."new"("call" :named("pasttype"), $P2493 :named("node"))
    store_lex "$past", $P2494
.annotate 'line', 1139
    find_lex $P2496, "$/"
    unless_null $P2496, vivify_809
    $P2496 = root_new ['parrot';'Hash']
  vivify_809:
    set $P2497, $P2496["EXPR"]
    unless_null $P2497, vivify_810
    new $P2497, "Undef"
  vivify_810:
    unless $P2497, if_2495_end
    .const 'Sub' $P2499 = "127_1300060192.103" 
    capture_lex $P2499
    $P2499()
  if_2495_end:
.annotate 'line', 1146
    new $P2531, "Integer"
    assign $P2531, 0
    store_lex "$i", $P2531
.annotate 'line', 1147
    find_lex $P2532, "$past"
    $P2533 = $P2532."list"()
    set $N2534, $P2533
    new $P2535, 'Float'
    set $P2535, $N2534
    store_lex "$n", $P2535
.annotate 'line', 1148
    new $P2583, 'ExceptionHandler'
    set_label $P2583, loop2582_handler
    $P2583."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2583
  loop2582_test:
    find_lex $P2536, "$i"
    set $N2537, $P2536
    find_lex $P2538, "$n"
    set $N2539, $P2538
    islt $I2540, $N2537, $N2539
    unless $I2540, loop2582_done
  loop2582_redo:
.annotate 'line', 1149
    find_lex $P2542, "$i"
    set $I2543, $P2542
    find_lex $P2544, "$past"
    unless_null $P2544, vivify_814
    $P2544 = root_new ['parrot';'ResizablePMCArray']
  vivify_814:
    set $P2545, $P2544[$I2543]
    unless_null $P2545, vivify_815
    new $P2545, "Undef"
  vivify_815:
    $S2546 = $P2545."name"()
    iseq $I2547, $S2546, "&prefix:<|>"
    unless $I2547, if_2541_end
.annotate 'line', 1150
    find_lex $P2548, "$i"
    set $I2549, $P2548
    find_lex $P2550, "$past"
    unless_null $P2550, vivify_816
    $P2550 = root_new ['parrot';'ResizablePMCArray']
  vivify_816:
    set $P2551, $P2550[$I2549]
    unless_null $P2551, vivify_817
    $P2551 = root_new ['parrot';'ResizablePMCArray']
  vivify_817:
    set $P2552, $P2551[0]
    unless_null $P2552, vivify_818
    new $P2552, "Undef"
  vivify_818:
    find_lex $P2553, "$i"
    set $I2554, $P2553
    find_lex $P2555, "$past"
    unless_null $P2555, vivify_819
    $P2555 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2555
  vivify_819:
    set $P2555[$I2554], $P2552
.annotate 'line', 1151
    find_lex $P2556, "$i"
    set $I2557, $P2556
    find_lex $P2558, "$past"
    unless_null $P2558, vivify_820
    $P2558 = root_new ['parrot';'ResizablePMCArray']
  vivify_820:
    set $P2559, $P2558[$I2557]
    unless_null $P2559, vivify_821
    new $P2559, "Undef"
  vivify_821:
    $P2559."flat"(1)
.annotate 'line', 1152
    find_lex $P2563, "$i"
    set $I2564, $P2563
    find_lex $P2565, "$past"
    unless_null $P2565, vivify_822
    $P2565 = root_new ['parrot';'ResizablePMCArray']
  vivify_822:
    set $P2566, $P2565[$I2564]
    unless_null $P2566, vivify_823
    new $P2566, "Undef"
  vivify_823:
    get_hll_global $P2567, ["PAST"], "Val"
    $P2568 = $P2566."isa"($P2567)
    if $P2568, if_2562
    set $P2561, $P2568
    goto if_2562_end
  if_2562:
.annotate 'line', 1153
    find_lex $P2569, "$i"
    set $I2570, $P2569
    find_lex $P2571, "$past"
    unless_null $P2571, vivify_824
    $P2571 = root_new ['parrot';'ResizablePMCArray']
  vivify_824:
    set $P2572, $P2571[$I2570]
    unless_null $P2572, vivify_825
    new $P2572, "Undef"
  vivify_825:
    $S2573 = $P2572."name"()
    substr $S2574, $S2573, 0, 1
    iseq $I2575, $S2574, "%"
    new $P2561, 'Integer'
    set $P2561, $I2575
  if_2562_end:
    unless $P2561, if_2560_end
.annotate 'line', 1154
    find_lex $P2576, "$i"
    set $I2577, $P2576
    find_lex $P2578, "$past"
    unless_null $P2578, vivify_826
    $P2578 = root_new ['parrot';'ResizablePMCArray']
  vivify_826:
    set $P2579, $P2578[$I2577]
    unless_null $P2579, vivify_827
    new $P2579, "Undef"
  vivify_827:
    $P2579."named"(1)
  if_2560_end:
  if_2541_end:
.annotate 'line', 1149
    find_lex $P2580, "$i"
    clone $P2581, $P2580
    inc $P2580
  loop2582_next:
.annotate 'line', 1148
    goto loop2582_test
  loop2582_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2584, exception, 'type'
    eq $P2584, .CONTROL_LOOP_NEXT, loop2582_next
    eq $P2584, .CONTROL_LOOP_REDO, loop2582_redo
  loop2582_done:
    pop_eh 
.annotate 'line', 1159
    find_lex $P2585, "$/"
    find_lex $P2586, "$past"
    $P2587 = $P2585."!make"($P2586)
.annotate 'line', 1137
    .return ($P2587)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2498"  :anon :subid("127_1300060192.103") :outer("126_1300060192.103")
.annotate 'line', 1139
    .const 'Sub' $P2520 = "128_1300060192.103" 
    capture_lex $P2520
.annotate 'line', 1140
    new $P2500, "Undef"
    .lex "$expr", $P2500
    find_lex $P2501, "$/"
    unless_null $P2501, vivify_811
    $P2501 = root_new ['parrot';'Hash']
  vivify_811:
    set $P2502, $P2501["EXPR"]
    unless_null $P2502, vivify_812
    new $P2502, "Undef"
  vivify_812:
    $P2503 = $P2502."ast"()
    store_lex "$expr", $P2503
.annotate 'line', 1141
    find_lex $P2508, "$expr"
    $S2509 = $P2508."name"()
    iseq $I2510, $S2509, "&infix:<,>"
    if $I2510, if_2507
    new $P2506, 'Integer'
    set $P2506, $I2510
    goto if_2507_end
  if_2507:
    find_lex $P2511, "$expr"
    $P2512 = $P2511."named"()
    isfalse $I2513, $P2512
    new $P2506, 'Integer'
    set $P2506, $I2513
  if_2507_end:
    if $P2506, if_2505
.annotate 'line', 1144
    find_lex $P2528, "$past"
    find_lex $P2529, "$expr"
    $P2530 = $P2528."push"($P2529)
    set $P2504, $P2530
.annotate 'line', 1141
    goto if_2505_end
  if_2505:
.annotate 'line', 1142
    find_lex $P2515, "$expr"
    $P2516 = $P2515."list"()
    defined $I2517, $P2516
    unless $I2517, for_undef_813
    iter $P2514, $P2516
    new $P2526, 'ExceptionHandler'
    set_label $P2526, loop2525_handler
    $P2526."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2526
  loop2525_test:
    unless $P2514, loop2525_done
    shift $P2518, $P2514
  loop2525_redo:
    .const 'Sub' $P2520 = "128_1300060192.103" 
    capture_lex $P2520
    $P2520($P2518)
  loop2525_next:
    goto loop2525_test
  loop2525_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2527, exception, 'type'
    eq $P2527, .CONTROL_LOOP_NEXT, loop2525_next
    eq $P2527, .CONTROL_LOOP_REDO, loop2525_redo
  loop2525_done:
    pop_eh 
  for_undef_813:
.annotate 'line', 1141
    set $P2504, $P2514
  if_2505_end:
.annotate 'line', 1139
    .return ($P2504)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2519"  :anon :subid("128_1300060192.103") :outer("127_1300060192.103")
    .param pmc param_2521
.annotate 'line', 1142
    .lex "$_", param_2521
    find_lex $P2522, "$past"
    find_lex $P2523, "$_"
    $P2524 = $P2522."push"($P2523)
    .return ($P2524)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("129_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2589
    .param pmc param_2590
.annotate 'line', 1162
    .lex "self", param_2589
    .lex "$/", param_2590
    find_lex $P2591, "$/"
    find_lex $P2592, "$/"
    unless_null $P2592, vivify_828
    $P2592 = root_new ['parrot';'Hash']
  vivify_828:
    set $P2593, $P2592["multi_declarator"]
    unless_null $P2593, vivify_829
    new $P2593, "Undef"
  vivify_829:
    $P2594 = $P2593."ast"()
    $P2595 = $P2591."!make"($P2594)
    .return ($P2595)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("130_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2597
    .param pmc param_2598
.annotate 'line', 1164
    .lex "self", param_2597
    .lex "$/", param_2598
    find_lex $P2599, "$/"
    find_lex $P2600, "$/"
    unless_null $P2600, vivify_830
    $P2600 = root_new ['parrot';'Hash']
  vivify_830:
    set $P2601, $P2600["value"]
    unless_null $P2601, vivify_831
    new $P2601, "Undef"
  vivify_831:
    $P2602 = $P2601."ast"()
    $P2603 = $P2599."!make"($P2602)
    .return ($P2603)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("131_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2605
    .param pmc param_2606
.annotate 'line', 1166
    .lex "self", param_2605
    .lex "$/", param_2606
.annotate 'line', 1167
    find_lex $P2607, "$/"
.annotate 'line', 1168
    find_lex $P2610, "$/"
    unless_null $P2610, vivify_832
    $P2610 = root_new ['parrot';'Hash']
  vivify_832:
    set $P2611, $P2610["EXPR"]
    unless_null $P2611, vivify_833
    new $P2611, "Undef"
  vivify_833:
    if $P2611, if_2609
.annotate 'line', 1169
    get_hll_global $P2616, ["PAST"], "Op"
    find_lex $P2617, "$/"
    $P2618 = $P2616."new"("list" :named("pasttype"), $P2617 :named("node"))
    set $P2608, $P2618
.annotate 'line', 1168
    goto if_2609_end
  if_2609:
    find_lex $P2612, "$/"
    unless_null $P2612, vivify_834
    $P2612 = root_new ['parrot';'Hash']
  vivify_834:
    set $P2613, $P2612["EXPR"]
    unless_null $P2613, vivify_835
    $P2613 = root_new ['parrot';'ResizablePMCArray']
  vivify_835:
    set $P2614, $P2613[0]
    unless_null $P2614, vivify_836
    new $P2614, "Undef"
  vivify_836:
    $P2615 = $P2614."ast"()
    set $P2608, $P2615
  if_2609_end:
    $P2619 = $P2607."!make"($P2608)
.annotate 'line', 1166
    .return ($P2619)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("132_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2621
    .param pmc param_2622
.annotate 'line', 1172
    .lex "self", param_2621
    .lex "$/", param_2622
.annotate 'line', 1173
    new $P2623, "Undef"
    .lex "$past", $P2623
.annotate 'line', 1172
    find_lex $P2624, "$past"
.annotate 'line', 1174
    find_lex $P2626, "$/"
    unless_null $P2626, vivify_837
    $P2626 = root_new ['parrot';'Hash']
  vivify_837:
    set $P2627, $P2626["EXPR"]
    unless_null $P2627, vivify_838
    new $P2627, "Undef"
  vivify_838:
    if $P2627, if_2625
.annotate 'line', 1181
    get_hll_global $P2639, ["PAST"], "Op"
    $P2640 = $P2639."new"("list" :named("pasttype"))
    store_lex "$past", $P2640
.annotate 'line', 1180
    goto if_2625_end
  if_2625:
.annotate 'line', 1175
    find_lex $P2628, "$/"
    unless_null $P2628, vivify_839
    $P2628 = root_new ['parrot';'Hash']
  vivify_839:
    set $P2629, $P2628["EXPR"]
    unless_null $P2629, vivify_840
    $P2629 = root_new ['parrot';'ResizablePMCArray']
  vivify_840:
    set $P2630, $P2629[0]
    unless_null $P2630, vivify_841
    new $P2630, "Undef"
  vivify_841:
    $P2631 = $P2630."ast"()
    store_lex "$past", $P2631
.annotate 'line', 1176
    find_lex $P2633, "$past"
    $S2634 = $P2633."name"()
    isne $I2635, $S2634, "&infix:<,>"
    unless $I2635, if_2632_end
.annotate 'line', 1177
    get_hll_global $P2636, ["PAST"], "Op"
    find_lex $P2637, "$past"
    $P2638 = $P2636."new"($P2637, "list" :named("pasttype"))
    store_lex "$past", $P2638
  if_2632_end:
  if_2625_end:
.annotate 'line', 1183
    find_lex $P2641, "$past"
    $P2641."name"("&circumfix:<[ ]>")
.annotate 'line', 1184
    find_lex $P2642, "$/"
    find_lex $P2643, "$past"
    $P2644 = $P2642."!make"($P2643)
.annotate 'line', 1172
    .return ($P2644)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("133_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2646
    .param pmc param_2647
.annotate 'line', 1187
    .lex "self", param_2646
    .lex "$/", param_2647
    find_lex $P2648, "$/"
    find_lex $P2649, "$/"
    unless_null $P2649, vivify_842
    $P2649 = root_new ['parrot';'Hash']
  vivify_842:
    set $P2650, $P2649["quote_EXPR"]
    unless_null $P2650, vivify_843
    new $P2650, "Undef"
  vivify_843:
    $P2651 = $P2650."ast"()
    $P2652 = $P2648."!make"($P2651)
    .return ($P2652)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("134_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2654
    .param pmc param_2655
.annotate 'line', 1188
    .lex "self", param_2654
    .lex "$/", param_2655
    find_lex $P2656, "$/"
    find_lex $P2657, "$/"
    unless_null $P2657, vivify_844
    $P2657 = root_new ['parrot';'Hash']
  vivify_844:
    set $P2658, $P2657["quote_EXPR"]
    unless_null $P2658, vivify_845
    new $P2658, "Undef"
  vivify_845:
    $P2659 = $P2658."ast"()
    $P2660 = $P2656."!make"($P2659)
    .return ($P2660)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("135_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2662
    .param pmc param_2663
.annotate 'line', 1190
    .const 'Sub' $P2674 = "136_1300060192.103" 
    capture_lex $P2674
    .lex "self", param_2662
    .lex "$/", param_2663
.annotate 'line', 1191
    find_lex $P2666, "$/"
    unless_null $P2666, vivify_846
    $P2666 = root_new ['parrot';'Hash']
  vivify_846:
    set $P2667, $P2666["pblock"]
    unless_null $P2667, vivify_847
    $P2667 = root_new ['parrot';'Hash']
  vivify_847:
    set $P2668, $P2667["blockoid"]
    unless_null $P2668, vivify_848
    $P2668 = root_new ['parrot';'Hash']
  vivify_848:
    set $P2669, $P2668["statementlist"]
    unless_null $P2669, vivify_849
    $P2669 = root_new ['parrot';'Hash']
  vivify_849:
    set $P2670, $P2669["statement"]
    unless_null $P2670, vivify_850
    new $P2670, "Undef"
  vivify_850:
    set $N2671, $P2670
    isgt $I2672, $N2671, 0.0
    if $I2672, if_2665
.annotate 'line', 1196
    find_lex $P2687, "$/"
    unless_null $P2687, vivify_851
    $P2687 = root_new ['parrot';'Hash']
  vivify_851:
    set $P2688, $P2687["pblock"]
    unless_null $P2688, vivify_852
    $P2688 = root_new ['parrot';'Hash']
  vivify_852:
    set $P2689, $P2688["blockoid"]
    unless_null $P2689, vivify_853
    $P2689 = root_new ['parrot';'Hash']
  vivify_853:
    set $P2690, $P2689["you_are_here"]
    unless_null $P2690, vivify_854
    new $P2690, "Undef"
  vivify_854:
    if $P2690, if_2686
.annotate 'line', 1200
    find_lex $P2696, "$/"
    $P2697 = "vivitype"("%")
    $P2698 = $P2696."!make"($P2697)
.annotate 'line', 1199
    set $P2685, $P2698
.annotate 'line', 1196
    goto if_2686_end
  if_2686:
.annotate 'line', 1197
    find_lex $P2691, "$/"
    find_lex $P2692, "$/"
    unless_null $P2692, vivify_855
    $P2692 = root_new ['parrot';'Hash']
  vivify_855:
    set $P2693, $P2692["pblock"]
    unless_null $P2693, vivify_856
    new $P2693, "Undef"
  vivify_856:
    $P2694 = $P2693."ast"()
    $P2695 = $P2691."!make"($P2694)
.annotate 'line', 1196
    set $P2685, $P2695
  if_2686_end:
    set $P2664, $P2685
.annotate 'line', 1191
    goto if_2665_end
  if_2665:
    .const 'Sub' $P2674 = "136_1300060192.103" 
    capture_lex $P2674
    $P2684 = $P2674()
    set $P2664, $P2684
  if_2665_end:
.annotate 'line', 1190
    .return ($P2664)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2673"  :anon :subid("136_1300060192.103") :outer("135_1300060192.103")
.annotate 'line', 1192
    new $P2675, "Undef"
    .lex "$past", $P2675
    find_lex $P2676, "$/"
    unless_null $P2676, vivify_857
    $P2676 = root_new ['parrot';'Hash']
  vivify_857:
    set $P2677, $P2676["pblock"]
    unless_null $P2677, vivify_858
    new $P2677, "Undef"
  vivify_858:
    $P2678 = $P2677."ast"()
    store_lex "$past", $P2678
.annotate 'line', 1193
    new $P2679, "Integer"
    assign $P2679, 1
    find_lex $P2680, "$past"
    unless_null $P2680, vivify_859
    $P2680 = root_new ['parrot';'Hash']
    store_lex "$past", $P2680
  vivify_859:
    set $P2680["bareblock"], $P2679
.annotate 'line', 1194
    find_dynamic_lex $P2681, "$/"
    find_lex $P2682, "$past"
    $P2683 = $P2681."!make"($P2682)
.annotate 'line', 1191
    .return ($P2683)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("137_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2700
    .param pmc param_2701
.annotate 'line', 1204
    .lex "self", param_2700
    .lex "$/", param_2701
.annotate 'line', 1205
    new $P2702, "Undef"
    .lex "$name", $P2702
    find_lex $P2705, "$/"
    unless_null $P2705, vivify_860
    $P2705 = root_new ['parrot';'Hash']
  vivify_860:
    set $P2706, $P2705["sigil"]
    unless_null $P2706, vivify_861
    new $P2706, "Undef"
  vivify_861:
    set $S2707, $P2706
    iseq $I2708, $S2707, "@"
    if $I2708, if_2704
.annotate 'line', 1206
    find_lex $P2712, "$/"
    unless_null $P2712, vivify_862
    $P2712 = root_new ['parrot';'Hash']
  vivify_862:
    set $P2713, $P2712["sigil"]
    unless_null $P2713, vivify_863
    new $P2713, "Undef"
  vivify_863:
    set $S2714, $P2713
    iseq $I2715, $S2714, "%"
    if $I2715, if_2711
    new $P2717, "String"
    assign $P2717, "item"
    set $P2710, $P2717
    goto if_2711_end
  if_2711:
    new $P2716, "String"
    assign $P2716, "hash"
    set $P2710, $P2716
  if_2711_end:
    set $P2703, $P2710
.annotate 'line', 1205
    goto if_2704_end
  if_2704:
    new $P2709, "String"
    assign $P2709, "list"
    set $P2703, $P2709
  if_2704_end:
    store_lex "$name", $P2703
.annotate 'line', 1208
    find_lex $P2718, "$/"
    get_hll_global $P2719, ["PAST"], "Op"
    find_lex $P2720, "$name"
    find_lex $P2721, "$/"
    unless_null $P2721, vivify_864
    $P2721 = root_new ['parrot';'Hash']
  vivify_864:
    set $P2722, $P2721["semilist"]
    unless_null $P2722, vivify_865
    new $P2722, "Undef"
  vivify_865:
    $P2723 = $P2722."ast"()
    $P2724 = $P2719."new"($P2723, "callmethod" :named("pasttype"), $P2720 :named("name"))
    $P2725 = $P2718."!make"($P2724)
.annotate 'line', 1204
    .return ($P2725)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("138_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2727
    .param pmc param_2728
.annotate 'line', 1211
    .lex "self", param_2727
    .lex "$/", param_2728
    find_lex $P2729, "$/"
    find_lex $P2730, "$/"
    unless_null $P2730, vivify_866
    $P2730 = root_new ['parrot';'Hash']
  vivify_866:
    set $P2731, $P2730["statement"]
    unless_null $P2731, vivify_867
    new $P2731, "Undef"
  vivify_867:
    $P2732 = $P2731."ast"()
    $P2733 = $P2729."!make"($P2732)
    .return ($P2733)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("139_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2735
    .param pmc param_2736
.annotate 'line', 1213
    .lex "self", param_2735
    .lex "$/", param_2736
.annotate 'line', 1214
    find_lex $P2737, "$/"
    get_hll_global $P2738, ["PAST"], "Var"
    find_lex $P2739, "$/"
    unless_null $P2739, vivify_868
    $P2739 = root_new ['parrot';'Hash']
  vivify_868:
    set $P2740, $P2739["EXPR"]
    unless_null $P2740, vivify_869
    new $P2740, "Undef"
  vivify_869:
    $P2741 = $P2740."ast"()
.annotate 'line', 1216
    $P2742 = "vivitype"("@")
    $P2743 = $P2738."new"($P2741, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2742 :named("vivibase"))
.annotate 'line', 1214
    $P2744 = $P2737."!make"($P2743)
.annotate 'line', 1213
    .return ($P2744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("140_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2746
    .param pmc param_2747
.annotate 'line', 1219
    .lex "self", param_2746
    .lex "$/", param_2747
.annotate 'line', 1220
    find_lex $P2748, "$/"
    get_hll_global $P2749, ["PAST"], "Var"
    find_lex $P2750, "$/"
    unless_null $P2750, vivify_870
    $P2750 = root_new ['parrot';'Hash']
  vivify_870:
    set $P2751, $P2750["EXPR"]
    unless_null $P2751, vivify_871
    new $P2751, "Undef"
  vivify_871:
    $P2752 = $P2751."ast"()
.annotate 'line', 1222
    $P2753 = "vivitype"("%")
    $P2754 = $P2749."new"($P2752, "keyed" :named("scope"), "Undef" :named("viviself"), $P2753 :named("vivibase"))
.annotate 'line', 1220
    $P2755 = $P2748."!make"($P2754)
.annotate 'line', 1219
    .return ($P2755)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("141_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2757
    .param pmc param_2758
.annotate 'line', 1225
    .lex "self", param_2757
    .lex "$/", param_2758
.annotate 'line', 1226
    find_lex $P2759, "$/"
    get_hll_global $P2760, ["PAST"], "Var"
    find_lex $P2761, "$/"
    unless_null $P2761, vivify_872
    $P2761 = root_new ['parrot';'Hash']
  vivify_872:
    set $P2762, $P2761["quote_EXPR"]
    unless_null $P2762, vivify_873
    new $P2762, "Undef"
  vivify_873:
    $P2763 = $P2762."ast"()
.annotate 'line', 1228
    $P2764 = "vivitype"("%")
    $P2765 = $P2760."new"($P2763, "keyed" :named("scope"), "Undef" :named("viviself"), $P2764 :named("vivibase"))
.annotate 'line', 1226
    $P2766 = $P2759."!make"($P2765)
.annotate 'line', 1225
    .return ($P2766)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("142_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2768
    .param pmc param_2769
.annotate 'line', 1231
    .lex "self", param_2768
    .lex "$/", param_2769
.annotate 'line', 1232
    find_lex $P2770, "$/"
    find_lex $P2771, "$/"
    unless_null $P2771, vivify_874
    $P2771 = root_new ['parrot';'Hash']
  vivify_874:
    set $P2772, $P2771["arglist"]
    unless_null $P2772, vivify_875
    new $P2772, "Undef"
  vivify_875:
    $P2773 = $P2772."ast"()
    $P2774 = $P2770."!make"($P2773)
.annotate 'line', 1231
    .return ($P2774)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("143_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2776
    .param pmc param_2777
.annotate 'line', 1235
    .lex "self", param_2776
    .lex "$/", param_2777
.annotate 'line', 1236
    find_lex $P2778, "$/"
    find_lex $P2781, "$/"
    unless_null $P2781, vivify_876
    $P2781 = root_new ['parrot';'Hash']
  vivify_876:
    set $P2782, $P2781["quote"]
    unless_null $P2782, vivify_877
    new $P2782, "Undef"
  vivify_877:
    if $P2782, if_2780
    find_lex $P2786, "$/"
    unless_null $P2786, vivify_878
    $P2786 = root_new ['parrot';'Hash']
  vivify_878:
    set $P2787, $P2786["number"]
    unless_null $P2787, vivify_879
    new $P2787, "Undef"
  vivify_879:
    $P2788 = $P2787."ast"()
    set $P2779, $P2788
    goto if_2780_end
  if_2780:
    find_lex $P2783, "$/"
    unless_null $P2783, vivify_880
    $P2783 = root_new ['parrot';'Hash']
  vivify_880:
    set $P2784, $P2783["quote"]
    unless_null $P2784, vivify_881
    new $P2784, "Undef"
  vivify_881:
    $P2785 = $P2784."ast"()
    set $P2779, $P2785
  if_2780_end:
    $P2789 = $P2778."!make"($P2779)
.annotate 'line', 1235
    .return ($P2789)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("144_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2791
    .param pmc param_2792
.annotate 'line', 1239
    .lex "self", param_2791
    .lex "$/", param_2792
.annotate 'line', 1240
    new $P2793, "Undef"
    .lex "$value", $P2793
    find_lex $P2796, "$/"
    unless_null $P2796, vivify_882
    $P2796 = root_new ['parrot';'Hash']
  vivify_882:
    set $P2797, $P2796["dec_number"]
    unless_null $P2797, vivify_883
    new $P2797, "Undef"
  vivify_883:
    if $P2797, if_2795
    find_lex $P2801, "$/"
    unless_null $P2801, vivify_884
    $P2801 = root_new ['parrot';'Hash']
  vivify_884:
    set $P2802, $P2801["integer"]
    unless_null $P2802, vivify_885
    new $P2802, "Undef"
  vivify_885:
    $P2803 = $P2802."ast"()
    set $P2794, $P2803
    goto if_2795_end
  if_2795:
    find_lex $P2798, "$/"
    unless_null $P2798, vivify_886
    $P2798 = root_new ['parrot';'Hash']
  vivify_886:
    set $P2799, $P2798["dec_number"]
    unless_null $P2799, vivify_887
    new $P2799, "Undef"
  vivify_887:
    $P2800 = $P2799."ast"()
    set $P2794, $P2800
  if_2795_end:
    store_lex "$value", $P2794
.annotate 'line', 1241
    find_lex $P2805, "$/"
    unless_null $P2805, vivify_888
    $P2805 = root_new ['parrot';'Hash']
  vivify_888:
    set $P2806, $P2805["sign"]
    unless_null $P2806, vivify_889
    new $P2806, "Undef"
  vivify_889:
    set $S2807, $P2806
    iseq $I2808, $S2807, "-"
    unless $I2808, if_2804_end
    find_lex $P2809, "$value"
    neg $P2810, $P2809
    store_lex "$value", $P2810
  if_2804_end:
.annotate 'line', 1242
    find_lex $P2811, "$/"
    get_hll_global $P2812, ["PAST"], "Val"
    find_lex $P2813, "$value"
    $P2814 = $P2812."new"($P2813 :named("value"))
    $P2815 = $P2811."!make"($P2814)
.annotate 'line', 1239
    .return ($P2815)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("145_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2817
    .param pmc param_2818
.annotate 'line', 1245
    .lex "self", param_2817
    .lex "$/", param_2818
    find_lex $P2819, "$/"
    find_lex $P2820, "$/"
    unless_null $P2820, vivify_890
    $P2820 = root_new ['parrot';'Hash']
  vivify_890:
    set $P2821, $P2820["quote_EXPR"]
    unless_null $P2821, vivify_891
    new $P2821, "Undef"
  vivify_891:
    $P2822 = $P2821."ast"()
    $P2823 = $P2819."!make"($P2822)
    .return ($P2823)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("146_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2825
    .param pmc param_2826
.annotate 'line', 1246
    .lex "self", param_2825
    .lex "$/", param_2826
    find_lex $P2827, "$/"
    find_lex $P2828, "$/"
    unless_null $P2828, vivify_892
    $P2828 = root_new ['parrot';'Hash']
  vivify_892:
    set $P2829, $P2828["quote_EXPR"]
    unless_null $P2829, vivify_893
    new $P2829, "Undef"
  vivify_893:
    $P2830 = $P2829."ast"()
    $P2831 = $P2827."!make"($P2830)
    .return ($P2831)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("147_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2833
    .param pmc param_2834
.annotate 'line', 1247
    .lex "self", param_2833
    .lex "$/", param_2834
    find_lex $P2835, "$/"
    find_lex $P2836, "$/"
    unless_null $P2836, vivify_894
    $P2836 = root_new ['parrot';'Hash']
  vivify_894:
    set $P2837, $P2836["quote_EXPR"]
    unless_null $P2837, vivify_895
    new $P2837, "Undef"
  vivify_895:
    $P2838 = $P2837."ast"()
    $P2839 = $P2835."!make"($P2838)
    .return ($P2839)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("148_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2841
    .param pmc param_2842
.annotate 'line', 1248
    .lex "self", param_2841
    .lex "$/", param_2842
    find_lex $P2843, "$/"
    find_lex $P2844, "$/"
    unless_null $P2844, vivify_896
    $P2844 = root_new ['parrot';'Hash']
  vivify_896:
    set $P2845, $P2844["quote_EXPR"]
    unless_null $P2845, vivify_897
    new $P2845, "Undef"
  vivify_897:
    $P2846 = $P2845."ast"()
    $P2847 = $P2843."!make"($P2846)
    .return ($P2847)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("149_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2849
    .param pmc param_2850
.annotate 'line', 1249
    .lex "self", param_2849
    .lex "$/", param_2850
    find_lex $P2851, "$/"
    find_lex $P2852, "$/"
    unless_null $P2852, vivify_898
    $P2852 = root_new ['parrot';'Hash']
  vivify_898:
    set $P2853, $P2852["quote_EXPR"]
    unless_null $P2853, vivify_899
    new $P2853, "Undef"
  vivify_899:
    $P2854 = $P2853."ast"()
    $P2855 = $P2851."!make"($P2854)
    .return ($P2855)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("150_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2857
    .param pmc param_2858
.annotate 'line', 1250
    .lex "self", param_2857
    .lex "$/", param_2858
.annotate 'line', 1251
    find_lex $P2859, "$/"
    get_hll_global $P2860, ["PAST"], "Op"
    find_lex $P2861, "$/"
    unless_null $P2861, vivify_900
    $P2861 = root_new ['parrot';'Hash']
  vivify_900:
    set $P2862, $P2861["quote_EXPR"]
    unless_null $P2862, vivify_901
    new $P2862, "Undef"
  vivify_901:
    $P2863 = $P2862."ast"()
    $P2864 = $P2863."value"()
    find_lex $P2865, "$/"
    $P2866 = $P2860."new"($P2864 :named("inline"), "inline" :named("pasttype"), $P2865 :named("node"))
    $P2867 = $P2859."!make"($P2866)
.annotate 'line', 1250
    .return ($P2867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("151_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2871
    .param pmc param_2872
    .param pmc param_2873 :optional
    .param int has_param_2873 :opt_flag
.annotate 'line', 1256
    new $P2870, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2870, control_2869
    push_eh $P2870
    .lex "self", param_2871
    .lex "$/", param_2872
    if has_param_2873, optparam_902
    new $P2874, "Undef"
    set param_2873, $P2874
  optparam_902:
    .lex "$key", param_2873
.annotate 'line', 1266
    new $P2875, "Undef"
    .lex "$regex", $P2875
.annotate 'line', 1268
    new $P2876, "Undef"
    .lex "$past", $P2876
.annotate 'line', 1257
    find_lex $P2878, "$key"
    set $S2879, $P2878
    iseq $I2880, $S2879, "open"
    unless $I2880, if_2877_end
.annotate 'line', 1258

                null $P0
                set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
            
.annotate 'line', 1262
    get_global $P2881, "@BLOCK"
    unless_null $P2881, vivify_903
    $P2881 = root_new ['parrot';'ResizablePMCArray']
  vivify_903:
    set $P2882, $P2881[0]
    unless_null $P2882, vivify_904
    new $P2882, "Undef"
  vivify_904:
    $P2882."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1263
    get_global $P2883, "@BLOCK"
    unless_null $P2883, vivify_905
    $P2883 = root_new ['parrot';'ResizablePMCArray']
  vivify_905:
    set $P2884, $P2883[0]
    unless_null $P2884, vivify_906
    new $P2884, "Undef"
  vivify_906:
    $P2884."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1264
    new $P2885, "Exception"
    set $P2885['type'], .CONTROL_RETURN
    new $P2886, "Integer"
    assign $P2886, 0
    setattribute $P2885, 'payload', $P2886
    throw $P2885
  if_2877_end:
.annotate 'line', 1267
    get_hll_global $P2887, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2888, "$/"
    unless_null $P2888, vivify_907
    $P2888 = root_new ['parrot';'Hash']
  vivify_907:
    set $P2889, $P2888["p6regex"]
    unless_null $P2889, vivify_908
    new $P2889, "Undef"
  vivify_908:
    $P2890 = $P2889."ast"()
    get_global $P2891, "@BLOCK"
    $P2892 = $P2891."shift"()
    $P2893 = $P2887($P2890, $P2892)
    store_lex "$regex", $P2893
.annotate 'line', 1269
    get_hll_global $P2894, ["PAST"], "Op"
.annotate 'line', 1271
    get_hll_global $P2895, ["PAST"], "Var"
    new $P2896, "ResizablePMCArray"
    push $P2896, "Regex"
    $P2897 = $P2895."new"("Regex" :named("name"), $P2896 :named("namespace"), "package" :named("scope"))
    find_lex $P2898, "$regex"
    $P2899 = $P2894."new"($P2897, $P2898, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1269
    store_lex "$past", $P2899
.annotate 'line', 1275
    find_lex $P2900, "$regex"
    find_lex $P2901, "$past"
    unless_null $P2901, vivify_909
    $P2901 = root_new ['parrot';'Hash']
    store_lex "$past", $P2901
  vivify_909:
    set $P2901["sink"], $P2900
.annotate 'line', 1276
    find_lex $P2902, "$/"
    find_lex $P2903, "$past"
    $P2904 = $P2902."!make"($P2903)
.annotate 'line', 1256
    .return ($P2904)
  control_2869:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2905, exception, "payload"
    .return ($P2905)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("152_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2907
    .param pmc param_2908
.annotate 'line', 1279
    .lex "self", param_2907
    .lex "$/", param_2908
    find_lex $P2909, "$/"
    find_lex $P2910, "$/"
    unless_null $P2910, vivify_910
    $P2910 = root_new ['parrot';'Hash']
  vivify_910:
    set $P2911, $P2910["variable"]
    unless_null $P2911, vivify_911
    new $P2911, "Undef"
  vivify_911:
    $P2912 = $P2911."ast"()
    $P2913 = $P2909."!make"($P2912)
    .return ($P2913)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("153_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2915
    .param pmc param_2916
.annotate 'line', 1280
    .lex "self", param_2915
    .lex "$/", param_2916
.annotate 'line', 1281
    find_lex $P2917, "$/"
    get_hll_global $P2918, ["PAST"], "Op"
.annotate 'line', 1282
    find_lex $P2919, "$/"
    unless_null $P2919, vivify_912
    $P2919 = root_new ['parrot';'Hash']
  vivify_912:
    set $P2920, $P2919["block"]
    unless_null $P2920, vivify_913
    new $P2920, "Undef"
  vivify_913:
    $P2921 = $P2920."ast"()
    $P2922 = "block_immediate"($P2921)
    find_lex $P2923, "$/"
    $P2924 = $P2918."new"($P2922, "set S*" :named("pirop"), $P2923 :named("node"))
.annotate 'line', 1281
    $P2925 = $P2917."!make"($P2924)
.annotate 'line', 1280
    .return ($P2925)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("154_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2927
    .param pmc param_2928
.annotate 'line', 1285
    .lex "self", param_2927
    .lex "$/", param_2928
    find_lex $P2929, "$/"
    $P2930 = $P2929."!make"("\e")
    .return ($P2930)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("155_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2932
    .param pmc param_2933
.annotate 'line', 1289
    .lex "self", param_2932
    .lex "$/", param_2933
    find_lex $P2934, "$/"
    find_lex $P2935, "$/"
    unless_null $P2935, vivify_914
    $P2935 = root_new ['parrot';'Hash']
  vivify_914:
    set $P2936, $P2935["dotty"]
    unless_null $P2936, vivify_915
    new $P2936, "Undef"
  vivify_915:
    $P2937 = $P2936."ast"()
    $P2938 = $P2934."!make"($P2937)
    .return ($P2938)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("156_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2940
    .param pmc param_2941
.annotate 'line', 1291
    .lex "self", param_2940
    .lex "$/", param_2941
.annotate 'line', 1292
    find_lex $P2942, "$/"
    get_hll_global $P2943, ["PAST"], "Op"
.annotate 'line', 1293
    new $P2944, "ResizablePMCArray"
    push $P2944, "    clone %r, %0"
    push $P2944, "    inc %0"
    $P2945 = $P2943."new"("postfix:<++>" :named("name"), $P2944 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1292
    $P2946 = $P2942."!make"($P2945)
.annotate 'line', 1291
    .return ($P2946)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("157_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2948
    .param pmc param_2949
.annotate 'line', 1297
    .lex "self", param_2948
    .lex "$/", param_2949
.annotate 'line', 1298
    find_lex $P2950, "$/"
    get_hll_global $P2951, ["PAST"], "Op"
.annotate 'line', 1299
    new $P2952, "ResizablePMCArray"
    push $P2952, "    clone %r, %0"
    push $P2952, "    dec %0"
    $P2953 = $P2951."new"("postfix:<-->" :named("name"), $P2952 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1298
    $P2954 = $P2950."!make"($P2953)
.annotate 'line', 1297
    .return ($P2954)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("158_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2956
    .param pmc param_2957
.annotate 'line', 1303
    .lex "self", param_2956
    .lex "$/", param_2957
.annotate 'line', 1304
    find_lex $P2958, "$/"
    get_hll_global $P2959, ["PAST"], "Op"
.annotate 'line', 1305
    get_hll_global $P2960, ["PAST"], "Var"
    $P2961 = $P2960."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2962, "$/"
    $P2963 = $P2959."new"($P2961, "callmethod" :named("pasttype"), "!make" :named("name"), $P2962 :named("node"))
.annotate 'line', 1304
    $P2964 = $P2958."!make"($P2963)
.annotate 'line', 1303
    .return ($P2964)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("159_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2967
    .param pmc param_2968
.annotate 'line', 1321
    .lex "self", param_2967
    .lex "$/", param_2968
    find_lex $P2969, "$/"
    $P2970 = "control"($P2969, "CONTROL_LOOP_NEXT")
    .return ($P2970)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("160_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2972
    .param pmc param_2973
.annotate 'line', 1322
    .lex "self", param_2972
    .lex "$/", param_2973
    find_lex $P2974, "$/"
    $P2975 = "control"($P2974, "CONTROL_LOOP_LAST")
    .return ($P2975)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("161_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2977
    .param pmc param_2978
.annotate 'line', 1323
    .lex "self", param_2977
    .lex "$/", param_2978
    find_lex $P2979, "$/"
    $P2980 = "control"($P2979, "CONTROL_LOOP_REDO")
    .return ($P2980)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("162_1300060192.103") :outer("11_1300060192.103")
    .param pmc param_2982
    .param pmc param_2983
.annotate 'line', 1325
    .lex "self", param_2982
    .lex "$/", param_2983
.annotate 'line', 1326
    find_lex $P2984, "$/"
    get_hll_global $P2985, ["PAST"], "Op"
    find_lex $P2986, "$/"
    $P2987 = $P2985."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2986 :named("node"))
    $P2988 = $P2984."!make"($P2987)
.annotate 'line', 1325
    .return ($P2988)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block3213"  :subid("164_1300060192.103") :outer("10_1300060192.103")
.annotate 'line', 1330
    .const 'Sub' $P3313 = "172_1300060192.103" 
    capture_lex $P3313
    .const 'Sub' $P3288 = "171_1300060192.103" 
    capture_lex $P3288
    .const 'Sub' $P3277 = "170_1300060192.103" 
    capture_lex $P3277
    .const 'Sub' $P3262 = "169_1300060192.103" 
    capture_lex $P3262
    .const 'Sub' $P3251 = "168_1300060192.103" 
    capture_lex $P3251
    .const 'Sub' $P3240 = "167_1300060192.103" 
    capture_lex $P3240
    .const 'Sub' $P3229 = "166_1300060192.103" 
    capture_lex $P3229
    .const 'Sub' $P3216 = "165_1300060192.103" 
    capture_lex $P3216
    get_global $P3215, "$?CLASS"
.annotate 'line', 1364
    .const 'Sub' $P3288 = "171_1300060192.103" 
    newclosure $P3311, $P3288
.annotate 'line', 1330
    .return ($P3311)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post916") :outer("164_1300060192.103")
.annotate 'line', 1330
    get_hll_global $P3214, ["NQP";"RegexActions"], "_block3213" 
    .local pmc block
    set block, $P3214
    .const 'Sub' $P3313 = "172_1300060192.103" 
    capture_lex $P3313
    $P3313()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block3312"  :anon :subid("172_1300060192.103") :outer("164_1300060192.103")
.annotate 'line', 1330
    nqp_get_sc_object $P3314, "1300060181.184", 1
    .local pmc type_obj
    set type_obj, $P3314
    set_global "$?CLASS", type_obj
    get_how $P3315, type_obj
    .const 'Sub' $P3316 = "165_1300060192.103" 
    $P3315."add_method"(type_obj, "metachar:sym<:my>", $P3316)
    get_how $P3317, type_obj
    .const 'Sub' $P3318 = "166_1300060192.103" 
    $P3317."add_method"(type_obj, "metachar:sym<{ }>", $P3318)
    get_how $P3319, type_obj
    .const 'Sub' $P3320 = "167_1300060192.103" 
    $P3319."add_method"(type_obj, "metachar:sym<nqpvar>", $P3320)
    get_how $P3321, type_obj
    .const 'Sub' $P3322 = "168_1300060192.103" 
    $P3321."add_method"(type_obj, "assertion:sym<{ }>", $P3322)
    get_how $P3323, type_obj
    .const 'Sub' $P3324 = "169_1300060192.103" 
    $P3323."add_method"(type_obj, "assertion:sym<?{ }>", $P3324)
    get_how $P3325, type_obj
    .const 'Sub' $P3326 = "170_1300060192.103" 
    $P3325."add_method"(type_obj, "assertion:sym<var>", $P3326)
    get_how $P3327, type_obj
    .const 'Sub' $P3328 = "171_1300060192.103" 
    $P3327."add_method"(type_obj, "codeblock", $P3328)
    get_how $P3329, type_obj
    get_hll_global $P3330, ["Regex";"P6Regex"], "Actions"
    $P3329."add_parent"(type_obj, $P3330)
    get_how $P3331, type_obj
    $P3332 = $P3331."compose"(type_obj)
    .return ($P3332)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("165_1300060192.103") :outer("164_1300060192.103")
    .param pmc param_3217
    .param pmc param_3218
.annotate 'line', 1332
    .lex "self", param_3217
    .lex "$/", param_3218
.annotate 'line', 1333
    new $P3219, "Undef"
    .lex "$past", $P3219
    find_lex $P3220, "$/"
    unless_null $P3220, vivify_917
    $P3220 = root_new ['parrot';'Hash']
  vivify_917:
    set $P3221, $P3220["statement"]
    unless_null $P3221, vivify_918
    new $P3221, "Undef"
  vivify_918:
    $P3222 = $P3221."ast"()
    store_lex "$past", $P3222
.annotate 'line', 1334
    find_lex $P3223, "$/"
    get_hll_global $P3224, ["PAST"], "Regex"
    find_lex $P3225, "$past"
    find_lex $P3226, "$/"
    $P3227 = $P3224."new"($P3225, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P3226 :named("node"))
    $P3228 = $P3223."!make"($P3227)
.annotate 'line', 1332
    .return ($P3228)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("166_1300060192.103") :outer("164_1300060192.103")
    .param pmc param_3230
    .param pmc param_3231
.annotate 'line', 1338
    .lex "self", param_3230
    .lex "$/", param_3231
.annotate 'line', 1339
    find_lex $P3232, "$/"
    get_hll_global $P3233, ["PAST"], "Regex"
    find_lex $P3234, "$/"
    unless_null $P3234, vivify_919
    $P3234 = root_new ['parrot';'Hash']
  vivify_919:
    set $P3235, $P3234["codeblock"]
    unless_null $P3235, vivify_920
    new $P3235, "Undef"
  vivify_920:
    $P3236 = $P3235."ast"()
    find_lex $P3237, "$/"
    $P3238 = $P3233."new"($P3236, "pastnode" :named("pasttype"), $P3237 :named("node"))
    $P3239 = $P3232."!make"($P3238)
.annotate 'line', 1338
    .return ($P3239)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("167_1300060192.103") :outer("164_1300060192.103")
    .param pmc param_3241
    .param pmc param_3242
.annotate 'line', 1343
    .lex "self", param_3241
    .lex "$/", param_3242
.annotate 'line', 1344
    find_lex $P3243, "$/"
    get_hll_global $P3244, ["PAST"], "Regex"
    find_lex $P3245, "$/"
    unless_null $P3245, vivify_921
    $P3245 = root_new ['parrot';'Hash']
  vivify_921:
    set $P3246, $P3245["var"]
    unless_null $P3246, vivify_922
    new $P3246, "Undef"
  vivify_922:
    $P3247 = $P3246."ast"()
    find_lex $P3248, "$/"
    $P3249 = $P3244."new"("!INTERPOLATE", $P3247, "subrule" :named("pasttype"), "method" :named("subtype"), $P3248 :named("node"))
    $P3250 = $P3243."!make"($P3249)
.annotate 'line', 1343
    .return ($P3250)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("168_1300060192.103") :outer("164_1300060192.103")
    .param pmc param_3252
    .param pmc param_3253
.annotate 'line', 1348
    .lex "self", param_3252
    .lex "$/", param_3253
.annotate 'line', 1349
    find_lex $P3254, "$/"
    get_hll_global $P3255, ["PAST"], "Regex"
    find_lex $P3256, "$/"
    unless_null $P3256, vivify_923
    $P3256 = root_new ['parrot';'Hash']
  vivify_923:
    set $P3257, $P3256["codeblock"]
    unless_null $P3257, vivify_924
    new $P3257, "Undef"
  vivify_924:
    $P3258 = $P3257."ast"()
    find_lex $P3259, "$/"
    $P3260 = $P3255."new"("!INTERPOLATE_REGEX", $P3258, "subrule" :named("pasttype"), "method" :named("subtype"), $P3259 :named("node"))
    $P3261 = $P3254."!make"($P3260)
.annotate 'line', 1348
    .return ($P3261)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("169_1300060192.103") :outer("164_1300060192.103")
    .param pmc param_3263
    .param pmc param_3264
.annotate 'line', 1353
    .lex "self", param_3263
    .lex "$/", param_3264
.annotate 'line', 1354
    find_lex $P3265, "$/"
    get_hll_global $P3266, ["PAST"], "Regex"
    find_lex $P3267, "$/"
    unless_null $P3267, vivify_925
    $P3267 = root_new ['parrot';'Hash']
  vivify_925:
    set $P3268, $P3267["codeblock"]
    unless_null $P3268, vivify_926
    new $P3268, "Undef"
  vivify_926:
    $P3269 = $P3268."ast"()
.annotate 'line', 1355
    find_lex $P3270, "$/"
    unless_null $P3270, vivify_927
    $P3270 = root_new ['parrot';'Hash']
  vivify_927:
    set $P3271, $P3270["zw"]
    unless_null $P3271, vivify_928
    new $P3271, "Undef"
  vivify_928:
    set $S3272, $P3271
    iseq $I3273, $S3272, "!"
    find_lex $P3274, "$/"
    $P3275 = $P3266."new"($P3269, "zerowidth" :named("subtype"), $I3273 :named("negate"), "pastnode" :named("pasttype"), $P3274 :named("node"))
.annotate 'line', 1354
    $P3276 = $P3265."!make"($P3275)
.annotate 'line', 1353
    .return ($P3276)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("170_1300060192.103") :outer("164_1300060192.103")
    .param pmc param_3278
    .param pmc param_3279
.annotate 'line', 1359
    .lex "self", param_3278
    .lex "$/", param_3279
.annotate 'line', 1360
    find_lex $P3280, "$/"
    get_hll_global $P3281, ["PAST"], "Regex"
    find_lex $P3282, "$/"
    unless_null $P3282, vivify_929
    $P3282 = root_new ['parrot';'Hash']
  vivify_929:
    set $P3283, $P3282["var"]
    unless_null $P3283, vivify_930
    new $P3283, "Undef"
  vivify_930:
    $P3284 = $P3283."ast"()
    find_lex $P3285, "$/"
    $P3286 = $P3281."new"("!INTERPOLATE_REGEX", $P3284, "subrule" :named("pasttype"), "method" :named("subtype"), $P3285 :named("node"))
    $P3287 = $P3280."!make"($P3286)
.annotate 'line', 1359
    .return ($P3287)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("171_1300060192.103") :outer("164_1300060192.103")
    .param pmc param_3289
    .param pmc param_3290
.annotate 'line', 1364
    .lex "self", param_3289
    .lex "$/", param_3290
.annotate 'line', 1365
    new $P3291, "Undef"
    .lex "$block", $P3291
.annotate 'line', 1367
    new $P3292, "Undef"
    .lex "$past", $P3292
.annotate 'line', 1365
    find_lex $P3293, "$/"
    unless_null $P3293, vivify_931
    $P3293 = root_new ['parrot';'Hash']
  vivify_931:
    set $P3294, $P3293["block"]
    unless_null $P3294, vivify_932
    new $P3294, "Undef"
  vivify_932:
    $P3295 = $P3294."ast"()
    store_lex "$block", $P3295
.annotate 'line', 1366
    find_lex $P3296, "$block"
    $P3296."blocktype"("immediate")
.annotate 'line', 1368
    get_hll_global $P3297, ["PAST"], "Stmts"
.annotate 'line', 1369
    get_hll_global $P3298, ["PAST"], "Op"
.annotate 'line', 1370
    get_hll_global $P3299, ["PAST"], "Var"
    $P3300 = $P3299."new"("$/" :named("name"))
.annotate 'line', 1371
    get_hll_global $P3301, ["PAST"], "Op"
.annotate 'line', 1372
    get_hll_global $P3302, ["PAST"], "Var"
    $P3303 = $P3302."new"(unicode:"$\x{a2}" :named("name"))
    $P3304 = $P3301."new"($P3303, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1371
    $P3305 = $P3298."new"($P3300, $P3304, "bind" :named("pasttype"))
.annotate 'line', 1369
    find_lex $P3306, "$block"
    $P3307 = $P3297."new"($P3305, $P3306)
.annotate 'line', 1368
    store_lex "$past", $P3307
.annotate 'line', 1380
    find_lex $P3308, "$/"
    find_lex $P3309, "$past"
    $P3310 = $P3308."!make"($P3309)
.annotate 'line', 1364
    .return ($P3310)
.end


.HLL "nqp"

.namespace []
.sub "_block3334" :load :anon :subid("173_1300060192.103")
.annotate 'line', 1
    .const 'Sub' $P3336 = "10_1300060192.103" 
    $P3337 = $P3336()
    .return ($P3337)
.end

### .include 'gen/nqp-compiler.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1300060194.556")
.annotate 'line', 0
    get_hll_global $P14, ["NQP";"Compiler"], "_block13" 
    capture_lex $P14
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P14, ["NQP";"Compiler"], "_block13" 
    capture_lex $P14
    $P23 = $P14()
    .return ($P23)
    .const 'Sub' $P25 = "13_1300060194.556" 
    .return ($P25)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post14") :outer("10_1300060194.556")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1300060194.556" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P29, "1300060194.543"
    isnull $I30, $P29
    if $I30, if_28
    nqp_get_sc_object $P40, "1300060194.543", 0
    set_hll_global ["NQP"], "Compiler", $P40
    goto if_28_end
  if_28:
    nqp_dynop_setup 
    getinterp $P31
    get_class $P32, "LexPad"
    get_class $P33, "NQPLexPad"
    $P31."hll_map"($P32, $P33)
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P34, "1300060194.543"
    .local pmc cur_sc
    set cur_sc, $P34
    load_bytecode "SettingManager.pbc"
    get_hll_global $P35, ["HLL"], "SettingManager"
    $P36 = $P35."load_setting"("NQPCORE")
    block."set_outer_ctx"($P36)
    get_hll_global $P37, "NQPClassHOW"
    $P38 = $P37."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P38, cur_sc
    nqp_set_sc_object "1300060194.543", 0, $P38
    nqp_get_sc_object $P39, "1300060194.543", 0
    set_hll_global ["NQP"], "Compiler", $P39
  if_28_end:
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block13"  :subid("11_1300060194.556") :outer("10_1300060194.556")
.annotate 'line', 1
    .const 'Sub' $P17 = "12_1300060194.556" 
    capture_lex $P17
    get_global $P15, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post15") :outer("11_1300060194.556")
.annotate 'line', 1
    get_hll_global $P14, ["NQP";"Compiler"], "_block13" 
    .local pmc block
    set block, $P14
    .const 'Sub' $P17 = "12_1300060194.556" 
    capture_lex $P17
    $P17()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block16"  :anon :subid("12_1300060194.556") :outer("11_1300060194.556")
.annotate 'line', 1
    nqp_get_sc_object $P18, "1300060194.543", 0
    .local pmc type_obj
    set type_obj, $P18
    set_global "$?CLASS", type_obj
    get_how $P19, type_obj
    get_hll_global $P20, ["HLL"], "Compiler"
    $P19."add_parent"(type_obj, $P20)
    get_how $P21, type_obj
    $P22 = $P21."compose"(type_obj)
    .return ($P22)
.end


.HLL "nqp"

.namespace []
.sub "_block24" :load :anon :subid("13_1300060194.556")
.annotate 'line', 1
    .const 'Sub' $P26 = "10_1300060194.556" 
    $P27 = $P26()
    .return ($P27)
.end


.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('nqp')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
    push $P0, 'setting=s'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'nqp'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
