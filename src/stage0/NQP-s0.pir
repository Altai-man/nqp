
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1303748459.273")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P7323 = "582_1303748459.273" 
    capture_lex $P7323
    .const 'Sub' $P7171 = "573_1303748459.273" 
    capture_lex $P7171
    .const 'Sub' $P2753 = "406_1303748459.273" 
    capture_lex $P2753
    .const 'Sub' $P2651 = "384_1303748459.273" 
    capture_lex $P2651
    .const 'Sub' $P47 = "12_1303748459.273" 
    capture_lex $P47
    .const 'Sub' $P16 = "11_1303748459.273" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2319
    .const 'Sub' $P16 = "11_1303748459.273" 
    newclosure $P45, $P16
    .lex "MAIN", $P45
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1303748459.273" 
    capture_lex $P47
    $P47()
.annotate 'line', 724
    .const 'Sub' $P2651 = "384_1303748459.273" 
    capture_lex $P2651
    $P2651()
.annotate 'line', 767
    .const 'Sub' $P2753 = "406_1303748459.273" 
    capture_lex $P2753
    $P2753()
.annotate 'line', 2261
    .const 'Sub' $P7171 = "573_1303748459.273" 
    capture_lex $P7171
    $P7171()
.annotate 'line', 2316
    .const 'Sub' $P7323 = "582_1303748459.273" 
    capture_lex $P7323
    $P7323()
    find_lex $P7331, "MAIN"
    find_lex $P7334, "@ARGS"
    if $P7334, if_7333
    set $P7332, $P7334
    goto if_7333_end
  if_7333:
    .const 'Sub' $P7335 = "11_1303748459.273" 
    find_lex $P7336, "@ARGS"
    $P7337 = $P7335($P7336 :flat)
    set $P7332, $P7337
  if_7333_end:
.annotate 'line', 1
    .return ($P7332)
    .const 'Sub' $P7339 = "584_1303748459.273" 
    .return ($P7339)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post585") :outer("10_1303748459.273")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1303748459.273" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P7343, "1303748446.727"
    isnull $I7344, $P7343
    if $I7344, if_7342
    .const 'Sub' $P7472 = "10_1303748459.273" 
    $P7473 = $P7472."get_lexinfo"()
    nqp_get_sc_object $P7474, "1303748446.727", 0
    $P7473."set_static_lexpad_value"("GLOBALish", $P7474)
    .const 'Sub' $P7475 = "10_1303748459.273" 
    $P7476 = $P7475."get_lexinfo"()
    $P7476."finish_static_lexpad"()
    .const 'Sub' $P7477 = "10_1303748459.273" 
    $P7478 = $P7477."get_lexinfo"()
    nqp_get_sc_object $P7479, "1303748446.727", 0
    $P7478."set_static_lexpad_value"("$?PACKAGE", $P7479)
    .const 'Sub' $P7480 = "10_1303748459.273" 
    $P7481 = $P7480."get_lexinfo"()
    $P7481."finish_static_lexpad"()
    nqp_get_sc_object $P7482, "1303748446.727", 1
    set_hll_global ["NQP"], "Grammar", $P7482
    .const 'Sub' $P7483 = "12_1303748459.273" 
    $P7484 = $P7483."get_lexinfo"()
    nqp_get_sc_object $P7485, "1303748446.727", 1
    $P7484."set_static_lexpad_value"("$?PACKAGE", $P7485)
    .const 'Sub' $P7486 = "12_1303748459.273" 
    $P7487 = $P7486."get_lexinfo"()
    $P7487."finish_static_lexpad"()
    .const 'Sub' $P7488 = "12_1303748459.273" 
    $P7489 = $P7488."get_lexinfo"()
    nqp_get_sc_object $P7490, "1303748446.727", 1
    $P7489."set_static_lexpad_value"("$?CLASS", $P7490)
    .const 'Sub' $P7491 = "12_1303748459.273" 
    $P7492 = $P7491."get_lexinfo"()
    $P7492."finish_static_lexpad"()
    nqp_get_sc_object $P7493, "1303748446.727", 2
    set_hll_global ["NQP"], "Regex", $P7493
    .const 'Sub' $P7494 = "384_1303748459.273" 
    $P7495 = $P7494."get_lexinfo"()
    nqp_get_sc_object $P7496, "1303748446.727", 2
    $P7495."set_static_lexpad_value"("$?PACKAGE", $P7496)
    .const 'Sub' $P7497 = "384_1303748459.273" 
    $P7498 = $P7497."get_lexinfo"()
    $P7498."finish_static_lexpad"()
    .const 'Sub' $P7499 = "384_1303748459.273" 
    $P7500 = $P7499."get_lexinfo"()
    nqp_get_sc_object $P7501, "1303748446.727", 2
    $P7500."set_static_lexpad_value"("$?CLASS", $P7501)
    .const 'Sub' $P7502 = "384_1303748459.273" 
    $P7503 = $P7502."get_lexinfo"()
    $P7503."finish_static_lexpad"()
    nqp_get_sc_object $P7504, "1303748446.727", 3
    set_hll_global ["NQP"], "Actions", $P7504
    .const 'Sub' $P7505 = "406_1303748459.273" 
    $P7506 = $P7505."get_lexinfo"()
    nqp_get_sc_object $P7507, "1303748446.727", 3
    $P7506."set_static_lexpad_value"("$?PACKAGE", $P7507)
    .const 'Sub' $P7508 = "406_1303748459.273" 
    $P7509 = $P7508."get_lexinfo"()
    $P7509."finish_static_lexpad"()
    .const 'Sub' $P7510 = "406_1303748459.273" 
    $P7511 = $P7510."get_lexinfo"()
    nqp_get_sc_object $P7512, "1303748446.727", 3
    $P7511."set_static_lexpad_value"("$?CLASS", $P7512)
    .const 'Sub' $P7513 = "406_1303748459.273" 
    $P7514 = $P7513."get_lexinfo"()
    $P7514."finish_static_lexpad"()
    nqp_get_sc_object $P7515, "1303748446.727", 4
    set_hll_global ["NQP"], "RegexActions", $P7515
    .const 'Sub' $P7516 = "573_1303748459.273" 
    $P7517 = $P7516."get_lexinfo"()
    nqp_get_sc_object $P7518, "1303748446.727", 4
    $P7517."set_static_lexpad_value"("$?PACKAGE", $P7518)
    .const 'Sub' $P7519 = "573_1303748459.273" 
    $P7520 = $P7519."get_lexinfo"()
    $P7520."finish_static_lexpad"()
    .const 'Sub' $P7521 = "573_1303748459.273" 
    $P7522 = $P7521."get_lexinfo"()
    nqp_get_sc_object $P7523, "1303748446.727", 4
    $P7522."set_static_lexpad_value"("$?CLASS", $P7523)
    .const 'Sub' $P7524 = "573_1303748459.273" 
    $P7525 = $P7524."get_lexinfo"()
    $P7525."finish_static_lexpad"()
    nqp_get_sc_object $P7526, "1303748446.727", 5
    set_hll_global ["NQP"], "Compiler", $P7526
    .const 'Sub' $P7527 = "582_1303748459.273" 
    $P7528 = $P7527."get_lexinfo"()
    nqp_get_sc_object $P7529, "1303748446.727", 5
    $P7528."set_static_lexpad_value"("$?PACKAGE", $P7529)
    .const 'Sub' $P7530 = "582_1303748459.273" 
    $P7531 = $P7530."get_lexinfo"()
    $P7531."finish_static_lexpad"()
    .const 'Sub' $P7532 = "582_1303748459.273" 
    $P7533 = $P7532."get_lexinfo"()
    nqp_get_sc_object $P7534, "1303748446.727", 5
    $P7533."set_static_lexpad_value"("$?CLASS", $P7534)
    .const 'Sub' $P7535 = "582_1303748459.273" 
    $P7536 = $P7535."get_lexinfo"()
    $P7536."finish_static_lexpad"()
    goto if_7342_end
  if_7342:
    nqp_dynop_setup 
    getinterp $P7345
    get_class $P7346, "LexPad"
    get_class $P7347, "NQPLexPad"
    $P7345."hll_map"($P7346, $P7347)
    nqp_create_sc $P7348, "1303748446.727"
    .local pmc cur_sc
    set cur_sc, $P7348
    nqp_get_sc_object $P7349, "__6MODEL_CORE__", 0
    $P7350 = $P7349."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P7350, cur_sc
    nqp_set_sc_object "1303748446.727", 0, $P7350
    .const 'Sub' $P7351 = "10_1303748459.273" 
    $P7352 = $P7351."get_lexinfo"()
    nqp_get_sc_object $P7353, "1303748446.727", 0
    $P7352."set_static_lexpad_value"("GLOBALish", $P7353)
    .const 'Sub' $P7354 = "10_1303748459.273" 
    $P7355 = $P7354."get_lexinfo"()
    $P7355."finish_static_lexpad"()
    .const 'Sub' $P7356 = "10_1303748459.273" 
    $P7357 = $P7356."get_lexinfo"()
    nqp_get_sc_object $P7358, "1303748446.727", 0
    $P7357."set_static_lexpad_value"("$?PACKAGE", $P7358)
    .const 'Sub' $P7359 = "10_1303748459.273" 
    $P7360 = $P7359."get_lexinfo"()
    $P7360."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7361, "ModuleLoader"
    $P7362 = $P7361."load_setting"("NQPCORE")
    block."set_outer_ctx"($P7362)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7363, "ModuleLoader"
    nqp_get_sc_object $P7364, "1303748446.727", 0
    $P7363."load_module"("Regex", $P7364)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7365, "ModuleLoader"
    nqp_get_sc_object $P7366, "1303748446.727", 0
    $P7365."load_module"("P6Regex", $P7366)
    nqp_get_sc_object $P7367, "1303748421.926", 6
    $P7368 = $P7367."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P7368, cur_sc
    nqp_set_sc_object "1303748446.727", 1, $P7368
    nqp_get_sc_object $P7369, "1303748446.727", 1
    nqp_get_sc_object $P7370, "1303748446.727", 0
    nqp_get_package_through_who $P7371, $P7370, "NQP"
    get_who $P7372, $P7371
    set $P7372["Grammar"], $P7369
    nqp_get_sc_object $P7373, "1303748446.727", 1
    set_hll_global ["NQP"], "Grammar", $P7373
    .const 'Sub' $P7374 = "12_1303748459.273" 
    $P7375 = $P7374."get_lexinfo"()
    nqp_get_sc_object $P7376, "1303748446.727", 1
    $P7375."set_static_lexpad_value"("$?PACKAGE", $P7376)
    .const 'Sub' $P7377 = "12_1303748459.273" 
    $P7378 = $P7377."get_lexinfo"()
    $P7378."finish_static_lexpad"()
    .const 'Sub' $P7379 = "12_1303748459.273" 
    $P7380 = $P7379."get_lexinfo"()
    nqp_get_sc_object $P7381, "1303748446.727", 1
    $P7380."set_static_lexpad_value"("$?CLASS", $P7381)
    .const 'Sub' $P7382 = "12_1303748459.273" 
    $P7383 = $P7382."get_lexinfo"()
    $P7383."finish_static_lexpad"()
    nqp_get_sc_object $P7384, "1303748446.727", 1
    get_how $P7385, $P7384
    nqp_get_sc_object $P7386, "1303748446.727", 1
    nqp_get_sc_object $P7387, "1303748429.183", 1
    $P7385."add_parent"($P7386, $P7387)
    nqp_get_sc_object $P7388, "1303748421.926", 6
    $P7389 = $P7388."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P7389, cur_sc
    nqp_set_sc_object "1303748446.727", 2, $P7389
    nqp_get_sc_object $P7390, "1303748446.727", 2
    nqp_get_sc_object $P7391, "1303748446.727", 0
    nqp_get_package_through_who $P7392, $P7391, "NQP"
    get_who $P7393, $P7392
    set $P7393["Regex"], $P7390
    nqp_get_sc_object $P7394, "1303748446.727", 2
    set_hll_global ["NQP"], "Regex", $P7394
    .const 'Sub' $P7395 = "384_1303748459.273" 
    $P7396 = $P7395."get_lexinfo"()
    nqp_get_sc_object $P7397, "1303748446.727", 2
    $P7396."set_static_lexpad_value"("$?PACKAGE", $P7397)
    .const 'Sub' $P7398 = "384_1303748459.273" 
    $P7399 = $P7398."get_lexinfo"()
    $P7399."finish_static_lexpad"()
    .const 'Sub' $P7400 = "384_1303748459.273" 
    $P7401 = $P7400."get_lexinfo"()
    nqp_get_sc_object $P7402, "1303748446.727", 2
    $P7401."set_static_lexpad_value"("$?CLASS", $P7402)
    .const 'Sub' $P7403 = "384_1303748459.273" 
    $P7404 = $P7403."get_lexinfo"()
    $P7404."finish_static_lexpad"()
    nqp_get_sc_object $P7405, "1303748446.727", 2
    get_how $P7406, $P7405
    nqp_get_sc_object $P7407, "1303748446.727", 2
    nqp_get_sc_object $P7408, "1303748440.034", 1
    $P7406."add_parent"($P7407, $P7408)
    nqp_get_sc_object $P7409, "1303748421.926", 6
    $P7410 = $P7409."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P7410, cur_sc
    nqp_set_sc_object "1303748446.727", 3, $P7410
    nqp_get_sc_object $P7411, "1303748446.727", 3
    nqp_get_sc_object $P7412, "1303748446.727", 0
    nqp_get_package_through_who $P7413, $P7412, "NQP"
    get_who $P7414, $P7413
    set $P7414["Actions"], $P7411
    nqp_get_sc_object $P7415, "1303748446.727", 3
    set_hll_global ["NQP"], "Actions", $P7415
    .const 'Sub' $P7416 = "406_1303748459.273" 
    $P7417 = $P7416."get_lexinfo"()
    nqp_get_sc_object $P7418, "1303748446.727", 3
    $P7417."set_static_lexpad_value"("$?PACKAGE", $P7418)
    .const 'Sub' $P7419 = "406_1303748459.273" 
    $P7420 = $P7419."get_lexinfo"()
    $P7420."finish_static_lexpad"()
    .const 'Sub' $P7421 = "406_1303748459.273" 
    $P7422 = $P7421."get_lexinfo"()
    nqp_get_sc_object $P7423, "1303748446.727", 3
    $P7422."set_static_lexpad_value"("$?CLASS", $P7423)
    .const 'Sub' $P7424 = "406_1303748459.273" 
    $P7425 = $P7424."get_lexinfo"()
    $P7425."finish_static_lexpad"()
    nqp_get_sc_object $P7426, "1303748446.727", 3
    get_how $P7427, $P7426
    nqp_get_sc_object $P7428, "1303748446.727", 3
    nqp_get_sc_object $P7429, "1303748429.183", 2
    $P7427."add_parent"($P7428, $P7429)
    nqp_get_sc_object $P7430, "1303748421.926", 6
    $P7431 = $P7430."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P7431, cur_sc
    nqp_set_sc_object "1303748446.727", 4, $P7431
    nqp_get_sc_object $P7432, "1303748446.727", 4
    nqp_get_sc_object $P7433, "1303748446.727", 0
    nqp_get_package_through_who $P7434, $P7433, "NQP"
    get_who $P7435, $P7434
    set $P7435["RegexActions"], $P7432
    nqp_get_sc_object $P7436, "1303748446.727", 4
    set_hll_global ["NQP"], "RegexActions", $P7436
    .const 'Sub' $P7437 = "573_1303748459.273" 
    $P7438 = $P7437."get_lexinfo"()
    nqp_get_sc_object $P7439, "1303748446.727", 4
    $P7438."set_static_lexpad_value"("$?PACKAGE", $P7439)
    .const 'Sub' $P7440 = "573_1303748459.273" 
    $P7441 = $P7440."get_lexinfo"()
    $P7441."finish_static_lexpad"()
    .const 'Sub' $P7442 = "573_1303748459.273" 
    $P7443 = $P7442."get_lexinfo"()
    nqp_get_sc_object $P7444, "1303748446.727", 4
    $P7443."set_static_lexpad_value"("$?CLASS", $P7444)
    .const 'Sub' $P7445 = "573_1303748459.273" 
    $P7446 = $P7445."get_lexinfo"()
    $P7446."finish_static_lexpad"()
    nqp_get_sc_object $P7447, "1303748446.727", 4
    get_how $P7448, $P7447
    nqp_get_sc_object $P7449, "1303748446.727", 4
    nqp_get_sc_object $P7450, "1303748440.034", 2
    $P7448."add_parent"($P7449, $P7450)
    nqp_get_sc_object $P7451, "1303748421.926", 6
    $P7452 = $P7451."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P7452, cur_sc
    nqp_set_sc_object "1303748446.727", 5, $P7452
    nqp_get_sc_object $P7453, "1303748446.727", 5
    nqp_get_sc_object $P7454, "1303748446.727", 0
    nqp_get_package_through_who $P7455, $P7454, "NQP"
    get_who $P7456, $P7455
    set $P7456["Compiler"], $P7453
    nqp_get_sc_object $P7457, "1303748446.727", 5
    set_hll_global ["NQP"], "Compiler", $P7457
    .const 'Sub' $P7458 = "582_1303748459.273" 
    $P7459 = $P7458."get_lexinfo"()
    nqp_get_sc_object $P7460, "1303748446.727", 5
    $P7459."set_static_lexpad_value"("$?PACKAGE", $P7460)
    .const 'Sub' $P7461 = "582_1303748459.273" 
    $P7462 = $P7461."get_lexinfo"()
    $P7462."finish_static_lexpad"()
    .const 'Sub' $P7463 = "582_1303748459.273" 
    $P7464 = $P7463."get_lexinfo"()
    nqp_get_sc_object $P7465, "1303748446.727", 5
    $P7464."set_static_lexpad_value"("$?CLASS", $P7465)
    .const 'Sub' $P7466 = "582_1303748459.273" 
    $P7467 = $P7466."get_lexinfo"()
    $P7467."finish_static_lexpad"()
    nqp_get_sc_object $P7468, "1303748446.727", 5
    get_how $P7469, $P7468
    nqp_get_sc_object $P7470, "1303748446.727", 5
    nqp_get_sc_object $P7471, "1303748429.183", 3
    $P7469."add_parent"($P7470, $P7471)
  if_7342_end:
    nqp_get_sc_object $P7537, "1303748446.727", 0
    set_hll_global "GLOBAL", $P7537
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1303748459.273") :outer("10_1303748459.273")
    .param pmc param_17
.annotate 'line', 2319
    .lex "@ARGS", param_17
.annotate 'line', 2321
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2327
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2321
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2322
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_586
    new $P25, "Undef"
  vivify_586:
    $P25."language"("nqp")
.annotate 'line', 2323
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_587
    new $P26, "Undef"
  vivify_587:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2324
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_588
    new $P31, "Undef"
  vivify_588:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2327
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_589
    new $P36, "Undef"
  vivify_589:
    $P37 = $P36."commandline_options"()
    store_lex "@clo", $P37
.annotate 'line', 2328
    find_lex $P38, "@clo"
    unless_null $P38, vivify_590
    $P38 = root_new ['parrot';'ResizablePMCArray']
  vivify_590:
    $P38."push"("parsetrace")
.annotate 'line', 2329
    find_lex $P39, "@clo"
    unless_null $P39, vivify_591
    $P39 = root_new ['parrot';'ResizablePMCArray']
  vivify_591:
    $P39."push"("setting=s")
.annotate 'line', 2330
    find_lex $P40, "@clo"
    unless_null $P40, vivify_592
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_592:
    $P40."push"("setting-path=s")
.annotate 'line', 2331
    find_lex $P41, "@clo"
    unless_null $P41, vivify_593
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_593:
    $P41."push"("module-path=s")
.annotate 'line', 2334
    find_lex $P42, "$nqpcomp"
    unless_null $P42, vivify_594
    new $P42, "Undef"
  vivify_594:
    find_lex $P43, "@ARGS"
    unless_null $P43, vivify_595
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_595:
    $P44 = $P42."command_line"($P43, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2319
    .return ($P44)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block46"  :subid("12_1303748459.273") :outer("10_1303748459.273")
.annotate 'line', 9
    .const 'Sub' $P1930 = "383_1303748459.273" 
    capture_lex $P1930
    .const 'Sub' $P1917 = "382_1303748459.273" 
    capture_lex $P1917
    .const 'Sub' $P1911 = "380_1303748459.273" 
    capture_lex $P1911
    .const 'Sub' $P1905 = "378_1303748459.273" 
    capture_lex $P1905
    .const 'Sub' $P1899 = "376_1303748459.273" 
    capture_lex $P1899
    .const 'Sub' $P1893 = "374_1303748459.273" 
    capture_lex $P1893
    .const 'Sub' $P1881 = "371_1303748459.273" 
    capture_lex $P1881
    .const 'Sub' $P1874 = "369_1303748459.273" 
    capture_lex $P1874
    .const 'Sub' $P1867 = "367_1303748459.273" 
    capture_lex $P1867
    .const 'Sub' $P1860 = "365_1303748459.273" 
    capture_lex $P1860
    .const 'Sub' $P1853 = "363_1303748459.273" 
    capture_lex $P1853
    .const 'Sub' $P1847 = "361_1303748459.273" 
    capture_lex $P1847
    .const 'Sub' $P1840 = "359_1303748459.273" 
    capture_lex $P1840
    .const 'Sub' $P1833 = "357_1303748459.273" 
    capture_lex $P1833
    .const 'Sub' $P1826 = "355_1303748459.273" 
    capture_lex $P1826
    .const 'Sub' $P1819 = "353_1303748459.273" 
    capture_lex $P1819
    .const 'Sub' $P1812 = "351_1303748459.273" 
    capture_lex $P1812
    .const 'Sub' $P1805 = "349_1303748459.273" 
    capture_lex $P1805
    .const 'Sub' $P1798 = "347_1303748459.273" 
    capture_lex $P1798
    .const 'Sub' $P1791 = "345_1303748459.273" 
    capture_lex $P1791
    .const 'Sub' $P1784 = "343_1303748459.273" 
    capture_lex $P1784
    .const 'Sub' $P1777 = "341_1303748459.273" 
    capture_lex $P1777
    .const 'Sub' $P1770 = "339_1303748459.273" 
    capture_lex $P1770
    .const 'Sub' $P1763 = "337_1303748459.273" 
    capture_lex $P1763
    .const 'Sub' $P1756 = "335_1303748459.273" 
    capture_lex $P1756
    .const 'Sub' $P1749 = "333_1303748459.273" 
    capture_lex $P1749
    .const 'Sub' $P1742 = "331_1303748459.273" 
    capture_lex $P1742
    .const 'Sub' $P1735 = "329_1303748459.273" 
    capture_lex $P1735
    .const 'Sub' $P1728 = "327_1303748459.273" 
    capture_lex $P1728
    .const 'Sub' $P1721 = "325_1303748459.273" 
    capture_lex $P1721
    .const 'Sub' $P1714 = "323_1303748459.273" 
    capture_lex $P1714
    .const 'Sub' $P1707 = "321_1303748459.273" 
    capture_lex $P1707
    .const 'Sub' $P1700 = "319_1303748459.273" 
    capture_lex $P1700
    .const 'Sub' $P1693 = "317_1303748459.273" 
    capture_lex $P1693
    .const 'Sub' $P1686 = "315_1303748459.273" 
    capture_lex $P1686
    .const 'Sub' $P1679 = "313_1303748459.273" 
    capture_lex $P1679
    .const 'Sub' $P1672 = "311_1303748459.273" 
    capture_lex $P1672
    .const 'Sub' $P1665 = "309_1303748459.273" 
    capture_lex $P1665
    .const 'Sub' $P1658 = "307_1303748459.273" 
    capture_lex $P1658
    .const 'Sub' $P1651 = "305_1303748459.273" 
    capture_lex $P1651
    .const 'Sub' $P1644 = "303_1303748459.273" 
    capture_lex $P1644
    .const 'Sub' $P1638 = "301_1303748459.273" 
    capture_lex $P1638
    .const 'Sub' $P1631 = "299_1303748459.273" 
    capture_lex $P1631
    .const 'Sub' $P1624 = "297_1303748459.273" 
    capture_lex $P1624
    .const 'Sub' $P1617 = "295_1303748459.273" 
    capture_lex $P1617
    .const 'Sub' $P1610 = "293_1303748459.273" 
    capture_lex $P1610
    .const 'Sub' $P1603 = "291_1303748459.273" 
    capture_lex $P1603
    .const 'Sub' $P1596 = "289_1303748459.273" 
    capture_lex $P1596
    .const 'Sub' $P1589 = "287_1303748459.273" 
    capture_lex $P1589
    .const 'Sub' $P1583 = "285_1303748459.273" 
    capture_lex $P1583
    .const 'Sub' $P1577 = "283_1303748459.273" 
    capture_lex $P1577
    .const 'Sub' $P1572 = "281_1303748459.273" 
    capture_lex $P1572
    .const 'Sub' $P1566 = "279_1303748459.273" 
    capture_lex $P1566
    .const 'Sub' $P1560 = "277_1303748459.273" 
    capture_lex $P1560
    .const 'Sub' $P1555 = "275_1303748459.273" 
    capture_lex $P1555
    .const 'Sub' $P1550 = "273_1303748459.273" 
    capture_lex $P1550
    .const 'Sub' $P1542 = "271_1303748459.273" 
    capture_lex $P1542
    .const 'Sub' $P1533 = "269_1303748459.273" 
    capture_lex $P1533
    .const 'Sub' $P1528 = "267_1303748459.273" 
    capture_lex $P1528
    .const 'Sub' $P1523 = "265_1303748459.273" 
    capture_lex $P1523
    .const 'Sub' $P1518 = "263_1303748459.273" 
    capture_lex $P1518
    .const 'Sub' $P1510 = "261_1303748459.273" 
    capture_lex $P1510
    .const 'Sub' $P1502 = "259_1303748459.273" 
    capture_lex $P1502
    .const 'Sub' $P1497 = "257_1303748459.273" 
    capture_lex $P1497
    .const 'Sub' $P1492 = "255_1303748459.273" 
    capture_lex $P1492
    .const 'Sub' $P1487 = "253_1303748459.273" 
    capture_lex $P1487
    .const 'Sub' $P1481 = "251_1303748459.273" 
    capture_lex $P1481
    .const 'Sub' $P1474 = "249_1303748459.273" 
    capture_lex $P1474
    .const 'Sub' $P1467 = "247_1303748459.273" 
    capture_lex $P1467
    .const 'Sub' $P1460 = "245_1303748459.273" 
    capture_lex $P1460
    .const 'Sub' $P1453 = "243_1303748459.273" 
    capture_lex $P1453
    .const 'Sub' $P1448 = "241_1303748459.273" 
    capture_lex $P1448
    .const 'Sub' $P1443 = "239_1303748459.273" 
    capture_lex $P1443
    .const 'Sub' $P1429 = "235_1303748459.273" 
    capture_lex $P1429
    .const 'Sub' $P1421 = "233_1303748459.273" 
    capture_lex $P1421
    .const 'Sub' $P1415 = "231_1303748459.273" 
    capture_lex $P1415
    .const 'Sub' $P1408 = "229_1303748459.273" 
    capture_lex $P1408
    .const 'Sub' $P1402 = "227_1303748459.273" 
    capture_lex $P1402
    .const 'Sub' $P1386 = "224_1303748459.273" 
    capture_lex $P1386
    .const 'Sub' $P1378 = "222_1303748459.273" 
    capture_lex $P1378
    .const 'Sub' $P1370 = "220_1303748459.273" 
    capture_lex $P1370
    .const 'Sub' $P1364 = "218_1303748459.273" 
    capture_lex $P1364
    .const 'Sub' $P1358 = "216_1303748459.273" 
    capture_lex $P1358
    .const 'Sub' $P1342 = "212_1303748459.273" 
    capture_lex $P1342
    .const 'Sub' $P1301 = "210_1303748459.273" 
    capture_lex $P1301
    .const 'Sub' $P1290 = "208_1303748459.273" 
    capture_lex $P1290
    .const 'Sub' $P1276 = "204_1303748459.273" 
    capture_lex $P1276
    .const 'Sub' $P1267 = "202_1303748459.273" 
    capture_lex $P1267
    .const 'Sub' $P1261 = "200_1303748459.273" 
    capture_lex $P1261
    .const 'Sub' $P1251 = "198_1303748459.273" 
    capture_lex $P1251
    .const 'Sub' $P1236 = "196_1303748459.273" 
    capture_lex $P1236
    .const 'Sub' $P1220 = "193_1303748459.273" 
    capture_lex $P1220
    .const 'Sub' $P1212 = "191_1303748459.273" 
    capture_lex $P1212
    .const 'Sub' $P1202 = "189_1303748459.273" 
    capture_lex $P1202
    .const 'Sub' $P1192 = "187_1303748459.273" 
    capture_lex $P1192
    .const 'Sub' $P1171 = "182_1303748459.273" 
    capture_lex $P1171
    .const 'Sub' $P1127 = "179_1303748459.273" 
    capture_lex $P1127
    .const 'Sub' $P1093 = "177_1303748459.273" 
    capture_lex $P1093
    .const 'Sub' $P1086 = "175_1303748459.273" 
    capture_lex $P1086
    .const 'Sub' $P1079 = "173_1303748459.273" 
    capture_lex $P1079
    .const 'Sub' $P1062 = "169_1303748459.273" 
    capture_lex $P1062
    .const 'Sub' $P1054 = "167_1303748459.273" 
    capture_lex $P1054
    .const 'Sub' $P1048 = "165_1303748459.273" 
    capture_lex $P1048
    .const 'Sub' $P1032 = "163_1303748459.273" 
    capture_lex $P1032
    .const 'Sub' $P1025 = "161_1303748459.273" 
    capture_lex $P1025
    .const 'Sub' $P1018 = "159_1303748459.273" 
    capture_lex $P1018
    .const 'Sub' $P1011 = "157_1303748459.273" 
    capture_lex $P1011
    .const 'Sub' $P833 = "152_1303748459.273" 
    capture_lex $P833
    .const 'Sub' $P814 = "150_1303748459.273" 
    capture_lex $P814
    .const 'Sub' $P795 = "148_1303748459.273" 
    capture_lex $P795
    .const 'Sub' $P776 = "146_1303748459.273" 
    capture_lex $P776
    .const 'Sub' $P757 = "144_1303748459.273" 
    capture_lex $P757
    .const 'Sub' $P738 = "142_1303748459.273" 
    capture_lex $P738
    .const 'Sub' $P719 = "140_1303748459.273" 
    capture_lex $P719
    .const 'Sub' $P708 = "136_1303748459.273" 
    capture_lex $P708
    .const 'Sub' $P703 = "134_1303748459.273" 
    capture_lex $P703
    .const 'Sub' $P691 = "132_1303748459.273" 
    capture_lex $P691
    .const 'Sub' $P679 = "130_1303748459.273" 
    capture_lex $P679
    .const 'Sub' $P672 = "128_1303748459.273" 
    capture_lex $P672
    .const 'Sub' $P667 = "126_1303748459.273" 
    capture_lex $P667
    .const 'Sub' $P661 = "124_1303748459.273" 
    capture_lex $P661
    .const 'Sub' $P655 = "122_1303748459.273" 
    capture_lex $P655
    .const 'Sub' $P640 = "118_1303748459.273" 
    capture_lex $P640
    .const 'Sub' $P634 = "116_1303748459.273" 
    capture_lex $P634
    .const 'Sub' $P628 = "114_1303748459.273" 
    capture_lex $P628
    .const 'Sub' $P622 = "112_1303748459.273" 
    capture_lex $P622
    .const 'Sub' $P616 = "110_1303748459.273" 
    capture_lex $P616
    .const 'Sub' $P610 = "108_1303748459.273" 
    capture_lex $P610
    .const 'Sub' $P604 = "106_1303748459.273" 
    capture_lex $P604
    .const 'Sub' $P595 = "104_1303748459.273" 
    capture_lex $P595
    .const 'Sub' $P586 = "102_1303748459.273" 
    capture_lex $P586
    .const 'Sub' $P577 = "100_1303748459.273" 
    capture_lex $P577
    .const 'Sub' $P562 = "96_1303748459.273" 
    capture_lex $P562
    .const 'Sub' $P553 = "94_1303748459.273" 
    capture_lex $P553
    .const 'Sub' $P541 = "90_1303748459.273" 
    capture_lex $P541
    .const 'Sub' $P534 = "88_1303748459.273" 
    capture_lex $P534
    .const 'Sub' $P527 = "86_1303748459.273" 
    capture_lex $P527
    .const 'Sub' $P513 = "82_1303748459.273" 
    capture_lex $P513
    .const 'Sub' $P505 = "80_1303748459.273" 
    capture_lex $P505
    .const 'Sub' $P497 = "78_1303748459.273" 
    capture_lex $P497
    .const 'Sub' $P477 = "76_1303748459.273" 
    capture_lex $P477
    .const 'Sub' $P468 = "74_1303748459.273" 
    capture_lex $P468
    .const 'Sub' $P450 = "71_1303748459.273" 
    capture_lex $P450
    .const 'Sub' $P432 = "69_1303748459.273" 
    capture_lex $P432
    .const 'Sub' $P424 = "67_1303748459.273" 
    capture_lex $P424
    .const 'Sub' $P413 = "63_1303748459.273" 
    capture_lex $P413
    .const 'Sub' $P408 = "61_1303748459.273" 
    capture_lex $P408
    .const 'Sub' $P397 = "57_1303748459.273" 
    capture_lex $P397
    .const 'Sub' $P392 = "55_1303748459.273" 
    capture_lex $P392
    .const 'Sub' $P387 = "53_1303748459.273" 
    capture_lex $P387
    .const 'Sub' $P382 = "51_1303748459.273" 
    capture_lex $P382
    .const 'Sub' $P377 = "49_1303748459.273" 
    capture_lex $P377
    .const 'Sub' $P367 = "47_1303748459.273" 
    capture_lex $P367
    .const 'Sub' $P360 = "45_1303748459.273" 
    capture_lex $P360
    .const 'Sub' $P354 = "43_1303748459.273" 
    capture_lex $P354
    .const 'Sub' $P346 = "41_1303748459.273" 
    capture_lex $P346
    .const 'Sub' $P340 = "39_1303748459.273" 
    capture_lex $P340
    .const 'Sub' $P334 = "37_1303748459.273" 
    capture_lex $P334
    .const 'Sub' $P319 = "34_1303748459.273" 
    capture_lex $P319
    .const 'Sub' $P305 = "32_1303748459.273" 
    capture_lex $P305
    .const 'Sub' $P284 = "30_1303748459.273" 
    capture_lex $P284
    .const 'Sub' $P245 = "27_1303748459.273" 
    capture_lex $P245
    .const 'Sub' $P230 = "24_1303748459.273" 
    capture_lex $P230
    .const 'Sub' $P219 = "22_1303748459.273" 
    capture_lex $P219
    .const 'Sub' $P207 = "20_1303748459.273" 
    capture_lex $P207
    .const 'Sub' $P199 = "18_1303748459.273" 
    capture_lex $P199
    .const 'Sub' $P192 = "16_1303748459.273" 
    capture_lex $P192
    .const 'Sub' $P185 = "14_1303748459.273" 
    capture_lex $P185
    .const 'Sub' $P110 = "13_1303748459.273" 
    capture_lex $P110
    .lex "$?PACKAGE", $P48
    .lex "$?CLASS", $P49
.annotate 'line', 605
    get_hll_global $P50, "GLOBAL"
    nqp_get_package_through_who $P51, $P50, "NQP"
    get_who $P52, $P51
    set $P53, $P52["Grammar"]
    $P53."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 606
    get_hll_global $P54, "GLOBAL"
    nqp_get_package_through_who $P55, $P54, "NQP"
    get_who $P56, $P55
    set $P57, $P56["Grammar"]
    $P57."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 607
    get_hll_global $P58, "GLOBAL"
    nqp_get_package_through_who $P59, $P58, "NQP"
    get_who $P60, $P59
    set $P61, $P60["Grammar"]
    $P61."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 608
    get_hll_global $P62, "GLOBAL"
    nqp_get_package_through_who $P63, $P62, "NQP"
    get_who $P64, $P63
    set $P65, $P64["Grammar"]
    $P65."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 609
    get_hll_global $P66, "GLOBAL"
    nqp_get_package_through_who $P67, $P66, "NQP"
    get_who $P68, $P67
    set $P69, $P68["Grammar"]
    $P69."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 610
    get_hll_global $P70, "GLOBAL"
    nqp_get_package_through_who $P71, $P70, "NQP"
    get_who $P72, $P71
    set $P73, $P72["Grammar"]
    $P73."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 611
    get_hll_global $P74, "GLOBAL"
    nqp_get_package_through_who $P75, $P74, "NQP"
    get_who $P76, $P75
    set $P77, $P76["Grammar"]
    $P77."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 612
    get_hll_global $P78, "GLOBAL"
    nqp_get_package_through_who $P79, $P78, "NQP"
    get_who $P80, $P79
    set $P81, $P80["Grammar"]
    $P81."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 613
    get_hll_global $P82, "GLOBAL"
    nqp_get_package_through_who $P83, $P82, "NQP"
    get_who $P84, $P83
    set $P85, $P84["Grammar"]
    $P85."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 614
    get_hll_global $P86, "GLOBAL"
    nqp_get_package_through_who $P87, $P86, "NQP"
    get_who $P88, $P87
    set $P89, $P88["Grammar"]
    $P89."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 615
    get_hll_global $P90, "GLOBAL"
    nqp_get_package_through_who $P91, $P90, "NQP"
    get_who $P92, $P91
    set $P93, $P92["Grammar"]
    $P93."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 616
    get_hll_global $P94, "GLOBAL"
    nqp_get_package_through_who $P95, $P94, "NQP"
    get_who $P96, $P95
    set $P97, $P96["Grammar"]
    $P97."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 617
    get_hll_global $P98, "GLOBAL"
    nqp_get_package_through_who $P99, $P98, "NQP"
    get_who $P100, $P99
    set $P101, $P100["Grammar"]
    $P101."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 618
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P105."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 619
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "NQP"
    get_who $P108, $P107
    set $P109, $P108["Grammar"]
    $P109."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 718
    .const 'Sub' $P1917 = "382_1303748459.273" 
    newclosure $P1928, $P1917
.annotate 'line', 9
    .return ($P1928)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post596") :outer("12_1303748459.273")
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1303748459.273" 
    .local pmc block
    set block, $P47
    .const 'Sub' $P1930 = "383_1303748459.273" 
    capture_lex $P1930
    $P1930()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1929"  :anon :subid("383_1303748459.273") :outer("12_1303748459.273")
.annotate 'line', 9
    nqp_get_sc_object $P1931, "1303748446.727", 1
    .local pmc type_obj
    set type_obj, $P1931
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "13_1303748459.273" 
    $P1932."add_method"(type_obj, "TOP", $P1933)
    get_how $P1934, type_obj
    .const 'Sub' $P1935 = "14_1303748459.273" 
    $P1934."add_method"(type_obj, "identifier", $P1935)
    get_how $P1936, type_obj
    get_global $P1937, "!PREFIX__identifier"
    $P1936."add_method"(type_obj, "!PREFIX__identifier", $P1937)
    get_how $P1938, type_obj
    .const 'Sub' $P1939 = "16_1303748459.273" 
    $P1938."add_method"(type_obj, "name", $P1939)
    get_how $P1940, type_obj
    get_global $P1941, "!PREFIX__name"
    $P1940."add_method"(type_obj, "!PREFIX__name", $P1941)
    get_how $P1942, type_obj
    .const 'Sub' $P1943 = "18_1303748459.273" 
    $P1942."add_method"(type_obj, "deflongname", $P1943)
    get_how $P1944, type_obj
    get_global $P1945, "!PREFIX__deflongname"
    $P1944."add_method"(type_obj, "!PREFIX__deflongname", $P1945)
    get_how $P1946, type_obj
    .const 'Sub' $P1947 = "20_1303748459.273" 
    $P1946."add_method"(type_obj, "ENDSTMT", $P1947)
    get_how $P1948, type_obj
    get_global $P1949, "!PREFIX__ENDSTMT"
    $P1948."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "22_1303748459.273" 
    $P1950."add_method"(type_obj, "ws", $P1951)
    get_how $P1952, type_obj
    get_global $P1953, "!PREFIX__ws"
    $P1952."add_method"(type_obj, "!PREFIX__ws", $P1953)
    get_how $P1954, type_obj
    .const 'Sub' $P1955 = "24_1303748459.273" 
    $P1954."add_method"(type_obj, "unv", $P1955)
    get_how $P1956, type_obj
    get_global $P1957, "!PREFIX__unv"
    $P1956."add_method"(type_obj, "!PREFIX__unv", $P1957)
    get_how $P1958, type_obj
    .const 'Sub' $P1959 = "27_1303748459.273" 
    $P1958."add_method"(type_obj, "pod_comment", $P1959)
    get_how $P1960, type_obj
    get_global $P1961, "!PREFIX__pod_comment"
    $P1960."add_method"(type_obj, "!PREFIX__pod_comment", $P1961)
    get_how $P1962, type_obj
    .const 'Sub' $P1963 = "30_1303748459.273" 
    $P1962."add_method"(type_obj, "comp_unit", $P1963)
    get_how $P1964, type_obj
    get_global $P1965, "!PREFIX__comp_unit"
    $P1964."add_method"(type_obj, "!PREFIX__comp_unit", $P1965)
    get_how $P1966, type_obj
    .const 'Sub' $P1967 = "32_1303748459.273" 
    $P1966."add_method"(type_obj, "statementlist", $P1967)
    get_how $P1968, type_obj
    get_global $P1969, "!PREFIX__statementlist"
    $P1968."add_method"(type_obj, "!PREFIX__statementlist", $P1969)
    get_how $P1970, type_obj
    .const 'Sub' $P1971 = "34_1303748459.273" 
    $P1970."add_method"(type_obj, "statement", $P1971)
    get_how $P1972, type_obj
    get_global $P1973, "!PREFIX__statement"
    $P1972."add_method"(type_obj, "!PREFIX__statement", $P1973)
    get_how $P1974, type_obj
    .const 'Sub' $P1975 = "37_1303748459.273" 
    $P1974."add_method"(type_obj, "eat_terminator", $P1975)
    get_how $P1976, type_obj
    get_global $P1977, "!PREFIX__eat_terminator"
    $P1976."add_method"(type_obj, "!PREFIX__eat_terminator", $P1977)
    get_how $P1978, type_obj
    .const 'Sub' $P1979 = "39_1303748459.273" 
    $P1978."add_method"(type_obj, "xblock", $P1979)
    get_how $P1980, type_obj
    get_global $P1981, "!PREFIX__xblock"
    $P1980."add_method"(type_obj, "!PREFIX__xblock", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "41_1303748459.273" 
    $P1982."add_method"(type_obj, "pblock", $P1983)
    get_how $P1984, type_obj
    get_global $P1985, "!PREFIX__pblock"
    $P1984."add_method"(type_obj, "!PREFIX__pblock", $P1985)
    get_how $P1986, type_obj
    .const 'Sub' $P1987 = "43_1303748459.273" 
    $P1986."add_method"(type_obj, "lambda", $P1987)
    get_how $P1988, type_obj
    get_global $P1989, "!PREFIX__lambda"
    $P1988."add_method"(type_obj, "!PREFIX__lambda", $P1989)
    get_how $P1990, type_obj
    .const 'Sub' $P1991 = "45_1303748459.273" 
    $P1990."add_method"(type_obj, "block", $P1991)
    get_how $P1992, type_obj
    get_global $P1993, "!PREFIX__block"
    $P1992."add_method"(type_obj, "!PREFIX__block", $P1993)
    get_how $P1994, type_obj
    .const 'Sub' $P1995 = "47_1303748459.273" 
    $P1994."add_method"(type_obj, "blockoid", $P1995)
    get_how $P1996, type_obj
    get_global $P1997, "!PREFIX__blockoid"
    $P1996."add_method"(type_obj, "!PREFIX__blockoid", $P1997)
    get_how $P1998, type_obj
    .const 'Sub' $P1999 = "49_1303748459.273" 
    $P1998."add_method"(type_obj, "newpad", $P1999)
    get_how $P2000, type_obj
    get_global $P2001, "!PREFIX__newpad"
    $P2000."add_method"(type_obj, "!PREFIX__newpad", $P2001)
    get_how $P2002, type_obj
    .const 'Sub' $P2003 = "51_1303748459.273" 
    $P2002."add_method"(type_obj, "outerctx", $P2003)
    get_how $P2004, type_obj
    get_global $P2005, "!PREFIX__outerctx"
    $P2004."add_method"(type_obj, "!PREFIX__outerctx", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "53_1303748459.273" 
    $P2006."add_method"(type_obj, "GLOBALish", $P2007)
    get_how $P2008, type_obj
    get_global $P2009, "!PREFIX__GLOBALish"
    $P2008."add_method"(type_obj, "!PREFIX__GLOBALish", $P2009)
    get_how $P2010, type_obj
    .const 'Sub' $P2011 = "55_1303748459.273" 
    $P2010."add_method"(type_obj, "finishpad", $P2011)
    get_how $P2012, type_obj
    get_global $P2013, "!PREFIX__finishpad"
    $P2012."add_method"(type_obj, "!PREFIX__finishpad", $P2013)
    get_how $P2014, type_obj
    .const 'Sub' $P2015 = "57_1303748459.273" 
    $P2014."add_method"(type_obj, "you_are_here", $P2015)
    get_how $P2016, type_obj
    get_global $P2017, "!PREFIX__you_are_here"
    $P2016."add_method"(type_obj, "!PREFIX__you_are_here", $P2017)
    get_how $P2018, type_obj
    .const 'Sub' $P2019 = "59_1303748459.273" 
    $P2018."add_method"(type_obj, "terminator", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "60_1303748459.273" 
    $P2020."add_method"(type_obj, "!PREFIX__terminator", $P2021)
    get_how $P2022, type_obj
    .const 'Sub' $P2023 = "61_1303748459.273" 
    $P2022."add_method"(type_obj, "terminator:sym<;>", $P2023)
    get_how $P2024, type_obj
    get_global $P2025, "!PREFIX__terminator:sym<;>"
    $P2024."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P2025)
    get_how $P2026, type_obj
    .const 'Sub' $P2027 = "63_1303748459.273" 
    $P2026."add_method"(type_obj, "terminator:sym<}>", $P2027)
    get_how $P2028, type_obj
    get_global $P2029, "!PREFIX__terminator:sym<}>"
    $P2028."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P2029)
    get_how $P2030, type_obj
    .const 'Sub' $P2031 = "65_1303748459.273" 
    $P2030."add_method"(type_obj, "statement_control", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "66_1303748459.273" 
    $P2032."add_method"(type_obj, "!PREFIX__statement_control", $P2033)
    get_how $P2034, type_obj
    .const 'Sub' $P2035 = "67_1303748459.273" 
    $P2034."add_method"(type_obj, "statement_control:sym<use>", $P2035)
    get_how $P2036, type_obj
    get_global $P2037, "!PREFIX__statement_control:sym<use>"
    $P2036."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "69_1303748459.273" 
    $P2038."add_method"(type_obj, "statement_control:sym<if>", $P2039)
    get_how $P2040, type_obj
    get_global $P2041, "!PREFIX__statement_control:sym<if>"
    $P2040."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P2041)
    get_how $P2042, type_obj
    .const 'Sub' $P2043 = "71_1303748459.273" 
    $P2042."add_method"(type_obj, "statement_control:sym<unless>", $P2043)
    get_how $P2044, type_obj
    get_global $P2045, "!PREFIX__statement_control:sym<unless>"
    $P2044."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "74_1303748459.273" 
    $P2046."add_method"(type_obj, "statement_control:sym<while>", $P2047)
    get_how $P2048, type_obj
    get_global $P2049, "!PREFIX__statement_control:sym<while>"
    $P2048."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P2049)
    get_how $P2050, type_obj
    .const 'Sub' $P2051 = "76_1303748459.273" 
    $P2050."add_method"(type_obj, "statement_control:sym<repeat>", $P2051)
    get_how $P2052, type_obj
    get_global $P2053, "!PREFIX__statement_control:sym<repeat>"
    $P2052."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P2053)
    get_how $P2054, type_obj
    .const 'Sub' $P2055 = "78_1303748459.273" 
    $P2054."add_method"(type_obj, "statement_control:sym<for>", $P2055)
    get_how $P2056, type_obj
    get_global $P2057, "!PREFIX__statement_control:sym<for>"
    $P2056."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P2057)
    get_how $P2058, type_obj
    .const 'Sub' $P2059 = "80_1303748459.273" 
    $P2058."add_method"(type_obj, "statement_control:sym<CATCH>", $P2059)
    get_how $P2060, type_obj
    get_global $P2061, "!PREFIX__statement_control:sym<CATCH>"
    $P2060."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "82_1303748459.273" 
    $P2062."add_method"(type_obj, "statement_control:sym<CONTROL>", $P2063)
    get_how $P2064, type_obj
    get_global $P2065, "!PREFIX__statement_control:sym<CONTROL>"
    $P2064."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "84_1303748459.273" 
    $P2066."add_method"(type_obj, "statement_prefix", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "85_1303748459.273" 
    $P2068."add_method"(type_obj, "!PREFIX__statement_prefix", $P2069)
    get_how $P2070, type_obj
    .const 'Sub' $P2071 = "86_1303748459.273" 
    $P2070."add_method"(type_obj, "statement_prefix:sym<INIT>", $P2071)
    get_how $P2072, type_obj
    get_global $P2073, "!PREFIX__statement_prefix:sym<INIT>"
    $P2072."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P2073)
    get_how $P2074, type_obj
    .const 'Sub' $P2075 = "88_1303748459.273" 
    $P2074."add_method"(type_obj, "statement_prefix:sym<try>", $P2075)
    get_how $P2076, type_obj
    get_global $P2077, "!PREFIX__statement_prefix:sym<try>"
    $P2076."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "90_1303748459.273" 
    $P2078."add_method"(type_obj, "blorst", $P2079)
    get_how $P2080, type_obj
    get_global $P2081, "!PREFIX__blorst"
    $P2080."add_method"(type_obj, "!PREFIX__blorst", $P2081)
    get_how $P2082, type_obj
    .const 'Sub' $P2083 = "92_1303748459.273" 
    $P2082."add_method"(type_obj, "statement_mod_cond", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "93_1303748459.273" 
    $P2084."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P2085)
    get_how $P2086, type_obj
    .const 'Sub' $P2087 = "94_1303748459.273" 
    $P2086."add_method"(type_obj, "statement_mod_cond:sym<if>", $P2087)
    get_how $P2088, type_obj
    get_global $P2089, "!PREFIX__statement_mod_cond:sym<if>"
    $P2088."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P2089)
    get_how $P2090, type_obj
    .const 'Sub' $P2091 = "96_1303748459.273" 
    $P2090."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P2091)
    get_how $P2092, type_obj
    get_global $P2093, "!PREFIX__statement_mod_cond:sym<unless>"
    $P2092."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P2093)
    get_how $P2094, type_obj
    .const 'Sub' $P2095 = "98_1303748459.273" 
    $P2094."add_method"(type_obj, "statement_mod_loop", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "99_1303748459.273" 
    $P2096."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P2097)
    get_how $P2098, type_obj
    .const 'Sub' $P2099 = "100_1303748459.273" 
    $P2098."add_method"(type_obj, "statement_mod_loop:sym<while>", $P2099)
    get_how $P2100, type_obj
    get_global $P2101, "!PREFIX__statement_mod_loop:sym<while>"
    $P2100."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P2101)
    get_how $P2102, type_obj
    .const 'Sub' $P2103 = "102_1303748459.273" 
    $P2102."add_method"(type_obj, "statement_mod_loop:sym<until>", $P2103)
    get_how $P2104, type_obj
    get_global $P2105, "!PREFIX__statement_mod_loop:sym<until>"
    $P2104."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P2105)
    get_how $P2106, type_obj
    .const 'Sub' $P2107 = "104_1303748459.273" 
    $P2106."add_method"(type_obj, "statement_mod_loop:sym<for>", $P2107)
    get_how $P2108, type_obj
    get_global $P2109, "!PREFIX__statement_mod_loop:sym<for>"
    $P2108."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P2109)
    get_how $P2110, type_obj
    .const 'Sub' $P2111 = "106_1303748459.273" 
    $P2110."add_method"(type_obj, "term:sym<fatarrow>", $P2111)
    get_how $P2112, type_obj
    get_global $P2113, "!PREFIX__term:sym<fatarrow>"
    $P2112."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P2113)
    get_how $P2114, type_obj
    .const 'Sub' $P2115 = "108_1303748459.273" 
    $P2114."add_method"(type_obj, "term:sym<colonpair>", $P2115)
    get_how $P2116, type_obj
    get_global $P2117, "!PREFIX__term:sym<colonpair>"
    $P2116."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P2117)
    get_how $P2118, type_obj
    .const 'Sub' $P2119 = "110_1303748459.273" 
    $P2118."add_method"(type_obj, "term:sym<variable>", $P2119)
    get_how $P2120, type_obj
    get_global $P2121, "!PREFIX__term:sym<variable>"
    $P2120."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P2121)
    get_how $P2122, type_obj
    .const 'Sub' $P2123 = "112_1303748459.273" 
    $P2122."add_method"(type_obj, "term:sym<package_declarator>", $P2123)
    get_how $P2124, type_obj
    get_global $P2125, "!PREFIX__term:sym<package_declarator>"
    $P2124."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P2125)
    get_how $P2126, type_obj
    .const 'Sub' $P2127 = "114_1303748459.273" 
    $P2126."add_method"(type_obj, "term:sym<scope_declarator>", $P2127)
    get_how $P2128, type_obj
    get_global $P2129, "!PREFIX__term:sym<scope_declarator>"
    $P2128."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P2129)
    get_how $P2130, type_obj
    .const 'Sub' $P2131 = "116_1303748459.273" 
    $P2130."add_method"(type_obj, "term:sym<routine_declarator>", $P2131)
    get_how $P2132, type_obj
    get_global $P2133, "!PREFIX__term:sym<routine_declarator>"
    $P2132."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P2133)
    get_how $P2134, type_obj
    .const 'Sub' $P2135 = "118_1303748459.273" 
    $P2134."add_method"(type_obj, "term:sym<multi_declarator>", $P2135)
    get_how $P2136, type_obj
    get_global $P2137, "!PREFIX__term:sym<multi_declarator>"
    $P2136."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P2137)
    get_how $P2138, type_obj
    .const 'Sub' $P2139 = "122_1303748459.273" 
    $P2138."add_method"(type_obj, "term:sym<regex_declarator>", $P2139)
    get_how $P2140, type_obj
    get_global $P2141, "!PREFIX__term:sym<regex_declarator>"
    $P2140."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P2141)
    get_how $P2142, type_obj
    .const 'Sub' $P2143 = "124_1303748459.273" 
    $P2142."add_method"(type_obj, "term:sym<statement_prefix>", $P2143)
    get_how $P2144, type_obj
    get_global $P2145, "!PREFIX__term:sym<statement_prefix>"
    $P2144."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P2145)
    get_how $P2146, type_obj
    .const 'Sub' $P2147 = "126_1303748459.273" 
    $P2146."add_method"(type_obj, "term:sym<lambda>", $P2147)
    get_how $P2148, type_obj
    get_global $P2149, "!PREFIX__term:sym<lambda>"
    $P2148."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P2149)
    get_how $P2150, type_obj
    .const 'Sub' $P2151 = "128_1303748459.273" 
    $P2150."add_method"(type_obj, "fatarrow", $P2151)
    get_how $P2152, type_obj
    get_global $P2153, "!PREFIX__fatarrow"
    $P2152."add_method"(type_obj, "!PREFIX__fatarrow", $P2153)
    get_how $P2154, type_obj
    .const 'Sub' $P2155 = "130_1303748459.273" 
    $P2154."add_method"(type_obj, "colonpair", $P2155)
    get_how $P2156, type_obj
    get_global $P2157, "!PREFIX__colonpair"
    $P2156."add_method"(type_obj, "!PREFIX__colonpair", $P2157)
    get_how $P2158, type_obj
    .const 'Sub' $P2159 = "132_1303748459.273" 
    $P2158."add_method"(type_obj, "variable", $P2159)
    get_how $P2160, type_obj
    get_global $P2161, "!PREFIX__variable"
    $P2160."add_method"(type_obj, "!PREFIX__variable", $P2161)
    get_how $P2162, type_obj
    .const 'Sub' $P2163 = "134_1303748459.273" 
    $P2162."add_method"(type_obj, "sigil", $P2163)
    get_how $P2164, type_obj
    get_global $P2165, "!PREFIX__sigil"
    $P2164."add_method"(type_obj, "!PREFIX__sigil", $P2165)
    get_how $P2166, type_obj
    .const 'Sub' $P2167 = "136_1303748459.273" 
    $P2166."add_method"(type_obj, "twigil", $P2167)
    get_how $P2168, type_obj
    get_global $P2169, "!PREFIX__twigil"
    $P2168."add_method"(type_obj, "!PREFIX__twigil", $P2169)
    get_how $P2170, type_obj
    .const 'Sub' $P2171 = "138_1303748459.273" 
    $P2170."add_method"(type_obj, "package_declarator", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "139_1303748459.273" 
    $P2172."add_method"(type_obj, "!PREFIX__package_declarator", $P2173)
    get_how $P2174, type_obj
    .const 'Sub' $P2175 = "140_1303748459.273" 
    $P2174."add_method"(type_obj, "package_declarator:sym<module>", $P2175)
    get_how $P2176, type_obj
    get_global $P2177, "!PREFIX__package_declarator:sym<module>"
    $P2176."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2177)
    get_how $P2178, type_obj
    .const 'Sub' $P2179 = "142_1303748459.273" 
    $P2178."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2179)
    get_how $P2180, type_obj
    get_global $P2181, "!PREFIX__package_declarator:sym<knowhow>"
    $P2180."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2181)
    get_how $P2182, type_obj
    .const 'Sub' $P2183 = "144_1303748459.273" 
    $P2182."add_method"(type_obj, "package_declarator:sym<class>", $P2183)
    get_how $P2184, type_obj
    get_global $P2185, "!PREFIX__package_declarator:sym<class>"
    $P2184."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2185)
    get_how $P2186, type_obj
    .const 'Sub' $P2187 = "146_1303748459.273" 
    $P2186."add_method"(type_obj, "package_declarator:sym<grammar>", $P2187)
    get_how $P2188, type_obj
    get_global $P2189, "!PREFIX__package_declarator:sym<grammar>"
    $P2188."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2189)
    get_how $P2190, type_obj
    .const 'Sub' $P2191 = "148_1303748459.273" 
    $P2190."add_method"(type_obj, "package_declarator:sym<role>", $P2191)
    get_how $P2192, type_obj
    get_global $P2193, "!PREFIX__package_declarator:sym<role>"
    $P2192."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2193)
    get_how $P2194, type_obj
    .const 'Sub' $P2195 = "150_1303748459.273" 
    $P2194."add_method"(type_obj, "package_declarator:sym<native>", $P2195)
    get_how $P2196, type_obj
    get_global $P2197, "!PREFIX__package_declarator:sym<native>"
    $P2196."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2197)
    get_how $P2198, type_obj
    .const 'Sub' $P2199 = "152_1303748459.273" 
    $P2198."add_method"(type_obj, "package_def", $P2199)
    get_how $P2200, type_obj
    get_global $P2201, "!PREFIX__package_def"
    $P2200."add_method"(type_obj, "!PREFIX__package_def", $P2201)
    get_how $P2202, type_obj
    .const 'Sub' $P2203 = "155_1303748459.273" 
    $P2202."add_method"(type_obj, "scope_declarator", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "156_1303748459.273" 
    $P2204."add_method"(type_obj, "!PREFIX__scope_declarator", $P2205)
    get_how $P2206, type_obj
    .const 'Sub' $P2207 = "157_1303748459.273" 
    $P2206."add_method"(type_obj, "scope_declarator:sym<my>", $P2207)
    get_how $P2208, type_obj
    get_global $P2209, "!PREFIX__scope_declarator:sym<my>"
    $P2208."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2209)
    get_how $P2210, type_obj
    .const 'Sub' $P2211 = "159_1303748459.273" 
    $P2210."add_method"(type_obj, "scope_declarator:sym<our>", $P2211)
    get_how $P2212, type_obj
    get_global $P2213, "!PREFIX__scope_declarator:sym<our>"
    $P2212."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2213)
    get_how $P2214, type_obj
    .const 'Sub' $P2215 = "161_1303748459.273" 
    $P2214."add_method"(type_obj, "scope_declarator:sym<has>", $P2215)
    get_how $P2216, type_obj
    get_global $P2217, "!PREFIX__scope_declarator:sym<has>"
    $P2216."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2217)
    get_how $P2218, type_obj
    .const 'Sub' $P2219 = "163_1303748459.273" 
    $P2218."add_method"(type_obj, "scoped", $P2219)
    get_how $P2220, type_obj
    get_global $P2221, "!PREFIX__scoped"
    $P2220."add_method"(type_obj, "!PREFIX__scoped", $P2221)
    get_how $P2222, type_obj
    .const 'Sub' $P2223 = "165_1303748459.273" 
    $P2222."add_method"(type_obj, "typename", $P2223)
    get_how $P2224, type_obj
    get_global $P2225, "!PREFIX__typename"
    $P2224."add_method"(type_obj, "!PREFIX__typename", $P2225)
    get_how $P2226, type_obj
    .const 'Sub' $P2227 = "167_1303748459.273" 
    $P2226."add_method"(type_obj, "declarator", $P2227)
    get_how $P2228, type_obj
    get_global $P2229, "!PREFIX__declarator"
    $P2228."add_method"(type_obj, "!PREFIX__declarator", $P2229)
    get_how $P2230, type_obj
    .const 'Sub' $P2231 = "169_1303748459.273" 
    $P2230."add_method"(type_obj, "variable_declarator", $P2231)
    get_how $P2232, type_obj
    get_global $P2233, "!PREFIX__variable_declarator"
    $P2232."add_method"(type_obj, "!PREFIX__variable_declarator", $P2233)
    get_how $P2234, type_obj
    .const 'Sub' $P2235 = "171_1303748459.273" 
    $P2234."add_method"(type_obj, "routine_declarator", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "172_1303748459.273" 
    $P2236."add_method"(type_obj, "!PREFIX__routine_declarator", $P2237)
    get_how $P2238, type_obj
    .const 'Sub' $P2239 = "173_1303748459.273" 
    $P2238."add_method"(type_obj, "routine_declarator:sym<sub>", $P2239)
    get_how $P2240, type_obj
    get_global $P2241, "!PREFIX__routine_declarator:sym<sub>"
    $P2240."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2241)
    get_how $P2242, type_obj
    .const 'Sub' $P2243 = "175_1303748459.273" 
    $P2242."add_method"(type_obj, "routine_declarator:sym<method>", $P2243)
    get_how $P2244, type_obj
    get_global $P2245, "!PREFIX__routine_declarator:sym<method>"
    $P2244."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2245)
    get_how $P2246, type_obj
    .const 'Sub' $P2247 = "177_1303748459.273" 
    $P2246."add_method"(type_obj, "routine_def", $P2247)
    get_how $P2248, type_obj
    get_global $P2249, "!PREFIX__routine_def"
    $P2248."add_method"(type_obj, "!PREFIX__routine_def", $P2249)
    get_how $P2250, type_obj
    .const 'Sub' $P2251 = "179_1303748459.273" 
    $P2250."add_method"(type_obj, "method_def", $P2251)
    get_how $P2252, type_obj
    get_global $P2253, "!PREFIX__method_def"
    $P2252."add_method"(type_obj, "!PREFIX__method_def", $P2253)
    get_how $P2254, type_obj
    .const 'Sub' $P2255 = "182_1303748459.273" 
    $P2254."add_method"(type_obj, "onlystar", $P2255)
    get_how $P2256, type_obj
    get_global $P2257, "!PREFIX__onlystar"
    $P2256."add_method"(type_obj, "!PREFIX__onlystar", $P2257)
    get_how $P2258, type_obj
    .const 'Sub' $P2259 = "185_1303748459.273" 
    $P2258."add_method"(type_obj, "multi_declarator", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "186_1303748459.273" 
    $P2260."add_method"(type_obj, "!PREFIX__multi_declarator", $P2261)
    get_how $P2262, type_obj
    .const 'Sub' $P2263 = "187_1303748459.273" 
    $P2262."add_method"(type_obj, "multi_declarator:sym<multi>", $P2263)
    get_how $P2264, type_obj
    get_global $P2265, "!PREFIX__multi_declarator:sym<multi>"
    $P2264."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2265)
    get_how $P2266, type_obj
    .const 'Sub' $P2267 = "189_1303748459.273" 
    $P2266."add_method"(type_obj, "multi_declarator:sym<proto>", $P2267)
    get_how $P2268, type_obj
    get_global $P2269, "!PREFIX__multi_declarator:sym<proto>"
    $P2268."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2269)
    get_how $P2270, type_obj
    .const 'Sub' $P2271 = "191_1303748459.273" 
    $P2270."add_method"(type_obj, "multi_declarator:sym<null>", $P2271)
    get_how $P2272, type_obj
    get_global $P2273, "!PREFIX__multi_declarator:sym<null>"
    $P2272."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2273)
    get_how $P2274, type_obj
    .const 'Sub' $P2275 = "193_1303748459.273" 
    $P2274."add_method"(type_obj, "signature", $P2275)
    get_how $P2276, type_obj
    get_global $P2277, "!PREFIX__signature"
    $P2276."add_method"(type_obj, "!PREFIX__signature", $P2277)
    get_how $P2278, type_obj
    .const 'Sub' $P2279 = "196_1303748459.273" 
    $P2278."add_method"(type_obj, "parameter", $P2279)
    get_how $P2280, type_obj
    get_global $P2281, "!PREFIX__parameter"
    $P2280."add_method"(type_obj, "!PREFIX__parameter", $P2281)
    get_how $P2282, type_obj
    .const 'Sub' $P2283 = "198_1303748459.273" 
    $P2282."add_method"(type_obj, "param_var", $P2283)
    get_how $P2284, type_obj
    get_global $P2285, "!PREFIX__param_var"
    $P2284."add_method"(type_obj, "!PREFIX__param_var", $P2285)
    get_how $P2286, type_obj
    .const 'Sub' $P2287 = "200_1303748459.273" 
    $P2286."add_method"(type_obj, "named_param", $P2287)
    get_how $P2288, type_obj
    get_global $P2289, "!PREFIX__named_param"
    $P2288."add_method"(type_obj, "!PREFIX__named_param", $P2289)
    get_how $P2290, type_obj
    .const 'Sub' $P2291 = "202_1303748459.273" 
    $P2290."add_method"(type_obj, "default_value", $P2291)
    get_how $P2292, type_obj
    get_global $P2293, "!PREFIX__default_value"
    $P2292."add_method"(type_obj, "!PREFIX__default_value", $P2293)
    get_how $P2294, type_obj
    .const 'Sub' $P2295 = "204_1303748459.273" 
    $P2294."add_method"(type_obj, "trait", $P2295)
    get_how $P2296, type_obj
    get_global $P2297, "!PREFIX__trait"
    $P2296."add_method"(type_obj, "!PREFIX__trait", $P2297)
    get_how $P2298, type_obj
    .const 'Sub' $P2299 = "206_1303748459.273" 
    $P2298."add_method"(type_obj, "trait_mod", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "207_1303748459.273" 
    $P2300."add_method"(type_obj, "!PREFIX__trait_mod", $P2301)
    get_how $P2302, type_obj
    .const 'Sub' $P2303 = "208_1303748459.273" 
    $P2302."add_method"(type_obj, "trait_mod:sym<is>", $P2303)
    get_how $P2304, type_obj
    get_global $P2305, "!PREFIX__trait_mod:sym<is>"
    $P2304."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2305)
    get_how $P2306, type_obj
    .const 'Sub' $P2307 = "210_1303748459.273" 
    $P2306."add_method"(type_obj, "regex_declarator", $P2307)
    get_how $P2308, type_obj
    get_global $P2309, "!PREFIX__regex_declarator"
    $P2308."add_method"(type_obj, "!PREFIX__regex_declarator", $P2309)
    get_how $P2310, type_obj
    .const 'Sub' $P2311 = "212_1303748459.273" 
    $P2310."add_method"(type_obj, "dotty", $P2311)
    get_how $P2312, type_obj
    get_global $P2313, "!PREFIX__dotty"
    $P2312."add_method"(type_obj, "!PREFIX__dotty", $P2313)
    get_how $P2314, type_obj
    .const 'Sub' $P2315 = "214_1303748459.273" 
    $P2314."add_method"(type_obj, "term", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "215_1303748459.273" 
    $P2316."add_method"(type_obj, "!PREFIX__term", $P2317)
    get_how $P2318, type_obj
    .const 'Sub' $P2319 = "216_1303748459.273" 
    $P2318."add_method"(type_obj, "term:sym<self>", $P2319)
    get_how $P2320, type_obj
    get_global $P2321, "!PREFIX__term:sym<self>"
    $P2320."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2321)
    get_how $P2322, type_obj
    .const 'Sub' $P2323 = "218_1303748459.273" 
    $P2322."add_method"(type_obj, "term:sym<identifier>", $P2323)
    get_how $P2324, type_obj
    get_global $P2325, "!PREFIX__term:sym<identifier>"
    $P2324."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2325)
    get_how $P2326, type_obj
    .const 'Sub' $P2327 = "220_1303748459.273" 
    $P2326."add_method"(type_obj, "term:sym<name>", $P2327)
    get_how $P2328, type_obj
    get_global $P2329, "!PREFIX__term:sym<name>"
    $P2328."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2329)
    get_how $P2330, type_obj
    .const 'Sub' $P2331 = "222_1303748459.273" 
    $P2330."add_method"(type_obj, "term:sym<pir::op>", $P2331)
    get_how $P2332, type_obj
    get_global $P2333, "!PREFIX__term:sym<pir::op>"
    $P2332."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2333)
    get_how $P2334, type_obj
    .const 'Sub' $P2335 = "224_1303748459.273" 
    $P2334."add_method"(type_obj, "term:sym<onlystar>", $P2335)
    get_how $P2336, type_obj
    get_global $P2337, "!PREFIX__term:sym<onlystar>"
    $P2336."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2337)
    get_how $P2338, type_obj
    .const 'Sub' $P2339 = "227_1303748459.273" 
    $P2338."add_method"(type_obj, "args", $P2339)
    get_how $P2340, type_obj
    get_global $P2341, "!PREFIX__args"
    $P2340."add_method"(type_obj, "!PREFIX__args", $P2341)
    get_how $P2342, type_obj
    .const 'Sub' $P2343 = "229_1303748459.273" 
    $P2342."add_method"(type_obj, "arglist", $P2343)
    get_how $P2344, type_obj
    get_global $P2345, "!PREFIX__arglist"
    $P2344."add_method"(type_obj, "!PREFIX__arglist", $P2345)
    get_how $P2346, type_obj
    .const 'Sub' $P2347 = "231_1303748459.273" 
    $P2346."add_method"(type_obj, "term:sym<value>", $P2347)
    get_how $P2348, type_obj
    get_global $P2349, "!PREFIX__term:sym<value>"
    $P2348."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2349)
    get_how $P2350, type_obj
    .const 'Sub' $P2351 = "233_1303748459.273" 
    $P2350."add_method"(type_obj, "value", $P2351)
    get_how $P2352, type_obj
    get_global $P2353, "!PREFIX__value"
    $P2352."add_method"(type_obj, "!PREFIX__value", $P2353)
    get_how $P2354, type_obj
    .const 'Sub' $P2355 = "235_1303748459.273" 
    $P2354."add_method"(type_obj, "number", $P2355)
    get_how $P2356, type_obj
    get_global $P2357, "!PREFIX__number"
    $P2356."add_method"(type_obj, "!PREFIX__number", $P2357)
    get_how $P2358, type_obj
    .const 'Sub' $P2359 = "237_1303748459.273" 
    $P2358."add_method"(type_obj, "quote", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "238_1303748459.273" 
    $P2360."add_method"(type_obj, "!PREFIX__quote", $P2361)
    get_how $P2362, type_obj
    .const 'Sub' $P2363 = "239_1303748459.273" 
    $P2362."add_method"(type_obj, "quote:sym<apos>", $P2363)
    get_how $P2364, type_obj
    get_global $P2365, "!PREFIX__quote:sym<apos>"
    $P2364."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2365)
    get_how $P2366, type_obj
    .const 'Sub' $P2367 = "241_1303748459.273" 
    $P2366."add_method"(type_obj, "quote:sym<dblq>", $P2367)
    get_how $P2368, type_obj
    get_global $P2369, "!PREFIX__quote:sym<dblq>"
    $P2368."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2369)
    get_how $P2370, type_obj
    .const 'Sub' $P2371 = "243_1303748459.273" 
    $P2370."add_method"(type_obj, "quote:sym<q>", $P2371)
    get_how $P2372, type_obj
    get_global $P2373, "!PREFIX__quote:sym<q>"
    $P2372."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2373)
    get_how $P2374, type_obj
    .const 'Sub' $P2375 = "245_1303748459.273" 
    $P2374."add_method"(type_obj, "quote:sym<qq>", $P2375)
    get_how $P2376, type_obj
    get_global $P2377, "!PREFIX__quote:sym<qq>"
    $P2376."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2377)
    get_how $P2378, type_obj
    .const 'Sub' $P2379 = "247_1303748459.273" 
    $P2378."add_method"(type_obj, "quote:sym<Q>", $P2379)
    get_how $P2380, type_obj
    get_global $P2381, "!PREFIX__quote:sym<Q>"
    $P2380."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2381)
    get_how $P2382, type_obj
    .const 'Sub' $P2383 = "249_1303748459.273" 
    $P2382."add_method"(type_obj, "quote:sym<Q:PIR>", $P2383)
    get_how $P2384, type_obj
    get_global $P2385, "!PREFIX__quote:sym<Q:PIR>"
    $P2384."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2385)
    get_how $P2386, type_obj
    .const 'Sub' $P2387 = "251_1303748459.273" 
    $P2386."add_method"(type_obj, "quote:sym</ />", $P2387)
    get_how $P2388, type_obj
    get_global $P2389, "!PREFIX__quote:sym</ />"
    $P2388."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2389)
    get_how $P2390, type_obj
    .const 'Sub' $P2391 = "253_1303748459.273" 
    $P2390."add_method"(type_obj, "quote_escape:sym<$>", $P2391)
    get_how $P2392, type_obj
    get_global $P2393, "!PREFIX__quote_escape:sym<$>"
    $P2392."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2393)
    get_how $P2394, type_obj
    .const 'Sub' $P2395 = "255_1303748459.273" 
    $P2394."add_method"(type_obj, "quote_escape:sym<{ }>", $P2395)
    get_how $P2396, type_obj
    get_global $P2397, "!PREFIX__quote_escape:sym<{ }>"
    $P2396."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2397)
    get_how $P2398, type_obj
    .const 'Sub' $P2399 = "257_1303748459.273" 
    $P2398."add_method"(type_obj, "quote_escape:sym<esc>", $P2399)
    get_how $P2400, type_obj
    get_global $P2401, "!PREFIX__quote_escape:sym<esc>"
    $P2400."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2401)
    get_how $P2402, type_obj
    .const 'Sub' $P2403 = "259_1303748459.273" 
    $P2402."add_method"(type_obj, "circumfix:sym<( )>", $P2403)
    get_how $P2404, type_obj
    get_global $P2405, "!PREFIX__circumfix:sym<( )>"
    $P2404."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2405)
    get_how $P2406, type_obj
    .const 'Sub' $P2407 = "261_1303748459.273" 
    $P2406."add_method"(type_obj, "circumfix:sym<[ ]>", $P2407)
    get_how $P2408, type_obj
    get_global $P2409, "!PREFIX__circumfix:sym<[ ]>"
    $P2408."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2409)
    get_how $P2410, type_obj
    .const 'Sub' $P2411 = "263_1303748459.273" 
    $P2410."add_method"(type_obj, "circumfix:sym<ang>", $P2411)
    get_how $P2412, type_obj
    get_global $P2413, "!PREFIX__circumfix:sym<ang>"
    $P2412."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2413)
    get_how $P2414, type_obj
    .const 'Sub' $P2415 = "265_1303748459.273" 
    $P2414."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2415)
    get_how $P2416, type_obj
    get_global $P2417, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2416."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2417)
    get_how $P2418, type_obj
    .const 'Sub' $P2419 = "267_1303748459.273" 
    $P2418."add_method"(type_obj, "circumfix:sym<{ }>", $P2419)
    get_how $P2420, type_obj
    get_global $P2421, "!PREFIX__circumfix:sym<{ }>"
    $P2420."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2421)
    get_how $P2422, type_obj
    .const 'Sub' $P2423 = "269_1303748459.273" 
    $P2422."add_method"(type_obj, "circumfix:sym<sigil>", $P2423)
    get_how $P2424, type_obj
    get_global $P2425, "!PREFIX__circumfix:sym<sigil>"
    $P2424."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2425)
    get_how $P2426, type_obj
    .const 'Sub' $P2427 = "271_1303748459.273" 
    $P2426."add_method"(type_obj, "semilist", $P2427)
    get_how $P2428, type_obj
    get_global $P2429, "!PREFIX__semilist"
    $P2428."add_method"(type_obj, "!PREFIX__semilist", $P2429)
    get_how $P2430, type_obj
    .const 'Sub' $P2431 = "273_1303748459.273" 
    $P2430."add_method"(type_obj, "infixish", $P2431)
    get_how $P2432, type_obj
    get_global $P2433, "!PREFIX__infixish"
    $P2432."add_method"(type_obj, "!PREFIX__infixish", $P2433)
    get_how $P2434, type_obj
    .const 'Sub' $P2435 = "275_1303748459.273" 
    $P2434."add_method"(type_obj, "infixstopper", $P2435)
    get_how $P2436, type_obj
    get_global $P2437, "!PREFIX__infixstopper"
    $P2436."add_method"(type_obj, "!PREFIX__infixstopper", $P2437)
    get_how $P2438, type_obj
    .const 'Sub' $P2439 = "277_1303748459.273" 
    $P2438."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2439)
    get_how $P2440, type_obj
    get_global $P2441, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2440."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2441)
    get_how $P2442, type_obj
    .const 'Sub' $P2443 = "279_1303748459.273" 
    $P2442."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2443)
    get_how $P2444, type_obj
    get_global $P2445, "!PREFIX__postcircumfix:sym<{ }>"
    $P2444."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2445)
    get_how $P2446, type_obj
    .const 'Sub' $P2447 = "281_1303748459.273" 
    $P2446."add_method"(type_obj, "postcircumfix:sym<ang>", $P2447)
    get_how $P2448, type_obj
    get_global $P2449, "!PREFIX__postcircumfix:sym<ang>"
    $P2448."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2449)
    get_how $P2450, type_obj
    .const 'Sub' $P2451 = "283_1303748459.273" 
    $P2450."add_method"(type_obj, "postcircumfix:sym<( )>", $P2451)
    get_how $P2452, type_obj
    get_global $P2453, "!PREFIX__postcircumfix:sym<( )>"
    $P2452."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2453)
    get_how $P2454, type_obj
    .const 'Sub' $P2455 = "285_1303748459.273" 
    $P2454."add_method"(type_obj, "postfix:sym<.>", $P2455)
    get_how $P2456, type_obj
    get_global $P2457, "!PREFIX__postfix:sym<.>"
    $P2456."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2457)
    get_how $P2458, type_obj
    .const 'Sub' $P2459 = "287_1303748459.273" 
    $P2458."add_method"(type_obj, "prefix:sym<++>", $P2459)
    get_how $P2460, type_obj
    get_global $P2461, "!PREFIX__prefix:sym<++>"
    $P2460."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2461)
    get_how $P2462, type_obj
    .const 'Sub' $P2463 = "289_1303748459.273" 
    $P2462."add_method"(type_obj, "prefix:sym<-->", $P2463)
    get_how $P2464, type_obj
    get_global $P2465, "!PREFIX__prefix:sym<-->"
    $P2464."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2465)
    get_how $P2466, type_obj
    .const 'Sub' $P2467 = "291_1303748459.273" 
    $P2466."add_method"(type_obj, "postfix:sym<++>", $P2467)
    get_how $P2468, type_obj
    get_global $P2469, "!PREFIX__postfix:sym<++>"
    $P2468."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2469)
    get_how $P2470, type_obj
    .const 'Sub' $P2471 = "293_1303748459.273" 
    $P2470."add_method"(type_obj, "postfix:sym<-->", $P2471)
    get_how $P2472, type_obj
    get_global $P2473, "!PREFIX__postfix:sym<-->"
    $P2472."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2473)
    get_how $P2474, type_obj
    .const 'Sub' $P2475 = "295_1303748459.273" 
    $P2474."add_method"(type_obj, "infix:sym<**>", $P2475)
    get_how $P2476, type_obj
    get_global $P2477, "!PREFIX__infix:sym<**>"
    $P2476."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2477)
    get_how $P2478, type_obj
    .const 'Sub' $P2479 = "297_1303748459.273" 
    $P2478."add_method"(type_obj, "prefix:sym<+>", $P2479)
    get_how $P2480, type_obj
    get_global $P2481, "!PREFIX__prefix:sym<+>"
    $P2480."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2481)
    get_how $P2482, type_obj
    .const 'Sub' $P2483 = "299_1303748459.273" 
    $P2482."add_method"(type_obj, "prefix:sym<~>", $P2483)
    get_how $P2484, type_obj
    get_global $P2485, "!PREFIX__prefix:sym<~>"
    $P2484."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2485)
    get_how $P2486, type_obj
    .const 'Sub' $P2487 = "301_1303748459.273" 
    $P2486."add_method"(type_obj, "prefix:sym<->", $P2487)
    get_how $P2488, type_obj
    get_global $P2489, "!PREFIX__prefix:sym<->"
    $P2488."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2489)
    get_how $P2490, type_obj
    .const 'Sub' $P2491 = "303_1303748459.273" 
    $P2490."add_method"(type_obj, "prefix:sym<?>", $P2491)
    get_how $P2492, type_obj
    get_global $P2493, "!PREFIX__prefix:sym<?>"
    $P2492."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2493)
    get_how $P2494, type_obj
    .const 'Sub' $P2495 = "305_1303748459.273" 
    $P2494."add_method"(type_obj, "prefix:sym<!>", $P2495)
    get_how $P2496, type_obj
    get_global $P2497, "!PREFIX__prefix:sym<!>"
    $P2496."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2497)
    get_how $P2498, type_obj
    .const 'Sub' $P2499 = "307_1303748459.273" 
    $P2498."add_method"(type_obj, "prefix:sym<|>", $P2499)
    get_how $P2500, type_obj
    get_global $P2501, "!PREFIX__prefix:sym<|>"
    $P2500."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2501)
    get_how $P2502, type_obj
    .const 'Sub' $P2503 = "309_1303748459.273" 
    $P2502."add_method"(type_obj, "infix:sym<*>", $P2503)
    get_how $P2504, type_obj
    get_global $P2505, "!PREFIX__infix:sym<*>"
    $P2504."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2505)
    get_how $P2506, type_obj
    .const 'Sub' $P2507 = "311_1303748459.273" 
    $P2506."add_method"(type_obj, "infix:sym</>", $P2507)
    get_how $P2508, type_obj
    get_global $P2509, "!PREFIX__infix:sym</>"
    $P2508."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2509)
    get_how $P2510, type_obj
    .const 'Sub' $P2511 = "313_1303748459.273" 
    $P2510."add_method"(type_obj, "infix:sym<%>", $P2511)
    get_how $P2512, type_obj
    get_global $P2513, "!PREFIX__infix:sym<%>"
    $P2512."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2513)
    get_how $P2514, type_obj
    .const 'Sub' $P2515 = "315_1303748459.273" 
    $P2514."add_method"(type_obj, "infix:sym<+&>", $P2515)
    get_how $P2516, type_obj
    get_global $P2517, "!PREFIX__infix:sym<+&>"
    $P2516."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2517)
    get_how $P2518, type_obj
    .const 'Sub' $P2519 = "317_1303748459.273" 
    $P2518."add_method"(type_obj, "infix:sym<+>", $P2519)
    get_how $P2520, type_obj
    get_global $P2521, "!PREFIX__infix:sym<+>"
    $P2520."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2521)
    get_how $P2522, type_obj
    .const 'Sub' $P2523 = "319_1303748459.273" 
    $P2522."add_method"(type_obj, "infix:sym<->", $P2523)
    get_how $P2524, type_obj
    get_global $P2525, "!PREFIX__infix:sym<->"
    $P2524."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2525)
    get_how $P2526, type_obj
    .const 'Sub' $P2527 = "321_1303748459.273" 
    $P2526."add_method"(type_obj, "infix:sym<+|>", $P2527)
    get_how $P2528, type_obj
    get_global $P2529, "!PREFIX__infix:sym<+|>"
    $P2528."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2529)
    get_how $P2530, type_obj
    .const 'Sub' $P2531 = "323_1303748459.273" 
    $P2530."add_method"(type_obj, "infix:sym<+^>", $P2531)
    get_how $P2532, type_obj
    get_global $P2533, "!PREFIX__infix:sym<+^>"
    $P2532."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2533)
    get_how $P2534, type_obj
    .const 'Sub' $P2535 = "325_1303748459.273" 
    $P2534."add_method"(type_obj, "infix:sym<~>", $P2535)
    get_how $P2536, type_obj
    get_global $P2537, "!PREFIX__infix:sym<~>"
    $P2536."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2537)
    get_how $P2538, type_obj
    .const 'Sub' $P2539 = "327_1303748459.273" 
    $P2538."add_method"(type_obj, "infix:sym<==>", $P2539)
    get_how $P2540, type_obj
    get_global $P2541, "!PREFIX__infix:sym<==>"
    $P2540."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2541)
    get_how $P2542, type_obj
    .const 'Sub' $P2543 = "329_1303748459.273" 
    $P2542."add_method"(type_obj, "infix:sym<!=>", $P2543)
    get_how $P2544, type_obj
    get_global $P2545, "!PREFIX__infix:sym<!=>"
    $P2544."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2545)
    get_how $P2546, type_obj
    .const 'Sub' $P2547 = "331_1303748459.273" 
    $P2546."add_method"(type_obj, "infix:sym<<=>", $P2547)
    get_how $P2548, type_obj
    get_global $P2549, "!PREFIX__infix:sym<<=>"
    $P2548."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2549)
    get_how $P2550, type_obj
    .const 'Sub' $P2551 = "333_1303748459.273" 
    $P2550."add_method"(type_obj, "infix:sym<>=>", $P2551)
    get_how $P2552, type_obj
    get_global $P2553, "!PREFIX__infix:sym<>=>"
    $P2552."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2553)
    get_how $P2554, type_obj
    .const 'Sub' $P2555 = "335_1303748459.273" 
    $P2554."add_method"(type_obj, "infix:sym<<>", $P2555)
    get_how $P2556, type_obj
    get_global $P2557, "!PREFIX__infix:sym<<>"
    $P2556."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2557)
    get_how $P2558, type_obj
    .const 'Sub' $P2559 = "337_1303748459.273" 
    $P2558."add_method"(type_obj, "infix:sym<>>", $P2559)
    get_how $P2560, type_obj
    get_global $P2561, "!PREFIX__infix:sym<>>"
    $P2560."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2561)
    get_how $P2562, type_obj
    .const 'Sub' $P2563 = "339_1303748459.273" 
    $P2562."add_method"(type_obj, "infix:sym<eq>", $P2563)
    get_how $P2564, type_obj
    get_global $P2565, "!PREFIX__infix:sym<eq>"
    $P2564."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2565)
    get_how $P2566, type_obj
    .const 'Sub' $P2567 = "341_1303748459.273" 
    $P2566."add_method"(type_obj, "infix:sym<ne>", $P2567)
    get_how $P2568, type_obj
    get_global $P2569, "!PREFIX__infix:sym<ne>"
    $P2568."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2569)
    get_how $P2570, type_obj
    .const 'Sub' $P2571 = "343_1303748459.273" 
    $P2570."add_method"(type_obj, "infix:sym<le>", $P2571)
    get_how $P2572, type_obj
    get_global $P2573, "!PREFIX__infix:sym<le>"
    $P2572."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2573)
    get_how $P2574, type_obj
    .const 'Sub' $P2575 = "345_1303748459.273" 
    $P2574."add_method"(type_obj, "infix:sym<ge>", $P2575)
    get_how $P2576, type_obj
    get_global $P2577, "!PREFIX__infix:sym<ge>"
    $P2576."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2577)
    get_how $P2578, type_obj
    .const 'Sub' $P2579 = "347_1303748459.273" 
    $P2578."add_method"(type_obj, "infix:sym<lt>", $P2579)
    get_how $P2580, type_obj
    get_global $P2581, "!PREFIX__infix:sym<lt>"
    $P2580."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2581)
    get_how $P2582, type_obj
    .const 'Sub' $P2583 = "349_1303748459.273" 
    $P2582."add_method"(type_obj, "infix:sym<gt>", $P2583)
    get_how $P2584, type_obj
    get_global $P2585, "!PREFIX__infix:sym<gt>"
    $P2584."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2585)
    get_how $P2586, type_obj
    .const 'Sub' $P2587 = "351_1303748459.273" 
    $P2586."add_method"(type_obj, "infix:sym<=:=>", $P2587)
    get_how $P2588, type_obj
    get_global $P2589, "!PREFIX__infix:sym<=:=>"
    $P2588."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2589)
    get_how $P2590, type_obj
    .const 'Sub' $P2591 = "353_1303748459.273" 
    $P2590."add_method"(type_obj, "infix:sym<~~>", $P2591)
    get_how $P2592, type_obj
    get_global $P2593, "!PREFIX__infix:sym<~~>"
    $P2592."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2593)
    get_how $P2594, type_obj
    .const 'Sub' $P2595 = "355_1303748459.273" 
    $P2594."add_method"(type_obj, "infix:sym<&&>", $P2595)
    get_how $P2596, type_obj
    get_global $P2597, "!PREFIX__infix:sym<&&>"
    $P2596."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2597)
    get_how $P2598, type_obj
    .const 'Sub' $P2599 = "357_1303748459.273" 
    $P2598."add_method"(type_obj, "infix:sym<||>", $P2599)
    get_how $P2600, type_obj
    get_global $P2601, "!PREFIX__infix:sym<||>"
    $P2600."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2601)
    get_how $P2602, type_obj
    .const 'Sub' $P2603 = "359_1303748459.273" 
    $P2602."add_method"(type_obj, "infix:sym<//>", $P2603)
    get_how $P2604, type_obj
    get_global $P2605, "!PREFIX__infix:sym<//>"
    $P2604."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2605)
    get_how $P2606, type_obj
    .const 'Sub' $P2607 = "361_1303748459.273" 
    $P2606."add_method"(type_obj, "infix:sym<?? !!>", $P2607)
    get_how $P2608, type_obj
    get_global $P2609, "!PREFIX__infix:sym<?? !!>"
    $P2608."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2609)
    get_how $P2610, type_obj
    .const 'Sub' $P2611 = "363_1303748459.273" 
    $P2610."add_method"(type_obj, "infix:sym<=>", $P2611)
    get_how $P2612, type_obj
    get_global $P2613, "!PREFIX__infix:sym<=>"
    $P2612."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2613)
    get_how $P2614, type_obj
    .const 'Sub' $P2615 = "365_1303748459.273" 
    $P2614."add_method"(type_obj, "infix:sym<:=>", $P2615)
    get_how $P2616, type_obj
    get_global $P2617, "!PREFIX__infix:sym<:=>"
    $P2616."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2617)
    get_how $P2618, type_obj
    .const 'Sub' $P2619 = "367_1303748459.273" 
    $P2618."add_method"(type_obj, "infix:sym<::=>", $P2619)
    get_how $P2620, type_obj
    get_global $P2621, "!PREFIX__infix:sym<::=>"
    $P2620."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2621)
    get_how $P2622, type_obj
    .const 'Sub' $P2623 = "369_1303748459.273" 
    $P2622."add_method"(type_obj, "infix:sym<,>", $P2623)
    get_how $P2624, type_obj
    get_global $P2625, "!PREFIX__infix:sym<,>"
    $P2624."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2625)
    get_how $P2626, type_obj
    .const 'Sub' $P2627 = "371_1303748459.273" 
    $P2626."add_method"(type_obj, "prefix:sym<return>", $P2627)
    get_how $P2628, type_obj
    get_global $P2629, "!PREFIX__prefix:sym<return>"
    $P2628."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2629)
    get_how $P2630, type_obj
    .const 'Sub' $P2631 = "374_1303748459.273" 
    $P2630."add_method"(type_obj, "prefix:sym<make>", $P2631)
    get_how $P2632, type_obj
    get_global $P2633, "!PREFIX__prefix:sym<make>"
    $P2632."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2633)
    get_how $P2634, type_obj
    .const 'Sub' $P2635 = "376_1303748459.273" 
    $P2634."add_method"(type_obj, "term:sym<last>", $P2635)
    get_how $P2636, type_obj
    get_global $P2637, "!PREFIX__term:sym<last>"
    $P2636."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2637)
    get_how $P2638, type_obj
    .const 'Sub' $P2639 = "378_1303748459.273" 
    $P2638."add_method"(type_obj, "term:sym<next>", $P2639)
    get_how $P2640, type_obj
    get_global $P2641, "!PREFIX__term:sym<next>"
    $P2640."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2641)
    get_how $P2642, type_obj
    .const 'Sub' $P2643 = "380_1303748459.273" 
    $P2642."add_method"(type_obj, "term:sym<redo>", $P2643)
    get_how $P2644, type_obj
    get_global $P2645, "!PREFIX__term:sym<redo>"
    $P2644."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2645)
    get_how $P2646, type_obj
    .const 'Sub' $P2647 = "382_1303748459.273" 
    $P2646."add_method"(type_obj, "smartmatch", $P2647)
    get_how $P2648, type_obj
    $P2649 = $P2648."compose"(type_obj)
    .return ($P2649)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1303748459.273") :outer("12_1303748459.273")
    .param pmc param_111
.annotate 'line', 10
    .lex "self", param_111
.annotate 'line', 12
    $P112 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P112
.annotate 'line', 20
    $P113 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P113
.annotate 'line', 24
    new $P114, "Undef"
    .lex "$*DEFAULT-METAATTR", $P114
.annotate 'line', 25
    $P115 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P115
.annotate 'line', 31
    new $P116, "Undef"
    .lex "$*SC", $P116
.annotate 'line', 35
    new $P117, "Undef"
    .lex "$*SCOPE", $P117
.annotate 'line', 36
    new $P118, "Undef"
    .lex "$*MULTINESS", $P118
.annotate 'line', 37
    new $P119, "Undef"
    .lex "$*INVOCANT_OK", $P119
.annotate 'line', 38
    new $P120, "Undef"
    .lex "$*RETURN_USED", $P120
.annotate 'line', 39
    new $P121, "Undef"
    .lex "$*PACKAGE-SETUP", $P121
.annotate 'line', 10
    find_lex $P124, "%*LANG"
    unless_null $P124, vivify_597
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["%LANG"]
    unless_null $P124, vivify_598
    die "Contextual %*LANG not found"
  vivify_598:
  vivify_597:
.annotate 'line', 13
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P126, $P125, "NQP"
    get_who $P127, $P126
    set $P128, $P127["Regex"]
    find_lex $P131, "%*LANG"
    unless_null $P131, vivify_599
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%LANG"]
    unless_null $P131, vivify_600
    die "Contextual %*LANG not found"
  vivify_600:
    store_lex "%*LANG", $P131
  vivify_599:
    set $P131["Regex"], $P128
.annotate 'line', 14
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "NQP"
    get_who $P134, $P133
    set $P135, $P134["RegexActions"]
    find_lex $P138, "%*LANG"
    unless_null $P138, vivify_601
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["%LANG"]
    unless_null $P138, vivify_602
    die "Contextual %*LANG not found"
  vivify_602:
    store_lex "%*LANG", $P138
  vivify_601:
    set $P138["Regex-actions"], $P135
.annotate 'line', 15
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "NQP"
    get_who $P141, $P140
    set $P142, $P141["Grammar"]
    find_lex $P145, "%*LANG"
    unless_null $P145, vivify_603
    get_hll_global $P143, "GLOBAL"
    get_who $P144, $P143
    set $P145, $P144["%LANG"]
    unless_null $P145, vivify_604
    die "Contextual %*LANG not found"
  vivify_604:
    store_lex "%*LANG", $P145
  vivify_603:
    set $P145["MAIN"], $P142
.annotate 'line', 16
    get_hll_global $P146, "GLOBAL"
    nqp_get_package_through_who $P147, $P146, "NQP"
    get_who $P148, $P147
    set $P149, $P148["Actions"]
    find_lex $P152, "%*LANG"
    unless_null $P152, vivify_605
    get_hll_global $P150, "GLOBAL"
    get_who $P151, $P150
    set $P152, $P151["%LANG"]
    unless_null $P152, vivify_606
    die "Contextual %*LANG not found"
  vivify_606:
    store_lex "%*LANG", $P152
  vivify_605:
    set $P152["MAIN-actions"], $P149
    find_lex $P155, "%*HOW"
    unless_null $P155, vivify_607
    get_hll_global $P153, "GLOBAL"
    get_who $P154, $P153
    set $P155, $P154["%HOW"]
    unless_null $P155, vivify_608
    die "Contextual %*HOW not found"
  vivify_608:
  vivify_607:
.annotate 'line', 21
    get_knowhow $P156
    find_lex $P159, "%*HOW"
    unless_null $P159, vivify_609
    get_hll_global $P157, "GLOBAL"
    get_who $P158, $P157
    set $P159, $P158["%HOW"]
    unless_null $P159, vivify_610
    die "Contextual %*HOW not found"
  vivify_610:
    store_lex "%*HOW", $P159
  vivify_609:
    set $P159["knowhow"], $P156
.annotate 'line', 24
    new $P160, "String"
    assign $P160, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P160
    find_lex $P163, "%*HOW-METAATTR"
    unless_null $P163, vivify_611
    get_hll_global $P161, "GLOBAL"
    get_who $P162, $P161
    set $P163, $P162["%HOW-METAATTR"]
    unless_null $P163, vivify_612
    die "Contextual %*HOW-METAATTR not found"
  vivify_612:
  vivify_611:
.annotate 'line', 26
    new $P164, "String"
    assign $P164, "KnowHOWAttribute"
    find_lex $P167, "%*HOW-METAATTR"
    unless_null $P167, vivify_613
    get_hll_global $P165, "GLOBAL"
    get_who $P166, $P165
    set $P167, $P166["%HOW-METAATTR"]
    unless_null $P167, vivify_614
    die "Contextual %*HOW-METAATTR not found"
  vivify_614:
    store_lex "%*HOW-METAATTR", $P167
  vivify_613:
    set $P167["knowhow"], $P164
.annotate 'line', 31
    get_hll_global $P168, "GLOBAL"
    nqp_get_package_through_who $P169, $P168, "HLL"
    nqp_get_package_through_who $P170, $P169, "Compiler"
    get_who $P171, $P170
    set $P172, $P171["SerializationContextBuilder"]
.annotate 'line', 33
    time $N173
    set $S174, $N173
    $P175 = $P172."new"($S174 :named("handle"))
.annotate 'line', 31
    store_lex "$*SC", $P175
.annotate 'line', 35
    new $P176, "String"
    assign $P176, ""
    store_lex "$*SCOPE", $P176
.annotate 'line', 36
    new $P177, "String"
    assign $P177, ""
    store_lex "$*MULTINESS", $P177
.annotate 'line', 37
    new $P178, "Integer"
    assign $P178, 0
    store_lex "$*INVOCANT_OK", $P178
.annotate 'line', 38
    new $P179, "Integer"
    assign $P179, 0
    store_lex "$*RETURN_USED", $P179
    find_lex $P182, "$*PACKAGE-SETUP"
    unless_null $P182, vivify_615
    get_hll_global $P180, "GLOBAL"
    get_who $P181, $P180
    set $P182, $P181["$PACKAGE-SETUP"]
    unless_null $P182, vivify_616
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_616:
  vivify_615:
.annotate 'line', 40
    find_lex $P183, "self"
    $P184 = $P183."comp_unit"()
.annotate 'line', 10
    .return ($P184)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx186_tgt
    .local int rx186_pos
    .local int rx186_off
    .local int rx186_eos
    .local int rx186_rep
    .local pmc rx186_cur
    .local pmc rx186_debug
    (rx186_cur, rx186_pos, rx186_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx186_cur
    .local pmc match
    .lex "$/", match
    length rx186_eos, rx186_tgt
    gt rx186_pos, rx186_eos, rx186_done
    set rx186_off, 0
    lt rx186_pos, 2, rx186_start
    sub rx186_off, rx186_pos, 1
    substr rx186_tgt, rx186_tgt, rx186_off
  rx186_start:
    eq $I10, 1, rx186_restart
    if_null rx186_debug, debug_617
    rx186_cur."!cursor_debug"("START", "identifier")
  debug_617:
    $I10 = self.'from'()
    ne $I10, -1, rxscan190_done
    goto rxscan190_scan
  rxscan190_loop:
    (rx186_pos) = rx186_cur."from"()
    inc rx186_pos
    rx186_cur."!cursor_from"(rx186_pos)
    ge rx186_pos, rx186_eos, rxscan190_done
  rxscan190_scan:
    set_addr $I10, rxscan190_loop
    rx186_cur."!mark_push"(0, rx186_pos, $I10)
  rxscan190_done:
.annotate 'line', 45
  # rx subrule "ident" subtype=method negate=
    rx186_cur."!cursor_pos"(rx186_pos)
    $P10 = rx186_cur."ident"()
    unless $P10, rx186_fail
    rx186_pos = $P10."pos"()
  # rx rxquantr191 ** 0..*
    set_addr $I10, rxquantr191_done
    rx186_cur."!mark_push"(0, rx186_pos, $I10)
  rxquantr191_loop:
  # rx enumcharlist negate=0 
    ge rx186_pos, rx186_eos, rx186_fail
    sub $I10, rx186_pos, rx186_off
    substr $S10, rx186_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx186_fail
    inc rx186_pos
  # rx subrule "ident" subtype=method negate=
    rx186_cur."!cursor_pos"(rx186_pos)
    $P10 = rx186_cur."ident"()
    unless $P10, rx186_fail
    rx186_pos = $P10."pos"()
    set_addr $I10, rxquantr191_done
    (rx186_rep) = rx186_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr191_done
    rx186_cur."!mark_push"(rx186_rep, rx186_pos, $I10)
    goto rxquantr191_loop
  rxquantr191_done:
  # rx pass
    rx186_cur."!cursor_pass"(rx186_pos, "identifier")
    if_null rx186_debug, debug_618
    rx186_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx186_pos)
  debug_618:
    .return (rx186_cur)
  rx186_restart:
.annotate 'line', 10
    if_null rx186_debug, debug_619
    rx186_cur."!cursor_debug"("NEXT", "identifier")
  debug_619:
  rx186_fail:
    (rx186_rep, rx186_pos, $I10, $P10) = rx186_cur."!mark_fail"(0)
    lt rx186_pos, -1, rx186_done
    eq rx186_pos, -1, rx186_fail
    jump $I10
  rx186_done:
    rx186_cur."!cursor_fail"()
    if_null rx186_debug, debug_620
    rx186_cur."!cursor_debug"("FAIL", "identifier")
  debug_620:
    .return (rx186_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1303748459.273") :method
.annotate 'line', 10
    $P188 = self."!PREFIX__!subrule"("ident", "")
    new $P189, "ResizablePMCArray"
    push $P189, $P188
    .return ($P189)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx193_tgt
    .local int rx193_pos
    .local int rx193_off
    .local int rx193_eos
    .local int rx193_rep
    .local pmc rx193_cur
    .local pmc rx193_debug
    (rx193_cur, rx193_pos, rx193_tgt, $I10) = self."!cursor_start"()
    rx193_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx193_cur
    .local pmc match
    .lex "$/", match
    length rx193_eos, rx193_tgt
    gt rx193_pos, rx193_eos, rx193_done
    set rx193_off, 0
    lt rx193_pos, 2, rx193_start
    sub rx193_off, rx193_pos, 1
    substr rx193_tgt, rx193_tgt, rx193_off
  rx193_start:
    eq $I10, 1, rx193_restart
    if_null rx193_debug, debug_621
    rx193_cur."!cursor_debug"("START", "name")
  debug_621:
    $I10 = self.'from'()
    ne $I10, -1, rxscan196_done
    goto rxscan196_scan
  rxscan196_loop:
    (rx193_pos) = rx193_cur."from"()
    inc rx193_pos
    rx193_cur."!cursor_from"(rx193_pos)
    ge rx193_pos, rx193_eos, rxscan196_done
  rxscan196_scan:
    set_addr $I10, rxscan196_loop
    rx193_cur."!mark_push"(0, rx193_pos, $I10)
  rxscan196_done:
.annotate 'line', 47
  # rx rxquantr197 ** 1..*
    set_addr $I10, rxquantr197_done
    rx193_cur."!mark_push"(0, -1, $I10)
  rxquantr197_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx193_cur."!cursor_pos"(rx193_pos)
    $P10 = rx193_cur."identifier"()
    unless $P10, rx193_fail
    goto rxsubrule198_pass
  rxsubrule198_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx193_fail
  rxsubrule198_pass:
    set_addr $I10, rxsubrule198_back
    rx193_cur."!mark_push"(0, rx193_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx193_pos = $P10."pos"()
    set_addr $I10, rxquantr197_done
    (rx193_rep) = rx193_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr197_done
    rx193_cur."!mark_push"(rx193_rep, rx193_pos, $I10)
  # rx literal  "::"
    add $I11, rx193_pos, 2
    gt $I11, rx193_eos, rx193_fail
    sub $I11, rx193_pos, rx193_off
    substr $S10, rx193_tgt, $I11, 2
    ne $S10, "::", rx193_fail
    add rx193_pos, 2
    goto rxquantr197_loop
  rxquantr197_done:
  # rx pass
    rx193_cur."!cursor_pass"(rx193_pos, "name")
    if_null rx193_debug, debug_622
    rx193_cur."!cursor_debug"("PASS", "name", " at pos=", rx193_pos)
  debug_622:
    .return (rx193_cur)
  rx193_restart:
.annotate 'line', 10
    if_null rx193_debug, debug_623
    rx193_cur."!cursor_debug"("NEXT", "name")
  debug_623:
  rx193_fail:
    (rx193_rep, rx193_pos, $I10, $P10) = rx193_cur."!mark_fail"(0)
    lt rx193_pos, -1, rx193_done
    eq rx193_pos, -1, rx193_fail
    jump $I10
  rx193_done:
    rx193_cur."!cursor_fail"()
    if_null rx193_debug, debug_624
    rx193_cur."!cursor_debug"("FAIL", "name")
  debug_624:
    .return (rx193_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1303748459.273") :method
.annotate 'line', 10
    new $P195, "ResizablePMCArray"
    push $P195, ""
    .return ($P195)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx200_tgt
    .local int rx200_pos
    .local int rx200_off
    .local int rx200_eos
    .local int rx200_rep
    .local pmc rx200_cur
    .local pmc rx200_debug
    (rx200_cur, rx200_pos, rx200_tgt, $I10) = self."!cursor_start"()
    rx200_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx200_cur
    .local pmc match
    .lex "$/", match
    length rx200_eos, rx200_tgt
    gt rx200_pos, rx200_eos, rx200_done
    set rx200_off, 0
    lt rx200_pos, 2, rx200_start
    sub rx200_off, rx200_pos, 1
    substr rx200_tgt, rx200_tgt, rx200_off
  rx200_start:
    eq $I10, 1, rx200_restart
    if_null rx200_debug, debug_625
    rx200_cur."!cursor_debug"("START", "deflongname")
  debug_625:
    $I10 = self.'from'()
    ne $I10, -1, rxscan204_done
    goto rxscan204_scan
  rxscan204_loop:
    (rx200_pos) = rx200_cur."from"()
    inc rx200_pos
    rx200_cur."!cursor_from"(rx200_pos)
    ge rx200_pos, rx200_eos, rxscan204_done
  rxscan204_scan:
    set_addr $I10, rxscan204_loop
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxscan204_done:
.annotate 'line', 50
  # rx subrule "identifier" subtype=capture negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."identifier"()
    unless $P10, rx200_fail
    rx200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx200_pos = $P10."pos"()
  # rx rxquantr205 ** 0..1
    set_addr $I10, rxquantr205_done
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxquantr205_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."colonpair"()
    unless $P10, rx200_fail
    goto rxsubrule206_pass
  rxsubrule206_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx200_fail
  rxsubrule206_pass:
    set_addr $I10, rxsubrule206_back
    rx200_cur."!mark_push"(0, rx200_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx200_pos = $P10."pos"()
    set_addr $I10, rxquantr205_done
    (rx200_rep) = rx200_cur."!mark_commit"($I10)
  rxquantr205_done:
.annotate 'line', 49
  # rx pass
    rx200_cur."!cursor_pass"(rx200_pos, "deflongname")
    if_null rx200_debug, debug_626
    rx200_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx200_pos)
  debug_626:
    .return (rx200_cur)
  rx200_restart:
.annotate 'line', 10
    if_null rx200_debug, debug_627
    rx200_cur."!cursor_debug"("NEXT", "deflongname")
  debug_627:
  rx200_fail:
    (rx200_rep, rx200_pos, $I10, $P10) = rx200_cur."!mark_fail"(0)
    lt rx200_pos, -1, rx200_done
    eq rx200_pos, -1, rx200_fail
    jump $I10
  rx200_done:
    rx200_cur."!cursor_fail"()
    if_null rx200_debug, debug_628
    rx200_cur."!cursor_debug"("FAIL", "deflongname")
  debug_628:
    .return (rx200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1303748459.273") :method
.annotate 'line', 10
    $P202 = self."!PREFIX__!subrule"("identifier", "")
    new $P203, "ResizablePMCArray"
    push $P203, $P202
    .return ($P203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx208_tgt
    .local int rx208_pos
    .local int rx208_off
    .local int rx208_eos
    .local int rx208_rep
    .local pmc rx208_cur
    .local pmc rx208_debug
    (rx208_cur, rx208_pos, rx208_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx208_cur
    .local pmc match
    .lex "$/", match
    length rx208_eos, rx208_tgt
    gt rx208_pos, rx208_eos, rx208_done
    set rx208_off, 0
    lt rx208_pos, 2, rx208_start
    sub rx208_off, rx208_pos, 1
    substr rx208_tgt, rx208_tgt, rx208_off
  rx208_start:
    eq $I10, 1, rx208_restart
    if_null rx208_debug, debug_629
    rx208_cur."!cursor_debug"("START", "ENDSTMT")
  debug_629:
    $I10 = self.'from'()
    ne $I10, -1, rxscan211_done
    goto rxscan211_scan
  rxscan211_loop:
    (rx208_pos) = rx208_cur."from"()
    inc rx208_pos
    rx208_cur."!cursor_from"(rx208_pos)
    ge rx208_pos, rx208_eos, rxscan211_done
  rxscan211_scan:
    set_addr $I10, rxscan211_loop
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxscan211_done:
.annotate 'line', 57
  # rx rxquantr212 ** 0..1
    set_addr $I10, rxquantr212_done
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxquantr212_loop:
  alt213_0:
.annotate 'line', 54
    set_addr $I10, alt213_1
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
.annotate 'line', 55
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx208_pos, rx208_off
    set rx208_rep, 0
    sub $I12, rx208_eos, rx208_pos
  rxenumcharlistq214_loop:
    le $I12, 0, rxenumcharlistq214_done
    substr $S10, rx208_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq214_done
    inc rx208_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq214_loop
  rxenumcharlistq214_done:
    add rx208_pos, rx208_pos, rx208_rep
  # rxanchor eol
    sub $I10, rx208_pos, rx208_off
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rxanchor215_done
    ne rx208_pos, rx208_eos, rx208_fail
    eq rx208_pos, 0, rxanchor215_done
    dec $I10
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rx208_fail
  rxanchor215_done:
  # rx subrule "ws" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."ws"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."MARKER"("endstmt")
    unless $P10, rx208_fail
    goto alt213_end
  alt213_1:
.annotate 'line', 56
  # rx rxquantr216 ** 0..1
    set_addr $I10, rxquantr216_done
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxquantr216_loop:
  # rx subrule "unv" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."unv"()
    unless $P10, rx208_fail
    goto rxsubrule217_pass
  rxsubrule217_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx208_fail
  rxsubrule217_pass:
    set_addr $I10, rxsubrule217_back
    rx208_cur."!mark_push"(0, rx208_pos, $I10, $P10)
    rx208_pos = $P10."pos"()
    set_addr $I10, rxquantr216_done
    (rx208_rep) = rx208_cur."!mark_commit"($I10)
  rxquantr216_done:
  # rxanchor eol
    sub $I10, rx208_pos, rx208_off
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rxanchor218_done
    ne rx208_pos, rx208_eos, rx208_fail
    eq rx208_pos, 0, rxanchor218_done
    dec $I10
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rx208_fail
  rxanchor218_done:
  # rx subrule "ws" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."ws"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."MARKER"("endstmt")
    unless $P10, rx208_fail
  alt213_end:
.annotate 'line', 57
    set_addr $I10, rxquantr212_done
    (rx208_rep) = rx208_cur."!mark_commit"($I10)
  rxquantr212_done:
.annotate 'line', 53
  # rx pass
    rx208_cur."!cursor_pass"(rx208_pos, "ENDSTMT")
    if_null rx208_debug, debug_630
    rx208_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx208_pos)
  debug_630:
    .return (rx208_cur)
  rx208_restart:
.annotate 'line', 10
    if_null rx208_debug, debug_631
    rx208_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_631:
  rx208_fail:
    (rx208_rep, rx208_pos, $I10, $P10) = rx208_cur."!mark_fail"(0)
    lt rx208_pos, -1, rx208_done
    eq rx208_pos, -1, rx208_fail
    jump $I10
  rx208_done:
    rx208_cur."!cursor_fail"()
    if_null rx208_debug, debug_632
    rx208_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_632:
    .return (rx208_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1303748459.273") :method
.annotate 'line', 10
    new $P210, "ResizablePMCArray"
    push $P210, ""
    .return ($P210)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx220_tgt
    .local int rx220_pos
    .local int rx220_off
    .local int rx220_eos
    .local int rx220_rep
    .local pmc rx220_cur
    .local pmc rx220_debug
    (rx220_cur, rx220_pos, rx220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx220_cur
    .local pmc match
    .lex "$/", match
    length rx220_eos, rx220_tgt
    gt rx220_pos, rx220_eos, rx220_done
    set rx220_off, 0
    lt rx220_pos, 2, rx220_start
    sub rx220_off, rx220_pos, 1
    substr rx220_tgt, rx220_tgt, rx220_off
  rx220_start:
    eq $I10, 1, rx220_restart
    if_null rx220_debug, debug_633
    rx220_cur."!cursor_debug"("START", "ws")
  debug_633:
    $I10 = self.'from'()
    ne $I10, -1, rxscan223_done
    goto rxscan223_scan
  rxscan223_loop:
    (rx220_pos) = rx220_cur."from"()
    inc rx220_pos
    rx220_cur."!cursor_from"(rx220_pos)
    ge rx220_pos, rx220_eos, rxscan223_done
  rxscan223_scan:
    set_addr $I10, rxscan223_loop
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxscan223_done:
  alt224_0:
.annotate 'line', 60
    set_addr $I10, alt224_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
.annotate 'line', 61
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."MARKED"("ws")
    unless $P10, rx220_fail
    goto alt224_end
  alt224_1:
.annotate 'line', 62
  # rx subrule "ww" subtype=zerowidth negate=1
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."ww"()
    if $P10, rx220_fail
.annotate 'line', 67
  # rx rxquantr225 ** 0..*
    set_addr $I10, rxquantr225_done
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxquantr225_loop:
  alt226_0:
.annotate 'line', 63
    set_addr $I10, alt226_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx220_pos, rx220_off
    set rx220_rep, 0
    sub $I12, rx220_eos, rx220_pos
  rxenumcharlistq227_loop:
    le $I12, 0, rxenumcharlistq227_done
    substr $S10, rx220_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq227_done
    inc rx220_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq227_loop
  rxenumcharlistq227_done:
    lt rx220_rep, 1, rx220_fail
    add rx220_pos, rx220_pos, rx220_rep
    goto alt226_end
  alt226_1:
    set_addr $I10, alt226_2
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
.annotate 'line', 64
  # rx literal  "#"
    add $I11, rx220_pos, 1
    gt $I11, rx220_eos, rx220_fail
    sub $I11, rx220_pos, rx220_off
    ord $I11, rx220_tgt, $I11
    ne $I11, 35, rx220_fail
    add rx220_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx220_pos, rx220_off
    find_cclass $I11, 4096, rx220_tgt, $I10, rx220_eos
    add rx220_pos, rx220_off, $I11
    goto alt226_end
  alt226_2:
    set_addr $I10, alt226_3
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
.annotate 'line', 65
  # rxanchor bol
    eq rx220_pos, 0, rxanchor228_done
    ge rx220_pos, rx220_eos, rx220_fail
    sub $I10, rx220_pos, rx220_off
    dec $I10
    is_cclass $I11, 4096, rx220_tgt, $I10
    unless $I11, rx220_fail
  rxanchor228_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."pod_comment"()
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
    goto alt226_end
  alt226_3:
.annotate 'line', 66
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx220_pos, rx220_off
    set rx220_rep, 0
    sub $I12, rx220_eos, rx220_pos
  rxenumcharlistq229_loop:
    le $I12, 0, rxenumcharlistq229_done
    substr $S10, rx220_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq229_done
    inc rx220_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq229_loop
  rxenumcharlistq229_done:
    lt rx220_rep, 1, rx220_fail
    add rx220_pos, rx220_pos, rx220_rep
  alt226_end:
.annotate 'line', 67
    set_addr $I10, rxquantr225_done
    (rx220_rep) = rx220_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr225_done
    rx220_cur."!mark_push"(rx220_rep, rx220_pos, $I10)
    goto rxquantr225_loop
  rxquantr225_done:
.annotate 'line', 68
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."MARKER"("ws")
    unless $P10, rx220_fail
  alt224_end:
.annotate 'line', 60
  # rx pass
    rx220_cur."!cursor_pass"(rx220_pos, "ws")
    if_null rx220_debug, debug_634
    rx220_cur."!cursor_debug"("PASS", "ws", " at pos=", rx220_pos)
  debug_634:
    .return (rx220_cur)
  rx220_restart:
.annotate 'line', 10
    if_null rx220_debug, debug_635
    rx220_cur."!cursor_debug"("NEXT", "ws")
  debug_635:
  rx220_fail:
    (rx220_rep, rx220_pos, $I10, $P10) = rx220_cur."!mark_fail"(0)
    lt rx220_pos, -1, rx220_done
    eq rx220_pos, -1, rx220_fail
    jump $I10
  rx220_done:
    rx220_cur."!cursor_fail"()
    if_null rx220_debug, debug_636
    rx220_cur."!cursor_debug"("FAIL", "ws")
  debug_636:
    .return (rx220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1303748459.273") :method
.annotate 'line', 10
    new $P222, "ResizablePMCArray"
    push $P222, ""
    push $P222, ""
    .return ($P222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P238 = "26_1303748459.273" 
    capture_lex $P238
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_637
    rx231_cur."!cursor_debug"("START", "unv")
  debug_637:
    $I10 = self.'from'()
    ne $I10, -1, rxscan234_done
    goto rxscan234_scan
  rxscan234_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan234_done
  rxscan234_scan:
    set_addr $I10, rxscan234_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan234_done:
  alt235_0:
.annotate 'line', 73
    set_addr $I10, alt235_1
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
.annotate 'line', 74
  # rxanchor bol
    eq rx231_pos, 0, rxanchor236_done
    ge rx231_pos, rx231_eos, rx231_fail
    sub $I10, rx231_pos, rx231_off
    dec $I10
    is_cclass $I11, 4096, rx231_tgt, $I10
    unless $I11, rx231_fail
  rxanchor236_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    .const 'Sub' $P238 = "26_1303748459.273" 
    capture_lex $P238
    $P10 = rx231_cur."before"($P238)
    unless $P10, rx231_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."pod_comment"()
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
    goto alt235_end
  alt235_1:
    set_addr $I10, alt235_2
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
.annotate 'line', 75
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx231_pos, rx231_off
    set rx231_rep, 0
    sub $I12, rx231_eos, rx231_pos
  rxenumcharlistq243_loop:
    le $I12, 0, rxenumcharlistq243_done
    substr $S10, rx231_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq243_done
    inc rx231_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq243_loop
  rxenumcharlistq243_done:
    add rx231_pos, rx231_pos, rx231_rep
  # rx literal  "#"
    add $I11, rx231_pos, 1
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    ord $I11, rx231_tgt, $I11
    ne $I11, 35, rx231_fail
    add rx231_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx231_pos, rx231_off
    find_cclass $I11, 4096, rx231_tgt, $I10, rx231_eos
    add rx231_pos, rx231_off, $I11
    goto alt235_end
  alt235_2:
.annotate 'line', 76
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx231_pos, rx231_off
    set rx231_rep, 0
    sub $I12, rx231_eos, rx231_pos
  rxenumcharlistq244_loop:
    le $I12, 0, rxenumcharlistq244_done
    substr $S10, rx231_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq244_done
    inc rx231_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq244_loop
  rxenumcharlistq244_done:
    lt rx231_rep, 1, rx231_fail
    add rx231_pos, rx231_pos, rx231_rep
  alt235_end:
.annotate 'line', 71
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "unv")
    if_null rx231_debug, debug_642
    rx231_cur."!cursor_debug"("PASS", "unv", " at pos=", rx231_pos)
  debug_642:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 10
    if_null rx231_debug, debug_643
    rx231_cur."!cursor_debug"("NEXT", "unv")
  debug_643:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_644
    rx231_cur."!cursor_debug"("FAIL", "unv")
  debug_644:
    .return (rx231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1303748459.273") :method
.annotate 'line', 10
    new $P233, "ResizablePMCArray"
    push $P233, ""
    push $P233, ""
    push $P233, ""
    .return ($P233)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block237"  :anon :subid("26_1303748459.273") :method :outer("24_1303748459.273")
.annotate 'line', 74
    .local string rx239_tgt
    .local int rx239_pos
    .local int rx239_off
    .local int rx239_eos
    .local int rx239_rep
    .local pmc rx239_cur
    .local pmc rx239_debug
    (rx239_cur, rx239_pos, rx239_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx239_cur
    .local pmc match
    .lex "$/", match
    length rx239_eos, rx239_tgt
    gt rx239_pos, rx239_eos, rx239_done
    set rx239_off, 0
    lt rx239_pos, 2, rx239_start
    sub rx239_off, rx239_pos, 1
    substr rx239_tgt, rx239_tgt, rx239_off
  rx239_start:
    eq $I10, 1, rx239_restart
    if_null rx239_debug, debug_638
    rx239_cur."!cursor_debug"("START", "")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan240_done
    goto rxscan240_scan
  rxscan240_loop:
    (rx239_pos) = rx239_cur."from"()
    inc rx239_pos
    rx239_cur."!cursor_from"(rx239_pos)
    ge rx239_pos, rx239_eos, rxscan240_done
  rxscan240_scan:
    set_addr $I10, rxscan240_loop
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  rxscan240_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx239_pos, rx239_off
    set rx239_rep, 0
    sub $I12, rx239_eos, rx239_pos
  rxenumcharlistq241_loop:
    le $I12, 0, rxenumcharlistq241_done
    substr $S10, rx239_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq241_done
    inc rx239_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq241_loop
  rxenumcharlistq241_done:
    add rx239_pos, rx239_pos, rx239_rep
  # rx literal  "="
    add $I11, rx239_pos, 1
    gt $I11, rx239_eos, rx239_fail
    sub $I11, rx239_pos, rx239_off
    ord $I11, rx239_tgt, $I11
    ne $I11, 61, rx239_fail
    add rx239_pos, 1
  alt242_0:
    set_addr $I10, alt242_1
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  # rx charclass w
    ge rx239_pos, rx239_eos, rx239_fail
    sub $I10, rx239_pos, rx239_off
    is_cclass $I11, 8192, rx239_tgt, $I10
    unless $I11, rx239_fail
    inc rx239_pos
    goto alt242_end
  alt242_1:
  # rx literal  "\\"
    add $I11, rx239_pos, 1
    gt $I11, rx239_eos, rx239_fail
    sub $I11, rx239_pos, rx239_off
    ord $I11, rx239_tgt, $I11
    ne $I11, 92, rx239_fail
    add rx239_pos, 1
  alt242_end:
  # rx pass
    rx239_cur."!cursor_pass"(rx239_pos, "")
    if_null rx239_debug, debug_639
    rx239_cur."!cursor_debug"("PASS", "", " at pos=", rx239_pos)
  debug_639:
    .return (rx239_cur)
  rx239_restart:
    if_null rx239_debug, debug_640
    rx239_cur."!cursor_debug"("NEXT", "")
  debug_640:
  rx239_fail:
    (rx239_rep, rx239_pos, $I10, $P10) = rx239_cur."!mark_fail"(0)
    lt rx239_pos, -1, rx239_done
    eq rx239_pos, -1, rx239_fail
    jump $I10
  rx239_done:
    rx239_cur."!cursor_fail"()
    if_null rx239_debug, debug_641
    rx239_cur."!cursor_debug"("FAIL", "")
  debug_641:
    .return (rx239_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P277 = "29_1303748459.273" 
    capture_lex $P277
    .local string rx246_tgt
    .local int rx246_pos
    .local int rx246_off
    .local int rx246_eos
    .local int rx246_rep
    .local pmc rx246_cur
    .local pmc rx246_debug
    (rx246_cur, rx246_pos, rx246_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx246_cur
    .local pmc match
    .lex "$/", match
    length rx246_eos, rx246_tgt
    gt rx246_pos, rx246_eos, rx246_done
    set rx246_off, 0
    lt rx246_pos, 2, rx246_start
    sub rx246_off, rx246_pos, 1
    substr rx246_tgt, rx246_tgt, rx246_off
  rx246_start:
    eq $I10, 1, rx246_restart
    if_null rx246_debug, debug_645
    rx246_cur."!cursor_debug"("START", "pod_comment")
  debug_645:
    $I10 = self.'from'()
    ne $I10, -1, rxscan249_done
    goto rxscan249_scan
  rxscan249_loop:
    (rx246_pos) = rx246_cur."from"()
    inc rx246_pos
    rx246_cur."!cursor_from"(rx246_pos)
    ge rx246_pos, rx246_eos, rxscan249_done
  rxscan249_scan:
    set_addr $I10, rxscan249_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  rxscan249_done:
.annotate 'line', 81
  # rxanchor bol
    eq rx246_pos, 0, rxanchor250_done
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    dec $I10
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
  rxanchor250_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq251_loop:
    le $I12, 0, rxenumcharlistq251_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq251_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq251_loop
  rxenumcharlistq251_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "="
    add $I11, rx246_pos, 1
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    ord $I11, rx246_tgt, $I11
    ne $I11, 61, rx246_fail
    add rx246_pos, 1
  alt252_0:
.annotate 'line', 82
    set_addr $I10, alt252_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 83
  # rx literal  "begin"
    add $I11, rx246_pos, 5
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 5
    ne $S10, "begin", rx246_fail
    add rx246_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq253_loop:
    le $I12, 0, rxenumcharlistq253_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq253_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq253_loop
  rxenumcharlistq253_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "END"
    add $I11, rx246_pos, 3
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 3
    ne $S10, "END", rx246_fail
    add rx246_pos, 3
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  alt254_0:
.annotate 'line', 84
    set_addr $I10, alt254_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rx rxquantf255 ** 0..*
    set_addr $I10, rxquantf255_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf255_done
  rxquantf255_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf255_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf255_done:
  # rx charclass nl
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
    substr $S10, rx246_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx246_pos, $I11
    inc rx246_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq257_loop:
    le $I12, 0, rxenumcharlistq257_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq257_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq257_loop
  rxenumcharlistq257_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "=end"
    add $I11, rx246_pos, 4
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 4
    ne $S10, "=end", rx246_fail
    add rx246_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq258_loop:
    le $I12, 0, rxenumcharlistq258_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq258_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq258_loop
  rxenumcharlistq258_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "END"
    add $I11, rx246_pos, 3
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 3
    ne $S10, "END", rx246_fail
    add rx246_pos, 3
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
    goto alt254_end
  alt254_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_not_cclass $I11, 65535, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
  alt254_end:
.annotate 'line', 83
    goto alt252_end
  alt252_1:
    set_addr $I10, alt252_2
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 85
  # rx literal  "begin"
    add $I11, rx246_pos, 5
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 5
    ne $S10, "begin", rx246_fail
    add rx246_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq259_loop:
    le $I12, 0, rxenumcharlistq259_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq259_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq259_loop
  rxenumcharlistq259_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx subrule "identifier" subtype=capture negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."identifier"()
    unless $P10, rx246_fail
    rx246_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx246_pos = $P10."pos"()
  alt260_0:
.annotate 'line', 86
    set_addr $I10, alt260_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 87
  # rx rxquantf261 ** 0..*
    set_addr $I10, rxquantf261_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf261_done
  rxquantf261_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf261_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf261_done:
  # rx charclass nl
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
    substr $S10, rx246_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx246_pos, $I11
    inc rx246_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq263_loop:
    le $I12, 0, rxenumcharlistq263_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq263_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq263_loop
  rxenumcharlistq263_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "=end"
    add $I11, rx246_pos, 4
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 4
    ne $S10, "=end", rx246_fail
    add rx246_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq264_loop:
    le $I12, 0, rxenumcharlistq264_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq264_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq264_loop
  rxenumcharlistq264_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."!BACKREF"("identifier")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
    goto alt260_end
  alt260_1:
.annotate 'line', 88
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("=begin without matching =end")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt260_end:
.annotate 'line', 85
    goto alt252_end
  alt252_2:
    set_addr $I10, alt252_3
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 90
  # rx literal  "begin"
    add $I11, rx246_pos, 5
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 5
    ne $S10, "begin", rx246_fail
    add rx246_pos, 5
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq266_loop:
    le $I12, 0, rxenumcharlistq266_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq266_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq266_loop
  rxenumcharlistq266_done:
    add rx246_pos, rx246_pos, rx246_rep
  alt267_0:
.annotate 'line', 91
    set_addr $I10, alt267_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rxanchor eol
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    if $I11, rxanchor268_done
    ne rx246_pos, rx246_eos, rx246_fail
    eq rx246_pos, 0, rxanchor268_done
    dec $I10
    is_cclass $I11, 4096, rx246_tgt, $I10
    if $I11, rx246_fail
  rxanchor268_done:
    goto alt267_end
  alt267_1:
    set_addr $I10, alt267_2
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rx literal  "#"
    add $I11, rx246_pos, 1
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    ord $I11, rx246_tgt, $I11
    ne $I11, 35, rx246_fail
    add rx246_pos, 1
    goto alt267_end
  alt267_2:
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt267_end:
  alt269_0:
.annotate 'line', 92
    set_addr $I10, alt269_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 93
  # rx rxquantf270 ** 0..*
    set_addr $I10, rxquantf270_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf270_done
  rxquantf270_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf270_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf270_done:
  # rx charclass nl
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
    substr $S10, rx246_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx246_pos, $I11
    inc rx246_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq272_loop:
    le $I12, 0, rxenumcharlistq272_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq272_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq272_loop
  rxenumcharlistq272_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "=end"
    add $I11, rx246_pos, 4
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 4
    ne $S10, "=end", rx246_fail
    add rx246_pos, 4
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
    goto alt269_end
  alt269_1:
.annotate 'line', 94
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("=begin without matching =end")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt269_end:
.annotate 'line', 90
    goto alt252_end
  alt252_3:
    set_addr $I10, alt252_4
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 96
  # rx subrule "identifier" subtype=capture negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."identifier"()
    unless $P10, rx246_fail
    rx246_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx246_pos = $P10."pos"()
.annotate 'line', 97
  # rx rxquantf273 ** 0..*
    set_addr $I10, rxquantf273_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf273_done
  rxquantf273_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf273_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf273_done:
  # rxanchor bol
    eq rx246_pos, 0, rxanchor275_done
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    dec $I10
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
  rxanchor275_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    .const 'Sub' $P277 = "29_1303748459.273" 
    capture_lex $P277
    $P10 = rx246_cur."before"($P277)
    unless $P10, rx246_fail
.annotate 'line', 96
    goto alt252_end
  alt252_4:
  alt283_0:
.annotate 'line', 103
    set_addr $I10, alt283_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rx charclass s
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 32, rx246_tgt, $I10
    unless $I11, rx246_fail
    inc rx246_pos
    goto alt283_end
  alt283_1:
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("Illegal pod directive")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt283_end:
.annotate 'line', 104
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
  alt252_end:
.annotate 'line', 80
  # rx pass
    rx246_cur."!cursor_pass"(rx246_pos, "pod_comment")
    if_null rx246_debug, debug_650
    rx246_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx246_pos)
  debug_650:
    .return (rx246_cur)
  rx246_restart:
.annotate 'line', 10
    if_null rx246_debug, debug_651
    rx246_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_651:
  rx246_fail:
    (rx246_rep, rx246_pos, $I10, $P10) = rx246_cur."!mark_fail"(0)
    lt rx246_pos, -1, rx246_done
    eq rx246_pos, -1, rx246_fail
    jump $I10
  rx246_done:
    rx246_cur."!cursor_fail"()
    if_null rx246_debug, debug_652
    rx246_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_652:
    .return (rx246_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1303748459.273") :method
.annotate 'line', 10
    new $P248, "ResizablePMCArray"
    push $P248, ""
    .return ($P248)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block276"  :anon :subid("29_1303748459.273") :method :outer("27_1303748459.273")
.annotate 'line', 97
    .local string rx278_tgt
    .local int rx278_pos
    .local int rx278_off
    .local int rx278_eos
    .local int rx278_rep
    .local pmc rx278_cur
    .local pmc rx278_debug
    (rx278_cur, rx278_pos, rx278_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx278_cur
    .local pmc match
    .lex "$/", match
    length rx278_eos, rx278_tgt
    gt rx278_pos, rx278_eos, rx278_done
    set rx278_off, 0
    lt rx278_pos, 2, rx278_start
    sub rx278_off, rx278_pos, 1
    substr rx278_tgt, rx278_tgt, rx278_off
  rx278_start:
    eq $I10, 1, rx278_restart
    if_null rx278_debug, debug_646
    rx278_cur."!cursor_debug"("START", "")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan279_done
    goto rxscan279_scan
  rxscan279_loop:
    (rx278_pos) = rx278_cur."from"()
    inc rx278_pos
    rx278_cur."!cursor_from"(rx278_pos)
    ge rx278_pos, rx278_eos, rxscan279_done
  rxscan279_scan:
    set_addr $I10, rxscan279_loop
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
  rxscan279_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx278_pos, rx278_off
    set rx278_rep, 0
    sub $I12, rx278_eos, rx278_pos
  rxenumcharlistq280_loop:
    le $I12, 0, rxenumcharlistq280_done
    substr $S10, rx278_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq280_done
    inc rx278_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq280_loop
  rxenumcharlistq280_done:
    add rx278_pos, rx278_pos, rx278_rep
  alt281_0:
    set_addr $I10, alt281_1
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
.annotate 'line', 98
  # rx literal  "="
    add $I11, rx278_pos, 1
    gt $I11, rx278_eos, rx278_fail
    sub $I11, rx278_pos, rx278_off
    ord $I11, rx278_tgt, $I11
    ne $I11, 61, rx278_fail
    add rx278_pos, 1
.annotate 'line', 100
  # rx rxquantr282 ** 0..1
    set_addr $I10, rxquantr282_done
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
  rxquantr282_loop:
.annotate 'line', 99
  # rx literal  "cut"
    add $I11, rx278_pos, 3
    gt $I11, rx278_eos, rx278_fail
    sub $I11, rx278_pos, rx278_off
    substr $S10, rx278_tgt, $I11, 3
    ne $S10, "cut", rx278_fail
    add rx278_pos, 3
  # rxanchor rwb
    le rx278_pos, 0, rx278_fail
    sub $I10, rx278_pos, rx278_off
    is_cclass $I11, 8192, rx278_tgt, $I10
    if $I11, rx278_fail
    dec $I10
    is_cclass $I11, 8192, rx278_tgt, $I10
    unless $I11, rx278_fail
.annotate 'line', 100
  # rx subrule "panic" subtype=method negate=
    rx278_cur."!cursor_pos"(rx278_pos)
    $P10 = rx278_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx278_fail
    rx278_pos = $P10."pos"()
    set_addr $I10, rxquantr282_done
    (rx278_rep) = rx278_cur."!mark_commit"($I10)
  rxquantr282_done:
.annotate 'line', 97
    goto alt281_end
  alt281_1:
.annotate 'line', 101
  # rx charclass nl
    ge rx278_pos, rx278_eos, rx278_fail
    sub $I10, rx278_pos, rx278_off
    is_cclass $I11, 4096, rx278_tgt, $I10
    unless $I11, rx278_fail
    substr $S10, rx278_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx278_pos, $I11
    inc rx278_pos
  alt281_end:
.annotate 'line', 97
  # rx pass
    rx278_cur."!cursor_pass"(rx278_pos, "")
    if_null rx278_debug, debug_647
    rx278_cur."!cursor_debug"("PASS", "", " at pos=", rx278_pos)
  debug_647:
    .return (rx278_cur)
  rx278_restart:
    if_null rx278_debug, debug_648
    rx278_cur."!cursor_debug"("NEXT", "")
  debug_648:
  rx278_fail:
    (rx278_rep, rx278_pos, $I10, $P10) = rx278_cur."!mark_fail"(0)
    lt rx278_pos, -1, rx278_done
    eq rx278_pos, -1, rx278_fail
    jump $I10
  rx278_done:
    rx278_cur."!cursor_fail"()
    if_null rx278_debug, debug_649
    rx278_cur."!cursor_debug"("FAIL", "")
  debug_649:
    .return (rx278_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 112
    new $P285, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P285
.annotate 'line', 113
    new $P286, "Undef"
    .lex "$*MAIN_SUB", $P286
.annotate 'line', 116
    new $P287, "Undef"
    .lex "$*PACKAGE", $P287
.annotate 'line', 117
    new $P288, "Undef"
    .lex "$*GLOBALish", $P288
.annotate 'line', 10
    .local string rx289_tgt
    .local int rx289_pos
    .local int rx289_off
    .local int rx289_eos
    .local int rx289_rep
    .local pmc rx289_cur
    .local pmc rx289_debug
    (rx289_cur, rx289_pos, rx289_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx289_cur
    .local pmc match
    .lex "$/", match
    length rx289_eos, rx289_tgt
    gt rx289_pos, rx289_eos, rx289_done
    set rx289_off, 0
    lt rx289_pos, 2, rx289_start
    sub rx289_off, rx289_pos, 1
    substr rx289_tgt, rx289_tgt, rx289_off
  rx289_start:
    eq $I10, 1, rx289_restart
    if_null rx289_debug, debug_653
    rx289_cur."!cursor_debug"("START", "comp_unit")
  debug_653:
    $I10 = self.'from'()
    ne $I10, -1, rxscan293_done
    goto rxscan293_scan
  rxscan293_loop:
    (rx289_pos) = rx289_cur."from"()
    inc rx289_pos
    rx289_cur."!cursor_from"(rx289_pos)
    ge rx289_pos, rx289_eos, rxscan293_done
  rxscan293_scan:
    set_addr $I10, rxscan293_loop
    rx289_cur."!mark_push"(0, rx289_pos, $I10)
  rxscan293_done:
.annotate 'line', 112
    rx289_cur."!cursor_pos"(rx289_pos)
    new $P294, "Integer"
    assign $P294, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P294
.annotate 'line', 113
    rx289_cur."!cursor_pos"(rx289_pos)
    find_lex $P297, "$*MAIN_SUB"
    unless_null $P297, vivify_654
    get_hll_global $P295, "GLOBAL"
    get_who $P296, $P295
    set $P297, $P296["$MAIN_SUB"]
    unless_null $P297, vivify_655
    die "Contextual $*MAIN_SUB not found"
  vivify_655:
  vivify_654:
.annotate 'line', 114
  # rx subrule "newpad" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."newpad"()
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
.annotate 'line', 116
    rx289_cur."!cursor_pos"(rx289_pos)
    find_lex $P300, "$*PACKAGE"
    unless_null $P300, vivify_656
    get_hll_global $P298, "GLOBAL"
    get_who $P299, $P298
    set $P300, $P299["$PACKAGE"]
    unless_null $P300, vivify_657
    die "Contextual $*PACKAGE not found"
  vivify_657:
  vivify_656:
.annotate 'line', 117
    rx289_cur."!cursor_pos"(rx289_pos)
    find_lex $P303, "$*GLOBALish"
    unless_null $P303, vivify_658
    get_hll_global $P301, "GLOBAL"
    get_who $P302, $P301
    set $P303, $P302["$GLOBALish"]
    unless_null $P303, vivify_659
    die "Contextual $*GLOBALish not found"
  vivify_659:
  vivify_658:
.annotate 'line', 118
  # rx subrule "GLOBALish" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."GLOBALish"()
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
.annotate 'line', 120
  # rx subrule "outerctx" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."outerctx"()
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
.annotate 'line', 122
  # rx subrule "statementlist" subtype=capture negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."statementlist"()
    unless $P10, rx289_fail
    rx289_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx289_pos = $P10."pos"()
  alt304_0:
.annotate 'line', 123
    set_addr $I10, alt304_1
    rx289_cur."!mark_push"(0, rx289_pos, $I10)
  # rxanchor eos
    ne rx289_pos, rx289_eos, rx289_fail
    goto alt304_end
  alt304_1:
  # rx subrule "panic" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."panic"("Confused")
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
  alt304_end:
.annotate 'line', 111
  # rx pass
    rx289_cur."!cursor_pass"(rx289_pos, "comp_unit")
    if_null rx289_debug, debug_660
    rx289_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx289_pos)
  debug_660:
    .return (rx289_cur)
  rx289_restart:
.annotate 'line', 10
    if_null rx289_debug, debug_661
    rx289_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_661:
  rx289_fail:
    (rx289_rep, rx289_pos, $I10, $P10) = rx289_cur."!mark_fail"(0)
    lt rx289_pos, -1, rx289_done
    eq rx289_pos, -1, rx289_fail
    jump $I10
  rx289_done:
    rx289_cur."!cursor_fail"()
    if_null rx289_debug, debug_662
    rx289_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_662:
    .return (rx289_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1303748459.273") :method
.annotate 'line', 10
    $P291 = self."!PREFIX__!subrule"("newpad", "")
    new $P292, "ResizablePMCArray"
    push $P292, $P291
    .return ($P292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx306_tgt
    .local int rx306_pos
    .local int rx306_off
    .local int rx306_eos
    .local int rx306_rep
    .local pmc rx306_cur
    .local pmc rx306_debug
    (rx306_cur, rx306_pos, rx306_tgt, $I10) = self."!cursor_start"()
    rx306_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx306_cur
    .local pmc match
    .lex "$/", match
    length rx306_eos, rx306_tgt
    gt rx306_pos, rx306_eos, rx306_done
    set rx306_off, 0
    lt rx306_pos, 2, rx306_start
    sub rx306_off, rx306_pos, 1
    substr rx306_tgt, rx306_tgt, rx306_off
  rx306_start:
    eq $I10, 1, rx306_restart
    if_null rx306_debug, debug_663
    rx306_cur."!cursor_debug"("START", "statementlist")
  debug_663:
    $I10 = self.'from'()
    ne $I10, -1, rxscan311_done
    goto rxscan311_scan
  rxscan311_loop:
    (rx306_pos) = rx306_cur."from"()
    inc rx306_pos
    rx306_cur."!cursor_from"(rx306_pos)
    ge rx306_pos, rx306_eos, rxscan311_done
  rxscan311_scan:
    set_addr $I10, rxscan311_loop
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
  rxscan311_done:
  alt312_0:
.annotate 'line', 126
    set_addr $I10, alt312_1
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
.annotate 'line', 127
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  # rxanchor eos
    ne rx306_pos, rx306_eos, rx306_fail
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
    goto alt312_end
  alt312_1:
.annotate 'line', 128
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  # rx rxquantr316 ** 0..*
    set_addr $I10, rxquantr316_done
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
  rxquantr316_loop:
  # rx subrule "statement" subtype=capture negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."statement"()
    unless $P10, rx306_fail
    rx306_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx306_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."eat_terminator"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
    set_addr $I10, rxquantr316_done
    (rx306_rep) = rx306_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr316_done
    rx306_cur."!mark_push"(rx306_rep, rx306_pos, $I10)
    goto rxquantr316_loop
  rxquantr316_done:
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  alt312_end:
.annotate 'line', 126
  # rx pass
    rx306_cur."!cursor_pass"(rx306_pos, "statementlist")
    if_null rx306_debug, debug_664
    rx306_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx306_pos)
  debug_664:
    .return (rx306_cur)
  rx306_restart:
.annotate 'line', 10
    if_null rx306_debug, debug_665
    rx306_cur."!cursor_debug"("NEXT", "statementlist")
  debug_665:
  rx306_fail:
    (rx306_rep, rx306_pos, $I10, $P10) = rx306_cur."!mark_fail"(0)
    lt rx306_pos, -1, rx306_done
    eq rx306_pos, -1, rx306_fail
    jump $I10
  rx306_done:
    rx306_cur."!cursor_fail"()
    if_null rx306_debug, debug_666
    rx306_cur."!cursor_debug"("FAIL", "statementlist")
  debug_666:
    .return (rx306_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1303748459.273") :method
.annotate 'line', 10
    $P308 = self."!PREFIX__!subrule"("ws", "")
    $P309 = self."!PREFIX__!subrule"("ws", "")
    new $P310, "ResizablePMCArray"
    push $P310, $P308
    push $P310, $P309
    .return ($P310)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P325 = "36_1303748459.273" 
    capture_lex $P325
    .local string rx320_tgt
    .local int rx320_pos
    .local int rx320_off
    .local int rx320_eos
    .local int rx320_rep
    .local pmc rx320_cur
    .local pmc rx320_debug
    (rx320_cur, rx320_pos, rx320_tgt, $I10) = self."!cursor_start"()
    rx320_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx320_cur
    .local pmc match
    .lex "$/", match
    length rx320_eos, rx320_tgt
    gt rx320_pos, rx320_eos, rx320_done
    set rx320_off, 0
    lt rx320_pos, 2, rx320_start
    sub rx320_off, rx320_pos, 1
    substr rx320_tgt, rx320_tgt, rx320_off
  rx320_start:
    eq $I10, 1, rx320_restart
    if_null rx320_debug, debug_667
    rx320_cur."!cursor_debug"("START", "statement")
  debug_667:
    $I10 = self.'from'()
    ne $I10, -1, rxscan323_done
    goto rxscan323_scan
  rxscan323_loop:
    (rx320_pos) = rx320_cur."from"()
    inc rx320_pos
    rx320_cur."!cursor_from"(rx320_pos)
    ge rx320_pos, rx320_eos, rxscan323_done
  rxscan323_scan:
    set_addr $I10, rxscan323_loop
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxscan323_done:
.annotate 'line', 132
  # rx subrule "before" subtype=zerowidth negate=1
    rx320_cur."!cursor_pos"(rx320_pos)
    .const 'Sub' $P325 = "36_1303748459.273" 
    capture_lex $P325
    $P10 = rx320_cur."before"($P325)
    if $P10, rx320_fail
  alt329_0:
.annotate 'line', 133
    set_addr $I10, alt329_1
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
.annotate 'line', 134
  # rx subrule "statement_control" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_control"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx320_pos = $P10."pos"()
    goto alt329_end
  alt329_1:
.annotate 'line', 135
  # rx subrule "EXPR" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."EXPR"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx320_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
.annotate 'line', 140
  # rx rxquantr330 ** 0..1
    set_addr $I10, rxquantr330_done
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxquantr330_loop:
  alt331_0:
.annotate 'line', 136
    set_addr $I10, alt331_1
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
.annotate 'line', 137
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."MARKED"("endstmt")
    unless $P10, rx320_fail
    goto alt331_end
  alt331_1:
    set_addr $I10, alt331_2
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
.annotate 'line', 138
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_mod_cond"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx320_pos = $P10."pos"()
  # rx rxquantr332 ** 0..1
    set_addr $I10, rxquantr332_done
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxquantr332_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_mod_loop"()
    unless $P10, rx320_fail
    goto rxsubrule333_pass
  rxsubrule333_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx320_fail
  rxsubrule333_pass:
    set_addr $I10, rxsubrule333_back
    rx320_cur."!mark_push"(0, rx320_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx320_pos = $P10."pos"()
    set_addr $I10, rxquantr332_done
    (rx320_rep) = rx320_cur."!mark_commit"($I10)
  rxquantr332_done:
    goto alt331_end
  alt331_2:
.annotate 'line', 139
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_mod_loop"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx320_pos = $P10."pos"()
  alt331_end:
.annotate 'line', 140
    set_addr $I10, rxquantr330_done
    (rx320_rep) = rx320_cur."!mark_commit"($I10)
  rxquantr330_done:
  alt329_end:
.annotate 'line', 131
  # rx pass
    rx320_cur."!cursor_pass"(rx320_pos, "statement")
    if_null rx320_debug, debug_672
    rx320_cur."!cursor_debug"("PASS", "statement", " at pos=", rx320_pos)
  debug_672:
    .return (rx320_cur)
  rx320_restart:
.annotate 'line', 10
    if_null rx320_debug, debug_673
    rx320_cur."!cursor_debug"("NEXT", "statement")
  debug_673:
  rx320_fail:
    (rx320_rep, rx320_pos, $I10, $P10) = rx320_cur."!mark_fail"(0)
    lt rx320_pos, -1, rx320_done
    eq rx320_pos, -1, rx320_fail
    jump $I10
  rx320_done:
    rx320_cur."!cursor_fail"()
    if_null rx320_debug, debug_674
    rx320_cur."!cursor_debug"("FAIL", "statement")
  debug_674:
    .return (rx320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1303748459.273") :method
.annotate 'line', 10
    new $P322, "ResizablePMCArray"
    push $P322, ""
    .return ($P322)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block324"  :anon :subid("36_1303748459.273") :method :outer("34_1303748459.273")
.annotate 'line', 132
    .local string rx326_tgt
    .local int rx326_pos
    .local int rx326_off
    .local int rx326_eos
    .local int rx326_rep
    .local pmc rx326_cur
    .local pmc rx326_debug
    (rx326_cur, rx326_pos, rx326_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx326_cur
    .local pmc match
    .lex "$/", match
    length rx326_eos, rx326_tgt
    gt rx326_pos, rx326_eos, rx326_done
    set rx326_off, 0
    lt rx326_pos, 2, rx326_start
    sub rx326_off, rx326_pos, 1
    substr rx326_tgt, rx326_tgt, rx326_off
  rx326_start:
    eq $I10, 1, rx326_restart
    if_null rx326_debug, debug_668
    rx326_cur."!cursor_debug"("START", "")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan327_done
    goto rxscan327_scan
  rxscan327_loop:
    (rx326_pos) = rx326_cur."from"()
    inc rx326_pos
    rx326_cur."!cursor_from"(rx326_pos)
    ge rx326_pos, rx326_eos, rxscan327_done
  rxscan327_scan:
    set_addr $I10, rxscan327_loop
    rx326_cur."!mark_push"(0, rx326_pos, $I10)
  rxscan327_done:
  alt328_0:
    set_addr $I10, alt328_1
    rx326_cur."!mark_push"(0, rx326_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx326_pos, rx326_eos, rx326_fail
    sub $I10, rx326_pos, rx326_off
    substr $S10, rx326_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx326_fail
    inc rx326_pos
    goto alt328_end
  alt328_1:
  # rxanchor eos
    ne rx326_pos, rx326_eos, rx326_fail
  alt328_end:
  # rx pass
    rx326_cur."!cursor_pass"(rx326_pos, "")
    if_null rx326_debug, debug_669
    rx326_cur."!cursor_debug"("PASS", "", " at pos=", rx326_pos)
  debug_669:
    .return (rx326_cur)
  rx326_restart:
    if_null rx326_debug, debug_670
    rx326_cur."!cursor_debug"("NEXT", "")
  debug_670:
  rx326_fail:
    (rx326_rep, rx326_pos, $I10, $P10) = rx326_cur."!mark_fail"(0)
    lt rx326_pos, -1, rx326_done
    eq rx326_pos, -1, rx326_fail
    jump $I10
  rx326_done:
    rx326_cur."!cursor_fail"()
    if_null rx326_debug, debug_671
    rx326_cur."!cursor_debug"("FAIL", "")
  debug_671:
    .return (rx326_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx335_tgt
    .local int rx335_pos
    .local int rx335_off
    .local int rx335_eos
    .local int rx335_rep
    .local pmc rx335_cur
    .local pmc rx335_debug
    (rx335_cur, rx335_pos, rx335_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx335_cur
    .local pmc match
    .lex "$/", match
    length rx335_eos, rx335_tgt
    gt rx335_pos, rx335_eos, rx335_done
    set rx335_off, 0
    lt rx335_pos, 2, rx335_start
    sub rx335_off, rx335_pos, 1
    substr rx335_tgt, rx335_tgt, rx335_off
  rx335_start:
    eq $I10, 1, rx335_restart
    if_null rx335_debug, debug_675
    rx335_cur."!cursor_debug"("START", "eat_terminator")
  debug_675:
    $I10 = self.'from'()
    ne $I10, -1, rxscan338_done
    goto rxscan338_scan
  rxscan338_loop:
    (rx335_pos) = rx335_cur."from"()
    inc rx335_pos
    rx335_cur."!cursor_from"(rx335_pos)
    ge rx335_pos, rx335_eos, rxscan338_done
  rxscan338_scan:
    set_addr $I10, rxscan338_loop
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
  rxscan338_done:
  alt339_0:
.annotate 'line', 144
    set_addr $I10, alt339_1
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
.annotate 'line', 145
  # rx literal  ";"
    add $I11, rx335_pos, 1
    gt $I11, rx335_eos, rx335_fail
    sub $I11, rx335_pos, rx335_off
    ord $I11, rx335_tgt, $I11
    ne $I11, 59, rx335_fail
    add rx335_pos, 1
    goto alt339_end
  alt339_1:
    set_addr $I10, alt339_2
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
.annotate 'line', 146
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."MARKED"("endstmt")
    unless $P10, rx335_fail
    goto alt339_end
  alt339_2:
    set_addr $I10, alt339_3
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
.annotate 'line', 147
  # rx subrule "terminator" subtype=zerowidth negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."terminator"()
    unless $P10, rx335_fail
    goto alt339_end
  alt339_3:
.annotate 'line', 148
  # rxanchor eos
    ne rx335_pos, rx335_eos, rx335_fail
  alt339_end:
.annotate 'line', 144
  # rx pass
    rx335_cur."!cursor_pass"(rx335_pos, "eat_terminator")
    if_null rx335_debug, debug_676
    rx335_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx335_pos)
  debug_676:
    .return (rx335_cur)
  rx335_restart:
.annotate 'line', 10
    if_null rx335_debug, debug_677
    rx335_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_677:
  rx335_fail:
    (rx335_rep, rx335_pos, $I10, $P10) = rx335_cur."!mark_fail"(0)
    lt rx335_pos, -1, rx335_done
    eq rx335_pos, -1, rx335_fail
    jump $I10
  rx335_done:
    rx335_cur."!cursor_fail"()
    if_null rx335_debug, debug_678
    rx335_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_678:
    .return (rx335_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1303748459.273") :method
.annotate 'line', 10
    new $P337, "ResizablePMCArray"
    push $P337, ""
    push $P337, ""
    push $P337, ""
    push $P337, ";"
    .return ($P337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx341_tgt
    .local int rx341_pos
    .local int rx341_off
    .local int rx341_eos
    .local int rx341_rep
    .local pmc rx341_cur
    .local pmc rx341_debug
    (rx341_cur, rx341_pos, rx341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx341_cur
    .local pmc match
    .lex "$/", match
    length rx341_eos, rx341_tgt
    gt rx341_pos, rx341_eos, rx341_done
    set rx341_off, 0
    lt rx341_pos, 2, rx341_start
    sub rx341_off, rx341_pos, 1
    substr rx341_tgt, rx341_tgt, rx341_off
  rx341_start:
    eq $I10, 1, rx341_restart
    if_null rx341_debug, debug_679
    rx341_cur."!cursor_debug"("START", "xblock")
  debug_679:
    $I10 = self.'from'()
    ne $I10, -1, rxscan345_done
    goto rxscan345_scan
  rxscan345_loop:
    (rx341_pos) = rx341_cur."from"()
    inc rx341_pos
    rx341_cur."!cursor_from"(rx341_pos)
    ge rx341_pos, rx341_eos, rxscan345_done
  rxscan345_scan:
    set_addr $I10, rxscan345_loop
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  rxscan345_done:
.annotate 'line', 152
  # rx subrule "EXPR" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."EXPR"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx341_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."pblock"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx341_pos = $P10."pos"()
.annotate 'line', 151
  # rx pass
    rx341_cur."!cursor_pass"(rx341_pos, "xblock")
    if_null rx341_debug, debug_680
    rx341_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx341_pos)
  debug_680:
    .return (rx341_cur)
  rx341_restart:
.annotate 'line', 10
    if_null rx341_debug, debug_681
    rx341_cur."!cursor_debug"("NEXT", "xblock")
  debug_681:
  rx341_fail:
    (rx341_rep, rx341_pos, $I10, $P10) = rx341_cur."!mark_fail"(0)
    lt rx341_pos, -1, rx341_done
    eq rx341_pos, -1, rx341_fail
    jump $I10
  rx341_done:
    rx341_cur."!cursor_fail"()
    if_null rx341_debug, debug_682
    rx341_cur."!cursor_debug"("FAIL", "xblock")
  debug_682:
    .return (rx341_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1303748459.273") :method
.annotate 'line', 10
    $P343 = self."!PREFIX__!subrule"("EXPR", "")
    new $P344, "ResizablePMCArray"
    push $P344, $P343
    .return ($P344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx347_tgt
    .local int rx347_pos
    .local int rx347_off
    .local int rx347_eos
    .local int rx347_rep
    .local pmc rx347_cur
    .local pmc rx347_debug
    (rx347_cur, rx347_pos, rx347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx347_cur
    .local pmc match
    .lex "$/", match
    length rx347_eos, rx347_tgt
    gt rx347_pos, rx347_eos, rx347_done
    set rx347_off, 0
    lt rx347_pos, 2, rx347_start
    sub rx347_off, rx347_pos, 1
    substr rx347_tgt, rx347_tgt, rx347_off
  rx347_start:
    eq $I10, 1, rx347_restart
    if_null rx347_debug, debug_683
    rx347_cur."!cursor_debug"("START", "pblock")
  debug_683:
    $I10 = self.'from'()
    ne $I10, -1, rxscan352_done
    goto rxscan352_scan
  rxscan352_loop:
    (rx347_pos) = rx347_cur."from"()
    inc rx347_pos
    rx347_cur."!cursor_from"(rx347_pos)
    ge rx347_pos, rx347_eos, rxscan352_done
  rxscan352_scan:
    set_addr $I10, rxscan352_loop
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxscan352_done:
  alt353_0:
.annotate 'line', 155
    set_addr $I10, alt353_1
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
.annotate 'line', 156
  # rx subrule "lambda" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."lambda"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "newpad" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."newpad"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 158
  # rx subrule "signature" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."signature"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx347_pos = $P10."pos"()
.annotate 'line', 159
  # rx subrule "blockoid" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."blockoid"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx347_pos = $P10."pos"()
.annotate 'line', 156
    goto alt353_end
  alt353_1:
    set_addr $I10, alt353_2
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
.annotate 'line', 160
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx347_fail
.annotate 'line', 161
  # rx subrule "newpad" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."newpad"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 162
  # rx subrule "blockoid" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."blockoid"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx347_pos = $P10."pos"()
.annotate 'line', 160
    goto alt353_end
  alt353_2:
.annotate 'line', 163
  # rx subrule "panic" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."panic"("Missing block")
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  alt353_end:
.annotate 'line', 155
  # rx pass
    rx347_cur."!cursor_pass"(rx347_pos, "pblock")
    if_null rx347_debug, debug_684
    rx347_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx347_pos)
  debug_684:
    .return (rx347_cur)
  rx347_restart:
.annotate 'line', 10
    if_null rx347_debug, debug_685
    rx347_cur."!cursor_debug"("NEXT", "pblock")
  debug_685:
  rx347_fail:
    (rx347_rep, rx347_pos, $I10, $P10) = rx347_cur."!mark_fail"(0)
    lt rx347_pos, -1, rx347_done
    eq rx347_pos, -1, rx347_fail
    jump $I10
  rx347_done:
    rx347_cur."!cursor_fail"()
    if_null rx347_debug, debug_686
    rx347_cur."!cursor_debug"("FAIL", "pblock")
  debug_686:
    .return (rx347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1303748459.273") :method
.annotate 'line', 10
    $P349 = self."!PREFIX__!subrule"("panic", "")
    $P350 = self."!PREFIX__!subrule"("lambda", "")
    new $P351, "ResizablePMCArray"
    push $P351, $P349
    push $P351, "{"
    push $P351, $P350
    .return ($P351)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx355_tgt
    .local int rx355_pos
    .local int rx355_off
    .local int rx355_eos
    .local int rx355_rep
    .local pmc rx355_cur
    .local pmc rx355_debug
    (rx355_cur, rx355_pos, rx355_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx355_cur
    .local pmc match
    .lex "$/", match
    length rx355_eos, rx355_tgt
    gt rx355_pos, rx355_eos, rx355_done
    set rx355_off, 0
    lt rx355_pos, 2, rx355_start
    sub rx355_off, rx355_pos, 1
    substr rx355_tgt, rx355_tgt, rx355_off
  rx355_start:
    eq $I10, 1, rx355_restart
    if_null rx355_debug, debug_687
    rx355_cur."!cursor_debug"("START", "lambda")
  debug_687:
    $I10 = self.'from'()
    ne $I10, -1, rxscan358_done
    goto rxscan358_scan
  rxscan358_loop:
    (rx355_pos) = rx355_cur."from"()
    inc rx355_pos
    rx355_cur."!cursor_from"(rx355_pos)
    ge rx355_pos, rx355_eos, rxscan358_done
  rxscan358_scan:
    set_addr $I10, rxscan358_loop
    rx355_cur."!mark_push"(0, rx355_pos, $I10)
  rxscan358_done:
  alt359_0:
.annotate 'line', 166
    set_addr $I10, alt359_1
    rx355_cur."!mark_push"(0, rx355_pos, $I10)
  # rx literal  "->"
    add $I11, rx355_pos, 2
    gt $I11, rx355_eos, rx355_fail
    sub $I11, rx355_pos, rx355_off
    substr $S10, rx355_tgt, $I11, 2
    ne $S10, "->", rx355_fail
    add rx355_pos, 2
    goto alt359_end
  alt359_1:
  # rx literal  "<->"
    add $I11, rx355_pos, 3
    gt $I11, rx355_eos, rx355_fail
    sub $I11, rx355_pos, rx355_off
    substr $S10, rx355_tgt, $I11, 3
    ne $S10, "<->", rx355_fail
    add rx355_pos, 3
  alt359_end:
  # rx pass
    rx355_cur."!cursor_pass"(rx355_pos, "lambda")
    if_null rx355_debug, debug_688
    rx355_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx355_pos)
  debug_688:
    .return (rx355_cur)
  rx355_restart:
.annotate 'line', 10
    if_null rx355_debug, debug_689
    rx355_cur."!cursor_debug"("NEXT", "lambda")
  debug_689:
  rx355_fail:
    (rx355_rep, rx355_pos, $I10, $P10) = rx355_cur."!mark_fail"(0)
    lt rx355_pos, -1, rx355_done
    eq rx355_pos, -1, rx355_fail
    jump $I10
  rx355_done:
    rx355_cur."!cursor_fail"()
    if_null rx355_debug, debug_690
    rx355_cur."!cursor_debug"("FAIL", "lambda")
  debug_690:
    .return (rx355_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1303748459.273") :method
.annotate 'line', 10
    new $P357, "ResizablePMCArray"
    push $P357, "<->"
    push $P357, "->"
    .return ($P357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx361_tgt
    .local int rx361_pos
    .local int rx361_off
    .local int rx361_eos
    .local int rx361_rep
    .local pmc rx361_cur
    .local pmc rx361_debug
    (rx361_cur, rx361_pos, rx361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx361_cur
    .local pmc match
    .lex "$/", match
    length rx361_eos, rx361_tgt
    gt rx361_pos, rx361_eos, rx361_done
    set rx361_off, 0
    lt rx361_pos, 2, rx361_start
    sub rx361_off, rx361_pos, 1
    substr rx361_tgt, rx361_tgt, rx361_off
  rx361_start:
    eq $I10, 1, rx361_restart
    if_null rx361_debug, debug_691
    rx361_cur."!cursor_debug"("START", "block")
  debug_691:
    $I10 = self.'from'()
    ne $I10, -1, rxscan365_done
    goto rxscan365_scan
  rxscan365_loop:
    (rx361_pos) = rx361_cur."from"()
    inc rx361_pos
    rx361_cur."!cursor_from"(rx361_pos)
    ge rx361_pos, rx361_eos, rxscan365_done
  rxscan365_scan:
    set_addr $I10, rxscan365_loop
    rx361_cur."!mark_push"(0, rx361_pos, $I10)
  rxscan365_done:
  alt366_0:
.annotate 'line', 169
    set_addr $I10, alt366_1
    rx361_cur."!mark_push"(0, rx361_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx361_pos, rx361_off
    substr $S10, rx361_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx361_fail
    goto alt366_end
  alt366_1:
  # rx subrule "panic" subtype=method negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."panic"("Missing block")
    unless $P10, rx361_fail
    rx361_pos = $P10."pos"()
  alt366_end:
.annotate 'line', 170
  # rx subrule "newpad" subtype=method negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."newpad"()
    unless $P10, rx361_fail
    rx361_pos = $P10."pos"()
.annotate 'line', 171
  # rx subrule "blockoid" subtype=capture negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."blockoid"()
    unless $P10, rx361_fail
    rx361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx361_pos = $P10."pos"()
.annotate 'line', 168
  # rx pass
    rx361_cur."!cursor_pass"(rx361_pos, "block")
    if_null rx361_debug, debug_692
    rx361_cur."!cursor_debug"("PASS", "block", " at pos=", rx361_pos)
  debug_692:
    .return (rx361_cur)
  rx361_restart:
.annotate 'line', 10
    if_null rx361_debug, debug_693
    rx361_cur."!cursor_debug"("NEXT", "block")
  debug_693:
  rx361_fail:
    (rx361_rep, rx361_pos, $I10, $P10) = rx361_cur."!mark_fail"(0)
    lt rx361_pos, -1, rx361_done
    eq rx361_pos, -1, rx361_fail
    jump $I10
  rx361_done:
    rx361_cur."!cursor_fail"()
    if_null rx361_debug, debug_694
    rx361_cur."!cursor_debug"("FAIL", "block")
  debug_694:
    .return (rx361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1303748459.273") :method
.annotate 'line', 10
    $P363 = self."!PREFIX__!subrule"("panic", "")
    new $P364, "ResizablePMCArray"
    push $P364, $P363
    push $P364, "{"
    .return ($P364)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx368_tgt
    .local int rx368_pos
    .local int rx368_off
    .local int rx368_eos
    .local int rx368_rep
    .local pmc rx368_cur
    .local pmc rx368_debug
    (rx368_cur, rx368_pos, rx368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx368_cur
    .local pmc match
    .lex "$/", match
    length rx368_eos, rx368_tgt
    gt rx368_pos, rx368_eos, rx368_done
    set rx368_off, 0
    lt rx368_pos, 2, rx368_start
    sub rx368_off, rx368_pos, 1
    substr rx368_tgt, rx368_tgt, rx368_off
  rx368_start:
    eq $I10, 1, rx368_restart
    if_null rx368_debug, debug_695
    rx368_cur."!cursor_debug"("START", "blockoid")
  debug_695:
    $I10 = self.'from'()
    ne $I10, -1, rxscan372_done
    goto rxscan372_scan
  rxscan372_loop:
    (rx368_pos) = rx368_cur."from"()
    inc rx368_pos
    rx368_cur."!cursor_from"(rx368_pos)
    ge rx368_pos, rx368_eos, rxscan372_done
  rxscan372_scan:
    set_addr $I10, rxscan372_loop
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
  rxscan372_done:
.annotate 'line', 175
  # rx subrule "finishpad" subtype=method negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."finishpad"()
    unless $P10, rx368_fail
    rx368_pos = $P10."pos"()
  alt373_0:
.annotate 'line', 176
    set_addr $I10, alt373_1
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
.annotate 'line', 177
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx368_pos, 14
    gt $I11, rx368_eos, rx368_fail
    sub $I11, rx368_pos, rx368_off
    substr $S10, rx368_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx368_fail
    add rx368_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."you_are_here"()
    unless $P10, rx368_fail
    rx368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx368_pos = $P10."pos"()
    goto alt373_end
  alt373_1:
.annotate 'line', 178
  # rx literal  "{"
    add $I11, rx368_pos, 1
    gt $I11, rx368_eos, rx368_fail
    sub $I11, rx368_pos, rx368_off
    ord $I11, rx368_tgt, $I11
    ne $I11, 123, rx368_fail
    add rx368_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."statementlist"()
    unless $P10, rx368_fail
    rx368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx368_pos = $P10."pos"()
  alt374_0:
    set_addr $I10, alt374_1
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
  # rx literal  "}"
    add $I11, rx368_pos, 1
    gt $I11, rx368_eos, rx368_fail
    sub $I11, rx368_pos, rx368_off
    ord $I11, rx368_tgt, $I11
    ne $I11, 125, rx368_fail
    add rx368_pos, 1
    goto alt374_end
  alt374_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."FAILGOAL"("'}'")
    unless $P10, rx368_fail
    goto rxsubrule376_pass
  rxsubrule376_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx368_fail
  rxsubrule376_pass:
    set_addr $I10, rxsubrule376_back
    rx368_cur."!mark_push"(0, rx368_pos, $I10, $P10)
    rx368_pos = $P10."pos"()
  alt374_end:
  alt373_end:
.annotate 'line', 180
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."ENDSTMT"()
    unless $P10, rx368_fail
.annotate 'line', 174
  # rx pass
    rx368_cur."!cursor_pass"(rx368_pos, "blockoid")
    if_null rx368_debug, debug_696
    rx368_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx368_pos)
  debug_696:
    .return (rx368_cur)
  rx368_restart:
.annotate 'line', 10
    if_null rx368_debug, debug_697
    rx368_cur."!cursor_debug"("NEXT", "blockoid")
  debug_697:
  rx368_fail:
    (rx368_rep, rx368_pos, $I10, $P10) = rx368_cur."!mark_fail"(0)
    lt rx368_pos, -1, rx368_done
    eq rx368_pos, -1, rx368_fail
    jump $I10
  rx368_done:
    rx368_cur."!cursor_fail"()
    if_null rx368_debug, debug_698
    rx368_cur."!cursor_debug"("FAIL", "blockoid")
  debug_698:
    .return (rx368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1303748459.273") :method
.annotate 'line', 10
    $P370 = self."!PREFIX__!subrule"("finishpad", "")
    new $P371, "ResizablePMCArray"
    push $P371, $P370
    .return ($P371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx378_tgt
    .local int rx378_pos
    .local int rx378_off
    .local int rx378_eos
    .local int rx378_rep
    .local pmc rx378_cur
    .local pmc rx378_debug
    (rx378_cur, rx378_pos, rx378_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx378_cur
    .local pmc match
    .lex "$/", match
    length rx378_eos, rx378_tgt
    gt rx378_pos, rx378_eos, rx378_done
    set rx378_off, 0
    lt rx378_pos, 2, rx378_start
    sub rx378_off, rx378_pos, 1
    substr rx378_tgt, rx378_tgt, rx378_off
  rx378_start:
    eq $I10, 1, rx378_restart
    if_null rx378_debug, debug_699
    rx378_cur."!cursor_debug"("START", "newpad")
  debug_699:
    $I10 = self.'from'()
    ne $I10, -1, rxscan381_done
    goto rxscan381_scan
  rxscan381_loop:
    (rx378_pos) = rx378_cur."from"()
    inc rx378_pos
    rx378_cur."!cursor_from"(rx378_pos)
    ge rx378_pos, rx378_eos, rxscan381_done
  rxscan381_scan:
    set_addr $I10, rxscan381_loop
    rx378_cur."!mark_push"(0, rx378_pos, $I10)
  rxscan381_done:
.annotate 'line', 183
  # rx pass
    rx378_cur."!cursor_pass"(rx378_pos, "newpad")
    if_null rx378_debug, debug_700
    rx378_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx378_pos)
  debug_700:
    .return (rx378_cur)
  rx378_restart:
.annotate 'line', 10
    if_null rx378_debug, debug_701
    rx378_cur."!cursor_debug"("NEXT", "newpad")
  debug_701:
  rx378_fail:
    (rx378_rep, rx378_pos, $I10, $P10) = rx378_cur."!mark_fail"(0)
    lt rx378_pos, -1, rx378_done
    eq rx378_pos, -1, rx378_fail
    jump $I10
  rx378_done:
    rx378_cur."!cursor_fail"()
    if_null rx378_debug, debug_702
    rx378_cur."!cursor_debug"("FAIL", "newpad")
  debug_702:
    .return (rx378_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1303748459.273") :method
.annotate 'line', 10
    new $P380, "ResizablePMCArray"
    push $P380, ""
    .return ($P380)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx383_tgt
    .local int rx383_pos
    .local int rx383_off
    .local int rx383_eos
    .local int rx383_rep
    .local pmc rx383_cur
    .local pmc rx383_debug
    (rx383_cur, rx383_pos, rx383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx383_cur
    .local pmc match
    .lex "$/", match
    length rx383_eos, rx383_tgt
    gt rx383_pos, rx383_eos, rx383_done
    set rx383_off, 0
    lt rx383_pos, 2, rx383_start
    sub rx383_off, rx383_pos, 1
    substr rx383_tgt, rx383_tgt, rx383_off
  rx383_start:
    eq $I10, 1, rx383_restart
    if_null rx383_debug, debug_703
    rx383_cur."!cursor_debug"("START", "outerctx")
  debug_703:
    $I10 = self.'from'()
    ne $I10, -1, rxscan386_done
    goto rxscan386_scan
  rxscan386_loop:
    (rx383_pos) = rx383_cur."from"()
    inc rx383_pos
    rx383_cur."!cursor_from"(rx383_pos)
    ge rx383_pos, rx383_eos, rxscan386_done
  rxscan386_scan:
    set_addr $I10, rxscan386_loop
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  rxscan386_done:
.annotate 'line', 184
  # rx pass
    rx383_cur."!cursor_pass"(rx383_pos, "outerctx")
    if_null rx383_debug, debug_704
    rx383_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx383_pos)
  debug_704:
    .return (rx383_cur)
  rx383_restart:
.annotate 'line', 10
    if_null rx383_debug, debug_705
    rx383_cur."!cursor_debug"("NEXT", "outerctx")
  debug_705:
  rx383_fail:
    (rx383_rep, rx383_pos, $I10, $P10) = rx383_cur."!mark_fail"(0)
    lt rx383_pos, -1, rx383_done
    eq rx383_pos, -1, rx383_fail
    jump $I10
  rx383_done:
    rx383_cur."!cursor_fail"()
    if_null rx383_debug, debug_706
    rx383_cur."!cursor_debug"("FAIL", "outerctx")
  debug_706:
    .return (rx383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1303748459.273") :method
.annotate 'line', 10
    new $P385, "ResizablePMCArray"
    push $P385, ""
    .return ($P385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx388_tgt
    .local int rx388_pos
    .local int rx388_off
    .local int rx388_eos
    .local int rx388_rep
    .local pmc rx388_cur
    .local pmc rx388_debug
    (rx388_cur, rx388_pos, rx388_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx388_cur
    .local pmc match
    .lex "$/", match
    length rx388_eos, rx388_tgt
    gt rx388_pos, rx388_eos, rx388_done
    set rx388_off, 0
    lt rx388_pos, 2, rx388_start
    sub rx388_off, rx388_pos, 1
    substr rx388_tgt, rx388_tgt, rx388_off
  rx388_start:
    eq $I10, 1, rx388_restart
    if_null rx388_debug, debug_707
    rx388_cur."!cursor_debug"("START", "GLOBALish")
  debug_707:
    $I10 = self.'from'()
    ne $I10, -1, rxscan391_done
    goto rxscan391_scan
  rxscan391_loop:
    (rx388_pos) = rx388_cur."from"()
    inc rx388_pos
    rx388_cur."!cursor_from"(rx388_pos)
    ge rx388_pos, rx388_eos, rxscan391_done
  rxscan391_scan:
    set_addr $I10, rxscan391_loop
    rx388_cur."!mark_push"(0, rx388_pos, $I10)
  rxscan391_done:
.annotate 'line', 185
  # rx pass
    rx388_cur."!cursor_pass"(rx388_pos, "GLOBALish")
    if_null rx388_debug, debug_708
    rx388_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx388_pos)
  debug_708:
    .return (rx388_cur)
  rx388_restart:
.annotate 'line', 10
    if_null rx388_debug, debug_709
    rx388_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_709:
  rx388_fail:
    (rx388_rep, rx388_pos, $I10, $P10) = rx388_cur."!mark_fail"(0)
    lt rx388_pos, -1, rx388_done
    eq rx388_pos, -1, rx388_fail
    jump $I10
  rx388_done:
    rx388_cur."!cursor_fail"()
    if_null rx388_debug, debug_710
    rx388_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_710:
    .return (rx388_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1303748459.273") :method
.annotate 'line', 10
    new $P390, "ResizablePMCArray"
    push $P390, ""
    .return ($P390)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx393_tgt
    .local int rx393_pos
    .local int rx393_off
    .local int rx393_eos
    .local int rx393_rep
    .local pmc rx393_cur
    .local pmc rx393_debug
    (rx393_cur, rx393_pos, rx393_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx393_cur
    .local pmc match
    .lex "$/", match
    length rx393_eos, rx393_tgt
    gt rx393_pos, rx393_eos, rx393_done
    set rx393_off, 0
    lt rx393_pos, 2, rx393_start
    sub rx393_off, rx393_pos, 1
    substr rx393_tgt, rx393_tgt, rx393_off
  rx393_start:
    eq $I10, 1, rx393_restart
    if_null rx393_debug, debug_711
    rx393_cur."!cursor_debug"("START", "finishpad")
  debug_711:
    $I10 = self.'from'()
    ne $I10, -1, rxscan396_done
    goto rxscan396_scan
  rxscan396_loop:
    (rx393_pos) = rx393_cur."from"()
    inc rx393_pos
    rx393_cur."!cursor_from"(rx393_pos)
    ge rx393_pos, rx393_eos, rxscan396_done
  rxscan396_scan:
    set_addr $I10, rxscan396_loop
    rx393_cur."!mark_push"(0, rx393_pos, $I10)
  rxscan396_done:
.annotate 'line', 186
  # rx pass
    rx393_cur."!cursor_pass"(rx393_pos, "finishpad")
    if_null rx393_debug, debug_712
    rx393_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx393_pos)
  debug_712:
    .return (rx393_cur)
  rx393_restart:
.annotate 'line', 10
    if_null rx393_debug, debug_713
    rx393_cur."!cursor_debug"("NEXT", "finishpad")
  debug_713:
  rx393_fail:
    (rx393_rep, rx393_pos, $I10, $P10) = rx393_cur."!mark_fail"(0)
    lt rx393_pos, -1, rx393_done
    eq rx393_pos, -1, rx393_fail
    jump $I10
  rx393_done:
    rx393_cur."!cursor_fail"()
    if_null rx393_debug, debug_714
    rx393_cur."!cursor_debug"("FAIL", "finishpad")
  debug_714:
    .return (rx393_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1303748459.273") :method
.annotate 'line', 10
    new $P395, "ResizablePMCArray"
    push $P395, ""
    .return ($P395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx398_tgt
    .local int rx398_pos
    .local int rx398_off
    .local int rx398_eos
    .local int rx398_rep
    .local pmc rx398_cur
    .local pmc rx398_debug
    (rx398_cur, rx398_pos, rx398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx398_cur
    .local pmc match
    .lex "$/", match
    length rx398_eos, rx398_tgt
    gt rx398_pos, rx398_eos, rx398_done
    set rx398_off, 0
    lt rx398_pos, 2, rx398_start
    sub rx398_off, rx398_pos, 1
    substr rx398_tgt, rx398_tgt, rx398_off
  rx398_start:
    eq $I10, 1, rx398_restart
    if_null rx398_debug, debug_715
    rx398_cur."!cursor_debug"("START", "you_are_here")
  debug_715:
    $I10 = self.'from'()
    ne $I10, -1, rxscan401_done
    goto rxscan401_scan
  rxscan401_loop:
    (rx398_pos) = rx398_cur."from"()
    inc rx398_pos
    rx398_cur."!cursor_from"(rx398_pos)
    ge rx398_pos, rx398_eos, rxscan401_done
  rxscan401_scan:
    set_addr $I10, rxscan401_loop
    rx398_cur."!mark_push"(0, rx398_pos, $I10)
  rxscan401_done:
.annotate 'line', 187
  # rx pass
    rx398_cur."!cursor_pass"(rx398_pos, "you_are_here")
    if_null rx398_debug, debug_716
    rx398_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx398_pos)
  debug_716:
    .return (rx398_cur)
  rx398_restart:
.annotate 'line', 10
    if_null rx398_debug, debug_717
    rx398_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_717:
  rx398_fail:
    (rx398_rep, rx398_pos, $I10, $P10) = rx398_cur."!mark_fail"(0)
    lt rx398_pos, -1, rx398_done
    eq rx398_pos, -1, rx398_fail
    jump $I10
  rx398_done:
    rx398_cur."!cursor_fail"()
    if_null rx398_debug, debug_718
    rx398_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_718:
    .return (rx398_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1303748459.273") :method
.annotate 'line', 10
    new $P400, "ResizablePMCArray"
    push $P400, ""
    .return ($P400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1303748459.273")
    .param pmc param_403
.annotate 'line', 189
    .lex "self", param_403
    $P404 = param_403."!protoregex"("terminator")
    .return ($P404)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1303748459.273")
    .param pmc param_406
.annotate 'line', 189
    .lex "self", param_406
    $P407 = param_406."!PREFIX__!protoregex"("terminator")
    .return ($P407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx409_tgt
    .local int rx409_pos
    .local int rx409_off
    .local int rx409_eos
    .local int rx409_rep
    .local pmc rx409_cur
    .local pmc rx409_debug
    (rx409_cur, rx409_pos, rx409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx409_cur
    .local pmc match
    .lex "$/", match
    length rx409_eos, rx409_tgt
    gt rx409_pos, rx409_eos, rx409_done
    set rx409_off, 0
    lt rx409_pos, 2, rx409_start
    sub rx409_off, rx409_pos, 1
    substr rx409_tgt, rx409_tgt, rx409_off
  rx409_start:
    eq $I10, 1, rx409_restart
    if_null rx409_debug, debug_719
    rx409_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_719:
    $I10 = self.'from'()
    ne $I10, -1, rxscan412_done
    goto rxscan412_scan
  rxscan412_loop:
    (rx409_pos) = rx409_cur."from"()
    inc rx409_pos
    rx409_cur."!cursor_from"(rx409_pos)
    ge rx409_pos, rx409_eos, rxscan412_done
  rxscan412_scan:
    set_addr $I10, rxscan412_loop
    rx409_cur."!mark_push"(0, rx409_pos, $I10)
  rxscan412_done:
.annotate 'line', 191
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx409_pos, rx409_off
    substr $S10, rx409_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx409_fail
  # rx pass
    rx409_cur."!cursor_pass"(rx409_pos, "terminator:sym<;>")
    if_null rx409_debug, debug_720
    rx409_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx409_pos)
  debug_720:
    .return (rx409_cur)
  rx409_restart:
.annotate 'line', 10
    if_null rx409_debug, debug_721
    rx409_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_721:
  rx409_fail:
    (rx409_rep, rx409_pos, $I10, $P10) = rx409_cur."!mark_fail"(0)
    lt rx409_pos, -1, rx409_done
    eq rx409_pos, -1, rx409_fail
    jump $I10
  rx409_done:
    rx409_cur."!cursor_fail"()
    if_null rx409_debug, debug_722
    rx409_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_722:
    .return (rx409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1303748459.273") :method
.annotate 'line', 10
    new $P411, "ResizablePMCArray"
    push $P411, ";"
    .return ($P411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx414_tgt
    .local int rx414_pos
    .local int rx414_off
    .local int rx414_eos
    .local int rx414_rep
    .local pmc rx414_cur
    .local pmc rx414_debug
    (rx414_cur, rx414_pos, rx414_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx414_cur
    .local pmc match
    .lex "$/", match
    length rx414_eos, rx414_tgt
    gt rx414_pos, rx414_eos, rx414_done
    set rx414_off, 0
    lt rx414_pos, 2, rx414_start
    sub rx414_off, rx414_pos, 1
    substr rx414_tgt, rx414_tgt, rx414_off
  rx414_start:
    eq $I10, 1, rx414_restart
    if_null rx414_debug, debug_723
    rx414_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_723:
    $I10 = self.'from'()
    ne $I10, -1, rxscan417_done
    goto rxscan417_scan
  rxscan417_loop:
    (rx414_pos) = rx414_cur."from"()
    inc rx414_pos
    rx414_cur."!cursor_from"(rx414_pos)
    ge rx414_pos, rx414_eos, rxscan417_done
  rxscan417_scan:
    set_addr $I10, rxscan417_loop
    rx414_cur."!mark_push"(0, rx414_pos, $I10)
  rxscan417_done:
.annotate 'line', 192
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx414_pos, rx414_off
    substr $S10, rx414_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx414_fail
  # rx pass
    rx414_cur."!cursor_pass"(rx414_pos, "terminator:sym<}>")
    if_null rx414_debug, debug_724
    rx414_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx414_pos)
  debug_724:
    .return (rx414_cur)
  rx414_restart:
.annotate 'line', 10
    if_null rx414_debug, debug_725
    rx414_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_725:
  rx414_fail:
    (rx414_rep, rx414_pos, $I10, $P10) = rx414_cur."!mark_fail"(0)
    lt rx414_pos, -1, rx414_done
    eq rx414_pos, -1, rx414_fail
    jump $I10
  rx414_done:
    rx414_cur."!cursor_fail"()
    if_null rx414_debug, debug_726
    rx414_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_726:
    .return (rx414_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1303748459.273") :method
.annotate 'line', 10
    new $P416, "ResizablePMCArray"
    push $P416, "}"
    .return ($P416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1303748459.273")
    .param pmc param_419
.annotate 'line', 196
    .lex "self", param_419
    $P420 = param_419."!protoregex"("statement_control")
    .return ($P420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1303748459.273")
    .param pmc param_422
.annotate 'line', 196
    .lex "self", param_422
    $P423 = param_422."!PREFIX__!protoregex"("statement_control")
    .return ($P423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx425_tgt
    .local int rx425_pos
    .local int rx425_off
    .local int rx425_eos
    .local int rx425_rep
    .local pmc rx425_cur
    .local pmc rx425_debug
    (rx425_cur, rx425_pos, rx425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx425_cur
    .local pmc match
    .lex "$/", match
    length rx425_eos, rx425_tgt
    gt rx425_pos, rx425_eos, rx425_done
    set rx425_off, 0
    lt rx425_pos, 2, rx425_start
    sub rx425_off, rx425_pos, 1
    substr rx425_tgt, rx425_tgt, rx425_off
  rx425_start:
    eq $I10, 1, rx425_restart
    if_null rx425_debug, debug_727
    rx425_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_727:
    $I10 = self.'from'()
    ne $I10, -1, rxscan428_done
    goto rxscan428_scan
  rxscan428_loop:
    (rx425_pos) = rx425_cur."from"()
    inc rx425_pos
    rx425_cur."!cursor_from"(rx425_pos)
    ge rx425_pos, rx425_eos, rxscan428_done
  rxscan428_scan:
    set_addr $I10, rxscan428_loop
    rx425_cur."!mark_push"(0, rx425_pos, $I10)
  rxscan428_done:
.annotate 'line', 199
  # rx subcapture "sym"
    set_addr $I10, rxcap_429_fail
    rx425_cur."!mark_push"(0, rx425_pos, $I10)
  # rx literal  "use"
    add $I11, rx425_pos, 3
    gt $I11, rx425_eos, rx425_fail
    sub $I11, rx425_pos, rx425_off
    substr $S10, rx425_tgt, $I11, 3
    ne $S10, "use", rx425_fail
    add rx425_pos, 3
    set_addr $I10, rxcap_429_fail
    ($I12, $I11) = rx425_cur."!mark_peek"($I10)
    rx425_cur."!cursor_pos"($I11)
    ($P10) = rx425_cur."!cursor_start"()
    $P10."!cursor_pass"(rx425_pos, "")
    rx425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_429_done
  rxcap_429_fail:
    goto rx425_fail
  rxcap_429_done:
  # rx charclass s
    ge rx425_pos, rx425_eos, rx425_fail
    sub $I10, rx425_pos, rx425_off
    is_cclass $I11, 32, rx425_tgt, $I10
    unless $I11, rx425_fail
    inc rx425_pos
  # rx subrule "ws" subtype=method negate=
    rx425_cur."!cursor_pos"(rx425_pos)
    $P10 = rx425_cur."ws"()
    unless $P10, rx425_fail
    rx425_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx425_cur."!cursor_pos"(rx425_pos)
    $P10 = rx425_cur."name"()
    unless $P10, rx425_fail
    rx425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx425_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx425_cur."!cursor_pos"(rx425_pos)
    $P10 = rx425_cur."ws"()
    unless $P10, rx425_fail
    rx425_pos = $P10."pos"()
.annotate 'line', 198
  # rx pass
    rx425_cur."!cursor_pass"(rx425_pos, "statement_control:sym<use>")
    if_null rx425_debug, debug_728
    rx425_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx425_pos)
  debug_728:
    .return (rx425_cur)
  rx425_restart:
.annotate 'line', 10
    if_null rx425_debug, debug_729
    rx425_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_729:
  rx425_fail:
    (rx425_rep, rx425_pos, $I10, $P10) = rx425_cur."!mark_fail"(0)
    lt rx425_pos, -1, rx425_done
    eq rx425_pos, -1, rx425_fail
    jump $I10
  rx425_done:
    rx425_cur."!cursor_fail"()
    if_null rx425_debug, debug_730
    rx425_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_730:
    .return (rx425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1303748459.273") :method
.annotate 'line', 10
    new $P427, "ResizablePMCArray"
    push $P427, "use"
    .return ($P427)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx433_tgt
    .local int rx433_pos
    .local int rx433_off
    .local int rx433_eos
    .local int rx433_rep
    .local pmc rx433_cur
    .local pmc rx433_debug
    (rx433_cur, rx433_pos, rx433_tgt, $I10) = self."!cursor_start"()
    rx433_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx433_cur
    .local pmc match
    .lex "$/", match
    length rx433_eos, rx433_tgt
    gt rx433_pos, rx433_eos, rx433_done
    set rx433_off, 0
    lt rx433_pos, 2, rx433_start
    sub rx433_off, rx433_pos, 1
    substr rx433_tgt, rx433_tgt, rx433_off
  rx433_start:
    eq $I10, 1, rx433_restart
    if_null rx433_debug, debug_731
    rx433_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_731:
    $I10 = self.'from'()
    ne $I10, -1, rxscan436_done
    goto rxscan436_scan
  rxscan436_loop:
    (rx433_pos) = rx433_cur."from"()
    inc rx433_pos
    rx433_cur."!cursor_from"(rx433_pos)
    ge rx433_pos, rx433_eos, rxscan436_done
  rxscan436_scan:
    set_addr $I10, rxscan436_loop
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  rxscan436_done:
.annotate 'line', 203
  # rx subcapture "sym"
    set_addr $I10, rxcap_437_fail
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  # rx literal  "if"
    add $I11, rx433_pos, 2
    gt $I11, rx433_eos, rx433_fail
    sub $I11, rx433_pos, rx433_off
    substr $S10, rx433_tgt, $I11, 2
    ne $S10, "if", rx433_fail
    add rx433_pos, 2
    set_addr $I10, rxcap_437_fail
    ($I12, $I11) = rx433_cur."!mark_peek"($I10)
    rx433_cur."!cursor_pos"($I11)
    ($P10) = rx433_cur."!cursor_start"()
    $P10."!cursor_pass"(rx433_pos, "")
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_437_done
  rxcap_437_fail:
    goto rx433_fail
  rxcap_437_done:
  # rx charclass s
    ge rx433_pos, rx433_eos, rx433_fail
    sub $I10, rx433_pos, rx433_off
    is_cclass $I11, 32, rx433_tgt, $I10
    unless $I11, rx433_fail
    inc rx433_pos
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 204
  # rx subrule "xblock" subtype=capture negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."xblock"()
    unless $P10, rx433_fail
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 205
  # rx rxquantr440 ** 0..*
    set_addr $I10, rxquantr440_done
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  rxquantr440_loop:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx433_pos, 5
    gt $I11, rx433_eos, rx433_fail
    sub $I11, rx433_pos, rx433_off
    substr $S10, rx433_tgt, $I11, 5
    ne $S10, "elsif", rx433_fail
    add rx433_pos, 5
  # rx charclass s
    ge rx433_pos, rx433_eos, rx433_fail
    sub $I10, rx433_pos, rx433_off
    is_cclass $I11, 32, rx433_tgt, $I10
    unless $I11, rx433_fail
    inc rx433_pos
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."xblock"()
    unless $P10, rx433_fail
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
    set_addr $I10, rxquantr440_done
    (rx433_rep) = rx433_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr440_done
    rx433_cur."!mark_push"(rx433_rep, rx433_pos, $I10)
    goto rxquantr440_loop
  rxquantr440_done:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 206
  # rx rxquantr445 ** 0..1
    set_addr $I10, rxquantr445_done
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  rxquantr445_loop:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx433_pos, 4
    gt $I11, rx433_eos, rx433_fail
    sub $I11, rx433_pos, rx433_off
    substr $S10, rx433_tgt, $I11, 4
    ne $S10, "else", rx433_fail
    add rx433_pos, 4
  # rx charclass s
    ge rx433_pos, rx433_eos, rx433_fail
    sub $I10, rx433_pos, rx433_off
    is_cclass $I11, 32, rx433_tgt, $I10
    unless $I11, rx433_fail
    inc rx433_pos
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."pblock"()
    unless $P10, rx433_fail
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
    set_addr $I10, rxquantr445_done
    (rx433_rep) = rx433_cur."!mark_commit"($I10)
  rxquantr445_done:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 202
  # rx pass
    rx433_cur."!cursor_pass"(rx433_pos, "statement_control:sym<if>")
    if_null rx433_debug, debug_732
    rx433_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx433_pos)
  debug_732:
    .return (rx433_cur)
  rx433_restart:
.annotate 'line', 10
    if_null rx433_debug, debug_733
    rx433_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_733:
  rx433_fail:
    (rx433_rep, rx433_pos, $I10, $P10) = rx433_cur."!mark_fail"(0)
    lt rx433_pos, -1, rx433_done
    eq rx433_pos, -1, rx433_fail
    jump $I10
  rx433_done:
    rx433_cur."!cursor_fail"()
    if_null rx433_debug, debug_734
    rx433_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_734:
    .return (rx433_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1303748459.273") :method
.annotate 'line', 10
    new $P435, "ResizablePMCArray"
    push $P435, "if"
    .return ($P435)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P461 = "73_1303748459.273" 
    capture_lex $P461
    .local string rx451_tgt
    .local int rx451_pos
    .local int rx451_off
    .local int rx451_eos
    .local int rx451_rep
    .local pmc rx451_cur
    .local pmc rx451_debug
    (rx451_cur, rx451_pos, rx451_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx451_cur
    .local pmc match
    .lex "$/", match
    length rx451_eos, rx451_tgt
    gt rx451_pos, rx451_eos, rx451_done
    set rx451_off, 0
    lt rx451_pos, 2, rx451_start
    sub rx451_off, rx451_pos, 1
    substr rx451_tgt, rx451_tgt, rx451_off
  rx451_start:
    eq $I10, 1, rx451_restart
    if_null rx451_debug, debug_735
    rx451_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_735:
    $I10 = self.'from'()
    ne $I10, -1, rxscan454_done
    goto rxscan454_scan
  rxscan454_loop:
    (rx451_pos) = rx451_cur."from"()
    inc rx451_pos
    rx451_cur."!cursor_from"(rx451_pos)
    ge rx451_pos, rx451_eos, rxscan454_done
  rxscan454_scan:
    set_addr $I10, rxscan454_loop
    rx451_cur."!mark_push"(0, rx451_pos, $I10)
  rxscan454_done:
.annotate 'line', 210
  # rx subcapture "sym"
    set_addr $I10, rxcap_455_fail
    rx451_cur."!mark_push"(0, rx451_pos, $I10)
  # rx literal  "unless"
    add $I11, rx451_pos, 6
    gt $I11, rx451_eos, rx451_fail
    sub $I11, rx451_pos, rx451_off
    substr $S10, rx451_tgt, $I11, 6
    ne $S10, "unless", rx451_fail
    add rx451_pos, 6
    set_addr $I10, rxcap_455_fail
    ($I12, $I11) = rx451_cur."!mark_peek"($I10)
    rx451_cur."!cursor_pos"($I11)
    ($P10) = rx451_cur."!cursor_start"()
    $P10."!cursor_pass"(rx451_pos, "")
    rx451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_455_done
  rxcap_455_fail:
    goto rx451_fail
  rxcap_455_done:
  # rx charclass s
    ge rx451_pos, rx451_eos, rx451_fail
    sub $I10, rx451_pos, rx451_off
    is_cclass $I11, 32, rx451_tgt, $I10
    unless $I11, rx451_fail
    inc rx451_pos
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
.annotate 'line', 211
  # rx subrule "xblock" subtype=capture negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."xblock"()
    unless $P10, rx451_fail
    rx451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx451_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  alt458_0:
.annotate 'line', 212
    set_addr $I10, alt458_1
    rx451_cur."!mark_push"(0, rx451_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx451_cur."!cursor_pos"(rx451_pos)
    .const 'Sub' $P461 = "73_1303748459.273" 
    capture_lex $P461
    $P10 = rx451_cur."before"($P461)
    if $P10, rx451_fail
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
    goto alt458_end
  alt458_1:
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  alt458_end:
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
.annotate 'line', 209
  # rx pass
    rx451_cur."!cursor_pass"(rx451_pos, "statement_control:sym<unless>")
    if_null rx451_debug, debug_740
    rx451_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx451_pos)
  debug_740:
    .return (rx451_cur)
  rx451_restart:
.annotate 'line', 10
    if_null rx451_debug, debug_741
    rx451_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_741:
  rx451_fail:
    (rx451_rep, rx451_pos, $I10, $P10) = rx451_cur."!mark_fail"(0)
    lt rx451_pos, -1, rx451_done
    eq rx451_pos, -1, rx451_fail
    jump $I10
  rx451_done:
    rx451_cur."!cursor_fail"()
    if_null rx451_debug, debug_742
    rx451_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_742:
    .return (rx451_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1303748459.273") :method
.annotate 'line', 10
    new $P453, "ResizablePMCArray"
    push $P453, "unless"
    .return ($P453)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block460"  :anon :subid("73_1303748459.273") :method :outer("71_1303748459.273")
.annotate 'line', 212
    .local string rx462_tgt
    .local int rx462_pos
    .local int rx462_off
    .local int rx462_eos
    .local int rx462_rep
    .local pmc rx462_cur
    .local pmc rx462_debug
    (rx462_cur, rx462_pos, rx462_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx462_cur
    .local pmc match
    .lex "$/", match
    length rx462_eos, rx462_tgt
    gt rx462_pos, rx462_eos, rx462_done
    set rx462_off, 0
    lt rx462_pos, 2, rx462_start
    sub rx462_off, rx462_pos, 1
    substr rx462_tgt, rx462_tgt, rx462_off
  rx462_start:
    eq $I10, 1, rx462_restart
    if_null rx462_debug, debug_736
    rx462_cur."!cursor_debug"("START", "")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan463_done
    goto rxscan463_scan
  rxscan463_loop:
    (rx462_pos) = rx462_cur."from"()
    inc rx462_pos
    rx462_cur."!cursor_from"(rx462_pos)
    ge rx462_pos, rx462_eos, rxscan463_done
  rxscan463_scan:
    set_addr $I10, rxscan463_loop
    rx462_cur."!mark_push"(0, rx462_pos, $I10)
  rxscan463_done:
  # rx literal  "else"
    add $I11, rx462_pos, 4
    gt $I11, rx462_eos, rx462_fail
    sub $I11, rx462_pos, rx462_off
    substr $S10, rx462_tgt, $I11, 4
    ne $S10, "else", rx462_fail
    add rx462_pos, 4
  # rx pass
    rx462_cur."!cursor_pass"(rx462_pos, "")
    if_null rx462_debug, debug_737
    rx462_cur."!cursor_debug"("PASS", "", " at pos=", rx462_pos)
  debug_737:
    .return (rx462_cur)
  rx462_restart:
    if_null rx462_debug, debug_738
    rx462_cur."!cursor_debug"("NEXT", "")
  debug_738:
  rx462_fail:
    (rx462_rep, rx462_pos, $I10, $P10) = rx462_cur."!mark_fail"(0)
    lt rx462_pos, -1, rx462_done
    eq rx462_pos, -1, rx462_fail
    jump $I10
  rx462_done:
    rx462_cur."!cursor_fail"()
    if_null rx462_debug, debug_739
    rx462_cur."!cursor_debug"("FAIL", "")
  debug_739:
    .return (rx462_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx469_tgt
    .local int rx469_pos
    .local int rx469_off
    .local int rx469_eos
    .local int rx469_rep
    .local pmc rx469_cur
    .local pmc rx469_debug
    (rx469_cur, rx469_pos, rx469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx469_cur
    .local pmc match
    .lex "$/", match
    length rx469_eos, rx469_tgt
    gt rx469_pos, rx469_eos, rx469_done
    set rx469_off, 0
    lt rx469_pos, 2, rx469_start
    sub rx469_off, rx469_pos, 1
    substr rx469_tgt, rx469_tgt, rx469_off
  rx469_start:
    eq $I10, 1, rx469_restart
    if_null rx469_debug, debug_743
    rx469_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_743:
    $I10 = self.'from'()
    ne $I10, -1, rxscan472_done
    goto rxscan472_scan
  rxscan472_loop:
    (rx469_pos) = rx469_cur."from"()
    inc rx469_pos
    rx469_cur."!cursor_from"(rx469_pos)
    ge rx469_pos, rx469_eos, rxscan472_done
  rxscan472_scan:
    set_addr $I10, rxscan472_loop
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  rxscan472_done:
.annotate 'line', 216
  # rx subcapture "sym"
    set_addr $I10, rxcap_474_fail
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  alt473_0:
    set_addr $I10, alt473_1
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  # rx literal  "while"
    add $I11, rx469_pos, 5
    gt $I11, rx469_eos, rx469_fail
    sub $I11, rx469_pos, rx469_off
    substr $S10, rx469_tgt, $I11, 5
    ne $S10, "while", rx469_fail
    add rx469_pos, 5
    goto alt473_end
  alt473_1:
  # rx literal  "until"
    add $I11, rx469_pos, 5
    gt $I11, rx469_eos, rx469_fail
    sub $I11, rx469_pos, rx469_off
    substr $S10, rx469_tgt, $I11, 5
    ne $S10, "until", rx469_fail
    add rx469_pos, 5
  alt473_end:
    set_addr $I10, rxcap_474_fail
    ($I12, $I11) = rx469_cur."!mark_peek"($I10)
    rx469_cur."!cursor_pos"($I11)
    ($P10) = rx469_cur."!cursor_start"()
    $P10."!cursor_pass"(rx469_pos, "")
    rx469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_474_done
  rxcap_474_fail:
    goto rx469_fail
  rxcap_474_done:
  # rx charclass s
    ge rx469_pos, rx469_eos, rx469_fail
    sub $I10, rx469_pos, rx469_off
    is_cclass $I11, 32, rx469_tgt, $I10
    unless $I11, rx469_fail
    inc rx469_pos
  # rx subrule "ws" subtype=method negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."ws"()
    unless $P10, rx469_fail
    rx469_pos = $P10."pos"()
.annotate 'line', 217
  # rx subrule "xblock" subtype=capture negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."xblock"()
    unless $P10, rx469_fail
    rx469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx469_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."ws"()
    unless $P10, rx469_fail
    rx469_pos = $P10."pos"()
.annotate 'line', 215
  # rx pass
    rx469_cur."!cursor_pass"(rx469_pos, "statement_control:sym<while>")
    if_null rx469_debug, debug_744
    rx469_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx469_pos)
  debug_744:
    .return (rx469_cur)
  rx469_restart:
.annotate 'line', 10
    if_null rx469_debug, debug_745
    rx469_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_745:
  rx469_fail:
    (rx469_rep, rx469_pos, $I10, $P10) = rx469_cur."!mark_fail"(0)
    lt rx469_pos, -1, rx469_done
    eq rx469_pos, -1, rx469_fail
    jump $I10
  rx469_done:
    rx469_cur."!cursor_fail"()
    if_null rx469_debug, debug_746
    rx469_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_746:
    .return (rx469_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1303748459.273") :method
.annotate 'line', 10
    new $P471, "ResizablePMCArray"
    push $P471, "until"
    push $P471, "while"
    .return ($P471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx478_tgt
    .local int rx478_pos
    .local int rx478_off
    .local int rx478_eos
    .local int rx478_rep
    .local pmc rx478_cur
    .local pmc rx478_debug
    (rx478_cur, rx478_pos, rx478_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx478_cur
    .local pmc match
    .lex "$/", match
    length rx478_eos, rx478_tgt
    gt rx478_pos, rx478_eos, rx478_done
    set rx478_off, 0
    lt rx478_pos, 2, rx478_start
    sub rx478_off, rx478_pos, 1
    substr rx478_tgt, rx478_tgt, rx478_off
  rx478_start:
    eq $I10, 1, rx478_restart
    if_null rx478_debug, debug_747
    rx478_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_747:
    $I10 = self.'from'()
    ne $I10, -1, rxscan481_done
    goto rxscan481_scan
  rxscan481_loop:
    (rx478_pos) = rx478_cur."from"()
    inc rx478_pos
    rx478_cur."!cursor_from"(rx478_pos)
    ge rx478_pos, rx478_eos, rxscan481_done
  rxscan481_scan:
    set_addr $I10, rxscan481_loop
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  rxscan481_done:
.annotate 'line', 221
  # rx subcapture "sym"
    set_addr $I10, rxcap_482_fail
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx478_pos, 6
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 6
    ne $S10, "repeat", rx478_fail
    add rx478_pos, 6
    set_addr $I10, rxcap_482_fail
    ($I12, $I11) = rx478_cur."!mark_peek"($I10)
    rx478_cur."!cursor_pos"($I11)
    ($P10) = rx478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx478_pos, "")
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_482_done
  rxcap_482_fail:
    goto rx478_fail
  rxcap_482_done:
  # rx charclass s
    ge rx478_pos, rx478_eos, rx478_fail
    sub $I10, rx478_pos, rx478_off
    is_cclass $I11, 32, rx478_tgt, $I10
    unless $I11, rx478_fail
    inc rx478_pos
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  alt484_0:
.annotate 'line', 222
    set_addr $I10, alt484_1
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
.annotate 'line', 223
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_487_fail
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  alt486_0:
    set_addr $I10, alt486_1
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  # rx literal  "while"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "while", rx478_fail
    add rx478_pos, 5
    goto alt486_end
  alt486_1:
  # rx literal  "until"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "until", rx478_fail
    add rx478_pos, 5
  alt486_end:
    set_addr $I10, rxcap_487_fail
    ($I12, $I11) = rx478_cur."!mark_peek"($I10)
    rx478_cur."!cursor_pos"($I11)
    ($P10) = rx478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx478_pos, "")
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_487_done
  rxcap_487_fail:
    goto rx478_fail
  rxcap_487_done:
  # rx charclass s
    ge rx478_pos, rx478_eos, rx478_fail
    sub $I10, rx478_pos, rx478_off
    is_cclass $I11, 32, rx478_tgt, $I10
    unless $I11, rx478_fail
    inc rx478_pos
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."xblock"()
    unless $P10, rx478_fail
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx478_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
    goto alt484_end
  alt484_1:
.annotate 'line', 224
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."pblock"()
    unless $P10, rx478_fail
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx478_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_493_fail
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  alt492_0:
    set_addr $I10, alt492_1
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  # rx literal  "while"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "while", rx478_fail
    add rx478_pos, 5
    goto alt492_end
  alt492_1:
  # rx literal  "until"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "until", rx478_fail
    add rx478_pos, 5
  alt492_end:
    set_addr $I10, rxcap_493_fail
    ($I12, $I11) = rx478_cur."!mark_peek"($I10)
    rx478_cur."!cursor_pos"($I11)
    ($P10) = rx478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx478_pos, "")
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_493_done
  rxcap_493_fail:
    goto rx478_fail
  rxcap_493_done:
  # rx charclass s
    ge rx478_pos, rx478_eos, rx478_fail
    sub $I10, rx478_pos, rx478_off
    is_cclass $I11, 32, rx478_tgt, $I10
    unless $I11, rx478_fail
    inc rx478_pos
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."EXPR"()
    unless $P10, rx478_fail
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx478_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  alt484_end:
.annotate 'line', 225
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
.annotate 'line', 220
  # rx pass
    rx478_cur."!cursor_pass"(rx478_pos, "statement_control:sym<repeat>")
    if_null rx478_debug, debug_748
    rx478_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx478_pos)
  debug_748:
    .return (rx478_cur)
  rx478_restart:
.annotate 'line', 10
    if_null rx478_debug, debug_749
    rx478_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_749:
  rx478_fail:
    (rx478_rep, rx478_pos, $I10, $P10) = rx478_cur."!mark_fail"(0)
    lt rx478_pos, -1, rx478_done
    eq rx478_pos, -1, rx478_fail
    jump $I10
  rx478_done:
    rx478_cur."!cursor_fail"()
    if_null rx478_debug, debug_750
    rx478_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_750:
    .return (rx478_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1303748459.273") :method
.annotate 'line', 10
    new $P480, "ResizablePMCArray"
    push $P480, "repeat"
    .return ($P480)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx498_tgt
    .local int rx498_pos
    .local int rx498_off
    .local int rx498_eos
    .local int rx498_rep
    .local pmc rx498_cur
    .local pmc rx498_debug
    (rx498_cur, rx498_pos, rx498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx498_cur
    .local pmc match
    .lex "$/", match
    length rx498_eos, rx498_tgt
    gt rx498_pos, rx498_eos, rx498_done
    set rx498_off, 0
    lt rx498_pos, 2, rx498_start
    sub rx498_off, rx498_pos, 1
    substr rx498_tgt, rx498_tgt, rx498_off
  rx498_start:
    eq $I10, 1, rx498_restart
    if_null rx498_debug, debug_751
    rx498_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_751:
    $I10 = self.'from'()
    ne $I10, -1, rxscan501_done
    goto rxscan501_scan
  rxscan501_loop:
    (rx498_pos) = rx498_cur."from"()
    inc rx498_pos
    rx498_cur."!cursor_from"(rx498_pos)
    ge rx498_pos, rx498_eos, rxscan501_done
  rxscan501_scan:
    set_addr $I10, rxscan501_loop
    rx498_cur."!mark_push"(0, rx498_pos, $I10)
  rxscan501_done:
.annotate 'line', 229
  # rx subcapture "sym"
    set_addr $I10, rxcap_502_fail
    rx498_cur."!mark_push"(0, rx498_pos, $I10)
  # rx literal  "for"
    add $I11, rx498_pos, 3
    gt $I11, rx498_eos, rx498_fail
    sub $I11, rx498_pos, rx498_off
    substr $S10, rx498_tgt, $I11, 3
    ne $S10, "for", rx498_fail
    add rx498_pos, 3
    set_addr $I10, rxcap_502_fail
    ($I12, $I11) = rx498_cur."!mark_peek"($I10)
    rx498_cur."!cursor_pos"($I11)
    ($P10) = rx498_cur."!cursor_start"()
    $P10."!cursor_pass"(rx498_pos, "")
    rx498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_502_done
  rxcap_502_fail:
    goto rx498_fail
  rxcap_502_done:
  # rx charclass s
    ge rx498_pos, rx498_eos, rx498_fail
    sub $I10, rx498_pos, rx498_off
    is_cclass $I11, 32, rx498_tgt, $I10
    unless $I11, rx498_fail
    inc rx498_pos
  # rx subrule "ws" subtype=method negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."ws"()
    unless $P10, rx498_fail
    rx498_pos = $P10."pos"()
.annotate 'line', 230
  # rx subrule "xblock" subtype=capture negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."xblock"()
    unless $P10, rx498_fail
    rx498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx498_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."ws"()
    unless $P10, rx498_fail
    rx498_pos = $P10."pos"()
.annotate 'line', 228
  # rx pass
    rx498_cur."!cursor_pass"(rx498_pos, "statement_control:sym<for>")
    if_null rx498_debug, debug_752
    rx498_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx498_pos)
  debug_752:
    .return (rx498_cur)
  rx498_restart:
.annotate 'line', 10
    if_null rx498_debug, debug_753
    rx498_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_753:
  rx498_fail:
    (rx498_rep, rx498_pos, $I10, $P10) = rx498_cur."!mark_fail"(0)
    lt rx498_pos, -1, rx498_done
    eq rx498_pos, -1, rx498_fail
    jump $I10
  rx498_done:
    rx498_cur."!cursor_fail"()
    if_null rx498_debug, debug_754
    rx498_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_754:
    .return (rx498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1303748459.273") :method
.annotate 'line', 10
    new $P500, "ResizablePMCArray"
    push $P500, "for"
    .return ($P500)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx506_tgt
    .local int rx506_pos
    .local int rx506_off
    .local int rx506_eos
    .local int rx506_rep
    .local pmc rx506_cur
    .local pmc rx506_debug
    (rx506_cur, rx506_pos, rx506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx506_cur
    .local pmc match
    .lex "$/", match
    length rx506_eos, rx506_tgt
    gt rx506_pos, rx506_eos, rx506_done
    set rx506_off, 0
    lt rx506_pos, 2, rx506_start
    sub rx506_off, rx506_pos, 1
    substr rx506_tgt, rx506_tgt, rx506_off
  rx506_start:
    eq $I10, 1, rx506_restart
    if_null rx506_debug, debug_755
    rx506_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_755:
    $I10 = self.'from'()
    ne $I10, -1, rxscan509_done
    goto rxscan509_scan
  rxscan509_loop:
    (rx506_pos) = rx506_cur."from"()
    inc rx506_pos
    rx506_cur."!cursor_from"(rx506_pos)
    ge rx506_pos, rx506_eos, rxscan509_done
  rxscan509_scan:
    set_addr $I10, rxscan509_loop
    rx506_cur."!mark_push"(0, rx506_pos, $I10)
  rxscan509_done:
.annotate 'line', 234
  # rx subcapture "sym"
    set_addr $I10, rxcap_510_fail
    rx506_cur."!mark_push"(0, rx506_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx506_pos, 5
    gt $I11, rx506_eos, rx506_fail
    sub $I11, rx506_pos, rx506_off
    substr $S10, rx506_tgt, $I11, 5
    ne $S10, "CATCH", rx506_fail
    add rx506_pos, 5
    set_addr $I10, rxcap_510_fail
    ($I12, $I11) = rx506_cur."!mark_peek"($I10)
    rx506_cur."!cursor_pos"($I11)
    ($P10) = rx506_cur."!cursor_start"()
    $P10."!cursor_pass"(rx506_pos, "")
    rx506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_510_done
  rxcap_510_fail:
    goto rx506_fail
  rxcap_510_done:
  # rx charclass s
    ge rx506_pos, rx506_eos, rx506_fail
    sub $I10, rx506_pos, rx506_off
    is_cclass $I11, 32, rx506_tgt, $I10
    unless $I11, rx506_fail
    inc rx506_pos
  # rx subrule "ws" subtype=method negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."ws"()
    unless $P10, rx506_fail
    rx506_pos = $P10."pos"()
.annotate 'line', 235
  # rx subrule "block" subtype=capture negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."block"()
    unless $P10, rx506_fail
    rx506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx506_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."ws"()
    unless $P10, rx506_fail
    rx506_pos = $P10."pos"()
.annotate 'line', 233
  # rx pass
    rx506_cur."!cursor_pass"(rx506_pos, "statement_control:sym<CATCH>")
    if_null rx506_debug, debug_756
    rx506_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx506_pos)
  debug_756:
    .return (rx506_cur)
  rx506_restart:
.annotate 'line', 10
    if_null rx506_debug, debug_757
    rx506_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_757:
  rx506_fail:
    (rx506_rep, rx506_pos, $I10, $P10) = rx506_cur."!mark_fail"(0)
    lt rx506_pos, -1, rx506_done
    eq rx506_pos, -1, rx506_fail
    jump $I10
  rx506_done:
    rx506_cur."!cursor_fail"()
    if_null rx506_debug, debug_758
    rx506_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_758:
    .return (rx506_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1303748459.273") :method
.annotate 'line', 10
    new $P508, "ResizablePMCArray"
    push $P508, "CATCH"
    .return ($P508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx514_tgt
    .local int rx514_pos
    .local int rx514_off
    .local int rx514_eos
    .local int rx514_rep
    .local pmc rx514_cur
    .local pmc rx514_debug
    (rx514_cur, rx514_pos, rx514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx514_cur
    .local pmc match
    .lex "$/", match
    length rx514_eos, rx514_tgt
    gt rx514_pos, rx514_eos, rx514_done
    set rx514_off, 0
    lt rx514_pos, 2, rx514_start
    sub rx514_off, rx514_pos, 1
    substr rx514_tgt, rx514_tgt, rx514_off
  rx514_start:
    eq $I10, 1, rx514_restart
    if_null rx514_debug, debug_759
    rx514_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_759:
    $I10 = self.'from'()
    ne $I10, -1, rxscan517_done
    goto rxscan517_scan
  rxscan517_loop:
    (rx514_pos) = rx514_cur."from"()
    inc rx514_pos
    rx514_cur."!cursor_from"(rx514_pos)
    ge rx514_pos, rx514_eos, rxscan517_done
  rxscan517_scan:
    set_addr $I10, rxscan517_loop
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  rxscan517_done:
.annotate 'line', 239
  # rx subcapture "sym"
    set_addr $I10, rxcap_518_fail
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx514_pos, 7
    gt $I11, rx514_eos, rx514_fail
    sub $I11, rx514_pos, rx514_off
    substr $S10, rx514_tgt, $I11, 7
    ne $S10, "CONTROL", rx514_fail
    add rx514_pos, 7
    set_addr $I10, rxcap_518_fail
    ($I12, $I11) = rx514_cur."!mark_peek"($I10)
    rx514_cur."!cursor_pos"($I11)
    ($P10) = rx514_cur."!cursor_start"()
    $P10."!cursor_pass"(rx514_pos, "")
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_518_done
  rxcap_518_fail:
    goto rx514_fail
  rxcap_518_done:
  # rx charclass s
    ge rx514_pos, rx514_eos, rx514_fail
    sub $I10, rx514_pos, rx514_off
    is_cclass $I11, 32, rx514_tgt, $I10
    unless $I11, rx514_fail
    inc rx514_pos
  # rx subrule "ws" subtype=method negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."ws"()
    unless $P10, rx514_fail
    rx514_pos = $P10."pos"()
.annotate 'line', 240
  # rx subrule "block" subtype=capture negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."block"()
    unless $P10, rx514_fail
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx514_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."ws"()
    unless $P10, rx514_fail
    rx514_pos = $P10."pos"()
.annotate 'line', 238
  # rx pass
    rx514_cur."!cursor_pass"(rx514_pos, "statement_control:sym<CONTROL>")
    if_null rx514_debug, debug_760
    rx514_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx514_pos)
  debug_760:
    .return (rx514_cur)
  rx514_restart:
.annotate 'line', 10
    if_null rx514_debug, debug_761
    rx514_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_761:
  rx514_fail:
    (rx514_rep, rx514_pos, $I10, $P10) = rx514_cur."!mark_fail"(0)
    lt rx514_pos, -1, rx514_done
    eq rx514_pos, -1, rx514_fail
    jump $I10
  rx514_done:
    rx514_cur."!cursor_fail"()
    if_null rx514_debug, debug_762
    rx514_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_762:
    .return (rx514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1303748459.273") :method
.annotate 'line', 10
    new $P516, "ResizablePMCArray"
    push $P516, "CONTROL"
    .return ($P516)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1303748459.273")
    .param pmc param_522
.annotate 'line', 243
    .lex "self", param_522
    $P523 = param_522."!protoregex"("statement_prefix")
    .return ($P523)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1303748459.273")
    .param pmc param_525
.annotate 'line', 243
    .lex "self", param_525
    $P526 = param_525."!PREFIX__!protoregex"("statement_prefix")
    .return ($P526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx528_tgt
    .local int rx528_pos
    .local int rx528_off
    .local int rx528_eos
    .local int rx528_rep
    .local pmc rx528_cur
    .local pmc rx528_debug
    (rx528_cur, rx528_pos, rx528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx528_cur
    .local pmc match
    .lex "$/", match
    length rx528_eos, rx528_tgt
    gt rx528_pos, rx528_eos, rx528_done
    set rx528_off, 0
    lt rx528_pos, 2, rx528_start
    sub rx528_off, rx528_pos, 1
    substr rx528_tgt, rx528_tgt, rx528_off
  rx528_start:
    eq $I10, 1, rx528_restart
    if_null rx528_debug, debug_763
    rx528_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_763:
    $I10 = self.'from'()
    ne $I10, -1, rxscan532_done
    goto rxscan532_scan
  rxscan532_loop:
    (rx528_pos) = rx528_cur."from"()
    inc rx528_pos
    rx528_cur."!cursor_from"(rx528_pos)
    ge rx528_pos, rx528_eos, rxscan532_done
  rxscan532_scan:
    set_addr $I10, rxscan532_loop
    rx528_cur."!mark_push"(0, rx528_pos, $I10)
  rxscan532_done:
.annotate 'line', 244
  # rx subcapture "sym"
    set_addr $I10, rxcap_533_fail
    rx528_cur."!mark_push"(0, rx528_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx528_pos, 4
    gt $I11, rx528_eos, rx528_fail
    sub $I11, rx528_pos, rx528_off
    substr $S10, rx528_tgt, $I11, 4
    ne $S10, "INIT", rx528_fail
    add rx528_pos, 4
    set_addr $I10, rxcap_533_fail
    ($I12, $I11) = rx528_cur."!mark_peek"($I10)
    rx528_cur."!cursor_pos"($I11)
    ($P10) = rx528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx528_pos, "")
    rx528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_533_done
  rxcap_533_fail:
    goto rx528_fail
  rxcap_533_done:
  # rx subrule "blorst" subtype=capture negate=
    rx528_cur."!cursor_pos"(rx528_pos)
    $P10 = rx528_cur."blorst"()
    unless $P10, rx528_fail
    rx528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx528_pos = $P10."pos"()
  # rx pass
    rx528_cur."!cursor_pass"(rx528_pos, "statement_prefix:sym<INIT>")
    if_null rx528_debug, debug_764
    rx528_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx528_pos)
  debug_764:
    .return (rx528_cur)
  rx528_restart:
.annotate 'line', 10
    if_null rx528_debug, debug_765
    rx528_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_765:
  rx528_fail:
    (rx528_rep, rx528_pos, $I10, $P10) = rx528_cur."!mark_fail"(0)
    lt rx528_pos, -1, rx528_done
    eq rx528_pos, -1, rx528_fail
    jump $I10
  rx528_done:
    rx528_cur."!cursor_fail"()
    if_null rx528_debug, debug_766
    rx528_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_766:
    .return (rx528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1303748459.273") :method
.annotate 'line', 10
    $P530 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P531, "ResizablePMCArray"
    push $P531, $P530
    .return ($P531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx535_tgt
    .local int rx535_pos
    .local int rx535_off
    .local int rx535_eos
    .local int rx535_rep
    .local pmc rx535_cur
    .local pmc rx535_debug
    (rx535_cur, rx535_pos, rx535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx535_cur
    .local pmc match
    .lex "$/", match
    length rx535_eos, rx535_tgt
    gt rx535_pos, rx535_eos, rx535_done
    set rx535_off, 0
    lt rx535_pos, 2, rx535_start
    sub rx535_off, rx535_pos, 1
    substr rx535_tgt, rx535_tgt, rx535_off
  rx535_start:
    eq $I10, 1, rx535_restart
    if_null rx535_debug, debug_767
    rx535_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_767:
    $I10 = self.'from'()
    ne $I10, -1, rxscan539_done
    goto rxscan539_scan
  rxscan539_loop:
    (rx535_pos) = rx535_cur."from"()
    inc rx535_pos
    rx535_cur."!cursor_from"(rx535_pos)
    ge rx535_pos, rx535_eos, rxscan539_done
  rxscan539_scan:
    set_addr $I10, rxscan539_loop
    rx535_cur."!mark_push"(0, rx535_pos, $I10)
  rxscan539_done:
.annotate 'line', 247
  # rx subcapture "sym"
    set_addr $I10, rxcap_540_fail
    rx535_cur."!mark_push"(0, rx535_pos, $I10)
  # rx literal  "try"
    add $I11, rx535_pos, 3
    gt $I11, rx535_eos, rx535_fail
    sub $I11, rx535_pos, rx535_off
    substr $S10, rx535_tgt, $I11, 3
    ne $S10, "try", rx535_fail
    add rx535_pos, 3
    set_addr $I10, rxcap_540_fail
    ($I12, $I11) = rx535_cur."!mark_peek"($I10)
    rx535_cur."!cursor_pos"($I11)
    ($P10) = rx535_cur."!cursor_start"()
    $P10."!cursor_pass"(rx535_pos, "")
    rx535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_540_done
  rxcap_540_fail:
    goto rx535_fail
  rxcap_540_done:
.annotate 'line', 248
  # rx subrule "blorst" subtype=capture negate=
    rx535_cur."!cursor_pos"(rx535_pos)
    $P10 = rx535_cur."blorst"()
    unless $P10, rx535_fail
    rx535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx535_pos = $P10."pos"()
.annotate 'line', 246
  # rx pass
    rx535_cur."!cursor_pass"(rx535_pos, "statement_prefix:sym<try>")
    if_null rx535_debug, debug_768
    rx535_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx535_pos)
  debug_768:
    .return (rx535_cur)
  rx535_restart:
.annotate 'line', 10
    if_null rx535_debug, debug_769
    rx535_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_769:
  rx535_fail:
    (rx535_rep, rx535_pos, $I10, $P10) = rx535_cur."!mark_fail"(0)
    lt rx535_pos, -1, rx535_done
    eq rx535_pos, -1, rx535_fail
    jump $I10
  rx535_done:
    rx535_cur."!cursor_fail"()
    if_null rx535_debug, debug_770
    rx535_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_770:
    .return (rx535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1303748459.273") :method
.annotate 'line', 10
    $P537 = self."!PREFIX__!subrule"("blorst", "try")
    new $P538, "ResizablePMCArray"
    push $P538, $P537
    .return ($P538)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx542_tgt
    .local int rx542_pos
    .local int rx542_off
    .local int rx542_eos
    .local int rx542_rep
    .local pmc rx542_cur
    .local pmc rx542_debug
    (rx542_cur, rx542_pos, rx542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx542_cur
    .local pmc match
    .lex "$/", match
    length rx542_eos, rx542_tgt
    gt rx542_pos, rx542_eos, rx542_done
    set rx542_off, 0
    lt rx542_pos, 2, rx542_start
    sub rx542_off, rx542_pos, 1
    substr rx542_tgt, rx542_tgt, rx542_off
  rx542_start:
    eq $I10, 1, rx542_restart
    if_null rx542_debug, debug_771
    rx542_cur."!cursor_debug"("START", "blorst")
  debug_771:
    $I10 = self.'from'()
    ne $I10, -1, rxscan545_done
    goto rxscan545_scan
  rxscan545_loop:
    (rx542_pos) = rx542_cur."from"()
    inc rx542_pos
    rx542_cur."!cursor_from"(rx542_pos)
    ge rx542_pos, rx542_eos, rxscan545_done
  rxscan545_scan:
    set_addr $I10, rxscan545_loop
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  rxscan545_done:
.annotate 'line', 252
  # rx charclass s
    ge rx542_pos, rx542_eos, rx542_fail
    sub $I10, rx542_pos, rx542_off
    is_cclass $I11, 32, rx542_tgt, $I10
    unless $I11, rx542_fail
    inc rx542_pos
  # rx subrule "ws" subtype=method negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."ws"()
    unless $P10, rx542_fail
    rx542_pos = $P10."pos"()
  alt546_0:
    set_addr $I10, alt546_1
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx542_pos, rx542_off
    substr $S10, rx542_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx542_fail
  # rx subrule "block" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."block"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx542_pos = $P10."pos"()
    goto alt546_end
  alt546_1:
  # rx subrule "statement" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."statement"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx542_pos = $P10."pos"()
  alt546_end:
.annotate 'line', 251
  # rx pass
    rx542_cur."!cursor_pass"(rx542_pos, "blorst")
    if_null rx542_debug, debug_772
    rx542_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx542_pos)
  debug_772:
    .return (rx542_cur)
  rx542_restart:
.annotate 'line', 10
    if_null rx542_debug, debug_773
    rx542_cur."!cursor_debug"("NEXT", "blorst")
  debug_773:
  rx542_fail:
    (rx542_rep, rx542_pos, $I10, $P10) = rx542_cur."!mark_fail"(0)
    lt rx542_pos, -1, rx542_done
    eq rx542_pos, -1, rx542_fail
    jump $I10
  rx542_done:
    rx542_cur."!cursor_fail"()
    if_null rx542_debug, debug_774
    rx542_cur."!cursor_debug"("FAIL", "blorst")
  debug_774:
    .return (rx542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1303748459.273") :method
.annotate 'line', 10
    new $P544, "ResizablePMCArray"
    push $P544, ""
    .return ($P544)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1303748459.273")
    .param pmc param_548
.annotate 'line', 257
    .lex "self", param_548
    $P549 = param_548."!protoregex"("statement_mod_cond")
    .return ($P549)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1303748459.273")
    .param pmc param_551
.annotate 'line', 257
    .lex "self", param_551
    $P552 = param_551."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx554_tgt
    .local int rx554_pos
    .local int rx554_off
    .local int rx554_eos
    .local int rx554_rep
    .local pmc rx554_cur
    .local pmc rx554_debug
    (rx554_cur, rx554_pos, rx554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx554_cur
    .local pmc match
    .lex "$/", match
    length rx554_eos, rx554_tgt
    gt rx554_pos, rx554_eos, rx554_done
    set rx554_off, 0
    lt rx554_pos, 2, rx554_start
    sub rx554_off, rx554_pos, 1
    substr rx554_tgt, rx554_tgt, rx554_off
  rx554_start:
    eq $I10, 1, rx554_restart
    if_null rx554_debug, debug_775
    rx554_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_775:
    $I10 = self.'from'()
    ne $I10, -1, rxscan558_done
    goto rxscan558_scan
  rxscan558_loop:
    (rx554_pos) = rx554_cur."from"()
    inc rx554_pos
    rx554_cur."!cursor_from"(rx554_pos)
    ge rx554_pos, rx554_eos, rxscan558_done
  rxscan558_scan:
    set_addr $I10, rxscan558_loop
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  rxscan558_done:
.annotate 'line', 259
  # rx subcapture "sym"
    set_addr $I10, rxcap_559_fail
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  # rx literal  "if"
    add $I11, rx554_pos, 2
    gt $I11, rx554_eos, rx554_fail
    sub $I11, rx554_pos, rx554_off
    substr $S10, rx554_tgt, $I11, 2
    ne $S10, "if", rx554_fail
    add rx554_pos, 2
    set_addr $I10, rxcap_559_fail
    ($I12, $I11) = rx554_cur."!mark_peek"($I10)
    rx554_cur."!cursor_pos"($I11)
    ($P10) = rx554_cur."!cursor_start"()
    $P10."!cursor_pass"(rx554_pos, "")
    rx554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_559_done
  rxcap_559_fail:
    goto rx554_fail
  rxcap_559_done:
  # rx subrule "ws" subtype=method negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."ws"()
    unless $P10, rx554_fail
    rx554_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."EXPR"()
    unless $P10, rx554_fail
    rx554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx554_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."ws"()
    unless $P10, rx554_fail
    rx554_pos = $P10."pos"()
  # rx pass
    rx554_cur."!cursor_pass"(rx554_pos, "statement_mod_cond:sym<if>")
    if_null rx554_debug, debug_776
    rx554_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx554_pos)
  debug_776:
    .return (rx554_cur)
  rx554_restart:
.annotate 'line', 10
    if_null rx554_debug, debug_777
    rx554_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_777:
  rx554_fail:
    (rx554_rep, rx554_pos, $I10, $P10) = rx554_cur."!mark_fail"(0)
    lt rx554_pos, -1, rx554_done
    eq rx554_pos, -1, rx554_fail
    jump $I10
  rx554_done:
    rx554_cur."!cursor_fail"()
    if_null rx554_debug, debug_778
    rx554_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_778:
    .return (rx554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1303748459.273") :method
.annotate 'line', 10
    $P556 = self."!PREFIX__!subrule"("ws", "if")
    new $P557, "ResizablePMCArray"
    push $P557, $P556
    .return ($P557)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx563_tgt
    .local int rx563_pos
    .local int rx563_off
    .local int rx563_eos
    .local int rx563_rep
    .local pmc rx563_cur
    .local pmc rx563_debug
    (rx563_cur, rx563_pos, rx563_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx563_cur
    .local pmc match
    .lex "$/", match
    length rx563_eos, rx563_tgt
    gt rx563_pos, rx563_eos, rx563_done
    set rx563_off, 0
    lt rx563_pos, 2, rx563_start
    sub rx563_off, rx563_pos, 1
    substr rx563_tgt, rx563_tgt, rx563_off
  rx563_start:
    eq $I10, 1, rx563_restart
    if_null rx563_debug, debug_779
    rx563_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_779:
    $I10 = self.'from'()
    ne $I10, -1, rxscan567_done
    goto rxscan567_scan
  rxscan567_loop:
    (rx563_pos) = rx563_cur."from"()
    inc rx563_pos
    rx563_cur."!cursor_from"(rx563_pos)
    ge rx563_pos, rx563_eos, rxscan567_done
  rxscan567_scan:
    set_addr $I10, rxscan567_loop
    rx563_cur."!mark_push"(0, rx563_pos, $I10)
  rxscan567_done:
.annotate 'line', 260
  # rx subcapture "sym"
    set_addr $I10, rxcap_568_fail
    rx563_cur."!mark_push"(0, rx563_pos, $I10)
  # rx literal  "unless"
    add $I11, rx563_pos, 6
    gt $I11, rx563_eos, rx563_fail
    sub $I11, rx563_pos, rx563_off
    substr $S10, rx563_tgt, $I11, 6
    ne $S10, "unless", rx563_fail
    add rx563_pos, 6
    set_addr $I10, rxcap_568_fail
    ($I12, $I11) = rx563_cur."!mark_peek"($I10)
    rx563_cur."!cursor_pos"($I11)
    ($P10) = rx563_cur."!cursor_start"()
    $P10."!cursor_pass"(rx563_pos, "")
    rx563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_568_done
  rxcap_568_fail:
    goto rx563_fail
  rxcap_568_done:
  # rx subrule "ws" subtype=method negate=
    rx563_cur."!cursor_pos"(rx563_pos)
    $P10 = rx563_cur."ws"()
    unless $P10, rx563_fail
    rx563_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx563_cur."!cursor_pos"(rx563_pos)
    $P10 = rx563_cur."EXPR"()
    unless $P10, rx563_fail
    rx563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx563_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx563_cur."!cursor_pos"(rx563_pos)
    $P10 = rx563_cur."ws"()
    unless $P10, rx563_fail
    rx563_pos = $P10."pos"()
  # rx pass
    rx563_cur."!cursor_pass"(rx563_pos, "statement_mod_cond:sym<unless>")
    if_null rx563_debug, debug_780
    rx563_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx563_pos)
  debug_780:
    .return (rx563_cur)
  rx563_restart:
.annotate 'line', 10
    if_null rx563_debug, debug_781
    rx563_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_781:
  rx563_fail:
    (rx563_rep, rx563_pos, $I10, $P10) = rx563_cur."!mark_fail"(0)
    lt rx563_pos, -1, rx563_done
    eq rx563_pos, -1, rx563_fail
    jump $I10
  rx563_done:
    rx563_cur."!cursor_fail"()
    if_null rx563_debug, debug_782
    rx563_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_782:
    .return (rx563_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1303748459.273") :method
.annotate 'line', 10
    $P565 = self."!PREFIX__!subrule"("ws", "unless")
    new $P566, "ResizablePMCArray"
    push $P566, $P565
    .return ($P566)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1303748459.273")
    .param pmc param_572
.annotate 'line', 262
    .lex "self", param_572
    $P573 = param_572."!protoregex"("statement_mod_loop")
    .return ($P573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1303748459.273")
    .param pmc param_575
.annotate 'line', 262
    .lex "self", param_575
    $P576 = param_575."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx578_tgt
    .local int rx578_pos
    .local int rx578_off
    .local int rx578_eos
    .local int rx578_rep
    .local pmc rx578_cur
    .local pmc rx578_debug
    (rx578_cur, rx578_pos, rx578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx578_cur
    .local pmc match
    .lex "$/", match
    length rx578_eos, rx578_tgt
    gt rx578_pos, rx578_eos, rx578_done
    set rx578_off, 0
    lt rx578_pos, 2, rx578_start
    sub rx578_off, rx578_pos, 1
    substr rx578_tgt, rx578_tgt, rx578_off
  rx578_start:
    eq $I10, 1, rx578_restart
    if_null rx578_debug, debug_783
    rx578_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_783:
    $I10 = self.'from'()
    ne $I10, -1, rxscan582_done
    goto rxscan582_scan
  rxscan582_loop:
    (rx578_pos) = rx578_cur."from"()
    inc rx578_pos
    rx578_cur."!cursor_from"(rx578_pos)
    ge rx578_pos, rx578_eos, rxscan582_done
  rxscan582_scan:
    set_addr $I10, rxscan582_loop
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  rxscan582_done:
.annotate 'line', 264
  # rx subcapture "sym"
    set_addr $I10, rxcap_583_fail
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  # rx literal  "while"
    add $I11, rx578_pos, 5
    gt $I11, rx578_eos, rx578_fail
    sub $I11, rx578_pos, rx578_off
    substr $S10, rx578_tgt, $I11, 5
    ne $S10, "while", rx578_fail
    add rx578_pos, 5
    set_addr $I10, rxcap_583_fail
    ($I12, $I11) = rx578_cur."!mark_peek"($I10)
    rx578_cur."!cursor_pos"($I11)
    ($P10) = rx578_cur."!cursor_start"()
    $P10."!cursor_pass"(rx578_pos, "")
    rx578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_583_done
  rxcap_583_fail:
    goto rx578_fail
  rxcap_583_done:
  # rx subrule "ws" subtype=method negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."ws"()
    unless $P10, rx578_fail
    rx578_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."EXPR"()
    unless $P10, rx578_fail
    rx578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx578_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."ws"()
    unless $P10, rx578_fail
    rx578_pos = $P10."pos"()
  # rx pass
    rx578_cur."!cursor_pass"(rx578_pos, "statement_mod_loop:sym<while>")
    if_null rx578_debug, debug_784
    rx578_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx578_pos)
  debug_784:
    .return (rx578_cur)
  rx578_restart:
.annotate 'line', 10
    if_null rx578_debug, debug_785
    rx578_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_785:
  rx578_fail:
    (rx578_rep, rx578_pos, $I10, $P10) = rx578_cur."!mark_fail"(0)
    lt rx578_pos, -1, rx578_done
    eq rx578_pos, -1, rx578_fail
    jump $I10
  rx578_done:
    rx578_cur."!cursor_fail"()
    if_null rx578_debug, debug_786
    rx578_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_786:
    .return (rx578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1303748459.273") :method
.annotate 'line', 10
    $P580 = self."!PREFIX__!subrule"("ws", "while")
    new $P581, "ResizablePMCArray"
    push $P581, $P580
    .return ($P581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx587_tgt
    .local int rx587_pos
    .local int rx587_off
    .local int rx587_eos
    .local int rx587_rep
    .local pmc rx587_cur
    .local pmc rx587_debug
    (rx587_cur, rx587_pos, rx587_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx587_cur
    .local pmc match
    .lex "$/", match
    length rx587_eos, rx587_tgt
    gt rx587_pos, rx587_eos, rx587_done
    set rx587_off, 0
    lt rx587_pos, 2, rx587_start
    sub rx587_off, rx587_pos, 1
    substr rx587_tgt, rx587_tgt, rx587_off
  rx587_start:
    eq $I10, 1, rx587_restart
    if_null rx587_debug, debug_787
    rx587_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_787:
    $I10 = self.'from'()
    ne $I10, -1, rxscan591_done
    goto rxscan591_scan
  rxscan591_loop:
    (rx587_pos) = rx587_cur."from"()
    inc rx587_pos
    rx587_cur."!cursor_from"(rx587_pos)
    ge rx587_pos, rx587_eos, rxscan591_done
  rxscan591_scan:
    set_addr $I10, rxscan591_loop
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  rxscan591_done:
.annotate 'line', 265
  # rx subcapture "sym"
    set_addr $I10, rxcap_592_fail
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  # rx literal  "until"
    add $I11, rx587_pos, 5
    gt $I11, rx587_eos, rx587_fail
    sub $I11, rx587_pos, rx587_off
    substr $S10, rx587_tgt, $I11, 5
    ne $S10, "until", rx587_fail
    add rx587_pos, 5
    set_addr $I10, rxcap_592_fail
    ($I12, $I11) = rx587_cur."!mark_peek"($I10)
    rx587_cur."!cursor_pos"($I11)
    ($P10) = rx587_cur."!cursor_start"()
    $P10."!cursor_pass"(rx587_pos, "")
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_592_done
  rxcap_592_fail:
    goto rx587_fail
  rxcap_592_done:
  # rx subrule "ws" subtype=method negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."ws"()
    unless $P10, rx587_fail
    rx587_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."EXPR"()
    unless $P10, rx587_fail
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx587_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."ws"()
    unless $P10, rx587_fail
    rx587_pos = $P10."pos"()
  # rx pass
    rx587_cur."!cursor_pass"(rx587_pos, "statement_mod_loop:sym<until>")
    if_null rx587_debug, debug_788
    rx587_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx587_pos)
  debug_788:
    .return (rx587_cur)
  rx587_restart:
.annotate 'line', 10
    if_null rx587_debug, debug_789
    rx587_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_789:
  rx587_fail:
    (rx587_rep, rx587_pos, $I10, $P10) = rx587_cur."!mark_fail"(0)
    lt rx587_pos, -1, rx587_done
    eq rx587_pos, -1, rx587_fail
    jump $I10
  rx587_done:
    rx587_cur."!cursor_fail"()
    if_null rx587_debug, debug_790
    rx587_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_790:
    .return (rx587_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1303748459.273") :method
.annotate 'line', 10
    $P589 = self."!PREFIX__!subrule"("ws", "until")
    new $P590, "ResizablePMCArray"
    push $P590, $P589
    .return ($P590)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx596_tgt
    .local int rx596_pos
    .local int rx596_off
    .local int rx596_eos
    .local int rx596_rep
    .local pmc rx596_cur
    .local pmc rx596_debug
    (rx596_cur, rx596_pos, rx596_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx596_cur
    .local pmc match
    .lex "$/", match
    length rx596_eos, rx596_tgt
    gt rx596_pos, rx596_eos, rx596_done
    set rx596_off, 0
    lt rx596_pos, 2, rx596_start
    sub rx596_off, rx596_pos, 1
    substr rx596_tgt, rx596_tgt, rx596_off
  rx596_start:
    eq $I10, 1, rx596_restart
    if_null rx596_debug, debug_791
    rx596_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_791:
    $I10 = self.'from'()
    ne $I10, -1, rxscan600_done
    goto rxscan600_scan
  rxscan600_loop:
    (rx596_pos) = rx596_cur."from"()
    inc rx596_pos
    rx596_cur."!cursor_from"(rx596_pos)
    ge rx596_pos, rx596_eos, rxscan600_done
  rxscan600_scan:
    set_addr $I10, rxscan600_loop
    rx596_cur."!mark_push"(0, rx596_pos, $I10)
  rxscan600_done:
.annotate 'line', 266
  # rx subcapture "sym"
    set_addr $I10, rxcap_601_fail
    rx596_cur."!mark_push"(0, rx596_pos, $I10)
  # rx literal  "for"
    add $I11, rx596_pos, 3
    gt $I11, rx596_eos, rx596_fail
    sub $I11, rx596_pos, rx596_off
    substr $S10, rx596_tgt, $I11, 3
    ne $S10, "for", rx596_fail
    add rx596_pos, 3
    set_addr $I10, rxcap_601_fail
    ($I12, $I11) = rx596_cur."!mark_peek"($I10)
    rx596_cur."!cursor_pos"($I11)
    ($P10) = rx596_cur."!cursor_start"()
    $P10."!cursor_pass"(rx596_pos, "")
    rx596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_601_done
  rxcap_601_fail:
    goto rx596_fail
  rxcap_601_done:
  # rx subrule "ws" subtype=method negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."ws"()
    unless $P10, rx596_fail
    rx596_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."EXPR"()
    unless $P10, rx596_fail
    rx596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx596_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."ws"()
    unless $P10, rx596_fail
    rx596_pos = $P10."pos"()
  # rx pass
    rx596_cur."!cursor_pass"(rx596_pos, "statement_mod_loop:sym<for>")
    if_null rx596_debug, debug_792
    rx596_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx596_pos)
  debug_792:
    .return (rx596_cur)
  rx596_restart:
.annotate 'line', 10
    if_null rx596_debug, debug_793
    rx596_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_793:
  rx596_fail:
    (rx596_rep, rx596_pos, $I10, $P10) = rx596_cur."!mark_fail"(0)
    lt rx596_pos, -1, rx596_done
    eq rx596_pos, -1, rx596_fail
    jump $I10
  rx596_done:
    rx596_cur."!cursor_fail"()
    if_null rx596_debug, debug_794
    rx596_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_794:
    .return (rx596_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1303748459.273") :method
.annotate 'line', 10
    $P598 = self."!PREFIX__!subrule"("ws", "for")
    new $P599, "ResizablePMCArray"
    push $P599, $P598
    .return ($P599)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx605_tgt
    .local int rx605_pos
    .local int rx605_off
    .local int rx605_eos
    .local int rx605_rep
    .local pmc rx605_cur
    .local pmc rx605_debug
    (rx605_cur, rx605_pos, rx605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx605_cur
    .local pmc match
    .lex "$/", match
    length rx605_eos, rx605_tgt
    gt rx605_pos, rx605_eos, rx605_done
    set rx605_off, 0
    lt rx605_pos, 2, rx605_start
    sub rx605_off, rx605_pos, 1
    substr rx605_tgt, rx605_tgt, rx605_off
  rx605_start:
    eq $I10, 1, rx605_restart
    if_null rx605_debug, debug_795
    rx605_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_795:
    $I10 = self.'from'()
    ne $I10, -1, rxscan609_done
    goto rxscan609_scan
  rxscan609_loop:
    (rx605_pos) = rx605_cur."from"()
    inc rx605_pos
    rx605_cur."!cursor_from"(rx605_pos)
    ge rx605_pos, rx605_eos, rxscan609_done
  rxscan609_scan:
    set_addr $I10, rxscan609_loop
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  rxscan609_done:
.annotate 'line', 270
  # rx subrule "fatarrow" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."fatarrow"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx605_pos = $P10."pos"()
  # rx pass
    rx605_cur."!cursor_pass"(rx605_pos, "term:sym<fatarrow>")
    if_null rx605_debug, debug_796
    rx605_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx605_pos)
  debug_796:
    .return (rx605_cur)
  rx605_restart:
.annotate 'line', 10
    if_null rx605_debug, debug_797
    rx605_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_797:
  rx605_fail:
    (rx605_rep, rx605_pos, $I10, $P10) = rx605_cur."!mark_fail"(0)
    lt rx605_pos, -1, rx605_done
    eq rx605_pos, -1, rx605_fail
    jump $I10
  rx605_done:
    rx605_cur."!cursor_fail"()
    if_null rx605_debug, debug_798
    rx605_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_798:
    .return (rx605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1303748459.273") :method
.annotate 'line', 10
    $P607 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P608, "ResizablePMCArray"
    push $P608, $P607
    .return ($P608)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx611_tgt
    .local int rx611_pos
    .local int rx611_off
    .local int rx611_eos
    .local int rx611_rep
    .local pmc rx611_cur
    .local pmc rx611_debug
    (rx611_cur, rx611_pos, rx611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx611_cur
    .local pmc match
    .lex "$/", match
    length rx611_eos, rx611_tgt
    gt rx611_pos, rx611_eos, rx611_done
    set rx611_off, 0
    lt rx611_pos, 2, rx611_start
    sub rx611_off, rx611_pos, 1
    substr rx611_tgt, rx611_tgt, rx611_off
  rx611_start:
    eq $I10, 1, rx611_restart
    if_null rx611_debug, debug_799
    rx611_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_799:
    $I10 = self.'from'()
    ne $I10, -1, rxscan615_done
    goto rxscan615_scan
  rxscan615_loop:
    (rx611_pos) = rx611_cur."from"()
    inc rx611_pos
    rx611_cur."!cursor_from"(rx611_pos)
    ge rx611_pos, rx611_eos, rxscan615_done
  rxscan615_scan:
    set_addr $I10, rxscan615_loop
    rx611_cur."!mark_push"(0, rx611_pos, $I10)
  rxscan615_done:
.annotate 'line', 271
  # rx subrule "colonpair" subtype=capture negate=
    rx611_cur."!cursor_pos"(rx611_pos)
    $P10 = rx611_cur."colonpair"()
    unless $P10, rx611_fail
    rx611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx611_pos = $P10."pos"()
  # rx pass
    rx611_cur."!cursor_pass"(rx611_pos, "term:sym<colonpair>")
    if_null rx611_debug, debug_800
    rx611_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx611_pos)
  debug_800:
    .return (rx611_cur)
  rx611_restart:
.annotate 'line', 10
    if_null rx611_debug, debug_801
    rx611_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_801:
  rx611_fail:
    (rx611_rep, rx611_pos, $I10, $P10) = rx611_cur."!mark_fail"(0)
    lt rx611_pos, -1, rx611_done
    eq rx611_pos, -1, rx611_fail
    jump $I10
  rx611_done:
    rx611_cur."!cursor_fail"()
    if_null rx611_debug, debug_802
    rx611_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_802:
    .return (rx611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1303748459.273") :method
.annotate 'line', 10
    $P613 = self."!PREFIX__!subrule"("colonpair", "")
    new $P614, "ResizablePMCArray"
    push $P614, $P613
    .return ($P614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx617_tgt
    .local int rx617_pos
    .local int rx617_off
    .local int rx617_eos
    .local int rx617_rep
    .local pmc rx617_cur
    .local pmc rx617_debug
    (rx617_cur, rx617_pos, rx617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx617_cur
    .local pmc match
    .lex "$/", match
    length rx617_eos, rx617_tgt
    gt rx617_pos, rx617_eos, rx617_done
    set rx617_off, 0
    lt rx617_pos, 2, rx617_start
    sub rx617_off, rx617_pos, 1
    substr rx617_tgt, rx617_tgt, rx617_off
  rx617_start:
    eq $I10, 1, rx617_restart
    if_null rx617_debug, debug_803
    rx617_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_803:
    $I10 = self.'from'()
    ne $I10, -1, rxscan621_done
    goto rxscan621_scan
  rxscan621_loop:
    (rx617_pos) = rx617_cur."from"()
    inc rx617_pos
    rx617_cur."!cursor_from"(rx617_pos)
    ge rx617_pos, rx617_eos, rxscan621_done
  rxscan621_scan:
    set_addr $I10, rxscan621_loop
    rx617_cur."!mark_push"(0, rx617_pos, $I10)
  rxscan621_done:
.annotate 'line', 272
  # rx subrule "variable" subtype=capture negate=
    rx617_cur."!cursor_pos"(rx617_pos)
    $P10 = rx617_cur."variable"()
    unless $P10, rx617_fail
    rx617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx617_pos = $P10."pos"()
  # rx pass
    rx617_cur."!cursor_pass"(rx617_pos, "term:sym<variable>")
    if_null rx617_debug, debug_804
    rx617_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx617_pos)
  debug_804:
    .return (rx617_cur)
  rx617_restart:
.annotate 'line', 10
    if_null rx617_debug, debug_805
    rx617_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_805:
  rx617_fail:
    (rx617_rep, rx617_pos, $I10, $P10) = rx617_cur."!mark_fail"(0)
    lt rx617_pos, -1, rx617_done
    eq rx617_pos, -1, rx617_fail
    jump $I10
  rx617_done:
    rx617_cur."!cursor_fail"()
    if_null rx617_debug, debug_806
    rx617_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_806:
    .return (rx617_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1303748459.273") :method
.annotate 'line', 10
    $P619 = self."!PREFIX__!subrule"("variable", "")
    new $P620, "ResizablePMCArray"
    push $P620, $P619
    .return ($P620)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx623_tgt
    .local int rx623_pos
    .local int rx623_off
    .local int rx623_eos
    .local int rx623_rep
    .local pmc rx623_cur
    .local pmc rx623_debug
    (rx623_cur, rx623_pos, rx623_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx623_cur
    .local pmc match
    .lex "$/", match
    length rx623_eos, rx623_tgt
    gt rx623_pos, rx623_eos, rx623_done
    set rx623_off, 0
    lt rx623_pos, 2, rx623_start
    sub rx623_off, rx623_pos, 1
    substr rx623_tgt, rx623_tgt, rx623_off
  rx623_start:
    eq $I10, 1, rx623_restart
    if_null rx623_debug, debug_807
    rx623_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_807:
    $I10 = self.'from'()
    ne $I10, -1, rxscan627_done
    goto rxscan627_scan
  rxscan627_loop:
    (rx623_pos) = rx623_cur."from"()
    inc rx623_pos
    rx623_cur."!cursor_from"(rx623_pos)
    ge rx623_pos, rx623_eos, rxscan627_done
  rxscan627_scan:
    set_addr $I10, rxscan627_loop
    rx623_cur."!mark_push"(0, rx623_pos, $I10)
  rxscan627_done:
.annotate 'line', 273
  # rx subrule "package_declarator" subtype=capture negate=
    rx623_cur."!cursor_pos"(rx623_pos)
    $P10 = rx623_cur."package_declarator"()
    unless $P10, rx623_fail
    rx623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx623_pos = $P10."pos"()
  # rx pass
    rx623_cur."!cursor_pass"(rx623_pos, "term:sym<package_declarator>")
    if_null rx623_debug, debug_808
    rx623_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx623_pos)
  debug_808:
    .return (rx623_cur)
  rx623_restart:
.annotate 'line', 10
    if_null rx623_debug, debug_809
    rx623_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_809:
  rx623_fail:
    (rx623_rep, rx623_pos, $I10, $P10) = rx623_cur."!mark_fail"(0)
    lt rx623_pos, -1, rx623_done
    eq rx623_pos, -1, rx623_fail
    jump $I10
  rx623_done:
    rx623_cur."!cursor_fail"()
    if_null rx623_debug, debug_810
    rx623_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_810:
    .return (rx623_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1303748459.273") :method
.annotate 'line', 10
    $P625 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P626, "ResizablePMCArray"
    push $P626, $P625
    .return ($P626)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx629_tgt
    .local int rx629_pos
    .local int rx629_off
    .local int rx629_eos
    .local int rx629_rep
    .local pmc rx629_cur
    .local pmc rx629_debug
    (rx629_cur, rx629_pos, rx629_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx629_cur
    .local pmc match
    .lex "$/", match
    length rx629_eos, rx629_tgt
    gt rx629_pos, rx629_eos, rx629_done
    set rx629_off, 0
    lt rx629_pos, 2, rx629_start
    sub rx629_off, rx629_pos, 1
    substr rx629_tgt, rx629_tgt, rx629_off
  rx629_start:
    eq $I10, 1, rx629_restart
    if_null rx629_debug, debug_811
    rx629_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_811:
    $I10 = self.'from'()
    ne $I10, -1, rxscan633_done
    goto rxscan633_scan
  rxscan633_loop:
    (rx629_pos) = rx629_cur."from"()
    inc rx629_pos
    rx629_cur."!cursor_from"(rx629_pos)
    ge rx629_pos, rx629_eos, rxscan633_done
  rxscan633_scan:
    set_addr $I10, rxscan633_loop
    rx629_cur."!mark_push"(0, rx629_pos, $I10)
  rxscan633_done:
.annotate 'line', 274
  # rx subrule "scope_declarator" subtype=capture negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."scope_declarator"()
    unless $P10, rx629_fail
    rx629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx629_pos = $P10."pos"()
  # rx pass
    rx629_cur."!cursor_pass"(rx629_pos, "term:sym<scope_declarator>")
    if_null rx629_debug, debug_812
    rx629_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx629_pos)
  debug_812:
    .return (rx629_cur)
  rx629_restart:
.annotate 'line', 10
    if_null rx629_debug, debug_813
    rx629_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_813:
  rx629_fail:
    (rx629_rep, rx629_pos, $I10, $P10) = rx629_cur."!mark_fail"(0)
    lt rx629_pos, -1, rx629_done
    eq rx629_pos, -1, rx629_fail
    jump $I10
  rx629_done:
    rx629_cur."!cursor_fail"()
    if_null rx629_debug, debug_814
    rx629_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_814:
    .return (rx629_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1303748459.273") :method
.annotate 'line', 10
    $P631 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P632, "ResizablePMCArray"
    push $P632, $P631
    .return ($P632)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx635_tgt
    .local int rx635_pos
    .local int rx635_off
    .local int rx635_eos
    .local int rx635_rep
    .local pmc rx635_cur
    .local pmc rx635_debug
    (rx635_cur, rx635_pos, rx635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx635_cur
    .local pmc match
    .lex "$/", match
    length rx635_eos, rx635_tgt
    gt rx635_pos, rx635_eos, rx635_done
    set rx635_off, 0
    lt rx635_pos, 2, rx635_start
    sub rx635_off, rx635_pos, 1
    substr rx635_tgt, rx635_tgt, rx635_off
  rx635_start:
    eq $I10, 1, rx635_restart
    if_null rx635_debug, debug_815
    rx635_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_815:
    $I10 = self.'from'()
    ne $I10, -1, rxscan639_done
    goto rxscan639_scan
  rxscan639_loop:
    (rx635_pos) = rx635_cur."from"()
    inc rx635_pos
    rx635_cur."!cursor_from"(rx635_pos)
    ge rx635_pos, rx635_eos, rxscan639_done
  rxscan639_scan:
    set_addr $I10, rxscan639_loop
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  rxscan639_done:
.annotate 'line', 275
  # rx subrule "routine_declarator" subtype=capture negate=
    rx635_cur."!cursor_pos"(rx635_pos)
    $P10 = rx635_cur."routine_declarator"()
    unless $P10, rx635_fail
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx635_pos = $P10."pos"()
  # rx pass
    rx635_cur."!cursor_pass"(rx635_pos, "term:sym<routine_declarator>")
    if_null rx635_debug, debug_816
    rx635_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx635_pos)
  debug_816:
    .return (rx635_cur)
  rx635_restart:
.annotate 'line', 10
    if_null rx635_debug, debug_817
    rx635_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_817:
  rx635_fail:
    (rx635_rep, rx635_pos, $I10, $P10) = rx635_cur."!mark_fail"(0)
    lt rx635_pos, -1, rx635_done
    eq rx635_pos, -1, rx635_fail
    jump $I10
  rx635_done:
    rx635_cur."!cursor_fail"()
    if_null rx635_debug, debug_818
    rx635_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_818:
    .return (rx635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1303748459.273") :method
.annotate 'line', 10
    $P637 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P638, "ResizablePMCArray"
    push $P638, $P637
    .return ($P638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P651 = "121_1303748459.273" 
    capture_lex $P651
    .const 'Sub' $P646 = "120_1303748459.273" 
    capture_lex $P646
    .local string rx641_tgt
    .local int rx641_pos
    .local int rx641_off
    .local int rx641_eos
    .local int rx641_rep
    .local pmc rx641_cur
    .local pmc rx641_debug
    (rx641_cur, rx641_pos, rx641_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx641_cur
    .local pmc match
    .lex "$/", match
    length rx641_eos, rx641_tgt
    gt rx641_pos, rx641_eos, rx641_done
    set rx641_off, 0
    lt rx641_pos, 2, rx641_start
    sub rx641_off, rx641_pos, 1
    substr rx641_tgt, rx641_tgt, rx641_off
  rx641_start:
    eq $I10, 1, rx641_restart
    if_null rx641_debug, debug_819
    rx641_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_819:
    $I10 = self.'from'()
    ne $I10, -1, rxscan644_done
    goto rxscan644_scan
  rxscan644_loop:
    (rx641_pos) = rx641_cur."from"()
    inc rx641_pos
    rx641_cur."!cursor_from"(rx641_pos)
    ge rx641_pos, rx641_eos, rxscan644_done
  rxscan644_scan:
    set_addr $I10, rxscan644_loop
    rx641_cur."!mark_push"(0, rx641_pos, $I10)
  rxscan644_done:
.annotate 'line', 277
  # rx subrule "before" subtype=zerowidth negate=
    rx641_cur."!cursor_pos"(rx641_pos)
    .const 'Sub' $P646 = "120_1303748459.273" 
    capture_lex $P646
    $P10 = rx641_cur."before"($P646)
    unless $P10, rx641_fail
.annotate 'line', 278
  # rx subrule "before" subtype=zerowidth negate=1
    rx641_cur."!cursor_pos"(rx641_pos)
    .const 'Sub' $P651 = "121_1303748459.273" 
    capture_lex $P651
    $P10 = rx641_cur."before"($P651)
    if $P10, rx641_fail
.annotate 'line', 279
  # rx subrule "multi_declarator" subtype=capture negate=
    rx641_cur."!cursor_pos"(rx641_pos)
    $P10 = rx641_cur."multi_declarator"()
    unless $P10, rx641_fail
    rx641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx641_pos = $P10."pos"()
.annotate 'line', 276
  # rx pass
    rx641_cur."!cursor_pass"(rx641_pos, "term:sym<multi_declarator>")
    if_null rx641_debug, debug_828
    rx641_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx641_pos)
  debug_828:
    .return (rx641_cur)
  rx641_restart:
.annotate 'line', 10
    if_null rx641_debug, debug_829
    rx641_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_829:
  rx641_fail:
    (rx641_rep, rx641_pos, $I10, $P10) = rx641_cur."!mark_fail"(0)
    lt rx641_pos, -1, rx641_done
    eq rx641_pos, -1, rx641_fail
    jump $I10
  rx641_done:
    rx641_cur."!cursor_fail"()
    if_null rx641_debug, debug_830
    rx641_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_830:
    .return (rx641_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1303748459.273") :method
.annotate 'line', 10
    new $P643, "ResizablePMCArray"
    push $P643, ""
    .return ($P643)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block645"  :anon :subid("120_1303748459.273") :method :outer("118_1303748459.273")
.annotate 'line', 277
    .local string rx647_tgt
    .local int rx647_pos
    .local int rx647_off
    .local int rx647_eos
    .local int rx647_rep
    .local pmc rx647_cur
    .local pmc rx647_debug
    (rx647_cur, rx647_pos, rx647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx647_cur
    .local pmc match
    .lex "$/", match
    length rx647_eos, rx647_tgt
    gt rx647_pos, rx647_eos, rx647_done
    set rx647_off, 0
    lt rx647_pos, 2, rx647_start
    sub rx647_off, rx647_pos, 1
    substr rx647_tgt, rx647_tgt, rx647_off
  rx647_start:
    eq $I10, 1, rx647_restart
    if_null rx647_debug, debug_820
    rx647_cur."!cursor_debug"("START", "")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan648_done
    goto rxscan648_scan
  rxscan648_loop:
    (rx647_pos) = rx647_cur."from"()
    inc rx647_pos
    rx647_cur."!cursor_from"(rx647_pos)
    ge rx647_pos, rx647_eos, rxscan648_done
  rxscan648_scan:
    set_addr $I10, rxscan648_loop
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  rxscan648_done:
  alt649_0:
    set_addr $I10, alt649_1
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  # rx literal  "multi"
    add $I11, rx647_pos, 5
    gt $I11, rx647_eos, rx647_fail
    sub $I11, rx647_pos, rx647_off
    substr $S10, rx647_tgt, $I11, 5
    ne $S10, "multi", rx647_fail
    add rx647_pos, 5
    goto alt649_end
  alt649_1:
    set_addr $I10, alt649_2
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  # rx literal  "proto"
    add $I11, rx647_pos, 5
    gt $I11, rx647_eos, rx647_fail
    sub $I11, rx647_pos, rx647_off
    substr $S10, rx647_tgt, $I11, 5
    ne $S10, "proto", rx647_fail
    add rx647_pos, 5
    goto alt649_end
  alt649_2:
  # rx literal  "only"
    add $I11, rx647_pos, 4
    gt $I11, rx647_eos, rx647_fail
    sub $I11, rx647_pos, rx647_off
    substr $S10, rx647_tgt, $I11, 4
    ne $S10, "only", rx647_fail
    add rx647_pos, 4
  alt649_end:
  # rx pass
    rx647_cur."!cursor_pass"(rx647_pos, "")
    if_null rx647_debug, debug_821
    rx647_cur."!cursor_debug"("PASS", "", " at pos=", rx647_pos)
  debug_821:
    .return (rx647_cur)
  rx647_restart:
    if_null rx647_debug, debug_822
    rx647_cur."!cursor_debug"("NEXT", "")
  debug_822:
  rx647_fail:
    (rx647_rep, rx647_pos, $I10, $P10) = rx647_cur."!mark_fail"(0)
    lt rx647_pos, -1, rx647_done
    eq rx647_pos, -1, rx647_fail
    jump $I10
  rx647_done:
    rx647_cur."!cursor_fail"()
    if_null rx647_debug, debug_823
    rx647_cur."!cursor_debug"("FAIL", "")
  debug_823:
    .return (rx647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block650"  :anon :subid("121_1303748459.273") :method :outer("118_1303748459.273")
.annotate 'line', 278
    .local string rx652_tgt
    .local int rx652_pos
    .local int rx652_off
    .local int rx652_eos
    .local int rx652_rep
    .local pmc rx652_cur
    .local pmc rx652_debug
    (rx652_cur, rx652_pos, rx652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx652_cur
    .local pmc match
    .lex "$/", match
    length rx652_eos, rx652_tgt
    gt rx652_pos, rx652_eos, rx652_done
    set rx652_off, 0
    lt rx652_pos, 2, rx652_start
    sub rx652_off, rx652_pos, 1
    substr rx652_tgt, rx652_tgt, rx652_off
  rx652_start:
    eq $I10, 1, rx652_restart
    if_null rx652_debug, debug_824
    rx652_cur."!cursor_debug"("START", "")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan653_done
    goto rxscan653_scan
  rxscan653_loop:
    (rx652_pos) = rx652_cur."from"()
    inc rx652_pos
    rx652_cur."!cursor_from"(rx652_pos)
    ge rx652_pos, rx652_eos, rxscan653_done
  rxscan653_scan:
    set_addr $I10, rxscan653_loop
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  rxscan653_done:
  # rx literal  "proto"
    add $I11, rx652_pos, 5
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 5
    ne $S10, "proto", rx652_fail
    add rx652_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx652_cur."!cursor_pos"(rx652_pos)
    $P10 = rx652_cur."ws"()
    unless $P10, rx652_fail
    rx652_pos = $P10."pos"()
  alt654_0:
    set_addr $I10, alt654_1
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  # rx literal  "regex"
    add $I11, rx652_pos, 5
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 5
    ne $S10, "regex", rx652_fail
    add rx652_pos, 5
    goto alt654_end
  alt654_1:
    set_addr $I10, alt654_2
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  # rx literal  "token"
    add $I11, rx652_pos, 5
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 5
    ne $S10, "token", rx652_fail
    add rx652_pos, 5
    goto alt654_end
  alt654_2:
  # rx literal  "rule"
    add $I11, rx652_pos, 4
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 4
    ne $S10, "rule", rx652_fail
    add rx652_pos, 4
  alt654_end:
  # rx pass
    rx652_cur."!cursor_pass"(rx652_pos, "")
    if_null rx652_debug, debug_825
    rx652_cur."!cursor_debug"("PASS", "", " at pos=", rx652_pos)
  debug_825:
    .return (rx652_cur)
  rx652_restart:
    if_null rx652_debug, debug_826
    rx652_cur."!cursor_debug"("NEXT", "")
  debug_826:
  rx652_fail:
    (rx652_rep, rx652_pos, $I10, $P10) = rx652_cur."!mark_fail"(0)
    lt rx652_pos, -1, rx652_done
    eq rx652_pos, -1, rx652_fail
    jump $I10
  rx652_done:
    rx652_cur."!cursor_fail"()
    if_null rx652_debug, debug_827
    rx652_cur."!cursor_debug"("FAIL", "")
  debug_827:
    .return (rx652_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx656_tgt
    .local int rx656_pos
    .local int rx656_off
    .local int rx656_eos
    .local int rx656_rep
    .local pmc rx656_cur
    .local pmc rx656_debug
    (rx656_cur, rx656_pos, rx656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx656_cur
    .local pmc match
    .lex "$/", match
    length rx656_eos, rx656_tgt
    gt rx656_pos, rx656_eos, rx656_done
    set rx656_off, 0
    lt rx656_pos, 2, rx656_start
    sub rx656_off, rx656_pos, 1
    substr rx656_tgt, rx656_tgt, rx656_off
  rx656_start:
    eq $I10, 1, rx656_restart
    if_null rx656_debug, debug_831
    rx656_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_831:
    $I10 = self.'from'()
    ne $I10, -1, rxscan660_done
    goto rxscan660_scan
  rxscan660_loop:
    (rx656_pos) = rx656_cur."from"()
    inc rx656_pos
    rx656_cur."!cursor_from"(rx656_pos)
    ge rx656_pos, rx656_eos, rxscan660_done
  rxscan660_scan:
    set_addr $I10, rxscan660_loop
    rx656_cur."!mark_push"(0, rx656_pos, $I10)
  rxscan660_done:
.annotate 'line', 281
  # rx subrule "regex_declarator" subtype=capture negate=
    rx656_cur."!cursor_pos"(rx656_pos)
    $P10 = rx656_cur."regex_declarator"()
    unless $P10, rx656_fail
    rx656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx656_pos = $P10."pos"()
  # rx pass
    rx656_cur."!cursor_pass"(rx656_pos, "term:sym<regex_declarator>")
    if_null rx656_debug, debug_832
    rx656_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx656_pos)
  debug_832:
    .return (rx656_cur)
  rx656_restart:
.annotate 'line', 10
    if_null rx656_debug, debug_833
    rx656_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_833:
  rx656_fail:
    (rx656_rep, rx656_pos, $I10, $P10) = rx656_cur."!mark_fail"(0)
    lt rx656_pos, -1, rx656_done
    eq rx656_pos, -1, rx656_fail
    jump $I10
  rx656_done:
    rx656_cur."!cursor_fail"()
    if_null rx656_debug, debug_834
    rx656_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_834:
    .return (rx656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1303748459.273") :method
.annotate 'line', 10
    $P658 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P659, "ResizablePMCArray"
    push $P659, $P658
    .return ($P659)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx662_tgt
    .local int rx662_pos
    .local int rx662_off
    .local int rx662_eos
    .local int rx662_rep
    .local pmc rx662_cur
    .local pmc rx662_debug
    (rx662_cur, rx662_pos, rx662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx662_cur
    .local pmc match
    .lex "$/", match
    length rx662_eos, rx662_tgt
    gt rx662_pos, rx662_eos, rx662_done
    set rx662_off, 0
    lt rx662_pos, 2, rx662_start
    sub rx662_off, rx662_pos, 1
    substr rx662_tgt, rx662_tgt, rx662_off
  rx662_start:
    eq $I10, 1, rx662_restart
    if_null rx662_debug, debug_835
    rx662_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_835:
    $I10 = self.'from'()
    ne $I10, -1, rxscan666_done
    goto rxscan666_scan
  rxscan666_loop:
    (rx662_pos) = rx662_cur."from"()
    inc rx662_pos
    rx662_cur."!cursor_from"(rx662_pos)
    ge rx662_pos, rx662_eos, rxscan666_done
  rxscan666_scan:
    set_addr $I10, rxscan666_loop
    rx662_cur."!mark_push"(0, rx662_pos, $I10)
  rxscan666_done:
.annotate 'line', 282
  # rx subrule "statement_prefix" subtype=capture negate=
    rx662_cur."!cursor_pos"(rx662_pos)
    $P10 = rx662_cur."statement_prefix"()
    unless $P10, rx662_fail
    rx662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx662_pos = $P10."pos"()
  # rx pass
    rx662_cur."!cursor_pass"(rx662_pos, "term:sym<statement_prefix>")
    if_null rx662_debug, debug_836
    rx662_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx662_pos)
  debug_836:
    .return (rx662_cur)
  rx662_restart:
.annotate 'line', 10
    if_null rx662_debug, debug_837
    rx662_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_837:
  rx662_fail:
    (rx662_rep, rx662_pos, $I10, $P10) = rx662_cur."!mark_fail"(0)
    lt rx662_pos, -1, rx662_done
    eq rx662_pos, -1, rx662_fail
    jump $I10
  rx662_done:
    rx662_cur."!cursor_fail"()
    if_null rx662_debug, debug_838
    rx662_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_838:
    .return (rx662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1303748459.273") :method
.annotate 'line', 10
    $P664 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P665, "ResizablePMCArray"
    push $P665, $P664
    .return ($P665)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx668_tgt
    .local int rx668_pos
    .local int rx668_off
    .local int rx668_eos
    .local int rx668_rep
    .local pmc rx668_cur
    .local pmc rx668_debug
    (rx668_cur, rx668_pos, rx668_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx668_cur
    .local pmc match
    .lex "$/", match
    length rx668_eos, rx668_tgt
    gt rx668_pos, rx668_eos, rx668_done
    set rx668_off, 0
    lt rx668_pos, 2, rx668_start
    sub rx668_off, rx668_pos, 1
    substr rx668_tgt, rx668_tgt, rx668_off
  rx668_start:
    eq $I10, 1, rx668_restart
    if_null rx668_debug, debug_839
    rx668_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_839:
    $I10 = self.'from'()
    ne $I10, -1, rxscan671_done
    goto rxscan671_scan
  rxscan671_loop:
    (rx668_pos) = rx668_cur."from"()
    inc rx668_pos
    rx668_cur."!cursor_from"(rx668_pos)
    ge rx668_pos, rx668_eos, rxscan671_done
  rxscan671_scan:
    set_addr $I10, rxscan671_loop
    rx668_cur."!mark_push"(0, rx668_pos, $I10)
  rxscan671_done:
.annotate 'line', 283
  # rx subrule "lambda" subtype=zerowidth negate=
    rx668_cur."!cursor_pos"(rx668_pos)
    $P10 = rx668_cur."lambda"()
    unless $P10, rx668_fail
  # rx subrule "pblock" subtype=capture negate=
    rx668_cur."!cursor_pos"(rx668_pos)
    $P10 = rx668_cur."pblock"()
    unless $P10, rx668_fail
    rx668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx668_pos = $P10."pos"()
  # rx pass
    rx668_cur."!cursor_pass"(rx668_pos, "term:sym<lambda>")
    if_null rx668_debug, debug_840
    rx668_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx668_pos)
  debug_840:
    .return (rx668_cur)
  rx668_restart:
.annotate 'line', 10
    if_null rx668_debug, debug_841
    rx668_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_841:
  rx668_fail:
    (rx668_rep, rx668_pos, $I10, $P10) = rx668_cur."!mark_fail"(0)
    lt rx668_pos, -1, rx668_done
    eq rx668_pos, -1, rx668_fail
    jump $I10
  rx668_done:
    rx668_cur."!cursor_fail"()
    if_null rx668_debug, debug_842
    rx668_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_842:
    .return (rx668_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1303748459.273") :method
.annotate 'line', 10
    new $P670, "ResizablePMCArray"
    push $P670, ""
    .return ($P670)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx673_tgt
    .local int rx673_pos
    .local int rx673_off
    .local int rx673_eos
    .local int rx673_rep
    .local pmc rx673_cur
    .local pmc rx673_debug
    (rx673_cur, rx673_pos, rx673_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx673_cur
    .local pmc match
    .lex "$/", match
    length rx673_eos, rx673_tgt
    gt rx673_pos, rx673_eos, rx673_done
    set rx673_off, 0
    lt rx673_pos, 2, rx673_start
    sub rx673_off, rx673_pos, 1
    substr rx673_tgt, rx673_tgt, rx673_off
  rx673_start:
    eq $I10, 1, rx673_restart
    if_null rx673_debug, debug_843
    rx673_cur."!cursor_debug"("START", "fatarrow")
  debug_843:
    $I10 = self.'from'()
    ne $I10, -1, rxscan677_done
    goto rxscan677_scan
  rxscan677_loop:
    (rx673_pos) = rx673_cur."from"()
    inc rx673_pos
    rx673_cur."!cursor_from"(rx673_pos)
    ge rx673_pos, rx673_eos, rxscan677_done
  rxscan677_scan:
    set_addr $I10, rxscan677_loop
    rx673_cur."!mark_push"(0, rx673_pos, $I10)
  rxscan677_done:
.annotate 'line', 286
  # rx subrule "identifier" subtype=capture negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."identifier"()
    unless $P10, rx673_fail
    rx673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx673_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx673_pos, rx673_off
    set rx673_rep, 0
    sub $I12, rx673_eos, rx673_pos
  rxenumcharlistq678_loop:
    le $I12, 0, rxenumcharlistq678_done
    substr $S10, rx673_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq678_done
    inc rx673_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq678_loop
  rxenumcharlistq678_done:
    add rx673_pos, rx673_pos, rx673_rep
  # rx literal  "=>"
    add $I11, rx673_pos, 2
    gt $I11, rx673_eos, rx673_fail
    sub $I11, rx673_pos, rx673_off
    substr $S10, rx673_tgt, $I11, 2
    ne $S10, "=>", rx673_fail
    add rx673_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."ws"()
    unless $P10, rx673_fail
    rx673_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."EXPR"("i=")
    unless $P10, rx673_fail
    rx673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx673_pos = $P10."pos"()
.annotate 'line', 285
  # rx pass
    rx673_cur."!cursor_pass"(rx673_pos, "fatarrow")
    if_null rx673_debug, debug_844
    rx673_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx673_pos)
  debug_844:
    .return (rx673_cur)
  rx673_restart:
.annotate 'line', 10
    if_null rx673_debug, debug_845
    rx673_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_845:
  rx673_fail:
    (rx673_rep, rx673_pos, $I10, $P10) = rx673_cur."!mark_fail"(0)
    lt rx673_pos, -1, rx673_done
    eq rx673_pos, -1, rx673_fail
    jump $I10
  rx673_done:
    rx673_cur."!cursor_fail"()
    if_null rx673_debug, debug_846
    rx673_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_846:
    .return (rx673_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1303748459.273") :method
.annotate 'line', 10
    $P675 = self."!PREFIX__!subrule"("identifier", "")
    new $P676, "ResizablePMCArray"
    push $P676, $P675
    .return ($P676)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx680_tgt
    .local int rx680_pos
    .local int rx680_off
    .local int rx680_eos
    .local int rx680_rep
    .local pmc rx680_cur
    .local pmc rx680_debug
    (rx680_cur, rx680_pos, rx680_tgt, $I10) = self."!cursor_start"()
    rx680_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx680_cur
    .local pmc match
    .lex "$/", match
    length rx680_eos, rx680_tgt
    gt rx680_pos, rx680_eos, rx680_done
    set rx680_off, 0
    lt rx680_pos, 2, rx680_start
    sub rx680_off, rx680_pos, 1
    substr rx680_tgt, rx680_tgt, rx680_off
  rx680_start:
    eq $I10, 1, rx680_restart
    if_null rx680_debug, debug_847
    rx680_cur."!cursor_debug"("START", "colonpair")
  debug_847:
    $I10 = self.'from'()
    ne $I10, -1, rxscan686_done
    goto rxscan686_scan
  rxscan686_loop:
    (rx680_pos) = rx680_cur."from"()
    inc rx680_pos
    rx680_cur."!cursor_from"(rx680_pos)
    ge rx680_pos, rx680_eos, rxscan686_done
  rxscan686_scan:
    set_addr $I10, rxscan686_loop
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
  rxscan686_done:
.annotate 'line', 290
  # rx literal  ":"
    add $I11, rx680_pos, 1
    gt $I11, rx680_eos, rx680_fail
    sub $I11, rx680_pos, rx680_off
    ord $I11, rx680_tgt, $I11
    ne $I11, 58, rx680_fail
    add rx680_pos, 1
  alt687_0:
.annotate 'line', 291
    set_addr $I10, alt687_1
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
.annotate 'line', 292
  # rx subcapture "not"
    set_addr $I10, rxcap_688_fail
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
  # rx literal  "!"
    add $I11, rx680_pos, 1
    gt $I11, rx680_eos, rx680_fail
    sub $I11, rx680_pos, rx680_off
    ord $I11, rx680_tgt, $I11
    ne $I11, 33, rx680_fail
    add rx680_pos, 1
    set_addr $I10, rxcap_688_fail
    ($I12, $I11) = rx680_cur."!mark_peek"($I10)
    rx680_cur."!cursor_pos"($I11)
    ($P10) = rx680_cur."!cursor_start"()
    $P10."!cursor_pass"(rx680_pos, "")
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_688_done
  rxcap_688_fail:
    goto rx680_fail
  rxcap_688_done:
  # rx subrule "identifier" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."identifier"()
    unless $P10, rx680_fail
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx680_pos = $P10."pos"()
    goto alt687_end
  alt687_1:
    set_addr $I10, alt687_2
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
.annotate 'line', 293
  # rx subrule "identifier" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."identifier"()
    unless $P10, rx680_fail
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx680_pos = $P10."pos"()
  # rx rxquantr689 ** 0..1
    set_addr $I10, rxquantr689_done
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
  rxquantr689_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."circumfix"()
    unless $P10, rx680_fail
    goto rxsubrule690_pass
  rxsubrule690_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx680_fail
  rxsubrule690_pass:
    set_addr $I10, rxsubrule690_back
    rx680_cur."!mark_push"(0, rx680_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx680_pos = $P10."pos"()
    set_addr $I10, rxquantr689_done
    (rx680_rep) = rx680_cur."!mark_commit"($I10)
  rxquantr689_done:
    goto alt687_end
  alt687_2:
.annotate 'line', 294
  # rx subrule "circumfix" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."circumfix"()
    unless $P10, rx680_fail
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx680_pos = $P10."pos"()
  alt687_end:
.annotate 'line', 289
  # rx pass
    rx680_cur."!cursor_pass"(rx680_pos, "colonpair")
    if_null rx680_debug, debug_848
    rx680_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx680_pos)
  debug_848:
    .return (rx680_cur)
  rx680_restart:
.annotate 'line', 10
    if_null rx680_debug, debug_849
    rx680_cur."!cursor_debug"("NEXT", "colonpair")
  debug_849:
  rx680_fail:
    (rx680_rep, rx680_pos, $I10, $P10) = rx680_cur."!mark_fail"(0)
    lt rx680_pos, -1, rx680_done
    eq rx680_pos, -1, rx680_fail
    jump $I10
  rx680_done:
    rx680_cur."!cursor_fail"()
    if_null rx680_debug, debug_850
    rx680_cur."!cursor_debug"("FAIL", "colonpair")
  debug_850:
    .return (rx680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1303748459.273") :method
.annotate 'line', 10
    $P682 = self."!PREFIX__!subrule"("circumfix", ":")
    $P683 = self."!PREFIX__!subrule"("identifier", ":")
    $P684 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P685, "ResizablePMCArray"
    push $P685, $P682
    push $P685, $P683
    push $P685, $P684
    .return ($P685)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx692_tgt
    .local int rx692_pos
    .local int rx692_off
    .local int rx692_eos
    .local int rx692_rep
    .local pmc rx692_cur
    .local pmc rx692_debug
    (rx692_cur, rx692_pos, rx692_tgt, $I10) = self."!cursor_start"()
    rx692_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx692_cur
    .local pmc match
    .lex "$/", match
    length rx692_eos, rx692_tgt
    gt rx692_pos, rx692_eos, rx692_done
    set rx692_off, 0
    lt rx692_pos, 2, rx692_start
    sub rx692_off, rx692_pos, 1
    substr rx692_tgt, rx692_tgt, rx692_off
  rx692_start:
    eq $I10, 1, rx692_restart
    if_null rx692_debug, debug_851
    rx692_cur."!cursor_debug"("START", "variable")
  debug_851:
    $I10 = self.'from'()
    ne $I10, -1, rxscan697_done
    goto rxscan697_scan
  rxscan697_loop:
    (rx692_pos) = rx692_cur."from"()
    inc rx692_pos
    rx692_cur."!cursor_from"(rx692_pos)
    ge rx692_pos, rx692_eos, rxscan697_done
  rxscan697_scan:
    set_addr $I10, rxscan697_loop
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  rxscan697_done:
  alt698_0:
.annotate 'line', 298
    set_addr $I10, alt698_1
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
.annotate 'line', 299
  # rx subrule "sigil" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."sigil"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx692_pos = $P10."pos"()
  # rx rxquantr699 ** 0..1
    set_addr $I10, rxquantr699_done
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  rxquantr699_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."twigil"()
    unless $P10, rx692_fail
    goto rxsubrule700_pass
  rxsubrule700_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx692_fail
  rxsubrule700_pass:
    set_addr $I10, rxsubrule700_back
    rx692_cur."!mark_push"(0, rx692_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx692_pos = $P10."pos"()
    set_addr $I10, rxquantr699_done
    (rx692_rep) = rx692_cur."!mark_commit"($I10)
  rxquantr699_done:
  # rx subrule "name" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."name"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx692_pos = $P10."pos"()
    goto alt698_end
  alt698_1:
    set_addr $I10, alt698_2
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
.annotate 'line', 300
  # rx subrule "sigil" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."sigil"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx692_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx692_pos, rx692_off
    substr $S10, rx692_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx692_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."postcircumfix"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx692_pos = $P10."pos"()
    goto alt698_end
  alt698_2:
.annotate 'line', 301
  # rx subcapture "sigil"
    set_addr $I10, rxcap_701_fail
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  # rx literal  "$"
    add $I11, rx692_pos, 1
    gt $I11, rx692_eos, rx692_fail
    sub $I11, rx692_pos, rx692_off
    ord $I11, rx692_tgt, $I11
    ne $I11, 36, rx692_fail
    add rx692_pos, 1
    set_addr $I10, rxcap_701_fail
    ($I12, $I11) = rx692_cur."!mark_peek"($I10)
    rx692_cur."!cursor_pos"($I11)
    ($P10) = rx692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx692_pos, "")
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_701_done
  rxcap_701_fail:
    goto rx692_fail
  rxcap_701_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_702_fail
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx692_pos, rx692_eos, rx692_fail
    sub $I10, rx692_pos, rx692_off
    substr $S10, rx692_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx692_fail
    inc rx692_pos
    set_addr $I10, rxcap_702_fail
    ($I12, $I11) = rx692_cur."!mark_peek"($I10)
    rx692_cur."!cursor_pos"($I11)
    ($P10) = rx692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx692_pos, "")
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_702_done
  rxcap_702_fail:
    goto rx692_fail
  rxcap_702_done:
  alt698_end:
.annotate 'line', 298
  # rx pass
    rx692_cur."!cursor_pass"(rx692_pos, "variable")
    if_null rx692_debug, debug_852
    rx692_cur."!cursor_debug"("PASS", "variable", " at pos=", rx692_pos)
  debug_852:
    .return (rx692_cur)
  rx692_restart:
.annotate 'line', 10
    if_null rx692_debug, debug_853
    rx692_cur."!cursor_debug"("NEXT", "variable")
  debug_853:
  rx692_fail:
    (rx692_rep, rx692_pos, $I10, $P10) = rx692_cur."!mark_fail"(0)
    lt rx692_pos, -1, rx692_done
    eq rx692_pos, -1, rx692_fail
    jump $I10
  rx692_done:
    rx692_cur."!cursor_fail"()
    if_null rx692_debug, debug_854
    rx692_cur."!cursor_debug"("FAIL", "variable")
  debug_854:
    .return (rx692_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1303748459.273") :method
.annotate 'line', 10
    $P694 = self."!PREFIX__!subrule"("sigil", "")
    $P695 = self."!PREFIX__!subrule"("sigil", "")
    new $P696, "ResizablePMCArray"
    push $P696, "$!"
    push $P696, "$_"
    push $P696, "$/"
    push $P696, $P694
    push $P696, $P695
    .return ($P696)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx704_tgt
    .local int rx704_pos
    .local int rx704_off
    .local int rx704_eos
    .local int rx704_rep
    .local pmc rx704_cur
    .local pmc rx704_debug
    (rx704_cur, rx704_pos, rx704_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx704_cur
    .local pmc match
    .lex "$/", match
    length rx704_eos, rx704_tgt
    gt rx704_pos, rx704_eos, rx704_done
    set rx704_off, 0
    lt rx704_pos, 2, rx704_start
    sub rx704_off, rx704_pos, 1
    substr rx704_tgt, rx704_tgt, rx704_off
  rx704_start:
    eq $I10, 1, rx704_restart
    if_null rx704_debug, debug_855
    rx704_cur."!cursor_debug"("START", "sigil")
  debug_855:
    $I10 = self.'from'()
    ne $I10, -1, rxscan707_done
    goto rxscan707_scan
  rxscan707_loop:
    (rx704_pos) = rx704_cur."from"()
    inc rx704_pos
    rx704_cur."!cursor_from"(rx704_pos)
    ge rx704_pos, rx704_eos, rxscan707_done
  rxscan707_scan:
    set_addr $I10, rxscan707_loop
    rx704_cur."!mark_push"(0, rx704_pos, $I10)
  rxscan707_done:
.annotate 'line', 304
  # rx enumcharlist negate=0 
    ge rx704_pos, rx704_eos, rx704_fail
    sub $I10, rx704_pos, rx704_off
    substr $S10, rx704_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx704_fail
    inc rx704_pos
  # rx pass
    rx704_cur."!cursor_pass"(rx704_pos, "sigil")
    if_null rx704_debug, debug_856
    rx704_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx704_pos)
  debug_856:
    .return (rx704_cur)
  rx704_restart:
.annotate 'line', 10
    if_null rx704_debug, debug_857
    rx704_cur."!cursor_debug"("NEXT", "sigil")
  debug_857:
  rx704_fail:
    (rx704_rep, rx704_pos, $I10, $P10) = rx704_cur."!mark_fail"(0)
    lt rx704_pos, -1, rx704_done
    eq rx704_pos, -1, rx704_fail
    jump $I10
  rx704_done:
    rx704_cur."!cursor_fail"()
    if_null rx704_debug, debug_858
    rx704_cur."!cursor_debug"("FAIL", "sigil")
  debug_858:
    .return (rx704_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1303748459.273") :method
.annotate 'line', 10
    new $P706, "ResizablePMCArray"
    push $P706, "&"
    push $P706, "%"
    push $P706, "@"
    push $P706, "$"
    .return ($P706)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx709_tgt
    .local int rx709_pos
    .local int rx709_off
    .local int rx709_eos
    .local int rx709_rep
    .local pmc rx709_cur
    .local pmc rx709_debug
    (rx709_cur, rx709_pos, rx709_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx709_cur
    .local pmc match
    .lex "$/", match
    length rx709_eos, rx709_tgt
    gt rx709_pos, rx709_eos, rx709_done
    set rx709_off, 0
    lt rx709_pos, 2, rx709_start
    sub rx709_off, rx709_pos, 1
    substr rx709_tgt, rx709_tgt, rx709_off
  rx709_start:
    eq $I10, 1, rx709_restart
    if_null rx709_debug, debug_859
    rx709_cur."!cursor_debug"("START", "twigil")
  debug_859:
    $I10 = self.'from'()
    ne $I10, -1, rxscan712_done
    goto rxscan712_scan
  rxscan712_loop:
    (rx709_pos) = rx709_cur."from"()
    inc rx709_pos
    rx709_cur."!cursor_from"(rx709_pos)
    ge rx709_pos, rx709_eos, rxscan712_done
  rxscan712_scan:
    set_addr $I10, rxscan712_loop
    rx709_cur."!mark_push"(0, rx709_pos, $I10)
  rxscan712_done:
.annotate 'line', 306
  # rx enumcharlist negate=0 
    ge rx709_pos, rx709_eos, rx709_fail
    sub $I10, rx709_pos, rx709_off
    substr $S10, rx709_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx709_fail
    inc rx709_pos
  # rx pass
    rx709_cur."!cursor_pass"(rx709_pos, "twigil")
    if_null rx709_debug, debug_860
    rx709_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx709_pos)
  debug_860:
    .return (rx709_cur)
  rx709_restart:
.annotate 'line', 10
    if_null rx709_debug, debug_861
    rx709_cur."!cursor_debug"("NEXT", "twigil")
  debug_861:
  rx709_fail:
    (rx709_rep, rx709_pos, $I10, $P10) = rx709_cur."!mark_fail"(0)
    lt rx709_pos, -1, rx709_done
    eq rx709_pos, -1, rx709_fail
    jump $I10
  rx709_done:
    rx709_cur."!cursor_fail"()
    if_null rx709_debug, debug_862
    rx709_cur."!cursor_debug"("FAIL", "twigil")
  debug_862:
    .return (rx709_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1303748459.273") :method
.annotate 'line', 10
    new $P711, "ResizablePMCArray"
    push $P711, "?"
    push $P711, "!"
    push $P711, "*"
    .return ($P711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1303748459.273")
    .param pmc param_714
.annotate 'line', 308
    .lex "self", param_714
    $P715 = param_714."!protoregex"("package_declarator")
    .return ($P715)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1303748459.273")
    .param pmc param_717
.annotate 'line', 308
    .lex "self", param_717
    $P718 = param_717."!PREFIX__!protoregex"("package_declarator")
    .return ($P718)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 310
    new $P720, "Undef"
    .lex "$*OUTERPACKAGE", $P720
.annotate 'line', 311
    new $P721, "Undef"
    .lex "$*PACKAGE-SETUP", $P721
.annotate 'line', 312
    new $P722, "Undef"
    .lex "$*PKGDECL", $P722
.annotate 'line', 10
    .local string rx723_tgt
    .local int rx723_pos
    .local int rx723_off
    .local int rx723_eos
    .local int rx723_rep
    .local pmc rx723_cur
    .local pmc rx723_debug
    (rx723_cur, rx723_pos, rx723_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx723_cur
    .local pmc match
    .lex "$/", match
    length rx723_eos, rx723_tgt
    gt rx723_pos, rx723_eos, rx723_done
    set rx723_off, 0
    lt rx723_pos, 2, rx723_start
    sub rx723_off, rx723_pos, 1
    substr rx723_tgt, rx723_tgt, rx723_off
  rx723_start:
    eq $I10, 1, rx723_restart
    if_null rx723_debug, debug_863
    rx723_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_863:
    $I10 = self.'from'()
    ne $I10, -1, rxscan727_done
    goto rxscan727_scan
  rxscan727_loop:
    (rx723_pos) = rx723_cur."from"()
    inc rx723_pos
    rx723_cur."!cursor_from"(rx723_pos)
    ge rx723_pos, rx723_eos, rxscan727_done
  rxscan727_scan:
    set_addr $I10, rxscan727_loop
    rx723_cur."!mark_push"(0, rx723_pos, $I10)
  rxscan727_done:
.annotate 'line', 310
    rx723_cur."!cursor_pos"(rx723_pos)
    find_dynamic_lex $P730, "$*PACKAGE"
    unless_null $P730, vivify_864
    get_hll_global $P728, "GLOBAL"
    get_who $P729, $P728
    set $P730, $P729["$PACKAGE"]
    unless_null $P730, vivify_865
    die "Contextual $*PACKAGE not found"
  vivify_865:
  vivify_864:
    store_lex "$*OUTERPACKAGE", $P730
.annotate 'line', 311
    rx723_cur."!cursor_pos"(rx723_pos)
    get_hll_global $P731, "GLOBAL"
    nqp_get_package_through_who $P732, $P731, "PAST"
    get_who $P733, $P732
    set $P734, $P733["Stmts"]
    $P735 = $P734."new"()
    store_lex "$*PACKAGE-SETUP", $P735
.annotate 'line', 312
    rx723_cur."!cursor_pos"(rx723_pos)
    new $P736, "String"
    assign $P736, "module"
    store_lex "$*PKGDECL", $P736
.annotate 'line', 313
  # rx subcapture "sym"
    set_addr $I10, rxcap_737_fail
    rx723_cur."!mark_push"(0, rx723_pos, $I10)
  # rx literal  "module"
    add $I11, rx723_pos, 6
    gt $I11, rx723_eos, rx723_fail
    sub $I11, rx723_pos, rx723_off
    substr $S10, rx723_tgt, $I11, 6
    ne $S10, "module", rx723_fail
    add rx723_pos, 6
    set_addr $I10, rxcap_737_fail
    ($I12, $I11) = rx723_cur."!mark_peek"($I10)
    rx723_cur."!cursor_pos"($I11)
    ($P10) = rx723_cur."!cursor_start"()
    $P10."!cursor_pass"(rx723_pos, "")
    rx723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_737_done
  rxcap_737_fail:
    goto rx723_fail
  rxcap_737_done:
  # rx subrule "package_def" subtype=capture negate=
    rx723_cur."!cursor_pos"(rx723_pos)
    $P10 = rx723_cur."package_def"()
    unless $P10, rx723_fail
    rx723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx723_pos = $P10."pos"()
.annotate 'line', 309
  # rx pass
    rx723_cur."!cursor_pass"(rx723_pos, "package_declarator:sym<module>")
    if_null rx723_debug, debug_866
    rx723_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx723_pos)
  debug_866:
    .return (rx723_cur)
  rx723_restart:
.annotate 'line', 10
    if_null rx723_debug, debug_867
    rx723_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_867:
  rx723_fail:
    (rx723_rep, rx723_pos, $I10, $P10) = rx723_cur."!mark_fail"(0)
    lt rx723_pos, -1, rx723_done
    eq rx723_pos, -1, rx723_fail
    jump $I10
  rx723_done:
    rx723_cur."!cursor_fail"()
    if_null rx723_debug, debug_868
    rx723_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_868:
    .return (rx723_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1303748459.273") :method
.annotate 'line', 10
    $P725 = self."!PREFIX__!subrule"("package_def", "module")
    new $P726, "ResizablePMCArray"
    push $P726, $P725
    .return ($P726)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 316
    new $P739, "Undef"
    .lex "$*OUTERPACKAGE", $P739
.annotate 'line', 317
    new $P740, "Undef"
    .lex "$*PACKAGE-SETUP", $P740
.annotate 'line', 318
    new $P741, "Undef"
    .lex "$*PKGDECL", $P741
.annotate 'line', 10
    .local string rx742_tgt
    .local int rx742_pos
    .local int rx742_off
    .local int rx742_eos
    .local int rx742_rep
    .local pmc rx742_cur
    .local pmc rx742_debug
    (rx742_cur, rx742_pos, rx742_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx742_cur
    .local pmc match
    .lex "$/", match
    length rx742_eos, rx742_tgt
    gt rx742_pos, rx742_eos, rx742_done
    set rx742_off, 0
    lt rx742_pos, 2, rx742_start
    sub rx742_off, rx742_pos, 1
    substr rx742_tgt, rx742_tgt, rx742_off
  rx742_start:
    eq $I10, 1, rx742_restart
    if_null rx742_debug, debug_869
    rx742_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_869:
    $I10 = self.'from'()
    ne $I10, -1, rxscan746_done
    goto rxscan746_scan
  rxscan746_loop:
    (rx742_pos) = rx742_cur."from"()
    inc rx742_pos
    rx742_cur."!cursor_from"(rx742_pos)
    ge rx742_pos, rx742_eos, rxscan746_done
  rxscan746_scan:
    set_addr $I10, rxscan746_loop
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  rxscan746_done:
.annotate 'line', 316
    rx742_cur."!cursor_pos"(rx742_pos)
    find_dynamic_lex $P749, "$*PACKAGE"
    unless_null $P749, vivify_870
    get_hll_global $P747, "GLOBAL"
    get_who $P748, $P747
    set $P749, $P748["$PACKAGE"]
    unless_null $P749, vivify_871
    die "Contextual $*PACKAGE not found"
  vivify_871:
  vivify_870:
    store_lex "$*OUTERPACKAGE", $P749
.annotate 'line', 317
    rx742_cur."!cursor_pos"(rx742_pos)
    get_hll_global $P750, "GLOBAL"
    nqp_get_package_through_who $P751, $P750, "PAST"
    get_who $P752, $P751
    set $P753, $P752["Stmts"]
    $P754 = $P753."new"()
    store_lex "$*PACKAGE-SETUP", $P754
.annotate 'line', 318
    rx742_cur."!cursor_pos"(rx742_pos)
    new $P755, "String"
    assign $P755, "knowhow"
    store_lex "$*PKGDECL", $P755
.annotate 'line', 319
  # rx subcapture "sym"
    set_addr $I10, rxcap_756_fail
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx742_pos, 7
    gt $I11, rx742_eos, rx742_fail
    sub $I11, rx742_pos, rx742_off
    substr $S10, rx742_tgt, $I11, 7
    ne $S10, "knowhow", rx742_fail
    add rx742_pos, 7
    set_addr $I10, rxcap_756_fail
    ($I12, $I11) = rx742_cur."!mark_peek"($I10)
    rx742_cur."!cursor_pos"($I11)
    ($P10) = rx742_cur."!cursor_start"()
    $P10."!cursor_pass"(rx742_pos, "")
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_756_done
  rxcap_756_fail:
    goto rx742_fail
  rxcap_756_done:
  # rx subrule "package_def" subtype=capture negate=
    rx742_cur."!cursor_pos"(rx742_pos)
    $P10 = rx742_cur."package_def"()
    unless $P10, rx742_fail
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx742_pos = $P10."pos"()
.annotate 'line', 315
  # rx pass
    rx742_cur."!cursor_pass"(rx742_pos, "package_declarator:sym<knowhow>")
    if_null rx742_debug, debug_872
    rx742_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx742_pos)
  debug_872:
    .return (rx742_cur)
  rx742_restart:
.annotate 'line', 10
    if_null rx742_debug, debug_873
    rx742_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_873:
  rx742_fail:
    (rx742_rep, rx742_pos, $I10, $P10) = rx742_cur."!mark_fail"(0)
    lt rx742_pos, -1, rx742_done
    eq rx742_pos, -1, rx742_fail
    jump $I10
  rx742_done:
    rx742_cur."!cursor_fail"()
    if_null rx742_debug, debug_874
    rx742_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_874:
    .return (rx742_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1303748459.273") :method
.annotate 'line', 10
    $P744 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P745, "ResizablePMCArray"
    push $P745, $P744
    .return ($P745)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 322
    new $P758, "Undef"
    .lex "$*OUTERPACKAGE", $P758
.annotate 'line', 323
    new $P759, "Undef"
    .lex "$*PACKAGE-SETUP", $P759
.annotate 'line', 324
    new $P760, "Undef"
    .lex "$*PKGDECL", $P760
.annotate 'line', 10
    .local string rx761_tgt
    .local int rx761_pos
    .local int rx761_off
    .local int rx761_eos
    .local int rx761_rep
    .local pmc rx761_cur
    .local pmc rx761_debug
    (rx761_cur, rx761_pos, rx761_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx761_cur
    .local pmc match
    .lex "$/", match
    length rx761_eos, rx761_tgt
    gt rx761_pos, rx761_eos, rx761_done
    set rx761_off, 0
    lt rx761_pos, 2, rx761_start
    sub rx761_off, rx761_pos, 1
    substr rx761_tgt, rx761_tgt, rx761_off
  rx761_start:
    eq $I10, 1, rx761_restart
    if_null rx761_debug, debug_875
    rx761_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_875:
    $I10 = self.'from'()
    ne $I10, -1, rxscan765_done
    goto rxscan765_scan
  rxscan765_loop:
    (rx761_pos) = rx761_cur."from"()
    inc rx761_pos
    rx761_cur."!cursor_from"(rx761_pos)
    ge rx761_pos, rx761_eos, rxscan765_done
  rxscan765_scan:
    set_addr $I10, rxscan765_loop
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  rxscan765_done:
.annotate 'line', 322
    rx761_cur."!cursor_pos"(rx761_pos)
    find_dynamic_lex $P768, "$*PACKAGE"
    unless_null $P768, vivify_876
    get_hll_global $P766, "GLOBAL"
    get_who $P767, $P766
    set $P768, $P767["$PACKAGE"]
    unless_null $P768, vivify_877
    die "Contextual $*PACKAGE not found"
  vivify_877:
  vivify_876:
    store_lex "$*OUTERPACKAGE", $P768
.annotate 'line', 323
    rx761_cur."!cursor_pos"(rx761_pos)
    get_hll_global $P769, "GLOBAL"
    nqp_get_package_through_who $P770, $P769, "PAST"
    get_who $P771, $P770
    set $P772, $P771["Stmts"]
    $P773 = $P772."new"()
    store_lex "$*PACKAGE-SETUP", $P773
.annotate 'line', 324
    rx761_cur."!cursor_pos"(rx761_pos)
    new $P774, "String"
    assign $P774, "class"
    store_lex "$*PKGDECL", $P774
.annotate 'line', 325
  # rx subcapture "sym"
    set_addr $I10, rxcap_775_fail
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  # rx literal  "class"
    add $I11, rx761_pos, 5
    gt $I11, rx761_eos, rx761_fail
    sub $I11, rx761_pos, rx761_off
    substr $S10, rx761_tgt, $I11, 5
    ne $S10, "class", rx761_fail
    add rx761_pos, 5
    set_addr $I10, rxcap_775_fail
    ($I12, $I11) = rx761_cur."!mark_peek"($I10)
    rx761_cur."!cursor_pos"($I11)
    ($P10) = rx761_cur."!cursor_start"()
    $P10."!cursor_pass"(rx761_pos, "")
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_775_done
  rxcap_775_fail:
    goto rx761_fail
  rxcap_775_done:
  # rx subrule "package_def" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."package_def"()
    unless $P10, rx761_fail
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx761_pos = $P10."pos"()
.annotate 'line', 321
  # rx pass
    rx761_cur."!cursor_pass"(rx761_pos, "package_declarator:sym<class>")
    if_null rx761_debug, debug_878
    rx761_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx761_pos)
  debug_878:
    .return (rx761_cur)
  rx761_restart:
.annotate 'line', 10
    if_null rx761_debug, debug_879
    rx761_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_879:
  rx761_fail:
    (rx761_rep, rx761_pos, $I10, $P10) = rx761_cur."!mark_fail"(0)
    lt rx761_pos, -1, rx761_done
    eq rx761_pos, -1, rx761_fail
    jump $I10
  rx761_done:
    rx761_cur."!cursor_fail"()
    if_null rx761_debug, debug_880
    rx761_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_880:
    .return (rx761_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1303748459.273") :method
.annotate 'line', 10
    $P763 = self."!PREFIX__!subrule"("package_def", "class")
    new $P764, "ResizablePMCArray"
    push $P764, $P763
    .return ($P764)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 328
    new $P777, "Undef"
    .lex "$*OUTERPACKAGE", $P777
.annotate 'line', 329
    new $P778, "Undef"
    .lex "$*PACKAGE-SETUP", $P778
.annotate 'line', 330
    new $P779, "Undef"
    .lex "$*PKGDECL", $P779
.annotate 'line', 10
    .local string rx780_tgt
    .local int rx780_pos
    .local int rx780_off
    .local int rx780_eos
    .local int rx780_rep
    .local pmc rx780_cur
    .local pmc rx780_debug
    (rx780_cur, rx780_pos, rx780_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx780_cur
    .local pmc match
    .lex "$/", match
    length rx780_eos, rx780_tgt
    gt rx780_pos, rx780_eos, rx780_done
    set rx780_off, 0
    lt rx780_pos, 2, rx780_start
    sub rx780_off, rx780_pos, 1
    substr rx780_tgt, rx780_tgt, rx780_off
  rx780_start:
    eq $I10, 1, rx780_restart
    if_null rx780_debug, debug_881
    rx780_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_881:
    $I10 = self.'from'()
    ne $I10, -1, rxscan784_done
    goto rxscan784_scan
  rxscan784_loop:
    (rx780_pos) = rx780_cur."from"()
    inc rx780_pos
    rx780_cur."!cursor_from"(rx780_pos)
    ge rx780_pos, rx780_eos, rxscan784_done
  rxscan784_scan:
    set_addr $I10, rxscan784_loop
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  rxscan784_done:
.annotate 'line', 328
    rx780_cur."!cursor_pos"(rx780_pos)
    find_dynamic_lex $P787, "$*PACKAGE"
    unless_null $P787, vivify_882
    get_hll_global $P785, "GLOBAL"
    get_who $P786, $P785
    set $P787, $P786["$PACKAGE"]
    unless_null $P787, vivify_883
    die "Contextual $*PACKAGE not found"
  vivify_883:
  vivify_882:
    store_lex "$*OUTERPACKAGE", $P787
.annotate 'line', 329
    rx780_cur."!cursor_pos"(rx780_pos)
    get_hll_global $P788, "GLOBAL"
    nqp_get_package_through_who $P789, $P788, "PAST"
    get_who $P790, $P789
    set $P791, $P790["Stmts"]
    $P792 = $P791."new"()
    store_lex "$*PACKAGE-SETUP", $P792
.annotate 'line', 330
    rx780_cur."!cursor_pos"(rx780_pos)
    new $P793, "String"
    assign $P793, "grammar"
    store_lex "$*PKGDECL", $P793
.annotate 'line', 331
  # rx subcapture "sym"
    set_addr $I10, rxcap_794_fail
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx780_pos, 7
    gt $I11, rx780_eos, rx780_fail
    sub $I11, rx780_pos, rx780_off
    substr $S10, rx780_tgt, $I11, 7
    ne $S10, "grammar", rx780_fail
    add rx780_pos, 7
    set_addr $I10, rxcap_794_fail
    ($I12, $I11) = rx780_cur."!mark_peek"($I10)
    rx780_cur."!cursor_pos"($I11)
    ($P10) = rx780_cur."!cursor_start"()
    $P10."!cursor_pass"(rx780_pos, "")
    rx780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_794_done
  rxcap_794_fail:
    goto rx780_fail
  rxcap_794_done:
  # rx subrule "package_def" subtype=capture negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."package_def"()
    unless $P10, rx780_fail
    rx780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx780_pos = $P10."pos"()
.annotate 'line', 327
  # rx pass
    rx780_cur."!cursor_pass"(rx780_pos, "package_declarator:sym<grammar>")
    if_null rx780_debug, debug_884
    rx780_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx780_pos)
  debug_884:
    .return (rx780_cur)
  rx780_restart:
.annotate 'line', 10
    if_null rx780_debug, debug_885
    rx780_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_885:
  rx780_fail:
    (rx780_rep, rx780_pos, $I10, $P10) = rx780_cur."!mark_fail"(0)
    lt rx780_pos, -1, rx780_done
    eq rx780_pos, -1, rx780_fail
    jump $I10
  rx780_done:
    rx780_cur."!cursor_fail"()
    if_null rx780_debug, debug_886
    rx780_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_886:
    .return (rx780_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1303748459.273") :method
.annotate 'line', 10
    $P782 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P783, "ResizablePMCArray"
    push $P783, $P782
    .return ($P783)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 334
    new $P796, "Undef"
    .lex "$*OUTERPACKAGE", $P796
.annotate 'line', 335
    new $P797, "Undef"
    .lex "$*PACKAGE-SETUP", $P797
.annotate 'line', 336
    new $P798, "Undef"
    .lex "$*PKGDECL", $P798
.annotate 'line', 10
    .local string rx799_tgt
    .local int rx799_pos
    .local int rx799_off
    .local int rx799_eos
    .local int rx799_rep
    .local pmc rx799_cur
    .local pmc rx799_debug
    (rx799_cur, rx799_pos, rx799_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx799_cur
    .local pmc match
    .lex "$/", match
    length rx799_eos, rx799_tgt
    gt rx799_pos, rx799_eos, rx799_done
    set rx799_off, 0
    lt rx799_pos, 2, rx799_start
    sub rx799_off, rx799_pos, 1
    substr rx799_tgt, rx799_tgt, rx799_off
  rx799_start:
    eq $I10, 1, rx799_restart
    if_null rx799_debug, debug_887
    rx799_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_887:
    $I10 = self.'from'()
    ne $I10, -1, rxscan803_done
    goto rxscan803_scan
  rxscan803_loop:
    (rx799_pos) = rx799_cur."from"()
    inc rx799_pos
    rx799_cur."!cursor_from"(rx799_pos)
    ge rx799_pos, rx799_eos, rxscan803_done
  rxscan803_scan:
    set_addr $I10, rxscan803_loop
    rx799_cur."!mark_push"(0, rx799_pos, $I10)
  rxscan803_done:
.annotate 'line', 334
    rx799_cur."!cursor_pos"(rx799_pos)
    find_dynamic_lex $P806, "$*PACKAGE"
    unless_null $P806, vivify_888
    get_hll_global $P804, "GLOBAL"
    get_who $P805, $P804
    set $P806, $P805["$PACKAGE"]
    unless_null $P806, vivify_889
    die "Contextual $*PACKAGE not found"
  vivify_889:
  vivify_888:
    store_lex "$*OUTERPACKAGE", $P806
.annotate 'line', 335
    rx799_cur."!cursor_pos"(rx799_pos)
    get_hll_global $P807, "GLOBAL"
    nqp_get_package_through_who $P808, $P807, "PAST"
    get_who $P809, $P808
    set $P810, $P809["Stmts"]
    $P811 = $P810."new"()
    store_lex "$*PACKAGE-SETUP", $P811
.annotate 'line', 336
    rx799_cur."!cursor_pos"(rx799_pos)
    new $P812, "String"
    assign $P812, "role"
    store_lex "$*PKGDECL", $P812
.annotate 'line', 337
  # rx subcapture "sym"
    set_addr $I10, rxcap_813_fail
    rx799_cur."!mark_push"(0, rx799_pos, $I10)
  # rx literal  "role"
    add $I11, rx799_pos, 4
    gt $I11, rx799_eos, rx799_fail
    sub $I11, rx799_pos, rx799_off
    substr $S10, rx799_tgt, $I11, 4
    ne $S10, "role", rx799_fail
    add rx799_pos, 4
    set_addr $I10, rxcap_813_fail
    ($I12, $I11) = rx799_cur."!mark_peek"($I10)
    rx799_cur."!cursor_pos"($I11)
    ($P10) = rx799_cur."!cursor_start"()
    $P10."!cursor_pass"(rx799_pos, "")
    rx799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_813_done
  rxcap_813_fail:
    goto rx799_fail
  rxcap_813_done:
  # rx subrule "package_def" subtype=capture negate=
    rx799_cur."!cursor_pos"(rx799_pos)
    $P10 = rx799_cur."package_def"()
    unless $P10, rx799_fail
    rx799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx799_pos = $P10."pos"()
.annotate 'line', 333
  # rx pass
    rx799_cur."!cursor_pass"(rx799_pos, "package_declarator:sym<role>")
    if_null rx799_debug, debug_890
    rx799_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx799_pos)
  debug_890:
    .return (rx799_cur)
  rx799_restart:
.annotate 'line', 10
    if_null rx799_debug, debug_891
    rx799_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_891:
  rx799_fail:
    (rx799_rep, rx799_pos, $I10, $P10) = rx799_cur."!mark_fail"(0)
    lt rx799_pos, -1, rx799_done
    eq rx799_pos, -1, rx799_fail
    jump $I10
  rx799_done:
    rx799_cur."!cursor_fail"()
    if_null rx799_debug, debug_892
    rx799_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_892:
    .return (rx799_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1303748459.273") :method
.annotate 'line', 10
    $P801 = self."!PREFIX__!subrule"("package_def", "role")
    new $P802, "ResizablePMCArray"
    push $P802, $P801
    .return ($P802)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 340
    new $P815, "Undef"
    .lex "$*OUTERPACKAGE", $P815
.annotate 'line', 341
    new $P816, "Undef"
    .lex "$*PACKAGE-SETUP", $P816
.annotate 'line', 342
    new $P817, "Undef"
    .lex "$*PKGDECL", $P817
.annotate 'line', 10
    .local string rx818_tgt
    .local int rx818_pos
    .local int rx818_off
    .local int rx818_eos
    .local int rx818_rep
    .local pmc rx818_cur
    .local pmc rx818_debug
    (rx818_cur, rx818_pos, rx818_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx818_cur
    .local pmc match
    .lex "$/", match
    length rx818_eos, rx818_tgt
    gt rx818_pos, rx818_eos, rx818_done
    set rx818_off, 0
    lt rx818_pos, 2, rx818_start
    sub rx818_off, rx818_pos, 1
    substr rx818_tgt, rx818_tgt, rx818_off
  rx818_start:
    eq $I10, 1, rx818_restart
    if_null rx818_debug, debug_893
    rx818_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_893:
    $I10 = self.'from'()
    ne $I10, -1, rxscan822_done
    goto rxscan822_scan
  rxscan822_loop:
    (rx818_pos) = rx818_cur."from"()
    inc rx818_pos
    rx818_cur."!cursor_from"(rx818_pos)
    ge rx818_pos, rx818_eos, rxscan822_done
  rxscan822_scan:
    set_addr $I10, rxscan822_loop
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  rxscan822_done:
.annotate 'line', 340
    rx818_cur."!cursor_pos"(rx818_pos)
    find_dynamic_lex $P825, "$*PACKAGE"
    unless_null $P825, vivify_894
    get_hll_global $P823, "GLOBAL"
    get_who $P824, $P823
    set $P825, $P824["$PACKAGE"]
    unless_null $P825, vivify_895
    die "Contextual $*PACKAGE not found"
  vivify_895:
  vivify_894:
    store_lex "$*OUTERPACKAGE", $P825
.annotate 'line', 341
    rx818_cur."!cursor_pos"(rx818_pos)
    get_hll_global $P826, "GLOBAL"
    nqp_get_package_through_who $P827, $P826, "PAST"
    get_who $P828, $P827
    set $P829, $P828["Stmts"]
    $P830 = $P829."new"()
    store_lex "$*PACKAGE-SETUP", $P830
.annotate 'line', 342
    rx818_cur."!cursor_pos"(rx818_pos)
    new $P831, "String"
    assign $P831, "native"
    store_lex "$*PKGDECL", $P831
.annotate 'line', 343
  # rx subcapture "sym"
    set_addr $I10, rxcap_832_fail
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  # rx literal  "native"
    add $I11, rx818_pos, 6
    gt $I11, rx818_eos, rx818_fail
    sub $I11, rx818_pos, rx818_off
    substr $S10, rx818_tgt, $I11, 6
    ne $S10, "native", rx818_fail
    add rx818_pos, 6
    set_addr $I10, rxcap_832_fail
    ($I12, $I11) = rx818_cur."!mark_peek"($I10)
    rx818_cur."!cursor_pos"($I11)
    ($P10) = rx818_cur."!cursor_start"()
    $P10."!cursor_pass"(rx818_pos, "")
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_832_done
  rxcap_832_fail:
    goto rx818_fail
  rxcap_832_done:
  # rx subrule "package_def" subtype=capture negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."package_def"()
    unless $P10, rx818_fail
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx818_pos = $P10."pos"()
.annotate 'line', 339
  # rx pass
    rx818_cur."!cursor_pass"(rx818_pos, "package_declarator:sym<native>")
    if_null rx818_debug, debug_896
    rx818_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx818_pos)
  debug_896:
    .return (rx818_cur)
  rx818_restart:
.annotate 'line', 10
    if_null rx818_debug, debug_897
    rx818_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_897:
  rx818_fail:
    (rx818_rep, rx818_pos, $I10, $P10) = rx818_cur."!mark_fail"(0)
    lt rx818_pos, -1, rx818_done
    eq rx818_pos, -1, rx818_fail
    jump $I10
  rx818_done:
    rx818_cur."!cursor_fail"()
    if_null rx818_debug, debug_898
    rx818_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_898:
    .return (rx818_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1303748459.273") :method
.annotate 'line', 10
    $P820 = self."!PREFIX__!subrule"("package_def", "native")
    new $P821, "ResizablePMCArray"
    push $P821, $P820
    .return ($P821)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P861 = "154_1303748459.273" 
    capture_lex $P861
.annotate 'line', 347
    new $P834, "Undef"
    .lex "$*PACKAGE", $P834
.annotate 'line', 348
    $P835 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P835
.annotate 'line', 10
    .local string rx836_tgt
    .local int rx836_pos
    .local int rx836_off
    .local int rx836_eos
    .local int rx836_rep
    .local pmc rx836_cur
    .local pmc rx836_debug
    (rx836_cur, rx836_pos, rx836_tgt, $I10) = self."!cursor_start"()
    rx836_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx836_cur
    .local pmc match
    .lex "$/", match
    length rx836_eos, rx836_tgt
    gt rx836_pos, rx836_eos, rx836_done
    set rx836_off, 0
    lt rx836_pos, 2, rx836_start
    sub rx836_off, rx836_pos, 1
    substr rx836_tgt, rx836_tgt, rx836_off
  rx836_start:
    eq $I10, 1, rx836_restart
    if_null rx836_debug, debug_899
    rx836_cur."!cursor_debug"("START", "package_def")
  debug_899:
    $I10 = self.'from'()
    ne $I10, -1, rxscan840_done
    goto rxscan840_scan
  rxscan840_loop:
    (rx836_pos) = rx836_cur."from"()
    inc rx836_pos
    rx836_cur."!cursor_from"(rx836_pos)
    ge rx836_pos, rx836_eos, rxscan840_done
  rxscan840_scan:
    set_addr $I10, rxscan840_loop
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxscan840_done:
.annotate 'line', 346
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 347
    rx836_cur."!cursor_pos"(rx836_pos)
    find_lex $P844, "$*PACKAGE"
    unless_null $P844, vivify_900
    get_hll_global $P842, "GLOBAL"
    get_who $P843, $P842
    set $P844, $P843["$PACKAGE"]
    unless_null $P844, vivify_901
    die "Contextual $*PACKAGE not found"
  vivify_901:
  vivify_900:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 348
    rx836_cur."!cursor_pos"(rx836_pos)
    find_lex $P848, "%*ATTR-CHECK"
    unless_null $P848, vivify_902
    get_hll_global $P846, "GLOBAL"
    get_who $P847, $P846
    set $P848, $P847["%ATTR-CHECK"]
    unless_null $P848, vivify_903
    die "Contextual %*ATTR-CHECK not found"
  vivify_903:
  vivify_902:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 350
  # rx subrule "name" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."name"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 351
  # rx rxquantr851 ** 0..1
    set_addr $I10, rxquantr851_done
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxquantr851_loop:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx836_pos, 2
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 2
    ne $S10, "is", rx836_fail
    add rx836_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx836_pos, 5
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 5
    ne $S10, "repr(", rx836_fail
    add rx836_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."quote_EXPR"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx836_pos, 1
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    ord $I11, rx836_tgt, $I11
    ne $I11, 41, rx836_fail
    add rx836_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    set_addr $I10, rxquantr851_done
    (rx836_rep) = rx836_cur."!mark_commit"($I10)
  rxquantr851_done:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 353
    rx836_cur."!cursor_pos"(rx836_pos)
    find_lex $P858, unicode:"$\x{a2}"
    $P859 = $P858."MATCH"()
    store_lex "$/", $P859
    .const 'Sub' $P861 = "154_1303748459.273" 
    capture_lex $P861
    $P983 = $P861()
.annotate 'line', 379
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 381
  # rx rxquantr985 ** 0..1
    set_addr $I10, rxquantr985_done
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxquantr985_loop:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx836_pos, 2
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 2
    ne $S10, "is", rx836_fail
    add rx836_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."name"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    set_addr $I10, rxquantr985_done
    (rx836_rep) = rx836_cur."!mark_commit"($I10)
  rxquantr985_done:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 382
  # rx rxquantr990 ** 0..*
    set_addr $I10, rxquantr990_done
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxquantr990_loop:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx836_pos, 4
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 4
    ne $S10, "does", rx836_fail
    add rx836_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."name"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    set_addr $I10, rxquantr990_done
    (rx836_rep) = rx836_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr990_done
    rx836_cur."!mark_push"(rx836_rep, rx836_pos, $I10)
    goto rxquantr990_loop
  rxquantr990_done:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  alt995_0:
.annotate 'line', 383
    set_addr $I10, alt995_1
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
.annotate 'line', 384
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx836_pos, 1
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    ord $I11, rx836_tgt, $I11
    ne $I11, 59, rx836_fail
    add rx836_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."comp_unit"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    goto alt995_end
  alt995_1:
    set_addr $I10, alt995_2
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
.annotate 'line', 385
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx836_fail
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."block"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    goto alt995_end
  alt995_2:
.annotate 'line', 386
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."panic"("Malformed package declaration")
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  alt995_end:
.annotate 'line', 387
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 346
  # rx pass
    rx836_cur."!cursor_pass"(rx836_pos, "package_def")
    if_null rx836_debug, debug_971
    rx836_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx836_pos)
  debug_971:
    .return (rx836_cur)
  rx836_restart:
.annotate 'line', 10
    if_null rx836_debug, debug_972
    rx836_cur."!cursor_debug"("NEXT", "package_def")
  debug_972:
  rx836_fail:
    (rx836_rep, rx836_pos, $I10, $P10) = rx836_cur."!mark_fail"(0)
    lt rx836_pos, -1, rx836_done
    eq rx836_pos, -1, rx836_fail
    jump $I10
  rx836_done:
    rx836_cur."!cursor_fail"()
    if_null rx836_debug, debug_973
    rx836_cur."!cursor_debug"("FAIL", "package_def")
  debug_973:
    .return (rx836_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1303748459.273") :method
.annotate 'line', 10
    $P838 = self."!PREFIX__!subrule"("ws", "")
    new $P839, "ResizablePMCArray"
    push $P839, $P838
    .return ($P839)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block860"  :anon :subid("154_1303748459.273") :outer("152_1303748459.273")
.annotate 'line', 356
    $P862 = root_new ['parrot';'Hash']
    .lex "%args", $P862
.annotate 'line', 353
    find_lex $P863, "%args"
    unless_null $P863, vivify_904
    $P863 = root_new ['parrot';'Hash']
  vivify_904:
.annotate 'line', 357
    find_lex $P864, "$/"
    unless_null $P864, vivify_905
    $P864 = root_new ['parrot';'Hash']
  vivify_905:
    set $P865, $P864["name"]
    unless_null $P865, vivify_906
    new $P865, "Undef"
  vivify_906:
    set $S866, $P865
    new $P867, 'String'
    set $P867, $S866
    find_lex $P868, "%args"
    unless_null $P868, vivify_907
    $P868 = root_new ['parrot';'Hash']
    store_lex "%args", $P868
  vivify_907:
    set $P868["name"], $P867
.annotate 'line', 358
    find_lex $P870, "$/"
    unless_null $P870, vivify_908
    $P870 = root_new ['parrot';'Hash']
  vivify_908:
    set $P871, $P870["repr"]
    unless_null $P871, vivify_909
    new $P871, "Undef"
  vivify_909:
    unless $P871, if_869_end
.annotate 'line', 359
    find_lex $P872, "$/"
    unless_null $P872, vivify_910
    $P872 = root_new ['parrot';'Hash']
  vivify_910:
    set $P873, $P872["repr"]
    unless_null $P873, vivify_911
    $P873 = root_new ['parrot';'ResizablePMCArray']
  vivify_911:
    set $P874, $P873[0]
    unless_null $P874, vivify_912
    $P874 = root_new ['parrot';'Hash']
  vivify_912:
    set $P875, $P874["quote_delimited"]
    unless_null $P875, vivify_913
    $P875 = root_new ['parrot';'Hash']
  vivify_913:
    set $P876, $P875["quote_atom"]
    unless_null $P876, vivify_914
    $P876 = root_new ['parrot';'ResizablePMCArray']
  vivify_914:
    set $P877, $P876[0]
    unless_null $P877, vivify_915
    new $P877, "Undef"
  vivify_915:
    set $S878, $P877
    new $P879, 'String'
    set $P879, $S878
    find_lex $P880, "%args"
    unless_null $P880, vivify_916
    $P880 = root_new ['parrot';'Hash']
    store_lex "%args", $P880
  vivify_916:
    set $P880["repr"], $P879
  if_869_end:
.annotate 'line', 361
    find_dynamic_lex $P883, "$*SC"
    unless_null $P883, vivify_917
    get_hll_global $P881, "GLOBAL"
    get_who $P882, $P881
    set $P883, $P882["$SC"]
    unless_null $P883, vivify_918
    die "Contextual $*SC not found"
  vivify_918:
  vivify_917:
    find_dynamic_lex $P886, "$*PKGDECL"
    unless_null $P886, vivify_919
    get_hll_global $P884, "GLOBAL"
    get_who $P885, $P884
    set $P886, $P885["$PKGDECL"]
    unless_null $P886, vivify_920
    die "Contextual $*PKGDECL not found"
  vivify_920:
  vivify_919:
    find_dynamic_lex $P889, "%*HOW"
    unless_null $P889, vivify_921
    get_hll_global $P887, "GLOBAL"
    get_who $P888, $P887
    set $P889, $P888["%HOW"]
    unless_null $P889, vivify_922
    die "Contextual %*HOW not found"
  vivify_922:
  vivify_921:
    set $P890, $P889[$P886]
    unless_null $P890, vivify_923
    new $P890, "Undef"
  vivify_923:
    find_lex $P891, "%args"
    unless_null $P891, vivify_924
    $P891 = root_new ['parrot';'Hash']
  vivify_924:
    $P892 = $P883."pkg_create_mo"($P890, $P891 :flat)
    store_dynamic_lex "$*PACKAGE", $P892
.annotate 'line', 364
    find_dynamic_lex $P899, "$*SCOPE"
    unless_null $P899, vivify_925
    get_hll_global $P897, "GLOBAL"
    get_who $P898, $P897
    set $P899, $P898["$SCOPE"]
    unless_null $P899, vivify_926
    die "Contextual $*SCOPE not found"
  vivify_926:
  vivify_925:
    set $S900, $P899
    iseq $I901, $S900, "our"
    unless $I901, unless_896
    new $P895, 'Integer'
    set $P895, $I901
    goto unless_896_end
  unless_896:
    find_dynamic_lex $P904, "$*SCOPE"
    unless_null $P904, vivify_927
    get_hll_global $P902, "GLOBAL"
    get_who $P903, $P902
    set $P904, $P903["$SCOPE"]
    unless_null $P904, vivify_928
    die "Contextual $*SCOPE not found"
  vivify_928:
  vivify_927:
    set $S905, $P904
    iseq $I906, $S905, ""
    new $P895, 'Integer'
    set $P895, $I906
  unless_896_end:
    if $P895, if_894
.annotate 'line', 370
    find_dynamic_lex $P947, "$*SCOPE"
    unless_null $P947, vivify_929
    get_hll_global $P945, "GLOBAL"
    get_who $P946, $P945
    set $P947, $P946["$SCOPE"]
    unless_null $P947, vivify_930
    die "Contextual $*SCOPE not found"
  vivify_930:
  vivify_929:
    set $S948, $P947
    iseq $I949, $S948, "my"
    if $I949, if_944
.annotate 'line', 377
    find_lex $P976, "$/"
    unless_null $P976, vivify_931
    new $P976, "Undef"
  vivify_931:
    $P977 = $P976."CURSOR"()
    find_dynamic_lex $P980, "$*SCOPE"
    unless_null $P980, vivify_932
    get_hll_global $P978, "GLOBAL"
    get_who $P979, $P978
    set $P980, $P979["$SCOPE"]
    unless_null $P980, vivify_933
    die "Contextual $*SCOPE not found"
  vivify_933:
  vivify_932:
    concat $P981, $P980, " scoped packages are not supported"
    $P982 = $P977."panic"($P981)
.annotate 'line', 376
    set $P943, $P982
.annotate 'line', 370
    goto if_944_end
  if_944:
.annotate 'line', 371
    find_lex $P951, "$/"
    unless_null $P951, vivify_934
    $P951 = root_new ['parrot';'Hash']
  vivify_934:
    set $P952, $P951["name"]
    unless_null $P952, vivify_935
    $P952 = root_new ['parrot';'Hash']
  vivify_935:
    set $P953, $P952["identifier"]
    unless_null $P953, vivify_936
    new $P953, "Undef"
  vivify_936:
    set $N954, $P953
    isne $I955, $N954, 1.0
    unless $I955, if_950_end
.annotate 'line', 372
    find_lex $P956, "$/"
    unless_null $P956, vivify_937
    $P956 = root_new ['parrot';'Hash']
  vivify_937:
    set $P957, $P956["name"]
    unless_null $P957, vivify_938
    new $P957, "Undef"
  vivify_938:
    $P958 = $P957."CURSOR"()
    $P958."panic"("A my scoped package cannot have a multi-part name yet")
  if_950_end:
.annotate 'line', 374
    find_dynamic_lex $P961, "$*SC"
    unless_null $P961, vivify_939
    get_hll_global $P959, "GLOBAL"
    get_who $P960, $P959
    set $P961, $P960["$SC"]
    unless_null $P961, vivify_940
    die "Contextual $*SC not found"
  vivify_940:
  vivify_939:
    get_hll_global $P962, "GLOBAL"
    nqp_get_package_through_who $P963, $P962, "NQP"
    nqp_get_package_through_who $P964, $P963, "Actions"
    get_who $P965, $P964
    set $P966, $P965["@BLOCK"]
    unless_null $P966, vivify_941
    $P966 = root_new ['parrot';'ResizablePMCArray']
  vivify_941:
    set $P967, $P966[0]
    unless_null $P967, vivify_942
    new $P967, "Undef"
  vivify_942:
    find_lex $P968, "$/"
    unless_null $P968, vivify_943
    $P968 = root_new ['parrot';'Hash']
  vivify_943:
    set $P969, $P968["name"]
    unless_null $P969, vivify_944
    $P969 = root_new ['parrot';'Hash']
  vivify_944:
    set $P970, $P969["identifier"]
    unless_null $P970, vivify_945
    $P970 = root_new ['parrot';'ResizablePMCArray']
  vivify_945:
    set $P971, $P970[0]
    unless_null $P971, vivify_946
    new $P971, "Undef"
  vivify_946:
    find_dynamic_lex $P974, "$*PACKAGE"
    unless_null $P974, vivify_947
    get_hll_global $P972, "GLOBAL"
    get_who $P973, $P972
    set $P974, $P973["$PACKAGE"]
    unless_null $P974, vivify_948
    die "Contextual $*PACKAGE not found"
  vivify_948:
  vivify_947:
    $P975 = $P961."install_lexical_symbol"($P967, $P971, $P974)
.annotate 'line', 370
    set $P943, $P975
  if_944_end:
    set $P893, $P943
.annotate 'line', 364
    goto if_894_end
  if_894:
.annotate 'line', 365
    find_dynamic_lex $P909, "$*SC"
    unless_null $P909, vivify_949
    get_hll_global $P907, "GLOBAL"
    get_who $P908, $P907
    set $P909, $P908["$SC"]
    unless_null $P909, vivify_950
    die "Contextual $*SC not found"
  vivify_950:
  vivify_949:
    find_dynamic_lex $P912, "$*OUTERPACKAGE"
    unless_null $P912, vivify_951
    get_hll_global $P910, "GLOBAL"
    get_who $P911, $P910
    set $P912, $P911["$OUTERPACKAGE"]
    unless_null $P912, vivify_952
    die "Contextual $*OUTERPACKAGE not found"
  vivify_952:
  vivify_951:
    find_lex $P913, "$/"
    unless_null $P913, vivify_953
    $P913 = root_new ['parrot';'Hash']
  vivify_953:
    set $P914, $P913["name"]
    unless_null $P914, vivify_954
    $P914 = root_new ['parrot';'Hash']
  vivify_954:
    set $P915, $P914["identifier"]
    unless_null $P915, vivify_955
    new $P915, "Undef"
  vivify_955:
    find_dynamic_lex $P918, "$*PACKAGE"
    unless_null $P918, vivify_956
    get_hll_global $P916, "GLOBAL"
    get_who $P917, $P916
    set $P918, $P917["$PACKAGE"]
    unless_null $P918, vivify_957
    die "Contextual $*PACKAGE not found"
  vivify_957:
  vivify_956:
    $P909."install_package_symbol"($P912, $P915, $P918)
.annotate 'line', 366
    find_lex $P921, "$/"
    unless_null $P921, vivify_958
    $P921 = root_new ['parrot';'Hash']
  vivify_958:
    set $P922, $P921["name"]
    unless_null $P922, vivify_959
    $P922 = root_new ['parrot';'Hash']
  vivify_959:
    set $P923, $P922["identifier"]
    unless_null $P923, vivify_960
    new $P923, "Undef"
  vivify_960:
    set $N924, $P923
    iseq $I925, $N924, 1.0
    if $I925, if_920
    new $P919, 'Integer'
    set $P919, $I925
    goto if_920_end
  if_920:
.annotate 'line', 367
    find_dynamic_lex $P928, "$*SC"
    unless_null $P928, vivify_961
    get_hll_global $P926, "GLOBAL"
    get_who $P927, $P926
    set $P928, $P927["$SC"]
    unless_null $P928, vivify_962
    die "Contextual $*SC not found"
  vivify_962:
  vivify_961:
    get_hll_global $P929, "GLOBAL"
    nqp_get_package_through_who $P930, $P929, "NQP"
    nqp_get_package_through_who $P931, $P930, "Actions"
    get_who $P932, $P931
    set $P933, $P932["@BLOCK"]
    unless_null $P933, vivify_963
    $P933 = root_new ['parrot';'ResizablePMCArray']
  vivify_963:
    set $P934, $P933[0]
    unless_null $P934, vivify_964
    new $P934, "Undef"
  vivify_964:
    find_lex $P935, "$/"
    unless_null $P935, vivify_965
    $P935 = root_new ['parrot';'Hash']
  vivify_965:
    set $P936, $P935["name"]
    unless_null $P936, vivify_966
    $P936 = root_new ['parrot';'Hash']
  vivify_966:
    set $P937, $P936["identifier"]
    unless_null $P937, vivify_967
    $P937 = root_new ['parrot';'ResizablePMCArray']
  vivify_967:
    set $P938, $P937[0]
    unless_null $P938, vivify_968
    new $P938, "Undef"
  vivify_968:
    find_dynamic_lex $P941, "$*PACKAGE"
    unless_null $P941, vivify_969
    get_hll_global $P939, "GLOBAL"
    get_who $P940, $P939
    set $P941, $P940["$PACKAGE"]
    unless_null $P941, vivify_970
    die "Contextual $*PACKAGE not found"
  vivify_970:
  vivify_969:
    $P942 = $P928."install_lexical_symbol"($P934, $P938, $P941)
.annotate 'line', 366
    set $P919, $P942
  if_920_end:
.annotate 'line', 364
    set $P893, $P919
  if_894_end:
.annotate 'line', 353
    .return ($P893)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1303748459.273")
    .param pmc param_1006
.annotate 'line', 390
    .lex "self", param_1006
    $P1007 = param_1006."!protoregex"("scope_declarator")
    .return ($P1007)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1303748459.273")
    .param pmc param_1009
.annotate 'line', 390
    .lex "self", param_1009
    $P1010 = param_1009."!PREFIX__!protoregex"("scope_declarator")
    .return ($P1010)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1012_tgt
    .local int rx1012_pos
    .local int rx1012_off
    .local int rx1012_eos
    .local int rx1012_rep
    .local pmc rx1012_cur
    .local pmc rx1012_debug
    (rx1012_cur, rx1012_pos, rx1012_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1012_cur
    .local pmc match
    .lex "$/", match
    length rx1012_eos, rx1012_tgt
    gt rx1012_pos, rx1012_eos, rx1012_done
    set rx1012_off, 0
    lt rx1012_pos, 2, rx1012_start
    sub rx1012_off, rx1012_pos, 1
    substr rx1012_tgt, rx1012_tgt, rx1012_off
  rx1012_start:
    eq $I10, 1, rx1012_restart
    if_null rx1012_debug, debug_974
    rx1012_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_974:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1016_done
    goto rxscan1016_scan
  rxscan1016_loop:
    (rx1012_pos) = rx1012_cur."from"()
    inc rx1012_pos
    rx1012_cur."!cursor_from"(rx1012_pos)
    ge rx1012_pos, rx1012_eos, rxscan1016_done
  rxscan1016_scan:
    set_addr $I10, rxscan1016_loop
    rx1012_cur."!mark_push"(0, rx1012_pos, $I10)
  rxscan1016_done:
.annotate 'line', 391
  # rx subcapture "sym"
    set_addr $I10, rxcap_1017_fail
    rx1012_cur."!mark_push"(0, rx1012_pos, $I10)
  # rx literal  "my"
    add $I11, rx1012_pos, 2
    gt $I11, rx1012_eos, rx1012_fail
    sub $I11, rx1012_pos, rx1012_off
    substr $S10, rx1012_tgt, $I11, 2
    ne $S10, "my", rx1012_fail
    add rx1012_pos, 2
    set_addr $I10, rxcap_1017_fail
    ($I12, $I11) = rx1012_cur."!mark_peek"($I10)
    rx1012_cur."!cursor_pos"($I11)
    ($P10) = rx1012_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1012_pos, "")
    rx1012_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1017_done
  rxcap_1017_fail:
    goto rx1012_fail
  rxcap_1017_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1012_cur."!cursor_pos"(rx1012_pos)
    $P10 = rx1012_cur."scoped"("my")
    unless $P10, rx1012_fail
    rx1012_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1012_pos = $P10."pos"()
  # rx pass
    rx1012_cur."!cursor_pass"(rx1012_pos, "scope_declarator:sym<my>")
    if_null rx1012_debug, debug_975
    rx1012_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1012_pos)
  debug_975:
    .return (rx1012_cur)
  rx1012_restart:
.annotate 'line', 10
    if_null rx1012_debug, debug_976
    rx1012_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_976:
  rx1012_fail:
    (rx1012_rep, rx1012_pos, $I10, $P10) = rx1012_cur."!mark_fail"(0)
    lt rx1012_pos, -1, rx1012_done
    eq rx1012_pos, -1, rx1012_fail
    jump $I10
  rx1012_done:
    rx1012_cur."!cursor_fail"()
    if_null rx1012_debug, debug_977
    rx1012_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_977:
    .return (rx1012_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1303748459.273") :method
.annotate 'line', 10
    $P1014 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1015, "ResizablePMCArray"
    push $P1015, $P1014
    .return ($P1015)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1019_tgt
    .local int rx1019_pos
    .local int rx1019_off
    .local int rx1019_eos
    .local int rx1019_rep
    .local pmc rx1019_cur
    .local pmc rx1019_debug
    (rx1019_cur, rx1019_pos, rx1019_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1019_cur
    .local pmc match
    .lex "$/", match
    length rx1019_eos, rx1019_tgt
    gt rx1019_pos, rx1019_eos, rx1019_done
    set rx1019_off, 0
    lt rx1019_pos, 2, rx1019_start
    sub rx1019_off, rx1019_pos, 1
    substr rx1019_tgt, rx1019_tgt, rx1019_off
  rx1019_start:
    eq $I10, 1, rx1019_restart
    if_null rx1019_debug, debug_978
    rx1019_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_978:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1023_done
    goto rxscan1023_scan
  rxscan1023_loop:
    (rx1019_pos) = rx1019_cur."from"()
    inc rx1019_pos
    rx1019_cur."!cursor_from"(rx1019_pos)
    ge rx1019_pos, rx1019_eos, rxscan1023_done
  rxscan1023_scan:
    set_addr $I10, rxscan1023_loop
    rx1019_cur."!mark_push"(0, rx1019_pos, $I10)
  rxscan1023_done:
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_1024_fail
    rx1019_cur."!mark_push"(0, rx1019_pos, $I10)
  # rx literal  "our"
    add $I11, rx1019_pos, 3
    gt $I11, rx1019_eos, rx1019_fail
    sub $I11, rx1019_pos, rx1019_off
    substr $S10, rx1019_tgt, $I11, 3
    ne $S10, "our", rx1019_fail
    add rx1019_pos, 3
    set_addr $I10, rxcap_1024_fail
    ($I12, $I11) = rx1019_cur."!mark_peek"($I10)
    rx1019_cur."!cursor_pos"($I11)
    ($P10) = rx1019_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1019_pos, "")
    rx1019_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1024_done
  rxcap_1024_fail:
    goto rx1019_fail
  rxcap_1024_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."scoped"("our")
    unless $P10, rx1019_fail
    rx1019_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1019_pos = $P10."pos"()
  # rx pass
    rx1019_cur."!cursor_pass"(rx1019_pos, "scope_declarator:sym<our>")
    if_null rx1019_debug, debug_979
    rx1019_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1019_pos)
  debug_979:
    .return (rx1019_cur)
  rx1019_restart:
.annotate 'line', 10
    if_null rx1019_debug, debug_980
    rx1019_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_980:
  rx1019_fail:
    (rx1019_rep, rx1019_pos, $I10, $P10) = rx1019_cur."!mark_fail"(0)
    lt rx1019_pos, -1, rx1019_done
    eq rx1019_pos, -1, rx1019_fail
    jump $I10
  rx1019_done:
    rx1019_cur."!cursor_fail"()
    if_null rx1019_debug, debug_981
    rx1019_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_981:
    .return (rx1019_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1303748459.273") :method
.annotate 'line', 10
    $P1021 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1022, "ResizablePMCArray"
    push $P1022, $P1021
    .return ($P1022)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1026_tgt
    .local int rx1026_pos
    .local int rx1026_off
    .local int rx1026_eos
    .local int rx1026_rep
    .local pmc rx1026_cur
    .local pmc rx1026_debug
    (rx1026_cur, rx1026_pos, rx1026_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1026_cur
    .local pmc match
    .lex "$/", match
    length rx1026_eos, rx1026_tgt
    gt rx1026_pos, rx1026_eos, rx1026_done
    set rx1026_off, 0
    lt rx1026_pos, 2, rx1026_start
    sub rx1026_off, rx1026_pos, 1
    substr rx1026_tgt, rx1026_tgt, rx1026_off
  rx1026_start:
    eq $I10, 1, rx1026_restart
    if_null rx1026_debug, debug_982
    rx1026_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_982:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1030_done
    goto rxscan1030_scan
  rxscan1030_loop:
    (rx1026_pos) = rx1026_cur."from"()
    inc rx1026_pos
    rx1026_cur."!cursor_from"(rx1026_pos)
    ge rx1026_pos, rx1026_eos, rxscan1030_done
  rxscan1030_scan:
    set_addr $I10, rxscan1030_loop
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
  rxscan1030_done:
.annotate 'line', 393
  # rx subcapture "sym"
    set_addr $I10, rxcap_1031_fail
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
  # rx literal  "has"
    add $I11, rx1026_pos, 3
    gt $I11, rx1026_eos, rx1026_fail
    sub $I11, rx1026_pos, rx1026_off
    substr $S10, rx1026_tgt, $I11, 3
    ne $S10, "has", rx1026_fail
    add rx1026_pos, 3
    set_addr $I10, rxcap_1031_fail
    ($I12, $I11) = rx1026_cur."!mark_peek"($I10)
    rx1026_cur."!cursor_pos"($I11)
    ($P10) = rx1026_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1026_pos, "")
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1031_done
  rxcap_1031_fail:
    goto rx1026_fail
  rxcap_1031_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1026_cur."!cursor_pos"(rx1026_pos)
    $P10 = rx1026_cur."scoped"("has")
    unless $P10, rx1026_fail
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1026_pos = $P10."pos"()
  # rx pass
    rx1026_cur."!cursor_pass"(rx1026_pos, "scope_declarator:sym<has>")
    if_null rx1026_debug, debug_983
    rx1026_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1026_pos)
  debug_983:
    .return (rx1026_cur)
  rx1026_restart:
.annotate 'line', 10
    if_null rx1026_debug, debug_984
    rx1026_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_984:
  rx1026_fail:
    (rx1026_rep, rx1026_pos, $I10, $P10) = rx1026_cur."!mark_fail"(0)
    lt rx1026_pos, -1, rx1026_done
    eq rx1026_pos, -1, rx1026_fail
    jump $I10
  rx1026_done:
    rx1026_cur."!cursor_fail"()
    if_null rx1026_debug, debug_985
    rx1026_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_985:
    .return (rx1026_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1303748459.273") :method
.annotate 'line', 10
    $P1028 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1029, "ResizablePMCArray"
    push $P1029, $P1028
    .return ($P1029)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1303748459.273") :method :outer("12_1303748459.273")
    .param pmc param_1033
.annotate 'line', 395
    .lex "$*SCOPE", param_1033
.annotate 'line', 10
    .local string rx1034_tgt
    .local int rx1034_pos
    .local int rx1034_off
    .local int rx1034_eos
    .local int rx1034_rep
    .local pmc rx1034_cur
    .local pmc rx1034_debug
    (rx1034_cur, rx1034_pos, rx1034_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1034_cur
    .local pmc match
    .lex "$/", match
    length rx1034_eos, rx1034_tgt
    gt rx1034_pos, rx1034_eos, rx1034_done
    set rx1034_off, 0
    lt rx1034_pos, 2, rx1034_start
    sub rx1034_off, rx1034_pos, 1
    substr rx1034_tgt, rx1034_tgt, rx1034_off
  rx1034_start:
    eq $I10, 1, rx1034_restart
    if_null rx1034_debug, debug_986
    rx1034_cur."!cursor_debug"("START", "scoped")
  debug_986:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1040_done
    goto rxscan1040_scan
  rxscan1040_loop:
    (rx1034_pos) = rx1034_cur."from"()
    inc rx1034_pos
    rx1034_cur."!cursor_from"(rx1034_pos)
    ge rx1034_pos, rx1034_eos, rxscan1040_done
  rxscan1040_scan:
    set_addr $I10, rxscan1040_loop
    rx1034_cur."!mark_push"(0, rx1034_pos, $I10)
  rxscan1040_done:
  alt1041_0:
.annotate 'line', 395
    set_addr $I10, alt1041_1
    rx1034_cur."!mark_push"(0, rx1034_pos, $I10)
.annotate 'line', 396
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."declarator"()
    unless $P10, rx1034_fail
    rx1034_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1034_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
    goto alt1041_end
  alt1041_1:
    set_addr $I10, alt1041_2
    rx1034_cur."!mark_push"(0, rx1034_pos, $I10)
.annotate 'line', 397
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."multi_declarator"()
    unless $P10, rx1034_fail
    rx1034_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1034_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
    goto alt1041_end
  alt1041_2:
.annotate 'line', 398
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."package_declarator"()
    unless $P10, rx1034_fail
    rx1034_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1034_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  alt1041_end:
.annotate 'line', 395
  # rx pass
    rx1034_cur."!cursor_pass"(rx1034_pos, "scoped")
    if_null rx1034_debug, debug_987
    rx1034_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1034_pos)
  debug_987:
    .return (rx1034_cur)
  rx1034_restart:
.annotate 'line', 10
    if_null rx1034_debug, debug_988
    rx1034_cur."!cursor_debug"("NEXT", "scoped")
  debug_988:
  rx1034_fail:
    (rx1034_rep, rx1034_pos, $I10, $P10) = rx1034_cur."!mark_fail"(0)
    lt rx1034_pos, -1, rx1034_done
    eq rx1034_pos, -1, rx1034_fail
    jump $I10
  rx1034_done:
    rx1034_cur."!cursor_fail"()
    if_null rx1034_debug, debug_989
    rx1034_cur."!cursor_debug"("FAIL", "scoped")
  debug_989:
    .return (rx1034_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1303748459.273") :method
.annotate 'line', 10
    $P1036 = self."!PREFIX__!subrule"("ws", "")
    $P1037 = self."!PREFIX__!subrule"("ws", "")
    $P1038 = self."!PREFIX__!subrule"("ws", "")
    new $P1039, "ResizablePMCArray"
    push $P1039, $P1036
    push $P1039, $P1037
    push $P1039, $P1038
    .return ($P1039)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1049_tgt
    .local int rx1049_pos
    .local int rx1049_off
    .local int rx1049_eos
    .local int rx1049_rep
    .local pmc rx1049_cur
    .local pmc rx1049_debug
    (rx1049_cur, rx1049_pos, rx1049_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1049_cur
    .local pmc match
    .lex "$/", match
    length rx1049_eos, rx1049_tgt
    gt rx1049_pos, rx1049_eos, rx1049_done
    set rx1049_off, 0
    lt rx1049_pos, 2, rx1049_start
    sub rx1049_off, rx1049_pos, 1
    substr rx1049_tgt, rx1049_tgt, rx1049_off
  rx1049_start:
    eq $I10, 1, rx1049_restart
    if_null rx1049_debug, debug_990
    rx1049_cur."!cursor_debug"("START", "typename")
  debug_990:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1053_done
    goto rxscan1053_scan
  rxscan1053_loop:
    (rx1049_pos) = rx1049_cur."from"()
    inc rx1049_pos
    rx1049_cur."!cursor_from"(rx1049_pos)
    ge rx1049_pos, rx1049_eos, rxscan1053_done
  rxscan1053_scan:
    set_addr $I10, rxscan1053_loop
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  rxscan1053_done:
.annotate 'line', 401
  # rx subrule "name" subtype=capture negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."name"()
    unless $P10, rx1049_fail
    rx1049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1049_pos = $P10."pos"()
  # rx pass
    rx1049_cur."!cursor_pass"(rx1049_pos, "typename")
    if_null rx1049_debug, debug_991
    rx1049_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1049_pos)
  debug_991:
    .return (rx1049_cur)
  rx1049_restart:
.annotate 'line', 10
    if_null rx1049_debug, debug_992
    rx1049_cur."!cursor_debug"("NEXT", "typename")
  debug_992:
  rx1049_fail:
    (rx1049_rep, rx1049_pos, $I10, $P10) = rx1049_cur."!mark_fail"(0)
    lt rx1049_pos, -1, rx1049_done
    eq rx1049_pos, -1, rx1049_fail
    jump $I10
  rx1049_done:
    rx1049_cur."!cursor_fail"()
    if_null rx1049_debug, debug_993
    rx1049_cur."!cursor_debug"("FAIL", "typename")
  debug_993:
    .return (rx1049_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1303748459.273") :method
.annotate 'line', 10
    $P1051 = self."!PREFIX__!subrule"("name", "")
    new $P1052, "ResizablePMCArray"
    push $P1052, $P1051
    .return ($P1052)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("167_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1055_tgt
    .local int rx1055_pos
    .local int rx1055_off
    .local int rx1055_eos
    .local int rx1055_rep
    .local pmc rx1055_cur
    .local pmc rx1055_debug
    (rx1055_cur, rx1055_pos, rx1055_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1055_cur
    .local pmc match
    .lex "$/", match
    length rx1055_eos, rx1055_tgt
    gt rx1055_pos, rx1055_eos, rx1055_done
    set rx1055_off, 0
    lt rx1055_pos, 2, rx1055_start
    sub rx1055_off, rx1055_pos, 1
    substr rx1055_tgt, rx1055_tgt, rx1055_off
  rx1055_start:
    eq $I10, 1, rx1055_restart
    if_null rx1055_debug, debug_994
    rx1055_cur."!cursor_debug"("START", "declarator")
  debug_994:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1060_done
    goto rxscan1060_scan
  rxscan1060_loop:
    (rx1055_pos) = rx1055_cur."from"()
    inc rx1055_pos
    rx1055_cur."!cursor_from"(rx1055_pos)
    ge rx1055_pos, rx1055_eos, rxscan1060_done
  rxscan1060_scan:
    set_addr $I10, rxscan1060_loop
    rx1055_cur."!mark_push"(0, rx1055_pos, $I10)
  rxscan1060_done:
  alt1061_0:
.annotate 'line', 403
    set_addr $I10, alt1061_1
    rx1055_cur."!mark_push"(0, rx1055_pos, $I10)
.annotate 'line', 404
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1055_cur."!cursor_pos"(rx1055_pos)
    $P10 = rx1055_cur."variable_declarator"()
    unless $P10, rx1055_fail
    rx1055_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1055_pos = $P10."pos"()
    goto alt1061_end
  alt1061_1:
.annotate 'line', 405
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1055_cur."!cursor_pos"(rx1055_pos)
    $P10 = rx1055_cur."routine_declarator"()
    unless $P10, rx1055_fail
    rx1055_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1055_pos = $P10."pos"()
  alt1061_end:
.annotate 'line', 403
  # rx pass
    rx1055_cur."!cursor_pass"(rx1055_pos, "declarator")
    if_null rx1055_debug, debug_995
    rx1055_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1055_pos)
  debug_995:
    .return (rx1055_cur)
  rx1055_restart:
.annotate 'line', 10
    if_null rx1055_debug, debug_996
    rx1055_cur."!cursor_debug"("NEXT", "declarator")
  debug_996:
  rx1055_fail:
    (rx1055_rep, rx1055_pos, $I10, $P10) = rx1055_cur."!mark_fail"(0)
    lt rx1055_pos, -1, rx1055_done
    eq rx1055_pos, -1, rx1055_fail
    jump $I10
  rx1055_done:
    rx1055_cur."!cursor_fail"()
    if_null rx1055_debug, debug_997
    rx1055_cur."!cursor_debug"("FAIL", "declarator")
  debug_997:
    .return (rx1055_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("168_1303748459.273") :method
.annotate 'line', 10
    $P1057 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1058 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1059, "ResizablePMCArray"
    push $P1059, $P1057
    push $P1059, $P1058
    .return ($P1059)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("169_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1063_tgt
    .local int rx1063_pos
    .local int rx1063_off
    .local int rx1063_eos
    .local int rx1063_rep
    .local pmc rx1063_cur
    .local pmc rx1063_debug
    (rx1063_cur, rx1063_pos, rx1063_tgt, $I10) = self."!cursor_start"()
    rx1063_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx1063_cur
    .local pmc match
    .lex "$/", match
    length rx1063_eos, rx1063_tgt
    gt rx1063_pos, rx1063_eos, rx1063_done
    set rx1063_off, 0
    lt rx1063_pos, 2, rx1063_start
    sub rx1063_off, rx1063_pos, 1
    substr rx1063_tgt, rx1063_tgt, rx1063_off
  rx1063_start:
    eq $I10, 1, rx1063_restart
    if_null rx1063_debug, debug_998
    rx1063_cur."!cursor_debug"("START", "variable_declarator")
  debug_998:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1067_done
    goto rxscan1067_scan
  rxscan1067_loop:
    (rx1063_pos) = rx1063_cur."from"()
    inc rx1063_pos
    rx1063_cur."!cursor_from"(rx1063_pos)
    ge rx1063_pos, rx1063_eos, rxscan1067_done
  rxscan1067_scan:
    set_addr $I10, rxscan1067_loop
    rx1063_cur."!mark_push"(0, rx1063_pos, $I10)
  rxscan1067_done:
.annotate 'line', 408
  # rx subrule "ws" subtype=method negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."ws"()
    unless $P10, rx1063_fail
    rx1063_pos = $P10."pos"()
  # rx rxquantr1069 ** 0..1
    set_addr $I10, rxquantr1069_done
    rx1063_cur."!mark_push"(0, rx1063_pos, $I10)
  rxquantr1069_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."typename"()
    unless $P10, rx1063_fail
    goto rxsubrule1070_pass
  rxsubrule1070_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1063_fail
  rxsubrule1070_pass:
    set_addr $I10, rxsubrule1070_back
    rx1063_cur."!mark_push"(0, rx1063_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1063_pos = $P10."pos"()
    set_addr $I10, rxquantr1069_done
    (rx1063_rep) = rx1063_cur."!mark_commit"($I10)
  rxquantr1069_done:
  # rx subrule "ws" subtype=method negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."ws"()
    unless $P10, rx1063_fail
    rx1063_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."variable"()
    unless $P10, rx1063_fail
    rx1063_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1063_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."ws"()
    unless $P10, rx1063_fail
    rx1063_pos = $P10."pos"()
  # rx pass
    rx1063_cur."!cursor_pass"(rx1063_pos, "variable_declarator")
    if_null rx1063_debug, debug_999
    rx1063_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1063_pos)
  debug_999:
    .return (rx1063_cur)
  rx1063_restart:
.annotate 'line', 10
    if_null rx1063_debug, debug_1000
    rx1063_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1000:
  rx1063_fail:
    (rx1063_rep, rx1063_pos, $I10, $P10) = rx1063_cur."!mark_fail"(0)
    lt rx1063_pos, -1, rx1063_done
    eq rx1063_pos, -1, rx1063_fail
    jump $I10
  rx1063_done:
    rx1063_cur."!cursor_fail"()
    if_null rx1063_debug, debug_1001
    rx1063_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1001:
    .return (rx1063_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("170_1303748459.273") :method
.annotate 'line', 10
    $P1065 = self."!PREFIX__!subrule"("ws", "")
    new $P1066, "ResizablePMCArray"
    push $P1066, $P1065
    .return ($P1066)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("171_1303748459.273")
    .param pmc param_1074
.annotate 'line', 410
    .lex "self", param_1074
    $P1075 = param_1074."!protoregex"("routine_declarator")
    .return ($P1075)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("172_1303748459.273")
    .param pmc param_1077
.annotate 'line', 410
    .lex "self", param_1077
    $P1078 = param_1077."!PREFIX__!protoregex"("routine_declarator")
    .return ($P1078)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("173_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1080_tgt
    .local int rx1080_pos
    .local int rx1080_off
    .local int rx1080_eos
    .local int rx1080_rep
    .local pmc rx1080_cur
    .local pmc rx1080_debug
    (rx1080_cur, rx1080_pos, rx1080_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1080_cur
    .local pmc match
    .lex "$/", match
    length rx1080_eos, rx1080_tgt
    gt rx1080_pos, rx1080_eos, rx1080_done
    set rx1080_off, 0
    lt rx1080_pos, 2, rx1080_start
    sub rx1080_off, rx1080_pos, 1
    substr rx1080_tgt, rx1080_tgt, rx1080_off
  rx1080_start:
    eq $I10, 1, rx1080_restart
    if_null rx1080_debug, debug_1002
    rx1080_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1002:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1084_done
    goto rxscan1084_scan
  rxscan1084_loop:
    (rx1080_pos) = rx1080_cur."from"()
    inc rx1080_pos
    rx1080_cur."!cursor_from"(rx1080_pos)
    ge rx1080_pos, rx1080_eos, rxscan1084_done
  rxscan1084_scan:
    set_addr $I10, rxscan1084_loop
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxscan1084_done:
.annotate 'line', 411
  # rx subcapture "sym"
    set_addr $I10, rxcap_1085_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1080_pos, 3
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 3
    ne $S10, "sub", rx1080_fail
    add rx1080_pos, 3
    set_addr $I10, rxcap_1085_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1085_done
  rxcap_1085_fail:
    goto rx1080_fail
  rxcap_1085_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."routine_def"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1080_pos = $P10."pos"()
  # rx pass
    rx1080_cur."!cursor_pass"(rx1080_pos, "routine_declarator:sym<sub>")
    if_null rx1080_debug, debug_1003
    rx1080_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1080_pos)
  debug_1003:
    .return (rx1080_cur)
  rx1080_restart:
.annotate 'line', 10
    if_null rx1080_debug, debug_1004
    rx1080_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1004:
  rx1080_fail:
    (rx1080_rep, rx1080_pos, $I10, $P10) = rx1080_cur."!mark_fail"(0)
    lt rx1080_pos, -1, rx1080_done
    eq rx1080_pos, -1, rx1080_fail
    jump $I10
  rx1080_done:
    rx1080_cur."!cursor_fail"()
    if_null rx1080_debug, debug_1005
    rx1080_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1005:
    .return (rx1080_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("174_1303748459.273") :method
.annotate 'line', 10
    $P1082 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P1083, "ResizablePMCArray"
    push $P1083, $P1082
    .return ($P1083)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("175_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1087_tgt
    .local int rx1087_pos
    .local int rx1087_off
    .local int rx1087_eos
    .local int rx1087_rep
    .local pmc rx1087_cur
    .local pmc rx1087_debug
    (rx1087_cur, rx1087_pos, rx1087_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1087_cur
    .local pmc match
    .lex "$/", match
    length rx1087_eos, rx1087_tgt
    gt rx1087_pos, rx1087_eos, rx1087_done
    set rx1087_off, 0
    lt rx1087_pos, 2, rx1087_start
    sub rx1087_off, rx1087_pos, 1
    substr rx1087_tgt, rx1087_tgt, rx1087_off
  rx1087_start:
    eq $I10, 1, rx1087_restart
    if_null rx1087_debug, debug_1006
    rx1087_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1006:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1091_done
    goto rxscan1091_scan
  rxscan1091_loop:
    (rx1087_pos) = rx1087_cur."from"()
    inc rx1087_pos
    rx1087_cur."!cursor_from"(rx1087_pos)
    ge rx1087_pos, rx1087_eos, rxscan1091_done
  rxscan1091_scan:
    set_addr $I10, rxscan1091_loop
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
  rxscan1091_done:
.annotate 'line', 412
  # rx subcapture "sym"
    set_addr $I10, rxcap_1092_fail
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
  # rx literal  "method"
    add $I11, rx1087_pos, 6
    gt $I11, rx1087_eos, rx1087_fail
    sub $I11, rx1087_pos, rx1087_off
    substr $S10, rx1087_tgt, $I11, 6
    ne $S10, "method", rx1087_fail
    add rx1087_pos, 6
    set_addr $I10, rxcap_1092_fail
    ($I12, $I11) = rx1087_cur."!mark_peek"($I10)
    rx1087_cur."!cursor_pos"($I11)
    ($P10) = rx1087_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1087_pos, "")
    rx1087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1092_done
  rxcap_1092_fail:
    goto rx1087_fail
  rxcap_1092_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1087_cur."!cursor_pos"(rx1087_pos)
    $P10 = rx1087_cur."method_def"()
    unless $P10, rx1087_fail
    rx1087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1087_pos = $P10."pos"()
  # rx pass
    rx1087_cur."!cursor_pass"(rx1087_pos, "routine_declarator:sym<method>")
    if_null rx1087_debug, debug_1007
    rx1087_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1087_pos)
  debug_1007:
    .return (rx1087_cur)
  rx1087_restart:
.annotate 'line', 10
    if_null rx1087_debug, debug_1008
    rx1087_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1008:
  rx1087_fail:
    (rx1087_rep, rx1087_pos, $I10, $P10) = rx1087_cur."!mark_fail"(0)
    lt rx1087_pos, -1, rx1087_done
    eq rx1087_pos, -1, rx1087_fail
    jump $I10
  rx1087_done:
    rx1087_cur."!cursor_fail"()
    if_null rx1087_debug, debug_1009
    rx1087_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1009:
    .return (rx1087_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("176_1303748459.273") :method
.annotate 'line', 10
    $P1089 = self."!PREFIX__!subrule"("method_def", "method")
    new $P1090, "ResizablePMCArray"
    push $P1090, $P1089
    .return ($P1090)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("177_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 415
    new $P1094, "Undef"
    .lex "$*RETURN_USED", $P1094
.annotate 'line', 10
    .local string rx1095_tgt
    .local int rx1095_pos
    .local int rx1095_off
    .local int rx1095_eos
    .local int rx1095_rep
    .local pmc rx1095_cur
    .local pmc rx1095_debug
    (rx1095_cur, rx1095_pos, rx1095_tgt, $I10) = self."!cursor_start"()
    rx1095_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1095_cur
    .local pmc match
    .lex "$/", match
    length rx1095_eos, rx1095_tgt
    gt rx1095_pos, rx1095_eos, rx1095_done
    set rx1095_off, 0
    lt rx1095_pos, 2, rx1095_start
    sub rx1095_off, rx1095_pos, 1
    substr rx1095_tgt, rx1095_tgt, rx1095_off
  rx1095_start:
    eq $I10, 1, rx1095_restart
    if_null rx1095_debug, debug_1010
    rx1095_cur."!cursor_debug"("START", "routine_def")
  debug_1010:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1099_done
    goto rxscan1099_scan
  rxscan1099_loop:
    (rx1095_pos) = rx1095_cur."from"()
    inc rx1095_pos
    rx1095_cur."!cursor_from"(rx1095_pos)
    ge rx1095_pos, rx1095_eos, rxscan1099_done
  rxscan1099_scan:
    set_addr $I10, rxscan1099_loop
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxscan1099_done:
.annotate 'line', 414
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 415
    rx1095_cur."!cursor_pos"(rx1095_pos)
    new $P1101, "Integer"
    assign $P1101, 0
    store_lex "$*RETURN_USED", $P1101
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 416
  # rx rxquantr1103 ** 0..1
    set_addr $I10, rxquantr1103_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1103_loop:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1106_fail
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  # rx rxquantr1105 ** 0..1
    set_addr $I10, rxquantr1105_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1105_loop:
  # rx literal  "&"
    add $I11, rx1095_pos, 1
    gt $I11, rx1095_eos, rx1095_fail
    sub $I11, rx1095_pos, rx1095_off
    ord $I11, rx1095_tgt, $I11
    ne $I11, 38, rx1095_fail
    add rx1095_pos, 1
    set_addr $I10, rxquantr1105_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
  rxquantr1105_done:
    set_addr $I10, rxcap_1106_fail
    ($I12, $I11) = rx1095_cur."!mark_peek"($I10)
    rx1095_cur."!cursor_pos"($I11)
    ($P10) = rx1095_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1095_pos, "")
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1106_done
  rxcap_1106_fail:
    goto rx1095_fail
  rxcap_1106_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."deflongname"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
    set_addr $I10, rxquantr1103_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
  rxquantr1103_done:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 417
  # rx subrule "newpad" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."newpad"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1110_0:
.annotate 'line', 418
    set_addr $I10, alt1110_1
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1095_pos, 1
    gt $I11, rx1095_eos, rx1095_fail
    sub $I11, rx1095_pos, rx1095_off
    ord $I11, rx1095_tgt, $I11
    ne $I11, 40, rx1095_fail
    add rx1095_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."signature"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1095_pos, 1
    gt $I11, rx1095_eos, rx1095_fail
    sub $I11, rx1095_pos, rx1095_off
    ord $I11, rx1095_tgt, $I11
    ne $I11, 41, rx1095_fail
    add rx1095_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
    goto alt1110_end
  alt1110_1:
.annotate 'line', 419
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1110_end:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 420
  # rx rxquantr1118 ** 0..*
    set_addr $I10, rxquantr1118_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1118_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."trait"()
    unless $P10, rx1095_fail
    goto rxsubrule1119_pass
  rxsubrule1119_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1095_fail
  rxsubrule1119_pass:
    set_addr $I10, rxsubrule1119_back
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1095_pos = $P10."pos"()
    set_addr $I10, rxquantr1118_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1118_done
    rx1095_cur."!mark_push"(rx1095_rep, rx1095_pos, $I10)
    goto rxquantr1118_loop
  rxquantr1118_done:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1121_0:
.annotate 'line', 421
    set_addr $I10, alt1121_1
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
.annotate 'line', 422
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."onlystar"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
    goto alt1121_end
  alt1121_1:
.annotate 'line', 423
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."blockoid"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1121_end:
.annotate 'line', 424
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 414
  # rx pass
    rx1095_cur."!cursor_pass"(rx1095_pos, "routine_def")
    if_null rx1095_debug, debug_1011
    rx1095_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1095_pos)
  debug_1011:
    .return (rx1095_cur)
  rx1095_restart:
.annotate 'line', 10
    if_null rx1095_debug, debug_1012
    rx1095_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1012:
  rx1095_fail:
    (rx1095_rep, rx1095_pos, $I10, $P10) = rx1095_cur."!mark_fail"(0)
    lt rx1095_pos, -1, rx1095_done
    eq rx1095_pos, -1, rx1095_fail
    jump $I10
  rx1095_done:
    rx1095_cur."!cursor_fail"()
    if_null rx1095_debug, debug_1013
    rx1095_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1013:
    .return (rx1095_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("178_1303748459.273") :method
.annotate 'line', 10
    $P1097 = self."!PREFIX__!subrule"("ws", "")
    new $P1098, "ResizablePMCArray"
    push $P1098, $P1097
    .return ($P1098)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("179_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P1158 = "181_1303748459.273" 
    capture_lex $P1158
.annotate 'line', 428
    new $P1128, "Undef"
    .lex "$*RETURN_USED", $P1128
.annotate 'line', 429
    new $P1129, "Undef"
    .lex "$*INVOCANT_OK", $P1129
.annotate 'line', 10
    .local string rx1130_tgt
    .local int rx1130_pos
    .local int rx1130_off
    .local int rx1130_eos
    .local int rx1130_rep
    .local pmc rx1130_cur
    .local pmc rx1130_debug
    (rx1130_cur, rx1130_pos, rx1130_tgt, $I10) = self."!cursor_start"()
    rx1130_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1130_cur
    .local pmc match
    .lex "$/", match
    length rx1130_eos, rx1130_tgt
    gt rx1130_pos, rx1130_eos, rx1130_done
    set rx1130_off, 0
    lt rx1130_pos, 2, rx1130_start
    sub rx1130_off, rx1130_pos, 1
    substr rx1130_tgt, rx1130_tgt, rx1130_off
  rx1130_start:
    eq $I10, 1, rx1130_restart
    if_null rx1130_debug, debug_1014
    rx1130_cur."!cursor_debug"("START", "method_def")
  debug_1014:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1134_done
    goto rxscan1134_scan
  rxscan1134_loop:
    (rx1130_pos) = rx1130_cur."from"()
    inc rx1130_pos
    rx1130_cur."!cursor_from"(rx1130_pos)
    ge rx1130_pos, rx1130_eos, rxscan1134_done
  rxscan1134_scan:
    set_addr $I10, rxscan1134_loop
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxscan1134_done:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 428
    rx1130_cur."!cursor_pos"(rx1130_pos)
    new $P1136, "Integer"
    assign $P1136, 0
    store_lex "$*RETURN_USED", $P1136
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 429
    rx1130_cur."!cursor_pos"(rx1130_pos)
    new $P1138, "Integer"
    assign $P1138, 1
    store_lex "$*INVOCANT_OK", $P1138
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 430
  # rx subcapture "private"
    set_addr $I10, rxcap_1141_fail
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  # rx rxquantr1140 ** 0..1
    set_addr $I10, rxquantr1140_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1140_loop:
  # rx literal  "!"
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 33, rx1130_fail
    add rx1130_pos, 1
    set_addr $I10, rxquantr1140_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
  rxquantr1140_done:
    set_addr $I10, rxcap_1141_fail
    ($I12, $I11) = rx1130_cur."!mark_peek"($I10)
    rx1130_cur."!cursor_pos"($I11)
    ($P10) = rx1130_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1130_pos, "")
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1141_done
  rxcap_1141_fail:
    goto rx1130_fail
  rxcap_1141_done:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 431
  # rx rxquantr1143 ** 0..1
    set_addr $I10, rxquantr1143_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1143_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."deflongname"()
    unless $P10, rx1130_fail
    goto rxsubrule1144_pass
  rxsubrule1144_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1130_fail
  rxsubrule1144_pass:
    set_addr $I10, rxsubrule1144_back
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1130_pos = $P10."pos"()
    set_addr $I10, rxquantr1143_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
  rxquantr1143_done:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 432
  # rx subrule "newpad" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."newpad"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1147_0:
.annotate 'line', 433
    set_addr $I10, alt1147_1
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 40, rx1130_fail
    add rx1130_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."signature"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 41, rx1130_fail
    add rx1130_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
    goto alt1147_end
  alt1147_1:
.annotate 'line', 434
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1147_end:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 435
    rx1130_cur."!cursor_pos"(rx1130_pos)
    find_lex $P1155, unicode:"$\x{a2}"
    $P1156 = $P1155."MATCH"()
    store_lex "$/", $P1156
    .const 'Sub' $P1158 = "181_1303748459.273" 
    capture_lex $P1158
    $P1160 = $P1158()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 436
  # rx rxquantr1162 ** 0..*
    set_addr $I10, rxquantr1162_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1162_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."trait"()
    unless $P10, rx1130_fail
    goto rxsubrule1163_pass
  rxsubrule1163_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1130_fail
  rxsubrule1163_pass:
    set_addr $I10, rxsubrule1163_back
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1130_pos = $P10."pos"()
    set_addr $I10, rxquantr1162_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1162_done
    rx1130_cur."!mark_push"(rx1130_rep, rx1130_pos, $I10)
    goto rxquantr1162_loop
  rxquantr1162_done:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1165_0:
.annotate 'line', 437
    set_addr $I10, alt1165_1
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
.annotate 'line', 438
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."onlystar"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
    goto alt1165_end
  alt1165_1:
.annotate 'line', 439
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."blockoid"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1165_end:
.annotate 'line', 440
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 427
  # rx pass
    rx1130_cur."!cursor_pass"(rx1130_pos, "method_def")
    if_null rx1130_debug, debug_1015
    rx1130_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1130_pos)
  debug_1015:
    .return (rx1130_cur)
  rx1130_restart:
.annotate 'line', 10
    if_null rx1130_debug, debug_1016
    rx1130_cur."!cursor_debug"("NEXT", "method_def")
  debug_1016:
  rx1130_fail:
    (rx1130_rep, rx1130_pos, $I10, $P10) = rx1130_cur."!mark_fail"(0)
    lt rx1130_pos, -1, rx1130_done
    eq rx1130_pos, -1, rx1130_fail
    jump $I10
  rx1130_done:
    rx1130_cur."!cursor_fail"()
    if_null rx1130_debug, debug_1017
    rx1130_cur."!cursor_debug"("FAIL", "method_def")
  debug_1017:
    .return (rx1130_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("180_1303748459.273") :method
.annotate 'line', 10
    $P1132 = self."!PREFIX__!subrule"("ws", "")
    new $P1133, "ResizablePMCArray"
    push $P1133, $P1132
    .return ($P1133)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1157"  :anon :subid("181_1303748459.273") :outer("179_1303748459.273")
.annotate 'line', 435
    new $P1159, "Integer"
    assign $P1159, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1159
    .return ($P1159)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("182_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P1179 = "184_1303748459.273" 
    capture_lex $P1179
    .local string rx1172_tgt
    .local int rx1172_pos
    .local int rx1172_off
    .local int rx1172_eos
    .local int rx1172_rep
    .local pmc rx1172_cur
    .local pmc rx1172_debug
    (rx1172_cur, rx1172_pos, rx1172_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1172_cur
    .local pmc match
    .lex "$/", match
    length rx1172_eos, rx1172_tgt
    gt rx1172_pos, rx1172_eos, rx1172_done
    set rx1172_off, 0
    lt rx1172_pos, 2, rx1172_start
    sub rx1172_off, rx1172_pos, 1
    substr rx1172_tgt, rx1172_tgt, rx1172_off
  rx1172_start:
    eq $I10, 1, rx1172_restart
    if_null rx1172_debug, debug_1018
    rx1172_cur."!cursor_debug"("START", "onlystar")
  debug_1018:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1175_done
    goto rxscan1175_scan
  rxscan1175_loop:
    (rx1172_pos) = rx1172_cur."from"()
    inc rx1172_pos
    rx1172_cur."!cursor_from"(rx1172_pos)
    ge rx1172_pos, rx1172_eos, rxscan1175_done
  rxscan1175_scan:
    set_addr $I10, rxscan1175_loop
    rx1172_cur."!mark_push"(0, rx1172_pos, $I10)
  rxscan1175_done:
.annotate 'line', 444
    rx1172_cur."!cursor_pos"(rx1172_pos)
    find_lex $P1176, unicode:"$\x{a2}"
    $P1177 = $P1176."MATCH"()
    store_lex "$/", $P1177
    .const 'Sub' $P1179 = "184_1303748459.273" 
    capture_lex $P1179
    $P1185 = $P1179()
    unless $P1185, rx1172_fail
.annotate 'line', 445
  # rx literal  "{"
    add $I11, rx1172_pos, 1
    gt $I11, rx1172_eos, rx1172_fail
    sub $I11, rx1172_pos, rx1172_off
    ord $I11, rx1172_tgt, $I11
    ne $I11, 123, rx1172_fail
    add rx1172_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."ws"()
    unless $P10, rx1172_fail
    rx1172_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1172_pos, 1
    gt $I11, rx1172_eos, rx1172_fail
    sub $I11, rx1172_pos, rx1172_off
    ord $I11, rx1172_tgt, $I11
    ne $I11, 42, rx1172_fail
    add rx1172_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."ws"()
    unless $P10, rx1172_fail
    rx1172_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1172_pos, 1
    gt $I11, rx1172_eos, rx1172_fail
    sub $I11, rx1172_pos, rx1172_off
    ord $I11, rx1172_tgt, $I11
    ne $I11, 125, rx1172_fail
    add rx1172_pos, 1
.annotate 'line', 446
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."ENDSTMT"()
    unless $P10, rx1172_fail
.annotate 'line', 447
  # rx subrule "finishpad" subtype=method negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."finishpad"()
    unless $P10, rx1172_fail
    rx1172_pos = $P10."pos"()
.annotate 'line', 443
  # rx pass
    rx1172_cur."!cursor_pass"(rx1172_pos, "onlystar")
    if_null rx1172_debug, debug_1021
    rx1172_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1172_pos)
  debug_1021:
    .return (rx1172_cur)
  rx1172_restart:
.annotate 'line', 10
    if_null rx1172_debug, debug_1022
    rx1172_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1022:
  rx1172_fail:
    (rx1172_rep, rx1172_pos, $I10, $P10) = rx1172_cur."!mark_fail"(0)
    lt rx1172_pos, -1, rx1172_done
    eq rx1172_pos, -1, rx1172_fail
    jump $I10
  rx1172_done:
    rx1172_cur."!cursor_fail"()
    if_null rx1172_debug, debug_1023
    rx1172_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1023:
    .return (rx1172_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("183_1303748459.273") :method
.annotate 'line', 10
    new $P1174, "ResizablePMCArray"
    push $P1174, ""
    .return ($P1174)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1178"  :anon :subid("184_1303748459.273") :outer("182_1303748459.273")
.annotate 'line', 444
    find_dynamic_lex $P1182, "$*MULTINESS"
    unless_null $P1182, vivify_1019
    get_hll_global $P1180, "GLOBAL"
    get_who $P1181, $P1180
    set $P1182, $P1181["$MULTINESS"]
    unless_null $P1182, vivify_1020
    die "Contextual $*MULTINESS not found"
  vivify_1020:
  vivify_1019:
    set $S1183, $P1182
    iseq $I1184, $S1183, "proto"
    .return ($I1184)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("185_1303748459.273")
    .param pmc param_1187
.annotate 'line', 450
    .lex "self", param_1187
    $P1188 = param_1187."!protoregex"("multi_declarator")
    .return ($P1188)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("186_1303748459.273")
    .param pmc param_1190
.annotate 'line', 450
    .lex "self", param_1190
    $P1191 = param_1190."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1191)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("187_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 452
    new $P1193, "Undef"
    .lex "$*MULTINESS", $P1193
.annotate 'line', 10
    .local string rx1194_tgt
    .local int rx1194_pos
    .local int rx1194_off
    .local int rx1194_eos
    .local int rx1194_rep
    .local pmc rx1194_cur
    .local pmc rx1194_debug
    (rx1194_cur, rx1194_pos, rx1194_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1194_cur
    .local pmc match
    .lex "$/", match
    length rx1194_eos, rx1194_tgt
    gt rx1194_pos, rx1194_eos, rx1194_done
    set rx1194_off, 0
    lt rx1194_pos, 2, rx1194_start
    sub rx1194_off, rx1194_pos, 1
    substr rx1194_tgt, rx1194_tgt, rx1194_off
  rx1194_start:
    eq $I10, 1, rx1194_restart
    if_null rx1194_debug, debug_1024
    rx1194_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1024:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1198_done
    goto rxscan1198_scan
  rxscan1198_loop:
    (rx1194_pos) = rx1194_cur."from"()
    inc rx1194_pos
    rx1194_cur."!cursor_from"(rx1194_pos)
    ge rx1194_pos, rx1194_eos, rxscan1198_done
  rxscan1198_scan:
    set_addr $I10, rxscan1198_loop
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  rxscan1198_done:
.annotate 'line', 452
    rx1194_cur."!cursor_pos"(rx1194_pos)
    new $P1199, "String"
    assign $P1199, "multi"
    store_lex "$*MULTINESS", $P1199
.annotate 'line', 453
  # rx subcapture "sym"
    set_addr $I10, rxcap_1200_fail
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1194_pos, 5
    gt $I11, rx1194_eos, rx1194_fail
    sub $I11, rx1194_pos, rx1194_off
    substr $S10, rx1194_tgt, $I11, 5
    ne $S10, "multi", rx1194_fail
    add rx1194_pos, 5
    set_addr $I10, rxcap_1200_fail
    ($I12, $I11) = rx1194_cur."!mark_peek"($I10)
    rx1194_cur."!cursor_pos"($I11)
    ($P10) = rx1194_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1194_pos, "")
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1200_done
  rxcap_1200_fail:
    goto rx1194_fail
  rxcap_1200_done:
.annotate 'line', 454
  # rx subrule "ws" subtype=method negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."ws"()
    unless $P10, rx1194_fail
    rx1194_pos = $P10."pos"()
  alt1201_0:
    set_addr $I10, alt1201_1
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."declarator"()
    unless $P10, rx1194_fail
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1194_pos = $P10."pos"()
    goto alt1201_end
  alt1201_1:
    set_addr $I10, alt1201_2
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."routine_def"()
    unless $P10, rx1194_fail
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1194_pos = $P10."pos"()
    goto alt1201_end
  alt1201_2:
  # rx subrule "panic" subtype=method negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."panic"("Malformed multi")
    unless $P10, rx1194_fail
    rx1194_pos = $P10."pos"()
  alt1201_end:
.annotate 'line', 451
  # rx pass
    rx1194_cur."!cursor_pass"(rx1194_pos, "multi_declarator:sym<multi>")
    if_null rx1194_debug, debug_1025
    rx1194_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1194_pos)
  debug_1025:
    .return (rx1194_cur)
  rx1194_restart:
.annotate 'line', 10
    if_null rx1194_debug, debug_1026
    rx1194_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1026:
  rx1194_fail:
    (rx1194_rep, rx1194_pos, $I10, $P10) = rx1194_cur."!mark_fail"(0)
    lt rx1194_pos, -1, rx1194_done
    eq rx1194_pos, -1, rx1194_fail
    jump $I10
  rx1194_done:
    rx1194_cur."!cursor_fail"()
    if_null rx1194_debug, debug_1027
    rx1194_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1027:
    .return (rx1194_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("188_1303748459.273") :method
.annotate 'line', 10
    $P1196 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1197, "ResizablePMCArray"
    push $P1197, $P1196
    .return ($P1197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("189_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 457
    new $P1203, "Undef"
    .lex "$*MULTINESS", $P1203
.annotate 'line', 10
    .local string rx1204_tgt
    .local int rx1204_pos
    .local int rx1204_off
    .local int rx1204_eos
    .local int rx1204_rep
    .local pmc rx1204_cur
    .local pmc rx1204_debug
    (rx1204_cur, rx1204_pos, rx1204_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1204_cur
    .local pmc match
    .lex "$/", match
    length rx1204_eos, rx1204_tgt
    gt rx1204_pos, rx1204_eos, rx1204_done
    set rx1204_off, 0
    lt rx1204_pos, 2, rx1204_start
    sub rx1204_off, rx1204_pos, 1
    substr rx1204_tgt, rx1204_tgt, rx1204_off
  rx1204_start:
    eq $I10, 1, rx1204_restart
    if_null rx1204_debug, debug_1028
    rx1204_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1028:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1208_done
    goto rxscan1208_scan
  rxscan1208_loop:
    (rx1204_pos) = rx1204_cur."from"()
    inc rx1204_pos
    rx1204_cur."!cursor_from"(rx1204_pos)
    ge rx1204_pos, rx1204_eos, rxscan1208_done
  rxscan1208_scan:
    set_addr $I10, rxscan1208_loop
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  rxscan1208_done:
.annotate 'line', 457
    rx1204_cur."!cursor_pos"(rx1204_pos)
    new $P1209, "String"
    assign $P1209, "proto"
    store_lex "$*MULTINESS", $P1209
.annotate 'line', 458
  # rx subcapture "sym"
    set_addr $I10, rxcap_1210_fail
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1204_pos, 5
    gt $I11, rx1204_eos, rx1204_fail
    sub $I11, rx1204_pos, rx1204_off
    substr $S10, rx1204_tgt, $I11, 5
    ne $S10, "proto", rx1204_fail
    add rx1204_pos, 5
    set_addr $I10, rxcap_1210_fail
    ($I12, $I11) = rx1204_cur."!mark_peek"($I10)
    rx1204_cur."!cursor_pos"($I11)
    ($P10) = rx1204_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1204_pos, "")
    rx1204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1210_done
  rxcap_1210_fail:
    goto rx1204_fail
  rxcap_1210_done:
.annotate 'line', 459
  # rx subrule "ws" subtype=method negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."ws"()
    unless $P10, rx1204_fail
    rx1204_pos = $P10."pos"()
  alt1211_0:
    set_addr $I10, alt1211_1
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."declarator"()
    unless $P10, rx1204_fail
    rx1204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1204_pos = $P10."pos"()
    goto alt1211_end
  alt1211_1:
    set_addr $I10, alt1211_2
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."routine_def"()
    unless $P10, rx1204_fail
    rx1204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1204_pos = $P10."pos"()
    goto alt1211_end
  alt1211_2:
  # rx subrule "panic" subtype=method negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."panic"("Malformed proto")
    unless $P10, rx1204_fail
    rx1204_pos = $P10."pos"()
  alt1211_end:
.annotate 'line', 456
  # rx pass
    rx1204_cur."!cursor_pass"(rx1204_pos, "multi_declarator:sym<proto>")
    if_null rx1204_debug, debug_1029
    rx1204_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1204_pos)
  debug_1029:
    .return (rx1204_cur)
  rx1204_restart:
.annotate 'line', 10
    if_null rx1204_debug, debug_1030
    rx1204_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1030:
  rx1204_fail:
    (rx1204_rep, rx1204_pos, $I10, $P10) = rx1204_cur."!mark_fail"(0)
    lt rx1204_pos, -1, rx1204_done
    eq rx1204_pos, -1, rx1204_fail
    jump $I10
  rx1204_done:
    rx1204_cur."!cursor_fail"()
    if_null rx1204_debug, debug_1031
    rx1204_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1031:
    .return (rx1204_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("190_1303748459.273") :method
.annotate 'line', 10
    $P1206 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1207, "ResizablePMCArray"
    push $P1207, $P1206
    .return ($P1207)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("191_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 462
    new $P1213, "Undef"
    .lex "$*MULTINESS", $P1213
.annotate 'line', 10
    .local string rx1214_tgt
    .local int rx1214_pos
    .local int rx1214_off
    .local int rx1214_eos
    .local int rx1214_rep
    .local pmc rx1214_cur
    .local pmc rx1214_debug
    (rx1214_cur, rx1214_pos, rx1214_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1214_cur
    .local pmc match
    .lex "$/", match
    length rx1214_eos, rx1214_tgt
    gt rx1214_pos, rx1214_eos, rx1214_done
    set rx1214_off, 0
    lt rx1214_pos, 2, rx1214_start
    sub rx1214_off, rx1214_pos, 1
    substr rx1214_tgt, rx1214_tgt, rx1214_off
  rx1214_start:
    eq $I10, 1, rx1214_restart
    if_null rx1214_debug, debug_1032
    rx1214_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1032:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1218_done
    goto rxscan1218_scan
  rxscan1218_loop:
    (rx1214_pos) = rx1214_cur."from"()
    inc rx1214_pos
    rx1214_cur."!cursor_from"(rx1214_pos)
    ge rx1214_pos, rx1214_eos, rxscan1218_done
  rxscan1218_scan:
    set_addr $I10, rxscan1218_loop
    rx1214_cur."!mark_push"(0, rx1214_pos, $I10)
  rxscan1218_done:
.annotate 'line', 462
    rx1214_cur."!cursor_pos"(rx1214_pos)
    new $P1219, "String"
    assign $P1219, ""
    store_lex "$*MULTINESS", $P1219
.annotate 'line', 463
  # rx subrule "declarator" subtype=capture negate=
    rx1214_cur."!cursor_pos"(rx1214_pos)
    $P10 = rx1214_cur."declarator"()
    unless $P10, rx1214_fail
    rx1214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1214_pos = $P10."pos"()
.annotate 'line', 461
  # rx pass
    rx1214_cur."!cursor_pass"(rx1214_pos, "multi_declarator:sym<null>")
    if_null rx1214_debug, debug_1033
    rx1214_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1214_pos)
  debug_1033:
    .return (rx1214_cur)
  rx1214_restart:
.annotate 'line', 10
    if_null rx1214_debug, debug_1034
    rx1214_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1034:
  rx1214_fail:
    (rx1214_rep, rx1214_pos, $I10, $P10) = rx1214_cur."!mark_fail"(0)
    lt rx1214_pos, -1, rx1214_done
    eq rx1214_pos, -1, rx1214_fail
    jump $I10
  rx1214_done:
    rx1214_cur."!cursor_fail"()
    if_null rx1214_debug, debug_1035
    rx1214_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1035:
    .return (rx1214_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("192_1303748459.273") :method
.annotate 'line', 10
    $P1216 = self."!PREFIX__!subrule"("declarator", "")
    new $P1217, "ResizablePMCArray"
    push $P1217, $P1216
    .return ($P1217)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("193_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P1229 = "195_1303748459.273" 
    capture_lex $P1229
    .local string rx1221_tgt
    .local int rx1221_pos
    .local int rx1221_off
    .local int rx1221_eos
    .local int rx1221_rep
    .local pmc rx1221_cur
    .local pmc rx1221_debug
    (rx1221_cur, rx1221_pos, rx1221_tgt, $I10) = self."!cursor_start"()
    rx1221_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1221_cur
    .local pmc match
    .lex "$/", match
    length rx1221_eos, rx1221_tgt
    gt rx1221_pos, rx1221_eos, rx1221_done
    set rx1221_off, 0
    lt rx1221_pos, 2, rx1221_start
    sub rx1221_off, rx1221_pos, 1
    substr rx1221_tgt, rx1221_tgt, rx1221_off
  rx1221_start:
    eq $I10, 1, rx1221_restart
    if_null rx1221_debug, debug_1036
    rx1221_cur."!cursor_debug"("START", "signature")
  debug_1036:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1221_pos) = rx1221_cur."from"()
    inc rx1221_pos
    rx1221_cur."!cursor_from"(rx1221_pos)
    ge rx1221_pos, rx1221_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxscan1224_done:
.annotate 'line', 467
  # rx rxquantr1225 ** 0..1
    set_addr $I10, rxquantr1225_done
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxquantr1225_loop:
    rx1221_cur."!cursor_pos"(rx1221_pos)
    find_lex $P1226, unicode:"$\x{a2}"
    $P1227 = $P1226."MATCH"()
    store_lex "$/", $P1227
    .const 'Sub' $P1229 = "195_1303748459.273" 
    capture_lex $P1229
    $P1233 = $P1229()
    unless $P1233, rx1221_fail
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."parameter"()
    unless $P10, rx1221_fail
    rx1221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1221_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1221_pos, 1
    gt $I11, rx1221_eos, rx1221_fail
    sub $I11, rx1221_pos, rx1221_off
    ord $I11, rx1221_tgt, $I11
    ne $I11, 58, rx1221_fail
    add rx1221_pos, 1
    set_addr $I10, rxquantr1225_done
    (rx1221_rep) = rx1221_cur."!mark_commit"($I10)
  rxquantr1225_done:
.annotate 'line', 468
  # rx rxquantr1234 ** 0..1
    set_addr $I10, rxquantr1234_done
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxquantr1234_loop:
  # rx rxquantr1235 ** 1..*
    set_addr $I10, rxquantr1235_done
    rx1221_cur."!mark_push"(0, -1, $I10)
  rxquantr1235_loop:
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."parameter"()
    unless $P10, rx1221_fail
    rx1221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1221_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
    set_addr $I10, rxquantr1235_done
    (rx1221_rep) = rx1221_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1235_done
    rx1221_cur."!mark_push"(rx1221_rep, rx1221_pos, $I10)
  # rx literal  ","
    add $I11, rx1221_pos, 1
    gt $I11, rx1221_eos, rx1221_fail
    sub $I11, rx1221_pos, rx1221_off
    ord $I11, rx1221_tgt, $I11
    ne $I11, 44, rx1221_fail
    add rx1221_pos, 1
    goto rxquantr1235_loop
  rxquantr1235_done:
    set_addr $I10, rxquantr1234_done
    (rx1221_rep) = rx1221_cur."!mark_commit"($I10)
  rxquantr1234_done:
.annotate 'line', 466
  # rx pass
    rx1221_cur."!cursor_pass"(rx1221_pos, "signature")
    if_null rx1221_debug, debug_1039
    rx1221_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1221_pos)
  debug_1039:
    .return (rx1221_cur)
  rx1221_restart:
.annotate 'line', 10
    if_null rx1221_debug, debug_1040
    rx1221_cur."!cursor_debug"("NEXT", "signature")
  debug_1040:
  rx1221_fail:
    (rx1221_rep, rx1221_pos, $I10, $P10) = rx1221_cur."!mark_fail"(0)
    lt rx1221_pos, -1, rx1221_done
    eq rx1221_pos, -1, rx1221_fail
    jump $I10
  rx1221_done:
    rx1221_cur."!cursor_fail"()
    if_null rx1221_debug, debug_1041
    rx1221_cur."!cursor_debug"("FAIL", "signature")
  debug_1041:
    .return (rx1221_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("194_1303748459.273") :method
.annotate 'line', 10
    new $P1223, "ResizablePMCArray"
    push $P1223, ""
    .return ($P1223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1228"  :anon :subid("195_1303748459.273") :outer("193_1303748459.273")
.annotate 'line', 467
    find_dynamic_lex $P1232, "$*INVOCANT_OK"
    unless_null $P1232, vivify_1037
    get_hll_global $P1230, "GLOBAL"
    get_who $P1231, $P1230
    set $P1232, $P1231["$INVOCANT_OK"]
    unless_null $P1232, vivify_1038
    die "Contextual $*INVOCANT_OK not found"
  vivify_1038:
  vivify_1037:
    .return ($P1232)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("196_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1237_tgt
    .local int rx1237_pos
    .local int rx1237_off
    .local int rx1237_eos
    .local int rx1237_rep
    .local pmc rx1237_cur
    .local pmc rx1237_debug
    (rx1237_cur, rx1237_pos, rx1237_tgt, $I10) = self."!cursor_start"()
    rx1237_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1237_cur
    .local pmc match
    .lex "$/", match
    length rx1237_eos, rx1237_tgt
    gt rx1237_pos, rx1237_eos, rx1237_done
    set rx1237_off, 0
    lt rx1237_pos, 2, rx1237_start
    sub rx1237_off, rx1237_pos, 1
    substr rx1237_tgt, rx1237_tgt, rx1237_off
  rx1237_start:
    eq $I10, 1, rx1237_restart
    if_null rx1237_debug, debug_1042
    rx1237_cur."!cursor_debug"("START", "parameter")
  debug_1042:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1240_done
    goto rxscan1240_scan
  rxscan1240_loop:
    (rx1237_pos) = rx1237_cur."from"()
    inc rx1237_pos
    rx1237_cur."!cursor_from"(rx1237_pos)
    ge rx1237_pos, rx1237_eos, rxscan1240_done
  rxscan1240_scan:
    set_addr $I10, rxscan1240_loop
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxscan1240_done:
.annotate 'line', 472
  # rx rxquantr1241 ** 0..*
    set_addr $I10, rxquantr1241_done
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxquantr1241_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."typename"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1237_pos = $P10."pos"()
  # rx rxquantr1242 ** 0..1
    set_addr $I10, rxquantr1242_done
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxquantr1242_loop:
  # rx literal  ":"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 58, rx1237_fail
    add rx1237_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1243_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1237_pos, rx1237_eos, rx1237_fail
    sub $I10, rx1237_pos, rx1237_off
    substr $S10, rx1237_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1237_fail
    inc rx1237_pos
    set_addr $I10, rxcap_1243_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1243_done
  rxcap_1243_fail:
    goto rx1237_fail
  rxcap_1243_done:
    set_addr $I10, rxquantr1242_done
    (rx1237_rep) = rx1237_cur."!mark_commit"($I10)
  rxquantr1242_done:
  # rx subrule "ws" subtype=method negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."ws"()
    unless $P10, rx1237_fail
    rx1237_pos = $P10."pos"()
    set_addr $I10, rxquantr1241_done
    (rx1237_rep) = rx1237_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1241_done
    rx1237_cur."!mark_push"(rx1237_rep, rx1237_pos, $I10)
    goto rxquantr1241_loop
  rxquantr1241_done:
  alt1244_0:
.annotate 'line', 473
    set_addr $I10, alt1244_1
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
.annotate 'line', 474
  # rx subcapture "quant"
    set_addr $I10, rxcap_1245_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "*"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 42, rx1237_fail
    add rx1237_pos, 1
    set_addr $I10, rxcap_1245_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1245_done
  rxcap_1245_fail:
    goto rx1237_fail
  rxcap_1245_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."param_var"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1237_pos = $P10."pos"()
    goto alt1244_end
  alt1244_1:
  alt1246_0:
.annotate 'line', 475
    set_addr $I10, alt1246_1
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."param_var"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1237_pos = $P10."pos"()
    goto alt1246_end
  alt1246_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."named_param"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1237_pos = $P10."pos"()
  alt1246_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1248_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  alt1247_0:
    set_addr $I10, alt1247_1
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "?"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 63, rx1237_fail
    add rx1237_pos, 1
    goto alt1247_end
  alt1247_1:
    set_addr $I10, alt1247_2
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "!"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 33, rx1237_fail
    add rx1237_pos, 1
    goto alt1247_end
  alt1247_2:
  alt1247_end:
    set_addr $I10, rxcap_1248_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1248_done
  rxcap_1248_fail:
    goto rx1237_fail
  rxcap_1248_done:
  alt1244_end:
.annotate 'line', 477
  # rx rxquantr1249 ** 0..1
    set_addr $I10, rxquantr1249_done
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxquantr1249_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."default_value"()
    unless $P10, rx1237_fail
    goto rxsubrule1250_pass
  rxsubrule1250_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1237_fail
  rxsubrule1250_pass:
    set_addr $I10, rxsubrule1250_back
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1237_pos = $P10."pos"()
    set_addr $I10, rxquantr1249_done
    (rx1237_rep) = rx1237_cur."!mark_commit"($I10)
  rxquantr1249_done:
.annotate 'line', 471
  # rx pass
    rx1237_cur."!cursor_pass"(rx1237_pos, "parameter")
    if_null rx1237_debug, debug_1043
    rx1237_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1237_pos)
  debug_1043:
    .return (rx1237_cur)
  rx1237_restart:
.annotate 'line', 10
    if_null rx1237_debug, debug_1044
    rx1237_cur."!cursor_debug"("NEXT", "parameter")
  debug_1044:
  rx1237_fail:
    (rx1237_rep, rx1237_pos, $I10, $P10) = rx1237_cur."!mark_fail"(0)
    lt rx1237_pos, -1, rx1237_done
    eq rx1237_pos, -1, rx1237_fail
    jump $I10
  rx1237_done:
    rx1237_cur."!cursor_fail"()
    if_null rx1237_debug, debug_1045
    rx1237_cur."!cursor_debug"("FAIL", "parameter")
  debug_1045:
    .return (rx1237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("197_1303748459.273") :method
.annotate 'line', 10
    new $P1239, "ResizablePMCArray"
    push $P1239, ""
    .return ($P1239)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("198_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1252_tgt
    .local int rx1252_pos
    .local int rx1252_off
    .local int rx1252_eos
    .local int rx1252_rep
    .local pmc rx1252_cur
    .local pmc rx1252_debug
    (rx1252_cur, rx1252_pos, rx1252_tgt, $I10) = self."!cursor_start"()
    rx1252_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1252_cur
    .local pmc match
    .lex "$/", match
    length rx1252_eos, rx1252_tgt
    gt rx1252_pos, rx1252_eos, rx1252_done
    set rx1252_off, 0
    lt rx1252_pos, 2, rx1252_start
    sub rx1252_off, rx1252_pos, 1
    substr rx1252_tgt, rx1252_tgt, rx1252_off
  rx1252_start:
    eq $I10, 1, rx1252_restart
    if_null rx1252_debug, debug_1046
    rx1252_cur."!cursor_debug"("START", "param_var")
  debug_1046:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1256_done
    goto rxscan1256_scan
  rxscan1256_loop:
    (rx1252_pos) = rx1252_cur."from"()
    inc rx1252_pos
    rx1252_cur."!cursor_from"(rx1252_pos)
    ge rx1252_pos, rx1252_eos, rxscan1256_done
  rxscan1256_scan:
    set_addr $I10, rxscan1256_loop
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxscan1256_done:
.annotate 'line', 481
  # rx subrule "sigil" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."sigil"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1252_pos = $P10."pos"()
  # rx rxquantr1257 ** 0..1
    set_addr $I10, rxquantr1257_done
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxquantr1257_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."twigil"()
    unless $P10, rx1252_fail
    goto rxsubrule1258_pass
  rxsubrule1258_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1252_fail
  rxsubrule1258_pass:
    set_addr $I10, rxsubrule1258_back
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1252_pos = $P10."pos"()
    set_addr $I10, rxquantr1257_done
    (rx1252_rep) = rx1252_cur."!mark_commit"($I10)
  rxquantr1257_done:
  alt1259_0:
.annotate 'line', 482
    set_addr $I10, alt1259_1
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."ident"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1252_pos = $P10."pos"()
    goto alt1259_end
  alt1259_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1260_fail
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1252_pos, rx1252_eos, rx1252_fail
    sub $I10, rx1252_pos, rx1252_off
    substr $S10, rx1252_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1252_fail
    inc rx1252_pos
    set_addr $I10, rxcap_1260_fail
    ($I12, $I11) = rx1252_cur."!mark_peek"($I10)
    rx1252_cur."!cursor_pos"($I11)
    ($P10) = rx1252_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1252_pos, "")
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1260_done
  rxcap_1260_fail:
    goto rx1252_fail
  rxcap_1260_done:
  alt1259_end:
.annotate 'line', 480
  # rx pass
    rx1252_cur."!cursor_pass"(rx1252_pos, "param_var")
    if_null rx1252_debug, debug_1047
    rx1252_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1252_pos)
  debug_1047:
    .return (rx1252_cur)
  rx1252_restart:
.annotate 'line', 10
    if_null rx1252_debug, debug_1048
    rx1252_cur."!cursor_debug"("NEXT", "param_var")
  debug_1048:
  rx1252_fail:
    (rx1252_rep, rx1252_pos, $I10, $P10) = rx1252_cur."!mark_fail"(0)
    lt rx1252_pos, -1, rx1252_done
    eq rx1252_pos, -1, rx1252_fail
    jump $I10
  rx1252_done:
    rx1252_cur."!cursor_fail"()
    if_null rx1252_debug, debug_1049
    rx1252_cur."!cursor_debug"("FAIL", "param_var")
  debug_1049:
    .return (rx1252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("199_1303748459.273") :method
.annotate 'line', 10
    $P1254 = self."!PREFIX__!subrule"("sigil", "")
    new $P1255, "ResizablePMCArray"
    push $P1255, $P1254
    .return ($P1255)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("200_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1262_tgt
    .local int rx1262_pos
    .local int rx1262_off
    .local int rx1262_eos
    .local int rx1262_rep
    .local pmc rx1262_cur
    .local pmc rx1262_debug
    (rx1262_cur, rx1262_pos, rx1262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1262_cur
    .local pmc match
    .lex "$/", match
    length rx1262_eos, rx1262_tgt
    gt rx1262_pos, rx1262_eos, rx1262_done
    set rx1262_off, 0
    lt rx1262_pos, 2, rx1262_start
    sub rx1262_off, rx1262_pos, 1
    substr rx1262_tgt, rx1262_tgt, rx1262_off
  rx1262_start:
    eq $I10, 1, rx1262_restart
    if_null rx1262_debug, debug_1050
    rx1262_cur."!cursor_debug"("START", "named_param")
  debug_1050:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1266_done
    goto rxscan1266_scan
  rxscan1266_loop:
    (rx1262_pos) = rx1262_cur."from"()
    inc rx1262_pos
    rx1262_cur."!cursor_from"(rx1262_pos)
    ge rx1262_pos, rx1262_eos, rxscan1266_done
  rxscan1266_scan:
    set_addr $I10, rxscan1266_loop
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
  rxscan1266_done:
.annotate 'line', 486
  # rx literal  ":"
    add $I11, rx1262_pos, 1
    gt $I11, rx1262_eos, rx1262_fail
    sub $I11, rx1262_pos, rx1262_off
    ord $I11, rx1262_tgt, $I11
    ne $I11, 58, rx1262_fail
    add rx1262_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1262_cur."!cursor_pos"(rx1262_pos)
    $P10 = rx1262_cur."param_var"()
    unless $P10, rx1262_fail
    rx1262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1262_pos = $P10."pos"()
.annotate 'line', 485
  # rx pass
    rx1262_cur."!cursor_pass"(rx1262_pos, "named_param")
    if_null rx1262_debug, debug_1051
    rx1262_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1262_pos)
  debug_1051:
    .return (rx1262_cur)
  rx1262_restart:
.annotate 'line', 10
    if_null rx1262_debug, debug_1052
    rx1262_cur."!cursor_debug"("NEXT", "named_param")
  debug_1052:
  rx1262_fail:
    (rx1262_rep, rx1262_pos, $I10, $P10) = rx1262_cur."!mark_fail"(0)
    lt rx1262_pos, -1, rx1262_done
    eq rx1262_pos, -1, rx1262_fail
    jump $I10
  rx1262_done:
    rx1262_cur."!cursor_fail"()
    if_null rx1262_debug, debug_1053
    rx1262_cur."!cursor_debug"("FAIL", "named_param")
  debug_1053:
    .return (rx1262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("201_1303748459.273") :method
.annotate 'line', 10
    $P1264 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1265, "ResizablePMCArray"
    push $P1265, $P1264
    .return ($P1265)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("202_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1268_tgt
    .local int rx1268_pos
    .local int rx1268_off
    .local int rx1268_eos
    .local int rx1268_rep
    .local pmc rx1268_cur
    .local pmc rx1268_debug
    (rx1268_cur, rx1268_pos, rx1268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1268_cur
    .local pmc match
    .lex "$/", match
    length rx1268_eos, rx1268_tgt
    gt rx1268_pos, rx1268_eos, rx1268_done
    set rx1268_off, 0
    lt rx1268_pos, 2, rx1268_start
    sub rx1268_off, rx1268_pos, 1
    substr rx1268_tgt, rx1268_tgt, rx1268_off
  rx1268_start:
    eq $I10, 1, rx1268_restart
    if_null rx1268_debug, debug_1054
    rx1268_cur."!cursor_debug"("START", "default_value")
  debug_1054:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1272_done
    goto rxscan1272_scan
  rxscan1272_loop:
    (rx1268_pos) = rx1268_cur."from"()
    inc rx1268_pos
    rx1268_cur."!cursor_from"(rx1268_pos)
    ge rx1268_pos, rx1268_eos, rxscan1272_done
  rxscan1272_scan:
    set_addr $I10, rxscan1272_loop
    rx1268_cur."!mark_push"(0, rx1268_pos, $I10)
  rxscan1272_done:
.annotate 'line', 489
  # rx subrule "ws" subtype=method negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."ws"()
    unless $P10, rx1268_fail
    rx1268_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1268_pos, 1
    gt $I11, rx1268_eos, rx1268_fail
    sub $I11, rx1268_pos, rx1268_off
    ord $I11, rx1268_tgt, $I11
    ne $I11, 61, rx1268_fail
    add rx1268_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."ws"()
    unless $P10, rx1268_fail
    rx1268_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."EXPR"("i=")
    unless $P10, rx1268_fail
    rx1268_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1268_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."ws"()
    unless $P10, rx1268_fail
    rx1268_pos = $P10."pos"()
  # rx pass
    rx1268_cur."!cursor_pass"(rx1268_pos, "default_value")
    if_null rx1268_debug, debug_1055
    rx1268_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1268_pos)
  debug_1055:
    .return (rx1268_cur)
  rx1268_restart:
.annotate 'line', 10
    if_null rx1268_debug, debug_1056
    rx1268_cur."!cursor_debug"("NEXT", "default_value")
  debug_1056:
  rx1268_fail:
    (rx1268_rep, rx1268_pos, $I10, $P10) = rx1268_cur."!mark_fail"(0)
    lt rx1268_pos, -1, rx1268_done
    eq rx1268_pos, -1, rx1268_fail
    jump $I10
  rx1268_done:
    rx1268_cur."!cursor_fail"()
    if_null rx1268_debug, debug_1057
    rx1268_cur."!cursor_debug"("FAIL", "default_value")
  debug_1057:
    .return (rx1268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("203_1303748459.273") :method
.annotate 'line', 10
    $P1270 = self."!PREFIX__!subrule"("ws", "")
    new $P1271, "ResizablePMCArray"
    push $P1271, $P1270
    .return ($P1271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("204_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1277_tgt
    .local int rx1277_pos
    .local int rx1277_off
    .local int rx1277_eos
    .local int rx1277_rep
    .local pmc rx1277_cur
    .local pmc rx1277_debug
    (rx1277_cur, rx1277_pos, rx1277_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1277_cur
    .local pmc match
    .lex "$/", match
    length rx1277_eos, rx1277_tgt
    gt rx1277_pos, rx1277_eos, rx1277_done
    set rx1277_off, 0
    lt rx1277_pos, 2, rx1277_start
    sub rx1277_off, rx1277_pos, 1
    substr rx1277_tgt, rx1277_tgt, rx1277_off
  rx1277_start:
    eq $I10, 1, rx1277_restart
    if_null rx1277_debug, debug_1058
    rx1277_cur."!cursor_debug"("START", "trait")
  debug_1058:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1281_done
    goto rxscan1281_scan
  rxscan1281_loop:
    (rx1277_pos) = rx1277_cur."from"()
    inc rx1277_pos
    rx1277_cur."!cursor_from"(rx1277_pos)
    ge rx1277_pos, rx1277_eos, rxscan1281_done
  rxscan1281_scan:
    set_addr $I10, rxscan1281_loop
    rx1277_cur."!mark_push"(0, rx1277_pos, $I10)
  rxscan1281_done:
.annotate 'line', 491
  # rx subrule "ws" subtype=method negate=
    rx1277_cur."!cursor_pos"(rx1277_pos)
    $P10 = rx1277_cur."ws"()
    unless $P10, rx1277_fail
    rx1277_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1277_cur."!cursor_pos"(rx1277_pos)
    $P10 = rx1277_cur."trait_mod"()
    unless $P10, rx1277_fail
    rx1277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1277_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1277_cur."!cursor_pos"(rx1277_pos)
    $P10 = rx1277_cur."ws"()
    unless $P10, rx1277_fail
    rx1277_pos = $P10."pos"()
  # rx pass
    rx1277_cur."!cursor_pass"(rx1277_pos, "trait")
    if_null rx1277_debug, debug_1059
    rx1277_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1277_pos)
  debug_1059:
    .return (rx1277_cur)
  rx1277_restart:
.annotate 'line', 10
    if_null rx1277_debug, debug_1060
    rx1277_cur."!cursor_debug"("NEXT", "trait")
  debug_1060:
  rx1277_fail:
    (rx1277_rep, rx1277_pos, $I10, $P10) = rx1277_cur."!mark_fail"(0)
    lt rx1277_pos, -1, rx1277_done
    eq rx1277_pos, -1, rx1277_fail
    jump $I10
  rx1277_done:
    rx1277_cur."!cursor_fail"()
    if_null rx1277_debug, debug_1061
    rx1277_cur."!cursor_debug"("FAIL", "trait")
  debug_1061:
    .return (rx1277_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("205_1303748459.273") :method
.annotate 'line', 10
    $P1279 = self."!PREFIX__!subrule"("ws", "")
    new $P1280, "ResizablePMCArray"
    push $P1280, $P1279
    .return ($P1280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("206_1303748459.273")
    .param pmc param_1285
.annotate 'line', 493
    .lex "self", param_1285
    $P1286 = param_1285."!protoregex"("trait_mod")
    .return ($P1286)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("207_1303748459.273")
    .param pmc param_1288
.annotate 'line', 493
    .lex "self", param_1288
    $P1289 = param_1288."!PREFIX__!protoregex"("trait_mod")
    .return ($P1289)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("208_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1291_tgt
    .local int rx1291_pos
    .local int rx1291_off
    .local int rx1291_eos
    .local int rx1291_rep
    .local pmc rx1291_cur
    .local pmc rx1291_debug
    (rx1291_cur, rx1291_pos, rx1291_tgt, $I10) = self."!cursor_start"()
    rx1291_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1291_cur
    .local pmc match
    .lex "$/", match
    length rx1291_eos, rx1291_tgt
    gt rx1291_pos, rx1291_eos, rx1291_done
    set rx1291_off, 0
    lt rx1291_pos, 2, rx1291_start
    sub rx1291_off, rx1291_pos, 1
    substr rx1291_tgt, rx1291_tgt, rx1291_off
  rx1291_start:
    eq $I10, 1, rx1291_restart
    if_null rx1291_debug, debug_1062
    rx1291_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1062:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1295_done
    goto rxscan1295_scan
  rxscan1295_loop:
    (rx1291_pos) = rx1291_cur."from"()
    inc rx1291_pos
    rx1291_cur."!cursor_from"(rx1291_pos)
    ge rx1291_pos, rx1291_eos, rxscan1295_done
  rxscan1295_scan:
    set_addr $I10, rxscan1295_loop
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  rxscan1295_done:
.annotate 'line', 494
  # rx subcapture "sym"
    set_addr $I10, rxcap_1296_fail
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  # rx literal  "is"
    add $I11, rx1291_pos, 2
    gt $I11, rx1291_eos, rx1291_fail
    sub $I11, rx1291_pos, rx1291_off
    substr $S10, rx1291_tgt, $I11, 2
    ne $S10, "is", rx1291_fail
    add rx1291_pos, 2
    set_addr $I10, rxcap_1296_fail
    ($I12, $I11) = rx1291_cur."!mark_peek"($I10)
    rx1291_cur."!cursor_pos"($I11)
    ($P10) = rx1291_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1291_pos, "")
    rx1291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1296_done
  rxcap_1296_fail:
    goto rx1291_fail
  rxcap_1296_done:
  # rx subrule "ws" subtype=method negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."ws"()
    unless $P10, rx1291_fail
    rx1291_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."deflongname"()
    unless $P10, rx1291_fail
    rx1291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1291_pos = $P10."pos"()
  # rx rxquantr1298 ** 0..1
    set_addr $I10, rxquantr1298_done
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  rxquantr1298_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."circumfix"()
    unless $P10, rx1291_fail
    goto rxsubrule1299_pass
  rxsubrule1299_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1291_fail
  rxsubrule1299_pass:
    set_addr $I10, rxsubrule1299_back
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1291_pos = $P10."pos"()
    set_addr $I10, rxquantr1298_done
    (rx1291_rep) = rx1291_cur."!mark_commit"($I10)
  rxquantr1298_done:
  # rx subrule "ws" subtype=method negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."ws"()
    unless $P10, rx1291_fail
    rx1291_pos = $P10."pos"()
  # rx pass
    rx1291_cur."!cursor_pass"(rx1291_pos, "trait_mod:sym<is>")
    if_null rx1291_debug, debug_1063
    rx1291_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1291_pos)
  debug_1063:
    .return (rx1291_cur)
  rx1291_restart:
.annotate 'line', 10
    if_null rx1291_debug, debug_1064
    rx1291_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1064:
  rx1291_fail:
    (rx1291_rep, rx1291_pos, $I10, $P10) = rx1291_cur."!mark_fail"(0)
    lt rx1291_pos, -1, rx1291_done
    eq rx1291_pos, -1, rx1291_fail
    jump $I10
  rx1291_done:
    rx1291_cur."!cursor_fail"()
    if_null rx1291_debug, debug_1065
    rx1291_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1065:
    .return (rx1291_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("209_1303748459.273") :method
.annotate 'line', 10
    $P1293 = self."!PREFIX__!subrule"("ws", "is")
    new $P1294, "ResizablePMCArray"
    push $P1294, $P1293
    .return ($P1294)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("210_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1302_tgt
    .local int rx1302_pos
    .local int rx1302_off
    .local int rx1302_eos
    .local int rx1302_rep
    .local pmc rx1302_cur
    .local pmc rx1302_debug
    (rx1302_cur, rx1302_pos, rx1302_tgt, $I10) = self."!cursor_start"()
    rx1302_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1302_cur
    .local pmc match
    .lex "$/", match
    length rx1302_eos, rx1302_tgt
    gt rx1302_pos, rx1302_eos, rx1302_done
    set rx1302_off, 0
    lt rx1302_pos, 2, rx1302_start
    sub rx1302_off, rx1302_pos, 1
    substr rx1302_tgt, rx1302_tgt, rx1302_off
  rx1302_start:
    eq $I10, 1, rx1302_restart
    if_null rx1302_debug, debug_1066
    rx1302_cur."!cursor_debug"("START", "regex_declarator")
  debug_1066:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1306_done
    goto rxscan1306_scan
  rxscan1306_loop:
    (rx1302_pos) = rx1302_cur."from"()
    inc rx1302_pos
    rx1302_cur."!cursor_from"(rx1302_pos)
    ge rx1302_pos, rx1302_eos, rxscan1306_done
  rxscan1306_scan:
    set_addr $I10, rxscan1306_loop
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxscan1306_done:
.annotate 'line', 496
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1308_0:
.annotate 'line', 497
    set_addr $I10, alt1308_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
.annotate 'line', 498
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1310_fail
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "proto", rx1302_fail
    add rx1302_pos, 5
    set_addr $I10, rxcap_1310_fail
    ($I12, $I11) = rx1302_cur."!mark_peek"($I10)
    rx1302_cur."!cursor_pos"($I11)
    ($P10) = rx1302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1302_pos, "")
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1310_done
  rxcap_1310_fail:
    goto rx1302_fail
  rxcap_1310_done:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1312_0:
    set_addr $I10, alt1312_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "regex", rx1302_fail
    add rx1302_pos, 5
    goto alt1312_end
  alt1312_1:
    set_addr $I10, alt1312_2
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "token"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "token", rx1302_fail
    add rx1302_pos, 5
    goto alt1312_end
  alt1312_2:
  # rx literal  "rule"
    add $I11, rx1302_pos, 4
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 4
    ne $S10, "rule", rx1302_fail
    add rx1302_pos, 4
  alt1312_end:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 499
  # rx subrule "deflongname" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."deflongname"()
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1315_0:
.annotate 'line', 500
    set_addr $I10, alt1315_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
.annotate 'line', 501
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 123, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "<...>", rx1302_fail
    add rx1302_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 125, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ENDSTMT"()
    unless $P10, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
    goto alt1315_end
  alt1315_1:
    set_addr $I10, alt1315_2
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
.annotate 'line', 502
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 123, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1302_pos, 3
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 3
    ne $S10, "<*>", rx1302_fail
    add rx1302_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 125, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ENDSTMT"()
    unless $P10, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
    goto alt1315_end
  alt1315_2:
.annotate 'line', 503
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1315_end:
.annotate 'line', 504
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 498
    goto alt1308_end
  alt1308_1:
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1329_fail
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  alt1328_0:
    set_addr $I10, alt1328_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "regex", rx1302_fail
    add rx1302_pos, 5
    goto alt1328_end
  alt1328_1:
    set_addr $I10, alt1328_2
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "token"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "token", rx1302_fail
    add rx1302_pos, 5
    goto alt1328_end
  alt1328_2:
  # rx literal  "rule"
    add $I11, rx1302_pos, 4
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 4
    ne $S10, "rule", rx1302_fail
    add rx1302_pos, 4
  alt1328_end:
    set_addr $I10, rxcap_1329_fail
    ($I12, $I11) = rx1302_cur."!mark_peek"($I10)
    rx1302_cur."!cursor_pos"($I11)
    ($P10) = rx1302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1302_pos, "")
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1329_done
  rxcap_1329_fail:
    goto rx1302_fail
  rxcap_1329_done:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 506
  # rx subrule "deflongname" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."deflongname"()
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 507
  # rx subrule "newpad" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."newpad"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 508
  # rx rxquantr1333 ** 0..1
    set_addr $I10, rxquantr1333_done
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxquantr1333_loop:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 40, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."signature"()
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 41, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
    set_addr $I10, rxquantr1333_done
    (rx1302_rep) = rx1302_cur."!mark_commit"($I10)
  rxquantr1333_done:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 509
  # rx reduce name="regex_declarator" key="open"
    rx1302_cur."!cursor_pos"(rx1302_pos)
    rx1302_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 510
  # rx literal  "{"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 123, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1302_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 125, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ENDSTMT"()
    unless $P10, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1308_end:
.annotate 'line', 511
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 496
  # rx pass
    rx1302_cur."!cursor_pass"(rx1302_pos, "regex_declarator")
    if_null rx1302_debug, debug_1067
    rx1302_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1302_pos)
  debug_1067:
    .return (rx1302_cur)
  rx1302_restart:
.annotate 'line', 10
    if_null rx1302_debug, debug_1068
    rx1302_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1068:
  rx1302_fail:
    (rx1302_rep, rx1302_pos, $I10, $P10) = rx1302_cur."!mark_fail"(0)
    lt rx1302_pos, -1, rx1302_done
    eq rx1302_pos, -1, rx1302_fail
    jump $I10
  rx1302_done:
    rx1302_cur."!cursor_fail"()
    if_null rx1302_debug, debug_1069
    rx1302_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1069:
    .return (rx1302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("211_1303748459.273") :method
.annotate 'line', 10
    $P1304 = self."!PREFIX__!subrule"("ws", "")
    new $P1305, "ResizablePMCArray"
    push $P1305, $P1304
    .return ($P1305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("212_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1343_tgt
    .local int rx1343_pos
    .local int rx1343_off
    .local int rx1343_eos
    .local int rx1343_rep
    .local pmc rx1343_cur
    .local pmc rx1343_debug
    (rx1343_cur, rx1343_pos, rx1343_tgt, $I10) = self."!cursor_start"()
    rx1343_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1343_cur
    .local pmc match
    .lex "$/", match
    length rx1343_eos, rx1343_tgt
    gt rx1343_pos, rx1343_eos, rx1343_done
    set rx1343_off, 0
    lt rx1343_pos, 2, rx1343_start
    sub rx1343_off, rx1343_pos, 1
    substr rx1343_tgt, rx1343_tgt, rx1343_off
  rx1343_start:
    eq $I10, 1, rx1343_restart
    if_null rx1343_debug, debug_1070
    rx1343_cur."!cursor_debug"("START", "dotty")
  debug_1070:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1343_pos) = rx1343_cur."from"()
    inc rx1343_pos
    rx1343_cur."!cursor_from"(rx1343_pos)
    ge rx1343_pos, rx1343_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxscan1347_done:
.annotate 'line', 515
  # rx literal  "."
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 46, rx1343_fail
    add rx1343_pos, 1
  alt1348_0:
.annotate 'line', 516
    set_addr $I10, alt1348_1
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."deflongname"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1343_pos = $P10."pos"()
    goto alt1348_end
  alt1348_1:
.annotate 'line', 517
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1343_pos, rx1343_off
    substr $S10, rx1343_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1343_fail
  # rx subrule "quote" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."quote"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1343_pos = $P10."pos"()
  alt1349_0:
.annotate 'line', 518
    set_addr $I10, alt1349_1
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1343_pos, rx1343_off
    substr $S10, rx1343_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1343_fail
    goto alt1349_end
  alt1349_1:
  # rx subrule "panic" subtype=method negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1343_fail
    rx1343_pos = $P10."pos"()
  alt1349_end:
  alt1348_end:
.annotate 'line', 524
  # rx rxquantr1350 ** 0..1
    set_addr $I10, rxquantr1350_done
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxquantr1350_loop:
  alt1351_0:
.annotate 'line', 521
    set_addr $I10, alt1351_1
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
.annotate 'line', 522
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1343_pos, rx1343_off
    substr $S10, rx1343_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1343_fail
  # rx subrule "args" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."args"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1343_pos = $P10."pos"()
    goto alt1351_end
  alt1351_1:
.annotate 'line', 523
  # rx literal  ":"
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 58, rx1343_fail
    add rx1343_pos, 1
  # rx charclass s
    ge rx1343_pos, rx1343_eos, rx1343_fail
    sub $I10, rx1343_pos, rx1343_off
    is_cclass $I11, 32, rx1343_tgt, $I10
    unless $I11, rx1343_fail
    inc rx1343_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."arglist"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1343_pos = $P10."pos"()
  alt1351_end:
.annotate 'line', 524
    set_addr $I10, rxquantr1350_done
    (rx1343_rep) = rx1343_cur."!mark_commit"($I10)
  rxquantr1350_done:
.annotate 'line', 514
  # rx pass
    rx1343_cur."!cursor_pass"(rx1343_pos, "dotty")
    if_null rx1343_debug, debug_1071
    rx1343_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1343_pos)
  debug_1071:
    .return (rx1343_cur)
  rx1343_restart:
.annotate 'line', 10
    if_null rx1343_debug, debug_1072
    rx1343_cur."!cursor_debug"("NEXT", "dotty")
  debug_1072:
  rx1343_fail:
    (rx1343_rep, rx1343_pos, $I10, $P10) = rx1343_cur."!mark_fail"(0)
    lt rx1343_pos, -1, rx1343_done
    eq rx1343_pos, -1, rx1343_fail
    jump $I10
  rx1343_done:
    rx1343_cur."!cursor_fail"()
    if_null rx1343_debug, debug_1073
    rx1343_cur."!cursor_debug"("FAIL", "dotty")
  debug_1073:
    .return (rx1343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("213_1303748459.273") :method
.annotate 'line', 10
    $P1345 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1346, "ResizablePMCArray"
    push $P1346, "'"
    push $P1346, "\""
    push $P1346, $P1345
    .return ($P1346)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("214_1303748459.273")
    .param pmc param_1353
.annotate 'line', 528
    .lex "self", param_1353
    $P1354 = param_1353."!protoregex"("term")
    .return ($P1354)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("215_1303748459.273")
    .param pmc param_1356
.annotate 'line', 528
    .lex "self", param_1356
    $P1357 = param_1356."!PREFIX__!protoregex"("term")
    .return ($P1357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("216_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1359_tgt
    .local int rx1359_pos
    .local int rx1359_off
    .local int rx1359_eos
    .local int rx1359_rep
    .local pmc rx1359_cur
    .local pmc rx1359_debug
    (rx1359_cur, rx1359_pos, rx1359_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1359_cur
    .local pmc match
    .lex "$/", match
    length rx1359_eos, rx1359_tgt
    gt rx1359_pos, rx1359_eos, rx1359_done
    set rx1359_off, 0
    lt rx1359_pos, 2, rx1359_start
    sub rx1359_off, rx1359_pos, 1
    substr rx1359_tgt, rx1359_tgt, rx1359_off
  rx1359_start:
    eq $I10, 1, rx1359_restart
    if_null rx1359_debug, debug_1074
    rx1359_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1074:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1362_done
    goto rxscan1362_scan
  rxscan1362_loop:
    (rx1359_pos) = rx1359_cur."from"()
    inc rx1359_pos
    rx1359_cur."!cursor_from"(rx1359_pos)
    ge rx1359_pos, rx1359_eos, rxscan1362_done
  rxscan1362_scan:
    set_addr $I10, rxscan1362_loop
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  rxscan1362_done:
.annotate 'line', 530
  # rx subcapture "sym"
    set_addr $I10, rxcap_1363_fail
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  # rx literal  "self"
    add $I11, rx1359_pos, 4
    gt $I11, rx1359_eos, rx1359_fail
    sub $I11, rx1359_pos, rx1359_off
    substr $S10, rx1359_tgt, $I11, 4
    ne $S10, "self", rx1359_fail
    add rx1359_pos, 4
    set_addr $I10, rxcap_1363_fail
    ($I12, $I11) = rx1359_cur."!mark_peek"($I10)
    rx1359_cur."!cursor_pos"($I11)
    ($P10) = rx1359_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1359_pos, "")
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1363_done
  rxcap_1363_fail:
    goto rx1359_fail
  rxcap_1363_done:
  # rxanchor rwb
    le rx1359_pos, 0, rx1359_fail
    sub $I10, rx1359_pos, rx1359_off
    is_cclass $I11, 8192, rx1359_tgt, $I10
    if $I11, rx1359_fail
    dec $I10
    is_cclass $I11, 8192, rx1359_tgt, $I10
    unless $I11, rx1359_fail
  # rx pass
    rx1359_cur."!cursor_pass"(rx1359_pos, "term:sym<self>")
    if_null rx1359_debug, debug_1075
    rx1359_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1359_pos)
  debug_1075:
    .return (rx1359_cur)
  rx1359_restart:
.annotate 'line', 10
    if_null rx1359_debug, debug_1076
    rx1359_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1076:
  rx1359_fail:
    (rx1359_rep, rx1359_pos, $I10, $P10) = rx1359_cur."!mark_fail"(0)
    lt rx1359_pos, -1, rx1359_done
    eq rx1359_pos, -1, rx1359_fail
    jump $I10
  rx1359_done:
    rx1359_cur."!cursor_fail"()
    if_null rx1359_debug, debug_1077
    rx1359_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1077:
    .return (rx1359_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("217_1303748459.273") :method
.annotate 'line', 10
    new $P1361, "ResizablePMCArray"
    push $P1361, "self"
    .return ($P1361)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("218_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1365_tgt
    .local int rx1365_pos
    .local int rx1365_off
    .local int rx1365_eos
    .local int rx1365_rep
    .local pmc rx1365_cur
    .local pmc rx1365_debug
    (rx1365_cur, rx1365_pos, rx1365_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1365_cur
    .local pmc match
    .lex "$/", match
    length rx1365_eos, rx1365_tgt
    gt rx1365_pos, rx1365_eos, rx1365_done
    set rx1365_off, 0
    lt rx1365_pos, 2, rx1365_start
    sub rx1365_off, rx1365_pos, 1
    substr rx1365_tgt, rx1365_tgt, rx1365_off
  rx1365_start:
    eq $I10, 1, rx1365_restart
    if_null rx1365_debug, debug_1078
    rx1365_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1078:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1369_done
    goto rxscan1369_scan
  rxscan1369_loop:
    (rx1365_pos) = rx1365_cur."from"()
    inc rx1365_pos
    rx1365_cur."!cursor_from"(rx1365_pos)
    ge rx1365_pos, rx1365_eos, rxscan1369_done
  rxscan1369_scan:
    set_addr $I10, rxscan1369_loop
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxscan1369_done:
.annotate 'line', 533
  # rx subrule "deflongname" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."deflongname"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1365_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1365_fail
  # rx subrule "args" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."args"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1365_pos = $P10."pos"()
.annotate 'line', 532
  # rx pass
    rx1365_cur."!cursor_pass"(rx1365_pos, "term:sym<identifier>")
    if_null rx1365_debug, debug_1079
    rx1365_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1365_pos)
  debug_1079:
    .return (rx1365_cur)
  rx1365_restart:
.annotate 'line', 10
    if_null rx1365_debug, debug_1080
    rx1365_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1080:
  rx1365_fail:
    (rx1365_rep, rx1365_pos, $I10, $P10) = rx1365_cur."!mark_fail"(0)
    lt rx1365_pos, -1, rx1365_done
    eq rx1365_pos, -1, rx1365_fail
    jump $I10
  rx1365_done:
    rx1365_cur."!cursor_fail"()
    if_null rx1365_debug, debug_1081
    rx1365_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1081:
    .return (rx1365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("219_1303748459.273") :method
.annotate 'line', 10
    $P1367 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1368, "ResizablePMCArray"
    push $P1368, $P1367
    .return ($P1368)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("220_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1371_tgt
    .local int rx1371_pos
    .local int rx1371_off
    .local int rx1371_eos
    .local int rx1371_rep
    .local pmc rx1371_cur
    .local pmc rx1371_debug
    (rx1371_cur, rx1371_pos, rx1371_tgt, $I10) = self."!cursor_start"()
    rx1371_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1371_cur
    .local pmc match
    .lex "$/", match
    length rx1371_eos, rx1371_tgt
    gt rx1371_pos, rx1371_eos, rx1371_done
    set rx1371_off, 0
    lt rx1371_pos, 2, rx1371_start
    sub rx1371_off, rx1371_pos, 1
    substr rx1371_tgt, rx1371_tgt, rx1371_off
  rx1371_start:
    eq $I10, 1, rx1371_restart
    if_null rx1371_debug, debug_1082
    rx1371_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1082:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1375_done
    goto rxscan1375_scan
  rxscan1375_loop:
    (rx1371_pos) = rx1371_cur."from"()
    inc rx1371_pos
    rx1371_cur."!cursor_from"(rx1371_pos)
    ge rx1371_pos, rx1371_eos, rxscan1375_done
  rxscan1375_scan:
    set_addr $I10, rxscan1375_loop
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  rxscan1375_done:
.annotate 'line', 537
  # rx subrule "name" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."name"()
    unless $P10, rx1371_fail
    rx1371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1371_pos = $P10."pos"()
  # rx rxquantr1376 ** 0..1
    set_addr $I10, rxquantr1376_done
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  rxquantr1376_loop:
  # rx subrule "args" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."args"()
    unless $P10, rx1371_fail
    goto rxsubrule1377_pass
  rxsubrule1377_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1371_fail
  rxsubrule1377_pass:
    set_addr $I10, rxsubrule1377_back
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1371_pos = $P10."pos"()
    set_addr $I10, rxquantr1376_done
    (rx1371_rep) = rx1371_cur."!mark_commit"($I10)
  rxquantr1376_done:
.annotate 'line', 536
  # rx pass
    rx1371_cur."!cursor_pass"(rx1371_pos, "term:sym<name>")
    if_null rx1371_debug, debug_1083
    rx1371_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1371_pos)
  debug_1083:
    .return (rx1371_cur)
  rx1371_restart:
.annotate 'line', 10
    if_null rx1371_debug, debug_1084
    rx1371_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1084:
  rx1371_fail:
    (rx1371_rep, rx1371_pos, $I10, $P10) = rx1371_cur."!mark_fail"(0)
    lt rx1371_pos, -1, rx1371_done
    eq rx1371_pos, -1, rx1371_fail
    jump $I10
  rx1371_done:
    rx1371_cur."!cursor_fail"()
    if_null rx1371_debug, debug_1085
    rx1371_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1085:
    .return (rx1371_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("221_1303748459.273") :method
.annotate 'line', 10
    $P1373 = self."!PREFIX__!subrule"("name", "")
    new $P1374, "ResizablePMCArray"
    push $P1374, $P1373
    .return ($P1374)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("222_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1379_tgt
    .local int rx1379_pos
    .local int rx1379_off
    .local int rx1379_eos
    .local int rx1379_rep
    .local pmc rx1379_cur
    .local pmc rx1379_debug
    (rx1379_cur, rx1379_pos, rx1379_tgt, $I10) = self."!cursor_start"()
    rx1379_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1379_cur
    .local pmc match
    .lex "$/", match
    length rx1379_eos, rx1379_tgt
    gt rx1379_pos, rx1379_eos, rx1379_done
    set rx1379_off, 0
    lt rx1379_pos, 2, rx1379_start
    sub rx1379_off, rx1379_pos, 1
    substr rx1379_tgt, rx1379_tgt, rx1379_off
  rx1379_start:
    eq $I10, 1, rx1379_restart
    if_null rx1379_debug, debug_1086
    rx1379_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1086:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1382_done
    goto rxscan1382_scan
  rxscan1382_loop:
    (rx1379_pos) = rx1379_cur."from"()
    inc rx1379_pos
    rx1379_cur."!cursor_from"(rx1379_pos)
    ge rx1379_pos, rx1379_eos, rxscan1382_done
  rxscan1382_scan:
    set_addr $I10, rxscan1382_loop
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  rxscan1382_done:
.annotate 'line', 541
  # rx literal  "pir::"
    add $I11, rx1379_pos, 5
    gt $I11, rx1379_eos, rx1379_fail
    sub $I11, rx1379_pos, rx1379_off
    substr $S10, rx1379_tgt, $I11, 5
    ne $S10, "pir::", rx1379_fail
    add rx1379_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1383_fail
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1379_pos, rx1379_off
    find_not_cclass $I11, 8192, rx1379_tgt, $I10, rx1379_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1379_fail
    add rx1379_pos, rx1379_off, $I11
    set_addr $I10, rxcap_1383_fail
    ($I12, $I11) = rx1379_cur."!mark_peek"($I10)
    rx1379_cur."!cursor_pos"($I11)
    ($P10) = rx1379_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1379_pos, "")
    rx1379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1383_done
  rxcap_1383_fail:
    goto rx1379_fail
  rxcap_1383_done:
  # rx rxquantr1384 ** 0..1
    set_addr $I10, rxquantr1384_done
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  rxquantr1384_loop:
  # rx subrule "args" subtype=capture negate=
    rx1379_cur."!cursor_pos"(rx1379_pos)
    $P10 = rx1379_cur."args"()
    unless $P10, rx1379_fail
    goto rxsubrule1385_pass
  rxsubrule1385_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1379_fail
  rxsubrule1385_pass:
    set_addr $I10, rxsubrule1385_back
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1379_pos = $P10."pos"()
    set_addr $I10, rxquantr1384_done
    (rx1379_rep) = rx1379_cur."!mark_commit"($I10)
  rxquantr1384_done:
.annotate 'line', 540
  # rx pass
    rx1379_cur."!cursor_pass"(rx1379_pos, "term:sym<pir::op>")
    if_null rx1379_debug, debug_1087
    rx1379_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1379_pos)
  debug_1087:
    .return (rx1379_cur)
  rx1379_restart:
.annotate 'line', 10
    if_null rx1379_debug, debug_1088
    rx1379_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1088:
  rx1379_fail:
    (rx1379_rep, rx1379_pos, $I10, $P10) = rx1379_cur."!mark_fail"(0)
    lt rx1379_pos, -1, rx1379_done
    eq rx1379_pos, -1, rx1379_fail
    jump $I10
  rx1379_done:
    rx1379_cur."!cursor_fail"()
    if_null rx1379_debug, debug_1089
    rx1379_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1089:
    .return (rx1379_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("223_1303748459.273") :method
.annotate 'line', 10
    new $P1381, "ResizablePMCArray"
    push $P1381, "pir::"
    .return ($P1381)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("224_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P1395 = "226_1303748459.273" 
    capture_lex $P1395
    .local string rx1387_tgt
    .local int rx1387_pos
    .local int rx1387_off
    .local int rx1387_eos
    .local int rx1387_rep
    .local pmc rx1387_cur
    .local pmc rx1387_debug
    (rx1387_cur, rx1387_pos, rx1387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1387_cur
    .local pmc match
    .lex "$/", match
    length rx1387_eos, rx1387_tgt
    gt rx1387_pos, rx1387_eos, rx1387_done
    set rx1387_off, 0
    lt rx1387_pos, 2, rx1387_start
    sub rx1387_off, rx1387_pos, 1
    substr rx1387_tgt, rx1387_tgt, rx1387_off
  rx1387_start:
    eq $I10, 1, rx1387_restart
    if_null rx1387_debug, debug_1090
    rx1387_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1090:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1390_done
    goto rxscan1390_scan
  rxscan1390_loop:
    (rx1387_pos) = rx1387_cur."from"()
    inc rx1387_pos
    rx1387_cur."!cursor_from"(rx1387_pos)
    ge rx1387_pos, rx1387_eos, rxscan1390_done
  rxscan1390_scan:
    set_addr $I10, rxscan1390_loop
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  rxscan1390_done:
.annotate 'line', 545
  # rx literal  "{*}"
    add $I11, rx1387_pos, 3
    gt $I11, rx1387_eos, rx1387_fail
    sub $I11, rx1387_pos, rx1387_off
    substr $S10, rx1387_tgt, $I11, 3
    ne $S10, "{*}", rx1387_fail
    add rx1387_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."ENDSTMT"()
    unless $P10, rx1387_fail
  alt1391_0:
.annotate 'line', 546
    set_addr $I10, alt1391_1
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
    rx1387_cur."!cursor_pos"(rx1387_pos)
    find_lex $P1392, unicode:"$\x{a2}"
    $P1393 = $P1392."MATCH"()
    store_lex "$/", $P1393
    .const 'Sub' $P1395 = "226_1303748459.273" 
    capture_lex $P1395
    $P1401 = $P1395()
    unless $P1401, rx1387_fail
    goto alt1391_end
  alt1391_1:
  # rx subrule "panic" subtype=method negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1387_fail
    rx1387_pos = $P10."pos"()
  alt1391_end:
.annotate 'line', 544
  # rx pass
    rx1387_cur."!cursor_pass"(rx1387_pos, "term:sym<onlystar>")
    if_null rx1387_debug, debug_1093
    rx1387_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1387_pos)
  debug_1093:
    .return (rx1387_cur)
  rx1387_restart:
.annotate 'line', 10
    if_null rx1387_debug, debug_1094
    rx1387_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1094:
  rx1387_fail:
    (rx1387_rep, rx1387_pos, $I10, $P10) = rx1387_cur."!mark_fail"(0)
    lt rx1387_pos, -1, rx1387_done
    eq rx1387_pos, -1, rx1387_fail
    jump $I10
  rx1387_done:
    rx1387_cur."!cursor_fail"()
    if_null rx1387_debug, debug_1095
    rx1387_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1095:
    .return (rx1387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("225_1303748459.273") :method
.annotate 'line', 10
    new $P1389, "ResizablePMCArray"
    push $P1389, "{*}"
    .return ($P1389)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1394"  :anon :subid("226_1303748459.273") :outer("224_1303748459.273")
.annotate 'line', 546
    find_dynamic_lex $P1398, "$*MULTINESS"
    unless_null $P1398, vivify_1091
    get_hll_global $P1396, "GLOBAL"
    get_who $P1397, $P1396
    set $P1398, $P1397["$MULTINESS"]
    unless_null $P1398, vivify_1092
    die "Contextual $*MULTINESS not found"
  vivify_1092:
  vivify_1091:
    set $S1399, $P1398
    iseq $I1400, $S1399, "proto"
    .return ($I1400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("227_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1403_tgt
    .local int rx1403_pos
    .local int rx1403_off
    .local int rx1403_eos
    .local int rx1403_rep
    .local pmc rx1403_cur
    .local pmc rx1403_debug
    (rx1403_cur, rx1403_pos, rx1403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1403_cur
    .local pmc match
    .lex "$/", match
    length rx1403_eos, rx1403_tgt
    gt rx1403_pos, rx1403_eos, rx1403_done
    set rx1403_off, 0
    lt rx1403_pos, 2, rx1403_start
    sub rx1403_off, rx1403_pos, 1
    substr rx1403_tgt, rx1403_tgt, rx1403_off
  rx1403_start:
    eq $I10, 1, rx1403_restart
    if_null rx1403_debug, debug_1096
    rx1403_cur."!cursor_debug"("START", "args")
  debug_1096:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1407_done
    goto rxscan1407_scan
  rxscan1407_loop:
    (rx1403_pos) = rx1403_cur."from"()
    inc rx1403_pos
    rx1403_cur."!cursor_from"(rx1403_pos)
    ge rx1403_pos, rx1403_eos, rxscan1407_done
  rxscan1407_scan:
    set_addr $I10, rxscan1407_loop
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  rxscan1407_done:
.annotate 'line', 550
  # rx literal  "("
    add $I11, rx1403_pos, 1
    gt $I11, rx1403_eos, rx1403_fail
    sub $I11, rx1403_pos, rx1403_off
    ord $I11, rx1403_tgt, $I11
    ne $I11, 40, rx1403_fail
    add rx1403_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."arglist"()
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1403_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1403_pos, 1
    gt $I11, rx1403_eos, rx1403_fail
    sub $I11, rx1403_pos, rx1403_off
    ord $I11, rx1403_tgt, $I11
    ne $I11, 41, rx1403_fail
    add rx1403_pos, 1
  # rx pass
    rx1403_cur."!cursor_pass"(rx1403_pos, "args")
    if_null rx1403_debug, debug_1097
    rx1403_cur."!cursor_debug"("PASS", "args", " at pos=", rx1403_pos)
  debug_1097:
    .return (rx1403_cur)
  rx1403_restart:
.annotate 'line', 10
    if_null rx1403_debug, debug_1098
    rx1403_cur."!cursor_debug"("NEXT", "args")
  debug_1098:
  rx1403_fail:
    (rx1403_rep, rx1403_pos, $I10, $P10) = rx1403_cur."!mark_fail"(0)
    lt rx1403_pos, -1, rx1403_done
    eq rx1403_pos, -1, rx1403_fail
    jump $I10
  rx1403_done:
    rx1403_cur."!cursor_fail"()
    if_null rx1403_debug, debug_1099
    rx1403_cur."!cursor_debug"("FAIL", "args")
  debug_1099:
    .return (rx1403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("228_1303748459.273") :method
.annotate 'line', 10
    $P1405 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1406, "ResizablePMCArray"
    push $P1406, $P1405
    .return ($P1406)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("229_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1409_tgt
    .local int rx1409_pos
    .local int rx1409_off
    .local int rx1409_eos
    .local int rx1409_rep
    .local pmc rx1409_cur
    .local pmc rx1409_debug
    (rx1409_cur, rx1409_pos, rx1409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1409_cur
    .local pmc match
    .lex "$/", match
    length rx1409_eos, rx1409_tgt
    gt rx1409_pos, rx1409_eos, rx1409_done
    set rx1409_off, 0
    lt rx1409_pos, 2, rx1409_start
    sub rx1409_off, rx1409_pos, 1
    substr rx1409_tgt, rx1409_tgt, rx1409_off
  rx1409_start:
    eq $I10, 1, rx1409_restart
    if_null rx1409_debug, debug_1100
    rx1409_cur."!cursor_debug"("START", "arglist")
  debug_1100:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1413_done
    goto rxscan1413_scan
  rxscan1413_loop:
    (rx1409_pos) = rx1409_cur."from"()
    inc rx1409_pos
    rx1409_cur."!cursor_from"(rx1409_pos)
    ge rx1409_pos, rx1409_eos, rxscan1413_done
  rxscan1413_scan:
    set_addr $I10, rxscan1413_loop
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  rxscan1413_done:
.annotate 'line', 554
  # rx subrule "ws" subtype=method negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."ws"()
    unless $P10, rx1409_fail
    rx1409_pos = $P10."pos"()
  alt1414_0:
.annotate 'line', 555
    set_addr $I10, alt1414_1
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
.annotate 'line', 556
  # rx subrule "EXPR" subtype=capture negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."EXPR"("f=")
    unless $P10, rx1409_fail
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1409_pos = $P10."pos"()
    goto alt1414_end
  alt1414_1:
  alt1414_end:
.annotate 'line', 553
  # rx pass
    rx1409_cur."!cursor_pass"(rx1409_pos, "arglist")
    if_null rx1409_debug, debug_1101
    rx1409_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1409_pos)
  debug_1101:
    .return (rx1409_cur)
  rx1409_restart:
.annotate 'line', 10
    if_null rx1409_debug, debug_1102
    rx1409_cur."!cursor_debug"("NEXT", "arglist")
  debug_1102:
  rx1409_fail:
    (rx1409_rep, rx1409_pos, $I10, $P10) = rx1409_cur."!mark_fail"(0)
    lt rx1409_pos, -1, rx1409_done
    eq rx1409_pos, -1, rx1409_fail
    jump $I10
  rx1409_done:
    rx1409_cur."!cursor_fail"()
    if_null rx1409_debug, debug_1103
    rx1409_cur."!cursor_debug"("FAIL", "arglist")
  debug_1103:
    .return (rx1409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("230_1303748459.273") :method
.annotate 'line', 10
    $P1411 = self."!PREFIX__!subrule"("ws", "")
    new $P1412, "ResizablePMCArray"
    push $P1412, $P1411
    .return ($P1412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("231_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1416_tgt
    .local int rx1416_pos
    .local int rx1416_off
    .local int rx1416_eos
    .local int rx1416_rep
    .local pmc rx1416_cur
    .local pmc rx1416_debug
    (rx1416_cur, rx1416_pos, rx1416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1416_cur
    .local pmc match
    .lex "$/", match
    length rx1416_eos, rx1416_tgt
    gt rx1416_pos, rx1416_eos, rx1416_done
    set rx1416_off, 0
    lt rx1416_pos, 2, rx1416_start
    sub rx1416_off, rx1416_pos, 1
    substr rx1416_tgt, rx1416_tgt, rx1416_off
  rx1416_start:
    eq $I10, 1, rx1416_restart
    if_null rx1416_debug, debug_1104
    rx1416_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1104:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1420_done
    goto rxscan1420_scan
  rxscan1420_loop:
    (rx1416_pos) = rx1416_cur."from"()
    inc rx1416_pos
    rx1416_cur."!cursor_from"(rx1416_pos)
    ge rx1416_pos, rx1416_eos, rxscan1420_done
  rxscan1420_scan:
    set_addr $I10, rxscan1420_loop
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  rxscan1420_done:
.annotate 'line', 562
  # rx subrule "value" subtype=capture negate=
    rx1416_cur."!cursor_pos"(rx1416_pos)
    $P10 = rx1416_cur."value"()
    unless $P10, rx1416_fail
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1416_pos = $P10."pos"()
  # rx pass
    rx1416_cur."!cursor_pass"(rx1416_pos, "term:sym<value>")
    if_null rx1416_debug, debug_1105
    rx1416_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1416_pos)
  debug_1105:
    .return (rx1416_cur)
  rx1416_restart:
.annotate 'line', 10
    if_null rx1416_debug, debug_1106
    rx1416_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1106:
  rx1416_fail:
    (rx1416_rep, rx1416_pos, $I10, $P10) = rx1416_cur."!mark_fail"(0)
    lt rx1416_pos, -1, rx1416_done
    eq rx1416_pos, -1, rx1416_fail
    jump $I10
  rx1416_done:
    rx1416_cur."!cursor_fail"()
    if_null rx1416_debug, debug_1107
    rx1416_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1107:
    .return (rx1416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("232_1303748459.273") :method
.annotate 'line', 10
    $P1418 = self."!PREFIX__!subrule"("value", "")
    new $P1419, "ResizablePMCArray"
    push $P1419, $P1418
    .return ($P1419)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("233_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1422_tgt
    .local int rx1422_pos
    .local int rx1422_off
    .local int rx1422_eos
    .local int rx1422_rep
    .local pmc rx1422_cur
    .local pmc rx1422_debug
    (rx1422_cur, rx1422_pos, rx1422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1422_cur
    .local pmc match
    .lex "$/", match
    length rx1422_eos, rx1422_tgt
    gt rx1422_pos, rx1422_eos, rx1422_done
    set rx1422_off, 0
    lt rx1422_pos, 2, rx1422_start
    sub rx1422_off, rx1422_pos, 1
    substr rx1422_tgt, rx1422_tgt, rx1422_off
  rx1422_start:
    eq $I10, 1, rx1422_restart
    if_null rx1422_debug, debug_1108
    rx1422_cur."!cursor_debug"("START", "value")
  debug_1108:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1427_done
    goto rxscan1427_scan
  rxscan1427_loop:
    (rx1422_pos) = rx1422_cur."from"()
    inc rx1422_pos
    rx1422_cur."!cursor_from"(rx1422_pos)
    ge rx1422_pos, rx1422_eos, rxscan1427_done
  rxscan1427_scan:
    set_addr $I10, rxscan1427_loop
    rx1422_cur."!mark_push"(0, rx1422_pos, $I10)
  rxscan1427_done:
  alt1428_0:
.annotate 'line', 564
    set_addr $I10, alt1428_1
    rx1422_cur."!mark_push"(0, rx1422_pos, $I10)
.annotate 'line', 565
  # rx subrule "quote" subtype=capture negate=
    rx1422_cur."!cursor_pos"(rx1422_pos)
    $P10 = rx1422_cur."quote"()
    unless $P10, rx1422_fail
    rx1422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1422_pos = $P10."pos"()
    goto alt1428_end
  alt1428_1:
.annotate 'line', 566
  # rx subrule "number" subtype=capture negate=
    rx1422_cur."!cursor_pos"(rx1422_pos)
    $P10 = rx1422_cur."number"()
    unless $P10, rx1422_fail
    rx1422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1422_pos = $P10."pos"()
  alt1428_end:
.annotate 'line', 564
  # rx pass
    rx1422_cur."!cursor_pass"(rx1422_pos, "value")
    if_null rx1422_debug, debug_1109
    rx1422_cur."!cursor_debug"("PASS", "value", " at pos=", rx1422_pos)
  debug_1109:
    .return (rx1422_cur)
  rx1422_restart:
.annotate 'line', 10
    if_null rx1422_debug, debug_1110
    rx1422_cur."!cursor_debug"("NEXT", "value")
  debug_1110:
  rx1422_fail:
    (rx1422_rep, rx1422_pos, $I10, $P10) = rx1422_cur."!mark_fail"(0)
    lt rx1422_pos, -1, rx1422_done
    eq rx1422_pos, -1, rx1422_fail
    jump $I10
  rx1422_done:
    rx1422_cur."!cursor_fail"()
    if_null rx1422_debug, debug_1111
    rx1422_cur."!cursor_debug"("FAIL", "value")
  debug_1111:
    .return (rx1422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("234_1303748459.273") :method
.annotate 'line', 10
    $P1424 = self."!PREFIX__!subrule"("number", "")
    $P1425 = self."!PREFIX__!subrule"("quote", "")
    new $P1426, "ResizablePMCArray"
    push $P1426, $P1424
    push $P1426, $P1425
    .return ($P1426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("235_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1112
    rx1430_cur."!cursor_debug"("START", "number")
  debug_1112:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1433_done
    goto rxscan1433_scan
  rxscan1433_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1433_done
  rxscan1433_scan:
    set_addr $I10, rxscan1433_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1433_done:
.annotate 'line', 570
  # rx subcapture "sign"
    set_addr $I10, rxcap_1435_fail
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1430_pos, rx1430_off
    set rx1430_rep, 0
    sub $I12, rx1430_eos, rx1430_pos
    le $I12, 1, rxenumcharlistq1434_loop
    set $I12, 1
  rxenumcharlistq1434_loop:
    le $I12, 0, rxenumcharlistq1434_done
    substr $S10, rx1430_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1434_done
    inc rx1430_rep
  rxenumcharlistq1434_done:
    add rx1430_pos, rx1430_pos, rx1430_rep
    set_addr $I10, rxcap_1435_fail
    ($I12, $I11) = rx1430_cur."!mark_peek"($I10)
    rx1430_cur."!cursor_pos"($I11)
    ($P10) = rx1430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1430_pos, "")
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1435_done
  rxcap_1435_fail:
    goto rx1430_fail
  rxcap_1435_done:
  alt1436_0:
.annotate 'line', 571
    set_addr $I10, alt1436_1
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."dec_number"()
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1430_pos = $P10."pos"()
    goto alt1436_end
  alt1436_1:
  # rx subrule "integer" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."integer"()
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1430_pos = $P10."pos"()
  alt1436_end:
.annotate 'line', 569
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "number")
    if_null rx1430_debug, debug_1113
    rx1430_cur."!cursor_debug"("PASS", "number", " at pos=", rx1430_pos)
  debug_1113:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 10
    if_null rx1430_debug, debug_1114
    rx1430_cur."!cursor_debug"("NEXT", "number")
  debug_1114:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1115
    rx1430_cur."!cursor_debug"("FAIL", "number")
  debug_1115:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("236_1303748459.273") :method
.annotate 'line', 10
    new $P1432, "ResizablePMCArray"
    push $P1432, ""
    .return ($P1432)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("237_1303748459.273")
    .param pmc param_1438
.annotate 'line', 574
    .lex "self", param_1438
    $P1439 = param_1438."!protoregex"("quote")
    .return ($P1439)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("238_1303748459.273")
    .param pmc param_1441
.annotate 'line', 574
    .lex "self", param_1441
    $P1442 = param_1441."!PREFIX__!protoregex"("quote")
    .return ($P1442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("239_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1444_tgt
    .local int rx1444_pos
    .local int rx1444_off
    .local int rx1444_eos
    .local int rx1444_rep
    .local pmc rx1444_cur
    .local pmc rx1444_debug
    (rx1444_cur, rx1444_pos, rx1444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1444_cur
    .local pmc match
    .lex "$/", match
    length rx1444_eos, rx1444_tgt
    gt rx1444_pos, rx1444_eos, rx1444_done
    set rx1444_off, 0
    lt rx1444_pos, 2, rx1444_start
    sub rx1444_off, rx1444_pos, 1
    substr rx1444_tgt, rx1444_tgt, rx1444_off
  rx1444_start:
    eq $I10, 1, rx1444_restart
    if_null rx1444_debug, debug_1116
    rx1444_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1116:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1447_done
    goto rxscan1447_scan
  rxscan1447_loop:
    (rx1444_pos) = rx1444_cur."from"()
    inc rx1444_pos
    rx1444_cur."!cursor_from"(rx1444_pos)
    ge rx1444_pos, rx1444_eos, rxscan1447_done
  rxscan1447_scan:
    set_addr $I10, rxscan1447_loop
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  rxscan1447_done:
.annotate 'line', 575
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1444_pos, rx1444_off
    substr $S10, rx1444_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1444_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."quote_EXPR"(":q")
    unless $P10, rx1444_fail
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1444_pos = $P10."pos"()
  # rx pass
    rx1444_cur."!cursor_pass"(rx1444_pos, "quote:sym<apos>")
    if_null rx1444_debug, debug_1117
    rx1444_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1444_pos)
  debug_1117:
    .return (rx1444_cur)
  rx1444_restart:
.annotate 'line', 10
    if_null rx1444_debug, debug_1118
    rx1444_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1118:
  rx1444_fail:
    (rx1444_rep, rx1444_pos, $I10, $P10) = rx1444_cur."!mark_fail"(0)
    lt rx1444_pos, -1, rx1444_done
    eq rx1444_pos, -1, rx1444_fail
    jump $I10
  rx1444_done:
    rx1444_cur."!cursor_fail"()
    if_null rx1444_debug, debug_1119
    rx1444_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1119:
    .return (rx1444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("240_1303748459.273") :method
.annotate 'line', 10
    new $P1446, "ResizablePMCArray"
    push $P1446, "'"
    .return ($P1446)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("241_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1449_tgt
    .local int rx1449_pos
    .local int rx1449_off
    .local int rx1449_eos
    .local int rx1449_rep
    .local pmc rx1449_cur
    .local pmc rx1449_debug
    (rx1449_cur, rx1449_pos, rx1449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1449_cur
    .local pmc match
    .lex "$/", match
    length rx1449_eos, rx1449_tgt
    gt rx1449_pos, rx1449_eos, rx1449_done
    set rx1449_off, 0
    lt rx1449_pos, 2, rx1449_start
    sub rx1449_off, rx1449_pos, 1
    substr rx1449_tgt, rx1449_tgt, rx1449_off
  rx1449_start:
    eq $I10, 1, rx1449_restart
    if_null rx1449_debug, debug_1120
    rx1449_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1120:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1452_done
    goto rxscan1452_scan
  rxscan1452_loop:
    (rx1449_pos) = rx1449_cur."from"()
    inc rx1449_pos
    rx1449_cur."!cursor_from"(rx1449_pos)
    ge rx1449_pos, rx1449_eos, rxscan1452_done
  rxscan1452_scan:
    set_addr $I10, rxscan1452_loop
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxscan1452_done:
.annotate 'line', 576
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1449_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."quote_EXPR"(":qq")
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1449_pos = $P10."pos"()
  # rx pass
    rx1449_cur."!cursor_pass"(rx1449_pos, "quote:sym<dblq>")
    if_null rx1449_debug, debug_1121
    rx1449_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1449_pos)
  debug_1121:
    .return (rx1449_cur)
  rx1449_restart:
.annotate 'line', 10
    if_null rx1449_debug, debug_1122
    rx1449_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1122:
  rx1449_fail:
    (rx1449_rep, rx1449_pos, $I10, $P10) = rx1449_cur."!mark_fail"(0)
    lt rx1449_pos, -1, rx1449_done
    eq rx1449_pos, -1, rx1449_fail
    jump $I10
  rx1449_done:
    rx1449_cur."!cursor_fail"()
    if_null rx1449_debug, debug_1123
    rx1449_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1123:
    .return (rx1449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("242_1303748459.273") :method
.annotate 'line', 10
    new $P1451, "ResizablePMCArray"
    push $P1451, "\""
    .return ($P1451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("243_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1454_tgt
    .local int rx1454_pos
    .local int rx1454_off
    .local int rx1454_eos
    .local int rx1454_rep
    .local pmc rx1454_cur
    .local pmc rx1454_debug
    (rx1454_cur, rx1454_pos, rx1454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1454_cur
    .local pmc match
    .lex "$/", match
    length rx1454_eos, rx1454_tgt
    gt rx1454_pos, rx1454_eos, rx1454_done
    set rx1454_off, 0
    lt rx1454_pos, 2, rx1454_start
    sub rx1454_off, rx1454_pos, 1
    substr rx1454_tgt, rx1454_tgt, rx1454_off
  rx1454_start:
    eq $I10, 1, rx1454_restart
    if_null rx1454_debug, debug_1124
    rx1454_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1124:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1458_done
    goto rxscan1458_scan
  rxscan1458_loop:
    (rx1454_pos) = rx1454_cur."from"()
    inc rx1454_pos
    rx1454_cur."!cursor_from"(rx1454_pos)
    ge rx1454_pos, rx1454_eos, rxscan1458_done
  rxscan1458_scan:
    set_addr $I10, rxscan1458_loop
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  rxscan1458_done:
.annotate 'line', 577
  # rx subcapture "sym"
    set_addr $I10, rxcap_1459_fail
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  # rx literal  "q"
    add $I11, rx1454_pos, 1
    gt $I11, rx1454_eos, rx1454_fail
    sub $I11, rx1454_pos, rx1454_off
    ord $I11, rx1454_tgt, $I11
    ne $I11, 113, rx1454_fail
    add rx1454_pos, 1
    set_addr $I10, rxcap_1459_fail
    ($I12, $I11) = rx1454_cur."!mark_peek"($I10)
    rx1454_cur."!cursor_pos"($I11)
    ($P10) = rx1454_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1454_pos, "")
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1459_done
  rxcap_1459_fail:
    goto rx1454_fail
  rxcap_1459_done:
  # rxanchor rwb
    le rx1454_pos, 0, rx1454_fail
    sub $I10, rx1454_pos, rx1454_off
    is_cclass $I11, 8192, rx1454_tgt, $I10
    if $I11, rx1454_fail
    dec $I10
    is_cclass $I11, 8192, rx1454_tgt, $I10
    unless $I11, rx1454_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1454_pos, rx1454_off
    substr $S10, rx1454_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1454_fail
  # rx subrule "ws" subtype=method negate=
    rx1454_cur."!cursor_pos"(rx1454_pos)
    $P10 = rx1454_cur."ws"()
    unless $P10, rx1454_fail
    rx1454_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1454_cur."!cursor_pos"(rx1454_pos)
    $P10 = rx1454_cur."quote_EXPR"(":q")
    unless $P10, rx1454_fail
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1454_pos = $P10."pos"()
  # rx pass
    rx1454_cur."!cursor_pass"(rx1454_pos, "quote:sym<q>")
    if_null rx1454_debug, debug_1125
    rx1454_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1454_pos)
  debug_1125:
    .return (rx1454_cur)
  rx1454_restart:
.annotate 'line', 10
    if_null rx1454_debug, debug_1126
    rx1454_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1126:
  rx1454_fail:
    (rx1454_rep, rx1454_pos, $I10, $P10) = rx1454_cur."!mark_fail"(0)
    lt rx1454_pos, -1, rx1454_done
    eq rx1454_pos, -1, rx1454_fail
    jump $I10
  rx1454_done:
    rx1454_cur."!cursor_fail"()
    if_null rx1454_debug, debug_1127
    rx1454_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1127:
    .return (rx1454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("244_1303748459.273") :method
.annotate 'line', 10
    $P1456 = self."!PREFIX__!subrule"("ws", "q")
    new $P1457, "ResizablePMCArray"
    push $P1457, $P1456
    .return ($P1457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("245_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1461_tgt
    .local int rx1461_pos
    .local int rx1461_off
    .local int rx1461_eos
    .local int rx1461_rep
    .local pmc rx1461_cur
    .local pmc rx1461_debug
    (rx1461_cur, rx1461_pos, rx1461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1461_cur
    .local pmc match
    .lex "$/", match
    length rx1461_eos, rx1461_tgt
    gt rx1461_pos, rx1461_eos, rx1461_done
    set rx1461_off, 0
    lt rx1461_pos, 2, rx1461_start
    sub rx1461_off, rx1461_pos, 1
    substr rx1461_tgt, rx1461_tgt, rx1461_off
  rx1461_start:
    eq $I10, 1, rx1461_restart
    if_null rx1461_debug, debug_1128
    rx1461_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1128:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1465_done
    goto rxscan1465_scan
  rxscan1465_loop:
    (rx1461_pos) = rx1461_cur."from"()
    inc rx1461_pos
    rx1461_cur."!cursor_from"(rx1461_pos)
    ge rx1461_pos, rx1461_eos, rxscan1465_done
  rxscan1465_scan:
    set_addr $I10, rxscan1465_loop
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  rxscan1465_done:
.annotate 'line', 578
  # rx subcapture "sym"
    set_addr $I10, rxcap_1466_fail
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1461_pos, 2
    gt $I11, rx1461_eos, rx1461_fail
    sub $I11, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I11, 2
    ne $S10, "qq", rx1461_fail
    add rx1461_pos, 2
    set_addr $I10, rxcap_1466_fail
    ($I12, $I11) = rx1461_cur."!mark_peek"($I10)
    rx1461_cur."!cursor_pos"($I11)
    ($P10) = rx1461_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1461_pos, "")
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1466_done
  rxcap_1466_fail:
    goto rx1461_fail
  rxcap_1466_done:
  # rxanchor rwb
    le rx1461_pos, 0, rx1461_fail
    sub $I10, rx1461_pos, rx1461_off
    is_cclass $I11, 8192, rx1461_tgt, $I10
    if $I11, rx1461_fail
    dec $I10
    is_cclass $I11, 8192, rx1461_tgt, $I10
    unless $I11, rx1461_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1461_fail
  # rx subrule "ws" subtype=method negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."ws"()
    unless $P10, rx1461_fail
    rx1461_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."quote_EXPR"(":qq")
    unless $P10, rx1461_fail
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1461_pos = $P10."pos"()
  # rx pass
    rx1461_cur."!cursor_pass"(rx1461_pos, "quote:sym<qq>")
    if_null rx1461_debug, debug_1129
    rx1461_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1461_pos)
  debug_1129:
    .return (rx1461_cur)
  rx1461_restart:
.annotate 'line', 10
    if_null rx1461_debug, debug_1130
    rx1461_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1130:
  rx1461_fail:
    (rx1461_rep, rx1461_pos, $I10, $P10) = rx1461_cur."!mark_fail"(0)
    lt rx1461_pos, -1, rx1461_done
    eq rx1461_pos, -1, rx1461_fail
    jump $I10
  rx1461_done:
    rx1461_cur."!cursor_fail"()
    if_null rx1461_debug, debug_1131
    rx1461_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1131:
    .return (rx1461_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("246_1303748459.273") :method
.annotate 'line', 10
    $P1463 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1464, "ResizablePMCArray"
    push $P1464, $P1463
    .return ($P1464)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("247_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1468_tgt
    .local int rx1468_pos
    .local int rx1468_off
    .local int rx1468_eos
    .local int rx1468_rep
    .local pmc rx1468_cur
    .local pmc rx1468_debug
    (rx1468_cur, rx1468_pos, rx1468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1468_cur
    .local pmc match
    .lex "$/", match
    length rx1468_eos, rx1468_tgt
    gt rx1468_pos, rx1468_eos, rx1468_done
    set rx1468_off, 0
    lt rx1468_pos, 2, rx1468_start
    sub rx1468_off, rx1468_pos, 1
    substr rx1468_tgt, rx1468_tgt, rx1468_off
  rx1468_start:
    eq $I10, 1, rx1468_restart
    if_null rx1468_debug, debug_1132
    rx1468_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1132:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1472_done
    goto rxscan1472_scan
  rxscan1472_loop:
    (rx1468_pos) = rx1468_cur."from"()
    inc rx1468_pos
    rx1468_cur."!cursor_from"(rx1468_pos)
    ge rx1468_pos, rx1468_eos, rxscan1472_done
  rxscan1472_scan:
    set_addr $I10, rxscan1472_loop
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  rxscan1472_done:
.annotate 'line', 579
  # rx subcapture "sym"
    set_addr $I10, rxcap_1473_fail
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1468_pos, 1
    gt $I11, rx1468_eos, rx1468_fail
    sub $I11, rx1468_pos, rx1468_off
    ord $I11, rx1468_tgt, $I11
    ne $I11, 81, rx1468_fail
    add rx1468_pos, 1
    set_addr $I10, rxcap_1473_fail
    ($I12, $I11) = rx1468_cur."!mark_peek"($I10)
    rx1468_cur."!cursor_pos"($I11)
    ($P10) = rx1468_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1468_pos, "")
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1473_done
  rxcap_1473_fail:
    goto rx1468_fail
  rxcap_1473_done:
  # rxanchor rwb
    le rx1468_pos, 0, rx1468_fail
    sub $I10, rx1468_pos, rx1468_off
    is_cclass $I11, 8192, rx1468_tgt, $I10
    if $I11, rx1468_fail
    dec $I10
    is_cclass $I11, 8192, rx1468_tgt, $I10
    unless $I11, rx1468_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1468_pos, rx1468_off
    substr $S10, rx1468_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1468_fail
  # rx subrule "ws" subtype=method negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."ws"()
    unless $P10, rx1468_fail
    rx1468_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."quote_EXPR"()
    unless $P10, rx1468_fail
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1468_pos = $P10."pos"()
  # rx pass
    rx1468_cur."!cursor_pass"(rx1468_pos, "quote:sym<Q>")
    if_null rx1468_debug, debug_1133
    rx1468_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1468_pos)
  debug_1133:
    .return (rx1468_cur)
  rx1468_restart:
.annotate 'line', 10
    if_null rx1468_debug, debug_1134
    rx1468_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1134:
  rx1468_fail:
    (rx1468_rep, rx1468_pos, $I10, $P10) = rx1468_cur."!mark_fail"(0)
    lt rx1468_pos, -1, rx1468_done
    eq rx1468_pos, -1, rx1468_fail
    jump $I10
  rx1468_done:
    rx1468_cur."!cursor_fail"()
    if_null rx1468_debug, debug_1135
    rx1468_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1135:
    .return (rx1468_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("248_1303748459.273") :method
.annotate 'line', 10
    $P1470 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1471, "ResizablePMCArray"
    push $P1471, $P1470
    .return ($P1471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("249_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1475_tgt
    .local int rx1475_pos
    .local int rx1475_off
    .local int rx1475_eos
    .local int rx1475_rep
    .local pmc rx1475_cur
    .local pmc rx1475_debug
    (rx1475_cur, rx1475_pos, rx1475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1475_cur
    .local pmc match
    .lex "$/", match
    length rx1475_eos, rx1475_tgt
    gt rx1475_pos, rx1475_eos, rx1475_done
    set rx1475_off, 0
    lt rx1475_pos, 2, rx1475_start
    sub rx1475_off, rx1475_pos, 1
    substr rx1475_tgt, rx1475_tgt, rx1475_off
  rx1475_start:
    eq $I10, 1, rx1475_restart
    if_null rx1475_debug, debug_1136
    rx1475_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1479_done
    goto rxscan1479_scan
  rxscan1479_loop:
    (rx1475_pos) = rx1475_cur."from"()
    inc rx1475_pos
    rx1475_cur."!cursor_from"(rx1475_pos)
    ge rx1475_pos, rx1475_eos, rxscan1479_done
  rxscan1479_scan:
    set_addr $I10, rxscan1479_loop
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  rxscan1479_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1480_fail
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1475_pos, 5
    gt $I11, rx1475_eos, rx1475_fail
    sub $I11, rx1475_pos, rx1475_off
    substr $S10, rx1475_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1475_fail
    add rx1475_pos, 5
    set_addr $I10, rxcap_1480_fail
    ($I12, $I11) = rx1475_cur."!mark_peek"($I10)
    rx1475_cur."!cursor_pos"($I11)
    ($P10) = rx1475_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1475_pos, "")
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1480_done
  rxcap_1480_fail:
    goto rx1475_fail
  rxcap_1480_done:
  # rx subrule "ws" subtype=method negate=
    rx1475_cur."!cursor_pos"(rx1475_pos)
    $P10 = rx1475_cur."ws"()
    unless $P10, rx1475_fail
    rx1475_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1475_cur."!cursor_pos"(rx1475_pos)
    $P10 = rx1475_cur."quote_EXPR"()
    unless $P10, rx1475_fail
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1475_pos = $P10."pos"()
  # rx pass
    rx1475_cur."!cursor_pass"(rx1475_pos, "quote:sym<Q:PIR>")
    if_null rx1475_debug, debug_1137
    rx1475_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1475_pos)
  debug_1137:
    .return (rx1475_cur)
  rx1475_restart:
.annotate 'line', 10
    if_null rx1475_debug, debug_1138
    rx1475_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1138:
  rx1475_fail:
    (rx1475_rep, rx1475_pos, $I10, $P10) = rx1475_cur."!mark_fail"(0)
    lt rx1475_pos, -1, rx1475_done
    eq rx1475_pos, -1, rx1475_fail
    jump $I10
  rx1475_done:
    rx1475_cur."!cursor_fail"()
    if_null rx1475_debug, debug_1139
    rx1475_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1139:
    .return (rx1475_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("250_1303748459.273") :method
.annotate 'line', 10
    $P1477 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1478, "ResizablePMCArray"
    push $P1478, $P1477
    .return ($P1478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("251_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1482_tgt
    .local int rx1482_pos
    .local int rx1482_off
    .local int rx1482_eos
    .local int rx1482_rep
    .local pmc rx1482_cur
    .local pmc rx1482_debug
    (rx1482_cur, rx1482_pos, rx1482_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1482_cur
    .local pmc match
    .lex "$/", match
    length rx1482_eos, rx1482_tgt
    gt rx1482_pos, rx1482_eos, rx1482_done
    set rx1482_off, 0
    lt rx1482_pos, 2, rx1482_start
    sub rx1482_off, rx1482_pos, 1
    substr rx1482_tgt, rx1482_tgt, rx1482_off
  rx1482_start:
    eq $I10, 1, rx1482_restart
    if_null rx1482_debug, debug_1140
    rx1482_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1486_done
    goto rxscan1486_scan
  rxscan1486_loop:
    (rx1482_pos) = rx1482_cur."from"()
    inc rx1482_pos
    rx1482_cur."!cursor_from"(rx1482_pos)
    ge rx1482_pos, rx1482_eos, rxscan1486_done
  rxscan1486_scan:
    set_addr $I10, rxscan1486_loop
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  rxscan1486_done:
.annotate 'line', 582
  # rx literal  "/"
    add $I11, rx1482_pos, 1
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    ord $I11, rx1482_tgt, $I11
    ne $I11, 47, rx1482_fail
    add rx1482_pos, 1
.annotate 'line', 583
  # rx subrule "newpad" subtype=method negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."newpad"()
    unless $P10, rx1482_fail
    rx1482_pos = $P10."pos"()
.annotate 'line', 584
  # rx reduce name="quote:sym</ />" key="open"
    rx1482_cur."!cursor_pos"(rx1482_pos)
    rx1482_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 585
  # rx subrule "LANG" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1482_pos = $P10."pos"()
.annotate 'line', 586
  # rx literal  "/"
    add $I11, rx1482_pos, 1
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    ord $I11, rx1482_tgt, $I11
    ne $I11, 47, rx1482_fail
    add rx1482_pos, 1
.annotate 'line', 581
  # rx pass
    rx1482_cur."!cursor_pass"(rx1482_pos, "quote:sym</ />")
    if_null rx1482_debug, debug_1141
    rx1482_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1482_pos)
  debug_1141:
    .return (rx1482_cur)
  rx1482_restart:
.annotate 'line', 10
    if_null rx1482_debug, debug_1142
    rx1482_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1142:
  rx1482_fail:
    (rx1482_rep, rx1482_pos, $I10, $P10) = rx1482_cur."!mark_fail"(0)
    lt rx1482_pos, -1, rx1482_done
    eq rx1482_pos, -1, rx1482_fail
    jump $I10
  rx1482_done:
    rx1482_cur."!cursor_fail"()
    if_null rx1482_debug, debug_1143
    rx1482_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1143:
    .return (rx1482_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("252_1303748459.273") :method
.annotate 'line', 10
    $P1484 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1485, "ResizablePMCArray"
    push $P1485, $P1484
    .return ($P1485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("253_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1488_tgt
    .local int rx1488_pos
    .local int rx1488_off
    .local int rx1488_eos
    .local int rx1488_rep
    .local pmc rx1488_cur
    .local pmc rx1488_debug
    (rx1488_cur, rx1488_pos, rx1488_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1488_cur
    .local pmc match
    .lex "$/", match
    length rx1488_eos, rx1488_tgt
    gt rx1488_pos, rx1488_eos, rx1488_done
    set rx1488_off, 0
    lt rx1488_pos, 2, rx1488_start
    sub rx1488_off, rx1488_pos, 1
    substr rx1488_tgt, rx1488_tgt, rx1488_off
  rx1488_start:
    eq $I10, 1, rx1488_restart
    if_null rx1488_debug, debug_1144
    rx1488_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1144:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1491_done
    goto rxscan1491_scan
  rxscan1491_loop:
    (rx1488_pos) = rx1488_cur."from"()
    inc rx1488_pos
    rx1488_cur."!cursor_from"(rx1488_pos)
    ge rx1488_pos, rx1488_eos, rxscan1491_done
  rxscan1491_scan:
    set_addr $I10, rxscan1491_loop
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  rxscan1491_done:
.annotate 'line', 589
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1488_pos, rx1488_off
    substr $S10, rx1488_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1488_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."quotemod_check"("s")
    unless $P10, rx1488_fail
  # rx subrule "variable" subtype=capture negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."variable"()
    unless $P10, rx1488_fail
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1488_pos = $P10."pos"()
  # rx pass
    rx1488_cur."!cursor_pass"(rx1488_pos, "quote_escape:sym<$>")
    if_null rx1488_debug, debug_1145
    rx1488_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1488_pos)
  debug_1145:
    .return (rx1488_cur)
  rx1488_restart:
.annotate 'line', 10
    if_null rx1488_debug, debug_1146
    rx1488_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1146:
  rx1488_fail:
    (rx1488_rep, rx1488_pos, $I10, $P10) = rx1488_cur."!mark_fail"(0)
    lt rx1488_pos, -1, rx1488_done
    eq rx1488_pos, -1, rx1488_fail
    jump $I10
  rx1488_done:
    rx1488_cur."!cursor_fail"()
    if_null rx1488_debug, debug_1147
    rx1488_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1147:
    .return (rx1488_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("254_1303748459.273") :method
.annotate 'line', 10
    new $P1490, "ResizablePMCArray"
    push $P1490, "$"
    .return ($P1490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("255_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1493_tgt
    .local int rx1493_pos
    .local int rx1493_off
    .local int rx1493_eos
    .local int rx1493_rep
    .local pmc rx1493_cur
    .local pmc rx1493_debug
    (rx1493_cur, rx1493_pos, rx1493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1493_cur
    .local pmc match
    .lex "$/", match
    length rx1493_eos, rx1493_tgt
    gt rx1493_pos, rx1493_eos, rx1493_done
    set rx1493_off, 0
    lt rx1493_pos, 2, rx1493_start
    sub rx1493_off, rx1493_pos, 1
    substr rx1493_tgt, rx1493_tgt, rx1493_off
  rx1493_start:
    eq $I10, 1, rx1493_restart
    if_null rx1493_debug, debug_1148
    rx1493_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1496_done
    goto rxscan1496_scan
  rxscan1496_loop:
    (rx1493_pos) = rx1493_cur."from"()
    inc rx1493_pos
    rx1493_cur."!cursor_from"(rx1493_pos)
    ge rx1493_pos, rx1493_eos, rxscan1496_done
  rxscan1496_scan:
    set_addr $I10, rxscan1496_loop
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  rxscan1496_done:
.annotate 'line', 590
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1493_pos, rx1493_off
    substr $S10, rx1493_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1493_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."quotemod_check"("c")
    unless $P10, rx1493_fail
  # rx subrule "block" subtype=capture negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."block"()
    unless $P10, rx1493_fail
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1493_pos = $P10."pos"()
  # rx pass
    rx1493_cur."!cursor_pass"(rx1493_pos, "quote_escape:sym<{ }>")
    if_null rx1493_debug, debug_1149
    rx1493_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1493_pos)
  debug_1149:
    .return (rx1493_cur)
  rx1493_restart:
.annotate 'line', 10
    if_null rx1493_debug, debug_1150
    rx1493_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1150:
  rx1493_fail:
    (rx1493_rep, rx1493_pos, $I10, $P10) = rx1493_cur."!mark_fail"(0)
    lt rx1493_pos, -1, rx1493_done
    eq rx1493_pos, -1, rx1493_fail
    jump $I10
  rx1493_done:
    rx1493_cur."!cursor_fail"()
    if_null rx1493_debug, debug_1151
    rx1493_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1151:
    .return (rx1493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("256_1303748459.273") :method
.annotate 'line', 10
    new $P1495, "ResizablePMCArray"
    push $P1495, "{"
    .return ($P1495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("257_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1498_tgt
    .local int rx1498_pos
    .local int rx1498_off
    .local int rx1498_eos
    .local int rx1498_rep
    .local pmc rx1498_cur
    .local pmc rx1498_debug
    (rx1498_cur, rx1498_pos, rx1498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1498_cur
    .local pmc match
    .lex "$/", match
    length rx1498_eos, rx1498_tgt
    gt rx1498_pos, rx1498_eos, rx1498_done
    set rx1498_off, 0
    lt rx1498_pos, 2, rx1498_start
    sub rx1498_off, rx1498_pos, 1
    substr rx1498_tgt, rx1498_tgt, rx1498_off
  rx1498_start:
    eq $I10, 1, rx1498_restart
    if_null rx1498_debug, debug_1152
    rx1498_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1152:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1501_done
    goto rxscan1501_scan
  rxscan1501_loop:
    (rx1498_pos) = rx1498_cur."from"()
    inc rx1498_pos
    rx1498_cur."!cursor_from"(rx1498_pos)
    ge rx1498_pos, rx1498_eos, rxscan1501_done
  rxscan1501_scan:
    set_addr $I10, rxscan1501_loop
    rx1498_cur."!mark_push"(0, rx1498_pos, $I10)
  rxscan1501_done:
.annotate 'line', 591
  # rx literal  "\\e"
    add $I11, rx1498_pos, 2
    gt $I11, rx1498_eos, rx1498_fail
    sub $I11, rx1498_pos, rx1498_off
    substr $S10, rx1498_tgt, $I11, 2
    ne $S10, "\\e", rx1498_fail
    add rx1498_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1498_cur."!cursor_pos"(rx1498_pos)
    $P10 = rx1498_cur."quotemod_check"("b")
    unless $P10, rx1498_fail
  # rx pass
    rx1498_cur."!cursor_pass"(rx1498_pos, "quote_escape:sym<esc>")
    if_null rx1498_debug, debug_1153
    rx1498_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1498_pos)
  debug_1153:
    .return (rx1498_cur)
  rx1498_restart:
.annotate 'line', 10
    if_null rx1498_debug, debug_1154
    rx1498_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1154:
  rx1498_fail:
    (rx1498_rep, rx1498_pos, $I10, $P10) = rx1498_cur."!mark_fail"(0)
    lt rx1498_pos, -1, rx1498_done
    eq rx1498_pos, -1, rx1498_fail
    jump $I10
  rx1498_done:
    rx1498_cur."!cursor_fail"()
    if_null rx1498_debug, debug_1155
    rx1498_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1155:
    .return (rx1498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("258_1303748459.273") :method
.annotate 'line', 10
    new $P1500, "ResizablePMCArray"
    push $P1500, "\\e"
    .return ($P1500)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("259_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1503_tgt
    .local int rx1503_pos
    .local int rx1503_off
    .local int rx1503_eos
    .local int rx1503_rep
    .local pmc rx1503_cur
    .local pmc rx1503_debug
    (rx1503_cur, rx1503_pos, rx1503_tgt, $I10) = self."!cursor_start"()
    rx1503_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1503_cur
    .local pmc match
    .lex "$/", match
    length rx1503_eos, rx1503_tgt
    gt rx1503_pos, rx1503_eos, rx1503_done
    set rx1503_off, 0
    lt rx1503_pos, 2, rx1503_start
    sub rx1503_off, rx1503_pos, 1
    substr rx1503_tgt, rx1503_tgt, rx1503_off
  rx1503_start:
    eq $I10, 1, rx1503_restart
    if_null rx1503_debug, debug_1156
    rx1503_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1156:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1507_done
    goto rxscan1507_scan
  rxscan1507_loop:
    (rx1503_pos) = rx1503_cur."from"()
    inc rx1503_pos
    rx1503_cur."!cursor_from"(rx1503_pos)
    ge rx1503_pos, rx1503_eos, rxscan1507_done
  rxscan1507_scan:
    set_addr $I10, rxscan1507_loop
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  rxscan1507_done:
.annotate 'line', 593
  # rx literal  "("
    add $I11, rx1503_pos, 1
    gt $I11, rx1503_eos, rx1503_fail
    sub $I11, rx1503_pos, rx1503_off
    ord $I11, rx1503_tgt, $I11
    ne $I11, 40, rx1503_fail
    add rx1503_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1503_cur."!cursor_pos"(rx1503_pos)
    $P10 = rx1503_cur."ws"()
    unless $P10, rx1503_fail
    rx1503_pos = $P10."pos"()
  # rx rxquantr1508 ** 0..1
    set_addr $I10, rxquantr1508_done
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  rxquantr1508_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1503_cur."!cursor_pos"(rx1503_pos)
    $P10 = rx1503_cur."EXPR"()
    unless $P10, rx1503_fail
    goto rxsubrule1509_pass
  rxsubrule1509_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1503_fail
  rxsubrule1509_pass:
    set_addr $I10, rxsubrule1509_back
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1503_pos = $P10."pos"()
    set_addr $I10, rxquantr1508_done
    (rx1503_rep) = rx1503_cur."!mark_commit"($I10)
  rxquantr1508_done:
  # rx literal  ")"
    add $I11, rx1503_pos, 1
    gt $I11, rx1503_eos, rx1503_fail
    sub $I11, rx1503_pos, rx1503_off
    ord $I11, rx1503_tgt, $I11
    ne $I11, 41, rx1503_fail
    add rx1503_pos, 1
  # rx pass
    rx1503_cur."!cursor_pass"(rx1503_pos, "circumfix:sym<( )>")
    if_null rx1503_debug, debug_1157
    rx1503_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1503_pos)
  debug_1157:
    .return (rx1503_cur)
  rx1503_restart:
.annotate 'line', 10
    if_null rx1503_debug, debug_1158
    rx1503_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1158:
  rx1503_fail:
    (rx1503_rep, rx1503_pos, $I10, $P10) = rx1503_cur."!mark_fail"(0)
    lt rx1503_pos, -1, rx1503_done
    eq rx1503_pos, -1, rx1503_fail
    jump $I10
  rx1503_done:
    rx1503_cur."!cursor_fail"()
    if_null rx1503_debug, debug_1159
    rx1503_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1159:
    .return (rx1503_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("260_1303748459.273") :method
.annotate 'line', 10
    $P1505 = self."!PREFIX__!subrule"("ws", "(")
    new $P1506, "ResizablePMCArray"
    push $P1506, $P1505
    .return ($P1506)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("261_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1511_tgt
    .local int rx1511_pos
    .local int rx1511_off
    .local int rx1511_eos
    .local int rx1511_rep
    .local pmc rx1511_cur
    .local pmc rx1511_debug
    (rx1511_cur, rx1511_pos, rx1511_tgt, $I10) = self."!cursor_start"()
    rx1511_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1511_cur
    .local pmc match
    .lex "$/", match
    length rx1511_eos, rx1511_tgt
    gt rx1511_pos, rx1511_eos, rx1511_done
    set rx1511_off, 0
    lt rx1511_pos, 2, rx1511_start
    sub rx1511_off, rx1511_pos, 1
    substr rx1511_tgt, rx1511_tgt, rx1511_off
  rx1511_start:
    eq $I10, 1, rx1511_restart
    if_null rx1511_debug, debug_1160
    rx1511_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1515_done
    goto rxscan1515_scan
  rxscan1515_loop:
    (rx1511_pos) = rx1511_cur."from"()
    inc rx1511_pos
    rx1511_cur."!cursor_from"(rx1511_pos)
    ge rx1511_pos, rx1511_eos, rxscan1515_done
  rxscan1515_scan:
    set_addr $I10, rxscan1515_loop
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxscan1515_done:
.annotate 'line', 594
  # rx literal  "["
    add $I11, rx1511_pos, 1
    gt $I11, rx1511_eos, rx1511_fail
    sub $I11, rx1511_pos, rx1511_off
    ord $I11, rx1511_tgt, $I11
    ne $I11, 91, rx1511_fail
    add rx1511_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."ws"()
    unless $P10, rx1511_fail
    rx1511_pos = $P10."pos"()
  # rx rxquantr1516 ** 0..1
    set_addr $I10, rxquantr1516_done
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxquantr1516_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."EXPR"()
    unless $P10, rx1511_fail
    goto rxsubrule1517_pass
  rxsubrule1517_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1511_fail
  rxsubrule1517_pass:
    set_addr $I10, rxsubrule1517_back
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1511_pos = $P10."pos"()
    set_addr $I10, rxquantr1516_done
    (rx1511_rep) = rx1511_cur."!mark_commit"($I10)
  rxquantr1516_done:
  # rx literal  "]"
    add $I11, rx1511_pos, 1
    gt $I11, rx1511_eos, rx1511_fail
    sub $I11, rx1511_pos, rx1511_off
    ord $I11, rx1511_tgt, $I11
    ne $I11, 93, rx1511_fail
    add rx1511_pos, 1
  # rx pass
    rx1511_cur."!cursor_pass"(rx1511_pos, "circumfix:sym<[ ]>")
    if_null rx1511_debug, debug_1161
    rx1511_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1511_pos)
  debug_1161:
    .return (rx1511_cur)
  rx1511_restart:
.annotate 'line', 10
    if_null rx1511_debug, debug_1162
    rx1511_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1162:
  rx1511_fail:
    (rx1511_rep, rx1511_pos, $I10, $P10) = rx1511_cur."!mark_fail"(0)
    lt rx1511_pos, -1, rx1511_done
    eq rx1511_pos, -1, rx1511_fail
    jump $I10
  rx1511_done:
    rx1511_cur."!cursor_fail"()
    if_null rx1511_debug, debug_1163
    rx1511_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1163:
    .return (rx1511_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("262_1303748459.273") :method
.annotate 'line', 10
    $P1513 = self."!PREFIX__!subrule"("ws", "[")
    new $P1514, "ResizablePMCArray"
    push $P1514, $P1513
    .return ($P1514)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("263_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1519_tgt
    .local int rx1519_pos
    .local int rx1519_off
    .local int rx1519_eos
    .local int rx1519_rep
    .local pmc rx1519_cur
    .local pmc rx1519_debug
    (rx1519_cur, rx1519_pos, rx1519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1519_cur
    .local pmc match
    .lex "$/", match
    length rx1519_eos, rx1519_tgt
    gt rx1519_pos, rx1519_eos, rx1519_done
    set rx1519_off, 0
    lt rx1519_pos, 2, rx1519_start
    sub rx1519_off, rx1519_pos, 1
    substr rx1519_tgt, rx1519_tgt, rx1519_off
  rx1519_start:
    eq $I10, 1, rx1519_restart
    if_null rx1519_debug, debug_1164
    rx1519_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1164:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1522_done
    goto rxscan1522_scan
  rxscan1522_loop:
    (rx1519_pos) = rx1519_cur."from"()
    inc rx1519_pos
    rx1519_cur."!cursor_from"(rx1519_pos)
    ge rx1519_pos, rx1519_eos, rxscan1522_done
  rxscan1522_scan:
    set_addr $I10, rxscan1522_loop
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  rxscan1522_done:
.annotate 'line', 595
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1519_pos, rx1519_off
    substr $S10, rx1519_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1519_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1519_fail
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1519_pos = $P10."pos"()
  # rx pass
    rx1519_cur."!cursor_pass"(rx1519_pos, "circumfix:sym<ang>")
    if_null rx1519_debug, debug_1165
    rx1519_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1519_pos)
  debug_1165:
    .return (rx1519_cur)
  rx1519_restart:
.annotate 'line', 10
    if_null rx1519_debug, debug_1166
    rx1519_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1166:
  rx1519_fail:
    (rx1519_rep, rx1519_pos, $I10, $P10) = rx1519_cur."!mark_fail"(0)
    lt rx1519_pos, -1, rx1519_done
    eq rx1519_pos, -1, rx1519_fail
    jump $I10
  rx1519_done:
    rx1519_cur."!cursor_fail"()
    if_null rx1519_debug, debug_1167
    rx1519_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1167:
    .return (rx1519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("264_1303748459.273") :method
.annotate 'line', 10
    new $P1521, "ResizablePMCArray"
    push $P1521, "<"
    .return ($P1521)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("265_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1524_tgt
    .local int rx1524_pos
    .local int rx1524_off
    .local int rx1524_eos
    .local int rx1524_rep
    .local pmc rx1524_cur
    .local pmc rx1524_debug
    (rx1524_cur, rx1524_pos, rx1524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1524_cur
    .local pmc match
    .lex "$/", match
    length rx1524_eos, rx1524_tgt
    gt rx1524_pos, rx1524_eos, rx1524_done
    set rx1524_off, 0
    lt rx1524_pos, 2, rx1524_start
    sub rx1524_off, rx1524_pos, 1
    substr rx1524_tgt, rx1524_tgt, rx1524_off
  rx1524_start:
    eq $I10, 1, rx1524_restart
    if_null rx1524_debug, debug_1168
    rx1524_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1168:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1527_done
    goto rxscan1527_scan
  rxscan1527_loop:
    (rx1524_pos) = rx1524_cur."from"()
    inc rx1524_pos
    rx1524_cur."!cursor_from"(rx1524_pos)
    ge rx1524_pos, rx1524_eos, rxscan1527_done
  rxscan1527_scan:
    set_addr $I10, rxscan1527_loop
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  rxscan1527_done:
.annotate 'line', 596
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1524_pos, rx1524_off
    substr $S10, rx1524_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1524_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1524_fail
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1524_pos = $P10."pos"()
  # rx pass
    rx1524_cur."!cursor_pass"(rx1524_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1524_debug, debug_1169
    rx1524_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1524_pos)
  debug_1169:
    .return (rx1524_cur)
  rx1524_restart:
.annotate 'line', 10
    if_null rx1524_debug, debug_1170
    rx1524_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1170:
  rx1524_fail:
    (rx1524_rep, rx1524_pos, $I10, $P10) = rx1524_cur."!mark_fail"(0)
    lt rx1524_pos, -1, rx1524_done
    eq rx1524_pos, -1, rx1524_fail
    jump $I10
  rx1524_done:
    rx1524_cur."!cursor_fail"()
    if_null rx1524_debug, debug_1171
    rx1524_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1171:
    .return (rx1524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("266_1303748459.273") :method
.annotate 'line', 10
    new $P1526, "ResizablePMCArray"
    push $P1526, unicode:"\x{ab}"
    .return ($P1526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("267_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1529_tgt
    .local int rx1529_pos
    .local int rx1529_off
    .local int rx1529_eos
    .local int rx1529_rep
    .local pmc rx1529_cur
    .local pmc rx1529_debug
    (rx1529_cur, rx1529_pos, rx1529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1529_cur
    .local pmc match
    .lex "$/", match
    length rx1529_eos, rx1529_tgt
    gt rx1529_pos, rx1529_eos, rx1529_done
    set rx1529_off, 0
    lt rx1529_pos, 2, rx1529_start
    sub rx1529_off, rx1529_pos, 1
    substr rx1529_tgt, rx1529_tgt, rx1529_off
  rx1529_start:
    eq $I10, 1, rx1529_restart
    if_null rx1529_debug, debug_1172
    rx1529_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1172:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1532_done
    goto rxscan1532_scan
  rxscan1532_loop:
    (rx1529_pos) = rx1529_cur."from"()
    inc rx1529_pos
    rx1529_cur."!cursor_from"(rx1529_pos)
    ge rx1529_pos, rx1529_eos, rxscan1532_done
  rxscan1532_scan:
    set_addr $I10, rxscan1532_loop
    rx1529_cur."!mark_push"(0, rx1529_pos, $I10)
  rxscan1532_done:
.annotate 'line', 597
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1529_pos, rx1529_off
    substr $S10, rx1529_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1529_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1529_cur."!cursor_pos"(rx1529_pos)
    $P10 = rx1529_cur."pblock"()
    unless $P10, rx1529_fail
    rx1529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1529_pos = $P10."pos"()
  # rx pass
    rx1529_cur."!cursor_pass"(rx1529_pos, "circumfix:sym<{ }>")
    if_null rx1529_debug, debug_1173
    rx1529_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1529_pos)
  debug_1173:
    .return (rx1529_cur)
  rx1529_restart:
.annotate 'line', 10
    if_null rx1529_debug, debug_1174
    rx1529_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1174:
  rx1529_fail:
    (rx1529_rep, rx1529_pos, $I10, $P10) = rx1529_cur."!mark_fail"(0)
    lt rx1529_pos, -1, rx1529_done
    eq rx1529_pos, -1, rx1529_fail
    jump $I10
  rx1529_done:
    rx1529_cur."!cursor_fail"()
    if_null rx1529_debug, debug_1175
    rx1529_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1175:
    .return (rx1529_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("268_1303748459.273") :method
.annotate 'line', 10
    new $P1531, "ResizablePMCArray"
    push $P1531, "{"
    .return ($P1531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("269_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1534_tgt
    .local int rx1534_pos
    .local int rx1534_off
    .local int rx1534_eos
    .local int rx1534_rep
    .local pmc rx1534_cur
    .local pmc rx1534_debug
    (rx1534_cur, rx1534_pos, rx1534_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1534_cur
    .local pmc match
    .lex "$/", match
    length rx1534_eos, rx1534_tgt
    gt rx1534_pos, rx1534_eos, rx1534_done
    set rx1534_off, 0
    lt rx1534_pos, 2, rx1534_start
    sub rx1534_off, rx1534_pos, 1
    substr rx1534_tgt, rx1534_tgt, rx1534_off
  rx1534_start:
    eq $I10, 1, rx1534_restart
    if_null rx1534_debug, debug_1176
    rx1534_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1176:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1534_pos) = rx1534_cur."from"()
    inc rx1534_pos
    rx1534_cur."!cursor_from"(rx1534_pos)
    ge rx1534_pos, rx1534_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  rxscan1538_done:
.annotate 'line', 598
  # rx subrule "sigil" subtype=capture negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."sigil"()
    unless $P10, rx1534_fail
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1534_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1534_pos, 1
    gt $I11, rx1534_eos, rx1534_fail
    sub $I11, rx1534_pos, rx1534_off
    ord $I11, rx1534_tgt, $I11
    ne $I11, 40, rx1534_fail
    add rx1534_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."semilist"()
    unless $P10, rx1534_fail
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1534_pos = $P10."pos"()
  alt1539_0:
    set_addr $I10, alt1539_1
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  # rx literal  ")"
    add $I11, rx1534_pos, 1
    gt $I11, rx1534_eos, rx1534_fail
    sub $I11, rx1534_pos, rx1534_off
    ord $I11, rx1534_tgt, $I11
    ne $I11, 41, rx1534_fail
    add rx1534_pos, 1
    goto alt1539_end
  alt1539_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."FAILGOAL"("')'")
    unless $P10, rx1534_fail
    goto rxsubrule1541_pass
  rxsubrule1541_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1534_fail
  rxsubrule1541_pass:
    set_addr $I10, rxsubrule1541_back
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10, $P10)
    rx1534_pos = $P10."pos"()
  alt1539_end:
  # rx pass
    rx1534_cur."!cursor_pass"(rx1534_pos, "circumfix:sym<sigil>")
    if_null rx1534_debug, debug_1177
    rx1534_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1534_pos)
  debug_1177:
    .return (rx1534_cur)
  rx1534_restart:
.annotate 'line', 10
    if_null rx1534_debug, debug_1178
    rx1534_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1178:
  rx1534_fail:
    (rx1534_rep, rx1534_pos, $I10, $P10) = rx1534_cur."!mark_fail"(0)
    lt rx1534_pos, -1, rx1534_done
    eq rx1534_pos, -1, rx1534_fail
    jump $I10
  rx1534_done:
    rx1534_cur."!cursor_fail"()
    if_null rx1534_debug, debug_1179
    rx1534_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1179:
    .return (rx1534_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("270_1303748459.273") :method
.annotate 'line', 10
    $P1536 = self."!PREFIX__!subrule"("sigil", "")
    new $P1537, "ResizablePMCArray"
    push $P1537, $P1536
    .return ($P1537)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("271_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1180
    rx1543_cur."!cursor_debug"("START", "semilist")
  debug_1180:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1547_done
    goto rxscan1547_scan
  rxscan1547_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1547_done
  rxscan1547_scan:
    set_addr $I10, rxscan1547_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1547_done:
.annotate 'line', 600
  # rx subrule "ws" subtype=method negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."ws"()
    unless $P10, rx1543_fail
    rx1543_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."statement"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1543_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."ws"()
    unless $P10, rx1543_fail
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "semilist")
    if_null rx1543_debug, debug_1181
    rx1543_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1543_pos)
  debug_1181:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 10
    if_null rx1543_debug, debug_1182
    rx1543_cur."!cursor_debug"("NEXT", "semilist")
  debug_1182:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1183
    rx1543_cur."!cursor_debug"("FAIL", "semilist")
  debug_1183:
    .return (rx1543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("272_1303748459.273") :method
.annotate 'line', 10
    $P1545 = self."!PREFIX__!subrule"("ws", "")
    new $P1546, "ResizablePMCArray"
    push $P1546, $P1545
    .return ($P1546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("273_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1551_tgt
    .local int rx1551_pos
    .local int rx1551_off
    .local int rx1551_eos
    .local int rx1551_rep
    .local pmc rx1551_cur
    .local pmc rx1551_debug
    (rx1551_cur, rx1551_pos, rx1551_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1551_cur
    .local pmc match
    .lex "$/", match
    length rx1551_eos, rx1551_tgt
    gt rx1551_pos, rx1551_eos, rx1551_done
    set rx1551_off, 0
    lt rx1551_pos, 2, rx1551_start
    sub rx1551_off, rx1551_pos, 1
    substr rx1551_tgt, rx1551_tgt, rx1551_off
  rx1551_start:
    eq $I10, 1, rx1551_restart
    if_null rx1551_debug, debug_1184
    rx1551_cur."!cursor_debug"("START", "infixish")
  debug_1184:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1554_done
    goto rxscan1554_scan
  rxscan1554_loop:
    (rx1551_pos) = rx1551_cur."from"()
    inc rx1551_pos
    rx1551_cur."!cursor_from"(rx1551_pos)
    ge rx1551_pos, rx1551_eos, rxscan1554_done
  rxscan1554_scan:
    set_addr $I10, rxscan1554_loop
    rx1551_cur."!mark_push"(0, rx1551_pos, $I10)
  rxscan1554_done:
.annotate 'line', 623
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1551_cur."!cursor_pos"(rx1551_pos)
    $P10 = rx1551_cur."infixstopper"()
    if $P10, rx1551_fail
  # rx subrule "infix" subtype=capture negate=
    rx1551_cur."!cursor_pos"(rx1551_pos)
    $P10 = rx1551_cur."infix"()
    unless $P10, rx1551_fail
    rx1551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1551_pos = $P10."pos"()
  # rx pass
    rx1551_cur."!cursor_pass"(rx1551_pos, "infixish")
    if_null rx1551_debug, debug_1185
    rx1551_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1551_pos)
  debug_1185:
    .return (rx1551_cur)
  rx1551_restart:
.annotate 'line', 10
    if_null rx1551_debug, debug_1186
    rx1551_cur."!cursor_debug"("NEXT", "infixish")
  debug_1186:
  rx1551_fail:
    (rx1551_rep, rx1551_pos, $I10, $P10) = rx1551_cur."!mark_fail"(0)
    lt rx1551_pos, -1, rx1551_done
    eq rx1551_pos, -1, rx1551_fail
    jump $I10
  rx1551_done:
    rx1551_cur."!cursor_fail"()
    if_null rx1551_debug, debug_1187
    rx1551_cur."!cursor_debug"("FAIL", "infixish")
  debug_1187:
    .return (rx1551_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("274_1303748459.273") :method
.annotate 'line', 10
    new $P1553, "ResizablePMCArray"
    push $P1553, ""
    .return ($P1553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("275_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1556_tgt
    .local int rx1556_pos
    .local int rx1556_off
    .local int rx1556_eos
    .local int rx1556_rep
    .local pmc rx1556_cur
    .local pmc rx1556_debug
    (rx1556_cur, rx1556_pos, rx1556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1556_cur
    .local pmc match
    .lex "$/", match
    length rx1556_eos, rx1556_tgt
    gt rx1556_pos, rx1556_eos, rx1556_done
    set rx1556_off, 0
    lt rx1556_pos, 2, rx1556_start
    sub rx1556_off, rx1556_pos, 1
    substr rx1556_tgt, rx1556_tgt, rx1556_off
  rx1556_start:
    eq $I10, 1, rx1556_restart
    if_null rx1556_debug, debug_1188
    rx1556_cur."!cursor_debug"("START", "infixstopper")
  debug_1188:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1559_done
    goto rxscan1559_scan
  rxscan1559_loop:
    (rx1556_pos) = rx1556_cur."from"()
    inc rx1556_pos
    rx1556_cur."!cursor_from"(rx1556_pos)
    ge rx1556_pos, rx1556_eos, rxscan1559_done
  rxscan1559_scan:
    set_addr $I10, rxscan1559_loop
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  rxscan1559_done:
.annotate 'line', 624
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1556_cur."!cursor_pos"(rx1556_pos)
    $P10 = rx1556_cur."lambda"()
    unless $P10, rx1556_fail
  # rx pass
    rx1556_cur."!cursor_pass"(rx1556_pos, "infixstopper")
    if_null rx1556_debug, debug_1189
    rx1556_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1556_pos)
  debug_1189:
    .return (rx1556_cur)
  rx1556_restart:
.annotate 'line', 10
    if_null rx1556_debug, debug_1190
    rx1556_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1190:
  rx1556_fail:
    (rx1556_rep, rx1556_pos, $I10, $P10) = rx1556_cur."!mark_fail"(0)
    lt rx1556_pos, -1, rx1556_done
    eq rx1556_pos, -1, rx1556_fail
    jump $I10
  rx1556_done:
    rx1556_cur."!cursor_fail"()
    if_null rx1556_debug, debug_1191
    rx1556_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1191:
    .return (rx1556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("276_1303748459.273") :method
.annotate 'line', 10
    new $P1558, "ResizablePMCArray"
    push $P1558, ""
    .return ($P1558)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("277_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1561_tgt
    .local int rx1561_pos
    .local int rx1561_off
    .local int rx1561_eos
    .local int rx1561_rep
    .local pmc rx1561_cur
    .local pmc rx1561_debug
    (rx1561_cur, rx1561_pos, rx1561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1561_cur
    .local pmc match
    .lex "$/", match
    length rx1561_eos, rx1561_tgt
    gt rx1561_pos, rx1561_eos, rx1561_done
    set rx1561_off, 0
    lt rx1561_pos, 2, rx1561_start
    sub rx1561_off, rx1561_pos, 1
    substr rx1561_tgt, rx1561_tgt, rx1561_off
  rx1561_start:
    eq $I10, 1, rx1561_restart
    if_null rx1561_debug, debug_1192
    rx1561_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1192:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1565_done
    goto rxscan1565_scan
  rxscan1565_loop:
    (rx1561_pos) = rx1561_cur."from"()
    inc rx1561_pos
    rx1561_cur."!cursor_from"(rx1561_pos)
    ge rx1561_pos, rx1561_eos, rxscan1565_done
  rxscan1565_scan:
    set_addr $I10, rxscan1565_loop
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxscan1565_done:
.annotate 'line', 627
  # rx literal  "["
    add $I11, rx1561_pos, 1
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    ord $I11, rx1561_tgt, $I11
    ne $I11, 91, rx1561_fail
    add rx1561_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."ws"()
    unless $P10, rx1561_fail
    rx1561_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."EXPR"()
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1561_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1561_pos, 1
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    ord $I11, rx1561_tgt, $I11
    ne $I11, 93, rx1561_fail
    add rx1561_pos, 1
.annotate 'line', 628
  # rx subrule "O" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."O"("%methodop")
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1561_pos = $P10."pos"()
.annotate 'line', 626
  # rx pass
    rx1561_cur."!cursor_pass"(rx1561_pos, "postcircumfix:sym<[ ]>")
    if_null rx1561_debug, debug_1193
    rx1561_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1561_pos)
  debug_1193:
    .return (rx1561_cur)
  rx1561_restart:
.annotate 'line', 10
    if_null rx1561_debug, debug_1194
    rx1561_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1194:
  rx1561_fail:
    (rx1561_rep, rx1561_pos, $I10, $P10) = rx1561_cur."!mark_fail"(0)
    lt rx1561_pos, -1, rx1561_done
    eq rx1561_pos, -1, rx1561_fail
    jump $I10
  rx1561_done:
    rx1561_cur."!cursor_fail"()
    if_null rx1561_debug, debug_1195
    rx1561_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1195:
    .return (rx1561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("278_1303748459.273") :method
.annotate 'line', 10
    $P1563 = self."!PREFIX__!subrule"("ws", "[")
    new $P1564, "ResizablePMCArray"
    push $P1564, $P1563
    .return ($P1564)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("279_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1567_tgt
    .local int rx1567_pos
    .local int rx1567_off
    .local int rx1567_eos
    .local int rx1567_rep
    .local pmc rx1567_cur
    .local pmc rx1567_debug
    (rx1567_cur, rx1567_pos, rx1567_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1567_cur
    .local pmc match
    .lex "$/", match
    length rx1567_eos, rx1567_tgt
    gt rx1567_pos, rx1567_eos, rx1567_done
    set rx1567_off, 0
    lt rx1567_pos, 2, rx1567_start
    sub rx1567_off, rx1567_pos, 1
    substr rx1567_tgt, rx1567_tgt, rx1567_off
  rx1567_start:
    eq $I10, 1, rx1567_restart
    if_null rx1567_debug, debug_1196
    rx1567_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1196:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1571_done
    goto rxscan1571_scan
  rxscan1571_loop:
    (rx1567_pos) = rx1567_cur."from"()
    inc rx1567_pos
    rx1567_cur."!cursor_from"(rx1567_pos)
    ge rx1567_pos, rx1567_eos, rxscan1571_done
  rxscan1571_scan:
    set_addr $I10, rxscan1571_loop
    rx1567_cur."!mark_push"(0, rx1567_pos, $I10)
  rxscan1571_done:
.annotate 'line', 632
  # rx literal  "{"
    add $I11, rx1567_pos, 1
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    ord $I11, rx1567_tgt, $I11
    ne $I11, 123, rx1567_fail
    add rx1567_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."ws"()
    unless $P10, rx1567_fail
    rx1567_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."EXPR"()
    unless $P10, rx1567_fail
    rx1567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1567_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1567_pos, 1
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    ord $I11, rx1567_tgt, $I11
    ne $I11, 125, rx1567_fail
    add rx1567_pos, 1
.annotate 'line', 633
  # rx subrule "O" subtype=capture negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."O"("%methodop")
    unless $P10, rx1567_fail
    rx1567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1567_pos = $P10."pos"()
.annotate 'line', 631
  # rx pass
    rx1567_cur."!cursor_pass"(rx1567_pos, "postcircumfix:sym<{ }>")
    if_null rx1567_debug, debug_1197
    rx1567_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1567_pos)
  debug_1197:
    .return (rx1567_cur)
  rx1567_restart:
.annotate 'line', 10
    if_null rx1567_debug, debug_1198
    rx1567_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1198:
  rx1567_fail:
    (rx1567_rep, rx1567_pos, $I10, $P10) = rx1567_cur."!mark_fail"(0)
    lt rx1567_pos, -1, rx1567_done
    eq rx1567_pos, -1, rx1567_fail
    jump $I10
  rx1567_done:
    rx1567_cur."!cursor_fail"()
    if_null rx1567_debug, debug_1199
    rx1567_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1199:
    .return (rx1567_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("280_1303748459.273") :method
.annotate 'line', 10
    $P1569 = self."!PREFIX__!subrule"("ws", "{")
    new $P1570, "ResizablePMCArray"
    push $P1570, $P1569
    .return ($P1570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("281_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1573_tgt
    .local int rx1573_pos
    .local int rx1573_off
    .local int rx1573_eos
    .local int rx1573_rep
    .local pmc rx1573_cur
    .local pmc rx1573_debug
    (rx1573_cur, rx1573_pos, rx1573_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1573_cur
    .local pmc match
    .lex "$/", match
    length rx1573_eos, rx1573_tgt
    gt rx1573_pos, rx1573_eos, rx1573_done
    set rx1573_off, 0
    lt rx1573_pos, 2, rx1573_start
    sub rx1573_off, rx1573_pos, 1
    substr rx1573_tgt, rx1573_tgt, rx1573_off
  rx1573_start:
    eq $I10, 1, rx1573_restart
    if_null rx1573_debug, debug_1200
    rx1573_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1200:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1576_done
    goto rxscan1576_scan
  rxscan1576_loop:
    (rx1573_pos) = rx1573_cur."from"()
    inc rx1573_pos
    rx1573_cur."!cursor_from"(rx1573_pos)
    ge rx1573_pos, rx1573_eos, rxscan1576_done
  rxscan1576_scan:
    set_addr $I10, rxscan1576_loop
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  rxscan1576_done:
.annotate 'line', 637
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1573_pos, rx1573_off
    substr $S10, rx1573_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1573_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."quote_EXPR"(":q")
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1573_pos = $P10."pos"()
.annotate 'line', 638
  # rx subrule "O" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."O"("%methodop")
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1573_pos = $P10."pos"()
.annotate 'line', 636
  # rx pass
    rx1573_cur."!cursor_pass"(rx1573_pos, "postcircumfix:sym<ang>")
    if_null rx1573_debug, debug_1201
    rx1573_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1573_pos)
  debug_1201:
    .return (rx1573_cur)
  rx1573_restart:
.annotate 'line', 10
    if_null rx1573_debug, debug_1202
    rx1573_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1202:
  rx1573_fail:
    (rx1573_rep, rx1573_pos, $I10, $P10) = rx1573_cur."!mark_fail"(0)
    lt rx1573_pos, -1, rx1573_done
    eq rx1573_pos, -1, rx1573_fail
    jump $I10
  rx1573_done:
    rx1573_cur."!cursor_fail"()
    if_null rx1573_debug, debug_1203
    rx1573_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1203:
    .return (rx1573_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("282_1303748459.273") :method
.annotate 'line', 10
    new $P1575, "ResizablePMCArray"
    push $P1575, "<"
    .return ($P1575)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("283_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1578_tgt
    .local int rx1578_pos
    .local int rx1578_off
    .local int rx1578_eos
    .local int rx1578_rep
    .local pmc rx1578_cur
    .local pmc rx1578_debug
    (rx1578_cur, rx1578_pos, rx1578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1578_cur
    .local pmc match
    .lex "$/", match
    length rx1578_eos, rx1578_tgt
    gt rx1578_pos, rx1578_eos, rx1578_done
    set rx1578_off, 0
    lt rx1578_pos, 2, rx1578_start
    sub rx1578_off, rx1578_pos, 1
    substr rx1578_tgt, rx1578_tgt, rx1578_off
  rx1578_start:
    eq $I10, 1, rx1578_restart
    if_null rx1578_debug, debug_1204
    rx1578_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1204:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1582_done
    goto rxscan1582_scan
  rxscan1582_loop:
    (rx1578_pos) = rx1578_cur."from"()
    inc rx1578_pos
    rx1578_cur."!cursor_from"(rx1578_pos)
    ge rx1578_pos, rx1578_eos, rxscan1582_done
  rxscan1582_scan:
    set_addr $I10, rxscan1582_loop
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  rxscan1582_done:
.annotate 'line', 642
  # rx literal  "("
    add $I11, rx1578_pos, 1
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    ord $I11, rx1578_tgt, $I11
    ne $I11, 40, rx1578_fail
    add rx1578_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."ws"()
    unless $P10, rx1578_fail
    rx1578_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."arglist"()
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1578_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1578_pos, 1
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    ord $I11, rx1578_tgt, $I11
    ne $I11, 41, rx1578_fail
    add rx1578_pos, 1
.annotate 'line', 643
  # rx subrule "O" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."O"("%methodop")
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1578_pos = $P10."pos"()
.annotate 'line', 641
  # rx pass
    rx1578_cur."!cursor_pass"(rx1578_pos, "postcircumfix:sym<( )>")
    if_null rx1578_debug, debug_1205
    rx1578_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1578_pos)
  debug_1205:
    .return (rx1578_cur)
  rx1578_restart:
.annotate 'line', 10
    if_null rx1578_debug, debug_1206
    rx1578_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1206:
  rx1578_fail:
    (rx1578_rep, rx1578_pos, $I10, $P10) = rx1578_cur."!mark_fail"(0)
    lt rx1578_pos, -1, rx1578_done
    eq rx1578_pos, -1, rx1578_fail
    jump $I10
  rx1578_done:
    rx1578_cur."!cursor_fail"()
    if_null rx1578_debug, debug_1207
    rx1578_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1207:
    .return (rx1578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("284_1303748459.273") :method
.annotate 'line', 10
    $P1580 = self."!PREFIX__!subrule"("ws", "(")
    new $P1581, "ResizablePMCArray"
    push $P1581, $P1580
    .return ($P1581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("285_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1208
    rx1584_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1208:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1588_done:
.annotate 'line', 646
  # rx subrule "dotty" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."dotty"()
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1584_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."O"("%methodop")
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1584_pos = $P10."pos"()
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "postfix:sym<.>")
    if_null rx1584_debug, debug_1209
    rx1584_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1584_pos)
  debug_1209:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 10
    if_null rx1584_debug, debug_1210
    rx1584_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1210:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1211
    rx1584_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1211:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("286_1303748459.273") :method
.annotate 'line', 10
    $P1586 = self."!PREFIX__!subrule"("dotty", "")
    new $P1587, "ResizablePMCArray"
    push $P1587, $P1586
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("287_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1590_tgt
    .local int rx1590_pos
    .local int rx1590_off
    .local int rx1590_eos
    .local int rx1590_rep
    .local pmc rx1590_cur
    .local pmc rx1590_debug
    (rx1590_cur, rx1590_pos, rx1590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1590_cur
    .local pmc match
    .lex "$/", match
    length rx1590_eos, rx1590_tgt
    gt rx1590_pos, rx1590_eos, rx1590_done
    set rx1590_off, 0
    lt rx1590_pos, 2, rx1590_start
    sub rx1590_off, rx1590_pos, 1
    substr rx1590_tgt, rx1590_tgt, rx1590_off
  rx1590_start:
    eq $I10, 1, rx1590_restart
    if_null rx1590_debug, debug_1212
    rx1590_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1212:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1594_done
    goto rxscan1594_scan
  rxscan1594_loop:
    (rx1590_pos) = rx1590_cur."from"()
    inc rx1590_pos
    rx1590_cur."!cursor_from"(rx1590_pos)
    ge rx1590_pos, rx1590_eos, rxscan1594_done
  rxscan1594_scan:
    set_addr $I10, rxscan1594_loop
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  rxscan1594_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1595_fail
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  # rx literal  "++"
    add $I11, rx1590_pos, 2
    gt $I11, rx1590_eos, rx1590_fail
    sub $I11, rx1590_pos, rx1590_off
    substr $S10, rx1590_tgt, $I11, 2
    ne $S10, "++", rx1590_fail
    add rx1590_pos, 2
    set_addr $I10, rxcap_1595_fail
    ($I12, $I11) = rx1590_cur."!mark_peek"($I10)
    rx1590_cur."!cursor_pos"($I11)
    ($P10) = rx1590_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1590_pos, "")
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1595_done
  rxcap_1595_fail:
    goto rx1590_fail
  rxcap_1595_done:
  # rx subrule "O" subtype=capture negate=
    rx1590_cur."!cursor_pos"(rx1590_pos)
    $P10 = rx1590_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1590_fail
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1590_pos = $P10."pos"()
  # rx pass
    rx1590_cur."!cursor_pass"(rx1590_pos, "prefix:sym<++>")
    if_null rx1590_debug, debug_1213
    rx1590_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1590_pos)
  debug_1213:
    .return (rx1590_cur)
  rx1590_restart:
.annotate 'line', 10
    if_null rx1590_debug, debug_1214
    rx1590_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1214:
  rx1590_fail:
    (rx1590_rep, rx1590_pos, $I10, $P10) = rx1590_cur."!mark_fail"(0)
    lt rx1590_pos, -1, rx1590_done
    eq rx1590_pos, -1, rx1590_fail
    jump $I10
  rx1590_done:
    rx1590_cur."!cursor_fail"()
    if_null rx1590_debug, debug_1215
    rx1590_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1215:
    .return (rx1590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("288_1303748459.273") :method
.annotate 'line', 10
    $P1592 = self."!PREFIX__!subrule"("O", "++")
    new $P1593, "ResizablePMCArray"
    push $P1593, $P1592
    .return ($P1593)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("289_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1597_tgt
    .local int rx1597_pos
    .local int rx1597_off
    .local int rx1597_eos
    .local int rx1597_rep
    .local pmc rx1597_cur
    .local pmc rx1597_debug
    (rx1597_cur, rx1597_pos, rx1597_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1597_cur
    .local pmc match
    .lex "$/", match
    length rx1597_eos, rx1597_tgt
    gt rx1597_pos, rx1597_eos, rx1597_done
    set rx1597_off, 0
    lt rx1597_pos, 2, rx1597_start
    sub rx1597_off, rx1597_pos, 1
    substr rx1597_tgt, rx1597_tgt, rx1597_off
  rx1597_start:
    eq $I10, 1, rx1597_restart
    if_null rx1597_debug, debug_1216
    rx1597_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1216:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1601_done
    goto rxscan1601_scan
  rxscan1601_loop:
    (rx1597_pos) = rx1597_cur."from"()
    inc rx1597_pos
    rx1597_cur."!cursor_from"(rx1597_pos)
    ge rx1597_pos, rx1597_eos, rxscan1601_done
  rxscan1601_scan:
    set_addr $I10, rxscan1601_loop
    rx1597_cur."!mark_push"(0, rx1597_pos, $I10)
  rxscan1601_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1602_fail
    rx1597_cur."!mark_push"(0, rx1597_pos, $I10)
  # rx literal  "--"
    add $I11, rx1597_pos, 2
    gt $I11, rx1597_eos, rx1597_fail
    sub $I11, rx1597_pos, rx1597_off
    substr $S10, rx1597_tgt, $I11, 2
    ne $S10, "--", rx1597_fail
    add rx1597_pos, 2
    set_addr $I10, rxcap_1602_fail
    ($I12, $I11) = rx1597_cur."!mark_peek"($I10)
    rx1597_cur."!cursor_pos"($I11)
    ($P10) = rx1597_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1597_pos, "")
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1602_done
  rxcap_1602_fail:
    goto rx1597_fail
  rxcap_1602_done:
  # rx subrule "O" subtype=capture negate=
    rx1597_cur."!cursor_pos"(rx1597_pos)
    $P10 = rx1597_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1597_fail
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1597_pos = $P10."pos"()
  # rx pass
    rx1597_cur."!cursor_pass"(rx1597_pos, "prefix:sym<-->")
    if_null rx1597_debug, debug_1217
    rx1597_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1597_pos)
  debug_1217:
    .return (rx1597_cur)
  rx1597_restart:
.annotate 'line', 10
    if_null rx1597_debug, debug_1218
    rx1597_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1218:
  rx1597_fail:
    (rx1597_rep, rx1597_pos, $I10, $P10) = rx1597_cur."!mark_fail"(0)
    lt rx1597_pos, -1, rx1597_done
    eq rx1597_pos, -1, rx1597_fail
    jump $I10
  rx1597_done:
    rx1597_cur."!cursor_fail"()
    if_null rx1597_debug, debug_1219
    rx1597_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1219:
    .return (rx1597_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("290_1303748459.273") :method
.annotate 'line', 10
    $P1599 = self."!PREFIX__!subrule"("O", "--")
    new $P1600, "ResizablePMCArray"
    push $P1600, $P1599
    .return ($P1600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("291_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1604_tgt
    .local int rx1604_pos
    .local int rx1604_off
    .local int rx1604_eos
    .local int rx1604_rep
    .local pmc rx1604_cur
    .local pmc rx1604_debug
    (rx1604_cur, rx1604_pos, rx1604_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1604_cur
    .local pmc match
    .lex "$/", match
    length rx1604_eos, rx1604_tgt
    gt rx1604_pos, rx1604_eos, rx1604_done
    set rx1604_off, 0
    lt rx1604_pos, 2, rx1604_start
    sub rx1604_off, rx1604_pos, 1
    substr rx1604_tgt, rx1604_tgt, rx1604_off
  rx1604_start:
    eq $I10, 1, rx1604_restart
    if_null rx1604_debug, debug_1220
    rx1604_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1220:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1608_done
    goto rxscan1608_scan
  rxscan1608_loop:
    (rx1604_pos) = rx1604_cur."from"()
    inc rx1604_pos
    rx1604_cur."!cursor_from"(rx1604_pos)
    ge rx1604_pos, rx1604_eos, rxscan1608_done
  rxscan1608_scan:
    set_addr $I10, rxscan1608_loop
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxscan1608_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1609_fail
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  # rx literal  "++"
    add $I11, rx1604_pos, 2
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    substr $S10, rx1604_tgt, $I11, 2
    ne $S10, "++", rx1604_fail
    add rx1604_pos, 2
    set_addr $I10, rxcap_1609_fail
    ($I12, $I11) = rx1604_cur."!mark_peek"($I10)
    rx1604_cur."!cursor_pos"($I11)
    ($P10) = rx1604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1604_pos, "")
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1609_done
  rxcap_1609_fail:
    goto rx1604_fail
  rxcap_1609_done:
  # rx subrule "O" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."O"("%autoincrement")
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1604_pos = $P10."pos"()
  # rx pass
    rx1604_cur."!cursor_pass"(rx1604_pos, "postfix:sym<++>")
    if_null rx1604_debug, debug_1221
    rx1604_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1604_pos)
  debug_1221:
    .return (rx1604_cur)
  rx1604_restart:
.annotate 'line', 10
    if_null rx1604_debug, debug_1222
    rx1604_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1222:
  rx1604_fail:
    (rx1604_rep, rx1604_pos, $I10, $P10) = rx1604_cur."!mark_fail"(0)
    lt rx1604_pos, -1, rx1604_done
    eq rx1604_pos, -1, rx1604_fail
    jump $I10
  rx1604_done:
    rx1604_cur."!cursor_fail"()
    if_null rx1604_debug, debug_1223
    rx1604_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1223:
    .return (rx1604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("292_1303748459.273") :method
.annotate 'line', 10
    $P1606 = self."!PREFIX__!subrule"("O", "++")
    new $P1607, "ResizablePMCArray"
    push $P1607, $P1606
    .return ($P1607)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("293_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1611_tgt
    .local int rx1611_pos
    .local int rx1611_off
    .local int rx1611_eos
    .local int rx1611_rep
    .local pmc rx1611_cur
    .local pmc rx1611_debug
    (rx1611_cur, rx1611_pos, rx1611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1611_cur
    .local pmc match
    .lex "$/", match
    length rx1611_eos, rx1611_tgt
    gt rx1611_pos, rx1611_eos, rx1611_done
    set rx1611_off, 0
    lt rx1611_pos, 2, rx1611_start
    sub rx1611_off, rx1611_pos, 1
    substr rx1611_tgt, rx1611_tgt, rx1611_off
  rx1611_start:
    eq $I10, 1, rx1611_restart
    if_null rx1611_debug, debug_1224
    rx1611_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1224:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1615_done
    goto rxscan1615_scan
  rxscan1615_loop:
    (rx1611_pos) = rx1611_cur."from"()
    inc rx1611_pos
    rx1611_cur."!cursor_from"(rx1611_pos)
    ge rx1611_pos, rx1611_eos, rxscan1615_done
  rxscan1615_scan:
    set_addr $I10, rxscan1615_loop
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  rxscan1615_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1616_fail
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  # rx literal  "--"
    add $I11, rx1611_pos, 2
    gt $I11, rx1611_eos, rx1611_fail
    sub $I11, rx1611_pos, rx1611_off
    substr $S10, rx1611_tgt, $I11, 2
    ne $S10, "--", rx1611_fail
    add rx1611_pos, 2
    set_addr $I10, rxcap_1616_fail
    ($I12, $I11) = rx1611_cur."!mark_peek"($I10)
    rx1611_cur."!cursor_pos"($I11)
    ($P10) = rx1611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1611_pos, "")
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1616_done
  rxcap_1616_fail:
    goto rx1611_fail
  rxcap_1616_done:
  # rx subrule "O" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."O"("%autoincrement")
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1611_pos = $P10."pos"()
  # rx pass
    rx1611_cur."!cursor_pass"(rx1611_pos, "postfix:sym<-->")
    if_null rx1611_debug, debug_1225
    rx1611_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1611_pos)
  debug_1225:
    .return (rx1611_cur)
  rx1611_restart:
.annotate 'line', 10
    if_null rx1611_debug, debug_1226
    rx1611_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1226:
  rx1611_fail:
    (rx1611_rep, rx1611_pos, $I10, $P10) = rx1611_cur."!mark_fail"(0)
    lt rx1611_pos, -1, rx1611_done
    eq rx1611_pos, -1, rx1611_fail
    jump $I10
  rx1611_done:
    rx1611_cur."!cursor_fail"()
    if_null rx1611_debug, debug_1227
    rx1611_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1227:
    .return (rx1611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("294_1303748459.273") :method
.annotate 'line', 10
    $P1613 = self."!PREFIX__!subrule"("O", "--")
    new $P1614, "ResizablePMCArray"
    push $P1614, $P1613
    .return ($P1614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("295_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1618_tgt
    .local int rx1618_pos
    .local int rx1618_off
    .local int rx1618_eos
    .local int rx1618_rep
    .local pmc rx1618_cur
    .local pmc rx1618_debug
    (rx1618_cur, rx1618_pos, rx1618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1618_cur
    .local pmc match
    .lex "$/", match
    length rx1618_eos, rx1618_tgt
    gt rx1618_pos, rx1618_eos, rx1618_done
    set rx1618_off, 0
    lt rx1618_pos, 2, rx1618_start
    sub rx1618_off, rx1618_pos, 1
    substr rx1618_tgt, rx1618_tgt, rx1618_off
  rx1618_start:
    eq $I10, 1, rx1618_restart
    if_null rx1618_debug, debug_1228
    rx1618_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1228:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1618_pos) = rx1618_cur."from"()
    inc rx1618_pos
    rx1618_cur."!cursor_from"(rx1618_pos)
    ge rx1618_pos, rx1618_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  rxscan1622_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1623_fail
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  # rx literal  "**"
    add $I11, rx1618_pos, 2
    gt $I11, rx1618_eos, rx1618_fail
    sub $I11, rx1618_pos, rx1618_off
    substr $S10, rx1618_tgt, $I11, 2
    ne $S10, "**", rx1618_fail
    add rx1618_pos, 2
    set_addr $I10, rxcap_1623_fail
    ($I12, $I11) = rx1618_cur."!mark_peek"($I10)
    rx1618_cur."!cursor_pos"($I11)
    ($P10) = rx1618_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1618_pos, "")
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1623_done
  rxcap_1623_fail:
    goto rx1618_fail
  rxcap_1623_done:
  # rx subrule "O" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1618_pos = $P10."pos"()
  # rx pass
    rx1618_cur."!cursor_pass"(rx1618_pos, "infix:sym<**>")
    if_null rx1618_debug, debug_1229
    rx1618_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1618_pos)
  debug_1229:
    .return (rx1618_cur)
  rx1618_restart:
.annotate 'line', 10
    if_null rx1618_debug, debug_1230
    rx1618_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1230:
  rx1618_fail:
    (rx1618_rep, rx1618_pos, $I10, $P10) = rx1618_cur."!mark_fail"(0)
    lt rx1618_pos, -1, rx1618_done
    eq rx1618_pos, -1, rx1618_fail
    jump $I10
  rx1618_done:
    rx1618_cur."!cursor_fail"()
    if_null rx1618_debug, debug_1231
    rx1618_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1231:
    .return (rx1618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("296_1303748459.273") :method
.annotate 'line', 10
    $P1620 = self."!PREFIX__!subrule"("O", "**")
    new $P1621, "ResizablePMCArray"
    push $P1621, $P1620
    .return ($P1621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("297_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1625_tgt
    .local int rx1625_pos
    .local int rx1625_off
    .local int rx1625_eos
    .local int rx1625_rep
    .local pmc rx1625_cur
    .local pmc rx1625_debug
    (rx1625_cur, rx1625_pos, rx1625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1625_cur
    .local pmc match
    .lex "$/", match
    length rx1625_eos, rx1625_tgt
    gt rx1625_pos, rx1625_eos, rx1625_done
    set rx1625_off, 0
    lt rx1625_pos, 2, rx1625_start
    sub rx1625_off, rx1625_pos, 1
    substr rx1625_tgt, rx1625_tgt, rx1625_off
  rx1625_start:
    eq $I10, 1, rx1625_restart
    if_null rx1625_debug, debug_1232
    rx1625_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1232:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1629_done
    goto rxscan1629_scan
  rxscan1629_loop:
    (rx1625_pos) = rx1625_cur."from"()
    inc rx1625_pos
    rx1625_cur."!cursor_from"(rx1625_pos)
    ge rx1625_pos, rx1625_eos, rxscan1629_done
  rxscan1629_scan:
    set_addr $I10, rxscan1629_loop
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  rxscan1629_done:
.annotate 'line', 657
  # rx subcapture "sym"
    set_addr $I10, rxcap_1630_fail
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  # rx literal  "+"
    add $I11, rx1625_pos, 1
    gt $I11, rx1625_eos, rx1625_fail
    sub $I11, rx1625_pos, rx1625_off
    ord $I11, rx1625_tgt, $I11
    ne $I11, 43, rx1625_fail
    add rx1625_pos, 1
    set_addr $I10, rxcap_1630_fail
    ($I12, $I11) = rx1625_cur."!mark_peek"($I10)
    rx1625_cur."!cursor_pos"($I11)
    ($P10) = rx1625_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1625_pos, "")
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1630_done
  rxcap_1630_fail:
    goto rx1625_fail
  rxcap_1630_done:
  # rx subrule "O" subtype=capture negate=
    rx1625_cur."!cursor_pos"(rx1625_pos)
    $P10 = rx1625_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1625_fail
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1625_pos = $P10."pos"()
  # rx pass
    rx1625_cur."!cursor_pass"(rx1625_pos, "prefix:sym<+>")
    if_null rx1625_debug, debug_1233
    rx1625_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1625_pos)
  debug_1233:
    .return (rx1625_cur)
  rx1625_restart:
.annotate 'line', 10
    if_null rx1625_debug, debug_1234
    rx1625_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1234:
  rx1625_fail:
    (rx1625_rep, rx1625_pos, $I10, $P10) = rx1625_cur."!mark_fail"(0)
    lt rx1625_pos, -1, rx1625_done
    eq rx1625_pos, -1, rx1625_fail
    jump $I10
  rx1625_done:
    rx1625_cur."!cursor_fail"()
    if_null rx1625_debug, debug_1235
    rx1625_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1235:
    .return (rx1625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("298_1303748459.273") :method
.annotate 'line', 10
    $P1627 = self."!PREFIX__!subrule"("O", "+")
    new $P1628, "ResizablePMCArray"
    push $P1628, $P1627
    .return ($P1628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("299_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1632_tgt
    .local int rx1632_pos
    .local int rx1632_off
    .local int rx1632_eos
    .local int rx1632_rep
    .local pmc rx1632_cur
    .local pmc rx1632_debug
    (rx1632_cur, rx1632_pos, rx1632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1632_cur
    .local pmc match
    .lex "$/", match
    length rx1632_eos, rx1632_tgt
    gt rx1632_pos, rx1632_eos, rx1632_done
    set rx1632_off, 0
    lt rx1632_pos, 2, rx1632_start
    sub rx1632_off, rx1632_pos, 1
    substr rx1632_tgt, rx1632_tgt, rx1632_off
  rx1632_start:
    eq $I10, 1, rx1632_restart
    if_null rx1632_debug, debug_1236
    rx1632_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1236:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1636_done
    goto rxscan1636_scan
  rxscan1636_loop:
    (rx1632_pos) = rx1632_cur."from"()
    inc rx1632_pos
    rx1632_cur."!cursor_from"(rx1632_pos)
    ge rx1632_pos, rx1632_eos, rxscan1636_done
  rxscan1636_scan:
    set_addr $I10, rxscan1636_loop
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  rxscan1636_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1637_fail
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  # rx literal  "~"
    add $I11, rx1632_pos, 1
    gt $I11, rx1632_eos, rx1632_fail
    sub $I11, rx1632_pos, rx1632_off
    ord $I11, rx1632_tgt, $I11
    ne $I11, 126, rx1632_fail
    add rx1632_pos, 1
    set_addr $I10, rxcap_1637_fail
    ($I12, $I11) = rx1632_cur."!mark_peek"($I10)
    rx1632_cur."!cursor_pos"($I11)
    ($P10) = rx1632_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1632_pos, "")
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1637_done
  rxcap_1637_fail:
    goto rx1632_fail
  rxcap_1637_done:
  # rx subrule "O" subtype=capture negate=
    rx1632_cur."!cursor_pos"(rx1632_pos)
    $P10 = rx1632_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1632_fail
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1632_pos = $P10."pos"()
  # rx pass
    rx1632_cur."!cursor_pass"(rx1632_pos, "prefix:sym<~>")
    if_null rx1632_debug, debug_1237
    rx1632_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1632_pos)
  debug_1237:
    .return (rx1632_cur)
  rx1632_restart:
.annotate 'line', 10
    if_null rx1632_debug, debug_1238
    rx1632_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1238:
  rx1632_fail:
    (rx1632_rep, rx1632_pos, $I10, $P10) = rx1632_cur."!mark_fail"(0)
    lt rx1632_pos, -1, rx1632_done
    eq rx1632_pos, -1, rx1632_fail
    jump $I10
  rx1632_done:
    rx1632_cur."!cursor_fail"()
    if_null rx1632_debug, debug_1239
    rx1632_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1239:
    .return (rx1632_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("300_1303748459.273") :method
.annotate 'line', 10
    $P1634 = self."!PREFIX__!subrule"("O", "~")
    new $P1635, "ResizablePMCArray"
    push $P1635, $P1634
    .return ($P1635)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("301_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1639_tgt
    .local int rx1639_pos
    .local int rx1639_off
    .local int rx1639_eos
    .local int rx1639_rep
    .local pmc rx1639_cur
    .local pmc rx1639_debug
    (rx1639_cur, rx1639_pos, rx1639_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1639_cur
    .local pmc match
    .lex "$/", match
    length rx1639_eos, rx1639_tgt
    gt rx1639_pos, rx1639_eos, rx1639_done
    set rx1639_off, 0
    lt rx1639_pos, 2, rx1639_start
    sub rx1639_off, rx1639_pos, 1
    substr rx1639_tgt, rx1639_tgt, rx1639_off
  rx1639_start:
    eq $I10, 1, rx1639_restart
    if_null rx1639_debug, debug_1240
    rx1639_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1240:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1642_done
    goto rxscan1642_scan
  rxscan1642_loop:
    (rx1639_pos) = rx1639_cur."from"()
    inc rx1639_pos
    rx1639_cur."!cursor_from"(rx1639_pos)
    ge rx1639_pos, rx1639_eos, rxscan1642_done
  rxscan1642_scan:
    set_addr $I10, rxscan1642_loop
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
  rxscan1642_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1643_fail
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
  # rx literal  "-"
    add $I11, rx1639_pos, 1
    gt $I11, rx1639_eos, rx1639_fail
    sub $I11, rx1639_pos, rx1639_off
    ord $I11, rx1639_tgt, $I11
    ne $I11, 45, rx1639_fail
    add rx1639_pos, 1
    set_addr $I10, rxcap_1643_fail
    ($I12, $I11) = rx1639_cur."!mark_peek"($I10)
    rx1639_cur."!cursor_pos"($I11)
    ($P10) = rx1639_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1639_pos, "")
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1643_done
  rxcap_1643_fail:
    goto rx1639_fail
  rxcap_1643_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1639_pos, rx1639_off
    substr $S10, rx1639_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1639_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."number"()
    if $P10, rx1639_fail
  # rx subrule "O" subtype=capture negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1639_fail
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1639_pos = $P10."pos"()
  # rx pass
    rx1639_cur."!cursor_pass"(rx1639_pos, "prefix:sym<->")
    if_null rx1639_debug, debug_1241
    rx1639_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1639_pos)
  debug_1241:
    .return (rx1639_cur)
  rx1639_restart:
.annotate 'line', 10
    if_null rx1639_debug, debug_1242
    rx1639_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1242:
  rx1639_fail:
    (rx1639_rep, rx1639_pos, $I10, $P10) = rx1639_cur."!mark_fail"(0)
    lt rx1639_pos, -1, rx1639_done
    eq rx1639_pos, -1, rx1639_fail
    jump $I10
  rx1639_done:
    rx1639_cur."!cursor_fail"()
    if_null rx1639_debug, debug_1243
    rx1639_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1243:
    .return (rx1639_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("302_1303748459.273") :method
.annotate 'line', 10
    new $P1641, "ResizablePMCArray"
    push $P1641, "-"
    .return ($P1641)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("303_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1645_tgt
    .local int rx1645_pos
    .local int rx1645_off
    .local int rx1645_eos
    .local int rx1645_rep
    .local pmc rx1645_cur
    .local pmc rx1645_debug
    (rx1645_cur, rx1645_pos, rx1645_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1645_cur
    .local pmc match
    .lex "$/", match
    length rx1645_eos, rx1645_tgt
    gt rx1645_pos, rx1645_eos, rx1645_done
    set rx1645_off, 0
    lt rx1645_pos, 2, rx1645_start
    sub rx1645_off, rx1645_pos, 1
    substr rx1645_tgt, rx1645_tgt, rx1645_off
  rx1645_start:
    eq $I10, 1, rx1645_restart
    if_null rx1645_debug, debug_1244
    rx1645_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1244:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1649_done
    goto rxscan1649_scan
  rxscan1649_loop:
    (rx1645_pos) = rx1645_cur."from"()
    inc rx1645_pos
    rx1645_cur."!cursor_from"(rx1645_pos)
    ge rx1645_pos, rx1645_eos, rxscan1649_done
  rxscan1649_scan:
    set_addr $I10, rxscan1649_loop
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
  rxscan1649_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1650_fail
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
  # rx literal  "?"
    add $I11, rx1645_pos, 1
    gt $I11, rx1645_eos, rx1645_fail
    sub $I11, rx1645_pos, rx1645_off
    ord $I11, rx1645_tgt, $I11
    ne $I11, 63, rx1645_fail
    add rx1645_pos, 1
    set_addr $I10, rxcap_1650_fail
    ($I12, $I11) = rx1645_cur."!mark_peek"($I10)
    rx1645_cur."!cursor_pos"($I11)
    ($P10) = rx1645_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1645_pos, "")
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1650_done
  rxcap_1650_fail:
    goto rx1645_fail
  rxcap_1650_done:
  # rx subrule "O" subtype=capture negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1645_fail
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1645_pos = $P10."pos"()
  # rx pass
    rx1645_cur."!cursor_pass"(rx1645_pos, "prefix:sym<?>")
    if_null rx1645_debug, debug_1245
    rx1645_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1645_pos)
  debug_1245:
    .return (rx1645_cur)
  rx1645_restart:
.annotate 'line', 10
    if_null rx1645_debug, debug_1246
    rx1645_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1246:
  rx1645_fail:
    (rx1645_rep, rx1645_pos, $I10, $P10) = rx1645_cur."!mark_fail"(0)
    lt rx1645_pos, -1, rx1645_done
    eq rx1645_pos, -1, rx1645_fail
    jump $I10
  rx1645_done:
    rx1645_cur."!cursor_fail"()
    if_null rx1645_debug, debug_1247
    rx1645_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1247:
    .return (rx1645_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("304_1303748459.273") :method
.annotate 'line', 10
    $P1647 = self."!PREFIX__!subrule"("O", "?")
    new $P1648, "ResizablePMCArray"
    push $P1648, $P1647
    .return ($P1648)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("305_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1652_tgt
    .local int rx1652_pos
    .local int rx1652_off
    .local int rx1652_eos
    .local int rx1652_rep
    .local pmc rx1652_cur
    .local pmc rx1652_debug
    (rx1652_cur, rx1652_pos, rx1652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1652_cur
    .local pmc match
    .lex "$/", match
    length rx1652_eos, rx1652_tgt
    gt rx1652_pos, rx1652_eos, rx1652_done
    set rx1652_off, 0
    lt rx1652_pos, 2, rx1652_start
    sub rx1652_off, rx1652_pos, 1
    substr rx1652_tgt, rx1652_tgt, rx1652_off
  rx1652_start:
    eq $I10, 1, rx1652_restart
    if_null rx1652_debug, debug_1248
    rx1652_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1248:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1656_done
    goto rxscan1656_scan
  rxscan1656_loop:
    (rx1652_pos) = rx1652_cur."from"()
    inc rx1652_pos
    rx1652_cur."!cursor_from"(rx1652_pos)
    ge rx1652_pos, rx1652_eos, rxscan1656_done
  rxscan1656_scan:
    set_addr $I10, rxscan1656_loop
    rx1652_cur."!mark_push"(0, rx1652_pos, $I10)
  rxscan1656_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1657_fail
    rx1652_cur."!mark_push"(0, rx1652_pos, $I10)
  # rx literal  "!"
    add $I11, rx1652_pos, 1
    gt $I11, rx1652_eos, rx1652_fail
    sub $I11, rx1652_pos, rx1652_off
    ord $I11, rx1652_tgt, $I11
    ne $I11, 33, rx1652_fail
    add rx1652_pos, 1
    set_addr $I10, rxcap_1657_fail
    ($I12, $I11) = rx1652_cur."!mark_peek"($I10)
    rx1652_cur."!cursor_pos"($I11)
    ($P10) = rx1652_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1652_pos, "")
    rx1652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1657_done
  rxcap_1657_fail:
    goto rx1652_fail
  rxcap_1657_done:
  # rx subrule "O" subtype=capture negate=
    rx1652_cur."!cursor_pos"(rx1652_pos)
    $P10 = rx1652_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1652_fail
    rx1652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1652_pos = $P10."pos"()
  # rx pass
    rx1652_cur."!cursor_pass"(rx1652_pos, "prefix:sym<!>")
    if_null rx1652_debug, debug_1249
    rx1652_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1652_pos)
  debug_1249:
    .return (rx1652_cur)
  rx1652_restart:
.annotate 'line', 10
    if_null rx1652_debug, debug_1250
    rx1652_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1250:
  rx1652_fail:
    (rx1652_rep, rx1652_pos, $I10, $P10) = rx1652_cur."!mark_fail"(0)
    lt rx1652_pos, -1, rx1652_done
    eq rx1652_pos, -1, rx1652_fail
    jump $I10
  rx1652_done:
    rx1652_cur."!cursor_fail"()
    if_null rx1652_debug, debug_1251
    rx1652_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1251:
    .return (rx1652_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("306_1303748459.273") :method
.annotate 'line', 10
    $P1654 = self."!PREFIX__!subrule"("O", "!")
    new $P1655, "ResizablePMCArray"
    push $P1655, $P1654
    .return ($P1655)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("307_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1659_tgt
    .local int rx1659_pos
    .local int rx1659_off
    .local int rx1659_eos
    .local int rx1659_rep
    .local pmc rx1659_cur
    .local pmc rx1659_debug
    (rx1659_cur, rx1659_pos, rx1659_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1659_cur
    .local pmc match
    .lex "$/", match
    length rx1659_eos, rx1659_tgt
    gt rx1659_pos, rx1659_eos, rx1659_done
    set rx1659_off, 0
    lt rx1659_pos, 2, rx1659_start
    sub rx1659_off, rx1659_pos, 1
    substr rx1659_tgt, rx1659_tgt, rx1659_off
  rx1659_start:
    eq $I10, 1, rx1659_restart
    if_null rx1659_debug, debug_1252
    rx1659_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1252:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1663_done
    goto rxscan1663_scan
  rxscan1663_loop:
    (rx1659_pos) = rx1659_cur."from"()
    inc rx1659_pos
    rx1659_cur."!cursor_from"(rx1659_pos)
    ge rx1659_pos, rx1659_eos, rxscan1663_done
  rxscan1663_scan:
    set_addr $I10, rxscan1663_loop
    rx1659_cur."!mark_push"(0, rx1659_pos, $I10)
  rxscan1663_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1664_fail
    rx1659_cur."!mark_push"(0, rx1659_pos, $I10)
  # rx literal  "|"
    add $I11, rx1659_pos, 1
    gt $I11, rx1659_eos, rx1659_fail
    sub $I11, rx1659_pos, rx1659_off
    ord $I11, rx1659_tgt, $I11
    ne $I11, 124, rx1659_fail
    add rx1659_pos, 1
    set_addr $I10, rxcap_1664_fail
    ($I12, $I11) = rx1659_cur."!mark_peek"($I10)
    rx1659_cur."!cursor_pos"($I11)
    ($P10) = rx1659_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1659_pos, "")
    rx1659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1664_done
  rxcap_1664_fail:
    goto rx1659_fail
  rxcap_1664_done:
  # rx subrule "O" subtype=capture negate=
    rx1659_cur."!cursor_pos"(rx1659_pos)
    $P10 = rx1659_cur."O"("%symbolic_unary")
    unless $P10, rx1659_fail
    rx1659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1659_pos = $P10."pos"()
  # rx pass
    rx1659_cur."!cursor_pass"(rx1659_pos, "prefix:sym<|>")
    if_null rx1659_debug, debug_1253
    rx1659_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1659_pos)
  debug_1253:
    .return (rx1659_cur)
  rx1659_restart:
.annotate 'line', 10
    if_null rx1659_debug, debug_1254
    rx1659_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1254:
  rx1659_fail:
    (rx1659_rep, rx1659_pos, $I10, $P10) = rx1659_cur."!mark_fail"(0)
    lt rx1659_pos, -1, rx1659_done
    eq rx1659_pos, -1, rx1659_fail
    jump $I10
  rx1659_done:
    rx1659_cur."!cursor_fail"()
    if_null rx1659_debug, debug_1255
    rx1659_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1255:
    .return (rx1659_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("308_1303748459.273") :method
.annotate 'line', 10
    $P1661 = self."!PREFIX__!subrule"("O", "|")
    new $P1662, "ResizablePMCArray"
    push $P1662, $P1661
    .return ($P1662)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("309_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1666_tgt
    .local int rx1666_pos
    .local int rx1666_off
    .local int rx1666_eos
    .local int rx1666_rep
    .local pmc rx1666_cur
    .local pmc rx1666_debug
    (rx1666_cur, rx1666_pos, rx1666_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1666_cur
    .local pmc match
    .lex "$/", match
    length rx1666_eos, rx1666_tgt
    gt rx1666_pos, rx1666_eos, rx1666_done
    set rx1666_off, 0
    lt rx1666_pos, 2, rx1666_start
    sub rx1666_off, rx1666_pos, 1
    substr rx1666_tgt, rx1666_tgt, rx1666_off
  rx1666_start:
    eq $I10, 1, rx1666_restart
    if_null rx1666_debug, debug_1256
    rx1666_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1256:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1670_done
    goto rxscan1670_scan
  rxscan1670_loop:
    (rx1666_pos) = rx1666_cur."from"()
    inc rx1666_pos
    rx1666_cur."!cursor_from"(rx1666_pos)
    ge rx1666_pos, rx1666_eos, rxscan1670_done
  rxscan1670_scan:
    set_addr $I10, rxscan1670_loop
    rx1666_cur."!mark_push"(0, rx1666_pos, $I10)
  rxscan1670_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1671_fail
    rx1666_cur."!mark_push"(0, rx1666_pos, $I10)
  # rx literal  "*"
    add $I11, rx1666_pos, 1
    gt $I11, rx1666_eos, rx1666_fail
    sub $I11, rx1666_pos, rx1666_off
    ord $I11, rx1666_tgt, $I11
    ne $I11, 42, rx1666_fail
    add rx1666_pos, 1
    set_addr $I10, rxcap_1671_fail
    ($I12, $I11) = rx1666_cur."!mark_peek"($I10)
    rx1666_cur."!cursor_pos"($I11)
    ($P10) = rx1666_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1666_pos, "")
    rx1666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1671_done
  rxcap_1671_fail:
    goto rx1666_fail
  rxcap_1671_done:
  # rx subrule "O" subtype=capture negate=
    rx1666_cur."!cursor_pos"(rx1666_pos)
    $P10 = rx1666_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1666_fail
    rx1666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1666_pos = $P10."pos"()
  # rx pass
    rx1666_cur."!cursor_pass"(rx1666_pos, "infix:sym<*>")
    if_null rx1666_debug, debug_1257
    rx1666_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1666_pos)
  debug_1257:
    .return (rx1666_cur)
  rx1666_restart:
.annotate 'line', 10
    if_null rx1666_debug, debug_1258
    rx1666_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1258:
  rx1666_fail:
    (rx1666_rep, rx1666_pos, $I10, $P10) = rx1666_cur."!mark_fail"(0)
    lt rx1666_pos, -1, rx1666_done
    eq rx1666_pos, -1, rx1666_fail
    jump $I10
  rx1666_done:
    rx1666_cur."!cursor_fail"()
    if_null rx1666_debug, debug_1259
    rx1666_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1259:
    .return (rx1666_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("310_1303748459.273") :method
.annotate 'line', 10
    $P1668 = self."!PREFIX__!subrule"("O", "*")
    new $P1669, "ResizablePMCArray"
    push $P1669, $P1668
    .return ($P1669)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("311_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1673_tgt
    .local int rx1673_pos
    .local int rx1673_off
    .local int rx1673_eos
    .local int rx1673_rep
    .local pmc rx1673_cur
    .local pmc rx1673_debug
    (rx1673_cur, rx1673_pos, rx1673_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1673_cur
    .local pmc match
    .lex "$/", match
    length rx1673_eos, rx1673_tgt
    gt rx1673_pos, rx1673_eos, rx1673_done
    set rx1673_off, 0
    lt rx1673_pos, 2, rx1673_start
    sub rx1673_off, rx1673_pos, 1
    substr rx1673_tgt, rx1673_tgt, rx1673_off
  rx1673_start:
    eq $I10, 1, rx1673_restart
    if_null rx1673_debug, debug_1260
    rx1673_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1260:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1677_done
    goto rxscan1677_scan
  rxscan1677_loop:
    (rx1673_pos) = rx1673_cur."from"()
    inc rx1673_pos
    rx1673_cur."!cursor_from"(rx1673_pos)
    ge rx1673_pos, rx1673_eos, rxscan1677_done
  rxscan1677_scan:
    set_addr $I10, rxscan1677_loop
    rx1673_cur."!mark_push"(0, rx1673_pos, $I10)
  rxscan1677_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1678_fail
    rx1673_cur."!mark_push"(0, rx1673_pos, $I10)
  # rx literal  "/"
    add $I11, rx1673_pos, 1
    gt $I11, rx1673_eos, rx1673_fail
    sub $I11, rx1673_pos, rx1673_off
    ord $I11, rx1673_tgt, $I11
    ne $I11, 47, rx1673_fail
    add rx1673_pos, 1
    set_addr $I10, rxcap_1678_fail
    ($I12, $I11) = rx1673_cur."!mark_peek"($I10)
    rx1673_cur."!cursor_pos"($I11)
    ($P10) = rx1673_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1673_pos, "")
    rx1673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1678_done
  rxcap_1678_fail:
    goto rx1673_fail
  rxcap_1678_done:
  # rx subrule "O" subtype=capture negate=
    rx1673_cur."!cursor_pos"(rx1673_pos)
    $P10 = rx1673_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1673_fail
    rx1673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1673_pos = $P10."pos"()
  # rx pass
    rx1673_cur."!cursor_pass"(rx1673_pos, "infix:sym</>")
    if_null rx1673_debug, debug_1261
    rx1673_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1673_pos)
  debug_1261:
    .return (rx1673_cur)
  rx1673_restart:
.annotate 'line', 10
    if_null rx1673_debug, debug_1262
    rx1673_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1262:
  rx1673_fail:
    (rx1673_rep, rx1673_pos, $I10, $P10) = rx1673_cur."!mark_fail"(0)
    lt rx1673_pos, -1, rx1673_done
    eq rx1673_pos, -1, rx1673_fail
    jump $I10
  rx1673_done:
    rx1673_cur."!cursor_fail"()
    if_null rx1673_debug, debug_1263
    rx1673_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1263:
    .return (rx1673_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("312_1303748459.273") :method
.annotate 'line', 10
    $P1675 = self."!PREFIX__!subrule"("O", "/")
    new $P1676, "ResizablePMCArray"
    push $P1676, $P1675
    .return ($P1676)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("313_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1680_tgt
    .local int rx1680_pos
    .local int rx1680_off
    .local int rx1680_eos
    .local int rx1680_rep
    .local pmc rx1680_cur
    .local pmc rx1680_debug
    (rx1680_cur, rx1680_pos, rx1680_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1680_cur
    .local pmc match
    .lex "$/", match
    length rx1680_eos, rx1680_tgt
    gt rx1680_pos, rx1680_eos, rx1680_done
    set rx1680_off, 0
    lt rx1680_pos, 2, rx1680_start
    sub rx1680_off, rx1680_pos, 1
    substr rx1680_tgt, rx1680_tgt, rx1680_off
  rx1680_start:
    eq $I10, 1, rx1680_restart
    if_null rx1680_debug, debug_1264
    rx1680_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1264:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1684_done
    goto rxscan1684_scan
  rxscan1684_loop:
    (rx1680_pos) = rx1680_cur."from"()
    inc rx1680_pos
    rx1680_cur."!cursor_from"(rx1680_pos)
    ge rx1680_pos, rx1680_eos, rxscan1684_done
  rxscan1684_scan:
    set_addr $I10, rxscan1684_loop
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  rxscan1684_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_1685_fail
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  # rx literal  "%"
    add $I11, rx1680_pos, 1
    gt $I11, rx1680_eos, rx1680_fail
    sub $I11, rx1680_pos, rx1680_off
    ord $I11, rx1680_tgt, $I11
    ne $I11, 37, rx1680_fail
    add rx1680_pos, 1
    set_addr $I10, rxcap_1685_fail
    ($I12, $I11) = rx1680_cur."!mark_peek"($I10)
    rx1680_cur."!cursor_pos"($I11)
    ($P10) = rx1680_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1680_pos, "")
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1685_done
  rxcap_1685_fail:
    goto rx1680_fail
  rxcap_1685_done:
  # rx subrule "O" subtype=capture negate=
    rx1680_cur."!cursor_pos"(rx1680_pos)
    $P10 = rx1680_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1680_fail
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1680_pos = $P10."pos"()
  # rx pass
    rx1680_cur."!cursor_pass"(rx1680_pos, "infix:sym<%>")
    if_null rx1680_debug, debug_1265
    rx1680_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1680_pos)
  debug_1265:
    .return (rx1680_cur)
  rx1680_restart:
.annotate 'line', 10
    if_null rx1680_debug, debug_1266
    rx1680_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1266:
  rx1680_fail:
    (rx1680_rep, rx1680_pos, $I10, $P10) = rx1680_cur."!mark_fail"(0)
    lt rx1680_pos, -1, rx1680_done
    eq rx1680_pos, -1, rx1680_fail
    jump $I10
  rx1680_done:
    rx1680_cur."!cursor_fail"()
    if_null rx1680_debug, debug_1267
    rx1680_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1267:
    .return (rx1680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("314_1303748459.273") :method
.annotate 'line', 10
    $P1682 = self."!PREFIX__!subrule"("O", "%")
    new $P1683, "ResizablePMCArray"
    push $P1683, $P1682
    .return ($P1683)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("315_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1687_tgt
    .local int rx1687_pos
    .local int rx1687_off
    .local int rx1687_eos
    .local int rx1687_rep
    .local pmc rx1687_cur
    .local pmc rx1687_debug
    (rx1687_cur, rx1687_pos, rx1687_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1687_cur
    .local pmc match
    .lex "$/", match
    length rx1687_eos, rx1687_tgt
    gt rx1687_pos, rx1687_eos, rx1687_done
    set rx1687_off, 0
    lt rx1687_pos, 2, rx1687_start
    sub rx1687_off, rx1687_pos, 1
    substr rx1687_tgt, rx1687_tgt, rx1687_off
  rx1687_start:
    eq $I10, 1, rx1687_restart
    if_null rx1687_debug, debug_1268
    rx1687_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1268:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1691_done
    goto rxscan1691_scan
  rxscan1691_loop:
    (rx1687_pos) = rx1687_cur."from"()
    inc rx1687_pos
    rx1687_cur."!cursor_from"(rx1687_pos)
    ge rx1687_pos, rx1687_eos, rxscan1691_done
  rxscan1691_scan:
    set_addr $I10, rxscan1691_loop
    rx1687_cur."!mark_push"(0, rx1687_pos, $I10)
  rxscan1691_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1692_fail
    rx1687_cur."!mark_push"(0, rx1687_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1687_pos, 2
    gt $I11, rx1687_eos, rx1687_fail
    sub $I11, rx1687_pos, rx1687_off
    substr $S10, rx1687_tgt, $I11, 2
    ne $S10, "+&", rx1687_fail
    add rx1687_pos, 2
    set_addr $I10, rxcap_1692_fail
    ($I12, $I11) = rx1687_cur."!mark_peek"($I10)
    rx1687_cur."!cursor_pos"($I11)
    ($P10) = rx1687_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1687_pos, "")
    rx1687_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1692_done
  rxcap_1692_fail:
    goto rx1687_fail
  rxcap_1692_done:
  # rx subrule "O" subtype=capture negate=
    rx1687_cur."!cursor_pos"(rx1687_pos)
    $P10 = rx1687_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1687_fail
    rx1687_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1687_pos = $P10."pos"()
  # rx pass
    rx1687_cur."!cursor_pass"(rx1687_pos, "infix:sym<+&>")
    if_null rx1687_debug, debug_1269
    rx1687_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1687_pos)
  debug_1269:
    .return (rx1687_cur)
  rx1687_restart:
.annotate 'line', 10
    if_null rx1687_debug, debug_1270
    rx1687_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1270:
  rx1687_fail:
    (rx1687_rep, rx1687_pos, $I10, $P10) = rx1687_cur."!mark_fail"(0)
    lt rx1687_pos, -1, rx1687_done
    eq rx1687_pos, -1, rx1687_fail
    jump $I10
  rx1687_done:
    rx1687_cur."!cursor_fail"()
    if_null rx1687_debug, debug_1271
    rx1687_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1271:
    .return (rx1687_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("316_1303748459.273") :method
.annotate 'line', 10
    $P1689 = self."!PREFIX__!subrule"("O", "+&")
    new $P1690, "ResizablePMCArray"
    push $P1690, $P1689
    .return ($P1690)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("317_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1694_tgt
    .local int rx1694_pos
    .local int rx1694_off
    .local int rx1694_eos
    .local int rx1694_rep
    .local pmc rx1694_cur
    .local pmc rx1694_debug
    (rx1694_cur, rx1694_pos, rx1694_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1694_cur
    .local pmc match
    .lex "$/", match
    length rx1694_eos, rx1694_tgt
    gt rx1694_pos, rx1694_eos, rx1694_done
    set rx1694_off, 0
    lt rx1694_pos, 2, rx1694_start
    sub rx1694_off, rx1694_pos, 1
    substr rx1694_tgt, rx1694_tgt, rx1694_off
  rx1694_start:
    eq $I10, 1, rx1694_restart
    if_null rx1694_debug, debug_1272
    rx1694_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1272:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1698_done
    goto rxscan1698_scan
  rxscan1698_loop:
    (rx1694_pos) = rx1694_cur."from"()
    inc rx1694_pos
    rx1694_cur."!cursor_from"(rx1694_pos)
    ge rx1694_pos, rx1694_eos, rxscan1698_done
  rxscan1698_scan:
    set_addr $I10, rxscan1698_loop
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  rxscan1698_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1699_fail
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  # rx literal  "+"
    add $I11, rx1694_pos, 1
    gt $I11, rx1694_eos, rx1694_fail
    sub $I11, rx1694_pos, rx1694_off
    ord $I11, rx1694_tgt, $I11
    ne $I11, 43, rx1694_fail
    add rx1694_pos, 1
    set_addr $I10, rxcap_1699_fail
    ($I12, $I11) = rx1694_cur."!mark_peek"($I10)
    rx1694_cur."!cursor_pos"($I11)
    ($P10) = rx1694_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1694_pos, "")
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1699_done
  rxcap_1699_fail:
    goto rx1694_fail
  rxcap_1699_done:
  # rx subrule "O" subtype=capture negate=
    rx1694_cur."!cursor_pos"(rx1694_pos)
    $P10 = rx1694_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1694_fail
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1694_pos = $P10."pos"()
  # rx pass
    rx1694_cur."!cursor_pass"(rx1694_pos, "infix:sym<+>")
    if_null rx1694_debug, debug_1273
    rx1694_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1694_pos)
  debug_1273:
    .return (rx1694_cur)
  rx1694_restart:
.annotate 'line', 10
    if_null rx1694_debug, debug_1274
    rx1694_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1274:
  rx1694_fail:
    (rx1694_rep, rx1694_pos, $I10, $P10) = rx1694_cur."!mark_fail"(0)
    lt rx1694_pos, -1, rx1694_done
    eq rx1694_pos, -1, rx1694_fail
    jump $I10
  rx1694_done:
    rx1694_cur."!cursor_fail"()
    if_null rx1694_debug, debug_1275
    rx1694_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1275:
    .return (rx1694_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("318_1303748459.273") :method
.annotate 'line', 10
    $P1696 = self."!PREFIX__!subrule"("O", "+")
    new $P1697, "ResizablePMCArray"
    push $P1697, $P1696
    .return ($P1697)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("319_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1701_tgt
    .local int rx1701_pos
    .local int rx1701_off
    .local int rx1701_eos
    .local int rx1701_rep
    .local pmc rx1701_cur
    .local pmc rx1701_debug
    (rx1701_cur, rx1701_pos, rx1701_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1701_cur
    .local pmc match
    .lex "$/", match
    length rx1701_eos, rx1701_tgt
    gt rx1701_pos, rx1701_eos, rx1701_done
    set rx1701_off, 0
    lt rx1701_pos, 2, rx1701_start
    sub rx1701_off, rx1701_pos, 1
    substr rx1701_tgt, rx1701_tgt, rx1701_off
  rx1701_start:
    eq $I10, 1, rx1701_restart
    if_null rx1701_debug, debug_1276
    rx1701_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1276:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1705_done
    goto rxscan1705_scan
  rxscan1705_loop:
    (rx1701_pos) = rx1701_cur."from"()
    inc rx1701_pos
    rx1701_cur."!cursor_from"(rx1701_pos)
    ge rx1701_pos, rx1701_eos, rxscan1705_done
  rxscan1705_scan:
    set_addr $I10, rxscan1705_loop
    rx1701_cur."!mark_push"(0, rx1701_pos, $I10)
  rxscan1705_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1706_fail
    rx1701_cur."!mark_push"(0, rx1701_pos, $I10)
  # rx literal  "-"
    add $I11, rx1701_pos, 1
    gt $I11, rx1701_eos, rx1701_fail
    sub $I11, rx1701_pos, rx1701_off
    ord $I11, rx1701_tgt, $I11
    ne $I11, 45, rx1701_fail
    add rx1701_pos, 1
    set_addr $I10, rxcap_1706_fail
    ($I12, $I11) = rx1701_cur."!mark_peek"($I10)
    rx1701_cur."!cursor_pos"($I11)
    ($P10) = rx1701_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1701_pos, "")
    rx1701_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1706_done
  rxcap_1706_fail:
    goto rx1701_fail
  rxcap_1706_done:
  # rx subrule "O" subtype=capture negate=
    rx1701_cur."!cursor_pos"(rx1701_pos)
    $P10 = rx1701_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1701_fail
    rx1701_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1701_pos = $P10."pos"()
  # rx pass
    rx1701_cur."!cursor_pass"(rx1701_pos, "infix:sym<->")
    if_null rx1701_debug, debug_1277
    rx1701_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1701_pos)
  debug_1277:
    .return (rx1701_cur)
  rx1701_restart:
.annotate 'line', 10
    if_null rx1701_debug, debug_1278
    rx1701_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1278:
  rx1701_fail:
    (rx1701_rep, rx1701_pos, $I10, $P10) = rx1701_cur."!mark_fail"(0)
    lt rx1701_pos, -1, rx1701_done
    eq rx1701_pos, -1, rx1701_fail
    jump $I10
  rx1701_done:
    rx1701_cur."!cursor_fail"()
    if_null rx1701_debug, debug_1279
    rx1701_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1279:
    .return (rx1701_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("320_1303748459.273") :method
.annotate 'line', 10
    $P1703 = self."!PREFIX__!subrule"("O", "-")
    new $P1704, "ResizablePMCArray"
    push $P1704, $P1703
    .return ($P1704)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("321_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1708_tgt
    .local int rx1708_pos
    .local int rx1708_off
    .local int rx1708_eos
    .local int rx1708_rep
    .local pmc rx1708_cur
    .local pmc rx1708_debug
    (rx1708_cur, rx1708_pos, rx1708_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1708_cur
    .local pmc match
    .lex "$/", match
    length rx1708_eos, rx1708_tgt
    gt rx1708_pos, rx1708_eos, rx1708_done
    set rx1708_off, 0
    lt rx1708_pos, 2, rx1708_start
    sub rx1708_off, rx1708_pos, 1
    substr rx1708_tgt, rx1708_tgt, rx1708_off
  rx1708_start:
    eq $I10, 1, rx1708_restart
    if_null rx1708_debug, debug_1280
    rx1708_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1280:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1712_done
    goto rxscan1712_scan
  rxscan1712_loop:
    (rx1708_pos) = rx1708_cur."from"()
    inc rx1708_pos
    rx1708_cur."!cursor_from"(rx1708_pos)
    ge rx1708_pos, rx1708_eos, rxscan1712_done
  rxscan1712_scan:
    set_addr $I10, rxscan1712_loop
    rx1708_cur."!mark_push"(0, rx1708_pos, $I10)
  rxscan1712_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1713_fail
    rx1708_cur."!mark_push"(0, rx1708_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1708_pos, 2
    gt $I11, rx1708_eos, rx1708_fail
    sub $I11, rx1708_pos, rx1708_off
    substr $S10, rx1708_tgt, $I11, 2
    ne $S10, "+|", rx1708_fail
    add rx1708_pos, 2
    set_addr $I10, rxcap_1713_fail
    ($I12, $I11) = rx1708_cur."!mark_peek"($I10)
    rx1708_cur."!cursor_pos"($I11)
    ($P10) = rx1708_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1708_pos, "")
    rx1708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1713_done
  rxcap_1713_fail:
    goto rx1708_fail
  rxcap_1713_done:
  # rx subrule "O" subtype=capture negate=
    rx1708_cur."!cursor_pos"(rx1708_pos)
    $P10 = rx1708_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1708_fail
    rx1708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1708_pos = $P10."pos"()
  # rx pass
    rx1708_cur."!cursor_pass"(rx1708_pos, "infix:sym<+|>")
    if_null rx1708_debug, debug_1281
    rx1708_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1708_pos)
  debug_1281:
    .return (rx1708_cur)
  rx1708_restart:
.annotate 'line', 10
    if_null rx1708_debug, debug_1282
    rx1708_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1282:
  rx1708_fail:
    (rx1708_rep, rx1708_pos, $I10, $P10) = rx1708_cur."!mark_fail"(0)
    lt rx1708_pos, -1, rx1708_done
    eq rx1708_pos, -1, rx1708_fail
    jump $I10
  rx1708_done:
    rx1708_cur."!cursor_fail"()
    if_null rx1708_debug, debug_1283
    rx1708_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1283:
    .return (rx1708_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("322_1303748459.273") :method
.annotate 'line', 10
    $P1710 = self."!PREFIX__!subrule"("O", "+|")
    new $P1711, "ResizablePMCArray"
    push $P1711, $P1710
    .return ($P1711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("323_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1715_tgt
    .local int rx1715_pos
    .local int rx1715_off
    .local int rx1715_eos
    .local int rx1715_rep
    .local pmc rx1715_cur
    .local pmc rx1715_debug
    (rx1715_cur, rx1715_pos, rx1715_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1715_cur
    .local pmc match
    .lex "$/", match
    length rx1715_eos, rx1715_tgt
    gt rx1715_pos, rx1715_eos, rx1715_done
    set rx1715_off, 0
    lt rx1715_pos, 2, rx1715_start
    sub rx1715_off, rx1715_pos, 1
    substr rx1715_tgt, rx1715_tgt, rx1715_off
  rx1715_start:
    eq $I10, 1, rx1715_restart
    if_null rx1715_debug, debug_1284
    rx1715_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1284:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1719_done
    goto rxscan1719_scan
  rxscan1719_loop:
    (rx1715_pos) = rx1715_cur."from"()
    inc rx1715_pos
    rx1715_cur."!cursor_from"(rx1715_pos)
    ge rx1715_pos, rx1715_eos, rxscan1719_done
  rxscan1719_scan:
    set_addr $I10, rxscan1719_loop
    rx1715_cur."!mark_push"(0, rx1715_pos, $I10)
  rxscan1719_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1720_fail
    rx1715_cur."!mark_push"(0, rx1715_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1715_pos, 2
    gt $I11, rx1715_eos, rx1715_fail
    sub $I11, rx1715_pos, rx1715_off
    substr $S10, rx1715_tgt, $I11, 2
    ne $S10, "+^", rx1715_fail
    add rx1715_pos, 2
    set_addr $I10, rxcap_1720_fail
    ($I12, $I11) = rx1715_cur."!mark_peek"($I10)
    rx1715_cur."!cursor_pos"($I11)
    ($P10) = rx1715_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1715_pos, "")
    rx1715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1720_done
  rxcap_1720_fail:
    goto rx1715_fail
  rxcap_1720_done:
  # rx subrule "O" subtype=capture negate=
    rx1715_cur."!cursor_pos"(rx1715_pos)
    $P10 = rx1715_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1715_fail
    rx1715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1715_pos = $P10."pos"()
  # rx pass
    rx1715_cur."!cursor_pass"(rx1715_pos, "infix:sym<+^>")
    if_null rx1715_debug, debug_1285
    rx1715_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1715_pos)
  debug_1285:
    .return (rx1715_cur)
  rx1715_restart:
.annotate 'line', 10
    if_null rx1715_debug, debug_1286
    rx1715_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1286:
  rx1715_fail:
    (rx1715_rep, rx1715_pos, $I10, $P10) = rx1715_cur."!mark_fail"(0)
    lt rx1715_pos, -1, rx1715_done
    eq rx1715_pos, -1, rx1715_fail
    jump $I10
  rx1715_done:
    rx1715_cur."!cursor_fail"()
    if_null rx1715_debug, debug_1287
    rx1715_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1287:
    .return (rx1715_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("324_1303748459.273") :method
.annotate 'line', 10
    $P1717 = self."!PREFIX__!subrule"("O", "+^")
    new $P1718, "ResizablePMCArray"
    push $P1718, $P1717
    .return ($P1718)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("325_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1722_tgt
    .local int rx1722_pos
    .local int rx1722_off
    .local int rx1722_eos
    .local int rx1722_rep
    .local pmc rx1722_cur
    .local pmc rx1722_debug
    (rx1722_cur, rx1722_pos, rx1722_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1722_cur
    .local pmc match
    .lex "$/", match
    length rx1722_eos, rx1722_tgt
    gt rx1722_pos, rx1722_eos, rx1722_done
    set rx1722_off, 0
    lt rx1722_pos, 2, rx1722_start
    sub rx1722_off, rx1722_pos, 1
    substr rx1722_tgt, rx1722_tgt, rx1722_off
  rx1722_start:
    eq $I10, 1, rx1722_restart
    if_null rx1722_debug, debug_1288
    rx1722_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1288:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1726_done
    goto rxscan1726_scan
  rxscan1726_loop:
    (rx1722_pos) = rx1722_cur."from"()
    inc rx1722_pos
    rx1722_cur."!cursor_from"(rx1722_pos)
    ge rx1722_pos, rx1722_eos, rxscan1726_done
  rxscan1726_scan:
    set_addr $I10, rxscan1726_loop
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  rxscan1726_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1727_fail
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  # rx literal  "~"
    add $I11, rx1722_pos, 1
    gt $I11, rx1722_eos, rx1722_fail
    sub $I11, rx1722_pos, rx1722_off
    ord $I11, rx1722_tgt, $I11
    ne $I11, 126, rx1722_fail
    add rx1722_pos, 1
    set_addr $I10, rxcap_1727_fail
    ($I12, $I11) = rx1722_cur."!mark_peek"($I10)
    rx1722_cur."!cursor_pos"($I11)
    ($P10) = rx1722_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1722_pos, "")
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1727_done
  rxcap_1727_fail:
    goto rx1722_fail
  rxcap_1727_done:
  # rx subrule "O" subtype=capture negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1722_fail
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1722_pos = $P10."pos"()
  # rx pass
    rx1722_cur."!cursor_pass"(rx1722_pos, "infix:sym<~>")
    if_null rx1722_debug, debug_1289
    rx1722_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1722_pos)
  debug_1289:
    .return (rx1722_cur)
  rx1722_restart:
.annotate 'line', 10
    if_null rx1722_debug, debug_1290
    rx1722_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1290:
  rx1722_fail:
    (rx1722_rep, rx1722_pos, $I10, $P10) = rx1722_cur."!mark_fail"(0)
    lt rx1722_pos, -1, rx1722_done
    eq rx1722_pos, -1, rx1722_fail
    jump $I10
  rx1722_done:
    rx1722_cur."!cursor_fail"()
    if_null rx1722_debug, debug_1291
    rx1722_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1291:
    .return (rx1722_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("326_1303748459.273") :method
.annotate 'line', 10
    $P1724 = self."!PREFIX__!subrule"("O", "~")
    new $P1725, "ResizablePMCArray"
    push $P1725, $P1724
    .return ($P1725)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("327_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1729_tgt
    .local int rx1729_pos
    .local int rx1729_off
    .local int rx1729_eos
    .local int rx1729_rep
    .local pmc rx1729_cur
    .local pmc rx1729_debug
    (rx1729_cur, rx1729_pos, rx1729_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1729_cur
    .local pmc match
    .lex "$/", match
    length rx1729_eos, rx1729_tgt
    gt rx1729_pos, rx1729_eos, rx1729_done
    set rx1729_off, 0
    lt rx1729_pos, 2, rx1729_start
    sub rx1729_off, rx1729_pos, 1
    substr rx1729_tgt, rx1729_tgt, rx1729_off
  rx1729_start:
    eq $I10, 1, rx1729_restart
    if_null rx1729_debug, debug_1292
    rx1729_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1292:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1733_done
    goto rxscan1733_scan
  rxscan1733_loop:
    (rx1729_pos) = rx1729_cur."from"()
    inc rx1729_pos
    rx1729_cur."!cursor_from"(rx1729_pos)
    ge rx1729_pos, rx1729_eos, rxscan1733_done
  rxscan1733_scan:
    set_addr $I10, rxscan1733_loop
    rx1729_cur."!mark_push"(0, rx1729_pos, $I10)
  rxscan1733_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_1734_fail
    rx1729_cur."!mark_push"(0, rx1729_pos, $I10)
  # rx literal  "=="
    add $I11, rx1729_pos, 2
    gt $I11, rx1729_eos, rx1729_fail
    sub $I11, rx1729_pos, rx1729_off
    substr $S10, rx1729_tgt, $I11, 2
    ne $S10, "==", rx1729_fail
    add rx1729_pos, 2
    set_addr $I10, rxcap_1734_fail
    ($I12, $I11) = rx1729_cur."!mark_peek"($I10)
    rx1729_cur."!cursor_pos"($I11)
    ($P10) = rx1729_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1729_pos, "")
    rx1729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1734_done
  rxcap_1734_fail:
    goto rx1729_fail
  rxcap_1734_done:
  # rx subrule "O" subtype=capture negate=
    rx1729_cur."!cursor_pos"(rx1729_pos)
    $P10 = rx1729_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1729_fail
    rx1729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1729_pos = $P10."pos"()
  # rx pass
    rx1729_cur."!cursor_pass"(rx1729_pos, "infix:sym<==>")
    if_null rx1729_debug, debug_1293
    rx1729_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1729_pos)
  debug_1293:
    .return (rx1729_cur)
  rx1729_restart:
.annotate 'line', 10
    if_null rx1729_debug, debug_1294
    rx1729_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1294:
  rx1729_fail:
    (rx1729_rep, rx1729_pos, $I10, $P10) = rx1729_cur."!mark_fail"(0)
    lt rx1729_pos, -1, rx1729_done
    eq rx1729_pos, -1, rx1729_fail
    jump $I10
  rx1729_done:
    rx1729_cur."!cursor_fail"()
    if_null rx1729_debug, debug_1295
    rx1729_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1295:
    .return (rx1729_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("328_1303748459.273") :method
.annotate 'line', 10
    $P1731 = self."!PREFIX__!subrule"("O", "==")
    new $P1732, "ResizablePMCArray"
    push $P1732, $P1731
    .return ($P1732)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("329_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1736_tgt
    .local int rx1736_pos
    .local int rx1736_off
    .local int rx1736_eos
    .local int rx1736_rep
    .local pmc rx1736_cur
    .local pmc rx1736_debug
    (rx1736_cur, rx1736_pos, rx1736_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1736_cur
    .local pmc match
    .lex "$/", match
    length rx1736_eos, rx1736_tgt
    gt rx1736_pos, rx1736_eos, rx1736_done
    set rx1736_off, 0
    lt rx1736_pos, 2, rx1736_start
    sub rx1736_off, rx1736_pos, 1
    substr rx1736_tgt, rx1736_tgt, rx1736_off
  rx1736_start:
    eq $I10, 1, rx1736_restart
    if_null rx1736_debug, debug_1296
    rx1736_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1296:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1740_done
    goto rxscan1740_scan
  rxscan1740_loop:
    (rx1736_pos) = rx1736_cur."from"()
    inc rx1736_pos
    rx1736_cur."!cursor_from"(rx1736_pos)
    ge rx1736_pos, rx1736_eos, rxscan1740_done
  rxscan1740_scan:
    set_addr $I10, rxscan1740_loop
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  rxscan1740_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1741_fail
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  # rx literal  "!="
    add $I11, rx1736_pos, 2
    gt $I11, rx1736_eos, rx1736_fail
    sub $I11, rx1736_pos, rx1736_off
    substr $S10, rx1736_tgt, $I11, 2
    ne $S10, "!=", rx1736_fail
    add rx1736_pos, 2
    set_addr $I10, rxcap_1741_fail
    ($I12, $I11) = rx1736_cur."!mark_peek"($I10)
    rx1736_cur."!cursor_pos"($I11)
    ($P10) = rx1736_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1736_pos, "")
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1741_done
  rxcap_1741_fail:
    goto rx1736_fail
  rxcap_1741_done:
  # rx subrule "O" subtype=capture negate=
    rx1736_cur."!cursor_pos"(rx1736_pos)
    $P10 = rx1736_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1736_fail
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1736_pos = $P10."pos"()
  # rx pass
    rx1736_cur."!cursor_pass"(rx1736_pos, "infix:sym<!=>")
    if_null rx1736_debug, debug_1297
    rx1736_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1736_pos)
  debug_1297:
    .return (rx1736_cur)
  rx1736_restart:
.annotate 'line', 10
    if_null rx1736_debug, debug_1298
    rx1736_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1298:
  rx1736_fail:
    (rx1736_rep, rx1736_pos, $I10, $P10) = rx1736_cur."!mark_fail"(0)
    lt rx1736_pos, -1, rx1736_done
    eq rx1736_pos, -1, rx1736_fail
    jump $I10
  rx1736_done:
    rx1736_cur."!cursor_fail"()
    if_null rx1736_debug, debug_1299
    rx1736_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1299:
    .return (rx1736_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("330_1303748459.273") :method
.annotate 'line', 10
    $P1738 = self."!PREFIX__!subrule"("O", "!=")
    new $P1739, "ResizablePMCArray"
    push $P1739, $P1738
    .return ($P1739)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("331_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1743_tgt
    .local int rx1743_pos
    .local int rx1743_off
    .local int rx1743_eos
    .local int rx1743_rep
    .local pmc rx1743_cur
    .local pmc rx1743_debug
    (rx1743_cur, rx1743_pos, rx1743_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1743_cur
    .local pmc match
    .lex "$/", match
    length rx1743_eos, rx1743_tgt
    gt rx1743_pos, rx1743_eos, rx1743_done
    set rx1743_off, 0
    lt rx1743_pos, 2, rx1743_start
    sub rx1743_off, rx1743_pos, 1
    substr rx1743_tgt, rx1743_tgt, rx1743_off
  rx1743_start:
    eq $I10, 1, rx1743_restart
    if_null rx1743_debug, debug_1300
    rx1743_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1300:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1747_done
    goto rxscan1747_scan
  rxscan1747_loop:
    (rx1743_pos) = rx1743_cur."from"()
    inc rx1743_pos
    rx1743_cur."!cursor_from"(rx1743_pos)
    ge rx1743_pos, rx1743_eos, rxscan1747_done
  rxscan1747_scan:
    set_addr $I10, rxscan1747_loop
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10)
  rxscan1747_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_1748_fail
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10)
  # rx literal  "<="
    add $I11, rx1743_pos, 2
    gt $I11, rx1743_eos, rx1743_fail
    sub $I11, rx1743_pos, rx1743_off
    substr $S10, rx1743_tgt, $I11, 2
    ne $S10, "<=", rx1743_fail
    add rx1743_pos, 2
    set_addr $I10, rxcap_1748_fail
    ($I12, $I11) = rx1743_cur."!mark_peek"($I10)
    rx1743_cur."!cursor_pos"($I11)
    ($P10) = rx1743_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1743_pos, "")
    rx1743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1748_done
  rxcap_1748_fail:
    goto rx1743_fail
  rxcap_1748_done:
  # rx subrule "O" subtype=capture negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1743_fail
    rx1743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1743_pos = $P10."pos"()
  # rx pass
    rx1743_cur."!cursor_pass"(rx1743_pos, "infix:sym<<=>")
    if_null rx1743_debug, debug_1301
    rx1743_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1743_pos)
  debug_1301:
    .return (rx1743_cur)
  rx1743_restart:
.annotate 'line', 10
    if_null rx1743_debug, debug_1302
    rx1743_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1302:
  rx1743_fail:
    (rx1743_rep, rx1743_pos, $I10, $P10) = rx1743_cur."!mark_fail"(0)
    lt rx1743_pos, -1, rx1743_done
    eq rx1743_pos, -1, rx1743_fail
    jump $I10
  rx1743_done:
    rx1743_cur."!cursor_fail"()
    if_null rx1743_debug, debug_1303
    rx1743_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1303:
    .return (rx1743_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("332_1303748459.273") :method
.annotate 'line', 10
    $P1745 = self."!PREFIX__!subrule"("O", "<=")
    new $P1746, "ResizablePMCArray"
    push $P1746, $P1745
    .return ($P1746)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("333_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1750_tgt
    .local int rx1750_pos
    .local int rx1750_off
    .local int rx1750_eos
    .local int rx1750_rep
    .local pmc rx1750_cur
    .local pmc rx1750_debug
    (rx1750_cur, rx1750_pos, rx1750_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1750_cur
    .local pmc match
    .lex "$/", match
    length rx1750_eos, rx1750_tgt
    gt rx1750_pos, rx1750_eos, rx1750_done
    set rx1750_off, 0
    lt rx1750_pos, 2, rx1750_start
    sub rx1750_off, rx1750_pos, 1
    substr rx1750_tgt, rx1750_tgt, rx1750_off
  rx1750_start:
    eq $I10, 1, rx1750_restart
    if_null rx1750_debug, debug_1304
    rx1750_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1304:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1754_done
    goto rxscan1754_scan
  rxscan1754_loop:
    (rx1750_pos) = rx1750_cur."from"()
    inc rx1750_pos
    rx1750_cur."!cursor_from"(rx1750_pos)
    ge rx1750_pos, rx1750_eos, rxscan1754_done
  rxscan1754_scan:
    set_addr $I10, rxscan1754_loop
    rx1750_cur."!mark_push"(0, rx1750_pos, $I10)
  rxscan1754_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1755_fail
    rx1750_cur."!mark_push"(0, rx1750_pos, $I10)
  # rx literal  ">="
    add $I11, rx1750_pos, 2
    gt $I11, rx1750_eos, rx1750_fail
    sub $I11, rx1750_pos, rx1750_off
    substr $S10, rx1750_tgt, $I11, 2
    ne $S10, ">=", rx1750_fail
    add rx1750_pos, 2
    set_addr $I10, rxcap_1755_fail
    ($I12, $I11) = rx1750_cur."!mark_peek"($I10)
    rx1750_cur."!cursor_pos"($I11)
    ($P10) = rx1750_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1750_pos, "")
    rx1750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1755_done
  rxcap_1755_fail:
    goto rx1750_fail
  rxcap_1755_done:
  # rx subrule "O" subtype=capture negate=
    rx1750_cur."!cursor_pos"(rx1750_pos)
    $P10 = rx1750_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1750_fail
    rx1750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1750_pos = $P10."pos"()
  # rx pass
    rx1750_cur."!cursor_pass"(rx1750_pos, "infix:sym<>=>")
    if_null rx1750_debug, debug_1305
    rx1750_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1750_pos)
  debug_1305:
    .return (rx1750_cur)
  rx1750_restart:
.annotate 'line', 10
    if_null rx1750_debug, debug_1306
    rx1750_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1306:
  rx1750_fail:
    (rx1750_rep, rx1750_pos, $I10, $P10) = rx1750_cur."!mark_fail"(0)
    lt rx1750_pos, -1, rx1750_done
    eq rx1750_pos, -1, rx1750_fail
    jump $I10
  rx1750_done:
    rx1750_cur."!cursor_fail"()
    if_null rx1750_debug, debug_1307
    rx1750_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1307:
    .return (rx1750_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("334_1303748459.273") :method
.annotate 'line', 10
    $P1752 = self."!PREFIX__!subrule"("O", ">=")
    new $P1753, "ResizablePMCArray"
    push $P1753, $P1752
    .return ($P1753)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("335_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1757_tgt
    .local int rx1757_pos
    .local int rx1757_off
    .local int rx1757_eos
    .local int rx1757_rep
    .local pmc rx1757_cur
    .local pmc rx1757_debug
    (rx1757_cur, rx1757_pos, rx1757_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1757_cur
    .local pmc match
    .lex "$/", match
    length rx1757_eos, rx1757_tgt
    gt rx1757_pos, rx1757_eos, rx1757_done
    set rx1757_off, 0
    lt rx1757_pos, 2, rx1757_start
    sub rx1757_off, rx1757_pos, 1
    substr rx1757_tgt, rx1757_tgt, rx1757_off
  rx1757_start:
    eq $I10, 1, rx1757_restart
    if_null rx1757_debug, debug_1308
    rx1757_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1308:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1761_done
    goto rxscan1761_scan
  rxscan1761_loop:
    (rx1757_pos) = rx1757_cur."from"()
    inc rx1757_pos
    rx1757_cur."!cursor_from"(rx1757_pos)
    ge rx1757_pos, rx1757_eos, rxscan1761_done
  rxscan1761_scan:
    set_addr $I10, rxscan1761_loop
    rx1757_cur."!mark_push"(0, rx1757_pos, $I10)
  rxscan1761_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1762_fail
    rx1757_cur."!mark_push"(0, rx1757_pos, $I10)
  # rx literal  "<"
    add $I11, rx1757_pos, 1
    gt $I11, rx1757_eos, rx1757_fail
    sub $I11, rx1757_pos, rx1757_off
    ord $I11, rx1757_tgt, $I11
    ne $I11, 60, rx1757_fail
    add rx1757_pos, 1
    set_addr $I10, rxcap_1762_fail
    ($I12, $I11) = rx1757_cur."!mark_peek"($I10)
    rx1757_cur."!cursor_pos"($I11)
    ($P10) = rx1757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1757_pos, "")
    rx1757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1762_done
  rxcap_1762_fail:
    goto rx1757_fail
  rxcap_1762_done:
  # rx subrule "O" subtype=capture negate=
    rx1757_cur."!cursor_pos"(rx1757_pos)
    $P10 = rx1757_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1757_fail
    rx1757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1757_pos = $P10."pos"()
  # rx pass
    rx1757_cur."!cursor_pass"(rx1757_pos, "infix:sym<<>")
    if_null rx1757_debug, debug_1309
    rx1757_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1757_pos)
  debug_1309:
    .return (rx1757_cur)
  rx1757_restart:
.annotate 'line', 10
    if_null rx1757_debug, debug_1310
    rx1757_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1310:
  rx1757_fail:
    (rx1757_rep, rx1757_pos, $I10, $P10) = rx1757_cur."!mark_fail"(0)
    lt rx1757_pos, -1, rx1757_done
    eq rx1757_pos, -1, rx1757_fail
    jump $I10
  rx1757_done:
    rx1757_cur."!cursor_fail"()
    if_null rx1757_debug, debug_1311
    rx1757_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1311:
    .return (rx1757_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("336_1303748459.273") :method
.annotate 'line', 10
    $P1759 = self."!PREFIX__!subrule"("O", "<")
    new $P1760, "ResizablePMCArray"
    push $P1760, $P1759
    .return ($P1760)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("337_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1764_tgt
    .local int rx1764_pos
    .local int rx1764_off
    .local int rx1764_eos
    .local int rx1764_rep
    .local pmc rx1764_cur
    .local pmc rx1764_debug
    (rx1764_cur, rx1764_pos, rx1764_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1764_cur
    .local pmc match
    .lex "$/", match
    length rx1764_eos, rx1764_tgt
    gt rx1764_pos, rx1764_eos, rx1764_done
    set rx1764_off, 0
    lt rx1764_pos, 2, rx1764_start
    sub rx1764_off, rx1764_pos, 1
    substr rx1764_tgt, rx1764_tgt, rx1764_off
  rx1764_start:
    eq $I10, 1, rx1764_restart
    if_null rx1764_debug, debug_1312
    rx1764_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1312:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1768_done
    goto rxscan1768_scan
  rxscan1768_loop:
    (rx1764_pos) = rx1764_cur."from"()
    inc rx1764_pos
    rx1764_cur."!cursor_from"(rx1764_pos)
    ge rx1764_pos, rx1764_eos, rxscan1768_done
  rxscan1768_scan:
    set_addr $I10, rxscan1768_loop
    rx1764_cur."!mark_push"(0, rx1764_pos, $I10)
  rxscan1768_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1769_fail
    rx1764_cur."!mark_push"(0, rx1764_pos, $I10)
  # rx literal  ">"
    add $I11, rx1764_pos, 1
    gt $I11, rx1764_eos, rx1764_fail
    sub $I11, rx1764_pos, rx1764_off
    ord $I11, rx1764_tgt, $I11
    ne $I11, 62, rx1764_fail
    add rx1764_pos, 1
    set_addr $I10, rxcap_1769_fail
    ($I12, $I11) = rx1764_cur."!mark_peek"($I10)
    rx1764_cur."!cursor_pos"($I11)
    ($P10) = rx1764_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1764_pos, "")
    rx1764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1769_done
  rxcap_1769_fail:
    goto rx1764_fail
  rxcap_1769_done:
  # rx subrule "O" subtype=capture negate=
    rx1764_cur."!cursor_pos"(rx1764_pos)
    $P10 = rx1764_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1764_fail
    rx1764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1764_pos = $P10."pos"()
  # rx pass
    rx1764_cur."!cursor_pass"(rx1764_pos, "infix:sym<>>")
    if_null rx1764_debug, debug_1313
    rx1764_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1764_pos)
  debug_1313:
    .return (rx1764_cur)
  rx1764_restart:
.annotate 'line', 10
    if_null rx1764_debug, debug_1314
    rx1764_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1314:
  rx1764_fail:
    (rx1764_rep, rx1764_pos, $I10, $P10) = rx1764_cur."!mark_fail"(0)
    lt rx1764_pos, -1, rx1764_done
    eq rx1764_pos, -1, rx1764_fail
    jump $I10
  rx1764_done:
    rx1764_cur."!cursor_fail"()
    if_null rx1764_debug, debug_1315
    rx1764_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1315:
    .return (rx1764_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("338_1303748459.273") :method
.annotate 'line', 10
    $P1766 = self."!PREFIX__!subrule"("O", ">")
    new $P1767, "ResizablePMCArray"
    push $P1767, $P1766
    .return ($P1767)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("339_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1771_tgt
    .local int rx1771_pos
    .local int rx1771_off
    .local int rx1771_eos
    .local int rx1771_rep
    .local pmc rx1771_cur
    .local pmc rx1771_debug
    (rx1771_cur, rx1771_pos, rx1771_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1771_cur
    .local pmc match
    .lex "$/", match
    length rx1771_eos, rx1771_tgt
    gt rx1771_pos, rx1771_eos, rx1771_done
    set rx1771_off, 0
    lt rx1771_pos, 2, rx1771_start
    sub rx1771_off, rx1771_pos, 1
    substr rx1771_tgt, rx1771_tgt, rx1771_off
  rx1771_start:
    eq $I10, 1, rx1771_restart
    if_null rx1771_debug, debug_1316
    rx1771_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1316:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1775_done
    goto rxscan1775_scan
  rxscan1775_loop:
    (rx1771_pos) = rx1771_cur."from"()
    inc rx1771_pos
    rx1771_cur."!cursor_from"(rx1771_pos)
    ge rx1771_pos, rx1771_eos, rxscan1775_done
  rxscan1775_scan:
    set_addr $I10, rxscan1775_loop
    rx1771_cur."!mark_push"(0, rx1771_pos, $I10)
  rxscan1775_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1776_fail
    rx1771_cur."!mark_push"(0, rx1771_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1771_pos, 2
    gt $I11, rx1771_eos, rx1771_fail
    sub $I11, rx1771_pos, rx1771_off
    substr $S10, rx1771_tgt, $I11, 2
    ne $S10, "eq", rx1771_fail
    add rx1771_pos, 2
    set_addr $I10, rxcap_1776_fail
    ($I12, $I11) = rx1771_cur."!mark_peek"($I10)
    rx1771_cur."!cursor_pos"($I11)
    ($P10) = rx1771_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1771_pos, "")
    rx1771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1776_done
  rxcap_1776_fail:
    goto rx1771_fail
  rxcap_1776_done:
  # rx subrule "O" subtype=capture negate=
    rx1771_cur."!cursor_pos"(rx1771_pos)
    $P10 = rx1771_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1771_fail
    rx1771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1771_pos = $P10."pos"()
  # rx pass
    rx1771_cur."!cursor_pass"(rx1771_pos, "infix:sym<eq>")
    if_null rx1771_debug, debug_1317
    rx1771_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1771_pos)
  debug_1317:
    .return (rx1771_cur)
  rx1771_restart:
.annotate 'line', 10
    if_null rx1771_debug, debug_1318
    rx1771_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1318:
  rx1771_fail:
    (rx1771_rep, rx1771_pos, $I10, $P10) = rx1771_cur."!mark_fail"(0)
    lt rx1771_pos, -1, rx1771_done
    eq rx1771_pos, -1, rx1771_fail
    jump $I10
  rx1771_done:
    rx1771_cur."!cursor_fail"()
    if_null rx1771_debug, debug_1319
    rx1771_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1319:
    .return (rx1771_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("340_1303748459.273") :method
.annotate 'line', 10
    $P1773 = self."!PREFIX__!subrule"("O", "eq")
    new $P1774, "ResizablePMCArray"
    push $P1774, $P1773
    .return ($P1774)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("341_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1778_tgt
    .local int rx1778_pos
    .local int rx1778_off
    .local int rx1778_eos
    .local int rx1778_rep
    .local pmc rx1778_cur
    .local pmc rx1778_debug
    (rx1778_cur, rx1778_pos, rx1778_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1778_cur
    .local pmc match
    .lex "$/", match
    length rx1778_eos, rx1778_tgt
    gt rx1778_pos, rx1778_eos, rx1778_done
    set rx1778_off, 0
    lt rx1778_pos, 2, rx1778_start
    sub rx1778_off, rx1778_pos, 1
    substr rx1778_tgt, rx1778_tgt, rx1778_off
  rx1778_start:
    eq $I10, 1, rx1778_restart
    if_null rx1778_debug, debug_1320
    rx1778_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1320:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1782_done
    goto rxscan1782_scan
  rxscan1782_loop:
    (rx1778_pos) = rx1778_cur."from"()
    inc rx1778_pos
    rx1778_cur."!cursor_from"(rx1778_pos)
    ge rx1778_pos, rx1778_eos, rxscan1782_done
  rxscan1782_scan:
    set_addr $I10, rxscan1782_loop
    rx1778_cur."!mark_push"(0, rx1778_pos, $I10)
  rxscan1782_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1783_fail
    rx1778_cur."!mark_push"(0, rx1778_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1778_pos, 2
    gt $I11, rx1778_eos, rx1778_fail
    sub $I11, rx1778_pos, rx1778_off
    substr $S10, rx1778_tgt, $I11, 2
    ne $S10, "ne", rx1778_fail
    add rx1778_pos, 2
    set_addr $I10, rxcap_1783_fail
    ($I12, $I11) = rx1778_cur."!mark_peek"($I10)
    rx1778_cur."!cursor_pos"($I11)
    ($P10) = rx1778_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1778_pos, "")
    rx1778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1783_done
  rxcap_1783_fail:
    goto rx1778_fail
  rxcap_1783_done:
  # rx subrule "O" subtype=capture negate=
    rx1778_cur."!cursor_pos"(rx1778_pos)
    $P10 = rx1778_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1778_fail
    rx1778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1778_pos = $P10."pos"()
  # rx pass
    rx1778_cur."!cursor_pass"(rx1778_pos, "infix:sym<ne>")
    if_null rx1778_debug, debug_1321
    rx1778_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1778_pos)
  debug_1321:
    .return (rx1778_cur)
  rx1778_restart:
.annotate 'line', 10
    if_null rx1778_debug, debug_1322
    rx1778_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1322:
  rx1778_fail:
    (rx1778_rep, rx1778_pos, $I10, $P10) = rx1778_cur."!mark_fail"(0)
    lt rx1778_pos, -1, rx1778_done
    eq rx1778_pos, -1, rx1778_fail
    jump $I10
  rx1778_done:
    rx1778_cur."!cursor_fail"()
    if_null rx1778_debug, debug_1323
    rx1778_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1323:
    .return (rx1778_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("342_1303748459.273") :method
.annotate 'line', 10
    $P1780 = self."!PREFIX__!subrule"("O", "ne")
    new $P1781, "ResizablePMCArray"
    push $P1781, $P1780
    .return ($P1781)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("343_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1785_tgt
    .local int rx1785_pos
    .local int rx1785_off
    .local int rx1785_eos
    .local int rx1785_rep
    .local pmc rx1785_cur
    .local pmc rx1785_debug
    (rx1785_cur, rx1785_pos, rx1785_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1785_cur
    .local pmc match
    .lex "$/", match
    length rx1785_eos, rx1785_tgt
    gt rx1785_pos, rx1785_eos, rx1785_done
    set rx1785_off, 0
    lt rx1785_pos, 2, rx1785_start
    sub rx1785_off, rx1785_pos, 1
    substr rx1785_tgt, rx1785_tgt, rx1785_off
  rx1785_start:
    eq $I10, 1, rx1785_restart
    if_null rx1785_debug, debug_1324
    rx1785_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1324:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1789_done
    goto rxscan1789_scan
  rxscan1789_loop:
    (rx1785_pos) = rx1785_cur."from"()
    inc rx1785_pos
    rx1785_cur."!cursor_from"(rx1785_pos)
    ge rx1785_pos, rx1785_eos, rxscan1789_done
  rxscan1789_scan:
    set_addr $I10, rxscan1789_loop
    rx1785_cur."!mark_push"(0, rx1785_pos, $I10)
  rxscan1789_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1790_fail
    rx1785_cur."!mark_push"(0, rx1785_pos, $I10)
  # rx literal  "le"
    add $I11, rx1785_pos, 2
    gt $I11, rx1785_eos, rx1785_fail
    sub $I11, rx1785_pos, rx1785_off
    substr $S10, rx1785_tgt, $I11, 2
    ne $S10, "le", rx1785_fail
    add rx1785_pos, 2
    set_addr $I10, rxcap_1790_fail
    ($I12, $I11) = rx1785_cur."!mark_peek"($I10)
    rx1785_cur."!cursor_pos"($I11)
    ($P10) = rx1785_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1785_pos, "")
    rx1785_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1790_done
  rxcap_1790_fail:
    goto rx1785_fail
  rxcap_1790_done:
  # rx subrule "O" subtype=capture negate=
    rx1785_cur."!cursor_pos"(rx1785_pos)
    $P10 = rx1785_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1785_fail
    rx1785_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1785_pos = $P10."pos"()
  # rx pass
    rx1785_cur."!cursor_pass"(rx1785_pos, "infix:sym<le>")
    if_null rx1785_debug, debug_1325
    rx1785_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1785_pos)
  debug_1325:
    .return (rx1785_cur)
  rx1785_restart:
.annotate 'line', 10
    if_null rx1785_debug, debug_1326
    rx1785_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1326:
  rx1785_fail:
    (rx1785_rep, rx1785_pos, $I10, $P10) = rx1785_cur."!mark_fail"(0)
    lt rx1785_pos, -1, rx1785_done
    eq rx1785_pos, -1, rx1785_fail
    jump $I10
  rx1785_done:
    rx1785_cur."!cursor_fail"()
    if_null rx1785_debug, debug_1327
    rx1785_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1327:
    .return (rx1785_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("344_1303748459.273") :method
.annotate 'line', 10
    $P1787 = self."!PREFIX__!subrule"("O", "le")
    new $P1788, "ResizablePMCArray"
    push $P1788, $P1787
    .return ($P1788)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("345_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1792_tgt
    .local int rx1792_pos
    .local int rx1792_off
    .local int rx1792_eos
    .local int rx1792_rep
    .local pmc rx1792_cur
    .local pmc rx1792_debug
    (rx1792_cur, rx1792_pos, rx1792_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1792_cur
    .local pmc match
    .lex "$/", match
    length rx1792_eos, rx1792_tgt
    gt rx1792_pos, rx1792_eos, rx1792_done
    set rx1792_off, 0
    lt rx1792_pos, 2, rx1792_start
    sub rx1792_off, rx1792_pos, 1
    substr rx1792_tgt, rx1792_tgt, rx1792_off
  rx1792_start:
    eq $I10, 1, rx1792_restart
    if_null rx1792_debug, debug_1328
    rx1792_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1328:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1796_done
    goto rxscan1796_scan
  rxscan1796_loop:
    (rx1792_pos) = rx1792_cur."from"()
    inc rx1792_pos
    rx1792_cur."!cursor_from"(rx1792_pos)
    ge rx1792_pos, rx1792_eos, rxscan1796_done
  rxscan1796_scan:
    set_addr $I10, rxscan1796_loop
    rx1792_cur."!mark_push"(0, rx1792_pos, $I10)
  rxscan1796_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1797_fail
    rx1792_cur."!mark_push"(0, rx1792_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1792_pos, 2
    gt $I11, rx1792_eos, rx1792_fail
    sub $I11, rx1792_pos, rx1792_off
    substr $S10, rx1792_tgt, $I11, 2
    ne $S10, "ge", rx1792_fail
    add rx1792_pos, 2
    set_addr $I10, rxcap_1797_fail
    ($I12, $I11) = rx1792_cur."!mark_peek"($I10)
    rx1792_cur."!cursor_pos"($I11)
    ($P10) = rx1792_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1792_pos, "")
    rx1792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1797_done
  rxcap_1797_fail:
    goto rx1792_fail
  rxcap_1797_done:
  # rx subrule "O" subtype=capture negate=
    rx1792_cur."!cursor_pos"(rx1792_pos)
    $P10 = rx1792_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1792_fail
    rx1792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1792_pos = $P10."pos"()
  # rx pass
    rx1792_cur."!cursor_pass"(rx1792_pos, "infix:sym<ge>")
    if_null rx1792_debug, debug_1329
    rx1792_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1792_pos)
  debug_1329:
    .return (rx1792_cur)
  rx1792_restart:
.annotate 'line', 10
    if_null rx1792_debug, debug_1330
    rx1792_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1330:
  rx1792_fail:
    (rx1792_rep, rx1792_pos, $I10, $P10) = rx1792_cur."!mark_fail"(0)
    lt rx1792_pos, -1, rx1792_done
    eq rx1792_pos, -1, rx1792_fail
    jump $I10
  rx1792_done:
    rx1792_cur."!cursor_fail"()
    if_null rx1792_debug, debug_1331
    rx1792_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1331:
    .return (rx1792_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("346_1303748459.273") :method
.annotate 'line', 10
    $P1794 = self."!PREFIX__!subrule"("O", "ge")
    new $P1795, "ResizablePMCArray"
    push $P1795, $P1794
    .return ($P1795)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("347_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1799_tgt
    .local int rx1799_pos
    .local int rx1799_off
    .local int rx1799_eos
    .local int rx1799_rep
    .local pmc rx1799_cur
    .local pmc rx1799_debug
    (rx1799_cur, rx1799_pos, rx1799_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1799_cur
    .local pmc match
    .lex "$/", match
    length rx1799_eos, rx1799_tgt
    gt rx1799_pos, rx1799_eos, rx1799_done
    set rx1799_off, 0
    lt rx1799_pos, 2, rx1799_start
    sub rx1799_off, rx1799_pos, 1
    substr rx1799_tgt, rx1799_tgt, rx1799_off
  rx1799_start:
    eq $I10, 1, rx1799_restart
    if_null rx1799_debug, debug_1332
    rx1799_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1332:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1803_done
    goto rxscan1803_scan
  rxscan1803_loop:
    (rx1799_pos) = rx1799_cur."from"()
    inc rx1799_pos
    rx1799_cur."!cursor_from"(rx1799_pos)
    ge rx1799_pos, rx1799_eos, rxscan1803_done
  rxscan1803_scan:
    set_addr $I10, rxscan1803_loop
    rx1799_cur."!mark_push"(0, rx1799_pos, $I10)
  rxscan1803_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1804_fail
    rx1799_cur."!mark_push"(0, rx1799_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1799_pos, 2
    gt $I11, rx1799_eos, rx1799_fail
    sub $I11, rx1799_pos, rx1799_off
    substr $S10, rx1799_tgt, $I11, 2
    ne $S10, "lt", rx1799_fail
    add rx1799_pos, 2
    set_addr $I10, rxcap_1804_fail
    ($I12, $I11) = rx1799_cur."!mark_peek"($I10)
    rx1799_cur."!cursor_pos"($I11)
    ($P10) = rx1799_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1799_pos, "")
    rx1799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1804_done
  rxcap_1804_fail:
    goto rx1799_fail
  rxcap_1804_done:
  # rx subrule "O" subtype=capture negate=
    rx1799_cur."!cursor_pos"(rx1799_pos)
    $P10 = rx1799_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1799_fail
    rx1799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1799_pos = $P10."pos"()
  # rx pass
    rx1799_cur."!cursor_pass"(rx1799_pos, "infix:sym<lt>")
    if_null rx1799_debug, debug_1333
    rx1799_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1799_pos)
  debug_1333:
    .return (rx1799_cur)
  rx1799_restart:
.annotate 'line', 10
    if_null rx1799_debug, debug_1334
    rx1799_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1334:
  rx1799_fail:
    (rx1799_rep, rx1799_pos, $I10, $P10) = rx1799_cur."!mark_fail"(0)
    lt rx1799_pos, -1, rx1799_done
    eq rx1799_pos, -1, rx1799_fail
    jump $I10
  rx1799_done:
    rx1799_cur."!cursor_fail"()
    if_null rx1799_debug, debug_1335
    rx1799_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1335:
    .return (rx1799_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("348_1303748459.273") :method
.annotate 'line', 10
    $P1801 = self."!PREFIX__!subrule"("O", "lt")
    new $P1802, "ResizablePMCArray"
    push $P1802, $P1801
    .return ($P1802)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("349_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1806_tgt
    .local int rx1806_pos
    .local int rx1806_off
    .local int rx1806_eos
    .local int rx1806_rep
    .local pmc rx1806_cur
    .local pmc rx1806_debug
    (rx1806_cur, rx1806_pos, rx1806_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1806_cur
    .local pmc match
    .lex "$/", match
    length rx1806_eos, rx1806_tgt
    gt rx1806_pos, rx1806_eos, rx1806_done
    set rx1806_off, 0
    lt rx1806_pos, 2, rx1806_start
    sub rx1806_off, rx1806_pos, 1
    substr rx1806_tgt, rx1806_tgt, rx1806_off
  rx1806_start:
    eq $I10, 1, rx1806_restart
    if_null rx1806_debug, debug_1336
    rx1806_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1336:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1810_done
    goto rxscan1810_scan
  rxscan1810_loop:
    (rx1806_pos) = rx1806_cur."from"()
    inc rx1806_pos
    rx1806_cur."!cursor_from"(rx1806_pos)
    ge rx1806_pos, rx1806_eos, rxscan1810_done
  rxscan1810_scan:
    set_addr $I10, rxscan1810_loop
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  rxscan1810_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1811_fail
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1806_pos, 2
    gt $I11, rx1806_eos, rx1806_fail
    sub $I11, rx1806_pos, rx1806_off
    substr $S10, rx1806_tgt, $I11, 2
    ne $S10, "gt", rx1806_fail
    add rx1806_pos, 2
    set_addr $I10, rxcap_1811_fail
    ($I12, $I11) = rx1806_cur."!mark_peek"($I10)
    rx1806_cur."!cursor_pos"($I11)
    ($P10) = rx1806_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1806_pos, "")
    rx1806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1811_done
  rxcap_1811_fail:
    goto rx1806_fail
  rxcap_1811_done:
  # rx subrule "O" subtype=capture negate=
    rx1806_cur."!cursor_pos"(rx1806_pos)
    $P10 = rx1806_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1806_fail
    rx1806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1806_pos = $P10."pos"()
  # rx pass
    rx1806_cur."!cursor_pass"(rx1806_pos, "infix:sym<gt>")
    if_null rx1806_debug, debug_1337
    rx1806_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1806_pos)
  debug_1337:
    .return (rx1806_cur)
  rx1806_restart:
.annotate 'line', 10
    if_null rx1806_debug, debug_1338
    rx1806_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1338:
  rx1806_fail:
    (rx1806_rep, rx1806_pos, $I10, $P10) = rx1806_cur."!mark_fail"(0)
    lt rx1806_pos, -1, rx1806_done
    eq rx1806_pos, -1, rx1806_fail
    jump $I10
  rx1806_done:
    rx1806_cur."!cursor_fail"()
    if_null rx1806_debug, debug_1339
    rx1806_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1339:
    .return (rx1806_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("350_1303748459.273") :method
.annotate 'line', 10
    $P1808 = self."!PREFIX__!subrule"("O", "gt")
    new $P1809, "ResizablePMCArray"
    push $P1809, $P1808
    .return ($P1809)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("351_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1813_tgt
    .local int rx1813_pos
    .local int rx1813_off
    .local int rx1813_eos
    .local int rx1813_rep
    .local pmc rx1813_cur
    .local pmc rx1813_debug
    (rx1813_cur, rx1813_pos, rx1813_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1813_cur
    .local pmc match
    .lex "$/", match
    length rx1813_eos, rx1813_tgt
    gt rx1813_pos, rx1813_eos, rx1813_done
    set rx1813_off, 0
    lt rx1813_pos, 2, rx1813_start
    sub rx1813_off, rx1813_pos, 1
    substr rx1813_tgt, rx1813_tgt, rx1813_off
  rx1813_start:
    eq $I10, 1, rx1813_restart
    if_null rx1813_debug, debug_1340
    rx1813_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1340:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1817_done
    goto rxscan1817_scan
  rxscan1817_loop:
    (rx1813_pos) = rx1813_cur."from"()
    inc rx1813_pos
    rx1813_cur."!cursor_from"(rx1813_pos)
    ge rx1813_pos, rx1813_eos, rxscan1817_done
  rxscan1817_scan:
    set_addr $I10, rxscan1817_loop
    rx1813_cur."!mark_push"(0, rx1813_pos, $I10)
  rxscan1817_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1818_fail
    rx1813_cur."!mark_push"(0, rx1813_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1813_pos, 3
    gt $I11, rx1813_eos, rx1813_fail
    sub $I11, rx1813_pos, rx1813_off
    substr $S10, rx1813_tgt, $I11, 3
    ne $S10, "=:=", rx1813_fail
    add rx1813_pos, 3
    set_addr $I10, rxcap_1818_fail
    ($I12, $I11) = rx1813_cur."!mark_peek"($I10)
    rx1813_cur."!cursor_pos"($I11)
    ($P10) = rx1813_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1813_pos, "")
    rx1813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1818_done
  rxcap_1818_fail:
    goto rx1813_fail
  rxcap_1818_done:
  # rx subrule "O" subtype=capture negate=
    rx1813_cur."!cursor_pos"(rx1813_pos)
    $P10 = rx1813_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1813_fail
    rx1813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1813_pos = $P10."pos"()
  # rx pass
    rx1813_cur."!cursor_pass"(rx1813_pos, "infix:sym<=:=>")
    if_null rx1813_debug, debug_1341
    rx1813_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1813_pos)
  debug_1341:
    .return (rx1813_cur)
  rx1813_restart:
.annotate 'line', 10
    if_null rx1813_debug, debug_1342
    rx1813_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1342:
  rx1813_fail:
    (rx1813_rep, rx1813_pos, $I10, $P10) = rx1813_cur."!mark_fail"(0)
    lt rx1813_pos, -1, rx1813_done
    eq rx1813_pos, -1, rx1813_fail
    jump $I10
  rx1813_done:
    rx1813_cur."!cursor_fail"()
    if_null rx1813_debug, debug_1343
    rx1813_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1343:
    .return (rx1813_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("352_1303748459.273") :method
.annotate 'line', 10
    $P1815 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1816, "ResizablePMCArray"
    push $P1816, $P1815
    .return ($P1816)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("353_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1820_tgt
    .local int rx1820_pos
    .local int rx1820_off
    .local int rx1820_eos
    .local int rx1820_rep
    .local pmc rx1820_cur
    .local pmc rx1820_debug
    (rx1820_cur, rx1820_pos, rx1820_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1820_cur
    .local pmc match
    .lex "$/", match
    length rx1820_eos, rx1820_tgt
    gt rx1820_pos, rx1820_eos, rx1820_done
    set rx1820_off, 0
    lt rx1820_pos, 2, rx1820_start
    sub rx1820_off, rx1820_pos, 1
    substr rx1820_tgt, rx1820_tgt, rx1820_off
  rx1820_start:
    eq $I10, 1, rx1820_restart
    if_null rx1820_debug, debug_1344
    rx1820_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1344:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1824_done
    goto rxscan1824_scan
  rxscan1824_loop:
    (rx1820_pos) = rx1820_cur."from"()
    inc rx1820_pos
    rx1820_cur."!cursor_from"(rx1820_pos)
    ge rx1820_pos, rx1820_eos, rxscan1824_done
  rxscan1824_scan:
    set_addr $I10, rxscan1824_loop
    rx1820_cur."!mark_push"(0, rx1820_pos, $I10)
  rxscan1824_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1825_fail
    rx1820_cur."!mark_push"(0, rx1820_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1820_pos, 2
    gt $I11, rx1820_eos, rx1820_fail
    sub $I11, rx1820_pos, rx1820_off
    substr $S10, rx1820_tgt, $I11, 2
    ne $S10, "~~", rx1820_fail
    add rx1820_pos, 2
    set_addr $I10, rxcap_1825_fail
    ($I12, $I11) = rx1820_cur."!mark_peek"($I10)
    rx1820_cur."!cursor_pos"($I11)
    ($P10) = rx1820_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1820_pos, "")
    rx1820_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1825_done
  rxcap_1825_fail:
    goto rx1820_fail
  rxcap_1825_done:
  # rx subrule "O" subtype=capture negate=
    rx1820_cur."!cursor_pos"(rx1820_pos)
    $P10 = rx1820_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1820_fail
    rx1820_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1820_pos = $P10."pos"()
  # rx pass
    rx1820_cur."!cursor_pass"(rx1820_pos, "infix:sym<~~>")
    if_null rx1820_debug, debug_1345
    rx1820_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1820_pos)
  debug_1345:
    .return (rx1820_cur)
  rx1820_restart:
.annotate 'line', 10
    if_null rx1820_debug, debug_1346
    rx1820_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1346:
  rx1820_fail:
    (rx1820_rep, rx1820_pos, $I10, $P10) = rx1820_cur."!mark_fail"(0)
    lt rx1820_pos, -1, rx1820_done
    eq rx1820_pos, -1, rx1820_fail
    jump $I10
  rx1820_done:
    rx1820_cur."!cursor_fail"()
    if_null rx1820_debug, debug_1347
    rx1820_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1347:
    .return (rx1820_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("354_1303748459.273") :method
.annotate 'line', 10
    $P1822 = self."!PREFIX__!subrule"("O", "~~")
    new $P1823, "ResizablePMCArray"
    push $P1823, $P1822
    .return ($P1823)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("355_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1827_tgt
    .local int rx1827_pos
    .local int rx1827_off
    .local int rx1827_eos
    .local int rx1827_rep
    .local pmc rx1827_cur
    .local pmc rx1827_debug
    (rx1827_cur, rx1827_pos, rx1827_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1827_cur
    .local pmc match
    .lex "$/", match
    length rx1827_eos, rx1827_tgt
    gt rx1827_pos, rx1827_eos, rx1827_done
    set rx1827_off, 0
    lt rx1827_pos, 2, rx1827_start
    sub rx1827_off, rx1827_pos, 1
    substr rx1827_tgt, rx1827_tgt, rx1827_off
  rx1827_start:
    eq $I10, 1, rx1827_restart
    if_null rx1827_debug, debug_1348
    rx1827_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1348:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1831_done
    goto rxscan1831_scan
  rxscan1831_loop:
    (rx1827_pos) = rx1827_cur."from"()
    inc rx1827_pos
    rx1827_cur."!cursor_from"(rx1827_pos)
    ge rx1827_pos, rx1827_eos, rxscan1831_done
  rxscan1831_scan:
    set_addr $I10, rxscan1831_loop
    rx1827_cur."!mark_push"(0, rx1827_pos, $I10)
  rxscan1831_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1832_fail
    rx1827_cur."!mark_push"(0, rx1827_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1827_pos, 2
    gt $I11, rx1827_eos, rx1827_fail
    sub $I11, rx1827_pos, rx1827_off
    substr $S10, rx1827_tgt, $I11, 2
    ne $S10, "&&", rx1827_fail
    add rx1827_pos, 2
    set_addr $I10, rxcap_1832_fail
    ($I12, $I11) = rx1827_cur."!mark_peek"($I10)
    rx1827_cur."!cursor_pos"($I11)
    ($P10) = rx1827_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1827_pos, "")
    rx1827_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1832_done
  rxcap_1832_fail:
    goto rx1827_fail
  rxcap_1832_done:
  # rx subrule "O" subtype=capture negate=
    rx1827_cur."!cursor_pos"(rx1827_pos)
    $P10 = rx1827_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1827_fail
    rx1827_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1827_pos = $P10."pos"()
  # rx pass
    rx1827_cur."!cursor_pass"(rx1827_pos, "infix:sym<&&>")
    if_null rx1827_debug, debug_1349
    rx1827_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1827_pos)
  debug_1349:
    .return (rx1827_cur)
  rx1827_restart:
.annotate 'line', 10
    if_null rx1827_debug, debug_1350
    rx1827_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1350:
  rx1827_fail:
    (rx1827_rep, rx1827_pos, $I10, $P10) = rx1827_cur."!mark_fail"(0)
    lt rx1827_pos, -1, rx1827_done
    eq rx1827_pos, -1, rx1827_fail
    jump $I10
  rx1827_done:
    rx1827_cur."!cursor_fail"()
    if_null rx1827_debug, debug_1351
    rx1827_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1351:
    .return (rx1827_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("356_1303748459.273") :method
.annotate 'line', 10
    $P1829 = self."!PREFIX__!subrule"("O", "&&")
    new $P1830, "ResizablePMCArray"
    push $P1830, $P1829
    .return ($P1830)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("357_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1834_tgt
    .local int rx1834_pos
    .local int rx1834_off
    .local int rx1834_eos
    .local int rx1834_rep
    .local pmc rx1834_cur
    .local pmc rx1834_debug
    (rx1834_cur, rx1834_pos, rx1834_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1834_cur
    .local pmc match
    .lex "$/", match
    length rx1834_eos, rx1834_tgt
    gt rx1834_pos, rx1834_eos, rx1834_done
    set rx1834_off, 0
    lt rx1834_pos, 2, rx1834_start
    sub rx1834_off, rx1834_pos, 1
    substr rx1834_tgt, rx1834_tgt, rx1834_off
  rx1834_start:
    eq $I10, 1, rx1834_restart
    if_null rx1834_debug, debug_1352
    rx1834_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1352:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1838_done
    goto rxscan1838_scan
  rxscan1838_loop:
    (rx1834_pos) = rx1834_cur."from"()
    inc rx1834_pos
    rx1834_cur."!cursor_from"(rx1834_pos)
    ge rx1834_pos, rx1834_eos, rxscan1838_done
  rxscan1838_scan:
    set_addr $I10, rxscan1838_loop
    rx1834_cur."!mark_push"(0, rx1834_pos, $I10)
  rxscan1838_done:
.annotate 'line', 693
  # rx subcapture "sym"
    set_addr $I10, rxcap_1839_fail
    rx1834_cur."!mark_push"(0, rx1834_pos, $I10)
  # rx literal  "||"
    add $I11, rx1834_pos, 2
    gt $I11, rx1834_eos, rx1834_fail
    sub $I11, rx1834_pos, rx1834_off
    substr $S10, rx1834_tgt, $I11, 2
    ne $S10, "||", rx1834_fail
    add rx1834_pos, 2
    set_addr $I10, rxcap_1839_fail
    ($I12, $I11) = rx1834_cur."!mark_peek"($I10)
    rx1834_cur."!cursor_pos"($I11)
    ($P10) = rx1834_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1834_pos, "")
    rx1834_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1839_done
  rxcap_1839_fail:
    goto rx1834_fail
  rxcap_1839_done:
  # rx subrule "O" subtype=capture negate=
    rx1834_cur."!cursor_pos"(rx1834_pos)
    $P10 = rx1834_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1834_fail
    rx1834_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1834_pos = $P10."pos"()
  # rx pass
    rx1834_cur."!cursor_pass"(rx1834_pos, "infix:sym<||>")
    if_null rx1834_debug, debug_1353
    rx1834_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1834_pos)
  debug_1353:
    .return (rx1834_cur)
  rx1834_restart:
.annotate 'line', 10
    if_null rx1834_debug, debug_1354
    rx1834_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1354:
  rx1834_fail:
    (rx1834_rep, rx1834_pos, $I10, $P10) = rx1834_cur."!mark_fail"(0)
    lt rx1834_pos, -1, rx1834_done
    eq rx1834_pos, -1, rx1834_fail
    jump $I10
  rx1834_done:
    rx1834_cur."!cursor_fail"()
    if_null rx1834_debug, debug_1355
    rx1834_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1355:
    .return (rx1834_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("358_1303748459.273") :method
.annotate 'line', 10
    $P1836 = self."!PREFIX__!subrule"("O", "||")
    new $P1837, "ResizablePMCArray"
    push $P1837, $P1836
    .return ($P1837)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("359_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1841_tgt
    .local int rx1841_pos
    .local int rx1841_off
    .local int rx1841_eos
    .local int rx1841_rep
    .local pmc rx1841_cur
    .local pmc rx1841_debug
    (rx1841_cur, rx1841_pos, rx1841_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1841_cur
    .local pmc match
    .lex "$/", match
    length rx1841_eos, rx1841_tgt
    gt rx1841_pos, rx1841_eos, rx1841_done
    set rx1841_off, 0
    lt rx1841_pos, 2, rx1841_start
    sub rx1841_off, rx1841_pos, 1
    substr rx1841_tgt, rx1841_tgt, rx1841_off
  rx1841_start:
    eq $I10, 1, rx1841_restart
    if_null rx1841_debug, debug_1356
    rx1841_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1356:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1845_done
    goto rxscan1845_scan
  rxscan1845_loop:
    (rx1841_pos) = rx1841_cur."from"()
    inc rx1841_pos
    rx1841_cur."!cursor_from"(rx1841_pos)
    ge rx1841_pos, rx1841_eos, rxscan1845_done
  rxscan1845_scan:
    set_addr $I10, rxscan1845_loop
    rx1841_cur."!mark_push"(0, rx1841_pos, $I10)
  rxscan1845_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1846_fail
    rx1841_cur."!mark_push"(0, rx1841_pos, $I10)
  # rx literal  "//"
    add $I11, rx1841_pos, 2
    gt $I11, rx1841_eos, rx1841_fail
    sub $I11, rx1841_pos, rx1841_off
    substr $S10, rx1841_tgt, $I11, 2
    ne $S10, "//", rx1841_fail
    add rx1841_pos, 2
    set_addr $I10, rxcap_1846_fail
    ($I12, $I11) = rx1841_cur."!mark_peek"($I10)
    rx1841_cur."!cursor_pos"($I11)
    ($P10) = rx1841_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1841_pos, "")
    rx1841_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1846_done
  rxcap_1846_fail:
    goto rx1841_fail
  rxcap_1846_done:
  # rx subrule "O" subtype=capture negate=
    rx1841_cur."!cursor_pos"(rx1841_pos)
    $P10 = rx1841_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1841_fail
    rx1841_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1841_pos = $P10."pos"()
  # rx pass
    rx1841_cur."!cursor_pass"(rx1841_pos, "infix:sym<//>")
    if_null rx1841_debug, debug_1357
    rx1841_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1841_pos)
  debug_1357:
    .return (rx1841_cur)
  rx1841_restart:
.annotate 'line', 10
    if_null rx1841_debug, debug_1358
    rx1841_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1358:
  rx1841_fail:
    (rx1841_rep, rx1841_pos, $I10, $P10) = rx1841_cur."!mark_fail"(0)
    lt rx1841_pos, -1, rx1841_done
    eq rx1841_pos, -1, rx1841_fail
    jump $I10
  rx1841_done:
    rx1841_cur."!cursor_fail"()
    if_null rx1841_debug, debug_1359
    rx1841_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1359:
    .return (rx1841_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("360_1303748459.273") :method
.annotate 'line', 10
    $P1843 = self."!PREFIX__!subrule"("O", "//")
    new $P1844, "ResizablePMCArray"
    push $P1844, $P1843
    .return ($P1844)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("361_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1848_tgt
    .local int rx1848_pos
    .local int rx1848_off
    .local int rx1848_eos
    .local int rx1848_rep
    .local pmc rx1848_cur
    .local pmc rx1848_debug
    (rx1848_cur, rx1848_pos, rx1848_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1848_cur
    .local pmc match
    .lex "$/", match
    length rx1848_eos, rx1848_tgt
    gt rx1848_pos, rx1848_eos, rx1848_done
    set rx1848_off, 0
    lt rx1848_pos, 2, rx1848_start
    sub rx1848_off, rx1848_pos, 1
    substr rx1848_tgt, rx1848_tgt, rx1848_off
  rx1848_start:
    eq $I10, 1, rx1848_restart
    if_null rx1848_debug, debug_1360
    rx1848_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1360:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1852_done
    goto rxscan1852_scan
  rxscan1852_loop:
    (rx1848_pos) = rx1848_cur."from"()
    inc rx1848_pos
    rx1848_cur."!cursor_from"(rx1848_pos)
    ge rx1848_pos, rx1848_eos, rxscan1852_done
  rxscan1852_scan:
    set_addr $I10, rxscan1852_loop
    rx1848_cur."!mark_push"(0, rx1848_pos, $I10)
  rxscan1852_done:
.annotate 'line', 697
  # rx literal  "??"
    add $I11, rx1848_pos, 2
    gt $I11, rx1848_eos, rx1848_fail
    sub $I11, rx1848_pos, rx1848_off
    substr $S10, rx1848_tgt, $I11, 2
    ne $S10, "??", rx1848_fail
    add rx1848_pos, 2
.annotate 'line', 698
  # rx subrule "ws" subtype=method negate=
    rx1848_cur."!cursor_pos"(rx1848_pos)
    $P10 = rx1848_cur."ws"()
    unless $P10, rx1848_fail
    rx1848_pos = $P10."pos"()
.annotate 'line', 699
  # rx subrule "EXPR" subtype=capture negate=
    rx1848_cur."!cursor_pos"(rx1848_pos)
    $P10 = rx1848_cur."EXPR"("i=")
    unless $P10, rx1848_fail
    rx1848_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1848_pos = $P10."pos"()
.annotate 'line', 700
  # rx literal  "!!"
    add $I11, rx1848_pos, 2
    gt $I11, rx1848_eos, rx1848_fail
    sub $I11, rx1848_pos, rx1848_off
    substr $S10, rx1848_tgt, $I11, 2
    ne $S10, "!!", rx1848_fail
    add rx1848_pos, 2
.annotate 'line', 701
  # rx subrule "O" subtype=capture negate=
    rx1848_cur."!cursor_pos"(rx1848_pos)
    $P10 = rx1848_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1848_fail
    rx1848_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1848_pos = $P10."pos"()
.annotate 'line', 696
  # rx pass
    rx1848_cur."!cursor_pass"(rx1848_pos, "infix:sym<?? !!>")
    if_null rx1848_debug, debug_1361
    rx1848_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1848_pos)
  debug_1361:
    .return (rx1848_cur)
  rx1848_restart:
.annotate 'line', 10
    if_null rx1848_debug, debug_1362
    rx1848_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1362:
  rx1848_fail:
    (rx1848_rep, rx1848_pos, $I10, $P10) = rx1848_cur."!mark_fail"(0)
    lt rx1848_pos, -1, rx1848_done
    eq rx1848_pos, -1, rx1848_fail
    jump $I10
  rx1848_done:
    rx1848_cur."!cursor_fail"()
    if_null rx1848_debug, debug_1363
    rx1848_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1363:
    .return (rx1848_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("362_1303748459.273") :method
.annotate 'line', 10
    $P1850 = self."!PREFIX__!subrule"("ws", "??")
    new $P1851, "ResizablePMCArray"
    push $P1851, $P1850
    .return ($P1851)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("363_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1854_tgt
    .local int rx1854_pos
    .local int rx1854_off
    .local int rx1854_eos
    .local int rx1854_rep
    .local pmc rx1854_cur
    .local pmc rx1854_debug
    (rx1854_cur, rx1854_pos, rx1854_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1854_cur
    .local pmc match
    .lex "$/", match
    length rx1854_eos, rx1854_tgt
    gt rx1854_pos, rx1854_eos, rx1854_done
    set rx1854_off, 0
    lt rx1854_pos, 2, rx1854_start
    sub rx1854_off, rx1854_pos, 1
    substr rx1854_tgt, rx1854_tgt, rx1854_off
  rx1854_start:
    eq $I10, 1, rx1854_restart
    if_null rx1854_debug, debug_1364
    rx1854_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1364:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1858_done
    goto rxscan1858_scan
  rxscan1858_loop:
    (rx1854_pos) = rx1854_cur."from"()
    inc rx1854_pos
    rx1854_cur."!cursor_from"(rx1854_pos)
    ge rx1854_pos, rx1854_eos, rxscan1858_done
  rxscan1858_scan:
    set_addr $I10, rxscan1858_loop
    rx1854_cur."!mark_push"(0, rx1854_pos, $I10)
  rxscan1858_done:
.annotate 'line', 705
  # rx subcapture "sym"
    set_addr $I10, rxcap_1859_fail
    rx1854_cur."!mark_push"(0, rx1854_pos, $I10)
  # rx literal  "="
    add $I11, rx1854_pos, 1
    gt $I11, rx1854_eos, rx1854_fail
    sub $I11, rx1854_pos, rx1854_off
    ord $I11, rx1854_tgt, $I11
    ne $I11, 61, rx1854_fail
    add rx1854_pos, 1
    set_addr $I10, rxcap_1859_fail
    ($I12, $I11) = rx1854_cur."!mark_peek"($I10)
    rx1854_cur."!cursor_pos"($I11)
    ($P10) = rx1854_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1854_pos, "")
    rx1854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1859_done
  rxcap_1859_fail:
    goto rx1854_fail
  rxcap_1859_done:
  # rx subrule "panic" subtype=method negate=
    rx1854_cur."!cursor_pos"(rx1854_pos)
    $P10 = rx1854_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1854_fail
    rx1854_pos = $P10."pos"()
.annotate 'line', 704
  # rx pass
    rx1854_cur."!cursor_pass"(rx1854_pos, "infix:sym<=>")
    if_null rx1854_debug, debug_1365
    rx1854_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1854_pos)
  debug_1365:
    .return (rx1854_cur)
  rx1854_restart:
.annotate 'line', 10
    if_null rx1854_debug, debug_1366
    rx1854_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1366:
  rx1854_fail:
    (rx1854_rep, rx1854_pos, $I10, $P10) = rx1854_cur."!mark_fail"(0)
    lt rx1854_pos, -1, rx1854_done
    eq rx1854_pos, -1, rx1854_fail
    jump $I10
  rx1854_done:
    rx1854_cur."!cursor_fail"()
    if_null rx1854_debug, debug_1367
    rx1854_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1367:
    .return (rx1854_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("364_1303748459.273") :method
.annotate 'line', 10
    $P1856 = self."!PREFIX__!subrule"("panic", "=")
    new $P1857, "ResizablePMCArray"
    push $P1857, $P1856
    .return ($P1857)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("365_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1861_tgt
    .local int rx1861_pos
    .local int rx1861_off
    .local int rx1861_eos
    .local int rx1861_rep
    .local pmc rx1861_cur
    .local pmc rx1861_debug
    (rx1861_cur, rx1861_pos, rx1861_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1861_cur
    .local pmc match
    .lex "$/", match
    length rx1861_eos, rx1861_tgt
    gt rx1861_pos, rx1861_eos, rx1861_done
    set rx1861_off, 0
    lt rx1861_pos, 2, rx1861_start
    sub rx1861_off, rx1861_pos, 1
    substr rx1861_tgt, rx1861_tgt, rx1861_off
  rx1861_start:
    eq $I10, 1, rx1861_restart
    if_null rx1861_debug, debug_1368
    rx1861_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1368:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1865_done
    goto rxscan1865_scan
  rxscan1865_loop:
    (rx1861_pos) = rx1861_cur."from"()
    inc rx1861_pos
    rx1861_cur."!cursor_from"(rx1861_pos)
    ge rx1861_pos, rx1861_eos, rxscan1865_done
  rxscan1865_scan:
    set_addr $I10, rxscan1865_loop
    rx1861_cur."!mark_push"(0, rx1861_pos, $I10)
  rxscan1865_done:
.annotate 'line', 707
  # rx subcapture "sym"
    set_addr $I10, rxcap_1866_fail
    rx1861_cur."!mark_push"(0, rx1861_pos, $I10)
  # rx literal  ":="
    add $I11, rx1861_pos, 2
    gt $I11, rx1861_eos, rx1861_fail
    sub $I11, rx1861_pos, rx1861_off
    substr $S10, rx1861_tgt, $I11, 2
    ne $S10, ":=", rx1861_fail
    add rx1861_pos, 2
    set_addr $I10, rxcap_1866_fail
    ($I12, $I11) = rx1861_cur."!mark_peek"($I10)
    rx1861_cur."!cursor_pos"($I11)
    ($P10) = rx1861_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1861_pos, "")
    rx1861_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1866_done
  rxcap_1866_fail:
    goto rx1861_fail
  rxcap_1866_done:
  # rx subrule "O" subtype=capture negate=
    rx1861_cur."!cursor_pos"(rx1861_pos)
    $P10 = rx1861_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1861_fail
    rx1861_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1861_pos = $P10."pos"()
  # rx pass
    rx1861_cur."!cursor_pass"(rx1861_pos, "infix:sym<:=>")
    if_null rx1861_debug, debug_1369
    rx1861_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1861_pos)
  debug_1369:
    .return (rx1861_cur)
  rx1861_restart:
.annotate 'line', 10
    if_null rx1861_debug, debug_1370
    rx1861_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1370:
  rx1861_fail:
    (rx1861_rep, rx1861_pos, $I10, $P10) = rx1861_cur."!mark_fail"(0)
    lt rx1861_pos, -1, rx1861_done
    eq rx1861_pos, -1, rx1861_fail
    jump $I10
  rx1861_done:
    rx1861_cur."!cursor_fail"()
    if_null rx1861_debug, debug_1371
    rx1861_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1371:
    .return (rx1861_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("366_1303748459.273") :method
.annotate 'line', 10
    $P1863 = self."!PREFIX__!subrule"("O", ":=")
    new $P1864, "ResizablePMCArray"
    push $P1864, $P1863
    .return ($P1864)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("367_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1868_tgt
    .local int rx1868_pos
    .local int rx1868_off
    .local int rx1868_eos
    .local int rx1868_rep
    .local pmc rx1868_cur
    .local pmc rx1868_debug
    (rx1868_cur, rx1868_pos, rx1868_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1868_cur
    .local pmc match
    .lex "$/", match
    length rx1868_eos, rx1868_tgt
    gt rx1868_pos, rx1868_eos, rx1868_done
    set rx1868_off, 0
    lt rx1868_pos, 2, rx1868_start
    sub rx1868_off, rx1868_pos, 1
    substr rx1868_tgt, rx1868_tgt, rx1868_off
  rx1868_start:
    eq $I10, 1, rx1868_restart
    if_null rx1868_debug, debug_1372
    rx1868_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1372:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1872_done
    goto rxscan1872_scan
  rxscan1872_loop:
    (rx1868_pos) = rx1868_cur."from"()
    inc rx1868_pos
    rx1868_cur."!cursor_from"(rx1868_pos)
    ge rx1868_pos, rx1868_eos, rxscan1872_done
  rxscan1872_scan:
    set_addr $I10, rxscan1872_loop
    rx1868_cur."!mark_push"(0, rx1868_pos, $I10)
  rxscan1872_done:
.annotate 'line', 708
  # rx subcapture "sym"
    set_addr $I10, rxcap_1873_fail
    rx1868_cur."!mark_push"(0, rx1868_pos, $I10)
  # rx literal  "::="
    add $I11, rx1868_pos, 3
    gt $I11, rx1868_eos, rx1868_fail
    sub $I11, rx1868_pos, rx1868_off
    substr $S10, rx1868_tgt, $I11, 3
    ne $S10, "::=", rx1868_fail
    add rx1868_pos, 3
    set_addr $I10, rxcap_1873_fail
    ($I12, $I11) = rx1868_cur."!mark_peek"($I10)
    rx1868_cur."!cursor_pos"($I11)
    ($P10) = rx1868_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1868_pos, "")
    rx1868_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1873_done
  rxcap_1873_fail:
    goto rx1868_fail
  rxcap_1873_done:
  # rx subrule "O" subtype=capture negate=
    rx1868_cur."!cursor_pos"(rx1868_pos)
    $P10 = rx1868_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1868_fail
    rx1868_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1868_pos = $P10."pos"()
  # rx pass
    rx1868_cur."!cursor_pass"(rx1868_pos, "infix:sym<::=>")
    if_null rx1868_debug, debug_1373
    rx1868_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1868_pos)
  debug_1373:
    .return (rx1868_cur)
  rx1868_restart:
.annotate 'line', 10
    if_null rx1868_debug, debug_1374
    rx1868_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1374:
  rx1868_fail:
    (rx1868_rep, rx1868_pos, $I10, $P10) = rx1868_cur."!mark_fail"(0)
    lt rx1868_pos, -1, rx1868_done
    eq rx1868_pos, -1, rx1868_fail
    jump $I10
  rx1868_done:
    rx1868_cur."!cursor_fail"()
    if_null rx1868_debug, debug_1375
    rx1868_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1375:
    .return (rx1868_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("368_1303748459.273") :method
.annotate 'line', 10
    $P1870 = self."!PREFIX__!subrule"("O", "::=")
    new $P1871, "ResizablePMCArray"
    push $P1871, $P1870
    .return ($P1871)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("369_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1875_tgt
    .local int rx1875_pos
    .local int rx1875_off
    .local int rx1875_eos
    .local int rx1875_rep
    .local pmc rx1875_cur
    .local pmc rx1875_debug
    (rx1875_cur, rx1875_pos, rx1875_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1875_cur
    .local pmc match
    .lex "$/", match
    length rx1875_eos, rx1875_tgt
    gt rx1875_pos, rx1875_eos, rx1875_done
    set rx1875_off, 0
    lt rx1875_pos, 2, rx1875_start
    sub rx1875_off, rx1875_pos, 1
    substr rx1875_tgt, rx1875_tgt, rx1875_off
  rx1875_start:
    eq $I10, 1, rx1875_restart
    if_null rx1875_debug, debug_1376
    rx1875_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1376:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1879_done
    goto rxscan1879_scan
  rxscan1879_loop:
    (rx1875_pos) = rx1875_cur."from"()
    inc rx1875_pos
    rx1875_cur."!cursor_from"(rx1875_pos)
    ge rx1875_pos, rx1875_eos, rxscan1879_done
  rxscan1879_scan:
    set_addr $I10, rxscan1879_loop
    rx1875_cur."!mark_push"(0, rx1875_pos, $I10)
  rxscan1879_done:
.annotate 'line', 710
  # rx subcapture "sym"
    set_addr $I10, rxcap_1880_fail
    rx1875_cur."!mark_push"(0, rx1875_pos, $I10)
  # rx literal  ","
    add $I11, rx1875_pos, 1
    gt $I11, rx1875_eos, rx1875_fail
    sub $I11, rx1875_pos, rx1875_off
    ord $I11, rx1875_tgt, $I11
    ne $I11, 44, rx1875_fail
    add rx1875_pos, 1
    set_addr $I10, rxcap_1880_fail
    ($I12, $I11) = rx1875_cur."!mark_peek"($I10)
    rx1875_cur."!cursor_pos"($I11)
    ($P10) = rx1875_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1875_pos, "")
    rx1875_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1880_done
  rxcap_1880_fail:
    goto rx1875_fail
  rxcap_1880_done:
  # rx subrule "O" subtype=capture negate=
    rx1875_cur."!cursor_pos"(rx1875_pos)
    $P10 = rx1875_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1875_fail
    rx1875_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1875_pos = $P10."pos"()
  # rx pass
    rx1875_cur."!cursor_pass"(rx1875_pos, "infix:sym<,>")
    if_null rx1875_debug, debug_1377
    rx1875_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1875_pos)
  debug_1377:
    .return (rx1875_cur)
  rx1875_restart:
.annotate 'line', 10
    if_null rx1875_debug, debug_1378
    rx1875_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1378:
  rx1875_fail:
    (rx1875_rep, rx1875_pos, $I10, $P10) = rx1875_cur."!mark_fail"(0)
    lt rx1875_pos, -1, rx1875_done
    eq rx1875_pos, -1, rx1875_fail
    jump $I10
  rx1875_done:
    rx1875_cur."!cursor_fail"()
    if_null rx1875_debug, debug_1379
    rx1875_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1379:
    .return (rx1875_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("370_1303748459.273") :method
.annotate 'line', 10
    $P1877 = self."!PREFIX__!subrule"("O", ",")
    new $P1878, "ResizablePMCArray"
    push $P1878, $P1877
    .return ($P1878)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("371_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .const 'Sub' $P1890 = "373_1303748459.273" 
    capture_lex $P1890
    .local string rx1882_tgt
    .local int rx1882_pos
    .local int rx1882_off
    .local int rx1882_eos
    .local int rx1882_rep
    .local pmc rx1882_cur
    .local pmc rx1882_debug
    (rx1882_cur, rx1882_pos, rx1882_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1882_cur
    .local pmc match
    .lex "$/", match
    length rx1882_eos, rx1882_tgt
    gt rx1882_pos, rx1882_eos, rx1882_done
    set rx1882_off, 0
    lt rx1882_pos, 2, rx1882_start
    sub rx1882_off, rx1882_pos, 1
    substr rx1882_tgt, rx1882_tgt, rx1882_off
  rx1882_start:
    eq $I10, 1, rx1882_restart
    if_null rx1882_debug, debug_1380
    rx1882_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1380:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1885_done
    goto rxscan1885_scan
  rxscan1885_loop:
    (rx1882_pos) = rx1882_cur."from"()
    inc rx1882_pos
    rx1882_cur."!cursor_from"(rx1882_pos)
    ge rx1882_pos, rx1882_eos, rxscan1885_done
  rxscan1885_scan:
    set_addr $I10, rxscan1885_loop
    rx1882_cur."!mark_push"(0, rx1882_pos, $I10)
  rxscan1885_done:
.annotate 'line', 712
  # rx subcapture "sym"
    set_addr $I10, rxcap_1886_fail
    rx1882_cur."!mark_push"(0, rx1882_pos, $I10)
  # rx literal  "return"
    add $I11, rx1882_pos, 6
    gt $I11, rx1882_eos, rx1882_fail
    sub $I11, rx1882_pos, rx1882_off
    substr $S10, rx1882_tgt, $I11, 6
    ne $S10, "return", rx1882_fail
    add rx1882_pos, 6
    set_addr $I10, rxcap_1886_fail
    ($I12, $I11) = rx1882_cur."!mark_peek"($I10)
    rx1882_cur."!cursor_pos"($I11)
    ($P10) = rx1882_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1882_pos, "")
    rx1882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1886_done
  rxcap_1886_fail:
    goto rx1882_fail
  rxcap_1886_done:
  # rx charclass s
    ge rx1882_pos, rx1882_eos, rx1882_fail
    sub $I10, rx1882_pos, rx1882_off
    is_cclass $I11, 32, rx1882_tgt, $I10
    unless $I11, rx1882_fail
    inc rx1882_pos
  # rx subrule "O" subtype=capture negate=
    rx1882_cur."!cursor_pos"(rx1882_pos)
    $P10 = rx1882_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1882_fail
    rx1882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1882_pos = $P10."pos"()
    rx1882_cur."!cursor_pos"(rx1882_pos)
    find_lex $P1887, unicode:"$\x{a2}"
    $P1888 = $P1887."MATCH"()
    store_lex "$/", $P1888
    .const 'Sub' $P1890 = "373_1303748459.273" 
    capture_lex $P1890
    $P1892 = $P1890()
  # rx pass
    rx1882_cur."!cursor_pass"(rx1882_pos, "prefix:sym<return>")
    if_null rx1882_debug, debug_1381
    rx1882_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1882_pos)
  debug_1381:
    .return (rx1882_cur)
  rx1882_restart:
.annotate 'line', 10
    if_null rx1882_debug, debug_1382
    rx1882_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1382:
  rx1882_fail:
    (rx1882_rep, rx1882_pos, $I10, $P10) = rx1882_cur."!mark_fail"(0)
    lt rx1882_pos, -1, rx1882_done
    eq rx1882_pos, -1, rx1882_fail
    jump $I10
  rx1882_done:
    rx1882_cur."!cursor_fail"()
    if_null rx1882_debug, debug_1383
    rx1882_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1383:
    .return (rx1882_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("372_1303748459.273") :method
.annotate 'line', 10
    new $P1884, "ResizablePMCArray"
    push $P1884, "return"
    .return ($P1884)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1889"  :anon :subid("373_1303748459.273") :outer("371_1303748459.273")
.annotate 'line', 712
    new $P1891, "Integer"
    assign $P1891, 1
    store_dynamic_lex "$*RETURN_USED", $P1891
    .return ($P1891)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("374_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1894_tgt
    .local int rx1894_pos
    .local int rx1894_off
    .local int rx1894_eos
    .local int rx1894_rep
    .local pmc rx1894_cur
    .local pmc rx1894_debug
    (rx1894_cur, rx1894_pos, rx1894_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1894_cur
    .local pmc match
    .lex "$/", match
    length rx1894_eos, rx1894_tgt
    gt rx1894_pos, rx1894_eos, rx1894_done
    set rx1894_off, 0
    lt rx1894_pos, 2, rx1894_start
    sub rx1894_off, rx1894_pos, 1
    substr rx1894_tgt, rx1894_tgt, rx1894_off
  rx1894_start:
    eq $I10, 1, rx1894_restart
    if_null rx1894_debug, debug_1384
    rx1894_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1384:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1897_done
    goto rxscan1897_scan
  rxscan1897_loop:
    (rx1894_pos) = rx1894_cur."from"()
    inc rx1894_pos
    rx1894_cur."!cursor_from"(rx1894_pos)
    ge rx1894_pos, rx1894_eos, rxscan1897_done
  rxscan1897_scan:
    set_addr $I10, rxscan1897_loop
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  rxscan1897_done:
.annotate 'line', 713
  # rx subcapture "sym"
    set_addr $I10, rxcap_1898_fail
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  # rx literal  "make"
    add $I11, rx1894_pos, 4
    gt $I11, rx1894_eos, rx1894_fail
    sub $I11, rx1894_pos, rx1894_off
    substr $S10, rx1894_tgt, $I11, 4
    ne $S10, "make", rx1894_fail
    add rx1894_pos, 4
    set_addr $I10, rxcap_1898_fail
    ($I12, $I11) = rx1894_cur."!mark_peek"($I10)
    rx1894_cur."!cursor_pos"($I11)
    ($P10) = rx1894_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1894_pos, "")
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1898_done
  rxcap_1898_fail:
    goto rx1894_fail
  rxcap_1898_done:
  # rx charclass s
    ge rx1894_pos, rx1894_eos, rx1894_fail
    sub $I10, rx1894_pos, rx1894_off
    is_cclass $I11, 32, rx1894_tgt, $I10
    unless $I11, rx1894_fail
    inc rx1894_pos
  # rx subrule "O" subtype=capture negate=
    rx1894_cur."!cursor_pos"(rx1894_pos)
    $P10 = rx1894_cur."O"("%list_prefix")
    unless $P10, rx1894_fail
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1894_pos = $P10."pos"()
  # rx pass
    rx1894_cur."!cursor_pass"(rx1894_pos, "prefix:sym<make>")
    if_null rx1894_debug, debug_1385
    rx1894_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1894_pos)
  debug_1385:
    .return (rx1894_cur)
  rx1894_restart:
.annotate 'line', 10
    if_null rx1894_debug, debug_1386
    rx1894_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1386:
  rx1894_fail:
    (rx1894_rep, rx1894_pos, $I10, $P10) = rx1894_cur."!mark_fail"(0)
    lt rx1894_pos, -1, rx1894_done
    eq rx1894_pos, -1, rx1894_fail
    jump $I10
  rx1894_done:
    rx1894_cur."!cursor_fail"()
    if_null rx1894_debug, debug_1387
    rx1894_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1387:
    .return (rx1894_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("375_1303748459.273") :method
.annotate 'line', 10
    new $P1896, "ResizablePMCArray"
    push $P1896, "make"
    .return ($P1896)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("376_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1900_tgt
    .local int rx1900_pos
    .local int rx1900_off
    .local int rx1900_eos
    .local int rx1900_rep
    .local pmc rx1900_cur
    .local pmc rx1900_debug
    (rx1900_cur, rx1900_pos, rx1900_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1900_cur
    .local pmc match
    .lex "$/", match
    length rx1900_eos, rx1900_tgt
    gt rx1900_pos, rx1900_eos, rx1900_done
    set rx1900_off, 0
    lt rx1900_pos, 2, rx1900_start
    sub rx1900_off, rx1900_pos, 1
    substr rx1900_tgt, rx1900_tgt, rx1900_off
  rx1900_start:
    eq $I10, 1, rx1900_restart
    if_null rx1900_debug, debug_1388
    rx1900_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1388:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1903_done
    goto rxscan1903_scan
  rxscan1903_loop:
    (rx1900_pos) = rx1900_cur."from"()
    inc rx1900_pos
    rx1900_cur."!cursor_from"(rx1900_pos)
    ge rx1900_pos, rx1900_eos, rxscan1903_done
  rxscan1903_scan:
    set_addr $I10, rxscan1903_loop
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  rxscan1903_done:
.annotate 'line', 714
  # rx subcapture "sym"
    set_addr $I10, rxcap_1904_fail
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  # rx literal  "last"
    add $I11, rx1900_pos, 4
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 4
    ne $S10, "last", rx1900_fail
    add rx1900_pos, 4
    set_addr $I10, rxcap_1904_fail
    ($I12, $I11) = rx1900_cur."!mark_peek"($I10)
    rx1900_cur."!cursor_pos"($I11)
    ($P10) = rx1900_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1900_pos, "")
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1904_done
  rxcap_1904_fail:
    goto rx1900_fail
  rxcap_1904_done:
  # rx pass
    rx1900_cur."!cursor_pass"(rx1900_pos, "term:sym<last>")
    if_null rx1900_debug, debug_1389
    rx1900_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1900_pos)
  debug_1389:
    .return (rx1900_cur)
  rx1900_restart:
.annotate 'line', 10
    if_null rx1900_debug, debug_1390
    rx1900_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1390:
  rx1900_fail:
    (rx1900_rep, rx1900_pos, $I10, $P10) = rx1900_cur."!mark_fail"(0)
    lt rx1900_pos, -1, rx1900_done
    eq rx1900_pos, -1, rx1900_fail
    jump $I10
  rx1900_done:
    rx1900_cur."!cursor_fail"()
    if_null rx1900_debug, debug_1391
    rx1900_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1391:
    .return (rx1900_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("377_1303748459.273") :method
.annotate 'line', 10
    new $P1902, "ResizablePMCArray"
    push $P1902, "last"
    .return ($P1902)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("378_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1906_tgt
    .local int rx1906_pos
    .local int rx1906_off
    .local int rx1906_eos
    .local int rx1906_rep
    .local pmc rx1906_cur
    .local pmc rx1906_debug
    (rx1906_cur, rx1906_pos, rx1906_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1906_cur
    .local pmc match
    .lex "$/", match
    length rx1906_eos, rx1906_tgt
    gt rx1906_pos, rx1906_eos, rx1906_done
    set rx1906_off, 0
    lt rx1906_pos, 2, rx1906_start
    sub rx1906_off, rx1906_pos, 1
    substr rx1906_tgt, rx1906_tgt, rx1906_off
  rx1906_start:
    eq $I10, 1, rx1906_restart
    if_null rx1906_debug, debug_1392
    rx1906_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1392:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1909_done
    goto rxscan1909_scan
  rxscan1909_loop:
    (rx1906_pos) = rx1906_cur."from"()
    inc rx1906_pos
    rx1906_cur."!cursor_from"(rx1906_pos)
    ge rx1906_pos, rx1906_eos, rxscan1909_done
  rxscan1909_scan:
    set_addr $I10, rxscan1909_loop
    rx1906_cur."!mark_push"(0, rx1906_pos, $I10)
  rxscan1909_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1910_fail
    rx1906_cur."!mark_push"(0, rx1906_pos, $I10)
  # rx literal  "next"
    add $I11, rx1906_pos, 4
    gt $I11, rx1906_eos, rx1906_fail
    sub $I11, rx1906_pos, rx1906_off
    substr $S10, rx1906_tgt, $I11, 4
    ne $S10, "next", rx1906_fail
    add rx1906_pos, 4
    set_addr $I10, rxcap_1910_fail
    ($I12, $I11) = rx1906_cur."!mark_peek"($I10)
    rx1906_cur."!cursor_pos"($I11)
    ($P10) = rx1906_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1906_pos, "")
    rx1906_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1910_done
  rxcap_1910_fail:
    goto rx1906_fail
  rxcap_1910_done:
  # rx pass
    rx1906_cur."!cursor_pass"(rx1906_pos, "term:sym<next>")
    if_null rx1906_debug, debug_1393
    rx1906_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1906_pos)
  debug_1393:
    .return (rx1906_cur)
  rx1906_restart:
.annotate 'line', 10
    if_null rx1906_debug, debug_1394
    rx1906_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1394:
  rx1906_fail:
    (rx1906_rep, rx1906_pos, $I10, $P10) = rx1906_cur."!mark_fail"(0)
    lt rx1906_pos, -1, rx1906_done
    eq rx1906_pos, -1, rx1906_fail
    jump $I10
  rx1906_done:
    rx1906_cur."!cursor_fail"()
    if_null rx1906_debug, debug_1395
    rx1906_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1395:
    .return (rx1906_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("379_1303748459.273") :method
.annotate 'line', 10
    new $P1908, "ResizablePMCArray"
    push $P1908, "next"
    .return ($P1908)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("380_1303748459.273") :method :outer("12_1303748459.273")
.annotate 'line', 10
    .local string rx1912_tgt
    .local int rx1912_pos
    .local int rx1912_off
    .local int rx1912_eos
    .local int rx1912_rep
    .local pmc rx1912_cur
    .local pmc rx1912_debug
    (rx1912_cur, rx1912_pos, rx1912_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1912_cur
    .local pmc match
    .lex "$/", match
    length rx1912_eos, rx1912_tgt
    gt rx1912_pos, rx1912_eos, rx1912_done
    set rx1912_off, 0
    lt rx1912_pos, 2, rx1912_start
    sub rx1912_off, rx1912_pos, 1
    substr rx1912_tgt, rx1912_tgt, rx1912_off
  rx1912_start:
    eq $I10, 1, rx1912_restart
    if_null rx1912_debug, debug_1396
    rx1912_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1396:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1915_done
    goto rxscan1915_scan
  rxscan1915_loop:
    (rx1912_pos) = rx1912_cur."from"()
    inc rx1912_pos
    rx1912_cur."!cursor_from"(rx1912_pos)
    ge rx1912_pos, rx1912_eos, rxscan1915_done
  rxscan1915_scan:
    set_addr $I10, rxscan1915_loop
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  rxscan1915_done:
.annotate 'line', 716
  # rx subcapture "sym"
    set_addr $I10, rxcap_1916_fail
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1912_pos, 4
    gt $I11, rx1912_eos, rx1912_fail
    sub $I11, rx1912_pos, rx1912_off
    substr $S10, rx1912_tgt, $I11, 4
    ne $S10, "redo", rx1912_fail
    add rx1912_pos, 4
    set_addr $I10, rxcap_1916_fail
    ($I12, $I11) = rx1912_cur."!mark_peek"($I10)
    rx1912_cur."!cursor_pos"($I11)
    ($P10) = rx1912_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1912_pos, "")
    rx1912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1916_done
  rxcap_1916_fail:
    goto rx1912_fail
  rxcap_1916_done:
  # rx pass
    rx1912_cur."!cursor_pass"(rx1912_pos, "term:sym<redo>")
    if_null rx1912_debug, debug_1397
    rx1912_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1912_pos)
  debug_1397:
    .return (rx1912_cur)
  rx1912_restart:
.annotate 'line', 10
    if_null rx1912_debug, debug_1398
    rx1912_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1398:
  rx1912_fail:
    (rx1912_rep, rx1912_pos, $I10, $P10) = rx1912_cur."!mark_fail"(0)
    lt rx1912_pos, -1, rx1912_done
    eq rx1912_pos, -1, rx1912_fail
    jump $I10
  rx1912_done:
    rx1912_cur."!cursor_fail"()
    if_null rx1912_debug, debug_1399
    rx1912_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1399:
    .return (rx1912_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("381_1303748459.273") :method
.annotate 'line', 10
    new $P1914, "ResizablePMCArray"
    push $P1914, "redo"
    .return ($P1914)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("382_1303748459.273") :outer("12_1303748459.273")
    .param pmc param_1918
    .param pmc param_1919
.annotate 'line', 718
    .lex "self", param_1918
    .lex "$/", param_1919
.annotate 'line', 720
    new $P1920, "Undef"
    .lex "$t", $P1920
    find_lex $P1921, "$/"
    unless_null $P1921, vivify_1400
    $P1921 = root_new ['parrot';'ResizablePMCArray']
  vivify_1400:
    set $P1922, $P1921[0]
    unless_null $P1922, vivify_1401
    new $P1922, "Undef"
  vivify_1401:
    store_lex "$t", $P1922
    find_lex $P1923, "$/"
    unless_null $P1923, vivify_1402
    $P1923 = root_new ['parrot';'ResizablePMCArray']
  vivify_1402:
    set $P1924, $P1923[1]
    unless_null $P1924, vivify_1403
    new $P1924, "Undef"
  vivify_1403:
    find_lex $P1925, "$/"
    unless_null $P1925, vivify_1404
    $P1925 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1925
  vivify_1404:
    set $P1925[0], $P1924
    find_lex $P1926, "$t"
    unless_null $P1926, vivify_1405
    new $P1926, "Undef"
  vivify_1405:
    find_lex $P1927, "$/"
    unless_null $P1927, vivify_1406
    $P1927 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1927
  vivify_1406:
    set $P1927[1], $P1926
.annotate 'line', 718
    .return ($P1926)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2650"  :subid("384_1303748459.273") :outer("10_1303748459.273")
.annotate 'line', 724
    .const 'Sub' $P2716 = "405_1303748459.273" 
    capture_lex $P2716
    .const 'Sub' $P2709 = "403_1303748459.273" 
    capture_lex $P2709
    .const 'Sub' $P2704 = "401_1303748459.273" 
    capture_lex $P2704
    .const 'Sub' $P2692 = "398_1303748459.273" 
    capture_lex $P2692
    .const 'Sub' $P2682 = "395_1303748459.273" 
    capture_lex $P2682
    .const 'Sub' $P2677 = "393_1303748459.273" 
    capture_lex $P2677
    .const 'Sub' $P2668 = "390_1303748459.273" 
    capture_lex $P2668
    .const 'Sub' $P2663 = "388_1303748459.273" 
    capture_lex $P2663
    .const 'Sub' $P2654 = "385_1303748459.273" 
    capture_lex $P2654
    .lex "$?PACKAGE", $P2652
    .lex "$?CLASS", $P2653
    .const 'Sub' $P2709 = "403_1303748459.273" 
    capture_lex $P2709
    .return ($P2709)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1407") :outer("384_1303748459.273")
.annotate 'line', 724
    .const 'Sub' $P2651 = "384_1303748459.273" 
    .local pmc block
    set block, $P2651
    .const 'Sub' $P2716 = "405_1303748459.273" 
    capture_lex $P2716
    $P2716()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2715"  :anon :subid("405_1303748459.273") :outer("384_1303748459.273")
.annotate 'line', 724
    nqp_get_sc_object $P2717, "1303748446.727", 2
    .local pmc type_obj
    set type_obj, $P2717
    get_how $P2718, type_obj
    .const 'Sub' $P2719 = "385_1303748459.273" 
    $P2718."add_method"(type_obj, "metachar:sym<:my>", $P2719)
    get_how $P2720, type_obj
    get_global $P2721, "!PREFIX__metachar:sym<:my>"
    $P2720."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2721)
    get_how $P2722, type_obj
    .const 'Sub' $P2723 = "388_1303748459.273" 
    $P2722."add_method"(type_obj, "metachar:sym<{ }>", $P2723)
    get_how $P2724, type_obj
    get_global $P2725, "!PREFIX__metachar:sym<{ }>"
    $P2724."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2725)
    get_how $P2726, type_obj
    .const 'Sub' $P2727 = "390_1303748459.273" 
    $P2726."add_method"(type_obj, "metachar:sym<nqpvar>", $P2727)
    get_how $P2728, type_obj
    get_global $P2729, "!PREFIX__metachar:sym<nqpvar>"
    $P2728."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2729)
    get_how $P2730, type_obj
    .const 'Sub' $P2731 = "393_1303748459.273" 
    $P2730."add_method"(type_obj, "assertion:sym<{ }>", $P2731)
    get_how $P2732, type_obj
    get_global $P2733, "!PREFIX__assertion:sym<{ }>"
    $P2732."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2733)
    get_how $P2734, type_obj
    .const 'Sub' $P2735 = "395_1303748459.273" 
    $P2734."add_method"(type_obj, "assertion:sym<?{ }>", $P2735)
    get_how $P2736, type_obj
    get_global $P2737, "!PREFIX__assertion:sym<?{ }>"
    $P2736."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2737)
    get_how $P2738, type_obj
    .const 'Sub' $P2739 = "398_1303748459.273" 
    $P2738."add_method"(type_obj, "assertion:sym<name>", $P2739)
    get_how $P2740, type_obj
    get_global $P2741, "!PREFIX__assertion:sym<name>"
    $P2740."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2741)
    get_how $P2742, type_obj
    .const 'Sub' $P2743 = "401_1303748459.273" 
    $P2742."add_method"(type_obj, "assertion:sym<var>", $P2743)
    get_how $P2744, type_obj
    get_global $P2745, "!PREFIX__assertion:sym<var>"
    $P2744."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2745)
    get_how $P2746, type_obj
    .const 'Sub' $P2747 = "403_1303748459.273" 
    $P2746."add_method"(type_obj, "codeblock", $P2747)
    get_how $P2748, type_obj
    get_global $P2749, "!PREFIX__codeblock"
    $P2748."add_method"(type_obj, "!PREFIX__codeblock", $P2749)
    get_how $P2750, type_obj
    $P2751 = $P2750."compose"(type_obj)
    .return ($P2751)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("385_1303748459.273") :method :outer("384_1303748459.273")
.annotate 'line', 724
    .const 'Sub' $P2660 = "387_1303748459.273" 
    capture_lex $P2660
    .local string rx2655_tgt
    .local int rx2655_pos
    .local int rx2655_off
    .local int rx2655_eos
    .local int rx2655_rep
    .local pmc rx2655_cur
    .local pmc rx2655_debug
    (rx2655_cur, rx2655_pos, rx2655_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2655_cur
    .local pmc match
    .lex "$/", match
    length rx2655_eos, rx2655_tgt
    gt rx2655_pos, rx2655_eos, rx2655_done
    set rx2655_off, 0
    lt rx2655_pos, 2, rx2655_start
    sub rx2655_off, rx2655_pos, 1
    substr rx2655_tgt, rx2655_tgt, rx2655_off
  rx2655_start:
    eq $I10, 1, rx2655_restart
    if_null rx2655_debug, debug_1408
    rx2655_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1408:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2658_done
    goto rxscan2658_scan
  rxscan2658_loop:
    (rx2655_pos) = rx2655_cur."from"()
    inc rx2655_pos
    rx2655_cur."!cursor_from"(rx2655_pos)
    ge rx2655_pos, rx2655_eos, rxscan2658_done
  rxscan2658_scan:
    set_addr $I10, rxscan2658_loop
    rx2655_cur."!mark_push"(0, rx2655_pos, $I10)
  rxscan2658_done:
.annotate 'line', 726
  # rx literal  ":"
    add $I11, rx2655_pos, 1
    gt $I11, rx2655_eos, rx2655_fail
    sub $I11, rx2655_pos, rx2655_off
    ord $I11, rx2655_tgt, $I11
    ne $I11, 58, rx2655_fail
    add rx2655_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2655_cur."!cursor_pos"(rx2655_pos)
    .const 'Sub' $P2660 = "387_1303748459.273" 
    capture_lex $P2660
    $P10 = rx2655_cur."before"($P2660)
    unless $P10, rx2655_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2655_cur."!cursor_pos"(rx2655_pos)
    $P10 = rx2655_cur."LANG"("MAIN", "statement")
    unless $P10, rx2655_fail
    rx2655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2655_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2655_cur."!cursor_pos"(rx2655_pos)
    $P10 = rx2655_cur."ws"()
    unless $P10, rx2655_fail
    rx2655_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2655_pos, 1
    gt $I11, rx2655_eos, rx2655_fail
    sub $I11, rx2655_pos, rx2655_off
    ord $I11, rx2655_tgt, $I11
    ne $I11, 59, rx2655_fail
    add rx2655_pos, 1
.annotate 'line', 725
  # rx pass
    rx2655_cur."!cursor_pass"(rx2655_pos, "metachar:sym<:my>")
    if_null rx2655_debug, debug_1413
    rx2655_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2655_pos)
  debug_1413:
    .return (rx2655_cur)
  rx2655_restart:
.annotate 'line', 724
    if_null rx2655_debug, debug_1414
    rx2655_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1414:
  rx2655_fail:
    (rx2655_rep, rx2655_pos, $I10, $P10) = rx2655_cur."!mark_fail"(0)
    lt rx2655_pos, -1, rx2655_done
    eq rx2655_pos, -1, rx2655_fail
    jump $I10
  rx2655_done:
    rx2655_cur."!cursor_fail"()
    if_null rx2655_debug, debug_1415
    rx2655_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1415:
    .return (rx2655_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("386_1303748459.273") :method
.annotate 'line', 724
    new $P2657, "ResizablePMCArray"
    push $P2657, ":"
    .return ($P2657)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2659"  :anon :subid("387_1303748459.273") :method :outer("385_1303748459.273")
.annotate 'line', 726
    .local string rx2661_tgt
    .local int rx2661_pos
    .local int rx2661_off
    .local int rx2661_eos
    .local int rx2661_rep
    .local pmc rx2661_cur
    .local pmc rx2661_debug
    (rx2661_cur, rx2661_pos, rx2661_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2661_cur
    .local pmc match
    .lex "$/", match
    length rx2661_eos, rx2661_tgt
    gt rx2661_pos, rx2661_eos, rx2661_done
    set rx2661_off, 0
    lt rx2661_pos, 2, rx2661_start
    sub rx2661_off, rx2661_pos, 1
    substr rx2661_tgt, rx2661_tgt, rx2661_off
  rx2661_start:
    eq $I10, 1, rx2661_restart
    if_null rx2661_debug, debug_1409
    rx2661_cur."!cursor_debug"("START", "")
  debug_1409:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2662_done
    goto rxscan2662_scan
  rxscan2662_loop:
    (rx2661_pos) = rx2661_cur."from"()
    inc rx2661_pos
    rx2661_cur."!cursor_from"(rx2661_pos)
    ge rx2661_pos, rx2661_eos, rxscan2662_done
  rxscan2662_scan:
    set_addr $I10, rxscan2662_loop
    rx2661_cur."!mark_push"(0, rx2661_pos, $I10)
  rxscan2662_done:
  # rx literal  "my"
    add $I11, rx2661_pos, 2
    gt $I11, rx2661_eos, rx2661_fail
    sub $I11, rx2661_pos, rx2661_off
    substr $S10, rx2661_tgt, $I11, 2
    ne $S10, "my", rx2661_fail
    add rx2661_pos, 2
  # rx pass
    rx2661_cur."!cursor_pass"(rx2661_pos, "")
    if_null rx2661_debug, debug_1410
    rx2661_cur."!cursor_debug"("PASS", "", " at pos=", rx2661_pos)
  debug_1410:
    .return (rx2661_cur)
  rx2661_restart:
    if_null rx2661_debug, debug_1411
    rx2661_cur."!cursor_debug"("NEXT", "")
  debug_1411:
  rx2661_fail:
    (rx2661_rep, rx2661_pos, $I10, $P10) = rx2661_cur."!mark_fail"(0)
    lt rx2661_pos, -1, rx2661_done
    eq rx2661_pos, -1, rx2661_fail
    jump $I10
  rx2661_done:
    rx2661_cur."!cursor_fail"()
    if_null rx2661_debug, debug_1412
    rx2661_cur."!cursor_debug"("FAIL", "")
  debug_1412:
    .return (rx2661_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("388_1303748459.273") :method :outer("384_1303748459.273")
.annotate 'line', 724
    .local string rx2664_tgt
    .local int rx2664_pos
    .local int rx2664_off
    .local int rx2664_eos
    .local int rx2664_rep
    .local pmc rx2664_cur
    .local pmc rx2664_debug
    (rx2664_cur, rx2664_pos, rx2664_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2664_cur
    .local pmc match
    .lex "$/", match
    length rx2664_eos, rx2664_tgt
    gt rx2664_pos, rx2664_eos, rx2664_done
    set rx2664_off, 0
    lt rx2664_pos, 2, rx2664_start
    sub rx2664_off, rx2664_pos, 1
    substr rx2664_tgt, rx2664_tgt, rx2664_off
  rx2664_start:
    eq $I10, 1, rx2664_restart
    if_null rx2664_debug, debug_1416
    rx2664_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1416:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2667_done
    goto rxscan2667_scan
  rxscan2667_loop:
    (rx2664_pos) = rx2664_cur."from"()
    inc rx2664_pos
    rx2664_cur."!cursor_from"(rx2664_pos)
    ge rx2664_pos, rx2664_eos, rxscan2667_done
  rxscan2667_scan:
    set_addr $I10, rxscan2667_loop
    rx2664_cur."!mark_push"(0, rx2664_pos, $I10)
  rxscan2667_done:
.annotate 'line', 730
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2664_pos, rx2664_off
    substr $S10, rx2664_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2664_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2664_cur."!cursor_pos"(rx2664_pos)
    $P10 = rx2664_cur."codeblock"()
    unless $P10, rx2664_fail
    rx2664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2664_pos = $P10."pos"()
.annotate 'line', 729
  # rx pass
    rx2664_cur."!cursor_pass"(rx2664_pos, "metachar:sym<{ }>")
    if_null rx2664_debug, debug_1417
    rx2664_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2664_pos)
  debug_1417:
    .return (rx2664_cur)
  rx2664_restart:
.annotate 'line', 724
    if_null rx2664_debug, debug_1418
    rx2664_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1418:
  rx2664_fail:
    (rx2664_rep, rx2664_pos, $I10, $P10) = rx2664_cur."!mark_fail"(0)
    lt rx2664_pos, -1, rx2664_done
    eq rx2664_pos, -1, rx2664_fail
    jump $I10
  rx2664_done:
    rx2664_cur."!cursor_fail"()
    if_null rx2664_debug, debug_1419
    rx2664_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1419:
    .return (rx2664_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("389_1303748459.273") :method
.annotate 'line', 724
    new $P2666, "ResizablePMCArray"
    push $P2666, "{"
    .return ($P2666)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("390_1303748459.273") :method :outer("384_1303748459.273")
.annotate 'line', 724
    .const 'Sub' $P2674 = "392_1303748459.273" 
    capture_lex $P2674
    .local string rx2669_tgt
    .local int rx2669_pos
    .local int rx2669_off
    .local int rx2669_eos
    .local int rx2669_rep
    .local pmc rx2669_cur
    .local pmc rx2669_debug
    (rx2669_cur, rx2669_pos, rx2669_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2669_cur
    .local pmc match
    .lex "$/", match
    length rx2669_eos, rx2669_tgt
    gt rx2669_pos, rx2669_eos, rx2669_done
    set rx2669_off, 0
    lt rx2669_pos, 2, rx2669_start
    sub rx2669_off, rx2669_pos, 1
    substr rx2669_tgt, rx2669_tgt, rx2669_off
  rx2669_start:
    eq $I10, 1, rx2669_restart
    if_null rx2669_debug, debug_1420
    rx2669_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1420:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2672_done
    goto rxscan2672_scan
  rxscan2672_loop:
    (rx2669_pos) = rx2669_cur."from"()
    inc rx2669_pos
    rx2669_cur."!cursor_from"(rx2669_pos)
    ge rx2669_pos, rx2669_eos, rxscan2672_done
  rxscan2672_scan:
    set_addr $I10, rxscan2672_loop
    rx2669_cur."!mark_push"(0, rx2669_pos, $I10)
  rxscan2672_done:
.annotate 'line', 734
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2669_pos, rx2669_off
    substr $S10, rx2669_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2669_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2669_cur."!cursor_pos"(rx2669_pos)
    .const 'Sub' $P2674 = "392_1303748459.273" 
    capture_lex $P2674
    $P10 = rx2669_cur."before"($P2674)
    unless $P10, rx2669_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2669_cur."!cursor_pos"(rx2669_pos)
    $P10 = rx2669_cur."LANG"("MAIN", "variable")
    unless $P10, rx2669_fail
    rx2669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2669_pos = $P10."pos"()
.annotate 'line', 733
  # rx pass
    rx2669_cur."!cursor_pass"(rx2669_pos, "metachar:sym<nqpvar>")
    if_null rx2669_debug, debug_1425
    rx2669_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2669_pos)
  debug_1425:
    .return (rx2669_cur)
  rx2669_restart:
.annotate 'line', 724
    if_null rx2669_debug, debug_1426
    rx2669_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1426:
  rx2669_fail:
    (rx2669_rep, rx2669_pos, $I10, $P10) = rx2669_cur."!mark_fail"(0)
    lt rx2669_pos, -1, rx2669_done
    eq rx2669_pos, -1, rx2669_fail
    jump $I10
  rx2669_done:
    rx2669_cur."!cursor_fail"()
    if_null rx2669_debug, debug_1427
    rx2669_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1427:
    .return (rx2669_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("391_1303748459.273") :method
.annotate 'line', 724
    new $P2671, "ResizablePMCArray"
    push $P2671, "$"
    push $P2671, "@"
    .return ($P2671)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2673"  :anon :subid("392_1303748459.273") :method :outer("390_1303748459.273")
.annotate 'line', 734
    .local string rx2675_tgt
    .local int rx2675_pos
    .local int rx2675_off
    .local int rx2675_eos
    .local int rx2675_rep
    .local pmc rx2675_cur
    .local pmc rx2675_debug
    (rx2675_cur, rx2675_pos, rx2675_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2675_cur
    .local pmc match
    .lex "$/", match
    length rx2675_eos, rx2675_tgt
    gt rx2675_pos, rx2675_eos, rx2675_done
    set rx2675_off, 0
    lt rx2675_pos, 2, rx2675_start
    sub rx2675_off, rx2675_pos, 1
    substr rx2675_tgt, rx2675_tgt, rx2675_off
  rx2675_start:
    eq $I10, 1, rx2675_restart
    if_null rx2675_debug, debug_1421
    rx2675_cur."!cursor_debug"("START", "")
  debug_1421:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2676_done
    goto rxscan2676_scan
  rxscan2676_loop:
    (rx2675_pos) = rx2675_cur."from"()
    inc rx2675_pos
    rx2675_cur."!cursor_from"(rx2675_pos)
    ge rx2675_pos, rx2675_eos, rxscan2676_done
  rxscan2676_scan:
    set_addr $I10, rxscan2676_loop
    rx2675_cur."!mark_push"(0, rx2675_pos, $I10)
  rxscan2676_done:
  # rx charclass .
    ge rx2675_pos, rx2675_eos, rx2675_fail
    inc rx2675_pos
  # rx charclass w
    ge rx2675_pos, rx2675_eos, rx2675_fail
    sub $I10, rx2675_pos, rx2675_off
    is_cclass $I11, 8192, rx2675_tgt, $I10
    unless $I11, rx2675_fail
    inc rx2675_pos
  # rx pass
    rx2675_cur."!cursor_pass"(rx2675_pos, "")
    if_null rx2675_debug, debug_1422
    rx2675_cur."!cursor_debug"("PASS", "", " at pos=", rx2675_pos)
  debug_1422:
    .return (rx2675_cur)
  rx2675_restart:
    if_null rx2675_debug, debug_1423
    rx2675_cur."!cursor_debug"("NEXT", "")
  debug_1423:
  rx2675_fail:
    (rx2675_rep, rx2675_pos, $I10, $P10) = rx2675_cur."!mark_fail"(0)
    lt rx2675_pos, -1, rx2675_done
    eq rx2675_pos, -1, rx2675_fail
    jump $I10
  rx2675_done:
    rx2675_cur."!cursor_fail"()
    if_null rx2675_debug, debug_1424
    rx2675_cur."!cursor_debug"("FAIL", "")
  debug_1424:
    .return (rx2675_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("393_1303748459.273") :method :outer("384_1303748459.273")
.annotate 'line', 724
    .local string rx2678_tgt
    .local int rx2678_pos
    .local int rx2678_off
    .local int rx2678_eos
    .local int rx2678_rep
    .local pmc rx2678_cur
    .local pmc rx2678_debug
    (rx2678_cur, rx2678_pos, rx2678_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2678_cur
    .local pmc match
    .lex "$/", match
    length rx2678_eos, rx2678_tgt
    gt rx2678_pos, rx2678_eos, rx2678_done
    set rx2678_off, 0
    lt rx2678_pos, 2, rx2678_start
    sub rx2678_off, rx2678_pos, 1
    substr rx2678_tgt, rx2678_tgt, rx2678_off
  rx2678_start:
    eq $I10, 1, rx2678_restart
    if_null rx2678_debug, debug_1428
    rx2678_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1428:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2681_done
    goto rxscan2681_scan
  rxscan2681_loop:
    (rx2678_pos) = rx2678_cur."from"()
    inc rx2678_pos
    rx2678_cur."!cursor_from"(rx2678_pos)
    ge rx2678_pos, rx2678_eos, rxscan2681_done
  rxscan2681_scan:
    set_addr $I10, rxscan2681_loop
    rx2678_cur."!mark_push"(0, rx2678_pos, $I10)
  rxscan2681_done:
.annotate 'line', 738
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2678_pos, rx2678_off
    substr $S10, rx2678_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2678_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2678_cur."!cursor_pos"(rx2678_pos)
    $P10 = rx2678_cur."codeblock"()
    unless $P10, rx2678_fail
    rx2678_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2678_pos = $P10."pos"()
.annotate 'line', 737
  # rx pass
    rx2678_cur."!cursor_pass"(rx2678_pos, "assertion:sym<{ }>")
    if_null rx2678_debug, debug_1429
    rx2678_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2678_pos)
  debug_1429:
    .return (rx2678_cur)
  rx2678_restart:
.annotate 'line', 724
    if_null rx2678_debug, debug_1430
    rx2678_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1430:
  rx2678_fail:
    (rx2678_rep, rx2678_pos, $I10, $P10) = rx2678_cur."!mark_fail"(0)
    lt rx2678_pos, -1, rx2678_done
    eq rx2678_pos, -1, rx2678_fail
    jump $I10
  rx2678_done:
    rx2678_cur."!cursor_fail"()
    if_null rx2678_debug, debug_1431
    rx2678_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1431:
    .return (rx2678_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("394_1303748459.273") :method
.annotate 'line', 724
    new $P2680, "ResizablePMCArray"
    push $P2680, "{"
    .return ($P2680)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("395_1303748459.273") :method :outer("384_1303748459.273")
.annotate 'line', 724
    .const 'Sub' $P2688 = "397_1303748459.273" 
    capture_lex $P2688
    .local string rx2683_tgt
    .local int rx2683_pos
    .local int rx2683_off
    .local int rx2683_eos
    .local int rx2683_rep
    .local pmc rx2683_cur
    .local pmc rx2683_debug
    (rx2683_cur, rx2683_pos, rx2683_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2683_cur
    .local pmc match
    .lex "$/", match
    length rx2683_eos, rx2683_tgt
    gt rx2683_pos, rx2683_eos, rx2683_done
    set rx2683_off, 0
    lt rx2683_pos, 2, rx2683_start
    sub rx2683_off, rx2683_pos, 1
    substr rx2683_tgt, rx2683_tgt, rx2683_off
  rx2683_start:
    eq $I10, 1, rx2683_restart
    if_null rx2683_debug, debug_1432
    rx2683_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1432:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2686_done
    goto rxscan2686_scan
  rxscan2686_loop:
    (rx2683_pos) = rx2683_cur."from"()
    inc rx2683_pos
    rx2683_cur."!cursor_from"(rx2683_pos)
    ge rx2683_pos, rx2683_eos, rxscan2686_done
  rxscan2686_scan:
    set_addr $I10, rxscan2686_loop
    rx2683_cur."!mark_push"(0, rx2683_pos, $I10)
  rxscan2686_done:
.annotate 'line', 742
  # rx subcapture "zw"
    set_addr $I10, rxcap_2691_fail
    rx2683_cur."!mark_push"(0, rx2683_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2683_pos, rx2683_eos, rx2683_fail
    sub $I10, rx2683_pos, rx2683_off
    substr $S10, rx2683_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2683_fail
    inc rx2683_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2683_cur."!cursor_pos"(rx2683_pos)
    .const 'Sub' $P2688 = "397_1303748459.273" 
    capture_lex $P2688
    $P10 = rx2683_cur."before"($P2688)
    unless $P10, rx2683_fail
    set_addr $I10, rxcap_2691_fail
    ($I12, $I11) = rx2683_cur."!mark_peek"($I10)
    rx2683_cur."!cursor_pos"($I11)
    ($P10) = rx2683_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2683_pos, "")
    rx2683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2691_done
  rxcap_2691_fail:
    goto rx2683_fail
  rxcap_2691_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2683_cur."!cursor_pos"(rx2683_pos)
    $P10 = rx2683_cur."codeblock"()
    unless $P10, rx2683_fail
    rx2683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2683_pos = $P10."pos"()
.annotate 'line', 741
  # rx pass
    rx2683_cur."!cursor_pass"(rx2683_pos, "assertion:sym<?{ }>")
    if_null rx2683_debug, debug_1437
    rx2683_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2683_pos)
  debug_1437:
    .return (rx2683_cur)
  rx2683_restart:
.annotate 'line', 724
    if_null rx2683_debug, debug_1438
    rx2683_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1438:
  rx2683_fail:
    (rx2683_rep, rx2683_pos, $I10, $P10) = rx2683_cur."!mark_fail"(0)
    lt rx2683_pos, -1, rx2683_done
    eq rx2683_pos, -1, rx2683_fail
    jump $I10
  rx2683_done:
    rx2683_cur."!cursor_fail"()
    if_null rx2683_debug, debug_1439
    rx2683_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1439:
    .return (rx2683_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("396_1303748459.273") :method
.annotate 'line', 724
    new $P2685, "ResizablePMCArray"
    push $P2685, "!"
    push $P2685, "?"
    .return ($P2685)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2687"  :anon :subid("397_1303748459.273") :method :outer("395_1303748459.273")
.annotate 'line', 742
    .local string rx2689_tgt
    .local int rx2689_pos
    .local int rx2689_off
    .local int rx2689_eos
    .local int rx2689_rep
    .local pmc rx2689_cur
    .local pmc rx2689_debug
    (rx2689_cur, rx2689_pos, rx2689_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2689_cur
    .local pmc match
    .lex "$/", match
    length rx2689_eos, rx2689_tgt
    gt rx2689_pos, rx2689_eos, rx2689_done
    set rx2689_off, 0
    lt rx2689_pos, 2, rx2689_start
    sub rx2689_off, rx2689_pos, 1
    substr rx2689_tgt, rx2689_tgt, rx2689_off
  rx2689_start:
    eq $I10, 1, rx2689_restart
    if_null rx2689_debug, debug_1433
    rx2689_cur."!cursor_debug"("START", "")
  debug_1433:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2690_done
    goto rxscan2690_scan
  rxscan2690_loop:
    (rx2689_pos) = rx2689_cur."from"()
    inc rx2689_pos
    rx2689_cur."!cursor_from"(rx2689_pos)
    ge rx2689_pos, rx2689_eos, rxscan2690_done
  rxscan2690_scan:
    set_addr $I10, rxscan2690_loop
    rx2689_cur."!mark_push"(0, rx2689_pos, $I10)
  rxscan2690_done:
  # rx literal  "{"
    add $I11, rx2689_pos, 1
    gt $I11, rx2689_eos, rx2689_fail
    sub $I11, rx2689_pos, rx2689_off
    ord $I11, rx2689_tgt, $I11
    ne $I11, 123, rx2689_fail
    add rx2689_pos, 1
  # rx pass
    rx2689_cur."!cursor_pass"(rx2689_pos, "")
    if_null rx2689_debug, debug_1434
    rx2689_cur."!cursor_debug"("PASS", "", " at pos=", rx2689_pos)
  debug_1434:
    .return (rx2689_cur)
  rx2689_restart:
    if_null rx2689_debug, debug_1435
    rx2689_cur."!cursor_debug"("NEXT", "")
  debug_1435:
  rx2689_fail:
    (rx2689_rep, rx2689_pos, $I10, $P10) = rx2689_cur."!mark_fail"(0)
    lt rx2689_pos, -1, rx2689_done
    eq rx2689_pos, -1, rx2689_fail
    jump $I10
  rx2689_done:
    rx2689_cur."!cursor_fail"()
    if_null rx2689_debug, debug_1436
    rx2689_cur."!cursor_debug"("FAIL", "")
  debug_1436:
    .return (rx2689_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("398_1303748459.273") :method :outer("384_1303748459.273")
.annotate 'line', 724
    .const 'Sub' $P2701 = "400_1303748459.273" 
    capture_lex $P2701
    .local string rx2693_tgt
    .local int rx2693_pos
    .local int rx2693_off
    .local int rx2693_eos
    .local int rx2693_rep
    .local pmc rx2693_cur
    .local pmc rx2693_debug
    (rx2693_cur, rx2693_pos, rx2693_tgt, $I10) = self."!cursor_start"()
    rx2693_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2693_cur
    .local pmc match
    .lex "$/", match
    length rx2693_eos, rx2693_tgt
    gt rx2693_pos, rx2693_eos, rx2693_done
    set rx2693_off, 0
    lt rx2693_pos, 2, rx2693_start
    sub rx2693_off, rx2693_pos, 1
    substr rx2693_tgt, rx2693_tgt, rx2693_off
  rx2693_start:
    eq $I10, 1, rx2693_restart
    if_null rx2693_debug, debug_1440
    rx2693_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1440:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2697_done
    goto rxscan2697_scan
  rxscan2697_loop:
    (rx2693_pos) = rx2693_cur."from"()
    inc rx2693_pos
    rx2693_cur."!cursor_from"(rx2693_pos)
    ge rx2693_pos, rx2693_eos, rxscan2697_done
  rxscan2697_scan:
    set_addr $I10, rxscan2697_loop
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
  rxscan2697_done:
.annotate 'line', 746
  # rx subrule "identifier" subtype=capture negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."identifier"()
    unless $P10, rx2693_fail
    rx2693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2693_pos = $P10."pos"()
.annotate 'line', 753
  # rx rxquantr2698 ** 0..1
    set_addr $I10, rxquantr2698_done
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
  rxquantr2698_loop:
  alt2699_0:
.annotate 'line', 747
    set_addr $I10, alt2699_1
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
.annotate 'line', 748
  # rx subrule "before" subtype=zerowidth negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    .const 'Sub' $P2701 = "400_1303748459.273" 
    capture_lex $P2701
    $P10 = rx2693_cur."before"($P2701)
    unless $P10, rx2693_fail
    goto alt2699_end
  alt2699_1:
    set_addr $I10, alt2699_2
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
.annotate 'line', 749
  # rx literal  "="
    add $I11, rx2693_pos, 1
    gt $I11, rx2693_eos, rx2693_fail
    sub $I11, rx2693_pos, rx2693_off
    ord $I11, rx2693_tgt, $I11
    ne $I11, 61, rx2693_fail
    add rx2693_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."assertion"()
    unless $P10, rx2693_fail
    rx2693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2693_pos = $P10."pos"()
    goto alt2699_end
  alt2699_2:
    set_addr $I10, alt2699_3
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
.annotate 'line', 750
  # rx literal  ":"
    add $I11, rx2693_pos, 1
    gt $I11, rx2693_eos, rx2693_fail
    sub $I11, rx2693_pos, rx2693_off
    ord $I11, rx2693_tgt, $I11
    ne $I11, 58, rx2693_fail
    add rx2693_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."arglist"()
    unless $P10, rx2693_fail
    rx2693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2693_pos = $P10."pos"()
    goto alt2699_end
  alt2699_3:
    set_addr $I10, alt2699_4
    rx2693_cur."!mark_push"(0, rx2693_pos, $I10)
.annotate 'line', 751
  # rx literal  "("
    add $I11, rx2693_pos, 1
    gt $I11, rx2693_eos, rx2693_fail
    sub $I11, rx2693_pos, rx2693_off
    ord $I11, rx2693_tgt, $I11
    ne $I11, 40, rx2693_fail
    add rx2693_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2693_fail
    rx2693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2693_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2693_pos, 1
    gt $I11, rx2693_eos, rx2693_fail
    sub $I11, rx2693_pos, rx2693_off
    ord $I11, rx2693_tgt, $I11
    ne $I11, 41, rx2693_fail
    add rx2693_pos, 1
    goto alt2699_end
  alt2699_4:
.annotate 'line', 752
  # rx subrule "normspace" subtype=method negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."normspace"()
    unless $P10, rx2693_fail
    rx2693_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2693_cur."!cursor_pos"(rx2693_pos)
    $P10 = rx2693_cur."nibbler"()
    unless $P10, rx2693_fail
    rx2693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2693_pos = $P10."pos"()
  alt2699_end:
.annotate 'line', 753
    set_addr $I10, rxquantr2698_done
    (rx2693_rep) = rx2693_cur."!mark_commit"($I10)
  rxquantr2698_done:
.annotate 'line', 745
  # rx pass
    rx2693_cur."!cursor_pass"(rx2693_pos, "assertion:sym<name>")
    if_null rx2693_debug, debug_1445
    rx2693_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2693_pos)
  debug_1445:
    .return (rx2693_cur)
  rx2693_restart:
.annotate 'line', 724
    if_null rx2693_debug, debug_1446
    rx2693_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1446:
  rx2693_fail:
    (rx2693_rep, rx2693_pos, $I10, $P10) = rx2693_cur."!mark_fail"(0)
    lt rx2693_pos, -1, rx2693_done
    eq rx2693_pos, -1, rx2693_fail
    jump $I10
  rx2693_done:
    rx2693_cur."!cursor_fail"()
    if_null rx2693_debug, debug_1447
    rx2693_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1447:
    .return (rx2693_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("399_1303748459.273") :method
.annotate 'line', 724
    $P2695 = self."!PREFIX__!subrule"("identifier", "")
    new $P2696, "ResizablePMCArray"
    push $P2696, $P2695
    .return ($P2696)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2700"  :anon :subid("400_1303748459.273") :method :outer("398_1303748459.273")
.annotate 'line', 748
    .local string rx2702_tgt
    .local int rx2702_pos
    .local int rx2702_off
    .local int rx2702_eos
    .local int rx2702_rep
    .local pmc rx2702_cur
    .local pmc rx2702_debug
    (rx2702_cur, rx2702_pos, rx2702_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2702_cur
    .local pmc match
    .lex "$/", match
    length rx2702_eos, rx2702_tgt
    gt rx2702_pos, rx2702_eos, rx2702_done
    set rx2702_off, 0
    lt rx2702_pos, 2, rx2702_start
    sub rx2702_off, rx2702_pos, 1
    substr rx2702_tgt, rx2702_tgt, rx2702_off
  rx2702_start:
    eq $I10, 1, rx2702_restart
    if_null rx2702_debug, debug_1441
    rx2702_cur."!cursor_debug"("START", "")
  debug_1441:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2703_done
    goto rxscan2703_scan
  rxscan2703_loop:
    (rx2702_pos) = rx2702_cur."from"()
    inc rx2702_pos
    rx2702_cur."!cursor_from"(rx2702_pos)
    ge rx2702_pos, rx2702_eos, rxscan2703_done
  rxscan2703_scan:
    set_addr $I10, rxscan2703_loop
    rx2702_cur."!mark_push"(0, rx2702_pos, $I10)
  rxscan2703_done:
  # rx literal  ">"
    add $I11, rx2702_pos, 1
    gt $I11, rx2702_eos, rx2702_fail
    sub $I11, rx2702_pos, rx2702_off
    ord $I11, rx2702_tgt, $I11
    ne $I11, 62, rx2702_fail
    add rx2702_pos, 1
  # rx pass
    rx2702_cur."!cursor_pass"(rx2702_pos, "")
    if_null rx2702_debug, debug_1442
    rx2702_cur."!cursor_debug"("PASS", "", " at pos=", rx2702_pos)
  debug_1442:
    .return (rx2702_cur)
  rx2702_restart:
    if_null rx2702_debug, debug_1443
    rx2702_cur."!cursor_debug"("NEXT", "")
  debug_1443:
  rx2702_fail:
    (rx2702_rep, rx2702_pos, $I10, $P10) = rx2702_cur."!mark_fail"(0)
    lt rx2702_pos, -1, rx2702_done
    eq rx2702_pos, -1, rx2702_fail
    jump $I10
  rx2702_done:
    rx2702_cur."!cursor_fail"()
    if_null rx2702_debug, debug_1444
    rx2702_cur."!cursor_debug"("FAIL", "")
  debug_1444:
    .return (rx2702_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("401_1303748459.273") :method :outer("384_1303748459.273")
.annotate 'line', 724
    .local string rx2705_tgt
    .local int rx2705_pos
    .local int rx2705_off
    .local int rx2705_eos
    .local int rx2705_rep
    .local pmc rx2705_cur
    .local pmc rx2705_debug
    (rx2705_cur, rx2705_pos, rx2705_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2705_cur
    .local pmc match
    .lex "$/", match
    length rx2705_eos, rx2705_tgt
    gt rx2705_pos, rx2705_eos, rx2705_done
    set rx2705_off, 0
    lt rx2705_pos, 2, rx2705_start
    sub rx2705_off, rx2705_pos, 1
    substr rx2705_tgt, rx2705_tgt, rx2705_off
  rx2705_start:
    eq $I10, 1, rx2705_restart
    if_null rx2705_debug, debug_1448
    rx2705_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1448:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2708_done
    goto rxscan2708_scan
  rxscan2708_loop:
    (rx2705_pos) = rx2705_cur."from"()
    inc rx2705_pos
    rx2705_cur."!cursor_from"(rx2705_pos)
    ge rx2705_pos, rx2705_eos, rxscan2708_done
  rxscan2708_scan:
    set_addr $I10, rxscan2708_loop
    rx2705_cur."!mark_push"(0, rx2705_pos, $I10)
  rxscan2708_done:
.annotate 'line', 757
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2705_pos, rx2705_off
    substr $S10, rx2705_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2705_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2705_cur."!cursor_pos"(rx2705_pos)
    $P10 = rx2705_cur."LANG"("MAIN", "variable")
    unless $P10, rx2705_fail
    rx2705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2705_pos = $P10."pos"()
.annotate 'line', 756
  # rx pass
    rx2705_cur."!cursor_pass"(rx2705_pos, "assertion:sym<var>")
    if_null rx2705_debug, debug_1449
    rx2705_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2705_pos)
  debug_1449:
    .return (rx2705_cur)
  rx2705_restart:
.annotate 'line', 724
    if_null rx2705_debug, debug_1450
    rx2705_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1450:
  rx2705_fail:
    (rx2705_rep, rx2705_pos, $I10, $P10) = rx2705_cur."!mark_fail"(0)
    lt rx2705_pos, -1, rx2705_done
    eq rx2705_pos, -1, rx2705_fail
    jump $I10
  rx2705_done:
    rx2705_cur."!cursor_fail"()
    if_null rx2705_debug, debug_1451
    rx2705_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1451:
    .return (rx2705_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("402_1303748459.273") :method
.annotate 'line', 724
    new $P2707, "ResizablePMCArray"
    push $P2707, "$"
    push $P2707, "@"
    .return ($P2707)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("403_1303748459.273") :method :outer("384_1303748459.273")
.annotate 'line', 724
    .local string rx2710_tgt
    .local int rx2710_pos
    .local int rx2710_off
    .local int rx2710_eos
    .local int rx2710_rep
    .local pmc rx2710_cur
    .local pmc rx2710_debug
    (rx2710_cur, rx2710_pos, rx2710_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2710_cur
    .local pmc match
    .lex "$/", match
    length rx2710_eos, rx2710_tgt
    gt rx2710_pos, rx2710_eos, rx2710_done
    set rx2710_off, 0
    lt rx2710_pos, 2, rx2710_start
    sub rx2710_off, rx2710_pos, 1
    substr rx2710_tgt, rx2710_tgt, rx2710_off
  rx2710_start:
    eq $I10, 1, rx2710_restart
    if_null rx2710_debug, debug_1452
    rx2710_cur."!cursor_debug"("START", "codeblock")
  debug_1452:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2714_done
    goto rxscan2714_scan
  rxscan2714_loop:
    (rx2710_pos) = rx2710_cur."from"()
    inc rx2710_pos
    rx2710_cur."!cursor_from"(rx2710_pos)
    ge rx2710_pos, rx2710_eos, rxscan2714_done
  rxscan2714_scan:
    set_addr $I10, rxscan2714_loop
    rx2710_cur."!mark_push"(0, rx2710_pos, $I10)
  rxscan2714_done:
.annotate 'line', 761
  # rx subrule "LANG" subtype=capture negate=
    rx2710_cur."!cursor_pos"(rx2710_pos)
    $P10 = rx2710_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2710_fail
    rx2710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2710_pos = $P10."pos"()
.annotate 'line', 760
  # rx pass
    rx2710_cur."!cursor_pass"(rx2710_pos, "codeblock")
    if_null rx2710_debug, debug_1453
    rx2710_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2710_pos)
  debug_1453:
    .return (rx2710_cur)
  rx2710_restart:
.annotate 'line', 724
    if_null rx2710_debug, debug_1454
    rx2710_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1454:
  rx2710_fail:
    (rx2710_rep, rx2710_pos, $I10, $P10) = rx2710_cur."!mark_fail"(0)
    lt rx2710_pos, -1, rx2710_done
    eq rx2710_pos, -1, rx2710_fail
    jump $I10
  rx2710_done:
    rx2710_cur."!cursor_fail"()
    if_null rx2710_debug, debug_1455
    rx2710_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1455:
    .return (rx2710_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("404_1303748459.273") :method
.annotate 'line', 724
    $P2712 = self."!PREFIX__!subrule"("LANG", "")
    new $P2713, "ResizablePMCArray"
    push $P2713, $P2712
    .return ($P2713)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2752"  :subid("406_1303748459.273") :outer("10_1303748459.273")
.annotate 'line', 767
    .const 'Sub' $P6948 = "572_1303748459.273" 
    capture_lex $P6948
    .const 'Sub' $P6931 = "571_1303748459.273" 
    capture_lex $P6931
    .const 'Sub' $P6926 = "570_1303748459.273" 
    capture_lex $P6926
    .const 'Sub' $P6921 = "569_1303748459.273" 
    capture_lex $P6921
    .const 'Sub' $P6916 = "568_1303748459.273" 
    capture_lex $P6916
    .const 'Sub' $P6899 = "567_1303748459.273" 
    capture_lex $P6899
    .const 'Sub' $P6888 = "566_1303748459.273" 
    capture_lex $P6888
    .const 'Sub' $P6877 = "565_1303748459.273" 
    capture_lex $P6877
    .const 'Sub' $P6869 = "564_1303748459.273" 
    capture_lex $P6869
    .const 'Sub' $P6864 = "563_1303748459.273" 
    capture_lex $P6864
    .const 'Sub' $P6849 = "562_1303748459.273" 
    capture_lex $P6849
    .const 'Sub' $P6841 = "561_1303748459.273" 
    capture_lex $P6841
    .const 'Sub' $P6780 = "560_1303748459.273" 
    capture_lex $P6780
    .const 'Sub' $P6765 = "559_1303748459.273" 
    capture_lex $P6765
    .const 'Sub' $P6757 = "558_1303748459.273" 
    capture_lex $P6757
    .const 'Sub' $P6749 = "557_1303748459.273" 
    capture_lex $P6749
    .const 'Sub' $P6741 = "556_1303748459.273" 
    capture_lex $P6741
    .const 'Sub' $P6733 = "555_1303748459.273" 
    capture_lex $P6733
    .const 'Sub' $P6725 = "554_1303748459.273" 
    capture_lex $P6725
    .const 'Sub' $P6696 = "553_1303748459.273" 
    capture_lex $P6696
    .const 'Sub' $P6681 = "552_1303748459.273" 
    capture_lex $P6681
    .const 'Sub' $P6673 = "551_1303748459.273" 
    capture_lex $P6673
    .const 'Sub' $P6659 = "550_1303748459.273" 
    capture_lex $P6659
    .const 'Sub' $P6645 = "549_1303748459.273" 
    capture_lex $P6645
    .const 'Sub' $P6631 = "548_1303748459.273" 
    capture_lex $P6631
    .const 'Sub' $P6623 = "547_1303748459.273" 
    capture_lex $P6623
    .const 'Sub' $P6593 = "546_1303748459.273" 
    capture_lex $P6593
    .const 'Sub' $P6555 = "544_1303748459.273" 
    capture_lex $P6555
    .const 'Sub' $P6547 = "543_1303748459.273" 
    capture_lex $P6547
    .const 'Sub' $P6539 = "542_1303748459.273" 
    capture_lex $P6539
    .const 'Sub' $P6508 = "541_1303748459.273" 
    capture_lex $P6508
    .const 'Sub' $P6489 = "540_1303748459.273" 
    capture_lex $P6489
    .const 'Sub' $P6481 = "539_1303748459.273" 
    capture_lex $P6481
    .const 'Sub' $P6473 = "538_1303748459.273" 
    capture_lex $P6473
    .const 'Sub' $P6365 = "535_1303748459.273" 
    capture_lex $P6365
    .const 'Sub' $P6357 = "534_1303748459.273" 
    capture_lex $P6357
    .const 'Sub' $P6347 = "533_1303748459.273" 
    capture_lex $P6347
    .const 'Sub' $P6313 = "532_1303748459.273" 
    capture_lex $P6313
    .const 'Sub' $P6271 = "530_1303748459.273" 
    capture_lex $P6271
    .const 'Sub' $P6257 = "529_1303748459.273" 
    capture_lex $P6257
    .const 'Sub' $P6247 = "528_1303748459.273" 
    capture_lex $P6247
    .const 'Sub' $P6195 = "527_1303748459.273" 
    capture_lex $P6195
    .const 'Sub' $P5919 = "523_1303748459.273" 
    capture_lex $P5919
    .const 'Sub' $P5837 = "521_1303748459.273" 
    capture_lex $P5837
    .const 'Sub' $P5829 = "520_1303748459.273" 
    capture_lex $P5829
    .const 'Sub' $P5813 = "519_1303748459.273" 
    capture_lex $P5813
    .const 'Sub' $P5798 = "518_1303748459.273" 
    capture_lex $P5798
    .const 'Sub' $P5775 = "517_1303748459.273" 
    capture_lex $P5775
    .const 'Sub' $P5672 = "516_1303748459.273" 
    capture_lex $P5672
    .const 'Sub' $P5618 = "513_1303748459.273" 
    capture_lex $P5618
    .const 'Sub' $P5436 = "510_1303748459.273" 
    capture_lex $P5436
    .const 'Sub' $P5065 = "503_1303748459.273" 
    capture_lex $P5065
    .const 'Sub' $P5057 = "502_1303748459.273" 
    capture_lex $P5057
    .const 'Sub' $P5049 = "501_1303748459.273" 
    capture_lex $P5049
    .const 'Sub' $P4902 = "498_1303748459.273" 
    capture_lex $P4902
    .const 'Sub' $P4894 = "497_1303748459.273" 
    capture_lex $P4894
    .const 'Sub' $P4879 = "496_1303748459.273" 
    capture_lex $P4879
    .const 'Sub' $P4864 = "495_1303748459.273" 
    capture_lex $P4864
    .const 'Sub' $P4849 = "494_1303748459.273" 
    capture_lex $P4849
    .const 'Sub' $P4827 = "493_1303748459.273" 
    capture_lex $P4827
    .const 'Sub' $P4819 = "492_1303748459.273" 
    capture_lex $P4819
    .const 'Sub' $P4811 = "491_1303748459.273" 
    capture_lex $P4811
    .const 'Sub' $P4803 = "490_1303748459.273" 
    capture_lex $P4803
    .const 'Sub' $P4472 = "486_1303748459.273" 
    capture_lex $P4472
    .const 'Sub' $P4464 = "485_1303748459.273" 
    capture_lex $P4464
    .const 'Sub' $P4456 = "484_1303748459.273" 
    capture_lex $P4456
    .const 'Sub' $P4448 = "483_1303748459.273" 
    capture_lex $P4448
    .const 'Sub' $P4440 = "482_1303748459.273" 
    capture_lex $P4440
    .const 'Sub' $P4432 = "481_1303748459.273" 
    capture_lex $P4432
    .const 'Sub' $P4424 = "480_1303748459.273" 
    capture_lex $P4424
    .const 'Sub' $P4282 = "477_1303748459.273" 
    capture_lex $P4282
    .const 'Sub' $P4255 = "476_1303748459.273" 
    capture_lex $P4255
    .const 'Sub' $P4241 = "475_1303748459.273" 
    capture_lex $P4241
    .const 'Sub' $P4233 = "474_1303748459.273" 
    capture_lex $P4233
    .const 'Sub' $P4225 = "473_1303748459.273" 
    capture_lex $P4225
    .const 'Sub' $P4217 = "472_1303748459.273" 
    capture_lex $P4217
    .const 'Sub' $P4209 = "471_1303748459.273" 
    capture_lex $P4209
    .const 'Sub' $P4201 = "470_1303748459.273" 
    capture_lex $P4201
    .const 'Sub' $P4193 = "469_1303748459.273" 
    capture_lex $P4193
    .const 'Sub' $P4185 = "468_1303748459.273" 
    capture_lex $P4185
    .const 'Sub' $P4177 = "467_1303748459.273" 
    capture_lex $P4177
    .const 'Sub' $P4169 = "466_1303748459.273" 
    capture_lex $P4169
    .const 'Sub' $P4161 = "465_1303748459.273" 
    capture_lex $P4161
    .const 'Sub' $P4153 = "464_1303748459.273" 
    capture_lex $P4153
    .const 'Sub' $P4145 = "463_1303748459.273" 
    capture_lex $P4145
    .const 'Sub' $P4137 = "462_1303748459.273" 
    capture_lex $P4137
    .const 'Sub' $P4121 = "461_1303748459.273" 
    capture_lex $P4121
    .const 'Sub' $P4067 = "460_1303748459.273" 
    capture_lex $P4067
    .const 'Sub' $P4050 = "459_1303748459.273" 
    capture_lex $P4050
    .const 'Sub' $P4026 = "458_1303748459.273" 
    capture_lex $P4026
    .const 'Sub' $P4003 = "457_1303748459.273" 
    capture_lex $P4003
    .const 'Sub' $P3976 = "456_1303748459.273" 
    capture_lex $P3976
    .const 'Sub' $P3939 = "455_1303748459.273" 
    capture_lex $P3939
    .const 'Sub' $P3924 = "454_1303748459.273" 
    capture_lex $P3924
    .const 'Sub' $P3912 = "453_1303748459.273" 
    capture_lex $P3912
    .const 'Sub' $P3861 = "451_1303748459.273" 
    capture_lex $P3861
    .const 'Sub' $P3836 = "450_1303748459.273" 
    capture_lex $P3836
    .const 'Sub' $P3829 = "449_1303748459.273" 
    capture_lex $P3829
    .const 'Sub' $P3787 = "448_1303748459.273" 
    capture_lex $P3787
    .const 'Sub' $P3737 = "446_1303748459.273" 
    capture_lex $P3737
    .const 'Sub' $P3720 = "445_1303748459.273" 
    capture_lex $P3720
    .const 'Sub' $P3681 = "443_1303748459.273" 
    capture_lex $P3681
    .const 'Sub' $P3673 = "442_1303748459.273" 
    capture_lex $P3673
    .const 'Sub' $P3665 = "441_1303748459.273" 
    capture_lex $P3665
    .const 'Sub' $P3648 = "440_1303748459.273" 
    capture_lex $P3648
    .const 'Sub' $P3552 = "438_1303748459.273" 
    capture_lex $P3552
    .const 'Sub' $P3508 = "436_1303748459.273" 
    capture_lex $P3508
    .const 'Sub' $P3393 = "435_1303748459.273" 
    capture_lex $P3393
    .const 'Sub' $P3362 = "434_1303748459.273" 
    capture_lex $P3362
    .const 'Sub' $P3354 = "433_1303748459.273" 
    capture_lex $P3354
    .const 'Sub' $P3225 = "427_1303748459.273" 
    capture_lex $P3225
    .const 'Sub' $P3190 = "425_1303748459.273" 
    capture_lex $P3190
    .const 'Sub' $P3185 = "424_1303748459.273" 
    capture_lex $P3185
    .const 'Sub' $P3180 = "423_1303748459.273" 
    capture_lex $P3180
    .const 'Sub' $P3067 = "420_1303748459.273" 
    capture_lex $P3067
    .const 'Sub' $P3049 = "419_1303748459.273" 
    capture_lex $P3049
    .const 'Sub' $P2966 = "417_1303748459.273" 
    capture_lex $P2966
    .const 'Sub' $P2951 = "416_1303748459.273" 
    capture_lex $P2951
    .const 'Sub' $P2864 = "415_1303748459.273" 
    capture_lex $P2864
    .const 'Sub' $P2838 = "413_1303748459.273" 
    capture_lex $P2838
    .const 'Sub' $P2822 = "412_1303748459.273" 
    capture_lex $P2822
    .const 'Sub' $P2798 = "411_1303748459.273" 
    capture_lex $P2798
    .const 'Sub' $P2762 = "408_1303748459.273" 
    capture_lex $P2762
    .const 'Sub' $P2754 = "407_1303748459.273" 
    capture_lex $P2754
.annotate 'line', 771
    .const 'Sub' $P2754 = "407_1303748459.273" 
    newclosure $P2761, $P2754
    .lex "xblock_immediate", $P2761
.annotate 'line', 776
    .const 'Sub' $P2762 = "408_1303748459.273" 
    newclosure $P2797, $P2762
    .lex "block_immediate", $P2797
.annotate 'line', 786
    .const 'Sub' $P2798 = "411_1303748459.273" 
    newclosure $P2821, $P2798
    .lex "vivitype", $P2821
.annotate 'line', 805
    .const 'Sub' $P2822 = "412_1303748459.273" 
    newclosure $P2837, $P2822
    .lex "colonpair_str", $P2837
.annotate 'line', 967
    .const 'Sub' $P2838 = "413_1303748459.273" 
    newclosure $P2863, $P2838
    .lex "import_HOW_exports", $P2863
.annotate 'line', 1072
    .const 'Sub' $P2864 = "415_1303748459.273" 
    newclosure $P2950, $P2864
    .lex "push_block_handler", $P2950
.annotate 'line', 1636
    .const 'Sub' $P2951 = "416_1303748459.273" 
    newclosure $P2965, $P2951
    .lex "only_star_block", $P2965
.annotate 'line', 1645
    .const 'Sub' $P2966 = "417_1303748459.273" 
    newclosure $P3048, $P2966
    .lex "attach_multi_signature", $P3048
.annotate 'line', 2111
    .const 'Sub' $P3049 = "419_1303748459.273" 
    newclosure $P3066, $P3049
    .lex "control", $P3066
.annotate 'line', 2130
    .const 'Sub' $P3067 = "420_1303748459.273" 
    newclosure $P3179, $P3067
    .lex "lexical_package_lookup", $P3179
.annotate 'line', 2179
    .const 'Sub' $P3180 = "423_1303748459.273" 
    newclosure $P3184, $P3180
    .lex "is_lexical", $P3184
.annotate 'line', 2185
    .const 'Sub' $P3185 = "424_1303748459.273" 
    newclosure $P3189, $P3185
    .lex "is_package", $P3189
.annotate 'line', 2191
    .const 'Sub' $P3190 = "425_1303748459.273" 
    newclosure $P3224, $P3190
    .lex "is_scope", $P3224
.annotate 'line', 2204
    .const 'Sub' $P3225 = "427_1303748459.273" 
    newclosure $P3345, $P3225
    .lex "find_sym", $P3345
.annotate 'line', 767
    .lex "$?PACKAGE", $P3346
    .lex "$?CLASS", $P3347
.annotate 'line', 769
    new $P3348, "ResizablePMCArray"
    find_lex $P3349, "$?PACKAGE"
    get_who $P3350, $P3349
    set $P3350["@BLOCK"], $P3348
    find_lex $P3351, "xblock_immediate"
    find_lex $P3352, "block_immediate"
    find_lex $P3353, "vivitype"
.annotate 'line', 797
    find_lex $P3392, "colonpair_str"
.annotate 'line', 950
    find_lex $P3786, "import_HOW_exports"
.annotate 'line', 1065
    find_lex $P4049, "push_block_handler"
.annotate 'line', 1561
    find_lex $P5616, "only_star_block"
    find_lex $P5617, "attach_multi_signature"
.annotate 'line', 2102
    find_lex $P6915, "control"
.annotate 'line', 2124
    find_lex $P6942, "lexical_package_lookup"
    find_lex $P6943, "is_lexical"
    find_lex $P6944, "is_package"
    find_lex $P6945, "is_scope"
    find_lex $P6946, "find_sym"
.annotate 'line', 767
    .return ($P6946)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1456") :outer("406_1303748459.273")
.annotate 'line', 767
    .const 'Sub' $P2753 = "406_1303748459.273" 
    .local pmc block
    set block, $P2753
    .const 'Sub' $P6948 = "572_1303748459.273" 
    capture_lex $P6948
    $P6948()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6947"  :anon :subid("572_1303748459.273") :outer("406_1303748459.273")
.annotate 'line', 767
    nqp_get_sc_object $P6949, "1303748446.727", 3
    .local pmc type_obj
    set type_obj, $P6949
    get_how $P6950, type_obj
    .const 'Sub' $P6951 = "433_1303748459.273" 
    $P6950."add_method"(type_obj, "TOP", $P6951)
    get_how $P6952, type_obj
    .const 'Sub' $P6953 = "434_1303748459.273" 
    $P6952."add_method"(type_obj, "deflongname", $P6953)
    get_how $P6954, type_obj
    .const 'Sub' $P6955 = "435_1303748459.273" 
    $P6954."add_method"(type_obj, "comp_unit", $P6955)
    get_how $P6956, type_obj
    .const 'Sub' $P6957 = "436_1303748459.273" 
    $P6956."add_method"(type_obj, "statementlist", $P6957)
    get_how $P6958, type_obj
    .const 'Sub' $P6959 = "438_1303748459.273" 
    $P6958."add_method"(type_obj, "statement", $P6959)
    get_how $P6960, type_obj
    .const 'Sub' $P6961 = "440_1303748459.273" 
    $P6960."add_method"(type_obj, "xblock", $P6961)
    get_how $P6962, type_obj
    .const 'Sub' $P6963 = "441_1303748459.273" 
    $P6962."add_method"(type_obj, "pblock", $P6963)
    get_how $P6964, type_obj
    .const 'Sub' $P6965 = "442_1303748459.273" 
    $P6964."add_method"(type_obj, "block", $P6965)
    get_how $P6966, type_obj
    .const 'Sub' $P6967 = "443_1303748459.273" 
    $P6966."add_method"(type_obj, "blockoid", $P6967)
    get_how $P6968, type_obj
    .const 'Sub' $P6969 = "445_1303748459.273" 
    $P6968."add_method"(type_obj, "newpad", $P6969)
    get_how $P6970, type_obj
    .const 'Sub' $P6971 = "446_1303748459.273" 
    $P6970."add_method"(type_obj, "outerctx", $P6971)
    get_how $P6972, type_obj
    .const 'Sub' $P6973 = "448_1303748459.273" 
    $P6972."add_method"(type_obj, "GLOBALish", $P6973)
    get_how $P6974, type_obj
    .const 'Sub' $P6975 = "449_1303748459.273" 
    $P6974."add_method"(type_obj, "you_are_here", $P6975)
    get_how $P6976, type_obj
    .const 'Sub' $P6977 = "450_1303748459.273" 
    $P6976."add_method"(type_obj, "statement_control:sym<use>", $P6977)
    get_how $P6978, type_obj
    .const 'Sub' $P6979 = "451_1303748459.273" 
    $P6978."add_method"(type_obj, "statement_control:sym<if>", $P6979)
    get_how $P6980, type_obj
    .const 'Sub' $P6981 = "453_1303748459.273" 
    $P6980."add_method"(type_obj, "statement_control:sym<unless>", $P6981)
    get_how $P6982, type_obj
    .const 'Sub' $P6983 = "454_1303748459.273" 
    $P6982."add_method"(type_obj, "statement_control:sym<while>", $P6983)
    get_how $P6984, type_obj
    .const 'Sub' $P6985 = "455_1303748459.273" 
    $P6984."add_method"(type_obj, "statement_control:sym<repeat>", $P6985)
    get_how $P6986, type_obj
    .const 'Sub' $P6987 = "456_1303748459.273" 
    $P6986."add_method"(type_obj, "statement_control:sym<for>", $P6987)
    get_how $P6988, type_obj
    .const 'Sub' $P6989 = "457_1303748459.273" 
    $P6988."add_method"(type_obj, "statement_control:sym<CATCH>", $P6989)
    get_how $P6990, type_obj
    .const 'Sub' $P6991 = "458_1303748459.273" 
    $P6990."add_method"(type_obj, "statement_control:sym<CONTROL>", $P6991)
    get_how $P6992, type_obj
    .const 'Sub' $P6993 = "459_1303748459.273" 
    $P6992."add_method"(type_obj, "statement_prefix:sym<INIT>", $P6993)
    get_how $P6994, type_obj
    .const 'Sub' $P6995 = "460_1303748459.273" 
    $P6994."add_method"(type_obj, "statement_prefix:sym<try>", $P6995)
    get_how $P6996, type_obj
    .const 'Sub' $P6997 = "461_1303748459.273" 
    $P6996."add_method"(type_obj, "blorst", $P6997)
    get_how $P6998, type_obj
    .const 'Sub' $P6999 = "462_1303748459.273" 
    $P6998."add_method"(type_obj, "statement_mod_cond:sym<if>", $P6999)
    get_how $P7000, type_obj
    .const 'Sub' $P7001 = "463_1303748459.273" 
    $P7000."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P7001)
    get_how $P7002, type_obj
    .const 'Sub' $P7003 = "464_1303748459.273" 
    $P7002."add_method"(type_obj, "statement_mod_loop:sym<while>", $P7003)
    get_how $P7004, type_obj
    .const 'Sub' $P7005 = "465_1303748459.273" 
    $P7004."add_method"(type_obj, "statement_mod_loop:sym<until>", $P7005)
    get_how $P7006, type_obj
    .const 'Sub' $P7007 = "466_1303748459.273" 
    $P7006."add_method"(type_obj, "term:sym<fatarrow>", $P7007)
    get_how $P7008, type_obj
    .const 'Sub' $P7009 = "467_1303748459.273" 
    $P7008."add_method"(type_obj, "term:sym<colonpair>", $P7009)
    get_how $P7010, type_obj
    .const 'Sub' $P7011 = "468_1303748459.273" 
    $P7010."add_method"(type_obj, "term:sym<variable>", $P7011)
    get_how $P7012, type_obj
    .const 'Sub' $P7013 = "469_1303748459.273" 
    $P7012."add_method"(type_obj, "term:sym<package_declarator>", $P7013)
    get_how $P7014, type_obj
    .const 'Sub' $P7015 = "470_1303748459.273" 
    $P7014."add_method"(type_obj, "term:sym<scope_declarator>", $P7015)
    get_how $P7016, type_obj
    .const 'Sub' $P7017 = "471_1303748459.273" 
    $P7016."add_method"(type_obj, "term:sym<routine_declarator>", $P7017)
    get_how $P7018, type_obj
    .const 'Sub' $P7019 = "472_1303748459.273" 
    $P7018."add_method"(type_obj, "term:sym<regex_declarator>", $P7019)
    get_how $P7020, type_obj
    .const 'Sub' $P7021 = "473_1303748459.273" 
    $P7020."add_method"(type_obj, "term:sym<statement_prefix>", $P7021)
    get_how $P7022, type_obj
    .const 'Sub' $P7023 = "474_1303748459.273" 
    $P7022."add_method"(type_obj, "term:sym<lambda>", $P7023)
    get_how $P7024, type_obj
    .const 'Sub' $P7025 = "475_1303748459.273" 
    $P7024."add_method"(type_obj, "fatarrow", $P7025)
    get_how $P7026, type_obj
    .const 'Sub' $P7027 = "476_1303748459.273" 
    $P7026."add_method"(type_obj, "colonpair", $P7027)
    get_how $P7028, type_obj
    .const 'Sub' $P7029 = "477_1303748459.273" 
    $P7028."add_method"(type_obj, "variable", $P7029)
    get_how $P7030, type_obj
    .const 'Sub' $P7031 = "480_1303748459.273" 
    $P7030."add_method"(type_obj, "package_declarator:sym<module>", $P7031)
    get_how $P7032, type_obj
    .const 'Sub' $P7033 = "481_1303748459.273" 
    $P7032."add_method"(type_obj, "package_declarator:sym<knowhow>", $P7033)
    get_how $P7034, type_obj
    .const 'Sub' $P7035 = "482_1303748459.273" 
    $P7034."add_method"(type_obj, "package_declarator:sym<class>", $P7035)
    get_how $P7036, type_obj
    .const 'Sub' $P7037 = "483_1303748459.273" 
    $P7036."add_method"(type_obj, "package_declarator:sym<grammar>", $P7037)
    get_how $P7038, type_obj
    .const 'Sub' $P7039 = "484_1303748459.273" 
    $P7038."add_method"(type_obj, "package_declarator:sym<role>", $P7039)
    get_how $P7040, type_obj
    .const 'Sub' $P7041 = "485_1303748459.273" 
    $P7040."add_method"(type_obj, "package_declarator:sym<native>", $P7041)
    get_how $P7042, type_obj
    .const 'Sub' $P7043 = "486_1303748459.273" 
    $P7042."add_method"(type_obj, "package_def", $P7043)
    get_how $P7044, type_obj
    .const 'Sub' $P7045 = "490_1303748459.273" 
    $P7044."add_method"(type_obj, "scope_declarator:sym<my>", $P7045)
    get_how $P7046, type_obj
    .const 'Sub' $P7047 = "491_1303748459.273" 
    $P7046."add_method"(type_obj, "scope_declarator:sym<our>", $P7047)
    get_how $P7048, type_obj
    .const 'Sub' $P7049 = "492_1303748459.273" 
    $P7048."add_method"(type_obj, "scope_declarator:sym<has>", $P7049)
    get_how $P7050, type_obj
    .const 'Sub' $P7051 = "493_1303748459.273" 
    $P7050."add_method"(type_obj, "scoped", $P7051)
    get_how $P7052, type_obj
    .const 'Sub' $P7053 = "494_1303748459.273" 
    $P7052."add_method"(type_obj, "declarator", $P7053)
    get_how $P7054, type_obj
    .const 'Sub' $P7055 = "495_1303748459.273" 
    $P7054."add_method"(type_obj, "multi_declarator:sym<multi>", $P7055)
    get_how $P7056, type_obj
    .const 'Sub' $P7057 = "496_1303748459.273" 
    $P7056."add_method"(type_obj, "multi_declarator:sym<proto>", $P7057)
    get_how $P7058, type_obj
    .const 'Sub' $P7059 = "497_1303748459.273" 
    $P7058."add_method"(type_obj, "multi_declarator:sym<null>", $P7059)
    get_how $P7060, type_obj
    .const 'Sub' $P7061 = "498_1303748459.273" 
    $P7060."add_method"(type_obj, "variable_declarator", $P7061)
    get_how $P7062, type_obj
    .const 'Sub' $P7063 = "501_1303748459.273" 
    $P7062."add_method"(type_obj, "routine_declarator:sym<sub>", $P7063)
    get_how $P7064, type_obj
    .const 'Sub' $P7065 = "502_1303748459.273" 
    $P7064."add_method"(type_obj, "routine_declarator:sym<method>", $P7065)
    get_how $P7066, type_obj
    .const 'Sub' $P7067 = "503_1303748459.273" 
    $P7066."add_method"(type_obj, "routine_def", $P7067)
    get_how $P7068, type_obj
    .const 'Sub' $P7069 = "510_1303748459.273" 
    $P7068."add_method"(type_obj, "method_def", $P7069)
    get_how $P7070, type_obj
    .const 'Sub' $P7071 = "513_1303748459.273" 
    $P7070."add_method"(type_obj, "signature", $P7071)
    get_how $P7072, type_obj
    .const 'Sub' $P7073 = "516_1303748459.273" 
    $P7072."add_method"(type_obj, "parameter", $P7073)
    get_how $P7074, type_obj
    .const 'Sub' $P7075 = "517_1303748459.273" 
    $P7074."add_method"(type_obj, "param_var", $P7075)
    get_how $P7076, type_obj
    .const 'Sub' $P7077 = "518_1303748459.273" 
    $P7076."add_method"(type_obj, "named_param", $P7077)
    get_how $P7078, type_obj
    .const 'Sub' $P7079 = "519_1303748459.273" 
    $P7078."add_method"(type_obj, "typename", $P7079)
    get_how $P7080, type_obj
    .const 'Sub' $P7081 = "520_1303748459.273" 
    $P7080."add_method"(type_obj, "trait", $P7081)
    get_how $P7082, type_obj
    .const 'Sub' $P7083 = "521_1303748459.273" 
    $P7082."add_method"(type_obj, "trait_mod:sym<is>", $P7083)
    get_how $P7084, type_obj
    .const 'Sub' $P7085 = "523_1303748459.273" 
    $P7084."add_method"(type_obj, "regex_declarator", $P7085)
    get_how $P7086, type_obj
    .const 'Sub' $P7087 = "527_1303748459.273" 
    $P7086."add_method"(type_obj, "dotty", $P7087)
    get_how $P7088, type_obj
    .const 'Sub' $P7089 = "528_1303748459.273" 
    $P7088."add_method"(type_obj, "term:sym<self>", $P7089)
    get_how $P7090, type_obj
    .const 'Sub' $P7091 = "529_1303748459.273" 
    $P7090."add_method"(type_obj, "term:sym<identifier>", $P7091)
    get_how $P7092, type_obj
    .const 'Sub' $P7093 = "530_1303748459.273" 
    $P7092."add_method"(type_obj, "term:sym<name>", $P7093)
    get_how $P7094, type_obj
    .const 'Sub' $P7095 = "532_1303748459.273" 
    $P7094."add_method"(type_obj, "term:sym<pir::op>", $P7095)
    get_how $P7096, type_obj
    .const 'Sub' $P7097 = "533_1303748459.273" 
    $P7096."add_method"(type_obj, "term:sym<onlystar>", $P7097)
    get_how $P7098, type_obj
    .const 'Sub' $P7099 = "534_1303748459.273" 
    $P7098."add_method"(type_obj, "args", $P7099)
    get_how $P7100, type_obj
    .const 'Sub' $P7101 = "535_1303748459.273" 
    $P7100."add_method"(type_obj, "arglist", $P7101)
    get_how $P7102, type_obj
    .const 'Sub' $P7103 = "538_1303748459.273" 
    $P7102."add_method"(type_obj, "term:sym<multi_declarator>", $P7103)
    get_how $P7104, type_obj
    .const 'Sub' $P7105 = "539_1303748459.273" 
    $P7104."add_method"(type_obj, "term:sym<value>", $P7105)
    get_how $P7106, type_obj
    .const 'Sub' $P7107 = "540_1303748459.273" 
    $P7106."add_method"(type_obj, "circumfix:sym<( )>", $P7107)
    get_how $P7108, type_obj
    .const 'Sub' $P7109 = "541_1303748459.273" 
    $P7108."add_method"(type_obj, "circumfix:sym<[ ]>", $P7109)
    get_how $P7110, type_obj
    .const 'Sub' $P7111 = "542_1303748459.273" 
    $P7110."add_method"(type_obj, "circumfix:sym<ang>", $P7111)
    get_how $P7112, type_obj
    .const 'Sub' $P7113 = "543_1303748459.273" 
    $P7112."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P7113)
    get_how $P7114, type_obj
    .const 'Sub' $P7115 = "544_1303748459.273" 
    $P7114."add_method"(type_obj, "circumfix:sym<{ }>", $P7115)
    get_how $P7116, type_obj
    .const 'Sub' $P7117 = "546_1303748459.273" 
    $P7116."add_method"(type_obj, "circumfix:sym<sigil>", $P7117)
    get_how $P7118, type_obj
    .const 'Sub' $P7119 = "547_1303748459.273" 
    $P7118."add_method"(type_obj, "semilist", $P7119)
    get_how $P7120, type_obj
    .const 'Sub' $P7121 = "548_1303748459.273" 
    $P7120."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P7121)
    get_how $P7122, type_obj
    .const 'Sub' $P7123 = "549_1303748459.273" 
    $P7122."add_method"(type_obj, "postcircumfix:sym<{ }>", $P7123)
    get_how $P7124, type_obj
    .const 'Sub' $P7125 = "550_1303748459.273" 
    $P7124."add_method"(type_obj, "postcircumfix:sym<ang>", $P7125)
    get_how $P7126, type_obj
    .const 'Sub' $P7127 = "551_1303748459.273" 
    $P7126."add_method"(type_obj, "postcircumfix:sym<( )>", $P7127)
    get_how $P7128, type_obj
    .const 'Sub' $P7129 = "552_1303748459.273" 
    $P7128."add_method"(type_obj, "value", $P7129)
    get_how $P7130, type_obj
    .const 'Sub' $P7131 = "553_1303748459.273" 
    $P7130."add_method"(type_obj, "number", $P7131)
    get_how $P7132, type_obj
    .const 'Sub' $P7133 = "554_1303748459.273" 
    $P7132."add_method"(type_obj, "quote:sym<apos>", $P7133)
    get_how $P7134, type_obj
    .const 'Sub' $P7135 = "555_1303748459.273" 
    $P7134."add_method"(type_obj, "quote:sym<dblq>", $P7135)
    get_how $P7136, type_obj
    .const 'Sub' $P7137 = "556_1303748459.273" 
    $P7136."add_method"(type_obj, "quote:sym<qq>", $P7137)
    get_how $P7138, type_obj
    .const 'Sub' $P7139 = "557_1303748459.273" 
    $P7138."add_method"(type_obj, "quote:sym<q>", $P7139)
    get_how $P7140, type_obj
    .const 'Sub' $P7141 = "558_1303748459.273" 
    $P7140."add_method"(type_obj, "quote:sym<Q>", $P7141)
    get_how $P7142, type_obj
    .const 'Sub' $P7143 = "559_1303748459.273" 
    $P7142."add_method"(type_obj, "quote:sym<Q:PIR>", $P7143)
    get_how $P7144, type_obj
    .const 'Sub' $P7145 = "560_1303748459.273" 
    $P7144."add_method"(type_obj, "quote:sym</ />", $P7145)
    get_how $P7146, type_obj
    .const 'Sub' $P7147 = "561_1303748459.273" 
    $P7146."add_method"(type_obj, "quote_escape:sym<$>", $P7147)
    get_how $P7148, type_obj
    .const 'Sub' $P7149 = "562_1303748459.273" 
    $P7148."add_method"(type_obj, "quote_escape:sym<{ }>", $P7149)
    get_how $P7150, type_obj
    .const 'Sub' $P7151 = "563_1303748459.273" 
    $P7150."add_method"(type_obj, "quote_escape:sym<esc>", $P7151)
    get_how $P7152, type_obj
    .const 'Sub' $P7153 = "564_1303748459.273" 
    $P7152."add_method"(type_obj, "postfix:sym<.>", $P7153)
    get_how $P7154, type_obj
    .const 'Sub' $P7155 = "565_1303748459.273" 
    $P7154."add_method"(type_obj, "postfix:sym<++>", $P7155)
    get_how $P7156, type_obj
    .const 'Sub' $P7157 = "566_1303748459.273" 
    $P7156."add_method"(type_obj, "postfix:sym<-->", $P7157)
    get_how $P7158, type_obj
    .const 'Sub' $P7159 = "567_1303748459.273" 
    $P7158."add_method"(type_obj, "prefix:sym<make>", $P7159)
    get_how $P7160, type_obj
    .const 'Sub' $P7161 = "568_1303748459.273" 
    $P7160."add_method"(type_obj, "term:sym<next>", $P7161)
    get_how $P7162, type_obj
    .const 'Sub' $P7163 = "569_1303748459.273" 
    $P7162."add_method"(type_obj, "term:sym<last>", $P7163)
    get_how $P7164, type_obj
    .const 'Sub' $P7165 = "570_1303748459.273" 
    $P7164."add_method"(type_obj, "term:sym<redo>", $P7165)
    get_how $P7166, type_obj
    .const 'Sub' $P7167 = "571_1303748459.273" 
    $P7166."add_method"(type_obj, "infix:sym<~~>", $P7167)
    get_how $P7168, type_obj
    $P7169 = $P7168."compose"(type_obj)
    .return ($P7169)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("407_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_2755
.annotate 'line', 771
    .lex "$xblock", param_2755
.annotate 'line', 772
    find_lex $P2756, "$xblock"
    unless_null $P2756, vivify_1457
    $P2756 = root_new ['parrot';'ResizablePMCArray']
  vivify_1457:
    set $P2757, $P2756[1]
    unless_null $P2757, vivify_1458
    new $P2757, "Undef"
  vivify_1458:
    $P2758 = "block_immediate"($P2757)
    find_lex $P2759, "$xblock"
    unless_null $P2759, vivify_1459
    $P2759 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2759
  vivify_1459:
    set $P2759[1], $P2758
    find_lex $P2760, "$xblock"
    unless_null $P2760, vivify_1460
    new $P2760, "Undef"
  vivify_1460:
.annotate 'line', 771
    .return ($P2760)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("408_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_2763
.annotate 'line', 776
    .const 'Sub' $P2773 = "409_1303748459.273" 
    capture_lex $P2773
    .lex "$block", param_2763
.annotate 'line', 777
    find_lex $P2764, "$block"
    unless_null $P2764, vivify_1461
    new $P2764, "Undef"
  vivify_1461:
    $P2764."blocktype"("immediate")
.annotate 'line', 778
    find_lex $P2768, "$block"
    unless_null $P2768, vivify_1462
    new $P2768, "Undef"
  vivify_1462:
    $P2769 = $P2768."symtable"()
    unless $P2769, unless_2767
    set $P2766, $P2769
    goto unless_2767_end
  unless_2767:
    find_lex $P2770, "$block"
    unless_null $P2770, vivify_1463
    new $P2770, "Undef"
  vivify_1463:
    $P2771 = $P2770."handlers"()
    set $P2766, $P2771
  unless_2767_end:
    if $P2766, unless_2765_end
    .const 'Sub' $P2773 = "409_1303748459.273" 
    capture_lex $P2773
    $P2773()
  unless_2765_end:
    find_lex $P2796, "$block"
    unless_null $P2796, vivify_1470
    new $P2796, "Undef"
  vivify_1470:
.annotate 'line', 776
    .return ($P2796)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2772"  :anon :subid("409_1303748459.273") :outer("408_1303748459.273")
.annotate 'line', 778
    .const 'Sub' $P2787 = "410_1303748459.273" 
    capture_lex $P2787
.annotate 'line', 779
    new $P2774, "Undef"
    .lex "$stmts", $P2774
    get_hll_global $P2775, "GLOBAL"
    nqp_get_package_through_who $P2776, $P2775, "PAST"
    get_who $P2777, $P2776
    set $P2778, $P2777["Stmts"]
    find_lex $P2779, "$block"
    unless_null $P2779, vivify_1464
    new $P2779, "Undef"
  vivify_1464:
    $P2780 = $P2778."new"($P2779 :named("node"))
    store_lex "$stmts", $P2780
.annotate 'line', 780
    find_lex $P2782, "$block"
    unless_null $P2782, vivify_1465
    new $P2782, "Undef"
  vivify_1465:
    $P2783 = $P2782."list"()
    defined $I2784, $P2783
    unless $I2784, for_undef_1466
    iter $P2781, $P2783
    new $P2793, 'ExceptionHandler'
    set_label $P2793, loop2792_handler
    $P2793."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2793
  loop2792_test:
    unless $P2781, loop2792_done
    shift $P2785, $P2781
  loop2792_redo:
    .const 'Sub' $P2787 = "410_1303748459.273" 
    capture_lex $P2787
    $P2787($P2785)
  loop2792_next:
    goto loop2792_test
  loop2792_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2794, exception, 'type'
    eq $P2794, .CONTROL_LOOP_NEXT, loop2792_next
    eq $P2794, .CONTROL_LOOP_REDO, loop2792_redo
  loop2792_done:
    pop_eh 
  for_undef_1466:
.annotate 'line', 781
    find_lex $P2795, "$stmts"
    unless_null $P2795, vivify_1469
    new $P2795, "Undef"
  vivify_1469:
    store_lex "$block", $P2795
.annotate 'line', 778
    .return ($P2795)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2786"  :anon :subid("410_1303748459.273") :outer("409_1303748459.273")
    .param pmc param_2788
.annotate 'line', 780
    .lex "$_", param_2788
    find_lex $P2789, "$stmts"
    unless_null $P2789, vivify_1467
    new $P2789, "Undef"
  vivify_1467:
    find_lex $P2790, "$_"
    unless_null $P2790, vivify_1468
    new $P2790, "Undef"
  vivify_1468:
    $P2791 = $P2789."push"($P2790)
    .return ($P2791)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("411_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_2799
.annotate 'line', 786
    .lex "$sigil", param_2799
.annotate 'line', 787
    find_lex $P2802, "$sigil"
    unless_null $P2802, vivify_1471
    new $P2802, "Undef"
  vivify_1471:
    set $S2803, $P2802
    iseq $I2804, $S2803, "%"
    if $I2804, if_2801
.annotate 'line', 789
    find_lex $P2812, "$sigil"
    unless_null $P2812, vivify_1472
    new $P2812, "Undef"
  vivify_1472:
    set $S2813, $P2812
    iseq $I2814, $S2813, "@"
    if $I2814, if_2811
    new $P2820, "String"
    assign $P2820, "Undef"
    set $P2810, $P2820
    goto if_2811_end
  if_2811:
.annotate 'line', 790
    get_hll_global $P2815, "GLOBAL"
    nqp_get_package_through_who $P2816, $P2815, "PAST"
    get_who $P2817, $P2816
    set $P2818, $P2817["Op"]
    $P2819 = $P2818."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2810, $P2819
  if_2811_end:
    set $P2800, $P2810
.annotate 'line', 787
    goto if_2801_end
  if_2801:
.annotate 'line', 788
    get_hll_global $P2805, "GLOBAL"
    nqp_get_package_through_who $P2806, $P2805, "PAST"
    get_who $P2807, $P2806
    set $P2808, $P2807["Op"]
    $P2809 = $P2808."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2800, $P2809
  if_2801_end:
.annotate 'line', 786
    .return ($P2800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("412_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_2823
.annotate 'line', 805
    .lex "$ast", param_2823
.annotate 'line', 806
    get_hll_global $P2826, "GLOBAL"
    nqp_get_package_through_who $P2827, $P2826, "PAST"
    get_who $P2828, $P2827
    set $P2829, $P2828["Op"]
    find_lex $P2830, "$ast"
    unless_null $P2830, vivify_1473
    new $P2830, "Undef"
  vivify_1473:
    $P2831 = $P2829."ACCEPTS"($P2830)
    if $P2831, if_2825
.annotate 'line', 808
    find_lex $P2835, "$ast"
    unless_null $P2835, vivify_1474
    new $P2835, "Undef"
  vivify_1474:
    $P2836 = $P2835."value"()
    set $P2824, $P2836
.annotate 'line', 806
    goto if_2825_end
  if_2825:
.annotate 'line', 807
    find_lex $P2832, "$ast"
    unless_null $P2832, vivify_1475
    new $P2832, "Undef"
  vivify_1475:
    $P2833 = $P2832."list"()
    join $S2834, " ", $P2833
    new $P2824, 'String'
    set $P2824, $S2834
  if_2825_end:
.annotate 'line', 805
    .return ($P2824)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("413_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_2839
.annotate 'line', 967
    .const 'Sub' $P2851 = "414_1303748459.273" 
    capture_lex $P2851
    .lex "$UNIT", param_2839
.annotate 'line', 969
    find_lex $P2842, "$UNIT"
    unless_null $P2842, vivify_1476
    new $P2842, "Undef"
  vivify_1476:
    exists $I2843, $P2842["EXPORTHOW"]
    if $I2843, if_2841
    new $P2840, 'Integer'
    set $P2840, $I2843
    goto if_2841_end
  if_2841:
.annotate 'line', 970
    find_lex $P2845, "$UNIT"
    unless_null $P2845, vivify_1477
    $P2845 = root_new ['parrot';'Hash']
  vivify_1477:
    set $P2846, $P2845["EXPORTHOW"]
    unless_null $P2846, vivify_1478
    new $P2846, "Undef"
  vivify_1478:
    get_who $P2847, $P2846
    defined $I2848, $P2847
    unless $I2848, for_undef_1479
    iter $P2844, $P2847
    new $P2861, 'ExceptionHandler'
    set_label $P2861, loop2860_handler
    $P2861."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2861
  loop2860_test:
    unless $P2844, loop2860_done
    shift $P2849, $P2844
  loop2860_redo:
    .const 'Sub' $P2851 = "414_1303748459.273" 
    capture_lex $P2851
    $P2851($P2849)
  loop2860_next:
    goto loop2860_test
  loop2860_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2862, exception, 'type'
    eq $P2862, .CONTROL_LOOP_NEXT, loop2860_next
    eq $P2862, .CONTROL_LOOP_REDO, loop2860_redo
  loop2860_done:
    pop_eh 
  for_undef_1479:
.annotate 'line', 969
    set $P2840, $P2844
  if_2841_end:
.annotate 'line', 967
    .return ($P2840)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2850"  :anon :subid("414_1303748459.273") :outer("413_1303748459.273")
    .param pmc param_2852
.annotate 'line', 970
    .lex "$_", param_2852
.annotate 'line', 971
    find_lex $P2853, "$_"
    unless_null $P2853, vivify_1480
    new $P2853, "Undef"
  vivify_1480:
    $P2854 = $P2853."value"()
    find_lex $P2855, "$_"
    unless_null $P2855, vivify_1481
    new $P2855, "Undef"
  vivify_1481:
    $P2856 = $P2855."key"()
    find_dynamic_lex $P2859, "%*HOW"
    unless_null $P2859, vivify_1482
    get_hll_global $P2857, "GLOBAL"
    get_who $P2858, $P2857
    set $P2859, $P2858["%HOW"]
    unless_null $P2859, vivify_1483
    die "Contextual %*HOW not found"
  vivify_1483:
    store_dynamic_lex "%*HOW", $P2859
  vivify_1482:
    set $P2859[$P2856], $P2854
.annotate 'line', 970
    .return ($P2854)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("415_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_2865
    .param pmc param_2866
.annotate 'line', 1072
    .lex "$/", param_2865
    .lex "$block", param_2866
.annotate 'line', 1073
    find_lex $P2868, "$?PACKAGE"
    get_who $P2869, $P2868
    set $P2870, $P2869["@BLOCK"]
    unless_null $P2870, vivify_1484
    $P2870 = root_new ['parrot';'ResizablePMCArray']
  vivify_1484:
    set $P2871, $P2870[0]
    unless_null $P2871, vivify_1485
    new $P2871, "Undef"
  vivify_1485:
    $P2872 = $P2871."handlers"()
    if $P2872, unless_2867_end
.annotate 'line', 1074
    find_lex $P2873, "$?PACKAGE"
    get_who $P2874, $P2873
    set $P2875, $P2874["@BLOCK"]
    unless_null $P2875, vivify_1486
    $P2875 = root_new ['parrot';'ResizablePMCArray']
  vivify_1486:
    set $P2876, $P2875[0]
    unless_null $P2876, vivify_1487
    new $P2876, "Undef"
  vivify_1487:
    new $P2877, "ResizablePMCArray"
    $P2876."handlers"($P2877)
  unless_2867_end:
.annotate 'line', 1076
    find_lex $P2879, "$block"
    unless_null $P2879, vivify_1488
    new $P2879, "Undef"
  vivify_1488:
    $P2880 = $P2879."arity"()
    if $P2880, unless_2878_end
.annotate 'line', 1077
    find_lex $P2881, "$block"
    unless_null $P2881, vivify_1489
    new $P2881, "Undef"
  vivify_1489:
.annotate 'line', 1078
    get_hll_global $P2882, "GLOBAL"
    nqp_get_package_through_who $P2883, $P2882, "PAST"
    get_who $P2884, $P2883
    set $P2885, $P2884["Op"]
.annotate 'line', 1079
    get_hll_global $P2886, "GLOBAL"
    nqp_get_package_through_who $P2887, $P2886, "PAST"
    get_who $P2888, $P2887
    set $P2889, $P2888["Var"]
    $P2890 = $P2889."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1080
    get_hll_global $P2891, "GLOBAL"
    nqp_get_package_through_who $P2892, $P2891, "PAST"
    get_who $P2893, $P2892
    set $P2894, $P2893["Var"]
    $P2895 = $P2894."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2896 = $P2885."new"($P2890, $P2895, "bind" :named("pasttype"))
.annotate 'line', 1078
    $P2881."unshift"($P2896)
.annotate 'line', 1083
    find_lex $P2897, "$block"
    unless_null $P2897, vivify_1490
    new $P2897, "Undef"
  vivify_1490:
    get_hll_global $P2898, "GLOBAL"
    nqp_get_package_through_who $P2899, $P2898, "PAST"
    get_who $P2900, $P2899
    set $P2901, $P2900["Var"]
    $P2902 = $P2901."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2897."unshift"($P2902)
.annotate 'line', 1084
    find_lex $P2903, "$block"
    unless_null $P2903, vivify_1491
    new $P2903, "Undef"
  vivify_1491:
    $P2903."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1085
    find_lex $P2904, "$block"
    unless_null $P2904, vivify_1492
    new $P2904, "Undef"
  vivify_1492:
    $P2904."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1086
    find_lex $P2905, "$block"
    unless_null $P2905, vivify_1493
    new $P2905, "Undef"
  vivify_1493:
    $P2905."arity"(1)
  unless_2878_end:
.annotate 'line', 1088
    find_lex $P2906, "$block"
    unless_null $P2906, vivify_1494
    new $P2906, "Undef"
  vivify_1494:
    $P2906."blocktype"("declaration")
.annotate 'line', 1089
    find_lex $P2907, "$?PACKAGE"
    get_who $P2908, $P2907
    set $P2909, $P2908["@BLOCK"]
    unless_null $P2909, vivify_1495
    $P2909 = root_new ['parrot';'ResizablePMCArray']
  vivify_1495:
    set $P2910, $P2909[0]
    unless_null $P2910, vivify_1496
    new $P2910, "Undef"
  vivify_1496:
    $P2911 = $P2910."handlers"()
.annotate 'line', 1090
    get_hll_global $P2912, "GLOBAL"
    nqp_get_package_through_who $P2913, $P2912, "PAST"
    get_who $P2914, $P2913
    set $P2915, $P2914["Control"]
    find_lex $P2916, "$/"
    unless_null $P2916, vivify_1497
    new $P2916, "Undef"
  vivify_1497:
.annotate 'line', 1092
    get_hll_global $P2917, "GLOBAL"
    nqp_get_package_through_who $P2918, $P2917, "PAST"
    get_who $P2919, $P2918
    set $P2920, $P2919["Stmts"]
.annotate 'line', 1093
    get_hll_global $P2921, "GLOBAL"
    nqp_get_package_through_who $P2922, $P2921, "PAST"
    get_who $P2923, $P2922
    set $P2924, $P2923["Op"]
    find_lex $P2925, "$block"
    unless_null $P2925, vivify_1498
    new $P2925, "Undef"
  vivify_1498:
.annotate 'line', 1095
    get_hll_global $P2926, "GLOBAL"
    nqp_get_package_through_who $P2927, $P2926, "PAST"
    get_who $P2928, $P2927
    set $P2929, $P2928["Var"]
    $P2930 = $P2929."new"("register" :named("scope"), "exception" :named("name"))
    $P2931 = $P2924."new"($P2925, $P2930, "call" :named("pasttype"))
.annotate 'line', 1097
    get_hll_global $P2932, "GLOBAL"
    nqp_get_package_through_who $P2933, $P2932, "PAST"
    get_who $P2934, $P2933
    set $P2935, $P2934["Op"]
.annotate 'line', 1098
    get_hll_global $P2936, "GLOBAL"
    nqp_get_package_through_who $P2937, $P2936, "PAST"
    get_who $P2938, $P2937
    set $P2939, $P2938["Var"]
.annotate 'line', 1099
    get_hll_global $P2940, "GLOBAL"
    nqp_get_package_through_who $P2941, $P2940, "PAST"
    get_who $P2942, $P2941
    set $P2943, $P2942["Var"]
    $P2944 = $P2943."new"("register" :named("scope"), "exception" :named("name"))
    $P2945 = $P2939."new"($P2944, "handled", "keyed" :named("scope"))
.annotate 'line', 1098
    $P2946 = $P2935."new"($P2945, 1, "bind" :named("pasttype"))
.annotate 'line', 1097
    $P2947 = $P2920."new"($P2931, $P2946)
.annotate 'line', 1092
    $P2948 = $P2915."new"($P2947, $P2916 :named("node"))
.annotate 'line', 1090
    $P2949 = $P2911."unshift"($P2948)
.annotate 'line', 1072
    .return ($P2949)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("416_1303748459.273") :outer("406_1303748459.273")
.annotate 'line', 1637
    new $P2952, "Undef"
    .lex "$past", $P2952
    find_lex $P2953, "$?PACKAGE"
    get_who $P2954, $P2953
    set $P2955, $P2954["@BLOCK"]
    unless_null $P2955, vivify_1499
    $P2955 = root_new ['parrot';'ResizablePMCArray']
  vivify_1499:
    $P2956 = $P2955."shift"()
    store_lex "$past", $P2956
.annotate 'line', 1638
    find_lex $P2957, "$past"
    unless_null $P2957, vivify_1500
    new $P2957, "Undef"
  vivify_1500:
    $P2957."closure"(1)
.annotate 'line', 1639
    find_lex $P2958, "$past"
    unless_null $P2958, vivify_1501
    new $P2958, "Undef"
  vivify_1501:
    get_hll_global $P2959, "GLOBAL"
    nqp_get_package_through_who $P2960, $P2959, "PAST"
    get_who $P2961, $P2960
    set $P2962, $P2961["Op"]
    $P2963 = $P2962."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2958."push"($P2963)
    find_lex $P2964, "$past"
    unless_null $P2964, vivify_1502
    new $P2964, "Undef"
  vivify_1502:
.annotate 'line', 1636
    .return ($P2964)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("417_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_2967
.annotate 'line', 1645
    .const 'Sub' $P2987 = "418_1303748459.273" 
    capture_lex $P2987
    .lex "$routine", param_2967
.annotate 'line', 1649
    new $P2968, "Undef"
    .lex "$types", $P2968
.annotate 'line', 1650
    new $P2969, "Undef"
    .lex "$definednesses", $P2969
.annotate 'line', 1649
    get_hll_global $P2970, "GLOBAL"
    nqp_get_package_through_who $P2971, $P2970, "PAST"
    get_who $P2972, $P2971
    set $P2973, $P2972["Op"]
    $P2974 = $P2973."new"("list" :named("pasttype"))
    store_lex "$types", $P2974
.annotate 'line', 1650
    get_hll_global $P2975, "GLOBAL"
    nqp_get_package_through_who $P2976, $P2975, "PAST"
    get_who $P2977, $P2976
    set $P2978, $P2977["Op"]
    $P2979 = $P2978."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2979
.annotate 'line', 1651
    find_lex $P2981, "$routine"
    unless_null $P2981, vivify_1503
    $P2981 = root_new ['parrot';'ResizablePMCArray']
  vivify_1503:
    set $P2982, $P2981[0]
    unless_null $P2982, vivify_1504
    new $P2982, "Undef"
  vivify_1504:
    $P2983 = $P2982."list"()
    defined $I2984, $P2983
    unless $I2984, for_undef_1505
    iter $P2980, $P2983
    new $P3031, 'ExceptionHandler'
    set_label $P3031, loop3030_handler
    $P3031."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3031
  loop3030_test:
    unless $P2980, loop3030_done
    shift $P2985, $P2980
  loop3030_redo:
    .const 'Sub' $P2987 = "418_1303748459.273" 
    capture_lex $P2987
    $P2987($P2985)
  loop3030_next:
    goto loop3030_test
  loop3030_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3032, exception, 'type'
    eq $P3032, .CONTROL_LOOP_NEXT, loop3030_next
    eq $P3032, .CONTROL_LOOP_REDO, loop3030_redo
  loop3030_done:
    pop_eh 
  for_undef_1505:
.annotate 'line', 1658
    find_lex $P3033, "$routine"
    unless_null $P3033, vivify_1515
    new $P3033, "Undef"
  vivify_1515:
    $P3034 = $P3033."loadinit"()
    get_hll_global $P3035, "GLOBAL"
    nqp_get_package_through_who $P3036, $P3035, "PAST"
    get_who $P3037, $P3036
    set $P3038, $P3037["Op"]
.annotate 'line', 1659
    get_hll_global $P3039, "GLOBAL"
    nqp_get_package_through_who $P3040, $P3039, "PAST"
    get_who $P3041, $P3040
    set $P3042, $P3041["Var"]
    $P3043 = $P3042."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P3044, "$types"
    unless_null $P3044, vivify_1516
    new $P3044, "Undef"
  vivify_1516:
    find_lex $P3045, "$definednesses"
    unless_null $P3045, vivify_1517
    new $P3045, "Undef"
  vivify_1517:
    $P3046 = $P3038."new"($P3043, $P3044, $P3045, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1658
    $P3047 = $P3034."push"($P3046)
.annotate 'line', 1645
    .return ($P3047)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2986"  :anon :subid("418_1303748459.273") :outer("417_1303748459.273")
    .param pmc param_2988
.annotate 'line', 1651
    .lex "$_", param_2988
.annotate 'line', 1652
    get_hll_global $P2993, "GLOBAL"
    nqp_get_package_through_who $P2994, $P2993, "PAST"
    get_who $P2995, $P2994
    set $P2996, $P2995["Var"]
    find_lex $P2997, "$_"
    unless_null $P2997, vivify_1506
    new $P2997, "Undef"
  vivify_1506:
    $P2998 = $P2996."ACCEPTS"($P2997)
    if $P2998, if_2992
    set $P2991, $P2998
    goto if_2992_end
  if_2992:
    find_lex $P2999, "$_"
    unless_null $P2999, vivify_1507
    new $P2999, "Undef"
  vivify_1507:
    $S3000 = $P2999."scope"()
    iseq $I3001, $S3000, "parameter"
    new $P2991, 'Integer'
    set $P2991, $I3001
  if_2992_end:
    if $P2991, if_2990
    set $P2989, $P2991
    goto if_2990_end
  if_2990:
.annotate 'line', 1653
    find_lex $P3002, "$types"
    unless_null $P3002, vivify_1508
    new $P3002, "Undef"
  vivify_1508:
    find_lex $P3004, "$_"
    unless_null $P3004, vivify_1509
    new $P3004, "Undef"
  vivify_1509:
    $P3005 = $P3004."multitype"()
    set $P3003, $P3005
    defined $I3007, $P3003
    if $I3007, default_3006
    get_hll_global $P3008, "GLOBAL"
    nqp_get_package_through_who $P3009, $P3008, "PAST"
    get_who $P3010, $P3009
    set $P3011, $P3010["Op"]
    $P3012 = $P3011."new"("null P" :named("pirop"))
    set $P3003, $P3012
  default_3006:
    $P3002."push"($P3003)
.annotate 'line', 1654
    find_lex $P3013, "$definednesses"
    unless_null $P3013, vivify_1510
    new $P3013, "Undef"
  vivify_1510:
    find_lex $P3016, "$_"
    unless_null $P3016, vivify_1511
    $P3016 = root_new ['parrot';'Hash']
  vivify_1511:
    set $P3017, $P3016["definedness"]
    unless_null $P3017, vivify_1512
    new $P3017, "Undef"
  vivify_1512:
    set $S3018, $P3017
    iseq $I3019, $S3018, "D"
    if $I3019, if_3015
.annotate 'line', 1655
    find_lex $P3023, "$_"
    unless_null $P3023, vivify_1513
    $P3023 = root_new ['parrot';'Hash']
  vivify_1513:
    set $P3024, $P3023["definedness"]
    unless_null $P3024, vivify_1514
    new $P3024, "Undef"
  vivify_1514:
    set $S3025, $P3024
    iseq $I3026, $S3025, "U"
    if $I3026, if_3022
    new $P3028, "Integer"
    assign $P3028, 0
    set $P3021, $P3028
    goto if_3022_end
  if_3022:
    new $P3027, "Integer"
    assign $P3027, 2
    set $P3021, $P3027
  if_3022_end:
    set $P3014, $P3021
.annotate 'line', 1654
    goto if_3015_end
  if_3015:
    new $P3020, "Integer"
    assign $P3020, 1
    set $P3014, $P3020
  if_3015_end:
    $P3029 = $P3013."push"($P3014)
.annotate 'line', 1652
    set $P2989, $P3029
  if_2990_end:
.annotate 'line', 1651
    .return ($P2989)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("419_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3050
    .param pmc param_3051
.annotate 'line', 2111
    .lex "$/", param_3050
    .lex "$type", param_3051
.annotate 'line', 2112
    find_lex $P3052, "$/"
    get_hll_global $P3053, "GLOBAL"
    nqp_get_package_through_who $P3054, $P3053, "PAST"
    get_who $P3055, $P3054
    set $P3056, $P3055["Op"]
    find_lex $P3057, "$/"
    unless_null $P3057, vivify_1518
    new $P3057, "Undef"
  vivify_1518:
.annotate 'line', 2116
    get_hll_global $P3058, "GLOBAL"
    nqp_get_package_through_who $P3059, $P3058, "PAST"
    get_who $P3060, $P3059
    set $P3061, $P3060["Val"]
    find_lex $P3062, "$type"
    unless_null $P3062, vivify_1519
    new $P3062, "Undef"
  vivify_1519:
    $P3063 = $P3061."new"($P3062 :named("value"), "!except_types" :named("returns"))
    $P3064 = $P3056."new"(0, $P3063, $P3057 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2112
    $P3065 = $P3052."!make"($P3064)
.annotate 'line', 2111
    .return ($P3065)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("420_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3070
    .param pmc param_3071
.annotate 'line', 2130
    .const 'Sub' $P3124 = "421_1303748459.273" 
    capture_lex $P3124
    new $P3069, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3069, control_3068
    push_eh $P3069
    .lex "@name", param_3070
    .lex "$/", param_3071
.annotate 'line', 2136
    new $P3072, "Undef"
    .lex "$final_name", $P3072
.annotate 'line', 2137
    new $P3073, "Undef"
    .lex "$lookup", $P3073
.annotate 'line', 2132
    find_lex $P3075, "@name"
    unless_null $P3075, vivify_1520
    $P3075 = root_new ['parrot';'ResizablePMCArray']
  vivify_1520:
    set $N3076, $P3075
    iseq $I3077, $N3076, 0.0
    unless $I3077, if_3074_end
    find_lex $P3078, "$/"
    unless_null $P3078, vivify_1521
    new $P3078, "Undef"
  vivify_1521:
    $P3079 = $P3078."CURSOR"()
    $P3079."panic"("Cannot compile empty name")
  if_3074_end:
.annotate 'line', 2136
    find_lex $P3080, "@name"
    unless_null $P3080, vivify_1522
    $P3080 = root_new ['parrot';'ResizablePMCArray']
  vivify_1522:
    $P3081 = $P3080."pop"()
    store_lex "$final_name", $P3081
.annotate 'line', 2137
    get_hll_global $P3082, "GLOBAL"
    nqp_get_package_through_who $P3083, $P3082, "PAST"
    get_who $P3084, $P3083
    set $P3085, $P3084["Var"]
    find_lex $P3086, "$final_name"
    unless_null $P3086, vivify_1523
    new $P3086, "Undef"
  vivify_1523:
    set $S3087, $P3086
    $P3088 = $P3085."new"($S3087, "keyed" :named("scope"))
    store_lex "$lookup", $P3088
.annotate 'line', 2141
    find_lex $P3090, "@name"
    unless_null $P3090, vivify_1524
    $P3090 = root_new ['parrot';'ResizablePMCArray']
  vivify_1524:
    set $N3091, $P3090
    iseq $I3092, $N3091, 0.0
    if $I3092, if_3089
.annotate 'line', 2159
    .const 'Sub' $P3124 = "421_1303748459.273" 
    capture_lex $P3124
    $P3124()
    goto if_3089_end
  if_3089:
.annotate 'line', 2142
    find_lex $P3093, "$lookup"
    unless_null $P3093, vivify_1537
    new $P3093, "Undef"
  vivify_1537:
    get_hll_global $P3094, "GLOBAL"
    nqp_get_package_through_who $P3095, $P3094, "PAST"
    get_who $P3096, $P3095
    set $P3097, $P3096["Op"]
.annotate 'line', 2144
    get_hll_global $P3098, "GLOBAL"
    nqp_get_package_through_who $P3099, $P3098, "PAST"
    get_who $P3100, $P3099
    set $P3101, $P3100["Var"]
    $P3102 = $P3101."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P3103 = $P3097."new"($P3102, "get_who PP" :named("pirop"))
.annotate 'line', 2142
    $P3093."unshift"($P3103)
.annotate 'line', 2146
    find_lex $P3104, "$lookup"
    unless_null $P3104, vivify_1538
    new $P3104, "Undef"
  vivify_1538:
    get_hll_global $P3105, "GLOBAL"
    nqp_get_package_through_who $P3106, $P3105, "PAST"
    get_who $P3107, $P3106
    set $P3108, $P3107["Var"]
.annotate 'line', 2148
    get_hll_global $P3109, "GLOBAL"
    nqp_get_package_through_who $P3110, $P3109, "PAST"
    get_who $P3111, $P3110
    set $P3112, $P3111["Op"]
.annotate 'line', 2150
    get_hll_global $P3113, "GLOBAL"
    nqp_get_package_through_who $P3114, $P3113, "PAST"
    get_who $P3115, $P3114
    set $P3116, $P3115["Var"]
    new $P3117, "ResizablePMCArray"
    $P3118 = $P3116."new"("GLOBAL" :named("name"), $P3117 :named("namespace"), "package" :named("scope"))
    $P3119 = $P3112."new"($P3118, "get_who PP" :named("pirop"))
.annotate 'line', 2152
    find_lex $P3120, "$final_name"
    unless_null $P3120, vivify_1539
    new $P3120, "Undef"
  vivify_1539:
    set $S3121, $P3120
    $P3122 = $P3108."new"($P3119, $S3121, "keyed" :named("scope"))
.annotate 'line', 2146
    $P3104."viviself"($P3122)
  if_3089_end:
.annotate 'line', 2174
    new $P3176, "Exception"
    set $P3176['type'], .CONTROL_RETURN
    find_lex $P3177, "$lookup"
    unless_null $P3177, vivify_1540
    new $P3177, "Undef"
  vivify_1540:
    setattribute $P3176, 'payload', $P3177
    throw $P3176
.annotate 'line', 2130
    .return ()
  control_3068:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3178, exception, "payload"
    .return ($P3178)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3123"  :anon :subid("421_1303748459.273") :outer("420_1303748459.273")
.annotate 'line', 2159
    .const 'Sub' $P3155 = "422_1303748459.273" 
    capture_lex $P3155
.annotate 'line', 2160
    new $P3125, "Undef"
    .lex "$path", $P3125
    find_lex $P3128, "@name"
    unless_null $P3128, vivify_1525
    $P3128 = root_new ['parrot';'ResizablePMCArray']
  vivify_1525:
    set $P3129, $P3128[0]
    unless_null $P3129, vivify_1526
    new $P3129, "Undef"
  vivify_1526:
    $P3130 = "is_lexical"($P3129)
    if $P3130, if_3127
.annotate 'line', 2162
    get_hll_global $P3138, "GLOBAL"
    nqp_get_package_through_who $P3139, $P3138, "PAST"
    get_who $P3140, $P3139
    set $P3141, $P3140["Var"]
    new $P3142, "ResizablePMCArray"
    $P3143 = $P3141."new"("GLOBAL" :named("name"), $P3142 :named("namespace"), "package" :named("scope"))
    set $P3126, $P3143
.annotate 'line', 2160
    goto if_3127_end
  if_3127:
.annotate 'line', 2161
    get_hll_global $P3131, "GLOBAL"
    nqp_get_package_through_who $P3132, $P3131, "PAST"
    get_who $P3133, $P3132
    set $P3134, $P3133["Var"]
    find_lex $P3135, "@name"
    unless_null $P3135, vivify_1527
    $P3135 = root_new ['parrot';'ResizablePMCArray']
  vivify_1527:
    $P3136 = $P3135."shift"()
    $P3137 = $P3134."new"($P3136 :named("name"), "lexical" :named("scope"))
    set $P3126, $P3137
  if_3127_end:
.annotate 'line', 2160
    store_lex "$path", $P3126
.annotate 'line', 2163
    find_lex $P3145, "@name"
    unless_null $P3145, vivify_1528
    $P3145 = root_new ['parrot';'ResizablePMCArray']
  vivify_1528:
    set $P3146, $P3145[0]
    unless_null $P3146, vivify_1529
    new $P3146, "Undef"
  vivify_1529:
    set $S3147, $P3146
    iseq $I3148, $S3147, "GLOBAL"
    unless $I3148, if_3144_end
.annotate 'line', 2164
    find_lex $P3149, "@name"
    unless_null $P3149, vivify_1530
    $P3149 = root_new ['parrot';'ResizablePMCArray']
  vivify_1530:
    $P3149."shift"()
  if_3144_end:
.annotate 'line', 2166
    find_lex $P3151, "@name"
    unless_null $P3151, vivify_1531
    $P3151 = root_new ['parrot';'ResizablePMCArray']
  vivify_1531:
    defined $I3152, $P3151
    unless $I3152, for_undef_1532
    iter $P3150, $P3151
    new $P3166, 'ExceptionHandler'
    set_label $P3166, loop3165_handler
    $P3166."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3166
  loop3165_test:
    unless $P3150, loop3165_done
    shift $P3153, $P3150
  loop3165_redo:
    .const 'Sub' $P3155 = "422_1303748459.273" 
    capture_lex $P3155
    $P3155($P3153)
  loop3165_next:
    goto loop3165_test
  loop3165_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3167, exception, 'type'
    eq $P3167, .CONTROL_LOOP_NEXT, loop3165_next
    eq $P3167, .CONTROL_LOOP_REDO, loop3165_redo
  loop3165_done:
    pop_eh 
  for_undef_1532:
.annotate 'line', 2171
    find_lex $P3168, "$lookup"
    unless_null $P3168, vivify_1535
    new $P3168, "Undef"
  vivify_1535:
    get_hll_global $P3169, "GLOBAL"
    nqp_get_package_through_who $P3170, $P3169, "PAST"
    get_who $P3171, $P3170
    set $P3172, $P3171["Op"]
    find_lex $P3173, "$path"
    unless_null $P3173, vivify_1536
    new $P3173, "Undef"
  vivify_1536:
    $P3174 = $P3172."new"($P3173, "get_who PP" :named("pirop"))
    $P3175 = $P3168."unshift"($P3174)
.annotate 'line', 2159
    .return ($P3175)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3154"  :anon :subid("422_1303748459.273") :outer("421_1303748459.273")
    .param pmc param_3156
.annotate 'line', 2166
    .lex "$_", param_3156
.annotate 'line', 2167
    get_hll_global $P3157, "GLOBAL"
    nqp_get_package_through_who $P3158, $P3157, "PAST"
    get_who $P3159, $P3158
    set $P3160, $P3159["Op"]
    find_lex $P3161, "$path"
    unless_null $P3161, vivify_1533
    new $P3161, "Undef"
  vivify_1533:
.annotate 'line', 2169
    find_lex $P3162, "$_"
    unless_null $P3162, vivify_1534
    new $P3162, "Undef"
  vivify_1534:
    set $S3163, $P3162
    $P3164 = $P3160."new"($P3161, $S3163, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2167
    store_lex "$path", $P3164
.annotate 'line', 2166
    .return ($P3164)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("423_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3181
.annotate 'line', 2179
    .lex "$name", param_3181
.annotate 'line', 2180
    find_lex $P3182, "$name"
    unless_null $P3182, vivify_1541
    new $P3182, "Undef"
  vivify_1541:
    $P3183 = "is_scope"($P3182, "lexical")
.annotate 'line', 2179
    .return ($P3183)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("424_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3186
.annotate 'line', 2185
    .lex "$name", param_3186
.annotate 'line', 2186
    find_lex $P3187, "$name"
    unless_null $P3187, vivify_1542
    new $P3187, "Undef"
  vivify_1542:
    $P3188 = "is_scope"($P3187, "package")
.annotate 'line', 2185
    .return ($P3188)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("425_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3193
    .param pmc param_3194
.annotate 'line', 2191
    .const 'Sub' $P3202 = "426_1303748459.273" 
    capture_lex $P3202
    new $P3192, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3192, control_3191
    push_eh $P3192
    .lex "$name", param_3193
    .lex "$wanted_scope", param_3194
.annotate 'line', 2192
    find_lex $P3196, "$?PACKAGE"
    get_who $P3197, $P3196
    set $P3198, $P3197["@BLOCK"]
    unless_null $P3198, vivify_1543
    $P3198 = root_new ['parrot';'ResizablePMCArray']
  vivify_1543:
    defined $I3199, $P3198
    unless $I3199, for_undef_1544
    iter $P3195, $P3198
    new $P3221, 'ExceptionHandler'
    set_label $P3221, loop3220_handler
    $P3221."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3221
  loop3220_test:
    unless $P3195, loop3220_done
    shift $P3200, $P3195
  loop3220_redo:
    .const 'Sub' $P3202 = "426_1303748459.273" 
    capture_lex $P3202
    $P3202($P3200)
  loop3220_next:
    goto loop3220_test
  loop3220_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3222, exception, 'type'
    eq $P3222, .CONTROL_LOOP_NEXT, loop3220_next
    eq $P3222, .CONTROL_LOOP_REDO, loop3220_redo
  loop3220_done:
    pop_eh 
  for_undef_1544:
.annotate 'line', 2191
    .return (0)
  control_3191:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3223, exception, "payload"
    .return ($P3223)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3201"  :anon :subid("426_1303748459.273") :outer("425_1303748459.273")
    .param pmc param_3204
.annotate 'line', 2193
    $P3203 = root_new ['parrot';'Hash']
    .lex "%sym", $P3203
    .lex "$_", param_3204
    find_lex $P3205, "$_"
    unless_null $P3205, vivify_1545
    new $P3205, "Undef"
  vivify_1545:
    find_lex $P3206, "$name"
    unless_null $P3206, vivify_1546
    new $P3206, "Undef"
  vivify_1546:
    $P3207 = $P3205."symbol"($P3206)
    store_lex "%sym", $P3207
.annotate 'line', 2194
    find_lex $P3210, "%sym"
    unless_null $P3210, vivify_1547
    $P3210 = root_new ['parrot';'Hash']
  vivify_1547:
    set $N3211, $P3210
    if $N3211, if_3209
    new $P3208, 'Float'
    set $P3208, $N3211
    goto if_3209_end
  if_3209:
.annotate 'line', 2195
    new $P3212, "Exception"
    set $P3212['type'], .CONTROL_RETURN
    find_lex $P3213, "%sym"
    unless_null $P3213, vivify_1548
    $P3213 = root_new ['parrot';'Hash']
  vivify_1548:
    set $P3214, $P3213["scope"]
    unless_null $P3214, vivify_1549
    new $P3214, "Undef"
  vivify_1549:
    set $S3215, $P3214
    find_lex $P3216, "$wanted_scope"
    unless_null $P3216, vivify_1550
    new $P3216, "Undef"
  vivify_1550:
    set $S3217, $P3216
    iseq $I3218, $S3215, $S3217
    new $P3219, 'Integer'
    set $P3219, $I3218
    setattribute $P3212, 'payload', $P3219
    throw $P3212
  if_3209_end:
.annotate 'line', 2192
    .return ($P3208)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("427_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3228
    .param pmc param_3229
.annotate 'line', 2204
    .const 'Sub' $P3323 = "432_1303748459.273" 
    capture_lex $P3323
    .const 'Sub' $P3283 = "430_1303748459.273" 
    capture_lex $P3283
    .const 'Sub' $P3241 = "428_1303748459.273" 
    capture_lex $P3241
    new $P3227, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3227, control_3226
    push_eh $P3227
    .lex "@name", param_3228
    .lex "$/", param_3229
.annotate 'line', 2228
    new $P3230, "Undef"
    .lex "$result", $P3230
.annotate 'line', 2206
    find_lex $P3232, "@name"
    unless_null $P3232, vivify_1551
    $P3232 = root_new ['parrot';'ResizablePMCArray']
  vivify_1551:
    set $N3233, $P3232
    if $N3233, unless_3231_end
    find_lex $P3234, "$/"
    unless_null $P3234, vivify_1552
    new $P3234, "Undef"
  vivify_1552:
    $P3235 = $P3234."CURSOR"()
    $P3235."panic"("Cannot look up empty name")
  unless_3231_end:
.annotate 'line', 2210
    find_lex $P3237, "@name"
    unless_null $P3237, vivify_1553
    $P3237 = root_new ['parrot';'ResizablePMCArray']
  vivify_1553:
    set $N3238, $P3237
    iseq $I3239, $N3238, 1.0
    unless $I3239, if_3236_end
    .const 'Sub' $P3241 = "428_1303748459.273" 
    capture_lex $P3241
    $P3241()
  if_3236_end:
.annotate 'line', 2228
    find_dynamic_lex $P3277, "$*GLOBALish"
    unless_null $P3277, vivify_1565
    get_hll_global $P3275, "GLOBAL"
    get_who $P3276, $P3275
    set $P3277, $P3276["$GLOBALish"]
    unless_null $P3277, vivify_1566
    die "Contextual $*GLOBALish not found"
  vivify_1566:
  vivify_1565:
    store_lex "$result", $P3277
.annotate 'line', 2229
    find_lex $P3279, "@name"
    unless_null $P3279, vivify_1567
    $P3279 = root_new ['parrot';'ResizablePMCArray']
  vivify_1567:
    set $N3280, $P3279
    isge $I3281, $N3280, 2.0
    unless $I3281, if_3278_end
    .const 'Sub' $P3283 = "430_1303748459.273" 
    capture_lex $P3283
    $P3283()
  if_3278_end:
.annotate 'line', 2247
    find_lex $P3319, "@name"
    unless_null $P3319, vivify_1580
    $P3319 = root_new ['parrot';'ResizablePMCArray']
  vivify_1580:
    defined $I3320, $P3319
    unless $I3320, for_undef_1581
    iter $P3318, $P3319
    new $P3341, 'ExceptionHandler'
    set_label $P3341, loop3340_handler
    $P3341."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3341
  loop3340_test:
    unless $P3318, loop3340_done
    shift $P3321, $P3318
  loop3340_redo:
    .const 'Sub' $P3323 = "432_1303748459.273" 
    capture_lex $P3323
    $P3323($P3321)
  loop3340_next:
    goto loop3340_test
  loop3340_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3342, exception, 'type'
    eq $P3342, .CONTROL_LOOP_NEXT, loop3340_next
    eq $P3342, .CONTROL_LOOP_REDO, loop3340_redo
  loop3340_done:
    pop_eh 
  for_undef_1581:
    find_lex $P3343, "$result"
    unless_null $P3343, vivify_1588
    new $P3343, "Undef"
  vivify_1588:
.annotate 'line', 2204
    .return ($P3343)
  control_3226:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3344, exception, "payload"
    .return ($P3344)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3240"  :anon :subid("428_1303748459.273") :outer("427_1303748459.273")
.annotate 'line', 2210
    .const 'Sub' $P3252 = "429_1303748459.273" 
    capture_lex $P3252
.annotate 'line', 2211
    new $P3242, "Undef"
    .lex "$final_name", $P3242
    find_lex $P3243, "@name"
    unless_null $P3243, vivify_1554
    $P3243 = root_new ['parrot';'ResizablePMCArray']
  vivify_1554:
    set $P3244, $P3243[0]
    unless_null $P3244, vivify_1555
    new $P3244, "Undef"
  vivify_1555:
    store_lex "$final_name", $P3244
.annotate 'line', 2212
    find_lex $P3246, "$?PACKAGE"
    get_who $P3247, $P3246
    set $P3248, $P3247["@BLOCK"]
    unless_null $P3248, vivify_1556
    $P3248 = root_new ['parrot';'ResizablePMCArray']
  vivify_1556:
    defined $I3249, $P3248
    unless $I3249, for_undef_1557
    iter $P3245, $P3248
    new $P3273, 'ExceptionHandler'
    set_label $P3273, loop3272_handler
    $P3273."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3273
  loop3272_test:
    unless $P3245, loop3272_done
    shift $P3250, $P3245
  loop3272_redo:
    .const 'Sub' $P3252 = "429_1303748459.273" 
    capture_lex $P3252
    $P3252($P3250)
  loop3272_next:
    goto loop3272_test
  loop3272_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3274, exception, 'type'
    eq $P3274, .CONTROL_LOOP_NEXT, loop3272_next
    eq $P3274, .CONTROL_LOOP_REDO, loop3272_redo
  loop3272_done:
    pop_eh 
  for_undef_1557:
.annotate 'line', 2210
    .return ($P3245)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3251"  :anon :subid("429_1303748459.273") :outer("428_1303748459.273")
    .param pmc param_3254
.annotate 'line', 2213
    $P3253 = root_new ['parrot';'Hash']
    .lex "%sym", $P3253
    .lex "$_", param_3254
    find_lex $P3255, "$_"
    unless_null $P3255, vivify_1558
    new $P3255, "Undef"
  vivify_1558:
    find_lex $P3256, "$final_name"
    unless_null $P3256, vivify_1559
    new $P3256, "Undef"
  vivify_1559:
    $P3257 = $P3255."symbol"($P3256)
    store_lex "%sym", $P3257
.annotate 'line', 2214
    find_lex $P3260, "%sym"
    unless_null $P3260, vivify_1560
    $P3260 = root_new ['parrot';'Hash']
  vivify_1560:
    set $N3261, $P3260
    if $N3261, if_3259
    new $P3258, 'Float'
    set $P3258, $N3261
    goto if_3259_end
  if_3259:
.annotate 'line', 2215
    find_lex $P3264, "%sym"
    unless_null $P3264, vivify_1561
    $P3264 = root_new ['parrot';'Hash']
  vivify_1561:
    exists $I3265, $P3264["value"]
    if $I3265, if_3263
.annotate 'line', 2219
    new $P3269, 'String'
    set $P3269, "No compile-time value for "
    find_lex $P3270, "$final_name"
    unless_null $P3270, vivify_1562
    new $P3270, "Undef"
  vivify_1562:
    concat $P3271, $P3269, $P3270
    die $P3271
.annotate 'line', 2218
    goto if_3263_end
  if_3263:
.annotate 'line', 2216
    new $P3266, "Exception"
    set $P3266['type'], .CONTROL_RETURN
    find_lex $P3267, "%sym"
    unless_null $P3267, vivify_1563
    $P3267 = root_new ['parrot';'Hash']
  vivify_1563:
    set $P3268, $P3267["value"]
    unless_null $P3268, vivify_1564
    new $P3268, "Undef"
  vivify_1564:
    setattribute $P3266, 'payload', $P3268
    throw $P3266
  if_3263_end:
.annotate 'line', 2214
    set $P3258, $P3262
  if_3259_end:
.annotate 'line', 2212
    .return ($P3258)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3282"  :anon :subid("430_1303748459.273") :outer("427_1303748459.273")
.annotate 'line', 2229
    .const 'Sub' $P3294 = "431_1303748459.273" 
    capture_lex $P3294
.annotate 'line', 2230
    new $P3284, "Undef"
    .lex "$first", $P3284
    find_lex $P3285, "@name"
    unless_null $P3285, vivify_1568
    $P3285 = root_new ['parrot';'ResizablePMCArray']
  vivify_1568:
    set $P3286, $P3285[0]
    unless_null $P3286, vivify_1569
    new $P3286, "Undef"
  vivify_1569:
    store_lex "$first", $P3286
.annotate 'line', 2231
    find_lex $P3288, "$?PACKAGE"
    get_who $P3289, $P3288
    set $P3290, $P3289["@BLOCK"]
    unless_null $P3290, vivify_1570
    $P3290 = root_new ['parrot';'ResizablePMCArray']
  vivify_1570:
    defined $I3291, $P3290
    unless $I3291, for_undef_1571
    iter $P3287, $P3290
    new $P3316, 'ExceptionHandler'
    set_label $P3316, loop3315_handler
    $P3316."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3316
  loop3315_test:
    unless $P3287, loop3315_done
    shift $P3292, $P3287
  loop3315_redo:
    .const 'Sub' $P3294 = "431_1303748459.273" 
    capture_lex $P3294
    $P3294($P3292)
  loop3315_next:
    goto loop3315_test
  loop3315_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3317, exception, 'type'
    eq $P3317, .CONTROL_LOOP_NEXT, loop3315_next
    eq $P3317, .CONTROL_LOOP_REDO, loop3315_redo
  loop3315_done:
    pop_eh 
  for_undef_1571:
.annotate 'line', 2229
    .return ($P3287)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3293"  :anon :subid("431_1303748459.273") :outer("430_1303748459.273")
    .param pmc param_3296
.annotate 'line', 2232
    $P3295 = root_new ['parrot';'Hash']
    .lex "%sym", $P3295
    .lex "$_", param_3296
    find_lex $P3297, "$_"
    unless_null $P3297, vivify_1572
    new $P3297, "Undef"
  vivify_1572:
    find_lex $P3298, "$first"
    unless_null $P3298, vivify_1573
    new $P3298, "Undef"
  vivify_1573:
    $P3299 = $P3297."symbol"($P3298)
    store_lex "%sym", $P3299
.annotate 'line', 2233
    find_lex $P3302, "%sym"
    unless_null $P3302, vivify_1574
    $P3302 = root_new ['parrot';'Hash']
  vivify_1574:
    set $N3303, $P3302
    if $N3303, if_3301
    new $P3300, 'Float'
    set $P3300, $N3303
    goto if_3301_end
  if_3301:
.annotate 'line', 2234
    find_lex $P3306, "%sym"
    unless_null $P3306, vivify_1575
    $P3306 = root_new ['parrot';'Hash']
  vivify_1575:
    exists $I3307, $P3306["value"]
    if $I3307, if_3305
.annotate 'line', 2240
    new $P3312, 'String'
    set $P3312, "No compile-time value for "
    find_lex $P3313, "$first"
    unless_null $P3313, vivify_1576
    new $P3313, "Undef"
  vivify_1576:
    concat $P3314, $P3312, $P3313
    die $P3314
.annotate 'line', 2239
    goto if_3305_end
  if_3305:
.annotate 'line', 2235
    find_lex $P3308, "%sym"
    unless_null $P3308, vivify_1577
    $P3308 = root_new ['parrot';'Hash']
  vivify_1577:
    set $P3309, $P3308["value"]
    unless_null $P3309, vivify_1578
    new $P3309, "Undef"
  vivify_1578:
    store_lex "$result", $P3309
.annotate 'line', 2236
    find_lex $P3310, "@name"
    unless_null $P3310, vivify_1579
    $P3310 = root_new ['parrot';'ResizablePMCArray']
  vivify_1579:
    $P3310."shift"()
.annotate 'line', 2237
    set $I3311, .CONTROL_LOOP_LAST
    die 0, $I3311
  if_3305_end:
.annotate 'line', 2233
    set $P3300, $P3304
  if_3301_end:
.annotate 'line', 2231
    .return ($P3300)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3322"  :anon :subid("432_1303748459.273") :outer("427_1303748459.273")
    .param pmc param_3324
.annotate 'line', 2247
    .lex "$_", param_3324
.annotate 'line', 2248
    find_lex $P3329, "$_"
    unless_null $P3329, vivify_1582
    new $P3329, "Undef"
  vivify_1582:
    set $S3330, $P3329
    find_lex $P3327, "$result"
    unless_null $P3327, vivify_1583
    new $P3327, "Undef"
  vivify_1583:
    get_who $P3328, $P3327
    exists $I3331, $P3328[$S3330]
    if $I3331, if_3326
.annotate 'line', 2252
    new $P3336, "String"
    assign $P3336, "Could not locate compile-time value for symbol "
.annotate 'line', 2253
    find_lex $P3337, "@name"
    unless_null $P3337, vivify_1584
    $P3337 = root_new ['parrot';'ResizablePMCArray']
  vivify_1584:
    join $S3338, "::", $P3337
    concat $P3339, $P3336, $S3338
.annotate 'line', 2252
    die $P3339
.annotate 'line', 2251
    goto if_3326_end
  if_3326:
.annotate 'line', 2249
    find_lex $P3332, "$_"
    unless_null $P3332, vivify_1585
    new $P3332, "Undef"
  vivify_1585:
    find_lex $P3333, "$result"
    unless_null $P3333, vivify_1586
    new $P3333, "Undef"
  vivify_1586:
    get_who $P3334, $P3333
    set $P3335, $P3334[$P3332]
    unless_null $P3335, vivify_1587
    new $P3335, "Undef"
  vivify_1587:
    store_lex "$result", $P3335
.annotate 'line', 2248
    set $P3325, $P3335
  if_3326_end:
.annotate 'line', 2247
    .return ($P3325)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("433_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3355
    .param pmc param_3356
.annotate 'line', 795
    .lex "self", param_3355
    .lex "$/", param_3356
    find_lex $P3357, "$/"
    find_lex $P3358, "$/"
    unless_null $P3358, vivify_1589
    $P3358 = root_new ['parrot';'Hash']
  vivify_1589:
    set $P3359, $P3358["comp_unit"]
    unless_null $P3359, vivify_1590
    new $P3359, "Undef"
  vivify_1590:
    $P3360 = $P3359."ast"()
    $P3361 = $P3357."!make"($P3360)
    .return ($P3361)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("434_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3363
    .param pmc param_3364
.annotate 'line', 797
    .lex "self", param_3363
    .lex "$/", param_3364
.annotate 'line', 798
    find_lex $P3365, "$/"
.annotate 'line', 799
    find_lex $P3368, "$/"
    unless_null $P3368, vivify_1591
    $P3368 = root_new ['parrot';'Hash']
  vivify_1591:
    set $P3369, $P3368["colonpair"]
    unless_null $P3369, vivify_1592
    new $P3369, "Undef"
  vivify_1592:
    if $P3369, if_3367
.annotate 'line', 801
    find_lex $P3389, "$/"
    unless_null $P3389, vivify_1593
    new $P3389, "Undef"
  vivify_1593:
    set $S3390, $P3389
    new $P3366, 'String'
    set $P3366, $S3390
.annotate 'line', 799
    goto if_3367_end
  if_3367:
    find_lex $P3370, "$/"
    unless_null $P3370, vivify_1594
    $P3370 = root_new ['parrot';'Hash']
  vivify_1594:
    set $P3371, $P3370["identifier"]
    unless_null $P3371, vivify_1595
    new $P3371, "Undef"
  vivify_1595:
    set $S3372, $P3371
    new $P3373, 'String'
    set $P3373, $S3372
    concat $P3374, $P3373, ":"
    find_lex $P3375, "$/"
    unless_null $P3375, vivify_1596
    $P3375 = root_new ['parrot';'Hash']
  vivify_1596:
    set $P3376, $P3375["colonpair"]
    unless_null $P3376, vivify_1597
    $P3376 = root_new ['parrot';'ResizablePMCArray']
  vivify_1597:
    set $P3377, $P3376[0]
    unless_null $P3377, vivify_1598
    new $P3377, "Undef"
  vivify_1598:
    $P3378 = $P3377."ast"()
    $S3379 = $P3378."named"()
    concat $P3380, $P3374, $S3379
    concat $P3381, $P3380, "<"
.annotate 'line', 800
    find_lex $P3382, "$/"
    unless_null $P3382, vivify_1599
    $P3382 = root_new ['parrot';'Hash']
  vivify_1599:
    set $P3383, $P3382["colonpair"]
    unless_null $P3383, vivify_1600
    $P3383 = root_new ['parrot';'ResizablePMCArray']
  vivify_1600:
    set $P3384, $P3383[0]
    unless_null $P3384, vivify_1601
    new $P3384, "Undef"
  vivify_1601:
    $P3385 = $P3384."ast"()
    $S3386 = "colonpair_str"($P3385)
    concat $P3387, $P3381, $S3386
    concat $P3388, $P3387, ">"
    set $P3366, $P3388
  if_3367_end:
.annotate 'line', 799
    $P3391 = $P3365."!make"($P3366)
.annotate 'line', 797
    .return ($P3391)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("435_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3394
    .param pmc param_3395
.annotate 'line', 811
    .lex "self", param_3394
    .lex "$/", param_3395
.annotate 'line', 812
    new $P3396, "Undef"
    .lex "$mainline", $P3396
.annotate 'line', 813
    new $P3397, "Undef"
    .lex "$unit", $P3397
.annotate 'line', 812
    find_lex $P3398, "$/"
    unless_null $P3398, vivify_1602
    $P3398 = root_new ['parrot';'Hash']
  vivify_1602:
    set $P3399, $P3398["statementlist"]
    unless_null $P3399, vivify_1603
    new $P3399, "Undef"
  vivify_1603:
    $P3400 = $P3399."ast"()
    store_lex "$mainline", $P3400
.annotate 'line', 813
    find_lex $P3401, "$?PACKAGE"
    get_who $P3402, $P3401
    set $P3403, $P3402["@BLOCK"]
    unless_null $P3403, vivify_1604
    $P3403 = root_new ['parrot';'ResizablePMCArray']
  vivify_1604:
    $P3404 = $P3403."shift"()
    store_lex "$unit", $P3404
.annotate 'line', 817
    find_lex $P3405, "$unit"
    unless_null $P3405, vivify_1605
    new $P3405, "Undef"
  vivify_1605:
    $P3406 = $P3405."loadinit"()
    find_dynamic_lex $P3409, "$*SC"
    unless_null $P3409, vivify_1606
    get_hll_global $P3407, "GLOBAL"
    get_who $P3408, $P3407
    set $P3409, $P3408["$SC"]
    unless_null $P3409, vivify_1607
    die "Contextual $*SC not found"
  vivify_1607:
  vivify_1606:
    $P3410 = $P3409."to_past"()
    $P3406."push"($P3410)
.annotate 'line', 822
    find_lex $P3411, "$unit"
    unless_null $P3411, vivify_1608
    new $P3411, "Undef"
  vivify_1608:
    $P3412 = $P3411."loadinit"()
    get_hll_global $P3413, "GLOBAL"
    nqp_get_package_through_who $P3414, $P3413, "PAST"
    get_who $P3415, $P3414
    set $P3416, $P3415["Op"]
.annotate 'line', 824
    get_hll_global $P3417, "GLOBAL"
    nqp_get_package_through_who $P3418, $P3417, "PAST"
    get_who $P3419, $P3418
    set $P3420, $P3419["Var"]
    new $P3421, "ResizablePMCArray"
    $P3422 = $P3420."new"("GLOBAL" :named("name"), $P3421 :named("namespace"), "package" :named("scope"))
.annotate 'line', 825
    find_dynamic_lex $P3425, "$*SC"
    unless_null $P3425, vivify_1609
    get_hll_global $P3423, "GLOBAL"
    get_who $P3424, $P3423
    set $P3425, $P3424["$SC"]
    unless_null $P3425, vivify_1610
    die "Contextual $*SC not found"
  vivify_1610:
  vivify_1609:
    find_dynamic_lex $P3428, "$*PACKAGE"
    unless_null $P3428, vivify_1611
    get_hll_global $P3426, "GLOBAL"
    get_who $P3427, $P3426
    set $P3428, $P3427["$PACKAGE"]
    unless_null $P3428, vivify_1612
    die "Contextual $*PACKAGE not found"
  vivify_1612:
  vivify_1611:
    $P3429 = $P3425."get_slot_past_for_object"($P3428)
    $P3430 = $P3416."new"($P3422, $P3429, "bind" :named("pasttype"))
.annotate 'line', 822
    $P3412."push"($P3430)
.annotate 'line', 831
    find_dynamic_lex $P3434, "$*HAS_YOU_ARE_HERE"
    unless_null $P3434, vivify_1613
    get_hll_global $P3432, "GLOBAL"
    get_who $P3433, $P3432
    set $P3434, $P3433["$HAS_YOU_ARE_HERE"]
    unless_null $P3434, vivify_1614
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1614:
  vivify_1613:
    if $P3434, unless_3431_end
.annotate 'line', 832
    find_lex $P3435, "$unit"
    unless_null $P3435, vivify_1615
    new $P3435, "Undef"
  vivify_1615:
    find_lex $P3436, "self"
    $P3437 = $P3436."CTXSAVE"()
    $P3435."push"($P3437)
  unless_3431_end:
.annotate 'line', 836
    find_lex $P3438, "$unit"
    unless_null $P3438, vivify_1616
    new $P3438, "Undef"
  vivify_1616:
    $P3438."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 840
    find_dynamic_lex $P3442, "$*MAIN_SUB"
    unless_null $P3442, vivify_1617
    get_hll_global $P3440, "GLOBAL"
    get_who $P3441, $P3440
    set $P3442, $P3441["$MAIN_SUB"]
    unless_null $P3442, vivify_1618
    die "Contextual $*MAIN_SUB not found"
  vivify_1618:
  vivify_1617:
    unless $P3442, if_3439_end
.annotate 'line', 841
    find_lex $P3443, "$unit"
    unless_null $P3443, vivify_1619
    new $P3443, "Undef"
  vivify_1619:
    get_hll_global $P3444, "GLOBAL"
    nqp_get_package_through_who $P3445, $P3444, "PAST"
    get_who $P3446, $P3445
    set $P3447, $P3446["Var"]
    $P3448 = $P3447."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3443."unshift"($P3448)
.annotate 'line', 842
    find_lex $P3449, "$mainline"
    unless_null $P3449, vivify_1620
    new $P3449, "Undef"
  vivify_1620:
    get_hll_global $P3450, "GLOBAL"
    nqp_get_package_through_who $P3451, $P3450, "PAST"
    get_who $P3452, $P3451
    set $P3453, $P3452["Op"]
.annotate 'line', 844
    get_hll_global $P3454, "GLOBAL"
    nqp_get_package_through_who $P3455, $P3454, "PAST"
    get_who $P3456, $P3455
    set $P3457, $P3456["Var"]
    $P3458 = $P3457."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 845
    get_hll_global $P3459, "GLOBAL"
    nqp_get_package_through_who $P3460, $P3459, "PAST"
    get_who $P3461, $P3460
    set $P3462, $P3461["Op"]
.annotate 'line', 846
    get_hll_global $P3463, "GLOBAL"
    nqp_get_package_through_who $P3464, $P3463, "PAST"
    get_who $P3465, $P3464
    set $P3466, $P3465["Val"]
    find_dynamic_lex $P3469, "$*MAIN_SUB"
    unless_null $P3469, vivify_1621
    get_hll_global $P3467, "GLOBAL"
    get_who $P3468, $P3467
    set $P3469, $P3468["$MAIN_SUB"]
    unless_null $P3469, vivify_1622
    die "Contextual $*MAIN_SUB not found"
  vivify_1622:
  vivify_1621:
    $P3470 = $P3466."new"($P3469 :named("value"))
.annotate 'line', 847
    get_hll_global $P3471, "GLOBAL"
    nqp_get_package_through_who $P3472, $P3471, "PAST"
    get_who $P3473, $P3472
    set $P3474, $P3473["Var"]
    $P3475 = $P3474."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3476 = $P3462."new"($P3470, $P3475, "call" :named("pasttype"))
.annotate 'line', 845
    $P3477 = $P3453."new"($P3458, $P3476, "if" :named("pasttype"))
.annotate 'line', 842
    $P3449."push"($P3477)
  if_3439_end:
.annotate 'line', 855
    find_lex $P3478, "$unit"
    unless_null $P3478, vivify_1623
    new $P3478, "Undef"
  vivify_1623:
.annotate 'line', 856
    get_hll_global $P3479, "GLOBAL"
    nqp_get_package_through_who $P3480, $P3479, "PAST"
    get_who $P3481, $P3480
    set $P3482, $P3481["Op"]
    find_lex $P3483, "$mainline"
    unless_null $P3483, vivify_1624
    new $P3483, "Undef"
  vivify_1624:
    $P3484 = $P3482."new"($P3483, "return" :named("pirop"))
    $P3478."push"($P3484)
.annotate 'line', 861
    find_lex $P3485, "$unit"
    unless_null $P3485, vivify_1625
    new $P3485, "Undef"
  vivify_1625:
.annotate 'line', 862
    get_hll_global $P3486, "GLOBAL"
    nqp_get_package_through_who $P3487, $P3486, "PAST"
    get_who $P3488, $P3487
    set $P3489, $P3488["Block"]
.annotate 'line', 864
    get_hll_global $P3490, "GLOBAL"
    nqp_get_package_through_who $P3491, $P3490, "PAST"
    get_who $P3492, $P3491
    set $P3493, $P3492["Op"]
    get_hll_global $P3494, "GLOBAL"
    nqp_get_package_through_who $P3495, $P3494, "PAST"
    get_who $P3496, $P3495
    set $P3497, $P3496["Val"]
    find_lex $P3498, "$unit"
    unless_null $P3498, vivify_1626
    new $P3498, "Undef"
  vivify_1626:
    $P3499 = $P3497."new"($P3498 :named("value"))
    $P3500 = $P3493."new"($P3499, "call" :named("pasttype"))
    $P3501 = $P3489."new"($P3500, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 862
    $P3485."push"($P3501)
.annotate 'line', 867
    find_lex $P3502, "$unit"
    unless_null $P3502, vivify_1627
    new $P3502, "Undef"
  vivify_1627:
    find_lex $P3503, "$/"
    unless_null $P3503, vivify_1628
    new $P3503, "Undef"
  vivify_1628:
    $P3502."node"($P3503)
.annotate 'line', 870
    find_lex $P3504, "$unit"
    unless_null $P3504, vivify_1629
    new $P3504, "Undef"
  vivify_1629:
    $P3504."hll"("nqp")
.annotate 'line', 872
    find_lex $P3505, "$/"
    find_lex $P3506, "$unit"
    unless_null $P3506, vivify_1630
    new $P3506, "Undef"
  vivify_1630:
    $P3507 = $P3505."!make"($P3506)
.annotate 'line', 811
    .return ($P3507)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("436_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3509
    .param pmc param_3510
.annotate 'line', 875
    .const 'Sub' $P3527 = "437_1303748459.273" 
    capture_lex $P3527
    .lex "self", param_3509
    .lex "$/", param_3510
.annotate 'line', 876
    new $P3511, "Undef"
    .lex "$past", $P3511
    get_hll_global $P3512, "GLOBAL"
    nqp_get_package_through_who $P3513, $P3512, "PAST"
    get_who $P3514, $P3513
    set $P3515, $P3514["Stmts"]
    find_lex $P3516, "$/"
    unless_null $P3516, vivify_1631
    new $P3516, "Undef"
  vivify_1631:
    $P3517 = $P3515."new"($P3516 :named("node"))
    store_lex "$past", $P3517
.annotate 'line', 877
    find_lex $P3519, "$/"
    unless_null $P3519, vivify_1632
    $P3519 = root_new ['parrot';'Hash']
  vivify_1632:
    set $P3520, $P3519["statement"]
    unless_null $P3520, vivify_1633
    new $P3520, "Undef"
  vivify_1633:
    unless $P3520, if_3518_end
.annotate 'line', 878
    find_lex $P3522, "$/"
    unless_null $P3522, vivify_1634
    $P3522 = root_new ['parrot';'Hash']
  vivify_1634:
    set $P3523, $P3522["statement"]
    unless_null $P3523, vivify_1635
    new $P3523, "Undef"
  vivify_1635:
    defined $I3524, $P3523
    unless $I3524, for_undef_1636
    iter $P3521, $P3523
    new $P3547, 'ExceptionHandler'
    set_label $P3547, loop3546_handler
    $P3547."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3547
  loop3546_test:
    unless $P3521, loop3546_done
    shift $P3525, $P3521
  loop3546_redo:
    .const 'Sub' $P3527 = "437_1303748459.273" 
    capture_lex $P3527
    $P3527($P3525)
  loop3546_next:
    goto loop3546_test
  loop3546_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3548, exception, 'type'
    eq $P3548, .CONTROL_LOOP_NEXT, loop3546_next
    eq $P3548, .CONTROL_LOOP_REDO, loop3546_redo
  loop3546_done:
    pop_eh 
  for_undef_1636:
  if_3518_end:
.annotate 'line', 885
    find_lex $P3549, "$/"
    find_lex $P3550, "$past"
    unless_null $P3550, vivify_1647
    new $P3550, "Undef"
  vivify_1647:
    $P3551 = $P3549."!make"($P3550)
.annotate 'line', 875
    .return ($P3551)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3526"  :anon :subid("437_1303748459.273") :outer("436_1303748459.273")
    .param pmc param_3529
.annotate 'line', 879
    new $P3528, "Undef"
    .lex "$ast", $P3528
    .lex "$_", param_3529
    find_lex $P3530, "$_"
    unless_null $P3530, vivify_1637
    new $P3530, "Undef"
  vivify_1637:
    $P3531 = $P3530."ast"()
    store_lex "$ast", $P3531
.annotate 'line', 880
    find_lex $P3533, "$ast"
    unless_null $P3533, vivify_1638
    $P3533 = root_new ['parrot';'Hash']
  vivify_1638:
    set $P3534, $P3533["sink"]
    unless_null $P3534, vivify_1639
    new $P3534, "Undef"
  vivify_1639:
    defined $I3535, $P3534
    unless $I3535, if_3532_end
    find_lex $P3536, "$ast"
    unless_null $P3536, vivify_1640
    $P3536 = root_new ['parrot';'Hash']
  vivify_1640:
    set $P3537, $P3536["sink"]
    unless_null $P3537, vivify_1641
    new $P3537, "Undef"
  vivify_1641:
    store_lex "$ast", $P3537
  if_3532_end:
.annotate 'line', 881
    find_lex $P3539, "$ast"
    unless_null $P3539, vivify_1642
    $P3539 = root_new ['parrot';'Hash']
  vivify_1642:
    set $P3540, $P3539["bareblock"]
    unless_null $P3540, vivify_1643
    new $P3540, "Undef"
  vivify_1643:
    unless $P3540, if_3538_end
    find_lex $P3541, "$ast"
    unless_null $P3541, vivify_1644
    new $P3541, "Undef"
  vivify_1644:
    $P3542 = "block_immediate"($P3541)
    store_lex "$ast", $P3542
  if_3538_end:
.annotate 'line', 882
    find_lex $P3543, "$past"
    unless_null $P3543, vivify_1645
    new $P3543, "Undef"
  vivify_1645:
    find_lex $P3544, "$ast"
    unless_null $P3544, vivify_1646
    new $P3544, "Undef"
  vivify_1646:
    $P3545 = $P3543."push"($P3544)
.annotate 'line', 878
    .return ($P3545)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("438_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3553
    .param pmc param_3554
    .param pmc param_3555 :optional
    .param int has_param_3555 :opt_flag
.annotate 'line', 888
    .const 'Sub' $P3563 = "439_1303748459.273" 
    capture_lex $P3563
    .lex "self", param_3553
    .lex "$/", param_3554
    if has_param_3555, optparam_1648
    new $P3556, "Undef"
    set param_3555, $P3556
  optparam_1648:
    .lex "$key", param_3555
.annotate 'line', 889
    new $P3557, "Undef"
    .lex "$past", $P3557
.annotate 'line', 888
    find_lex $P3558, "$past"
    unless_null $P3558, vivify_1649
    new $P3558, "Undef"
  vivify_1649:
.annotate 'line', 890
    find_lex $P3560, "$/"
    unless_null $P3560, vivify_1650
    $P3560 = root_new ['parrot';'Hash']
  vivify_1650:
    set $P3561, $P3560["EXPR"]
    unless_null $P3561, vivify_1651
    new $P3561, "Undef"
  vivify_1651:
    if $P3561, if_3559
.annotate 'line', 911
    find_lex $P3639, "$/"
    unless_null $P3639, vivify_1652
    $P3639 = root_new ['parrot';'Hash']
  vivify_1652:
    set $P3640, $P3639["statement_control"]
    unless_null $P3640, vivify_1653
    new $P3640, "Undef"
  vivify_1653:
    if $P3640, if_3638
.annotate 'line', 912
    new $P3644, "Integer"
    assign $P3644, 0
    store_lex "$past", $P3644
    goto if_3638_end
  if_3638:
.annotate 'line', 911
    find_lex $P3641, "$/"
    unless_null $P3641, vivify_1654
    $P3641 = root_new ['parrot';'Hash']
  vivify_1654:
    set $P3642, $P3641["statement_control"]
    unless_null $P3642, vivify_1655
    new $P3642, "Undef"
  vivify_1655:
    $P3643 = $P3642."ast"()
    store_lex "$past", $P3643
  if_3638_end:
    goto if_3559_end
  if_3559:
.annotate 'line', 890
    .const 'Sub' $P3563 = "439_1303748459.273" 
    capture_lex $P3563
    $P3563()
  if_3559_end:
.annotate 'line', 913
    find_lex $P3645, "$/"
    find_lex $P3646, "$past"
    unless_null $P3646, vivify_1689
    new $P3646, "Undef"
  vivify_1689:
    $P3647 = $P3645."!make"($P3646)
.annotate 'line', 888
    .return ($P3647)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3562"  :anon :subid("439_1303748459.273") :outer("438_1303748459.273")
.annotate 'line', 891
    new $P3564, "Undef"
    .lex "$mc", $P3564
.annotate 'line', 892
    new $P3565, "Undef"
    .lex "$ml", $P3565
.annotate 'line', 891
    find_lex $P3566, "$/"
    unless_null $P3566, vivify_1656
    $P3566 = root_new ['parrot';'Hash']
  vivify_1656:
    set $P3567, $P3566["statement_mod_cond"]
    unless_null $P3567, vivify_1657
    $P3567 = root_new ['parrot';'ResizablePMCArray']
  vivify_1657:
    set $P3568, $P3567[0]
    unless_null $P3568, vivify_1658
    new $P3568, "Undef"
  vivify_1658:
    store_lex "$mc", $P3568
.annotate 'line', 892
    find_lex $P3569, "$/"
    unless_null $P3569, vivify_1659
    $P3569 = root_new ['parrot';'Hash']
  vivify_1659:
    set $P3570, $P3569["statement_mod_loop"]
    unless_null $P3570, vivify_1660
    $P3570 = root_new ['parrot';'ResizablePMCArray']
  vivify_1660:
    set $P3571, $P3570[0]
    unless_null $P3571, vivify_1661
    new $P3571, "Undef"
  vivify_1661:
    store_lex "$ml", $P3571
.annotate 'line', 893
    find_lex $P3572, "$/"
    unless_null $P3572, vivify_1662
    $P3572 = root_new ['parrot';'Hash']
  vivify_1662:
    set $P3573, $P3572["EXPR"]
    unless_null $P3573, vivify_1663
    new $P3573, "Undef"
  vivify_1663:
    $P3574 = $P3573."ast"()
    store_lex "$past", $P3574
.annotate 'line', 894
    find_lex $P3576, "$mc"
    unless_null $P3576, vivify_1664
    new $P3576, "Undef"
  vivify_1664:
    unless $P3576, if_3575_end
.annotate 'line', 895
    get_hll_global $P3577, "GLOBAL"
    nqp_get_package_through_who $P3578, $P3577, "PAST"
    get_who $P3579, $P3578
    set $P3580, $P3579["Op"]
    find_lex $P3581, "$mc"
    unless_null $P3581, vivify_1665
    $P3581 = root_new ['parrot';'Hash']
  vivify_1665:
    set $P3582, $P3581["cond"]
    unless_null $P3582, vivify_1666
    new $P3582, "Undef"
  vivify_1666:
    $P3583 = $P3582."ast"()
    find_lex $P3584, "$past"
    unless_null $P3584, vivify_1667
    new $P3584, "Undef"
  vivify_1667:
    find_lex $P3585, "$mc"
    unless_null $P3585, vivify_1668
    $P3585 = root_new ['parrot';'Hash']
  vivify_1668:
    set $P3586, $P3585["sym"]
    unless_null $P3586, vivify_1669
    new $P3586, "Undef"
  vivify_1669:
    set $S3587, $P3586
    find_lex $P3588, "$/"
    unless_null $P3588, vivify_1670
    new $P3588, "Undef"
  vivify_1670:
    $P3589 = $P3580."new"($P3583, $P3584, $S3587 :named("pasttype"), $P3588 :named("node"))
    store_lex "$past", $P3589
  if_3575_end:
.annotate 'line', 897
    find_lex $P3592, "$ml"
    unless_null $P3592, vivify_1671
    new $P3592, "Undef"
  vivify_1671:
    if $P3592, if_3591
    set $P3590, $P3592
    goto if_3591_end
  if_3591:
.annotate 'line', 898
    find_lex $P3595, "$ml"
    unless_null $P3595, vivify_1672
    $P3595 = root_new ['parrot';'Hash']
  vivify_1672:
    set $P3596, $P3595["sym"]
    unless_null $P3596, vivify_1673
    new $P3596, "Undef"
  vivify_1673:
    set $S3597, $P3596
    iseq $I3598, $S3597, "for"
    if $I3598, if_3594
.annotate 'line', 907
    get_hll_global $P3625, "GLOBAL"
    nqp_get_package_through_who $P3626, $P3625, "PAST"
    get_who $P3627, $P3626
    set $P3628, $P3627["Op"]
    find_lex $P3629, "$ml"
    unless_null $P3629, vivify_1674
    $P3629 = root_new ['parrot';'Hash']
  vivify_1674:
    set $P3630, $P3629["cond"]
    unless_null $P3630, vivify_1675
    new $P3630, "Undef"
  vivify_1675:
    $P3631 = $P3630."ast"()
    find_lex $P3632, "$past"
    unless_null $P3632, vivify_1676
    new $P3632, "Undef"
  vivify_1676:
    find_lex $P3633, "$ml"
    unless_null $P3633, vivify_1677
    $P3633 = root_new ['parrot';'Hash']
  vivify_1677:
    set $P3634, $P3633["sym"]
    unless_null $P3634, vivify_1678
    new $P3634, "Undef"
  vivify_1678:
    set $S3635, $P3634
    find_lex $P3636, "$/"
    unless_null $P3636, vivify_1679
    new $P3636, "Undef"
  vivify_1679:
    $P3637 = $P3628."new"($P3631, $P3632, $S3635 :named("pasttype"), $P3636 :named("node"))
    store_lex "$past", $P3637
.annotate 'line', 906
    set $P3593, $P3637
.annotate 'line', 898
    goto if_3594_end
  if_3594:
.annotate 'line', 899
    get_hll_global $P3599, "GLOBAL"
    nqp_get_package_through_who $P3600, $P3599, "PAST"
    get_who $P3601, $P3600
    set $P3602, $P3601["Block"]
.annotate 'line', 900
    get_hll_global $P3603, "GLOBAL"
    nqp_get_package_through_who $P3604, $P3603, "PAST"
    get_who $P3605, $P3604
    set $P3606, $P3605["Var"]
    $P3607 = $P3606."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3608, "$past"
    unless_null $P3608, vivify_1680
    new $P3608, "Undef"
  vivify_1680:
    $P3609 = $P3602."new"($P3607, $P3608, "immediate" :named("blocktype"))
.annotate 'line', 899
    store_lex "$past", $P3609
.annotate 'line', 902
    find_lex $P3610, "$past"
    unless_null $P3610, vivify_1681
    new $P3610, "Undef"
  vivify_1681:
    $P3610."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 903
    find_lex $P3611, "$past"
    unless_null $P3611, vivify_1682
    new $P3611, "Undef"
  vivify_1682:
    $P3611."arity"(1)
.annotate 'line', 904
    get_hll_global $P3612, "GLOBAL"
    nqp_get_package_through_who $P3613, $P3612, "PAST"
    get_who $P3614, $P3613
    set $P3615, $P3614["Op"]
    find_lex $P3616, "$ml"
    unless_null $P3616, vivify_1683
    $P3616 = root_new ['parrot';'Hash']
  vivify_1683:
    set $P3617, $P3616["cond"]
    unless_null $P3617, vivify_1684
    new $P3617, "Undef"
  vivify_1684:
    $P3618 = $P3617."ast"()
    find_lex $P3619, "$past"
    unless_null $P3619, vivify_1685
    new $P3619, "Undef"
  vivify_1685:
    find_lex $P3620, "$ml"
    unless_null $P3620, vivify_1686
    $P3620 = root_new ['parrot';'Hash']
  vivify_1686:
    set $P3621, $P3620["sym"]
    unless_null $P3621, vivify_1687
    new $P3621, "Undef"
  vivify_1687:
    set $S3622, $P3621
    find_lex $P3623, "$/"
    unless_null $P3623, vivify_1688
    new $P3623, "Undef"
  vivify_1688:
    $P3624 = $P3615."new"($P3618, $P3619, $S3622 :named("pasttype"), $P3623 :named("node"))
    store_lex "$past", $P3624
.annotate 'line', 898
    set $P3593, $P3624
  if_3594_end:
.annotate 'line', 897
    set $P3590, $P3593
  if_3591_end:
.annotate 'line', 890
    .return ($P3590)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("440_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3649
    .param pmc param_3650
.annotate 'line', 916
    .lex "self", param_3649
    .lex "$/", param_3650
.annotate 'line', 917
    find_lex $P3651, "$/"
    get_hll_global $P3652, "GLOBAL"
    nqp_get_package_through_who $P3653, $P3652, "PAST"
    get_who $P3654, $P3653
    set $P3655, $P3654["Op"]
    find_lex $P3656, "$/"
    unless_null $P3656, vivify_1690
    $P3656 = root_new ['parrot';'Hash']
  vivify_1690:
    set $P3657, $P3656["EXPR"]
    unless_null $P3657, vivify_1691
    new $P3657, "Undef"
  vivify_1691:
    $P3658 = $P3657."ast"()
    find_lex $P3659, "$/"
    unless_null $P3659, vivify_1692
    $P3659 = root_new ['parrot';'Hash']
  vivify_1692:
    set $P3660, $P3659["pblock"]
    unless_null $P3660, vivify_1693
    new $P3660, "Undef"
  vivify_1693:
    $P3661 = $P3660."ast"()
    find_lex $P3662, "$/"
    unless_null $P3662, vivify_1694
    new $P3662, "Undef"
  vivify_1694:
    $P3663 = $P3655."new"($P3658, $P3661, "if" :named("pasttype"), $P3662 :named("node"))
    $P3664 = $P3651."!make"($P3663)
.annotate 'line', 916
    .return ($P3664)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("441_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3666
    .param pmc param_3667
.annotate 'line', 920
    .lex "self", param_3666
    .lex "$/", param_3667
.annotate 'line', 921
    find_lex $P3668, "$/"
    find_lex $P3669, "$/"
    unless_null $P3669, vivify_1695
    $P3669 = root_new ['parrot';'Hash']
  vivify_1695:
    set $P3670, $P3669["blockoid"]
    unless_null $P3670, vivify_1696
    new $P3670, "Undef"
  vivify_1696:
    $P3671 = $P3670."ast"()
    $P3672 = $P3668."!make"($P3671)
.annotate 'line', 920
    .return ($P3672)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("442_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3674
    .param pmc param_3675
.annotate 'line', 924
    .lex "self", param_3674
    .lex "$/", param_3675
.annotate 'line', 925
    find_lex $P3676, "$/"
    find_lex $P3677, "$/"
    unless_null $P3677, vivify_1697
    $P3677 = root_new ['parrot';'Hash']
  vivify_1697:
    set $P3678, $P3677["blockoid"]
    unless_null $P3678, vivify_1698
    new $P3678, "Undef"
  vivify_1698:
    $P3679 = $P3678."ast"()
    $P3680 = $P3676."!make"($P3679)
.annotate 'line', 924
    .return ($P3680)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("443_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3682
    .param pmc param_3683
.annotate 'line', 928
    .const 'Sub' $P3694 = "444_1303748459.273" 
    capture_lex $P3694
    .lex "self", param_3682
    .lex "$/", param_3683
.annotate 'line', 929
    new $P3684, "Undef"
    .lex "$BLOCK", $P3684
    find_lex $P3685, "$?PACKAGE"
    get_who $P3686, $P3685
    set $P3687, $P3686["@BLOCK"]
    unless_null $P3687, vivify_1699
    $P3687 = root_new ['parrot';'ResizablePMCArray']
  vivify_1699:
    $P3688 = $P3687."shift"()
    store_lex "$BLOCK", $P3688
.annotate 'line', 930
    find_lex $P3691, "$/"
    unless_null $P3691, vivify_1700
    $P3691 = root_new ['parrot';'Hash']
  vivify_1700:
    set $P3692, $P3691["statementlist"]
    unless_null $P3692, vivify_1701
    new $P3692, "Undef"
  vivify_1701:
    if $P3692, if_3690
.annotate 'line', 938
    find_dynamic_lex $P3711, "$*HAS_YOU_ARE_HERE"
    unless_null $P3711, vivify_1702
    get_hll_global $P3709, "GLOBAL"
    get_who $P3710, $P3709
    set $P3711, $P3710["$HAS_YOU_ARE_HERE"]
    unless_null $P3711, vivify_1703
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1703:
  vivify_1702:
    unless $P3711, if_3708_end
.annotate 'line', 939
    find_lex $P3712, "$/"
    unless_null $P3712, vivify_1704
    new $P3712, "Undef"
  vivify_1704:
    $P3713 = $P3712."CURSOR"()
    $P3713."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3708_end:
.annotate 'line', 941
    new $P3714, "Integer"
    assign $P3714, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3714
.annotate 'line', 942
    find_lex $P3715, "$/"
    find_lex $P3716, "$/"
    unless_null $P3716, vivify_1705
    $P3716 = root_new ['parrot';'Hash']
  vivify_1705:
    set $P3717, $P3716["you_are_here"]
    unless_null $P3717, vivify_1706
    new $P3717, "Undef"
  vivify_1706:
    $P3718 = $P3717."ast"()
    $P3719 = $P3715."!make"($P3718)
.annotate 'line', 937
    set $P3689, $P3719
.annotate 'line', 930
    goto if_3690_end
  if_3690:
    .const 'Sub' $P3694 = "444_1303748459.273" 
    capture_lex $P3694
    $P3707 = $P3694()
    set $P3689, $P3707
  if_3690_end:
.annotate 'line', 928
    .return ($P3689)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3693"  :anon :subid("444_1303748459.273") :outer("443_1303748459.273")
.annotate 'line', 931
    new $P3695, "Undef"
    .lex "$past", $P3695
    find_lex $P3696, "$/"
    unless_null $P3696, vivify_1707
    $P3696 = root_new ['parrot';'Hash']
  vivify_1707:
    set $P3697, $P3696["statementlist"]
    unless_null $P3697, vivify_1708
    new $P3697, "Undef"
  vivify_1708:
    $P3698 = $P3697."ast"()
    store_lex "$past", $P3698
.annotate 'line', 932
    find_lex $P3699, "$BLOCK"
    unless_null $P3699, vivify_1709
    new $P3699, "Undef"
  vivify_1709:
    find_lex $P3700, "$past"
    unless_null $P3700, vivify_1710
    new $P3700, "Undef"
  vivify_1710:
    $P3699."push"($P3700)
.annotate 'line', 933
    find_lex $P3701, "$BLOCK"
    unless_null $P3701, vivify_1711
    new $P3701, "Undef"
  vivify_1711:
    find_lex $P3702, "$/"
    unless_null $P3702, vivify_1712
    new $P3702, "Undef"
  vivify_1712:
    $P3701."node"($P3702)
.annotate 'line', 934
    find_lex $P3703, "$BLOCK"
    unless_null $P3703, vivify_1713
    new $P3703, "Undef"
  vivify_1713:
    $P3703."closure"(1)
.annotate 'line', 935
    find_dynamic_lex $P3704, "$/"
    find_lex $P3705, "$BLOCK"
    unless_null $P3705, vivify_1714
    new $P3705, "Undef"
  vivify_1714:
    $P3706 = $P3704."!make"($P3705)
.annotate 'line', 930
    .return ($P3706)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("445_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3721
    .param pmc param_3722
.annotate 'line', 946
    .lex "self", param_3721
    .lex "$/", param_3722
.annotate 'line', 947
    find_lex $P3723, "$?PACKAGE"
    get_who $P3724, $P3723
    set $P3725, $P3724["@BLOCK"]
    unless_null $P3725, vivify_1715
    $P3725 = root_new ['parrot';'ResizablePMCArray']
  vivify_1715:
    get_hll_global $P3726, "GLOBAL"
    nqp_get_package_through_who $P3727, $P3726, "PAST"
    get_who $P3728, $P3727
    set $P3729, $P3728["Block"]
    get_hll_global $P3730, "GLOBAL"
    nqp_get_package_through_who $P3731, $P3730, "PAST"
    get_who $P3732, $P3731
    set $P3733, $P3732["Stmts"]
    $P3734 = $P3733."new"()
    $P3735 = $P3729."new"($P3734)
    $P3736 = $P3725."unshift"($P3735)
.annotate 'line', 946
    .return ($P3736)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("446_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3738
    .param pmc param_3739
.annotate 'line', 950
    .const 'Sub' $P3748 = "447_1303748459.273" 
    capture_lex $P3748
    .lex "self", param_3738
    .lex "$/", param_3739
.annotate 'line', 951
    find_dynamic_lex $P3743, "%*COMPILING"
    unless_null $P3743, vivify_1716
    get_hll_global $P3741, "GLOBAL"
    get_who $P3742, $P3741
    set $P3743, $P3742["%COMPILING"]
    unless_null $P3743, vivify_1717
    die "Contextual %*COMPILING not found"
  vivify_1717:
  vivify_1716:
    set $P3744, $P3743["%?OPTIONS"]
    unless_null $P3744, vivify_1718
    $P3744 = root_new ['parrot';'Hash']
  vivify_1718:
    set $P3745, $P3744["outer_ctx"]
    unless_null $P3745, vivify_1719
    new $P3745, "Undef"
  vivify_1719:
    defined $I3746, $P3745
    if $I3746, unless_3740_end
    .const 'Sub' $P3748 = "447_1303748459.273" 
    capture_lex $P3748
    $P3748()
  unless_3740_end:
.annotate 'line', 964
    find_lex $P3780, "self"
    find_lex $P3781, "$?PACKAGE"
    get_who $P3782, $P3781
    set $P3783, $P3782["@BLOCK"]
    unless_null $P3783, vivify_1735
    $P3783 = root_new ['parrot';'ResizablePMCArray']
  vivify_1735:
    set $P3784, $P3783[0]
    unless_null $P3784, vivify_1736
    new $P3784, "Undef"
  vivify_1736:
    $P3785 = $P3780."SET_BLOCK_OUTER_CTX"($P3784)
.annotate 'line', 950
    .return ($P3785)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3747"  :anon :subid("447_1303748459.273") :outer("446_1303748459.273")
.annotate 'line', 954
    new $P3749, "Undef"
    .lex "$SETTING", $P3749
    find_dynamic_lex $P3752, "$*SC"
    unless_null $P3752, vivify_1720
    get_hll_global $P3750, "GLOBAL"
    get_who $P3751, $P3750
    set $P3752, $P3751["$SC"]
    unless_null $P3752, vivify_1721
    die "Contextual $*SC not found"
  vivify_1721:
  vivify_1720:
    find_dynamic_lex $P3756, "%*COMPILING"
    unless_null $P3756, vivify_1722
    get_hll_global $P3754, "GLOBAL"
    get_who $P3755, $P3754
    set $P3756, $P3755["%COMPILING"]
    unless_null $P3756, vivify_1723
    die "Contextual %*COMPILING not found"
  vivify_1723:
  vivify_1722:
    set $P3757, $P3756["%?OPTIONS"]
    unless_null $P3757, vivify_1724
    $P3757 = root_new ['parrot';'Hash']
  vivify_1724:
    set $P3758, $P3757["setting"]
    unless_null $P3758, vivify_1725
    new $P3758, "Undef"
  vivify_1725:
    set $P3753, $P3758
    defined $I3760, $P3753
    if $I3760, default_3759
    new $P3761, "String"
    assign $P3761, "NQPCORE"
    set $P3753, $P3761
  default_3759:
    $P3762 = $P3752."load_setting"($P3753)
    store_lex "$SETTING", $P3762
.annotate 'line', 959
    find_dynamic_lex $P3767, "%*COMPILING"
    unless_null $P3767, vivify_1726
    get_hll_global $P3765, "GLOBAL"
    get_who $P3766, $P3765
    set $P3767, $P3766["%COMPILING"]
    unless_null $P3767, vivify_1727
    die "Contextual %*COMPILING not found"
  vivify_1727:
  vivify_1726:
    set $P3768, $P3767["%?OPTIONS"]
    unless_null $P3768, vivify_1728
    $P3768 = root_new ['parrot';'Hash']
  vivify_1728:
    set $P3769, $P3768["setting"]
    unless_null $P3769, vivify_1729
    new $P3769, "Undef"
  vivify_1729:
    set $S3770, $P3769
    iseq $I3771, $S3770, "NULL"
    unless $I3771, unless_3764
    new $P3763, 'Integer'
    set $P3763, $I3771
    goto unless_3764_end
  unless_3764:
.annotate 'line', 960
    find_lex $P3772, "$SETTING"
    unless_null $P3772, vivify_1730
    new $P3772, "Undef"
  vivify_1730:
    "import_HOW_exports"($P3772)
.annotate 'line', 961
    find_dynamic_lex $P3775, "$*SC"
    unless_null $P3775, vivify_1731
    get_hll_global $P3773, "GLOBAL"
    get_who $P3774, $P3773
    set $P3775, $P3774["$SC"]
    unless_null $P3775, vivify_1732
    die "Contextual $*SC not found"
  vivify_1732:
  vivify_1731:
    find_dynamic_lex $P3778, "$*GLOBALish"
    unless_null $P3778, vivify_1733
    get_hll_global $P3776, "GLOBAL"
    get_who $P3777, $P3776
    set $P3778, $P3777["$GLOBALish"]
    unless_null $P3778, vivify_1734
    die "Contextual $*GLOBALish not found"
  vivify_1734:
  vivify_1733:
    $P3779 = $P3775."load_module"("Regex", $P3778)
.annotate 'line', 959
    set $P3763, $P3779
  unless_3764_end:
.annotate 'line', 951
    .return ($P3763)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("448_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3788
    .param pmc param_3789
.annotate 'line', 976
    .lex "self", param_3788
    .lex "$/", param_3789
.annotate 'line', 980
    find_dynamic_lex $P3792, "$*SC"
    unless_null $P3792, vivify_1737
    get_hll_global $P3790, "GLOBAL"
    get_who $P3791, $P3790
    set $P3792, $P3791["$SC"]
    unless_null $P3792, vivify_1738
    die "Contextual $*SC not found"
  vivify_1738:
  vivify_1737:
    find_dynamic_lex $P3795, "%*HOW"
    unless_null $P3795, vivify_1739
    get_hll_global $P3793, "GLOBAL"
    get_who $P3794, $P3793
    set $P3795, $P3794["%HOW"]
    unless_null $P3795, vivify_1740
    die "Contextual %*HOW not found"
  vivify_1740:
  vivify_1739:
    set $P3796, $P3795["knowhow"]
    unless_null $P3796, vivify_1741
    new $P3796, "Undef"
  vivify_1741:
    $P3797 = $P3792."pkg_create_mo"($P3796, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3797
.annotate 'line', 981
    find_dynamic_lex $P3800, "$*GLOBALish"
    unless_null $P3800, vivify_1742
    get_hll_global $P3798, "GLOBAL"
    get_who $P3799, $P3798
    set $P3800, $P3799["$GLOBALish"]
    unless_null $P3800, vivify_1743
    die "Contextual $*GLOBALish not found"
  vivify_1743:
  vivify_1742:
    get_how $P3801, $P3800
    find_dynamic_lex $P3804, "$*GLOBALish"
    unless_null $P3804, vivify_1744
    get_hll_global $P3802, "GLOBAL"
    get_who $P3803, $P3802
    set $P3804, $P3803["$GLOBALish"]
    unless_null $P3804, vivify_1745
    die "Contextual $*GLOBALish not found"
  vivify_1745:
  vivify_1744:
    $P3801."compose"($P3804)
.annotate 'line', 982
    find_dynamic_lex $P3807, "$*SC"
    unless_null $P3807, vivify_1746
    get_hll_global $P3805, "GLOBAL"
    get_who $P3806, $P3805
    set $P3807, $P3806["$SC"]
    unless_null $P3807, vivify_1747
    die "Contextual $*SC not found"
  vivify_1747:
  vivify_1746:
    find_lex $P3808, "$?PACKAGE"
    get_who $P3809, $P3808
    set $P3810, $P3809["@BLOCK"]
    unless_null $P3810, vivify_1748
    $P3810 = root_new ['parrot';'ResizablePMCArray']
  vivify_1748:
    set $P3811, $P3810[0]
    unless_null $P3811, vivify_1749
    new $P3811, "Undef"
  vivify_1749:
    find_dynamic_lex $P3814, "$*GLOBALish"
    unless_null $P3814, vivify_1750
    get_hll_global $P3812, "GLOBAL"
    get_who $P3813, $P3812
    set $P3814, $P3813["$GLOBALish"]
    unless_null $P3814, vivify_1751
    die "Contextual $*GLOBALish not found"
  vivify_1751:
  vivify_1750:
    $P3807."install_lexical_symbol"($P3811, "GLOBALish", $P3814)
.annotate 'line', 985
    find_dynamic_lex $P3817, "$*GLOBALish"
    unless_null $P3817, vivify_1752
    get_hll_global $P3815, "GLOBAL"
    get_who $P3816, $P3815
    set $P3817, $P3816["$GLOBALish"]
    unless_null $P3817, vivify_1753
    die "Contextual $*GLOBALish not found"
  vivify_1753:
  vivify_1752:
    store_dynamic_lex "$*PACKAGE", $P3817
.annotate 'line', 986
    find_dynamic_lex $P3820, "$*SC"
    unless_null $P3820, vivify_1754
    get_hll_global $P3818, "GLOBAL"
    get_who $P3819, $P3818
    set $P3820, $P3819["$SC"]
    unless_null $P3820, vivify_1755
    die "Contextual $*SC not found"
  vivify_1755:
  vivify_1754:
    find_lex $P3821, "$?PACKAGE"
    get_who $P3822, $P3821
    set $P3823, $P3822["@BLOCK"]
    unless_null $P3823, vivify_1756
    $P3823 = root_new ['parrot';'ResizablePMCArray']
  vivify_1756:
    set $P3824, $P3823[0]
    unless_null $P3824, vivify_1757
    new $P3824, "Undef"
  vivify_1757:
    find_dynamic_lex $P3827, "$*PACKAGE"
    unless_null $P3827, vivify_1758
    get_hll_global $P3825, "GLOBAL"
    get_who $P3826, $P3825
    set $P3827, $P3826["$PACKAGE"]
    unless_null $P3827, vivify_1759
    die "Contextual $*PACKAGE not found"
  vivify_1759:
  vivify_1758:
    $P3828 = $P3820."install_lexical_symbol"($P3824, "$?PACKAGE", $P3827)
.annotate 'line', 976
    .return ($P3828)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("449_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3830
    .param pmc param_3831
.annotate 'line', 989
    .lex "self", param_3830
    .lex "$/", param_3831
.annotate 'line', 990
    find_lex $P3832, "$/"
    find_lex $P3833, "self"
    $P3834 = $P3833."CTXSAVE"()
    $P3835 = $P3832."!make"($P3834)
.annotate 'line', 989
    .return ($P3835)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("450_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3837
    .param pmc param_3838
.annotate 'line', 995
    .lex "self", param_3837
    .lex "$/", param_3838
.annotate 'line', 996
    new $P3839, "Undef"
    .lex "$module", $P3839
    find_dynamic_lex $P3842, "$*SC"
    unless_null $P3842, vivify_1760
    get_hll_global $P3840, "GLOBAL"
    get_who $P3841, $P3840
    set $P3842, $P3841["$SC"]
    unless_null $P3842, vivify_1761
    die "Contextual $*SC not found"
  vivify_1761:
  vivify_1760:
    find_lex $P3843, "$/"
    unless_null $P3843, vivify_1762
    $P3843 = root_new ['parrot';'Hash']
  vivify_1762:
    set $P3844, $P3843["name"]
    unless_null $P3844, vivify_1763
    new $P3844, "Undef"
  vivify_1763:
    set $S3845, $P3844
    find_dynamic_lex $P3848, "$*GLOBALish"
    unless_null $P3848, vivify_1764
    get_hll_global $P3846, "GLOBAL"
    get_who $P3847, $P3846
    set $P3848, $P3847["$GLOBALish"]
    unless_null $P3848, vivify_1765
    die "Contextual $*GLOBALish not found"
  vivify_1765:
  vivify_1764:
    $P3849 = $P3842."load_module"($S3845, $P3848)
    store_lex "$module", $P3849
.annotate 'line', 997
    find_lex $P3851, "$module"
    unless_null $P3851, vivify_1766
    new $P3851, "Undef"
  vivify_1766:
    defined $I3852, $P3851
    unless $I3852, if_3850_end
.annotate 'line', 998
    find_lex $P3853, "$module"
    unless_null $P3853, vivify_1767
    new $P3853, "Undef"
  vivify_1767:
    "import_HOW_exports"($P3853)
  if_3850_end:
.annotate 'line', 1000
    find_lex $P3854, "$/"
    get_hll_global $P3855, "GLOBAL"
    nqp_get_package_through_who $P3856, $P3855, "PAST"
    get_who $P3857, $P3856
    set $P3858, $P3857["Stmts"]
    $P3859 = $P3858."new"()
    $P3860 = $P3854."!make"($P3859)
.annotate 'line', 995
    .return ($P3860)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("451_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3862
    .param pmc param_3863
.annotate 'line', 1003
    .const 'Sub' $P3891 = "452_1303748459.273" 
    capture_lex $P3891
    .lex "self", param_3862
    .lex "$/", param_3863
.annotate 'line', 1004
    new $P3864, "Undef"
    .lex "$count", $P3864
.annotate 'line', 1005
    new $P3865, "Undef"
    .lex "$past", $P3865
.annotate 'line', 1004
    find_lex $P3866, "$/"
    unless_null $P3866, vivify_1768
    $P3866 = root_new ['parrot';'Hash']
  vivify_1768:
    set $P3867, $P3866["xblock"]
    unless_null $P3867, vivify_1769
    new $P3867, "Undef"
  vivify_1769:
    set $N3868, $P3867
    new $P3869, 'Float'
    set $P3869, $N3868
    sub $P3870, $P3869, 1
    store_lex "$count", $P3870
.annotate 'line', 1005
    find_lex $P3871, "$count"
    unless_null $P3871, vivify_1770
    new $P3871, "Undef"
  vivify_1770:
    set $I3872, $P3871
    find_lex $P3873, "$/"
    unless_null $P3873, vivify_1771
    $P3873 = root_new ['parrot';'Hash']
  vivify_1771:
    set $P3874, $P3873["xblock"]
    unless_null $P3874, vivify_1772
    $P3874 = root_new ['parrot';'ResizablePMCArray']
  vivify_1772:
    set $P3875, $P3874[$I3872]
    unless_null $P3875, vivify_1773
    new $P3875, "Undef"
  vivify_1773:
    $P3876 = $P3875."ast"()
    $P3877 = "xblock_immediate"($P3876)
    store_lex "$past", $P3877
.annotate 'line', 1006
    find_lex $P3879, "$/"
    unless_null $P3879, vivify_1774
    $P3879 = root_new ['parrot';'Hash']
  vivify_1774:
    set $P3880, $P3879["else"]
    unless_null $P3880, vivify_1775
    new $P3880, "Undef"
  vivify_1775:
    unless $P3880, if_3878_end
.annotate 'line', 1007
    find_lex $P3881, "$past"
    unless_null $P3881, vivify_1776
    new $P3881, "Undef"
  vivify_1776:
    find_lex $P3882, "$/"
    unless_null $P3882, vivify_1777
    $P3882 = root_new ['parrot';'Hash']
  vivify_1777:
    set $P3883, $P3882["else"]
    unless_null $P3883, vivify_1778
    $P3883 = root_new ['parrot';'ResizablePMCArray']
  vivify_1778:
    set $P3884, $P3883[0]
    unless_null $P3884, vivify_1779
    new $P3884, "Undef"
  vivify_1779:
    $P3885 = $P3884."ast"()
    $P3886 = "block_immediate"($P3885)
    $P3881."push"($P3886)
  if_3878_end:
.annotate 'line', 1010
    new $P3907, 'ExceptionHandler'
    set_label $P3907, loop3906_handler
    $P3907."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3907
  loop3906_test:
    find_lex $P3887, "$count"
    unless_null $P3887, vivify_1780
    new $P3887, "Undef"
  vivify_1780:
    set $N3888, $P3887
    isgt $I3889, $N3888, 0.0
    unless $I3889, loop3906_done
  loop3906_redo:
    .const 'Sub' $P3891 = "452_1303748459.273" 
    capture_lex $P3891
    $P3891()
  loop3906_next:
    goto loop3906_test
  loop3906_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3908, exception, 'type'
    eq $P3908, .CONTROL_LOOP_NEXT, loop3906_next
    eq $P3908, .CONTROL_LOOP_REDO, loop3906_redo
  loop3906_done:
    pop_eh 
.annotate 'line', 1016
    find_lex $P3909, "$/"
    find_lex $P3910, "$past"
    unless_null $P3910, vivify_1789
    new $P3910, "Undef"
  vivify_1789:
    $P3911 = $P3909."!make"($P3910)
.annotate 'line', 1003
    .return ($P3911)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3890"  :anon :subid("452_1303748459.273") :outer("451_1303748459.273")
.annotate 'line', 1012
    new $P3892, "Undef"
    .lex "$else", $P3892
.annotate 'line', 1010
    find_lex $P3893, "$count"
    unless_null $P3893, vivify_1781
    new $P3893, "Undef"
  vivify_1781:
    clone $P3894, $P3893
    dec $P3893
.annotate 'line', 1012
    find_lex $P3895, "$past"
    unless_null $P3895, vivify_1782
    new $P3895, "Undef"
  vivify_1782:
    store_lex "$else", $P3895
.annotate 'line', 1013
    find_lex $P3896, "$count"
    unless_null $P3896, vivify_1783
    new $P3896, "Undef"
  vivify_1783:
    set $I3897, $P3896
    find_lex $P3898, "$/"
    unless_null $P3898, vivify_1784
    $P3898 = root_new ['parrot';'Hash']
  vivify_1784:
    set $P3899, $P3898["xblock"]
    unless_null $P3899, vivify_1785
    $P3899 = root_new ['parrot';'ResizablePMCArray']
  vivify_1785:
    set $P3900, $P3899[$I3897]
    unless_null $P3900, vivify_1786
    new $P3900, "Undef"
  vivify_1786:
    $P3901 = $P3900."ast"()
    $P3902 = "xblock_immediate"($P3901)
    store_lex "$past", $P3902
.annotate 'line', 1014
    find_lex $P3903, "$past"
    unless_null $P3903, vivify_1787
    new $P3903, "Undef"
  vivify_1787:
    find_lex $P3904, "$else"
    unless_null $P3904, vivify_1788
    new $P3904, "Undef"
  vivify_1788:
    $P3905 = $P3903."push"($P3904)
.annotate 'line', 1010
    .return ($P3905)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("453_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3913
    .param pmc param_3914
.annotate 'line', 1019
    .lex "self", param_3913
    .lex "$/", param_3914
.annotate 'line', 1020
    new $P3915, "Undef"
    .lex "$past", $P3915
    find_lex $P3916, "$/"
    unless_null $P3916, vivify_1790
    $P3916 = root_new ['parrot';'Hash']
  vivify_1790:
    set $P3917, $P3916["xblock"]
    unless_null $P3917, vivify_1791
    new $P3917, "Undef"
  vivify_1791:
    $P3918 = $P3917."ast"()
    $P3919 = "xblock_immediate"($P3918)
    store_lex "$past", $P3919
.annotate 'line', 1021
    find_lex $P3920, "$past"
    unless_null $P3920, vivify_1792
    new $P3920, "Undef"
  vivify_1792:
    $P3920."pasttype"("unless")
.annotate 'line', 1022
    find_lex $P3921, "$/"
    find_lex $P3922, "$past"
    unless_null $P3922, vivify_1793
    new $P3922, "Undef"
  vivify_1793:
    $P3923 = $P3921."!make"($P3922)
.annotate 'line', 1019
    .return ($P3923)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("454_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3925
    .param pmc param_3926
.annotate 'line', 1025
    .lex "self", param_3925
    .lex "$/", param_3926
.annotate 'line', 1026
    new $P3927, "Undef"
    .lex "$past", $P3927
    find_lex $P3928, "$/"
    unless_null $P3928, vivify_1794
    $P3928 = root_new ['parrot';'Hash']
  vivify_1794:
    set $P3929, $P3928["xblock"]
    unless_null $P3929, vivify_1795
    new $P3929, "Undef"
  vivify_1795:
    $P3930 = $P3929."ast"()
    $P3931 = "xblock_immediate"($P3930)
    store_lex "$past", $P3931
.annotate 'line', 1027
    find_lex $P3932, "$past"
    unless_null $P3932, vivify_1796
    new $P3932, "Undef"
  vivify_1796:
    find_lex $P3933, "$/"
    unless_null $P3933, vivify_1797
    $P3933 = root_new ['parrot';'Hash']
  vivify_1797:
    set $P3934, $P3933["sym"]
    unless_null $P3934, vivify_1798
    new $P3934, "Undef"
  vivify_1798:
    set $S3935, $P3934
    $P3932."pasttype"($S3935)
.annotate 'line', 1028
    find_lex $P3936, "$/"
    find_lex $P3937, "$past"
    unless_null $P3937, vivify_1799
    new $P3937, "Undef"
  vivify_1799:
    $P3938 = $P3936."!make"($P3937)
.annotate 'line', 1025
    .return ($P3938)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("455_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3940
    .param pmc param_3941
.annotate 'line', 1031
    .lex "self", param_3940
    .lex "$/", param_3941
.annotate 'line', 1032
    new $P3942, "Undef"
    .lex "$pasttype", $P3942
.annotate 'line', 1033
    new $P3943, "Undef"
    .lex "$past", $P3943
.annotate 'line', 1032
    new $P3944, "String"
    assign $P3944, "repeat_"
    find_lex $P3945, "$/"
    unless_null $P3945, vivify_1800
    $P3945 = root_new ['parrot';'Hash']
  vivify_1800:
    set $P3946, $P3945["wu"]
    unless_null $P3946, vivify_1801
    new $P3946, "Undef"
  vivify_1801:
    set $S3947, $P3946
    concat $P3948, $P3944, $S3947
    store_lex "$pasttype", $P3948
    find_lex $P3949, "$past"
    unless_null $P3949, vivify_1802
    new $P3949, "Undef"
  vivify_1802:
.annotate 'line', 1034
    find_lex $P3951, "$/"
    unless_null $P3951, vivify_1803
    $P3951 = root_new ['parrot';'Hash']
  vivify_1803:
    set $P3952, $P3951["xblock"]
    unless_null $P3952, vivify_1804
    new $P3952, "Undef"
  vivify_1804:
    if $P3952, if_3950
.annotate 'line', 1039
    get_hll_global $P3959, "GLOBAL"
    nqp_get_package_through_who $P3960, $P3959, "PAST"
    get_who $P3961, $P3960
    set $P3962, $P3961["Op"]
    find_lex $P3963, "$/"
    unless_null $P3963, vivify_1805
    $P3963 = root_new ['parrot';'Hash']
  vivify_1805:
    set $P3964, $P3963["EXPR"]
    unless_null $P3964, vivify_1806
    new $P3964, "Undef"
  vivify_1806:
    $P3965 = $P3964."ast"()
    find_lex $P3966, "$/"
    unless_null $P3966, vivify_1807
    $P3966 = root_new ['parrot';'Hash']
  vivify_1807:
    set $P3967, $P3966["pblock"]
    unless_null $P3967, vivify_1808
    new $P3967, "Undef"
  vivify_1808:
    $P3968 = $P3967."ast"()
    $P3969 = "block_immediate"($P3968)
    find_lex $P3970, "$pasttype"
    unless_null $P3970, vivify_1809
    new $P3970, "Undef"
  vivify_1809:
    find_lex $P3971, "$/"
    unless_null $P3971, vivify_1810
    new $P3971, "Undef"
  vivify_1810:
    $P3972 = $P3962."new"($P3965, $P3969, $P3970 :named("pasttype"), $P3971 :named("node"))
    store_lex "$past", $P3972
.annotate 'line', 1038
    goto if_3950_end
  if_3950:
.annotate 'line', 1035
    find_lex $P3953, "$/"
    unless_null $P3953, vivify_1811
    $P3953 = root_new ['parrot';'Hash']
  vivify_1811:
    set $P3954, $P3953["xblock"]
    unless_null $P3954, vivify_1812
    new $P3954, "Undef"
  vivify_1812:
    $P3955 = $P3954."ast"()
    $P3956 = "xblock_immediate"($P3955)
    store_lex "$past", $P3956
.annotate 'line', 1036
    find_lex $P3957, "$past"
    unless_null $P3957, vivify_1813
    new $P3957, "Undef"
  vivify_1813:
    find_lex $P3958, "$pasttype"
    unless_null $P3958, vivify_1814
    new $P3958, "Undef"
  vivify_1814:
    $P3957."pasttype"($P3958)
  if_3950_end:
.annotate 'line', 1042
    find_lex $P3973, "$/"
    find_lex $P3974, "$past"
    unless_null $P3974, vivify_1815
    new $P3974, "Undef"
  vivify_1815:
    $P3975 = $P3973."!make"($P3974)
.annotate 'line', 1031
    .return ($P3975)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("456_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_3977
    .param pmc param_3978
.annotate 'line', 1045
    .lex "self", param_3977
    .lex "$/", param_3978
.annotate 'line', 1046
    new $P3979, "Undef"
    .lex "$past", $P3979
.annotate 'line', 1048
    new $P3980, "Undef"
    .lex "$block", $P3980
.annotate 'line', 1046
    find_lex $P3981, "$/"
    unless_null $P3981, vivify_1816
    $P3981 = root_new ['parrot';'Hash']
  vivify_1816:
    set $P3982, $P3981["xblock"]
    unless_null $P3982, vivify_1817
    new $P3982, "Undef"
  vivify_1817:
    $P3983 = $P3982."ast"()
    store_lex "$past", $P3983
.annotate 'line', 1047
    find_lex $P3984, "$past"
    unless_null $P3984, vivify_1818
    new $P3984, "Undef"
  vivify_1818:
    $P3984."pasttype"("for")
.annotate 'line', 1048
    find_lex $P3985, "$past"
    unless_null $P3985, vivify_1819
    $P3985 = root_new ['parrot';'ResizablePMCArray']
  vivify_1819:
    set $P3986, $P3985[1]
    unless_null $P3986, vivify_1820
    new $P3986, "Undef"
  vivify_1820:
    store_lex "$block", $P3986
.annotate 'line', 1049
    find_lex $P3988, "$block"
    unless_null $P3988, vivify_1821
    new $P3988, "Undef"
  vivify_1821:
    $P3989 = $P3988."arity"()
    if $P3989, unless_3987_end
.annotate 'line', 1050
    find_lex $P3990, "$block"
    unless_null $P3990, vivify_1822
    $P3990 = root_new ['parrot';'ResizablePMCArray']
  vivify_1822:
    set $P3991, $P3990[0]
    unless_null $P3991, vivify_1823
    new $P3991, "Undef"
  vivify_1823:
    get_hll_global $P3992, "GLOBAL"
    nqp_get_package_through_who $P3993, $P3992, "PAST"
    get_who $P3994, $P3993
    set $P3995, $P3994["Var"]
    $P3996 = $P3995."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3991."push"($P3996)
.annotate 'line', 1051
    find_lex $P3997, "$block"
    unless_null $P3997, vivify_1824
    new $P3997, "Undef"
  vivify_1824:
    $P3997."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1052
    find_lex $P3998, "$block"
    unless_null $P3998, vivify_1825
    new $P3998, "Undef"
  vivify_1825:
    $P3998."arity"(1)
  unless_3987_end:
.annotate 'line', 1054
    find_lex $P3999, "$block"
    unless_null $P3999, vivify_1826
    new $P3999, "Undef"
  vivify_1826:
    $P3999."blocktype"("immediate")
.annotate 'line', 1055
    find_lex $P4000, "$/"
    find_lex $P4001, "$past"
    unless_null $P4001, vivify_1827
    new $P4001, "Undef"
  vivify_1827:
    $P4002 = $P4000."!make"($P4001)
.annotate 'line', 1045
    .return ($P4002)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("457_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4004
    .param pmc param_4005
.annotate 'line', 1058
    .lex "self", param_4004
    .lex "$/", param_4005
.annotate 'line', 1059
    new $P4006, "Undef"
    .lex "$block", $P4006
    find_lex $P4007, "$/"
    unless_null $P4007, vivify_1828
    $P4007 = root_new ['parrot';'Hash']
  vivify_1828:
    set $P4008, $P4007["block"]
    unless_null $P4008, vivify_1829
    new $P4008, "Undef"
  vivify_1829:
    $P4009 = $P4008."ast"()
    store_lex "$block", $P4009
.annotate 'line', 1060
    find_lex $P4010, "$/"
    unless_null $P4010, vivify_1830
    new $P4010, "Undef"
  vivify_1830:
    find_lex $P4011, "$block"
    unless_null $P4011, vivify_1831
    new $P4011, "Undef"
  vivify_1831:
    "push_block_handler"($P4010, $P4011)
.annotate 'line', 1061
    find_lex $P4012, "$?PACKAGE"
    get_who $P4013, $P4012
    set $P4014, $P4013["@BLOCK"]
    unless_null $P4014, vivify_1832
    $P4014 = root_new ['parrot';'ResizablePMCArray']
  vivify_1832:
    set $P4015, $P4014[0]
    unless_null $P4015, vivify_1833
    new $P4015, "Undef"
  vivify_1833:
    $P4016 = $P4015."handlers"()
    set $P4017, $P4016[0]
    unless_null $P4017, vivify_1834
    new $P4017, "Undef"
  vivify_1834:
    $P4017."handle_types_except"("CONTROL")
.annotate 'line', 1062
    find_lex $P4018, "$/"
    get_hll_global $P4019, "GLOBAL"
    nqp_get_package_through_who $P4020, $P4019, "PAST"
    get_who $P4021, $P4020
    set $P4022, $P4021["Stmts"]
    find_lex $P4023, "$/"
    unless_null $P4023, vivify_1835
    new $P4023, "Undef"
  vivify_1835:
    $P4024 = $P4022."new"($P4023 :named("node"))
    $P4025 = $P4018."!make"($P4024)
.annotate 'line', 1058
    .return ($P4025)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("458_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4027
    .param pmc param_4028
.annotate 'line', 1065
    .lex "self", param_4027
    .lex "$/", param_4028
.annotate 'line', 1066
    new $P4029, "Undef"
    .lex "$block", $P4029
    find_lex $P4030, "$/"
    unless_null $P4030, vivify_1836
    $P4030 = root_new ['parrot';'Hash']
  vivify_1836:
    set $P4031, $P4030["block"]
    unless_null $P4031, vivify_1837
    new $P4031, "Undef"
  vivify_1837:
    $P4032 = $P4031."ast"()
    store_lex "$block", $P4032
.annotate 'line', 1067
    find_lex $P4033, "$/"
    unless_null $P4033, vivify_1838
    new $P4033, "Undef"
  vivify_1838:
    find_lex $P4034, "$block"
    unless_null $P4034, vivify_1839
    new $P4034, "Undef"
  vivify_1839:
    "push_block_handler"($P4033, $P4034)
.annotate 'line', 1068
    find_lex $P4035, "$?PACKAGE"
    get_who $P4036, $P4035
    set $P4037, $P4036["@BLOCK"]
    unless_null $P4037, vivify_1840
    $P4037 = root_new ['parrot';'ResizablePMCArray']
  vivify_1840:
    set $P4038, $P4037[0]
    unless_null $P4038, vivify_1841
    new $P4038, "Undef"
  vivify_1841:
    $P4039 = $P4038."handlers"()
    set $P4040, $P4039[0]
    unless_null $P4040, vivify_1842
    new $P4040, "Undef"
  vivify_1842:
    $P4040."handle_types"("CONTROL")
.annotate 'line', 1069
    find_lex $P4041, "$/"
    get_hll_global $P4042, "GLOBAL"
    nqp_get_package_through_who $P4043, $P4042, "PAST"
    get_who $P4044, $P4043
    set $P4045, $P4044["Stmts"]
    find_lex $P4046, "$/"
    unless_null $P4046, vivify_1843
    new $P4046, "Undef"
  vivify_1843:
    $P4047 = $P4045."new"($P4046 :named("node"))
    $P4048 = $P4041."!make"($P4047)
.annotate 'line', 1065
    .return ($P4048)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("459_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4051
    .param pmc param_4052
.annotate 'line', 1109
    .lex "self", param_4051
    .lex "$/", param_4052
.annotate 'line', 1110
    find_lex $P4053, "$?PACKAGE"
    get_who $P4054, $P4053
    set $P4055, $P4054["@BLOCK"]
    unless_null $P4055, vivify_1844
    $P4055 = root_new ['parrot';'ResizablePMCArray']
  vivify_1844:
    set $P4056, $P4055[0]
    unless_null $P4056, vivify_1845
    new $P4056, "Undef"
  vivify_1845:
    find_lex $P4057, "$/"
    unless_null $P4057, vivify_1846
    $P4057 = root_new ['parrot';'Hash']
  vivify_1846:
    set $P4058, $P4057["blorst"]
    unless_null $P4058, vivify_1847
    new $P4058, "Undef"
  vivify_1847:
    $P4059 = $P4058."ast"()
    $P4056."push"($P4059)
.annotate 'line', 1111
    find_lex $P4060, "$/"
    get_hll_global $P4061, "GLOBAL"
    nqp_get_package_through_who $P4062, $P4061, "PAST"
    get_who $P4063, $P4062
    set $P4064, $P4063["Stmts"]
    $P4065 = $P4064."new"()
    $P4066 = $P4060."!make"($P4065)
.annotate 'line', 1109
    .return ($P4066)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("460_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4068
    .param pmc param_4069
.annotate 'line', 1114
    .lex "self", param_4068
    .lex "$/", param_4069
.annotate 'line', 1115
    new $P4070, "Undef"
    .lex "$past", $P4070
    find_lex $P4071, "$/"
    unless_null $P4071, vivify_1848
    $P4071 = root_new ['parrot';'Hash']
  vivify_1848:
    set $P4072, $P4071["blorst"]
    unless_null $P4072, vivify_1849
    new $P4072, "Undef"
  vivify_1849:
    $P4073 = $P4072."ast"()
    store_lex "$past", $P4073
.annotate 'line', 1116
    get_hll_global $P4075, "GLOBAL"
    nqp_get_package_through_who $P4076, $P4075, "PAST"
    get_who $P4077, $P4076
    set $P4078, $P4077["Block"]
    find_lex $P4079, "$past"
    unless_null $P4079, vivify_1850
    new $P4079, "Undef"
  vivify_1850:
    $P4080 = $P4078."ACCEPTS"($P4079)
    if $P4080, unless_4074_end
.annotate 'line', 1117
    get_hll_global $P4081, "GLOBAL"
    nqp_get_package_through_who $P4082, $P4081, "PAST"
    get_who $P4083, $P4082
    set $P4084, $P4083["Block"]
    find_lex $P4085, "$past"
    unless_null $P4085, vivify_1851
    new $P4085, "Undef"
  vivify_1851:
    find_lex $P4086, "$/"
    unless_null $P4086, vivify_1852
    new $P4086, "Undef"
  vivify_1852:
    $P4087 = $P4084."new"($P4085, "immediate" :named("blocktype"), $P4086 :named("node"))
    store_lex "$past", $P4087
  unless_4074_end:
.annotate 'line', 1119
    find_lex $P4089, "$past"
    unless_null $P4089, vivify_1853
    new $P4089, "Undef"
  vivify_1853:
    $P4090 = $P4089."handlers"()
    if $P4090, unless_4088_end
.annotate 'line', 1120
    find_lex $P4091, "$past"
    unless_null $P4091, vivify_1854
    new $P4091, "Undef"
  vivify_1854:
    get_hll_global $P4092, "GLOBAL"
    nqp_get_package_through_who $P4093, $P4092, "PAST"
    get_who $P4094, $P4093
    set $P4095, $P4094["Control"]
.annotate 'line', 1122
    get_hll_global $P4096, "GLOBAL"
    nqp_get_package_through_who $P4097, $P4096, "PAST"
    get_who $P4098, $P4097
    set $P4099, $P4098["Stmts"]
.annotate 'line', 1123
    get_hll_global $P4100, "GLOBAL"
    nqp_get_package_through_who $P4101, $P4100, "PAST"
    get_who $P4102, $P4101
    set $P4103, $P4102["Op"]
.annotate 'line', 1124
    get_hll_global $P4104, "GLOBAL"
    nqp_get_package_through_who $P4105, $P4104, "PAST"
    get_who $P4106, $P4105
    set $P4107, $P4106["Var"]
.annotate 'line', 1125
    get_hll_global $P4108, "GLOBAL"
    nqp_get_package_through_who $P4109, $P4108, "PAST"
    get_who $P4110, $P4109
    set $P4111, $P4110["Var"]
    $P4112 = $P4111."new"("register" :named("scope"), "exception" :named("name"))
    $P4113 = $P4107."new"($P4112, "handled", "keyed" :named("scope"))
.annotate 'line', 1124
    $P4114 = $P4103."new"($P4113, 1, "bind" :named("pasttype"))
.annotate 'line', 1123
    $P4115 = $P4099."new"($P4114)
.annotate 'line', 1122
    $P4116 = $P4095."new"($P4115, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1120
    new $P4117, "ResizablePMCArray"
    push $P4117, $P4116
    $P4091."handlers"($P4117)
  unless_4088_end:
.annotate 'line', 1134
    find_lex $P4118, "$/"
    find_lex $P4119, "$past"
    unless_null $P4119, vivify_1855
    new $P4119, "Undef"
  vivify_1855:
    $P4120 = $P4118."!make"($P4119)
.annotate 'line', 1114
    .return ($P4120)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("461_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4122
    .param pmc param_4123
.annotate 'line', 1137
    .lex "self", param_4122
    .lex "$/", param_4123
.annotate 'line', 1138
    find_lex $P4124, "$/"
.annotate 'line', 1139
    find_lex $P4127, "$/"
    unless_null $P4127, vivify_1856
    $P4127 = root_new ['parrot';'Hash']
  vivify_1856:
    set $P4128, $P4127["block"]
    unless_null $P4128, vivify_1857
    new $P4128, "Undef"
  vivify_1857:
    if $P4128, if_4126
.annotate 'line', 1140
    find_lex $P4133, "$/"
    unless_null $P4133, vivify_1858
    $P4133 = root_new ['parrot';'Hash']
  vivify_1858:
    set $P4134, $P4133["statement"]
    unless_null $P4134, vivify_1859
    new $P4134, "Undef"
  vivify_1859:
    $P4135 = $P4134."ast"()
    set $P4125, $P4135
.annotate 'line', 1139
    goto if_4126_end
  if_4126:
    find_lex $P4129, "$/"
    unless_null $P4129, vivify_1860
    $P4129 = root_new ['parrot';'Hash']
  vivify_1860:
    set $P4130, $P4129["block"]
    unless_null $P4130, vivify_1861
    new $P4130, "Undef"
  vivify_1861:
    $P4131 = $P4130."ast"()
    $P4132 = "block_immediate"($P4131)
    set $P4125, $P4132
  if_4126_end:
    $P4136 = $P4124."!make"($P4125)
.annotate 'line', 1137
    .return ($P4136)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("462_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4138
    .param pmc param_4139
.annotate 'line', 1145
    .lex "self", param_4138
    .lex "$/", param_4139
    find_lex $P4140, "$/"
    find_lex $P4141, "$/"
    unless_null $P4141, vivify_1862
    $P4141 = root_new ['parrot';'Hash']
  vivify_1862:
    set $P4142, $P4141["cond"]
    unless_null $P4142, vivify_1863
    new $P4142, "Undef"
  vivify_1863:
    $P4143 = $P4142."ast"()
    $P4144 = $P4140."!make"($P4143)
    .return ($P4144)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("463_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4146
    .param pmc param_4147
.annotate 'line', 1146
    .lex "self", param_4146
    .lex "$/", param_4147
    find_lex $P4148, "$/"
    find_lex $P4149, "$/"
    unless_null $P4149, vivify_1864
    $P4149 = root_new ['parrot';'Hash']
  vivify_1864:
    set $P4150, $P4149["cond"]
    unless_null $P4150, vivify_1865
    new $P4150, "Undef"
  vivify_1865:
    $P4151 = $P4150."ast"()
    $P4152 = $P4148."!make"($P4151)
    .return ($P4152)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("464_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4154
    .param pmc param_4155
.annotate 'line', 1148
    .lex "self", param_4154
    .lex "$/", param_4155
    find_lex $P4156, "$/"
    find_lex $P4157, "$/"
    unless_null $P4157, vivify_1866
    $P4157 = root_new ['parrot';'Hash']
  vivify_1866:
    set $P4158, $P4157["cond"]
    unless_null $P4158, vivify_1867
    new $P4158, "Undef"
  vivify_1867:
    $P4159 = $P4158."ast"()
    $P4160 = $P4156."!make"($P4159)
    .return ($P4160)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("465_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4162
    .param pmc param_4163
.annotate 'line', 1149
    .lex "self", param_4162
    .lex "$/", param_4163
    find_lex $P4164, "$/"
    find_lex $P4165, "$/"
    unless_null $P4165, vivify_1868
    $P4165 = root_new ['parrot';'Hash']
  vivify_1868:
    set $P4166, $P4165["cond"]
    unless_null $P4166, vivify_1869
    new $P4166, "Undef"
  vivify_1869:
    $P4167 = $P4166."ast"()
    $P4168 = $P4164."!make"($P4167)
    .return ($P4168)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("466_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4170
    .param pmc param_4171
.annotate 'line', 1153
    .lex "self", param_4170
    .lex "$/", param_4171
    find_lex $P4172, "$/"
    find_lex $P4173, "$/"
    unless_null $P4173, vivify_1870
    $P4173 = root_new ['parrot';'Hash']
  vivify_1870:
    set $P4174, $P4173["fatarrow"]
    unless_null $P4174, vivify_1871
    new $P4174, "Undef"
  vivify_1871:
    $P4175 = $P4174."ast"()
    $P4176 = $P4172."!make"($P4175)
    .return ($P4176)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("467_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4178
    .param pmc param_4179
.annotate 'line', 1154
    .lex "self", param_4178
    .lex "$/", param_4179
    find_lex $P4180, "$/"
    find_lex $P4181, "$/"
    unless_null $P4181, vivify_1872
    $P4181 = root_new ['parrot';'Hash']
  vivify_1872:
    set $P4182, $P4181["colonpair"]
    unless_null $P4182, vivify_1873
    new $P4182, "Undef"
  vivify_1873:
    $P4183 = $P4182."ast"()
    $P4184 = $P4180."!make"($P4183)
    .return ($P4184)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("468_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4186
    .param pmc param_4187
.annotate 'line', 1155
    .lex "self", param_4186
    .lex "$/", param_4187
    find_lex $P4188, "$/"
    find_lex $P4189, "$/"
    unless_null $P4189, vivify_1874
    $P4189 = root_new ['parrot';'Hash']
  vivify_1874:
    set $P4190, $P4189["variable"]
    unless_null $P4190, vivify_1875
    new $P4190, "Undef"
  vivify_1875:
    $P4191 = $P4190."ast"()
    $P4192 = $P4188."!make"($P4191)
    .return ($P4192)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("469_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4194
    .param pmc param_4195
.annotate 'line', 1156
    .lex "self", param_4194
    .lex "$/", param_4195
    find_lex $P4196, "$/"
    find_lex $P4197, "$/"
    unless_null $P4197, vivify_1876
    $P4197 = root_new ['parrot';'Hash']
  vivify_1876:
    set $P4198, $P4197["package_declarator"]
    unless_null $P4198, vivify_1877
    new $P4198, "Undef"
  vivify_1877:
    $P4199 = $P4198."ast"()
    $P4200 = $P4196."!make"($P4199)
    .return ($P4200)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("470_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4202
    .param pmc param_4203
.annotate 'line', 1157
    .lex "self", param_4202
    .lex "$/", param_4203
    find_lex $P4204, "$/"
    find_lex $P4205, "$/"
    unless_null $P4205, vivify_1878
    $P4205 = root_new ['parrot';'Hash']
  vivify_1878:
    set $P4206, $P4205["scope_declarator"]
    unless_null $P4206, vivify_1879
    new $P4206, "Undef"
  vivify_1879:
    $P4207 = $P4206."ast"()
    $P4208 = $P4204."!make"($P4207)
    .return ($P4208)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("471_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4210
    .param pmc param_4211
.annotate 'line', 1158
    .lex "self", param_4210
    .lex "$/", param_4211
    find_lex $P4212, "$/"
    find_lex $P4213, "$/"
    unless_null $P4213, vivify_1880
    $P4213 = root_new ['parrot';'Hash']
  vivify_1880:
    set $P4214, $P4213["routine_declarator"]
    unless_null $P4214, vivify_1881
    new $P4214, "Undef"
  vivify_1881:
    $P4215 = $P4214."ast"()
    $P4216 = $P4212."!make"($P4215)
    .return ($P4216)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("472_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4218
    .param pmc param_4219
.annotate 'line', 1159
    .lex "self", param_4218
    .lex "$/", param_4219
    find_lex $P4220, "$/"
    find_lex $P4221, "$/"
    unless_null $P4221, vivify_1882
    $P4221 = root_new ['parrot';'Hash']
  vivify_1882:
    set $P4222, $P4221["regex_declarator"]
    unless_null $P4222, vivify_1883
    new $P4222, "Undef"
  vivify_1883:
    $P4223 = $P4222."ast"()
    $P4224 = $P4220."!make"($P4223)
    .return ($P4224)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("473_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4226
    .param pmc param_4227
.annotate 'line', 1160
    .lex "self", param_4226
    .lex "$/", param_4227
    find_lex $P4228, "$/"
    find_lex $P4229, "$/"
    unless_null $P4229, vivify_1884
    $P4229 = root_new ['parrot';'Hash']
  vivify_1884:
    set $P4230, $P4229["statement_prefix"]
    unless_null $P4230, vivify_1885
    new $P4230, "Undef"
  vivify_1885:
    $P4231 = $P4230."ast"()
    $P4232 = $P4228."!make"($P4231)
    .return ($P4232)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("474_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4234
    .param pmc param_4235
.annotate 'line', 1161
    .lex "self", param_4234
    .lex "$/", param_4235
    find_lex $P4236, "$/"
    find_lex $P4237, "$/"
    unless_null $P4237, vivify_1886
    $P4237 = root_new ['parrot';'Hash']
  vivify_1886:
    set $P4238, $P4237["pblock"]
    unless_null $P4238, vivify_1887
    new $P4238, "Undef"
  vivify_1887:
    $P4239 = $P4238."ast"()
    $P4240 = $P4236."!make"($P4239)
    .return ($P4240)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("475_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4242
    .param pmc param_4243
.annotate 'line', 1163
    .lex "self", param_4242
    .lex "$/", param_4243
.annotate 'line', 1164
    new $P4244, "Undef"
    .lex "$past", $P4244
    find_lex $P4245, "$/"
    unless_null $P4245, vivify_1888
    $P4245 = root_new ['parrot';'Hash']
  vivify_1888:
    set $P4246, $P4245["val"]
    unless_null $P4246, vivify_1889
    new $P4246, "Undef"
  vivify_1889:
    $P4247 = $P4246."ast"()
    store_lex "$past", $P4247
.annotate 'line', 1165
    find_lex $P4248, "$past"
    unless_null $P4248, vivify_1890
    new $P4248, "Undef"
  vivify_1890:
    find_lex $P4249, "$/"
    unless_null $P4249, vivify_1891
    $P4249 = root_new ['parrot';'Hash']
  vivify_1891:
    set $P4250, $P4249["key"]
    unless_null $P4250, vivify_1892
    new $P4250, "Undef"
  vivify_1892:
    $P4251 = $P4250."Str"()
    $P4248."named"($P4251)
.annotate 'line', 1166
    find_lex $P4252, "$/"
    find_lex $P4253, "$past"
    unless_null $P4253, vivify_1893
    new $P4253, "Undef"
  vivify_1893:
    $P4254 = $P4252."!make"($P4253)
.annotate 'line', 1163
    .return ($P4254)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("476_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4256
    .param pmc param_4257
.annotate 'line', 1169
    .lex "self", param_4256
    .lex "$/", param_4257
.annotate 'line', 1170
    new $P4258, "Undef"
    .lex "$past", $P4258
.annotate 'line', 1171
    find_lex $P4261, "$/"
    unless_null $P4261, vivify_1894
    $P4261 = root_new ['parrot';'Hash']
  vivify_1894:
    set $P4262, $P4261["circumfix"]
    unless_null $P4262, vivify_1895
    new $P4262, "Undef"
  vivify_1895:
    if $P4262, if_4260
.annotate 'line', 1172
    get_hll_global $P4267, "GLOBAL"
    nqp_get_package_through_who $P4268, $P4267, "PAST"
    get_who $P4269, $P4268
    set $P4270, $P4269["Val"]
    find_lex $P4271, "$/"
    unless_null $P4271, vivify_1896
    $P4271 = root_new ['parrot';'Hash']
  vivify_1896:
    set $P4272, $P4271["not"]
    unless_null $P4272, vivify_1897
    new $P4272, "Undef"
  vivify_1897:
    isfalse $I4273, $P4272
    $P4274 = $P4270."new"($I4273 :named("value"))
    set $P4259, $P4274
.annotate 'line', 1171
    goto if_4260_end
  if_4260:
    find_lex $P4263, "$/"
    unless_null $P4263, vivify_1898
    $P4263 = root_new ['parrot';'Hash']
  vivify_1898:
    set $P4264, $P4263["circumfix"]
    unless_null $P4264, vivify_1899
    $P4264 = root_new ['parrot';'ResizablePMCArray']
  vivify_1899:
    set $P4265, $P4264[0]
    unless_null $P4265, vivify_1900
    new $P4265, "Undef"
  vivify_1900:
    $P4266 = $P4265."ast"()
    set $P4259, $P4266
  if_4260_end:
    store_lex "$past", $P4259
.annotate 'line', 1173
    find_lex $P4275, "$past"
    unless_null $P4275, vivify_1901
    new $P4275, "Undef"
  vivify_1901:
    find_lex $P4276, "$/"
    unless_null $P4276, vivify_1902
    $P4276 = root_new ['parrot';'Hash']
  vivify_1902:
    set $P4277, $P4276["identifier"]
    unless_null $P4277, vivify_1903
    new $P4277, "Undef"
  vivify_1903:
    set $S4278, $P4277
    $P4275."named"($S4278)
.annotate 'line', 1174
    find_lex $P4279, "$/"
    find_lex $P4280, "$past"
    unless_null $P4280, vivify_1904
    new $P4280, "Undef"
  vivify_1904:
    $P4281 = $P4279."!make"($P4280)
.annotate 'line', 1169
    .return ($P4281)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("477_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4283
    .param pmc param_4284
.annotate 'line', 1177
    .const 'Sub' $P4300 = "478_1303748459.273" 
    capture_lex $P4300
    .lex "self", param_4283
    .lex "$/", param_4284
.annotate 'line', 1178
    new $P4285, "Undef"
    .lex "$past", $P4285
.annotate 'line', 1177
    find_lex $P4286, "$past"
    unless_null $P4286, vivify_1905
    new $P4286, "Undef"
  vivify_1905:
.annotate 'line', 1179
    find_lex $P4288, "$/"
    unless_null $P4288, vivify_1906
    $P4288 = root_new ['parrot';'Hash']
  vivify_1906:
    set $P4289, $P4288["postcircumfix"]
    unless_null $P4289, vivify_1907
    new $P4289, "Undef"
  vivify_1907:
    if $P4289, if_4287
.annotate 'line', 1183
    .const 'Sub' $P4300 = "478_1303748459.273" 
    capture_lex $P4300
    $P4300()
    goto if_4287_end
  if_4287:
.annotate 'line', 1180
    find_lex $P4290, "$/"
    unless_null $P4290, vivify_1946
    $P4290 = root_new ['parrot';'Hash']
  vivify_1946:
    set $P4291, $P4290["postcircumfix"]
    unless_null $P4291, vivify_1947
    new $P4291, "Undef"
  vivify_1947:
    $P4292 = $P4291."ast"()
    store_lex "$past", $P4292
.annotate 'line', 1181
    find_lex $P4293, "$past"
    unless_null $P4293, vivify_1948
    new $P4293, "Undef"
  vivify_1948:
    get_hll_global $P4294, "GLOBAL"
    nqp_get_package_through_who $P4295, $P4294, "PAST"
    get_who $P4296, $P4295
    set $P4297, $P4296["Var"]
    $P4298 = $P4297."new"("$/" :named("name"))
    $P4293."unshift"($P4298)
  if_4287_end:
.annotate 'line', 1221
    find_lex $P4421, "$/"
    find_lex $P4422, "$past"
    unless_null $P4422, vivify_1949
    new $P4422, "Undef"
  vivify_1949:
    $P4423 = $P4421."!make"($P4422)
.annotate 'line', 1177
    .return ($P4423)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4299"  :anon :subid("478_1303748459.273") :outer("477_1303748459.273")
.annotate 'line', 1183
    .const 'Sub' $P4335 = "479_1303748459.273" 
    capture_lex $P4335
.annotate 'line', 1184
    $P4301 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4301
    get_hll_global $P4302, "GLOBAL"
    nqp_get_package_through_who $P4303, $P4302, "NQP"
    get_who $P4304, $P4303
    set $P4305, $P4304["Compiler"]
    find_lex $P4306, "$/"
    unless_null $P4306, vivify_1908
    new $P4306, "Undef"
  vivify_1908:
    set $S4307, $P4306
    $P4308 = $P4305."parse_name"($S4307)
    store_lex "@name", $P4308
.annotate 'line', 1185
    find_lex $P4311, "@name"
    unless_null $P4311, vivify_1909
    $P4311 = root_new ['parrot';'ResizablePMCArray']
  vivify_1909:
    set $N4312, $P4311
    isgt $I4313, $N4312, 1.0
    if $I4313, if_4310
.annotate 'line', 1192
    find_lex $P4329, "$/"
    unless_null $P4329, vivify_1910
    $P4329 = root_new ['parrot';'Hash']
  vivify_1910:
    set $P4330, $P4329["twigil"]
    unless_null $P4330, vivify_1911
    $P4330 = root_new ['parrot';'ResizablePMCArray']
  vivify_1911:
    set $P4331, $P4330[0]
    unless_null $P4331, vivify_1912
    new $P4331, "Undef"
  vivify_1912:
    set $S4332, $P4331
    iseq $I4333, $S4332, "*"
    if $I4333, if_4328
.annotate 'line', 1203
    find_lex $P4370, "$/"
    unless_null $P4370, vivify_1913
    $P4370 = root_new ['parrot';'Hash']
  vivify_1913:
    set $P4371, $P4370["twigil"]
    unless_null $P4371, vivify_1914
    $P4371 = root_new ['parrot';'ResizablePMCArray']
  vivify_1914:
    set $P4372, $P4371[0]
    unless_null $P4372, vivify_1915
    new $P4372, "Undef"
  vivify_1915:
    set $S4373, $P4372
    iseq $I4374, $S4373, "!"
    if $I4374, if_4369
.annotate 'line', 1211
    find_lex $P4398, "@name"
    unless_null $P4398, vivify_1916
    $P4398 = root_new ['parrot';'ResizablePMCArray']
  vivify_1916:
    set $P4399, $P4398[0]
    unless_null $P4399, vivify_1917
    new $P4399, "Undef"
  vivify_1917:
    set $S4400, $P4399
    $P4401 = "is_package"($S4400)
    if $P4401, if_4397
.annotate 'line', 1216
    get_hll_global $P4410, "GLOBAL"
    nqp_get_package_through_who $P4411, $P4410, "PAST"
    get_who $P4412, $P4411
    set $P4413, $P4412["Var"]
.annotate 'line', 1217
    find_lex $P4414, "@name"
    unless_null $P4414, vivify_1918
    $P4414 = root_new ['parrot';'ResizablePMCArray']
  vivify_1918:
    $P4415 = $P4414."pop"()
    set $S4416, $P4415
    find_lex $P4417, "$/"
    unless_null $P4417, vivify_1919
    $P4417 = root_new ['parrot';'Hash']
  vivify_1919:
    set $P4418, $P4417["sigil"]
    unless_null $P4418, vivify_1920
    new $P4418, "Undef"
  vivify_1920:
    $P4419 = "vivitype"($P4418)
    $P4420 = $P4413."new"($S4416 :named("name"), $P4419 :named("viviself"))
.annotate 'line', 1216
    store_lex "$past", $P4420
.annotate 'line', 1215
    set $P4396, $P4420
.annotate 'line', 1211
    goto if_4397_end
  if_4397:
.annotate 'line', 1212
    find_lex $P4402, "@name"
    unless_null $P4402, vivify_1921
    $P4402 = root_new ['parrot';'ResizablePMCArray']
  vivify_1921:
    find_lex $P4403, "$/"
    unless_null $P4403, vivify_1922
    new $P4403, "Undef"
  vivify_1922:
    $P4404 = "lexical_package_lookup"($P4402, $P4403)
    store_lex "$past", $P4404
.annotate 'line', 1213
    find_lex $P4405, "$past"
    unless_null $P4405, vivify_1923
    new $P4405, "Undef"
  vivify_1923:
    find_lex $P4406, "$/"
    unless_null $P4406, vivify_1924
    $P4406 = root_new ['parrot';'Hash']
  vivify_1924:
    set $P4407, $P4406["sigil"]
    unless_null $P4407, vivify_1925
    new $P4407, "Undef"
  vivify_1925:
    $P4408 = "vivitype"($P4407)
    $P4409 = $P4405."viviself"($P4408)
.annotate 'line', 1211
    set $P4396, $P4409
  if_4397_end:
    set $P4368, $P4396
.annotate 'line', 1203
    goto if_4369_end
  if_4369:
.annotate 'line', 1204
    get_hll_global $P4375, "GLOBAL"
    nqp_get_package_through_who $P4376, $P4375, "PAST"
    get_who $P4377, $P4376
    set $P4378, $P4377["Var"]
.annotate 'line', 1205
    find_lex $P4379, "@name"
    unless_null $P4379, vivify_1926
    $P4379 = root_new ['parrot';'ResizablePMCArray']
  vivify_1926:
    $P4380 = $P4379."pop"()
    set $S4381, $P4380
.annotate 'line', 1206
    find_lex $P4382, "$/"
    unless_null $P4382, vivify_1927
    $P4382 = root_new ['parrot';'Hash']
  vivify_1927:
    set $P4383, $P4382["sigil"]
    unless_null $P4383, vivify_1928
    new $P4383, "Undef"
  vivify_1928:
    $P4384 = "vivitype"($P4383)
.annotate 'line', 1207
    get_hll_global $P4385, "GLOBAL"
    nqp_get_package_through_who $P4386, $P4385, "PAST"
    get_who $P4387, $P4386
    set $P4388, $P4387["Var"]
    $P4389 = $P4388."new"("self" :named("name"))
.annotate 'line', 1208
    get_hll_global $P4390, "GLOBAL"
    nqp_get_package_through_who $P4391, $P4390, "PAST"
    get_who $P4392, $P4391
    set $P4393, $P4392["Var"]
    $P4394 = $P4393."new"("$?CLASS" :named("name"))
    $P4395 = $P4378."new"($P4389, $P4394, $S4381 :named("name"), "attribute" :named("scope"), $P4384 :named("viviself"))
.annotate 'line', 1204
    store_lex "$past", $P4395
.annotate 'line', 1203
    set $P4368, $P4395
  if_4369_end:
    set $P4327, $P4368
.annotate 'line', 1192
    goto if_4328_end
  if_4328:
    .const 'Sub' $P4335 = "479_1303748459.273" 
    capture_lex $P4335
    $P4367 = $P4335()
    set $P4327, $P4367
  if_4328_end:
    set $P4309, $P4327
.annotate 'line', 1185
    goto if_4310_end
  if_4310:
.annotate 'line', 1186
    find_lex $P4315, "$/"
    unless_null $P4315, vivify_1938
    $P4315 = root_new ['parrot';'Hash']
  vivify_1938:
    set $P4316, $P4315["twigil"]
    unless_null $P4316, vivify_1939
    new $P4316, "Undef"
  vivify_1939:
    unless $P4316, if_4314_end
.annotate 'line', 1187
    find_lex $P4317, "$/"
    unless_null $P4317, vivify_1940
    new $P4317, "Undef"
  vivify_1940:
    $P4318 = $P4317."CURSOR"()
    $P4318."panic"("Twigil not allowed on multi-part name")
  if_4314_end:
.annotate 'line', 1189
    find_lex $P4319, "@name"
    unless_null $P4319, vivify_1941
    $P4319 = root_new ['parrot';'ResizablePMCArray']
  vivify_1941:
    find_lex $P4320, "$/"
    unless_null $P4320, vivify_1942
    new $P4320, "Undef"
  vivify_1942:
    $P4321 = "lexical_package_lookup"($P4319, $P4320)
    store_lex "$past", $P4321
.annotate 'line', 1190
    find_lex $P4322, "$past"
    unless_null $P4322, vivify_1943
    new $P4322, "Undef"
  vivify_1943:
    find_lex $P4323, "$/"
    unless_null $P4323, vivify_1944
    $P4323 = root_new ['parrot';'Hash']
  vivify_1944:
    set $P4324, $P4323["sigil"]
    unless_null $P4324, vivify_1945
    new $P4324, "Undef"
  vivify_1945:
    $P4325 = "vivitype"($P4324)
    $P4326 = $P4322."viviself"($P4325)
.annotate 'line', 1185
    set $P4309, $P4326
  if_4310_end:
.annotate 'line', 1183
    .return ($P4309)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4334"  :anon :subid("479_1303748459.273") :outer("478_1303748459.273")
.annotate 'line', 1193
    new $P4336, "Undef"
    .lex "$global_fallback", $P4336
    find_lex $P4337, "$/"
    unless_null $P4337, vivify_1929
    $P4337 = root_new ['parrot';'Hash']
  vivify_1929:
    set $P4338, $P4337["sigil"]
    unless_null $P4338, vivify_1930
    new $P4338, "Undef"
  vivify_1930:
    set $S4339, $P4338
    new $P4340, 'String'
    set $P4340, $S4339
    find_lex $P4341, "$/"
    unless_null $P4341, vivify_1931
    $P4341 = root_new ['parrot';'Hash']
  vivify_1931:
    set $P4342, $P4341["desigilname"]
    unless_null $P4342, vivify_1932
    new $P4342, "Undef"
  vivify_1932:
    concat $P4343, $P4340, $P4342
    new $P4344, "ResizablePMCArray"
    push $P4344, "GLOBAL"
    push $P4344, $P4343
    find_lex $P4345, "$/"
    unless_null $P4345, vivify_1933
    new $P4345, "Undef"
  vivify_1933:
    $P4346 = "lexical_package_lookup"($P4344, $P4345)
    store_lex "$global_fallback", $P4346
.annotate 'line', 1194
    find_lex $P4347, "$global_fallback"
    unless_null $P4347, vivify_1934
    new $P4347, "Undef"
  vivify_1934:
    get_hll_global $P4348, "GLOBAL"
    nqp_get_package_through_who $P4349, $P4348, "PAST"
    get_who $P4350, $P4349
    set $P4351, $P4350["Op"]
.annotate 'line', 1195
    new $P4352, "String"
    assign $P4352, "Contextual "
    find_lex $P4353, "$/"
    unless_null $P4353, vivify_1935
    new $P4353, "Undef"
  vivify_1935:
    set $S4354, $P4353
    concat $P4355, $P4352, $S4354
    concat $P4356, $P4355, " not found"
    $P4357 = $P4351."new"($P4356, "die" :named("pirop"))
.annotate 'line', 1194
    $P4347."viviself"($P4357)
.annotate 'line', 1198
    get_hll_global $P4358, "GLOBAL"
    nqp_get_package_through_who $P4359, $P4358, "PAST"
    get_who $P4360, $P4359
    set $P4361, $P4360["Var"]
.annotate 'line', 1199
    find_lex $P4362, "@name"
    unless_null $P4362, vivify_1936
    $P4362 = root_new ['parrot';'ResizablePMCArray']
  vivify_1936:
    $P4363 = $P4362."pop"()
    set $S4364, $P4363
    find_lex $P4365, "$global_fallback"
    unless_null $P4365, vivify_1937
    new $P4365, "Undef"
  vivify_1937:
    $P4366 = $P4361."new"($S4364 :named("name"), "contextual" :named("scope"), $P4365 :named("viviself"))
.annotate 'line', 1198
    store_lex "$past", $P4366
.annotate 'line', 1192
    .return ($P4366)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("480_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4425
    .param pmc param_4426
.annotate 'line', 1224
    .lex "self", param_4425
    .lex "$/", param_4426
    find_lex $P4427, "$/"
    find_lex $P4428, "$/"
    unless_null $P4428, vivify_1950
    $P4428 = root_new ['parrot';'Hash']
  vivify_1950:
    set $P4429, $P4428["package_def"]
    unless_null $P4429, vivify_1951
    new $P4429, "Undef"
  vivify_1951:
    $P4430 = $P4429."ast"()
    $P4431 = $P4427."!make"($P4430)
    .return ($P4431)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("481_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4433
    .param pmc param_4434
.annotate 'line', 1225
    .lex "self", param_4433
    .lex "$/", param_4434
    find_lex $P4435, "$/"
    find_lex $P4436, "$/"
    unless_null $P4436, vivify_1952
    $P4436 = root_new ['parrot';'Hash']
  vivify_1952:
    set $P4437, $P4436["package_def"]
    unless_null $P4437, vivify_1953
    new $P4437, "Undef"
  vivify_1953:
    $P4438 = $P4437."ast"()
    $P4439 = $P4435."!make"($P4438)
    .return ($P4439)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("482_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4441
    .param pmc param_4442
.annotate 'line', 1226
    .lex "self", param_4441
    .lex "$/", param_4442
    find_lex $P4443, "$/"
    find_lex $P4444, "$/"
    unless_null $P4444, vivify_1954
    $P4444 = root_new ['parrot';'Hash']
  vivify_1954:
    set $P4445, $P4444["package_def"]
    unless_null $P4445, vivify_1955
    new $P4445, "Undef"
  vivify_1955:
    $P4446 = $P4445."ast"()
    $P4447 = $P4443."!make"($P4446)
    .return ($P4447)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("483_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4449
    .param pmc param_4450
.annotate 'line', 1227
    .lex "self", param_4449
    .lex "$/", param_4450
    find_lex $P4451, "$/"
    find_lex $P4452, "$/"
    unless_null $P4452, vivify_1956
    $P4452 = root_new ['parrot';'Hash']
  vivify_1956:
    set $P4453, $P4452["package_def"]
    unless_null $P4453, vivify_1957
    new $P4453, "Undef"
  vivify_1957:
    $P4454 = $P4453."ast"()
    $P4455 = $P4451."!make"($P4454)
    .return ($P4455)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("484_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4457
    .param pmc param_4458
.annotate 'line', 1228
    .lex "self", param_4457
    .lex "$/", param_4458
    find_lex $P4459, "$/"
    find_lex $P4460, "$/"
    unless_null $P4460, vivify_1958
    $P4460 = root_new ['parrot';'Hash']
  vivify_1958:
    set $P4461, $P4460["package_def"]
    unless_null $P4461, vivify_1959
    new $P4461, "Undef"
  vivify_1959:
    $P4462 = $P4461."ast"()
    $P4463 = $P4459."!make"($P4462)
    .return ($P4463)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("485_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4465
    .param pmc param_4466
.annotate 'line', 1229
    .lex "self", param_4465
    .lex "$/", param_4466
    find_lex $P4467, "$/"
    find_lex $P4468, "$/"
    unless_null $P4468, vivify_1960
    $P4468 = root_new ['parrot';'Hash']
  vivify_1960:
    set $P4469, $P4468["package_def"]
    unless_null $P4469, vivify_1961
    new $P4469, "Undef"
  vivify_1961:
    $P4470 = $P4469."ast"()
    $P4471 = $P4467."!make"($P4470)
    .return ($P4471)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("486_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4473
    .param pmc param_4474
.annotate 'line', 1231
    .const 'Sub' $P4721 = "489_1303748459.273" 
    capture_lex $P4721
    .const 'Sub' $P4624 = "487_1303748459.273" 
    capture_lex $P4624
    .lex "self", param_4473
    .lex "$/", param_4474
.annotate 'line', 1233
    $P4475 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4475
.annotate 'line', 1234
    new $P4476, "Undef"
    .lex "$name", $P4476
.annotate 'line', 1235
    new $P4477, "Undef"
    .lex "$how", $P4477
.annotate 'line', 1238
    new $P4478, "Undef"
    .lex "$past", $P4478
.annotate 'line', 1233
    find_lex $P4479, "$/"
    unless_null $P4479, vivify_1962
    $P4479 = root_new ['parrot';'Hash']
  vivify_1962:
    set $P4480, $P4479["name"]
    unless_null $P4480, vivify_1963
    $P4480 = root_new ['parrot';'Hash']
  vivify_1963:
    set $P4481, $P4480["identifier"]
    unless_null $P4481, vivify_1964
    new $P4481, "Undef"
  vivify_1964:
    clone $P4482, $P4481
    store_lex "@ns", $P4482
.annotate 'line', 1234
    find_lex $P4483, "@ns"
    unless_null $P4483, vivify_1965
    $P4483 = root_new ['parrot';'ResizablePMCArray']
  vivify_1965:
    $P4484 = $P4483."pop"()
    set $S4485, $P4484
    new $P4486, 'String'
    set $P4486, $S4485
    store_lex "$name", $P4486
.annotate 'line', 1235
    find_dynamic_lex $P4489, "$*PKGDECL"
    unless_null $P4489, vivify_1966
    get_hll_global $P4487, "GLOBAL"
    get_who $P4488, $P4487
    set $P4489, $P4488["$PKGDECL"]
    unless_null $P4489, vivify_1967
    die "Contextual $*PKGDECL not found"
  vivify_1967:
  vivify_1966:
    find_dynamic_lex $P4492, "%*HOW"
    unless_null $P4492, vivify_1968
    get_hll_global $P4490, "GLOBAL"
    get_who $P4491, $P4490
    set $P4492, $P4491["%HOW"]
    unless_null $P4492, vivify_1969
    die "Contextual %*HOW not found"
  vivify_1969:
  vivify_1968:
    set $P4493, $P4492[$P4489]
    unless_null $P4493, vivify_1970
    new $P4493, "Undef"
  vivify_1970:
    store_lex "$how", $P4493
.annotate 'line', 1238
    find_lex $P4496, "$/"
    unless_null $P4496, vivify_1971
    $P4496 = root_new ['parrot';'Hash']
  vivify_1971:
    set $P4497, $P4496["block"]
    unless_null $P4497, vivify_1972
    new $P4497, "Undef"
  vivify_1972:
    if $P4497, if_4495
    find_lex $P4501, "$/"
    unless_null $P4501, vivify_1973
    $P4501 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P4502, $P4501["comp_unit"]
    unless_null $P4502, vivify_1974
    new $P4502, "Undef"
  vivify_1974:
    $P4503 = $P4502."ast"()
    set $P4494, $P4503
    goto if_4495_end
  if_4495:
    find_lex $P4498, "$/"
    unless_null $P4498, vivify_1975
    $P4498 = root_new ['parrot';'Hash']
  vivify_1975:
    set $P4499, $P4498["block"]
    unless_null $P4499, vivify_1976
    new $P4499, "Undef"
  vivify_1976:
    $P4500 = $P4499."ast"()
    set $P4494, $P4500
  if_4495_end:
    store_lex "$past", $P4494
.annotate 'line', 1239
    find_dynamic_lex $P4509, "$*SCOPE"
    unless_null $P4509, vivify_1977
    get_hll_global $P4507, "GLOBAL"
    get_who $P4508, $P4507
    set $P4509, $P4508["$SCOPE"]
    unless_null $P4509, vivify_1978
    die "Contextual $*SCOPE not found"
  vivify_1978:
  vivify_1977:
    set $S4510, $P4509
    iseq $I4511, $S4510, "our"
    unless $I4511, unless_4506
    new $P4505, 'Integer'
    set $P4505, $I4511
    goto unless_4506_end
  unless_4506:
    find_dynamic_lex $P4514, "$*SCOPE"
    unless_null $P4514, vivify_1979
    get_hll_global $P4512, "GLOBAL"
    get_who $P4513, $P4512
    set $P4514, $P4513["$SCOPE"]
    unless_null $P4514, vivify_1980
    die "Contextual $*SCOPE not found"
  vivify_1980:
  vivify_1979:
    set $S4515, $P4514
    iseq $I4516, $S4515, ""
    new $P4505, 'Integer'
    set $P4505, $I4516
  unless_4506_end:
    unless $P4505, if_4504_end
.annotate 'line', 1240
    find_lex $P4517, "$past"
    unless_null $P4517, vivify_1981
    new $P4517, "Undef"
  vivify_1981:
    find_lex $P4518, "$/"
    unless_null $P4518, vivify_1982
    $P4518 = root_new ['parrot';'Hash']
  vivify_1982:
    set $P4519, $P4518["name"]
    unless_null $P4519, vivify_1983
    $P4519 = root_new ['parrot';'Hash']
  vivify_1983:
    set $P4520, $P4519["identifier"]
    unless_null $P4520, vivify_1984
    new $P4520, "Undef"
  vivify_1984:
    $P4517."namespace"($P4520)
  if_4504_end:
.annotate 'line', 1244
    find_dynamic_lex $P4523, "$*PACKAGE-SETUP"
    unless_null $P4523, vivify_1985
    get_hll_global $P4521, "GLOBAL"
    get_who $P4522, $P4521
    set $P4523, $P4522["$PACKAGE-SETUP"]
    unless_null $P4523, vivify_1986
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1986:
  vivify_1985:
    get_hll_global $P4524, "GLOBAL"
    nqp_get_package_through_who $P4525, $P4524, "PAST"
    get_who $P4526, $P4525
    set $P4527, $P4526["Stmts"]
.annotate 'line', 1245
    get_hll_global $P4528, "GLOBAL"
    nqp_get_package_through_who $P4529, $P4528, "PAST"
    get_who $P4530, $P4529
    set $P4531, $P4530["Op"]
.annotate 'line', 1246
    get_hll_global $P4532, "GLOBAL"
    nqp_get_package_through_who $P4533, $P4532, "PAST"
    get_who $P4534, $P4533
    set $P4535, $P4534["Var"]
    $P4536 = $P4535."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1247
    find_dynamic_lex $P4539, "$*SC"
    unless_null $P4539, vivify_1987
    get_hll_global $P4537, "GLOBAL"
    get_who $P4538, $P4537
    set $P4539, $P4538["$SC"]
    unless_null $P4539, vivify_1988
    die "Contextual $*SC not found"
  vivify_1988:
  vivify_1987:
    find_dynamic_lex $P4542, "$*PACKAGE"
    unless_null $P4542, vivify_1989
    get_hll_global $P4540, "GLOBAL"
    get_who $P4541, $P4540
    set $P4542, $P4541["$PACKAGE"]
    unless_null $P4542, vivify_1990
    die "Contextual $*PACKAGE not found"
  vivify_1990:
  vivify_1989:
    $P4543 = $P4539."get_slot_past_for_object"($P4542)
    $P4544 = $P4531."new"($P4536, $P4543, "bind" :named("pasttype"))
.annotate 'line', 1245
    $P4545 = $P4527."new"($P4544)
.annotate 'line', 1244
    $P4523."unshift"($P4545)
.annotate 'line', 1256
    find_lex $P4549, "$how"
    unless_null $P4549, vivify_1991
    new $P4549, "Undef"
  vivify_1991:
    can $I4550, $P4549, "parametric"
    if $I4550, if_4548
    new $P4547, 'Integer'
    set $P4547, $I4550
    goto if_4548_end
  if_4548:
    find_lex $P4551, "$how"
    unless_null $P4551, vivify_1992
    new $P4551, "Undef"
  vivify_1992:
    find_lex $P4552, "$how"
    unless_null $P4552, vivify_1993
    new $P4552, "Undef"
  vivify_1993:
    $P4553 = $P4551."parametric"($P4552)
    set $P4547, $P4553
  if_4548_end:
    if $P4547, if_4546
.annotate 'line', 1274
    find_lex $P4605, "$past"
    unless_null $P4605, vivify_1994
    new $P4605, "Undef"
  vivify_1994:
    $P4605."blocktype"("immediate")
.annotate 'line', 1275
    find_dynamic_lex $P4608, "$*SC"
    unless_null $P4608, vivify_1995
    get_hll_global $P4606, "GLOBAL"
    get_who $P4607, $P4606
    set $P4608, $P4607["$SC"]
    unless_null $P4608, vivify_1996
    die "Contextual $*SC not found"
  vivify_1996:
  vivify_1995:
    find_lex $P4609, "$past"
    unless_null $P4609, vivify_1997
    new $P4609, "Undef"
  vivify_1997:
    find_dynamic_lex $P4612, "$*PACKAGE"
    unless_null $P4612, vivify_1998
    get_hll_global $P4610, "GLOBAL"
    get_who $P4611, $P4610
    set $P4612, $P4611["$PACKAGE"]
    unless_null $P4612, vivify_1999
    die "Contextual $*PACKAGE not found"
  vivify_1999:
  vivify_1998:
    $P4608."install_lexical_symbol"($P4609, "$?PACKAGE", $P4612)
.annotate 'line', 1276
    find_dynamic_lex $P4615, "$*SC"
    unless_null $P4615, vivify_2000
    get_hll_global $P4613, "GLOBAL"
    get_who $P4614, $P4613
    set $P4615, $P4614["$SC"]
    unless_null $P4615, vivify_2001
    die "Contextual $*SC not found"
  vivify_2001:
  vivify_2000:
    find_lex $P4616, "$past"
    unless_null $P4616, vivify_2002
    new $P4616, "Undef"
  vivify_2002:
    find_dynamic_lex $P4619, "$*PACKAGE"
    unless_null $P4619, vivify_2003
    get_hll_global $P4617, "GLOBAL"
    get_who $P4618, $P4617
    set $P4619, $P4618["$PACKAGE"]
    unless_null $P4619, vivify_2004
    die "Contextual $*PACKAGE not found"
  vivify_2004:
  vivify_2003:
    $P4615."install_lexical_symbol"($P4616, "$?CLASS", $P4619)
.annotate 'line', 1273
    goto if_4546_end
  if_4546:
.annotate 'line', 1257
    find_lex $P4554, "$past"
    unless_null $P4554, vivify_2005
    new $P4554, "Undef"
  vivify_2005:
    $P4554."blocktype"("declaration")
.annotate 'line', 1258
    find_lex $P4555, "$past"
    unless_null $P4555, vivify_2006
    new $P4555, "Undef"
  vivify_2006:
    get_hll_global $P4556, "GLOBAL"
    nqp_get_package_through_who $P4557, $P4556, "PAST"
    get_who $P4558, $P4557
    set $P4559, $P4558["Var"]
    $P4560 = $P4559."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4555."unshift"($P4560)
.annotate 'line', 1259
    find_lex $P4561, "$past"
    unless_null $P4561, vivify_2007
    new $P4561, "Undef"
  vivify_2007:
    $P4561."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1260
    find_dynamic_lex $P4564, "$*PACKAGE-SETUP"
    unless_null $P4564, vivify_2008
    get_hll_global $P4562, "GLOBAL"
    get_who $P4563, $P4562
    set $P4564, $P4563["$PACKAGE-SETUP"]
    unless_null $P4564, vivify_2009
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2009:
  vivify_2008:
    get_hll_global $P4565, "GLOBAL"
    nqp_get_package_through_who $P4566, $P4565, "PAST"
    get_who $P4567, $P4566
    set $P4568, $P4567["Op"]
.annotate 'line', 1262
    get_hll_global $P4569, "GLOBAL"
    nqp_get_package_through_who $P4570, $P4569, "PAST"
    get_who $P4571, $P4570
    set $P4572, $P4571["Op"]
.annotate 'line', 1265
    get_hll_global $P4573, "GLOBAL"
    nqp_get_package_through_who $P4574, $P4573, "PAST"
    get_who $P4575, $P4574
    set $P4576, $P4575["Var"]
    $P4577 = $P4576."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4578 = $P4572."new"($P4577, "get_how PP" :named("pirop"))
.annotate 'line', 1267
    get_hll_global $P4579, "GLOBAL"
    nqp_get_package_through_who $P4580, $P4579, "PAST"
    get_who $P4581, $P4580
    set $P4582, $P4581["Var"]
    $P4583 = $P4582."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1268
    get_hll_global $P4584, "GLOBAL"
    nqp_get_package_through_who $P4585, $P4584, "PAST"
    get_who $P4586, $P4585
    set $P4587, $P4586["Val"]
    find_lex $P4588, "$past"
    unless_null $P4588, vivify_2010
    new $P4588, "Undef"
  vivify_2010:
    $P4589 = $P4587."new"($P4588 :named("value"))
    $P4590 = $P4568."new"($P4578, $P4583, $P4589, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1260
    $P4564."push"($P4590)
.annotate 'line', 1270
    find_dynamic_lex $P4593, "$*SC"
    unless_null $P4593, vivify_2011
    get_hll_global $P4591, "GLOBAL"
    get_who $P4592, $P4591
    set $P4593, $P4592["$SC"]
    unless_null $P4593, vivify_2012
    die "Contextual $*SC not found"
  vivify_2012:
  vivify_2011:
    find_lex $P4594, "$past"
    unless_null $P4594, vivify_2013
    new $P4594, "Undef"
  vivify_2013:
    find_dynamic_lex $P4597, "$*PACKAGE"
    unless_null $P4597, vivify_2014
    get_hll_global $P4595, "GLOBAL"
    get_who $P4596, $P4595
    set $P4597, $P4596["$PACKAGE"]
    unless_null $P4597, vivify_2015
    die "Contextual $*PACKAGE not found"
  vivify_2015:
  vivify_2014:
    $P4593."install_lexical_symbol"($P4594, "$?PACKAGE", $P4597)
.annotate 'line', 1271
    find_dynamic_lex $P4600, "$*SC"
    unless_null $P4600, vivify_2016
    get_hll_global $P4598, "GLOBAL"
    get_who $P4599, $P4598
    set $P4600, $P4599["$SC"]
    unless_null $P4600, vivify_2017
    die "Contextual $*SC not found"
  vivify_2017:
  vivify_2016:
    find_lex $P4601, "$past"
    unless_null $P4601, vivify_2018
    new $P4601, "Undef"
  vivify_2018:
    find_dynamic_lex $P4604, "$*PACKAGE"
    unless_null $P4604, vivify_2019
    get_hll_global $P4602, "GLOBAL"
    get_who $P4603, $P4602
    set $P4604, $P4603["$PACKAGE"]
    unless_null $P4604, vivify_2020
    die "Contextual $*PACKAGE not found"
  vivify_2020:
  vivify_2019:
    $P4600."install_lexical_symbol"($P4601, "$?ROLE", $P4604)
  if_4546_end:
.annotate 'line', 1280
    find_lex $P4621, "$/"
    unless_null $P4621, vivify_2021
    $P4621 = root_new ['parrot';'Hash']
  vivify_2021:
    set $P4622, $P4621["parent"]
    unless_null $P4622, vivify_2022
    new $P4622, "Undef"
  vivify_2022:
    if $P4622, if_4620
.annotate 'line', 1294
    find_lex $P4668, "$how"
    unless_null $P4668, vivify_2023
    new $P4668, "Undef"
  vivify_2023:
    can $I4669, $P4668, "set_default_parent"
    unless $I4669, if_4667_end
.annotate 'line', 1296
    find_dynamic_lex $P4672, "$*PACKAGE-SETUP"
    unless_null $P4672, vivify_2024
    get_hll_global $P4670, "GLOBAL"
    get_who $P4671, $P4670
    set $P4672, $P4671["$PACKAGE-SETUP"]
    unless_null $P4672, vivify_2025
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2025:
  vivify_2024:
    get_hll_global $P4673, "GLOBAL"
    nqp_get_package_through_who $P4674, $P4673, "PAST"
    get_who $P4675, $P4674
    set $P4676, $P4675["Op"]
.annotate 'line', 1298
    get_hll_global $P4677, "GLOBAL"
    nqp_get_package_through_who $P4678, $P4677, "PAST"
    get_who $P4679, $P4678
    set $P4680, $P4679["Op"]
.annotate 'line', 1301
    get_hll_global $P4681, "GLOBAL"
    nqp_get_package_through_who $P4682, $P4681, "PAST"
    get_who $P4683, $P4682
    set $P4684, $P4683["Var"]
    $P4685 = $P4684."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4686 = $P4680."new"($P4685, "get_how PP" :named("pirop"))
.annotate 'line', 1303
    get_hll_global $P4687, "GLOBAL"
    nqp_get_package_through_who $P4688, $P4687, "PAST"
    get_who $P4689, $P4688
    set $P4690, $P4689["Var"]
    $P4691 = $P4690."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1304
    find_dynamic_lex $P4696, "$*PKGDECL"
    unless_null $P4696, vivify_2026
    get_hll_global $P4694, "GLOBAL"
    get_who $P4695, $P4694
    set $P4696, $P4695["$PKGDECL"]
    unless_null $P4696, vivify_2027
    die "Contextual $*PKGDECL not found"
  vivify_2027:
  vivify_2026:
    set $S4697, $P4696
    iseq $I4698, $S4697, "grammar"
    if $I4698, if_4693
.annotate 'line', 1306
    find_dynamic_lex $P4706, "$*SC"
    unless_null $P4706, vivify_2028
    get_hll_global $P4704, "GLOBAL"
    get_who $P4705, $P4704
    set $P4706, $P4705["$SC"]
    unless_null $P4706, vivify_2029
    die "Contextual $*SC not found"
  vivify_2029:
  vivify_2028:
    new $P4707, "ResizablePMCArray"
    push $P4707, "NQPMu"
    find_lex $P4708, "$/"
    unless_null $P4708, vivify_2030
    new $P4708, "Undef"
  vivify_2030:
    $P4709 = "find_sym"($P4707, $P4708)
    $P4710 = $P4706."get_object_sc_ref_past"($P4709)
    set $P4692, $P4710
.annotate 'line', 1304
    goto if_4693_end
  if_4693:
.annotate 'line', 1305
    get_hll_global $P4699, "GLOBAL"
    nqp_get_package_through_who $P4700, $P4699, "PAST"
    get_who $P4701, $P4700
    set $P4702, $P4701["Var"]
    $P4703 = $P4702."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    set $P4692, $P4703
  if_4693_end:
.annotate 'line', 1304
    $P4711 = $P4676."new"($P4686, $P4691, $P4692, "callmethod" :named("pasttype"), "set_default_parent" :named("name"))
.annotate 'line', 1296
    $P4672."push"($P4711)
  if_4667_end:
.annotate 'line', 1294
    goto if_4620_end
  if_4620:
.annotate 'line', 1280
    .const 'Sub' $P4624 = "487_1303748459.273" 
    capture_lex $P4624
    $P4624()
  if_4620_end:
.annotate 'line', 1311
    find_lex $P4713, "$/"
    unless_null $P4713, vivify_2048
    $P4713 = root_new ['parrot';'Hash']
  vivify_2048:
    set $P4714, $P4713["role"]
    unless_null $P4714, vivify_2049
    new $P4714, "Undef"
  vivify_2049:
    unless $P4714, if_4712_end
.annotate 'line', 1312
    find_lex $P4716, "$/"
    unless_null $P4716, vivify_2050
    $P4716 = root_new ['parrot';'Hash']
  vivify_2050:
    set $P4717, $P4716["role"]
    unless_null $P4717, vivify_2051
    new $P4717, "Undef"
  vivify_2051:
    defined $I4718, $P4717
    unless $I4718, for_undef_2052
    iter $P4715, $P4717
    new $P4765, 'ExceptionHandler'
    set_label $P4765, loop4764_handler
    $P4765."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4765
  loop4764_test:
    unless $P4715, loop4764_done
    shift $P4719, $P4715
  loop4764_redo:
    .const 'Sub' $P4721 = "489_1303748459.273" 
    capture_lex $P4721
    $P4721($P4719)
  loop4764_next:
    goto loop4764_test
  loop4764_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4766, exception, 'type'
    eq $P4766, .CONTROL_LOOP_NEXT, loop4764_next
    eq $P4766, .CONTROL_LOOP_REDO, loop4764_redo
  loop4764_done:
    pop_eh 
  for_undef_2052:
  if_4712_end:
.annotate 'line', 1329
    find_dynamic_lex $P4769, "$*PACKAGE-SETUP"
    unless_null $P4769, vivify_2060
    get_hll_global $P4767, "GLOBAL"
    get_who $P4768, $P4767
    set $P4769, $P4768["$PACKAGE-SETUP"]
    unless_null $P4769, vivify_2061
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2061:
  vivify_2060:
    get_hll_global $P4770, "GLOBAL"
    nqp_get_package_through_who $P4771, $P4770, "PAST"
    get_who $P4772, $P4771
    set $P4773, $P4772["Op"]
.annotate 'line', 1331
    get_hll_global $P4774, "GLOBAL"
    nqp_get_package_through_who $P4775, $P4774, "PAST"
    get_who $P4776, $P4775
    set $P4777, $P4776["Op"]
.annotate 'line', 1334
    get_hll_global $P4778, "GLOBAL"
    nqp_get_package_through_who $P4779, $P4778, "PAST"
    get_who $P4780, $P4779
    set $P4781, $P4780["Var"]
    $P4782 = $P4781."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4783 = $P4777."new"($P4782, "get_how PP" :named("pirop"))
.annotate 'line', 1336
    get_hll_global $P4784, "GLOBAL"
    nqp_get_package_through_who $P4785, $P4784, "PAST"
    get_who $P4786, $P4785
    set $P4787, $P4786["Var"]
    $P4788 = $P4787."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4789 = $P4773."new"($P4783, $P4788, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1329
    $P4769."push"($P4789)
.annotate 'line', 1340
    find_lex $P4790, "$past"
    unless_null $P4790, vivify_2062
    new $P4790, "Undef"
  vivify_2062:
    $P4791 = $P4790."loadinit"()
    get_hll_global $P4792, "GLOBAL"
    nqp_get_package_through_who $P4793, $P4792, "PAST"
    get_who $P4794, $P4793
    set $P4795, $P4794["Block"]
    find_dynamic_lex $P4798, "$*PACKAGE-SETUP"
    unless_null $P4798, vivify_2063
    get_hll_global $P4796, "GLOBAL"
    get_who $P4797, $P4796
    set $P4798, $P4797["$PACKAGE-SETUP"]
    unless_null $P4798, vivify_2064
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2064:
  vivify_2063:
    $P4799 = $P4795."new"($P4798, "immediate" :named("blocktype"))
    $P4791."push"($P4799)
.annotate 'line', 1342
    find_lex $P4800, "$/"
    find_lex $P4801, "$past"
    unless_null $P4801, vivify_2065
    new $P4801, "Undef"
  vivify_2065:
    $P4802 = $P4800."!make"($P4801)
.annotate 'line', 1231
    .return ($P4802)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4623"  :anon :subid("487_1303748459.273") :outer("486_1303748459.273")
.annotate 'line', 1280
    .const 'Sub' $P4630 = "488_1303748459.273" 
    capture_lex $P4630
.annotate 'line', 1281
    new $P4625, "Undef"
    .lex "$parent", $P4625
.annotate 'line', 1282
    new $P4626, "Undef"
    .lex "$parent_found", $P4626
.annotate 'line', 1280
    find_lex $P4627, "$parent"
    unless_null $P4627, vivify_2031
    new $P4627, "Undef"
  vivify_2031:
    find_lex $P4628, "$parent_found"
    unless_null $P4628, vivify_2032
    new $P4628, "Undef"
  vivify_2032:
.annotate 'line', 1283
    .const 'Sub' $P4630 = "488_1303748459.273" 
    capture_lex $P4630
    $P4630()
.annotate 'line', 1287
    find_lex $P4648, "$parent_found"
    unless_null $P4648, vivify_2038
    new $P4648, "Undef"
  vivify_2038:
    if $P4648, if_4647
.annotate 'line', 1291
    find_lex $P4657, "$/"
    unless_null $P4657, vivify_2039
    new $P4657, "Undef"
  vivify_2039:
    $P4658 = $P4657."CURSOR"()
    new $P4659, "String"
    assign $P4659, "Could not find parent class '"
    find_lex $P4660, "$/"
    unless_null $P4660, vivify_2040
    $P4660 = root_new ['parrot';'Hash']
  vivify_2040:
    set $P4661, $P4660["parent"]
    unless_null $P4661, vivify_2041
    $P4661 = root_new ['parrot';'ResizablePMCArray']
  vivify_2041:
    set $P4662, $P4661[0]
    unless_null $P4662, vivify_2042
    new $P4662, "Undef"
  vivify_2042:
    set $S4663, $P4662
    concat $P4664, $P4659, $S4663
    concat $P4665, $P4664, "'"
    $P4666 = $P4658."panic"($P4665)
.annotate 'line', 1290
    set $P4646, $P4666
.annotate 'line', 1287
    goto if_4647_end
  if_4647:
.annotate 'line', 1288
    find_dynamic_lex $P4651, "$*SC"
    unless_null $P4651, vivify_2043
    get_hll_global $P4649, "GLOBAL"
    get_who $P4650, $P4649
    set $P4651, $P4650["$SC"]
    unless_null $P4651, vivify_2044
    die "Contextual $*SC not found"
  vivify_2044:
  vivify_2043:
    find_dynamic_lex $P4654, "$*PACKAGE"
    unless_null $P4654, vivify_2045
    get_hll_global $P4652, "GLOBAL"
    get_who $P4653, $P4652
    set $P4654, $P4653["$PACKAGE"]
    unless_null $P4654, vivify_2046
    die "Contextual $*PACKAGE not found"
  vivify_2046:
  vivify_2045:
    find_lex $P4655, "$parent"
    unless_null $P4655, vivify_2047
    new $P4655, "Undef"
  vivify_2047:
    $P4656 = $P4651."pkg_add_parent_or_role"($P4654, "add_parent", $P4655)
.annotate 'line', 1287
    set $P4646, $P4656
  if_4647_end:
.annotate 'line', 1280
    .return ($P4646)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4629"  :anon :subid("488_1303748459.273") :outer("487_1303748459.273")
.annotate 'line', 1283
    new $P4641, 'ExceptionHandler'
    set_label $P4641, control_4640
    $P4641."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4641
.annotate 'line', 1284
    find_lex $P4631, "$/"
    unless_null $P4631, vivify_2033
    $P4631 = root_new ['parrot';'Hash']
  vivify_2033:
    set $P4632, $P4631["parent"]
    unless_null $P4632, vivify_2034
    $P4632 = root_new ['parrot';'ResizablePMCArray']
  vivify_2034:
    set $P4633, $P4632[0]
    unless_null $P4633, vivify_2035
    $P4633 = root_new ['parrot';'Hash']
  vivify_2035:
    set $P4634, $P4633["identifier"]
    unless_null $P4634, vivify_2036
    new $P4634, "Undef"
  vivify_2036:
    clone $P4635, $P4634
    find_lex $P4636, "$/"
    unless_null $P4636, vivify_2037
    new $P4636, "Undef"
  vivify_2037:
    $P4637 = "find_sym"($P4635, $P4636)
    store_lex "$parent", $P4637
.annotate 'line', 1285
    new $P4638, "Integer"
    assign $P4638, 1
    store_lex "$parent_found", $P4638
.annotate 'line', 1283
    pop_eh 
    goto skip_handler_4639
  control_4640:
    .local pmc exception 
    .get_results (exception) 
    new $P4644, 'Integer'
    set $P4644, 1
    set exception["handled"], $P4644
    set $I4645, exception["handled"]
    ne $I4645, 1, nothandled_4643
  handled_4642:
    .return (exception)
  nothandled_4643:
    rethrow exception
  skip_handler_4639:
    .return ($P4638)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4720"  :anon :subid("489_1303748459.273") :outer("486_1303748459.273")
    .param pmc param_4724
.annotate 'line', 1313
    $P4722 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4722
.annotate 'line', 1314
    new $P4723, "Undef"
    .lex "$name", $P4723
    .lex "$_", param_4724
.annotate 'line', 1313
    find_lex $P4725, "$_"
    unless_null $P4725, vivify_2053
    $P4725 = root_new ['parrot';'Hash']
  vivify_2053:
    set $P4726, $P4725["identifier"]
    unless_null $P4726, vivify_2054
    new $P4726, "Undef"
  vivify_2054:
    clone $P4727, $P4726
    store_lex "@ns", $P4727
.annotate 'line', 1314
    find_lex $P4728, "@ns"
    unless_null $P4728, vivify_2055
    $P4728 = root_new ['parrot';'ResizablePMCArray']
  vivify_2055:
    $P4729 = $P4728."pop"()
    set $S4730, $P4729
    new $P4731, 'String'
    set $P4731, $S4730
    store_lex "$name", $P4731
.annotate 'line', 1315
    find_dynamic_lex $P4734, "$*PACKAGE-SETUP"
    unless_null $P4734, vivify_2056
    get_hll_global $P4732, "GLOBAL"
    get_who $P4733, $P4732
    set $P4734, $P4733["$PACKAGE-SETUP"]
    unless_null $P4734, vivify_2057
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2057:
  vivify_2056:
    get_hll_global $P4735, "GLOBAL"
    nqp_get_package_through_who $P4736, $P4735, "PAST"
    get_who $P4737, $P4736
    set $P4738, $P4737["Op"]
.annotate 'line', 1317
    get_hll_global $P4739, "GLOBAL"
    nqp_get_package_through_who $P4740, $P4739, "PAST"
    get_who $P4741, $P4740
    set $P4742, $P4741["Op"]
.annotate 'line', 1320
    get_hll_global $P4743, "GLOBAL"
    nqp_get_package_through_who $P4744, $P4743, "PAST"
    get_who $P4745, $P4744
    set $P4746, $P4745["Var"]
    $P4747 = $P4746."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4748 = $P4742."new"($P4747, "get_how PP" :named("pirop"))
.annotate 'line', 1322
    get_hll_global $P4749, "GLOBAL"
    nqp_get_package_through_who $P4750, $P4749, "PAST"
    get_who $P4751, $P4750
    set $P4752, $P4751["Var"]
    $P4753 = $P4752."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1323
    get_hll_global $P4754, "GLOBAL"
    nqp_get_package_through_who $P4755, $P4754, "PAST"
    get_who $P4756, $P4755
    set $P4757, $P4756["Var"]
    find_lex $P4758, "$name"
    unless_null $P4758, vivify_2058
    new $P4758, "Undef"
  vivify_2058:
    set $S4759, $P4758
    find_lex $P4760, "@ns"
    unless_null $P4760, vivify_2059
    $P4760 = root_new ['parrot';'ResizablePMCArray']
  vivify_2059:
    $P4761 = $P4757."new"($S4759 :named("name"), $P4760 :named("namespace"), "package" :named("scope"))
    $P4762 = $P4738."new"($P4748, $P4753, $P4761, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1315
    $P4763 = $P4734."push"($P4762)
.annotate 'line', 1312
    .return ($P4763)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("490_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4804
    .param pmc param_4805
.annotate 'line', 1345
    .lex "self", param_4804
    .lex "$/", param_4805
    find_lex $P4806, "$/"
    find_lex $P4807, "$/"
    unless_null $P4807, vivify_2066
    $P4807 = root_new ['parrot';'Hash']
  vivify_2066:
    set $P4808, $P4807["scoped"]
    unless_null $P4808, vivify_2067
    new $P4808, "Undef"
  vivify_2067:
    $P4809 = $P4808."ast"()
    $P4810 = $P4806."!make"($P4809)
    .return ($P4810)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("491_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4812
    .param pmc param_4813
.annotate 'line', 1346
    .lex "self", param_4812
    .lex "$/", param_4813
    find_lex $P4814, "$/"
    find_lex $P4815, "$/"
    unless_null $P4815, vivify_2068
    $P4815 = root_new ['parrot';'Hash']
  vivify_2068:
    set $P4816, $P4815["scoped"]
    unless_null $P4816, vivify_2069
    new $P4816, "Undef"
  vivify_2069:
    $P4817 = $P4816."ast"()
    $P4818 = $P4814."!make"($P4817)
    .return ($P4818)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("492_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4820
    .param pmc param_4821
.annotate 'line', 1347
    .lex "self", param_4820
    .lex "$/", param_4821
    find_lex $P4822, "$/"
    find_lex $P4823, "$/"
    unless_null $P4823, vivify_2070
    $P4823 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P4824, $P4823["scoped"]
    unless_null $P4824, vivify_2071
    new $P4824, "Undef"
  vivify_2071:
    $P4825 = $P4824."ast"()
    $P4826 = $P4822."!make"($P4825)
    .return ($P4826)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("493_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4828
    .param pmc param_4829
.annotate 'line', 1349
    .lex "self", param_4828
    .lex "$/", param_4829
.annotate 'line', 1350
    find_lex $P4830, "$/"
    find_lex $P4833, "$/"
    unless_null $P4833, vivify_2072
    $P4833 = root_new ['parrot';'Hash']
  vivify_2072:
    set $P4834, $P4833["declarator"]
    unless_null $P4834, vivify_2073
    new $P4834, "Undef"
  vivify_2073:
    if $P4834, if_4832
.annotate 'line', 1351
    find_lex $P4840, "$/"
    unless_null $P4840, vivify_2074
    $P4840 = root_new ['parrot';'Hash']
  vivify_2074:
    set $P4841, $P4840["multi_declarator"]
    unless_null $P4841, vivify_2075
    new $P4841, "Undef"
  vivify_2075:
    if $P4841, if_4839
.annotate 'line', 1352
    find_lex $P4845, "$/"
    unless_null $P4845, vivify_2076
    $P4845 = root_new ['parrot';'Hash']
  vivify_2076:
    set $P4846, $P4845["package_declarator"]
    unless_null $P4846, vivify_2077
    new $P4846, "Undef"
  vivify_2077:
    $P4847 = $P4846."ast"()
    set $P4838, $P4847
.annotate 'line', 1351
    goto if_4839_end
  if_4839:
    find_lex $P4842, "$/"
    unless_null $P4842, vivify_2078
    $P4842 = root_new ['parrot';'Hash']
  vivify_2078:
    set $P4843, $P4842["multi_declarator"]
    unless_null $P4843, vivify_2079
    new $P4843, "Undef"
  vivify_2079:
    $P4844 = $P4843."ast"()
    set $P4838, $P4844
  if_4839_end:
    set $P4831, $P4838
.annotate 'line', 1350
    goto if_4832_end
  if_4832:
    find_lex $P4835, "$/"
    unless_null $P4835, vivify_2080
    $P4835 = root_new ['parrot';'Hash']
  vivify_2080:
    set $P4836, $P4835["declarator"]
    unless_null $P4836, vivify_2081
    new $P4836, "Undef"
  vivify_2081:
    $P4837 = $P4836."ast"()
    set $P4831, $P4837
  if_4832_end:
    $P4848 = $P4830."!make"($P4831)
.annotate 'line', 1349
    .return ($P4848)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("494_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4850
    .param pmc param_4851
.annotate 'line', 1355
    .lex "self", param_4850
    .lex "$/", param_4851
.annotate 'line', 1356
    find_lex $P4852, "$/"
.annotate 'line', 1357
    find_lex $P4855, "$/"
    unless_null $P4855, vivify_2082
    $P4855 = root_new ['parrot';'Hash']
  vivify_2082:
    set $P4856, $P4855["routine_declarator"]
    unless_null $P4856, vivify_2083
    new $P4856, "Undef"
  vivify_2083:
    if $P4856, if_4854
.annotate 'line', 1358
    find_lex $P4860, "$/"
    unless_null $P4860, vivify_2084
    $P4860 = root_new ['parrot';'Hash']
  vivify_2084:
    set $P4861, $P4860["variable_declarator"]
    unless_null $P4861, vivify_2085
    new $P4861, "Undef"
  vivify_2085:
    $P4862 = $P4861."ast"()
    set $P4853, $P4862
.annotate 'line', 1357
    goto if_4854_end
  if_4854:
    find_lex $P4857, "$/"
    unless_null $P4857, vivify_2086
    $P4857 = root_new ['parrot';'Hash']
  vivify_2086:
    set $P4858, $P4857["routine_declarator"]
    unless_null $P4858, vivify_2087
    new $P4858, "Undef"
  vivify_2087:
    $P4859 = $P4858."ast"()
    set $P4853, $P4859
  if_4854_end:
    $P4863 = $P4852."!make"($P4853)
.annotate 'line', 1355
    .return ($P4863)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("495_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4865
    .param pmc param_4866
.annotate 'line', 1361
    .lex "self", param_4865
    .lex "$/", param_4866
    find_lex $P4867, "$/"
    find_lex $P4870, "$/"
    unless_null $P4870, vivify_2088
    $P4870 = root_new ['parrot';'Hash']
  vivify_2088:
    set $P4871, $P4870["declarator"]
    unless_null $P4871, vivify_2089
    new $P4871, "Undef"
  vivify_2089:
    if $P4871, if_4869
    find_lex $P4875, "$/"
    unless_null $P4875, vivify_2090
    $P4875 = root_new ['parrot';'Hash']
  vivify_2090:
    set $P4876, $P4875["routine_def"]
    unless_null $P4876, vivify_2091
    new $P4876, "Undef"
  vivify_2091:
    $P4877 = $P4876."ast"()
    set $P4868, $P4877
    goto if_4869_end
  if_4869:
    find_lex $P4872, "$/"
    unless_null $P4872, vivify_2092
    $P4872 = root_new ['parrot';'Hash']
  vivify_2092:
    set $P4873, $P4872["declarator"]
    unless_null $P4873, vivify_2093
    new $P4873, "Undef"
  vivify_2093:
    $P4874 = $P4873."ast"()
    set $P4868, $P4874
  if_4869_end:
    $P4878 = $P4867."!make"($P4868)
    .return ($P4878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("496_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4880
    .param pmc param_4881
.annotate 'line', 1362
    .lex "self", param_4880
    .lex "$/", param_4881
    find_lex $P4882, "$/"
    find_lex $P4885, "$/"
    unless_null $P4885, vivify_2094
    $P4885 = root_new ['parrot';'Hash']
  vivify_2094:
    set $P4886, $P4885["declarator"]
    unless_null $P4886, vivify_2095
    new $P4886, "Undef"
  vivify_2095:
    if $P4886, if_4884
    find_lex $P4890, "$/"
    unless_null $P4890, vivify_2096
    $P4890 = root_new ['parrot';'Hash']
  vivify_2096:
    set $P4891, $P4890["routine_def"]
    unless_null $P4891, vivify_2097
    new $P4891, "Undef"
  vivify_2097:
    $P4892 = $P4891."ast"()
    set $P4883, $P4892
    goto if_4884_end
  if_4884:
    find_lex $P4887, "$/"
    unless_null $P4887, vivify_2098
    $P4887 = root_new ['parrot';'Hash']
  vivify_2098:
    set $P4888, $P4887["declarator"]
    unless_null $P4888, vivify_2099
    new $P4888, "Undef"
  vivify_2099:
    $P4889 = $P4888."ast"()
    set $P4883, $P4889
  if_4884_end:
    $P4893 = $P4882."!make"($P4883)
    .return ($P4893)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("497_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4895
    .param pmc param_4896
.annotate 'line', 1363
    .lex "self", param_4895
    .lex "$/", param_4896
    find_lex $P4897, "$/"
    find_lex $P4898, "$/"
    unless_null $P4898, vivify_2100
    $P4898 = root_new ['parrot';'Hash']
  vivify_2100:
    set $P4899, $P4898["declarator"]
    unless_null $P4899, vivify_2101
    new $P4899, "Undef"
  vivify_2101:
    $P4900 = $P4899."ast"()
    $P4901 = $P4897."!make"($P4900)
    .return ($P4901)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("498_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_4903
    .param pmc param_4904
.annotate 'line', 1366
    .const 'Sub' $P4938 = "499_1303748459.273" 
    capture_lex $P4938
    .lex "self", param_4903
    .lex "$/", param_4904
.annotate 'line', 1367
    new $P4905, "Undef"
    .lex "$past", $P4905
.annotate 'line', 1368
    new $P4906, "Undef"
    .lex "$sigil", $P4906
.annotate 'line', 1369
    new $P4907, "Undef"
    .lex "$name", $P4907
.annotate 'line', 1370
    new $P4908, "Undef"
    .lex "$BLOCK", $P4908
.annotate 'line', 1367
    find_lex $P4909, "$/"
    unless_null $P4909, vivify_2102
    $P4909 = root_new ['parrot';'Hash']
  vivify_2102:
    set $P4910, $P4909["variable"]
    unless_null $P4910, vivify_2103
    new $P4910, "Undef"
  vivify_2103:
    $P4911 = $P4910."ast"()
    store_lex "$past", $P4911
.annotate 'line', 1368
    find_lex $P4912, "$/"
    unless_null $P4912, vivify_2104
    $P4912 = root_new ['parrot';'Hash']
  vivify_2104:
    set $P4913, $P4912["variable"]
    unless_null $P4913, vivify_2105
    $P4913 = root_new ['parrot';'Hash']
  vivify_2105:
    set $P4914, $P4913["sigil"]
    unless_null $P4914, vivify_2106
    new $P4914, "Undef"
  vivify_2106:
    store_lex "$sigil", $P4914
.annotate 'line', 1369
    find_lex $P4915, "$past"
    unless_null $P4915, vivify_2107
    new $P4915, "Undef"
  vivify_2107:
    $P4916 = $P4915."name"()
    store_lex "$name", $P4916
.annotate 'line', 1370
    find_lex $P4917, "$?PACKAGE"
    get_who $P4918, $P4917
    set $P4919, $P4918["@BLOCK"]
    unless_null $P4919, vivify_2108
    $P4919 = root_new ['parrot';'ResizablePMCArray']
  vivify_2108:
    set $P4920, $P4919[0]
    unless_null $P4920, vivify_2109
    new $P4920, "Undef"
  vivify_2109:
    store_lex "$BLOCK", $P4920
.annotate 'line', 1371
    find_lex $P4924, "$name"
    unless_null $P4924, vivify_2110
    new $P4924, "Undef"
  vivify_2110:
    if $P4924, if_4923
    set $P4922, $P4924
    goto if_4923_end
  if_4923:
    find_lex $P4925, "$BLOCK"
    unless_null $P4925, vivify_2111
    new $P4925, "Undef"
  vivify_2111:
    find_lex $P4926, "$name"
    unless_null $P4926, vivify_2112
    new $P4926, "Undef"
  vivify_2112:
    $P4927 = $P4925."symbol"($P4926)
    set $P4922, $P4927
  if_4923_end:
    unless $P4922, if_4921_end
.annotate 'line', 1372
    find_lex $P4928, "$/"
    unless_null $P4928, vivify_2113
    new $P4928, "Undef"
  vivify_2113:
    $P4929 = $P4928."CURSOR"()
    find_lex $P4930, "$name"
    unless_null $P4930, vivify_2114
    new $P4930, "Undef"
  vivify_2114:
    $P4929."panic"("Redeclaration of symbol ", $P4930)
  if_4921_end:
.annotate 'line', 1374
    find_dynamic_lex $P4934, "$*SCOPE"
    unless_null $P4934, vivify_2115
    get_hll_global $P4932, "GLOBAL"
    get_who $P4933, $P4932
    set $P4934, $P4933["$SCOPE"]
    unless_null $P4934, vivify_2116
    die "Contextual $*SCOPE not found"
  vivify_2116:
  vivify_2115:
    set $S4935, $P4934
    iseq $I4936, $S4935, "has"
    if $I4936, if_4931
.annotate 'line', 1399
    find_dynamic_lex $P5017, "$*SCOPE"
    unless_null $P5017, vivify_2117
    get_hll_global $P5015, "GLOBAL"
    get_who $P5016, $P5015
    set $P5017, $P5016["$SCOPE"]
    unless_null $P5017, vivify_2118
    die "Contextual $*SCOPE not found"
  vivify_2118:
  vivify_2117:
    set $S5018, $P5017
    iseq $I5019, $S5018, "our"
    if $I5019, if_5014
.annotate 'line', 1409
    find_lex $P5033, "$BLOCK"
    unless_null $P5033, vivify_2119
    $P5033 = root_new ['parrot';'ResizablePMCArray']
  vivify_2119:
    set $P5034, $P5033[0]
    unless_null $P5034, vivify_2120
    new $P5034, "Undef"
  vivify_2120:
    get_hll_global $P5035, "GLOBAL"
    nqp_get_package_through_who $P5036, $P5035, "PAST"
    get_who $P5037, $P5036
    set $P5038, $P5037["Var"]
    find_lex $P5039, "$name"
    unless_null $P5039, vivify_2121
    new $P5039, "Undef"
  vivify_2121:
.annotate 'line', 1411
    find_lex $P5040, "$sigil"
    unless_null $P5040, vivify_2122
    new $P5040, "Undef"
  vivify_2122:
    $P5041 = "vivitype"($P5040)
    find_lex $P5042, "$/"
    unless_null $P5042, vivify_2123
    new $P5042, "Undef"
  vivify_2123:
    $P5043 = $P5038."new"($P5039 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P5041 :named("viviself"), $P5042 :named("node"))
.annotate 'line', 1409
    $P5034."push"($P5043)
.annotate 'line', 1414
    find_lex $P5044, "$BLOCK"
    unless_null $P5044, vivify_2124
    new $P5044, "Undef"
  vivify_2124:
    find_lex $P5045, "$name"
    unless_null $P5045, vivify_2125
    new $P5045, "Undef"
  vivify_2125:
    $P5044."symbol"($P5045, "lexical" :named("scope"))
.annotate 'line', 1408
    goto if_5014_end
  if_5014:
.annotate 'line', 1403
    find_lex $P5020, "$/"
    unless_null $P5020, vivify_2126
    $P5020 = root_new ['parrot';'Hash']
  vivify_2126:
    set $P5021, $P5020["variable"]
    unless_null $P5021, vivify_2127
    new $P5021, "Undef"
  vivify_2127:
    set $S5022, $P5021
    new $P5023, 'String'
    set $P5023, $S5022
    store_lex "$name", $P5023
.annotate 'line', 1404
    find_lex $P5024, "$name"
    unless_null $P5024, vivify_2128
    new $P5024, "Undef"
  vivify_2128:
    new $P5025, "ResizablePMCArray"
    push $P5025, $P5024
    find_lex $P5026, "$/"
    unless_null $P5026, vivify_2129
    new $P5026, "Undef"
  vivify_2129:
    $P5027 = "lexical_package_lookup"($P5025, $P5026)
    store_lex "$past", $P5027
.annotate 'line', 1405
    find_lex $P5028, "$past"
    unless_null $P5028, vivify_2130
    new $P5028, "Undef"
  vivify_2130:
    find_lex $P5029, "$sigil"
    unless_null $P5029, vivify_2131
    new $P5029, "Undef"
  vivify_2131:
    $P5030 = "vivitype"($P5029)
    $P5028."viviself"($P5030)
.annotate 'line', 1406
    find_lex $P5031, "$BLOCK"
    unless_null $P5031, vivify_2132
    new $P5031, "Undef"
  vivify_2132:
    find_lex $P5032, "$name"
    unless_null $P5032, vivify_2133
    new $P5032, "Undef"
  vivify_2133:
    $P5031."symbol"($P5032, "package" :named("scope"))
  if_5014_end:
.annotate 'line', 1399
    goto if_4931_end
  if_4931:
.annotate 'line', 1374
    .const 'Sub' $P4938 = "499_1303748459.273" 
    capture_lex $P4938
    $P4938()
  if_4931_end:
.annotate 'line', 1416
    find_lex $P5046, "$/"
    find_lex $P5047, "$past"
    unless_null $P5047, vivify_2155
    new $P5047, "Undef"
  vivify_2155:
    $P5048 = $P5046."!make"($P5047)
.annotate 'line', 1366
    .return ($P5048)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4937"  :anon :subid("499_1303748459.273") :outer("498_1303748459.273")
.annotate 'line', 1374
    .const 'Sub' $P4997 = "500_1303748459.273" 
    capture_lex $P4997
.annotate 'line', 1376
    new $P4939, "Undef"
    .lex "$meta-attr-type", $P4939
.annotate 'line', 1384
    new $P4940, "Undef"
    .lex "$meta_args", $P4940
.annotate 'line', 1376
    find_dynamic_lex $P4945, "$*PKGDECL"
    unless_null $P4945, vivify_2134
    get_hll_global $P4943, "GLOBAL"
    get_who $P4944, $P4943
    set $P4945, $P4944["$PKGDECL"]
    unless_null $P4945, vivify_2135
    die "Contextual $*PKGDECL not found"
  vivify_2135:
  vivify_2134:
    find_dynamic_lex $P4948, "%*HOW-METAATTR"
    unless_null $P4948, vivify_2136
    get_hll_global $P4946, "GLOBAL"
    get_who $P4947, $P4946
    set $P4948, $P4947["%HOW-METAATTR"]
    unless_null $P4948, vivify_2137
    die "Contextual %*HOW-METAATTR not found"
  vivify_2137:
  vivify_2136:
    set $P4949, $P4948[$P4945]
    unless_null $P4949, vivify_2138
    new $P4949, "Undef"
  vivify_2138:
    unless $P4949, unless_4942
    set $P4941, $P4949
    goto unless_4942_end
  unless_4942:
    find_dynamic_lex $P4952, "$*DEFAULT-METAATTR"
    unless_null $P4952, vivify_2139
    get_hll_global $P4950, "GLOBAL"
    get_who $P4951, $P4950
    set $P4952, $P4951["$DEFAULT-METAATTR"]
    unless_null $P4952, vivify_2140
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_2140:
  vivify_2139:
    set $P4941, $P4952
  unless_4942_end:
    store_lex "$meta-attr-type", $P4941
.annotate 'line', 1377
    find_dynamic_lex $P4955, "$*PACKAGE-SETUP"
    unless_null $P4955, vivify_2141
    get_hll_global $P4953, "GLOBAL"
    get_who $P4954, $P4953
    set $P4955, $P4954["$PACKAGE-SETUP"]
    unless_null $P4955, vivify_2142
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2142:
  vivify_2141:
    get_hll_global $P4956, "GLOBAL"
    nqp_get_package_through_who $P4957, $P4956, "PAST"
    get_who $P4958, $P4957
    set $P4959, $P4958["Op"]
.annotate 'line', 1379
    get_hll_global $P4960, "GLOBAL"
    nqp_get_package_through_who $P4961, $P4960, "PAST"
    get_who $P4962, $P4961
    set $P4963, $P4962["Op"]
.annotate 'line', 1381
    get_hll_global $P4964, "GLOBAL"
    nqp_get_package_through_who $P4965, $P4964, "PAST"
    get_who $P4966, $P4965
    set $P4967, $P4966["Var"]
    $P4968 = $P4967."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4969 = $P4963."new"($P4968, "get_how PP" :named("pirop"))
.annotate 'line', 1383
    get_hll_global $P4970, "GLOBAL"
    nqp_get_package_through_who $P4971, $P4970, "PAST"
    get_who $P4972, $P4971
    set $P4973, $P4972["Var"]
    $P4974 = $P4973."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1384
    get_hll_global $P4975, "GLOBAL"
    nqp_get_package_through_who $P4976, $P4975, "PAST"
    get_who $P4977, $P4976
    set $P4978, $P4977["Op"]
.annotate 'line', 1386
    get_hll_global $P4979, "GLOBAL"
    nqp_get_package_through_who $P4980, $P4979, "PAST"
    get_who $P4981, $P4980
    set $P4982, $P4981["Var"]
    find_lex $P4983, "$meta-attr-type"
    unless_null $P4983, vivify_2143
    new $P4983, "Undef"
  vivify_2143:
    $P4984 = $P4982."new"($P4983 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1387
    get_hll_global $P4985, "GLOBAL"
    nqp_get_package_through_who $P4986, $P4985, "PAST"
    get_who $P4987, $P4986
    set $P4988, $P4987["Val"]
    find_lex $P4989, "$name"
    unless_null $P4989, vivify_2144
    new $P4989, "Undef"
  vivify_2144:
    $P4990 = $P4988."new"($P4989 :named("value"), "name" :named("named"))
    $P4991 = $P4978."new"($P4984, $P4990, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1384
    store_lex "$meta_args", $P4991
    $P4992 = $P4959."new"($P4969, $P4974, $P4991, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1377
    $P4955."push"($P4992)
.annotate 'line', 1390
    find_lex $P4994, "$/"
    unless_null $P4994, vivify_2145
    $P4994 = root_new ['parrot';'Hash']
  vivify_2145:
    set $P4995, $P4994["typename"]
    unless_null $P4995, vivify_2146
    new $P4995, "Undef"
  vivify_2146:
    unless $P4995, if_4993_end
    .const 'Sub' $P4997 = "500_1303748459.273" 
    capture_lex $P4997
    $P4997()
  if_4993_end:
.annotate 'line', 1396
    find_lex $P5007, "$BLOCK"
    unless_null $P5007, vivify_2153
    new $P5007, "Undef"
  vivify_2153:
    find_lex $P5008, "$name"
    unless_null $P5008, vivify_2154
    new $P5008, "Undef"
  vivify_2154:
    $P5007."symbol"($P5008, "attribute" :named("scope"))
.annotate 'line', 1397
    get_hll_global $P5009, "GLOBAL"
    nqp_get_package_through_who $P5010, $P5009, "PAST"
    get_who $P5011, $P5010
    set $P5012, $P5011["Stmts"]
    $P5013 = $P5012."new"()
    store_lex "$past", $P5013
.annotate 'line', 1374
    .return ($P5013)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4996"  :anon :subid("500_1303748459.273") :outer("499_1303748459.273")
.annotate 'line', 1391
    new $P4998, "Undef"
    .lex "$type", $P4998
    find_lex $P4999, "$/"
    unless_null $P4999, vivify_2147
    $P4999 = root_new ['parrot';'Hash']
  vivify_2147:
    set $P5000, $P4999["typename"]
    unless_null $P5000, vivify_2148
    $P5000 = root_new ['parrot';'ResizablePMCArray']
  vivify_2148:
    set $P5001, $P5000[0]
    unless_null $P5001, vivify_2149
    new $P5001, "Undef"
  vivify_2149:
    $P5002 = $P5001."ast"()
    store_lex "$type", $P5002
.annotate 'line', 1392
    find_lex $P5003, "$type"
    unless_null $P5003, vivify_2150
    new $P5003, "Undef"
  vivify_2150:
    $P5003."named"("type")
.annotate 'line', 1393
    find_lex $P5004, "$meta_args"
    unless_null $P5004, vivify_2151
    new $P5004, "Undef"
  vivify_2151:
    find_lex $P5005, "$type"
    unless_null $P5005, vivify_2152
    new $P5005, "Undef"
  vivify_2152:
    $P5006 = $P5004."push"($P5005)
.annotate 'line', 1390
    .return ($P5006)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("501_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5050
    .param pmc param_5051
.annotate 'line', 1419
    .lex "self", param_5050
    .lex "$/", param_5051
    find_lex $P5052, "$/"
    find_lex $P5053, "$/"
    unless_null $P5053, vivify_2156
    $P5053 = root_new ['parrot';'Hash']
  vivify_2156:
    set $P5054, $P5053["routine_def"]
    unless_null $P5054, vivify_2157
    new $P5054, "Undef"
  vivify_2157:
    $P5055 = $P5054."ast"()
    $P5056 = $P5052."!make"($P5055)
    .return ($P5056)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("502_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5058
    .param pmc param_5059
.annotate 'line', 1420
    .lex "self", param_5058
    .lex "$/", param_5059
    find_lex $P5060, "$/"
    find_lex $P5061, "$/"
    unless_null $P5061, vivify_2158
    $P5061 = root_new ['parrot';'Hash']
  vivify_2158:
    set $P5062, $P5061["method_def"]
    unless_null $P5062, vivify_2159
    new $P5062, "Undef"
  vivify_2159:
    $P5063 = $P5062."ast"()
    $P5064 = $P5060."!make"($P5063)
    .return ($P5064)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("503_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5066
    .param pmc param_5067
.annotate 'line', 1422
    .const 'Sub' $P5424 = "509_1303748459.273" 
    capture_lex $P5424
    .const 'Sub' $P5089 = "504_1303748459.273" 
    capture_lex $P5089
    .lex "self", param_5066
    .lex "$/", param_5067
.annotate 'line', 1425
    new $P5068, "Undef"
    .lex "$past", $P5068
.annotate 'line', 1436
    new $P5069, "Undef"
    .lex "$block", $P5069
.annotate 'line', 1422
    find_lex $P5070, "$past"
    unless_null $P5070, vivify_2160
    new $P5070, "Undef"
  vivify_2160:
.annotate 'line', 1426
    find_lex $P5072, "$/"
    unless_null $P5072, vivify_2161
    $P5072 = root_new ['parrot';'Hash']
  vivify_2161:
    set $P5073, $P5072["onlystar"]
    unless_null $P5073, vivify_2162
    new $P5073, "Undef"
  vivify_2162:
    if $P5073, if_5071
.annotate 'line', 1430
    find_lex $P5075, "$/"
    unless_null $P5075, vivify_2163
    $P5075 = root_new ['parrot';'Hash']
  vivify_2163:
    set $P5076, $P5075["blockoid"]
    unless_null $P5076, vivify_2164
    new $P5076, "Undef"
  vivify_2164:
    $P5077 = $P5076."ast"()
    store_lex "$past", $P5077
.annotate 'line', 1431
    find_lex $P5078, "$past"
    unless_null $P5078, vivify_2165
    new $P5078, "Undef"
  vivify_2165:
    $P5078."blocktype"("declaration")
.annotate 'line', 1432
    find_dynamic_lex $P5082, "$*RETURN_USED"
    unless_null $P5082, vivify_2166
    get_hll_global $P5080, "GLOBAL"
    get_who $P5081, $P5080
    set $P5082, $P5081["$RETURN_USED"]
    unless_null $P5082, vivify_2167
    die "Contextual $*RETURN_USED not found"
  vivify_2167:
  vivify_2166:
    unless $P5082, if_5079_end
.annotate 'line', 1433
    find_lex $P5083, "$past"
    unless_null $P5083, vivify_2168
    new $P5083, "Undef"
  vivify_2168:
    $P5083."control"("return_pir")
  if_5079_end:
.annotate 'line', 1429
    goto if_5071_end
  if_5071:
.annotate 'line', 1427
    $P5074 = "only_star_block"()
    store_lex "$past", $P5074
  if_5071_end:
.annotate 'line', 1436
    find_lex $P5084, "$past"
    unless_null $P5084, vivify_2169
    new $P5084, "Undef"
  vivify_2169:
    store_lex "$block", $P5084
.annotate 'line', 1438
    find_lex $P5086, "$/"
    unless_null $P5086, vivify_2170
    $P5086 = root_new ['parrot';'Hash']
  vivify_2170:
    set $P5087, $P5086["deflongname"]
    unless_null $P5087, vivify_2171
    new $P5087, "Undef"
  vivify_2171:
    unless $P5087, if_5085_end
    .const 'Sub' $P5089 = "504_1303748459.273" 
    capture_lex $P5089
    $P5089()
  if_5085_end:
.annotate 'line', 1552
    find_lex $P5413, "$block"
    unless_null $P5413, vivify_2286
    new $P5413, "Undef"
  vivify_2286:
    find_lex $P5414, "$past"
    unless_null $P5414, vivify_2287
    $P5414 = root_new ['parrot';'Hash']
    store_lex "$past", $P5414
  vivify_2287:
    set $P5414["block_past"], $P5413
.annotate 'line', 1553
    find_lex $P5416, "$/"
    unless_null $P5416, vivify_2288
    $P5416 = root_new ['parrot';'Hash']
  vivify_2288:
    set $P5417, $P5416["trait"]
    unless_null $P5417, vivify_2289
    new $P5417, "Undef"
  vivify_2289:
    unless $P5417, if_5415_end
.annotate 'line', 1554
    find_lex $P5419, "$/"
    unless_null $P5419, vivify_2290
    $P5419 = root_new ['parrot';'Hash']
  vivify_2290:
    set $P5420, $P5419["trait"]
    unless_null $P5420, vivify_2291
    new $P5420, "Undef"
  vivify_2291:
    defined $I5421, $P5420
    unless $I5421, for_undef_2292
    iter $P5418, $P5420
    new $P5431, 'ExceptionHandler'
    set_label $P5431, loop5430_handler
    $P5431."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5431
  loop5430_test:
    unless $P5418, loop5430_done
    shift $P5422, $P5418
  loop5430_redo:
    .const 'Sub' $P5424 = "509_1303748459.273" 
    capture_lex $P5424
    $P5424($P5422)
  loop5430_next:
    goto loop5430_test
  loop5430_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5432, exception, 'type'
    eq $P5432, .CONTROL_LOOP_NEXT, loop5430_next
    eq $P5432, .CONTROL_LOOP_REDO, loop5430_redo
  loop5430_done:
    pop_eh 
  for_undef_2292:
  if_5415_end:
.annotate 'line', 1557
    find_lex $P5433, "$/"
    find_lex $P5434, "$past"
    unless_null $P5434, vivify_2295
    new $P5434, "Undef"
  vivify_2295:
    $P5435 = $P5433."!make"($P5434)
.annotate 'line', 1422
    .return ($P5435)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5088"  :anon :subid("504_1303748459.273") :outer("503_1303748459.273")
.annotate 'line', 1438
    .const 'Sub' $P5243 = "508_1303748459.273" 
    capture_lex $P5243
    .const 'Sub' $P5130 = "505_1303748459.273" 
    capture_lex $P5130
.annotate 'line', 1439
    new $P5090, "Undef"
    .lex "$name", $P5090
    find_lex $P5091, "$/"
    unless_null $P5091, vivify_2172
    $P5091 = root_new ['parrot';'Hash']
  vivify_2172:
    set $P5092, $P5091["sigil"]
    unless_null $P5092, vivify_2173
    $P5092 = root_new ['parrot';'ResizablePMCArray']
  vivify_2173:
    set $P5093, $P5092[0]
    unless_null $P5093, vivify_2174
    new $P5093, "Undef"
  vivify_2174:
    set $S5094, $P5093
    new $P5095, 'String'
    set $P5095, $S5094
    find_lex $P5096, "$/"
    unless_null $P5096, vivify_2175
    $P5096 = root_new ['parrot';'Hash']
  vivify_2175:
    set $P5097, $P5096["deflongname"]
    unless_null $P5097, vivify_2176
    $P5097 = root_new ['parrot';'ResizablePMCArray']
  vivify_2176:
    set $P5098, $P5097[0]
    unless_null $P5098, vivify_2177
    new $P5098, "Undef"
  vivify_2177:
    $S5099 = $P5098."ast"()
    concat $P5100, $P5095, $S5099
    store_lex "$name", $P5100
.annotate 'line', 1440
    find_lex $P5101, "$past"
    unless_null $P5101, vivify_2178
    new $P5101, "Undef"
  vivify_2178:
    find_lex $P5102, "$name"
    unless_null $P5102, vivify_2179
    new $P5102, "Undef"
  vivify_2179:
    $P5101."name"($P5102)
.annotate 'line', 1441
    find_dynamic_lex $P5110, "$*SCOPE"
    unless_null $P5110, vivify_2180
    get_hll_global $P5108, "GLOBAL"
    get_who $P5109, $P5108
    set $P5110, $P5109["$SCOPE"]
    unless_null $P5110, vivify_2181
    die "Contextual $*SCOPE not found"
  vivify_2181:
  vivify_2180:
    set $S5111, $P5110
    iseq $I5112, $S5111, ""
    unless $I5112, unless_5107
    new $P5106, 'Integer'
    set $P5106, $I5112
    goto unless_5107_end
  unless_5107:
    find_dynamic_lex $P5115, "$*SCOPE"
    unless_null $P5115, vivify_2182
    get_hll_global $P5113, "GLOBAL"
    get_who $P5114, $P5113
    set $P5115, $P5114["$SCOPE"]
    unless_null $P5115, vivify_2183
    die "Contextual $*SCOPE not found"
  vivify_2183:
  vivify_2182:
    set $S5116, $P5115
    iseq $I5117, $S5116, "my"
    new $P5106, 'Integer'
    set $P5106, $I5117
  unless_5107_end:
    unless $P5106, unless_5105
    set $P5104, $P5106
    goto unless_5105_end
  unless_5105:
    find_dynamic_lex $P5120, "$*SCOPE"
    unless_null $P5120, vivify_2184
    get_hll_global $P5118, "GLOBAL"
    get_who $P5119, $P5118
    set $P5120, $P5119["$SCOPE"]
    unless_null $P5120, vivify_2185
    die "Contextual $*SCOPE not found"
  vivify_2185:
  vivify_2184:
    set $S5121, $P5120
    iseq $I5122, $S5121, "our"
    new $P5104, 'Integer'
    set $P5104, $I5122
  unless_5105_end:
    if $P5104, if_5103
.annotate 'line', 1542
    find_lex $P5394, "$/"
    unless_null $P5394, vivify_2186
    new $P5394, "Undef"
  vivify_2186:
    $P5395 = $P5394."CURSOR"()
    find_dynamic_lex $P5398, "$*SCOPE"
    unless_null $P5398, vivify_2187
    get_hll_global $P5396, "GLOBAL"
    get_who $P5397, $P5396
    set $P5398, $P5397["$SCOPE"]
    unless_null $P5398, vivify_2188
    die "Contextual $*SCOPE not found"
  vivify_2188:
  vivify_2187:
    concat $P5399, $P5398, " scoped routines are not supported yet"
    $P5395."panic"($P5399)
.annotate 'line', 1541
    goto if_5103_end
  if_5103:
.annotate 'line', 1442
    find_dynamic_lex $P5126, "$*MULTINESS"
    unless_null $P5126, vivify_2189
    get_hll_global $P5124, "GLOBAL"
    get_who $P5125, $P5124
    set $P5126, $P5125["$MULTINESS"]
    unless_null $P5126, vivify_2190
    die "Contextual $*MULTINESS not found"
  vivify_2190:
  vivify_2189:
    set $S5127, $P5126
    iseq $I5128, $S5127, "multi"
    if $I5128, if_5123
.annotate 'line', 1493
    find_dynamic_lex $P5239, "$*MULTINESS"
    unless_null $P5239, vivify_2191
    get_hll_global $P5237, "GLOBAL"
    get_who $P5238, $P5237
    set $P5239, $P5238["$MULTINESS"]
    unless_null $P5239, vivify_2192
    die "Contextual $*MULTINESS not found"
  vivify_2192:
  vivify_2191:
    set $S5240, $P5239
    iseq $I5241, $S5240, "proto"
    if $I5241, if_5236
.annotate 'line', 1512
    find_lex $P5293, "$?PACKAGE"
    get_who $P5294, $P5293
    set $P5295, $P5294["@BLOCK"]
    unless_null $P5295, vivify_2193
    $P5295 = root_new ['parrot';'ResizablePMCArray']
  vivify_2193:
    set $P5296, $P5295[0]
    unless_null $P5296, vivify_2194
    $P5296 = root_new ['parrot';'ResizablePMCArray']
  vivify_2194:
    set $P5297, $P5296[0]
    unless_null $P5297, vivify_2195
    new $P5297, "Undef"
  vivify_2195:
    get_hll_global $P5298, "GLOBAL"
    nqp_get_package_through_who $P5299, $P5298, "PAST"
    get_who $P5300, $P5299
    set $P5301, $P5300["Var"]
    find_lex $P5302, "$name"
    unless_null $P5302, vivify_2196
    new $P5302, "Undef"
  vivify_2196:
    find_lex $P5303, "$past"
    unless_null $P5303, vivify_2197
    new $P5303, "Undef"
  vivify_2197:
    $P5304 = $P5301."new"($P5302 :named("name"), 1 :named("isdecl"), $P5303 :named("viviself"), "lexical" :named("scope"))
    $P5297."push"($P5304)
.annotate 'line', 1514
    find_lex $P5305, "$?PACKAGE"
    get_who $P5306, $P5305
    set $P5307, $P5306["@BLOCK"]
    unless_null $P5307, vivify_2198
    $P5307 = root_new ['parrot';'ResizablePMCArray']
  vivify_2198:
    set $P5308, $P5307[0]
    unless_null $P5308, vivify_2199
    new $P5308, "Undef"
  vivify_2199:
    find_lex $P5309, "$name"
    unless_null $P5309, vivify_2200
    new $P5309, "Undef"
  vivify_2200:
    $P5308."symbol"($P5309, "lexical" :named("scope"))
.annotate 'line', 1515
    find_dynamic_lex $P5313, "$*SCOPE"
    unless_null $P5313, vivify_2201
    get_hll_global $P5311, "GLOBAL"
    get_who $P5312, $P5311
    set $P5313, $P5312["$SCOPE"]
    unless_null $P5313, vivify_2202
    die "Contextual $*SCOPE not found"
  vivify_2202:
  vivify_2201:
    set $S5314, $P5313
    iseq $I5315, $S5314, "our"
    unless $I5315, if_5310_end
.annotate 'line', 1518
    find_dynamic_lex $P5318, "$*SC"
    unless_null $P5318, vivify_2203
    get_hll_global $P5316, "GLOBAL"
    get_who $P5317, $P5316
    set $P5318, $P5317["$SC"]
    unless_null $P5318, vivify_2204
    die "Contextual $*SC not found"
  vivify_2204:
  vivify_2203:
    find_dynamic_lex $P5321, "$*PACKAGE"
    unless_null $P5321, vivify_2205
    get_hll_global $P5319, "GLOBAL"
    get_who $P5320, $P5319
    set $P5321, $P5320["$PACKAGE"]
    unless_null $P5321, vivify_2206
    die "Contextual $*PACKAGE not found"
  vivify_2206:
  vivify_2205:
    find_lex $P5322, "$name"
    unless_null $P5322, vivify_2207
    new $P5322, "Undef"
  vivify_2207:
    find_lex $P5323, "$past"
    unless_null $P5323, vivify_2208
    new $P5323, "Undef"
  vivify_2208:
    $P5318."install_package_routine"($P5321, $P5322, $P5323)
.annotate 'line', 1519
    find_lex $P5324, "$?PACKAGE"
    get_who $P5325, $P5324
    set $P5326, $P5325["@BLOCK"]
    unless_null $P5326, vivify_2209
    $P5326 = root_new ['parrot';'ResizablePMCArray']
  vivify_2209:
    set $P5327, $P5326[0]
    unless_null $P5327, vivify_2210
    $P5327 = root_new ['parrot';'ResizablePMCArray']
  vivify_2210:
    set $P5328, $P5327[0]
    unless_null $P5328, vivify_2211
    new $P5328, "Undef"
  vivify_2211:
    get_hll_global $P5329, "GLOBAL"
    nqp_get_package_through_who $P5330, $P5329, "PAST"
    get_who $P5331, $P5330
    set $P5332, $P5331["Op"]
.annotate 'line', 1521
    find_lex $P5333, "$name"
    unless_null $P5333, vivify_2212
    new $P5333, "Undef"
  vivify_2212:
    new $P5334, "ResizablePMCArray"
    push $P5334, $P5333
    find_lex $P5335, "$/"
    unless_null $P5335, vivify_2213
    new $P5335, "Undef"
  vivify_2213:
    $P5336 = "lexical_package_lookup"($P5334, $P5335)
.annotate 'line', 1522
    get_hll_global $P5337, "GLOBAL"
    nqp_get_package_through_who $P5338, $P5337, "PAST"
    get_who $P5339, $P5338
    set $P5340, $P5339["Var"]
    find_lex $P5341, "$name"
    unless_null $P5341, vivify_2214
    new $P5341, "Undef"
  vivify_2214:
    $P5342 = $P5340."new"($P5341 :named("name"), "lexical" :named("scope"))
    $P5343 = $P5332."new"($P5336, $P5342, "bind" :named("pasttype"))
.annotate 'line', 1519
    $P5328."push"($P5343)
.annotate 'line', 1526
    find_lex $P5344, "$?PACKAGE"
    get_who $P5345, $P5344
    set $P5346, $P5345["@BLOCK"]
    unless_null $P5346, vivify_2215
    $P5346 = root_new ['parrot';'ResizablePMCArray']
  vivify_2215:
    set $P5347, $P5346[0]
    unless_null $P5347, vivify_2216
    $P5347 = root_new ['parrot';'ResizablePMCArray']
  vivify_2216:
    set $P5348, $P5347[0]
    unless_null $P5348, vivify_2217
    new $P5348, "Undef"
  vivify_2217:
    get_hll_global $P5349, "GLOBAL"
    nqp_get_package_through_who $P5350, $P5349, "PAST"
    get_who $P5351, $P5350
    set $P5352, $P5351["Op"]
.annotate 'line', 1528
    get_hll_global $P5353, "GLOBAL"
    nqp_get_package_through_who $P5354, $P5353, "PAST"
    get_who $P5355, $P5354
    set $P5356, $P5355["Var"]
    find_lex $P5357, "$name"
    unless_null $P5357, vivify_2218
    new $P5357, "Undef"
  vivify_2218:
    $P5358 = $P5356."new"($P5357 :named("name"), "package" :named("scope"))
.annotate 'line', 1529
    get_hll_global $P5359, "GLOBAL"
    nqp_get_package_through_who $P5360, $P5359, "PAST"
    get_who $P5361, $P5360
    set $P5362, $P5361["Var"]
    find_lex $P5363, "$name"
    unless_null $P5363, vivify_2219
    new $P5363, "Undef"
  vivify_2219:
    $P5364 = $P5362."new"($P5363 :named("name"), "lexical" :named("scope"))
    $P5365 = $P5352."new"($P5358, $P5364, "bind" :named("pasttype"))
.annotate 'line', 1526
    $P5348."push"($P5365)
.annotate 'line', 1531
    find_lex $P5366, "$?PACKAGE"
    get_who $P5367, $P5366
    set $P5368, $P5367["@BLOCK"]
    unless_null $P5368, vivify_2220
    $P5368 = root_new ['parrot';'ResizablePMCArray']
  vivify_2220:
    set $P5369, $P5368[0]
    unless_null $P5369, vivify_2221
    new $P5369, "Undef"
  vivify_2221:
    $P5370 = $P5369."loadinit"()
    get_hll_global $P5371, "GLOBAL"
    nqp_get_package_through_who $P5372, $P5371, "PAST"
    get_who $P5373, $P5372
    set $P5374, $P5373["Op"]
.annotate 'line', 1533
    get_hll_global $P5375, "GLOBAL"
    nqp_get_package_through_who $P5376, $P5375, "PAST"
    get_who $P5377, $P5376
    set $P5378, $P5377["Var"]
    find_lex $P5379, "$name"
    unless_null $P5379, vivify_2222
    new $P5379, "Undef"
  vivify_2222:
    $P5380 = $P5378."new"($P5379 :named("name"), "package" :named("scope"))
.annotate 'line', 1534
    get_hll_global $P5381, "GLOBAL"
    nqp_get_package_through_who $P5382, $P5381, "PAST"
    get_who $P5383, $P5382
    set $P5384, $P5383["Val"]
    find_lex $P5385, "$past"
    unless_null $P5385, vivify_2223
    new $P5385, "Undef"
  vivify_2223:
    $P5386 = $P5384."new"($P5385 :named("value"))
    $P5387 = $P5374."new"($P5380, $P5386, "bind" :named("pasttype"))
.annotate 'line', 1531
    $P5370."push"($P5387)
  if_5310_end:
.annotate 'line', 1511
    goto if_5236_end
  if_5236:
.annotate 'line', 1493
    .const 'Sub' $P5243 = "508_1303748459.273" 
    capture_lex $P5243
    $P5243()
  if_5236_end:
    goto if_5123_end
  if_5123:
.annotate 'line', 1442
    .const 'Sub' $P5130 = "505_1303748459.273" 
    capture_lex $P5130
    $P5130()
  if_5123_end:
.annotate 'line', 1539
    get_hll_global $P5388, "GLOBAL"
    nqp_get_package_through_who $P5389, $P5388, "PAST"
    get_who $P5390, $P5389
    set $P5391, $P5390["Var"]
    find_lex $P5392, "$name"
    unless_null $P5392, vivify_2281
    new $P5392, "Undef"
  vivify_2281:
    $P5393 = $P5391."new"($P5392 :named("name"))
    store_lex "$past", $P5393
  if_5103_end:
.annotate 'line', 1546
    find_lex $P5404, "$name"
    unless_null $P5404, vivify_2282
    new $P5404, "Undef"
  vivify_2282:
    set $S5405, $P5404
    iseq $I5406, $S5405, "MAIN"
    if $I5406, if_5403
    new $P5402, 'Integer'
    set $P5402, $I5406
    goto if_5403_end
  if_5403:
    find_dynamic_lex $P5409, "$*MULTINESS"
    unless_null $P5409, vivify_2283
    get_hll_global $P5407, "GLOBAL"
    get_who $P5408, $P5407
    set $P5409, $P5408["$MULTINESS"]
    unless_null $P5409, vivify_2284
    die "Contextual $*MULTINESS not found"
  vivify_2284:
  vivify_2283:
    set $S5410, $P5409
    isne $I5411, $S5410, "multi"
    new $P5402, 'Integer'
    set $P5402, $I5411
  if_5403_end:
    if $P5402, if_5401
    set $P5400, $P5402
    goto if_5401_end
  if_5401:
.annotate 'line', 1547
    find_lex $P5412, "$block"
    unless_null $P5412, vivify_2285
    new $P5412, "Undef"
  vivify_2285:
    store_dynamic_lex "$*MAIN_SUB", $P5412
.annotate 'line', 1546
    set $P5400, $P5412
  if_5401_end:
.annotate 'line', 1438
    .return ($P5400)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5242"  :anon :subid("508_1303748459.273") :outer("504_1303748459.273")
.annotate 'line', 1498
    new $P5244, "Undef"
    .lex "$cholder", $P5244
.annotate 'line', 1497
    find_dynamic_lex $P5248, "$*SCOPE"
    unless_null $P5248, vivify_2224
    get_hll_global $P5246, "GLOBAL"
    get_who $P5247, $P5246
    set $P5248, $P5247["$SCOPE"]
    unless_null $P5248, vivify_2225
    die "Contextual $*SCOPE not found"
  vivify_2225:
  vivify_2224:
    set $S5249, $P5248
    iseq $I5250, $S5249, "our"
    unless $I5250, if_5245_end
    die "our-scoped protos not yet implemented"
  if_5245_end:
.annotate 'line', 1498
    get_hll_global $P5251, "GLOBAL"
    nqp_get_package_through_who $P5252, $P5251, "PAST"
    get_who $P5253, $P5252
    set $P5254, $P5253["Op"]
    $P5255 = $P5254."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5255
.annotate 'line', 1499
    find_lex $P5256, "$?PACKAGE"
    get_who $P5257, $P5256
    set $P5258, $P5257["@BLOCK"]
    unless_null $P5258, vivify_2226
    $P5258 = root_new ['parrot';'ResizablePMCArray']
  vivify_2226:
    set $P5259, $P5258[0]
    unless_null $P5259, vivify_2227
    $P5259 = root_new ['parrot';'ResizablePMCArray']
  vivify_2227:
    set $P5260, $P5259[0]
    unless_null $P5260, vivify_2228
    new $P5260, "Undef"
  vivify_2228:
    get_hll_global $P5261, "GLOBAL"
    nqp_get_package_through_who $P5262, $P5261, "PAST"
    get_who $P5263, $P5262
    set $P5264, $P5263["Var"]
    find_lex $P5265, "$name"
    unless_null $P5265, vivify_2229
    new $P5265, "Undef"
  vivify_2229:
    find_lex $P5266, "$past"
    unless_null $P5266, vivify_2230
    new $P5266, "Undef"
  vivify_2230:
    $P5267 = $P5264."new"($P5265 :named("name"), 1 :named("isdecl"), $P5266 :named("viviself"), "lexical" :named("scope"))
    $P5260."push"($P5267)
.annotate 'line', 1501
    find_lex $P5268, "$?PACKAGE"
    get_who $P5269, $P5268
    set $P5270, $P5269["@BLOCK"]
    unless_null $P5270, vivify_2231
    $P5270 = root_new ['parrot';'ResizablePMCArray']
  vivify_2231:
    set $P5271, $P5270[0]
    unless_null $P5271, vivify_2232
    $P5271 = root_new ['parrot';'ResizablePMCArray']
  vivify_2232:
    set $P5272, $P5271[0]
    unless_null $P5272, vivify_2233
    new $P5272, "Undef"
  vivify_2233:
    get_hll_global $P5273, "GLOBAL"
    nqp_get_package_through_who $P5274, $P5273, "PAST"
    get_who $P5275, $P5274
    set $P5276, $P5275["Op"]
.annotate 'line', 1503
    get_hll_global $P5277, "GLOBAL"
    nqp_get_package_through_who $P5278, $P5277, "PAST"
    get_who $P5279, $P5278
    set $P5280, $P5279["Var"]
    find_lex $P5281, "$name"
    unless_null $P5281, vivify_2234
    new $P5281, "Undef"
  vivify_2234:
    $P5282 = $P5280."new"($P5281 :named("name"))
    find_lex $P5283, "$cholder"
    unless_null $P5283, vivify_2235
    new $P5283, "Undef"
  vivify_2235:
    $P5284 = $P5276."new"($P5282, $P5283, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1501
    $P5272."push"($P5284)
.annotate 'line', 1506
    find_lex $P5285, "$?PACKAGE"
    get_who $P5286, $P5285
    set $P5287, $P5286["@BLOCK"]
    unless_null $P5287, vivify_2236
    $P5287 = root_new ['parrot';'ResizablePMCArray']
  vivify_2236:
    set $P5288, $P5287[0]
    unless_null $P5288, vivify_2237
    new $P5288, "Undef"
  vivify_2237:
    find_lex $P5289, "$name"
    unless_null $P5289, vivify_2238
    new $P5289, "Undef"
  vivify_2238:
    find_lex $P5290, "$cholder"
    unless_null $P5290, vivify_2239
    new $P5290, "Undef"
  vivify_2239:
    $P5288."symbol"($P5289, "lexical" :named("scope"), 1 :named("proto"), $P5290 :named("cholder"))
.annotate 'line', 1509
    find_lex $P5291, "$past"
    unless_null $P5291, vivify_2240
    new $P5291, "Undef"
  vivify_2240:
    $P5292 = $P5291."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1493
    .return ($P5292)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5129"  :anon :subid("505_1303748459.273") :outer("504_1303748459.273")
.annotate 'line', 1442
    .const 'Sub' $P5152 = "506_1303748459.273" 
    capture_lex $P5152
.annotate 'line', 1445
    new $P5131, "Undef"
    .lex "$cholder", $P5131
.annotate 'line', 1446
    $P5132 = root_new ['parrot';'Hash']
    .lex "%sym", $P5132
.annotate 'line', 1444
    find_dynamic_lex $P5136, "$*SCOPE"
    unless_null $P5136, vivify_2241
    get_hll_global $P5134, "GLOBAL"
    get_who $P5135, $P5134
    set $P5136, $P5135["$SCOPE"]
    unless_null $P5136, vivify_2242
    die "Contextual $*SCOPE not found"
  vivify_2242:
  vivify_2241:
    set $S5137, $P5136
    iseq $I5138, $S5137, "our"
    unless $I5138, if_5133_end
    die "our-scoped multis not yet implemented"
  if_5133_end:
    find_lex $P5139, "$cholder"
    unless_null $P5139, vivify_2243
    new $P5139, "Undef"
  vivify_2243:
.annotate 'line', 1446
    find_lex $P5140, "$?PACKAGE"
    get_who $P5141, $P5140
    set $P5142, $P5141["@BLOCK"]
    unless_null $P5142, vivify_2244
    $P5142 = root_new ['parrot';'ResizablePMCArray']
  vivify_2244:
    set $P5143, $P5142[0]
    unless_null $P5143, vivify_2245
    new $P5143, "Undef"
  vivify_2245:
    find_lex $P5144, "$name"
    unless_null $P5144, vivify_2246
    new $P5144, "Undef"
  vivify_2246:
    $P5145 = $P5143."symbol"($P5144)
    store_lex "%sym", $P5145
.annotate 'line', 1447
    find_lex $P5147, "%sym"
    unless_null $P5147, vivify_2247
    $P5147 = root_new ['parrot';'Hash']
  vivify_2247:
    set $P5148, $P5147["cholder"]
    unless_null $P5148, vivify_2248
    new $P5148, "Undef"
  vivify_2248:
    if $P5148, if_5146
.annotate 'line', 1452
    .const 'Sub' $P5152 = "506_1303748459.273" 
    capture_lex $P5152
    $P5152()
    goto if_5146_end
  if_5146:
.annotate 'line', 1448
    find_lex $P5149, "%sym"
    unless_null $P5149, vivify_2276
    $P5149 = root_new ['parrot';'Hash']
  vivify_2276:
    set $P5150, $P5149["cholder"]
    unless_null $P5150, vivify_2277
    new $P5150, "Undef"
  vivify_2277:
    store_lex "$cholder", $P5150
  if_5146_end:
.annotate 'line', 1488
    find_lex $P5232, "$cholder"
    unless_null $P5232, vivify_2278
    new $P5232, "Undef"
  vivify_2278:
    find_lex $P5233, "$past"
    unless_null $P5233, vivify_2279
    new $P5233, "Undef"
  vivify_2279:
    $P5232."push"($P5233)
.annotate 'line', 1491
    find_lex $P5234, "$past"
    unless_null $P5234, vivify_2280
    new $P5234, "Undef"
  vivify_2280:
    $P5235 = "attach_multi_signature"($P5234)
.annotate 'line', 1442
    .return ($P5235)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5151"  :anon :subid("506_1303748459.273") :outer("505_1303748459.273")
.annotate 'line', 1452
    .const 'Sub' $P5168 = "507_1303748459.273" 
    capture_lex $P5168
.annotate 'line', 1459
    new $P5153, "Undef"
    .lex "$found_proto", $P5153
.annotate 'line', 1477
    new $P5154, "Undef"
    .lex "$dispatch_setup", $P5154
.annotate 'line', 1454
    find_lex $P5156, "%sym"
    unless_null $P5156, vivify_2249
    $P5156 = root_new ['parrot';'Hash']
  vivify_2249:
    set $P5157, $P5156["proto"]
    unless_null $P5157, vivify_2250
    new $P5157, "Undef"
  vivify_2250:
    unless $P5157, if_5155_end
.annotate 'line', 1457
    find_lex $P5158, "$/"
    unless_null $P5158, vivify_2251
    new $P5158, "Undef"
  vivify_2251:
    $P5159 = $P5158."CURSOR"()
    $P5159."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_5155_end:
.annotate 'line', 1454
    find_lex $P5160, "$found_proto"
    unless_null $P5160, vivify_2252
    new $P5160, "Undef"
  vivify_2252:
.annotate 'line', 1460
    find_lex $P5162, "$?PACKAGE"
    get_who $P5163, $P5162
    set $P5164, $P5163["@BLOCK"]
    unless_null $P5164, vivify_2253
    $P5164 = root_new ['parrot';'ResizablePMCArray']
  vivify_2253:
    defined $I5165, $P5164
    unless $I5165, for_undef_2254
    iter $P5161, $P5164
    new $P5190, 'ExceptionHandler'
    set_label $P5190, loop5189_handler
    $P5190."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5190
  loop5189_test:
    unless $P5161, loop5189_done
    shift $P5166, $P5161
  loop5189_redo:
    .const 'Sub' $P5168 = "507_1303748459.273" 
    capture_lex $P5168
    $P5168($P5166)
  loop5189_next:
    goto loop5189_test
  loop5189_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5191, exception, 'type'
    eq $P5191, .CONTROL_LOOP_NEXT, loop5189_next
    eq $P5191, .CONTROL_LOOP_REDO, loop5189_redo
  loop5189_done:
    pop_eh 
  for_undef_2254:
.annotate 'line', 1471
    find_lex $P5193, "$found_proto"
    unless_null $P5193, vivify_2263
    new $P5193, "Undef"
  vivify_2263:
    if $P5193, unless_5192_end
.annotate 'line', 1472
    find_lex $P5194, "$/"
    unless_null $P5194, vivify_2264
    new $P5194, "Undef"
  vivify_2264:
    $P5195 = $P5194."CURSOR"()
    $P5195."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_5192_end:
.annotate 'line', 1476
    get_hll_global $P5196, "GLOBAL"
    nqp_get_package_through_who $P5197, $P5196, "PAST"
    get_who $P5198, $P5197
    set $P5199, $P5198["Op"]
    $P5200 = $P5199."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5200
.annotate 'line', 1477
    get_hll_global $P5201, "GLOBAL"
    nqp_get_package_through_who $P5202, $P5201, "PAST"
    get_who $P5203, $P5202
    set $P5204, $P5203["Op"]
.annotate 'line', 1479
    get_hll_global $P5205, "GLOBAL"
    nqp_get_package_through_who $P5206, $P5205, "PAST"
    get_who $P5207, $P5206
    set $P5208, $P5207["Var"]
    find_lex $P5209, "$name"
    unless_null $P5209, vivify_2265
    new $P5209, "Undef"
  vivify_2265:
    $P5210 = $P5208."new"($P5209 :named("name"), "outer" :named("scope"))
    find_lex $P5211, "$cholder"
    unless_null $P5211, vivify_2266
    new $P5211, "Undef"
  vivify_2266:
    $P5212 = $P5204."new"($P5210, $P5211, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1477
    store_lex "$dispatch_setup", $P5212
.annotate 'line', 1482
    find_lex $P5213, "$?PACKAGE"
    get_who $P5214, $P5213
    set $P5215, $P5214["@BLOCK"]
    unless_null $P5215, vivify_2267
    $P5215 = root_new ['parrot';'ResizablePMCArray']
  vivify_2267:
    set $P5216, $P5215[0]
    unless_null $P5216, vivify_2268
    $P5216 = root_new ['parrot';'ResizablePMCArray']
  vivify_2268:
    set $P5217, $P5216[0]
    unless_null $P5217, vivify_2269
    new $P5217, "Undef"
  vivify_2269:
    get_hll_global $P5218, "GLOBAL"
    nqp_get_package_through_who $P5219, $P5218, "PAST"
    get_who $P5220, $P5219
    set $P5221, $P5220["Var"]
    find_lex $P5222, "$name"
    unless_null $P5222, vivify_2270
    new $P5222, "Undef"
  vivify_2270:
    find_lex $P5223, "$dispatch_setup"
    unless_null $P5223, vivify_2271
    new $P5223, "Undef"
  vivify_2271:
    $P5224 = $P5221."new"($P5222 :named("name"), 1 :named("isdecl"), $P5223 :named("viviself"), "lexical" :named("scope"))
    $P5217."push"($P5224)
.annotate 'line', 1484
    find_lex $P5225, "$?PACKAGE"
    get_who $P5226, $P5225
    set $P5227, $P5226["@BLOCK"]
    unless_null $P5227, vivify_2272
    $P5227 = root_new ['parrot';'ResizablePMCArray']
  vivify_2272:
    set $P5228, $P5227[0]
    unless_null $P5228, vivify_2273
    new $P5228, "Undef"
  vivify_2273:
    find_lex $P5229, "$name"
    unless_null $P5229, vivify_2274
    new $P5229, "Undef"
  vivify_2274:
    find_lex $P5230, "$cholder"
    unless_null $P5230, vivify_2275
    new $P5230, "Undef"
  vivify_2275:
    $P5231 = $P5228."symbol"($P5229, "lexical" :named("scope"), $P5230 :named("cholder"))
.annotate 'line', 1452
    .return ($P5231)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5167"  :anon :subid("507_1303748459.273") :outer("506_1303748459.273")
    .param pmc param_5170
.annotate 'line', 1461
    $P5169 = root_new ['parrot';'Hash']
    .lex "%sym", $P5169
    .lex "$_", param_5170
    find_lex $P5171, "$_"
    unless_null $P5171, vivify_2255
    new $P5171, "Undef"
  vivify_2255:
    find_lex $P5172, "$name"
    unless_null $P5172, vivify_2256
    new $P5172, "Undef"
  vivify_2256:
    $P5173 = $P5171."symbol"($P5172)
    store_lex "%sym", $P5173
.annotate 'line', 1462
    find_lex $P5178, "%sym"
    unless_null $P5178, vivify_2257
    $P5178 = root_new ['parrot';'Hash']
  vivify_2257:
    set $P5179, $P5178["proto"]
    unless_null $P5179, vivify_2258
    new $P5179, "Undef"
  vivify_2258:
    unless $P5179, unless_5177
    set $P5176, $P5179
    goto unless_5177_end
  unless_5177:
    find_lex $P5180, "%sym"
    unless_null $P5180, vivify_2259
    $P5180 = root_new ['parrot';'Hash']
  vivify_2259:
    set $P5181, $P5180["cholder"]
    unless_null $P5181, vivify_2260
    new $P5181, "Undef"
  vivify_2260:
    set $P5176, $P5181
  unless_5177_end:
    if $P5176, if_5175
.annotate 'line', 1465
    find_lex $P5185, "%sym"
    unless_null $P5185, vivify_2261
    $P5185 = root_new ['parrot';'Hash']
  vivify_2261:
    if $P5185, if_5184
    set $P5183, $P5185
    goto if_5184_end
  if_5184:
.annotate 'line', 1466
    find_lex $P5186, "$/"
    unless_null $P5186, vivify_2262
    new $P5186, "Undef"
  vivify_2262:
    $P5187 = $P5186."CURSOR"()
    $P5188 = $P5187."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1465
    set $P5183, $P5188
  if_5184_end:
    set $P5174, $P5183
.annotate 'line', 1462
    goto if_5175_end
  if_5175:
.annotate 'line', 1463
    new $P5182, "Integer"
    assign $P5182, 1
    store_lex "$found_proto", $P5182
.annotate 'line', 1462
    set $P5174, $P5182
  if_5175_end:
.annotate 'line', 1460
    .return ($P5174)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5423"  :anon :subid("509_1303748459.273") :outer("503_1303748459.273")
    .param pmc param_5425
.annotate 'line', 1554
    .lex "$_", param_5425
    find_lex $P5426, "$_"
    unless_null $P5426, vivify_2293
    new $P5426, "Undef"
  vivify_2293:
    $P5427 = $P5426."ast"()
    find_lex $P5428, "$/"
    unless_null $P5428, vivify_2294
    new $P5428, "Undef"
  vivify_2294:
    $P5429 = $P5427($P5428)
    .return ($P5429)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("510_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5437
    .param pmc param_5438
.annotate 'line', 1561
    .const 'Sub' $P5607 = "512_1303748459.273" 
    capture_lex $P5607
    .const 'Sub' $P5474 = "511_1303748459.273" 
    capture_lex $P5474
    .lex "self", param_5437
    .lex "$/", param_5438
.annotate 'line', 1564
    new $P5439, "Undef"
    .lex "$past", $P5439
.annotate 'line', 1561
    find_lex $P5440, "$past"
    unless_null $P5440, vivify_2296
    new $P5440, "Undef"
  vivify_2296:
.annotate 'line', 1565
    find_lex $P5442, "$/"
    unless_null $P5442, vivify_2297
    $P5442 = root_new ['parrot';'Hash']
  vivify_2297:
    set $P5443, $P5442["onlystar"]
    unless_null $P5443, vivify_2298
    new $P5443, "Undef"
  vivify_2298:
    if $P5443, if_5441
.annotate 'line', 1569
    find_lex $P5445, "$/"
    unless_null $P5445, vivify_2299
    $P5445 = root_new ['parrot';'Hash']
  vivify_2299:
    set $P5446, $P5445["blockoid"]
    unless_null $P5446, vivify_2300
    new $P5446, "Undef"
  vivify_2300:
    $P5447 = $P5446."ast"()
    store_lex "$past", $P5447
.annotate 'line', 1570
    find_lex $P5448, "$past"
    unless_null $P5448, vivify_2301
    new $P5448, "Undef"
  vivify_2301:
    $P5448."blocktype"("declaration")
.annotate 'line', 1571
    find_dynamic_lex $P5452, "$*RETURN_USED"
    unless_null $P5452, vivify_2302
    get_hll_global $P5450, "GLOBAL"
    get_who $P5451, $P5450
    set $P5452, $P5451["$RETURN_USED"]
    unless_null $P5452, vivify_2303
    die "Contextual $*RETURN_USED not found"
  vivify_2303:
  vivify_2302:
    unless $P5452, if_5449_end
.annotate 'line', 1572
    find_lex $P5453, "$past"
    unless_null $P5453, vivify_2304
    new $P5453, "Undef"
  vivify_2304:
    $P5453."control"("return_pir")
  if_5449_end:
.annotate 'line', 1568
    goto if_5441_end
  if_5441:
.annotate 'line', 1566
    $P5444 = "only_star_block"()
    store_lex "$past", $P5444
  if_5441_end:
.annotate 'line', 1577
    find_lex $P5455, "$past"
    unless_null $P5455, vivify_2305
    $P5455 = root_new ['parrot';'Hash']
  vivify_2305:
    set $P5456, $P5455["signature_has_invocant"]
    unless_null $P5456, vivify_2306
    new $P5456, "Undef"
  vivify_2306:
    if $P5456, unless_5454_end
.annotate 'line', 1578
    find_lex $P5457, "$past"
    unless_null $P5457, vivify_2307
    $P5457 = root_new ['parrot';'ResizablePMCArray']
  vivify_2307:
    set $P5458, $P5457[0]
    unless_null $P5458, vivify_2308
    new $P5458, "Undef"
  vivify_2308:
    get_hll_global $P5459, "GLOBAL"
    nqp_get_package_through_who $P5460, $P5459, "PAST"
    get_who $P5461, $P5460
    set $P5462, $P5461["Var"]
.annotate 'line', 1580
    get_hll_global $P5463, "GLOBAL"
    nqp_get_package_through_who $P5464, $P5463, "PAST"
    get_who $P5465, $P5464
    set $P5466, $P5465["Var"]
    $P5467 = $P5466."new"("$?CLASS" :named("name"))
    $P5468 = $P5462."new"("self" :named("name"), "parameter" :named("scope"), $P5467 :named("multitype"))
.annotate 'line', 1578
    $P5458."unshift"($P5468)
  unless_5454_end:
.annotate 'line', 1583
    find_lex $P5469, "$past"
    unless_null $P5469, vivify_2309
    new $P5469, "Undef"
  vivify_2309:
    $P5469."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1586
    find_lex $P5471, "$/"
    unless_null $P5471, vivify_2310
    $P5471 = root_new ['parrot';'Hash']
  vivify_2310:
    set $P5472, $P5471["deflongname"]
    unless_null $P5472, vivify_2311
    new $P5472, "Undef"
  vivify_2311:
    unless $P5472, if_5470_end
    .const 'Sub' $P5474 = "511_1303748459.273" 
    capture_lex $P5474
    $P5474()
  if_5470_end:
.annotate 'line', 1629
    find_lex $P5593, "$/"
    find_lex $P5594, "$past"
    unless_null $P5594, vivify_2346
    new $P5594, "Undef"
  vivify_2346:
    $P5593."!make"($P5594)
.annotate 'line', 1630
    find_lex $P5595, "$past"
    unless_null $P5595, vivify_2347
    new $P5595, "Undef"
  vivify_2347:
    find_lex $P5596, "$past"
    unless_null $P5596, vivify_2348
    $P5596 = root_new ['parrot';'Hash']
    store_lex "$past", $P5596
  vivify_2348:
    set $P5596["block_past"], $P5595
.annotate 'line', 1631
    find_lex $P5599, "$/"
    unless_null $P5599, vivify_2349
    $P5599 = root_new ['parrot';'Hash']
  vivify_2349:
    set $P5600, $P5599["trait"]
    unless_null $P5600, vivify_2350
    new $P5600, "Undef"
  vivify_2350:
    if $P5600, if_5598
    set $P5597, $P5600
    goto if_5598_end
  if_5598:
.annotate 'line', 1632
    find_lex $P5602, "$/"
    unless_null $P5602, vivify_2351
    $P5602 = root_new ['parrot';'Hash']
  vivify_2351:
    set $P5603, $P5602["trait"]
    unless_null $P5603, vivify_2352
    new $P5603, "Undef"
  vivify_2352:
    defined $I5604, $P5603
    unless $I5604, for_undef_2353
    iter $P5601, $P5603
    new $P5614, 'ExceptionHandler'
    set_label $P5614, loop5613_handler
    $P5614."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5614
  loop5613_test:
    unless $P5601, loop5613_done
    shift $P5605, $P5601
  loop5613_redo:
    .const 'Sub' $P5607 = "512_1303748459.273" 
    capture_lex $P5607
    $P5607($P5605)
  loop5613_next:
    goto loop5613_test
  loop5613_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5615, exception, 'type'
    eq $P5615, .CONTROL_LOOP_NEXT, loop5613_next
    eq $P5615, .CONTROL_LOOP_REDO, loop5613_redo
  loop5613_done:
    pop_eh 
  for_undef_2353:
.annotate 'line', 1631
    set $P5597, $P5601
  if_5598_end:
.annotate 'line', 1561
    .return ($P5597)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5473"  :anon :subid("511_1303748459.273") :outer("510_1303748459.273")
.annotate 'line', 1588
    new $P5475, "Undef"
    .lex "$name", $P5475
.annotate 'line', 1593
    new $P5476, "Undef"
    .lex "$to_add", $P5476
.annotate 'line', 1588
    find_lex $P5477, "$/"
    unless_null $P5477, vivify_2312
    $P5477 = root_new ['parrot';'Hash']
  vivify_2312:
    set $P5478, $P5477["private"]
    unless_null $P5478, vivify_2313
    new $P5478, "Undef"
  vivify_2313:
    set $S5479, $P5478
    new $P5480, 'String'
    set $P5480, $S5479
    find_lex $P5481, "$/"
    unless_null $P5481, vivify_2314
    $P5481 = root_new ['parrot';'Hash']
  vivify_2314:
    set $P5482, $P5481["deflongname"]
    unless_null $P5482, vivify_2315
    $P5482 = root_new ['parrot';'ResizablePMCArray']
  vivify_2315:
    set $P5483, $P5482[0]
    unless_null $P5483, vivify_2316
    new $P5483, "Undef"
  vivify_2316:
    $P5484 = $P5483."ast"()
    set $S5485, $P5484
    concat $P5486, $P5480, $S5485
    store_lex "$name", $P5486
.annotate 'line', 1589
    find_lex $P5487, "$past"
    unless_null $P5487, vivify_2317
    new $P5487, "Undef"
  vivify_2317:
    find_lex $P5488, "$name"
    unless_null $P5488, vivify_2318
    new $P5488, "Undef"
  vivify_2318:
    $P5487."name"($P5488)
.annotate 'line', 1593
    find_dynamic_lex $P5493, "$*MULTINESS"
    unless_null $P5493, vivify_2319
    get_hll_global $P5491, "GLOBAL"
    get_who $P5492, $P5491
    set $P5493, $P5492["$MULTINESS"]
    unless_null $P5493, vivify_2320
    die "Contextual $*MULTINESS not found"
  vivify_2320:
  vivify_2319:
    set $S5494, $P5493
    isne $I5495, $S5494, "proto"
    if $I5495, if_5490
.annotate 'line', 1595
    get_hll_global $P5502, "GLOBAL"
    nqp_get_package_through_who $P5503, $P5502, "PAST"
    get_who $P5504, $P5503
    set $P5505, $P5504["Op"]
.annotate 'line', 1597
    get_hll_global $P5506, "GLOBAL"
    nqp_get_package_through_who $P5507, $P5506, "PAST"
    get_who $P5508, $P5507
    set $P5509, $P5508["Val"]
    find_lex $P5510, "$past"
    unless_null $P5510, vivify_2321
    new $P5510, "Undef"
  vivify_2321:
    $P5511 = $P5509."new"($P5510 :named("value"))
.annotate 'line', 1598
    get_hll_global $P5512, "GLOBAL"
    nqp_get_package_through_who $P5513, $P5512, "PAST"
    get_who $P5514, $P5513
    set $P5515, $P5514["Op"]
    $P5516 = $P5515."new"("list" :named("pasttype"))
    $P5517 = $P5505."new"($P5511, $P5516, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1595
    set $P5489, $P5517
.annotate 'line', 1593
    goto if_5490_end
  if_5490:
.annotate 'line', 1594
    get_hll_global $P5496, "GLOBAL"
    nqp_get_package_through_who $P5497, $P5496, "PAST"
    get_who $P5498, $P5497
    set $P5499, $P5498["Val"]
    find_lex $P5500, "$past"
    unless_null $P5500, vivify_2322
    new $P5500, "Undef"
  vivify_2322:
    $P5501 = $P5499."new"($P5500 :named("value"))
    set $P5489, $P5501
  if_5490_end:
.annotate 'line', 1593
    store_lex "$to_add", $P5489
.annotate 'line', 1600
    find_dynamic_lex $P5521, "$*MULTINESS"
    unless_null $P5521, vivify_2323
    get_hll_global $P5519, "GLOBAL"
    get_who $P5520, $P5519
    set $P5521, $P5520["$MULTINESS"]
    unless_null $P5521, vivify_2324
    die "Contextual $*MULTINESS not found"
  vivify_2324:
  vivify_2323:
    set $S5522, $P5521
    iseq $I5523, $S5522, "proto"
    unless $I5523, if_5518_end
    find_lex $P5524, "$past"
    unless_null $P5524, vivify_2325
    new $P5524, "Undef"
  vivify_2325:
    $P5524."pirflags"(":instanceof(\"DispatcherSub\")")
  if_5518_end:
.annotate 'line', 1604
    find_dynamic_lex $P5528, "$*MULTINESS"
    unless_null $P5528, vivify_2326
    get_hll_global $P5526, "GLOBAL"
    get_who $P5527, $P5526
    set $P5528, $P5527["$MULTINESS"]
    unless_null $P5528, vivify_2327
    die "Contextual $*MULTINESS not found"
  vivify_2327:
  vivify_2326:
    set $S5529, $P5528
    iseq $I5530, $S5529, "multi"
    unless $I5530, if_5525_end
    find_lex $P5531, "$past"
    unless_null $P5531, vivify_2328
    new $P5531, "Undef"
  vivify_2328:
    "attach_multi_signature"($P5531)
  if_5525_end:
.annotate 'line', 1607
    find_dynamic_lex $P5535, "$*PACKAGE-SETUP"
    unless_null $P5535, vivify_2329
    get_hll_global $P5533, "GLOBAL"
    get_who $P5534, $P5533
    set $P5535, $P5534["$PACKAGE-SETUP"]
    unless_null $P5535, vivify_2330
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2330:
  vivify_2329:
    defined $I5536, $P5535
    unless $I5536, if_5532_end
.annotate 'line', 1608
    find_dynamic_lex $P5539, "$*PACKAGE-SETUP"
    unless_null $P5539, vivify_2331
    get_hll_global $P5537, "GLOBAL"
    get_who $P5538, $P5537
    set $P5539, $P5538["$PACKAGE-SETUP"]
    unless_null $P5539, vivify_2332
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2332:
  vivify_2331:
    get_hll_global $P5540, "GLOBAL"
    nqp_get_package_through_who $P5541, $P5540, "PAST"
    get_who $P5542, $P5541
    set $P5543, $P5542["Op"]
.annotate 'line', 1609
    find_dynamic_lex $P5548, "$*MULTINESS"
    unless_null $P5548, vivify_2333
    get_hll_global $P5546, "GLOBAL"
    get_who $P5547, $P5546
    set $P5548, $P5547["$MULTINESS"]
    unless_null $P5548, vivify_2334
    die "Contextual $*MULTINESS not found"
  vivify_2334:
  vivify_2333:
    set $S5549, $P5548
    iseq $I5550, $S5549, "multi"
    if $I5550, if_5545
    new $P5552, "String"
    assign $P5552, "add_method"
    set $P5544, $P5552
    goto if_5545_end
  if_5545:
    new $P5551, "String"
    assign $P5551, "add_multi_method"
    set $P5544, $P5551
  if_5545_end:
.annotate 'line', 1610
    get_hll_global $P5553, "GLOBAL"
    nqp_get_package_through_who $P5554, $P5553, "PAST"
    get_who $P5555, $P5554
    set $P5556, $P5555["Op"]
.annotate 'line', 1613
    get_hll_global $P5557, "GLOBAL"
    nqp_get_package_through_who $P5558, $P5557, "PAST"
    get_who $P5559, $P5558
    set $P5560, $P5559["Var"]
    $P5561 = $P5560."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5562 = $P5556."new"($P5561, "get_how PP" :named("pirop"))
.annotate 'line', 1615
    get_hll_global $P5563, "GLOBAL"
    nqp_get_package_through_who $P5564, $P5563, "PAST"
    get_who $P5565, $P5564
    set $P5566, $P5565["Var"]
    $P5567 = $P5566."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1616
    get_hll_global $P5568, "GLOBAL"
    nqp_get_package_through_who $P5569, $P5568, "PAST"
    get_who $P5570, $P5569
    set $P5571, $P5570["Val"]
    find_lex $P5572, "$name"
    unless_null $P5572, vivify_2335
    new $P5572, "Undef"
  vivify_2335:
    $P5573 = $P5571."new"($P5572 :named("value"))
    find_lex $P5574, "$to_add"
    unless_null $P5574, vivify_2336
    new $P5574, "Undef"
  vivify_2336:
    $P5575 = $P5543."new"($P5562, $P5567, $P5573, $P5574, "callmethod" :named("pasttype"), $P5544 :named("name"))
.annotate 'line', 1608
    $P5539."push"($P5575)
  if_5532_end:
.annotate 'line', 1621
    find_dynamic_lex $P5580, "$*SCOPE"
    unless_null $P5580, vivify_2337
    get_hll_global $P5578, "GLOBAL"
    get_who $P5579, $P5578
    set $P5580, $P5579["$SCOPE"]
    unless_null $P5580, vivify_2338
    die "Contextual $*SCOPE not found"
  vivify_2338:
  vivify_2337:
    set $S5581, $P5580
    iseq $I5582, $S5581, "our"
    if $I5582, if_5577
    new $P5576, 'Integer'
    set $P5576, $I5582
    goto if_5577_end
  if_5577:
.annotate 'line', 1622
    find_dynamic_lex $P5585, "$*SC"
    unless_null $P5585, vivify_2339
    get_hll_global $P5583, "GLOBAL"
    get_who $P5584, $P5583
    set $P5585, $P5584["$SC"]
    unless_null $P5585, vivify_2340
    die "Contextual $*SC not found"
  vivify_2340:
  vivify_2339:
    find_dynamic_lex $P5588, "$*PACKAGE"
    unless_null $P5588, vivify_2341
    get_hll_global $P5586, "GLOBAL"
    get_who $P5587, $P5586
    set $P5588, $P5587["$PACKAGE"]
    unless_null $P5588, vivify_2342
    die "Contextual $*PACKAGE not found"
  vivify_2342:
  vivify_2341:
    find_lex $P5589, "$name"
    unless_null $P5589, vivify_2343
    new $P5589, "Undef"
  vivify_2343:
    find_lex $P5590, "$past"
    unless_null $P5590, vivify_2344
    new $P5590, "Undef"
  vivify_2344:
    $P5585."install_package_routine"($P5588, $P5589, $P5590)
.annotate 'line', 1624
    find_lex $P5591, "$past"
    unless_null $P5591, vivify_2345
    new $P5591, "Undef"
  vivify_2345:
    $P5592 = $P5591."pirflags"(":nsentry")
.annotate 'line', 1621
    set $P5576, $P5592
  if_5577_end:
.annotate 'line', 1586
    .return ($P5576)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5606"  :anon :subid("512_1303748459.273") :outer("510_1303748459.273")
    .param pmc param_5608
.annotate 'line', 1632
    .lex "$_", param_5608
    find_lex $P5609, "$_"
    unless_null $P5609, vivify_2354
    new $P5609, "Undef"
  vivify_2354:
    $P5610 = $P5609."ast"()
    find_lex $P5611, "$/"
    unless_null $P5611, vivify_2355
    new $P5611, "Undef"
  vivify_2355:
    $P5612 = $P5610($P5611)
    .return ($P5612)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("513_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5619
    .param pmc param_5620
.annotate 'line', 1664
    .const 'Sub' $P5663 = "515_1303748459.273" 
    capture_lex $P5663
    .const 'Sub' $P5631 = "514_1303748459.273" 
    capture_lex $P5631
    .lex "self", param_5619
    .lex "$/", param_5620
.annotate 'line', 1665
    new $P5621, "Undef"
    .lex "$BLOCKINIT", $P5621
    find_lex $P5622, "$?PACKAGE"
    get_who $P5623, $P5622
    set $P5624, $P5623["@BLOCK"]
    unless_null $P5624, vivify_2356
    $P5624 = root_new ['parrot';'ResizablePMCArray']
  vivify_2356:
    set $P5625, $P5624[0]
    unless_null $P5625, vivify_2357
    $P5625 = root_new ['parrot';'ResizablePMCArray']
  vivify_2357:
    set $P5626, $P5625[0]
    unless_null $P5626, vivify_2358
    new $P5626, "Undef"
  vivify_2358:
    store_lex "$BLOCKINIT", $P5626
.annotate 'line', 1666
    find_lex $P5628, "$/"
    unless_null $P5628, vivify_2359
    $P5628 = root_new ['parrot';'Hash']
  vivify_2359:
    set $P5629, $P5628["invocant"]
    unless_null $P5629, vivify_2360
    new $P5629, "Undef"
  vivify_2360:
    unless $P5629, if_5627_end
    .const 'Sub' $P5631 = "514_1303748459.273" 
    capture_lex $P5631
    $P5631()
  if_5627_end:
.annotate 'line', 1675
    find_lex $P5658, "$/"
    unless_null $P5658, vivify_2370
    $P5658 = root_new ['parrot';'Hash']
  vivify_2370:
    set $P5659, $P5658["parameter"]
    unless_null $P5659, vivify_2371
    new $P5659, "Undef"
  vivify_2371:
    defined $I5660, $P5659
    unless $I5660, for_undef_2372
    iter $P5657, $P5659
    new $P5670, 'ExceptionHandler'
    set_label $P5670, loop5669_handler
    $P5670."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5670
  loop5669_test:
    unless $P5657, loop5669_done
    shift $P5661, $P5657
  loop5669_redo:
    .const 'Sub' $P5663 = "515_1303748459.273" 
    capture_lex $P5663
    $P5663($P5661)
  loop5669_next:
    goto loop5669_test
  loop5669_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5671, exception, 'type'
    eq $P5671, .CONTROL_LOOP_NEXT, loop5669_next
    eq $P5671, .CONTROL_LOOP_REDO, loop5669_redo
  loop5669_done:
    pop_eh 
  for_undef_2372:
.annotate 'line', 1664
    .return ($P5657)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5630"  :anon :subid("514_1303748459.273") :outer("513_1303748459.273")
.annotate 'line', 1667
    new $P5632, "Undef"
    .lex "$inv", $P5632
    find_lex $P5633, "$/"
    unless_null $P5633, vivify_2361
    $P5633 = root_new ['parrot';'Hash']
  vivify_2361:
    set $P5634, $P5633["invocant"]
    unless_null $P5634, vivify_2362
    $P5634 = root_new ['parrot';'ResizablePMCArray']
  vivify_2362:
    set $P5635, $P5634[0]
    unless_null $P5635, vivify_2363
    new $P5635, "Undef"
  vivify_2363:
    $P5636 = $P5635."ast"()
    store_lex "$inv", $P5636
.annotate 'line', 1668
    find_lex $P5637, "$BLOCKINIT"
    unless_null $P5637, vivify_2364
    new $P5637, "Undef"
  vivify_2364:
    find_lex $P5638, "$inv"
    unless_null $P5638, vivify_2365
    new $P5638, "Undef"
  vivify_2365:
    $P5637."push"($P5638)
.annotate 'line', 1669
    find_lex $P5639, "$BLOCKINIT"
    unless_null $P5639, vivify_2366
    new $P5639, "Undef"
  vivify_2366:
    get_hll_global $P5640, "GLOBAL"
    nqp_get_package_through_who $P5641, $P5640, "PAST"
    get_who $P5642, $P5641
    set $P5643, $P5642["Var"]
.annotate 'line', 1671
    get_hll_global $P5644, "GLOBAL"
    nqp_get_package_through_who $P5645, $P5644, "PAST"
    get_who $P5646, $P5645
    set $P5647, $P5646["Var"]
    find_lex $P5648, "$inv"
    unless_null $P5648, vivify_2367
    new $P5648, "Undef"
  vivify_2367:
    $P5649 = $P5648."name"()
    $P5650 = $P5647."new"("lexical" :named("scope"), $P5649 :named("name"))
    $P5651 = $P5643."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P5650 :named("viviself"))
.annotate 'line', 1669
    $P5639."push"($P5651)
.annotate 'line', 1673
    new $P5652, "Integer"
    assign $P5652, 1
    find_lex $P5653, "$?PACKAGE"
    get_who $P5654, $P5653
    set $P5655, $P5654["@BLOCK"]
    unless_null $P5655, vivify_2368
    $P5655 = root_new ['parrot';'ResizablePMCArray']
    set $P5654["@BLOCK"], $P5655
  vivify_2368:
    set $P5656, $P5655[0]
    unless_null $P5656, vivify_2369
    $P5656 = root_new ['parrot';'Hash']
    set $P5655[0], $P5656
  vivify_2369:
    set $P5656["signature_has_invocant"], $P5652
.annotate 'line', 1666
    .return ($P5652)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5662"  :anon :subid("515_1303748459.273") :outer("513_1303748459.273")
    .param pmc param_5664
.annotate 'line', 1675
    .lex "$_", param_5664
    find_lex $P5665, "$BLOCKINIT"
    unless_null $P5665, vivify_2373
    new $P5665, "Undef"
  vivify_2373:
    find_lex $P5666, "$_"
    unless_null $P5666, vivify_2374
    new $P5666, "Undef"
  vivify_2374:
    $P5667 = $P5666."ast"()
    $P5668 = $P5665."push"($P5667)
    .return ($P5668)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("516_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5673
    .param pmc param_5674
.annotate 'line', 1678
    .lex "self", param_5673
    .lex "$/", param_5674
.annotate 'line', 1679
    new $P5675, "Undef"
    .lex "$quant", $P5675
.annotate 'line', 1680
    new $P5676, "Undef"
    .lex "$past", $P5676
.annotate 'line', 1679
    find_lex $P5677, "$/"
    unless_null $P5677, vivify_2375
    $P5677 = root_new ['parrot';'Hash']
  vivify_2375:
    set $P5678, $P5677["quant"]
    unless_null $P5678, vivify_2376
    new $P5678, "Undef"
  vivify_2376:
    store_lex "$quant", $P5678
    find_lex $P5679, "$past"
    unless_null $P5679, vivify_2377
    new $P5679, "Undef"
  vivify_2377:
.annotate 'line', 1681
    find_lex $P5681, "$/"
    unless_null $P5681, vivify_2378
    $P5681 = root_new ['parrot';'Hash']
  vivify_2378:
    set $P5682, $P5681["named_param"]
    unless_null $P5682, vivify_2379
    new $P5682, "Undef"
  vivify_2379:
    if $P5682, if_5680
.annotate 'line', 1688
    find_lex $P5696, "$/"
    unless_null $P5696, vivify_2380
    $P5696 = root_new ['parrot';'Hash']
  vivify_2380:
    set $P5697, $P5696["param_var"]
    unless_null $P5697, vivify_2381
    new $P5697, "Undef"
  vivify_2381:
    $P5698 = $P5697."ast"()
    store_lex "$past", $P5698
.annotate 'line', 1689
    find_lex $P5700, "$quant"
    unless_null $P5700, vivify_2382
    new $P5700, "Undef"
  vivify_2382:
    set $S5701, $P5700
    iseq $I5702, $S5701, "*"
    if $I5702, if_5699
.annotate 'line', 1693
    find_lex $P5711, "$quant"
    unless_null $P5711, vivify_2383
    new $P5711, "Undef"
  vivify_2383:
    set $S5712, $P5711
    iseq $I5713, $S5712, "?"
    unless $I5713, if_5710_end
.annotate 'line', 1694
    find_lex $P5714, "$past"
    unless_null $P5714, vivify_2384
    new $P5714, "Undef"
  vivify_2384:
    find_lex $P5715, "$/"
    unless_null $P5715, vivify_2385
    $P5715 = root_new ['parrot';'Hash']
  vivify_2385:
    set $P5716, $P5715["param_var"]
    unless_null $P5716, vivify_2386
    $P5716 = root_new ['parrot';'Hash']
  vivify_2386:
    set $P5717, $P5716["sigil"]
    unless_null $P5717, vivify_2387
    new $P5717, "Undef"
  vivify_2387:
    $P5718 = "vivitype"($P5717)
    $P5714."viviself"($P5718)
  if_5710_end:
.annotate 'line', 1693
    goto if_5699_end
  if_5699:
.annotate 'line', 1690
    find_lex $P5703, "$past"
    unless_null $P5703, vivify_2388
    new $P5703, "Undef"
  vivify_2388:
    $P5703."slurpy"(1)
.annotate 'line', 1691
    find_lex $P5704, "$past"
    unless_null $P5704, vivify_2389
    new $P5704, "Undef"
  vivify_2389:
    find_lex $P5705, "$/"
    unless_null $P5705, vivify_2390
    $P5705 = root_new ['parrot';'Hash']
  vivify_2390:
    set $P5706, $P5705["param_var"]
    unless_null $P5706, vivify_2391
    $P5706 = root_new ['parrot';'Hash']
  vivify_2391:
    set $P5707, $P5706["sigil"]
    unless_null $P5707, vivify_2392
    new $P5707, "Undef"
  vivify_2392:
    set $S5708, $P5707
    iseq $I5709, $S5708, "%"
    $P5704."named"($I5709)
  if_5699_end:
.annotate 'line', 1687
    goto if_5680_end
  if_5680:
.annotate 'line', 1682
    find_lex $P5683, "$/"
    unless_null $P5683, vivify_2393
    $P5683 = root_new ['parrot';'Hash']
  vivify_2393:
    set $P5684, $P5683["named_param"]
    unless_null $P5684, vivify_2394
    new $P5684, "Undef"
  vivify_2394:
    $P5685 = $P5684."ast"()
    store_lex "$past", $P5685
.annotate 'line', 1683
    find_lex $P5687, "$quant"
    unless_null $P5687, vivify_2395
    new $P5687, "Undef"
  vivify_2395:
    set $S5688, $P5687
    isne $I5689, $S5688, "!"
    unless $I5689, if_5686_end
.annotate 'line', 1684
    find_lex $P5690, "$past"
    unless_null $P5690, vivify_2396
    new $P5690, "Undef"
  vivify_2396:
    find_lex $P5691, "$/"
    unless_null $P5691, vivify_2397
    $P5691 = root_new ['parrot';'Hash']
  vivify_2397:
    set $P5692, $P5691["named_param"]
    unless_null $P5692, vivify_2398
    $P5692 = root_new ['parrot';'Hash']
  vivify_2398:
    set $P5693, $P5692["param_var"]
    unless_null $P5693, vivify_2399
    $P5693 = root_new ['parrot';'Hash']
  vivify_2399:
    set $P5694, $P5693["sigil"]
    unless_null $P5694, vivify_2400
    new $P5694, "Undef"
  vivify_2400:
    $P5695 = "vivitype"($P5694)
    $P5690."viviself"($P5695)
  if_5686_end:
  if_5680_end:
.annotate 'line', 1697
    find_lex $P5720, "$/"
    unless_null $P5720, vivify_2401
    $P5720 = root_new ['parrot';'Hash']
  vivify_2401:
    set $P5721, $P5720["default_value"]
    unless_null $P5721, vivify_2402
    new $P5721, "Undef"
  vivify_2402:
    unless $P5721, if_5719_end
.annotate 'line', 1698
    find_lex $P5723, "$quant"
    unless_null $P5723, vivify_2403
    new $P5723, "Undef"
  vivify_2403:
    set $S5724, $P5723
    iseq $I5725, $S5724, "*"
    unless $I5725, if_5722_end
.annotate 'line', 1699
    find_lex $P5726, "$/"
    unless_null $P5726, vivify_2404
    new $P5726, "Undef"
  vivify_2404:
    $P5727 = $P5726."CURSOR"()
    $P5727."panic"("Can't put default on slurpy parameter")
  if_5722_end:
.annotate 'line', 1701
    find_lex $P5729, "$quant"
    unless_null $P5729, vivify_2405
    new $P5729, "Undef"
  vivify_2405:
    set $S5730, $P5729
    iseq $I5731, $S5730, "!"
    unless $I5731, if_5728_end
.annotate 'line', 1702
    find_lex $P5732, "$/"
    unless_null $P5732, vivify_2406
    new $P5732, "Undef"
  vivify_2406:
    $P5733 = $P5732."CURSOR"()
    $P5733."panic"("Can't put default on required parameter")
  if_5728_end:
.annotate 'line', 1704
    find_lex $P5734, "$past"
    unless_null $P5734, vivify_2407
    new $P5734, "Undef"
  vivify_2407:
    find_lex $P5735, "$/"
    unless_null $P5735, vivify_2408
    $P5735 = root_new ['parrot';'Hash']
  vivify_2408:
    set $P5736, $P5735["default_value"]
    unless_null $P5736, vivify_2409
    $P5736 = root_new ['parrot';'ResizablePMCArray']
  vivify_2409:
    set $P5737, $P5736[0]
    unless_null $P5737, vivify_2410
    $P5737 = root_new ['parrot';'Hash']
  vivify_2410:
    set $P5738, $P5737["EXPR"]
    unless_null $P5738, vivify_2411
    new $P5738, "Undef"
  vivify_2411:
    $P5739 = $P5738."ast"()
    $P5734."viviself"($P5739)
  if_5719_end:
.annotate 'line', 1706
    find_lex $P5741, "$past"
    unless_null $P5741, vivify_2412
    new $P5741, "Undef"
  vivify_2412:
    $P5742 = $P5741."viviself"()
    if $P5742, unless_5740_end
    find_lex $P5743, "$?PACKAGE"
    get_who $P5744, $P5743
    set $P5745, $P5744["@BLOCK"]
    unless_null $P5745, vivify_2413
    $P5745 = root_new ['parrot';'ResizablePMCArray']
  vivify_2413:
    set $P5746, $P5745[0]
    unless_null $P5746, vivify_2414
    new $P5746, "Undef"
  vivify_2414:
    find_lex $P5747, "$?PACKAGE"
    get_who $P5748, $P5747
    set $P5749, $P5748["@BLOCK"]
    unless_null $P5749, vivify_2415
    $P5749 = root_new ['parrot';'ResizablePMCArray']
  vivify_2415:
    set $P5750, $P5749[0]
    unless_null $P5750, vivify_2416
    new $P5750, "Undef"
  vivify_2416:
    $P5751 = $P5750."arity"()
    set $N5752, $P5751
    new $P5753, 'Float'
    set $P5753, $N5752
    add $P5754, $P5753, 1
    $P5746."arity"($P5754)
  unless_5740_end:
.annotate 'line', 1710
    find_lex $P5756, "$/"
    unless_null $P5756, vivify_2417
    $P5756 = root_new ['parrot';'Hash']
  vivify_2417:
    set $P5757, $P5756["typename"]
    unless_null $P5757, vivify_2418
    new $P5757, "Undef"
  vivify_2418:
    unless $P5757, if_5755_end
.annotate 'line', 1711
    find_lex $P5758, "$past"
    unless_null $P5758, vivify_2419
    new $P5758, "Undef"
  vivify_2419:
    find_lex $P5759, "$/"
    unless_null $P5759, vivify_2420
    $P5759 = root_new ['parrot';'Hash']
  vivify_2420:
    set $P5760, $P5759["typename"]
    unless_null $P5760, vivify_2421
    $P5760 = root_new ['parrot';'ResizablePMCArray']
  vivify_2421:
    set $P5761, $P5760[0]
    unless_null $P5761, vivify_2422
    new $P5761, "Undef"
  vivify_2422:
    $P5762 = $P5761."ast"()
    $P5758."multitype"($P5762)
  if_5755_end:
.annotate 'line', 1715
    find_lex $P5764, "$/"
    unless_null $P5764, vivify_2423
    $P5764 = root_new ['parrot';'Hash']
  vivify_2423:
    set $P5765, $P5764["definedness"]
    unless_null $P5765, vivify_2424
    new $P5765, "Undef"
  vivify_2424:
    unless $P5765, if_5763_end
.annotate 'line', 1716
    find_lex $P5766, "$/"
    unless_null $P5766, vivify_2425
    $P5766 = root_new ['parrot';'Hash']
  vivify_2425:
    set $P5767, $P5766["definedness"]
    unless_null $P5767, vivify_2426
    $P5767 = root_new ['parrot';'ResizablePMCArray']
  vivify_2426:
    set $P5768, $P5767[0]
    unless_null $P5768, vivify_2427
    new $P5768, "Undef"
  vivify_2427:
    set $S5769, $P5768
    new $P5770, 'String'
    set $P5770, $S5769
    find_lex $P5771, "$past"
    unless_null $P5771, vivify_2428
    $P5771 = root_new ['parrot';'Hash']
    store_lex "$past", $P5771
  vivify_2428:
    set $P5771["definedness"], $P5770
  if_5763_end:
.annotate 'line', 1719
    find_lex $P5772, "$/"
    find_lex $P5773, "$past"
    unless_null $P5773, vivify_2429
    new $P5773, "Undef"
  vivify_2429:
    $P5774 = $P5772."!make"($P5773)
.annotate 'line', 1678
    .return ($P5774)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("517_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5776
    .param pmc param_5777
.annotate 'line', 1722
    .lex "self", param_5776
    .lex "$/", param_5777
.annotate 'line', 1723
    new $P5778, "Undef"
    .lex "$name", $P5778
.annotate 'line', 1724
    new $P5779, "Undef"
    .lex "$past", $P5779
.annotate 'line', 1723
    find_lex $P5780, "$/"
    unless_null $P5780, vivify_2430
    new $P5780, "Undef"
  vivify_2430:
    set $S5781, $P5780
    new $P5782, 'String'
    set $P5782, $S5781
    store_lex "$name", $P5782
.annotate 'line', 1724
    get_hll_global $P5783, "GLOBAL"
    nqp_get_package_through_who $P5784, $P5783, "PAST"
    get_who $P5785, $P5784
    set $P5786, $P5785["Var"]
    find_lex $P5787, "$name"
    unless_null $P5787, vivify_2431
    new $P5787, "Undef"
  vivify_2431:
    find_lex $P5788, "$/"
    unless_null $P5788, vivify_2432
    new $P5788, "Undef"
  vivify_2432:
    $P5789 = $P5786."new"($P5787 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P5788 :named("node"))
    store_lex "$past", $P5789
.annotate 'line', 1726
    find_lex $P5790, "$?PACKAGE"
    get_who $P5791, $P5790
    set $P5792, $P5791["@BLOCK"]
    unless_null $P5792, vivify_2433
    $P5792 = root_new ['parrot';'ResizablePMCArray']
  vivify_2433:
    set $P5793, $P5792[0]
    unless_null $P5793, vivify_2434
    new $P5793, "Undef"
  vivify_2434:
    find_lex $P5794, "$name"
    unless_null $P5794, vivify_2435
    new $P5794, "Undef"
  vivify_2435:
    $P5793."symbol"($P5794, "lexical" :named("scope"))
.annotate 'line', 1727
    find_lex $P5795, "$/"
    find_lex $P5796, "$past"
    unless_null $P5796, vivify_2436
    new $P5796, "Undef"
  vivify_2436:
    $P5797 = $P5795."!make"($P5796)
.annotate 'line', 1722
    .return ($P5797)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("518_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5799
    .param pmc param_5800
.annotate 'line', 1730
    .lex "self", param_5799
    .lex "$/", param_5800
.annotate 'line', 1731
    new $P5801, "Undef"
    .lex "$past", $P5801
    find_lex $P5802, "$/"
    unless_null $P5802, vivify_2437
    $P5802 = root_new ['parrot';'Hash']
  vivify_2437:
    set $P5803, $P5802["param_var"]
    unless_null $P5803, vivify_2438
    new $P5803, "Undef"
  vivify_2438:
    $P5804 = $P5803."ast"()
    store_lex "$past", $P5804
.annotate 'line', 1732
    find_lex $P5805, "$past"
    unless_null $P5805, vivify_2439
    new $P5805, "Undef"
  vivify_2439:
    find_lex $P5806, "$/"
    unless_null $P5806, vivify_2440
    $P5806 = root_new ['parrot';'Hash']
  vivify_2440:
    set $P5807, $P5806["param_var"]
    unless_null $P5807, vivify_2441
    $P5807 = root_new ['parrot';'Hash']
  vivify_2441:
    set $P5808, $P5807["name"]
    unless_null $P5808, vivify_2442
    new $P5808, "Undef"
  vivify_2442:
    set $S5809, $P5808
    $P5805."named"($S5809)
.annotate 'line', 1733
    find_lex $P5810, "$/"
    find_lex $P5811, "$past"
    unless_null $P5811, vivify_2443
    new $P5811, "Undef"
  vivify_2443:
    $P5812 = $P5810."!make"($P5811)
.annotate 'line', 1730
    .return ($P5812)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("519_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5814
    .param pmc param_5815
.annotate 'line', 1736
    .lex "self", param_5814
    .lex "$/", param_5815
.annotate 'line', 1737
    $P5816 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P5816
    get_hll_global $P5817, "GLOBAL"
    nqp_get_package_through_who $P5818, $P5817, "HLL"
    get_who $P5819, $P5818
    set $P5820, $P5819["Compiler"]
    find_lex $P5821, "$/"
    unless_null $P5821, vivify_2444
    new $P5821, "Undef"
  vivify_2444:
    set $S5822, $P5821
    $P5823 = $P5820."parse_name"($S5822)
    store_lex "@name", $P5823
.annotate 'line', 1738
    find_lex $P5824, "$/"
    find_lex $P5825, "@name"
    unless_null $P5825, vivify_2445
    $P5825 = root_new ['parrot';'ResizablePMCArray']
  vivify_2445:
    find_lex $P5826, "$/"
    unless_null $P5826, vivify_2446
    new $P5826, "Undef"
  vivify_2446:
    $P5827 = "lexical_package_lookup"($P5825, $P5826)
    $P5828 = $P5824."!make"($P5827)
.annotate 'line', 1736
    .return ($P5828)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("520_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5830
    .param pmc param_5831
.annotate 'line', 1741
    .lex "self", param_5830
    .lex "$/", param_5831
.annotate 'line', 1742
    find_lex $P5832, "$/"
    find_lex $P5833, "$/"
    unless_null $P5833, vivify_2447
    $P5833 = root_new ['parrot';'Hash']
  vivify_2447:
    set $P5834, $P5833["trait_mod"]
    unless_null $P5834, vivify_2448
    new $P5834, "Undef"
  vivify_2448:
    $P5835 = $P5834."ast"()
    $P5836 = $P5832."!make"($P5835)
.annotate 'line', 1741
    .return ($P5836)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("521_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5838
    .param pmc param_5839
.annotate 'line', 1745
    .const 'Sub' $P5862 = "522_1303748459.273" 
    capture_lex $P5862
    .lex "self", param_5838
    .lex "$/", param_5839
.annotate 'line', 1746
    new $P5840, "Undef"
    .lex "$cpast", $P5840
    find_lex $P5841, "$/"
    unless_null $P5841, vivify_2449
    $P5841 = root_new ['parrot';'Hash']
  vivify_2449:
    set $P5842, $P5841["circumfix"]
    unless_null $P5842, vivify_2450
    $P5842 = root_new ['parrot';'ResizablePMCArray']
  vivify_2450:
    set $P5843, $P5842[0]
    unless_null $P5843, vivify_2451
    new $P5843, "Undef"
  vivify_2451:
    $P5844 = $P5843."ast"()
    store_lex "$cpast", $P5844
.annotate 'line', 1747
    find_lex $P5847, "$/"
    unless_null $P5847, vivify_2452
    $P5847 = root_new ['parrot';'Hash']
  vivify_2452:
    set $P5848, $P5847["longname"]
    unless_null $P5848, vivify_2453
    new $P5848, "Undef"
  vivify_2453:
    set $S5849, $P5848
    iseq $I5850, $S5849, "parrot_vtable"
    if $I5850, if_5846
.annotate 'line', 1767
    find_lex $P5904, "$/"
    unless_null $P5904, vivify_2454
    $P5904 = root_new ['parrot';'Hash']
  vivify_2454:
    set $P5905, $P5904["longname"]
    unless_null $P5905, vivify_2455
    new $P5905, "Undef"
  vivify_2455:
    set $S5906, $P5905
    iseq $I5907, $S5906, "pirflags"
    if $I5907, if_5903
.annotate 'line', 1771
    find_lex $P5911, "$/"
    unless_null $P5911, vivify_2456
    new $P5911, "Undef"
  vivify_2456:
    $P5912 = $P5911."CURSOR"()
    new $P5913, 'String'
    set $P5913, "Trait '"
    find_lex $P5914, "$/"
    unless_null $P5914, vivify_2457
    $P5914 = root_new ['parrot';'Hash']
  vivify_2457:
    set $P5915, $P5914["longname"]
    unless_null $P5915, vivify_2458
    new $P5915, "Undef"
  vivify_2458:
    concat $P5916, $P5913, $P5915
    concat $P5917, $P5916, "' not implemented"
    $P5918 = $P5912."panic"($P5917)
.annotate 'line', 1770
    set $P5902, $P5918
.annotate 'line', 1767
    goto if_5903_end
  if_5903:
.annotate 'line', 1768
    find_lex $P5908, "$/"
    unless_null $P5908, vivify_2459
    new $P5908, "Undef"
  vivify_2459:
    $P5909 = $P5908."CURSOR"()
    $P5910 = $P5909."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1767
    set $P5902, $P5910
  if_5903_end:
    set $P5845, $P5902
.annotate 'line', 1747
    goto if_5846_end
  if_5846:
.annotate 'line', 1750
    get_hll_global $P5852, "GLOBAL"
    nqp_get_package_through_who $P5853, $P5852, "PAST"
    get_who $P5854, $P5853
    set $P5855, $P5854["Val"]
    find_lex $P5856, "$cpast"
    unless_null $P5856, vivify_2460
    new $P5856, "Undef"
  vivify_2460:
    $P5857 = $P5855."ACCEPTS"($P5856)
    if $P5857, unless_5851_end
.annotate 'line', 1749
    find_lex $P5858, "$/"
    unless_null $P5858, vivify_2461
    new $P5858, "Undef"
  vivify_2461:
    $P5859 = $P5858."CURSOR"()
    $P5859."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_5851_end:
.annotate 'line', 1751
    find_lex $P5860, "$/"
    .const 'Sub' $P5862 = "522_1303748459.273" 
    newclosure $P5900, $P5862
    $P5901 = $P5860."!make"($P5900)
.annotate 'line', 1747
    set $P5845, $P5901
  if_5846_end:
.annotate 'line', 1745
    .return ($P5845)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5861"  :anon :subid("522_1303748459.273") :outer("521_1303748459.273")
    .param pmc param_5863
.annotate 'line', 1751
    .lex "$match", param_5863
.annotate 'line', 1752
    new $P5864, "Undef"
    .lex "$meth", $P5864
    find_lex $P5865, "$match"
    unless_null $P5865, vivify_2462
    new $P5865, "Undef"
  vivify_2462:
    $P5866 = $P5865."ast"()
    set $P5867, $P5866["block_past"]
    unless_null $P5867, vivify_2463
    new $P5867, "Undef"
  vivify_2463:
    store_lex "$meth", $P5867
.annotate 'line', 1753
    find_dynamic_lex $P5872, "$*PACKAGE-SETUP"
    unless_null $P5872, vivify_2464
    get_hll_global $P5870, "GLOBAL"
    get_who $P5871, $P5870
    set $P5872, $P5871["$PACKAGE-SETUP"]
    unless_null $P5872, vivify_2465
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2465:
  vivify_2464:
    defined $I5873, $P5872
    if $I5873, if_5869
    new $P5868, 'Integer'
    set $P5868, $I5873
    goto if_5869_end
  if_5869:
.annotate 'line', 1754
    find_dynamic_lex $P5876, "$*PACKAGE-SETUP"
    unless_null $P5876, vivify_2466
    get_hll_global $P5874, "GLOBAL"
    get_who $P5875, $P5874
    set $P5876, $P5875["$PACKAGE-SETUP"]
    unless_null $P5876, vivify_2467
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2467:
  vivify_2466:
    get_hll_global $P5877, "GLOBAL"
    nqp_get_package_through_who $P5878, $P5877, "PAST"
    get_who $P5879, $P5878
    set $P5880, $P5879["Op"]
.annotate 'line', 1756
    get_hll_global $P5881, "GLOBAL"
    nqp_get_package_through_who $P5882, $P5881, "PAST"
    get_who $P5883, $P5882
    set $P5884, $P5883["Op"]
.annotate 'line', 1759
    get_hll_global $P5885, "GLOBAL"
    nqp_get_package_through_who $P5886, $P5885, "PAST"
    get_who $P5887, $P5886
    set $P5888, $P5887["Var"]
    $P5889 = $P5888."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5890 = $P5884."new"($P5889, "get_how PP" :named("pirop"))
.annotate 'line', 1761
    get_hll_global $P5891, "GLOBAL"
    nqp_get_package_through_who $P5892, $P5891, "PAST"
    get_who $P5893, $P5892
    set $P5894, $P5893["Var"]
    $P5895 = $P5894."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P5896, "$cpast"
    unless_null $P5896, vivify_2468
    new $P5896, "Undef"
  vivify_2468:
    find_lex $P5897, "$meth"
    unless_null $P5897, vivify_2469
    new $P5897, "Undef"
  vivify_2469:
    $P5898 = $P5880."new"($P5890, $P5895, $P5896, $P5897, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1754
    $P5899 = $P5876."push"($P5898)
.annotate 'line', 1753
    set $P5868, $P5899
  if_5869_end:
.annotate 'line', 1751
    .return ($P5868)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("523_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_5922
    .param pmc param_5923
    .param pmc param_5924 :optional
    .param int has_param_5924 :opt_flag
.annotate 'line', 1775
    .const 'Sub' $P6078 = "526_1303748459.273" 
    capture_lex $P6078
    .const 'Sub' $P6040 = "525_1303748459.273" 
    capture_lex $P6040
    .const 'Sub' $P5993 = "524_1303748459.273" 
    capture_lex $P5993
    new $P5921, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5921, control_5920
    push_eh $P5921
    .lex "self", param_5922
    .lex "$/", param_5923
    if has_param_5924, optparam_2470
    new $P5925, "Undef"
    set param_5924, $P5925
  optparam_2470:
    .lex "$key", param_5924
.annotate 'line', 1776
    $P5926 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P5926
.annotate 'line', 1777
    new $P5927, "Undef"
    .lex "$name", $P5927
.annotate 'line', 1778
    new $P5928, "Undef"
    .lex "$past", $P5928
.annotate 'line', 1776
    get_hll_global $P5929, "GLOBAL"
    nqp_get_package_through_who $P5930, $P5929, "Regex"
    nqp_get_package_through_who $P5931, $P5930, "P6Regex"
    nqp_get_package_through_who $P5932, $P5931, "Actions"
    get_who $P5933, $P5932
    set $P5934, $P5933["@MODIFIERS"]
    unless_null $P5934, vivify_2471
    $P5934 = root_new ['parrot';'ResizablePMCArray']
  vivify_2471:
    store_lex "@MODIFIERS", $P5934
.annotate 'line', 1777
    find_lex $P5935, "$/"
    unless_null $P5935, vivify_2472
    $P5935 = root_new ['parrot';'Hash']
  vivify_2472:
    set $P5936, $P5935["deflongname"]
    unless_null $P5936, vivify_2473
    new $P5936, "Undef"
  vivify_2473:
    $P5937 = $P5936."ast"()
    set $S5938, $P5937
    new $P5939, 'String'
    set $P5939, $S5938
    store_lex "$name", $P5939
    find_lex $P5940, "$past"
    unless_null $P5940, vivify_2474
    new $P5940, "Undef"
  vivify_2474:
.annotate 'line', 1779
    find_lex $P5942, "$/"
    unless_null $P5942, vivify_2475
    $P5942 = root_new ['parrot';'Hash']
  vivify_2475:
    set $P5943, $P5942["proto"]
    unless_null $P5943, vivify_2476
    new $P5943, "Undef"
  vivify_2476:
    if $P5943, if_5941
.annotate 'line', 1818
    find_lex $P6036, "$key"
    unless_null $P6036, vivify_2477
    new $P6036, "Undef"
  vivify_2477:
    set $S6037, $P6036
    iseq $I6038, $S6037, "open"
    if $I6038, if_6035
.annotate 'line', 1828
    .const 'Sub' $P6078 = "526_1303748459.273" 
    capture_lex $P6078
    $P6078()
    goto if_6035_end
  if_6035:
.annotate 'line', 1818
    .const 'Sub' $P6040 = "525_1303748459.273" 
    capture_lex $P6040
    $P6040()
  if_6035_end:
    goto if_5941_end
  if_5941:
.annotate 'line', 1781
    get_hll_global $P5944, "GLOBAL"
    nqp_get_package_through_who $P5945, $P5944, "PAST"
    get_who $P5946, $P5945
    set $P5947, $P5946["Stmts"]
.annotate 'line', 1782
    get_hll_global $P5948, "GLOBAL"
    nqp_get_package_through_who $P5949, $P5948, "PAST"
    get_who $P5950, $P5949
    set $P5951, $P5950["Block"]
    find_lex $P5952, "$name"
    unless_null $P5952, vivify_2512
    new $P5952, "Undef"
  vivify_2512:
.annotate 'line', 1783
    get_hll_global $P5953, "GLOBAL"
    nqp_get_package_through_who $P5954, $P5953, "PAST"
    get_who $P5955, $P5954
    set $P5956, $P5955["Op"]
.annotate 'line', 1784
    get_hll_global $P5957, "GLOBAL"
    nqp_get_package_through_who $P5958, $P5957, "PAST"
    get_who $P5959, $P5958
    set $P5960, $P5959["Var"]
    $P5961 = $P5960."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5962, "$name"
    unless_null $P5962, vivify_2513
    new $P5962, "Undef"
  vivify_2513:
    $P5963 = $P5956."new"($P5961, $P5962, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1783
    find_lex $P5964, "$/"
    unless_null $P5964, vivify_2514
    new $P5964, "Undef"
  vivify_2514:
    $P5965 = $P5951."new"($P5963, $P5952 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5964 :named("node"))
.annotate 'line', 1793
    get_hll_global $P5966, "GLOBAL"
    nqp_get_package_through_who $P5967, $P5966, "PAST"
    get_who $P5968, $P5967
    set $P5969, $P5968["Block"]
    new $P5970, "String"
    assign $P5970, "!PREFIX__"
    find_lex $P5971, "$name"
    unless_null $P5971, vivify_2515
    new $P5971, "Undef"
  vivify_2515:
    concat $P5972, $P5970, $P5971
.annotate 'line', 1794
    get_hll_global $P5973, "GLOBAL"
    nqp_get_package_through_who $P5974, $P5973, "PAST"
    get_who $P5975, $P5974
    set $P5976, $P5975["Op"]
.annotate 'line', 1795
    get_hll_global $P5977, "GLOBAL"
    nqp_get_package_through_who $P5978, $P5977, "PAST"
    get_who $P5979, $P5978
    set $P5980, $P5979["Var"]
    $P5981 = $P5980."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5982, "$name"
    unless_null $P5982, vivify_2516
    new $P5982, "Undef"
  vivify_2516:
    $P5983 = $P5976."new"($P5981, $P5982, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1794
    find_lex $P5984, "$/"
    unless_null $P5984, vivify_2517
    new $P5984, "Undef"
  vivify_2517:
    $P5985 = $P5969."new"($P5983, $P5972 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5984 :named("node"))
.annotate 'line', 1793
    $P5986 = $P5947."new"($P5965, $P5985)
.annotate 'line', 1781
    store_lex "$past", $P5986
.annotate 'line', 1805
    find_lex $P5988, "$past"
    unless_null $P5988, vivify_2518
    new $P5988, "Undef"
  vivify_2518:
    $P5989 = $P5988."list"()
    defined $I5990, $P5989
    unless $I5990, for_undef_2519
    iter $P5987, $P5989
    new $P6033, 'ExceptionHandler'
    set_label $P6033, loop6032_handler
    $P6033."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6033
  loop6032_test:
    unless $P5987, loop6032_done
    shift $P5991, $P5987
  loop6032_redo:
    .const 'Sub' $P5993 = "524_1303748459.273" 
    capture_lex $P5993
    $P5993($P5991)
  loop6032_next:
    goto loop6032_test
  loop6032_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6034, exception, 'type'
    eq $P6034, .CONTROL_LOOP_NEXT, loop6032_next
    eq $P6034, .CONTROL_LOOP_REDO, loop6032_redo
  loop6032_done:
    pop_eh 
  for_undef_2519:
  if_5941_end:
.annotate 'line', 1864
    find_lex $P6191, "$/"
    find_lex $P6192, "$past"
    unless_null $P6192, vivify_2524
    new $P6192, "Undef"
  vivify_2524:
    $P6193 = $P6191."!make"($P6192)
.annotate 'line', 1775
    .return ($P6193)
  control_5920:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6194, exception, "payload"
    .return ($P6194)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6077"  :anon :subid("526_1303748459.273") :outer("523_1303748459.273")
.annotate 'line', 1829
    new $P6079, "Undef"
    .lex "$regex", $P6079
.annotate 'line', 1830
    get_hll_global $P6080, "GLOBAL"
    nqp_get_package_through_who $P6081, $P6080, "Regex"
    nqp_get_package_through_who $P6082, $P6081, "P6Regex"
    nqp_get_package_through_who $P6083, $P6082, "Actions"
    get_who $P6084, $P6083
    set $P6085, $P6084["buildsub"]
    find_lex $P6086, "$/"
    unless_null $P6086, vivify_2478
    $P6086 = root_new ['parrot';'Hash']
  vivify_2478:
    set $P6087, $P6086["p6regex"]
    unless_null $P6087, vivify_2479
    new $P6087, "Undef"
  vivify_2479:
    $P6088 = $P6087."ast"()
    find_lex $P6089, "$?PACKAGE"
    get_who $P6090, $P6089
    set $P6091, $P6090["@BLOCK"]
    unless_null $P6091, vivify_2480
    $P6091 = root_new ['parrot';'ResizablePMCArray']
  vivify_2480:
    $P6092 = $P6091."shift"()
    $P6093 = $P6085($P6088, $P6092)
    store_lex "$regex", $P6093
.annotate 'line', 1831
    find_lex $P6094, "$regex"
    unless_null $P6094, vivify_2481
    new $P6094, "Undef"
  vivify_2481:
    find_lex $P6095, "$name"
    unless_null $P6095, vivify_2482
    new $P6095, "Undef"
  vivify_2482:
    $P6094."name"($P6095)
.annotate 'line', 1833
    get_hll_global $P6096, "GLOBAL"
    nqp_get_package_through_who $P6097, $P6096, "PAST"
    get_who $P6098, $P6097
    set $P6099, $P6098["Op"]
.annotate 'line', 1835
    get_hll_global $P6100, "GLOBAL"
    nqp_get_package_through_who $P6101, $P6100, "PAST"
    get_who $P6102, $P6101
    set $P6103, $P6102["Var"]
    new $P6104, "ResizablePMCArray"
    push $P6104, "Regex"
    $P6105 = $P6103."new"("Method" :named("name"), $P6104 :named("namespace"), "package" :named("scope"))
    find_lex $P6106, "$regex"
    unless_null $P6106, vivify_2483
    new $P6106, "Undef"
  vivify_2483:
    $P6107 = $P6099."new"($P6105, $P6106, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1833
    store_lex "$past", $P6107
.annotate 'line', 1838
    find_dynamic_lex $P6111, "$*PACKAGE-SETUP"
    unless_null $P6111, vivify_2484
    get_hll_global $P6109, "GLOBAL"
    get_who $P6110, $P6109
    set $P6111, $P6110["$PACKAGE-SETUP"]
    unless_null $P6111, vivify_2485
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2485:
  vivify_2484:
    defined $I6112, $P6111
    unless $I6112, if_6108_end
.annotate 'line', 1839
    find_dynamic_lex $P6115, "$*PACKAGE-SETUP"
    unless_null $P6115, vivify_2486
    get_hll_global $P6113, "GLOBAL"
    get_who $P6114, $P6113
    set $P6115, $P6114["$PACKAGE-SETUP"]
    unless_null $P6115, vivify_2487
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2487:
  vivify_2486:
    get_hll_global $P6116, "GLOBAL"
    nqp_get_package_through_who $P6117, $P6116, "PAST"
    get_who $P6118, $P6117
    set $P6119, $P6118["Op"]
.annotate 'line', 1841
    get_hll_global $P6120, "GLOBAL"
    nqp_get_package_through_who $P6121, $P6120, "PAST"
    get_who $P6122, $P6121
    set $P6123, $P6122["Op"]
.annotate 'line', 1843
    get_hll_global $P6124, "GLOBAL"
    nqp_get_package_through_who $P6125, $P6124, "PAST"
    get_who $P6126, $P6125
    set $P6127, $P6126["Var"]
    $P6128 = $P6127."new"("type_obj" :named("name"), "register" :named("scope"))
    $P6129 = $P6123."new"($P6128, "get_how PP" :named("pirop"))
.annotate 'line', 1845
    get_hll_global $P6130, "GLOBAL"
    nqp_get_package_through_who $P6131, $P6130, "PAST"
    get_who $P6132, $P6131
    set $P6133, $P6132["Var"]
    $P6134 = $P6133."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1846
    get_hll_global $P6135, "GLOBAL"
    nqp_get_package_through_who $P6136, $P6135, "PAST"
    get_who $P6137, $P6136
    set $P6138, $P6137["Val"]
    find_lex $P6139, "$name"
    unless_null $P6139, vivify_2488
    new $P6139, "Undef"
  vivify_2488:
    $P6140 = $P6138."new"($P6139 :named("value"))
.annotate 'line', 1847
    get_hll_global $P6141, "GLOBAL"
    nqp_get_package_through_who $P6142, $P6141, "PAST"
    get_who $P6143, $P6142
    set $P6144, $P6143["Val"]
    find_lex $P6145, "$regex"
    unless_null $P6145, vivify_2489
    new $P6145, "Undef"
  vivify_2489:
    $P6146 = $P6144."new"($P6145 :named("value"))
    $P6147 = $P6119."new"($P6129, $P6134, $P6140, $P6146, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1839
    $P6115."push"($P6147)
.annotate 'line', 1849
    find_dynamic_lex $P6150, "$*PACKAGE-SETUP"
    unless_null $P6150, vivify_2490
    get_hll_global $P6148, "GLOBAL"
    get_who $P6149, $P6148
    set $P6150, $P6149["$PACKAGE-SETUP"]
    unless_null $P6150, vivify_2491
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2491:
  vivify_2490:
    get_hll_global $P6151, "GLOBAL"
    nqp_get_package_through_who $P6152, $P6151, "PAST"
    get_who $P6153, $P6152
    set $P6154, $P6153["Op"]
.annotate 'line', 1851
    get_hll_global $P6155, "GLOBAL"
    nqp_get_package_through_who $P6156, $P6155, "PAST"
    get_who $P6157, $P6156
    set $P6158, $P6157["Op"]
.annotate 'line', 1853
    get_hll_global $P6159, "GLOBAL"
    nqp_get_package_through_who $P6160, $P6159, "PAST"
    get_who $P6161, $P6160
    set $P6162, $P6161["Var"]
    $P6163 = $P6162."new"("type_obj" :named("name"), "register" :named("scope"))
    $P6164 = $P6158."new"($P6163, "get_how PP" :named("pirop"))
.annotate 'line', 1855
    get_hll_global $P6165, "GLOBAL"
    nqp_get_package_through_who $P6166, $P6165, "PAST"
    get_who $P6167, $P6166
    set $P6168, $P6167["Var"]
    $P6169 = $P6168."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1856
    get_hll_global $P6170, "GLOBAL"
    nqp_get_package_through_who $P6171, $P6170, "PAST"
    get_who $P6172, $P6171
    set $P6173, $P6172["Val"]
    new $P6174, "String"
    assign $P6174, "!PREFIX__"
    find_lex $P6175, "$name"
    unless_null $P6175, vivify_2492
    new $P6175, "Undef"
  vivify_2492:
    concat $P6176, $P6174, $P6175
    $P6177 = $P6173."new"($P6176 :named("value"))
.annotate 'line', 1857
    get_hll_global $P6178, "GLOBAL"
    nqp_get_package_through_who $P6179, $P6178, "PAST"
    get_who $P6180, $P6179
    set $P6181, $P6180["Var"]
    new $P6182, "String"
    assign $P6182, "!PREFIX__"
    find_lex $P6183, "$name"
    unless_null $P6183, vivify_2493
    new $P6183, "Undef"
  vivify_2493:
    concat $P6184, $P6182, $P6183
    $P6185 = $P6181."new"($P6184 :named("name"), "package" :named("scope"))
    $P6186 = $P6154."new"($P6164, $P6169, $P6177, $P6185, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1849
    $P6150."push"($P6186)
  if_6108_end:
.annotate 'line', 1861
    find_lex $P6187, "$regex"
    unless_null $P6187, vivify_2494
    new $P6187, "Undef"
  vivify_2494:
    find_lex $P6188, "$past"
    unless_null $P6188, vivify_2495
    $P6188 = root_new ['parrot';'Hash']
    store_lex "$past", $P6188
  vivify_2495:
    set $P6188["sink"], $P6187
.annotate 'line', 1862
    find_lex $P6189, "@MODIFIERS"
    unless_null $P6189, vivify_2496
    $P6189 = root_new ['parrot';'ResizablePMCArray']
  vivify_2496:
    $P6190 = $P6189."shift"()
.annotate 'line', 1828
    .return ($P6190)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6039"  :anon :subid("525_1303748459.273") :outer("523_1303748459.273")
.annotate 'line', 1819
    $P6041 = root_new ['parrot';'Hash']
    .lex "%h", $P6041
.annotate 'line', 1818
    find_lex $P6042, "%h"
    unless_null $P6042, vivify_2497
    $P6042 = root_new ['parrot';'Hash']
  vivify_2497:
.annotate 'line', 1820
    find_lex $P6044, "$/"
    unless_null $P6044, vivify_2498
    $P6044 = root_new ['parrot';'Hash']
  vivify_2498:
    set $P6045, $P6044["sym"]
    unless_null $P6045, vivify_2499
    new $P6045, "Undef"
  vivify_2499:
    set $S6046, $P6045
    iseq $I6047, $S6046, "token"
    unless $I6047, if_6043_end
    new $P6048, "Integer"
    assign $P6048, 1
    find_lex $P6049, "%h"
    unless_null $P6049, vivify_2500
    $P6049 = root_new ['parrot';'Hash']
    store_lex "%h", $P6049
  vivify_2500:
    set $P6049["r"], $P6048
  if_6043_end:
.annotate 'line', 1821
    find_lex $P6051, "$/"
    unless_null $P6051, vivify_2501
    $P6051 = root_new ['parrot';'Hash']
  vivify_2501:
    set $P6052, $P6051["sym"]
    unless_null $P6052, vivify_2502
    new $P6052, "Undef"
  vivify_2502:
    set $S6053, $P6052
    iseq $I6054, $S6053, "rule"
    unless $I6054, if_6050_end
    new $P6055, "Integer"
    assign $P6055, 1
    find_lex $P6056, "%h"
    unless_null $P6056, vivify_2503
    $P6056 = root_new ['parrot';'Hash']
    store_lex "%h", $P6056
  vivify_2503:
    set $P6056["r"], $P6055
    new $P6057, "Integer"
    assign $P6057, 1
    find_lex $P6058, "%h"
    unless_null $P6058, vivify_2504
    $P6058 = root_new ['parrot';'Hash']
    store_lex "%h", $P6058
  vivify_2504:
    set $P6058["s"], $P6057
  if_6050_end:
.annotate 'line', 1822
    find_lex $P6059, "@MODIFIERS"
    unless_null $P6059, vivify_2505
    $P6059 = root_new ['parrot';'ResizablePMCArray']
  vivify_2505:
    find_lex $P6060, "%h"
    unless_null $P6060, vivify_2506
    $P6060 = root_new ['parrot';'Hash']
  vivify_2506:
    $P6059."unshift"($P6060)
.annotate 'line', 1823
    find_lex $P6061, "$name"
    unless_null $P6061, vivify_2507
    new $P6061, "Undef"
  vivify_2507:
    get_hll_global $P6062, "GLOBAL"
    nqp_get_package_through_who $P6063, $P6062, "Regex"
    nqp_get_package_through_who $P6064, $P6063, "P6Regex"
    nqp_get_package_through_who $P6065, $P6064, "Actions"
    get_who $P6066, $P6065
    set $P6066["$REGEXNAME"], $P6061
.annotate 'line', 1824
    find_lex $P6067, "$?PACKAGE"
    get_who $P6068, $P6067
    set $P6069, $P6068["@BLOCK"]
    unless_null $P6069, vivify_2508
    $P6069 = root_new ['parrot';'ResizablePMCArray']
  vivify_2508:
    set $P6070, $P6069[0]
    unless_null $P6070, vivify_2509
    new $P6070, "Undef"
  vivify_2509:
    $P6070."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1825
    find_lex $P6071, "$?PACKAGE"
    get_who $P6072, $P6071
    set $P6073, $P6072["@BLOCK"]
    unless_null $P6073, vivify_2510
    $P6073 = root_new ['parrot';'ResizablePMCArray']
  vivify_2510:
    set $P6074, $P6073[0]
    unless_null $P6074, vivify_2511
    new $P6074, "Undef"
  vivify_2511:
    $P6074."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1826
    new $P6075, "Exception"
    set $P6075['type'], .CONTROL_RETURN
    new $P6076, "Integer"
    assign $P6076, 0
    setattribute $P6075, 'payload', $P6076
    throw $P6075
.annotate 'line', 1818
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5992"  :anon :subid("524_1303748459.273") :outer("523_1303748459.273")
    .param pmc param_5994
.annotate 'line', 1805
    .lex "$_", param_5994
.annotate 'line', 1806
    find_dynamic_lex $P5997, "$*PACKAGE-SETUP"
    unless_null $P5997, vivify_2520
    get_hll_global $P5995, "GLOBAL"
    get_who $P5996, $P5995
    set $P5997, $P5996["$PACKAGE-SETUP"]
    unless_null $P5997, vivify_2521
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2521:
  vivify_2520:
    get_hll_global $P5998, "GLOBAL"
    nqp_get_package_through_who $P5999, $P5998, "PAST"
    get_who $P6000, $P5999
    set $P6001, $P6000["Op"]
.annotate 'line', 1808
    get_hll_global $P6002, "GLOBAL"
    nqp_get_package_through_who $P6003, $P6002, "PAST"
    get_who $P6004, $P6003
    set $P6005, $P6004["Op"]
.annotate 'line', 1810
    get_hll_global $P6006, "GLOBAL"
    nqp_get_package_through_who $P6007, $P6006, "PAST"
    get_who $P6008, $P6007
    set $P6009, $P6008["Var"]
    $P6010 = $P6009."new"("type_obj" :named("name"), "register" :named("scope"))
    $P6011 = $P6005."new"($P6010, "get_how PP" :named("pirop"))
.annotate 'line', 1812
    get_hll_global $P6012, "GLOBAL"
    nqp_get_package_through_who $P6013, $P6012, "PAST"
    get_who $P6014, $P6013
    set $P6015, $P6014["Var"]
    $P6016 = $P6015."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1813
    get_hll_global $P6017, "GLOBAL"
    nqp_get_package_through_who $P6018, $P6017, "PAST"
    get_who $P6019, $P6018
    set $P6020, $P6019["Val"]
    find_lex $P6021, "$_"
    unless_null $P6021, vivify_2522
    new $P6021, "Undef"
  vivify_2522:
    $P6022 = $P6021."name"()
    $P6023 = $P6020."new"($P6022 :named("value"))
.annotate 'line', 1814
    get_hll_global $P6024, "GLOBAL"
    nqp_get_package_through_who $P6025, $P6024, "PAST"
    get_who $P6026, $P6025
    set $P6027, $P6026["Val"]
    find_lex $P6028, "$_"
    unless_null $P6028, vivify_2523
    new $P6028, "Undef"
  vivify_2523:
    $P6029 = $P6027."new"($P6028 :named("value"))
    $P6030 = $P6001."new"($P6011, $P6016, $P6023, $P6029, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1806
    $P6031 = $P5997."push"($P6030)
.annotate 'line', 1805
    .return ($P6031)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("527_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6196
    .param pmc param_6197
.annotate 'line', 1868
    .lex "self", param_6196
    .lex "$/", param_6197
.annotate 'line', 1869
    new $P6198, "Undef"
    .lex "$past", $P6198
    find_lex $P6201, "$/"
    unless_null $P6201, vivify_2525
    $P6201 = root_new ['parrot';'Hash']
  vivify_2525:
    set $P6202, $P6201["args"]
    unless_null $P6202, vivify_2526
    new $P6202, "Undef"
  vivify_2526:
    if $P6202, if_6200
    get_hll_global $P6207, "GLOBAL"
    nqp_get_package_through_who $P6208, $P6207, "PAST"
    get_who $P6209, $P6208
    set $P6210, $P6209["Op"]
    find_lex $P6211, "$/"
    unless_null $P6211, vivify_2527
    new $P6211, "Undef"
  vivify_2527:
    $P6212 = $P6210."new"($P6211 :named("node"))
    set $P6199, $P6212
    goto if_6200_end
  if_6200:
    find_lex $P6203, "$/"
    unless_null $P6203, vivify_2528
    $P6203 = root_new ['parrot';'Hash']
  vivify_2528:
    set $P6204, $P6203["args"]
    unless_null $P6204, vivify_2529
    $P6204 = root_new ['parrot';'ResizablePMCArray']
  vivify_2529:
    set $P6205, $P6204[0]
    unless_null $P6205, vivify_2530
    new $P6205, "Undef"
  vivify_2530:
    $P6206 = $P6205."ast"()
    set $P6199, $P6206
  if_6200_end:
    store_lex "$past", $P6199
.annotate 'line', 1870
    find_lex $P6214, "$/"
    unless_null $P6214, vivify_2531
    $P6214 = root_new ['parrot';'Hash']
  vivify_2531:
    set $P6215, $P6214["quote"]
    unless_null $P6215, vivify_2532
    new $P6215, "Undef"
  vivify_2532:
    if $P6215, if_6213
.annotate 'line', 1874
    find_lex $P6222, "$/"
    unless_null $P6222, vivify_2533
    $P6222 = root_new ['parrot';'Hash']
  vivify_2533:
    set $P6223, $P6222["longname"]
    unless_null $P6223, vivify_2534
    new $P6223, "Undef"
  vivify_2534:
    set $S6224, $P6223
    iseq $I6225, $S6224, "HOW"
    if $I6225, if_6221
.annotate 'line', 1877
    find_lex $P6228, "$/"
    unless_null $P6228, vivify_2535
    $P6228 = root_new ['parrot';'Hash']
  vivify_2535:
    set $P6229, $P6228["longname"]
    unless_null $P6229, vivify_2536
    new $P6229, "Undef"
  vivify_2536:
    set $S6230, $P6229
    iseq $I6231, $S6230, "WHAT"
    if $I6231, if_6227
.annotate 'line', 1880
    find_lex $P6234, "$/"
    unless_null $P6234, vivify_2537
    $P6234 = root_new ['parrot';'Hash']
  vivify_2537:
    set $P6235, $P6234["longname"]
    unless_null $P6235, vivify_2538
    new $P6235, "Undef"
  vivify_2538:
    set $S6236, $P6235
    iseq $I6237, $S6236, "WHO"
    if $I6237, if_6233
.annotate 'line', 1884
    find_lex $P6239, "$past"
    unless_null $P6239, vivify_2539
    new $P6239, "Undef"
  vivify_2539:
    find_lex $P6240, "$/"
    unless_null $P6240, vivify_2540
    $P6240 = root_new ['parrot';'Hash']
  vivify_2540:
    set $P6241, $P6240["longname"]
    unless_null $P6241, vivify_2541
    new $P6241, "Undef"
  vivify_2541:
    set $S6242, $P6241
    $P6239."name"($S6242)
.annotate 'line', 1885
    find_lex $P6243, "$past"
    unless_null $P6243, vivify_2542
    new $P6243, "Undef"
  vivify_2542:
    $P6243."pasttype"("callmethod")
.annotate 'line', 1883
    goto if_6233_end
  if_6233:
.annotate 'line', 1881
    find_lex $P6238, "$past"
    unless_null $P6238, vivify_2543
    new $P6238, "Undef"
  vivify_2543:
    $P6238."pirop"("get_who PP")
  if_6233_end:
.annotate 'line', 1880
    goto if_6227_end
  if_6227:
.annotate 'line', 1878
    find_lex $P6232, "$past"
    unless_null $P6232, vivify_2544
    new $P6232, "Undef"
  vivify_2544:
    $P6232."pirop"("get_what PP")
  if_6227_end:
.annotate 'line', 1877
    goto if_6221_end
  if_6221:
.annotate 'line', 1875
    find_lex $P6226, "$past"
    unless_null $P6226, vivify_2545
    new $P6226, "Undef"
  vivify_2545:
    $P6226."pirop"("get_how PP")
  if_6221_end:
.annotate 'line', 1874
    goto if_6213_end
  if_6213:
.annotate 'line', 1871
    find_lex $P6216, "$past"
    unless_null $P6216, vivify_2546
    new $P6216, "Undef"
  vivify_2546:
    find_lex $P6217, "$/"
    unless_null $P6217, vivify_2547
    $P6217 = root_new ['parrot';'Hash']
  vivify_2547:
    set $P6218, $P6217["quote"]
    unless_null $P6218, vivify_2548
    new $P6218, "Undef"
  vivify_2548:
    $P6219 = $P6218."ast"()
    $P6216."name"($P6219)
.annotate 'line', 1872
    find_lex $P6220, "$past"
    unless_null $P6220, vivify_2549
    new $P6220, "Undef"
  vivify_2549:
    $P6220."pasttype"("callmethod")
  if_6213_end:
.annotate 'line', 1887
    find_lex $P6244, "$/"
    find_lex $P6245, "$past"
    unless_null $P6245, vivify_2550
    new $P6245, "Undef"
  vivify_2550:
    $P6246 = $P6244."!make"($P6245)
.annotate 'line', 1868
    .return ($P6246)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("528_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6248
    .param pmc param_6249
.annotate 'line', 1892
    .lex "self", param_6248
    .lex "$/", param_6249
.annotate 'line', 1893
    find_lex $P6250, "$/"
    get_hll_global $P6251, "GLOBAL"
    nqp_get_package_through_who $P6252, $P6251, "PAST"
    get_who $P6253, $P6252
    set $P6254, $P6253["Var"]
    $P6255 = $P6254."new"("self" :named("name"))
    $P6256 = $P6250."!make"($P6255)
.annotate 'line', 1892
    .return ($P6256)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("529_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6258
    .param pmc param_6259
.annotate 'line', 1896
    .lex "self", param_6258
    .lex "$/", param_6259
.annotate 'line', 1897
    new $P6260, "Undef"
    .lex "$past", $P6260
    find_lex $P6261, "$/"
    unless_null $P6261, vivify_2551
    $P6261 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P6262, $P6261["args"]
    unless_null $P6262, vivify_2552
    new $P6262, "Undef"
  vivify_2552:
    $P6263 = $P6262."ast"()
    store_lex "$past", $P6263
.annotate 'line', 1898
    find_lex $P6264, "$past"
    unless_null $P6264, vivify_2553
    new $P6264, "Undef"
  vivify_2553:
    find_lex $P6265, "$/"
    unless_null $P6265, vivify_2554
    $P6265 = root_new ['parrot';'Hash']
  vivify_2554:
    set $P6266, $P6265["deflongname"]
    unless_null $P6266, vivify_2555
    new $P6266, "Undef"
  vivify_2555:
    set $S6267, $P6266
    $P6264."name"($S6267)
.annotate 'line', 1899
    find_lex $P6268, "$/"
    find_lex $P6269, "$past"
    unless_null $P6269, vivify_2556
    new $P6269, "Undef"
  vivify_2556:
    $P6270 = $P6268."!make"($P6269)
.annotate 'line', 1896
    .return ($P6270)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("530_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6272
    .param pmc param_6273
.annotate 'line', 1902
    .const 'Sub' $P6291 = "531_1303748459.273" 
    capture_lex $P6291
    .lex "self", param_6272
    .lex "$/", param_6273
.annotate 'line', 1904
    new $P6274, "Undef"
    .lex "$var", $P6274
.annotate 'line', 1914
    new $P6275, "Undef"
    .lex "$past", $P6275
.annotate 'line', 1902
    find_lex $P6276, "$var"
    unless_null $P6276, vivify_2557
    new $P6276, "Undef"
  vivify_2557:
.annotate 'line', 1905
    find_lex $P6278, "$/"
    unless_null $P6278, vivify_2558
    $P6278 = root_new ['parrot';'Hash']
  vivify_2558:
    set $P6279, $P6278["name"]
    unless_null $P6279, vivify_2559
    new $P6279, "Undef"
  vivify_2559:
    set $S6280, $P6279
    $P6281 = "is_lexical"($S6280)
    if $P6281, if_6277
.annotate 'line', 1908
    .const 'Sub' $P6291 = "531_1303748459.273" 
    capture_lex $P6291
    $P6291()
    goto if_6277_end
  if_6277:
.annotate 'line', 1906
    get_hll_global $P6282, "GLOBAL"
    nqp_get_package_through_who $P6283, $P6282, "PAST"
    get_who $P6284, $P6283
    set $P6285, $P6284["Var"]
    find_lex $P6286, "$/"
    unless_null $P6286, vivify_2565
    $P6286 = root_new ['parrot';'Hash']
  vivify_2565:
    set $P6287, $P6286["name"]
    unless_null $P6287, vivify_2566
    new $P6287, "Undef"
  vivify_2566:
    set $S6288, $P6287
    $P6289 = $P6285."new"($S6288 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P6289
  if_6277_end:
.annotate 'line', 1914
    find_lex $P6300, "$var"
    unless_null $P6300, vivify_2567
    new $P6300, "Undef"
  vivify_2567:
    store_lex "$past", $P6300
.annotate 'line', 1915
    find_lex $P6302, "$/"
    unless_null $P6302, vivify_2568
    $P6302 = root_new ['parrot';'Hash']
  vivify_2568:
    set $P6303, $P6302["args"]
    unless_null $P6303, vivify_2569
    new $P6303, "Undef"
  vivify_2569:
    unless $P6303, if_6301_end
.annotate 'line', 1916
    find_lex $P6304, "$/"
    unless_null $P6304, vivify_2570
    $P6304 = root_new ['parrot';'Hash']
  vivify_2570:
    set $P6305, $P6304["args"]
    unless_null $P6305, vivify_2571
    $P6305 = root_new ['parrot';'ResizablePMCArray']
  vivify_2571:
    set $P6306, $P6305[0]
    unless_null $P6306, vivify_2572
    new $P6306, "Undef"
  vivify_2572:
    $P6307 = $P6306."ast"()
    store_lex "$past", $P6307
.annotate 'line', 1917
    find_lex $P6308, "$past"
    unless_null $P6308, vivify_2573
    new $P6308, "Undef"
  vivify_2573:
    find_lex $P6309, "$var"
    unless_null $P6309, vivify_2574
    new $P6309, "Undef"
  vivify_2574:
    $P6308."unshift"($P6309)
  if_6301_end:
.annotate 'line', 1919
    find_lex $P6310, "$/"
    find_lex $P6311, "$past"
    unless_null $P6311, vivify_2575
    new $P6311, "Undef"
  vivify_2575:
    $P6312 = $P6310."!make"($P6311)
.annotate 'line', 1902
    .return ($P6312)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6290"  :anon :subid("531_1303748459.273") :outer("530_1303748459.273")
.annotate 'line', 1909
    $P6292 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P6292
    find_lex $P6293, "$/"
    unless_null $P6293, vivify_2560
    $P6293 = root_new ['parrot';'Hash']
  vivify_2560:
    set $P6294, $P6293["name"]
    unless_null $P6294, vivify_2561
    $P6294 = root_new ['parrot';'Hash']
  vivify_2561:
    set $P6295, $P6294["identifier"]
    unless_null $P6295, vivify_2562
    new $P6295, "Undef"
  vivify_2562:
    clone $P6296, $P6295
    store_lex "@ns", $P6296
.annotate 'line', 1910
    find_lex $P6297, "@ns"
    unless_null $P6297, vivify_2563
    $P6297 = root_new ['parrot';'ResizablePMCArray']
  vivify_2563:
    find_lex $P6298, "$/"
    unless_null $P6298, vivify_2564
    new $P6298, "Undef"
  vivify_2564:
    $P6299 = "lexical_package_lookup"($P6297, $P6298)
    store_lex "$var", $P6299
.annotate 'line', 1908
    .return ($P6299)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("532_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6314
    .param pmc param_6315
.annotate 'line', 1922
    .lex "self", param_6314
    .lex "$/", param_6315
.annotate 'line', 1923
    new $P6316, "Undef"
    .lex "$past", $P6316
.annotate 'line', 1924
    new $P6317, "Undef"
    .lex "$pirop", $P6317
.annotate 'line', 1923
    find_lex $P6320, "$/"
    unless_null $P6320, vivify_2576
    $P6320 = root_new ['parrot';'Hash']
  vivify_2576:
    set $P6321, $P6320["args"]
    unless_null $P6321, vivify_2577
    new $P6321, "Undef"
  vivify_2577:
    if $P6321, if_6319
    get_hll_global $P6326, "GLOBAL"
    nqp_get_package_through_who $P6327, $P6326, "PAST"
    get_who $P6328, $P6327
    set $P6329, $P6328["Op"]
    find_lex $P6330, "$/"
    unless_null $P6330, vivify_2578
    new $P6330, "Undef"
  vivify_2578:
    $P6331 = $P6329."new"($P6330 :named("node"))
    set $P6318, $P6331
    goto if_6319_end
  if_6319:
    find_lex $P6322, "$/"
    unless_null $P6322, vivify_2579
    $P6322 = root_new ['parrot';'Hash']
  vivify_2579:
    set $P6323, $P6322["args"]
    unless_null $P6323, vivify_2580
    $P6323 = root_new ['parrot';'ResizablePMCArray']
  vivify_2580:
    set $P6324, $P6323[0]
    unless_null $P6324, vivify_2581
    new $P6324, "Undef"
  vivify_2581:
    $P6325 = $P6324."ast"()
    set $P6318, $P6325
  if_6319_end:
    store_lex "$past", $P6318
.annotate 'line', 1924
    find_lex $P6332, "$/"
    unless_null $P6332, vivify_2582
    $P6332 = root_new ['parrot';'Hash']
  vivify_2582:
    set $P6333, $P6332["op"]
    unless_null $P6333, vivify_2583
    new $P6333, "Undef"
  vivify_2583:
    set $S6334, $P6333
    new $P6335, 'String'
    set $P6335, $S6334
    store_lex "$pirop", $P6335
.annotate 'line', 1925
    find_lex $P6336, "$pirop"
    unless_null $P6336, vivify_2584
    new $P6336, "Undef"
  vivify_2584:
    set $S6337, $P6336
    split $P6338, "__", $S6337
    join $S6339, " ", $P6338
    new $P6340, 'String'
    set $P6340, $S6339
    store_lex "$pirop", $P6340
.annotate 'line', 1926
    find_lex $P6341, "$past"
    unless_null $P6341, vivify_2585
    new $P6341, "Undef"
  vivify_2585:
    find_lex $P6342, "$pirop"
    unless_null $P6342, vivify_2586
    new $P6342, "Undef"
  vivify_2586:
    $P6341."pirop"($P6342)
.annotate 'line', 1927
    find_lex $P6343, "$past"
    unless_null $P6343, vivify_2587
    new $P6343, "Undef"
  vivify_2587:
    $P6343."pasttype"("pirop")
.annotate 'line', 1928
    find_lex $P6344, "$/"
    find_lex $P6345, "$past"
    unless_null $P6345, vivify_2588
    new $P6345, "Undef"
  vivify_2588:
    $P6346 = $P6344."!make"($P6345)
.annotate 'line', 1922
    .return ($P6346)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("533_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6348
    .param pmc param_6349
.annotate 'line', 1931
    .lex "self", param_6348
    .lex "$/", param_6349
.annotate 'line', 1932
    find_lex $P6350, "$/"
    get_hll_global $P6351, "GLOBAL"
    nqp_get_package_through_who $P6352, $P6351, "PAST"
    get_who $P6353, $P6352
    set $P6354, $P6353["Op"]
    $P6355 = $P6354."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P6356 = $P6350."!make"($P6355)
.annotate 'line', 1931
    .return ($P6356)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("534_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6358
    .param pmc param_6359
.annotate 'line', 1937
    .lex "self", param_6358
    .lex "$/", param_6359
    find_lex $P6360, "$/"
    find_lex $P6361, "$/"
    unless_null $P6361, vivify_2589
    $P6361 = root_new ['parrot';'Hash']
  vivify_2589:
    set $P6362, $P6361["arglist"]
    unless_null $P6362, vivify_2590
    new $P6362, "Undef"
  vivify_2590:
    $P6363 = $P6362."ast"()
    $P6364 = $P6360."!make"($P6363)
    .return ($P6364)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("535_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6366
    .param pmc param_6367
.annotate 'line', 1939
    .const 'Sub' $P6381 = "536_1303748459.273" 
    capture_lex $P6381
    .lex "self", param_6366
    .lex "$/", param_6367
.annotate 'line', 1940
    new $P6368, "Undef"
    .lex "$past", $P6368
.annotate 'line', 1948
    new $P6369, "Undef"
    .lex "$i", $P6369
.annotate 'line', 1949
    new $P6370, "Undef"
    .lex "$n", $P6370
.annotate 'line', 1940
    get_hll_global $P6371, "GLOBAL"
    nqp_get_package_through_who $P6372, $P6371, "PAST"
    get_who $P6373, $P6372
    set $P6374, $P6373["Op"]
    find_lex $P6375, "$/"
    unless_null $P6375, vivify_2591
    new $P6375, "Undef"
  vivify_2591:
    $P6376 = $P6374."new"("call" :named("pasttype"), $P6375 :named("node"))
    store_lex "$past", $P6376
.annotate 'line', 1941
    find_lex $P6378, "$/"
    unless_null $P6378, vivify_2592
    $P6378 = root_new ['parrot';'Hash']
  vivify_2592:
    set $P6379, $P6378["EXPR"]
    unless_null $P6379, vivify_2593
    new $P6379, "Undef"
  vivify_2593:
    unless $P6379, if_6377_end
    .const 'Sub' $P6381 = "536_1303748459.273" 
    capture_lex $P6381
    $P6381()
  if_6377_end:
.annotate 'line', 1948
    new $P6413, "Integer"
    assign $P6413, 0
    store_lex "$i", $P6413
.annotate 'line', 1949
    find_lex $P6414, "$past"
    unless_null $P6414, vivify_2604
    new $P6414, "Undef"
  vivify_2604:
    $P6415 = $P6414."list"()
    set $N6416, $P6415
    new $P6417, 'Float'
    set $P6417, $N6416
    store_lex "$n", $P6417
.annotate 'line', 1950
    new $P6468, 'ExceptionHandler'
    set_label $P6468, loop6467_handler
    $P6468."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6468
  loop6467_test:
    find_lex $P6418, "$i"
    unless_null $P6418, vivify_2605
    new $P6418, "Undef"
  vivify_2605:
    set $N6419, $P6418
    find_lex $P6420, "$n"
    unless_null $P6420, vivify_2606
    new $P6420, "Undef"
  vivify_2606:
    set $N6421, $P6420
    islt $I6422, $N6419, $N6421
    unless $I6422, loop6467_done
  loop6467_redo:
.annotate 'line', 1951
    find_lex $P6424, "$i"
    unless_null $P6424, vivify_2607
    new $P6424, "Undef"
  vivify_2607:
    set $I6425, $P6424
    find_lex $P6426, "$past"
    unless_null $P6426, vivify_2608
    $P6426 = root_new ['parrot';'ResizablePMCArray']
  vivify_2608:
    set $P6427, $P6426[$I6425]
    unless_null $P6427, vivify_2609
    new $P6427, "Undef"
  vivify_2609:
    $S6428 = $P6427."name"()
    iseq $I6429, $S6428, "&prefix:<|>"
    unless $I6429, if_6423_end
.annotate 'line', 1952
    find_lex $P6430, "$i"
    unless_null $P6430, vivify_2610
    new $P6430, "Undef"
  vivify_2610:
    set $I6431, $P6430
    find_lex $P6432, "$past"
    unless_null $P6432, vivify_2611
    $P6432 = root_new ['parrot';'ResizablePMCArray']
  vivify_2611:
    set $P6433, $P6432[$I6431]
    unless_null $P6433, vivify_2612
    $P6433 = root_new ['parrot';'ResizablePMCArray']
  vivify_2612:
    set $P6434, $P6433[0]
    unless_null $P6434, vivify_2613
    new $P6434, "Undef"
  vivify_2613:
    find_lex $P6435, "$i"
    unless_null $P6435, vivify_2614
    new $P6435, "Undef"
  vivify_2614:
    set $I6436, $P6435
    find_lex $P6437, "$past"
    unless_null $P6437, vivify_2615
    $P6437 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P6437
  vivify_2615:
    set $P6437[$I6436], $P6434
.annotate 'line', 1953
    find_lex $P6438, "$i"
    unless_null $P6438, vivify_2616
    new $P6438, "Undef"
  vivify_2616:
    set $I6439, $P6438
    find_lex $P6440, "$past"
    unless_null $P6440, vivify_2617
    $P6440 = root_new ['parrot';'ResizablePMCArray']
  vivify_2617:
    set $P6441, $P6440[$I6439]
    unless_null $P6441, vivify_2618
    new $P6441, "Undef"
  vivify_2618:
    $P6441."flat"(1)
.annotate 'line', 1954
    find_lex $P6445, "$i"
    unless_null $P6445, vivify_2619
    new $P6445, "Undef"
  vivify_2619:
    set $I6446, $P6445
    find_lex $P6447, "$past"
    unless_null $P6447, vivify_2620
    $P6447 = root_new ['parrot';'ResizablePMCArray']
  vivify_2620:
    set $P6448, $P6447[$I6446]
    unless_null $P6448, vivify_2621
    new $P6448, "Undef"
  vivify_2621:
    get_hll_global $P6449, "GLOBAL"
    nqp_get_package_through_who $P6450, $P6449, "PAST"
    get_who $P6451, $P6450
    set $P6452, $P6451["Val"]
    $P6453 = $P6448."isa"($P6452)
    if $P6453, if_6444
    set $P6443, $P6453
    goto if_6444_end
  if_6444:
.annotate 'line', 1955
    find_lex $P6454, "$i"
    unless_null $P6454, vivify_2622
    new $P6454, "Undef"
  vivify_2622:
    set $I6455, $P6454
    find_lex $P6456, "$past"
    unless_null $P6456, vivify_2623
    $P6456 = root_new ['parrot';'ResizablePMCArray']
  vivify_2623:
    set $P6457, $P6456[$I6455]
    unless_null $P6457, vivify_2624
    new $P6457, "Undef"
  vivify_2624:
    $S6458 = $P6457."name"()
    substr $S6459, $S6458, 0, 1
    iseq $I6460, $S6459, "%"
    new $P6443, 'Integer'
    set $P6443, $I6460
  if_6444_end:
    unless $P6443, if_6442_end
.annotate 'line', 1956
    find_lex $P6461, "$i"
    unless_null $P6461, vivify_2625
    new $P6461, "Undef"
  vivify_2625:
    set $I6462, $P6461
    find_lex $P6463, "$past"
    unless_null $P6463, vivify_2626
    $P6463 = root_new ['parrot';'ResizablePMCArray']
  vivify_2626:
    set $P6464, $P6463[$I6462]
    unless_null $P6464, vivify_2627
    new $P6464, "Undef"
  vivify_2627:
    $P6464."named"(1)
  if_6442_end:
  if_6423_end:
.annotate 'line', 1951
    find_lex $P6465, "$i"
    unless_null $P6465, vivify_2628
    new $P6465, "Undef"
  vivify_2628:
    clone $P6466, $P6465
    inc $P6465
  loop6467_next:
.annotate 'line', 1950
    goto loop6467_test
  loop6467_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6469, exception, 'type'
    eq $P6469, .CONTROL_LOOP_NEXT, loop6467_next
    eq $P6469, .CONTROL_LOOP_REDO, loop6467_redo
  loop6467_done:
    pop_eh 
.annotate 'line', 1961
    find_lex $P6470, "$/"
    find_lex $P6471, "$past"
    unless_null $P6471, vivify_2629
    new $P6471, "Undef"
  vivify_2629:
    $P6472 = $P6470."!make"($P6471)
.annotate 'line', 1939
    .return ($P6472)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6380"  :anon :subid("536_1303748459.273") :outer("535_1303748459.273")
.annotate 'line', 1941
    .const 'Sub' $P6402 = "537_1303748459.273" 
    capture_lex $P6402
.annotate 'line', 1942
    new $P6382, "Undef"
    .lex "$expr", $P6382
    find_lex $P6383, "$/"
    unless_null $P6383, vivify_2594
    $P6383 = root_new ['parrot';'Hash']
  vivify_2594:
    set $P6384, $P6383["EXPR"]
    unless_null $P6384, vivify_2595
    new $P6384, "Undef"
  vivify_2595:
    $P6385 = $P6384."ast"()
    store_lex "$expr", $P6385
.annotate 'line', 1943
    find_lex $P6390, "$expr"
    unless_null $P6390, vivify_2596
    new $P6390, "Undef"
  vivify_2596:
    $S6391 = $P6390."name"()
    iseq $I6392, $S6391, "&infix:<,>"
    if $I6392, if_6389
    new $P6388, 'Integer'
    set $P6388, $I6392
    goto if_6389_end
  if_6389:
    find_lex $P6393, "$expr"
    unless_null $P6393, vivify_2597
    new $P6393, "Undef"
  vivify_2597:
    $P6394 = $P6393."named"()
    isfalse $I6395, $P6394
    new $P6388, 'Integer'
    set $P6388, $I6395
  if_6389_end:
    if $P6388, if_6387
.annotate 'line', 1946
    find_lex $P6410, "$past"
    unless_null $P6410, vivify_2598
    new $P6410, "Undef"
  vivify_2598:
    find_lex $P6411, "$expr"
    unless_null $P6411, vivify_2599
    new $P6411, "Undef"
  vivify_2599:
    $P6412 = $P6410."push"($P6411)
    set $P6386, $P6412
.annotate 'line', 1943
    goto if_6387_end
  if_6387:
.annotate 'line', 1944
    find_lex $P6397, "$expr"
    unless_null $P6397, vivify_2600
    new $P6397, "Undef"
  vivify_2600:
    $P6398 = $P6397."list"()
    defined $I6399, $P6398
    unless $I6399, for_undef_2601
    iter $P6396, $P6398
    new $P6408, 'ExceptionHandler'
    set_label $P6408, loop6407_handler
    $P6408."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6408
  loop6407_test:
    unless $P6396, loop6407_done
    shift $P6400, $P6396
  loop6407_redo:
    .const 'Sub' $P6402 = "537_1303748459.273" 
    capture_lex $P6402
    $P6402($P6400)
  loop6407_next:
    goto loop6407_test
  loop6407_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6409, exception, 'type'
    eq $P6409, .CONTROL_LOOP_NEXT, loop6407_next
    eq $P6409, .CONTROL_LOOP_REDO, loop6407_redo
  loop6407_done:
    pop_eh 
  for_undef_2601:
.annotate 'line', 1943
    set $P6386, $P6396
  if_6387_end:
.annotate 'line', 1941
    .return ($P6386)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6401"  :anon :subid("537_1303748459.273") :outer("536_1303748459.273")
    .param pmc param_6403
.annotate 'line', 1944
    .lex "$_", param_6403
    find_lex $P6404, "$past"
    unless_null $P6404, vivify_2602
    new $P6404, "Undef"
  vivify_2602:
    find_lex $P6405, "$_"
    unless_null $P6405, vivify_2603
    new $P6405, "Undef"
  vivify_2603:
    $P6406 = $P6404."push"($P6405)
    .return ($P6406)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("538_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6474
    .param pmc param_6475
.annotate 'line', 1964
    .lex "self", param_6474
    .lex "$/", param_6475
    find_lex $P6476, "$/"
    find_lex $P6477, "$/"
    unless_null $P6477, vivify_2630
    $P6477 = root_new ['parrot';'Hash']
  vivify_2630:
    set $P6478, $P6477["multi_declarator"]
    unless_null $P6478, vivify_2631
    new $P6478, "Undef"
  vivify_2631:
    $P6479 = $P6478."ast"()
    $P6480 = $P6476."!make"($P6479)
    .return ($P6480)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("539_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6482
    .param pmc param_6483
.annotate 'line', 1966
    .lex "self", param_6482
    .lex "$/", param_6483
    find_lex $P6484, "$/"
    find_lex $P6485, "$/"
    unless_null $P6485, vivify_2632
    $P6485 = root_new ['parrot';'Hash']
  vivify_2632:
    set $P6486, $P6485["value"]
    unless_null $P6486, vivify_2633
    new $P6486, "Undef"
  vivify_2633:
    $P6487 = $P6486."ast"()
    $P6488 = $P6484."!make"($P6487)
    .return ($P6488)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("540_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6490
    .param pmc param_6491
.annotate 'line', 1968
    .lex "self", param_6490
    .lex "$/", param_6491
.annotate 'line', 1969
    find_lex $P6492, "$/"
.annotate 'line', 1970
    find_lex $P6495, "$/"
    unless_null $P6495, vivify_2634
    $P6495 = root_new ['parrot';'Hash']
  vivify_2634:
    set $P6496, $P6495["EXPR"]
    unless_null $P6496, vivify_2635
    new $P6496, "Undef"
  vivify_2635:
    if $P6496, if_6494
.annotate 'line', 1971
    get_hll_global $P6501, "GLOBAL"
    nqp_get_package_through_who $P6502, $P6501, "PAST"
    get_who $P6503, $P6502
    set $P6504, $P6503["Op"]
    find_lex $P6505, "$/"
    unless_null $P6505, vivify_2636
    new $P6505, "Undef"
  vivify_2636:
    $P6506 = $P6504."new"("list" :named("pasttype"), $P6505 :named("node"))
    set $P6493, $P6506
.annotate 'line', 1970
    goto if_6494_end
  if_6494:
    find_lex $P6497, "$/"
    unless_null $P6497, vivify_2637
    $P6497 = root_new ['parrot';'Hash']
  vivify_2637:
    set $P6498, $P6497["EXPR"]
    unless_null $P6498, vivify_2638
    $P6498 = root_new ['parrot';'ResizablePMCArray']
  vivify_2638:
    set $P6499, $P6498[0]
    unless_null $P6499, vivify_2639
    new $P6499, "Undef"
  vivify_2639:
    $P6500 = $P6499."ast"()
    set $P6493, $P6500
  if_6494_end:
    $P6507 = $P6492."!make"($P6493)
.annotate 'line', 1968
    .return ($P6507)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("541_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6509
    .param pmc param_6510
.annotate 'line', 1974
    .lex "self", param_6509
    .lex "$/", param_6510
.annotate 'line', 1975
    new $P6511, "Undef"
    .lex "$past", $P6511
.annotate 'line', 1974
    find_lex $P6512, "$past"
    unless_null $P6512, vivify_2640
    new $P6512, "Undef"
  vivify_2640:
.annotate 'line', 1976
    find_lex $P6514, "$/"
    unless_null $P6514, vivify_2641
    $P6514 = root_new ['parrot';'Hash']
  vivify_2641:
    set $P6515, $P6514["EXPR"]
    unless_null $P6515, vivify_2642
    new $P6515, "Undef"
  vivify_2642:
    if $P6515, if_6513
.annotate 'line', 1983
    get_hll_global $P6530, "GLOBAL"
    nqp_get_package_through_who $P6531, $P6530, "PAST"
    get_who $P6532, $P6531
    set $P6533, $P6532["Op"]
    $P6534 = $P6533."new"("list" :named("pasttype"))
    store_lex "$past", $P6534
.annotate 'line', 1982
    goto if_6513_end
  if_6513:
.annotate 'line', 1977
    find_lex $P6516, "$/"
    unless_null $P6516, vivify_2643
    $P6516 = root_new ['parrot';'Hash']
  vivify_2643:
    set $P6517, $P6516["EXPR"]
    unless_null $P6517, vivify_2644
    $P6517 = root_new ['parrot';'ResizablePMCArray']
  vivify_2644:
    set $P6518, $P6517[0]
    unless_null $P6518, vivify_2645
    new $P6518, "Undef"
  vivify_2645:
    $P6519 = $P6518."ast"()
    store_lex "$past", $P6519
.annotate 'line', 1978
    find_lex $P6521, "$past"
    unless_null $P6521, vivify_2646
    new $P6521, "Undef"
  vivify_2646:
    $S6522 = $P6521."name"()
    isne $I6523, $S6522, "&infix:<,>"
    unless $I6523, if_6520_end
.annotate 'line', 1979
    get_hll_global $P6524, "GLOBAL"
    nqp_get_package_through_who $P6525, $P6524, "PAST"
    get_who $P6526, $P6525
    set $P6527, $P6526["Op"]
    find_lex $P6528, "$past"
    unless_null $P6528, vivify_2647
    new $P6528, "Undef"
  vivify_2647:
    $P6529 = $P6527."new"($P6528, "list" :named("pasttype"))
    store_lex "$past", $P6529
  if_6520_end:
  if_6513_end:
.annotate 'line', 1985
    find_lex $P6535, "$past"
    unless_null $P6535, vivify_2648
    new $P6535, "Undef"
  vivify_2648:
    $P6535."name"("&circumfix:<[ ]>")
.annotate 'line', 1986
    find_lex $P6536, "$/"
    find_lex $P6537, "$past"
    unless_null $P6537, vivify_2649
    new $P6537, "Undef"
  vivify_2649:
    $P6538 = $P6536."!make"($P6537)
.annotate 'line', 1974
    .return ($P6538)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("542_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6540
    .param pmc param_6541
.annotate 'line', 1989
    .lex "self", param_6540
    .lex "$/", param_6541
    find_lex $P6542, "$/"
    find_lex $P6543, "$/"
    unless_null $P6543, vivify_2650
    $P6543 = root_new ['parrot';'Hash']
  vivify_2650:
    set $P6544, $P6543["quote_EXPR"]
    unless_null $P6544, vivify_2651
    new $P6544, "Undef"
  vivify_2651:
    $P6545 = $P6544."ast"()
    $P6546 = $P6542."!make"($P6545)
    .return ($P6546)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("543_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6548
    .param pmc param_6549
.annotate 'line', 1990
    .lex "self", param_6548
    .lex "$/", param_6549
    find_lex $P6550, "$/"
    find_lex $P6551, "$/"
    unless_null $P6551, vivify_2652
    $P6551 = root_new ['parrot';'Hash']
  vivify_2652:
    set $P6552, $P6551["quote_EXPR"]
    unless_null $P6552, vivify_2653
    new $P6552, "Undef"
  vivify_2653:
    $P6553 = $P6552."ast"()
    $P6554 = $P6550."!make"($P6553)
    .return ($P6554)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("544_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6556
    .param pmc param_6557
.annotate 'line', 1992
    .const 'Sub' $P6568 = "545_1303748459.273" 
    capture_lex $P6568
    .lex "self", param_6556
    .lex "$/", param_6557
.annotate 'line', 1993
    find_lex $P6560, "$/"
    unless_null $P6560, vivify_2654
    $P6560 = root_new ['parrot';'Hash']
  vivify_2654:
    set $P6561, $P6560["pblock"]
    unless_null $P6561, vivify_2655
    $P6561 = root_new ['parrot';'Hash']
  vivify_2655:
    set $P6562, $P6561["blockoid"]
    unless_null $P6562, vivify_2656
    $P6562 = root_new ['parrot';'Hash']
  vivify_2656:
    set $P6563, $P6562["statementlist"]
    unless_null $P6563, vivify_2657
    $P6563 = root_new ['parrot';'Hash']
  vivify_2657:
    set $P6564, $P6563["statement"]
    unless_null $P6564, vivify_2658
    new $P6564, "Undef"
  vivify_2658:
    set $N6565, $P6564
    isgt $I6566, $N6565, 0.0
    if $I6566, if_6559
.annotate 'line', 1998
    find_lex $P6581, "$/"
    unless_null $P6581, vivify_2659
    $P6581 = root_new ['parrot';'Hash']
  vivify_2659:
    set $P6582, $P6581["pblock"]
    unless_null $P6582, vivify_2660
    $P6582 = root_new ['parrot';'Hash']
  vivify_2660:
    set $P6583, $P6582["blockoid"]
    unless_null $P6583, vivify_2661
    $P6583 = root_new ['parrot';'Hash']
  vivify_2661:
    set $P6584, $P6583["you_are_here"]
    unless_null $P6584, vivify_2662
    new $P6584, "Undef"
  vivify_2662:
    if $P6584, if_6580
.annotate 'line', 2002
    find_lex $P6590, "$/"
    $P6591 = "vivitype"("%")
    $P6592 = $P6590."!make"($P6591)
.annotate 'line', 2001
    set $P6579, $P6592
.annotate 'line', 1998
    goto if_6580_end
  if_6580:
.annotate 'line', 1999
    find_lex $P6585, "$/"
    find_lex $P6586, "$/"
    unless_null $P6586, vivify_2663
    $P6586 = root_new ['parrot';'Hash']
  vivify_2663:
    set $P6587, $P6586["pblock"]
    unless_null $P6587, vivify_2664
    new $P6587, "Undef"
  vivify_2664:
    $P6588 = $P6587."ast"()
    $P6589 = $P6585."!make"($P6588)
.annotate 'line', 1998
    set $P6579, $P6589
  if_6580_end:
    set $P6558, $P6579
.annotate 'line', 1993
    goto if_6559_end
  if_6559:
    .const 'Sub' $P6568 = "545_1303748459.273" 
    capture_lex $P6568
    $P6578 = $P6568()
    set $P6558, $P6578
  if_6559_end:
.annotate 'line', 1992
    .return ($P6558)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6567"  :anon :subid("545_1303748459.273") :outer("544_1303748459.273")
.annotate 'line', 1994
    new $P6569, "Undef"
    .lex "$past", $P6569
    find_lex $P6570, "$/"
    unless_null $P6570, vivify_2665
    $P6570 = root_new ['parrot';'Hash']
  vivify_2665:
    set $P6571, $P6570["pblock"]
    unless_null $P6571, vivify_2666
    new $P6571, "Undef"
  vivify_2666:
    $P6572 = $P6571."ast"()
    store_lex "$past", $P6572
.annotate 'line', 1995
    new $P6573, "Integer"
    assign $P6573, 1
    find_lex $P6574, "$past"
    unless_null $P6574, vivify_2667
    $P6574 = root_new ['parrot';'Hash']
    store_lex "$past", $P6574
  vivify_2667:
    set $P6574["bareblock"], $P6573
.annotate 'line', 1996
    find_dynamic_lex $P6575, "$/"
    find_lex $P6576, "$past"
    unless_null $P6576, vivify_2668
    new $P6576, "Undef"
  vivify_2668:
    $P6577 = $P6575."!make"($P6576)
.annotate 'line', 1993
    .return ($P6577)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("546_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6594
    .param pmc param_6595
.annotate 'line', 2006
    .lex "self", param_6594
    .lex "$/", param_6595
.annotate 'line', 2007
    new $P6596, "Undef"
    .lex "$name", $P6596
    find_lex $P6599, "$/"
    unless_null $P6599, vivify_2669
    $P6599 = root_new ['parrot';'Hash']
  vivify_2669:
    set $P6600, $P6599["sigil"]
    unless_null $P6600, vivify_2670
    new $P6600, "Undef"
  vivify_2670:
    set $S6601, $P6600
    iseq $I6602, $S6601, "@"
    if $I6602, if_6598
.annotate 'line', 2008
    find_lex $P6606, "$/"
    unless_null $P6606, vivify_2671
    $P6606 = root_new ['parrot';'Hash']
  vivify_2671:
    set $P6607, $P6606["sigil"]
    unless_null $P6607, vivify_2672
    new $P6607, "Undef"
  vivify_2672:
    set $S6608, $P6607
    iseq $I6609, $S6608, "%"
    if $I6609, if_6605
    new $P6611, "String"
    assign $P6611, "item"
    set $P6604, $P6611
    goto if_6605_end
  if_6605:
    new $P6610, "String"
    assign $P6610, "hash"
    set $P6604, $P6610
  if_6605_end:
    set $P6597, $P6604
.annotate 'line', 2007
    goto if_6598_end
  if_6598:
    new $P6603, "String"
    assign $P6603, "list"
    set $P6597, $P6603
  if_6598_end:
    store_lex "$name", $P6597
.annotate 'line', 2010
    find_lex $P6612, "$/"
    get_hll_global $P6613, "GLOBAL"
    nqp_get_package_through_who $P6614, $P6613, "PAST"
    get_who $P6615, $P6614
    set $P6616, $P6615["Op"]
    find_lex $P6617, "$name"
    unless_null $P6617, vivify_2673
    new $P6617, "Undef"
  vivify_2673:
    find_lex $P6618, "$/"
    unless_null $P6618, vivify_2674
    $P6618 = root_new ['parrot';'Hash']
  vivify_2674:
    set $P6619, $P6618["semilist"]
    unless_null $P6619, vivify_2675
    new $P6619, "Undef"
  vivify_2675:
    $P6620 = $P6619."ast"()
    $P6621 = $P6616."new"($P6620, "callmethod" :named("pasttype"), $P6617 :named("name"))
    $P6622 = $P6612."!make"($P6621)
.annotate 'line', 2006
    .return ($P6622)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("547_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6624
    .param pmc param_6625
.annotate 'line', 2013
    .lex "self", param_6624
    .lex "$/", param_6625
    find_lex $P6626, "$/"
    find_lex $P6627, "$/"
    unless_null $P6627, vivify_2676
    $P6627 = root_new ['parrot';'Hash']
  vivify_2676:
    set $P6628, $P6627["statement"]
    unless_null $P6628, vivify_2677
    new $P6628, "Undef"
  vivify_2677:
    $P6629 = $P6628."ast"()
    $P6630 = $P6626."!make"($P6629)
    .return ($P6630)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("548_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6632
    .param pmc param_6633
.annotate 'line', 2015
    .lex "self", param_6632
    .lex "$/", param_6633
.annotate 'line', 2016
    find_lex $P6634, "$/"
    get_hll_global $P6635, "GLOBAL"
    nqp_get_package_through_who $P6636, $P6635, "PAST"
    get_who $P6637, $P6636
    set $P6638, $P6637["Var"]
    find_lex $P6639, "$/"
    unless_null $P6639, vivify_2678
    $P6639 = root_new ['parrot';'Hash']
  vivify_2678:
    set $P6640, $P6639["EXPR"]
    unless_null $P6640, vivify_2679
    new $P6640, "Undef"
  vivify_2679:
    $P6641 = $P6640."ast"()
.annotate 'line', 2018
    $P6642 = "vivitype"("@")
    $P6643 = $P6638."new"($P6641, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P6642 :named("vivibase"))
.annotate 'line', 2016
    $P6644 = $P6634."!make"($P6643)
.annotate 'line', 2015
    .return ($P6644)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("549_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6646
    .param pmc param_6647
.annotate 'line', 2021
    .lex "self", param_6646
    .lex "$/", param_6647
.annotate 'line', 2022
    find_lex $P6648, "$/"
    get_hll_global $P6649, "GLOBAL"
    nqp_get_package_through_who $P6650, $P6649, "PAST"
    get_who $P6651, $P6650
    set $P6652, $P6651["Var"]
    find_lex $P6653, "$/"
    unless_null $P6653, vivify_2680
    $P6653 = root_new ['parrot';'Hash']
  vivify_2680:
    set $P6654, $P6653["EXPR"]
    unless_null $P6654, vivify_2681
    new $P6654, "Undef"
  vivify_2681:
    $P6655 = $P6654."ast"()
.annotate 'line', 2024
    $P6656 = "vivitype"("%")
    $P6657 = $P6652."new"($P6655, "keyed" :named("scope"), "Undef" :named("viviself"), $P6656 :named("vivibase"))
.annotate 'line', 2022
    $P6658 = $P6648."!make"($P6657)
.annotate 'line', 2021
    .return ($P6658)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("550_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6660
    .param pmc param_6661
.annotate 'line', 2027
    .lex "self", param_6660
    .lex "$/", param_6661
.annotate 'line', 2028
    find_lex $P6662, "$/"
    get_hll_global $P6663, "GLOBAL"
    nqp_get_package_through_who $P6664, $P6663, "PAST"
    get_who $P6665, $P6664
    set $P6666, $P6665["Var"]
    find_lex $P6667, "$/"
    unless_null $P6667, vivify_2682
    $P6667 = root_new ['parrot';'Hash']
  vivify_2682:
    set $P6668, $P6667["quote_EXPR"]
    unless_null $P6668, vivify_2683
    new $P6668, "Undef"
  vivify_2683:
    $P6669 = $P6668."ast"()
.annotate 'line', 2030
    $P6670 = "vivitype"("%")
    $P6671 = $P6666."new"($P6669, "keyed" :named("scope"), "Undef" :named("viviself"), $P6670 :named("vivibase"))
.annotate 'line', 2028
    $P6672 = $P6662."!make"($P6671)
.annotate 'line', 2027
    .return ($P6672)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("551_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6674
    .param pmc param_6675
.annotate 'line', 2033
    .lex "self", param_6674
    .lex "$/", param_6675
.annotate 'line', 2034
    find_lex $P6676, "$/"
    find_lex $P6677, "$/"
    unless_null $P6677, vivify_2684
    $P6677 = root_new ['parrot';'Hash']
  vivify_2684:
    set $P6678, $P6677["arglist"]
    unless_null $P6678, vivify_2685
    new $P6678, "Undef"
  vivify_2685:
    $P6679 = $P6678."ast"()
    $P6680 = $P6676."!make"($P6679)
.annotate 'line', 2033
    .return ($P6680)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("552_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6682
    .param pmc param_6683
.annotate 'line', 2037
    .lex "self", param_6682
    .lex "$/", param_6683
.annotate 'line', 2038
    find_lex $P6684, "$/"
    find_lex $P6687, "$/"
    unless_null $P6687, vivify_2686
    $P6687 = root_new ['parrot';'Hash']
  vivify_2686:
    set $P6688, $P6687["quote"]
    unless_null $P6688, vivify_2687
    new $P6688, "Undef"
  vivify_2687:
    if $P6688, if_6686
    find_lex $P6692, "$/"
    unless_null $P6692, vivify_2688
    $P6692 = root_new ['parrot';'Hash']
  vivify_2688:
    set $P6693, $P6692["number"]
    unless_null $P6693, vivify_2689
    new $P6693, "Undef"
  vivify_2689:
    $P6694 = $P6693."ast"()
    set $P6685, $P6694
    goto if_6686_end
  if_6686:
    find_lex $P6689, "$/"
    unless_null $P6689, vivify_2690
    $P6689 = root_new ['parrot';'Hash']
  vivify_2690:
    set $P6690, $P6689["quote"]
    unless_null $P6690, vivify_2691
    new $P6690, "Undef"
  vivify_2691:
    $P6691 = $P6690."ast"()
    set $P6685, $P6691
  if_6686_end:
    $P6695 = $P6684."!make"($P6685)
.annotate 'line', 2037
    .return ($P6695)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("553_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6697
    .param pmc param_6698
.annotate 'line', 2041
    .lex "self", param_6697
    .lex "$/", param_6698
.annotate 'line', 2042
    new $P6699, "Undef"
    .lex "$value", $P6699
    find_lex $P6702, "$/"
    unless_null $P6702, vivify_2692
    $P6702 = root_new ['parrot';'Hash']
  vivify_2692:
    set $P6703, $P6702["dec_number"]
    unless_null $P6703, vivify_2693
    new $P6703, "Undef"
  vivify_2693:
    if $P6703, if_6701
    find_lex $P6707, "$/"
    unless_null $P6707, vivify_2694
    $P6707 = root_new ['parrot';'Hash']
  vivify_2694:
    set $P6708, $P6707["integer"]
    unless_null $P6708, vivify_2695
    new $P6708, "Undef"
  vivify_2695:
    $P6709 = $P6708."ast"()
    set $P6700, $P6709
    goto if_6701_end
  if_6701:
    find_lex $P6704, "$/"
    unless_null $P6704, vivify_2696
    $P6704 = root_new ['parrot';'Hash']
  vivify_2696:
    set $P6705, $P6704["dec_number"]
    unless_null $P6705, vivify_2697
    new $P6705, "Undef"
  vivify_2697:
    $P6706 = $P6705."ast"()
    set $P6700, $P6706
  if_6701_end:
    store_lex "$value", $P6700
.annotate 'line', 2043
    find_lex $P6711, "$/"
    unless_null $P6711, vivify_2698
    $P6711 = root_new ['parrot';'Hash']
  vivify_2698:
    set $P6712, $P6711["sign"]
    unless_null $P6712, vivify_2699
    new $P6712, "Undef"
  vivify_2699:
    set $S6713, $P6712
    iseq $I6714, $S6713, "-"
    unless $I6714, if_6710_end
    find_lex $P6715, "$value"
    unless_null $P6715, vivify_2700
    new $P6715, "Undef"
  vivify_2700:
    neg $P6716, $P6715
    store_lex "$value", $P6716
  if_6710_end:
.annotate 'line', 2044
    find_lex $P6717, "$/"
    get_hll_global $P6718, "GLOBAL"
    nqp_get_package_through_who $P6719, $P6718, "PAST"
    get_who $P6720, $P6719
    set $P6721, $P6720["Val"]
    find_lex $P6722, "$value"
    unless_null $P6722, vivify_2701
    new $P6722, "Undef"
  vivify_2701:
    $P6723 = $P6721."new"($P6722 :named("value"))
    $P6724 = $P6717."!make"($P6723)
.annotate 'line', 2041
    .return ($P6724)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("554_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6726
    .param pmc param_6727
.annotate 'line', 2047
    .lex "self", param_6726
    .lex "$/", param_6727
    find_lex $P6728, "$/"
    find_lex $P6729, "$/"
    unless_null $P6729, vivify_2702
    $P6729 = root_new ['parrot';'Hash']
  vivify_2702:
    set $P6730, $P6729["quote_EXPR"]
    unless_null $P6730, vivify_2703
    new $P6730, "Undef"
  vivify_2703:
    $P6731 = $P6730."ast"()
    $P6732 = $P6728."!make"($P6731)
    .return ($P6732)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("555_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6734
    .param pmc param_6735
.annotate 'line', 2048
    .lex "self", param_6734
    .lex "$/", param_6735
    find_lex $P6736, "$/"
    find_lex $P6737, "$/"
    unless_null $P6737, vivify_2704
    $P6737 = root_new ['parrot';'Hash']
  vivify_2704:
    set $P6738, $P6737["quote_EXPR"]
    unless_null $P6738, vivify_2705
    new $P6738, "Undef"
  vivify_2705:
    $P6739 = $P6738."ast"()
    $P6740 = $P6736."!make"($P6739)
    .return ($P6740)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("556_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6742
    .param pmc param_6743
.annotate 'line', 2049
    .lex "self", param_6742
    .lex "$/", param_6743
    find_lex $P6744, "$/"
    find_lex $P6745, "$/"
    unless_null $P6745, vivify_2706
    $P6745 = root_new ['parrot';'Hash']
  vivify_2706:
    set $P6746, $P6745["quote_EXPR"]
    unless_null $P6746, vivify_2707
    new $P6746, "Undef"
  vivify_2707:
    $P6747 = $P6746."ast"()
    $P6748 = $P6744."!make"($P6747)
    .return ($P6748)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("557_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6750
    .param pmc param_6751
.annotate 'line', 2050
    .lex "self", param_6750
    .lex "$/", param_6751
    find_lex $P6752, "$/"
    find_lex $P6753, "$/"
    unless_null $P6753, vivify_2708
    $P6753 = root_new ['parrot';'Hash']
  vivify_2708:
    set $P6754, $P6753["quote_EXPR"]
    unless_null $P6754, vivify_2709
    new $P6754, "Undef"
  vivify_2709:
    $P6755 = $P6754."ast"()
    $P6756 = $P6752."!make"($P6755)
    .return ($P6756)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("558_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6758
    .param pmc param_6759
.annotate 'line', 2051
    .lex "self", param_6758
    .lex "$/", param_6759
    find_lex $P6760, "$/"
    find_lex $P6761, "$/"
    unless_null $P6761, vivify_2710
    $P6761 = root_new ['parrot';'Hash']
  vivify_2710:
    set $P6762, $P6761["quote_EXPR"]
    unless_null $P6762, vivify_2711
    new $P6762, "Undef"
  vivify_2711:
    $P6763 = $P6762."ast"()
    $P6764 = $P6760."!make"($P6763)
    .return ($P6764)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("559_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6766
    .param pmc param_6767
.annotate 'line', 2052
    .lex "self", param_6766
    .lex "$/", param_6767
.annotate 'line', 2053
    find_lex $P6768, "$/"
    get_hll_global $P6769, "GLOBAL"
    nqp_get_package_through_who $P6770, $P6769, "PAST"
    get_who $P6771, $P6770
    set $P6772, $P6771["Op"]
    find_lex $P6773, "$/"
    unless_null $P6773, vivify_2712
    $P6773 = root_new ['parrot';'Hash']
  vivify_2712:
    set $P6774, $P6773["quote_EXPR"]
    unless_null $P6774, vivify_2713
    new $P6774, "Undef"
  vivify_2713:
    $P6775 = $P6774."ast"()
    $P6776 = $P6775."value"()
    find_lex $P6777, "$/"
    unless_null $P6777, vivify_2714
    new $P6777, "Undef"
  vivify_2714:
    $P6778 = $P6772."new"($P6776 :named("inline"), "inline" :named("pasttype"), $P6777 :named("node"))
    $P6779 = $P6768."!make"($P6778)
.annotate 'line', 2052
    .return ($P6779)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("560_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6783
    .param pmc param_6784
    .param pmc param_6785 :optional
    .param int has_param_6785 :opt_flag
.annotate 'line', 2058
    new $P6782, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6782, control_6781
    push_eh $P6782
    .lex "self", param_6783
    .lex "$/", param_6784
    if has_param_6785, optparam_2715
    new $P6786, "Undef"
    set param_6785, $P6786
  optparam_2715:
    .lex "$key", param_6785
.annotate 'line', 2065
    new $P6787, "Undef"
    .lex "$regex", $P6787
.annotate 'line', 2067
    new $P6788, "Undef"
    .lex "$past", $P6788
.annotate 'line', 2059
    find_lex $P6790, "$key"
    unless_null $P6790, vivify_2716
    new $P6790, "Undef"
  vivify_2716:
    set $S6791, $P6790
    iseq $I6792, $S6791, "open"
    unless $I6792, if_6789_end
.annotate 'line', 2060
    null $P6793
    get_hll_global $P6794, "GLOBAL"
    nqp_get_package_through_who $P6795, $P6794, "Regex"
    nqp_get_package_through_who $P6796, $P6795, "P6Regex"
    nqp_get_package_through_who $P6797, $P6796, "Actions"
    get_who $P6798, $P6797
    set $P6798["$REGEXNAME"], $P6793
.annotate 'line', 2061
    find_lex $P6799, "$?PACKAGE"
    get_who $P6800, $P6799
    set $P6801, $P6800["@BLOCK"]
    unless_null $P6801, vivify_2717
    $P6801 = root_new ['parrot';'ResizablePMCArray']
  vivify_2717:
    set $P6802, $P6801[0]
    unless_null $P6802, vivify_2718
    new $P6802, "Undef"
  vivify_2718:
    $P6802."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2062
    find_lex $P6803, "$?PACKAGE"
    get_who $P6804, $P6803
    set $P6805, $P6804["@BLOCK"]
    unless_null $P6805, vivify_2719
    $P6805 = root_new ['parrot';'ResizablePMCArray']
  vivify_2719:
    set $P6806, $P6805[0]
    unless_null $P6806, vivify_2720
    new $P6806, "Undef"
  vivify_2720:
    $P6806."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2063
    new $P6807, "Exception"
    set $P6807['type'], .CONTROL_RETURN
    new $P6808, "Integer"
    assign $P6808, 0
    setattribute $P6807, 'payload', $P6808
    throw $P6807
  if_6789_end:
.annotate 'line', 2066
    get_hll_global $P6809, "GLOBAL"
    nqp_get_package_through_who $P6810, $P6809, "Regex"
    nqp_get_package_through_who $P6811, $P6810, "P6Regex"
    nqp_get_package_through_who $P6812, $P6811, "Actions"
    get_who $P6813, $P6812
    set $P6814, $P6813["buildsub"]
    find_lex $P6815, "$/"
    unless_null $P6815, vivify_2721
    $P6815 = root_new ['parrot';'Hash']
  vivify_2721:
    set $P6816, $P6815["p6regex"]
    unless_null $P6816, vivify_2722
    new $P6816, "Undef"
  vivify_2722:
    $P6817 = $P6816."ast"()
    find_lex $P6818, "$?PACKAGE"
    get_who $P6819, $P6818
    set $P6820, $P6819["@BLOCK"]
    unless_null $P6820, vivify_2723
    $P6820 = root_new ['parrot';'ResizablePMCArray']
  vivify_2723:
    $P6821 = $P6820."shift"()
    $P6822 = $P6814($P6817, $P6821)
    store_lex "$regex", $P6822
.annotate 'line', 2068
    get_hll_global $P6823, "GLOBAL"
    nqp_get_package_through_who $P6824, $P6823, "PAST"
    get_who $P6825, $P6824
    set $P6826, $P6825["Op"]
.annotate 'line', 2070
    get_hll_global $P6827, "GLOBAL"
    nqp_get_package_through_who $P6828, $P6827, "PAST"
    get_who $P6829, $P6828
    set $P6830, $P6829["Var"]
    new $P6831, "ResizablePMCArray"
    push $P6831, "Regex"
    $P6832 = $P6830."new"("Regex" :named("name"), $P6831 :named("namespace"), "package" :named("scope"))
    find_lex $P6833, "$regex"
    unless_null $P6833, vivify_2724
    new $P6833, "Undef"
  vivify_2724:
    $P6834 = $P6826."new"($P6832, $P6833, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2068
    store_lex "$past", $P6834
.annotate 'line', 2074
    find_lex $P6835, "$regex"
    unless_null $P6835, vivify_2725
    new $P6835, "Undef"
  vivify_2725:
    find_lex $P6836, "$past"
    unless_null $P6836, vivify_2726
    $P6836 = root_new ['parrot';'Hash']
    store_lex "$past", $P6836
  vivify_2726:
    set $P6836["sink"], $P6835
.annotate 'line', 2075
    find_lex $P6837, "$/"
    find_lex $P6838, "$past"
    unless_null $P6838, vivify_2727
    new $P6838, "Undef"
  vivify_2727:
    $P6839 = $P6837."!make"($P6838)
.annotate 'line', 2058
    .return ($P6839)
  control_6781:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6840, exception, "payload"
    .return ($P6840)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("561_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6842
    .param pmc param_6843
.annotate 'line', 2078
    .lex "self", param_6842
    .lex "$/", param_6843
    find_lex $P6844, "$/"
    find_lex $P6845, "$/"
    unless_null $P6845, vivify_2728
    $P6845 = root_new ['parrot';'Hash']
  vivify_2728:
    set $P6846, $P6845["variable"]
    unless_null $P6846, vivify_2729
    new $P6846, "Undef"
  vivify_2729:
    $P6847 = $P6846."ast"()
    $P6848 = $P6844."!make"($P6847)
    .return ($P6848)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("562_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6850
    .param pmc param_6851
.annotate 'line', 2079
    .lex "self", param_6850
    .lex "$/", param_6851
.annotate 'line', 2080
    find_lex $P6852, "$/"
    get_hll_global $P6853, "GLOBAL"
    nqp_get_package_through_who $P6854, $P6853, "PAST"
    get_who $P6855, $P6854
    set $P6856, $P6855["Op"]
.annotate 'line', 2081
    find_lex $P6857, "$/"
    unless_null $P6857, vivify_2730
    $P6857 = root_new ['parrot';'Hash']
  vivify_2730:
    set $P6858, $P6857["block"]
    unless_null $P6858, vivify_2731
    new $P6858, "Undef"
  vivify_2731:
    $P6859 = $P6858."ast"()
    $P6860 = "block_immediate"($P6859)
    find_lex $P6861, "$/"
    unless_null $P6861, vivify_2732
    new $P6861, "Undef"
  vivify_2732:
    $P6862 = $P6856."new"($P6860, "set S*" :named("pirop"), $P6861 :named("node"))
.annotate 'line', 2080
    $P6863 = $P6852."!make"($P6862)
.annotate 'line', 2079
    .return ($P6863)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("563_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6865
    .param pmc param_6866
.annotate 'line', 2084
    .lex "self", param_6865
    .lex "$/", param_6866
    find_lex $P6867, "$/"
    $P6868 = $P6867."!make"("\e")
    .return ($P6868)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("564_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6870
    .param pmc param_6871
.annotate 'line', 2088
    .lex "self", param_6870
    .lex "$/", param_6871
    find_lex $P6872, "$/"
    find_lex $P6873, "$/"
    unless_null $P6873, vivify_2733
    $P6873 = root_new ['parrot';'Hash']
  vivify_2733:
    set $P6874, $P6873["dotty"]
    unless_null $P6874, vivify_2734
    new $P6874, "Undef"
  vivify_2734:
    $P6875 = $P6874."ast"()
    $P6876 = $P6872."!make"($P6875)
    .return ($P6876)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("565_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6878
    .param pmc param_6879
.annotate 'line', 2090
    .lex "self", param_6878
    .lex "$/", param_6879
.annotate 'line', 2091
    find_lex $P6880, "$/"
    get_hll_global $P6881, "GLOBAL"
    nqp_get_package_through_who $P6882, $P6881, "PAST"
    get_who $P6883, $P6882
    set $P6884, $P6883["Op"]
.annotate 'line', 2092
    new $P6885, "ResizablePMCArray"
    push $P6885, "    clone %r, %0"
    push $P6885, "    inc %0"
    $P6886 = $P6884."new"("postfix:<++>" :named("name"), $P6885 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2091
    $P6887 = $P6880."!make"($P6886)
.annotate 'line', 2090
    .return ($P6887)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("566_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6889
    .param pmc param_6890
.annotate 'line', 2096
    .lex "self", param_6889
    .lex "$/", param_6890
.annotate 'line', 2097
    find_lex $P6891, "$/"
    get_hll_global $P6892, "GLOBAL"
    nqp_get_package_through_who $P6893, $P6892, "PAST"
    get_who $P6894, $P6893
    set $P6895, $P6894["Op"]
.annotate 'line', 2098
    new $P6896, "ResizablePMCArray"
    push $P6896, "    clone %r, %0"
    push $P6896, "    dec %0"
    $P6897 = $P6895."new"("postfix:<-->" :named("name"), $P6896 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2097
    $P6898 = $P6891."!make"($P6897)
.annotate 'line', 2096
    .return ($P6898)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("567_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6900
    .param pmc param_6901
.annotate 'line', 2102
    .lex "self", param_6900
    .lex "$/", param_6901
.annotate 'line', 2103
    find_lex $P6902, "$/"
    get_hll_global $P6903, "GLOBAL"
    nqp_get_package_through_who $P6904, $P6903, "PAST"
    get_who $P6905, $P6904
    set $P6906, $P6905["Op"]
.annotate 'line', 2104
    get_hll_global $P6907, "GLOBAL"
    nqp_get_package_through_who $P6908, $P6907, "PAST"
    get_who $P6909, $P6908
    set $P6910, $P6909["Var"]
    $P6911 = $P6910."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P6912, "$/"
    unless_null $P6912, vivify_2735
    new $P6912, "Undef"
  vivify_2735:
    $P6913 = $P6906."new"($P6911, "callmethod" :named("pasttype"), "!make" :named("name"), $P6912 :named("node"))
.annotate 'line', 2103
    $P6914 = $P6902."!make"($P6913)
.annotate 'line', 2102
    .return ($P6914)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("568_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6917
    .param pmc param_6918
.annotate 'line', 2120
    .lex "self", param_6917
    .lex "$/", param_6918
    find_lex $P6919, "$/"
    unless_null $P6919, vivify_2736
    new $P6919, "Undef"
  vivify_2736:
    $P6920 = "control"($P6919, "CONTROL_LOOP_NEXT")
    .return ($P6920)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("569_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6922
    .param pmc param_6923
.annotate 'line', 2121
    .lex "self", param_6922
    .lex "$/", param_6923
    find_lex $P6924, "$/"
    unless_null $P6924, vivify_2737
    new $P6924, "Undef"
  vivify_2737:
    $P6925 = "control"($P6924, "CONTROL_LOOP_LAST")
    .return ($P6925)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("570_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6927
    .param pmc param_6928
.annotate 'line', 2122
    .lex "self", param_6927
    .lex "$/", param_6928
    find_lex $P6929, "$/"
    unless_null $P6929, vivify_2738
    new $P6929, "Undef"
  vivify_2738:
    $P6930 = "control"($P6929, "CONTROL_LOOP_REDO")
    .return ($P6930)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("571_1303748459.273") :outer("406_1303748459.273")
    .param pmc param_6932
    .param pmc param_6933
.annotate 'line', 2124
    .lex "self", param_6932
    .lex "$/", param_6933
.annotate 'line', 2125
    find_lex $P6934, "$/"
    get_hll_global $P6935, "GLOBAL"
    nqp_get_package_through_who $P6936, $P6935, "PAST"
    get_who $P6937, $P6936
    set $P6938, $P6937["Op"]
    find_lex $P6939, "$/"
    unless_null $P6939, vivify_2739
    new $P6939, "Undef"
  vivify_2739:
    $P6940 = $P6938."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P6939 :named("node"))
    $P6941 = $P6934."!make"($P6940)
.annotate 'line', 2124
    .return ($P6941)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7170"  :subid("573_1303748459.273") :outer("10_1303748459.273")
.annotate 'line', 2261
    .const 'Sub' $P7304 = "581_1303748459.273" 
    capture_lex $P7304
    .const 'Sub' $P7264 = "580_1303748459.273" 
    capture_lex $P7264
    .const 'Sub' $P7250 = "579_1303748459.273" 
    capture_lex $P7250
    .const 'Sub' $P7232 = "578_1303748459.273" 
    capture_lex $P7232
    .const 'Sub' $P7218 = "577_1303748459.273" 
    capture_lex $P7218
    .const 'Sub' $P7204 = "576_1303748459.273" 
    capture_lex $P7204
    .const 'Sub' $P7190 = "575_1303748459.273" 
    capture_lex $P7190
    .const 'Sub' $P7174 = "574_1303748459.273" 
    capture_lex $P7174
    .lex "$?PACKAGE", $P7172
    .lex "$?CLASS", $P7173
.annotate 'line', 2295
    .const 'Sub' $P7264 = "580_1303748459.273" 
    newclosure $P7302, $P7264
.annotate 'line', 2261
    .return ($P7302)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2740") :outer("573_1303748459.273")
.annotate 'line', 2261
    .const 'Sub' $P7171 = "573_1303748459.273" 
    .local pmc block
    set block, $P7171
    .const 'Sub' $P7304 = "581_1303748459.273" 
    capture_lex $P7304
    $P7304()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7303"  :anon :subid("581_1303748459.273") :outer("573_1303748459.273")
.annotate 'line', 2261
    nqp_get_sc_object $P7305, "1303748446.727", 4
    .local pmc type_obj
    set type_obj, $P7305
    get_how $P7306, type_obj
    .const 'Sub' $P7307 = "574_1303748459.273" 
    $P7306."add_method"(type_obj, "metachar:sym<:my>", $P7307)
    get_how $P7308, type_obj
    .const 'Sub' $P7309 = "575_1303748459.273" 
    $P7308."add_method"(type_obj, "metachar:sym<{ }>", $P7309)
    get_how $P7310, type_obj
    .const 'Sub' $P7311 = "576_1303748459.273" 
    $P7310."add_method"(type_obj, "metachar:sym<nqpvar>", $P7311)
    get_how $P7312, type_obj
    .const 'Sub' $P7313 = "577_1303748459.273" 
    $P7312."add_method"(type_obj, "assertion:sym<{ }>", $P7313)
    get_how $P7314, type_obj
    .const 'Sub' $P7315 = "578_1303748459.273" 
    $P7314."add_method"(type_obj, "assertion:sym<?{ }>", $P7315)
    get_how $P7316, type_obj
    .const 'Sub' $P7317 = "579_1303748459.273" 
    $P7316."add_method"(type_obj, "assertion:sym<var>", $P7317)
    get_how $P7318, type_obj
    .const 'Sub' $P7319 = "580_1303748459.273" 
    $P7318."add_method"(type_obj, "codeblock", $P7319)
    get_how $P7320, type_obj
    $P7321 = $P7320."compose"(type_obj)
    .return ($P7321)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("574_1303748459.273") :outer("573_1303748459.273")
    .param pmc param_7175
    .param pmc param_7176
.annotate 'line', 2263
    .lex "self", param_7175
    .lex "$/", param_7176
.annotate 'line', 2264
    new $P7177, "Undef"
    .lex "$past", $P7177
    find_lex $P7178, "$/"
    unless_null $P7178, vivify_2741
    $P7178 = root_new ['parrot';'Hash']
  vivify_2741:
    set $P7179, $P7178["statement"]
    unless_null $P7179, vivify_2742
    new $P7179, "Undef"
  vivify_2742:
    $P7180 = $P7179."ast"()
    store_lex "$past", $P7180
.annotate 'line', 2265
    find_lex $P7181, "$/"
    get_hll_global $P7182, "GLOBAL"
    nqp_get_package_through_who $P7183, $P7182, "PAST"
    get_who $P7184, $P7183
    set $P7185, $P7184["Regex"]
    find_lex $P7186, "$past"
    unless_null $P7186, vivify_2743
    new $P7186, "Undef"
  vivify_2743:
    find_lex $P7187, "$/"
    unless_null $P7187, vivify_2744
    new $P7187, "Undef"
  vivify_2744:
    $P7188 = $P7185."new"($P7186, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P7187 :named("node"))
    $P7189 = $P7181."!make"($P7188)
.annotate 'line', 2263
    .return ($P7189)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("575_1303748459.273") :outer("573_1303748459.273")
    .param pmc param_7191
    .param pmc param_7192
.annotate 'line', 2269
    .lex "self", param_7191
    .lex "$/", param_7192
.annotate 'line', 2270
    find_lex $P7193, "$/"
    get_hll_global $P7194, "GLOBAL"
    nqp_get_package_through_who $P7195, $P7194, "PAST"
    get_who $P7196, $P7195
    set $P7197, $P7196["Regex"]
    find_lex $P7198, "$/"
    unless_null $P7198, vivify_2745
    $P7198 = root_new ['parrot';'Hash']
  vivify_2745:
    set $P7199, $P7198["codeblock"]
    unless_null $P7199, vivify_2746
    new $P7199, "Undef"
  vivify_2746:
    $P7200 = $P7199."ast"()
    find_lex $P7201, "$/"
    unless_null $P7201, vivify_2747
    new $P7201, "Undef"
  vivify_2747:
    $P7202 = $P7197."new"($P7200, "pastnode" :named("pasttype"), $P7201 :named("node"))
    $P7203 = $P7193."!make"($P7202)
.annotate 'line', 2269
    .return ($P7203)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("576_1303748459.273") :outer("573_1303748459.273")
    .param pmc param_7205
    .param pmc param_7206
.annotate 'line', 2274
    .lex "self", param_7205
    .lex "$/", param_7206
.annotate 'line', 2275
    find_lex $P7207, "$/"
    get_hll_global $P7208, "GLOBAL"
    nqp_get_package_through_who $P7209, $P7208, "PAST"
    get_who $P7210, $P7209
    set $P7211, $P7210["Regex"]
    find_lex $P7212, "$/"
    unless_null $P7212, vivify_2748
    $P7212 = root_new ['parrot';'Hash']
  vivify_2748:
    set $P7213, $P7212["var"]
    unless_null $P7213, vivify_2749
    new $P7213, "Undef"
  vivify_2749:
    $P7214 = $P7213."ast"()
    find_lex $P7215, "$/"
    unless_null $P7215, vivify_2750
    new $P7215, "Undef"
  vivify_2750:
    $P7216 = $P7211."new"("!INTERPOLATE", $P7214, "subrule" :named("pasttype"), "method" :named("subtype"), $P7215 :named("node"))
    $P7217 = $P7207."!make"($P7216)
.annotate 'line', 2274
    .return ($P7217)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("577_1303748459.273") :outer("573_1303748459.273")
    .param pmc param_7219
    .param pmc param_7220
.annotate 'line', 2279
    .lex "self", param_7219
    .lex "$/", param_7220
.annotate 'line', 2280
    find_lex $P7221, "$/"
    get_hll_global $P7222, "GLOBAL"
    nqp_get_package_through_who $P7223, $P7222, "PAST"
    get_who $P7224, $P7223
    set $P7225, $P7224["Regex"]
    find_lex $P7226, "$/"
    unless_null $P7226, vivify_2751
    $P7226 = root_new ['parrot';'Hash']
  vivify_2751:
    set $P7227, $P7226["codeblock"]
    unless_null $P7227, vivify_2752
    new $P7227, "Undef"
  vivify_2752:
    $P7228 = $P7227."ast"()
    find_lex $P7229, "$/"
    unless_null $P7229, vivify_2753
    new $P7229, "Undef"
  vivify_2753:
    $P7230 = $P7225."new"("!INTERPOLATE_REGEX", $P7228, "subrule" :named("pasttype"), "method" :named("subtype"), $P7229 :named("node"))
    $P7231 = $P7221."!make"($P7230)
.annotate 'line', 2279
    .return ($P7231)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("578_1303748459.273") :outer("573_1303748459.273")
    .param pmc param_7233
    .param pmc param_7234
.annotate 'line', 2284
    .lex "self", param_7233
    .lex "$/", param_7234
.annotate 'line', 2285
    find_lex $P7235, "$/"
    get_hll_global $P7236, "GLOBAL"
    nqp_get_package_through_who $P7237, $P7236, "PAST"
    get_who $P7238, $P7237
    set $P7239, $P7238["Regex"]
    find_lex $P7240, "$/"
    unless_null $P7240, vivify_2754
    $P7240 = root_new ['parrot';'Hash']
  vivify_2754:
    set $P7241, $P7240["codeblock"]
    unless_null $P7241, vivify_2755
    new $P7241, "Undef"
  vivify_2755:
    $P7242 = $P7241."ast"()
.annotate 'line', 2286
    find_lex $P7243, "$/"
    unless_null $P7243, vivify_2756
    $P7243 = root_new ['parrot';'Hash']
  vivify_2756:
    set $P7244, $P7243["zw"]
    unless_null $P7244, vivify_2757
    new $P7244, "Undef"
  vivify_2757:
    set $S7245, $P7244
    iseq $I7246, $S7245, "!"
    find_lex $P7247, "$/"
    unless_null $P7247, vivify_2758
    new $P7247, "Undef"
  vivify_2758:
    $P7248 = $P7239."new"($P7242, "zerowidth" :named("subtype"), $I7246 :named("negate"), "pastnode" :named("pasttype"), $P7247 :named("node"))
.annotate 'line', 2285
    $P7249 = $P7235."!make"($P7248)
.annotate 'line', 2284
    .return ($P7249)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("579_1303748459.273") :outer("573_1303748459.273")
    .param pmc param_7251
    .param pmc param_7252
.annotate 'line', 2290
    .lex "self", param_7251
    .lex "$/", param_7252
.annotate 'line', 2291
    find_lex $P7253, "$/"
    get_hll_global $P7254, "GLOBAL"
    nqp_get_package_through_who $P7255, $P7254, "PAST"
    get_who $P7256, $P7255
    set $P7257, $P7256["Regex"]
    find_lex $P7258, "$/"
    unless_null $P7258, vivify_2759
    $P7258 = root_new ['parrot';'Hash']
  vivify_2759:
    set $P7259, $P7258["var"]
    unless_null $P7259, vivify_2760
    new $P7259, "Undef"
  vivify_2760:
    $P7260 = $P7259."ast"()
    find_lex $P7261, "$/"
    unless_null $P7261, vivify_2761
    new $P7261, "Undef"
  vivify_2761:
    $P7262 = $P7257."new"("!INTERPOLATE_REGEX", $P7260, "subrule" :named("pasttype"), "method" :named("subtype"), $P7261 :named("node"))
    $P7263 = $P7253."!make"($P7262)
.annotate 'line', 2290
    .return ($P7263)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("580_1303748459.273") :outer("573_1303748459.273")
    .param pmc param_7265
    .param pmc param_7266
.annotate 'line', 2295
    .lex "self", param_7265
    .lex "$/", param_7266
.annotate 'line', 2296
    new $P7267, "Undef"
    .lex "$block", $P7267
.annotate 'line', 2298
    new $P7268, "Undef"
    .lex "$past", $P7268
.annotate 'line', 2296
    find_lex $P7269, "$/"
    unless_null $P7269, vivify_2762
    $P7269 = root_new ['parrot';'Hash']
  vivify_2762:
    set $P7270, $P7269["block"]
    unless_null $P7270, vivify_2763
    new $P7270, "Undef"
  vivify_2763:
    $P7271 = $P7270."ast"()
    store_lex "$block", $P7271
.annotate 'line', 2297
    find_lex $P7272, "$block"
    unless_null $P7272, vivify_2764
    new $P7272, "Undef"
  vivify_2764:
    $P7272."blocktype"("immediate")
.annotate 'line', 2299
    get_hll_global $P7273, "GLOBAL"
    nqp_get_package_through_who $P7274, $P7273, "PAST"
    get_who $P7275, $P7274
    set $P7276, $P7275["Stmts"]
.annotate 'line', 2300
    get_hll_global $P7277, "GLOBAL"
    nqp_get_package_through_who $P7278, $P7277, "PAST"
    get_who $P7279, $P7278
    set $P7280, $P7279["Op"]
.annotate 'line', 2301
    get_hll_global $P7281, "GLOBAL"
    nqp_get_package_through_who $P7282, $P7281, "PAST"
    get_who $P7283, $P7282
    set $P7284, $P7283["Var"]
    $P7285 = $P7284."new"("$/" :named("name"))
.annotate 'line', 2302
    get_hll_global $P7286, "GLOBAL"
    nqp_get_package_through_who $P7287, $P7286, "PAST"
    get_who $P7288, $P7287
    set $P7289, $P7288["Op"]
.annotate 'line', 2303
    get_hll_global $P7290, "GLOBAL"
    nqp_get_package_through_who $P7291, $P7290, "PAST"
    get_who $P7292, $P7291
    set $P7293, $P7292["Var"]
    $P7294 = $P7293."new"(unicode:"$\x{a2}" :named("name"))
    $P7295 = $P7289."new"($P7294, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2302
    $P7296 = $P7280."new"($P7285, $P7295, "bind" :named("pasttype"))
.annotate 'line', 2300
    find_lex $P7297, "$block"
    unless_null $P7297, vivify_2765
    new $P7297, "Undef"
  vivify_2765:
    $P7298 = $P7276."new"($P7296, $P7297)
.annotate 'line', 2299
    store_lex "$past", $P7298
.annotate 'line', 2311
    find_lex $P7299, "$/"
    find_lex $P7300, "$past"
    unless_null $P7300, vivify_2766
    new $P7300, "Undef"
  vivify_2766:
    $P7301 = $P7299."!make"($P7300)
.annotate 'line', 2295
    .return ($P7301)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7322"  :subid("582_1303748459.273") :outer("10_1303748459.273")
.annotate 'line', 2316
    .const 'Sub' $P7327 = "583_1303748459.273" 
    capture_lex $P7327
    .lex "$?PACKAGE", $P7324
    .lex "$?CLASS", $P7325
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2767") :outer("582_1303748459.273")
.annotate 'line', 2316
    .const 'Sub' $P7323 = "582_1303748459.273" 
    .local pmc block
    set block, $P7323
    .const 'Sub' $P7327 = "583_1303748459.273" 
    capture_lex $P7327
    $P7327()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7326"  :anon :subid("583_1303748459.273") :outer("582_1303748459.273")
.annotate 'line', 2316
    nqp_get_sc_object $P7328, "1303748446.727", 5
    .local pmc type_obj
    set type_obj, $P7328
    get_how $P7329, type_obj
    $P7330 = $P7329."compose"(type_obj)
    .return ($P7330)
.end


.HLL "nqp"

.namespace []
.sub "_block7338" :load :anon :subid("584_1303748459.273")
.annotate 'line', 1
    .const 'Sub' $P7340 = "10_1303748459.273" 
    $P7341 = $P7340()
    .return ($P7341)
.end

