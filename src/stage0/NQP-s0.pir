# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup
.end
### .include 'gen/nqp-how.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1297619303.875")
.annotate 'line', 0
    get_hll_global $P2518, ["str"], "_block2517" 
    capture_lex $P2518
    get_hll_global $P2509, ["num"], "_block2508" 
    capture_lex $P2509
    get_hll_global $P2500, ["int"], "_block2499" 
    capture_lex $P2500
    get_hll_global $P2428, ["NQPMu"], "_block2427" 
    capture_lex $P2428
    get_hll_global $P2339, ["NQPModuleHOW"], "_block2338" 
    capture_lex $P2339
    get_hll_global $P2109, ["RoleToRoleApplier"], "_block2108" 
    capture_lex $P2109
    get_hll_global $P1893, ["RoleToClassApplier"], "_block1892" 
    capture_lex $P1893
    get_hll_global $P1537, ["NQPParametricRoleHOW"], "_block1536" 
    capture_lex $P1537
    get_hll_global $P1215, ["NQPConcreteRoleHOW"], "_block1214" 
    capture_lex $P1215
    get_hll_global $P1131, ["NQPAttribute"], "_block1130" 
    capture_lex $P1131
    get_hll_global $P1043, ["NQPNativeHOW"], "_block1042" 
    capture_lex $P1043
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    capture_lex $P53
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    capture_lex $P27
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, "str"
    get_hll_global $P14, "num"
    get_hll_global $P15, "int"
    get_hll_global $P16, "NQPMu"
    get_hll_global $P17, "NQPModuleHOW"
    get_hll_global $P18, "RoleToRoleApplier"
    get_hll_global $P19, "RoleToClassApplier"
    get_hll_global $P20, "NQPParametricRoleHOW"
    get_hll_global $P21, "NQPConcreteRoleHOW"
    get_hll_global $P22, "NQPAttribute"
    get_hll_global $P23, "NQPNativeHOW"
    get_hll_global $P24, "NQPClassHOW"
    get_hll_global $P25, "KnowHOWAttribute"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 10
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    capture_lex $P27
    $P27()
.annotate 'line', 26
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    capture_lex $P53
    $P53()
.annotate 'line', 434
    get_hll_global $P1043, ["NQPNativeHOW"], "_block1042" 
    capture_lex $P1043
    $P1043()
.annotate 'line', 478
    get_hll_global $P1131, ["NQPAttribute"], "_block1130" 
    capture_lex $P1131
    $P1131()
.annotate 'line', 511
    get_hll_global $P1215, ["NQPConcreteRoleHOW"], "_block1214" 
    capture_lex $P1215
    $P1215()
.annotate 'line', 660
    get_hll_global $P1537, ["NQPParametricRoleHOW"], "_block1536" 
    capture_lex $P1537
    $P1537()
.annotate 'line', 826
    get_hll_global $P1893, ["RoleToClassApplier"], "_block1892" 
    capture_lex $P1893
    $P1893()
.annotate 'line', 898
    get_hll_global $P2109, ["RoleToRoleApplier"], "_block2108" 
    capture_lex $P2109
    $P2109()
.annotate 'line', 988
    get_hll_global $P2339, ["NQPModuleHOW"], "_block2338" 
    capture_lex $P2339
    $P2339()
.annotate 'line', 1033
    get_hll_global $P2428, ["NQPMu"], "_block2427" 
    capture_lex $P2428
    $P2428()
.annotate 'line', 1059
    get_hll_global $P2500, ["int"], "_block2499" 
    capture_lex $P2500
    $P2500()
.annotate 'line', 1061
    get_hll_global $P2509, ["num"], "_block2508" 
    capture_lex $P2509
    $P2509()
.annotate 'line', 1063
    get_hll_global $P2518, ["str"], "_block2517" 
    capture_lex $P2518
    $P2526 = $P2518()
.annotate 'line', 1
    .return ($P2526)
    .const 'Sub' $P2528 = "176_1297619303.875" 
    .return ($P2528)
.end


.namespace ["KnowHOWAttribute"]
.sub "_block26"  :subid("11_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 10
    .const 'Sub' $P43 = "14_1297619303.875" 
    capture_lex $P43
    .const 'Sub' $P37 = "13_1297619303.875" 
    capture_lex $P37
    .const 'Sub' $P29 = "12_1297619303.875" 
    capture_lex $P29
    get_global $P28, "$?CLASS"
.annotate 'line', 14
    .const 'Sub' $P37 = "13_1297619303.875" 
    newclosure $P41, $P37
.annotate 'line', 10
    .return ($P41)
.end


.namespace ["KnowHOWAttribute"]
.sub "" :load :init :subid("post177") :outer("11_1297619303.875")
.annotate 'line', 10
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    .local pmc block
    set block, $P27
    .const 'Sub' $P43 = "14_1297619303.875" 
    capture_lex $P43
    $P43()
.end


.namespace ["KnowHOWAttribute"]
.sub "_block42"  :anon :subid("14_1297619303.875") :outer("11_1297619303.875")
.annotate 'line', 10
    get_hll_global $P44, "KnowHOW"
    $P45 = $P44."new_type"("KnowHOWAttribute" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P45
    set_hll_global "KnowHOWAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P46, type_obj
    .const 'Sub' $P47 = "12_1297619303.875" 
    $P46."add_method"(type_obj, "new", $P47)
    get_how $P48, type_obj
    .const 'Sub' $P49 = "13_1297619303.875" 
    $P48."add_method"(type_obj, "name", $P49)
    get_how $P50, type_obj
    $P51 = $P50."compose"(type_obj)
    .return ($P51)
.end


.namespace ["KnowHOWAttribute"]
.sub "new"  :subid("12_1297619303.875") :outer("11_1297619303.875")
    .param pmc param_30
    .param pmc param_31 :optional :named("name")
    .param int has_param_31 :opt_flag
.annotate 'line', 11
    .lex "self", param_30
    if has_param_31, optparam_178
    new $P32, "Undef"
    set param_31, $P32
  optparam_178:
    .lex "$name", param_31
.annotate 'line', 12
    find_lex $P33, "$name"
    set $S34, $P33
    get_hll_global $P35, "KnowHOWAttribute"
    repr_box_str $P36, $S34, $P35
.annotate 'line', 11
    .return ($P36)
.end


.namespace ["KnowHOWAttribute"]
.sub "name"  :subid("13_1297619303.875") :outer("11_1297619303.875")
    .param pmc param_38
.annotate 'line', 14
    .lex "self", param_38
.annotate 'line', 15
    find_lex $P39, "self"
    repr_unbox_str $S40, $P39
.annotate 'line', 14
    .return ($S40)
.end


.namespace ["NQPClassHOW"]
.sub "_block52"  :subid("15_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 26
    .const 'Sub' $P955 = "65_1297619303.875" 
    capture_lex $P955
    .const 'Sub' $P918 = "63_1297619303.875" 
    capture_lex $P918
    .const 'Sub' $P882 = "61_1297619303.875" 
    capture_lex $P882
    .const 'Sub' $P848 = "60_1297619303.875" 
    capture_lex $P848
    .const 'Sub' $P811 = "59_1297619303.875" 
    capture_lex $P811
    .const 'Sub' $P788 = "57_1297619303.875" 
    capture_lex $P788
    .const 'Sub' $P782 = "56_1297619303.875" 
    capture_lex $P782
    .const 'Sub' $P776 = "55_1297619303.875" 
    capture_lex $P776
    .const 'Sub' $P753 = "53_1297619303.875" 
    capture_lex $P753
    .const 'Sub' $P746 = "52_1297619303.875" 
    capture_lex $P746
    .const 'Sub' $P732 = "51_1297619303.875" 
    capture_lex $P732
    .const 'Sub' $P687 = "48_1297619303.875" 
    capture_lex $P687
    .const 'Sub' $P650 = "45_1297619303.875" 
    capture_lex $P650
    .const 'Sub' $P520 = "40_1297619303.875" 
    capture_lex $P520
    .const 'Sub' $P424 = "37_1297619303.875" 
    capture_lex $P424
    .const 'Sub' $P398 = "36_1297619303.875" 
    capture_lex $P398
    .const 'Sub' $P364 = "34_1297619303.875" 
    capture_lex $P364
    .const 'Sub' $P326 = "32_1297619303.875" 
    capture_lex $P326
    .const 'Sub' $P305 = "31_1297619303.875" 
    capture_lex $P305
    .const 'Sub' $P284 = "30_1297619303.875" 
    capture_lex $P284
    .const 'Sub' $P265 = "29_1297619303.875" 
    capture_lex $P265
    .const 'Sub' $P251 = "28_1297619303.875" 
    capture_lex $P251
    .const 'Sub' $P244 = "27_1297619303.875" 
    capture_lex $P244
    .const 'Sub' $P234 = "26_1297619303.875" 
    capture_lex $P234
    .const 'Sub' $P97 = "19_1297619303.875" 
    capture_lex $P97
    .const 'Sub' $P55 = "16_1297619303.875" 
    capture_lex $P55
    get_global $P54, "$?CLASS"
.annotate 'line', 234
    .const 'Sub' $P55 = "16_1297619303.875" 
    newclosure $P96, $P55
    .lex "compute_c3_mro", $P96
.annotate 'line', 256
    .const 'Sub' $P97 = "19_1297619303.875" 
    newclosure $P233, $P97
    .lex "c3_merge", $P233
.annotate 'line', 180
    find_lex $P648, "compute_c3_mro"
    find_lex $P649, "c3_merge"
.annotate 'line', 421
    .const 'Sub' $P918 = "63_1297619303.875" 
    newclosure $P953, $P918
.annotate 'line', 26
    .return ($P953)
.end


.namespace ["NQPClassHOW"]
.sub "" :load :init :subid("post179") :outer("15_1297619303.875")
.annotate 'line', 26
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    .local pmc block
    set block, $P53
    .const 'Sub' $P955 = "65_1297619303.875" 
    capture_lex $P955
    $P955()
.end


.namespace ["NQPClassHOW"]
.sub "_block954"  :anon :subid("65_1297619303.875") :outer("15_1297619303.875")
.annotate 'line', 26
    get_hll_global $P956, "KnowHOW"
    $P957 = $P956."new_type"("NQPClassHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P957
    set_hll_global "NQPClassHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P958, type_obj
    get_hll_global $P959, "KnowHOWAttribute"
    $P960 = $P959."new"("$!name" :named("name"))
    $P958."add_attribute"(type_obj, $P960)
    get_how $P961, type_obj
    get_hll_global $P962, "KnowHOWAttribute"
    $P963 = $P962."new"("%!attributes" :named("name"))
    $P961."add_attribute"(type_obj, $P963)
    get_how $P964, type_obj
    get_hll_global $P965, "KnowHOWAttribute"
    $P966 = $P965."new"("%!methods" :named("name"))
    $P964."add_attribute"(type_obj, $P966)
    get_how $P967, type_obj
    get_hll_global $P968, "KnowHOWAttribute"
    $P969 = $P968."new"("@!multi_methods_to_incorporate" :named("name"))
    $P967."add_attribute"(type_obj, $P969)
    get_how $P970, type_obj
    get_hll_global $P971, "KnowHOWAttribute"
    $P972 = $P971."new"("@!parents" :named("name"))
    $P970."add_attribute"(type_obj, $P972)
    get_how $P973, type_obj
    get_hll_global $P974, "KnowHOWAttribute"
    $P975 = $P974."new"("@!roles" :named("name"))
    $P973."add_attribute"(type_obj, $P975)
    get_how $P976, type_obj
    get_hll_global $P977, "KnowHOWAttribute"
    $P978 = $P977."new"("@!vtable" :named("name"))
    $P976."add_attribute"(type_obj, $P978)
    get_how $P979, type_obj
    get_hll_global $P980, "KnowHOWAttribute"
    $P981 = $P980."new"("%!method-vtable-slots" :named("name"))
    $P979."add_attribute"(type_obj, $P981)
    get_how $P982, type_obj
    get_hll_global $P983, "KnowHOWAttribute"
    $P984 = $P983."new"("$!composed" :named("name"))
    $P982."add_attribute"(type_obj, $P984)
    get_how $P985, type_obj
    get_hll_global $P986, "KnowHOWAttribute"
    $P987 = $P986."new"("@!mro" :named("name"))
    $P985."add_attribute"(type_obj, $P987)
    get_how $P988, type_obj
    get_hll_global $P989, "KnowHOWAttribute"
    $P990 = $P989."new"("@!done" :named("name"))
    $P988."add_attribute"(type_obj, $P990)
    get_how $P991, type_obj
    get_hll_global $P992, "KnowHOWAttribute"
    $P993 = $P992."new"("%!parrot_vtable_mapping" :named("name"))
    $P991."add_attribute"(type_obj, $P993)
    get_how $P994, type_obj
    .const 'Sub' $P995 = "26_1297619303.875" 
    $P994."add_method"(type_obj, "new", $P995)
    get_how $P996, type_obj
    .const 'Sub' $P997 = "27_1297619303.875" 
    $P996."add_method"(type_obj, "BUILD", $P997)
    get_how $P998, type_obj
    .const 'Sub' $P999 = "28_1297619303.875" 
    $P998."add_method"(type_obj, "new_type", $P999)
    get_how $P1000, type_obj
    .const 'Sub' $P1001 = "29_1297619303.875" 
    $P1000."add_method"(type_obj, "add_method", $P1001)
    get_how $P1002, type_obj
    .const 'Sub' $P1003 = "30_1297619303.875" 
    $P1002."add_method"(type_obj, "add_multi_method", $P1003)
    get_how $P1004, type_obj
    .const 'Sub' $P1005 = "31_1297619303.875" 
    $P1004."add_method"(type_obj, "add_attribute", $P1005)
    get_how $P1006, type_obj
    .const 'Sub' $P1007 = "32_1297619303.875" 
    $P1006."add_method"(type_obj, "add_parent", $P1007)
    get_how $P1008, type_obj
    .const 'Sub' $P1009 = "34_1297619303.875" 
    $P1008."add_method"(type_obj, "add_role", $P1009)
    get_how $P1010, type_obj
    .const 'Sub' $P1011 = "36_1297619303.875" 
    $P1010."add_method"(type_obj, "add_parrot_vtable_mapping", $P1011)
    get_how $P1012, type_obj
    .const 'Sub' $P1013 = "37_1297619303.875" 
    $P1012."add_method"(type_obj, "compose", $P1013)
    get_how $P1014, type_obj
    .const 'Sub' $P1015 = "40_1297619303.875" 
    $P1014."add_method"(type_obj, "incorporate_multi_candidates", $P1015)
    get_how $P1016, type_obj
    .const 'Sub' $P1017 = "45_1297619303.875" 
    $P1016."add_method"(type_obj, "publish_type_cache", $P1017)
    get_how $P1018, type_obj
    .const 'Sub' $P1019 = "48_1297619303.875" 
    $P1018."add_method"(type_obj, "publish_method_cache", $P1019)
    get_how $P1020, type_obj
    .const 'Sub' $P1021 = "51_1297619303.875" 
    $P1020."add_method"(type_obj, "parents", $P1021)
    get_how $P1022, type_obj
    .const 'Sub' $P1023 = "52_1297619303.875" 
    $P1022."add_method"(type_obj, "roles", $P1023)
    get_how $P1024, type_obj
    .const 'Sub' $P1025 = "53_1297619303.875" 
    $P1024."add_method"(type_obj, "methods", $P1025)
    get_how $P1026, type_obj
    .const 'Sub' $P1027 = "55_1297619303.875" 
    $P1026."add_method"(type_obj, "method_table", $P1027)
    get_how $P1028, type_obj
    .const 'Sub' $P1029 = "56_1297619303.875" 
    $P1028."add_method"(type_obj, "name", $P1029)
    get_how $P1030, type_obj
    .const 'Sub' $P1031 = "57_1297619303.875" 
    $P1030."add_method"(type_obj, "attributes", $P1031)
    get_how $P1032, type_obj
    .const 'Sub' $P1033 = "59_1297619303.875" 
    $P1032."add_method"(type_obj, "isa", $P1033)
    get_how $P1034, type_obj
    .const 'Sub' $P1035 = "60_1297619303.875" 
    $P1034."add_method"(type_obj, "does", $P1035)
    get_how $P1036, type_obj
    .const 'Sub' $P1037 = "61_1297619303.875" 
    $P1036."add_method"(type_obj, "can", $P1037)
    get_how $P1038, type_obj
    .const 'Sub' $P1039 = "63_1297619303.875" 
    $P1038."add_method"(type_obj, "find_method", $P1039)
    get_how $P1040, type_obj
    $P1041 = $P1040."compose"(type_obj)
    .return ($P1041)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compute_c3_mro"  :subid("16_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_58
.annotate 'line', 234
    .const 'Sub' $P70 = "17_1297619303.875" 
    capture_lex $P70
    new $P57, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P57, control_56
    push_eh $P57
    .lex "$class", param_58
.annotate 'line', 235
    $P59 = root_new ['parrot';'ResizablePMCArray']
    .lex "@immediate_parents", $P59
.annotate 'line', 238
    $P60 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P60
.annotate 'line', 235
    find_lex $P61, "$class"
    get_how $P62, $P61
    find_lex $P63, "$class"
    $P64 = $P62."parents"($P63, 1 :named("local"))
    store_lex "@immediate_parents", $P64
    find_lex $P65, "@result"
.annotate 'line', 239
    find_lex $P67, "@immediate_parents"
    set $N68, $P67
    unless $N68, if_66_end
    .const 'Sub' $P70 = "17_1297619303.875" 
    capture_lex $P70
    $P70()
  if_66_end:
.annotate 'line', 251
    find_lex $P91, "@result"
    find_lex $P92, "$class"
    $P91."unshift"($P92)
.annotate 'line', 252
    new $P93, "Exception"
    set $P93['type'], .CONTROL_RETURN
    find_lex $P94, "@result"
    setattribute $P93, 'payload', $P94
    throw $P93
.annotate 'line', 234
    .return ()
  control_56:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P95, exception, "payload"
    .return ($P95)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block69"  :anon :subid("17_1297619303.875") :outer("16_1297619303.875")
.annotate 'line', 239
    .const 'Sub' $P78 = "18_1297619303.875" 
    capture_lex $P78
.annotate 'line', 242
    $P71 = root_new ['parrot';'ResizablePMCArray']
    .lex "@merge_list", $P71
.annotate 'line', 239
    find_lex $P72, "@merge_list"
.annotate 'line', 243
    find_lex $P74, "@immediate_parents"
    defined $I75, $P74
    unless $I75, for_undef_180
    iter $P73, $P74
    new $P85, 'ExceptionHandler'
    set_label $P85, loop84_handler
    $P85."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P85
  loop84_test:
    unless $P73, loop84_done
    shift $P76, $P73
  loop84_redo:
    .const 'Sub' $P78 = "18_1297619303.875" 
    capture_lex $P78
    $P78($P76)
  loop84_next:
    goto loop84_test
  loop84_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P86, exception, 'type'
    eq $P86, .CONTROL_LOOP_NEXT, loop84_next
    eq $P86, .CONTROL_LOOP_REDO, loop84_redo
  loop84_done:
    pop_eh 
  for_undef_180:
.annotate 'line', 246
    find_lex $P87, "@merge_list"
    find_lex $P88, "@immediate_parents"
    $P87."push"($P88)
.annotate 'line', 247
    find_lex $P89, "@merge_list"
    $P90 = "c3_merge"($P89)
    store_lex "@result", $P90
.annotate 'line', 239
    .return ($P90)
.end


.namespace ["NQPClassHOW"]
.sub "_block77"  :anon :subid("18_1297619303.875") :outer("17_1297619303.875")
    .param pmc param_79
.annotate 'line', 243
    .lex "$_", param_79
.annotate 'line', 244
    find_lex $P80, "@merge_list"
    find_lex $P81, "$_"
    $P82 = "compute_c3_mro"($P81)
    $P83 = $P80."push"($P82)
.annotate 'line', 243
    .return ($P83)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "c3_merge"  :subid("19_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_100
.annotate 'line', 256
    .const 'Sub' $P193 = "24_1297619303.875" 
    capture_lex $P193
    .const 'Sub' $P115 = "20_1297619303.875" 
    capture_lex $P115
    new $P99, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P99, control_98
    push_eh $P99
    .lex "@merge_list", param_100
.annotate 'line', 257
    $P101 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P101
.annotate 'line', 258
    new $P102, "Undef"
    .lex "$accepted", $P102
.annotate 'line', 259
    new $P103, "Undef"
    .lex "$something_accepted", $P103
.annotate 'line', 260
    new $P104, "Undef"
    .lex "$cand_count", $P104
.annotate 'line', 303
    new $P105, "Undef"
    .lex "$i", $P105
.annotate 'line', 256
    find_lex $P106, "@result"
    find_lex $P107, "$accepted"
.annotate 'line', 259
    new $P108, "Integer"
    assign $P108, 0
    store_lex "$something_accepted", $P108
.annotate 'line', 260
    new $P109, "Integer"
    assign $P109, 0
    store_lex "$cand_count", $P109
.annotate 'line', 263
    find_lex $P111, "@merge_list"
    defined $I112, $P111
    unless $I112, for_undef_181
    iter $P110, $P111
    new $P176, 'ExceptionHandler'
    set_label $P176, loop175_handler
    $P176."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P176
  loop175_test:
    unless $P110, loop175_done
    shift $P113, $P110
  loop175_redo:
    .const 'Sub' $P115 = "20_1297619303.875" 
    capture_lex $P115
    $P115($P113)
  loop175_next:
    goto loop175_test
  loop175_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P177, exception, 'type'
    eq $P177, .CONTROL_LOOP_NEXT, loop175_next
    eq $P177, .CONTROL_LOOP_REDO, loop175_redo
  loop175_done:
    pop_eh 
  for_undef_181:
.annotate 'line', 293
    find_lex $P179, "$cand_count"
    set $N180, $P179
    iseq $I181, $N180, 0.0
    unless $I181, if_178_end
.annotate 'line', 294
    new $P182, "Exception"
    set $P182['type'], .CONTROL_RETURN
    find_lex $P183, "@result"
    setattribute $P182, 'payload', $P183
    throw $P182
  if_178_end:
.annotate 'line', 298
    find_lex $P185, "$something_accepted"
    if $P185, unless_184_end
.annotate 'line', 299
    die "Could not build C3 linearization: ambiguous hierarchy"
  unless_184_end:
.annotate 'line', 303
    new $P186, "Integer"
    assign $P186, 0
    store_lex "$i", $P186
.annotate 'line', 304
    new $P224, 'ExceptionHandler'
    set_label $P224, loop223_handler
    $P224."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P224
  loop223_test:
    find_lex $P187, "$i"
    set $N188, $P187
    find_lex $P189, "@merge_list"
    set $N190, $P189
    islt $I191, $N188, $N190
    unless $I191, loop223_done
  loop223_redo:
    .const 'Sub' $P193 = "24_1297619303.875" 
    capture_lex $P193
    $P193()
  loop223_next:
    goto loop223_test
  loop223_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P225, exception, 'type'
    eq $P225, .CONTROL_LOOP_NEXT, loop223_next
    eq $P225, .CONTROL_LOOP_REDO, loop223_redo
  loop223_done:
    pop_eh 
.annotate 'line', 317
    find_lex $P226, "@merge_list"
    $P227 = "c3_merge"($P226)
    store_lex "@result", $P227
.annotate 'line', 318
    find_lex $P228, "@result"
    find_lex $P229, "$accepted"
    $P228."unshift"($P229)
.annotate 'line', 319
    new $P230, "Exception"
    set $P230['type'], .CONTROL_RETURN
    find_lex $P231, "@result"
    setattribute $P230, 'payload', $P231
    throw $P230
.annotate 'line', 256
    .return ()
  control_98:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P232, exception, "payload"
    .return ($P232)
.end


.namespace ["NQPClassHOW"]
.sub "_block114"  :anon :subid("20_1297619303.875") :outer("19_1297619303.875")
    .param pmc param_117
.annotate 'line', 263
    .const 'Sub' $P124 = "21_1297619303.875" 
    capture_lex $P124
.annotate 'line', 264
    $P116 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cand_list", $P116
    .lex "$_", param_117
    find_lex $P118, "$_"
    store_lex "@cand_list", $P118
.annotate 'line', 265
    find_lex $P121, "@cand_list"
    set $N122, $P121
    if $N122, if_120
    new $P119, 'Float'
    set $P119, $N122
    goto if_120_end
  if_120:
    .const 'Sub' $P124 = "21_1297619303.875" 
    capture_lex $P124
    $P174 = $P124()
    set $P119, $P174
  if_120_end:
.annotate 'line', 263
    .return ($P119)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block123"  :anon :subid("21_1297619303.875") :outer("20_1297619303.875")
.annotate 'line', 265
    .const 'Sub' $P137 = "22_1297619303.875" 
    capture_lex $P137
.annotate 'line', 266
    new $P125, "Undef"
    .lex "$rejected", $P125
.annotate 'line', 267
    new $P126, "Undef"
    .lex "$cand_class", $P126
.annotate 'line', 266
    new $P127, "Integer"
    assign $P127, 0
    store_lex "$rejected", $P127
.annotate 'line', 267
    find_lex $P128, "@cand_list"
    unless_null $P128, vivify_182
    $P128 = root_new ['parrot';'ResizablePMCArray']
  vivify_182:
    set $P129, $P128[0]
    unless_null $P129, vivify_183
    new $P129, "Undef"
  vivify_183:
    store_lex "$cand_class", $P129
.annotate 'line', 268
    find_lex $P130, "$cand_count"
    add $P131, $P130, 1
    store_lex "$cand_count", $P131
.annotate 'line', 269
    find_lex $P133, "@merge_list"
    defined $I134, $P133
    unless $I134, for_undef_184
    iter $P132, $P133
    new $P172, 'ExceptionHandler'
    set_label $P172, loop171_handler
    $P172."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P172
  loop171_test:
    unless $P132, loop171_done
    shift $P135, $P132
  loop171_redo:
    .const 'Sub' $P137 = "22_1297619303.875" 
    capture_lex $P137
    $P137($P135)
  loop171_next:
    goto loop171_test
  loop171_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P173, exception, 'type'
    eq $P173, .CONTROL_LOOP_NEXT, loop171_next
    eq $P173, .CONTROL_LOOP_REDO, loop171_redo
  loop171_done:
    pop_eh 
  for_undef_184:
.annotate 'line', 265
    .return ($P132)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block136"  :anon :subid("22_1297619303.875") :outer("21_1297619303.875")
    .param pmc param_138
.annotate 'line', 269
    .const 'Sub' $P144 = "23_1297619303.875" 
    capture_lex $P144
    .lex "$_", param_138
.annotate 'line', 271
    find_lex $P140, "$_"
    find_lex $P141, "@cand_list"
    issame $I142, $P140, $P141
    if $I142, unless_139_end
    .const 'Sub' $P144 = "23_1297619303.875" 
    capture_lex $P144
    $P144()
  unless_139_end:
.annotate 'line', 283
    find_lex $P167, "$rejected"
    unless $P167, unless_166
    set $P165, $P167
    goto unless_166_end
  unless_166:
.annotate 'line', 284
    find_lex $P168, "$cand_class"
    store_lex "$accepted", $P168
.annotate 'line', 285
    new $P169, "Integer"
    assign $P169, 1
    store_lex "$something_accepted", $P169
.annotate 'line', 286
    set $I170, .CONTROL_LOOP_LAST
    die 0, $I170
  unless_166_end:
.annotate 'line', 269
    .return ($P165)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block143"  :anon :subid("23_1297619303.875") :outer("22_1297619303.875")
.annotate 'line', 273
    new $P145, "Undef"
    .lex "$cur_pos", $P145
    new $P146, "Integer"
    assign $P146, 1
    store_lex "$cur_pos", $P146
.annotate 'line', 274
    new $P163, 'ExceptionHandler'
    set_label $P163, loop162_handler
    $P163."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P163
  loop162_test:
    find_lex $P147, "$cur_pos"
    set $N148, $P147
    find_lex $P149, "$_"
    set $N150, $P149
    isle $I151, $N148, $N150
    unless $I151, loop162_done
  loop162_redo:
.annotate 'line', 275
    find_lex $P153, "$cur_pos"
    set $I154, $P153
    find_lex $P155, "$_"
    unless_null $P155, vivify_185
    $P155 = root_new ['parrot';'ResizablePMCArray']
  vivify_185:
    set $P156, $P155[$I154]
    unless_null $P156, vivify_186
    new $P156, "Undef"
  vivify_186:
    find_lex $P157, "$cand_class"
    issame $I158, $P156, $P157
    unless $I158, if_152_end
.annotate 'line', 276
    new $P159, "Integer"
    assign $P159, 1
    store_lex "$rejected", $P159
  if_152_end:
.annotate 'line', 278
    find_lex $P160, "$cur_pos"
    add $P161, $P160, 1
    store_lex "$cur_pos", $P161
  loop162_next:
.annotate 'line', 274
    goto loop162_test
  loop162_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P164, exception, 'type'
    eq $P164, .CONTROL_LOOP_NEXT, loop162_next
    eq $P164, .CONTROL_LOOP_REDO, loop162_redo
  loop162_done:
    pop_eh 
.annotate 'line', 271
    .return ($I151)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block192"  :anon :subid("24_1297619303.875") :outer("19_1297619303.875")
.annotate 'line', 304
    .const 'Sub' $P204 = "25_1297619303.875" 
    capture_lex $P204
.annotate 'line', 305
    $P194 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_list", $P194
.annotate 'line', 304
    find_lex $P195, "@new_list"
.annotate 'line', 306
    find_lex $P197, "$i"
    set $I198, $P197
    find_lex $P199, "@merge_list"
    unless_null $P199, vivify_187
    $P199 = root_new ['parrot';'ResizablePMCArray']
  vivify_187:
    set $P200, $P199[$I198]
    unless_null $P200, vivify_188
    new $P200, "Undef"
  vivify_188:
    defined $I201, $P200
    unless $I201, for_undef_189
    iter $P196, $P200
    new $P215, 'ExceptionHandler'
    set_label $P215, loop214_handler
    $P215."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P215
  loop214_test:
    unless $P196, loop214_done
    shift $P202, $P196
  loop214_redo:
    .const 'Sub' $P204 = "25_1297619303.875" 
    capture_lex $P204
    $P204($P202)
  loop214_next:
    goto loop214_test
  loop214_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P216, exception, 'type'
    eq $P216, .CONTROL_LOOP_NEXT, loop214_next
    eq $P216, .CONTROL_LOOP_REDO, loop214_redo
  loop214_done:
    pop_eh 
  for_undef_189:
.annotate 'line', 311
    find_lex $P217, "@new_list"
    find_lex $P218, "$i"
    set $I219, $P218
    find_lex $P220, "@merge_list"
    unless_null $P220, vivify_190
    $P220 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@merge_list", $P220
  vivify_190:
    set $P220[$I219], $P217
.annotate 'line', 312
    find_lex $P221, "$i"
    add $P222, $P221, 1
    store_lex "$i", $P222
.annotate 'line', 304
    .return ($P222)
.end


.namespace ["NQPClassHOW"]
.sub "_block203"  :anon :subid("25_1297619303.875") :outer("24_1297619303.875")
    .param pmc param_205
.annotate 'line', 306
    .lex "$_", param_205
.annotate 'line', 307
    find_lex $P208, "$_"
    find_lex $P209, "$accepted"
    issame $I210, $P208, $P209
    unless $I210, unless_207
    new $P206, 'Integer'
    set $P206, $I210
    goto unless_207_end
  unless_207:
.annotate 'line', 308
    find_lex $P211, "@new_list"
    find_lex $P212, "$_"
    $P213 = $P211."push"($P212)
.annotate 'line', 307
    set $P206, $P213
  unless_207_end:
.annotate 'line', 306
    .return ($P206)
.end


.namespace ["NQPClassHOW"]
.sub "new"  :subid("26_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_235
    .param pmc param_236 :optional :named("name")
    .param int has_param_236 :opt_flag
.annotate 'line', 62
    .lex "self", param_235
    if has_param_236, optparam_191
    new $P237, "Undef"
    set param_236, $P237
  optparam_191:
    .lex "$name", param_236
.annotate 'line', 63
    new $P238, "Undef"
    .lex "$obj", $P238
    find_lex $P239, "self"
    repr_instance_of $P240, $P239
    store_lex "$obj", $P240
.annotate 'line', 64
    find_lex $P241, "$obj"
    find_lex $P242, "$name"
    $P241."BUILD"($P242 :named("name"))
    find_lex $P243, "$obj"
.annotate 'line', 62
    .return ($P243)
.end


.namespace ["NQPClassHOW"]
.sub "BUILD"  :subid("27_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_245
    .param pmc param_246 :optional :named("name")
    .param int has_param_246 :opt_flag
.annotate 'line', 68
    .lex "self", param_245
    if has_param_246, optparam_192
    new $P247, "Undef"
    set param_246, $P247
  optparam_192:
    .lex "$name", param_246
.annotate 'line', 69
    find_lex $P248, "$name"
    find_lex $P249, "self"
    get_global $P250, "$?CLASS"
    setattribute $P249, $P250, "$!name", $P248
.annotate 'line', 68
    .return ($P248)
.end


.namespace ["NQPClassHOW"]
.sub "new_type"  :subid("28_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_252
    .param pmc param_253 :optional :named("name")
    .param int has_param_253 :opt_flag
    .param pmc param_255 :optional :named("repr")
    .param int has_param_255 :opt_flag
.annotate 'line', 74
    .lex "self", param_252
    if has_param_253, optparam_193
    new $P254, "String"
    assign $P254, "<anon>"
    set param_253, $P254
  optparam_193:
    .lex "$name", param_253
    if has_param_255, optparam_194
    new $P256, "String"
    assign $P256, "P6opaque"
    set param_255, $P256
  optparam_194:
    .lex "$repr", param_255
.annotate 'line', 75
    new $P257, "Undef"
    .lex "$metaclass", $P257
    find_lex $P258, "self"
    find_lex $P259, "$name"
    $P260 = $P258."new"($P259 :named("name"))
    store_lex "$metaclass", $P260
.annotate 'line', 76
    find_lex $P261, "$metaclass"
    find_lex $P262, "$repr"
    set $S263, $P262
    repr_type_object_for $P264, $P261, $S263
.annotate 'line', 74
    .return ($P264)
.end


.namespace ["NQPClassHOW"]
.sub "add_method"  :subid("29_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_266
    .param pmc param_267
    .param pmc param_268
    .param pmc param_269
.annotate 'line', 79
    .lex "self", param_266
    .lex "$obj", param_267
    .lex "$name", param_268
    .lex "$code_obj", param_269
.annotate 'line', 80
    find_lex $P271, "$name"
    find_lex $P272, "self"
    get_global $P273, "$?CLASS"
    getattribute $P274, $P272, $P273, "%!methods"
    unless_null $P274, vivify_195
    $P274 = root_new ['parrot';'Hash']
  vivify_195:
    set $P275, $P274[$P271]
    unless_null $P275, vivify_196
    new $P275, "Undef"
  vivify_196:
    unless $P275, if_270_end
.annotate 'line', 81
    new $P276, "String"
    assign $P276, "This class already has a method named "
    find_lex $P277, "$name"
    concat $P278, $P276, $P277
    die $P278
  if_270_end:
.annotate 'line', 83
    find_lex $P279, "$code_obj"
    find_lex $P280, "$name"
    find_lex $P281, "self"
    get_global $P282, "$?CLASS"
    getattribute $P283, $P281, $P282, "%!methods"
    unless_null $P283, vivify_197
    $P283 = root_new ['parrot';'Hash']
    setattribute $P281, $P282, "%!methods", $P283
  vivify_197:
    set $P283[$P280], $P279
.annotate 'line', 79
    .return ($P279)
.end


.namespace ["NQPClassHOW"]
.sub "add_multi_method"  :subid("30_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_285
    .param pmc param_286
    .param pmc param_287
    .param pmc param_288
.annotate 'line', 86
    .lex "self", param_285
    .lex "$obj", param_286
    .lex "$name", param_287
    .lex "$code_obj", param_288
.annotate 'line', 92
    $P289 = root_new ['parrot';'Hash']
    .lex "%todo", $P289
.annotate 'line', 86
    find_lex $P290, "%todo"
.annotate 'line', 93
    find_lex $P291, "$name"
    find_lex $P292, "%todo"
    unless_null $P292, vivify_198
    $P292 = root_new ['parrot';'Hash']
    store_lex "%todo", $P292
  vivify_198:
    set $P292["name"], $P291
.annotate 'line', 94
    find_lex $P293, "$code_obj"
    find_lex $P294, "%todo"
    unless_null $P294, vivify_199
    $P294 = root_new ['parrot';'Hash']
    store_lex "%todo", $P294
  vivify_199:
    set $P294["code"], $P293
.annotate 'line', 95
    find_lex $P295, "%todo"
    find_lex $P296, "self"
    get_global $P297, "$?CLASS"
    getattribute $P298, $P296, $P297, "@!multi_methods_to_incorporate"
    unless_null $P298, vivify_200
    $P298 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $N299, $P298
    set $I300, $N299
    find_lex $P301, "self"
    get_global $P302, "$?CLASS"
    getattribute $P303, $P301, $P302, "@!multi_methods_to_incorporate"
    unless_null $P303, vivify_201
    $P303 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P301, $P302, "@!multi_methods_to_incorporate", $P303
  vivify_201:
    set $P303[$I300], $P295
    find_lex $P304, "$code_obj"
.annotate 'line', 86
    .return ($P304)
.end


.namespace ["NQPClassHOW"]
.sub "add_attribute"  :subid("31_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_306
    .param pmc param_307
    .param pmc param_308
.annotate 'line', 99
    .lex "self", param_306
    .lex "$obj", param_307
    .lex "$meta_attr", param_308
.annotate 'line', 100
    new $P309, "Undef"
    .lex "$name", $P309
    find_lex $P310, "$meta_attr"
    $P311 = $P310."name"()
    store_lex "$name", $P311
.annotate 'line', 101
    find_lex $P313, "$name"
    find_lex $P314, "self"
    get_global $P315, "$?CLASS"
    getattribute $P316, $P314, $P315, "%!attributes"
    unless_null $P316, vivify_202
    $P316 = root_new ['parrot';'Hash']
  vivify_202:
    set $P317, $P316[$P313]
    unless_null $P317, vivify_203
    new $P317, "Undef"
  vivify_203:
    unless $P317, if_312_end
.annotate 'line', 102
    new $P318, "String"
    assign $P318, "This class already has an attribute named "
    find_lex $P319, "$name"
    concat $P320, $P318, $P319
    die $P320
  if_312_end:
.annotate 'line', 104
    find_lex $P321, "$meta_attr"
    find_lex $P322, "$name"
    find_lex $P323, "self"
    get_global $P324, "$?CLASS"
    getattribute $P325, $P323, $P324, "%!attributes"
    unless_null $P325, vivify_204
    $P325 = root_new ['parrot';'Hash']
    setattribute $P323, $P324, "%!attributes", $P325
  vivify_204:
    set $P325[$P322], $P321
.annotate 'line', 99
    .return ($P321)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_parent"  :subid("32_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_327
    .param pmc param_328
    .param pmc param_329
.annotate 'line', 107
    .const 'Sub' $P341 = "33_1297619303.875" 
    capture_lex $P341
    .lex "self", param_327
    .lex "$obj", param_328
    .lex "$parent", param_329
.annotate 'line', 108
    find_lex $P331, "self"
    get_global $P332, "$?CLASS"
    getattribute $P333, $P331, $P332, "$!composed"
    unless_null $P333, vivify_205
    new $P333, "Undef"
  vivify_205:
    unless $P333, if_330_end
.annotate 'line', 109
    die "NQPClassHOW does not support adding parents after being composed."
  if_330_end:
.annotate 'line', 111
    find_lex $P335, "self"
    get_global $P336, "$?CLASS"
    getattribute $P337, $P335, $P336, "@!parents"
    unless_null $P337, vivify_206
    $P337 = root_new ['parrot';'ResizablePMCArray']
  vivify_206:
    defined $I338, $P337
    unless $I338, for_undef_207
    iter $P334, $P337
    new $P353, 'ExceptionHandler'
    set_label $P353, loop352_handler
    $P353."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P353
  loop352_test:
    unless $P334, loop352_done
    shift $P339, $P334
  loop352_redo:
    .const 'Sub' $P341 = "33_1297619303.875" 
    capture_lex $P341
    $P341($P339)
  loop352_next:
    goto loop352_test
  loop352_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P354, exception, 'type'
    eq $P354, .CONTROL_LOOP_NEXT, loop352_next
    eq $P354, .CONTROL_LOOP_REDO, loop352_redo
  loop352_done:
    pop_eh 
  for_undef_207:
.annotate 'line', 116
    find_lex $P355, "$parent"
    find_lex $P356, "self"
    get_global $P357, "$?CLASS"
    getattribute $P358, $P356, $P357, "@!parents"
    unless_null $P358, vivify_208
    $P358 = root_new ['parrot';'ResizablePMCArray']
  vivify_208:
    set $N359, $P358
    set $I360, $N359
    find_lex $P361, "self"
    get_global $P362, "$?CLASS"
    getattribute $P363, $P361, $P362, "@!parents"
    unless_null $P363, vivify_209
    $P363 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P361, $P362, "@!parents", $P363
  vivify_209:
    set $P363[$I360], $P355
.annotate 'line', 107
    .return ($P355)
.end


.namespace ["NQPClassHOW"]
.sub "_block340"  :anon :subid("33_1297619303.875") :outer("32_1297619303.875")
    .param pmc param_342
.annotate 'line', 111
    .lex "$_", param_342
.annotate 'line', 112
    find_lex $P345, "$_"
    find_lex $P346, "$parent"
    issame $I347, $P345, $P346
    if $I347, if_344
    new $P343, 'Integer'
    set $P343, $I347
    goto if_344_end
  if_344:
.annotate 'line', 113
    new $P348, "String"
    assign $P348, "Already have "
    find_lex $P349, "$parent"
    concat $P350, $P348, $P349
    concat $P351, $P350, " as a parent class."
    die $P351
  if_344_end:
.annotate 'line', 111
    .return ($P343)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_role"  :subid("34_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_365
    .param pmc param_366
    .param pmc param_367
.annotate 'line', 119
    .const 'Sub' $P375 = "35_1297619303.875" 
    capture_lex $P375
    .lex "self", param_365
    .lex "$obj", param_366
    .lex "$role", param_367
.annotate 'line', 120
    find_lex $P369, "self"
    get_global $P370, "$?CLASS"
    getattribute $P371, $P369, $P370, "@!roles"
    unless_null $P371, vivify_210
    $P371 = root_new ['parrot';'ResizablePMCArray']
  vivify_210:
    defined $I372, $P371
    unless $I372, for_undef_211
    iter $P368, $P371
    new $P387, 'ExceptionHandler'
    set_label $P387, loop386_handler
    $P387."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P387
  loop386_test:
    unless $P368, loop386_done
    shift $P373, $P368
  loop386_redo:
    .const 'Sub' $P375 = "35_1297619303.875" 
    capture_lex $P375
    $P375($P373)
  loop386_next:
    goto loop386_test
  loop386_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P388, exception, 'type'
    eq $P388, .CONTROL_LOOP_NEXT, loop386_next
    eq $P388, .CONTROL_LOOP_REDO, loop386_redo
  loop386_done:
    pop_eh 
  for_undef_211:
.annotate 'line', 125
    find_lex $P389, "$role"
    find_lex $P390, "self"
    get_global $P391, "$?CLASS"
    getattribute $P392, $P390, $P391, "@!roles"
    unless_null $P392, vivify_212
    $P392 = root_new ['parrot';'ResizablePMCArray']
  vivify_212:
    set $N393, $P392
    set $I394, $N393
    find_lex $P395, "self"
    get_global $P396, "$?CLASS"
    getattribute $P397, $P395, $P396, "@!roles"
    unless_null $P397, vivify_213
    $P397 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P395, $P396, "@!roles", $P397
  vivify_213:
    set $P397[$I394], $P389
.annotate 'line', 119
    .return ($P389)
.end


.namespace ["NQPClassHOW"]
.sub "_block374"  :anon :subid("35_1297619303.875") :outer("34_1297619303.875")
    .param pmc param_376
.annotate 'line', 120
    .lex "$_", param_376
.annotate 'line', 121
    find_lex $P379, "$_"
    find_lex $P380, "$role"
    issame $I381, $P379, $P380
    if $I381, if_378
    new $P377, 'Integer'
    set $P377, $I381
    goto if_378_end
  if_378:
.annotate 'line', 122
    new $P382, "String"
    assign $P382, "The role "
    find_lex $P383, "$role"
    concat $P384, $P382, $P383
    concat $P385, $P384, " has already been added."
    die $P385
  if_378_end:
.annotate 'line', 120
    .return ($P377)
.end


.namespace ["NQPClassHOW"]
.sub "add_parrot_vtable_mapping"  :subid("36_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_399
    .param pmc param_400
    .param pmc param_401
    .param pmc param_402
.annotate 'line', 128
    .lex "self", param_399
    .lex "$obj", param_400
    .lex "$name", param_401
    .lex "$meth", param_402
.annotate 'line', 129
    find_lex $P404, "$name"
    find_lex $P405, "self"
    get_global $P406, "$?CLASS"
    getattribute $P407, $P405, $P406, "%!parrot_vtable_mapping"
    unless_null $P407, vivify_214
    $P407 = root_new ['parrot';'Hash']
  vivify_214:
    set $P408, $P407[$P404]
    unless_null $P408, vivify_215
    new $P408, "Undef"
  vivify_215:
    defined $I409, $P408
    unless $I409, if_403_end
.annotate 'line', 130
    new $P410, "String"
    assign $P410, "Class '"
    find_lex $P411, "self"
    get_global $P412, "$?CLASS"
    getattribute $P413, $P411, $P412, "$!name"
    unless_null $P413, vivify_216
    new $P413, "Undef"
  vivify_216:
    concat $P414, $P410, $P413
    concat $P415, $P414, "' already has a Parrot v-table override for '"
    find_lex $P416, "$name"
    concat $P417, $P415, $P416
.annotate 'line', 131
    concat $P418, $P417, "'"
.annotate 'line', 132
    die $P418
  if_403_end:
.annotate 'line', 134
    find_lex $P419, "$meth"
    find_lex $P420, "$name"
    find_lex $P421, "self"
    get_global $P422, "$?CLASS"
    getattribute $P423, $P421, $P422, "%!parrot_vtable_mapping"
    unless_null $P423, vivify_217
    $P423 = root_new ['parrot';'Hash']
    setattribute $P421, $P422, "%!parrot_vtable_mapping", $P423
  vivify_217:
    set $P423[$P420], $P419
.annotate 'line', 128
    .return ($P419)
.end


.namespace ["NQPClassHOW"]
.sub "compose"  :subid("37_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_425
    .param pmc param_426
.annotate 'line', 137
    .const 'Sub' $P432 = "38_1297619303.875" 
    capture_lex $P432
    .lex "self", param_425
    .lex "$obj", param_426
.annotate 'line', 141
    find_lex $P428, "self"
    get_global $P429, "$?CLASS"
    getattribute $P430, $P428, $P429, "@!roles"
    unless_null $P430, vivify_218
    $P430 = root_new ['parrot';'ResizablePMCArray']
  vivify_218:
    unless $P430, if_427_end
    .const 'Sub' $P432 = "38_1297619303.875" 
    capture_lex $P432
    $P432()
  if_427_end:
.annotate 'line', 154
    find_lex $P480, "self"
    get_global $P481, "$?CLASS"
    getattribute $P482, $P480, $P481, "@!parents"
    unless_null $P482, vivify_225
    $P482 = root_new ['parrot';'ResizablePMCArray']
  vivify_225:
    set $N483, $P482
    iseq $I484, $N483, 0.0
    if $I484, if_479
    new $P478, 'Integer'
    set $P478, $I484
    goto if_479_end
  if_479:
    find_lex $P485, "self"
    get_global $P486, "$?CLASS"
    getattribute $P487, $P485, $P486, "$!name"
    unless_null $P487, vivify_226
    new $P487, "Undef"
  vivify_226:
    set $S488, $P487
    isne $I489, $S488, "NQPMu"
    new $P478, 'Integer'
    set $P478, $I489
  if_479_end:
    unless $P478, if_477_end
.annotate 'line', 155
    find_lex $P490, "self"
    find_lex $P491, "$obj"
    get_hll_global $P492, "NQPMu"
    $P490."add_parent"($P491, $P492)
  if_477_end:
.annotate 'line', 160
    find_lex $P494, "self"
    get_global $P495, "$?CLASS"
    getattribute $P496, $P494, $P495, "$!composed"
    unless_null $P496, vivify_227
    new $P496, "Undef"
  vivify_227:
    if $P496, unless_493_end
.annotate 'line', 161
    find_lex $P497, "$obj"
    $P498 = "compute_c3_mro"($P497)
    find_lex $P499, "self"
    get_global $P500, "$?CLASS"
    setattribute $P499, $P500, "@!mro", $P498
.annotate 'line', 162
    new $P501, "Integer"
    assign $P501, 1
    find_lex $P502, "self"
    get_global $P503, "$?CLASS"
    setattribute $P502, $P503, "$!composed", $P501
  unless_493_end:
.annotate 'line', 166
    find_lex $P504, "self"
    find_lex $P505, "$obj"
    $P504."incorporate_multi_candidates"($P505)
.annotate 'line', 169
    find_lex $P506, "self"
    find_lex $P507, "$obj"
    $P506."publish_type_cache"($P507)
.annotate 'line', 170
    find_lex $P508, "self"
    find_lex $P509, "$obj"
    $P508."publish_method_cache"($P509)
.annotate 'line', 173
    find_lex $P511, "self"
    get_global $P512, "$?CLASS"
    getattribute $P513, $P511, $P512, "%!parrot_vtable_mapping"
    unless_null $P513, vivify_228
    $P513 = root_new ['parrot';'Hash']
  vivify_228:
    set $N514, $P513
    unless $N514, if_510_end
.annotate 'line', 174
    find_lex $P515, "$obj"
    find_lex $P516, "self"
    get_global $P517, "$?CLASS"
    getattribute $P518, $P516, $P517, "%!parrot_vtable_mapping"
    unless_null $P518, vivify_229
    $P518 = root_new ['parrot';'Hash']
  vivify_229:
    stable_publish_vtable_mapping $P515, $P518
  if_510_end:
.annotate 'line', 173
    find_lex $P519, "$obj"
.annotate 'line', 137
    .return ($P519)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block431"  :anon :subid("38_1297619303.875") :outer("37_1297619303.875")
.annotate 'line', 141
    .const 'Sub' $P442 = "39_1297619303.875" 
    capture_lex $P442
.annotate 'line', 142
    $P433 = root_new ['parrot';'ResizablePMCArray']
    .lex "@instantiated_roles", $P433
.annotate 'line', 141
    find_lex $P434, "@instantiated_roles"
.annotate 'line', 143
    find_lex $P436, "self"
    get_global $P437, "$?CLASS"
    getattribute $P438, $P436, $P437, "@!roles"
    unless_null $P438, vivify_219
    $P438 = root_new ['parrot';'ResizablePMCArray']
  vivify_219:
    defined $I439, $P438
    unless $I439, for_undef_220
    iter $P435, $P438
    new $P471, 'ExceptionHandler'
    set_label $P471, loop470_handler
    $P471."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P471
  loop470_test:
    unless $P435, loop470_done
    shift $P440, $P435
  loop470_redo:
    .const 'Sub' $P442 = "39_1297619303.875" 
    capture_lex $P442
    $P442($P440)
  loop470_next:
    goto loop470_test
  loop470_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P472, exception, 'type'
    eq $P472, .CONTROL_LOOP_NEXT, loop470_next
    eq $P472, .CONTROL_LOOP_REDO, loop470_redo
  loop470_done:
    pop_eh 
  for_undef_220:
.annotate 'line', 149
    get_hll_global $P473, "RoleToClassApplier"
    find_lex $P474, "$obj"
    find_lex $P475, "@instantiated_roles"
    $P476 = $P473."apply"($P474, $P475)
.annotate 'line', 141
    .return ($P476)
.end


.namespace ["NQPClassHOW"]
.sub "_block441"  :anon :subid("39_1297619303.875") :outer("38_1297619303.875")
    .param pmc param_444
.annotate 'line', 144
    new $P443, "Undef"
    .lex "$ins", $P443
    .lex "$_", param_444
    find_lex $P445, "$_"
    get_how $P446, $P445
    find_lex $P447, "$_"
    find_lex $P448, "$obj"
    $P449 = $P446."instantiate"($P447, $P448)
    store_lex "$ins", $P449
.annotate 'line', 145
    find_lex $P450, "@instantiated_roles"
    find_lex $P451, "$ins"
    $P450."push"($P451)
.annotate 'line', 146
    find_lex $P452, "$_"
    find_lex $P453, "self"
    get_global $P454, "$?CLASS"
    getattribute $P455, $P453, $P454, "@!done"
    unless_null $P455, vivify_221
    $P455 = root_new ['parrot';'ResizablePMCArray']
  vivify_221:
    set $N456, $P455
    set $I457, $N456
    find_lex $P458, "self"
    get_global $P459, "$?CLASS"
    getattribute $P460, $P458, $P459, "@!done"
    unless_null $P460, vivify_222
    $P460 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P458, $P459, "@!done", $P460
  vivify_222:
    set $P460[$I457], $P452
.annotate 'line', 147
    find_lex $P461, "$ins"
    find_lex $P462, "self"
    get_global $P463, "$?CLASS"
    getattribute $P464, $P462, $P463, "@!done"
    unless_null $P464, vivify_223
    $P464 = root_new ['parrot';'ResizablePMCArray']
  vivify_223:
    set $N465, $P464
    set $I466, $N465
    find_lex $P467, "self"
    get_global $P468, "$?CLASS"
    getattribute $P469, $P467, $P468, "@!done"
    unless_null $P469, vivify_224
    $P469 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P467, $P468, "@!done", $P469
  vivify_224:
    set $P469[$I466], $P461
.annotate 'line', 143
    .return ($P461)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "incorporate_multi_candidates"  :subid("40_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_521
    .param pmc param_522
.annotate 'line', 180
    .const 'Sub' $P537 = "41_1297619303.875" 
    capture_lex $P537
    .lex "self", param_521
    .lex "$obj", param_522
.annotate 'line', 181
    new $P523, "Undef"
    .lex "$num_todo", $P523
.annotate 'line', 182
    new $P524, "Undef"
    .lex "$i", $P524
.annotate 'line', 181
    find_lex $P525, "self"
    get_global $P526, "$?CLASS"
    getattribute $P527, $P525, $P526, "@!multi_methods_to_incorporate"
    unless_null $P527, vivify_230
    $P527 = root_new ['parrot';'ResizablePMCArray']
  vivify_230:
    set $N528, $P527
    new $P529, 'Float'
    set $P529, $N528
    store_lex "$num_todo", $P529
.annotate 'line', 182
    new $P530, "Integer"
    assign $P530, 0
    store_lex "$i", $P530
.annotate 'line', 183
    new $P646, 'ExceptionHandler'
    set_label $P646, loop645_handler
    $P646."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P646
  loop645_test:
    find_lex $P531, "$i"
    set $N532, $P531
    find_lex $P533, "$num_todo"
    set $N534, $P533
    isne $I535, $N532, $N534
    unless $I535, loop645_done
  loop645_redo:
    .const 'Sub' $P537 = "41_1297619303.875" 
    capture_lex $P537
    $P537()
  loop645_next:
    goto loop645_test
  loop645_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P647, exception, 'type'
    eq $P647, .CONTROL_LOOP_NEXT, loop645_next
    eq $P647, .CONTROL_LOOP_REDO, loop645_redo
  loop645_done:
    pop_eh 
.annotate 'line', 180
    .return ($I535)
.end


.namespace ["NQPClassHOW"]
.sub "_block536"  :anon :subid("41_1297619303.875") :outer("40_1297619303.875")
.annotate 'line', 183
    .const 'Sub' $P573 = "42_1297619303.875" 
    capture_lex $P573
.annotate 'line', 185
    new $P538, "Undef"
    .lex "$name", $P538
.annotate 'line', 186
    new $P539, "Undef"
    .lex "$code", $P539
.annotate 'line', 190
    new $P540, "Undef"
    .lex "$dispatcher", $P540
.annotate 'line', 185
    find_lex $P541, "$i"
    set $I542, $P541
    find_lex $P543, "self"
    get_global $P544, "$?CLASS"
    getattribute $P545, $P543, $P544, "@!multi_methods_to_incorporate"
    unless_null $P545, vivify_231
    $P545 = root_new ['parrot';'ResizablePMCArray']
  vivify_231:
    set $P546, $P545[$I542]
    unless_null $P546, vivify_232
    $P546 = root_new ['parrot';'Hash']
  vivify_232:
    set $P547, $P546["name"]
    unless_null $P547, vivify_233
    new $P547, "Undef"
  vivify_233:
    store_lex "$name", $P547
.annotate 'line', 186
    find_lex $P548, "$i"
    set $I549, $P548
    find_lex $P550, "self"
    get_global $P551, "$?CLASS"
    getattribute $P552, $P550, $P551, "@!multi_methods_to_incorporate"
    unless_null $P552, vivify_234
    $P552 = root_new ['parrot';'ResizablePMCArray']
  vivify_234:
    set $P553, $P552[$I549]
    unless_null $P553, vivify_235
    $P553 = root_new ['parrot';'Hash']
  vivify_235:
    set $P554, $P553["code"]
    unless_null $P554, vivify_236
    new $P554, "Undef"
  vivify_236:
    store_lex "$code", $P554
.annotate 'line', 190
    find_lex $P555, "$name"
    find_lex $P556, "self"
    get_global $P557, "$?CLASS"
    getattribute $P558, $P556, $P557, "%!methods"
    unless_null $P558, vivify_237
    $P558 = root_new ['parrot';'Hash']
  vivify_237:
    set $P559, $P558[$P555]
    unless_null $P559, vivify_238
    new $P559, "Undef"
  vivify_238:
    store_lex "$dispatcher", $P559
.annotate 'line', 191
    find_lex $P561, "$dispatcher"
    defined $I562, $P561
    if $I562, if_560
.annotate 'line', 201
    .const 'Sub' $P573 = "42_1297619303.875" 
    capture_lex $P573
    $P573()
    goto if_560_end
  if_560:
.annotate 'line', 194
    find_lex $P564, "$dispatcher"
    is_dispatcher $I565, $P564
    if $I565, if_563
.annotate 'line', 198
    new $P568, 'String'
    set $P568, "Cannot have a multi candidate for "
    find_lex $P569, "$name"
    concat $P570, $P568, $P569
    concat $P571, $P570, " when an only method is also in the class"
    die $P571
.annotate 'line', 197
    goto if_563_end
  if_563:
.annotate 'line', 195
    find_lex $P566, "$dispatcher"
    find_lex $P567, "$code"
    push_dispatchee $P566, $P567
  if_563_end:
  if_560_end:
.annotate 'line', 229
    find_lex $P643, "$i"
    add $P644, $P643, 1
    store_lex "$i", $P644
.annotate 'line', 183
    .return ($P644)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block572"  :anon :subid("42_1297619303.875") :outer("41_1297619303.875")
.annotate 'line', 201
    .const 'Sub' $P590 = "43_1297619303.875" 
    capture_lex $P590
.annotate 'line', 203
    new $P574, "Undef"
    .lex "$j", $P574
.annotate 'line', 204
    new $P575, "Undef"
    .lex "$found", $P575
.annotate 'line', 203
    new $P576, "Integer"
    assign $P576, 1
    store_lex "$j", $P576
.annotate 'line', 204
    new $P577, "Integer"
    assign $P577, 0
    store_lex "$found", $P577
.annotate 'line', 205
    new $P634, 'ExceptionHandler'
    set_label $P634, loop633_handler
    $P634."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P634
  loop633_test:
    find_lex $P580, "$j"
    set $N581, $P580
    find_lex $P582, "self"
    get_global $P583, "$?CLASS"
    getattribute $P584, $P582, $P583, "@!mro"
    unless_null $P584, vivify_239
    $P584 = root_new ['parrot';'ResizablePMCArray']
  vivify_239:
    set $N585, $P584
    isne $I586, $N581, $N585
    if $I586, if_579
    new $P578, 'Integer'
    set $P578, $I586
    goto if_579_end
  if_579:
    find_lex $P587, "$found"
    isfalse $I588, $P587
    new $P578, 'Integer'
    set $P578, $I588
  if_579_end:
    unless $P578, loop633_done
  loop633_redo:
    .const 'Sub' $P590 = "43_1297619303.875" 
    capture_lex $P590
    $P590()
  loop633_next:
    goto loop633_test
  loop633_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P635, exception, 'type'
    eq $P635, .CONTROL_LOOP_NEXT, loop633_next
    eq $P635, .CONTROL_LOOP_REDO, loop633_redo
  loop633_done:
    pop_eh 
.annotate 'line', 225
    find_lex $P638, "$found"
    unless $P638, unless_637
    set $P636, $P638
    goto unless_637_end
  unless_637:
.annotate 'line', 226
    new $P639, 'String'
    set $P639, "Could not find a proto for multi "
    find_lex $P640, "$name"
    concat $P641, $P639, $P640
    concat $P642, $P641, ", and proto generation is NYI"
    die $P642
  unless_637_end:
.annotate 'line', 201
    .return ($P636)
.end


.namespace ["NQPClassHOW"]
.sub "_block589"  :anon :subid("43_1297619303.875") :outer("42_1297619303.875")
.annotate 'line', 205
    .const 'Sub' $P614 = "44_1297619303.875" 
    capture_lex $P614
.annotate 'line', 206
    new $P591, "Undef"
    .lex "$parent", $P591
.annotate 'line', 207
    $P592 = root_new ['parrot';'Hash']
    .lex "%meths", $P592
.annotate 'line', 208
    new $P593, "Undef"
    .lex "$dispatcher", $P593
.annotate 'line', 206
    find_lex $P594, "$j"
    set $I595, $P594
    find_lex $P596, "self"
    get_global $P597, "$?CLASS"
    getattribute $P598, $P596, $P597, "@!mro"
    unless_null $P598, vivify_240
    $P598 = root_new ['parrot';'ResizablePMCArray']
  vivify_240:
    set $P599, $P598[$I595]
    unless_null $P599, vivify_241
    new $P599, "Undef"
  vivify_241:
    store_lex "$parent", $P599
.annotate 'line', 207
    find_lex $P600, "$parent"
    get_how $P601, $P600
    find_lex $P602, "$parent"
    $P603 = $P601."method_table"($P602)
    store_lex "%meths", $P603
.annotate 'line', 208
    find_lex $P604, "$name"
    find_lex $P605, "%meths"
    unless_null $P605, vivify_242
    $P605 = root_new ['parrot';'Hash']
  vivify_242:
    set $P606, $P605[$P604]
    unless_null $P606, vivify_243
    new $P606, "Undef"
  vivify_243:
    store_lex "$dispatcher", $P606
.annotate 'line', 209
    find_lex $P608, "$dispatcher"
    defined $I609, $P608
    unless $I609, if_607_end
.annotate 'line', 212
    find_lex $P611, "$dispatcher"
    is_dispatcher $I612, $P611
    if $I612, if_610
.annotate 'line', 220
    new $P627, 'String'
    set $P627, "Could not find a proto for multi "
    find_lex $P628, "$name"
    concat $P629, $P627, $P628
    concat $P630, $P629, " (it may exist, but an only is hiding it if so)"
    die $P630
.annotate 'line', 219
    goto if_610_end
  if_610:
.annotate 'line', 212
    .const 'Sub' $P614 = "44_1297619303.875" 
    capture_lex $P614
    $P614()
  if_610_end:
  if_607_end:
.annotate 'line', 223
    find_lex $P631, "$j"
    add $P632, $P631, 1
    store_lex "$j", $P632
.annotate 'line', 205
    .return ($P632)
.end


.namespace ["NQPClassHOW"]
.sub "_block613"  :anon :subid("44_1297619303.875") :outer("43_1297619303.875")
.annotate 'line', 214
    $P615 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_dispatchees", $P615
.annotate 'line', 212
    find_lex $P616, "@new_dispatchees"
.annotate 'line', 215
    find_lex $P617, "$code"
    find_lex $P618, "@new_dispatchees"
    unless_null $P618, vivify_244
    $P618 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@new_dispatchees", $P618
  vivify_244:
    set $P618[0], $P617
.annotate 'line', 216
    find_lex $P619, "$dispatcher"
    find_lex $P620, "@new_dispatchees"
    create_dispatch_and_add_candidates $P621, $P619, $P620
    find_lex $P622, "$name"
    find_lex $P623, "self"
    get_global $P624, "$?CLASS"
    getattribute $P625, $P623, $P624, "%!methods"
    unless_null $P625, vivify_245
    $P625 = root_new ['parrot';'Hash']
    setattribute $P623, $P624, "%!methods", $P625
  vivify_245:
    set $P625[$P622], $P621
.annotate 'line', 217
    new $P626, "Integer"
    assign $P626, 1
    store_lex "$found", $P626
.annotate 'line', 212
    .return ($P626)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_type_cache"  :subid("45_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_651
    .param pmc param_652
.annotate 'line', 322
    .const 'Sub' $P677 = "47_1297619303.875" 
    capture_lex $P677
    .const 'Sub' $P662 = "46_1297619303.875" 
    capture_lex $P662
    .lex "self", param_651
    .lex "$obj", param_652
.annotate 'line', 323
    $P653 = root_new ['parrot';'ResizablePMCArray']
    .lex "@tc", $P653
.annotate 'line', 322
    find_lex $P654, "@tc"
.annotate 'line', 324
    find_lex $P656, "self"
    get_global $P657, "$?CLASS"
    getattribute $P658, $P656, $P657, "@!mro"
    unless_null $P658, vivify_246
    $P658 = root_new ['parrot';'ResizablePMCArray']
  vivify_246:
    defined $I659, $P658
    unless $I659, for_undef_247
    iter $P655, $P658
    new $P668, 'ExceptionHandler'
    set_label $P668, loop667_handler
    $P668."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P668
  loop667_test:
    unless $P655, loop667_done
    shift $P660, $P655
  loop667_redo:
    .const 'Sub' $P662 = "46_1297619303.875" 
    capture_lex $P662
    $P662($P660)
  loop667_next:
    goto loop667_test
  loop667_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P669, exception, 'type'
    eq $P669, .CONTROL_LOOP_NEXT, loop667_next
    eq $P669, .CONTROL_LOOP_REDO, loop667_redo
  loop667_done:
    pop_eh 
  for_undef_247:
.annotate 'line', 325
    find_lex $P671, "self"
    get_global $P672, "$?CLASS"
    getattribute $P673, $P671, $P672, "@!done"
    unless_null $P673, vivify_248
    $P673 = root_new ['parrot';'ResizablePMCArray']
  vivify_248:
    defined $I674, $P673
    unless $I674, for_undef_249
    iter $P670, $P673
    new $P683, 'ExceptionHandler'
    set_label $P683, loop682_handler
    $P683."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P683
  loop682_test:
    unless $P670, loop682_done
    shift $P675, $P670
  loop682_redo:
    .const 'Sub' $P677 = "47_1297619303.875" 
    capture_lex $P677
    $P677($P675)
  loop682_next:
    goto loop682_test
  loop682_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P684, exception, 'type'
    eq $P684, .CONTROL_LOOP_NEXT, loop682_next
    eq $P684, .CONTROL_LOOP_REDO, loop682_redo
  loop682_done:
    pop_eh 
  for_undef_249:
.annotate 'line', 326
    find_lex $P685, "$obj"
    find_lex $P686, "@tc"
    publish_type_check_cache $P685, $P686
.annotate 'line', 322
    .return ()
.end


.namespace ["NQPClassHOW"]
.sub "_block661"  :anon :subid("46_1297619303.875") :outer("45_1297619303.875")
    .param pmc param_663
.annotate 'line', 324
    .lex "$_", param_663
    find_lex $P664, "@tc"
    find_lex $P665, "$_"
    $P666 = $P664."push"($P665)
    .return ($P666)
.end


.namespace ["NQPClassHOW"]
.sub "_block676"  :anon :subid("47_1297619303.875") :outer("45_1297619303.875")
    .param pmc param_678
.annotate 'line', 325
    .lex "$_", param_678
    find_lex $P679, "@tc"
    find_lex $P680, "$_"
    $P681 = $P679."push"($P680)
    .return ($P681)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_method_cache"  :subid("48_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_688
    .param pmc param_689
.annotate 'line', 329
    .const 'Sub' $P699 = "49_1297619303.875" 
    capture_lex $P699
    .lex "self", param_688
    .lex "$obj", param_689
.annotate 'line', 332
    $P690 = root_new ['parrot';'Hash']
    .lex "%cache", $P690
.annotate 'line', 329
    find_lex $P691, "%cache"
.annotate 'line', 333
    find_lex $P693, "self"
    get_global $P694, "$?CLASS"
    getattribute $P695, $P693, $P694, "@!mro"
    unless_null $P695, vivify_250
    $P695 = root_new ['parrot';'ResizablePMCArray']
  vivify_250:
    defined $I696, $P695
    unless $I696, for_undef_251
    iter $P692, $P695
    new $P728, 'ExceptionHandler'
    set_label $P728, loop727_handler
    $P728."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P728
  loop727_test:
    unless $P692, loop727_done
    shift $P697, $P692
  loop727_redo:
    .const 'Sub' $P699 = "49_1297619303.875" 
    capture_lex $P699
    $P699($P697)
  loop727_next:
    goto loop727_test
  loop727_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P729, exception, 'type'
    eq $P729, .CONTROL_LOOP_NEXT, loop727_next
    eq $P729, .CONTROL_LOOP_REDO, loop727_redo
  loop727_done:
    pop_eh 
  for_undef_251:
.annotate 'line', 341
    find_lex $P730, "$obj"
    find_lex $P731, "%cache"
    publish_method_cache $P730, $P731
.annotate 'line', 329
    .return ()
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block698"  :anon :subid("49_1297619303.875") :outer("48_1297619303.875")
    .param pmc param_701
.annotate 'line', 333
    .const 'Sub' $P711 = "50_1297619303.875" 
    capture_lex $P711
.annotate 'line', 334
    $P700 = root_new ['parrot';'Hash']
    .lex "%methods", $P700
    .lex "$_", param_701
    find_lex $P702, "$_"
    get_how $P703, $P702
    find_lex $P704, "$_"
    $P705 = $P703."method_table"($P704)
    store_lex "%methods", $P705
.annotate 'line', 335
    find_lex $P707, "%methods"
    defined $I708, $P707
    unless $I708, for_undef_252
    iter $P706, $P707
    new $P725, 'ExceptionHandler'
    set_label $P725, loop724_handler
    $P725."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P725
  loop724_test:
    unless $P706, loop724_done
    shift $P709, $P706
  loop724_redo:
    .const 'Sub' $P711 = "50_1297619303.875" 
    capture_lex $P711
    $P711($P709)
  loop724_next:
    goto loop724_test
  loop724_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P726, exception, 'type'
    eq $P726, .CONTROL_LOOP_NEXT, loop724_next
    eq $P726, .CONTROL_LOOP_REDO, loop724_redo
  loop724_done:
    pop_eh 
  for_undef_252:
.annotate 'line', 333
    .return ($P706)
.end


.namespace ["NQPClassHOW"]
.sub "_block710"  :anon :subid("50_1297619303.875") :outer("49_1297619303.875")
    .param pmc param_712
.annotate 'line', 335
    .lex "$_", param_712
.annotate 'line', 336
    find_lex $P715, "$_"
    $P716 = $P715."key"()
    find_lex $P717, "%cache"
    unless_null $P717, vivify_253
    $P717 = root_new ['parrot';'Hash']
  vivify_253:
    set $P718, $P717[$P716]
    unless_null $P718, vivify_254
    new $P718, "Undef"
  vivify_254:
    unless $P718, unless_714
    set $P713, $P718
    goto unless_714_end
  unless_714:
.annotate 'line', 337
    find_lex $P719, "$_"
    $P720 = $P719."value"()
    find_lex $P721, "$_"
    $P722 = $P721."key"()
    find_lex $P723, "%cache"
    unless_null $P723, vivify_255
    $P723 = root_new ['parrot';'Hash']
    store_lex "%cache", $P723
  vivify_255:
    set $P723[$P722], $P720
.annotate 'line', 336
    set $P713, $P720
  unless_714_end:
.annotate 'line', 335
    .return ($P713)
.end


.namespace ["NQPClassHOW"]
.sub "parents"  :subid("51_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_733
    .param pmc param_734
    .param pmc param_735 :optional :named("local")
    .param int has_param_735 :opt_flag
.annotate 'line', 348
    .lex "self", param_733
    .lex "$obj", param_734
    if has_param_735, optparam_256
    new $P736, "Undef"
    set param_735, $P736
  optparam_256:
    .lex "$local", param_735
.annotate 'line', 349
    find_lex $P739, "$local"
    if $P739, if_738
    find_lex $P743, "self"
    get_global $P744, "$?CLASS"
    getattribute $P745, $P743, $P744, "@!mro"
    unless_null $P745, vivify_257
    $P745 = root_new ['parrot';'ResizablePMCArray']
  vivify_257:
    set $P737, $P745
    goto if_738_end
  if_738:
    find_lex $P740, "self"
    get_global $P741, "$?CLASS"
    getattribute $P742, $P740, $P741, "@!parents"
    unless_null $P742, vivify_258
    $P742 = root_new ['parrot';'ResizablePMCArray']
  vivify_258:
    set $P737, $P742
  if_738_end:
.annotate 'line', 348
    .return ($P737)
.end


.namespace ["NQPClassHOW"]
.sub "roles"  :subid("52_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_747
    .param pmc param_748
    .param pmc param_749 :named("local")
.annotate 'line', 352
    .lex "self", param_747
    .lex "$obj", param_748
    .lex "$local", param_749
    find_lex $P750, "self"
    get_global $P751, "$?CLASS"
    getattribute $P752, $P750, $P751, "@!roles"
    unless_null $P752, vivify_259
    $P752 = root_new ['parrot';'ResizablePMCArray']
  vivify_259:
    .return ($P752)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("53_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_754
    .param pmc param_755
    .param pmc param_756 :named("local")
.annotate 'line', 356
    .const 'Sub' $P766 = "54_1297619303.875" 
    capture_lex $P766
    .lex "self", param_754
    .lex "$obj", param_755
    .lex "$local", param_756
.annotate 'line', 357
    $P757 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P757
.annotate 'line', 356
    find_lex $P758, "@meths"
.annotate 'line', 358
    find_lex $P760, "self"
    get_global $P761, "$?CLASS"
    getattribute $P762, $P760, $P761, "%!methods"
    unless_null $P762, vivify_260
    $P762 = root_new ['parrot';'Hash']
  vivify_260:
    defined $I763, $P762
    unless $I763, for_undef_261
    iter $P759, $P762
    new $P773, 'ExceptionHandler'
    set_label $P773, loop772_handler
    $P773."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P773
  loop772_test:
    unless $P759, loop772_done
    shift $P764, $P759
  loop772_redo:
    .const 'Sub' $P766 = "54_1297619303.875" 
    capture_lex $P766
    $P766($P764)
  loop772_next:
    goto loop772_test
  loop772_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P774, exception, 'type'
    eq $P774, .CONTROL_LOOP_NEXT, loop772_next
    eq $P774, .CONTROL_LOOP_REDO, loop772_redo
  loop772_done:
    pop_eh 
  for_undef_261:
    find_lex $P775, "@meths"
.annotate 'line', 356
    .return ($P775)
.end


.namespace ["NQPClassHOW"]
.sub "_block765"  :anon :subid("54_1297619303.875") :outer("53_1297619303.875")
    .param pmc param_767
.annotate 'line', 358
    .lex "$_", param_767
.annotate 'line', 359
    find_lex $P768, "@meths"
    find_lex $P769, "$_"
    $P770 = $P769."value"()
    $P771 = $P768."push"($P770)
.annotate 'line', 358
    .return ($P771)
.end


.namespace ["NQPClassHOW"]
.sub "method_table"  :subid("55_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_777
    .param pmc param_778
.annotate 'line', 364
    .lex "self", param_777
    .lex "$obj", param_778
    find_lex $P779, "self"
    get_global $P780, "$?CLASS"
    getattribute $P781, $P779, $P780, "%!methods"
    unless_null $P781, vivify_262
    $P781 = root_new ['parrot';'Hash']
  vivify_262:
    .return ($P781)
.end


.namespace ["NQPClassHOW"]
.sub "name"  :subid("56_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_783
    .param pmc param_784
.annotate 'line', 368
    .lex "self", param_783
    .lex "$obj", param_784
    find_lex $P785, "self"
    get_global $P786, "$?CLASS"
    getattribute $P787, $P785, $P786, "$!name"
    unless_null $P787, vivify_263
    new $P787, "Undef"
  vivify_263:
    .return ($P787)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("57_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_789
    .param pmc param_790
    .param pmc param_791 :named("local")
.annotate 'line', 372
    .const 'Sub' $P801 = "58_1297619303.875" 
    capture_lex $P801
    .lex "self", param_789
    .lex "$obj", param_790
    .lex "$local", param_791
.annotate 'line', 373
    $P792 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P792
.annotate 'line', 372
    find_lex $P793, "@attrs"
.annotate 'line', 374
    find_lex $P795, "self"
    get_global $P796, "$?CLASS"
    getattribute $P797, $P795, $P796, "%!attributes"
    unless_null $P797, vivify_264
    $P797 = root_new ['parrot';'Hash']
  vivify_264:
    defined $I798, $P797
    unless $I798, for_undef_265
    iter $P794, $P797
    new $P808, 'ExceptionHandler'
    set_label $P808, loop807_handler
    $P808."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P808
  loop807_test:
    unless $P794, loop807_done
    shift $P799, $P794
  loop807_redo:
    .const 'Sub' $P801 = "58_1297619303.875" 
    capture_lex $P801
    $P801($P799)
  loop807_next:
    goto loop807_test
  loop807_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P809, exception, 'type'
    eq $P809, .CONTROL_LOOP_NEXT, loop807_next
    eq $P809, .CONTROL_LOOP_REDO, loop807_redo
  loop807_done:
    pop_eh 
  for_undef_265:
    find_lex $P810, "@attrs"
.annotate 'line', 372
    .return ($P810)
.end


.namespace ["NQPClassHOW"]
.sub "_block800"  :anon :subid("58_1297619303.875") :outer("57_1297619303.875")
    .param pmc param_802
.annotate 'line', 374
    .lex "$_", param_802
.annotate 'line', 375
    find_lex $P803, "@attrs"
    find_lex $P804, "$_"
    $P805 = $P804."value"()
    $P806 = $P803."push"($P805)
.annotate 'line', 374
    .return ($P806)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "isa"  :subid("59_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_814
    .param pmc param_815
    .param pmc param_816
.annotate 'line', 384
    new $P813, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P813, control_812
    push_eh $P813
    .lex "self", param_814
    .lex "$obj", param_815
    .lex "$check", param_816
.annotate 'line', 385
    new $P817, "Undef"
    .lex "$check-class", $P817
.annotate 'line', 386
    new $P818, "Undef"
    .lex "$i", $P818
.annotate 'line', 385
    find_lex $P819, "$check"
    get_what $P820, $P819
    store_lex "$check-class", $P820
.annotate 'line', 386
    find_lex $P821, "self"
    get_global $P822, "$?CLASS"
    getattribute $P823, $P821, $P822, "@!mro"
    unless_null $P823, vivify_266
    $P823 = root_new ['parrot';'ResizablePMCArray']
  vivify_266:
    set $N824, $P823
    new $P825, 'Float'
    set $P825, $N824
    store_lex "$i", $P825
.annotate 'line', 387
    new $P843, 'ExceptionHandler'
    set_label $P843, loop842_handler
    $P843."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P843
  loop842_test:
    find_lex $P826, "$i"
    set $N827, $P826
    isgt $I828, $N827, 0.0
    unless $I828, loop842_done
  loop842_redo:
.annotate 'line', 388
    find_lex $P829, "$i"
    sub $P830, $P829, 1
    store_lex "$i", $P830
.annotate 'line', 389
    find_lex $P832, "$i"
    set $I833, $P832
    find_lex $P834, "self"
    get_global $P835, "$?CLASS"
    getattribute $P836, $P834, $P835, "@!mro"
    unless_null $P836, vivify_267
    $P836 = root_new ['parrot';'ResizablePMCArray']
  vivify_267:
    set $P837, $P836[$I833]
    unless_null $P837, vivify_268
    new $P837, "Undef"
  vivify_268:
    find_lex $P838, "$check-class"
    issame $I839, $P837, $P838
    unless $I839, if_831_end
.annotate 'line', 390
    new $P840, "Exception"
    set $P840['type'], .CONTROL_RETURN
    new $P841, "Integer"
    assign $P841, 1
    setattribute $P840, 'payload', $P841
    throw $P840
  if_831_end:
  loop842_next:
.annotate 'line', 387
    goto loop842_test
  loop842_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P844, exception, 'type'
    eq $P844, .CONTROL_LOOP_NEXT, loop842_next
    eq $P844, .CONTROL_LOOP_REDO, loop842_redo
  loop842_done:
    pop_eh 
.annotate 'line', 393
    new $P845, "Exception"
    set $P845['type'], .CONTROL_RETURN
    new $P846, "Integer"
    assign $P846, 0
    setattribute $P845, 'payload', $P846
    throw $P845
.annotate 'line', 384
    .return ()
  control_812:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P847, exception, "payload"
    .return ($P847)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "does"  :subid("60_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_851
    .param pmc param_852
    .param pmc param_853
.annotate 'line', 396
    new $P850, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P850, control_849
    push_eh $P850
    .lex "self", param_851
    .lex "$obj", param_852
    .lex "$check", param_853
.annotate 'line', 397
    new $P854, "Undef"
    .lex "$i", $P854
    find_lex $P855, "self"
    get_global $P856, "$?CLASS"
    getattribute $P857, $P855, $P856, "@!done"
    unless_null $P857, vivify_269
    $P857 = root_new ['parrot';'ResizablePMCArray']
  vivify_269:
    set $N858, $P857
    new $P859, 'Float'
    set $P859, $N858
    store_lex "$i", $P859
.annotate 'line', 398
    new $P877, 'ExceptionHandler'
    set_label $P877, loop876_handler
    $P877."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P877
  loop876_test:
    find_lex $P860, "$i"
    set $N861, $P860
    isgt $I862, $N861, 0.0
    unless $I862, loop876_done
  loop876_redo:
.annotate 'line', 399
    find_lex $P863, "$i"
    sub $P864, $P863, 1
    store_lex "$i", $P864
.annotate 'line', 400
    find_lex $P866, "$i"
    set $I867, $P866
    find_lex $P868, "self"
    get_global $P869, "$?CLASS"
    getattribute $P870, $P868, $P869, "@!done"
    unless_null $P870, vivify_270
    $P870 = root_new ['parrot';'ResizablePMCArray']
  vivify_270:
    set $P871, $P870[$I867]
    unless_null $P871, vivify_271
    new $P871, "Undef"
  vivify_271:
    find_lex $P872, "$check"
    issame $I873, $P871, $P872
    unless $I873, if_865_end
.annotate 'line', 401
    new $P874, "Exception"
    set $P874['type'], .CONTROL_RETURN
    new $P875, "Integer"
    assign $P875, 1
    setattribute $P874, 'payload', $P875
    throw $P874
  if_865_end:
  loop876_next:
.annotate 'line', 398
    goto loop876_test
  loop876_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P878, exception, 'type'
    eq $P878, .CONTROL_LOOP_NEXT, loop876_next
    eq $P878, .CONTROL_LOOP_REDO, loop876_redo
  loop876_done:
    pop_eh 
.annotate 'line', 404
    new $P879, "Exception"
    set $P879['type'], .CONTROL_RETURN
    new $P880, "Integer"
    assign $P880, 0
    setattribute $P879, 'payload', $P880
    throw $P879
.annotate 'line', 396
    .return ()
  control_849:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P881, exception, "payload"
    .return ($P881)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "can"  :subid("61_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_885
    .param pmc param_886
    .param pmc param_887
.annotate 'line', 407
    .const 'Sub' $P895 = "62_1297619303.875" 
    capture_lex $P895
    new $P884, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P884, control_883
    push_eh $P884
    .lex "self", param_885
    .lex "$obj", param_886
    .lex "$name", param_887
.annotate 'line', 408
    find_lex $P889, "self"
    get_global $P890, "$?CLASS"
    getattribute $P891, $P889, $P890, "@!mro"
    unless_null $P891, vivify_272
    $P891 = root_new ['parrot';'ResizablePMCArray']
  vivify_272:
    defined $I892, $P891
    unless $I892, for_undef_273
    iter $P888, $P891
    new $P913, 'ExceptionHandler'
    set_label $P913, loop912_handler
    $P913."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P913
  loop912_test:
    unless $P888, loop912_done
    shift $P893, $P888
  loop912_redo:
    .const 'Sub' $P895 = "62_1297619303.875" 
    capture_lex $P895
    $P895($P893)
  loop912_next:
    goto loop912_test
  loop912_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P914, exception, 'type'
    eq $P914, .CONTROL_LOOP_NEXT, loop912_next
    eq $P914, .CONTROL_LOOP_REDO, loop912_redo
  loop912_done:
    pop_eh 
  for_undef_273:
.annotate 'line', 415
    new $P915, "Exception"
    set $P915['type'], .CONTROL_RETURN
    new $P916, "Integer"
    assign $P916, 0
    setattribute $P915, 'payload', $P916
    throw $P915
.annotate 'line', 407
    .return ()
  control_883:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P917, exception, "payload"
    .return ($P917)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block894"  :anon :subid("62_1297619303.875") :outer("61_1297619303.875")
    .param pmc param_898
.annotate 'line', 409
    $P896 = root_new ['parrot';'Hash']
    .lex "%meths", $P896
.annotate 'line', 410
    new $P897, "Undef"
    .lex "$can", $P897
    .lex "$_", param_898
.annotate 'line', 409
    find_lex $P899, "$_"
    get_how $P900, $P899
    find_lex $P901, "$obj"
    $P902 = $P900."method_table"($P901)
    store_lex "%meths", $P902
.annotate 'line', 410
    find_lex $P903, "$name"
    find_lex $P904, "%meths"
    unless_null $P904, vivify_274
    $P904 = root_new ['parrot';'Hash']
  vivify_274:
    set $P905, $P904[$P903]
    unless_null $P905, vivify_275
    new $P905, "Undef"
  vivify_275:
    store_lex "$can", $P905
.annotate 'line', 411
    find_lex $P908, "$can"
    defined $I909, $P908
    if $I909, if_907
    new $P906, 'Integer'
    set $P906, $I909
    goto if_907_end
  if_907:
.annotate 'line', 412
    new $P910, "Exception"
    set $P910['type'], .CONTROL_RETURN
    find_lex $P911, "$can"
    setattribute $P910, 'payload', $P911
    throw $P910
  if_907_end:
.annotate 'line', 408
    .return ($P906)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "find_method"  :subid("63_1297619303.875") :outer("15_1297619303.875")
    .param pmc param_921
    .param pmc param_922
    .param pmc param_923
.annotate 'line', 421
    .const 'Sub' $P931 = "64_1297619303.875" 
    capture_lex $P931
    new $P920, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P920, control_919
    push_eh $P920
    .lex "self", param_921
    .lex "$obj", param_922
    .lex "$name", param_923
.annotate 'line', 422
    find_lex $P925, "self"
    get_global $P926, "$?CLASS"
    getattribute $P927, $P925, $P926, "@!mro"
    unless_null $P927, vivify_276
    $P927 = root_new ['parrot';'ResizablePMCArray']
  vivify_276:
    defined $I928, $P927
    unless $I928, for_undef_277
    iter $P924, $P927
    new $P949, 'ExceptionHandler'
    set_label $P949, loop948_handler
    $P949."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P949
  loop948_test:
    unless $P924, loop948_done
    shift $P929, $P924
  loop948_redo:
    .const 'Sub' $P931 = "64_1297619303.875" 
    capture_lex $P931
    $P931($P929)
  loop948_next:
    goto loop948_test
  loop948_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P950, exception, 'type'
    eq $P950, .CONTROL_LOOP_NEXT, loop948_next
    eq $P950, .CONTROL_LOOP_REDO, loop948_redo
  loop948_done:
    pop_eh 
  for_undef_277:
.annotate 'line', 429
    null $P951
.annotate 'line', 421
    .return ($P951)
  control_919:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P952, exception, "payload"
    .return ($P952)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block930"  :anon :subid("64_1297619303.875") :outer("63_1297619303.875")
    .param pmc param_934
.annotate 'line', 423
    $P932 = root_new ['parrot';'Hash']
    .lex "%meths", $P932
.annotate 'line', 424
    new $P933, "Undef"
    .lex "$found", $P933
    .lex "$_", param_934
.annotate 'line', 423
    find_lex $P935, "$_"
    get_how $P936, $P935
    find_lex $P937, "$obj"
    $P938 = $P936."method_table"($P937)
    store_lex "%meths", $P938
.annotate 'line', 424
    find_lex $P939, "$name"
    find_lex $P940, "%meths"
    unless_null $P940, vivify_278
    $P940 = root_new ['parrot';'Hash']
  vivify_278:
    set $P941, $P940[$P939]
    unless_null $P941, vivify_279
    new $P941, "Undef"
  vivify_279:
    store_lex "$found", $P941
.annotate 'line', 425
    find_lex $P944, "$found"
    defined $I945, $P944
    if $I945, if_943
    new $P942, 'Integer'
    set $P942, $I945
    goto if_943_end
  if_943:
.annotate 'line', 426
    new $P946, "Exception"
    set $P946['type'], .CONTROL_RETURN
    find_lex $P947, "$found"
    setattribute $P946, 'payload', $P947
    throw $P946
  if_943_end:
.annotate 'line', 422
    .return ($P942)
.end


.namespace ["NQPNativeHOW"]
.sub "_block1042"  :subid("66_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 434
    .const 'Sub' $P1103 = "75_1297619303.875" 
    capture_lex $P1103
    .const 'Sub' $P1095 = "74_1297619303.875" 
    capture_lex $P1095
    .const 'Sub' $P1089 = "73_1297619303.875" 
    capture_lex $P1089
    .const 'Sub' $P1085 = "72_1297619303.875" 
    capture_lex $P1085
    .const 'Sub' $P1080 = "71_1297619303.875" 
    capture_lex $P1080
    .const 'Sub' $P1075 = "70_1297619303.875" 
    capture_lex $P1075
    .const 'Sub' $P1062 = "69_1297619303.875" 
    capture_lex $P1062
    .const 'Sub' $P1055 = "68_1297619303.875" 
    capture_lex $P1055
    .const 'Sub' $P1045 = "67_1297619303.875" 
    capture_lex $P1045
    get_global $P1044, "$?CLASS"
.annotate 'line', 472
    .const 'Sub' $P1095 = "74_1297619303.875" 
    newclosure $P1101, $P1095
.annotate 'line', 434
    .return ($P1101)
.end


.namespace ["NQPNativeHOW"]
.sub "" :load :init :subid("post280") :outer("66_1297619303.875")
.annotate 'line', 434
    get_hll_global $P1043, ["NQPNativeHOW"], "_block1042" 
    .local pmc block
    set block, $P1043
    .const 'Sub' $P1103 = "75_1297619303.875" 
    capture_lex $P1103
    $P1103()
.end


.namespace ["NQPNativeHOW"]
.sub "_block1102"  :anon :subid("75_1297619303.875") :outer("66_1297619303.875")
.annotate 'line', 434
    get_hll_global $P1104, "KnowHOW"
    $P1105 = $P1104."new_type"("NQPNativeHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1105
    set_hll_global "NQPNativeHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1106, type_obj
    get_hll_global $P1107, "KnowHOWAttribute"
    $P1108 = $P1107."new"("$!name" :named("name"))
    $P1106."add_attribute"(type_obj, $P1108)
    get_how $P1109, type_obj
    get_hll_global $P1110, "KnowHOWAttribute"
    $P1111 = $P1110."new"("$!composed" :named("name"))
    $P1109."add_attribute"(type_obj, $P1111)
    get_how $P1112, type_obj
    .const 'Sub' $P1113 = "67_1297619303.875" 
    $P1112."add_method"(type_obj, "new", $P1113)
    get_how $P1114, type_obj
    .const 'Sub' $P1115 = "68_1297619303.875" 
    $P1114."add_method"(type_obj, "BUILD", $P1115)
    get_how $P1116, type_obj
    .const 'Sub' $P1117 = "69_1297619303.875" 
    $P1116."add_method"(type_obj, "new_type", $P1117)
    get_how $P1118, type_obj
    .const 'Sub' $P1119 = "70_1297619303.875" 
    $P1118."add_method"(type_obj, "add_method", $P1119)
    get_how $P1120, type_obj
    .const 'Sub' $P1121 = "71_1297619303.875" 
    $P1120."add_method"(type_obj, "add_multi_method", $P1121)
    get_how $P1122, type_obj
    .const 'Sub' $P1123 = "72_1297619303.875" 
    $P1122."add_method"(type_obj, "add_attribute", $P1123)
    get_how $P1124, type_obj
    .const 'Sub' $P1125 = "73_1297619303.875" 
    $P1124."add_method"(type_obj, "compose", $P1125)
    get_how $P1126, type_obj
    .const 'Sub' $P1127 = "74_1297619303.875" 
    $P1126."add_method"(type_obj, "name", $P1127)
    get_how $P1128, type_obj
    $P1129 = $P1128."compose"(type_obj)
    .return ($P1129)
.end


.namespace ["NQPNativeHOW"]
.sub "new"  :subid("67_1297619303.875") :outer("66_1297619303.875")
    .param pmc param_1046
    .param pmc param_1047 :optional :named("name")
    .param int has_param_1047 :opt_flag
.annotate 'line', 438
    .lex "self", param_1046
    if has_param_1047, optparam_281
    new $P1048, "Undef"
    set param_1047, $P1048
  optparam_281:
    .lex "$name", param_1047
.annotate 'line', 439
    new $P1049, "Undef"
    .lex "$obj", $P1049
    find_lex $P1050, "self"
    repr_instance_of $P1051, $P1050
    store_lex "$obj", $P1051
.annotate 'line', 440
    find_lex $P1052, "$obj"
    find_lex $P1053, "$name"
    $P1052."BUILD"($P1053 :named("name"))
    find_lex $P1054, "$obj"
.annotate 'line', 438
    .return ($P1054)
.end


.namespace ["NQPNativeHOW"]
.sub "BUILD"  :subid("68_1297619303.875") :outer("66_1297619303.875")
    .param pmc param_1056
    .param pmc param_1057 :optional :named("name")
    .param int has_param_1057 :opt_flag
.annotate 'line', 444
    .lex "self", param_1056
    if has_param_1057, optparam_282
    new $P1058, "Undef"
    set param_1057, $P1058
  optparam_282:
    .lex "$name", param_1057
.annotate 'line', 445
    find_lex $P1059, "$name"
    find_lex $P1060, "self"
    get_global $P1061, "$?CLASS"
    setattribute $P1060, $P1061, "$!name", $P1059
.annotate 'line', 444
    .return ($P1059)
.end


.namespace ["NQPNativeHOW"]
.sub "new_type"  :subid("69_1297619303.875") :outer("66_1297619303.875")
    .param pmc param_1063
    .param pmc param_1066 :named("repr")
    .param pmc param_1064 :optional :named("name")
    .param int has_param_1064 :opt_flag
.annotate 'line', 451
    .lex "self", param_1063
    if has_param_1064, optparam_283
    new $P1065, "String"
    assign $P1065, "<anon>"
    set param_1064, $P1065
  optparam_283:
    .lex "$name", param_1064
    .lex "$repr", param_1066
.annotate 'line', 452
    new $P1067, "Undef"
    .lex "$metaclass", $P1067
    find_lex $P1068, "self"
    find_lex $P1069, "$name"
    $P1070 = $P1068."new"($P1069 :named("name"))
    store_lex "$metaclass", $P1070
.annotate 'line', 453
    find_lex $P1071, "$metaclass"
    find_lex $P1072, "$repr"
    set $S1073, $P1072
    repr_type_object_for $P1074, $P1071, $S1073
.annotate 'line', 451
    .return ($P1074)
.end


.namespace ["NQPNativeHOW"]
.sub "add_method"  :subid("70_1297619303.875") :outer("66_1297619303.875")
    .param pmc param_1076
    .param pmc param_1077
    .param pmc param_1078
    .param pmc param_1079
.annotate 'line', 456
    .lex "self", param_1076
    .lex "$obj", param_1077
    .lex "$name", param_1078
    .lex "$code_obj", param_1079
.annotate 'line', 457
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 456
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "add_multi_method"  :subid("71_1297619303.875") :outer("66_1297619303.875")
    .param pmc param_1081
    .param pmc param_1082
    .param pmc param_1083
    .param pmc param_1084
.annotate 'line', 460
    .lex "self", param_1081
    .lex "$obj", param_1082
    .lex "$name", param_1083
    .lex "$code_obj", param_1084
.annotate 'line', 461
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 460
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "add_attribute"  :subid("72_1297619303.875") :outer("66_1297619303.875")
    .param pmc param_1086
    .param pmc param_1087
    .param pmc param_1088
.annotate 'line', 464
    .lex "self", param_1086
    .lex "$obj", param_1087
    .lex "$meta_attr", param_1088
.annotate 'line', 465
    die "Native types may not have attributes"
.annotate 'line', 464
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "compose"  :subid("73_1297619303.875") :outer("66_1297619303.875")
    .param pmc param_1090
    .param pmc param_1091
.annotate 'line', 468
    .lex "self", param_1090
    .lex "$obj", param_1091
.annotate 'line', 469
    new $P1092, "Integer"
    assign $P1092, 1
    find_lex $P1093, "self"
    get_global $P1094, "$?CLASS"
    setattribute $P1093, $P1094, "$!composed", $P1092
.annotate 'line', 468
    .return ($P1092)
.end


.namespace ["NQPNativeHOW"]
.sub "name"  :subid("74_1297619303.875") :outer("66_1297619303.875")
    .param pmc param_1096
    .param pmc param_1097
.annotate 'line', 472
    .lex "self", param_1096
    .lex "$obj", param_1097
    find_lex $P1098, "self"
    get_global $P1099, "$?CLASS"
    getattribute $P1100, $P1098, $P1099, "$!name"
    unless_null $P1100, vivify_284
    new $P1100, "Undef"
  vivify_284:
    .return ($P1100)
.end


.namespace ["NQPAttribute"]
.sub "_block1130"  :subid("76_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 478
    .const 'Sub' $P1190 = "82_1297619303.875" 
    capture_lex $P1190
    .const 'Sub' $P1179 = "81_1297619303.875" 
    capture_lex $P1179
    .const 'Sub' $P1170 = "80_1297619303.875" 
    capture_lex $P1170
    .const 'Sub' $P1165 = "79_1297619303.875" 
    capture_lex $P1165
    .const 'Sub' $P1148 = "78_1297619303.875" 
    capture_lex $P1148
    .const 'Sub' $P1133 = "77_1297619303.875" 
    capture_lex $P1133
    get_global $P1132, "$?CLASS"
.annotate 'line', 503
    .const 'Sub' $P1179 = "81_1297619303.875" 
    newclosure $P1188, $P1179
.annotate 'line', 478
    .return ($P1188)
.end


.namespace ["NQPAttribute"]
.sub "" :load :init :subid("post285") :outer("76_1297619303.875")
.annotate 'line', 478
    get_hll_global $P1131, ["NQPAttribute"], "_block1130" 
    .local pmc block
    set block, $P1131
    .const 'Sub' $P1190 = "82_1297619303.875" 
    capture_lex $P1190
    $P1190()
.end


.namespace ["NQPAttribute"]
.sub "_block1189"  :anon :subid("82_1297619303.875") :outer("76_1297619303.875")
.annotate 'line', 478
    get_hll_global $P1191, "KnowHOW"
    $P1192 = $P1191."new_type"("NQPAttribute" :named("name"))
    .local pmc type_obj
    set type_obj, $P1192
    set_hll_global "NQPAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1193, type_obj
    get_hll_global $P1194, "KnowHOWAttribute"
    $P1195 = $P1194."new"("$!name" :named("name"))
    $P1193."add_attribute"(type_obj, $P1195)
    get_how $P1196, type_obj
    get_hll_global $P1197, "KnowHOWAttribute"
    $P1198 = $P1197."new"("$!type" :named("name"))
    $P1196."add_attribute"(type_obj, $P1198)
    get_how $P1199, type_obj
    get_hll_global $P1200, "KnowHOWAttribute"
    $P1201 = $P1200."new"("$!box_target" :named("name"))
    $P1199."add_attribute"(type_obj, $P1201)
    get_how $P1202, type_obj
    .const 'Sub' $P1203 = "77_1297619303.875" 
    $P1202."add_method"(type_obj, "new", $P1203)
    get_how $P1204, type_obj
    .const 'Sub' $P1205 = "78_1297619303.875" 
    $P1204."add_method"(type_obj, "BUILD", $P1205)
    get_how $P1206, type_obj
    .const 'Sub' $P1207 = "79_1297619303.875" 
    $P1206."add_method"(type_obj, "name", $P1207)
    get_how $P1208, type_obj
    .const 'Sub' $P1209 = "80_1297619303.875" 
    $P1208."add_method"(type_obj, "type", $P1209)
    get_how $P1210, type_obj
    .const 'Sub' $P1211 = "81_1297619303.875" 
    $P1210."add_method"(type_obj, "box_target", $P1211)
    get_how $P1212, type_obj
    $P1213 = $P1212."compose"(type_obj)
    .return ($P1213)
.end


.namespace ["NQPAttribute"]
.sub "new"  :subid("77_1297619303.875") :outer("76_1297619303.875")
    .param pmc param_1134
    .param pmc param_1135 :named("name")
    .param pmc param_1136 :optional :named("type")
    .param int has_param_1136 :opt_flag
    .param pmc param_1138 :optional :named("box_target")
    .param int has_param_1138 :opt_flag
.annotate 'line', 483
    .lex "self", param_1134
    .lex "$name", param_1135
    if has_param_1136, optparam_286
    new $P1137, "Undef"
    set param_1136, $P1137
  optparam_286:
    .lex "$type", param_1136
    if has_param_1138, optparam_287
    new $P1139, "Undef"
    set param_1138, $P1139
  optparam_287:
    .lex "$box_target", param_1138
.annotate 'line', 484
    new $P1140, "Undef"
    .lex "$attr", $P1140
    find_lex $P1141, "self"
    repr_instance_of $P1142, $P1141
    store_lex "$attr", $P1142
.annotate 'line', 485
    find_lex $P1143, "$attr"
    find_lex $P1144, "$name"
    find_lex $P1145, "$type"
    find_lex $P1146, "$box_target"
    $P1143."BUILD"($P1144 :named("name"), $P1145 :named("type"), $P1146 :named("box_target"))
    find_lex $P1147, "$attr"
.annotate 'line', 483
    .return ($P1147)
.end


.namespace ["NQPAttribute"]
.sub "BUILD"  :subid("78_1297619303.875") :outer("76_1297619303.875")
    .param pmc param_1149
    .param pmc param_1150 :optional :named("name")
    .param int has_param_1150 :opt_flag
    .param pmc param_1152 :optional :named("type")
    .param int has_param_1152 :opt_flag
    .param pmc param_1154 :optional :named("box_target")
    .param int has_param_1154 :opt_flag
.annotate 'line', 489
    .lex "self", param_1149
    if has_param_1150, optparam_288
    new $P1151, "Undef"
    set param_1150, $P1151
  optparam_288:
    .lex "$name", param_1150
    if has_param_1152, optparam_289
    new $P1153, "Undef"
    set param_1152, $P1153
  optparam_289:
    .lex "$type", param_1152
    if has_param_1154, optparam_290
    new $P1155, "Undef"
    set param_1154, $P1155
  optparam_290:
    .lex "$box_target", param_1154
.annotate 'line', 490
    find_lex $P1156, "$name"
    find_lex $P1157, "self"
    get_global $P1158, "$?CLASS"
    setattribute $P1157, $P1158, "$!name", $P1156
.annotate 'line', 491
    find_lex $P1159, "$type"
    find_lex $P1160, "self"
    get_global $P1161, "$?CLASS"
    setattribute $P1160, $P1161, "$!type", $P1159
.annotate 'line', 492
    find_lex $P1162, "$box_target"
    find_lex $P1163, "self"
    get_global $P1164, "$?CLASS"
    setattribute $P1163, $P1164, "$!box_target", $P1162
.annotate 'line', 489
    .return ($P1162)
.end


.namespace ["NQPAttribute"]
.sub "name"  :subid("79_1297619303.875") :outer("76_1297619303.875")
    .param pmc param_1166
.annotate 'line', 495
    .lex "self", param_1166
    find_lex $P1167, "self"
    get_global $P1168, "$?CLASS"
    getattribute $P1169, $P1167, $P1168, "$!name"
    unless_null $P1169, vivify_291
    new $P1169, "Undef"
  vivify_291:
    .return ($P1169)
.end


.namespace ["NQPAttribute"]
.sub "type"  :subid("80_1297619303.875") :outer("76_1297619303.875")
    .param pmc param_1171
.annotate 'line', 499
    .lex "self", param_1171
.annotate 'line', 500
    find_lex $P1173, "self"
    get_global $P1174, "$?CLASS"
    getattribute $P1175, $P1173, $P1174, "$!type"
    unless_null $P1175, vivify_292
    new $P1175, "Undef"
  vivify_292:
    set $P1172, $P1175
    defined $I1177, $P1172
    if $I1177, default_1176
    null $P1178
    set $P1172, $P1178
  default_1176:
.annotate 'line', 499
    .return ($P1172)
.end


.namespace ["NQPAttribute"]
.sub "box_target"  :subid("81_1297619303.875") :outer("76_1297619303.875")
    .param pmc param_1180
.annotate 'line', 503
    .lex "self", param_1180
.annotate 'line', 504
    find_lex $P1183, "self"
    get_global $P1184, "$?CLASS"
    getattribute $P1185, $P1183, $P1184, "$!box_target"
    unless_null $P1185, vivify_293
    new $P1185, "Undef"
  vivify_293:
    if $P1185, if_1182
    new $P1187, "Integer"
    assign $P1187, 0
    set $P1181, $P1187
    goto if_1182_end
  if_1182:
    new $P1186, "Integer"
    assign $P1186, 1
    set $P1181, $P1186
  if_1182_end:
.annotate 'line', 503
    .return ($P1181)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1214"  :subid("83_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 511
    .const 'Sub' $P1470 = "104_1297619303.875" 
    capture_lex $P1470
    .const 'Sub' $P1462 = "103_1297619303.875" 
    capture_lex $P1462
    .const 'Sub' $P1456 = "102_1297619303.875" 
    capture_lex $P1456
    .const 'Sub' $P1434 = "100_1297619303.875" 
    capture_lex $P1434
    .const 'Sub' $P1428 = "99_1297619303.875" 
    capture_lex $P1428
    .const 'Sub' $P1422 = "98_1297619303.875" 
    capture_lex $P1422
    .const 'Sub' $P1416 = "97_1297619303.875" 
    capture_lex $P1416
    .const 'Sub' $P1394 = "95_1297619303.875" 
    capture_lex $P1394
    .const 'Sub' $P1345 = "93_1297619303.875" 
    capture_lex $P1345
    .const 'Sub' $P1332 = "92_1297619303.875" 
    capture_lex $P1332
    .const 'Sub' $P1319 = "91_1297619303.875" 
    capture_lex $P1319
    .const 'Sub' $P1315 = "90_1297619303.875" 
    capture_lex $P1315
    .const 'Sub' $P1294 = "89_1297619303.875" 
    capture_lex $P1294
    .const 'Sub' $P1273 = "88_1297619303.875" 
    capture_lex $P1273
    .const 'Sub' $P1254 = "87_1297619303.875" 
    capture_lex $P1254
    .const 'Sub' $P1238 = "86_1297619303.875" 
    capture_lex $P1238
    .const 'Sub' $P1228 = "85_1297619303.875" 
    capture_lex $P1228
    .const 'Sub' $P1217 = "84_1297619303.875" 
    capture_lex $P1217
    get_global $P1216, "$?CLASS"
.annotate 'line', 650
    .const 'Sub' $P1462 = "103_1297619303.875" 
    newclosure $P1468, $P1462
.annotate 'line', 511
    .return ($P1468)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "" :load :init :subid("post294") :outer("83_1297619303.875")
.annotate 'line', 511
    get_hll_global $P1215, ["NQPConcreteRoleHOW"], "_block1214" 
    .local pmc block
    set block, $P1215
    .const 'Sub' $P1470 = "104_1297619303.875" 
    capture_lex $P1470
    $P1470()
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1469"  :anon :subid("104_1297619303.875") :outer("83_1297619303.875")
.annotate 'line', 511
    get_hll_global $P1471, "KnowHOW"
    $P1472 = $P1471."new_type"("NQPConcreteRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1472
    set_hll_global "NQPConcreteRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1473, type_obj
    get_hll_global $P1474, "KnowHOWAttribute"
    $P1475 = $P1474."new"("$!name" :named("name"))
    $P1473."add_attribute"(type_obj, $P1475)
    get_how $P1476, type_obj
    get_hll_global $P1477, "KnowHOWAttribute"
    $P1478 = $P1477."new"("$!instance_of" :named("name"))
    $P1476."add_attribute"(type_obj, $P1478)
    get_how $P1479, type_obj
    get_hll_global $P1480, "KnowHOWAttribute"
    $P1481 = $P1480."new"("%!attributes" :named("name"))
    $P1479."add_attribute"(type_obj, $P1481)
    get_how $P1482, type_obj
    get_hll_global $P1483, "KnowHOWAttribute"
    $P1484 = $P1483."new"("%!methods" :named("name"))
    $P1482."add_attribute"(type_obj, $P1484)
    get_how $P1485, type_obj
    get_hll_global $P1486, "KnowHOWAttribute"
    $P1487 = $P1486."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1485."add_attribute"(type_obj, $P1487)
    get_how $P1488, type_obj
    get_hll_global $P1489, "KnowHOWAttribute"
    $P1490 = $P1489."new"("@!collisions" :named("name"))
    $P1488."add_attribute"(type_obj, $P1490)
    get_how $P1491, type_obj
    get_hll_global $P1492, "KnowHOWAttribute"
    $P1493 = $P1492."new"("@!roles" :named("name"))
    $P1491."add_attribute"(type_obj, $P1493)
    get_how $P1494, type_obj
    get_hll_global $P1495, "KnowHOWAttribute"
    $P1496 = $P1495."new"("@!done" :named("name"))
    $P1494."add_attribute"(type_obj, $P1496)
    get_how $P1497, type_obj
    get_hll_global $P1498, "KnowHOWAttribute"
    $P1499 = $P1498."new"("$!composed" :named("name"))
    $P1497."add_attribute"(type_obj, $P1499)
    get_how $P1500, type_obj
    .const 'Sub' $P1501 = "84_1297619303.875" 
    $P1500."add_method"(type_obj, "new", $P1501)
    get_how $P1502, type_obj
    .const 'Sub' $P1503 = "85_1297619303.875" 
    $P1502."add_method"(type_obj, "BUILD", $P1503)
    get_how $P1504, type_obj
    .const 'Sub' $P1505 = "86_1297619303.875" 
    $P1504."add_method"(type_obj, "new_type", $P1505)
    get_how $P1506, type_obj
    .const 'Sub' $P1507 = "87_1297619303.875" 
    $P1506."add_method"(type_obj, "add_method", $P1507)
    get_how $P1508, type_obj
    .const 'Sub' $P1509 = "88_1297619303.875" 
    $P1508."add_method"(type_obj, "add_multi_method", $P1509)
    get_how $P1510, type_obj
    .const 'Sub' $P1511 = "89_1297619303.875" 
    $P1510."add_method"(type_obj, "add_attribute", $P1511)
    get_how $P1512, type_obj
    .const 'Sub' $P1513 = "90_1297619303.875" 
    $P1512."add_method"(type_obj, "add_parent", $P1513)
    get_how $P1514, type_obj
    .const 'Sub' $P1515 = "91_1297619303.875" 
    $P1514."add_method"(type_obj, "add_role", $P1515)
    get_how $P1516, type_obj
    .const 'Sub' $P1517 = "92_1297619303.875" 
    $P1516."add_method"(type_obj, "add_collision", $P1517)
    get_how $P1518, type_obj
    .const 'Sub' $P1519 = "93_1297619303.875" 
    $P1518."add_method"(type_obj, "compose", $P1519)
    get_how $P1520, type_obj
    .const 'Sub' $P1521 = "95_1297619303.875" 
    $P1520."add_method"(type_obj, "methods", $P1521)
    get_how $P1522, type_obj
    .const 'Sub' $P1523 = "97_1297619303.875" 
    $P1522."add_method"(type_obj, "method_table", $P1523)
    get_how $P1524, type_obj
    .const 'Sub' $P1525 = "98_1297619303.875" 
    $P1524."add_method"(type_obj, "collisions", $P1525)
    get_how $P1526, type_obj
    .const 'Sub' $P1527 = "99_1297619303.875" 
    $P1526."add_method"(type_obj, "name", $P1527)
    get_how $P1528, type_obj
    .const 'Sub' $P1529 = "100_1297619303.875" 
    $P1528."add_method"(type_obj, "attributes", $P1529)
    get_how $P1530, type_obj
    .const 'Sub' $P1531 = "102_1297619303.875" 
    $P1530."add_method"(type_obj, "roles", $P1531)
    get_how $P1532, type_obj
    .const 'Sub' $P1533 = "103_1297619303.875" 
    $P1532."add_method"(type_obj, "instance_of", $P1533)
    get_how $P1534, type_obj
    $P1535 = $P1534."compose"(type_obj)
    .return ($P1535)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "new"  :subid("84_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1218
    .param pmc param_1219 :named("name")
    .param pmc param_1220 :named("instance_of")
.annotate 'line', 543
    .lex "self", param_1218
    .lex "$name", param_1219
    .lex "$instance_of", param_1220
.annotate 'line', 544
    new $P1221, "Undef"
    .lex "$obj", $P1221
    find_lex $P1222, "self"
    repr_instance_of $P1223, $P1222
    store_lex "$obj", $P1223
.annotate 'line', 545
    find_lex $P1224, "$obj"
    find_lex $P1225, "$name"
    find_lex $P1226, "$instance_of"
    $P1224."BUILD"($P1225 :named("name"), $P1226 :named("instance_of"))
    find_lex $P1227, "$obj"
.annotate 'line', 543
    .return ($P1227)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "BUILD"  :subid("85_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1229
    .param pmc param_1230 :named("name")
    .param pmc param_1231 :named("instance_of")
.annotate 'line', 549
    .lex "self", param_1229
    .lex "$name", param_1230
    .lex "$instance_of", param_1231
.annotate 'line', 550
    find_lex $P1232, "$name"
    find_lex $P1233, "self"
    get_global $P1234, "$?CLASS"
    setattribute $P1233, $P1234, "$!name", $P1232
.annotate 'line', 551
    find_lex $P1235, "$instance_of"
    find_lex $P1236, "self"
    get_global $P1237, "$?CLASS"
    setattribute $P1236, $P1237, "$!instance_of", $P1235
.annotate 'line', 549
    .return ($P1235)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "new_type"  :subid("86_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1239
    .param pmc param_1244 :named("instance_of")
    .param pmc param_1240 :optional :named("name")
    .param int has_param_1240 :opt_flag
    .param pmc param_1242 :optional :named("repr")
    .param int has_param_1242 :opt_flag
.annotate 'line', 556
    .lex "self", param_1239
    if has_param_1240, optparam_295
    new $P1241, "String"
    assign $P1241, "<anon>"
    set param_1240, $P1241
  optparam_295:
    .lex "$name", param_1240
    if has_param_1242, optparam_296
    new $P1243, "String"
    assign $P1243, "P6opaque"
    set param_1242, $P1243
  optparam_296:
    .lex "$repr", param_1242
    .lex "$instance_of", param_1244
.annotate 'line', 557
    new $P1245, "Undef"
    .lex "$metarole", $P1245
    find_lex $P1246, "self"
    find_lex $P1247, "$name"
    find_lex $P1248, "$instance_of"
    $P1249 = $P1246."new"($P1247 :named("name"), $P1248 :named("instance_of"))
    store_lex "$metarole", $P1249
.annotate 'line', 558
    find_lex $P1250, "$metarole"
    find_lex $P1251, "$repr"
    set $S1252, $P1251
    repr_type_object_for $P1253, $P1250, $S1252
.annotate 'line', 556
    .return ($P1253)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_method"  :subid("87_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1255
    .param pmc param_1256
    .param pmc param_1257
    .param pmc param_1258
.annotate 'line', 561
    .lex "self", param_1255
    .lex "$obj", param_1256
    .lex "$name", param_1257
    .lex "$code_obj", param_1258
.annotate 'line', 562
    find_lex $P1260, "$name"
    find_lex $P1261, "self"
    get_global $P1262, "$?CLASS"
    getattribute $P1263, $P1261, $P1262, "%!methods"
    unless_null $P1263, vivify_297
    $P1263 = root_new ['parrot';'Hash']
  vivify_297:
    set $P1264, $P1263[$P1260]
    unless_null $P1264, vivify_298
    new $P1264, "Undef"
  vivify_298:
    unless $P1264, if_1259_end
.annotate 'line', 563
    new $P1265, "String"
    assign $P1265, "This role already has a method named "
    find_lex $P1266, "$name"
    concat $P1267, $P1265, $P1266
    die $P1267
  if_1259_end:
.annotate 'line', 565
    find_lex $P1268, "$code_obj"
    find_lex $P1269, "$name"
    find_lex $P1270, "self"
    get_global $P1271, "$?CLASS"
    getattribute $P1272, $P1270, $P1271, "%!methods"
    unless_null $P1272, vivify_299
    $P1272 = root_new ['parrot';'Hash']
    setattribute $P1270, $P1271, "%!methods", $P1272
  vivify_299:
    set $P1272[$P1269], $P1268
.annotate 'line', 561
    .return ($P1268)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_multi_method"  :subid("88_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1274
    .param pmc param_1275
    .param pmc param_1276
    .param pmc param_1277
.annotate 'line', 568
    .lex "self", param_1274
    .lex "$obj", param_1275
    .lex "$name", param_1276
    .lex "$code_obj", param_1277
.annotate 'line', 569
    $P1278 = root_new ['parrot';'Hash']
    .lex "%todo", $P1278
.annotate 'line', 568
    find_lex $P1279, "%todo"
.annotate 'line', 570
    find_lex $P1280, "$name"
    find_lex $P1281, "%todo"
    unless_null $P1281, vivify_300
    $P1281 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1281
  vivify_300:
    set $P1281["name"], $P1280
.annotate 'line', 571
    find_lex $P1282, "$code_obj"
    find_lex $P1283, "%todo"
    unless_null $P1283, vivify_301
    $P1283 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1283
  vivify_301:
    set $P1283["code"], $P1282
.annotate 'line', 572
    find_lex $P1284, "%todo"
    find_lex $P1285, "self"
    get_global $P1286, "$?CLASS"
    getattribute $P1287, $P1285, $P1286, "@!multi_methods_to_incorporate"
    unless_null $P1287, vivify_302
    $P1287 = root_new ['parrot';'ResizablePMCArray']
  vivify_302:
    set $N1288, $P1287
    set $I1289, $N1288
    find_lex $P1290, "self"
    get_global $P1291, "$?CLASS"
    getattribute $P1292, $P1290, $P1291, "@!multi_methods_to_incorporate"
    unless_null $P1292, vivify_303
    $P1292 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1290, $P1291, "@!multi_methods_to_incorporate", $P1292
  vivify_303:
    set $P1292[$I1289], $P1284
    find_lex $P1293, "$code_obj"
.annotate 'line', 568
    .return ($P1293)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_attribute"  :subid("89_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1295
    .param pmc param_1296
    .param pmc param_1297
.annotate 'line', 576
    .lex "self", param_1295
    .lex "$obj", param_1296
    .lex "$meta_attr", param_1297
.annotate 'line', 577
    new $P1298, "Undef"
    .lex "$name", $P1298
    find_lex $P1299, "$meta_attr"
    $P1300 = $P1299."name"()
    store_lex "$name", $P1300
.annotate 'line', 578
    find_lex $P1302, "$name"
    find_lex $P1303, "self"
    get_global $P1304, "$?CLASS"
    getattribute $P1305, $P1303, $P1304, "%!attributes"
    unless_null $P1305, vivify_304
    $P1305 = root_new ['parrot';'Hash']
  vivify_304:
    set $P1306, $P1305[$P1302]
    unless_null $P1306, vivify_305
    new $P1306, "Undef"
  vivify_305:
    unless $P1306, if_1301_end
.annotate 'line', 579
    new $P1307, "String"
    assign $P1307, "This role already has an attribute named "
    find_lex $P1308, "$name"
    concat $P1309, $P1307, $P1308
    die $P1309
  if_1301_end:
.annotate 'line', 581
    find_lex $P1310, "$meta_attr"
    find_lex $P1311, "$name"
    find_lex $P1312, "self"
    get_global $P1313, "$?CLASS"
    getattribute $P1314, $P1312, $P1313, "%!attributes"
    unless_null $P1314, vivify_306
    $P1314 = root_new ['parrot';'Hash']
    setattribute $P1312, $P1313, "%!attributes", $P1314
  vivify_306:
    set $P1314[$P1311], $P1310
.annotate 'line', 576
    .return ($P1310)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_parent"  :subid("90_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1316
    .param pmc param_1317
    .param pmc param_1318
.annotate 'line', 584
    .lex "self", param_1316
    .lex "$obj", param_1317
    .lex "$parent", param_1318
.annotate 'line', 585
    die "A role cannot inherit from a class in NQP"
.annotate 'line', 584
    .return ()
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_role"  :subid("91_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1320
    .param pmc param_1321
    .param pmc param_1322
.annotate 'line', 588
    .lex "self", param_1320
    .lex "$obj", param_1321
    .lex "$role", param_1322
.annotate 'line', 589
    find_lex $P1323, "$role"
    find_lex $P1324, "self"
    get_global $P1325, "$?CLASS"
    getattribute $P1326, $P1324, $P1325, "@!roles"
    unless_null $P1326, vivify_307
    $P1326 = root_new ['parrot';'ResizablePMCArray']
  vivify_307:
    set $N1327, $P1326
    set $I1328, $N1327
    find_lex $P1329, "self"
    get_global $P1330, "$?CLASS"
    getattribute $P1331, $P1329, $P1330, "@!roles"
    unless_null $P1331, vivify_308
    $P1331 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1329, $P1330, "@!roles", $P1331
  vivify_308:
    set $P1331[$I1328], $P1323
.annotate 'line', 588
    .return ($P1323)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_collision"  :subid("92_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1333
    .param pmc param_1334
    .param pmc param_1335
.annotate 'line', 592
    .lex "self", param_1333
    .lex "$obj", param_1334
    .lex "$colliding_name", param_1335
.annotate 'line', 593
    find_lex $P1336, "$colliding_name"
    find_lex $P1337, "self"
    get_global $P1338, "$?CLASS"
    getattribute $P1339, $P1337, $P1338, "@!collisions"
    unless_null $P1339, vivify_309
    $P1339 = root_new ['parrot';'ResizablePMCArray']
  vivify_309:
    set $N1340, $P1339
    set $I1341, $N1340
    find_lex $P1342, "self"
    get_global $P1343, "$?CLASS"
    getattribute $P1344, $P1342, $P1343, "@!collisions"
    unless_null $P1344, vivify_310
    $P1344 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1342, $P1343, "@!collisions", $P1344
  vivify_310:
    set $P1344[$I1341], $P1336
.annotate 'line', 592
    .return ($P1336)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "compose"  :subid("93_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1346
    .param pmc param_1347
.annotate 'line', 597
    .const 'Sub' $P1359 = "94_1297619303.875" 
    capture_lex $P1359
    .lex "self", param_1346
    .lex "$obj", param_1347
.annotate 'line', 600
    find_lex $P1349, "self"
    get_global $P1350, "$?CLASS"
    getattribute $P1351, $P1349, $P1350, "@!roles"
    unless_null $P1351, vivify_311
    $P1351 = root_new ['parrot';'ResizablePMCArray']
  vivify_311:
    unless $P1351, if_1348_end
.annotate 'line', 601
    find_lex $P1353, "self"
    get_global $P1354, "$?CLASS"
    getattribute $P1355, $P1353, $P1354, "@!roles"
    unless_null $P1355, vivify_312
    $P1355 = root_new ['parrot';'ResizablePMCArray']
  vivify_312:
    defined $I1356, $P1355
    unless $I1356, for_undef_313
    iter $P1352, $P1355
    new $P1383, 'ExceptionHandler'
    set_label $P1383, loop1382_handler
    $P1383."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1383
  loop1382_test:
    unless $P1352, loop1382_done
    shift $P1357, $P1352
  loop1382_redo:
    .const 'Sub' $P1359 = "94_1297619303.875" 
    capture_lex $P1359
    $P1359($P1357)
  loop1382_next:
    goto loop1382_test
  loop1382_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1384, exception, 'type'
    eq $P1384, .CONTROL_LOOP_NEXT, loop1382_next
    eq $P1384, .CONTROL_LOOP_REDO, loop1382_redo
  loop1382_done:
    pop_eh 
  for_undef_313:
.annotate 'line', 605
    get_hll_global $P1385, "RoleToRoleApplier"
    find_lex $P1386, "$obj"
    find_lex $P1387, "self"
    get_global $P1388, "$?CLASS"
    getattribute $P1389, $P1387, $P1388, "@!roles"
    unless_null $P1389, vivify_318
    $P1389 = root_new ['parrot';'ResizablePMCArray']
  vivify_318:
    $P1385."apply"($P1386, $P1389)
  if_1348_end:
.annotate 'line', 609
    new $P1390, "Integer"
    assign $P1390, 1
    find_lex $P1391, "self"
    get_global $P1392, "$?CLASS"
    setattribute $P1391, $P1392, "$!composed", $P1390
    find_lex $P1393, "$obj"
.annotate 'line', 597
    .return ($P1393)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1358"  :anon :subid("94_1297619303.875") :outer("93_1297619303.875")
    .param pmc param_1360
.annotate 'line', 601
    .lex "$_", param_1360
.annotate 'line', 602
    find_lex $P1361, "$_"
    find_lex $P1362, "self"
    get_global $P1363, "$?CLASS"
    getattribute $P1364, $P1362, $P1363, "@!done"
    unless_null $P1364, vivify_314
    $P1364 = root_new ['parrot';'ResizablePMCArray']
  vivify_314:
    set $N1365, $P1364
    set $I1366, $N1365
    find_lex $P1367, "self"
    get_global $P1368, "$?CLASS"
    getattribute $P1369, $P1367, $P1368, "@!done"
    unless_null $P1369, vivify_315
    $P1369 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1367, $P1368, "@!done", $P1369
  vivify_315:
    set $P1369[$I1366], $P1361
.annotate 'line', 603
    find_lex $P1370, "$_"
    get_how $P1371, $P1370
    find_lex $P1372, "$_"
    $P1373 = $P1371."instance_of"($P1372)
    find_lex $P1374, "self"
    get_global $P1375, "$?CLASS"
    getattribute $P1376, $P1374, $P1375, "@!done"
    unless_null $P1376, vivify_316
    $P1376 = root_new ['parrot';'ResizablePMCArray']
  vivify_316:
    set $N1377, $P1376
    set $I1378, $N1377
    find_lex $P1379, "self"
    get_global $P1380, "$?CLASS"
    getattribute $P1381, $P1379, $P1380, "@!done"
    unless_null $P1381, vivify_317
    $P1381 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1379, $P1380, "@!done", $P1381
  vivify_317:
    set $P1381[$I1378], $P1373
.annotate 'line', 601
    .return ($P1373)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("95_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1395
    .param pmc param_1396
.annotate 'line', 618
    .const 'Sub' $P1406 = "96_1297619303.875" 
    capture_lex $P1406
    .lex "self", param_1395
    .lex "$obj", param_1396
.annotate 'line', 619
    $P1397 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1397
.annotate 'line', 618
    find_lex $P1398, "@meths"
.annotate 'line', 620
    find_lex $P1400, "self"
    get_global $P1401, "$?CLASS"
    getattribute $P1402, $P1400, $P1401, "%!methods"
    unless_null $P1402, vivify_319
    $P1402 = root_new ['parrot';'Hash']
  vivify_319:
    defined $I1403, $P1402
    unless $I1403, for_undef_320
    iter $P1399, $P1402
    new $P1413, 'ExceptionHandler'
    set_label $P1413, loop1412_handler
    $P1413."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1413
  loop1412_test:
    unless $P1399, loop1412_done
    shift $P1404, $P1399
  loop1412_redo:
    .const 'Sub' $P1406 = "96_1297619303.875" 
    capture_lex $P1406
    $P1406($P1404)
  loop1412_next:
    goto loop1412_test
  loop1412_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1414, exception, 'type'
    eq $P1414, .CONTROL_LOOP_NEXT, loop1412_next
    eq $P1414, .CONTROL_LOOP_REDO, loop1412_redo
  loop1412_done:
    pop_eh 
  for_undef_320:
    find_lex $P1415, "@meths"
.annotate 'line', 618
    .return ($P1415)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1405"  :anon :subid("96_1297619303.875") :outer("95_1297619303.875")
    .param pmc param_1407
.annotate 'line', 620
    .lex "$_", param_1407
.annotate 'line', 621
    find_lex $P1408, "@meths"
    find_lex $P1409, "$_"
    $P1410 = $P1409."value"()
    $P1411 = $P1408."push"($P1410)
.annotate 'line', 620
    .return ($P1411)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "method_table"  :subid("97_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1417
    .param pmc param_1418
.annotate 'line', 626
    .lex "self", param_1417
    .lex "$obj", param_1418
    find_lex $P1419, "self"
    get_global $P1420, "$?CLASS"
    getattribute $P1421, $P1419, $P1420, "%!methods"
    unless_null $P1421, vivify_321
    $P1421 = root_new ['parrot';'Hash']
  vivify_321:
    .return ($P1421)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "collisions"  :subid("98_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1423
    .param pmc param_1424
.annotate 'line', 630
    .lex "self", param_1423
    .lex "$obj", param_1424
    find_lex $P1425, "self"
    get_global $P1426, "$?CLASS"
    getattribute $P1427, $P1425, $P1426, "@!collisions"
    unless_null $P1427, vivify_322
    $P1427 = root_new ['parrot';'ResizablePMCArray']
  vivify_322:
    .return ($P1427)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "name"  :subid("99_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1429
    .param pmc param_1430
.annotate 'line', 634
    .lex "self", param_1429
    .lex "$obj", param_1430
    find_lex $P1431, "self"
    get_global $P1432, "$?CLASS"
    getattribute $P1433, $P1431, $P1432, "$!name"
    unless_null $P1433, vivify_323
    new $P1433, "Undef"
  vivify_323:
    .return ($P1433)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("100_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1435
    .param pmc param_1436
.annotate 'line', 638
    .const 'Sub' $P1446 = "101_1297619303.875" 
    capture_lex $P1446
    .lex "self", param_1435
    .lex "$obj", param_1436
.annotate 'line', 639
    $P1437 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P1437
.annotate 'line', 638
    find_lex $P1438, "@attrs"
.annotate 'line', 640
    find_lex $P1440, "self"
    get_global $P1441, "$?CLASS"
    getattribute $P1442, $P1440, $P1441, "%!attributes"
    unless_null $P1442, vivify_324
    $P1442 = root_new ['parrot';'Hash']
  vivify_324:
    defined $I1443, $P1442
    unless $I1443, for_undef_325
    iter $P1439, $P1442
    new $P1453, 'ExceptionHandler'
    set_label $P1453, loop1452_handler
    $P1453."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1453
  loop1452_test:
    unless $P1439, loop1452_done
    shift $P1444, $P1439
  loop1452_redo:
    .const 'Sub' $P1446 = "101_1297619303.875" 
    capture_lex $P1446
    $P1446($P1444)
  loop1452_next:
    goto loop1452_test
  loop1452_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1454, exception, 'type'
    eq $P1454, .CONTROL_LOOP_NEXT, loop1452_next
    eq $P1454, .CONTROL_LOOP_REDO, loop1452_redo
  loop1452_done:
    pop_eh 
  for_undef_325:
    find_lex $P1455, "@attrs"
.annotate 'line', 638
    .return ($P1455)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1445"  :anon :subid("101_1297619303.875") :outer("100_1297619303.875")
    .param pmc param_1447
.annotate 'line', 640
    .lex "$_", param_1447
.annotate 'line', 641
    find_lex $P1448, "@attrs"
    find_lex $P1449, "$_"
    $P1450 = $P1449."value"()
    $P1451 = $P1448."push"($P1450)
.annotate 'line', 640
    .return ($P1451)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "roles"  :subid("102_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1457
    .param pmc param_1458
.annotate 'line', 646
    .lex "self", param_1457
    .lex "$obj", param_1458
    find_lex $P1459, "self"
    get_global $P1460, "$?CLASS"
    getattribute $P1461, $P1459, $P1460, "@!roles"
    unless_null $P1461, vivify_326
    $P1461 = root_new ['parrot';'ResizablePMCArray']
  vivify_326:
    .return ($P1461)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "instance_of"  :subid("103_1297619303.875") :outer("83_1297619303.875")
    .param pmc param_1463
    .param pmc param_1464
.annotate 'line', 650
    .lex "self", param_1463
    .lex "$obj", param_1464
    find_lex $P1465, "self"
    get_global $P1466, "$?CLASS"
    getattribute $P1467, $P1465, $P1466, "$!instance_of"
    unless_null $P1467, vivify_327
    new $P1467, "Undef"
  vivify_327:
    .return ($P1467)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1536"  :subid("105_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 660
    .const 'Sub' $P1834 = "128_1297619303.875" 
    capture_lex $P1834
    .const 'Sub' $P1826 = "127_1297619303.875" 
    capture_lex $P1826
    .const 'Sub' $P1804 = "125_1297619303.875" 
    capture_lex $P1804
    .const 'Sub' $P1798 = "124_1297619303.875" 
    capture_lex $P1798
    .const 'Sub' $P1792 = "123_1297619303.875" 
    capture_lex $P1792
    .const 'Sub' $P1770 = "121_1297619303.875" 
    capture_lex $P1770
    .const 'Sub' $P1664 = "116_1297619303.875" 
    capture_lex $P1664
    .const 'Sub' $P1661 = "115_1297619303.875" 
    capture_lex $P1661
    .const 'Sub' $P1654 = "114_1297619303.875" 
    capture_lex $P1654
    .const 'Sub' $P1641 = "113_1297619303.875" 
    capture_lex $P1641
    .const 'Sub' $P1637 = "112_1297619303.875" 
    capture_lex $P1637
    .const 'Sub' $P1616 = "111_1297619303.875" 
    capture_lex $P1616
    .const 'Sub' $P1595 = "110_1297619303.875" 
    capture_lex $P1595
    .const 'Sub' $P1576 = "109_1297619303.875" 
    capture_lex $P1576
    .const 'Sub' $P1560 = "108_1297619303.875" 
    capture_lex $P1560
    .const 'Sub' $P1550 = "107_1297619303.875" 
    capture_lex $P1550
    .const 'Sub' $P1539 = "106_1297619303.875" 
    capture_lex $P1539
    get_global $P1538, "$?CLASS"
.annotate 'line', 820
    .const 'Sub' $P1826 = "127_1297619303.875" 
    newclosure $P1832, $P1826
.annotate 'line', 660
    .return ($P1832)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "" :load :init :subid("post328") :outer("105_1297619303.875")
.annotate 'line', 660
    get_hll_global $P1537, ["NQPParametricRoleHOW"], "_block1536" 
    .local pmc block
    set block, $P1537
    .const 'Sub' $P1834 = "128_1297619303.875" 
    capture_lex $P1834
    $P1834()
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1833"  :anon :subid("128_1297619303.875") :outer("105_1297619303.875")
.annotate 'line', 660
    get_hll_global $P1835, "KnowHOW"
    $P1836 = $P1835."new_type"("NQPParametricRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1836
    set_hll_global "NQPParametricRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1837, type_obj
    get_hll_global $P1838, "KnowHOWAttribute"
    $P1839 = $P1838."new"("$!name" :named("name"))
    $P1837."add_attribute"(type_obj, $P1839)
    get_how $P1840, type_obj
    get_hll_global $P1841, "KnowHOWAttribute"
    $P1842 = $P1841."new"("%!attributes" :named("name"))
    $P1840."add_attribute"(type_obj, $P1842)
    get_how $P1843, type_obj
    get_hll_global $P1844, "KnowHOWAttribute"
    $P1845 = $P1844."new"("%!methods" :named("name"))
    $P1843."add_attribute"(type_obj, $P1845)
    get_how $P1846, type_obj
    get_hll_global $P1847, "KnowHOWAttribute"
    $P1848 = $P1847."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1846."add_attribute"(type_obj, $P1848)
    get_how $P1849, type_obj
    get_hll_global $P1850, "KnowHOWAttribute"
    $P1851 = $P1850."new"("@!roles" :named("name"))
    $P1849."add_attribute"(type_obj, $P1851)
    get_how $P1852, type_obj
    get_hll_global $P1853, "KnowHOWAttribute"
    $P1854 = $P1853."new"("$!composed" :named("name"))
    $P1852."add_attribute"(type_obj, $P1854)
    get_how $P1855, type_obj
    get_hll_global $P1856, "KnowHOWAttribute"
    $P1857 = $P1856."new"("$!body_block" :named("name"))
    $P1855."add_attribute"(type_obj, $P1857)
    get_how $P1858, type_obj
    .const 'Sub' $P1859 = "106_1297619303.875" 
    $P1858."add_method"(type_obj, "new", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "107_1297619303.875" 
    $P1860."add_method"(type_obj, "BUILD", $P1861)
    get_how $P1862, type_obj
    .const 'Sub' $P1863 = "108_1297619303.875" 
    $P1862."add_method"(type_obj, "new_type", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "109_1297619303.875" 
    $P1864."add_method"(type_obj, "add_method", $P1865)
    get_how $P1866, type_obj
    .const 'Sub' $P1867 = "110_1297619303.875" 
    $P1866."add_method"(type_obj, "add_multi_method", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "111_1297619303.875" 
    $P1868."add_method"(type_obj, "add_attribute", $P1869)
    get_how $P1870, type_obj
    .const 'Sub' $P1871 = "112_1297619303.875" 
    $P1870."add_method"(type_obj, "add_parent", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "113_1297619303.875" 
    $P1872."add_method"(type_obj, "add_role", $P1873)
    get_how $P1874, type_obj
    .const 'Sub' $P1875 = "114_1297619303.875" 
    $P1874."add_method"(type_obj, "compose", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "115_1297619303.875" 
    $P1876."add_method"(type_obj, "parametric", $P1877)
    get_how $P1878, type_obj
    .const 'Sub' $P1879 = "116_1297619303.875" 
    $P1878."add_method"(type_obj, "instantiate", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "121_1297619303.875" 
    $P1880."add_method"(type_obj, "methods", $P1881)
    get_how $P1882, type_obj
    .const 'Sub' $P1883 = "123_1297619303.875" 
    $P1882."add_method"(type_obj, "method_table", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "124_1297619303.875" 
    $P1884."add_method"(type_obj, "name", $P1885)
    get_how $P1886, type_obj
    .const 'Sub' $P1887 = "125_1297619303.875" 
    $P1886."add_method"(type_obj, "attributes", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "127_1297619303.875" 
    $P1888."add_method"(type_obj, "roles", $P1889)
    get_how $P1890, type_obj
    $P1891 = $P1890."compose"(type_obj)
    .return ($P1891)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "new"  :subid("106_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1540
    .param pmc param_1541 :named("name")
    .param pmc param_1542 :named("body_block")
.annotate 'line', 690
    .lex "self", param_1540
    .lex "$name", param_1541
    .lex "$body_block", param_1542
.annotate 'line', 691
    new $P1543, "Undef"
    .lex "$obj", $P1543
    find_lex $P1544, "self"
    repr_instance_of $P1545, $P1544
    store_lex "$obj", $P1545
.annotate 'line', 692
    find_lex $P1546, "$obj"
    find_lex $P1547, "$name"
    find_lex $P1548, "$body_block"
    $P1546."BUILD"($P1547 :named("name"), $P1548 :named("body_block"))
    find_lex $P1549, "$obj"
.annotate 'line', 690
    .return ($P1549)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "BUILD"  :subid("107_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1551
    .param pmc param_1552 :named("name")
    .param pmc param_1553 :named("body_block")
.annotate 'line', 696
    .lex "self", param_1551
    .lex "$name", param_1552
    .lex "$body_block", param_1553
.annotate 'line', 697
    find_lex $P1554, "$name"
    find_lex $P1555, "self"
    get_global $P1556, "$?CLASS"
    setattribute $P1555, $P1556, "$!name", $P1554
.annotate 'line', 698
    find_lex $P1557, "$body_block"
    find_lex $P1558, "self"
    get_global $P1559, "$?CLASS"
    setattribute $P1558, $P1559, "$!body_block", $P1557
.annotate 'line', 696
    .return ($P1557)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "new_type"  :subid("108_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1561
    .param pmc param_1562 :named("body_block")
    .param pmc param_1563 :optional :named("name")
    .param int has_param_1563 :opt_flag
    .param pmc param_1565 :optional :named("repr")
    .param int has_param_1565 :opt_flag
.annotate 'line', 703
    .lex "self", param_1561
    .lex "$body_block", param_1562
    if has_param_1563, optparam_329
    new $P1564, "String"
    assign $P1564, "<anon>"
    set param_1563, $P1564
  optparam_329:
    .lex "$name", param_1563
    if has_param_1565, optparam_330
    new $P1566, "String"
    assign $P1566, "P6opaque"
    set param_1565, $P1566
  optparam_330:
    .lex "$repr", param_1565
.annotate 'line', 704
    new $P1567, "Undef"
    .lex "$metarole", $P1567
    find_lex $P1568, "self"
    find_lex $P1569, "$name"
    find_lex $P1570, "$body_block"
    $P1571 = $P1568."new"($P1569 :named("name"), $P1570 :named("body_block"))
    store_lex "$metarole", $P1571
.annotate 'line', 705
    find_lex $P1572, "$metarole"
    find_lex $P1573, "$repr"
    set $S1574, $P1573
    repr_type_object_for $P1575, $P1572, $S1574
.annotate 'line', 703
    .return ($P1575)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_method"  :subid("109_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1577
    .param pmc param_1578
    .param pmc param_1579
    .param pmc param_1580
.annotate 'line', 708
    .lex "self", param_1577
    .lex "$obj", param_1578
    .lex "$name", param_1579
    .lex "$code_obj", param_1580
.annotate 'line', 709
    find_lex $P1582, "$name"
    find_lex $P1583, "self"
    get_global $P1584, "$?CLASS"
    getattribute $P1585, $P1583, $P1584, "%!methods"
    unless_null $P1585, vivify_331
    $P1585 = root_new ['parrot';'Hash']
  vivify_331:
    set $P1586, $P1585[$P1582]
    unless_null $P1586, vivify_332
    new $P1586, "Undef"
  vivify_332:
    unless $P1586, if_1581_end
.annotate 'line', 710
    new $P1587, "String"
    assign $P1587, "This role already has a method named "
    find_lex $P1588, "$name"
    concat $P1589, $P1587, $P1588
    die $P1589
  if_1581_end:
.annotate 'line', 712
    find_lex $P1590, "$code_obj"
    find_lex $P1591, "$name"
    find_lex $P1592, "self"
    get_global $P1593, "$?CLASS"
    getattribute $P1594, $P1592, $P1593, "%!methods"
    unless_null $P1594, vivify_333
    $P1594 = root_new ['parrot';'Hash']
    setattribute $P1592, $P1593, "%!methods", $P1594
  vivify_333:
    set $P1594[$P1591], $P1590
.annotate 'line', 708
    .return ($P1590)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_multi_method"  :subid("110_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1596
    .param pmc param_1597
    .param pmc param_1598
    .param pmc param_1599
.annotate 'line', 715
    .lex "self", param_1596
    .lex "$obj", param_1597
    .lex "$name", param_1598
    .lex "$code_obj", param_1599
.annotate 'line', 716
    $P1600 = root_new ['parrot';'Hash']
    .lex "%todo", $P1600
.annotate 'line', 715
    find_lex $P1601, "%todo"
.annotate 'line', 717
    find_lex $P1602, "$name"
    find_lex $P1603, "%todo"
    unless_null $P1603, vivify_334
    $P1603 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1603
  vivify_334:
    set $P1603["name"], $P1602
.annotate 'line', 718
    find_lex $P1604, "$code_obj"
    find_lex $P1605, "%todo"
    unless_null $P1605, vivify_335
    $P1605 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1605
  vivify_335:
    set $P1605["code"], $P1604
.annotate 'line', 719
    find_lex $P1606, "%todo"
    find_lex $P1607, "self"
    get_global $P1608, "$?CLASS"
    getattribute $P1609, $P1607, $P1608, "@!multi_methods_to_incorporate"
    unless_null $P1609, vivify_336
    $P1609 = root_new ['parrot';'ResizablePMCArray']
  vivify_336:
    set $N1610, $P1609
    set $I1611, $N1610
    find_lex $P1612, "self"
    get_global $P1613, "$?CLASS"
    getattribute $P1614, $P1612, $P1613, "@!multi_methods_to_incorporate"
    unless_null $P1614, vivify_337
    $P1614 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1612, $P1613, "@!multi_methods_to_incorporate", $P1614
  vivify_337:
    set $P1614[$I1611], $P1606
    find_lex $P1615, "$code_obj"
.annotate 'line', 715
    .return ($P1615)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_attribute"  :subid("111_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1617
    .param pmc param_1618
    .param pmc param_1619
.annotate 'line', 723
    .lex "self", param_1617
    .lex "$obj", param_1618
    .lex "$meta_attr", param_1619
.annotate 'line', 724
    new $P1620, "Undef"
    .lex "$name", $P1620
    find_lex $P1621, "$meta_attr"
    $P1622 = $P1621."name"()
    store_lex "$name", $P1622
.annotate 'line', 725
    find_lex $P1624, "$name"
    find_lex $P1625, "self"
    get_global $P1626, "$?CLASS"
    getattribute $P1627, $P1625, $P1626, "%!attributes"
    unless_null $P1627, vivify_338
    $P1627 = root_new ['parrot';'Hash']
  vivify_338:
    set $P1628, $P1627[$P1624]
    unless_null $P1628, vivify_339
    new $P1628, "Undef"
  vivify_339:
    unless $P1628, if_1623_end
.annotate 'line', 726
    new $P1629, "String"
    assign $P1629, "This role already has an attribute named "
    find_lex $P1630, "$name"
    concat $P1631, $P1629, $P1630
    die $P1631
  if_1623_end:
.annotate 'line', 728
    find_lex $P1632, "$meta_attr"
    find_lex $P1633, "$name"
    find_lex $P1634, "self"
    get_global $P1635, "$?CLASS"
    getattribute $P1636, $P1634, $P1635, "%!attributes"
    unless_null $P1636, vivify_340
    $P1636 = root_new ['parrot';'Hash']
    setattribute $P1634, $P1635, "%!attributes", $P1636
  vivify_340:
    set $P1636[$P1633], $P1632
.annotate 'line', 723
    .return ($P1632)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_parent"  :subid("112_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1638
    .param pmc param_1639
    .param pmc param_1640
.annotate 'line', 731
    .lex "self", param_1638
    .lex "$obj", param_1639
    .lex "$parent", param_1640
.annotate 'line', 732
    die "A role cannot inherit from a class"
.annotate 'line', 731
    .return ()
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_role"  :subid("113_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1642
    .param pmc param_1643
    .param pmc param_1644
.annotate 'line', 735
    .lex "self", param_1642
    .lex "$obj", param_1643
    .lex "$role", param_1644
.annotate 'line', 736
    find_lex $P1645, "$role"
    find_lex $P1646, "self"
    get_global $P1647, "$?CLASS"
    getattribute $P1648, $P1646, $P1647, "@!roles"
    unless_null $P1648, vivify_341
    $P1648 = root_new ['parrot';'ResizablePMCArray']
  vivify_341:
    set $N1649, $P1648
    set $I1650, $N1649
    find_lex $P1651, "self"
    get_global $P1652, "$?CLASS"
    getattribute $P1653, $P1651, $P1652, "@!roles"
    unless_null $P1653, vivify_342
    $P1653 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1651, $P1652, "@!roles", $P1653
  vivify_342:
    set $P1653[$I1650], $P1645
.annotate 'line', 735
    .return ($P1645)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "compose"  :subid("114_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1655
    .param pmc param_1656
.annotate 'line', 740
    .lex "self", param_1655
    .lex "$obj", param_1656
.annotate 'line', 741
    new $P1657, "Integer"
    assign $P1657, 1
    find_lex $P1658, "self"
    get_global $P1659, "$?CLASS"
    setattribute $P1658, $P1659, "$!composed", $P1657
    find_lex $P1660, "$obj"
.annotate 'line', 740
    .return ($P1660)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "parametric"  :subid("115_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1662
    .param pmc param_1663
.annotate 'line', 751
    .lex "self", param_1662
    .lex "$obj", param_1663
    .return (1)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "instantiate"  :subid("116_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1667
    .param pmc param_1668
    .param pmc param_1669
.annotate 'line', 757
    .const 'Sub' $P1748 = "120_1297619303.875" 
    capture_lex $P1748
    .const 'Sub' $P1727 = "119_1297619303.875" 
    capture_lex $P1727
    .const 'Sub' $P1706 = "118_1297619303.875" 
    capture_lex $P1706
    .const 'Sub' $P1688 = "117_1297619303.875" 
    capture_lex $P1688
    new $P1666, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1666, control_1665
    push_eh $P1666
    .lex "self", param_1667
    .lex "$obj", param_1668
    .lex "$class_arg", param_1669
.annotate 'line', 763
    new $P1670, "Undef"
    .lex "$irole", $P1670
.annotate 'line', 760
    find_lex $P1671, "self"
    get_global $P1672, "$?CLASS"
    getattribute $P1673, $P1671, $P1672, "$!body_block"
    unless_null $P1673, vivify_343
    new $P1673, "Undef"
  vivify_343:
    find_lex $P1674, "$class_arg"
    $P1673($P1674)
.annotate 'line', 763
    get_hll_global $P1675, "NQPConcreteRoleHOW"
    find_lex $P1676, "self"
    get_global $P1677, "$?CLASS"
    getattribute $P1678, $P1676, $P1677, "$!name"
    unless_null $P1678, vivify_344
    new $P1678, "Undef"
  vivify_344:
    find_lex $P1679, "$obj"
    $P1680 = $P1675."new_type"($P1678 :named("name"), $P1679 :named("instance_of"))
    store_lex "$irole", $P1680
.annotate 'line', 767
    find_lex $P1682, "self"
    get_global $P1683, "$?CLASS"
    getattribute $P1684, $P1682, $P1683, "%!attributes"
    unless_null $P1684, vivify_345
    $P1684 = root_new ['parrot';'Hash']
  vivify_345:
    defined $I1685, $P1684
    unless $I1685, for_undef_346
    iter $P1681, $P1684
    new $P1697, 'ExceptionHandler'
    set_label $P1697, loop1696_handler
    $P1697."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1697
  loop1696_test:
    unless $P1681, loop1696_done
    shift $P1686, $P1681
  loop1696_redo:
    .const 'Sub' $P1688 = "117_1297619303.875" 
    capture_lex $P1688
    $P1688($P1686)
  loop1696_next:
    goto loop1696_test
  loop1696_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1698, exception, 'type'
    eq $P1698, .CONTROL_LOOP_NEXT, loop1696_next
    eq $P1698, .CONTROL_LOOP_REDO, loop1696_redo
  loop1696_done:
    pop_eh 
  for_undef_346:
.annotate 'line', 773
    find_lex $P1700, "self"
    get_global $P1701, "$?CLASS"
    getattribute $P1702, $P1700, $P1701, "%!methods"
    unless_null $P1702, vivify_347
    $P1702 = root_new ['parrot';'Hash']
  vivify_347:
    defined $I1703, $P1702
    unless $I1703, for_undef_348
    iter $P1699, $P1702
    new $P1718, 'ExceptionHandler'
    set_label $P1718, loop1717_handler
    $P1718."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1718
  loop1717_test:
    unless $P1699, loop1717_done
    shift $P1704, $P1699
  loop1717_redo:
    .const 'Sub' $P1706 = "118_1297619303.875" 
    capture_lex $P1706
    $P1706($P1704)
  loop1717_next:
    goto loop1717_test
  loop1717_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1719, exception, 'type'
    eq $P1719, .CONTROL_LOOP_NEXT, loop1717_next
    eq $P1719, .CONTROL_LOOP_REDO, loop1717_redo
  loop1717_done:
    pop_eh 
  for_undef_348:
.annotate 'line', 776
    find_lex $P1721, "self"
    get_global $P1722, "$?CLASS"
    getattribute $P1723, $P1721, $P1722, "@!multi_methods_to_incorporate"
    unless_null $P1723, vivify_349
    $P1723 = root_new ['parrot';'ResizablePMCArray']
  vivify_349:
    defined $I1724, $P1723
    unless $I1724, for_undef_350
    iter $P1720, $P1723
    new $P1739, 'ExceptionHandler'
    set_label $P1739, loop1738_handler
    $P1739."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1739
  loop1738_test:
    unless $P1720, loop1738_done
    shift $P1725, $P1720
  loop1738_redo:
    .const 'Sub' $P1727 = "119_1297619303.875" 
    capture_lex $P1727
    $P1727($P1725)
  loop1738_next:
    goto loop1738_test
  loop1738_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1740, exception, 'type'
    eq $P1740, .CONTROL_LOOP_NEXT, loop1738_next
    eq $P1740, .CONTROL_LOOP_REDO, loop1738_redo
  loop1738_done:
    pop_eh 
  for_undef_350:
.annotate 'line', 781
    find_lex $P1742, "self"
    get_global $P1743, "$?CLASS"
    getattribute $P1744, $P1742, $P1743, "@!roles"
    unless_null $P1744, vivify_355
    $P1744 = root_new ['parrot';'ResizablePMCArray']
  vivify_355:
    defined $I1745, $P1744
    unless $I1745, for_undef_356
    iter $P1741, $P1744
    new $P1762, 'ExceptionHandler'
    set_label $P1762, loop1761_handler
    $P1762."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1762
  loop1761_test:
    unless $P1741, loop1761_done
    shift $P1746, $P1741
  loop1761_redo:
    .const 'Sub' $P1748 = "120_1297619303.875" 
    capture_lex $P1748
    $P1748($P1746)
  loop1761_next:
    goto loop1761_test
  loop1761_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1763, exception, 'type'
    eq $P1763, .CONTROL_LOOP_NEXT, loop1761_next
    eq $P1763, .CONTROL_LOOP_REDO, loop1761_redo
  loop1761_done:
    pop_eh 
  for_undef_356:
.annotate 'line', 787
    find_lex $P1764, "$irole"
    get_how $P1765, $P1764
    find_lex $P1766, "$irole"
    $P1765."compose"($P1766)
.annotate 'line', 788
    new $P1767, "Exception"
    set $P1767['type'], .CONTROL_RETURN
    find_lex $P1768, "$irole"
    setattribute $P1767, 'payload', $P1768
    throw $P1767
.annotate 'line', 757
    .return ()
  control_1665:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1769, exception, "payload"
    .return ($P1769)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1687"  :anon :subid("117_1297619303.875") :outer("116_1297619303.875")
    .param pmc param_1689
.annotate 'line', 767
    .lex "$_", param_1689
.annotate 'line', 768
    find_lex $P1690, "$irole"
    get_how $P1691, $P1690
    find_lex $P1692, "$irole"
    find_lex $P1693, "$_"
    $P1694 = $P1693."value"()
    $P1695 = $P1691."add_attribute"($P1692, $P1694)
.annotate 'line', 767
    .return ($P1695)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1705"  :anon :subid("118_1297619303.875") :outer("116_1297619303.875")
    .param pmc param_1707
.annotate 'line', 773
    .lex "$_", param_1707
.annotate 'line', 774
    find_lex $P1708, "$irole"
    get_how $P1709, $P1708
    find_lex $P1710, "$irole"
    find_lex $P1711, "$_"
    $P1712 = $P1711."key"()
    find_lex $P1713, "$_"
    $P1714 = $P1713."value"()
    clone $P1715, $P1714
    $P1716 = $P1709."add_method"($P1710, $P1712, $P1715)
.annotate 'line', 773
    .return ($P1716)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1726"  :anon :subid("119_1297619303.875") :outer("116_1297619303.875")
    .param pmc param_1728
.annotate 'line', 776
    .lex "$_", param_1728
.annotate 'line', 777
    find_lex $P1729, "$irole"
    get_how $P1730, $P1729
    find_lex $P1731, "$irole"
    find_lex $P1732, "$_"
    unless_null $P1732, vivify_351
    $P1732 = root_new ['parrot';'Hash']
  vivify_351:
    set $P1733, $P1732["name"]
    unless_null $P1733, vivify_352
    new $P1733, "Undef"
  vivify_352:
    find_lex $P1734, "$_"
    unless_null $P1734, vivify_353
    $P1734 = root_new ['parrot';'Hash']
  vivify_353:
    set $P1735, $P1734["code"]
    unless_null $P1735, vivify_354
    new $P1735, "Undef"
  vivify_354:
    clone $P1736, $P1735
    $P1737 = $P1730."add_multi_method"($P1731, $P1733, $P1736)
.annotate 'line', 776
    .return ($P1737)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1747"  :anon :subid("120_1297619303.875") :outer("116_1297619303.875")
    .param pmc param_1750
.annotate 'line', 782
    new $P1749, "Undef"
    .lex "$instantiated", $P1749
    .lex "$_", param_1750
    find_lex $P1751, "$irole"
    get_how $P1752, $P1751
    find_lex $P1753, "$irole"
    find_lex $P1754, "$class_arg"
    $P1755 = $P1752."instantiate"($P1753, $P1754)
    store_lex "$instantiated", $P1755
.annotate 'line', 783
    find_lex $P1756, "$irole"
    get_how $P1757, $P1756
    find_lex $P1758, "$irole"
    find_lex $P1759, "$instantiated"
    $P1760 = $P1757."add_role"($P1758, $P1759)
.annotate 'line', 781
    .return ($P1760)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("121_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1771
    .param pmc param_1772
.annotate 'line', 796
    .const 'Sub' $P1782 = "122_1297619303.875" 
    capture_lex $P1782
    .lex "self", param_1771
    .lex "$obj", param_1772
.annotate 'line', 797
    $P1773 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1773
.annotate 'line', 796
    find_lex $P1774, "@meths"
.annotate 'line', 798
    find_lex $P1776, "self"
    get_global $P1777, "$?CLASS"
    getattribute $P1778, $P1776, $P1777, "%!methods"
    unless_null $P1778, vivify_357
    $P1778 = root_new ['parrot';'Hash']
  vivify_357:
    defined $I1779, $P1778
    unless $I1779, for_undef_358
    iter $P1775, $P1778
    new $P1789, 'ExceptionHandler'
    set_label $P1789, loop1788_handler
    $P1789."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1789
  loop1788_test:
    unless $P1775, loop1788_done
    shift $P1780, $P1775
  loop1788_redo:
    .const 'Sub' $P1782 = "122_1297619303.875" 
    capture_lex $P1782
    $P1782($P1780)
  loop1788_next:
    goto loop1788_test
  loop1788_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1790, exception, 'type'
    eq $P1790, .CONTROL_LOOP_NEXT, loop1788_next
    eq $P1790, .CONTROL_LOOP_REDO, loop1788_redo
  loop1788_done:
    pop_eh 
  for_undef_358:
    find_lex $P1791, "@meths"
.annotate 'line', 796
    .return ($P1791)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1781"  :anon :subid("122_1297619303.875") :outer("121_1297619303.875")
    .param pmc param_1783
.annotate 'line', 798
    .lex "$_", param_1783
.annotate 'line', 799
    find_lex $P1784, "@meths"
    find_lex $P1785, "$_"
    $P1786 = $P1785."value"()
    $P1787 = $P1784."push"($P1786)
.annotate 'line', 798
    .return ($P1787)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "method_table"  :subid("123_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1793
    .param pmc param_1794
.annotate 'line', 804
    .lex "self", param_1793
    .lex "$obj", param_1794
    find_lex $P1795, "self"
    get_global $P1796, "$?CLASS"
    getattribute $P1797, $P1795, $P1796, "%!methods"
    unless_null $P1797, vivify_359
    $P1797 = root_new ['parrot';'Hash']
  vivify_359:
    .return ($P1797)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "name"  :subid("124_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1799
    .param pmc param_1800
.annotate 'line', 808
    .lex "self", param_1799
    .lex "$obj", param_1800
    find_lex $P1801, "self"
    get_global $P1802, "$?CLASS"
    getattribute $P1803, $P1801, $P1802, "$!name"
    unless_null $P1803, vivify_360
    new $P1803, "Undef"
  vivify_360:
    .return ($P1803)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("125_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1805
    .param pmc param_1806
.annotate 'line', 812
    .const 'Sub' $P1816 = "126_1297619303.875" 
    capture_lex $P1816
    .lex "self", param_1805
    .lex "$obj", param_1806
.annotate 'line', 813
    $P1807 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P1807
.annotate 'line', 812
    find_lex $P1808, "@attrs"
.annotate 'line', 814
    find_lex $P1810, "self"
    get_global $P1811, "$?CLASS"
    getattribute $P1812, $P1810, $P1811, "%!attributes"
    unless_null $P1812, vivify_361
    $P1812 = root_new ['parrot';'Hash']
  vivify_361:
    defined $I1813, $P1812
    unless $I1813, for_undef_362
    iter $P1809, $P1812
    new $P1823, 'ExceptionHandler'
    set_label $P1823, loop1822_handler
    $P1823."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1823
  loop1822_test:
    unless $P1809, loop1822_done
    shift $P1814, $P1809
  loop1822_redo:
    .const 'Sub' $P1816 = "126_1297619303.875" 
    capture_lex $P1816
    $P1816($P1814)
  loop1822_next:
    goto loop1822_test
  loop1822_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1824, exception, 'type'
    eq $P1824, .CONTROL_LOOP_NEXT, loop1822_next
    eq $P1824, .CONTROL_LOOP_REDO, loop1822_redo
  loop1822_done:
    pop_eh 
  for_undef_362:
    find_lex $P1825, "@attrs"
.annotate 'line', 812
    .return ($P1825)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1815"  :anon :subid("126_1297619303.875") :outer("125_1297619303.875")
    .param pmc param_1817
.annotate 'line', 814
    .lex "$_", param_1817
.annotate 'line', 815
    find_lex $P1818, "@attrs"
    find_lex $P1819, "$_"
    $P1820 = $P1819."value"()
    $P1821 = $P1818."push"($P1820)
.annotate 'line', 814
    .return ($P1821)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "roles"  :subid("127_1297619303.875") :outer("105_1297619303.875")
    .param pmc param_1827
    .param pmc param_1828
.annotate 'line', 820
    .lex "self", param_1827
    .lex "$obj", param_1828
    find_lex $P1829, "self"
    get_global $P1830, "$?CLASS"
    getattribute $P1831, $P1829, $P1830, "@!roles"
    unless_null $P1831, vivify_363
    $P1831 = root_new ['parrot';'ResizablePMCArray']
  vivify_363:
    .return ($P1831)
.end


.namespace ["RoleToClassApplier"]
.sub "_block1892"  :subid("129_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 826
    .const 'Sub' $P2101 = "139_1297619303.875" 
    capture_lex $P2101
    .const 'Sub' $P1965 = "134_1297619303.875" 
    capture_lex $P1965
    .const 'Sub' $P1930 = "132_1297619303.875" 
    capture_lex $P1930
    .const 'Sub' $P1895 = "130_1297619303.875" 
    capture_lex $P1895
    get_global $P1894, "$?CLASS"
.annotate 'line', 828
    .const 'Sub' $P1895 = "130_1297619303.875" 
    newclosure $P1929, $P1895
    .lex "has_method", $P1929
.annotate 'line', 836
    .const 'Sub' $P1930 = "132_1297619303.875" 
    newclosure $P1962, $P1930
    .lex "has_attribute", $P1962
.annotate 'line', 826
    find_lex $P1963, "has_method"
    find_lex $P1964, "has_attribute"
.annotate 'line', 844
    .const 'Sub' $P1965 = "134_1297619303.875" 
    newclosure $P2099, $P1965
.annotate 'line', 826
    .return ($P2099)
.end


.namespace ["RoleToClassApplier"]
.sub "" :load :init :subid("post364") :outer("129_1297619303.875")
.annotate 'line', 826
    get_hll_global $P1893, ["RoleToClassApplier"], "_block1892" 
    .local pmc block
    set block, $P1893
    .const 'Sub' $P2101 = "139_1297619303.875" 
    capture_lex $P2101
    $P2101()
.end


.namespace ["RoleToClassApplier"]
.sub "_block2100"  :anon :subid("139_1297619303.875") :outer("129_1297619303.875")
.annotate 'line', 826
    get_hll_global $P2102, "KnowHOW"
    $P2103 = $P2102."new_type"("RoleToClassApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2103
    set_hll_global "RoleToClassApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "134_1297619303.875" 
    $P2104."add_method"(type_obj, "apply", $P2105)
    get_how $P2106, type_obj
    $P2107 = $P2106."compose"(type_obj)
    .return ($P2107)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_method"  :subid("130_1297619303.875") :outer("129_1297619303.875")
    .param pmc param_1898
    .param pmc param_1899
    .param pmc param_1900
.annotate 'line', 828
    .const 'Sub' $P1912 = "131_1297619303.875" 
    capture_lex $P1912
    new $P1897, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1897, control_1896
    push_eh $P1897
    .lex "$target", param_1898
    .lex "$name", param_1899
    .lex "$local", param_1900
.annotate 'line', 829
    $P1901 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P1901
    find_lex $P1902, "$target"
    get_how $P1903, $P1902
    find_lex $P1904, "$target"
    find_lex $P1905, "$local"
    $P1906 = $P1903."methods"($P1904, $P1905 :named("local"))
    store_lex "@methods", $P1906
.annotate 'line', 830
    find_lex $P1908, "@methods"
    defined $I1909, $P1908
    unless $I1909, for_undef_365
    iter $P1907, $P1908
    new $P1924, 'ExceptionHandler'
    set_label $P1924, loop1923_handler
    $P1924."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1924
  loop1923_test:
    unless $P1907, loop1923_done
    shift $P1910, $P1907
  loop1923_redo:
    .const 'Sub' $P1912 = "131_1297619303.875" 
    capture_lex $P1912
    $P1912($P1910)
  loop1923_next:
    goto loop1923_test
  loop1923_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1925, exception, 'type'
    eq $P1925, .CONTROL_LOOP_NEXT, loop1923_next
    eq $P1925, .CONTROL_LOOP_REDO, loop1923_redo
  loop1923_done:
    pop_eh 
  for_undef_365:
.annotate 'line', 833
    new $P1926, "Exception"
    set $P1926['type'], .CONTROL_RETURN
    new $P1927, "Integer"
    assign $P1927, 0
    setattribute $P1926, 'payload', $P1927
    throw $P1926
.annotate 'line', 828
    .return ()
  control_1896:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1928, exception, "payload"
    .return ($P1928)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block1911"  :anon :subid("131_1297619303.875") :outer("130_1297619303.875")
    .param pmc param_1913
.annotate 'line', 830
    .lex "$_", param_1913
.annotate 'line', 831
    find_lex $P1916, "$_"
    set $S1917, $P1916
    find_lex $P1918, "$name"
    set $S1919, $P1918
    iseq $I1920, $S1917, $S1919
    if $I1920, if_1915
    new $P1914, 'Integer'
    set $P1914, $I1920
    goto if_1915_end
  if_1915:
    new $P1921, "Exception"
    set $P1921['type'], .CONTROL_RETURN
    new $P1922, "Integer"
    assign $P1922, 1
    setattribute $P1921, 'payload', $P1922
    throw $P1921
  if_1915_end:
.annotate 'line', 830
    .return ($P1914)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_attribute"  :subid("132_1297619303.875") :outer("129_1297619303.875")
    .param pmc param_1933
    .param pmc param_1934
.annotate 'line', 836
    .const 'Sub' $P1945 = "133_1297619303.875" 
    capture_lex $P1945
    new $P1932, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1932, control_1931
    push_eh $P1932
    .lex "$target", param_1933
    .lex "$name", param_1934
.annotate 'line', 837
    $P1935 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P1935
    find_lex $P1936, "$target"
    get_how $P1937, $P1936
    find_lex $P1938, "$target"
    $P1939 = $P1937."attributes"($P1938, 1 :named("local"))
    store_lex "@attributes", $P1939
.annotate 'line', 838
    find_lex $P1941, "@attributes"
    defined $I1942, $P1941
    unless $I1942, for_undef_366
    iter $P1940, $P1941
    new $P1957, 'ExceptionHandler'
    set_label $P1957, loop1956_handler
    $P1957."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1957
  loop1956_test:
    unless $P1940, loop1956_done
    shift $P1943, $P1940
  loop1956_redo:
    .const 'Sub' $P1945 = "133_1297619303.875" 
    capture_lex $P1945
    $P1945($P1943)
  loop1956_next:
    goto loop1956_test
  loop1956_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1958, exception, 'type'
    eq $P1958, .CONTROL_LOOP_NEXT, loop1956_next
    eq $P1958, .CONTROL_LOOP_REDO, loop1956_redo
  loop1956_done:
    pop_eh 
  for_undef_366:
.annotate 'line', 841
    new $P1959, "Exception"
    set $P1959['type'], .CONTROL_RETURN
    new $P1960, "Integer"
    assign $P1960, 0
    setattribute $P1959, 'payload', $P1960
    throw $P1959
.annotate 'line', 836
    .return ()
  control_1931:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1961, exception, "payload"
    .return ($P1961)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block1944"  :anon :subid("133_1297619303.875") :outer("132_1297619303.875")
    .param pmc param_1946
.annotate 'line', 838
    .lex "$_", param_1946
.annotate 'line', 839
    find_lex $P1949, "$_"
    $S1950 = $P1949."name"()
    find_lex $P1951, "$name"
    set $S1952, $P1951
    iseq $I1953, $S1950, $S1952
    if $I1953, if_1948
    new $P1947, 'Integer'
    set $P1947, $I1953
    goto if_1948_end
  if_1948:
    new $P1954, "Exception"
    set $P1954['type'], .CONTROL_RETURN
    new $P1955, "Integer"
    assign $P1955, 1
    setattribute $P1954, 'payload', $P1955
    throw $P1954
  if_1948_end:
.annotate 'line', 838
    .return ($P1947)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("134_1297619303.875") :outer("129_1297619303.875")
    .param pmc param_1966
    .param pmc param_1967
    .param pmc param_1968
.annotate 'line', 844
    .const 'Sub' $P2070 = "138_1297619303.875" 
    capture_lex $P2070
    .const 'Sub' $P2044 = "137_1297619303.875" 
    capture_lex $P2044
    .const 'Sub' $P2015 = "136_1297619303.875" 
    capture_lex $P2015
    .const 'Sub' $P1995 = "135_1297619303.875" 
    capture_lex $P1995
    .lex "self", param_1966
    .lex "$target", param_1967
    .lex "@roles", param_1968
.annotate 'line', 847
    new $P1969, "Undef"
    .lex "$to_compose", $P1969
.annotate 'line', 848
    new $P1970, "Undef"
    .lex "$to_compose_meta", $P1970
.annotate 'line', 863
    $P1971 = root_new ['parrot';'ResizablePMCArray']
    .lex "@collisions", $P1971
.annotate 'line', 872
    $P1972 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P1972
.annotate 'line', 880
    $P1973 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P1973
.annotate 'line', 892
    $P1974 = root_new ['parrot';'ResizablePMCArray']
    .lex "@done", $P1974
.annotate 'line', 844
    find_lex $P1975, "$to_compose"
    find_lex $P1976, "$to_compose_meta"
.annotate 'line', 849
    find_lex $P1978, "@roles"
    set $N1979, $P1978
    iseq $I1980, $N1979, 1.0
    if $I1980, if_1977
.annotate 'line', 854
    get_hll_global $P1985, "NQPConcreteRoleHOW"
    get_hll_global $P1986, "NQPMu"
    $P1987 = $P1985."new_type"($P1986 :named("instance_of"))
    store_lex "$to_compose", $P1987
.annotate 'line', 855
    find_lex $P1988, "$to_compose"
    get_how $P1989, $P1988
    store_lex "$to_compose_meta", $P1989
.annotate 'line', 856
    find_lex $P1991, "@roles"
    defined $I1992, $P1991
    unless $I1992, for_undef_367
    iter $P1990, $P1991
    new $P2002, 'ExceptionHandler'
    set_label $P2002, loop2001_handler
    $P2002."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2002
  loop2001_test:
    unless $P1990, loop2001_done
    shift $P1993, $P1990
  loop2001_redo:
    .const 'Sub' $P1995 = "135_1297619303.875" 
    capture_lex $P1995
    $P1995($P1993)
  loop2001_next:
    goto loop2001_test
  loop2001_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2003, exception, 'type'
    eq $P2003, .CONTROL_LOOP_NEXT, loop2001_next
    eq $P2003, .CONTROL_LOOP_REDO, loop2001_redo
  loop2001_done:
    pop_eh 
  for_undef_367:
.annotate 'line', 859
    find_lex $P2004, "$to_compose_meta"
    find_lex $P2005, "$to_compose"
    $P2006 = $P2004."compose"($P2005)
    store_lex "$to_compose", $P2006
.annotate 'line', 853
    goto if_1977_end
  if_1977:
.annotate 'line', 850
    find_lex $P1981, "@roles"
    unless_null $P1981, vivify_368
    $P1981 = root_new ['parrot';'ResizablePMCArray']
  vivify_368:
    set $P1982, $P1981[0]
    unless_null $P1982, vivify_369
    new $P1982, "Undef"
  vivify_369:
    store_lex "$to_compose", $P1982
.annotate 'line', 851
    find_lex $P1983, "$to_compose"
    get_how $P1984, $P1983
    store_lex "$to_compose_meta", $P1984
  if_1977_end:
.annotate 'line', 863
    find_lex $P2007, "$to_compose_meta"
    find_lex $P2008, "$to_compose"
    $P2009 = $P2007."collisions"($P2008)
    store_lex "@collisions", $P2009
.annotate 'line', 864
    find_lex $P2011, "@collisions"
    defined $I2012, $P2011
    unless $I2012, for_undef_370
    iter $P2010, $P2011
    new $P2034, 'ExceptionHandler'
    set_label $P2034, loop2033_handler
    $P2034."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2034
  loop2033_test:
    unless $P2010, loop2033_done
    shift $P2013, $P2010
  loop2033_redo:
    .const 'Sub' $P2015 = "136_1297619303.875" 
    capture_lex $P2015
    $P2015($P2013)
  loop2033_next:
    goto loop2033_test
  loop2033_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2035, exception, 'type'
    eq $P2035, .CONTROL_LOOP_NEXT, loop2033_next
    eq $P2035, .CONTROL_LOOP_REDO, loop2033_redo
  loop2033_done:
    pop_eh 
  for_undef_370:
.annotate 'line', 872
    find_lex $P2036, "$to_compose_meta"
    find_lex $P2037, "$to_compose"
    $P2038 = $P2036."methods"($P2037)
    store_lex "@methods", $P2038
.annotate 'line', 873
    find_lex $P2040, "@methods"
    defined $I2041, $P2040
    unless $I2041, for_undef_371
    iter $P2039, $P2040
    new $P2060, 'ExceptionHandler'
    set_label $P2060, loop2059_handler
    $P2060."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2060
  loop2059_test:
    unless $P2039, loop2059_done
    shift $P2042, $P2039
  loop2059_redo:
    .const 'Sub' $P2044 = "137_1297619303.875" 
    capture_lex $P2044
    $P2044($P2042)
  loop2059_next:
    goto loop2059_test
  loop2059_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2061, exception, 'type'
    eq $P2061, .CONTROL_LOOP_NEXT, loop2059_next
    eq $P2061, .CONTROL_LOOP_REDO, loop2059_redo
  loop2059_done:
    pop_eh 
  for_undef_371:
.annotate 'line', 880
    find_lex $P2062, "$to_compose_meta"
    find_lex $P2063, "$to_compose"
    $P2064 = $P2062."attributes"($P2063)
    store_lex "@attributes", $P2064
.annotate 'line', 881
    find_lex $P2066, "@attributes"
    defined $I2067, $P2066
    unless $I2067, for_undef_372
    iter $P2065, $P2066
    new $P2094, 'ExceptionHandler'
    set_label $P2094, loop2093_handler
    $P2094."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2094
  loop2093_test:
    unless $P2065, loop2093_done
    shift $P2068, $P2065
  loop2093_redo:
    .const 'Sub' $P2070 = "138_1297619303.875" 
    capture_lex $P2070
    $P2070($P2068)
  loop2093_next:
    goto loop2093_test
  loop2093_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2095, exception, 'type'
    eq $P2095, .CONTROL_LOOP_NEXT, loop2093_next
    eq $P2095, .CONTROL_LOOP_REDO, loop2093_redo
  loop2093_done:
    pop_eh 
  for_undef_372:
    find_lex $P2096, "@done"
.annotate 'line', 893
    find_lex $P2097, "$to_compose"
    find_lex $P2098, "@done"
    unless_null $P2098, vivify_373
    $P2098 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@done", $P2098
  vivify_373:
    set $P2098[0], $P2097
.annotate 'line', 844
    .return ($P2097)
.end


.namespace ["RoleToClassApplier"]
.sub "_block1994"  :anon :subid("135_1297619303.875") :outer("134_1297619303.875")
    .param pmc param_1996
.annotate 'line', 856
    .lex "$_", param_1996
.annotate 'line', 857
    find_lex $P1997, "$to_compose_meta"
    find_lex $P1998, "$to_compose"
    find_lex $P1999, "$_"
    $P2000 = $P1997."add_role"($P1998, $P1999)
.annotate 'line', 856
    .return ($P2000)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2014"  :anon :subid("136_1297619303.875") :outer("134_1297619303.875")
    .param pmc param_2016
.annotate 'line', 864
    .lex "$_", param_2016
.annotate 'line', 865
    find_lex $P2019, "$target"
    find_lex $P2020, "$_"
    set $S2021, $P2020
    $P2022 = "has_method"($P2019, $S2021, 1)
    unless $P2022, unless_2018
    set $P2017, $P2022
    goto unless_2018_end
  unless_2018:
.annotate 'line', 866
    new $P2023, 'String'
    set $P2023, "Method '"
    find_lex $P2024, "$_"
    concat $P2025, $P2023, $P2024
    concat $P2026, $P2025, "' collides and a resolution must be provided by the class '"
.annotate 'line', 867
    find_lex $P2027, "$target"
    get_how $P2028, $P2027
    find_lex $P2029, "$target"
    $S2030 = $P2028."name"($P2029)
    concat $P2031, $P2026, $S2030
.annotate 'line', 866
    concat $P2032, $P2031, "'"
.annotate 'line', 867
    die $P2032
  unless_2018_end:
.annotate 'line', 864
    .return ($P2017)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2043"  :anon :subid("137_1297619303.875") :outer("134_1297619303.875")
    .param pmc param_2045
.annotate 'line', 873
    .lex "$_", param_2045
.annotate 'line', 874
    find_lex $P2048, "$target"
    find_lex $P2049, "$_"
    set $S2050, $P2049
    $P2051 = "has_method"($P2048, $S2050, 0)
    unless $P2051, unless_2047
    set $P2046, $P2051
    goto unless_2047_end
  unless_2047:
.annotate 'line', 875
    find_lex $P2052, "$target"
    get_how $P2053, $P2052
    find_lex $P2054, "$target"
    find_lex $P2055, "$_"
    set $S2056, $P2055
    find_lex $P2057, "$_"
    $P2058 = $P2053."add_method"($P2054, $S2056, $P2057)
.annotate 'line', 874
    set $P2046, $P2058
  unless_2047_end:
.annotate 'line', 873
    .return ($P2046)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2069"  :anon :subid("138_1297619303.875") :outer("134_1297619303.875")
    .param pmc param_2071
.annotate 'line', 881
    .lex "$_", param_2071
.annotate 'line', 882
    find_lex $P2073, "$target"
    find_lex $P2074, "$_"
    $P2075 = $P2074."name"()
    $P2076 = "has_attribute"($P2073, $P2075)
    unless $P2076, if_2072_end
.annotate 'line', 883
    new $P2077, "String"
    assign $P2077, "Attribute '"
    find_lex $P2078, "$_"
    $S2079 = $P2078."name"()
    concat $P2080, $P2077, $S2079
    concat $P2081, $P2080, "' already exists in the class '"
.annotate 'line', 884
    find_lex $P2082, "$target"
    get_how $P2083, $P2082
    find_lex $P2084, "$target"
    $S2085 = $P2083."name"($P2084)
    concat $P2086, $P2081, $S2085
.annotate 'line', 883
    concat $P2087, $P2086, "', but a role also wishes to compose it"
.annotate 'line', 884
    die $P2087
  if_2072_end:
.annotate 'line', 886
    find_lex $P2088, "$target"
    get_how $P2089, $P2088
    find_lex $P2090, "$target"
    find_lex $P2091, "$_"
    $P2092 = $P2089."add_attribute"($P2090, $P2091)
.annotate 'line', 881
    .return ($P2092)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2108"  :subid("140_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 898
    .const 'Sub' $P2331 = "150_1297619303.875" 
    capture_lex $P2331
    .const 'Sub' $P2111 = "141_1297619303.875" 
    capture_lex $P2111
    get_global $P2110, "$?CLASS"
.annotate 'line', 899
    .const 'Sub' $P2111 = "141_1297619303.875" 
    newclosure $P2329, $P2111
.annotate 'line', 898
    .return ($P2329)
.end


.namespace ["RoleToRoleApplier"]
.sub "" :load :init :subid("post374") :outer("140_1297619303.875")
.annotate 'line', 898
    get_hll_global $P2109, ["RoleToRoleApplier"], "_block2108" 
    .local pmc block
    set block, $P2109
    .const 'Sub' $P2331 = "150_1297619303.875" 
    capture_lex $P2331
    $P2331()
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2330"  :anon :subid("150_1297619303.875") :outer("140_1297619303.875")
.annotate 'line', 898
    get_hll_global $P2332, "KnowHOW"
    $P2333 = $P2332."new_type"("RoleToRoleApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2333
    set_hll_global "RoleToRoleApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2334, type_obj
    .const 'Sub' $P2335 = "141_1297619303.875" 
    $P2334."add_method"(type_obj, "apply", $P2335)
    get_how $P2336, type_obj
    $P2337 = $P2336."compose"(type_obj)
    .return ($P2337)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("141_1297619303.875") :outer("140_1297619303.875")
    .param pmc param_2114
    .param pmc param_2115
    .param pmc param_2116
.annotate 'line', 899
    .const 'Sub' $P2256 = "147_1297619303.875" 
    capture_lex $P2256
    .const 'Sub' $P2214 = "146_1297619303.875" 
    capture_lex $P2214
    .const 'Sub' $P2200 = "145_1297619303.875" 
    capture_lex $P2200
    .const 'Sub' $P2127 = "142_1297619303.875" 
    capture_lex $P2127
    new $P2113, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2113, control_2112
    push_eh $P2113
    .lex "self", param_2114
    .lex "$target", param_2115
    .lex "@roles", param_2116
.annotate 'line', 901
    $P2117 = root_new ['parrot';'Hash']
    .lex "%meth_info", $P2117
.annotate 'line', 927
    $P2118 = root_new ['parrot';'Hash']
    .lex "%target_meth_info", $P2118
.annotate 'line', 928
    $P2119 = root_new ['parrot';'ResizablePMCArray']
    .lex "@target_meths", $P2119
.annotate 'line', 953
    $P2120 = root_new ['parrot';'ResizablePMCArray']
    .lex "@all_roles", $P2120
.annotate 'line', 899
    find_lex $P2121, "%meth_info"
.annotate 'line', 902
    find_lex $P2123, "@roles"
    defined $I2124, $P2123
    unless $I2124, for_undef_375
    iter $P2122, $P2123
    new $P2188, 'ExceptionHandler'
    set_label $P2188, loop2187_handler
    $P2188."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2188
  loop2187_test:
    unless $P2122, loop2187_done
    shift $P2125, $P2122
  loop2187_redo:
    .const 'Sub' $P2127 = "142_1297619303.875" 
    capture_lex $P2127
    $P2127($P2125)
  loop2187_next:
    goto loop2187_test
  loop2187_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2189, exception, 'type'
    eq $P2189, .CONTROL_LOOP_NEXT, loop2187_next
    eq $P2189, .CONTROL_LOOP_REDO, loop2187_redo
  loop2187_done:
    pop_eh 
  for_undef_375:
    find_lex $P2190, "%target_meth_info"
.annotate 'line', 928
    find_lex $P2191, "$target"
    get_how $P2192, $P2191
    find_lex $P2193, "$target"
    $P2194 = $P2192."methods"($P2193)
    store_lex "@target_meths", $P2194
.annotate 'line', 929
    find_lex $P2196, "@target_meths"
    defined $I2197, $P2196
    unless $I2197, for_undef_383
    iter $P2195, $P2196
    new $P2207, 'ExceptionHandler'
    set_label $P2207, loop2206_handler
    $P2207."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2207
  loop2206_test:
    unless $P2195, loop2206_done
    shift $P2198, $P2195
  loop2206_redo:
    .const 'Sub' $P2200 = "145_1297619303.875" 
    capture_lex $P2200
    $P2200($P2198)
  loop2206_next:
    goto loop2206_test
  loop2206_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2208, exception, 'type'
    eq $P2208, .CONTROL_LOOP_NEXT, loop2206_next
    eq $P2208, .CONTROL_LOOP_REDO, loop2206_redo
  loop2206_done:
    pop_eh 
  for_undef_383:
.annotate 'line', 934
    find_lex $P2210, "%meth_info"
    defined $I2211, $P2210
    unless $I2211, for_undef_385
    iter $P2209, $P2210
    new $P2248, 'ExceptionHandler'
    set_label $P2248, loop2247_handler
    $P2248."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2248
  loop2247_test:
    unless $P2209, loop2247_done
    shift $P2212, $P2209
  loop2247_redo:
    .const 'Sub' $P2214 = "146_1297619303.875" 
    capture_lex $P2214
    $P2214($P2212)
  loop2247_next:
    goto loop2247_test
  loop2247_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2249, exception, 'type'
    eq $P2249, .CONTROL_LOOP_NEXT, loop2247_next
    eq $P2249, .CONTROL_LOOP_REDO, loop2247_redo
  loop2247_done:
    pop_eh 
  for_undef_385:
    find_lex $P2250, "@all_roles"
.annotate 'line', 954
    find_lex $P2252, "@roles"
    defined $I2253, $P2252
    unless $I2253, for_undef_392
    iter $P2251, $P2252
    new $P2324, 'ExceptionHandler'
    set_label $P2324, loop2323_handler
    $P2324."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2324
  loop2323_test:
    unless $P2251, loop2323_done
    shift $P2254, $P2251
  loop2323_redo:
    .const 'Sub' $P2256 = "147_1297619303.875" 
    capture_lex $P2256
    $P2256($P2254)
  loop2323_next:
    goto loop2323_test
  loop2323_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2325, exception, 'type'
    eq $P2325, .CONTROL_LOOP_NEXT, loop2323_next
    eq $P2325, .CONTROL_LOOP_REDO, loop2323_redo
  loop2323_done:
    pop_eh 
  for_undef_392:
.annotate 'line', 983
    new $P2326, "Exception"
    set $P2326['type'], .CONTROL_RETURN
    find_lex $P2327, "@all_roles"
    setattribute $P2326, 'payload', $P2327
    throw $P2326
.annotate 'line', 899
    .return ()
  control_2112:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2328, exception, "payload"
    .return ($P2328)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2126"  :anon :subid("142_1297619303.875") :outer("141_1297619303.875")
    .param pmc param_2129
.annotate 'line', 902
    .const 'Sub' $P2139 = "143_1297619303.875" 
    capture_lex $P2139
.annotate 'line', 903
    $P2128 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2128
    .lex "$_", param_2129
    find_lex $P2130, "$_"
    get_how $P2131, $P2130
    find_lex $P2132, "$_"
    $P2133 = $P2131."methods"($P2132)
    store_lex "@methods", $P2133
.annotate 'line', 904
    find_lex $P2135, "@methods"
    defined $I2136, $P2135
    unless $I2136, for_undef_376
    iter $P2134, $P2135
    new $P2185, 'ExceptionHandler'
    set_label $P2185, loop2184_handler
    $P2185."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2185
  loop2184_test:
    unless $P2134, loop2184_done
    shift $P2137, $P2134
  loop2184_redo:
    .const 'Sub' $P2139 = "143_1297619303.875" 
    capture_lex $P2139
    $P2139($P2137)
  loop2184_next:
    goto loop2184_test
  loop2184_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2186, exception, 'type'
    eq $P2186, .CONTROL_LOOP_NEXT, loop2184_next
    eq $P2186, .CONTROL_LOOP_REDO, loop2184_redo
  loop2184_done:
    pop_eh 
  for_undef_376:
.annotate 'line', 902
    .return ($P2134)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2138"  :anon :subid("143_1297619303.875") :outer("142_1297619303.875")
    .param pmc param_2144
.annotate 'line', 904
    .const 'Sub' $P2167 = "144_1297619303.875" 
    capture_lex $P2167
.annotate 'line', 905
    new $P2140, "Undef"
    .lex "$name", $P2140
.annotate 'line', 906
    new $P2141, "Undef"
    .lex "$meth", $P2141
.annotate 'line', 907
    $P2142 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meth_list", $P2142
.annotate 'line', 914
    new $P2143, "Undef"
    .lex "$found", $P2143
    .lex "$_", param_2144
.annotate 'line', 905
    find_lex $P2145, "$_"
    set $S2146, $P2145
    new $P2147, 'String'
    set $P2147, $S2146
    store_lex "$name", $P2147
.annotate 'line', 906
    find_lex $P2148, "$_"
    store_lex "$meth", $P2148
    find_lex $P2149, "@meth_list"
.annotate 'line', 908
    find_lex $P2151, "$name"
    find_lex $P2152, "%meth_info"
    unless_null $P2152, vivify_377
    $P2152 = root_new ['parrot';'Hash']
  vivify_377:
    set $P2153, $P2152[$P2151]
    unless_null $P2153, vivify_378
    new $P2153, "Undef"
  vivify_378:
    defined $I2154, $P2153
    if $I2154, if_2150
.annotate 'line', 912
    find_lex $P2158, "@meth_list"
    find_lex $P2159, "$name"
    find_lex $P2160, "%meth_info"
    unless_null $P2160, vivify_379
    $P2160 = root_new ['parrot';'Hash']
    store_lex "%meth_info", $P2160
  vivify_379:
    set $P2160[$P2159], $P2158
.annotate 'line', 911
    goto if_2150_end
  if_2150:
.annotate 'line', 909
    find_lex $P2155, "$name"
    find_lex $P2156, "%meth_info"
    unless_null $P2156, vivify_380
    $P2156 = root_new ['parrot';'Hash']
  vivify_380:
    set $P2157, $P2156[$P2155]
    unless_null $P2157, vivify_381
    new $P2157, "Undef"
  vivify_381:
    store_lex "@meth_list", $P2157
  if_2150_end:
.annotate 'line', 914
    new $P2161, "Integer"
    assign $P2161, 0
    store_lex "$found", $P2161
.annotate 'line', 915
    find_lex $P2163, "@meth_list"
    defined $I2164, $P2163
    unless $I2164, for_undef_382
    iter $P2162, $P2163
    new $P2176, 'ExceptionHandler'
    set_label $P2176, loop2175_handler
    $P2176."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2176
  loop2175_test:
    unless $P2162, loop2175_done
    shift $P2165, $P2162
  loop2175_redo:
    .const 'Sub' $P2167 = "144_1297619303.875" 
    capture_lex $P2167
    $P2167($P2165)
  loop2175_next:
    goto loop2175_test
  loop2175_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2177, exception, 'type'
    eq $P2177, .CONTROL_LOOP_NEXT, loop2175_next
    eq $P2177, .CONTROL_LOOP_REDO, loop2175_redo
  loop2175_done:
    pop_eh 
  for_undef_382:
.annotate 'line', 920
    find_lex $P2180, "$found"
    unless $P2180, unless_2179
    set $P2178, $P2180
    goto unless_2179_end
  unless_2179:
.annotate 'line', 921
    find_lex $P2181, "@meth_list"
    find_lex $P2182, "$meth"
    $P2183 = $P2181."push"($P2182)
.annotate 'line', 920
    set $P2178, $P2183
  unless_2179_end:
.annotate 'line', 904
    .return ($P2178)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2166"  :anon :subid("144_1297619303.875") :outer("143_1297619303.875")
    .param pmc param_2168
.annotate 'line', 915
    .lex "$_", param_2168
.annotate 'line', 916
    find_lex $P2171, "$meth"
    find_lex $P2172, "$_"
    issame $I2173, $P2171, $P2172
    if $I2173, if_2170
    new $P2169, 'Integer'
    set $P2169, $I2173
    goto if_2170_end
  if_2170:
.annotate 'line', 917
    new $P2174, "Integer"
    assign $P2174, 1
    store_lex "$found", $P2174
.annotate 'line', 916
    set $P2169, $P2174
  if_2170_end:
.annotate 'line', 915
    .return ($P2169)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2199"  :anon :subid("145_1297619303.875") :outer("141_1297619303.875")
    .param pmc param_2201
.annotate 'line', 929
    .lex "$_", param_2201
.annotate 'line', 930
    find_lex $P2202, "$_"
    find_lex $P2203, "$_"
    set $S2204, $P2203
    find_lex $P2205, "%target_meth_info"
    unless_null $P2205, vivify_384
    $P2205 = root_new ['parrot';'Hash']
    store_lex "%target_meth_info", $P2205
  vivify_384:
    set $P2205[$S2204], $P2202
.annotate 'line', 929
    .return ($P2202)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2213"  :anon :subid("146_1297619303.875") :outer("141_1297619303.875")
    .param pmc param_2217
.annotate 'line', 935
    new $P2215, "Undef"
    .lex "$name", $P2215
.annotate 'line', 936
    $P2216 = root_new ['parrot';'ResizablePMCArray']
    .lex "@add_meths", $P2216
    .lex "$_", param_2217
.annotate 'line', 935
    find_lex $P2218, "$_"
    set $S2219, $P2218
    new $P2220, 'String'
    set $P2220, $S2219
    store_lex "$name", $P2220
.annotate 'line', 936
    find_lex $P2221, "$name"
    find_lex $P2222, "%meth_info"
    unless_null $P2222, vivify_386
    $P2222 = root_new ['parrot';'Hash']
  vivify_386:
    set $P2223, $P2222[$P2221]
    unless_null $P2223, vivify_387
    new $P2223, "Undef"
  vivify_387:
    store_lex "@add_meths", $P2223
.annotate 'line', 940
    find_lex $P2226, "$name"
    find_lex $P2227, "%target_meth_info"
    unless_null $P2227, vivify_388
    $P2227 = root_new ['parrot';'Hash']
  vivify_388:
    set $P2228, $P2227[$P2226]
    unless_null $P2228, vivify_389
    new $P2228, "Undef"
  vivify_389:
    defined $I2229, $P2228
    unless $I2229, unless_2225
    new $P2224, 'Integer'
    set $P2224, $I2229
    goto unless_2225_end
  unless_2225:
.annotate 'line', 942
    find_lex $P2232, "@add_meths"
    set $N2233, $P2232
    iseq $I2234, $N2233, 1.0
    if $I2234, if_2231
.annotate 'line', 947
    find_lex $P2242, "$target"
    get_how $P2243, $P2242
    find_lex $P2244, "$target"
    find_lex $P2245, "$name"
    $P2246 = $P2243."add_collision"($P2244, $P2245)
.annotate 'line', 945
    set $P2230, $P2246
.annotate 'line', 942
    goto if_2231_end
  if_2231:
.annotate 'line', 943
    find_lex $P2235, "$target"
    get_how $P2236, $P2235
    find_lex $P2237, "$target"
    find_lex $P2238, "$name"
    find_lex $P2239, "@add_meths"
    unless_null $P2239, vivify_390
    $P2239 = root_new ['parrot';'ResizablePMCArray']
  vivify_390:
    set $P2240, $P2239[0]
    unless_null $P2240, vivify_391
    new $P2240, "Undef"
  vivify_391:
    $P2241 = $P2236."add_method"($P2237, $P2238, $P2240)
.annotate 'line', 942
    set $P2230, $P2241
  if_2231_end:
.annotate 'line', 940
    set $P2224, $P2230
  unless_2225_end:
.annotate 'line', 934
    .return ($P2224)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2255"  :anon :subid("147_1297619303.875") :outer("141_1297619303.875")
    .param pmc param_2259
.annotate 'line', 954
    .const 'Sub' $P2270 = "148_1297619303.875" 
    capture_lex $P2270
.annotate 'line', 955
    new $P2257, "Undef"
    .lex "$how", $P2257
.annotate 'line', 958
    $P2258 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2258
    .lex "$_", param_2259
.annotate 'line', 955
    find_lex $P2260, "$_"
    get_how $P2261, $P2260
    store_lex "$how", $P2261
.annotate 'line', 958
    find_lex $P2262, "$how"
    find_lex $P2263, "$_"
    $P2264 = $P2262."attributes"($P2263)
    store_lex "@attributes", $P2264
.annotate 'line', 959
    find_lex $P2266, "@attributes"
    defined $I2267, $P2266
    unless $I2267, for_undef_393
    iter $P2265, $P2266
    new $P2318, 'ExceptionHandler'
    set_label $P2318, loop2317_handler
    $P2318."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2318
  loop2317_test:
    unless $P2265, loop2317_done
    shift $P2268, $P2265
  loop2317_redo:
    .const 'Sub' $P2270 = "148_1297619303.875" 
    capture_lex $P2270
    $P2270($P2268)
  loop2317_next:
    goto loop2317_test
  loop2317_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2319, exception, 'type'
    eq $P2319, .CONTROL_LOOP_NEXT, loop2317_next
    eq $P2319, .CONTROL_LOOP_REDO, loop2317_redo
  loop2317_done:
    pop_eh 
  for_undef_393:
.annotate 'line', 980
    find_lex $P2320, "@all_roles"
    find_lex $P2321, "$_"
    $P2322 = $P2320."push"($P2321)
.annotate 'line', 954
    .return ($P2322)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2269"  :anon :subid("148_1297619303.875") :outer("147_1297619303.875")
    .param pmc param_2274
.annotate 'line', 959
    .const 'Sub' $P2286 = "149_1297619303.875" 
    capture_lex $P2286
.annotate 'line', 960
    new $P2271, "Undef"
    .lex "$add_attr", $P2271
.annotate 'line', 961
    new $P2272, "Undef"
    .lex "$skip", $P2272
.annotate 'line', 962
    $P2273 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cur_attrs", $P2273
    .lex "$_", param_2274
.annotate 'line', 960
    find_lex $P2275, "$_"
    store_lex "$add_attr", $P2275
.annotate 'line', 961
    new $P2276, "Integer"
    assign $P2276, 0
    store_lex "$skip", $P2276
.annotate 'line', 962
    find_lex $P2277, "$target"
    get_how $P2278, $P2277
    find_lex $P2279, "$target"
    $P2280 = $P2278."attributes"($P2279)
    store_lex "@cur_attrs", $P2280
.annotate 'line', 963
    find_lex $P2282, "@cur_attrs"
    defined $I2283, $P2282
    unless $I2283, for_undef_394
    iter $P2281, $P2282
    new $P2307, 'ExceptionHandler'
    set_label $P2307, loop2306_handler
    $P2307."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2307
  loop2306_test:
    unless $P2281, loop2306_done
    shift $P2284, $P2281
  loop2306_redo:
    .const 'Sub' $P2286 = "149_1297619303.875" 
    capture_lex $P2286
    $P2286($P2284)
  loop2306_next:
    goto loop2306_test
  loop2306_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2308, exception, 'type'
    eq $P2308, .CONTROL_LOOP_NEXT, loop2306_next
    eq $P2308, .CONTROL_LOOP_REDO, loop2306_redo
  loop2306_done:
    pop_eh 
  for_undef_394:
.annotate 'line', 973
    find_lex $P2311, "$skip"
    unless $P2311, unless_2310
    set $P2309, $P2311
    goto unless_2310_end
  unless_2310:
.annotate 'line', 974
    find_lex $P2312, "$target"
    get_how $P2313, $P2312
    find_lex $P2314, "$target"
    find_lex $P2315, "$add_attr"
    $P2316 = $P2313."add_attribute"($P2314, $P2315)
.annotate 'line', 973
    set $P2309, $P2316
  unless_2310_end:
.annotate 'line', 959
    .return ($P2309)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2285"  :anon :subid("149_1297619303.875") :outer("148_1297619303.875")
    .param pmc param_2287
.annotate 'line', 963
    .lex "$_", param_2287
.annotate 'line', 964
    find_lex $P2290, "$_"
    find_lex $P2291, "$add_attr"
    issame $I2292, $P2290, $P2291
    if $I2292, if_2289
.annotate 'line', 968
    find_lex $P2296, "$_"
    $S2297 = $P2296."name"()
    find_lex $P2298, "$add_attr"
    $S2299 = $P2298."name"()
    iseq $I2300, $S2297, $S2299
    if $I2300, if_2295
    new $P2294, 'Integer'
    set $P2294, $I2300
    goto if_2295_end
  if_2295:
.annotate 'line', 969
    new $P2301, "String"
    assign $P2301, "Attribute '"
    find_lex $P2302, "$_"
    $S2303 = $P2302."name"()
    concat $P2304, $P2301, $S2303
    concat $P2305, $P2304, "' conflicts in role composition"
    die $P2305
  if_2295_end:
.annotate 'line', 967
    set $P2288, $P2294
.annotate 'line', 964
    goto if_2289_end
  if_2289:
.annotate 'line', 965
    new $P2293, "Integer"
    assign $P2293, 1
    store_lex "$skip", $P2293
.annotate 'line', 964
    set $P2288, $P2293
  if_2289_end:
.annotate 'line', 963
    .return ($P2288)
.end


.namespace ["NQPModuleHOW"]
.sub "_block2338"  :subid("151_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 988
    .const 'Sub' $P2400 = "160_1297619303.875" 
    capture_lex $P2400
    .const 'Sub' $P2392 = "159_1297619303.875" 
    capture_lex $P2392
    .const 'Sub' $P2386 = "158_1297619303.875" 
    capture_lex $P2386
    .const 'Sub' $P2382 = "157_1297619303.875" 
    capture_lex $P2382
    .const 'Sub' $P2377 = "156_1297619303.875" 
    capture_lex $P2377
    .const 'Sub' $P2372 = "155_1297619303.875" 
    capture_lex $P2372
    .const 'Sub' $P2358 = "154_1297619303.875" 
    capture_lex $P2358
    .const 'Sub' $P2351 = "153_1297619303.875" 
    capture_lex $P2351
    .const 'Sub' $P2341 = "152_1297619303.875" 
    capture_lex $P2341
    get_global $P2340, "$?CLASS"
.annotate 'line', 1027
    .const 'Sub' $P2392 = "159_1297619303.875" 
    newclosure $P2398, $P2392
.annotate 'line', 988
    .return ($P2398)
.end


.namespace ["NQPModuleHOW"]
.sub "" :load :init :subid("post395") :outer("151_1297619303.875")
.annotate 'line', 988
    get_hll_global $P2339, ["NQPModuleHOW"], "_block2338" 
    .local pmc block
    set block, $P2339
    .const 'Sub' $P2400 = "160_1297619303.875" 
    capture_lex $P2400
    $P2400()
.end


.namespace ["NQPModuleHOW"]
.sub "_block2399"  :anon :subid("160_1297619303.875") :outer("151_1297619303.875")
.annotate 'line', 988
    get_hll_global $P2401, "KnowHOW"
    $P2402 = $P2401."new_type"("NQPModuleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P2402
    set_hll_global "NQPModuleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2403, type_obj
    get_hll_global $P2404, "KnowHOWAttribute"
    $P2405 = $P2404."new"("$!name" :named("name"))
    $P2403."add_attribute"(type_obj, $P2405)
    get_how $P2406, type_obj
    get_hll_global $P2407, "KnowHOWAttribute"
    $P2408 = $P2407."new"("$!composed" :named("name"))
    $P2406."add_attribute"(type_obj, $P2408)
    get_how $P2409, type_obj
    .const 'Sub' $P2410 = "152_1297619303.875" 
    $P2409."add_method"(type_obj, "new", $P2410)
    get_how $P2411, type_obj
    .const 'Sub' $P2412 = "153_1297619303.875" 
    $P2411."add_method"(type_obj, "BUILD", $P2412)
    get_how $P2413, type_obj
    .const 'Sub' $P2414 = "154_1297619303.875" 
    $P2413."add_method"(type_obj, "new_type", $P2414)
    get_how $P2415, type_obj
    .const 'Sub' $P2416 = "155_1297619303.875" 
    $P2415."add_method"(type_obj, "add_method", $P2416)
    get_how $P2417, type_obj
    .const 'Sub' $P2418 = "156_1297619303.875" 
    $P2417."add_method"(type_obj, "add_multi_method", $P2418)
    get_how $P2419, type_obj
    .const 'Sub' $P2420 = "157_1297619303.875" 
    $P2419."add_method"(type_obj, "add_attribute", $P2420)
    get_how $P2421, type_obj
    .const 'Sub' $P2422 = "158_1297619303.875" 
    $P2421."add_method"(type_obj, "compose", $P2422)
    get_how $P2423, type_obj
    .const 'Sub' $P2424 = "159_1297619303.875" 
    $P2423."add_method"(type_obj, "name", $P2424)
    get_how $P2425, type_obj
    $P2426 = $P2425."compose"(type_obj)
    .return ($P2426)
.end


.namespace ["NQPModuleHOW"]
.sub "new"  :subid("152_1297619303.875") :outer("151_1297619303.875")
    .param pmc param_2342
    .param pmc param_2343 :optional :named("name")
    .param int has_param_2343 :opt_flag
.annotate 'line', 992
    .lex "self", param_2342
    if has_param_2343, optparam_396
    new $P2344, "Undef"
    set param_2343, $P2344
  optparam_396:
    .lex "$name", param_2343
.annotate 'line', 993
    new $P2345, "Undef"
    .lex "$obj", $P2345
    find_lex $P2346, "self"
    repr_instance_of $P2347, $P2346
    store_lex "$obj", $P2347
.annotate 'line', 994
    find_lex $P2348, "$obj"
    find_lex $P2349, "$name"
    $P2348."BUILD"($P2349 :named("name"))
    find_lex $P2350, "$obj"
.annotate 'line', 992
    .return ($P2350)
.end


.namespace ["NQPModuleHOW"]
.sub "BUILD"  :subid("153_1297619303.875") :outer("151_1297619303.875")
    .param pmc param_2352
    .param pmc param_2353 :optional :named("name")
    .param int has_param_2353 :opt_flag
.annotate 'line', 998
    .lex "self", param_2352
    if has_param_2353, optparam_397
    new $P2354, "Undef"
    set param_2353, $P2354
  optparam_397:
    .lex "$name", param_2353
.annotate 'line', 999
    find_lex $P2355, "$name"
    find_lex $P2356, "self"
    get_global $P2357, "$?CLASS"
    setattribute $P2356, $P2357, "$!name", $P2355
.annotate 'line', 998
    .return ($P2355)
.end


.namespace ["NQPModuleHOW"]
.sub "new_type"  :subid("154_1297619303.875") :outer("151_1297619303.875")
    .param pmc param_2359
    .param pmc param_2360 :optional :named("name")
    .param int has_param_2360 :opt_flag
    .param pmc param_2362 :optional :named("repr")
    .param int has_param_2362 :opt_flag
.annotate 'line', 1004
    .lex "self", param_2359
    if has_param_2360, optparam_398
    new $P2361, "String"
    assign $P2361, "<anon>"
    set param_2360, $P2361
  optparam_398:
    .lex "$name", param_2360
    if has_param_2362, optparam_399
    new $P2363, "String"
    assign $P2363, "P6opaque"
    set param_2362, $P2363
  optparam_399:
    .lex "$repr", param_2362
.annotate 'line', 1005
    new $P2364, "Undef"
    .lex "$metaclass", $P2364
    find_lex $P2365, "self"
    find_lex $P2366, "$name"
    $P2367 = $P2365."new"($P2366 :named("name"))
    store_lex "$metaclass", $P2367
.annotate 'line', 1006
    find_lex $P2368, "$metaclass"
    find_lex $P2369, "$repr"
    set $S2370, $P2369
    repr_type_object_for $P2371, $P2368, $S2370
.annotate 'line', 1004
    .return ($P2371)
.end


.namespace ["NQPModuleHOW"]
.sub "add_method"  :subid("155_1297619303.875") :outer("151_1297619303.875")
    .param pmc param_2373
    .param pmc param_2374
    .param pmc param_2375
    .param pmc param_2376
.annotate 'line', 1009
    .lex "self", param_2373
    .lex "$obj", param_2374
    .lex "$name", param_2375
    .lex "$code_obj", param_2376
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "add_multi_method"  :subid("156_1297619303.875") :outer("151_1297619303.875")
    .param pmc param_2378
    .param pmc param_2379
    .param pmc param_2380
    .param pmc param_2381
.annotate 'line', 1015
    .lex "self", param_2378
    .lex "$obj", param_2379
    .lex "$name", param_2380
    .lex "$code_obj", param_2381
.annotate 'line', 1016
    die "Modules may not have methods"
.annotate 'line', 1015
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "add_attribute"  :subid("157_1297619303.875") :outer("151_1297619303.875")
    .param pmc param_2383
    .param pmc param_2384
    .param pmc param_2385
.annotate 'line', 1019
    .lex "self", param_2383
    .lex "$obj", param_2384
    .lex "$meta_attr", param_2385
.annotate 'line', 1020
    die "Modules may not have attributes"
.annotate 'line', 1019
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "compose"  :subid("158_1297619303.875") :outer("151_1297619303.875")
    .param pmc param_2387
    .param pmc param_2388
.annotate 'line', 1023
    .lex "self", param_2387
    .lex "$obj", param_2388
.annotate 'line', 1024
    new $P2389, "Integer"
    assign $P2389, 1
    find_lex $P2390, "self"
    get_global $P2391, "$?CLASS"
    setattribute $P2390, $P2391, "$!composed", $P2389
.annotate 'line', 1023
    .return ($P2389)
.end


.namespace ["NQPModuleHOW"]
.sub "name"  :subid("159_1297619303.875") :outer("151_1297619303.875")
    .param pmc param_2393
    .param pmc param_2394
.annotate 'line', 1027
    .lex "self", param_2393
    .lex "$obj", param_2394
    find_lex $P2395, "self"
    get_global $P2396, "$?CLASS"
    getattribute $P2397, $P2395, $P2396, "$!name"
    unless_null $P2397, vivify_400
    new $P2397, "Undef"
  vivify_400:
    .return ($P2397)
.end


.namespace ["NQPMu"]
.sub "_block2427"  :subid("161_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 1033
    .const 'Sub' $P2478 = "169_1297619303.875" 
    capture_lex $P2478
    .const 'Sub' $P2468 = "168_1297619303.875" 
    capture_lex $P2468
    .const 'Sub' $P2456 = "167_1297619303.875" 
    capture_lex $P2456
    .const 'Sub' $P2452 = "166_1297619303.875" 
    capture_lex $P2452
    .const 'Sub' $P2441 = "165_1297619303.875" 
    capture_lex $P2441
    .const 'Sub' $P2438 = "164_1297619303.875" 
    capture_lex $P2438
    .const 'Sub' $P2434 = "163_1297619303.875" 
    capture_lex $P2434
    .const 'Sub' $P2430 = "162_1297619303.875" 
    capture_lex $P2430
    get_global $P2429, "$?CLASS"
.annotate 'line', 1052
    .const 'Sub' $P2468 = "168_1297619303.875" 
    newclosure $P2476, $P2468
.annotate 'line', 1033
    .return ($P2476)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post401") :outer("161_1297619303.875")
.annotate 'line', 1033
    get_hll_global $P2428, ["NQPMu"], "_block2427" 
    .local pmc block
    set block, $P2428
    .const 'Sub' $P2478 = "169_1297619303.875" 
    capture_lex $P2478
    $P2478()
.end


.namespace ["NQPMu"]
.sub "_block2477"  :anon :subid("169_1297619303.875") :outer("161_1297619303.875")
.annotate 'line', 1033
    get_hll_global $P2479, "NQPClassHOW"
    $P2480 = $P2479."new_type"("NQPMu" :named("name"))
    .local pmc type_obj
    set type_obj, $P2480
    set_hll_global "NQPMu", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2481, type_obj
    .const 'Sub' $P2482 = "162_1297619303.875" 
    $P2481."add_method"(type_obj, "CREATE", $P2482)
    get_how $P2483, type_obj
    .const 'Sub' $P2484 = "163_1297619303.875" 
    $P2483."add_method"(type_obj, "new", $P2484)
    get_how $P2485, type_obj
    .const 'Sub' $P2486 = "164_1297619303.875" 
    new $P2487, "ResizablePMCArray"
    set_dispatchees $P2486, $P2487
    $P2485."add_method"(type_obj, "Str", $P2486)
    get_how $P2488, type_obj
    .const 'Sub' $P2489 = "165_1297619303.875" 
    $P2488."add_multi_method"(type_obj, "Str", $P2489)
    get_how $P2490, type_obj
    .const 'Sub' $P2491 = "166_1297619303.875" 
    new $P2492, "ResizablePMCArray"
    set_dispatchees $P2491, $P2492
    $P2490."add_method"(type_obj, "ACCEPTS", $P2491)
    get_how $P2493, type_obj
    .const 'Sub' $P2494 = "167_1297619303.875" 
    $P2493."add_multi_method"(type_obj, "ACCEPTS", $P2494)
    get_how $P2495, type_obj
    .const 'Sub' $P2496 = "168_1297619303.875" 
    $P2495."add_method"(type_obj, "isa", $P2496)
    get_how $P2497, type_obj
    $P2498 = $P2497."compose"(type_obj)
    .return ($P2498)
.end


.namespace ["NQPMu"]
.sub "CREATE"  :subid("162_1297619303.875") :outer("161_1297619303.875")
    .param pmc param_2431
.annotate 'line', 1034
    .lex "self", param_2431
.annotate 'line', 1035
    find_lex $P2432, "self"
    repr_instance_of $P2433, $P2432
.annotate 'line', 1034
    .return ($P2433)
.end


.namespace ["NQPMu"]
.sub "new"  :subid("163_1297619303.875") :outer("161_1297619303.875")
    .param pmc param_2435
.annotate 'line', 1038
    .lex "self", param_2435
.annotate 'line', 1039
    find_lex $P2436, "self"
    $P2437 = $P2436."CREATE"()
.annotate 'line', 1038
    .return ($P2437)
.end


.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("164_1297619303.875") :outer("161_1297619303.875")
    .param pmc param_2439
.annotate 'line', 1038
    .lex "self", param_2439
    multi_dispatch_over_lexical_candidates $P2440
    .return ($P2440)
.end


.namespace ["NQPMu"]
.sub "Str"  :subid("165_1297619303.875") :outer("161_1297619303.875")
    .param pmc param_2442
.annotate 'line', 1043
    .lex "$self", param_2442
    find_lex $P2443, "$self"
    .lex "self", $P2443
.annotate 'line', 1044
    find_lex $P2444, "self"
    get_how $P2445, $P2444
    find_lex $P2446, "self"
    $P2447 = $P2445."name"($P2446)
    concat $P2448, $P2447, "()"
.annotate 'line', 1043
    .return ($P2448)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post402") :outer("165_1297619303.875")
.annotate 'line', 1043
    .const 'Sub' $P2441 = "165_1297619303.875" 
    .local pmc block
    set block, $P2441
    get_hll_global $P2449, "Mu"
    new $P2450, "ResizablePMCArray"
    push $P2450, $P2449
    new $P2451, "ResizablePMCArray"
    push $P2451, 2
    set_sub_multisig block, $P2450, $P2451
.end


.namespace ["NQPMu"]
.sub "ACCEPTS" :instanceof("DispatcherSub") :subid("166_1297619303.875") :outer("161_1297619303.875")
    .param pmc param_2453
    .param pmc param_2454
.annotate 'line', 1043
    .lex "self", param_2453
.annotate 'line', 1047
    .lex "$topic", param_2454
.annotate 'line', 1043
    multi_dispatch_over_lexical_candidates $P2455
    .return ($P2455)
.end


.namespace ["NQPMu"]
.sub "ACCEPTS"  :subid("167_1297619303.875") :outer("161_1297619303.875")
    .param pmc param_2457
    .param pmc param_2459
.annotate 'line', 1048
    .lex "$self", param_2457
    find_lex $P2458, "$self"
    .lex "self", $P2458
    .lex "$topic", param_2459
.annotate 'line', 1049
    find_lex $P2460, "$topic"
    find_lex $P2461, "self"
    get_what $P2462, $P2461
    type_check $I2463, $P2460, $P2462
.annotate 'line', 1048
    .return ($I2463)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post403") :outer("167_1297619303.875")
.annotate 'line', 1048
    .const 'Sub' $P2456 = "167_1297619303.875" 
    .local pmc block
    set block, $P2456
    get_hll_global $P2464, "NQPMu"
    null $P2465
    new $P2466, "ResizablePMCArray"
    push $P2466, $P2464
    push $P2466, $P2465
    new $P2467, "ResizablePMCArray"
    push $P2467, 2
    push $P2467, 0
    set_sub_multisig block, $P2466, $P2467
.end


.namespace ["NQPMu"]
.sub "isa"  :subid("168_1297619303.875") :outer("161_1297619303.875")
    .param pmc param_2469
    .param pmc param_2470
.annotate 'line', 1052
    .lex "self", param_2469
    .lex "$type", param_2470
.annotate 'line', 1053
    find_lex $P2471, "self"
    get_how $P2472, $P2471
    find_lex $P2473, "self"
    find_lex $P2474, "$type"
    $P2475 = $P2472."isa"($P2473, $P2474)
.annotate 'line', 1052
    .return ($P2475)
.end


.namespace ["int"]
.sub "_block2499"  :subid("170_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 1059
    .const 'Sub' $P2503 = "171_1297619303.875" 
    capture_lex $P2503
    get_global $P2501, "$?CLASS"
    .return ()
.end


.namespace ["int"]
.sub "" :load :init :subid("post404") :outer("170_1297619303.875")
.annotate 'line', 1059
    get_hll_global $P2500, ["int"], "_block2499" 
    .local pmc block
    set block, $P2500
    .const 'Sub' $P2503 = "171_1297619303.875" 
    capture_lex $P2503
    $P2503()
.end


.namespace ["int"]
.sub "_block2502"  :anon :subid("171_1297619303.875") :outer("170_1297619303.875")
.annotate 'line', 1059
    get_hll_global $P2504, "NQPNativeHOW"
    $P2505 = $P2504."new_type"("int" :named("name"), "P6int" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2505
    set_hll_global "int", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2506, type_obj
    $P2507 = $P2506."compose"(type_obj)
    .return ($P2507)
.end


.namespace ["num"]
.sub "_block2508"  :subid("172_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 1061
    .const 'Sub' $P2512 = "173_1297619303.875" 
    capture_lex $P2512
    get_global $P2510, "$?CLASS"
    .return ()
.end


.namespace ["num"]
.sub "" :load :init :subid("post405") :outer("172_1297619303.875")
.annotate 'line', 1061
    get_hll_global $P2509, ["num"], "_block2508" 
    .local pmc block
    set block, $P2509
    .const 'Sub' $P2512 = "173_1297619303.875" 
    capture_lex $P2512
    $P2512()
.end


.namespace ["num"]
.sub "_block2511"  :anon :subid("173_1297619303.875") :outer("172_1297619303.875")
.annotate 'line', 1061
    get_hll_global $P2513, "NQPNativeHOW"
    $P2514 = $P2513."new_type"("num" :named("name"), "P6num" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2514
    set_hll_global "num", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2515, type_obj
    $P2516 = $P2515."compose"(type_obj)
    .return ($P2516)
.end


.namespace ["str"]
.sub "_block2517"  :subid("174_1297619303.875") :outer("10_1297619303.875")
.annotate 'line', 1063
    .const 'Sub' $P2521 = "175_1297619303.875" 
    capture_lex $P2521
    get_global $P2519, "$?CLASS"
    .return ()
.end


.namespace ["str"]
.sub "" :load :init :subid("post406") :outer("174_1297619303.875")
.annotate 'line', 1063
    get_hll_global $P2518, ["str"], "_block2517" 
    .local pmc block
    set block, $P2518
    .const 'Sub' $P2521 = "175_1297619303.875" 
    capture_lex $P2521
    $P2521()
.end


.namespace ["str"]
.sub "_block2520"  :anon :subid("175_1297619303.875") :outer("174_1297619303.875")
.annotate 'line', 1063
    get_hll_global $P2522, "NQPNativeHOW"
    $P2523 = $P2522."new_type"("str" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2523
    set_hll_global "str", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2524, type_obj
    $P2525 = $P2524."compose"(type_obj)
    .return ($P2525)
.end


.namespace []
.sub "_block2527" :load :anon :subid("176_1297619303.875")
.annotate 'line', 1
    .const 'Sub' $P2529 = "10_1297619303.875" 
    $P2530 = $P2529()
    .return ($P2530)
.end


.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
.end

### .include 'gen/nqp-grammar.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1297619321.796")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Grammar"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
    $P2414 = $P15()
.annotate 'line', 1
    .return ($P2414)
    .const 'Sub' $P2416 = "400_1297619321.796" 
    .return ($P2416)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block14"  :subid("11_1297619321.796") :outer("10_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P1703 = "399_1297619321.796" 
    capture_lex $P1703
    get_hll_global $P1594, ["NQP";"Regex"], "_block1593" 
    capture_lex $P1594
    .const 'Sub' $P1582 = "375_1297619321.796" 
    capture_lex $P1582
    .const 'Sub' $P1576 = "373_1297619321.796" 
    capture_lex $P1576
    .const 'Sub' $P1570 = "371_1297619321.796" 
    capture_lex $P1570
    .const 'Sub' $P1564 = "369_1297619321.796" 
    capture_lex $P1564
    .const 'Sub' $P1558 = "367_1297619321.796" 
    capture_lex $P1558
    .const 'Sub' $P1546 = "364_1297619321.796" 
    capture_lex $P1546
    .const 'Sub' $P1539 = "362_1297619321.796" 
    capture_lex $P1539
    .const 'Sub' $P1532 = "360_1297619321.796" 
    capture_lex $P1532
    .const 'Sub' $P1525 = "358_1297619321.796" 
    capture_lex $P1525
    .const 'Sub' $P1518 = "356_1297619321.796" 
    capture_lex $P1518
    .const 'Sub' $P1512 = "354_1297619321.796" 
    capture_lex $P1512
    .const 'Sub' $P1505 = "352_1297619321.796" 
    capture_lex $P1505
    .const 'Sub' $P1498 = "350_1297619321.796" 
    capture_lex $P1498
    .const 'Sub' $P1491 = "348_1297619321.796" 
    capture_lex $P1491
    .const 'Sub' $P1484 = "346_1297619321.796" 
    capture_lex $P1484
    .const 'Sub' $P1477 = "344_1297619321.796" 
    capture_lex $P1477
    .const 'Sub' $P1470 = "342_1297619321.796" 
    capture_lex $P1470
    .const 'Sub' $P1463 = "340_1297619321.796" 
    capture_lex $P1463
    .const 'Sub' $P1456 = "338_1297619321.796" 
    capture_lex $P1456
    .const 'Sub' $P1449 = "336_1297619321.796" 
    capture_lex $P1449
    .const 'Sub' $P1442 = "334_1297619321.796" 
    capture_lex $P1442
    .const 'Sub' $P1435 = "332_1297619321.796" 
    capture_lex $P1435
    .const 'Sub' $P1428 = "330_1297619321.796" 
    capture_lex $P1428
    .const 'Sub' $P1421 = "328_1297619321.796" 
    capture_lex $P1421
    .const 'Sub' $P1414 = "326_1297619321.796" 
    capture_lex $P1414
    .const 'Sub' $P1407 = "324_1297619321.796" 
    capture_lex $P1407
    .const 'Sub' $P1400 = "322_1297619321.796" 
    capture_lex $P1400
    .const 'Sub' $P1393 = "320_1297619321.796" 
    capture_lex $P1393
    .const 'Sub' $P1386 = "318_1297619321.796" 
    capture_lex $P1386
    .const 'Sub' $P1379 = "316_1297619321.796" 
    capture_lex $P1379
    .const 'Sub' $P1372 = "314_1297619321.796" 
    capture_lex $P1372
    .const 'Sub' $P1365 = "312_1297619321.796" 
    capture_lex $P1365
    .const 'Sub' $P1358 = "310_1297619321.796" 
    capture_lex $P1358
    .const 'Sub' $P1351 = "308_1297619321.796" 
    capture_lex $P1351
    .const 'Sub' $P1344 = "306_1297619321.796" 
    capture_lex $P1344
    .const 'Sub' $P1337 = "304_1297619321.796" 
    capture_lex $P1337
    .const 'Sub' $P1330 = "302_1297619321.796" 
    capture_lex $P1330
    .const 'Sub' $P1323 = "300_1297619321.796" 
    capture_lex $P1323
    .const 'Sub' $P1316 = "298_1297619321.796" 
    capture_lex $P1316
    .const 'Sub' $P1309 = "296_1297619321.796" 
    capture_lex $P1309
    .const 'Sub' $P1303 = "294_1297619321.796" 
    capture_lex $P1303
    .const 'Sub' $P1296 = "292_1297619321.796" 
    capture_lex $P1296
    .const 'Sub' $P1289 = "290_1297619321.796" 
    capture_lex $P1289
    .const 'Sub' $P1282 = "288_1297619321.796" 
    capture_lex $P1282
    .const 'Sub' $P1275 = "286_1297619321.796" 
    capture_lex $P1275
    .const 'Sub' $P1268 = "284_1297619321.796" 
    capture_lex $P1268
    .const 'Sub' $P1261 = "282_1297619321.796" 
    capture_lex $P1261
    .const 'Sub' $P1254 = "280_1297619321.796" 
    capture_lex $P1254
    .const 'Sub' $P1248 = "278_1297619321.796" 
    capture_lex $P1248
    .const 'Sub' $P1242 = "276_1297619321.796" 
    capture_lex $P1242
    .const 'Sub' $P1237 = "274_1297619321.796" 
    capture_lex $P1237
    .const 'Sub' $P1231 = "272_1297619321.796" 
    capture_lex $P1231
    .const 'Sub' $P1225 = "270_1297619321.796" 
    capture_lex $P1225
    .const 'Sub' $P1220 = "268_1297619321.796" 
    capture_lex $P1220
    .const 'Sub' $P1215 = "266_1297619321.796" 
    capture_lex $P1215
    .const 'Sub' $P1199 = "265_1297619321.796" 
    capture_lex $P1199
    .const 'Sub' $P1190 = "263_1297619321.796" 
    capture_lex $P1190
    .const 'Sub' $P1181 = "261_1297619321.796" 
    capture_lex $P1181
    .const 'Sub' $P1176 = "259_1297619321.796" 
    capture_lex $P1176
    .const 'Sub' $P1171 = "257_1297619321.796" 
    capture_lex $P1171
    .const 'Sub' $P1166 = "255_1297619321.796" 
    capture_lex $P1166
    .const 'Sub' $P1158 = "253_1297619321.796" 
    capture_lex $P1158
    .const 'Sub' $P1150 = "251_1297619321.796" 
    capture_lex $P1150
    .const 'Sub' $P1145 = "249_1297619321.796" 
    capture_lex $P1145
    .const 'Sub' $P1140 = "247_1297619321.796" 
    capture_lex $P1140
    .const 'Sub' $P1135 = "245_1297619321.796" 
    capture_lex $P1135
    .const 'Sub' $P1129 = "243_1297619321.796" 
    capture_lex $P1129
    .const 'Sub' $P1123 = "241_1297619321.796" 
    capture_lex $P1123
    .const 'Sub' $P1117 = "239_1297619321.796" 
    capture_lex $P1117
    .const 'Sub' $P1111 = "237_1297619321.796" 
    capture_lex $P1111
    .const 'Sub' $P1105 = "235_1297619321.796" 
    capture_lex $P1105
    .const 'Sub' $P1100 = "233_1297619321.796" 
    capture_lex $P1100
    .const 'Sub' $P1095 = "231_1297619321.796" 
    capture_lex $P1095
    .const 'Sub' $P1081 = "227_1297619321.796" 
    capture_lex $P1081
    .const 'Sub' $P1073 = "225_1297619321.796" 
    capture_lex $P1073
    .const 'Sub' $P1067 = "223_1297619321.796" 
    capture_lex $P1067
    .const 'Sub' $P1060 = "221_1297619321.796" 
    capture_lex $P1060
    .const 'Sub' $P1054 = "219_1297619321.796" 
    capture_lex $P1054
    .const 'Sub' $P1040 = "216_1297619321.796" 
    capture_lex $P1040
    .const 'Sub' $P1032 = "214_1297619321.796" 
    capture_lex $P1032
    .const 'Sub' $P1024 = "212_1297619321.796" 
    capture_lex $P1024
    .const 'Sub' $P1018 = "210_1297619321.796" 
    capture_lex $P1018
    .const 'Sub' $P1012 = "208_1297619321.796" 
    capture_lex $P1012
    .const 'Sub' $P996 = "204_1297619321.796" 
    capture_lex $P996
    .const 'Sub' $P959 = "202_1297619321.796" 
    capture_lex $P959
    .const 'Sub' $P948 = "200_1297619321.796" 
    capture_lex $P948
    .const 'Sub' $P934 = "196_1297619321.796" 
    capture_lex $P934
    .const 'Sub' $P925 = "194_1297619321.796" 
    capture_lex $P925
    .const 'Sub' $P919 = "192_1297619321.796" 
    capture_lex $P919
    .const 'Sub' $P909 = "190_1297619321.796" 
    capture_lex $P909
    .const 'Sub' $P894 = "188_1297619321.796" 
    capture_lex $P894
    .const 'Sub' $P880 = "185_1297619321.796" 
    capture_lex $P880
    .const 'Sub' $P872 = "183_1297619321.796" 
    capture_lex $P872
    .const 'Sub' $P862 = "181_1297619321.796" 
    capture_lex $P862
    .const 'Sub' $P852 = "179_1297619321.796" 
    capture_lex $P852
    .const 'Sub' $P833 = "174_1297619321.796" 
    capture_lex $P833
    .const 'Sub' $P789 = "171_1297619321.796" 
    capture_lex $P789
    .const 'Sub' $P755 = "169_1297619321.796" 
    capture_lex $P755
    .const 'Sub' $P748 = "167_1297619321.796" 
    capture_lex $P748
    .const 'Sub' $P741 = "165_1297619321.796" 
    capture_lex $P741
    .const 'Sub' $P724 = "161_1297619321.796" 
    capture_lex $P724
    .const 'Sub' $P716 = "159_1297619321.796" 
    capture_lex $P716
    .const 'Sub' $P710 = "157_1297619321.796" 
    capture_lex $P710
    .const 'Sub' $P697 = "155_1297619321.796" 
    capture_lex $P697
    .const 'Sub' $P690 = "153_1297619321.796" 
    capture_lex $P690
    .const 'Sub' $P683 = "151_1297619321.796" 
    capture_lex $P683
    .const 'Sub' $P676 = "149_1297619321.796" 
    capture_lex $P676
    .const 'Sub' $P635 = "145_1297619321.796" 
    capture_lex $P635
    .const 'Sub' $P623 = "143_1297619321.796" 
    capture_lex $P623
    .const 'Sub' $P611 = "141_1297619321.796" 
    capture_lex $P611
    .const 'Sub' $P599 = "139_1297619321.796" 
    capture_lex $P599
    .const 'Sub' $P587 = "137_1297619321.796" 
    capture_lex $P587
    .const 'Sub' $P575 = "135_1297619321.796" 
    capture_lex $P575
    .const 'Sub' $P563 = "133_1297619321.796" 
    capture_lex $P563
    .const 'Sub' $P552 = "129_1297619321.796" 
    capture_lex $P552
    .const 'Sub' $P547 = "127_1297619321.796" 
    capture_lex $P547
    .const 'Sub' $P535 = "125_1297619321.796" 
    capture_lex $P535
    .const 'Sub' $P523 = "123_1297619321.796" 
    capture_lex $P523
    .const 'Sub' $P516 = "121_1297619321.796" 
    capture_lex $P516
    .const 'Sub' $P511 = "119_1297619321.796" 
    capture_lex $P511
    .const 'Sub' $P505 = "117_1297619321.796" 
    capture_lex $P505
    .const 'Sub' $P499 = "115_1297619321.796" 
    capture_lex $P499
    .const 'Sub' $P484 = "111_1297619321.796" 
    capture_lex $P484
    .const 'Sub' $P478 = "109_1297619321.796" 
    capture_lex $P478
    .const 'Sub' $P472 = "107_1297619321.796" 
    capture_lex $P472
    .const 'Sub' $P466 = "105_1297619321.796" 
    capture_lex $P466
    .const 'Sub' $P460 = "103_1297619321.796" 
    capture_lex $P460
    .const 'Sub' $P454 = "101_1297619321.796" 
    capture_lex $P454
    .const 'Sub' $P448 = "99_1297619321.796" 
    capture_lex $P448
    .const 'Sub' $P439 = "97_1297619321.796" 
    capture_lex $P439
    .const 'Sub' $P430 = "95_1297619321.796" 
    capture_lex $P430
    .const 'Sub' $P421 = "93_1297619321.796" 
    capture_lex $P421
    .const 'Sub' $P406 = "89_1297619321.796" 
    capture_lex $P406
    .const 'Sub' $P397 = "87_1297619321.796" 
    capture_lex $P397
    .const 'Sub' $P385 = "83_1297619321.796" 
    capture_lex $P385
    .const 'Sub' $P378 = "81_1297619321.796" 
    capture_lex $P378
    .const 'Sub' $P371 = "79_1297619321.796" 
    capture_lex $P371
    .const 'Sub' $P357 = "75_1297619321.796" 
    capture_lex $P357
    .const 'Sub' $P349 = "73_1297619321.796" 
    capture_lex $P349
    .const 'Sub' $P341 = "71_1297619321.796" 
    capture_lex $P341
    .const 'Sub' $P321 = "69_1297619321.796" 
    capture_lex $P321
    .const 'Sub' $P312 = "67_1297619321.796" 
    capture_lex $P312
    .const 'Sub' $P294 = "64_1297619321.796" 
    capture_lex $P294
    .const 'Sub' $P276 = "62_1297619321.796" 
    capture_lex $P276
    .const 'Sub' $P265 = "58_1297619321.796" 
    capture_lex $P265
    .const 'Sub' $P260 = "56_1297619321.796" 
    capture_lex $P260
    .const 'Sub' $P249 = "52_1297619321.796" 
    capture_lex $P249
    .const 'Sub' $P244 = "50_1297619321.796" 
    capture_lex $P244
    .const 'Sub' $P239 = "48_1297619321.796" 
    capture_lex $P239
    .const 'Sub' $P230 = "46_1297619321.796" 
    capture_lex $P230
    .const 'Sub' $P223 = "44_1297619321.796" 
    capture_lex $P223
    .const 'Sub' $P217 = "42_1297619321.796" 
    capture_lex $P217
    .const 'Sub' $P209 = "40_1297619321.796" 
    capture_lex $P209
    .const 'Sub' $P203 = "38_1297619321.796" 
    capture_lex $P203
    .const 'Sub' $P197 = "36_1297619321.796" 
    capture_lex $P197
    .const 'Sub' $P182 = "33_1297619321.796" 
    capture_lex $P182
    .const 'Sub' $P168 = "31_1297619321.796" 
    capture_lex $P168
    .const 'Sub' $P161 = "29_1297619321.796" 
    capture_lex $P161
    .const 'Sub' $P122 = "26_1297619321.796" 
    capture_lex $P122
    .const 'Sub' $P107 = "23_1297619321.796" 
    capture_lex $P107
    .const 'Sub' $P96 = "21_1297619321.796" 
    capture_lex $P96
    .const 'Sub' $P84 = "19_1297619321.796" 
    capture_lex $P84
    .const 'Sub' $P76 = "17_1297619321.796" 
    capture_lex $P76
    .const 'Sub' $P69 = "15_1297619321.796" 
    capture_lex $P69
    .const 'Sub' $P62 = "13_1297619321.796" 
    capture_lex $P62
    .const 'Sub' $P18 = "12_1297619321.796" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "Regex"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    .const 'Sub' $P1199 = "265_1297619321.796" 
    capture_lex $P1199
    $P1199()
.annotate 'line', 657
    get_hll_global $P1594, ["NQP";"Regex"], "_block1593" 
    capture_lex $P1594
    $P1697 = $P1594()
.annotate 'line', 4
    .return ($P1697)
    .const 'Sub' $P1699 = "398_1297619321.796" 
    .return ($P1699)
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post401") :outer("11_1297619321.796")
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P1703 = "399_1297619321.796" 
    capture_lex $P1703
    $P1703()
.end


.namespace ["NQP";"Grammar"]
.sub "_block1702"  :anon :subid("399_1297619321.796") :outer("11_1297619321.796")
.annotate 'line', 4
    get_hll_global $P1704, "NQPClassHOW"
    $P1705 = $P1704."new_type"("Grammar" :named("name"))
    .local pmc type_obj
    set type_obj, $P1705
    set_hll_global ["NQP"], "Grammar", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1706, type_obj
    .const 'Sub' $P1707 = "12_1297619321.796" 
    $P1706."add_method"(type_obj, "TOP", $P1707)
    get_how $P1708, type_obj
    .const 'Sub' $P1709 = "13_1297619321.796" 
    $P1708."add_method"(type_obj, "identifier", $P1709)
    get_how $P1710, type_obj
    get_global $P1711, "!PREFIX__identifier"
    $P1710."add_method"(type_obj, "!PREFIX__identifier", $P1711)
    get_how $P1712, type_obj
    .const 'Sub' $P1713 = "15_1297619321.796" 
    $P1712."add_method"(type_obj, "name", $P1713)
    get_how $P1714, type_obj
    get_global $P1715, "!PREFIX__name"
    $P1714."add_method"(type_obj, "!PREFIX__name", $P1715)
    get_how $P1716, type_obj
    .const 'Sub' $P1717 = "17_1297619321.796" 
    $P1716."add_method"(type_obj, "deflongname", $P1717)
    get_how $P1718, type_obj
    get_global $P1719, "!PREFIX__deflongname"
    $P1718."add_method"(type_obj, "!PREFIX__deflongname", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "19_1297619321.796" 
    $P1720."add_method"(type_obj, "ENDSTMT", $P1721)
    get_how $P1722, type_obj
    get_global $P1723, "!PREFIX__ENDSTMT"
    $P1722."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "21_1297619321.796" 
    $P1724."add_method"(type_obj, "ws", $P1725)
    get_how $P1726, type_obj
    get_global $P1727, "!PREFIX__ws"
    $P1726."add_method"(type_obj, "!PREFIX__ws", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "23_1297619321.796" 
    $P1728."add_method"(type_obj, "unv", $P1729)
    get_how $P1730, type_obj
    get_global $P1731, "!PREFIX__unv"
    $P1730."add_method"(type_obj, "!PREFIX__unv", $P1731)
    get_how $P1732, type_obj
    .const 'Sub' $P1733 = "26_1297619321.796" 
    $P1732."add_method"(type_obj, "pod_comment", $P1733)
    get_how $P1734, type_obj
    get_global $P1735, "!PREFIX__pod_comment"
    $P1734."add_method"(type_obj, "!PREFIX__pod_comment", $P1735)
    get_how $P1736, type_obj
    .const 'Sub' $P1737 = "29_1297619321.796" 
    $P1736."add_method"(type_obj, "comp_unit", $P1737)
    get_how $P1738, type_obj
    get_global $P1739, "!PREFIX__comp_unit"
    $P1738."add_method"(type_obj, "!PREFIX__comp_unit", $P1739)
    get_how $P1740, type_obj
    .const 'Sub' $P1741 = "31_1297619321.796" 
    $P1740."add_method"(type_obj, "statementlist", $P1741)
    get_how $P1742, type_obj
    get_global $P1743, "!PREFIX__statementlist"
    $P1742."add_method"(type_obj, "!PREFIX__statementlist", $P1743)
    get_how $P1744, type_obj
    .const 'Sub' $P1745 = "33_1297619321.796" 
    $P1744."add_method"(type_obj, "statement", $P1745)
    get_how $P1746, type_obj
    get_global $P1747, "!PREFIX__statement"
    $P1746."add_method"(type_obj, "!PREFIX__statement", $P1747)
    get_how $P1748, type_obj
    .const 'Sub' $P1749 = "36_1297619321.796" 
    $P1748."add_method"(type_obj, "eat_terminator", $P1749)
    get_how $P1750, type_obj
    get_global $P1751, "!PREFIX__eat_terminator"
    $P1750."add_method"(type_obj, "!PREFIX__eat_terminator", $P1751)
    get_how $P1752, type_obj
    .const 'Sub' $P1753 = "38_1297619321.796" 
    $P1752."add_method"(type_obj, "xblock", $P1753)
    get_how $P1754, type_obj
    get_global $P1755, "!PREFIX__xblock"
    $P1754."add_method"(type_obj, "!PREFIX__xblock", $P1755)
    get_how $P1756, type_obj
    .const 'Sub' $P1757 = "40_1297619321.796" 
    $P1756."add_method"(type_obj, "pblock", $P1757)
    get_how $P1758, type_obj
    get_global $P1759, "!PREFIX__pblock"
    $P1758."add_method"(type_obj, "!PREFIX__pblock", $P1759)
    get_how $P1760, type_obj
    .const 'Sub' $P1761 = "42_1297619321.796" 
    $P1760."add_method"(type_obj, "lambda", $P1761)
    get_how $P1762, type_obj
    get_global $P1763, "!PREFIX__lambda"
    $P1762."add_method"(type_obj, "!PREFIX__lambda", $P1763)
    get_how $P1764, type_obj
    .const 'Sub' $P1765 = "44_1297619321.796" 
    $P1764."add_method"(type_obj, "block", $P1765)
    get_how $P1766, type_obj
    get_global $P1767, "!PREFIX__block"
    $P1766."add_method"(type_obj, "!PREFIX__block", $P1767)
    get_how $P1768, type_obj
    .const 'Sub' $P1769 = "46_1297619321.796" 
    $P1768."add_method"(type_obj, "blockoid", $P1769)
    get_how $P1770, type_obj
    get_global $P1771, "!PREFIX__blockoid"
    $P1770."add_method"(type_obj, "!PREFIX__blockoid", $P1771)
    get_how $P1772, type_obj
    .const 'Sub' $P1773 = "48_1297619321.796" 
    $P1772."add_method"(type_obj, "newpad", $P1773)
    get_how $P1774, type_obj
    get_global $P1775, "!PREFIX__newpad"
    $P1774."add_method"(type_obj, "!PREFIX__newpad", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "50_1297619321.796" 
    $P1776."add_method"(type_obj, "outerctx", $P1777)
    get_how $P1778, type_obj
    get_global $P1779, "!PREFIX__outerctx"
    $P1778."add_method"(type_obj, "!PREFIX__outerctx", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "52_1297619321.796" 
    $P1780."add_method"(type_obj, "finishpad", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__finishpad"
    $P1782."add_method"(type_obj, "!PREFIX__finishpad", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "54_1297619321.796" 
    $P1784."add_method"(type_obj, "terminator", $P1785)
    get_how $P1786, type_obj
    .const 'Sub' $P1787 = "55_1297619321.796" 
    $P1786."add_method"(type_obj, "!PREFIX__terminator", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "56_1297619321.796" 
    $P1788."add_method"(type_obj, "terminator:sym<;>", $P1789)
    get_how $P1790, type_obj
    get_global $P1791, "!PREFIX__terminator:sym<;>"
    $P1790."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "58_1297619321.796" 
    $P1792."add_method"(type_obj, "terminator:sym<}>", $P1793)
    get_how $P1794, type_obj
    get_global $P1795, "!PREFIX__terminator:sym<}>"
    $P1794."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "60_1297619321.796" 
    $P1796."add_method"(type_obj, "statement_control", $P1797)
    get_how $P1798, type_obj
    .const 'Sub' $P1799 = "61_1297619321.796" 
    $P1798."add_method"(type_obj, "!PREFIX__statement_control", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "62_1297619321.796" 
    $P1800."add_method"(type_obj, "statement_control:sym<if>", $P1801)
    get_how $P1802, type_obj
    get_global $P1803, "!PREFIX__statement_control:sym<if>"
    $P1802."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "64_1297619321.796" 
    $P1804."add_method"(type_obj, "statement_control:sym<unless>", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__statement_control:sym<unless>"
    $P1806."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "67_1297619321.796" 
    $P1808."add_method"(type_obj, "statement_control:sym<while>", $P1809)
    get_how $P1810, type_obj
    get_global $P1811, "!PREFIX__statement_control:sym<while>"
    $P1810."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "69_1297619321.796" 
    $P1812."add_method"(type_obj, "statement_control:sym<repeat>", $P1813)
    get_how $P1814, type_obj
    get_global $P1815, "!PREFIX__statement_control:sym<repeat>"
    $P1814."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "71_1297619321.796" 
    $P1816."add_method"(type_obj, "statement_control:sym<for>", $P1817)
    get_how $P1818, type_obj
    get_global $P1819, "!PREFIX__statement_control:sym<for>"
    $P1818."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "73_1297619321.796" 
    $P1820."add_method"(type_obj, "statement_control:sym<CATCH>", $P1821)
    get_how $P1822, type_obj
    get_global $P1823, "!PREFIX__statement_control:sym<CATCH>"
    $P1822."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "75_1297619321.796" 
    $P1824."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__statement_control:sym<CONTROL>"
    $P1826."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "77_1297619321.796" 
    $P1828."add_method"(type_obj, "statement_prefix", $P1829)
    get_how $P1830, type_obj
    .const 'Sub' $P1831 = "78_1297619321.796" 
    $P1830."add_method"(type_obj, "!PREFIX__statement_prefix", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "79_1297619321.796" 
    $P1832."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1833)
    get_how $P1834, type_obj
    get_global $P1835, "!PREFIX__statement_prefix:sym<INIT>"
    $P1834."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "81_1297619321.796" 
    $P1836."add_method"(type_obj, "statement_prefix:sym<try>", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__statement_prefix:sym<try>"
    $P1838."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "83_1297619321.796" 
    $P1840."add_method"(type_obj, "blorst", $P1841)
    get_how $P1842, type_obj
    get_global $P1843, "!PREFIX__blorst"
    $P1842."add_method"(type_obj, "!PREFIX__blorst", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "85_1297619321.796" 
    $P1844."add_method"(type_obj, "statement_mod_cond", $P1845)
    get_how $P1846, type_obj
    .const 'Sub' $P1847 = "86_1297619321.796" 
    $P1846."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "87_1297619321.796" 
    $P1848."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1849)
    get_how $P1850, type_obj
    get_global $P1851, "!PREFIX__statement_mod_cond:sym<if>"
    $P1850."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "89_1297619321.796" 
    $P1852."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1854."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "91_1297619321.796" 
    $P1856."add_method"(type_obj, "statement_mod_loop", $P1857)
    get_how $P1858, type_obj
    .const 'Sub' $P1859 = "92_1297619321.796" 
    $P1858."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "93_1297619321.796" 
    $P1860."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1861)
    get_how $P1862, type_obj
    get_global $P1863, "!PREFIX__statement_mod_loop:sym<while>"
    $P1862."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "95_1297619321.796" 
    $P1864."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__statement_mod_loop:sym<until>"
    $P1866."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "97_1297619321.796" 
    $P1868."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1869)
    get_how $P1870, type_obj
    get_global $P1871, "!PREFIX__statement_mod_loop:sym<for>"
    $P1870."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "99_1297619321.796" 
    $P1872."add_method"(type_obj, "term:sym<fatarrow>", $P1873)
    get_how $P1874, type_obj
    get_global $P1875, "!PREFIX__term:sym<fatarrow>"
    $P1874."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "101_1297619321.796" 
    $P1876."add_method"(type_obj, "term:sym<colonpair>", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__term:sym<colonpair>"
    $P1878."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "103_1297619321.796" 
    $P1880."add_method"(type_obj, "term:sym<variable>", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__term:sym<variable>"
    $P1882."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "105_1297619321.796" 
    $P1884."add_method"(type_obj, "term:sym<package_declarator>", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__term:sym<package_declarator>"
    $P1886."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "107_1297619321.796" 
    $P1888."add_method"(type_obj, "term:sym<scope_declarator>", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__term:sym<scope_declarator>"
    $P1890."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "109_1297619321.796" 
    $P1892."add_method"(type_obj, "term:sym<routine_declarator>", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__term:sym<routine_declarator>"
    $P1894."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "111_1297619321.796" 
    $P1896."add_method"(type_obj, "term:sym<multi_declarator>", $P1897)
    get_how $P1898, type_obj
    get_global $P1899, "!PREFIX__term:sym<multi_declarator>"
    $P1898."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "115_1297619321.796" 
    $P1900."add_method"(type_obj, "term:sym<regex_declarator>", $P1901)
    get_how $P1902, type_obj
    get_global $P1903, "!PREFIX__term:sym<regex_declarator>"
    $P1902."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "117_1297619321.796" 
    $P1904."add_method"(type_obj, "term:sym<statement_prefix>", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__term:sym<statement_prefix>"
    $P1906."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "119_1297619321.796" 
    $P1908."add_method"(type_obj, "term:sym<lambda>", $P1909)
    get_how $P1910, type_obj
    get_global $P1911, "!PREFIX__term:sym<lambda>"
    $P1910."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "121_1297619321.796" 
    $P1912."add_method"(type_obj, "fatarrow", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__fatarrow"
    $P1914."add_method"(type_obj, "!PREFIX__fatarrow", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "123_1297619321.796" 
    $P1916."add_method"(type_obj, "colonpair", $P1917)
    get_how $P1918, type_obj
    get_global $P1919, "!PREFIX__colonpair"
    $P1918."add_method"(type_obj, "!PREFIX__colonpair", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "125_1297619321.796" 
    $P1920."add_method"(type_obj, "variable", $P1921)
    get_how $P1922, type_obj
    get_global $P1923, "!PREFIX__variable"
    $P1922."add_method"(type_obj, "!PREFIX__variable", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "127_1297619321.796" 
    $P1924."add_method"(type_obj, "sigil", $P1925)
    get_how $P1926, type_obj
    get_global $P1927, "!PREFIX__sigil"
    $P1926."add_method"(type_obj, "!PREFIX__sigil", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "129_1297619321.796" 
    $P1928."add_method"(type_obj, "twigil", $P1929)
    get_how $P1930, type_obj
    get_global $P1931, "!PREFIX__twigil"
    $P1930."add_method"(type_obj, "!PREFIX__twigil", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "131_1297619321.796" 
    $P1932."add_method"(type_obj, "package_declarator", $P1933)
    get_how $P1934, type_obj
    .const 'Sub' $P1935 = "132_1297619321.796" 
    $P1934."add_method"(type_obj, "!PREFIX__package_declarator", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "133_1297619321.796" 
    $P1936."add_method"(type_obj, "package_declarator:sym<module>", $P1937)
    get_how $P1938, type_obj
    get_global $P1939, "!PREFIX__package_declarator:sym<module>"
    $P1938."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "135_1297619321.796" 
    $P1940."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__package_declarator:sym<knowhow>"
    $P1942."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "137_1297619321.796" 
    $P1944."add_method"(type_obj, "package_declarator:sym<class>", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__package_declarator:sym<class>"
    $P1946."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "139_1297619321.796" 
    $P1948."add_method"(type_obj, "package_declarator:sym<grammar>", $P1949)
    get_how $P1950, type_obj
    get_global $P1951, "!PREFIX__package_declarator:sym<grammar>"
    $P1950."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "141_1297619321.796" 
    $P1952."add_method"(type_obj, "package_declarator:sym<role>", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__package_declarator:sym<role>"
    $P1954."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "143_1297619321.796" 
    $P1956."add_method"(type_obj, "package_declarator:sym<native>", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__package_declarator:sym<native>"
    $P1958."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "145_1297619321.796" 
    $P1960."add_method"(type_obj, "package_def", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__package_def"
    $P1962."add_method"(type_obj, "!PREFIX__package_def", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "147_1297619321.796" 
    $P1964."add_method"(type_obj, "scope_declarator", $P1965)
    get_how $P1966, type_obj
    .const 'Sub' $P1967 = "148_1297619321.796" 
    $P1966."add_method"(type_obj, "!PREFIX__scope_declarator", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "149_1297619321.796" 
    $P1968."add_method"(type_obj, "scope_declarator:sym<my>", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__scope_declarator:sym<my>"
    $P1970."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "151_1297619321.796" 
    $P1972."add_method"(type_obj, "scope_declarator:sym<our>", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__scope_declarator:sym<our>"
    $P1974."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "153_1297619321.796" 
    $P1976."add_method"(type_obj, "scope_declarator:sym<has>", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__scope_declarator:sym<has>"
    $P1978."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "155_1297619321.796" 
    $P1980."add_method"(type_obj, "scoped", $P1981)
    get_how $P1982, type_obj
    get_global $P1983, "!PREFIX__scoped"
    $P1982."add_method"(type_obj, "!PREFIX__scoped", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "157_1297619321.796" 
    $P1984."add_method"(type_obj, "typename", $P1985)
    get_how $P1986, type_obj
    get_global $P1987, "!PREFIX__typename"
    $P1986."add_method"(type_obj, "!PREFIX__typename", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "159_1297619321.796" 
    $P1988."add_method"(type_obj, "declarator", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__declarator"
    $P1990."add_method"(type_obj, "!PREFIX__declarator", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "161_1297619321.796" 
    $P1992."add_method"(type_obj, "variable_declarator", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__variable_declarator"
    $P1994."add_method"(type_obj, "!PREFIX__variable_declarator", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "163_1297619321.796" 
    $P1996."add_method"(type_obj, "routine_declarator", $P1997)
    get_how $P1998, type_obj
    .const 'Sub' $P1999 = "164_1297619321.796" 
    $P1998."add_method"(type_obj, "!PREFIX__routine_declarator", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "165_1297619321.796" 
    $P2000."add_method"(type_obj, "routine_declarator:sym<sub>", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__routine_declarator:sym<sub>"
    $P2002."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "167_1297619321.796" 
    $P2004."add_method"(type_obj, "routine_declarator:sym<method>", $P2005)
    get_how $P2006, type_obj
    get_global $P2007, "!PREFIX__routine_declarator:sym<method>"
    $P2006."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "169_1297619321.796" 
    $P2008."add_method"(type_obj, "routine_def", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__routine_def"
    $P2010."add_method"(type_obj, "!PREFIX__routine_def", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "171_1297619321.796" 
    $P2012."add_method"(type_obj, "method_def", $P2013)
    get_how $P2014, type_obj
    get_global $P2015, "!PREFIX__method_def"
    $P2014."add_method"(type_obj, "!PREFIX__method_def", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "174_1297619321.796" 
    $P2016."add_method"(type_obj, "onlystar", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__onlystar"
    $P2018."add_method"(type_obj, "!PREFIX__onlystar", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "177_1297619321.796" 
    $P2020."add_method"(type_obj, "multi_declarator", $P2021)
    get_how $P2022, type_obj
    .const 'Sub' $P2023 = "178_1297619321.796" 
    $P2022."add_method"(type_obj, "!PREFIX__multi_declarator", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "179_1297619321.796" 
    $P2024."add_method"(type_obj, "multi_declarator:sym<multi>", $P2025)
    get_how $P2026, type_obj
    get_global $P2027, "!PREFIX__multi_declarator:sym<multi>"
    $P2026."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "181_1297619321.796" 
    $P2028."add_method"(type_obj, "multi_declarator:sym<proto>", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__multi_declarator:sym<proto>"
    $P2030."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "183_1297619321.796" 
    $P2032."add_method"(type_obj, "multi_declarator:sym<null>", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__multi_declarator:sym<null>"
    $P2034."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "185_1297619321.796" 
    $P2036."add_method"(type_obj, "signature", $P2037)
    get_how $P2038, type_obj
    get_global $P2039, "!PREFIX__signature"
    $P2038."add_method"(type_obj, "!PREFIX__signature", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "188_1297619321.796" 
    $P2040."add_method"(type_obj, "parameter", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__parameter"
    $P2042."add_method"(type_obj, "!PREFIX__parameter", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "190_1297619321.796" 
    $P2044."add_method"(type_obj, "param_var", $P2045)
    get_how $P2046, type_obj
    get_global $P2047, "!PREFIX__param_var"
    $P2046."add_method"(type_obj, "!PREFIX__param_var", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "192_1297619321.796" 
    $P2048."add_method"(type_obj, "named_param", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__named_param"
    $P2050."add_method"(type_obj, "!PREFIX__named_param", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "194_1297619321.796" 
    $P2052."add_method"(type_obj, "default_value", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__default_value"
    $P2054."add_method"(type_obj, "!PREFIX__default_value", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "196_1297619321.796" 
    $P2056."add_method"(type_obj, "trait", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__trait"
    $P2058."add_method"(type_obj, "!PREFIX__trait", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "198_1297619321.796" 
    $P2060."add_method"(type_obj, "trait_mod", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "199_1297619321.796" 
    $P2062."add_method"(type_obj, "!PREFIX__trait_mod", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "200_1297619321.796" 
    $P2064."add_method"(type_obj, "trait_mod:sym<is>", $P2065)
    get_how $P2066, type_obj
    get_global $P2067, "!PREFIX__trait_mod:sym<is>"
    $P2066."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "202_1297619321.796" 
    $P2068."add_method"(type_obj, "regex_declarator", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__regex_declarator"
    $P2070."add_method"(type_obj, "!PREFIX__regex_declarator", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "204_1297619321.796" 
    $P2072."add_method"(type_obj, "dotty", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__dotty"
    $P2074."add_method"(type_obj, "!PREFIX__dotty", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "206_1297619321.796" 
    $P2076."add_method"(type_obj, "term", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "207_1297619321.796" 
    $P2078."add_method"(type_obj, "!PREFIX__term", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "208_1297619321.796" 
    $P2080."add_method"(type_obj, "term:sym<self>", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__term:sym<self>"
    $P2082."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "210_1297619321.796" 
    $P2084."add_method"(type_obj, "term:sym<identifier>", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__term:sym<identifier>"
    $P2086."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "212_1297619321.796" 
    $P2088."add_method"(type_obj, "term:sym<name>", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__term:sym<name>"
    $P2090."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "214_1297619321.796" 
    $P2092."add_method"(type_obj, "term:sym<pir::op>", $P2093)
    get_how $P2094, type_obj
    get_global $P2095, "!PREFIX__term:sym<pir::op>"
    $P2094."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "216_1297619321.796" 
    $P2096."add_method"(type_obj, "term:sym<onlystar>", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__term:sym<onlystar>"
    $P2098."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "219_1297619321.796" 
    $P2100."add_method"(type_obj, "args", $P2101)
    get_how $P2102, type_obj
    get_global $P2103, "!PREFIX__args"
    $P2102."add_method"(type_obj, "!PREFIX__args", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "221_1297619321.796" 
    $P2104."add_method"(type_obj, "arglist", $P2105)
    get_how $P2106, type_obj
    get_global $P2107, "!PREFIX__arglist"
    $P2106."add_method"(type_obj, "!PREFIX__arglist", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "223_1297619321.796" 
    $P2108."add_method"(type_obj, "term:sym<value>", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__term:sym<value>"
    $P2110."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "225_1297619321.796" 
    $P2112."add_method"(type_obj, "value", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__value"
    $P2114."add_method"(type_obj, "!PREFIX__value", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "227_1297619321.796" 
    $P2116."add_method"(type_obj, "number", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__number"
    $P2118."add_method"(type_obj, "!PREFIX__number", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "229_1297619321.796" 
    $P2120."add_method"(type_obj, "quote", $P2121)
    get_how $P2122, type_obj
    .const 'Sub' $P2123 = "230_1297619321.796" 
    $P2122."add_method"(type_obj, "!PREFIX__quote", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "231_1297619321.796" 
    $P2124."add_method"(type_obj, "quote:sym<apos>", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__quote:sym<apos>"
    $P2126."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "233_1297619321.796" 
    $P2128."add_method"(type_obj, "quote:sym<dblq>", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__quote:sym<dblq>"
    $P2130."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "235_1297619321.796" 
    $P2132."add_method"(type_obj, "quote:sym<q>", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__quote:sym<q>"
    $P2134."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "237_1297619321.796" 
    $P2136."add_method"(type_obj, "quote:sym<qq>", $P2137)
    get_how $P2138, type_obj
    get_global $P2139, "!PREFIX__quote:sym<qq>"
    $P2138."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "239_1297619321.796" 
    $P2140."add_method"(type_obj, "quote:sym<Q>", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, "!PREFIX__quote:sym<Q>"
    $P2142."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "241_1297619321.796" 
    $P2144."add_method"(type_obj, "quote:sym<Q:PIR>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__quote:sym<Q:PIR>"
    $P2146."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "243_1297619321.796" 
    $P2148."add_method"(type_obj, "quote:sym</ />", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__quote:sym</ />"
    $P2150."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "245_1297619321.796" 
    $P2152."add_method"(type_obj, "quote_escape:sym<$>", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__quote_escape:sym<$>"
    $P2154."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "247_1297619321.796" 
    $P2156."add_method"(type_obj, "quote_escape:sym<{ }>", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__quote_escape:sym<{ }>"
    $P2158."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "249_1297619321.796" 
    $P2160."add_method"(type_obj, "quote_escape:sym<esc>", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, "!PREFIX__quote_escape:sym<esc>"
    $P2162."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "251_1297619321.796" 
    $P2164."add_method"(type_obj, "circumfix:sym<( )>", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__circumfix:sym<( )>"
    $P2166."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "253_1297619321.796" 
    $P2168."add_method"(type_obj, "circumfix:sym<[ ]>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__circumfix:sym<[ ]>"
    $P2170."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "255_1297619321.796" 
    $P2172."add_method"(type_obj, "circumfix:sym<ang>", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__circumfix:sym<ang>"
    $P2174."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "257_1297619321.796" 
    $P2176."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2178."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "259_1297619321.796" 
    $P2180."add_method"(type_obj, "circumfix:sym<{ }>", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__circumfix:sym<{ }>"
    $P2182."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "261_1297619321.796" 
    $P2184."add_method"(type_obj, "circumfix:sym<sigil>", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__circumfix:sym<sigil>"
    $P2186."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "263_1297619321.796" 
    $P2188."add_method"(type_obj, "semilist", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__semilist"
    $P2190."add_method"(type_obj, "!PREFIX__semilist", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "266_1297619321.796" 
    $P2192."add_method"(type_obj, "infixish", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, "!PREFIX__infixish"
    $P2194."add_method"(type_obj, "!PREFIX__infixish", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "268_1297619321.796" 
    $P2196."add_method"(type_obj, "infixstopper", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__infixstopper"
    $P2198."add_method"(type_obj, "!PREFIX__infixstopper", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "270_1297619321.796" 
    $P2200."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2202."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "272_1297619321.796" 
    $P2204."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__postcircumfix:sym<{ }>"
    $P2206."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "274_1297619321.796" 
    $P2208."add_method"(type_obj, "postcircumfix:sym<ang>", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__postcircumfix:sym<ang>"
    $P2210."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "276_1297619321.796" 
    $P2212."add_method"(type_obj, "postcircumfix:sym<( )>", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__postcircumfix:sym<( )>"
    $P2214."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "278_1297619321.796" 
    $P2216."add_method"(type_obj, "postfix:sym<.>", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__postfix:sym<.>"
    $P2218."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "280_1297619321.796" 
    $P2220."add_method"(type_obj, "prefix:sym<++>", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__prefix:sym<++>"
    $P2222."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "282_1297619321.796" 
    $P2224."add_method"(type_obj, "prefix:sym<-->", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__prefix:sym<-->"
    $P2226."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "284_1297619321.796" 
    $P2228."add_method"(type_obj, "postfix:sym<++>", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__postfix:sym<++>"
    $P2230."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "286_1297619321.796" 
    $P2232."add_method"(type_obj, "postfix:sym<-->", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__postfix:sym<-->"
    $P2234."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "288_1297619321.796" 
    $P2236."add_method"(type_obj, "infix:sym<**>", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__infix:sym<**>"
    $P2238."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "290_1297619321.796" 
    $P2240."add_method"(type_obj, "prefix:sym<+>", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__prefix:sym<+>"
    $P2242."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "292_1297619321.796" 
    $P2244."add_method"(type_obj, "prefix:sym<~>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__prefix:sym<~>"
    $P2246."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "294_1297619321.796" 
    $P2248."add_method"(type_obj, "prefix:sym<->", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__prefix:sym<->"
    $P2250."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "296_1297619321.796" 
    $P2252."add_method"(type_obj, "prefix:sym<?>", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__prefix:sym<?>"
    $P2254."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "298_1297619321.796" 
    $P2256."add_method"(type_obj, "prefix:sym<!>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__prefix:sym<!>"
    $P2258."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "300_1297619321.796" 
    $P2260."add_method"(type_obj, "prefix:sym<|>", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__prefix:sym<|>"
    $P2262."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "302_1297619321.796" 
    $P2264."add_method"(type_obj, "infix:sym<*>", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__infix:sym<*>"
    $P2266."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "304_1297619321.796" 
    $P2268."add_method"(type_obj, "infix:sym</>", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__infix:sym</>"
    $P2270."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "306_1297619321.796" 
    $P2272."add_method"(type_obj, "infix:sym<%>", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__infix:sym<%>"
    $P2274."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "308_1297619321.796" 
    $P2276."add_method"(type_obj, "infix:sym<+&>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__infix:sym<+&>"
    $P2278."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "310_1297619321.796" 
    $P2280."add_method"(type_obj, "infix:sym<+>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__infix:sym<+>"
    $P2282."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "312_1297619321.796" 
    $P2284."add_method"(type_obj, "infix:sym<->", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__infix:sym<->"
    $P2286."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "314_1297619321.796" 
    $P2288."add_method"(type_obj, "infix:sym<+|>", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__infix:sym<+|>"
    $P2290."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "316_1297619321.796" 
    $P2292."add_method"(type_obj, "infix:sym<+^>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__infix:sym<+^>"
    $P2294."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "318_1297619321.796" 
    $P2296."add_method"(type_obj, "infix:sym<~>", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__infix:sym<~>"
    $P2298."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "320_1297619321.796" 
    $P2300."add_method"(type_obj, "infix:sym<==>", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__infix:sym<==>"
    $P2302."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "322_1297619321.796" 
    $P2304."add_method"(type_obj, "infix:sym<!=>", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__infix:sym<!=>"
    $P2306."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "324_1297619321.796" 
    $P2308."add_method"(type_obj, "infix:sym<<=>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__infix:sym<<=>"
    $P2310."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "326_1297619321.796" 
    $P2312."add_method"(type_obj, "infix:sym<>=>", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__infix:sym<>=>"
    $P2314."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "328_1297619321.796" 
    $P2316."add_method"(type_obj, "infix:sym<<>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__infix:sym<<>"
    $P2318."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "330_1297619321.796" 
    $P2320."add_method"(type_obj, "infix:sym<>>", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__infix:sym<>>"
    $P2322."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "332_1297619321.796" 
    $P2324."add_method"(type_obj, "infix:sym<eq>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__infix:sym<eq>"
    $P2326."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "334_1297619321.796" 
    $P2328."add_method"(type_obj, "infix:sym<ne>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__infix:sym<ne>"
    $P2330."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "336_1297619321.796" 
    $P2332."add_method"(type_obj, "infix:sym<le>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__infix:sym<le>"
    $P2334."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "338_1297619321.796" 
    $P2336."add_method"(type_obj, "infix:sym<ge>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__infix:sym<ge>"
    $P2338."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "340_1297619321.796" 
    $P2340."add_method"(type_obj, "infix:sym<lt>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__infix:sym<lt>"
    $P2342."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "342_1297619321.796" 
    $P2344."add_method"(type_obj, "infix:sym<gt>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<gt>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "344_1297619321.796" 
    $P2348."add_method"(type_obj, "infix:sym<=:=>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym<=:=>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "346_1297619321.796" 
    $P2352."add_method"(type_obj, "infix:sym<~~>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__infix:sym<~~>"
    $P2354."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "348_1297619321.796" 
    $P2356."add_method"(type_obj, "infix:sym<&&>", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__infix:sym<&&>"
    $P2358."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "350_1297619321.796" 
    $P2360."add_method"(type_obj, "infix:sym<||>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__infix:sym<||>"
    $P2362."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "352_1297619321.796" 
    $P2364."add_method"(type_obj, "infix:sym<//>", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__infix:sym<//>"
    $P2366."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "354_1297619321.796" 
    $P2368."add_method"(type_obj, "infix:sym<?? !!>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__infix:sym<?? !!>"
    $P2370."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "356_1297619321.796" 
    $P2372."add_method"(type_obj, "infix:sym<=>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__infix:sym<=>"
    $P2374."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "358_1297619321.796" 
    $P2376."add_method"(type_obj, "infix:sym<:=>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__infix:sym<:=>"
    $P2378."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "360_1297619321.796" 
    $P2380."add_method"(type_obj, "infix:sym<::=>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__infix:sym<::=>"
    $P2382."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "362_1297619321.796" 
    $P2384."add_method"(type_obj, "infix:sym<,>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__infix:sym<,>"
    $P2386."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "364_1297619321.796" 
    $P2388."add_method"(type_obj, "prefix:sym<return>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__prefix:sym<return>"
    $P2390."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "367_1297619321.796" 
    $P2392."add_method"(type_obj, "prefix:sym<make>", $P2393)
    get_how $P2394, type_obj
    get_global $P2395, "!PREFIX__prefix:sym<make>"
    $P2394."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2395)
    get_how $P2396, type_obj
    .const 'Sub' $P2397 = "369_1297619321.796" 
    $P2396."add_method"(type_obj, "term:sym<last>", $P2397)
    get_how $P2398, type_obj
    get_global $P2399, "!PREFIX__term:sym<last>"
    $P2398."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2399)
    get_how $P2400, type_obj
    .const 'Sub' $P2401 = "371_1297619321.796" 
    $P2400."add_method"(type_obj, "term:sym<next>", $P2401)
    get_how $P2402, type_obj
    get_global $P2403, "!PREFIX__term:sym<next>"
    $P2402."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2403)
    get_how $P2404, type_obj
    .const 'Sub' $P2405 = "373_1297619321.796" 
    $P2404."add_method"(type_obj, "term:sym<redo>", $P2405)
    get_how $P2406, type_obj
    get_global $P2407, "!PREFIX__term:sym<redo>"
    $P2406."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2407)
    get_how $P2408, type_obj
    .const 'Sub' $P2409 = "375_1297619321.796" 
    $P2408."add_method"(type_obj, "smartmatch", $P2409)
    get_how $P2410, type_obj
    get_hll_global $P2411, ["HLL"], "Grammar"
    $P2410."add_parent"(type_obj, $P2411)
    get_how $P2412, type_obj
    $P2413 = $P2412."compose"(type_obj)
    .return ($P2413)
.end


.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1297619321.796") :outer("11_1297619321.796")
    .param pmc param_19
.annotate 'line', 4
    .lex "self", param_19
.annotate 'line', 5
    $P20 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P20
.annotate 'line', 12
    $P21 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P21
.annotate 'line', 21
    new $P22, "Undef"
    .lex "$*DEFAULT-METAATTR", $P22
.annotate 'line', 22
    $P23 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P23
.annotate 'line', 25
    new $P24, "Undef"
    .lex "$*SCOPE", $P24
.annotate 'line', 26
    new $P25, "Undef"
    .lex "$*MULTINESS", $P25
.annotate 'line', 27
    new $P26, "Undef"
    .lex "$*INVOCANT_OK", $P26
.annotate 'line', 28
    new $P27, "Undef"
    .lex "$*RETURN_USED", $P27
.annotate 'line', 29
    new $P28, "Undef"
    .lex "$*PACKAGE-SETUP", $P28
.annotate 'line', 4
    find_lex $P29, "%*LANG"
    unless_null $P29, vivify_402
    get_hll_global $P29, "%LANG"
    unless_null $P29, vivify_403
    die "Contextual %*LANG not found"
  vivify_403:
  vivify_402:
.annotate 'line', 6
    get_hll_global $P30, ["NQP"], "Regex"
    find_lex $P31, "%*LANG"
    unless_null $P31, vivify_404
    get_hll_global $P31, "%LANG"
    unless_null $P31, vivify_405
    die "Contextual %*LANG not found"
  vivify_405:
    store_lex "%*LANG", $P31
  vivify_404:
    set $P31["Regex"], $P30
.annotate 'line', 7
    get_hll_global $P32, ["NQP"], "RegexActions"
    find_lex $P33, "%*LANG"
    unless_null $P33, vivify_406
    get_hll_global $P33, "%LANG"
    unless_null $P33, vivify_407
    die "Contextual %*LANG not found"
  vivify_407:
    store_lex "%*LANG", $P33
  vivify_406:
    set $P33["Regex-actions"], $P32
.annotate 'line', 8
    get_hll_global $P34, ["NQP"], "Grammar"
    find_lex $P35, "%*LANG"
    unless_null $P35, vivify_408
    get_hll_global $P35, "%LANG"
    unless_null $P35, vivify_409
    die "Contextual %*LANG not found"
  vivify_409:
    store_lex "%*LANG", $P35
  vivify_408:
    set $P35["MAIN"], $P34
.annotate 'line', 9
    get_hll_global $P36, ["NQP"], "Actions"
    find_lex $P37, "%*LANG"
    unless_null $P37, vivify_410
    get_hll_global $P37, "%LANG"
    unless_null $P37, vivify_411
    die "Contextual %*LANG not found"
  vivify_411:
    store_lex "%*LANG", $P37
  vivify_410:
    set $P37["MAIN-actions"], $P36
    find_lex $P38, "%*HOW"
    unless_null $P38, vivify_412
    get_hll_global $P38, "%HOW"
    unless_null $P38, vivify_413
    die "Contextual %*HOW not found"
  vivify_413:
  vivify_412:
.annotate 'line', 13
    get_hll_global $P39, "KnowHOW"
    find_lex $P40, "%*HOW"
    unless_null $P40, vivify_414
    get_hll_global $P40, "%HOW"
    unless_null $P40, vivify_415
    die "Contextual %*HOW not found"
  vivify_415:
    store_lex "%*HOW", $P40
  vivify_414:
    set $P40["knowhow"], $P39
.annotate 'line', 14
    get_hll_global $P41, "NQPModuleHOW"
    find_lex $P42, "%*HOW"
    unless_null $P42, vivify_416
    get_hll_global $P42, "%HOW"
    unless_null $P42, vivify_417
    die "Contextual %*HOW not found"
  vivify_417:
    store_lex "%*HOW", $P42
  vivify_416:
    set $P42["module"], $P41
.annotate 'line', 15
    get_hll_global $P43, "NQPClassHOW"
    find_lex $P44, "%*HOW"
    unless_null $P44, vivify_418
    get_hll_global $P44, "%HOW"
    unless_null $P44, vivify_419
    die "Contextual %*HOW not found"
  vivify_419:
    store_lex "%*HOW", $P44
  vivify_418:
    set $P44["class"], $P43
.annotate 'line', 16
    get_hll_global $P45, "NQPClassHOW"
    find_lex $P46, "%*HOW"
    unless_null $P46, vivify_420
    get_hll_global $P46, "%HOW"
    unless_null $P46, vivify_421
    die "Contextual %*HOW not found"
  vivify_421:
    store_lex "%*HOW", $P46
  vivify_420:
    set $P46["grammar"], $P45
.annotate 'line', 17
    get_hll_global $P47, "NQPParametricRoleHOW"
    find_lex $P48, "%*HOW"
    unless_null $P48, vivify_422
    get_hll_global $P48, "%HOW"
    unless_null $P48, vivify_423
    die "Contextual %*HOW not found"
  vivify_423:
    store_lex "%*HOW", $P48
  vivify_422:
    set $P48["role"], $P47
.annotate 'line', 18
    get_hll_global $P49, "NQPNativeHOW"
    find_lex $P50, "%*HOW"
    unless_null $P50, vivify_424
    get_hll_global $P50, "%HOW"
    unless_null $P50, vivify_425
    die "Contextual %*HOW not found"
  vivify_425:
    store_lex "%*HOW", $P50
  vivify_424:
    set $P50["native"], $P49
.annotate 'line', 21
    new $P51, "String"
    assign $P51, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P51
    find_lex $P52, "%*HOW-METAATTR"
    unless_null $P52, vivify_426
    get_hll_global $P52, "%HOW-METAATTR"
    unless_null $P52, vivify_427
    die "Contextual %*HOW-METAATTR not found"
  vivify_427:
  vivify_426:
.annotate 'line', 23
    new $P53, "String"
    assign $P53, "KnowHOWAttribute"
    find_lex $P54, "%*HOW-METAATTR"
    unless_null $P54, vivify_428
    get_hll_global $P54, "%HOW-METAATTR"
    unless_null $P54, vivify_429
    die "Contextual %*HOW-METAATTR not found"
  vivify_429:
    store_lex "%*HOW-METAATTR", $P54
  vivify_428:
    set $P54["knowhow"], $P53
.annotate 'line', 25
    new $P55, "String"
    assign $P55, ""
    store_lex "$*SCOPE", $P55
.annotate 'line', 26
    new $P56, "String"
    assign $P56, ""
    store_lex "$*MULTINESS", $P56
.annotate 'line', 27
    new $P57, "Integer"
    assign $P57, 0
    store_lex "$*INVOCANT_OK", $P57
.annotate 'line', 28
    new $P58, "Integer"
    assign $P58, 0
    store_lex "$*RETURN_USED", $P58
    find_lex $P59, "$*PACKAGE-SETUP"
    unless_null $P59, vivify_430
    get_hll_global $P59, "$PACKAGE-SETUP"
    unless_null $P59, vivify_431
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_431:
  vivify_430:
.annotate 'line', 30
    find_lex $P60, "self"
    $P61 = $P60."comp_unit"()
.annotate 'line', 4
    .return ($P61)
.end


.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx63_tgt
    .local int rx63_pos
    .local int rx63_off
    .local int rx63_eos
    .local int rx63_rep
    .local pmc rx63_cur
    .local pmc rx63_debug
    (rx63_cur, rx63_pos, rx63_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx63_cur
    .local pmc match
    .lex "$/", match
    length rx63_eos, rx63_tgt
    gt rx63_pos, rx63_eos, rx63_done
    set rx63_off, 0
    lt rx63_pos, 2, rx63_start
    sub rx63_off, rx63_pos, 1
    substr rx63_tgt, rx63_tgt, rx63_off
  rx63_start:
    eq $I10, 1, rx63_restart
    if_null rx63_debug, debug_432
    rx63_cur."!cursor_debug"("START", "identifier")
  debug_432:
    $I10 = self.'from'()
    ne $I10, -1, rxscan67_done
    goto rxscan67_scan
  rxscan67_loop:
    (rx63_pos) = rx63_cur."from"()
    inc rx63_pos
    rx63_cur."!cursor_from"(rx63_pos)
    ge rx63_pos, rx63_eos, rxscan67_done
  rxscan67_scan:
    set_addr $I10, rxscan67_loop
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxscan67_done:
.annotate 'line', 35
  # rx subrule "ident" subtype=method negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."ident"()
    unless $P10, rx63_fail
    rx63_pos = $P10."pos"()
  # rx rxquantr68 ** 0..*
    set_addr $I10, rxquantr68_done
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxquantr68_loop:
  # rx enumcharlist negate=0 
    ge rx63_pos, rx63_eos, rx63_fail
    sub $I10, rx63_pos, rx63_off
    substr $S10, rx63_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx63_fail
    inc rx63_pos
  # rx subrule "ident" subtype=method negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."ident"()
    unless $P10, rx63_fail
    rx63_pos = $P10."pos"()
    set_addr $I10, rxquantr68_done
    (rx63_rep) = rx63_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr68_done
    rx63_cur."!mark_push"(rx63_rep, rx63_pos, $I10)
    goto rxquantr68_loop
  rxquantr68_done:
  # rx pass
    rx63_cur."!cursor_pass"(rx63_pos, "identifier")
    if_null rx63_debug, debug_433
    rx63_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx63_pos)
  debug_433:
    .return (rx63_cur)
  rx63_restart:
.annotate 'line', 4
    if_null rx63_debug, debug_434
    rx63_cur."!cursor_debug"("NEXT", "identifier")
  debug_434:
  rx63_fail:
    (rx63_rep, rx63_pos, $I10, $P10) = rx63_cur."!mark_fail"(0)
    lt rx63_pos, -1, rx63_done
    eq rx63_pos, -1, rx63_fail
    jump $I10
  rx63_done:
    rx63_cur."!cursor_fail"()
    if_null rx63_debug, debug_435
    rx63_cur."!cursor_debug"("FAIL", "identifier")
  debug_435:
    .return (rx63_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1297619321.796") :method
.annotate 'line', 4
    $P65 = self."!PREFIX__!subrule"("ident", "")
    new $P66, "ResizablePMCArray"
    push $P66, $P65
    .return ($P66)
.end


.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx70_tgt
    .local int rx70_pos
    .local int rx70_off
    .local int rx70_eos
    .local int rx70_rep
    .local pmc rx70_cur
    .local pmc rx70_debug
    (rx70_cur, rx70_pos, rx70_tgt, $I10) = self."!cursor_start"()
    rx70_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx70_cur
    .local pmc match
    .lex "$/", match
    length rx70_eos, rx70_tgt
    gt rx70_pos, rx70_eos, rx70_done
    set rx70_off, 0
    lt rx70_pos, 2, rx70_start
    sub rx70_off, rx70_pos, 1
    substr rx70_tgt, rx70_tgt, rx70_off
  rx70_start:
    eq $I10, 1, rx70_restart
    if_null rx70_debug, debug_436
    rx70_cur."!cursor_debug"("START", "name")
  debug_436:
    $I10 = self.'from'()
    ne $I10, -1, rxscan73_done
    goto rxscan73_scan
  rxscan73_loop:
    (rx70_pos) = rx70_cur."from"()
    inc rx70_pos
    rx70_cur."!cursor_from"(rx70_pos)
    ge rx70_pos, rx70_eos, rxscan73_done
  rxscan73_scan:
    set_addr $I10, rxscan73_loop
    rx70_cur."!mark_push"(0, rx70_pos, $I10)
  rxscan73_done:
.annotate 'line', 37
  # rx rxquantr74 ** 1..*
    set_addr $I10, rxquantr74_done
    rx70_cur."!mark_push"(0, -1, $I10)
  rxquantr74_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx70_cur."!cursor_pos"(rx70_pos)
    $P10 = rx70_cur."identifier"()
    unless $P10, rx70_fail
    goto rxsubrule75_pass
  rxsubrule75_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx70_fail
  rxsubrule75_pass:
    set_addr $I10, rxsubrule75_back
    rx70_cur."!mark_push"(0, rx70_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx70_pos = $P10."pos"()
    set_addr $I10, rxquantr74_done
    (rx70_rep) = rx70_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr74_done
    rx70_cur."!mark_push"(rx70_rep, rx70_pos, $I10)
  # rx literal  "::"
    add $I11, rx70_pos, 2
    gt $I11, rx70_eos, rx70_fail
    sub $I11, rx70_pos, rx70_off
    substr $S10, rx70_tgt, $I11, 2
    ne $S10, "::", rx70_fail
    add rx70_pos, 2
    goto rxquantr74_loop
  rxquantr74_done:
  # rx pass
    rx70_cur."!cursor_pass"(rx70_pos, "name")
    if_null rx70_debug, debug_437
    rx70_cur."!cursor_debug"("PASS", "name", " at pos=", rx70_pos)
  debug_437:
    .return (rx70_cur)
  rx70_restart:
.annotate 'line', 4
    if_null rx70_debug, debug_438
    rx70_cur."!cursor_debug"("NEXT", "name")
  debug_438:
  rx70_fail:
    (rx70_rep, rx70_pos, $I10, $P10) = rx70_cur."!mark_fail"(0)
    lt rx70_pos, -1, rx70_done
    eq rx70_pos, -1, rx70_fail
    jump $I10
  rx70_done:
    rx70_cur."!cursor_fail"()
    if_null rx70_debug, debug_439
    rx70_cur."!cursor_debug"("FAIL", "name")
  debug_439:
    .return (rx70_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1297619321.796") :method
.annotate 'line', 4
    new $P72, "ResizablePMCArray"
    push $P72, ""
    .return ($P72)
.end


.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx77_tgt
    .local int rx77_pos
    .local int rx77_off
    .local int rx77_eos
    .local int rx77_rep
    .local pmc rx77_cur
    .local pmc rx77_debug
    (rx77_cur, rx77_pos, rx77_tgt, $I10) = self."!cursor_start"()
    rx77_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx77_cur
    .local pmc match
    .lex "$/", match
    length rx77_eos, rx77_tgt
    gt rx77_pos, rx77_eos, rx77_done
    set rx77_off, 0
    lt rx77_pos, 2, rx77_start
    sub rx77_off, rx77_pos, 1
    substr rx77_tgt, rx77_tgt, rx77_off
  rx77_start:
    eq $I10, 1, rx77_restart
    if_null rx77_debug, debug_440
    rx77_cur."!cursor_debug"("START", "deflongname")
  debug_440:
    $I10 = self.'from'()
    ne $I10, -1, rxscan81_done
    goto rxscan81_scan
  rxscan81_loop:
    (rx77_pos) = rx77_cur."from"()
    inc rx77_pos
    rx77_cur."!cursor_from"(rx77_pos)
    ge rx77_pos, rx77_eos, rxscan81_done
  rxscan81_scan:
    set_addr $I10, rxscan81_loop
    rx77_cur."!mark_push"(0, rx77_pos, $I10)
  rxscan81_done:
.annotate 'line', 40
  # rx subrule "identifier" subtype=capture negate=
    rx77_cur."!cursor_pos"(rx77_pos)
    $P10 = rx77_cur."identifier"()
    unless $P10, rx77_fail
    rx77_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx77_pos = $P10."pos"()
  # rx rxquantr82 ** 0..1
    set_addr $I10, rxquantr82_done
    rx77_cur."!mark_push"(0, rx77_pos, $I10)
  rxquantr82_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx77_cur."!cursor_pos"(rx77_pos)
    $P10 = rx77_cur."colonpair"()
    unless $P10, rx77_fail
    goto rxsubrule83_pass
  rxsubrule83_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx77_fail
  rxsubrule83_pass:
    set_addr $I10, rxsubrule83_back
    rx77_cur."!mark_push"(0, rx77_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx77_pos = $P10."pos"()
    set_addr $I10, rxquantr82_done
    (rx77_rep) = rx77_cur."!mark_commit"($I10)
  rxquantr82_done:
.annotate 'line', 39
  # rx pass
    rx77_cur."!cursor_pass"(rx77_pos, "deflongname")
    if_null rx77_debug, debug_441
    rx77_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx77_pos)
  debug_441:
    .return (rx77_cur)
  rx77_restart:
.annotate 'line', 4
    if_null rx77_debug, debug_442
    rx77_cur."!cursor_debug"("NEXT", "deflongname")
  debug_442:
  rx77_fail:
    (rx77_rep, rx77_pos, $I10, $P10) = rx77_cur."!mark_fail"(0)
    lt rx77_pos, -1, rx77_done
    eq rx77_pos, -1, rx77_fail
    jump $I10
  rx77_done:
    rx77_cur."!cursor_fail"()
    if_null rx77_debug, debug_443
    rx77_cur."!cursor_debug"("FAIL", "deflongname")
  debug_443:
    .return (rx77_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1297619321.796") :method
.annotate 'line', 4
    $P79 = self."!PREFIX__!subrule"("identifier", "")
    new $P80, "ResizablePMCArray"
    push $P80, $P79
    .return ($P80)
.end


.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx85_tgt
    .local int rx85_pos
    .local int rx85_off
    .local int rx85_eos
    .local int rx85_rep
    .local pmc rx85_cur
    .local pmc rx85_debug
    (rx85_cur, rx85_pos, rx85_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx85_cur
    .local pmc match
    .lex "$/", match
    length rx85_eos, rx85_tgt
    gt rx85_pos, rx85_eos, rx85_done
    set rx85_off, 0
    lt rx85_pos, 2, rx85_start
    sub rx85_off, rx85_pos, 1
    substr rx85_tgt, rx85_tgt, rx85_off
  rx85_start:
    eq $I10, 1, rx85_restart
    if_null rx85_debug, debug_444
    rx85_cur."!cursor_debug"("START", "ENDSTMT")
  debug_444:
    $I10 = self.'from'()
    ne $I10, -1, rxscan88_done
    goto rxscan88_scan
  rxscan88_loop:
    (rx85_pos) = rx85_cur."from"()
    inc rx85_pos
    rx85_cur."!cursor_from"(rx85_pos)
    ge rx85_pos, rx85_eos, rxscan88_done
  rxscan88_scan:
    set_addr $I10, rxscan88_loop
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxscan88_done:
.annotate 'line', 47
  # rx rxquantr89 ** 0..1
    set_addr $I10, rxquantr89_done
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxquantr89_loop:
  alt90_0:
.annotate 'line', 44
    set_addr $I10, alt90_1
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
.annotate 'line', 45
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx85_pos, rx85_off
    set rx85_rep, 0
    sub $I12, rx85_eos, rx85_pos
  rxenumcharlistq91_loop:
    le $I12, 0, rxenumcharlistq91_done
    substr $S10, rx85_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq91_done
    inc rx85_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq91_loop
  rxenumcharlistq91_done:
    add rx85_pos, rx85_pos, rx85_rep
  # rxanchor eol
    sub $I10, rx85_pos, rx85_off
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rxanchor92_done
    ne rx85_pos, rx85_eos, rx85_fail
    eq rx85_pos, 0, rxanchor92_done
    dec $I10
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rx85_fail
  rxanchor92_done:
  # rx subrule "ws" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."ws"()
    unless $P10, rx85_fail
    rx85_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."MARKER"("endstmt")
    unless $P10, rx85_fail
    goto alt90_end
  alt90_1:
.annotate 'line', 46
  # rx rxquantr93 ** 0..1
    set_addr $I10, rxquantr93_done
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxquantr93_loop:
  # rx subrule "unv" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."unv"()
    unless $P10, rx85_fail
    goto rxsubrule94_pass
  rxsubrule94_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx85_fail
  rxsubrule94_pass:
    set_addr $I10, rxsubrule94_back
    rx85_cur."!mark_push"(0, rx85_pos, $I10, $P10)
    rx85_pos = $P10."pos"()
    set_addr $I10, rxquantr93_done
    (rx85_rep) = rx85_cur."!mark_commit"($I10)
  rxquantr93_done:
  # rxanchor eol
    sub $I10, rx85_pos, rx85_off
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rxanchor95_done
    ne rx85_pos, rx85_eos, rx85_fail
    eq rx85_pos, 0, rxanchor95_done
    dec $I10
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rx85_fail
  rxanchor95_done:
  # rx subrule "ws" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."ws"()
    unless $P10, rx85_fail
    rx85_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."MARKER"("endstmt")
    unless $P10, rx85_fail
  alt90_end:
.annotate 'line', 47
    set_addr $I10, rxquantr89_done
    (rx85_rep) = rx85_cur."!mark_commit"($I10)
  rxquantr89_done:
.annotate 'line', 43
  # rx pass
    rx85_cur."!cursor_pass"(rx85_pos, "ENDSTMT")
    if_null rx85_debug, debug_445
    rx85_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx85_pos)
  debug_445:
    .return (rx85_cur)
  rx85_restart:
.annotate 'line', 4
    if_null rx85_debug, debug_446
    rx85_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_446:
  rx85_fail:
    (rx85_rep, rx85_pos, $I10, $P10) = rx85_cur."!mark_fail"(0)
    lt rx85_pos, -1, rx85_done
    eq rx85_pos, -1, rx85_fail
    jump $I10
  rx85_done:
    rx85_cur."!cursor_fail"()
    if_null rx85_debug, debug_447
    rx85_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_447:
    .return (rx85_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1297619321.796") :method
.annotate 'line', 4
    new $P87, "ResizablePMCArray"
    push $P87, ""
    .return ($P87)
.end


.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx97_tgt
    .local int rx97_pos
    .local int rx97_off
    .local int rx97_eos
    .local int rx97_rep
    .local pmc rx97_cur
    .local pmc rx97_debug
    (rx97_cur, rx97_pos, rx97_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx97_cur
    .local pmc match
    .lex "$/", match
    length rx97_eos, rx97_tgt
    gt rx97_pos, rx97_eos, rx97_done
    set rx97_off, 0
    lt rx97_pos, 2, rx97_start
    sub rx97_off, rx97_pos, 1
    substr rx97_tgt, rx97_tgt, rx97_off
  rx97_start:
    eq $I10, 1, rx97_restart
    if_null rx97_debug, debug_448
    rx97_cur."!cursor_debug"("START", "ws")
  debug_448:
    $I10 = self.'from'()
    ne $I10, -1, rxscan100_done
    goto rxscan100_scan
  rxscan100_loop:
    (rx97_pos) = rx97_cur."from"()
    inc rx97_pos
    rx97_cur."!cursor_from"(rx97_pos)
    ge rx97_pos, rx97_eos, rxscan100_done
  rxscan100_scan:
    set_addr $I10, rxscan100_loop
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  rxscan100_done:
  alt101_0:
.annotate 'line', 50
    set_addr $I10, alt101_1
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 51
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."MARKED"("ws")
    unless $P10, rx97_fail
    goto alt101_end
  alt101_1:
.annotate 'line', 52
  # rx subrule "ww" subtype=zerowidth negate=1
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."ww"()
    if $P10, rx97_fail
.annotate 'line', 57
  # rx rxquantr102 ** 0..*
    set_addr $I10, rxquantr102_done
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  rxquantr102_loop:
  alt103_0:
.annotate 'line', 53
    set_addr $I10, alt103_1
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx97_pos, rx97_off
    set rx97_rep, 0
    sub $I12, rx97_eos, rx97_pos
  rxenumcharlistq104_loop:
    le $I12, 0, rxenumcharlistq104_done
    substr $S10, rx97_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq104_done
    inc rx97_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq104_loop
  rxenumcharlistq104_done:
    lt rx97_rep, 1, rx97_fail
    add rx97_pos, rx97_pos, rx97_rep
    goto alt103_end
  alt103_1:
    set_addr $I10, alt103_2
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 54
  # rx literal  "#"
    add $I11, rx97_pos, 1
    gt $I11, rx97_eos, rx97_fail
    sub $I11, rx97_pos, rx97_off
    ord $I11, rx97_tgt, $I11
    ne $I11, 35, rx97_fail
    add rx97_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx97_pos, rx97_off
    find_cclass $I11, 4096, rx97_tgt, $I10, rx97_eos
    add rx97_pos, rx97_off, $I11
    goto alt103_end
  alt103_2:
    set_addr $I10, alt103_3
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 55
  # rxanchor bol
    eq rx97_pos, 0, rxanchor105_done
    ge rx97_pos, rx97_eos, rx97_fail
    sub $I10, rx97_pos, rx97_off
    dec $I10
    is_cclass $I11, 4096, rx97_tgt, $I10
    unless $I11, rx97_fail
  rxanchor105_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."pod_comment"()
    unless $P10, rx97_fail
    rx97_pos = $P10."pos"()
    goto alt103_end
  alt103_3:
.annotate 'line', 56
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx97_pos, rx97_off
    set rx97_rep, 0
    sub $I12, rx97_eos, rx97_pos
  rxenumcharlistq106_loop:
    le $I12, 0, rxenumcharlistq106_done
    substr $S10, rx97_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq106_done
    inc rx97_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq106_loop
  rxenumcharlistq106_done:
    lt rx97_rep, 1, rx97_fail
    add rx97_pos, rx97_pos, rx97_rep
  alt103_end:
.annotate 'line', 57
    set_addr $I10, rxquantr102_done
    (rx97_rep) = rx97_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr102_done
    rx97_cur."!mark_push"(rx97_rep, rx97_pos, $I10)
    goto rxquantr102_loop
  rxquantr102_done:
.annotate 'line', 58
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."MARKER"("ws")
    unless $P10, rx97_fail
  alt101_end:
.annotate 'line', 50
  # rx pass
    rx97_cur."!cursor_pass"(rx97_pos, "ws")
    if_null rx97_debug, debug_449
    rx97_cur."!cursor_debug"("PASS", "ws", " at pos=", rx97_pos)
  debug_449:
    .return (rx97_cur)
  rx97_restart:
.annotate 'line', 4
    if_null rx97_debug, debug_450
    rx97_cur."!cursor_debug"("NEXT", "ws")
  debug_450:
  rx97_fail:
    (rx97_rep, rx97_pos, $I10, $P10) = rx97_cur."!mark_fail"(0)
    lt rx97_pos, -1, rx97_done
    eq rx97_pos, -1, rx97_fail
    jump $I10
  rx97_done:
    rx97_cur."!cursor_fail"()
    if_null rx97_debug, debug_451
    rx97_cur."!cursor_debug"("FAIL", "ws")
  debug_451:
    .return (rx97_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1297619321.796") :method
.annotate 'line', 4
    new $P99, "ResizablePMCArray"
    push $P99, ""
    push $P99, ""
    .return ($P99)
.end


.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P115 = "25_1297619321.796" 
    capture_lex $P115
    .local string rx108_tgt
    .local int rx108_pos
    .local int rx108_off
    .local int rx108_eos
    .local int rx108_rep
    .local pmc rx108_cur
    .local pmc rx108_debug
    (rx108_cur, rx108_pos, rx108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx108_cur
    .local pmc match
    .lex "$/", match
    length rx108_eos, rx108_tgt
    gt rx108_pos, rx108_eos, rx108_done
    set rx108_off, 0
    lt rx108_pos, 2, rx108_start
    sub rx108_off, rx108_pos, 1
    substr rx108_tgt, rx108_tgt, rx108_off
  rx108_start:
    eq $I10, 1, rx108_restart
    if_null rx108_debug, debug_452
    rx108_cur."!cursor_debug"("START", "unv")
  debug_452:
    $I10 = self.'from'()
    ne $I10, -1, rxscan111_done
    goto rxscan111_scan
  rxscan111_loop:
    (rx108_pos) = rx108_cur."from"()
    inc rx108_pos
    rx108_cur."!cursor_from"(rx108_pos)
    ge rx108_pos, rx108_eos, rxscan111_done
  rxscan111_scan:
    set_addr $I10, rxscan111_loop
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxscan111_done:
  alt112_0:
.annotate 'line', 63
    set_addr $I10, alt112_1
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 64
  # rxanchor bol
    eq rx108_pos, 0, rxanchor113_done
    ge rx108_pos, rx108_eos, rx108_fail
    sub $I10, rx108_pos, rx108_off
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    unless $I11, rx108_fail
  rxanchor113_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    .const 'Sub' $P115 = "25_1297619321.796" 
    capture_lex $P115
    $P10 = rx108_cur."before"($P115)
    unless $P10, rx108_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."pod_comment"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
    goto alt112_end
  alt112_1:
    set_addr $I10, alt112_2
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 65
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq120_loop:
    le $I12, 0, rxenumcharlistq120_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq120_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq120_loop
  rxenumcharlistq120_done:
    add rx108_pos, rx108_pos, rx108_rep
  # rx literal  "#"
    add $I11, rx108_pos, 1
    gt $I11, rx108_eos, rx108_fail
    sub $I11, rx108_pos, rx108_off
    ord $I11, rx108_tgt, $I11
    ne $I11, 35, rx108_fail
    add rx108_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx108_pos, rx108_off
    find_cclass $I11, 4096, rx108_tgt, $I10, rx108_eos
    add rx108_pos, rx108_off, $I11
    goto alt112_end
  alt112_2:
.annotate 'line', 66
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq121_loop:
    le $I12, 0, rxenumcharlistq121_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq121_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq121_loop
  rxenumcharlistq121_done:
    lt rx108_rep, 1, rx108_fail
    add rx108_pos, rx108_pos, rx108_rep
  alt112_end:
.annotate 'line', 61
  # rx pass
    rx108_cur."!cursor_pass"(rx108_pos, "unv")
    if_null rx108_debug, debug_457
    rx108_cur."!cursor_debug"("PASS", "unv", " at pos=", rx108_pos)
  debug_457:
    .return (rx108_cur)
  rx108_restart:
.annotate 'line', 4
    if_null rx108_debug, debug_458
    rx108_cur."!cursor_debug"("NEXT", "unv")
  debug_458:
  rx108_fail:
    (rx108_rep, rx108_pos, $I10, $P10) = rx108_cur."!mark_fail"(0)
    lt rx108_pos, -1, rx108_done
    eq rx108_pos, -1, rx108_fail
    jump $I10
  rx108_done:
    rx108_cur."!cursor_fail"()
    if_null rx108_debug, debug_459
    rx108_cur."!cursor_debug"("FAIL", "unv")
  debug_459:
    .return (rx108_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1297619321.796") :method
.annotate 'line', 4
    new $P110, "ResizablePMCArray"
    push $P110, ""
    push $P110, ""
    push $P110, ""
    .return ($P110)
.end


.namespace ["NQP";"Grammar"]
.sub "_block114"  :anon :subid("25_1297619321.796") :method :outer("23_1297619321.796")
.annotate 'line', 64
    .local string rx116_tgt
    .local int rx116_pos
    .local int rx116_off
    .local int rx116_eos
    .local int rx116_rep
    .local pmc rx116_cur
    .local pmc rx116_debug
    (rx116_cur, rx116_pos, rx116_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx116_cur
    .local pmc match
    .lex "$/", match
    length rx116_eos, rx116_tgt
    gt rx116_pos, rx116_eos, rx116_done
    set rx116_off, 0
    lt rx116_pos, 2, rx116_start
    sub rx116_off, rx116_pos, 1
    substr rx116_tgt, rx116_tgt, rx116_off
  rx116_start:
    eq $I10, 1, rx116_restart
    if_null rx116_debug, debug_453
    rx116_cur."!cursor_debug"("START", "")
  debug_453:
    $I10 = self.'from'()
    ne $I10, -1, rxscan117_done
    goto rxscan117_scan
  rxscan117_loop:
    (rx116_pos) = rx116_cur."from"()
    inc rx116_pos
    rx116_cur."!cursor_from"(rx116_pos)
    ge rx116_pos, rx116_eos, rxscan117_done
  rxscan117_scan:
    set_addr $I10, rxscan117_loop
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  rxscan117_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq118_loop:
    le $I12, 0, rxenumcharlistq118_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq118_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq118_loop
  rxenumcharlistq118_done:
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "="
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 61, rx116_fail
    add rx116_pos, 1
  alt119_0:
    set_addr $I10, alt119_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  # rx charclass w
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 8192, rx116_tgt, $I10
    unless $I11, rx116_fail
    inc rx116_pos
    goto alt119_end
  alt119_1:
  # rx literal  "\\"
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 92, rx116_fail
    add rx116_pos, 1
  alt119_end:
  # rx pass
    rx116_cur."!cursor_pass"(rx116_pos, "")
    if_null rx116_debug, debug_454
    rx116_cur."!cursor_debug"("PASS", "", " at pos=", rx116_pos)
  debug_454:
    .return (rx116_cur)
  rx116_restart:
    if_null rx116_debug, debug_455
    rx116_cur."!cursor_debug"("NEXT", "")
  debug_455:
  rx116_fail:
    (rx116_rep, rx116_pos, $I10, $P10) = rx116_cur."!mark_fail"(0)
    lt rx116_pos, -1, rx116_done
    eq rx116_pos, -1, rx116_fail
    jump $I10
  rx116_done:
    rx116_cur."!cursor_fail"()
    if_null rx116_debug, debug_456
    rx116_cur."!cursor_debug"("FAIL", "")
  debug_456:
    .return (rx116_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P154 = "28_1297619321.796" 
    capture_lex $P154
    .local string rx123_tgt
    .local int rx123_pos
    .local int rx123_off
    .local int rx123_eos
    .local int rx123_rep
    .local pmc rx123_cur
    .local pmc rx123_debug
    (rx123_cur, rx123_pos, rx123_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx123_cur
    .local pmc match
    .lex "$/", match
    length rx123_eos, rx123_tgt
    gt rx123_pos, rx123_eos, rx123_done
    set rx123_off, 0
    lt rx123_pos, 2, rx123_start
    sub rx123_off, rx123_pos, 1
    substr rx123_tgt, rx123_tgt, rx123_off
  rx123_start:
    eq $I10, 1, rx123_restart
    if_null rx123_debug, debug_460
    rx123_cur."!cursor_debug"("START", "pod_comment")
  debug_460:
    $I10 = self.'from'()
    ne $I10, -1, rxscan126_done
    goto rxscan126_scan
  rxscan126_loop:
    (rx123_pos) = rx123_cur."from"()
    inc rx123_pos
    rx123_cur."!cursor_from"(rx123_pos)
    ge rx123_pos, rx123_eos, rxscan126_done
  rxscan126_scan:
    set_addr $I10, rxscan126_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  rxscan126_done:
.annotate 'line', 71
  # rxanchor bol
    eq rx123_pos, 0, rxanchor127_done
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
  rxanchor127_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq128_loop:
    le $I12, 0, rxenumcharlistq128_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq128_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq128_loop
  rxenumcharlistq128_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "="
    add $I11, rx123_pos, 1
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    ord $I11, rx123_tgt, $I11
    ne $I11, 61, rx123_fail
    add rx123_pos, 1
  alt129_0:
.annotate 'line', 72
    set_addr $I10, alt129_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 73
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq130_loop:
    le $I12, 0, rxenumcharlistq130_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq130_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq130_loop
  rxenumcharlistq130_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "END"
    add $I11, rx123_pos, 3
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 3
    ne $S10, "END", rx123_fail
    add rx123_pos, 3
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  alt131_0:
.annotate 'line', 74
    set_addr $I10, alt131_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx rxquantf132 ** 0..*
    set_addr $I10, rxquantf132_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf132_done
  rxquantf132_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf132_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf132_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq134_loop:
    le $I12, 0, rxenumcharlistq134_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq134_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq134_loop
  rxenumcharlistq134_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq135_loop:
    le $I12, 0, rxenumcharlistq135_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq135_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq135_loop
  rxenumcharlistq135_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "END"
    add $I11, rx123_pos, 3
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 3
    ne $S10, "END", rx123_fail
    add rx123_pos, 3
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt131_end
  alt131_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_not_cclass $I11, 65535, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
  alt131_end:
.annotate 'line', 73
    goto alt129_end
  alt129_1:
    set_addr $I10, alt129_2
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 75
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq136_loop:
    le $I12, 0, rxenumcharlistq136_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq136_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq136_loop
  rxenumcharlistq136_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx subrule "identifier" subtype=capture negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."identifier"()
    unless $P10, rx123_fail
    rx123_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx123_pos = $P10."pos"()
  alt137_0:
.annotate 'line', 76
    set_addr $I10, alt137_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 77
  # rx rxquantf138 ** 0..*
    set_addr $I10, rxquantf138_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf138_done
  rxquantf138_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf138_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf138_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq140_loop:
    le $I12, 0, rxenumcharlistq140_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq140_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq140_loop
  rxenumcharlistq140_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."!BACKREF"("identifier")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt137_end
  alt137_1:
.annotate 'line', 78
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("=begin without matching =end")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt137_end:
.annotate 'line', 75
    goto alt129_end
  alt129_2:
    set_addr $I10, alt129_3
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx123_pos, rx123_pos, rx123_rep
  alt144_0:
.annotate 'line', 81
    set_addr $I10, alt144_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rxanchor eol
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    if $I11, rxanchor145_done
    ne rx123_pos, rx123_eos, rx123_fail
    eq rx123_pos, 0, rxanchor145_done
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    if $I11, rx123_fail
  rxanchor145_done:
    goto alt144_end
  alt144_1:
    set_addr $I10, alt144_2
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx literal  "#"
    add $I11, rx123_pos, 1
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    ord $I11, rx123_tgt, $I11
    ne $I11, 35, rx123_fail
    add rx123_pos, 1
    goto alt144_end
  alt144_2:
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt144_end:
  alt146_0:
.annotate 'line', 82
    set_addr $I10, alt146_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 83
  # rx rxquantf147 ** 0..*
    set_addr $I10, rxquantf147_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf147_done
  rxquantf147_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf147_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf147_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq149_loop:
    le $I12, 0, rxenumcharlistq149_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq149_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq149_loop
  rxenumcharlistq149_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt146_end
  alt146_1:
.annotate 'line', 84
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("=begin without matching =end")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt146_end:
.annotate 'line', 80
    goto alt129_end
  alt129_3:
    set_addr $I10, alt129_4
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 86
  # rx subrule "identifier" subtype=capture negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."identifier"()
    unless $P10, rx123_fail
    rx123_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx123_pos = $P10."pos"()
.annotate 'line', 87
  # rx rxquantf150 ** 0..*
    set_addr $I10, rxquantf150_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf150_done
  rxquantf150_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf150_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf150_done:
  # rxanchor bol
    eq rx123_pos, 0, rxanchor152_done
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
  rxanchor152_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    .const 'Sub' $P154 = "28_1297619321.796" 
    capture_lex $P154
    $P10 = rx123_cur."before"($P154)
    unless $P10, rx123_fail
.annotate 'line', 86
    goto alt129_end
  alt129_4:
  alt160_0:
.annotate 'line', 93
    set_addr $I10, alt160_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx charclass s
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 32, rx123_tgt, $I10
    unless $I11, rx123_fail
    inc rx123_pos
    goto alt160_end
  alt160_1:
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("Illegal pod directive")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt160_end:
.annotate 'line', 94
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
  alt129_end:
.annotate 'line', 70
  # rx pass
    rx123_cur."!cursor_pass"(rx123_pos, "pod_comment")
    if_null rx123_debug, debug_465
    rx123_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx123_pos)
  debug_465:
    .return (rx123_cur)
  rx123_restart:
.annotate 'line', 4
    if_null rx123_debug, debug_466
    rx123_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_466:
  rx123_fail:
    (rx123_rep, rx123_pos, $I10, $P10) = rx123_cur."!mark_fail"(0)
    lt rx123_pos, -1, rx123_done
    eq rx123_pos, -1, rx123_fail
    jump $I10
  rx123_done:
    rx123_cur."!cursor_fail"()
    if_null rx123_debug, debug_467
    rx123_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_467:
    .return (rx123_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1297619321.796") :method
.annotate 'line', 4
    new $P125, "ResizablePMCArray"
    push $P125, ""
    .return ($P125)
.end


.namespace ["NQP";"Grammar"]
.sub "_block153"  :anon :subid("28_1297619321.796") :method :outer("26_1297619321.796")
.annotate 'line', 87
    .local string rx155_tgt
    .local int rx155_pos
    .local int rx155_off
    .local int rx155_eos
    .local int rx155_rep
    .local pmc rx155_cur
    .local pmc rx155_debug
    (rx155_cur, rx155_pos, rx155_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx155_cur
    .local pmc match
    .lex "$/", match
    length rx155_eos, rx155_tgt
    gt rx155_pos, rx155_eos, rx155_done
    set rx155_off, 0
    lt rx155_pos, 2, rx155_start
    sub rx155_off, rx155_pos, 1
    substr rx155_tgt, rx155_tgt, rx155_off
  rx155_start:
    eq $I10, 1, rx155_restart
    if_null rx155_debug, debug_461
    rx155_cur."!cursor_debug"("START", "")
  debug_461:
    $I10 = self.'from'()
    ne $I10, -1, rxscan156_done
    goto rxscan156_scan
  rxscan156_loop:
    (rx155_pos) = rx155_cur."from"()
    inc rx155_pos
    rx155_cur."!cursor_from"(rx155_pos)
    ge rx155_pos, rx155_eos, rxscan156_done
  rxscan156_scan:
    set_addr $I10, rxscan156_loop
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxscan156_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx155_pos, rx155_off
    set rx155_rep, 0
    sub $I12, rx155_eos, rx155_pos
  rxenumcharlistq157_loop:
    le $I12, 0, rxenumcharlistq157_done
    substr $S10, rx155_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq157_done
    inc rx155_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq157_loop
  rxenumcharlistq157_done:
    add rx155_pos, rx155_pos, rx155_rep
  alt158_0:
    set_addr $I10, alt158_1
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
.annotate 'line', 88
  # rx literal  "="
    add $I11, rx155_pos, 1
    gt $I11, rx155_eos, rx155_fail
    sub $I11, rx155_pos, rx155_off
    ord $I11, rx155_tgt, $I11
    ne $I11, 61, rx155_fail
    add rx155_pos, 1
.annotate 'line', 90
  # rx rxquantr159 ** 0..1
    set_addr $I10, rxquantr159_done
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxquantr159_loop:
.annotate 'line', 89
  # rx literal  "cut"
    add $I11, rx155_pos, 3
    gt $I11, rx155_eos, rx155_fail
    sub $I11, rx155_pos, rx155_off
    substr $S10, rx155_tgt, $I11, 3
    ne $S10, "cut", rx155_fail
    add rx155_pos, 3
  # rxanchor rwb
    le rx155_pos, 0, rx155_fail
    sub $I10, rx155_pos, rx155_off
    is_cclass $I11, 8192, rx155_tgt, $I10
    if $I11, rx155_fail
    dec $I10
    is_cclass $I11, 8192, rx155_tgt, $I10
    unless $I11, rx155_fail
.annotate 'line', 90
  # rx subrule "panic" subtype=method negate=
    rx155_cur."!cursor_pos"(rx155_pos)
    $P10 = rx155_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx155_fail
    rx155_pos = $P10."pos"()
    set_addr $I10, rxquantr159_done
    (rx155_rep) = rx155_cur."!mark_commit"($I10)
  rxquantr159_done:
.annotate 'line', 87
    goto alt158_end
  alt158_1:
.annotate 'line', 91
  # rx charclass nl
    ge rx155_pos, rx155_eos, rx155_fail
    sub $I10, rx155_pos, rx155_off
    is_cclass $I11, 4096, rx155_tgt, $I10
    unless $I11, rx155_fail
    substr $S10, rx155_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx155_pos, $I11
    inc rx155_pos
  alt158_end:
.annotate 'line', 87
  # rx pass
    rx155_cur."!cursor_pass"(rx155_pos, "")
    if_null rx155_debug, debug_462
    rx155_cur."!cursor_debug"("PASS", "", " at pos=", rx155_pos)
  debug_462:
    .return (rx155_cur)
  rx155_restart:
    if_null rx155_debug, debug_463
    rx155_cur."!cursor_debug"("NEXT", "")
  debug_463:
  rx155_fail:
    (rx155_rep, rx155_pos, $I10, $P10) = rx155_cur."!mark_fail"(0)
    lt rx155_pos, -1, rx155_done
    eq rx155_pos, -1, rx155_fail
    jump $I10
  rx155_done:
    rx155_cur."!cursor_fail"()
    if_null rx155_debug, debug_464
    rx155_cur."!cursor_debug"("FAIL", "")
  debug_464:
    .return (rx155_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx162_tgt
    .local int rx162_pos
    .local int rx162_off
    .local int rx162_eos
    .local int rx162_rep
    .local pmc rx162_cur
    .local pmc rx162_debug
    (rx162_cur, rx162_pos, rx162_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx162_cur
    .local pmc match
    .lex "$/", match
    length rx162_eos, rx162_tgt
    gt rx162_pos, rx162_eos, rx162_done
    set rx162_off, 0
    lt rx162_pos, 2, rx162_start
    sub rx162_off, rx162_pos, 1
    substr rx162_tgt, rx162_tgt, rx162_off
  rx162_start:
    eq $I10, 1, rx162_restart
    if_null rx162_debug, debug_468
    rx162_cur."!cursor_debug"("START", "comp_unit")
  debug_468:
    $I10 = self.'from'()
    ne $I10, -1, rxscan166_done
    goto rxscan166_scan
  rxscan166_loop:
    (rx162_pos) = rx162_cur."from"()
    inc rx162_pos
    rx162_cur."!cursor_from"(rx162_pos)
    ge rx162_pos, rx162_eos, rxscan166_done
  rxscan166_scan:
    set_addr $I10, rxscan166_loop
    rx162_cur."!mark_push"(0, rx162_pos, $I10)
  rxscan166_done:
.annotate 'line', 102
  # rx subrule "newpad" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."newpad"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
.annotate 'line', 103
  # rx subrule "outerctx" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."outerctx"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
.annotate 'line', 104
  # rx subrule "statementlist" subtype=capture negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."statementlist"()
    unless $P10, rx162_fail
    rx162_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx162_pos = $P10."pos"()
  alt167_0:
.annotate 'line', 105
    set_addr $I10, alt167_1
    rx162_cur."!mark_push"(0, rx162_pos, $I10)
  # rxanchor eos
    ne rx162_pos, rx162_eos, rx162_fail
    goto alt167_end
  alt167_1:
  # rx subrule "panic" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."panic"("Confused")
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
  alt167_end:
.annotate 'line', 101
  # rx pass
    rx162_cur."!cursor_pass"(rx162_pos, "comp_unit")
    if_null rx162_debug, debug_469
    rx162_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx162_pos)
  debug_469:
    .return (rx162_cur)
  rx162_restart:
.annotate 'line', 4
    if_null rx162_debug, debug_470
    rx162_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_470:
  rx162_fail:
    (rx162_rep, rx162_pos, $I10, $P10) = rx162_cur."!mark_fail"(0)
    lt rx162_pos, -1, rx162_done
    eq rx162_pos, -1, rx162_fail
    jump $I10
  rx162_done:
    rx162_cur."!cursor_fail"()
    if_null rx162_debug, debug_471
    rx162_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_471:
    .return (rx162_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1297619321.796") :method
.annotate 'line', 4
    $P164 = self."!PREFIX__!subrule"("newpad", "")
    new $P165, "ResizablePMCArray"
    push $P165, $P164
    .return ($P165)
.end


.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx169_tgt
    .local int rx169_pos
    .local int rx169_off
    .local int rx169_eos
    .local int rx169_rep
    .local pmc rx169_cur
    .local pmc rx169_debug
    (rx169_cur, rx169_pos, rx169_tgt, $I10) = self."!cursor_start"()
    rx169_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx169_cur
    .local pmc match
    .lex "$/", match
    length rx169_eos, rx169_tgt
    gt rx169_pos, rx169_eos, rx169_done
    set rx169_off, 0
    lt rx169_pos, 2, rx169_start
    sub rx169_off, rx169_pos, 1
    substr rx169_tgt, rx169_tgt, rx169_off
  rx169_start:
    eq $I10, 1, rx169_restart
    if_null rx169_debug, debug_472
    rx169_cur."!cursor_debug"("START", "statementlist")
  debug_472:
    $I10 = self.'from'()
    ne $I10, -1, rxscan174_done
    goto rxscan174_scan
  rxscan174_loop:
    (rx169_pos) = rx169_cur."from"()
    inc rx169_pos
    rx169_cur."!cursor_from"(rx169_pos)
    ge rx169_pos, rx169_eos, rxscan174_done
  rxscan174_scan:
    set_addr $I10, rxscan174_loop
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
  rxscan174_done:
  alt175_0:
.annotate 'line', 108
    set_addr $I10, alt175_1
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
.annotate 'line', 109
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  # rxanchor eos
    ne rx169_pos, rx169_eos, rx169_fail
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
    goto alt175_end
  alt175_1:
.annotate 'line', 110
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  # rx rxquantr179 ** 0..*
    set_addr $I10, rxquantr179_done
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
  rxquantr179_loop:
  # rx subrule "statement" subtype=capture negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."statement"()
    unless $P10, rx169_fail
    rx169_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx169_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."eat_terminator"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
    set_addr $I10, rxquantr179_done
    (rx169_rep) = rx169_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr179_done
    rx169_cur."!mark_push"(rx169_rep, rx169_pos, $I10)
    goto rxquantr179_loop
  rxquantr179_done:
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  alt175_end:
.annotate 'line', 108
  # rx pass
    rx169_cur."!cursor_pass"(rx169_pos, "statementlist")
    if_null rx169_debug, debug_473
    rx169_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx169_pos)
  debug_473:
    .return (rx169_cur)
  rx169_restart:
.annotate 'line', 4
    if_null rx169_debug, debug_474
    rx169_cur."!cursor_debug"("NEXT", "statementlist")
  debug_474:
  rx169_fail:
    (rx169_rep, rx169_pos, $I10, $P10) = rx169_cur."!mark_fail"(0)
    lt rx169_pos, -1, rx169_done
    eq rx169_pos, -1, rx169_fail
    jump $I10
  rx169_done:
    rx169_cur."!cursor_fail"()
    if_null rx169_debug, debug_475
    rx169_cur."!cursor_debug"("FAIL", "statementlist")
  debug_475:
    .return (rx169_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1297619321.796") :method
.annotate 'line', 4
    $P171 = self."!PREFIX__!subrule"("ws", "")
    $P172 = self."!PREFIX__!subrule"("ws", "")
    new $P173, "ResizablePMCArray"
    push $P173, $P171
    push $P173, $P172
    .return ($P173)
.end


.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P188 = "35_1297619321.796" 
    capture_lex $P188
    .local string rx183_tgt
    .local int rx183_pos
    .local int rx183_off
    .local int rx183_eos
    .local int rx183_rep
    .local pmc rx183_cur
    .local pmc rx183_debug
    (rx183_cur, rx183_pos, rx183_tgt, $I10) = self."!cursor_start"()
    rx183_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx183_cur
    .local pmc match
    .lex "$/", match
    length rx183_eos, rx183_tgt
    gt rx183_pos, rx183_eos, rx183_done
    set rx183_off, 0
    lt rx183_pos, 2, rx183_start
    sub rx183_off, rx183_pos, 1
    substr rx183_tgt, rx183_tgt, rx183_off
  rx183_start:
    eq $I10, 1, rx183_restart
    if_null rx183_debug, debug_476
    rx183_cur."!cursor_debug"("START", "statement")
  debug_476:
    $I10 = self.'from'()
    ne $I10, -1, rxscan186_done
    goto rxscan186_scan
  rxscan186_loop:
    (rx183_pos) = rx183_cur."from"()
    inc rx183_pos
    rx183_cur."!cursor_from"(rx183_pos)
    ge rx183_pos, rx183_eos, rxscan186_done
  rxscan186_scan:
    set_addr $I10, rxscan186_loop
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
  rxscan186_done:
.annotate 'line', 114
  # rx subrule "before" subtype=zerowidth negate=1
    rx183_cur."!cursor_pos"(rx183_pos)
    .const 'Sub' $P188 = "35_1297619321.796" 
    capture_lex $P188
    $P10 = rx183_cur."before"($P188)
    if $P10, rx183_fail
  alt192_0:
.annotate 'line', 115
    set_addr $I10, alt192_1
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
.annotate 'line', 116
  # rx subrule "statement_control" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_control"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx183_pos = $P10."pos"()
    goto alt192_end
  alt192_1:
.annotate 'line', 117
  # rx subrule "EXPR" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."EXPR"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx183_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."ws"()
    unless $P10, rx183_fail
    rx183_pos = $P10."pos"()
.annotate 'line', 122
  # rx rxquantr193 ** 0..1
    set_addr $I10, rxquantr193_done
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
  rxquantr193_loop:
  alt194_0:
.annotate 'line', 118
    set_addr $I10, alt194_1
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
.annotate 'line', 119
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."MARKED"("endstmt")
    unless $P10, rx183_fail
    goto alt194_end
  alt194_1:
    set_addr $I10, alt194_2
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
.annotate 'line', 120
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_mod_cond"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx183_pos = $P10."pos"()
  # rx rxquantr195 ** 0..1
    set_addr $I10, rxquantr195_done
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
  rxquantr195_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_mod_loop"()
    unless $P10, rx183_fail
    goto rxsubrule196_pass
  rxsubrule196_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx183_fail
  rxsubrule196_pass:
    set_addr $I10, rxsubrule196_back
    rx183_cur."!mark_push"(0, rx183_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx183_pos = $P10."pos"()
    set_addr $I10, rxquantr195_done
    (rx183_rep) = rx183_cur."!mark_commit"($I10)
  rxquantr195_done:
    goto alt194_end
  alt194_2:
.annotate 'line', 121
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_mod_loop"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx183_pos = $P10."pos"()
  alt194_end:
.annotate 'line', 122
    set_addr $I10, rxquantr193_done
    (rx183_rep) = rx183_cur."!mark_commit"($I10)
  rxquantr193_done:
  alt192_end:
.annotate 'line', 113
  # rx pass
    rx183_cur."!cursor_pass"(rx183_pos, "statement")
    if_null rx183_debug, debug_481
    rx183_cur."!cursor_debug"("PASS", "statement", " at pos=", rx183_pos)
  debug_481:
    .return (rx183_cur)
  rx183_restart:
.annotate 'line', 4
    if_null rx183_debug, debug_482
    rx183_cur."!cursor_debug"("NEXT", "statement")
  debug_482:
  rx183_fail:
    (rx183_rep, rx183_pos, $I10, $P10) = rx183_cur."!mark_fail"(0)
    lt rx183_pos, -1, rx183_done
    eq rx183_pos, -1, rx183_fail
    jump $I10
  rx183_done:
    rx183_cur."!cursor_fail"()
    if_null rx183_debug, debug_483
    rx183_cur."!cursor_debug"("FAIL", "statement")
  debug_483:
    .return (rx183_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1297619321.796") :method
.annotate 'line', 4
    new $P185, "ResizablePMCArray"
    push $P185, ""
    .return ($P185)
.end


.namespace ["NQP";"Grammar"]
.sub "_block187"  :anon :subid("35_1297619321.796") :method :outer("33_1297619321.796")
.annotate 'line', 114
    .local string rx189_tgt
    .local int rx189_pos
    .local int rx189_off
    .local int rx189_eos
    .local int rx189_rep
    .local pmc rx189_cur
    .local pmc rx189_debug
    (rx189_cur, rx189_pos, rx189_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx189_cur
    .local pmc match
    .lex "$/", match
    length rx189_eos, rx189_tgt
    gt rx189_pos, rx189_eos, rx189_done
    set rx189_off, 0
    lt rx189_pos, 2, rx189_start
    sub rx189_off, rx189_pos, 1
    substr rx189_tgt, rx189_tgt, rx189_off
  rx189_start:
    eq $I10, 1, rx189_restart
    if_null rx189_debug, debug_477
    rx189_cur."!cursor_debug"("START", "")
  debug_477:
    $I10 = self.'from'()
    ne $I10, -1, rxscan190_done
    goto rxscan190_scan
  rxscan190_loop:
    (rx189_pos) = rx189_cur."from"()
    inc rx189_pos
    rx189_cur."!cursor_from"(rx189_pos)
    ge rx189_pos, rx189_eos, rxscan190_done
  rxscan190_scan:
    set_addr $I10, rxscan190_loop
    rx189_cur."!mark_push"(0, rx189_pos, $I10)
  rxscan190_done:
  alt191_0:
    set_addr $I10, alt191_1
    rx189_cur."!mark_push"(0, rx189_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx189_pos, rx189_eos, rx189_fail
    sub $I10, rx189_pos, rx189_off
    substr $S10, rx189_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx189_fail
    inc rx189_pos
    goto alt191_end
  alt191_1:
  # rxanchor eos
    ne rx189_pos, rx189_eos, rx189_fail
  alt191_end:
  # rx pass
    rx189_cur."!cursor_pass"(rx189_pos, "")
    if_null rx189_debug, debug_478
    rx189_cur."!cursor_debug"("PASS", "", " at pos=", rx189_pos)
  debug_478:
    .return (rx189_cur)
  rx189_restart:
    if_null rx189_debug, debug_479
    rx189_cur."!cursor_debug"("NEXT", "")
  debug_479:
  rx189_fail:
    (rx189_rep, rx189_pos, $I10, $P10) = rx189_cur."!mark_fail"(0)
    lt rx189_pos, -1, rx189_done
    eq rx189_pos, -1, rx189_fail
    jump $I10
  rx189_done:
    rx189_cur."!cursor_fail"()
    if_null rx189_debug, debug_480
    rx189_cur."!cursor_debug"("FAIL", "")
  debug_480:
    .return (rx189_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx198_tgt
    .local int rx198_pos
    .local int rx198_off
    .local int rx198_eos
    .local int rx198_rep
    .local pmc rx198_cur
    .local pmc rx198_debug
    (rx198_cur, rx198_pos, rx198_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx198_cur
    .local pmc match
    .lex "$/", match
    length rx198_eos, rx198_tgt
    gt rx198_pos, rx198_eos, rx198_done
    set rx198_off, 0
    lt rx198_pos, 2, rx198_start
    sub rx198_off, rx198_pos, 1
    substr rx198_tgt, rx198_tgt, rx198_off
  rx198_start:
    eq $I10, 1, rx198_restart
    if_null rx198_debug, debug_484
    rx198_cur."!cursor_debug"("START", "eat_terminator")
  debug_484:
    $I10 = self.'from'()
    ne $I10, -1, rxscan201_done
    goto rxscan201_scan
  rxscan201_loop:
    (rx198_pos) = rx198_cur."from"()
    inc rx198_pos
    rx198_cur."!cursor_from"(rx198_pos)
    ge rx198_pos, rx198_eos, rxscan201_done
  rxscan201_scan:
    set_addr $I10, rxscan201_loop
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
  rxscan201_done:
  alt202_0:
.annotate 'line', 126
    set_addr $I10, alt202_1
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
.annotate 'line', 127
  # rx literal  ";"
    add $I11, rx198_pos, 1
    gt $I11, rx198_eos, rx198_fail
    sub $I11, rx198_pos, rx198_off
    ord $I11, rx198_tgt, $I11
    ne $I11, 59, rx198_fail
    add rx198_pos, 1
    goto alt202_end
  alt202_1:
    set_addr $I10, alt202_2
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
.annotate 'line', 128
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx198_cur."!cursor_pos"(rx198_pos)
    $P10 = rx198_cur."MARKED"("endstmt")
    unless $P10, rx198_fail
    goto alt202_end
  alt202_2:
    set_addr $I10, alt202_3
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
.annotate 'line', 129
  # rx subrule "terminator" subtype=zerowidth negate=
    rx198_cur."!cursor_pos"(rx198_pos)
    $P10 = rx198_cur."terminator"()
    unless $P10, rx198_fail
    goto alt202_end
  alt202_3:
.annotate 'line', 130
  # rxanchor eos
    ne rx198_pos, rx198_eos, rx198_fail
  alt202_end:
.annotate 'line', 126
  # rx pass
    rx198_cur."!cursor_pass"(rx198_pos, "eat_terminator")
    if_null rx198_debug, debug_485
    rx198_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx198_pos)
  debug_485:
    .return (rx198_cur)
  rx198_restart:
.annotate 'line', 4
    if_null rx198_debug, debug_486
    rx198_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_486:
  rx198_fail:
    (rx198_rep, rx198_pos, $I10, $P10) = rx198_cur."!mark_fail"(0)
    lt rx198_pos, -1, rx198_done
    eq rx198_pos, -1, rx198_fail
    jump $I10
  rx198_done:
    rx198_cur."!cursor_fail"()
    if_null rx198_debug, debug_487
    rx198_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_487:
    .return (rx198_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1297619321.796") :method
.annotate 'line', 4
    new $P200, "ResizablePMCArray"
    push $P200, ""
    push $P200, ""
    push $P200, ""
    push $P200, ";"
    .return ($P200)
.end


.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx204_tgt
    .local int rx204_pos
    .local int rx204_off
    .local int rx204_eos
    .local int rx204_rep
    .local pmc rx204_cur
    .local pmc rx204_debug
    (rx204_cur, rx204_pos, rx204_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx204_cur
    .local pmc match
    .lex "$/", match
    length rx204_eos, rx204_tgt
    gt rx204_pos, rx204_eos, rx204_done
    set rx204_off, 0
    lt rx204_pos, 2, rx204_start
    sub rx204_off, rx204_pos, 1
    substr rx204_tgt, rx204_tgt, rx204_off
  rx204_start:
    eq $I10, 1, rx204_restart
    if_null rx204_debug, debug_488
    rx204_cur."!cursor_debug"("START", "xblock")
  debug_488:
    $I10 = self.'from'()
    ne $I10, -1, rxscan208_done
    goto rxscan208_scan
  rxscan208_loop:
    (rx204_pos) = rx204_cur."from"()
    inc rx204_pos
    rx204_cur."!cursor_from"(rx204_pos)
    ge rx204_pos, rx204_eos, rxscan208_done
  rxscan208_scan:
    set_addr $I10, rxscan208_loop
    rx204_cur."!mark_push"(0, rx204_pos, $I10)
  rxscan208_done:
.annotate 'line', 134
  # rx subrule "EXPR" subtype=capture negate=
    rx204_cur."!cursor_pos"(rx204_pos)
    $P10 = rx204_cur."EXPR"()
    unless $P10, rx204_fail
    rx204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx204_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx204_cur."!cursor_pos"(rx204_pos)
    $P10 = rx204_cur."ws"()
    unless $P10, rx204_fail
    rx204_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx204_cur."!cursor_pos"(rx204_pos)
    $P10 = rx204_cur."pblock"()
    unless $P10, rx204_fail
    rx204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx204_pos = $P10."pos"()
.annotate 'line', 133
  # rx pass
    rx204_cur."!cursor_pass"(rx204_pos, "xblock")
    if_null rx204_debug, debug_489
    rx204_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx204_pos)
  debug_489:
    .return (rx204_cur)
  rx204_restart:
.annotate 'line', 4
    if_null rx204_debug, debug_490
    rx204_cur."!cursor_debug"("NEXT", "xblock")
  debug_490:
  rx204_fail:
    (rx204_rep, rx204_pos, $I10, $P10) = rx204_cur."!mark_fail"(0)
    lt rx204_pos, -1, rx204_done
    eq rx204_pos, -1, rx204_fail
    jump $I10
  rx204_done:
    rx204_cur."!cursor_fail"()
    if_null rx204_debug, debug_491
    rx204_cur."!cursor_debug"("FAIL", "xblock")
  debug_491:
    .return (rx204_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1297619321.796") :method
.annotate 'line', 4
    $P206 = self."!PREFIX__!subrule"("EXPR", "")
    new $P207, "ResizablePMCArray"
    push $P207, $P206
    .return ($P207)
.end


.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx210_tgt
    .local int rx210_pos
    .local int rx210_off
    .local int rx210_eos
    .local int rx210_rep
    .local pmc rx210_cur
    .local pmc rx210_debug
    (rx210_cur, rx210_pos, rx210_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx210_cur
    .local pmc match
    .lex "$/", match
    length rx210_eos, rx210_tgt
    gt rx210_pos, rx210_eos, rx210_done
    set rx210_off, 0
    lt rx210_pos, 2, rx210_start
    sub rx210_off, rx210_pos, 1
    substr rx210_tgt, rx210_tgt, rx210_off
  rx210_start:
    eq $I10, 1, rx210_restart
    if_null rx210_debug, debug_492
    rx210_cur."!cursor_debug"("START", "pblock")
  debug_492:
    $I10 = self.'from'()
    ne $I10, -1, rxscan215_done
    goto rxscan215_scan
  rxscan215_loop:
    (rx210_pos) = rx210_cur."from"()
    inc rx210_pos
    rx210_cur."!cursor_from"(rx210_pos)
    ge rx210_pos, rx210_eos, rxscan215_done
  rxscan215_scan:
    set_addr $I10, rxscan215_loop
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxscan215_done:
  alt216_0:
.annotate 'line', 137
    set_addr $I10, alt216_1
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 138
  # rx subrule "lambda" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."lambda"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 139
  # rx subrule "newpad" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."newpad"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 140
  # rx subrule "signature" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."signature"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx210_pos = $P10."pos"()
.annotate 'line', 141
  # rx subrule "blockoid" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."blockoid"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx210_pos = $P10."pos"()
.annotate 'line', 138
    goto alt216_end
  alt216_1:
    set_addr $I10, alt216_2
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 142
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx210_pos, rx210_off
    substr $S10, rx210_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx210_fail
.annotate 'line', 143
  # rx subrule "newpad" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."newpad"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 144
  # rx subrule "blockoid" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."blockoid"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx210_pos = $P10."pos"()
.annotate 'line', 142
    goto alt216_end
  alt216_2:
.annotate 'line', 145
  # rx subrule "panic" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."panic"("Missing block")
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
  alt216_end:
.annotate 'line', 137
  # rx pass
    rx210_cur."!cursor_pass"(rx210_pos, "pblock")
    if_null rx210_debug, debug_493
    rx210_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx210_pos)
  debug_493:
    .return (rx210_cur)
  rx210_restart:
.annotate 'line', 4
    if_null rx210_debug, debug_494
    rx210_cur."!cursor_debug"("NEXT", "pblock")
  debug_494:
  rx210_fail:
    (rx210_rep, rx210_pos, $I10, $P10) = rx210_cur."!mark_fail"(0)
    lt rx210_pos, -1, rx210_done
    eq rx210_pos, -1, rx210_fail
    jump $I10
  rx210_done:
    rx210_cur."!cursor_fail"()
    if_null rx210_debug, debug_495
    rx210_cur."!cursor_debug"("FAIL", "pblock")
  debug_495:
    .return (rx210_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1297619321.796") :method
.annotate 'line', 4
    $P212 = self."!PREFIX__!subrule"("panic", "")
    $P213 = self."!PREFIX__!subrule"("lambda", "")
    new $P214, "ResizablePMCArray"
    push $P214, $P212
    push $P214, "{"
    push $P214, $P213
    .return ($P214)
.end


.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx218_tgt
    .local int rx218_pos
    .local int rx218_off
    .local int rx218_eos
    .local int rx218_rep
    .local pmc rx218_cur
    .local pmc rx218_debug
    (rx218_cur, rx218_pos, rx218_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx218_cur
    .local pmc match
    .lex "$/", match
    length rx218_eos, rx218_tgt
    gt rx218_pos, rx218_eos, rx218_done
    set rx218_off, 0
    lt rx218_pos, 2, rx218_start
    sub rx218_off, rx218_pos, 1
    substr rx218_tgt, rx218_tgt, rx218_off
  rx218_start:
    eq $I10, 1, rx218_restart
    if_null rx218_debug, debug_496
    rx218_cur."!cursor_debug"("START", "lambda")
  debug_496:
    $I10 = self.'from'()
    ne $I10, -1, rxscan221_done
    goto rxscan221_scan
  rxscan221_loop:
    (rx218_pos) = rx218_cur."from"()
    inc rx218_pos
    rx218_cur."!cursor_from"(rx218_pos)
    ge rx218_pos, rx218_eos, rxscan221_done
  rxscan221_scan:
    set_addr $I10, rxscan221_loop
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  rxscan221_done:
  alt222_0:
.annotate 'line', 148
    set_addr $I10, alt222_1
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  # rx literal  "->"
    add $I11, rx218_pos, 2
    gt $I11, rx218_eos, rx218_fail
    sub $I11, rx218_pos, rx218_off
    substr $S10, rx218_tgt, $I11, 2
    ne $S10, "->", rx218_fail
    add rx218_pos, 2
    goto alt222_end
  alt222_1:
  # rx literal  "<->"
    add $I11, rx218_pos, 3
    gt $I11, rx218_eos, rx218_fail
    sub $I11, rx218_pos, rx218_off
    substr $S10, rx218_tgt, $I11, 3
    ne $S10, "<->", rx218_fail
    add rx218_pos, 3
  alt222_end:
  # rx pass
    rx218_cur."!cursor_pass"(rx218_pos, "lambda")
    if_null rx218_debug, debug_497
    rx218_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx218_pos)
  debug_497:
    .return (rx218_cur)
  rx218_restart:
.annotate 'line', 4
    if_null rx218_debug, debug_498
    rx218_cur."!cursor_debug"("NEXT", "lambda")
  debug_498:
  rx218_fail:
    (rx218_rep, rx218_pos, $I10, $P10) = rx218_cur."!mark_fail"(0)
    lt rx218_pos, -1, rx218_done
    eq rx218_pos, -1, rx218_fail
    jump $I10
  rx218_done:
    rx218_cur."!cursor_fail"()
    if_null rx218_debug, debug_499
    rx218_cur."!cursor_debug"("FAIL", "lambda")
  debug_499:
    .return (rx218_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1297619321.796") :method
.annotate 'line', 4
    new $P220, "ResizablePMCArray"
    push $P220, "<->"
    push $P220, "->"
    .return ($P220)
.end


.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx224_tgt
    .local int rx224_pos
    .local int rx224_off
    .local int rx224_eos
    .local int rx224_rep
    .local pmc rx224_cur
    .local pmc rx224_debug
    (rx224_cur, rx224_pos, rx224_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx224_cur
    .local pmc match
    .lex "$/", match
    length rx224_eos, rx224_tgt
    gt rx224_pos, rx224_eos, rx224_done
    set rx224_off, 0
    lt rx224_pos, 2, rx224_start
    sub rx224_off, rx224_pos, 1
    substr rx224_tgt, rx224_tgt, rx224_off
  rx224_start:
    eq $I10, 1, rx224_restart
    if_null rx224_debug, debug_500
    rx224_cur."!cursor_debug"("START", "block")
  debug_500:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    (rx224_pos) = rx224_cur."from"()
    inc rx224_pos
    rx224_cur."!cursor_from"(rx224_pos)
    ge rx224_pos, rx224_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  rxscan228_done:
  alt229_0:
.annotate 'line', 151
    set_addr $I10, alt229_1
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx224_pos, rx224_off
    substr $S10, rx224_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx224_fail
    goto alt229_end
  alt229_1:
  # rx subrule "panic" subtype=method negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."panic"("Missing block")
    unless $P10, rx224_fail
    rx224_pos = $P10."pos"()
  alt229_end:
.annotate 'line', 152
  # rx subrule "newpad" subtype=method negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."newpad"()
    unless $P10, rx224_fail
    rx224_pos = $P10."pos"()
.annotate 'line', 153
  # rx subrule "blockoid" subtype=capture negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."blockoid"()
    unless $P10, rx224_fail
    rx224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx224_pos = $P10."pos"()
.annotate 'line', 150
  # rx pass
    rx224_cur."!cursor_pass"(rx224_pos, "block")
    if_null rx224_debug, debug_501
    rx224_cur."!cursor_debug"("PASS", "block", " at pos=", rx224_pos)
  debug_501:
    .return (rx224_cur)
  rx224_restart:
.annotate 'line', 4
    if_null rx224_debug, debug_502
    rx224_cur."!cursor_debug"("NEXT", "block")
  debug_502:
  rx224_fail:
    (rx224_rep, rx224_pos, $I10, $P10) = rx224_cur."!mark_fail"(0)
    lt rx224_pos, -1, rx224_done
    eq rx224_pos, -1, rx224_fail
    jump $I10
  rx224_done:
    rx224_cur."!cursor_fail"()
    if_null rx224_debug, debug_503
    rx224_cur."!cursor_debug"("FAIL", "block")
  debug_503:
    .return (rx224_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1297619321.796") :method
.annotate 'line', 4
    $P226 = self."!PREFIX__!subrule"("panic", "")
    new $P227, "ResizablePMCArray"
    push $P227, $P226
    push $P227, "{"
    .return ($P227)
.end


.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_504
    rx231_cur."!cursor_debug"("START", "blockoid")
  debug_504:
    $I10 = self.'from'()
    ne $I10, -1, rxscan235_done
    goto rxscan235_scan
  rxscan235_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan235_done
  rxscan235_scan:
    set_addr $I10, rxscan235_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan235_done:
.annotate 'line', 157
  # rx subrule "finishpad" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."finishpad"()
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
.annotate 'line', 158
  # rx literal  "{"
    add $I11, rx231_pos, 1
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    ord $I11, rx231_tgt, $I11
    ne $I11, 123, rx231_fail
    add rx231_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."statementlist"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx231_pos = $P10."pos"()
  alt236_0:
    set_addr $I10, alt236_1
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  # rx literal  "}"
    add $I11, rx231_pos, 1
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    ord $I11, rx231_tgt, $I11
    ne $I11, 125, rx231_fail
    add rx231_pos, 1
    goto alt236_end
  alt236_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."FAILGOAL"("'}'")
    unless $P10, rx231_fail
    goto rxsubrule238_pass
  rxsubrule238_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx231_fail
  rxsubrule238_pass:
    set_addr $I10, rxsubrule238_back
    rx231_cur."!mark_push"(0, rx231_pos, $I10, $P10)
    rx231_pos = $P10."pos"()
  alt236_end:
.annotate 'line', 159
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."ENDSTMT"()
    unless $P10, rx231_fail
.annotate 'line', 156
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "blockoid")
    if_null rx231_debug, debug_505
    rx231_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx231_pos)
  debug_505:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 4
    if_null rx231_debug, debug_506
    rx231_cur."!cursor_debug"("NEXT", "blockoid")
  debug_506:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_507
    rx231_cur."!cursor_debug"("FAIL", "blockoid")
  debug_507:
    .return (rx231_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1297619321.796") :method
.annotate 'line', 4
    $P233 = self."!PREFIX__!subrule"("finishpad", "")
    new $P234, "ResizablePMCArray"
    push $P234, $P233
    .return ($P234)
.end


.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx240_tgt
    .local int rx240_pos
    .local int rx240_off
    .local int rx240_eos
    .local int rx240_rep
    .local pmc rx240_cur
    .local pmc rx240_debug
    (rx240_cur, rx240_pos, rx240_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx240_cur
    .local pmc match
    .lex "$/", match
    length rx240_eos, rx240_tgt
    gt rx240_pos, rx240_eos, rx240_done
    set rx240_off, 0
    lt rx240_pos, 2, rx240_start
    sub rx240_off, rx240_pos, 1
    substr rx240_tgt, rx240_tgt, rx240_off
  rx240_start:
    eq $I10, 1, rx240_restart
    if_null rx240_debug, debug_508
    rx240_cur."!cursor_debug"("START", "newpad")
  debug_508:
    $I10 = self.'from'()
    ne $I10, -1, rxscan243_done
    goto rxscan243_scan
  rxscan243_loop:
    (rx240_pos) = rx240_cur."from"()
    inc rx240_pos
    rx240_cur."!cursor_from"(rx240_pos)
    ge rx240_pos, rx240_eos, rxscan243_done
  rxscan243_scan:
    set_addr $I10, rxscan243_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  rxscan243_done:
.annotate 'line', 162
  # rx pass
    rx240_cur."!cursor_pass"(rx240_pos, "newpad")
    if_null rx240_debug, debug_509
    rx240_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx240_pos)
  debug_509:
    .return (rx240_cur)
  rx240_restart:
.annotate 'line', 4
    if_null rx240_debug, debug_510
    rx240_cur."!cursor_debug"("NEXT", "newpad")
  debug_510:
  rx240_fail:
    (rx240_rep, rx240_pos, $I10, $P10) = rx240_cur."!mark_fail"(0)
    lt rx240_pos, -1, rx240_done
    eq rx240_pos, -1, rx240_fail
    jump $I10
  rx240_done:
    rx240_cur."!cursor_fail"()
    if_null rx240_debug, debug_511
    rx240_cur."!cursor_debug"("FAIL", "newpad")
  debug_511:
    .return (rx240_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1297619321.796") :method
.annotate 'line', 4
    new $P242, "ResizablePMCArray"
    push $P242, ""
    .return ($P242)
.end


.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx245_tgt
    .local int rx245_pos
    .local int rx245_off
    .local int rx245_eos
    .local int rx245_rep
    .local pmc rx245_cur
    .local pmc rx245_debug
    (rx245_cur, rx245_pos, rx245_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx245_cur
    .local pmc match
    .lex "$/", match
    length rx245_eos, rx245_tgt
    gt rx245_pos, rx245_eos, rx245_done
    set rx245_off, 0
    lt rx245_pos, 2, rx245_start
    sub rx245_off, rx245_pos, 1
    substr rx245_tgt, rx245_tgt, rx245_off
  rx245_start:
    eq $I10, 1, rx245_restart
    if_null rx245_debug, debug_512
    rx245_cur."!cursor_debug"("START", "outerctx")
  debug_512:
    $I10 = self.'from'()
    ne $I10, -1, rxscan248_done
    goto rxscan248_scan
  rxscan248_loop:
    (rx245_pos) = rx245_cur."from"()
    inc rx245_pos
    rx245_cur."!cursor_from"(rx245_pos)
    ge rx245_pos, rx245_eos, rxscan248_done
  rxscan248_scan:
    set_addr $I10, rxscan248_loop
    rx245_cur."!mark_push"(0, rx245_pos, $I10)
  rxscan248_done:
.annotate 'line', 163
  # rx pass
    rx245_cur."!cursor_pass"(rx245_pos, "outerctx")
    if_null rx245_debug, debug_513
    rx245_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx245_pos)
  debug_513:
    .return (rx245_cur)
  rx245_restart:
.annotate 'line', 4
    if_null rx245_debug, debug_514
    rx245_cur."!cursor_debug"("NEXT", "outerctx")
  debug_514:
  rx245_fail:
    (rx245_rep, rx245_pos, $I10, $P10) = rx245_cur."!mark_fail"(0)
    lt rx245_pos, -1, rx245_done
    eq rx245_pos, -1, rx245_fail
    jump $I10
  rx245_done:
    rx245_cur."!cursor_fail"()
    if_null rx245_debug, debug_515
    rx245_cur."!cursor_debug"("FAIL", "outerctx")
  debug_515:
    .return (rx245_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1297619321.796") :method
.annotate 'line', 4
    new $P247, "ResizablePMCArray"
    push $P247, ""
    .return ($P247)
.end


.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx250_tgt
    .local int rx250_pos
    .local int rx250_off
    .local int rx250_eos
    .local int rx250_rep
    .local pmc rx250_cur
    .local pmc rx250_debug
    (rx250_cur, rx250_pos, rx250_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx250_cur
    .local pmc match
    .lex "$/", match
    length rx250_eos, rx250_tgt
    gt rx250_pos, rx250_eos, rx250_done
    set rx250_off, 0
    lt rx250_pos, 2, rx250_start
    sub rx250_off, rx250_pos, 1
    substr rx250_tgt, rx250_tgt, rx250_off
  rx250_start:
    eq $I10, 1, rx250_restart
    if_null rx250_debug, debug_516
    rx250_cur."!cursor_debug"("START", "finishpad")
  debug_516:
    $I10 = self.'from'()
    ne $I10, -1, rxscan253_done
    goto rxscan253_scan
  rxscan253_loop:
    (rx250_pos) = rx250_cur."from"()
    inc rx250_pos
    rx250_cur."!cursor_from"(rx250_pos)
    ge rx250_pos, rx250_eos, rxscan253_done
  rxscan253_scan:
    set_addr $I10, rxscan253_loop
    rx250_cur."!mark_push"(0, rx250_pos, $I10)
  rxscan253_done:
.annotate 'line', 164
  # rx pass
    rx250_cur."!cursor_pass"(rx250_pos, "finishpad")
    if_null rx250_debug, debug_517
    rx250_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx250_pos)
  debug_517:
    .return (rx250_cur)
  rx250_restart:
.annotate 'line', 4
    if_null rx250_debug, debug_518
    rx250_cur."!cursor_debug"("NEXT", "finishpad")
  debug_518:
  rx250_fail:
    (rx250_rep, rx250_pos, $I10, $P10) = rx250_cur."!mark_fail"(0)
    lt rx250_pos, -1, rx250_done
    eq rx250_pos, -1, rx250_fail
    jump $I10
  rx250_done:
    rx250_cur."!cursor_fail"()
    if_null rx250_debug, debug_519
    rx250_cur."!cursor_debug"("FAIL", "finishpad")
  debug_519:
    .return (rx250_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1297619321.796") :method
.annotate 'line', 4
    new $P252, "ResizablePMCArray"
    push $P252, ""
    .return ($P252)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("54_1297619321.796")
    .param pmc param_255
.annotate 'line', 166
    .lex "self", param_255
    $P256 = param_255."!protoregex"("terminator")
    .return ($P256)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("55_1297619321.796")
    .param pmc param_258
.annotate 'line', 166
    .lex "self", param_258
    $P259 = param_258."!PREFIX__!protoregex"("terminator")
    .return ($P259)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("56_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx261_tgt
    .local int rx261_pos
    .local int rx261_off
    .local int rx261_eos
    .local int rx261_rep
    .local pmc rx261_cur
    .local pmc rx261_debug
    (rx261_cur, rx261_pos, rx261_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx261_cur
    .local pmc match
    .lex "$/", match
    length rx261_eos, rx261_tgt
    gt rx261_pos, rx261_eos, rx261_done
    set rx261_off, 0
    lt rx261_pos, 2, rx261_start
    sub rx261_off, rx261_pos, 1
    substr rx261_tgt, rx261_tgt, rx261_off
  rx261_start:
    eq $I10, 1, rx261_restart
    if_null rx261_debug, debug_520
    rx261_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_520:
    $I10 = self.'from'()
    ne $I10, -1, rxscan264_done
    goto rxscan264_scan
  rxscan264_loop:
    (rx261_pos) = rx261_cur."from"()
    inc rx261_pos
    rx261_cur."!cursor_from"(rx261_pos)
    ge rx261_pos, rx261_eos, rxscan264_done
  rxscan264_scan:
    set_addr $I10, rxscan264_loop
    rx261_cur."!mark_push"(0, rx261_pos, $I10)
  rxscan264_done:
.annotate 'line', 168
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx261_pos, rx261_off
    substr $S10, rx261_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx261_fail
  # rx pass
    rx261_cur."!cursor_pass"(rx261_pos, "terminator:sym<;>")
    if_null rx261_debug, debug_521
    rx261_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx261_pos)
  debug_521:
    .return (rx261_cur)
  rx261_restart:
.annotate 'line', 4
    if_null rx261_debug, debug_522
    rx261_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_522:
  rx261_fail:
    (rx261_rep, rx261_pos, $I10, $P10) = rx261_cur."!mark_fail"(0)
    lt rx261_pos, -1, rx261_done
    eq rx261_pos, -1, rx261_fail
    jump $I10
  rx261_done:
    rx261_cur."!cursor_fail"()
    if_null rx261_debug, debug_523
    rx261_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_523:
    .return (rx261_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("57_1297619321.796") :method
.annotate 'line', 4
    new $P263, "ResizablePMCArray"
    push $P263, ";"
    .return ($P263)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("58_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx266_tgt
    .local int rx266_pos
    .local int rx266_off
    .local int rx266_eos
    .local int rx266_rep
    .local pmc rx266_cur
    .local pmc rx266_debug
    (rx266_cur, rx266_pos, rx266_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx266_cur
    .local pmc match
    .lex "$/", match
    length rx266_eos, rx266_tgt
    gt rx266_pos, rx266_eos, rx266_done
    set rx266_off, 0
    lt rx266_pos, 2, rx266_start
    sub rx266_off, rx266_pos, 1
    substr rx266_tgt, rx266_tgt, rx266_off
  rx266_start:
    eq $I10, 1, rx266_restart
    if_null rx266_debug, debug_524
    rx266_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_524:
    $I10 = self.'from'()
    ne $I10, -1, rxscan269_done
    goto rxscan269_scan
  rxscan269_loop:
    (rx266_pos) = rx266_cur."from"()
    inc rx266_pos
    rx266_cur."!cursor_from"(rx266_pos)
    ge rx266_pos, rx266_eos, rxscan269_done
  rxscan269_scan:
    set_addr $I10, rxscan269_loop
    rx266_cur."!mark_push"(0, rx266_pos, $I10)
  rxscan269_done:
.annotate 'line', 169
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx266_pos, rx266_off
    substr $S10, rx266_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx266_fail
  # rx pass
    rx266_cur."!cursor_pass"(rx266_pos, "terminator:sym<}>")
    if_null rx266_debug, debug_525
    rx266_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx266_pos)
  debug_525:
    .return (rx266_cur)
  rx266_restart:
.annotate 'line', 4
    if_null rx266_debug, debug_526
    rx266_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_526:
  rx266_fail:
    (rx266_rep, rx266_pos, $I10, $P10) = rx266_cur."!mark_fail"(0)
    lt rx266_pos, -1, rx266_done
    eq rx266_pos, -1, rx266_fail
    jump $I10
  rx266_done:
    rx266_cur."!cursor_fail"()
    if_null rx266_debug, debug_527
    rx266_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_527:
    .return (rx266_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("59_1297619321.796") :method
.annotate 'line', 4
    new $P268, "ResizablePMCArray"
    push $P268, "}"
    .return ($P268)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("60_1297619321.796")
    .param pmc param_271
.annotate 'line', 173
    .lex "self", param_271
    $P272 = param_271."!protoregex"("statement_control")
    .return ($P272)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("61_1297619321.796")
    .param pmc param_274
.annotate 'line', 173
    .lex "self", param_274
    $P275 = param_274."!PREFIX__!protoregex"("statement_control")
    .return ($P275)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("62_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx277_tgt
    .local int rx277_pos
    .local int rx277_off
    .local int rx277_eos
    .local int rx277_rep
    .local pmc rx277_cur
    .local pmc rx277_debug
    (rx277_cur, rx277_pos, rx277_tgt, $I10) = self."!cursor_start"()
    rx277_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx277_cur
    .local pmc match
    .lex "$/", match
    length rx277_eos, rx277_tgt
    gt rx277_pos, rx277_eos, rx277_done
    set rx277_off, 0
    lt rx277_pos, 2, rx277_start
    sub rx277_off, rx277_pos, 1
    substr rx277_tgt, rx277_tgt, rx277_off
  rx277_start:
    eq $I10, 1, rx277_restart
    if_null rx277_debug, debug_528
    rx277_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_528:
    $I10 = self.'from'()
    ne $I10, -1, rxscan280_done
    goto rxscan280_scan
  rxscan280_loop:
    (rx277_pos) = rx277_cur."from"()
    inc rx277_pos
    rx277_cur."!cursor_from"(rx277_pos)
    ge rx277_pos, rx277_eos, rxscan280_done
  rxscan280_scan:
    set_addr $I10, rxscan280_loop
    rx277_cur."!mark_push"(0, rx277_pos, $I10)
  rxscan280_done:
.annotate 'line', 176
  # rx subcapture "sym"
    set_addr $I10, rxcap_281_fail
    rx277_cur."!mark_push"(0, rx277_pos, $I10)
  # rx literal  "if"
    add $I11, rx277_pos, 2
    gt $I11, rx277_eos, rx277_fail
    sub $I11, rx277_pos, rx277_off
    substr $S10, rx277_tgt, $I11, 2
    ne $S10, "if", rx277_fail
    add rx277_pos, 2
    set_addr $I10, rxcap_281_fail
    ($I12, $I11) = rx277_cur."!mark_peek"($I10)
    rx277_cur."!cursor_pos"($I11)
    ($P10) = rx277_cur."!cursor_start"()
    $P10."!cursor_pass"(rx277_pos, "")
    rx277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_281_done
  rxcap_281_fail:
    goto rx277_fail
  rxcap_281_done:
  # rx charclass s
    ge rx277_pos, rx277_eos, rx277_fail
    sub $I10, rx277_pos, rx277_off
    is_cclass $I11, 32, rx277_tgt, $I10
    unless $I11, rx277_fail
    inc rx277_pos
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
.annotate 'line', 177
  # rx subrule "xblock" subtype=capture negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."xblock"()
    unless $P10, rx277_fail
    rx277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx277_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
.annotate 'line', 178
  # rx rxquantr284 ** 0..*
    set_addr $I10, rxquantr284_done
    rx277_cur."!mark_push"(0, rx277_pos, $I10)
  rxquantr284_loop:
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx277_pos, 5
    gt $I11, rx277_eos, rx277_fail
    sub $I11, rx277_pos, rx277_off
    substr $S10, rx277_tgt, $I11, 5
    ne $S10, "elsif", rx277_fail
    add rx277_pos, 5
  # rx charclass s
    ge rx277_pos, rx277_eos, rx277_fail
    sub $I10, rx277_pos, rx277_off
    is_cclass $I11, 32, rx277_tgt, $I10
    unless $I11, rx277_fail
    inc rx277_pos
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."xblock"()
    unless $P10, rx277_fail
    rx277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx277_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
    set_addr $I10, rxquantr284_done
    (rx277_rep) = rx277_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr284_done
    rx277_cur."!mark_push"(rx277_rep, rx277_pos, $I10)
    goto rxquantr284_loop
  rxquantr284_done:
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
.annotate 'line', 179
  # rx rxquantr289 ** 0..1
    set_addr $I10, rxquantr289_done
    rx277_cur."!mark_push"(0, rx277_pos, $I10)
  rxquantr289_loop:
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx277_pos, 4
    gt $I11, rx277_eos, rx277_fail
    sub $I11, rx277_pos, rx277_off
    substr $S10, rx277_tgt, $I11, 4
    ne $S10, "else", rx277_fail
    add rx277_pos, 4
  # rx charclass s
    ge rx277_pos, rx277_eos, rx277_fail
    sub $I10, rx277_pos, rx277_off
    is_cclass $I11, 32, rx277_tgt, $I10
    unless $I11, rx277_fail
    inc rx277_pos
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."pblock"()
    unless $P10, rx277_fail
    rx277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx277_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
    set_addr $I10, rxquantr289_done
    (rx277_rep) = rx277_cur."!mark_commit"($I10)
  rxquantr289_done:
  # rx subrule "ws" subtype=method negate=
    rx277_cur."!cursor_pos"(rx277_pos)
    $P10 = rx277_cur."ws"()
    unless $P10, rx277_fail
    rx277_pos = $P10."pos"()
.annotate 'line', 175
  # rx pass
    rx277_cur."!cursor_pass"(rx277_pos, "statement_control:sym<if>")
    if_null rx277_debug, debug_529
    rx277_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx277_pos)
  debug_529:
    .return (rx277_cur)
  rx277_restart:
.annotate 'line', 4
    if_null rx277_debug, debug_530
    rx277_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_530:
  rx277_fail:
    (rx277_rep, rx277_pos, $I10, $P10) = rx277_cur."!mark_fail"(0)
    lt rx277_pos, -1, rx277_done
    eq rx277_pos, -1, rx277_fail
    jump $I10
  rx277_done:
    rx277_cur."!cursor_fail"()
    if_null rx277_debug, debug_531
    rx277_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_531:
    .return (rx277_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("63_1297619321.796") :method
.annotate 'line', 4
    new $P279, "ResizablePMCArray"
    push $P279, "if"
    .return ($P279)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("64_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P305 = "66_1297619321.796" 
    capture_lex $P305
    .local string rx295_tgt
    .local int rx295_pos
    .local int rx295_off
    .local int rx295_eos
    .local int rx295_rep
    .local pmc rx295_cur
    .local pmc rx295_debug
    (rx295_cur, rx295_pos, rx295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx295_cur
    .local pmc match
    .lex "$/", match
    length rx295_eos, rx295_tgt
    gt rx295_pos, rx295_eos, rx295_done
    set rx295_off, 0
    lt rx295_pos, 2, rx295_start
    sub rx295_off, rx295_pos, 1
    substr rx295_tgt, rx295_tgt, rx295_off
  rx295_start:
    eq $I10, 1, rx295_restart
    if_null rx295_debug, debug_532
    rx295_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_532:
    $I10 = self.'from'()
    ne $I10, -1, rxscan298_done
    goto rxscan298_scan
  rxscan298_loop:
    (rx295_pos) = rx295_cur."from"()
    inc rx295_pos
    rx295_cur."!cursor_from"(rx295_pos)
    ge rx295_pos, rx295_eos, rxscan298_done
  rxscan298_scan:
    set_addr $I10, rxscan298_loop
    rx295_cur."!mark_push"(0, rx295_pos, $I10)
  rxscan298_done:
.annotate 'line', 183
  # rx subcapture "sym"
    set_addr $I10, rxcap_299_fail
    rx295_cur."!mark_push"(0, rx295_pos, $I10)
  # rx literal  "unless"
    add $I11, rx295_pos, 6
    gt $I11, rx295_eos, rx295_fail
    sub $I11, rx295_pos, rx295_off
    substr $S10, rx295_tgt, $I11, 6
    ne $S10, "unless", rx295_fail
    add rx295_pos, 6
    set_addr $I10, rxcap_299_fail
    ($I12, $I11) = rx295_cur."!mark_peek"($I10)
    rx295_cur."!cursor_pos"($I11)
    ($P10) = rx295_cur."!cursor_start"()
    $P10."!cursor_pass"(rx295_pos, "")
    rx295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_299_done
  rxcap_299_fail:
    goto rx295_fail
  rxcap_299_done:
  # rx charclass s
    ge rx295_pos, rx295_eos, rx295_fail
    sub $I10, rx295_pos, rx295_off
    is_cclass $I11, 32, rx295_tgt, $I10
    unless $I11, rx295_fail
    inc rx295_pos
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
.annotate 'line', 184
  # rx subrule "xblock" subtype=capture negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."xblock"()
    unless $P10, rx295_fail
    rx295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx295_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
  alt302_0:
.annotate 'line', 185
    set_addr $I10, alt302_1
    rx295_cur."!mark_push"(0, rx295_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx295_cur."!cursor_pos"(rx295_pos)
    .const 'Sub' $P305 = "66_1297619321.796" 
    capture_lex $P305
    $P10 = rx295_cur."before"($P305)
    if $P10, rx295_fail
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
    goto alt302_end
  alt302_1:
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
  alt302_end:
  # rx subrule "ws" subtype=method negate=
    rx295_cur."!cursor_pos"(rx295_pos)
    $P10 = rx295_cur."ws"()
    unless $P10, rx295_fail
    rx295_pos = $P10."pos"()
.annotate 'line', 182
  # rx pass
    rx295_cur."!cursor_pass"(rx295_pos, "statement_control:sym<unless>")
    if_null rx295_debug, debug_537
    rx295_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx295_pos)
  debug_537:
    .return (rx295_cur)
  rx295_restart:
.annotate 'line', 4
    if_null rx295_debug, debug_538
    rx295_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_538:
  rx295_fail:
    (rx295_rep, rx295_pos, $I10, $P10) = rx295_cur."!mark_fail"(0)
    lt rx295_pos, -1, rx295_done
    eq rx295_pos, -1, rx295_fail
    jump $I10
  rx295_done:
    rx295_cur."!cursor_fail"()
    if_null rx295_debug, debug_539
    rx295_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_539:
    .return (rx295_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("65_1297619321.796") :method
.annotate 'line', 4
    new $P297, "ResizablePMCArray"
    push $P297, "unless"
    .return ($P297)
.end


.namespace ["NQP";"Grammar"]
.sub "_block304"  :anon :subid("66_1297619321.796") :method :outer("64_1297619321.796")
.annotate 'line', 185
    .local string rx306_tgt
    .local int rx306_pos
    .local int rx306_off
    .local int rx306_eos
    .local int rx306_rep
    .local pmc rx306_cur
    .local pmc rx306_debug
    (rx306_cur, rx306_pos, rx306_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx306_cur
    .local pmc match
    .lex "$/", match
    length rx306_eos, rx306_tgt
    gt rx306_pos, rx306_eos, rx306_done
    set rx306_off, 0
    lt rx306_pos, 2, rx306_start
    sub rx306_off, rx306_pos, 1
    substr rx306_tgt, rx306_tgt, rx306_off
  rx306_start:
    eq $I10, 1, rx306_restart
    if_null rx306_debug, debug_533
    rx306_cur."!cursor_debug"("START", "")
  debug_533:
    $I10 = self.'from'()
    ne $I10, -1, rxscan307_done
    goto rxscan307_scan
  rxscan307_loop:
    (rx306_pos) = rx306_cur."from"()
    inc rx306_pos
    rx306_cur."!cursor_from"(rx306_pos)
    ge rx306_pos, rx306_eos, rxscan307_done
  rxscan307_scan:
    set_addr $I10, rxscan307_loop
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
  rxscan307_done:
  # rx literal  "else"
    add $I11, rx306_pos, 4
    gt $I11, rx306_eos, rx306_fail
    sub $I11, rx306_pos, rx306_off
    substr $S10, rx306_tgt, $I11, 4
    ne $S10, "else", rx306_fail
    add rx306_pos, 4
  # rx pass
    rx306_cur."!cursor_pass"(rx306_pos, "")
    if_null rx306_debug, debug_534
    rx306_cur."!cursor_debug"("PASS", "", " at pos=", rx306_pos)
  debug_534:
    .return (rx306_cur)
  rx306_restart:
    if_null rx306_debug, debug_535
    rx306_cur."!cursor_debug"("NEXT", "")
  debug_535:
  rx306_fail:
    (rx306_rep, rx306_pos, $I10, $P10) = rx306_cur."!mark_fail"(0)
    lt rx306_pos, -1, rx306_done
    eq rx306_pos, -1, rx306_fail
    jump $I10
  rx306_done:
    rx306_cur."!cursor_fail"()
    if_null rx306_debug, debug_536
    rx306_cur."!cursor_debug"("FAIL", "")
  debug_536:
    .return (rx306_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("67_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx313_tgt
    .local int rx313_pos
    .local int rx313_off
    .local int rx313_eos
    .local int rx313_rep
    .local pmc rx313_cur
    .local pmc rx313_debug
    (rx313_cur, rx313_pos, rx313_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx313_cur
    .local pmc match
    .lex "$/", match
    length rx313_eos, rx313_tgt
    gt rx313_pos, rx313_eos, rx313_done
    set rx313_off, 0
    lt rx313_pos, 2, rx313_start
    sub rx313_off, rx313_pos, 1
    substr rx313_tgt, rx313_tgt, rx313_off
  rx313_start:
    eq $I10, 1, rx313_restart
    if_null rx313_debug, debug_540
    rx313_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_540:
    $I10 = self.'from'()
    ne $I10, -1, rxscan316_done
    goto rxscan316_scan
  rxscan316_loop:
    (rx313_pos) = rx313_cur."from"()
    inc rx313_pos
    rx313_cur."!cursor_from"(rx313_pos)
    ge rx313_pos, rx313_eos, rxscan316_done
  rxscan316_scan:
    set_addr $I10, rxscan316_loop
    rx313_cur."!mark_push"(0, rx313_pos, $I10)
  rxscan316_done:
.annotate 'line', 189
  # rx subcapture "sym"
    set_addr $I10, rxcap_318_fail
    rx313_cur."!mark_push"(0, rx313_pos, $I10)
  alt317_0:
    set_addr $I10, alt317_1
    rx313_cur."!mark_push"(0, rx313_pos, $I10)
  # rx literal  "while"
    add $I11, rx313_pos, 5
    gt $I11, rx313_eos, rx313_fail
    sub $I11, rx313_pos, rx313_off
    substr $S10, rx313_tgt, $I11, 5
    ne $S10, "while", rx313_fail
    add rx313_pos, 5
    goto alt317_end
  alt317_1:
  # rx literal  "until"
    add $I11, rx313_pos, 5
    gt $I11, rx313_eos, rx313_fail
    sub $I11, rx313_pos, rx313_off
    substr $S10, rx313_tgt, $I11, 5
    ne $S10, "until", rx313_fail
    add rx313_pos, 5
  alt317_end:
    set_addr $I10, rxcap_318_fail
    ($I12, $I11) = rx313_cur."!mark_peek"($I10)
    rx313_cur."!cursor_pos"($I11)
    ($P10) = rx313_cur."!cursor_start"()
    $P10."!cursor_pass"(rx313_pos, "")
    rx313_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_318_done
  rxcap_318_fail:
    goto rx313_fail
  rxcap_318_done:
  # rx charclass s
    ge rx313_pos, rx313_eos, rx313_fail
    sub $I10, rx313_pos, rx313_off
    is_cclass $I11, 32, rx313_tgt, $I10
    unless $I11, rx313_fail
    inc rx313_pos
  # rx subrule "ws" subtype=method negate=
    rx313_cur."!cursor_pos"(rx313_pos)
    $P10 = rx313_cur."ws"()
    unless $P10, rx313_fail
    rx313_pos = $P10."pos"()
.annotate 'line', 190
  # rx subrule "xblock" subtype=capture negate=
    rx313_cur."!cursor_pos"(rx313_pos)
    $P10 = rx313_cur."xblock"()
    unless $P10, rx313_fail
    rx313_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx313_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx313_cur."!cursor_pos"(rx313_pos)
    $P10 = rx313_cur."ws"()
    unless $P10, rx313_fail
    rx313_pos = $P10."pos"()
.annotate 'line', 188
  # rx pass
    rx313_cur."!cursor_pass"(rx313_pos, "statement_control:sym<while>")
    if_null rx313_debug, debug_541
    rx313_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx313_pos)
  debug_541:
    .return (rx313_cur)
  rx313_restart:
.annotate 'line', 4
    if_null rx313_debug, debug_542
    rx313_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_542:
  rx313_fail:
    (rx313_rep, rx313_pos, $I10, $P10) = rx313_cur."!mark_fail"(0)
    lt rx313_pos, -1, rx313_done
    eq rx313_pos, -1, rx313_fail
    jump $I10
  rx313_done:
    rx313_cur."!cursor_fail"()
    if_null rx313_debug, debug_543
    rx313_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_543:
    .return (rx313_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("68_1297619321.796") :method
.annotate 'line', 4
    new $P315, "ResizablePMCArray"
    push $P315, "until"
    push $P315, "while"
    .return ($P315)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("69_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx322_tgt
    .local int rx322_pos
    .local int rx322_off
    .local int rx322_eos
    .local int rx322_rep
    .local pmc rx322_cur
    .local pmc rx322_debug
    (rx322_cur, rx322_pos, rx322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx322_cur
    .local pmc match
    .lex "$/", match
    length rx322_eos, rx322_tgt
    gt rx322_pos, rx322_eos, rx322_done
    set rx322_off, 0
    lt rx322_pos, 2, rx322_start
    sub rx322_off, rx322_pos, 1
    substr rx322_tgt, rx322_tgt, rx322_off
  rx322_start:
    eq $I10, 1, rx322_restart
    if_null rx322_debug, debug_544
    rx322_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_544:
    $I10 = self.'from'()
    ne $I10, -1, rxscan325_done
    goto rxscan325_scan
  rxscan325_loop:
    (rx322_pos) = rx322_cur."from"()
    inc rx322_pos
    rx322_cur."!cursor_from"(rx322_pos)
    ge rx322_pos, rx322_eos, rxscan325_done
  rxscan325_scan:
    set_addr $I10, rxscan325_loop
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  rxscan325_done:
.annotate 'line', 194
  # rx subcapture "sym"
    set_addr $I10, rxcap_326_fail
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx322_pos, 6
    gt $I11, rx322_eos, rx322_fail
    sub $I11, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I11, 6
    ne $S10, "repeat", rx322_fail
    add rx322_pos, 6
    set_addr $I10, rxcap_326_fail
    ($I12, $I11) = rx322_cur."!mark_peek"($I10)
    rx322_cur."!cursor_pos"($I11)
    ($P10) = rx322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx322_pos, "")
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_326_done
  rxcap_326_fail:
    goto rx322_fail
  rxcap_326_done:
  # rx charclass s
    ge rx322_pos, rx322_eos, rx322_fail
    sub $I10, rx322_pos, rx322_off
    is_cclass $I11, 32, rx322_tgt, $I10
    unless $I11, rx322_fail
    inc rx322_pos
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  alt328_0:
.annotate 'line', 195
    set_addr $I10, alt328_1
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
.annotate 'line', 196
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_331_fail
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  alt330_0:
    set_addr $I10, alt330_1
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  # rx literal  "while"
    add $I11, rx322_pos, 5
    gt $I11, rx322_eos, rx322_fail
    sub $I11, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I11, 5
    ne $S10, "while", rx322_fail
    add rx322_pos, 5
    goto alt330_end
  alt330_1:
  # rx literal  "until"
    add $I11, rx322_pos, 5
    gt $I11, rx322_eos, rx322_fail
    sub $I11, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I11, 5
    ne $S10, "until", rx322_fail
    add rx322_pos, 5
  alt330_end:
    set_addr $I10, rxcap_331_fail
    ($I12, $I11) = rx322_cur."!mark_peek"($I10)
    rx322_cur."!cursor_pos"($I11)
    ($P10) = rx322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx322_pos, "")
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_331_done
  rxcap_331_fail:
    goto rx322_fail
  rxcap_331_done:
  # rx charclass s
    ge rx322_pos, rx322_eos, rx322_fail
    sub $I10, rx322_pos, rx322_off
    is_cclass $I11, 32, rx322_tgt, $I10
    unless $I11, rx322_fail
    inc rx322_pos
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."xblock"()
    unless $P10, rx322_fail
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx322_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
    goto alt328_end
  alt328_1:
.annotate 'line', 197
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."pblock"()
    unless $P10, rx322_fail
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx322_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_337_fail
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  alt336_0:
    set_addr $I10, alt336_1
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  # rx literal  "while"
    add $I11, rx322_pos, 5
    gt $I11, rx322_eos, rx322_fail
    sub $I11, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I11, 5
    ne $S10, "while", rx322_fail
    add rx322_pos, 5
    goto alt336_end
  alt336_1:
  # rx literal  "until"
    add $I11, rx322_pos, 5
    gt $I11, rx322_eos, rx322_fail
    sub $I11, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I11, 5
    ne $S10, "until", rx322_fail
    add rx322_pos, 5
  alt336_end:
    set_addr $I10, rxcap_337_fail
    ($I12, $I11) = rx322_cur."!mark_peek"($I10)
    rx322_cur."!cursor_pos"($I11)
    ($P10) = rx322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx322_pos, "")
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_337_done
  rxcap_337_fail:
    goto rx322_fail
  rxcap_337_done:
  # rx charclass s
    ge rx322_pos, rx322_eos, rx322_fail
    sub $I10, rx322_pos, rx322_off
    is_cclass $I11, 32, rx322_tgt, $I10
    unless $I11, rx322_fail
    inc rx322_pos
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."EXPR"()
    unless $P10, rx322_fail
    rx322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx322_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
  alt328_end:
.annotate 'line', 198
  # rx subrule "ws" subtype=method negate=
    rx322_cur."!cursor_pos"(rx322_pos)
    $P10 = rx322_cur."ws"()
    unless $P10, rx322_fail
    rx322_pos = $P10."pos"()
.annotate 'line', 193
  # rx pass
    rx322_cur."!cursor_pass"(rx322_pos, "statement_control:sym<repeat>")
    if_null rx322_debug, debug_545
    rx322_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx322_pos)
  debug_545:
    .return (rx322_cur)
  rx322_restart:
.annotate 'line', 4
    if_null rx322_debug, debug_546
    rx322_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_546:
  rx322_fail:
    (rx322_rep, rx322_pos, $I10, $P10) = rx322_cur."!mark_fail"(0)
    lt rx322_pos, -1, rx322_done
    eq rx322_pos, -1, rx322_fail
    jump $I10
  rx322_done:
    rx322_cur."!cursor_fail"()
    if_null rx322_debug, debug_547
    rx322_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_547:
    .return (rx322_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("70_1297619321.796") :method
.annotate 'line', 4
    new $P324, "ResizablePMCArray"
    push $P324, "repeat"
    .return ($P324)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("71_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx342_tgt
    .local int rx342_pos
    .local int rx342_off
    .local int rx342_eos
    .local int rx342_rep
    .local pmc rx342_cur
    .local pmc rx342_debug
    (rx342_cur, rx342_pos, rx342_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx342_cur
    .local pmc match
    .lex "$/", match
    length rx342_eos, rx342_tgt
    gt rx342_pos, rx342_eos, rx342_done
    set rx342_off, 0
    lt rx342_pos, 2, rx342_start
    sub rx342_off, rx342_pos, 1
    substr rx342_tgt, rx342_tgt, rx342_off
  rx342_start:
    eq $I10, 1, rx342_restart
    if_null rx342_debug, debug_548
    rx342_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_548:
    $I10 = self.'from'()
    ne $I10, -1, rxscan345_done
    goto rxscan345_scan
  rxscan345_loop:
    (rx342_pos) = rx342_cur."from"()
    inc rx342_pos
    rx342_cur."!cursor_from"(rx342_pos)
    ge rx342_pos, rx342_eos, rxscan345_done
  rxscan345_scan:
    set_addr $I10, rxscan345_loop
    rx342_cur."!mark_push"(0, rx342_pos, $I10)
  rxscan345_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_346_fail
    rx342_cur."!mark_push"(0, rx342_pos, $I10)
  # rx literal  "for"
    add $I11, rx342_pos, 3
    gt $I11, rx342_eos, rx342_fail
    sub $I11, rx342_pos, rx342_off
    substr $S10, rx342_tgt, $I11, 3
    ne $S10, "for", rx342_fail
    add rx342_pos, 3
    set_addr $I10, rxcap_346_fail
    ($I12, $I11) = rx342_cur."!mark_peek"($I10)
    rx342_cur."!cursor_pos"($I11)
    ($P10) = rx342_cur."!cursor_start"()
    $P10."!cursor_pass"(rx342_pos, "")
    rx342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_346_done
  rxcap_346_fail:
    goto rx342_fail
  rxcap_346_done:
  # rx charclass s
    ge rx342_pos, rx342_eos, rx342_fail
    sub $I10, rx342_pos, rx342_off
    is_cclass $I11, 32, rx342_tgt, $I10
    unless $I11, rx342_fail
    inc rx342_pos
  # rx subrule "ws" subtype=method negate=
    rx342_cur."!cursor_pos"(rx342_pos)
    $P10 = rx342_cur."ws"()
    unless $P10, rx342_fail
    rx342_pos = $P10."pos"()
.annotate 'line', 203
  # rx subrule "xblock" subtype=capture negate=
    rx342_cur."!cursor_pos"(rx342_pos)
    $P10 = rx342_cur."xblock"()
    unless $P10, rx342_fail
    rx342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx342_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx342_cur."!cursor_pos"(rx342_pos)
    $P10 = rx342_cur."ws"()
    unless $P10, rx342_fail
    rx342_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx342_cur."!cursor_pass"(rx342_pos, "statement_control:sym<for>")
    if_null rx342_debug, debug_549
    rx342_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx342_pos)
  debug_549:
    .return (rx342_cur)
  rx342_restart:
.annotate 'line', 4
    if_null rx342_debug, debug_550
    rx342_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_550:
  rx342_fail:
    (rx342_rep, rx342_pos, $I10, $P10) = rx342_cur."!mark_fail"(0)
    lt rx342_pos, -1, rx342_done
    eq rx342_pos, -1, rx342_fail
    jump $I10
  rx342_done:
    rx342_cur."!cursor_fail"()
    if_null rx342_debug, debug_551
    rx342_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_551:
    .return (rx342_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("72_1297619321.796") :method
.annotate 'line', 4
    new $P344, "ResizablePMCArray"
    push $P344, "for"
    .return ($P344)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("73_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx350_tgt
    .local int rx350_pos
    .local int rx350_off
    .local int rx350_eos
    .local int rx350_rep
    .local pmc rx350_cur
    .local pmc rx350_debug
    (rx350_cur, rx350_pos, rx350_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx350_cur
    .local pmc match
    .lex "$/", match
    length rx350_eos, rx350_tgt
    gt rx350_pos, rx350_eos, rx350_done
    set rx350_off, 0
    lt rx350_pos, 2, rx350_start
    sub rx350_off, rx350_pos, 1
    substr rx350_tgt, rx350_tgt, rx350_off
  rx350_start:
    eq $I10, 1, rx350_restart
    if_null rx350_debug, debug_552
    rx350_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_552:
    $I10 = self.'from'()
    ne $I10, -1, rxscan353_done
    goto rxscan353_scan
  rxscan353_loop:
    (rx350_pos) = rx350_cur."from"()
    inc rx350_pos
    rx350_cur."!cursor_from"(rx350_pos)
    ge rx350_pos, rx350_eos, rxscan353_done
  rxscan353_scan:
    set_addr $I10, rxscan353_loop
    rx350_cur."!mark_push"(0, rx350_pos, $I10)
  rxscan353_done:
.annotate 'line', 207
  # rx subcapture "sym"
    set_addr $I10, rxcap_354_fail
    rx350_cur."!mark_push"(0, rx350_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx350_pos, 5
    gt $I11, rx350_eos, rx350_fail
    sub $I11, rx350_pos, rx350_off
    substr $S10, rx350_tgt, $I11, 5
    ne $S10, "CATCH", rx350_fail
    add rx350_pos, 5
    set_addr $I10, rxcap_354_fail
    ($I12, $I11) = rx350_cur."!mark_peek"($I10)
    rx350_cur."!cursor_pos"($I11)
    ($P10) = rx350_cur."!cursor_start"()
    $P10."!cursor_pass"(rx350_pos, "")
    rx350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_354_done
  rxcap_354_fail:
    goto rx350_fail
  rxcap_354_done:
  # rx charclass s
    ge rx350_pos, rx350_eos, rx350_fail
    sub $I10, rx350_pos, rx350_off
    is_cclass $I11, 32, rx350_tgt, $I10
    unless $I11, rx350_fail
    inc rx350_pos
  # rx subrule "ws" subtype=method negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."ws"()
    unless $P10, rx350_fail
    rx350_pos = $P10."pos"()
.annotate 'line', 208
  # rx subrule "block" subtype=capture negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."block"()
    unless $P10, rx350_fail
    rx350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx350_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."ws"()
    unless $P10, rx350_fail
    rx350_pos = $P10."pos"()
.annotate 'line', 206
  # rx pass
    rx350_cur."!cursor_pass"(rx350_pos, "statement_control:sym<CATCH>")
    if_null rx350_debug, debug_553
    rx350_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx350_pos)
  debug_553:
    .return (rx350_cur)
  rx350_restart:
.annotate 'line', 4
    if_null rx350_debug, debug_554
    rx350_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_554:
  rx350_fail:
    (rx350_rep, rx350_pos, $I10, $P10) = rx350_cur."!mark_fail"(0)
    lt rx350_pos, -1, rx350_done
    eq rx350_pos, -1, rx350_fail
    jump $I10
  rx350_done:
    rx350_cur."!cursor_fail"()
    if_null rx350_debug, debug_555
    rx350_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_555:
    .return (rx350_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("74_1297619321.796") :method
.annotate 'line', 4
    new $P352, "ResizablePMCArray"
    push $P352, "CATCH"
    .return ($P352)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("75_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx358_tgt
    .local int rx358_pos
    .local int rx358_off
    .local int rx358_eos
    .local int rx358_rep
    .local pmc rx358_cur
    .local pmc rx358_debug
    (rx358_cur, rx358_pos, rx358_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx358_cur
    .local pmc match
    .lex "$/", match
    length rx358_eos, rx358_tgt
    gt rx358_pos, rx358_eos, rx358_done
    set rx358_off, 0
    lt rx358_pos, 2, rx358_start
    sub rx358_off, rx358_pos, 1
    substr rx358_tgt, rx358_tgt, rx358_off
  rx358_start:
    eq $I10, 1, rx358_restart
    if_null rx358_debug, debug_556
    rx358_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_556:
    $I10 = self.'from'()
    ne $I10, -1, rxscan361_done
    goto rxscan361_scan
  rxscan361_loop:
    (rx358_pos) = rx358_cur."from"()
    inc rx358_pos
    rx358_cur."!cursor_from"(rx358_pos)
    ge rx358_pos, rx358_eos, rxscan361_done
  rxscan361_scan:
    set_addr $I10, rxscan361_loop
    rx358_cur."!mark_push"(0, rx358_pos, $I10)
  rxscan361_done:
.annotate 'line', 212
  # rx subcapture "sym"
    set_addr $I10, rxcap_362_fail
    rx358_cur."!mark_push"(0, rx358_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx358_pos, 7
    gt $I11, rx358_eos, rx358_fail
    sub $I11, rx358_pos, rx358_off
    substr $S10, rx358_tgt, $I11, 7
    ne $S10, "CONTROL", rx358_fail
    add rx358_pos, 7
    set_addr $I10, rxcap_362_fail
    ($I12, $I11) = rx358_cur."!mark_peek"($I10)
    rx358_cur."!cursor_pos"($I11)
    ($P10) = rx358_cur."!cursor_start"()
    $P10."!cursor_pass"(rx358_pos, "")
    rx358_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_362_done
  rxcap_362_fail:
    goto rx358_fail
  rxcap_362_done:
  # rx charclass s
    ge rx358_pos, rx358_eos, rx358_fail
    sub $I10, rx358_pos, rx358_off
    is_cclass $I11, 32, rx358_tgt, $I10
    unless $I11, rx358_fail
    inc rx358_pos
  # rx subrule "ws" subtype=method negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."ws"()
    unless $P10, rx358_fail
    rx358_pos = $P10."pos"()
.annotate 'line', 213
  # rx subrule "block" subtype=capture negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."block"()
    unless $P10, rx358_fail
    rx358_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx358_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."ws"()
    unless $P10, rx358_fail
    rx358_pos = $P10."pos"()
.annotate 'line', 211
  # rx pass
    rx358_cur."!cursor_pass"(rx358_pos, "statement_control:sym<CONTROL>")
    if_null rx358_debug, debug_557
    rx358_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx358_pos)
  debug_557:
    .return (rx358_cur)
  rx358_restart:
.annotate 'line', 4
    if_null rx358_debug, debug_558
    rx358_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_558:
  rx358_fail:
    (rx358_rep, rx358_pos, $I10, $P10) = rx358_cur."!mark_fail"(0)
    lt rx358_pos, -1, rx358_done
    eq rx358_pos, -1, rx358_fail
    jump $I10
  rx358_done:
    rx358_cur."!cursor_fail"()
    if_null rx358_debug, debug_559
    rx358_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_559:
    .return (rx358_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("76_1297619321.796") :method
.annotate 'line', 4
    new $P360, "ResizablePMCArray"
    push $P360, "CONTROL"
    .return ($P360)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("77_1297619321.796")
    .param pmc param_366
.annotate 'line', 216
    .lex "self", param_366
    $P367 = param_366."!protoregex"("statement_prefix")
    .return ($P367)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("78_1297619321.796")
    .param pmc param_369
.annotate 'line', 216
    .lex "self", param_369
    $P370 = param_369."!PREFIX__!protoregex"("statement_prefix")
    .return ($P370)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("79_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx372_tgt
    .local int rx372_pos
    .local int rx372_off
    .local int rx372_eos
    .local int rx372_rep
    .local pmc rx372_cur
    .local pmc rx372_debug
    (rx372_cur, rx372_pos, rx372_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx372_cur
    .local pmc match
    .lex "$/", match
    length rx372_eos, rx372_tgt
    gt rx372_pos, rx372_eos, rx372_done
    set rx372_off, 0
    lt rx372_pos, 2, rx372_start
    sub rx372_off, rx372_pos, 1
    substr rx372_tgt, rx372_tgt, rx372_off
  rx372_start:
    eq $I10, 1, rx372_restart
    if_null rx372_debug, debug_560
    rx372_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_560:
    $I10 = self.'from'()
    ne $I10, -1, rxscan376_done
    goto rxscan376_scan
  rxscan376_loop:
    (rx372_pos) = rx372_cur."from"()
    inc rx372_pos
    rx372_cur."!cursor_from"(rx372_pos)
    ge rx372_pos, rx372_eos, rxscan376_done
  rxscan376_scan:
    set_addr $I10, rxscan376_loop
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  rxscan376_done:
.annotate 'line', 217
  # rx subcapture "sym"
    set_addr $I10, rxcap_377_fail
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx372_pos, 4
    gt $I11, rx372_eos, rx372_fail
    sub $I11, rx372_pos, rx372_off
    substr $S10, rx372_tgt, $I11, 4
    ne $S10, "INIT", rx372_fail
    add rx372_pos, 4
    set_addr $I10, rxcap_377_fail
    ($I12, $I11) = rx372_cur."!mark_peek"($I10)
    rx372_cur."!cursor_pos"($I11)
    ($P10) = rx372_cur."!cursor_start"()
    $P10."!cursor_pass"(rx372_pos, "")
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_377_done
  rxcap_377_fail:
    goto rx372_fail
  rxcap_377_done:
  # rx subrule "blorst" subtype=capture negate=
    rx372_cur."!cursor_pos"(rx372_pos)
    $P10 = rx372_cur."blorst"()
    unless $P10, rx372_fail
    rx372_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx372_pos = $P10."pos"()
  # rx pass
    rx372_cur."!cursor_pass"(rx372_pos, "statement_prefix:sym<INIT>")
    if_null rx372_debug, debug_561
    rx372_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx372_pos)
  debug_561:
    .return (rx372_cur)
  rx372_restart:
.annotate 'line', 4
    if_null rx372_debug, debug_562
    rx372_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_562:
  rx372_fail:
    (rx372_rep, rx372_pos, $I10, $P10) = rx372_cur."!mark_fail"(0)
    lt rx372_pos, -1, rx372_done
    eq rx372_pos, -1, rx372_fail
    jump $I10
  rx372_done:
    rx372_cur."!cursor_fail"()
    if_null rx372_debug, debug_563
    rx372_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_563:
    .return (rx372_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("80_1297619321.796") :method
.annotate 'line', 4
    $P374 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P375, "ResizablePMCArray"
    push $P375, $P374
    .return ($P375)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("81_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx379_tgt
    .local int rx379_pos
    .local int rx379_off
    .local int rx379_eos
    .local int rx379_rep
    .local pmc rx379_cur
    .local pmc rx379_debug
    (rx379_cur, rx379_pos, rx379_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx379_cur
    .local pmc match
    .lex "$/", match
    length rx379_eos, rx379_tgt
    gt rx379_pos, rx379_eos, rx379_done
    set rx379_off, 0
    lt rx379_pos, 2, rx379_start
    sub rx379_off, rx379_pos, 1
    substr rx379_tgt, rx379_tgt, rx379_off
  rx379_start:
    eq $I10, 1, rx379_restart
    if_null rx379_debug, debug_564
    rx379_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_564:
    $I10 = self.'from'()
    ne $I10, -1, rxscan383_done
    goto rxscan383_scan
  rxscan383_loop:
    (rx379_pos) = rx379_cur."from"()
    inc rx379_pos
    rx379_cur."!cursor_from"(rx379_pos)
    ge rx379_pos, rx379_eos, rxscan383_done
  rxscan383_scan:
    set_addr $I10, rxscan383_loop
    rx379_cur."!mark_push"(0, rx379_pos, $I10)
  rxscan383_done:
.annotate 'line', 220
  # rx subcapture "sym"
    set_addr $I10, rxcap_384_fail
    rx379_cur."!mark_push"(0, rx379_pos, $I10)
  # rx literal  "try"
    add $I11, rx379_pos, 3
    gt $I11, rx379_eos, rx379_fail
    sub $I11, rx379_pos, rx379_off
    substr $S10, rx379_tgt, $I11, 3
    ne $S10, "try", rx379_fail
    add rx379_pos, 3
    set_addr $I10, rxcap_384_fail
    ($I12, $I11) = rx379_cur."!mark_peek"($I10)
    rx379_cur."!cursor_pos"($I11)
    ($P10) = rx379_cur."!cursor_start"()
    $P10."!cursor_pass"(rx379_pos, "")
    rx379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_384_done
  rxcap_384_fail:
    goto rx379_fail
  rxcap_384_done:
.annotate 'line', 221
  # rx subrule "blorst" subtype=capture negate=
    rx379_cur."!cursor_pos"(rx379_pos)
    $P10 = rx379_cur."blorst"()
    unless $P10, rx379_fail
    rx379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx379_pos = $P10."pos"()
.annotate 'line', 219
  # rx pass
    rx379_cur."!cursor_pass"(rx379_pos, "statement_prefix:sym<try>")
    if_null rx379_debug, debug_565
    rx379_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx379_pos)
  debug_565:
    .return (rx379_cur)
  rx379_restart:
.annotate 'line', 4
    if_null rx379_debug, debug_566
    rx379_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_566:
  rx379_fail:
    (rx379_rep, rx379_pos, $I10, $P10) = rx379_cur."!mark_fail"(0)
    lt rx379_pos, -1, rx379_done
    eq rx379_pos, -1, rx379_fail
    jump $I10
  rx379_done:
    rx379_cur."!cursor_fail"()
    if_null rx379_debug, debug_567
    rx379_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_567:
    .return (rx379_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("82_1297619321.796") :method
.annotate 'line', 4
    $P381 = self."!PREFIX__!subrule"("blorst", "try")
    new $P382, "ResizablePMCArray"
    push $P382, $P381
    .return ($P382)
.end


.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("83_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx386_tgt
    .local int rx386_pos
    .local int rx386_off
    .local int rx386_eos
    .local int rx386_rep
    .local pmc rx386_cur
    .local pmc rx386_debug
    (rx386_cur, rx386_pos, rx386_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx386_cur
    .local pmc match
    .lex "$/", match
    length rx386_eos, rx386_tgt
    gt rx386_pos, rx386_eos, rx386_done
    set rx386_off, 0
    lt rx386_pos, 2, rx386_start
    sub rx386_off, rx386_pos, 1
    substr rx386_tgt, rx386_tgt, rx386_off
  rx386_start:
    eq $I10, 1, rx386_restart
    if_null rx386_debug, debug_568
    rx386_cur."!cursor_debug"("START", "blorst")
  debug_568:
    $I10 = self.'from'()
    ne $I10, -1, rxscan389_done
    goto rxscan389_scan
  rxscan389_loop:
    (rx386_pos) = rx386_cur."from"()
    inc rx386_pos
    rx386_cur."!cursor_from"(rx386_pos)
    ge rx386_pos, rx386_eos, rxscan389_done
  rxscan389_scan:
    set_addr $I10, rxscan389_loop
    rx386_cur."!mark_push"(0, rx386_pos, $I10)
  rxscan389_done:
.annotate 'line', 225
  # rx charclass s
    ge rx386_pos, rx386_eos, rx386_fail
    sub $I10, rx386_pos, rx386_off
    is_cclass $I11, 32, rx386_tgt, $I10
    unless $I11, rx386_fail
    inc rx386_pos
  # rx subrule "ws" subtype=method negate=
    rx386_cur."!cursor_pos"(rx386_pos)
    $P10 = rx386_cur."ws"()
    unless $P10, rx386_fail
    rx386_pos = $P10."pos"()
  alt390_0:
    set_addr $I10, alt390_1
    rx386_cur."!mark_push"(0, rx386_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx386_pos, rx386_off
    substr $S10, rx386_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx386_fail
  # rx subrule "block" subtype=capture negate=
    rx386_cur."!cursor_pos"(rx386_pos)
    $P10 = rx386_cur."block"()
    unless $P10, rx386_fail
    rx386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx386_pos = $P10."pos"()
    goto alt390_end
  alt390_1:
  # rx subrule "statement" subtype=capture negate=
    rx386_cur."!cursor_pos"(rx386_pos)
    $P10 = rx386_cur."statement"()
    unless $P10, rx386_fail
    rx386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx386_pos = $P10."pos"()
  alt390_end:
.annotate 'line', 224
  # rx pass
    rx386_cur."!cursor_pass"(rx386_pos, "blorst")
    if_null rx386_debug, debug_569
    rx386_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx386_pos)
  debug_569:
    .return (rx386_cur)
  rx386_restart:
.annotate 'line', 4
    if_null rx386_debug, debug_570
    rx386_cur."!cursor_debug"("NEXT", "blorst")
  debug_570:
  rx386_fail:
    (rx386_rep, rx386_pos, $I10, $P10) = rx386_cur."!mark_fail"(0)
    lt rx386_pos, -1, rx386_done
    eq rx386_pos, -1, rx386_fail
    jump $I10
  rx386_done:
    rx386_cur."!cursor_fail"()
    if_null rx386_debug, debug_571
    rx386_cur."!cursor_debug"("FAIL", "blorst")
  debug_571:
    .return (rx386_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("84_1297619321.796") :method
.annotate 'line', 4
    new $P388, "ResizablePMCArray"
    push $P388, ""
    .return ($P388)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("85_1297619321.796")
    .param pmc param_392
.annotate 'line', 230
    .lex "self", param_392
    $P393 = param_392."!protoregex"("statement_mod_cond")
    .return ($P393)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("86_1297619321.796")
    .param pmc param_395
.annotate 'line', 230
    .lex "self", param_395
    $P396 = param_395."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P396)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("87_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx398_tgt
    .local int rx398_pos
    .local int rx398_off
    .local int rx398_eos
    .local int rx398_rep
    .local pmc rx398_cur
    .local pmc rx398_debug
    (rx398_cur, rx398_pos, rx398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx398_cur
    .local pmc match
    .lex "$/", match
    length rx398_eos, rx398_tgt
    gt rx398_pos, rx398_eos, rx398_done
    set rx398_off, 0
    lt rx398_pos, 2, rx398_start
    sub rx398_off, rx398_pos, 1
    substr rx398_tgt, rx398_tgt, rx398_off
  rx398_start:
    eq $I10, 1, rx398_restart
    if_null rx398_debug, debug_572
    rx398_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_572:
    $I10 = self.'from'()
    ne $I10, -1, rxscan402_done
    goto rxscan402_scan
  rxscan402_loop:
    (rx398_pos) = rx398_cur."from"()
    inc rx398_pos
    rx398_cur."!cursor_from"(rx398_pos)
    ge rx398_pos, rx398_eos, rxscan402_done
  rxscan402_scan:
    set_addr $I10, rxscan402_loop
    rx398_cur."!mark_push"(0, rx398_pos, $I10)
  rxscan402_done:
.annotate 'line', 232
  # rx subcapture "sym"
    set_addr $I10, rxcap_403_fail
    rx398_cur."!mark_push"(0, rx398_pos, $I10)
  # rx literal  "if"
    add $I11, rx398_pos, 2
    gt $I11, rx398_eos, rx398_fail
    sub $I11, rx398_pos, rx398_off
    substr $S10, rx398_tgt, $I11, 2
    ne $S10, "if", rx398_fail
    add rx398_pos, 2
    set_addr $I10, rxcap_403_fail
    ($I12, $I11) = rx398_cur."!mark_peek"($I10)
    rx398_cur."!cursor_pos"($I11)
    ($P10) = rx398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx398_pos, "")
    rx398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_403_done
  rxcap_403_fail:
    goto rx398_fail
  rxcap_403_done:
  # rx subrule "ws" subtype=method negate=
    rx398_cur."!cursor_pos"(rx398_pos)
    $P10 = rx398_cur."ws"()
    unless $P10, rx398_fail
    rx398_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx398_cur."!cursor_pos"(rx398_pos)
    $P10 = rx398_cur."EXPR"()
    unless $P10, rx398_fail
    rx398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx398_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx398_cur."!cursor_pos"(rx398_pos)
    $P10 = rx398_cur."ws"()
    unless $P10, rx398_fail
    rx398_pos = $P10."pos"()
  # rx pass
    rx398_cur."!cursor_pass"(rx398_pos, "statement_mod_cond:sym<if>")
    if_null rx398_debug, debug_573
    rx398_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx398_pos)
  debug_573:
    .return (rx398_cur)
  rx398_restart:
.annotate 'line', 4
    if_null rx398_debug, debug_574
    rx398_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_574:
  rx398_fail:
    (rx398_rep, rx398_pos, $I10, $P10) = rx398_cur."!mark_fail"(0)
    lt rx398_pos, -1, rx398_done
    eq rx398_pos, -1, rx398_fail
    jump $I10
  rx398_done:
    rx398_cur."!cursor_fail"()
    if_null rx398_debug, debug_575
    rx398_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_575:
    .return (rx398_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("88_1297619321.796") :method
.annotate 'line', 4
    $P400 = self."!PREFIX__!subrule"("ws", "if")
    new $P401, "ResizablePMCArray"
    push $P401, $P400
    .return ($P401)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("89_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx407_tgt
    .local int rx407_pos
    .local int rx407_off
    .local int rx407_eos
    .local int rx407_rep
    .local pmc rx407_cur
    .local pmc rx407_debug
    (rx407_cur, rx407_pos, rx407_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx407_cur
    .local pmc match
    .lex "$/", match
    length rx407_eos, rx407_tgt
    gt rx407_pos, rx407_eos, rx407_done
    set rx407_off, 0
    lt rx407_pos, 2, rx407_start
    sub rx407_off, rx407_pos, 1
    substr rx407_tgt, rx407_tgt, rx407_off
  rx407_start:
    eq $I10, 1, rx407_restart
    if_null rx407_debug, debug_576
    rx407_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_576:
    $I10 = self.'from'()
    ne $I10, -1, rxscan411_done
    goto rxscan411_scan
  rxscan411_loop:
    (rx407_pos) = rx407_cur."from"()
    inc rx407_pos
    rx407_cur."!cursor_from"(rx407_pos)
    ge rx407_pos, rx407_eos, rxscan411_done
  rxscan411_scan:
    set_addr $I10, rxscan411_loop
    rx407_cur."!mark_push"(0, rx407_pos, $I10)
  rxscan411_done:
.annotate 'line', 233
  # rx subcapture "sym"
    set_addr $I10, rxcap_412_fail
    rx407_cur."!mark_push"(0, rx407_pos, $I10)
  # rx literal  "unless"
    add $I11, rx407_pos, 6
    gt $I11, rx407_eos, rx407_fail
    sub $I11, rx407_pos, rx407_off
    substr $S10, rx407_tgt, $I11, 6
    ne $S10, "unless", rx407_fail
    add rx407_pos, 6
    set_addr $I10, rxcap_412_fail
    ($I12, $I11) = rx407_cur."!mark_peek"($I10)
    rx407_cur."!cursor_pos"($I11)
    ($P10) = rx407_cur."!cursor_start"()
    $P10."!cursor_pass"(rx407_pos, "")
    rx407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_412_done
  rxcap_412_fail:
    goto rx407_fail
  rxcap_412_done:
  # rx subrule "ws" subtype=method negate=
    rx407_cur."!cursor_pos"(rx407_pos)
    $P10 = rx407_cur."ws"()
    unless $P10, rx407_fail
    rx407_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx407_cur."!cursor_pos"(rx407_pos)
    $P10 = rx407_cur."EXPR"()
    unless $P10, rx407_fail
    rx407_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx407_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx407_cur."!cursor_pos"(rx407_pos)
    $P10 = rx407_cur."ws"()
    unless $P10, rx407_fail
    rx407_pos = $P10."pos"()
  # rx pass
    rx407_cur."!cursor_pass"(rx407_pos, "statement_mod_cond:sym<unless>")
    if_null rx407_debug, debug_577
    rx407_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx407_pos)
  debug_577:
    .return (rx407_cur)
  rx407_restart:
.annotate 'line', 4
    if_null rx407_debug, debug_578
    rx407_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_578:
  rx407_fail:
    (rx407_rep, rx407_pos, $I10, $P10) = rx407_cur."!mark_fail"(0)
    lt rx407_pos, -1, rx407_done
    eq rx407_pos, -1, rx407_fail
    jump $I10
  rx407_done:
    rx407_cur."!cursor_fail"()
    if_null rx407_debug, debug_579
    rx407_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_579:
    .return (rx407_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("90_1297619321.796") :method
.annotate 'line', 4
    $P409 = self."!PREFIX__!subrule"("ws", "unless")
    new $P410, "ResizablePMCArray"
    push $P410, $P409
    .return ($P410)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("91_1297619321.796")
    .param pmc param_416
.annotate 'line', 235
    .lex "self", param_416
    $P417 = param_416."!protoregex"("statement_mod_loop")
    .return ($P417)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("92_1297619321.796")
    .param pmc param_419
.annotate 'line', 235
    .lex "self", param_419
    $P420 = param_419."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P420)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("93_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx422_tgt
    .local int rx422_pos
    .local int rx422_off
    .local int rx422_eos
    .local int rx422_rep
    .local pmc rx422_cur
    .local pmc rx422_debug
    (rx422_cur, rx422_pos, rx422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx422_cur
    .local pmc match
    .lex "$/", match
    length rx422_eos, rx422_tgt
    gt rx422_pos, rx422_eos, rx422_done
    set rx422_off, 0
    lt rx422_pos, 2, rx422_start
    sub rx422_off, rx422_pos, 1
    substr rx422_tgt, rx422_tgt, rx422_off
  rx422_start:
    eq $I10, 1, rx422_restart
    if_null rx422_debug, debug_580
    rx422_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_580:
    $I10 = self.'from'()
    ne $I10, -1, rxscan426_done
    goto rxscan426_scan
  rxscan426_loop:
    (rx422_pos) = rx422_cur."from"()
    inc rx422_pos
    rx422_cur."!cursor_from"(rx422_pos)
    ge rx422_pos, rx422_eos, rxscan426_done
  rxscan426_scan:
    set_addr $I10, rxscan426_loop
    rx422_cur."!mark_push"(0, rx422_pos, $I10)
  rxscan426_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_427_fail
    rx422_cur."!mark_push"(0, rx422_pos, $I10)
  # rx literal  "while"
    add $I11, rx422_pos, 5
    gt $I11, rx422_eos, rx422_fail
    sub $I11, rx422_pos, rx422_off
    substr $S10, rx422_tgt, $I11, 5
    ne $S10, "while", rx422_fail
    add rx422_pos, 5
    set_addr $I10, rxcap_427_fail
    ($I12, $I11) = rx422_cur."!mark_peek"($I10)
    rx422_cur."!cursor_pos"($I11)
    ($P10) = rx422_cur."!cursor_start"()
    $P10."!cursor_pass"(rx422_pos, "")
    rx422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_427_done
  rxcap_427_fail:
    goto rx422_fail
  rxcap_427_done:
  # rx subrule "ws" subtype=method negate=
    rx422_cur."!cursor_pos"(rx422_pos)
    $P10 = rx422_cur."ws"()
    unless $P10, rx422_fail
    rx422_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx422_cur."!cursor_pos"(rx422_pos)
    $P10 = rx422_cur."EXPR"()
    unless $P10, rx422_fail
    rx422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx422_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx422_cur."!cursor_pos"(rx422_pos)
    $P10 = rx422_cur."ws"()
    unless $P10, rx422_fail
    rx422_pos = $P10."pos"()
  # rx pass
    rx422_cur."!cursor_pass"(rx422_pos, "statement_mod_loop:sym<while>")
    if_null rx422_debug, debug_581
    rx422_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx422_pos)
  debug_581:
    .return (rx422_cur)
  rx422_restart:
.annotate 'line', 4
    if_null rx422_debug, debug_582
    rx422_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_582:
  rx422_fail:
    (rx422_rep, rx422_pos, $I10, $P10) = rx422_cur."!mark_fail"(0)
    lt rx422_pos, -1, rx422_done
    eq rx422_pos, -1, rx422_fail
    jump $I10
  rx422_done:
    rx422_cur."!cursor_fail"()
    if_null rx422_debug, debug_583
    rx422_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_583:
    .return (rx422_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("94_1297619321.796") :method
.annotate 'line', 4
    $P424 = self."!PREFIX__!subrule"("ws", "while")
    new $P425, "ResizablePMCArray"
    push $P425, $P424
    .return ($P425)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("95_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx431_tgt
    .local int rx431_pos
    .local int rx431_off
    .local int rx431_eos
    .local int rx431_rep
    .local pmc rx431_cur
    .local pmc rx431_debug
    (rx431_cur, rx431_pos, rx431_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx431_cur
    .local pmc match
    .lex "$/", match
    length rx431_eos, rx431_tgt
    gt rx431_pos, rx431_eos, rx431_done
    set rx431_off, 0
    lt rx431_pos, 2, rx431_start
    sub rx431_off, rx431_pos, 1
    substr rx431_tgt, rx431_tgt, rx431_off
  rx431_start:
    eq $I10, 1, rx431_restart
    if_null rx431_debug, debug_584
    rx431_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_584:
    $I10 = self.'from'()
    ne $I10, -1, rxscan435_done
    goto rxscan435_scan
  rxscan435_loop:
    (rx431_pos) = rx431_cur."from"()
    inc rx431_pos
    rx431_cur."!cursor_from"(rx431_pos)
    ge rx431_pos, rx431_eos, rxscan435_done
  rxscan435_scan:
    set_addr $I10, rxscan435_loop
    rx431_cur."!mark_push"(0, rx431_pos, $I10)
  rxscan435_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_436_fail
    rx431_cur."!mark_push"(0, rx431_pos, $I10)
  # rx literal  "until"
    add $I11, rx431_pos, 5
    gt $I11, rx431_eos, rx431_fail
    sub $I11, rx431_pos, rx431_off
    substr $S10, rx431_tgt, $I11, 5
    ne $S10, "until", rx431_fail
    add rx431_pos, 5
    set_addr $I10, rxcap_436_fail
    ($I12, $I11) = rx431_cur."!mark_peek"($I10)
    rx431_cur."!cursor_pos"($I11)
    ($P10) = rx431_cur."!cursor_start"()
    $P10."!cursor_pass"(rx431_pos, "")
    rx431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_436_done
  rxcap_436_fail:
    goto rx431_fail
  rxcap_436_done:
  # rx subrule "ws" subtype=method negate=
    rx431_cur."!cursor_pos"(rx431_pos)
    $P10 = rx431_cur."ws"()
    unless $P10, rx431_fail
    rx431_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx431_cur."!cursor_pos"(rx431_pos)
    $P10 = rx431_cur."EXPR"()
    unless $P10, rx431_fail
    rx431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx431_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx431_cur."!cursor_pos"(rx431_pos)
    $P10 = rx431_cur."ws"()
    unless $P10, rx431_fail
    rx431_pos = $P10."pos"()
  # rx pass
    rx431_cur."!cursor_pass"(rx431_pos, "statement_mod_loop:sym<until>")
    if_null rx431_debug, debug_585
    rx431_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx431_pos)
  debug_585:
    .return (rx431_cur)
  rx431_restart:
.annotate 'line', 4
    if_null rx431_debug, debug_586
    rx431_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_586:
  rx431_fail:
    (rx431_rep, rx431_pos, $I10, $P10) = rx431_cur."!mark_fail"(0)
    lt rx431_pos, -1, rx431_done
    eq rx431_pos, -1, rx431_fail
    jump $I10
  rx431_done:
    rx431_cur."!cursor_fail"()
    if_null rx431_debug, debug_587
    rx431_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_587:
    .return (rx431_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("96_1297619321.796") :method
.annotate 'line', 4
    $P433 = self."!PREFIX__!subrule"("ws", "until")
    new $P434, "ResizablePMCArray"
    push $P434, $P433
    .return ($P434)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("97_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx440_tgt
    .local int rx440_pos
    .local int rx440_off
    .local int rx440_eos
    .local int rx440_rep
    .local pmc rx440_cur
    .local pmc rx440_debug
    (rx440_cur, rx440_pos, rx440_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx440_cur
    .local pmc match
    .lex "$/", match
    length rx440_eos, rx440_tgt
    gt rx440_pos, rx440_eos, rx440_done
    set rx440_off, 0
    lt rx440_pos, 2, rx440_start
    sub rx440_off, rx440_pos, 1
    substr rx440_tgt, rx440_tgt, rx440_off
  rx440_start:
    eq $I10, 1, rx440_restart
    if_null rx440_debug, debug_588
    rx440_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_588:
    $I10 = self.'from'()
    ne $I10, -1, rxscan444_done
    goto rxscan444_scan
  rxscan444_loop:
    (rx440_pos) = rx440_cur."from"()
    inc rx440_pos
    rx440_cur."!cursor_from"(rx440_pos)
    ge rx440_pos, rx440_eos, rxscan444_done
  rxscan444_scan:
    set_addr $I10, rxscan444_loop
    rx440_cur."!mark_push"(0, rx440_pos, $I10)
  rxscan444_done:
.annotate 'line', 239
  # rx subcapture "sym"
    set_addr $I10, rxcap_445_fail
    rx440_cur."!mark_push"(0, rx440_pos, $I10)
  # rx literal  "for"
    add $I11, rx440_pos, 3
    gt $I11, rx440_eos, rx440_fail
    sub $I11, rx440_pos, rx440_off
    substr $S10, rx440_tgt, $I11, 3
    ne $S10, "for", rx440_fail
    add rx440_pos, 3
    set_addr $I10, rxcap_445_fail
    ($I12, $I11) = rx440_cur."!mark_peek"($I10)
    rx440_cur."!cursor_pos"($I11)
    ($P10) = rx440_cur."!cursor_start"()
    $P10."!cursor_pass"(rx440_pos, "")
    rx440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_445_done
  rxcap_445_fail:
    goto rx440_fail
  rxcap_445_done:
  # rx subrule "ws" subtype=method negate=
    rx440_cur."!cursor_pos"(rx440_pos)
    $P10 = rx440_cur."ws"()
    unless $P10, rx440_fail
    rx440_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx440_cur."!cursor_pos"(rx440_pos)
    $P10 = rx440_cur."EXPR"()
    unless $P10, rx440_fail
    rx440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx440_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx440_cur."!cursor_pos"(rx440_pos)
    $P10 = rx440_cur."ws"()
    unless $P10, rx440_fail
    rx440_pos = $P10."pos"()
  # rx pass
    rx440_cur."!cursor_pass"(rx440_pos, "statement_mod_loop:sym<for>")
    if_null rx440_debug, debug_589
    rx440_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx440_pos)
  debug_589:
    .return (rx440_cur)
  rx440_restart:
.annotate 'line', 4
    if_null rx440_debug, debug_590
    rx440_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_590:
  rx440_fail:
    (rx440_rep, rx440_pos, $I10, $P10) = rx440_cur."!mark_fail"(0)
    lt rx440_pos, -1, rx440_done
    eq rx440_pos, -1, rx440_fail
    jump $I10
  rx440_done:
    rx440_cur."!cursor_fail"()
    if_null rx440_debug, debug_591
    rx440_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_591:
    .return (rx440_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("98_1297619321.796") :method
.annotate 'line', 4
    $P442 = self."!PREFIX__!subrule"("ws", "for")
    new $P443, "ResizablePMCArray"
    push $P443, $P442
    .return ($P443)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("99_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx449_tgt
    .local int rx449_pos
    .local int rx449_off
    .local int rx449_eos
    .local int rx449_rep
    .local pmc rx449_cur
    .local pmc rx449_debug
    (rx449_cur, rx449_pos, rx449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx449_cur
    .local pmc match
    .lex "$/", match
    length rx449_eos, rx449_tgt
    gt rx449_pos, rx449_eos, rx449_done
    set rx449_off, 0
    lt rx449_pos, 2, rx449_start
    sub rx449_off, rx449_pos, 1
    substr rx449_tgt, rx449_tgt, rx449_off
  rx449_start:
    eq $I10, 1, rx449_restart
    if_null rx449_debug, debug_592
    rx449_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_592:
    $I10 = self.'from'()
    ne $I10, -1, rxscan453_done
    goto rxscan453_scan
  rxscan453_loop:
    (rx449_pos) = rx449_cur."from"()
    inc rx449_pos
    rx449_cur."!cursor_from"(rx449_pos)
    ge rx449_pos, rx449_eos, rxscan453_done
  rxscan453_scan:
    set_addr $I10, rxscan453_loop
    rx449_cur."!mark_push"(0, rx449_pos, $I10)
  rxscan453_done:
.annotate 'line', 243
  # rx subrule "fatarrow" subtype=capture negate=
    rx449_cur."!cursor_pos"(rx449_pos)
    $P10 = rx449_cur."fatarrow"()
    unless $P10, rx449_fail
    rx449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx449_pos = $P10."pos"()
  # rx pass
    rx449_cur."!cursor_pass"(rx449_pos, "term:sym<fatarrow>")
    if_null rx449_debug, debug_593
    rx449_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx449_pos)
  debug_593:
    .return (rx449_cur)
  rx449_restart:
.annotate 'line', 4
    if_null rx449_debug, debug_594
    rx449_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_594:
  rx449_fail:
    (rx449_rep, rx449_pos, $I10, $P10) = rx449_cur."!mark_fail"(0)
    lt rx449_pos, -1, rx449_done
    eq rx449_pos, -1, rx449_fail
    jump $I10
  rx449_done:
    rx449_cur."!cursor_fail"()
    if_null rx449_debug, debug_595
    rx449_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_595:
    .return (rx449_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("100_1297619321.796") :method
.annotate 'line', 4
    $P451 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P452, "ResizablePMCArray"
    push $P452, $P451
    .return ($P452)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("101_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx455_tgt
    .local int rx455_pos
    .local int rx455_off
    .local int rx455_eos
    .local int rx455_rep
    .local pmc rx455_cur
    .local pmc rx455_debug
    (rx455_cur, rx455_pos, rx455_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx455_cur
    .local pmc match
    .lex "$/", match
    length rx455_eos, rx455_tgt
    gt rx455_pos, rx455_eos, rx455_done
    set rx455_off, 0
    lt rx455_pos, 2, rx455_start
    sub rx455_off, rx455_pos, 1
    substr rx455_tgt, rx455_tgt, rx455_off
  rx455_start:
    eq $I10, 1, rx455_restart
    if_null rx455_debug, debug_596
    rx455_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_596:
    $I10 = self.'from'()
    ne $I10, -1, rxscan459_done
    goto rxscan459_scan
  rxscan459_loop:
    (rx455_pos) = rx455_cur."from"()
    inc rx455_pos
    rx455_cur."!cursor_from"(rx455_pos)
    ge rx455_pos, rx455_eos, rxscan459_done
  rxscan459_scan:
    set_addr $I10, rxscan459_loop
    rx455_cur."!mark_push"(0, rx455_pos, $I10)
  rxscan459_done:
.annotate 'line', 244
  # rx subrule "colonpair" subtype=capture negate=
    rx455_cur."!cursor_pos"(rx455_pos)
    $P10 = rx455_cur."colonpair"()
    unless $P10, rx455_fail
    rx455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx455_pos = $P10."pos"()
  # rx pass
    rx455_cur."!cursor_pass"(rx455_pos, "term:sym<colonpair>")
    if_null rx455_debug, debug_597
    rx455_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx455_pos)
  debug_597:
    .return (rx455_cur)
  rx455_restart:
.annotate 'line', 4
    if_null rx455_debug, debug_598
    rx455_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_598:
  rx455_fail:
    (rx455_rep, rx455_pos, $I10, $P10) = rx455_cur."!mark_fail"(0)
    lt rx455_pos, -1, rx455_done
    eq rx455_pos, -1, rx455_fail
    jump $I10
  rx455_done:
    rx455_cur."!cursor_fail"()
    if_null rx455_debug, debug_599
    rx455_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_599:
    .return (rx455_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("102_1297619321.796") :method
.annotate 'line', 4
    $P457 = self."!PREFIX__!subrule"("colonpair", "")
    new $P458, "ResizablePMCArray"
    push $P458, $P457
    .return ($P458)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("103_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx461_tgt
    .local int rx461_pos
    .local int rx461_off
    .local int rx461_eos
    .local int rx461_rep
    .local pmc rx461_cur
    .local pmc rx461_debug
    (rx461_cur, rx461_pos, rx461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx461_cur
    .local pmc match
    .lex "$/", match
    length rx461_eos, rx461_tgt
    gt rx461_pos, rx461_eos, rx461_done
    set rx461_off, 0
    lt rx461_pos, 2, rx461_start
    sub rx461_off, rx461_pos, 1
    substr rx461_tgt, rx461_tgt, rx461_off
  rx461_start:
    eq $I10, 1, rx461_restart
    if_null rx461_debug, debug_600
    rx461_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_600:
    $I10 = self.'from'()
    ne $I10, -1, rxscan465_done
    goto rxscan465_scan
  rxscan465_loop:
    (rx461_pos) = rx461_cur."from"()
    inc rx461_pos
    rx461_cur."!cursor_from"(rx461_pos)
    ge rx461_pos, rx461_eos, rxscan465_done
  rxscan465_scan:
    set_addr $I10, rxscan465_loop
    rx461_cur."!mark_push"(0, rx461_pos, $I10)
  rxscan465_done:
.annotate 'line', 245
  # rx subrule "variable" subtype=capture negate=
    rx461_cur."!cursor_pos"(rx461_pos)
    $P10 = rx461_cur."variable"()
    unless $P10, rx461_fail
    rx461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx461_pos = $P10."pos"()
  # rx pass
    rx461_cur."!cursor_pass"(rx461_pos, "term:sym<variable>")
    if_null rx461_debug, debug_601
    rx461_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx461_pos)
  debug_601:
    .return (rx461_cur)
  rx461_restart:
.annotate 'line', 4
    if_null rx461_debug, debug_602
    rx461_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_602:
  rx461_fail:
    (rx461_rep, rx461_pos, $I10, $P10) = rx461_cur."!mark_fail"(0)
    lt rx461_pos, -1, rx461_done
    eq rx461_pos, -1, rx461_fail
    jump $I10
  rx461_done:
    rx461_cur."!cursor_fail"()
    if_null rx461_debug, debug_603
    rx461_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_603:
    .return (rx461_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("104_1297619321.796") :method
.annotate 'line', 4
    $P463 = self."!PREFIX__!subrule"("variable", "")
    new $P464, "ResizablePMCArray"
    push $P464, $P463
    .return ($P464)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("105_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx467_tgt
    .local int rx467_pos
    .local int rx467_off
    .local int rx467_eos
    .local int rx467_rep
    .local pmc rx467_cur
    .local pmc rx467_debug
    (rx467_cur, rx467_pos, rx467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx467_cur
    .local pmc match
    .lex "$/", match
    length rx467_eos, rx467_tgt
    gt rx467_pos, rx467_eos, rx467_done
    set rx467_off, 0
    lt rx467_pos, 2, rx467_start
    sub rx467_off, rx467_pos, 1
    substr rx467_tgt, rx467_tgt, rx467_off
  rx467_start:
    eq $I10, 1, rx467_restart
    if_null rx467_debug, debug_604
    rx467_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_604:
    $I10 = self.'from'()
    ne $I10, -1, rxscan471_done
    goto rxscan471_scan
  rxscan471_loop:
    (rx467_pos) = rx467_cur."from"()
    inc rx467_pos
    rx467_cur."!cursor_from"(rx467_pos)
    ge rx467_pos, rx467_eos, rxscan471_done
  rxscan471_scan:
    set_addr $I10, rxscan471_loop
    rx467_cur."!mark_push"(0, rx467_pos, $I10)
  rxscan471_done:
.annotate 'line', 246
  # rx subrule "package_declarator" subtype=capture negate=
    rx467_cur."!cursor_pos"(rx467_pos)
    $P10 = rx467_cur."package_declarator"()
    unless $P10, rx467_fail
    rx467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx467_pos = $P10."pos"()
  # rx pass
    rx467_cur."!cursor_pass"(rx467_pos, "term:sym<package_declarator>")
    if_null rx467_debug, debug_605
    rx467_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx467_pos)
  debug_605:
    .return (rx467_cur)
  rx467_restart:
.annotate 'line', 4
    if_null rx467_debug, debug_606
    rx467_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_606:
  rx467_fail:
    (rx467_rep, rx467_pos, $I10, $P10) = rx467_cur."!mark_fail"(0)
    lt rx467_pos, -1, rx467_done
    eq rx467_pos, -1, rx467_fail
    jump $I10
  rx467_done:
    rx467_cur."!cursor_fail"()
    if_null rx467_debug, debug_607
    rx467_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_607:
    .return (rx467_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("106_1297619321.796") :method
.annotate 'line', 4
    $P469 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P470, "ResizablePMCArray"
    push $P470, $P469
    .return ($P470)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("107_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx473_tgt
    .local int rx473_pos
    .local int rx473_off
    .local int rx473_eos
    .local int rx473_rep
    .local pmc rx473_cur
    .local pmc rx473_debug
    (rx473_cur, rx473_pos, rx473_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx473_cur
    .local pmc match
    .lex "$/", match
    length rx473_eos, rx473_tgt
    gt rx473_pos, rx473_eos, rx473_done
    set rx473_off, 0
    lt rx473_pos, 2, rx473_start
    sub rx473_off, rx473_pos, 1
    substr rx473_tgt, rx473_tgt, rx473_off
  rx473_start:
    eq $I10, 1, rx473_restart
    if_null rx473_debug, debug_608
    rx473_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_608:
    $I10 = self.'from'()
    ne $I10, -1, rxscan477_done
    goto rxscan477_scan
  rxscan477_loop:
    (rx473_pos) = rx473_cur."from"()
    inc rx473_pos
    rx473_cur."!cursor_from"(rx473_pos)
    ge rx473_pos, rx473_eos, rxscan477_done
  rxscan477_scan:
    set_addr $I10, rxscan477_loop
    rx473_cur."!mark_push"(0, rx473_pos, $I10)
  rxscan477_done:
.annotate 'line', 247
  # rx subrule "scope_declarator" subtype=capture negate=
    rx473_cur."!cursor_pos"(rx473_pos)
    $P10 = rx473_cur."scope_declarator"()
    unless $P10, rx473_fail
    rx473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx473_pos = $P10."pos"()
  # rx pass
    rx473_cur."!cursor_pass"(rx473_pos, "term:sym<scope_declarator>")
    if_null rx473_debug, debug_609
    rx473_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx473_pos)
  debug_609:
    .return (rx473_cur)
  rx473_restart:
.annotate 'line', 4
    if_null rx473_debug, debug_610
    rx473_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_610:
  rx473_fail:
    (rx473_rep, rx473_pos, $I10, $P10) = rx473_cur."!mark_fail"(0)
    lt rx473_pos, -1, rx473_done
    eq rx473_pos, -1, rx473_fail
    jump $I10
  rx473_done:
    rx473_cur."!cursor_fail"()
    if_null rx473_debug, debug_611
    rx473_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_611:
    .return (rx473_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("108_1297619321.796") :method
.annotate 'line', 4
    $P475 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P476, "ResizablePMCArray"
    push $P476, $P475
    .return ($P476)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("109_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx479_tgt
    .local int rx479_pos
    .local int rx479_off
    .local int rx479_eos
    .local int rx479_rep
    .local pmc rx479_cur
    .local pmc rx479_debug
    (rx479_cur, rx479_pos, rx479_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx479_cur
    .local pmc match
    .lex "$/", match
    length rx479_eos, rx479_tgt
    gt rx479_pos, rx479_eos, rx479_done
    set rx479_off, 0
    lt rx479_pos, 2, rx479_start
    sub rx479_off, rx479_pos, 1
    substr rx479_tgt, rx479_tgt, rx479_off
  rx479_start:
    eq $I10, 1, rx479_restart
    if_null rx479_debug, debug_612
    rx479_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_612:
    $I10 = self.'from'()
    ne $I10, -1, rxscan483_done
    goto rxscan483_scan
  rxscan483_loop:
    (rx479_pos) = rx479_cur."from"()
    inc rx479_pos
    rx479_cur."!cursor_from"(rx479_pos)
    ge rx479_pos, rx479_eos, rxscan483_done
  rxscan483_scan:
    set_addr $I10, rxscan483_loop
    rx479_cur."!mark_push"(0, rx479_pos, $I10)
  rxscan483_done:
.annotate 'line', 248
  # rx subrule "routine_declarator" subtype=capture negate=
    rx479_cur."!cursor_pos"(rx479_pos)
    $P10 = rx479_cur."routine_declarator"()
    unless $P10, rx479_fail
    rx479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx479_pos = $P10."pos"()
  # rx pass
    rx479_cur."!cursor_pass"(rx479_pos, "term:sym<routine_declarator>")
    if_null rx479_debug, debug_613
    rx479_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx479_pos)
  debug_613:
    .return (rx479_cur)
  rx479_restart:
.annotate 'line', 4
    if_null rx479_debug, debug_614
    rx479_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_614:
  rx479_fail:
    (rx479_rep, rx479_pos, $I10, $P10) = rx479_cur."!mark_fail"(0)
    lt rx479_pos, -1, rx479_done
    eq rx479_pos, -1, rx479_fail
    jump $I10
  rx479_done:
    rx479_cur."!cursor_fail"()
    if_null rx479_debug, debug_615
    rx479_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_615:
    .return (rx479_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("110_1297619321.796") :method
.annotate 'line', 4
    $P481 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P482, "ResizablePMCArray"
    push $P482, $P481
    .return ($P482)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("111_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P495 = "114_1297619321.796" 
    capture_lex $P495
    .const 'Sub' $P490 = "113_1297619321.796" 
    capture_lex $P490
    .local string rx485_tgt
    .local int rx485_pos
    .local int rx485_off
    .local int rx485_eos
    .local int rx485_rep
    .local pmc rx485_cur
    .local pmc rx485_debug
    (rx485_cur, rx485_pos, rx485_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx485_cur
    .local pmc match
    .lex "$/", match
    length rx485_eos, rx485_tgt
    gt rx485_pos, rx485_eos, rx485_done
    set rx485_off, 0
    lt rx485_pos, 2, rx485_start
    sub rx485_off, rx485_pos, 1
    substr rx485_tgt, rx485_tgt, rx485_off
  rx485_start:
    eq $I10, 1, rx485_restart
    if_null rx485_debug, debug_616
    rx485_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_616:
    $I10 = self.'from'()
    ne $I10, -1, rxscan488_done
    goto rxscan488_scan
  rxscan488_loop:
    (rx485_pos) = rx485_cur."from"()
    inc rx485_pos
    rx485_cur."!cursor_from"(rx485_pos)
    ge rx485_pos, rx485_eos, rxscan488_done
  rxscan488_scan:
    set_addr $I10, rxscan488_loop
    rx485_cur."!mark_push"(0, rx485_pos, $I10)
  rxscan488_done:
.annotate 'line', 250
  # rx subrule "before" subtype=zerowidth negate=
    rx485_cur."!cursor_pos"(rx485_pos)
    .const 'Sub' $P490 = "113_1297619321.796" 
    capture_lex $P490
    $P10 = rx485_cur."before"($P490)
    unless $P10, rx485_fail
.annotate 'line', 251
  # rx subrule "before" subtype=zerowidth negate=1
    rx485_cur."!cursor_pos"(rx485_pos)
    .const 'Sub' $P495 = "114_1297619321.796" 
    capture_lex $P495
    $P10 = rx485_cur."before"($P495)
    if $P10, rx485_fail
.annotate 'line', 252
  # rx subrule "multi_declarator" subtype=capture negate=
    rx485_cur."!cursor_pos"(rx485_pos)
    $P10 = rx485_cur."multi_declarator"()
    unless $P10, rx485_fail
    rx485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx485_pos = $P10."pos"()
.annotate 'line', 249
  # rx pass
    rx485_cur."!cursor_pass"(rx485_pos, "term:sym<multi_declarator>")
    if_null rx485_debug, debug_625
    rx485_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx485_pos)
  debug_625:
    .return (rx485_cur)
  rx485_restart:
.annotate 'line', 4
    if_null rx485_debug, debug_626
    rx485_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_626:
  rx485_fail:
    (rx485_rep, rx485_pos, $I10, $P10) = rx485_cur."!mark_fail"(0)
    lt rx485_pos, -1, rx485_done
    eq rx485_pos, -1, rx485_fail
    jump $I10
  rx485_done:
    rx485_cur."!cursor_fail"()
    if_null rx485_debug, debug_627
    rx485_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_627:
    .return (rx485_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("112_1297619321.796") :method
.annotate 'line', 4
    new $P487, "ResizablePMCArray"
    push $P487, ""
    .return ($P487)
.end


.namespace ["NQP";"Grammar"]
.sub "_block489"  :anon :subid("113_1297619321.796") :method :outer("111_1297619321.796")
.annotate 'line', 250
    .local string rx491_tgt
    .local int rx491_pos
    .local int rx491_off
    .local int rx491_eos
    .local int rx491_rep
    .local pmc rx491_cur
    .local pmc rx491_debug
    (rx491_cur, rx491_pos, rx491_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx491_cur
    .local pmc match
    .lex "$/", match
    length rx491_eos, rx491_tgt
    gt rx491_pos, rx491_eos, rx491_done
    set rx491_off, 0
    lt rx491_pos, 2, rx491_start
    sub rx491_off, rx491_pos, 1
    substr rx491_tgt, rx491_tgt, rx491_off
  rx491_start:
    eq $I10, 1, rx491_restart
    if_null rx491_debug, debug_617
    rx491_cur."!cursor_debug"("START", "")
  debug_617:
    $I10 = self.'from'()
    ne $I10, -1, rxscan492_done
    goto rxscan492_scan
  rxscan492_loop:
    (rx491_pos) = rx491_cur."from"()
    inc rx491_pos
    rx491_cur."!cursor_from"(rx491_pos)
    ge rx491_pos, rx491_eos, rxscan492_done
  rxscan492_scan:
    set_addr $I10, rxscan492_loop
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  rxscan492_done:
  alt493_0:
    set_addr $I10, alt493_1
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  # rx literal  "multi"
    add $I11, rx491_pos, 5
    gt $I11, rx491_eos, rx491_fail
    sub $I11, rx491_pos, rx491_off
    substr $S10, rx491_tgt, $I11, 5
    ne $S10, "multi", rx491_fail
    add rx491_pos, 5
    goto alt493_end
  alt493_1:
    set_addr $I10, alt493_2
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  # rx literal  "proto"
    add $I11, rx491_pos, 5
    gt $I11, rx491_eos, rx491_fail
    sub $I11, rx491_pos, rx491_off
    substr $S10, rx491_tgt, $I11, 5
    ne $S10, "proto", rx491_fail
    add rx491_pos, 5
    goto alt493_end
  alt493_2:
  # rx literal  "only"
    add $I11, rx491_pos, 4
    gt $I11, rx491_eos, rx491_fail
    sub $I11, rx491_pos, rx491_off
    substr $S10, rx491_tgt, $I11, 4
    ne $S10, "only", rx491_fail
    add rx491_pos, 4
  alt493_end:
  # rx pass
    rx491_cur."!cursor_pass"(rx491_pos, "")
    if_null rx491_debug, debug_618
    rx491_cur."!cursor_debug"("PASS", "", " at pos=", rx491_pos)
  debug_618:
    .return (rx491_cur)
  rx491_restart:
    if_null rx491_debug, debug_619
    rx491_cur."!cursor_debug"("NEXT", "")
  debug_619:
  rx491_fail:
    (rx491_rep, rx491_pos, $I10, $P10) = rx491_cur."!mark_fail"(0)
    lt rx491_pos, -1, rx491_done
    eq rx491_pos, -1, rx491_fail
    jump $I10
  rx491_done:
    rx491_cur."!cursor_fail"()
    if_null rx491_debug, debug_620
    rx491_cur."!cursor_debug"("FAIL", "")
  debug_620:
    .return (rx491_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "_block494"  :anon :subid("114_1297619321.796") :method :outer("111_1297619321.796")
.annotate 'line', 251
    .local string rx496_tgt
    .local int rx496_pos
    .local int rx496_off
    .local int rx496_eos
    .local int rx496_rep
    .local pmc rx496_cur
    .local pmc rx496_debug
    (rx496_cur, rx496_pos, rx496_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx496_cur
    .local pmc match
    .lex "$/", match
    length rx496_eos, rx496_tgt
    gt rx496_pos, rx496_eos, rx496_done
    set rx496_off, 0
    lt rx496_pos, 2, rx496_start
    sub rx496_off, rx496_pos, 1
    substr rx496_tgt, rx496_tgt, rx496_off
  rx496_start:
    eq $I10, 1, rx496_restart
    if_null rx496_debug, debug_621
    rx496_cur."!cursor_debug"("START", "")
  debug_621:
    $I10 = self.'from'()
    ne $I10, -1, rxscan497_done
    goto rxscan497_scan
  rxscan497_loop:
    (rx496_pos) = rx496_cur."from"()
    inc rx496_pos
    rx496_cur."!cursor_from"(rx496_pos)
    ge rx496_pos, rx496_eos, rxscan497_done
  rxscan497_scan:
    set_addr $I10, rxscan497_loop
    rx496_cur."!mark_push"(0, rx496_pos, $I10)
  rxscan497_done:
  # rx literal  "proto"
    add $I11, rx496_pos, 5
    gt $I11, rx496_eos, rx496_fail
    sub $I11, rx496_pos, rx496_off
    substr $S10, rx496_tgt, $I11, 5
    ne $S10, "proto", rx496_fail
    add rx496_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx496_cur."!cursor_pos"(rx496_pos)
    $P10 = rx496_cur."ws"()
    unless $P10, rx496_fail
    rx496_pos = $P10."pos"()
  alt498_0:
    set_addr $I10, alt498_1
    rx496_cur."!mark_push"(0, rx496_pos, $I10)
  # rx literal  "regex"
    add $I11, rx496_pos, 5
    gt $I11, rx496_eos, rx496_fail
    sub $I11, rx496_pos, rx496_off
    substr $S10, rx496_tgt, $I11, 5
    ne $S10, "regex", rx496_fail
    add rx496_pos, 5
    goto alt498_end
  alt498_1:
    set_addr $I10, alt498_2
    rx496_cur."!mark_push"(0, rx496_pos, $I10)
  # rx literal  "token"
    add $I11, rx496_pos, 5
    gt $I11, rx496_eos, rx496_fail
    sub $I11, rx496_pos, rx496_off
    substr $S10, rx496_tgt, $I11, 5
    ne $S10, "token", rx496_fail
    add rx496_pos, 5
    goto alt498_end
  alt498_2:
  # rx literal  "rule"
    add $I11, rx496_pos, 4
    gt $I11, rx496_eos, rx496_fail
    sub $I11, rx496_pos, rx496_off
    substr $S10, rx496_tgt, $I11, 4
    ne $S10, "rule", rx496_fail
    add rx496_pos, 4
  alt498_end:
  # rx pass
    rx496_cur."!cursor_pass"(rx496_pos, "")
    if_null rx496_debug, debug_622
    rx496_cur."!cursor_debug"("PASS", "", " at pos=", rx496_pos)
  debug_622:
    .return (rx496_cur)
  rx496_restart:
    if_null rx496_debug, debug_623
    rx496_cur."!cursor_debug"("NEXT", "")
  debug_623:
  rx496_fail:
    (rx496_rep, rx496_pos, $I10, $P10) = rx496_cur."!mark_fail"(0)
    lt rx496_pos, -1, rx496_done
    eq rx496_pos, -1, rx496_fail
    jump $I10
  rx496_done:
    rx496_cur."!cursor_fail"()
    if_null rx496_debug, debug_624
    rx496_cur."!cursor_debug"("FAIL", "")
  debug_624:
    .return (rx496_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("115_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx500_tgt
    .local int rx500_pos
    .local int rx500_off
    .local int rx500_eos
    .local int rx500_rep
    .local pmc rx500_cur
    .local pmc rx500_debug
    (rx500_cur, rx500_pos, rx500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx500_cur
    .local pmc match
    .lex "$/", match
    length rx500_eos, rx500_tgt
    gt rx500_pos, rx500_eos, rx500_done
    set rx500_off, 0
    lt rx500_pos, 2, rx500_start
    sub rx500_off, rx500_pos, 1
    substr rx500_tgt, rx500_tgt, rx500_off
  rx500_start:
    eq $I10, 1, rx500_restart
    if_null rx500_debug, debug_628
    rx500_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_628:
    $I10 = self.'from'()
    ne $I10, -1, rxscan504_done
    goto rxscan504_scan
  rxscan504_loop:
    (rx500_pos) = rx500_cur."from"()
    inc rx500_pos
    rx500_cur."!cursor_from"(rx500_pos)
    ge rx500_pos, rx500_eos, rxscan504_done
  rxscan504_scan:
    set_addr $I10, rxscan504_loop
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  rxscan504_done:
.annotate 'line', 254
  # rx subrule "regex_declarator" subtype=capture negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."regex_declarator"()
    unless $P10, rx500_fail
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx500_pos = $P10."pos"()
  # rx pass
    rx500_cur."!cursor_pass"(rx500_pos, "term:sym<regex_declarator>")
    if_null rx500_debug, debug_629
    rx500_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx500_pos)
  debug_629:
    .return (rx500_cur)
  rx500_restart:
.annotate 'line', 4
    if_null rx500_debug, debug_630
    rx500_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_630:
  rx500_fail:
    (rx500_rep, rx500_pos, $I10, $P10) = rx500_cur."!mark_fail"(0)
    lt rx500_pos, -1, rx500_done
    eq rx500_pos, -1, rx500_fail
    jump $I10
  rx500_done:
    rx500_cur."!cursor_fail"()
    if_null rx500_debug, debug_631
    rx500_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_631:
    .return (rx500_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("116_1297619321.796") :method
.annotate 'line', 4
    $P502 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P503, "ResizablePMCArray"
    push $P503, $P502
    .return ($P503)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("117_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx506_tgt
    .local int rx506_pos
    .local int rx506_off
    .local int rx506_eos
    .local int rx506_rep
    .local pmc rx506_cur
    .local pmc rx506_debug
    (rx506_cur, rx506_pos, rx506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx506_cur
    .local pmc match
    .lex "$/", match
    length rx506_eos, rx506_tgt
    gt rx506_pos, rx506_eos, rx506_done
    set rx506_off, 0
    lt rx506_pos, 2, rx506_start
    sub rx506_off, rx506_pos, 1
    substr rx506_tgt, rx506_tgt, rx506_off
  rx506_start:
    eq $I10, 1, rx506_restart
    if_null rx506_debug, debug_632
    rx506_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_632:
    $I10 = self.'from'()
    ne $I10, -1, rxscan510_done
    goto rxscan510_scan
  rxscan510_loop:
    (rx506_pos) = rx506_cur."from"()
    inc rx506_pos
    rx506_cur."!cursor_from"(rx506_pos)
    ge rx506_pos, rx506_eos, rxscan510_done
  rxscan510_scan:
    set_addr $I10, rxscan510_loop
    rx506_cur."!mark_push"(0, rx506_pos, $I10)
  rxscan510_done:
.annotate 'line', 255
  # rx subrule "statement_prefix" subtype=capture negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."statement_prefix"()
    unless $P10, rx506_fail
    rx506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx506_pos = $P10."pos"()
  # rx pass
    rx506_cur."!cursor_pass"(rx506_pos, "term:sym<statement_prefix>")
    if_null rx506_debug, debug_633
    rx506_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx506_pos)
  debug_633:
    .return (rx506_cur)
  rx506_restart:
.annotate 'line', 4
    if_null rx506_debug, debug_634
    rx506_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_634:
  rx506_fail:
    (rx506_rep, rx506_pos, $I10, $P10) = rx506_cur."!mark_fail"(0)
    lt rx506_pos, -1, rx506_done
    eq rx506_pos, -1, rx506_fail
    jump $I10
  rx506_done:
    rx506_cur."!cursor_fail"()
    if_null rx506_debug, debug_635
    rx506_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_635:
    .return (rx506_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("118_1297619321.796") :method
.annotate 'line', 4
    $P508 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P509, "ResizablePMCArray"
    push $P509, $P508
    .return ($P509)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("119_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx512_tgt
    .local int rx512_pos
    .local int rx512_off
    .local int rx512_eos
    .local int rx512_rep
    .local pmc rx512_cur
    .local pmc rx512_debug
    (rx512_cur, rx512_pos, rx512_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx512_cur
    .local pmc match
    .lex "$/", match
    length rx512_eos, rx512_tgt
    gt rx512_pos, rx512_eos, rx512_done
    set rx512_off, 0
    lt rx512_pos, 2, rx512_start
    sub rx512_off, rx512_pos, 1
    substr rx512_tgt, rx512_tgt, rx512_off
  rx512_start:
    eq $I10, 1, rx512_restart
    if_null rx512_debug, debug_636
    rx512_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_636:
    $I10 = self.'from'()
    ne $I10, -1, rxscan515_done
    goto rxscan515_scan
  rxscan515_loop:
    (rx512_pos) = rx512_cur."from"()
    inc rx512_pos
    rx512_cur."!cursor_from"(rx512_pos)
    ge rx512_pos, rx512_eos, rxscan515_done
  rxscan515_scan:
    set_addr $I10, rxscan515_loop
    rx512_cur."!mark_push"(0, rx512_pos, $I10)
  rxscan515_done:
.annotate 'line', 256
  # rx subrule "lambda" subtype=zerowidth negate=
    rx512_cur."!cursor_pos"(rx512_pos)
    $P10 = rx512_cur."lambda"()
    unless $P10, rx512_fail
  # rx subrule "pblock" subtype=capture negate=
    rx512_cur."!cursor_pos"(rx512_pos)
    $P10 = rx512_cur."pblock"()
    unless $P10, rx512_fail
    rx512_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx512_pos = $P10."pos"()
  # rx pass
    rx512_cur."!cursor_pass"(rx512_pos, "term:sym<lambda>")
    if_null rx512_debug, debug_637
    rx512_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx512_pos)
  debug_637:
    .return (rx512_cur)
  rx512_restart:
.annotate 'line', 4
    if_null rx512_debug, debug_638
    rx512_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_638:
  rx512_fail:
    (rx512_rep, rx512_pos, $I10, $P10) = rx512_cur."!mark_fail"(0)
    lt rx512_pos, -1, rx512_done
    eq rx512_pos, -1, rx512_fail
    jump $I10
  rx512_done:
    rx512_cur."!cursor_fail"()
    if_null rx512_debug, debug_639
    rx512_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_639:
    .return (rx512_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("120_1297619321.796") :method
.annotate 'line', 4
    new $P514, "ResizablePMCArray"
    push $P514, ""
    .return ($P514)
.end


.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("121_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx517_tgt
    .local int rx517_pos
    .local int rx517_off
    .local int rx517_eos
    .local int rx517_rep
    .local pmc rx517_cur
    .local pmc rx517_debug
    (rx517_cur, rx517_pos, rx517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx517_cur
    .local pmc match
    .lex "$/", match
    length rx517_eos, rx517_tgt
    gt rx517_pos, rx517_eos, rx517_done
    set rx517_off, 0
    lt rx517_pos, 2, rx517_start
    sub rx517_off, rx517_pos, 1
    substr rx517_tgt, rx517_tgt, rx517_off
  rx517_start:
    eq $I10, 1, rx517_restart
    if_null rx517_debug, debug_640
    rx517_cur."!cursor_debug"("START", "fatarrow")
  debug_640:
    $I10 = self.'from'()
    ne $I10, -1, rxscan521_done
    goto rxscan521_scan
  rxscan521_loop:
    (rx517_pos) = rx517_cur."from"()
    inc rx517_pos
    rx517_cur."!cursor_from"(rx517_pos)
    ge rx517_pos, rx517_eos, rxscan521_done
  rxscan521_scan:
    set_addr $I10, rxscan521_loop
    rx517_cur."!mark_push"(0, rx517_pos, $I10)
  rxscan521_done:
.annotate 'line', 259
  # rx subrule "identifier" subtype=capture negate=
    rx517_cur."!cursor_pos"(rx517_pos)
    $P10 = rx517_cur."identifier"()
    unless $P10, rx517_fail
    rx517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx517_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx517_pos, rx517_off
    set rx517_rep, 0
    sub $I12, rx517_eos, rx517_pos
  rxenumcharlistq522_loop:
    le $I12, 0, rxenumcharlistq522_done
    substr $S10, rx517_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq522_done
    inc rx517_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq522_loop
  rxenumcharlistq522_done:
    add rx517_pos, rx517_pos, rx517_rep
  # rx literal  "=>"
    add $I11, rx517_pos, 2
    gt $I11, rx517_eos, rx517_fail
    sub $I11, rx517_pos, rx517_off
    substr $S10, rx517_tgt, $I11, 2
    ne $S10, "=>", rx517_fail
    add rx517_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx517_cur."!cursor_pos"(rx517_pos)
    $P10 = rx517_cur."ws"()
    unless $P10, rx517_fail
    rx517_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx517_cur."!cursor_pos"(rx517_pos)
    $P10 = rx517_cur."EXPR"("i=")
    unless $P10, rx517_fail
    rx517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx517_pos = $P10."pos"()
.annotate 'line', 258
  # rx pass
    rx517_cur."!cursor_pass"(rx517_pos, "fatarrow")
    if_null rx517_debug, debug_641
    rx517_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx517_pos)
  debug_641:
    .return (rx517_cur)
  rx517_restart:
.annotate 'line', 4
    if_null rx517_debug, debug_642
    rx517_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_642:
  rx517_fail:
    (rx517_rep, rx517_pos, $I10, $P10) = rx517_cur."!mark_fail"(0)
    lt rx517_pos, -1, rx517_done
    eq rx517_pos, -1, rx517_fail
    jump $I10
  rx517_done:
    rx517_cur."!cursor_fail"()
    if_null rx517_debug, debug_643
    rx517_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_643:
    .return (rx517_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("122_1297619321.796") :method
.annotate 'line', 4
    $P519 = self."!PREFIX__!subrule"("identifier", "")
    new $P520, "ResizablePMCArray"
    push $P520, $P519
    .return ($P520)
.end


.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("123_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx524_tgt
    .local int rx524_pos
    .local int rx524_off
    .local int rx524_eos
    .local int rx524_rep
    .local pmc rx524_cur
    .local pmc rx524_debug
    (rx524_cur, rx524_pos, rx524_tgt, $I10) = self."!cursor_start"()
    rx524_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx524_cur
    .local pmc match
    .lex "$/", match
    length rx524_eos, rx524_tgt
    gt rx524_pos, rx524_eos, rx524_done
    set rx524_off, 0
    lt rx524_pos, 2, rx524_start
    sub rx524_off, rx524_pos, 1
    substr rx524_tgt, rx524_tgt, rx524_off
  rx524_start:
    eq $I10, 1, rx524_restart
    if_null rx524_debug, debug_644
    rx524_cur."!cursor_debug"("START", "colonpair")
  debug_644:
    $I10 = self.'from'()
    ne $I10, -1, rxscan530_done
    goto rxscan530_scan
  rxscan530_loop:
    (rx524_pos) = rx524_cur."from"()
    inc rx524_pos
    rx524_cur."!cursor_from"(rx524_pos)
    ge rx524_pos, rx524_eos, rxscan530_done
  rxscan530_scan:
    set_addr $I10, rxscan530_loop
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  rxscan530_done:
.annotate 'line', 263
  # rx literal  ":"
    add $I11, rx524_pos, 1
    gt $I11, rx524_eos, rx524_fail
    sub $I11, rx524_pos, rx524_off
    ord $I11, rx524_tgt, $I11
    ne $I11, 58, rx524_fail
    add rx524_pos, 1
  alt531_0:
.annotate 'line', 264
    set_addr $I10, alt531_1
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
.annotate 'line', 265
  # rx subcapture "not"
    set_addr $I10, rxcap_532_fail
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  # rx literal  "!"
    add $I11, rx524_pos, 1
    gt $I11, rx524_eos, rx524_fail
    sub $I11, rx524_pos, rx524_off
    ord $I11, rx524_tgt, $I11
    ne $I11, 33, rx524_fail
    add rx524_pos, 1
    set_addr $I10, rxcap_532_fail
    ($I12, $I11) = rx524_cur."!mark_peek"($I10)
    rx524_cur."!cursor_pos"($I11)
    ($P10) = rx524_cur."!cursor_start"()
    $P10."!cursor_pass"(rx524_pos, "")
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_532_done
  rxcap_532_fail:
    goto rx524_fail
  rxcap_532_done:
  # rx subrule "identifier" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."identifier"()
    unless $P10, rx524_fail
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx524_pos = $P10."pos"()
    goto alt531_end
  alt531_1:
    set_addr $I10, alt531_2
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
.annotate 'line', 266
  # rx subrule "identifier" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."identifier"()
    unless $P10, rx524_fail
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx524_pos = $P10."pos"()
  # rx rxquantr533 ** 0..1
    set_addr $I10, rxquantr533_done
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  rxquantr533_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."circumfix"()
    unless $P10, rx524_fail
    goto rxsubrule534_pass
  rxsubrule534_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx524_fail
  rxsubrule534_pass:
    set_addr $I10, rxsubrule534_back
    rx524_cur."!mark_push"(0, rx524_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx524_pos = $P10."pos"()
    set_addr $I10, rxquantr533_done
    (rx524_rep) = rx524_cur."!mark_commit"($I10)
  rxquantr533_done:
    goto alt531_end
  alt531_2:
.annotate 'line', 267
  # rx subrule "circumfix" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."circumfix"()
    unless $P10, rx524_fail
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx524_pos = $P10."pos"()
  alt531_end:
.annotate 'line', 262
  # rx pass
    rx524_cur."!cursor_pass"(rx524_pos, "colonpair")
    if_null rx524_debug, debug_645
    rx524_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx524_pos)
  debug_645:
    .return (rx524_cur)
  rx524_restart:
.annotate 'line', 4
    if_null rx524_debug, debug_646
    rx524_cur."!cursor_debug"("NEXT", "colonpair")
  debug_646:
  rx524_fail:
    (rx524_rep, rx524_pos, $I10, $P10) = rx524_cur."!mark_fail"(0)
    lt rx524_pos, -1, rx524_done
    eq rx524_pos, -1, rx524_fail
    jump $I10
  rx524_done:
    rx524_cur."!cursor_fail"()
    if_null rx524_debug, debug_647
    rx524_cur."!cursor_debug"("FAIL", "colonpair")
  debug_647:
    .return (rx524_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("124_1297619321.796") :method
.annotate 'line', 4
    $P526 = self."!PREFIX__!subrule"("circumfix", ":")
    $P527 = self."!PREFIX__!subrule"("identifier", ":")
    $P528 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P529, "ResizablePMCArray"
    push $P529, $P526
    push $P529, $P527
    push $P529, $P528
    .return ($P529)
.end


.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("125_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx536_tgt
    .local int rx536_pos
    .local int rx536_off
    .local int rx536_eos
    .local int rx536_rep
    .local pmc rx536_cur
    .local pmc rx536_debug
    (rx536_cur, rx536_pos, rx536_tgt, $I10) = self."!cursor_start"()
    rx536_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx536_cur
    .local pmc match
    .lex "$/", match
    length rx536_eos, rx536_tgt
    gt rx536_pos, rx536_eos, rx536_done
    set rx536_off, 0
    lt rx536_pos, 2, rx536_start
    sub rx536_off, rx536_pos, 1
    substr rx536_tgt, rx536_tgt, rx536_off
  rx536_start:
    eq $I10, 1, rx536_restart
    if_null rx536_debug, debug_648
    rx536_cur."!cursor_debug"("START", "variable")
  debug_648:
    $I10 = self.'from'()
    ne $I10, -1, rxscan541_done
    goto rxscan541_scan
  rxscan541_loop:
    (rx536_pos) = rx536_cur."from"()
    inc rx536_pos
    rx536_cur."!cursor_from"(rx536_pos)
    ge rx536_pos, rx536_eos, rxscan541_done
  rxscan541_scan:
    set_addr $I10, rxscan541_loop
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  rxscan541_done:
  alt542_0:
.annotate 'line', 271
    set_addr $I10, alt542_1
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
.annotate 'line', 272
  # rx subrule "sigil" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."sigil"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx536_pos = $P10."pos"()
  # rx rxquantr543 ** 0..1
    set_addr $I10, rxquantr543_done
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  rxquantr543_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."twigil"()
    unless $P10, rx536_fail
    goto rxsubrule544_pass
  rxsubrule544_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx536_fail
  rxsubrule544_pass:
    set_addr $I10, rxsubrule544_back
    rx536_cur."!mark_push"(0, rx536_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx536_pos = $P10."pos"()
    set_addr $I10, rxquantr543_done
    (rx536_rep) = rx536_cur."!mark_commit"($I10)
  rxquantr543_done:
  # rx subrule "name" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."name"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx536_pos = $P10."pos"()
    goto alt542_end
  alt542_1:
    set_addr $I10, alt542_2
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
.annotate 'line', 273
  # rx subrule "sigil" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."sigil"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx536_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx536_pos, rx536_off
    substr $S10, rx536_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx536_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."postcircumfix"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx536_pos = $P10."pos"()
    goto alt542_end
  alt542_2:
.annotate 'line', 274
  # rx subcapture "sigil"
    set_addr $I10, rxcap_545_fail
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  # rx literal  "$"
    add $I11, rx536_pos, 1
    gt $I11, rx536_eos, rx536_fail
    sub $I11, rx536_pos, rx536_off
    ord $I11, rx536_tgt, $I11
    ne $I11, 36, rx536_fail
    add rx536_pos, 1
    set_addr $I10, rxcap_545_fail
    ($I12, $I11) = rx536_cur."!mark_peek"($I10)
    rx536_cur."!cursor_pos"($I11)
    ($P10) = rx536_cur."!cursor_start"()
    $P10."!cursor_pass"(rx536_pos, "")
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_545_done
  rxcap_545_fail:
    goto rx536_fail
  rxcap_545_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_546_fail
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx536_pos, rx536_eos, rx536_fail
    sub $I10, rx536_pos, rx536_off
    substr $S10, rx536_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx536_fail
    inc rx536_pos
    set_addr $I10, rxcap_546_fail
    ($I12, $I11) = rx536_cur."!mark_peek"($I10)
    rx536_cur."!cursor_pos"($I11)
    ($P10) = rx536_cur."!cursor_start"()
    $P10."!cursor_pass"(rx536_pos, "")
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_546_done
  rxcap_546_fail:
    goto rx536_fail
  rxcap_546_done:
  alt542_end:
.annotate 'line', 271
  # rx pass
    rx536_cur."!cursor_pass"(rx536_pos, "variable")
    if_null rx536_debug, debug_649
    rx536_cur."!cursor_debug"("PASS", "variable", " at pos=", rx536_pos)
  debug_649:
    .return (rx536_cur)
  rx536_restart:
.annotate 'line', 4
    if_null rx536_debug, debug_650
    rx536_cur."!cursor_debug"("NEXT", "variable")
  debug_650:
  rx536_fail:
    (rx536_rep, rx536_pos, $I10, $P10) = rx536_cur."!mark_fail"(0)
    lt rx536_pos, -1, rx536_done
    eq rx536_pos, -1, rx536_fail
    jump $I10
  rx536_done:
    rx536_cur."!cursor_fail"()
    if_null rx536_debug, debug_651
    rx536_cur."!cursor_debug"("FAIL", "variable")
  debug_651:
    .return (rx536_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("126_1297619321.796") :method
.annotate 'line', 4
    $P538 = self."!PREFIX__!subrule"("sigil", "")
    $P539 = self."!PREFIX__!subrule"("sigil", "")
    new $P540, "ResizablePMCArray"
    push $P540, "$!"
    push $P540, "$_"
    push $P540, "$/"
    push $P540, $P538
    push $P540, $P539
    .return ($P540)
.end


.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("127_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx548_tgt
    .local int rx548_pos
    .local int rx548_off
    .local int rx548_eos
    .local int rx548_rep
    .local pmc rx548_cur
    .local pmc rx548_debug
    (rx548_cur, rx548_pos, rx548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx548_cur
    .local pmc match
    .lex "$/", match
    length rx548_eos, rx548_tgt
    gt rx548_pos, rx548_eos, rx548_done
    set rx548_off, 0
    lt rx548_pos, 2, rx548_start
    sub rx548_off, rx548_pos, 1
    substr rx548_tgt, rx548_tgt, rx548_off
  rx548_start:
    eq $I10, 1, rx548_restart
    if_null rx548_debug, debug_652
    rx548_cur."!cursor_debug"("START", "sigil")
  debug_652:
    $I10 = self.'from'()
    ne $I10, -1, rxscan551_done
    goto rxscan551_scan
  rxscan551_loop:
    (rx548_pos) = rx548_cur."from"()
    inc rx548_pos
    rx548_cur."!cursor_from"(rx548_pos)
    ge rx548_pos, rx548_eos, rxscan551_done
  rxscan551_scan:
    set_addr $I10, rxscan551_loop
    rx548_cur."!mark_push"(0, rx548_pos, $I10)
  rxscan551_done:
.annotate 'line', 277
  # rx enumcharlist negate=0 
    ge rx548_pos, rx548_eos, rx548_fail
    sub $I10, rx548_pos, rx548_off
    substr $S10, rx548_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx548_fail
    inc rx548_pos
  # rx pass
    rx548_cur."!cursor_pass"(rx548_pos, "sigil")
    if_null rx548_debug, debug_653
    rx548_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx548_pos)
  debug_653:
    .return (rx548_cur)
  rx548_restart:
.annotate 'line', 4
    if_null rx548_debug, debug_654
    rx548_cur."!cursor_debug"("NEXT", "sigil")
  debug_654:
  rx548_fail:
    (rx548_rep, rx548_pos, $I10, $P10) = rx548_cur."!mark_fail"(0)
    lt rx548_pos, -1, rx548_done
    eq rx548_pos, -1, rx548_fail
    jump $I10
  rx548_done:
    rx548_cur."!cursor_fail"()
    if_null rx548_debug, debug_655
    rx548_cur."!cursor_debug"("FAIL", "sigil")
  debug_655:
    .return (rx548_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("128_1297619321.796") :method
.annotate 'line', 4
    new $P550, "ResizablePMCArray"
    push $P550, "&"
    push $P550, "%"
    push $P550, "@"
    push $P550, "$"
    .return ($P550)
.end


.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("129_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx553_tgt
    .local int rx553_pos
    .local int rx553_off
    .local int rx553_eos
    .local int rx553_rep
    .local pmc rx553_cur
    .local pmc rx553_debug
    (rx553_cur, rx553_pos, rx553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx553_cur
    .local pmc match
    .lex "$/", match
    length rx553_eos, rx553_tgt
    gt rx553_pos, rx553_eos, rx553_done
    set rx553_off, 0
    lt rx553_pos, 2, rx553_start
    sub rx553_off, rx553_pos, 1
    substr rx553_tgt, rx553_tgt, rx553_off
  rx553_start:
    eq $I10, 1, rx553_restart
    if_null rx553_debug, debug_656
    rx553_cur."!cursor_debug"("START", "twigil")
  debug_656:
    $I10 = self.'from'()
    ne $I10, -1, rxscan556_done
    goto rxscan556_scan
  rxscan556_loop:
    (rx553_pos) = rx553_cur."from"()
    inc rx553_pos
    rx553_cur."!cursor_from"(rx553_pos)
    ge rx553_pos, rx553_eos, rxscan556_done
  rxscan556_scan:
    set_addr $I10, rxscan556_loop
    rx553_cur."!mark_push"(0, rx553_pos, $I10)
  rxscan556_done:
.annotate 'line', 279
  # rx enumcharlist negate=0 
    ge rx553_pos, rx553_eos, rx553_fail
    sub $I10, rx553_pos, rx553_off
    substr $S10, rx553_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx553_fail
    inc rx553_pos
  # rx pass
    rx553_cur."!cursor_pass"(rx553_pos, "twigil")
    if_null rx553_debug, debug_657
    rx553_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx553_pos)
  debug_657:
    .return (rx553_cur)
  rx553_restart:
.annotate 'line', 4
    if_null rx553_debug, debug_658
    rx553_cur."!cursor_debug"("NEXT", "twigil")
  debug_658:
  rx553_fail:
    (rx553_rep, rx553_pos, $I10, $P10) = rx553_cur."!mark_fail"(0)
    lt rx553_pos, -1, rx553_done
    eq rx553_pos, -1, rx553_fail
    jump $I10
  rx553_done:
    rx553_cur."!cursor_fail"()
    if_null rx553_debug, debug_659
    rx553_cur."!cursor_debug"("FAIL", "twigil")
  debug_659:
    .return (rx553_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("130_1297619321.796") :method
.annotate 'line', 4
    new $P555, "ResizablePMCArray"
    push $P555, "?"
    push $P555, "!"
    push $P555, "*"
    .return ($P555)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("131_1297619321.796")
    .param pmc param_558
.annotate 'line', 281
    .lex "self", param_558
    $P559 = param_558."!protoregex"("package_declarator")
    .return ($P559)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("132_1297619321.796")
    .param pmc param_561
.annotate 'line', 281
    .lex "self", param_561
    $P562 = param_561."!PREFIX__!protoregex"("package_declarator")
    .return ($P562)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("133_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 283
    new $P564, "Undef"
    .lex "$*PACKAGE-SETUP", $P564
.annotate 'line', 284
    new $P565, "Undef"
    .lex "$*PKGDECL", $P565
.annotate 'line', 4
    .local string rx566_tgt
    .local int rx566_pos
    .local int rx566_off
    .local int rx566_eos
    .local int rx566_rep
    .local pmc rx566_cur
    .local pmc rx566_debug
    (rx566_cur, rx566_pos, rx566_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx566_cur
    .local pmc match
    .lex "$/", match
    length rx566_eos, rx566_tgt
    gt rx566_pos, rx566_eos, rx566_done
    set rx566_off, 0
    lt rx566_pos, 2, rx566_start
    sub rx566_off, rx566_pos, 1
    substr rx566_tgt, rx566_tgt, rx566_off
  rx566_start:
    eq $I10, 1, rx566_restart
    if_null rx566_debug, debug_660
    rx566_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan570_done
    goto rxscan570_scan
  rxscan570_loop:
    (rx566_pos) = rx566_cur."from"()
    inc rx566_pos
    rx566_cur."!cursor_from"(rx566_pos)
    ge rx566_pos, rx566_eos, rxscan570_done
  rxscan570_scan:
    set_addr $I10, rxscan570_loop
    rx566_cur."!mark_push"(0, rx566_pos, $I10)
  rxscan570_done:
.annotate 'line', 283
    rx566_cur."!cursor_pos"(rx566_pos)
    get_hll_global $P571, ["PAST"], "Stmts"
    $P572 = $P571."new"()
    store_lex "$*PACKAGE-SETUP", $P572
.annotate 'line', 284
    rx566_cur."!cursor_pos"(rx566_pos)
    new $P573, "String"
    assign $P573, "module"
    store_lex "$*PKGDECL", $P573
.annotate 'line', 285
  # rx subcapture "sym"
    set_addr $I10, rxcap_574_fail
    rx566_cur."!mark_push"(0, rx566_pos, $I10)
  # rx literal  "module"
    add $I11, rx566_pos, 6
    gt $I11, rx566_eos, rx566_fail
    sub $I11, rx566_pos, rx566_off
    substr $S10, rx566_tgt, $I11, 6
    ne $S10, "module", rx566_fail
    add rx566_pos, 6
    set_addr $I10, rxcap_574_fail
    ($I12, $I11) = rx566_cur."!mark_peek"($I10)
    rx566_cur."!cursor_pos"($I11)
    ($P10) = rx566_cur."!cursor_start"()
    $P10."!cursor_pass"(rx566_pos, "")
    rx566_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_574_done
  rxcap_574_fail:
    goto rx566_fail
  rxcap_574_done:
  # rx subrule "package_def" subtype=capture negate=
    rx566_cur."!cursor_pos"(rx566_pos)
    $P10 = rx566_cur."package_def"()
    unless $P10, rx566_fail
    rx566_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx566_pos = $P10."pos"()
.annotate 'line', 282
  # rx pass
    rx566_cur."!cursor_pass"(rx566_pos, "package_declarator:sym<module>")
    if_null rx566_debug, debug_661
    rx566_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx566_pos)
  debug_661:
    .return (rx566_cur)
  rx566_restart:
.annotate 'line', 4
    if_null rx566_debug, debug_662
    rx566_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_662:
  rx566_fail:
    (rx566_rep, rx566_pos, $I10, $P10) = rx566_cur."!mark_fail"(0)
    lt rx566_pos, -1, rx566_done
    eq rx566_pos, -1, rx566_fail
    jump $I10
  rx566_done:
    rx566_cur."!cursor_fail"()
    if_null rx566_debug, debug_663
    rx566_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_663:
    .return (rx566_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("134_1297619321.796") :method
.annotate 'line', 4
    $P568 = self."!PREFIX__!subrule"("package_def", "module")
    new $P569, "ResizablePMCArray"
    push $P569, $P568
    .return ($P569)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("135_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 288
    new $P576, "Undef"
    .lex "$*PACKAGE-SETUP", $P576
.annotate 'line', 289
    new $P577, "Undef"
    .lex "$*PKGDECL", $P577
.annotate 'line', 4
    .local string rx578_tgt
    .local int rx578_pos
    .local int rx578_off
    .local int rx578_eos
    .local int rx578_rep
    .local pmc rx578_cur
    .local pmc rx578_debug
    (rx578_cur, rx578_pos, rx578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx578_cur
    .local pmc match
    .lex "$/", match
    length rx578_eos, rx578_tgt
    gt rx578_pos, rx578_eos, rx578_done
    set rx578_off, 0
    lt rx578_pos, 2, rx578_start
    sub rx578_off, rx578_pos, 1
    substr rx578_tgt, rx578_tgt, rx578_off
  rx578_start:
    eq $I10, 1, rx578_restart
    if_null rx578_debug, debug_664
    rx578_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan582_done
    goto rxscan582_scan
  rxscan582_loop:
    (rx578_pos) = rx578_cur."from"()
    inc rx578_pos
    rx578_cur."!cursor_from"(rx578_pos)
    ge rx578_pos, rx578_eos, rxscan582_done
  rxscan582_scan:
    set_addr $I10, rxscan582_loop
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  rxscan582_done:
.annotate 'line', 288
    rx578_cur."!cursor_pos"(rx578_pos)
    get_hll_global $P583, ["PAST"], "Stmts"
    $P584 = $P583."new"()
    store_lex "$*PACKAGE-SETUP", $P584
.annotate 'line', 289
    rx578_cur."!cursor_pos"(rx578_pos)
    new $P585, "String"
    assign $P585, "knowhow"
    store_lex "$*PKGDECL", $P585
.annotate 'line', 290
  # rx subcapture "sym"
    set_addr $I10, rxcap_586_fail
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx578_pos, 7
    gt $I11, rx578_eos, rx578_fail
    sub $I11, rx578_pos, rx578_off
    substr $S10, rx578_tgt, $I11, 7
    ne $S10, "knowhow", rx578_fail
    add rx578_pos, 7
    set_addr $I10, rxcap_586_fail
    ($I12, $I11) = rx578_cur."!mark_peek"($I10)
    rx578_cur."!cursor_pos"($I11)
    ($P10) = rx578_cur."!cursor_start"()
    $P10."!cursor_pass"(rx578_pos, "")
    rx578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_586_done
  rxcap_586_fail:
    goto rx578_fail
  rxcap_586_done:
  # rx subrule "package_def" subtype=capture negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."package_def"()
    unless $P10, rx578_fail
    rx578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx578_pos = $P10."pos"()
.annotate 'line', 287
  # rx pass
    rx578_cur."!cursor_pass"(rx578_pos, "package_declarator:sym<knowhow>")
    if_null rx578_debug, debug_665
    rx578_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx578_pos)
  debug_665:
    .return (rx578_cur)
  rx578_restart:
.annotate 'line', 4
    if_null rx578_debug, debug_666
    rx578_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_666:
  rx578_fail:
    (rx578_rep, rx578_pos, $I10, $P10) = rx578_cur."!mark_fail"(0)
    lt rx578_pos, -1, rx578_done
    eq rx578_pos, -1, rx578_fail
    jump $I10
  rx578_done:
    rx578_cur."!cursor_fail"()
    if_null rx578_debug, debug_667
    rx578_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_667:
    .return (rx578_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("136_1297619321.796") :method
.annotate 'line', 4
    $P580 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P581, "ResizablePMCArray"
    push $P581, $P580
    .return ($P581)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("137_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 293
    new $P588, "Undef"
    .lex "$*PACKAGE-SETUP", $P588
.annotate 'line', 294
    new $P589, "Undef"
    .lex "$*PKGDECL", $P589
.annotate 'line', 4
    .local string rx590_tgt
    .local int rx590_pos
    .local int rx590_off
    .local int rx590_eos
    .local int rx590_rep
    .local pmc rx590_cur
    .local pmc rx590_debug
    (rx590_cur, rx590_pos, rx590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx590_cur
    .local pmc match
    .lex "$/", match
    length rx590_eos, rx590_tgt
    gt rx590_pos, rx590_eos, rx590_done
    set rx590_off, 0
    lt rx590_pos, 2, rx590_start
    sub rx590_off, rx590_pos, 1
    substr rx590_tgt, rx590_tgt, rx590_off
  rx590_start:
    eq $I10, 1, rx590_restart
    if_null rx590_debug, debug_668
    rx590_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan594_done
    goto rxscan594_scan
  rxscan594_loop:
    (rx590_pos) = rx590_cur."from"()
    inc rx590_pos
    rx590_cur."!cursor_from"(rx590_pos)
    ge rx590_pos, rx590_eos, rxscan594_done
  rxscan594_scan:
    set_addr $I10, rxscan594_loop
    rx590_cur."!mark_push"(0, rx590_pos, $I10)
  rxscan594_done:
.annotate 'line', 293
    rx590_cur."!cursor_pos"(rx590_pos)
    get_hll_global $P595, ["PAST"], "Stmts"
    $P596 = $P595."new"()
    store_lex "$*PACKAGE-SETUP", $P596
.annotate 'line', 294
    rx590_cur."!cursor_pos"(rx590_pos)
    new $P597, "String"
    assign $P597, "class"
    store_lex "$*PKGDECL", $P597
.annotate 'line', 295
  # rx subcapture "sym"
    set_addr $I10, rxcap_598_fail
    rx590_cur."!mark_push"(0, rx590_pos, $I10)
  # rx literal  "class"
    add $I11, rx590_pos, 5
    gt $I11, rx590_eos, rx590_fail
    sub $I11, rx590_pos, rx590_off
    substr $S10, rx590_tgt, $I11, 5
    ne $S10, "class", rx590_fail
    add rx590_pos, 5
    set_addr $I10, rxcap_598_fail
    ($I12, $I11) = rx590_cur."!mark_peek"($I10)
    rx590_cur."!cursor_pos"($I11)
    ($P10) = rx590_cur."!cursor_start"()
    $P10."!cursor_pass"(rx590_pos, "")
    rx590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_598_done
  rxcap_598_fail:
    goto rx590_fail
  rxcap_598_done:
  # rx subrule "package_def" subtype=capture negate=
    rx590_cur."!cursor_pos"(rx590_pos)
    $P10 = rx590_cur."package_def"()
    unless $P10, rx590_fail
    rx590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx590_pos = $P10."pos"()
.annotate 'line', 292
  # rx pass
    rx590_cur."!cursor_pass"(rx590_pos, "package_declarator:sym<class>")
    if_null rx590_debug, debug_669
    rx590_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx590_pos)
  debug_669:
    .return (rx590_cur)
  rx590_restart:
.annotate 'line', 4
    if_null rx590_debug, debug_670
    rx590_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_670:
  rx590_fail:
    (rx590_rep, rx590_pos, $I10, $P10) = rx590_cur."!mark_fail"(0)
    lt rx590_pos, -1, rx590_done
    eq rx590_pos, -1, rx590_fail
    jump $I10
  rx590_done:
    rx590_cur."!cursor_fail"()
    if_null rx590_debug, debug_671
    rx590_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_671:
    .return (rx590_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("138_1297619321.796") :method
.annotate 'line', 4
    $P592 = self."!PREFIX__!subrule"("package_def", "class")
    new $P593, "ResizablePMCArray"
    push $P593, $P592
    .return ($P593)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("139_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 298
    new $P600, "Undef"
    .lex "$*PACKAGE-SETUP", $P600
.annotate 'line', 299
    new $P601, "Undef"
    .lex "$*PKGDECL", $P601
.annotate 'line', 4
    .local string rx602_tgt
    .local int rx602_pos
    .local int rx602_off
    .local int rx602_eos
    .local int rx602_rep
    .local pmc rx602_cur
    .local pmc rx602_debug
    (rx602_cur, rx602_pos, rx602_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx602_cur
    .local pmc match
    .lex "$/", match
    length rx602_eos, rx602_tgt
    gt rx602_pos, rx602_eos, rx602_done
    set rx602_off, 0
    lt rx602_pos, 2, rx602_start
    sub rx602_off, rx602_pos, 1
    substr rx602_tgt, rx602_tgt, rx602_off
  rx602_start:
    eq $I10, 1, rx602_restart
    if_null rx602_debug, debug_672
    rx602_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan606_done
    goto rxscan606_scan
  rxscan606_loop:
    (rx602_pos) = rx602_cur."from"()
    inc rx602_pos
    rx602_cur."!cursor_from"(rx602_pos)
    ge rx602_pos, rx602_eos, rxscan606_done
  rxscan606_scan:
    set_addr $I10, rxscan606_loop
    rx602_cur."!mark_push"(0, rx602_pos, $I10)
  rxscan606_done:
.annotate 'line', 298
    rx602_cur."!cursor_pos"(rx602_pos)
    get_hll_global $P607, ["PAST"], "Stmts"
    $P608 = $P607."new"()
    store_lex "$*PACKAGE-SETUP", $P608
.annotate 'line', 299
    rx602_cur."!cursor_pos"(rx602_pos)
    new $P609, "String"
    assign $P609, "grammar"
    store_lex "$*PKGDECL", $P609
.annotate 'line', 300
  # rx subcapture "sym"
    set_addr $I10, rxcap_610_fail
    rx602_cur."!mark_push"(0, rx602_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx602_pos, 7
    gt $I11, rx602_eos, rx602_fail
    sub $I11, rx602_pos, rx602_off
    substr $S10, rx602_tgt, $I11, 7
    ne $S10, "grammar", rx602_fail
    add rx602_pos, 7
    set_addr $I10, rxcap_610_fail
    ($I12, $I11) = rx602_cur."!mark_peek"($I10)
    rx602_cur."!cursor_pos"($I11)
    ($P10) = rx602_cur."!cursor_start"()
    $P10."!cursor_pass"(rx602_pos, "")
    rx602_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_610_done
  rxcap_610_fail:
    goto rx602_fail
  rxcap_610_done:
  # rx subrule "package_def" subtype=capture negate=
    rx602_cur."!cursor_pos"(rx602_pos)
    $P10 = rx602_cur."package_def"()
    unless $P10, rx602_fail
    rx602_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx602_pos = $P10."pos"()
.annotate 'line', 297
  # rx pass
    rx602_cur."!cursor_pass"(rx602_pos, "package_declarator:sym<grammar>")
    if_null rx602_debug, debug_673
    rx602_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx602_pos)
  debug_673:
    .return (rx602_cur)
  rx602_restart:
.annotate 'line', 4
    if_null rx602_debug, debug_674
    rx602_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_674:
  rx602_fail:
    (rx602_rep, rx602_pos, $I10, $P10) = rx602_cur."!mark_fail"(0)
    lt rx602_pos, -1, rx602_done
    eq rx602_pos, -1, rx602_fail
    jump $I10
  rx602_done:
    rx602_cur."!cursor_fail"()
    if_null rx602_debug, debug_675
    rx602_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_675:
    .return (rx602_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("140_1297619321.796") :method
.annotate 'line', 4
    $P604 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P605, "ResizablePMCArray"
    push $P605, $P604
    .return ($P605)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("141_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 303
    new $P612, "Undef"
    .lex "$*PACKAGE-SETUP", $P612
.annotate 'line', 304
    new $P613, "Undef"
    .lex "$*PKGDECL", $P613
.annotate 'line', 4
    .local string rx614_tgt
    .local int rx614_pos
    .local int rx614_off
    .local int rx614_eos
    .local int rx614_rep
    .local pmc rx614_cur
    .local pmc rx614_debug
    (rx614_cur, rx614_pos, rx614_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx614_cur
    .local pmc match
    .lex "$/", match
    length rx614_eos, rx614_tgt
    gt rx614_pos, rx614_eos, rx614_done
    set rx614_off, 0
    lt rx614_pos, 2, rx614_start
    sub rx614_off, rx614_pos, 1
    substr rx614_tgt, rx614_tgt, rx614_off
  rx614_start:
    eq $I10, 1, rx614_restart
    if_null rx614_debug, debug_676
    rx614_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan618_done
    goto rxscan618_scan
  rxscan618_loop:
    (rx614_pos) = rx614_cur."from"()
    inc rx614_pos
    rx614_cur."!cursor_from"(rx614_pos)
    ge rx614_pos, rx614_eos, rxscan618_done
  rxscan618_scan:
    set_addr $I10, rxscan618_loop
    rx614_cur."!mark_push"(0, rx614_pos, $I10)
  rxscan618_done:
.annotate 'line', 303
    rx614_cur."!cursor_pos"(rx614_pos)
    get_hll_global $P619, ["PAST"], "Stmts"
    $P620 = $P619."new"()
    store_lex "$*PACKAGE-SETUP", $P620
.annotate 'line', 304
    rx614_cur."!cursor_pos"(rx614_pos)
    new $P621, "String"
    assign $P621, "role"
    store_lex "$*PKGDECL", $P621
.annotate 'line', 305
  # rx subcapture "sym"
    set_addr $I10, rxcap_622_fail
    rx614_cur."!mark_push"(0, rx614_pos, $I10)
  # rx literal  "role"
    add $I11, rx614_pos, 4
    gt $I11, rx614_eos, rx614_fail
    sub $I11, rx614_pos, rx614_off
    substr $S10, rx614_tgt, $I11, 4
    ne $S10, "role", rx614_fail
    add rx614_pos, 4
    set_addr $I10, rxcap_622_fail
    ($I12, $I11) = rx614_cur."!mark_peek"($I10)
    rx614_cur."!cursor_pos"($I11)
    ($P10) = rx614_cur."!cursor_start"()
    $P10."!cursor_pass"(rx614_pos, "")
    rx614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_622_done
  rxcap_622_fail:
    goto rx614_fail
  rxcap_622_done:
  # rx subrule "package_def" subtype=capture negate=
    rx614_cur."!cursor_pos"(rx614_pos)
    $P10 = rx614_cur."package_def"()
    unless $P10, rx614_fail
    rx614_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx614_pos = $P10."pos"()
.annotate 'line', 302
  # rx pass
    rx614_cur."!cursor_pass"(rx614_pos, "package_declarator:sym<role>")
    if_null rx614_debug, debug_677
    rx614_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx614_pos)
  debug_677:
    .return (rx614_cur)
  rx614_restart:
.annotate 'line', 4
    if_null rx614_debug, debug_678
    rx614_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_678:
  rx614_fail:
    (rx614_rep, rx614_pos, $I10, $P10) = rx614_cur."!mark_fail"(0)
    lt rx614_pos, -1, rx614_done
    eq rx614_pos, -1, rx614_fail
    jump $I10
  rx614_done:
    rx614_cur."!cursor_fail"()
    if_null rx614_debug, debug_679
    rx614_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_679:
    .return (rx614_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("142_1297619321.796") :method
.annotate 'line', 4
    $P616 = self."!PREFIX__!subrule"("package_def", "role")
    new $P617, "ResizablePMCArray"
    push $P617, $P616
    .return ($P617)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("143_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 308
    new $P624, "Undef"
    .lex "$*PACKAGE-SETUP", $P624
.annotate 'line', 309
    new $P625, "Undef"
    .lex "$*PKGDECL", $P625
.annotate 'line', 4
    .local string rx626_tgt
    .local int rx626_pos
    .local int rx626_off
    .local int rx626_eos
    .local int rx626_rep
    .local pmc rx626_cur
    .local pmc rx626_debug
    (rx626_cur, rx626_pos, rx626_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx626_cur
    .local pmc match
    .lex "$/", match
    length rx626_eos, rx626_tgt
    gt rx626_pos, rx626_eos, rx626_done
    set rx626_off, 0
    lt rx626_pos, 2, rx626_start
    sub rx626_off, rx626_pos, 1
    substr rx626_tgt, rx626_tgt, rx626_off
  rx626_start:
    eq $I10, 1, rx626_restart
    if_null rx626_debug, debug_680
    rx626_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan630_done
    goto rxscan630_scan
  rxscan630_loop:
    (rx626_pos) = rx626_cur."from"()
    inc rx626_pos
    rx626_cur."!cursor_from"(rx626_pos)
    ge rx626_pos, rx626_eos, rxscan630_done
  rxscan630_scan:
    set_addr $I10, rxscan630_loop
    rx626_cur."!mark_push"(0, rx626_pos, $I10)
  rxscan630_done:
.annotate 'line', 308
    rx626_cur."!cursor_pos"(rx626_pos)
    get_hll_global $P631, ["PAST"], "Stmts"
    $P632 = $P631."new"()
    store_lex "$*PACKAGE-SETUP", $P632
.annotate 'line', 309
    rx626_cur."!cursor_pos"(rx626_pos)
    new $P633, "String"
    assign $P633, "native"
    store_lex "$*PKGDECL", $P633
.annotate 'line', 310
  # rx subcapture "sym"
    set_addr $I10, rxcap_634_fail
    rx626_cur."!mark_push"(0, rx626_pos, $I10)
  # rx literal  "native"
    add $I11, rx626_pos, 6
    gt $I11, rx626_eos, rx626_fail
    sub $I11, rx626_pos, rx626_off
    substr $S10, rx626_tgt, $I11, 6
    ne $S10, "native", rx626_fail
    add rx626_pos, 6
    set_addr $I10, rxcap_634_fail
    ($I12, $I11) = rx626_cur."!mark_peek"($I10)
    rx626_cur."!cursor_pos"($I11)
    ($P10) = rx626_cur."!cursor_start"()
    $P10."!cursor_pass"(rx626_pos, "")
    rx626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_634_done
  rxcap_634_fail:
    goto rx626_fail
  rxcap_634_done:
  # rx subrule "package_def" subtype=capture negate=
    rx626_cur."!cursor_pos"(rx626_pos)
    $P10 = rx626_cur."package_def"()
    unless $P10, rx626_fail
    rx626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx626_pos = $P10."pos"()
.annotate 'line', 307
  # rx pass
    rx626_cur."!cursor_pass"(rx626_pos, "package_declarator:sym<native>")
    if_null rx626_debug, debug_681
    rx626_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx626_pos)
  debug_681:
    .return (rx626_cur)
  rx626_restart:
.annotate 'line', 4
    if_null rx626_debug, debug_682
    rx626_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_682:
  rx626_fail:
    (rx626_rep, rx626_pos, $I10, $P10) = rx626_cur."!mark_fail"(0)
    lt rx626_pos, -1, rx626_done
    eq rx626_pos, -1, rx626_fail
    jump $I10
  rx626_done:
    rx626_cur."!cursor_fail"()
    if_null rx626_debug, debug_683
    rx626_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_683:
    .return (rx626_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("144_1297619321.796") :method
.annotate 'line', 4
    $P628 = self."!PREFIX__!subrule"("package_def", "native")
    new $P629, "ResizablePMCArray"
    push $P629, $P628
    .return ($P629)
.end


.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("145_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx636_tgt
    .local int rx636_pos
    .local int rx636_off
    .local int rx636_eos
    .local int rx636_rep
    .local pmc rx636_cur
    .local pmc rx636_debug
    (rx636_cur, rx636_pos, rx636_tgt, $I10) = self."!cursor_start"()
    rx636_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx636_cur
    .local pmc match
    .lex "$/", match
    length rx636_eos, rx636_tgt
    gt rx636_pos, rx636_eos, rx636_done
    set rx636_off, 0
    lt rx636_pos, 2, rx636_start
    sub rx636_off, rx636_pos, 1
    substr rx636_tgt, rx636_tgt, rx636_off
  rx636_start:
    eq $I10, 1, rx636_restart
    if_null rx636_debug, debug_684
    rx636_cur."!cursor_debug"("START", "package_def")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan640_done
    goto rxscan640_scan
  rxscan640_loop:
    (rx636_pos) = rx636_cur."from"()
    inc rx636_pos
    rx636_cur."!cursor_from"(rx636_pos)
    ge rx636_pos, rx636_eos, rxscan640_done
  rxscan640_scan:
    set_addr $I10, rxscan640_loop
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  rxscan640_done:
.annotate 'line', 313
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
.annotate 'line', 314
  # rx subrule "name" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."name"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
.annotate 'line', 315
  # rx rxquantr643 ** 0..1
    set_addr $I10, rxquantr643_done
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  rxquantr643_loop:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx636_pos, 2
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I11, 2
    ne $S10, "is", rx636_fail
    add rx636_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx636_pos, 5
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I11, 5
    ne $S10, "repr(", rx636_fail
    add rx636_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."quote_EXPR"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx636_pos, 1
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    ord $I11, rx636_tgt, $I11
    ne $I11, 41, rx636_fail
    add rx636_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
    set_addr $I10, rxquantr643_done
    (rx636_rep) = rx636_cur."!mark_commit"($I10)
  rxquantr643_done:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
.annotate 'line', 316
  # rx rxquantr650 ** 0..1
    set_addr $I10, rxquantr650_done
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  rxquantr650_loop:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx636_pos, 2
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I11, 2
    ne $S10, "is", rx636_fail
    add rx636_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."name"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
    set_addr $I10, rxquantr650_done
    (rx636_rep) = rx636_cur."!mark_commit"($I10)
  rxquantr650_done:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
.annotate 'line', 317
  # rx rxquantr655 ** 0..*
    set_addr $I10, rxquantr655_done
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
  rxquantr655_loop:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx636_pos, 4
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I11, 4
    ne $S10, "does", rx636_fail
    add rx636_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."name"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
    set_addr $I10, rxquantr655_done
    (rx636_rep) = rx636_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr655_done
    rx636_cur."!mark_push"(rx636_rep, rx636_pos, $I10)
    goto rxquantr655_loop
  rxquantr655_done:
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  alt660_0:
.annotate 'line', 318
    set_addr $I10, alt660_1
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
.annotate 'line', 319
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx636_pos, 1
    gt $I11, rx636_eos, rx636_fail
    sub $I11, rx636_pos, rx636_off
    ord $I11, rx636_tgt, $I11
    ne $I11, 59, rx636_fail
    add rx636_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."comp_unit"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
    goto alt660_end
  alt660_1:
    set_addr $I10, alt660_2
    rx636_cur."!mark_push"(0, rx636_pos, $I10)
.annotate 'line', 320
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx636_pos, rx636_off
    substr $S10, rx636_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx636_fail
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."block"()
    unless $P10, rx636_fail
    rx636_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
    goto alt660_end
  alt660_2:
.annotate 'line', 321
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."panic"("Malformed package declaration")
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
  alt660_end:
.annotate 'line', 322
  # rx subrule "ws" subtype=method negate=
    rx636_cur."!cursor_pos"(rx636_pos)
    $P10 = rx636_cur."ws"()
    unless $P10, rx636_fail
    rx636_pos = $P10."pos"()
.annotate 'line', 313
  # rx pass
    rx636_cur."!cursor_pass"(rx636_pos, "package_def")
    if_null rx636_debug, debug_685
    rx636_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx636_pos)
  debug_685:
    .return (rx636_cur)
  rx636_restart:
.annotate 'line', 4
    if_null rx636_debug, debug_686
    rx636_cur."!cursor_debug"("NEXT", "package_def")
  debug_686:
  rx636_fail:
    (rx636_rep, rx636_pos, $I10, $P10) = rx636_cur."!mark_fail"(0)
    lt rx636_pos, -1, rx636_done
    eq rx636_pos, -1, rx636_fail
    jump $I10
  rx636_done:
    rx636_cur."!cursor_fail"()
    if_null rx636_debug, debug_687
    rx636_cur."!cursor_debug"("FAIL", "package_def")
  debug_687:
    .return (rx636_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("146_1297619321.796") :method
.annotate 'line', 4
    $P638 = self."!PREFIX__!subrule"("ws", "")
    new $P639, "ResizablePMCArray"
    push $P639, $P638
    .return ($P639)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("147_1297619321.796")
    .param pmc param_671
.annotate 'line', 325
    .lex "self", param_671
    $P672 = param_671."!protoregex"("scope_declarator")
    .return ($P672)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("148_1297619321.796")
    .param pmc param_674
.annotate 'line', 325
    .lex "self", param_674
    $P675 = param_674."!PREFIX__!protoregex"("scope_declarator")
    .return ($P675)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("149_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx677_tgt
    .local int rx677_pos
    .local int rx677_off
    .local int rx677_eos
    .local int rx677_rep
    .local pmc rx677_cur
    .local pmc rx677_debug
    (rx677_cur, rx677_pos, rx677_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx677_cur
    .local pmc match
    .lex "$/", match
    length rx677_eos, rx677_tgt
    gt rx677_pos, rx677_eos, rx677_done
    set rx677_off, 0
    lt rx677_pos, 2, rx677_start
    sub rx677_off, rx677_pos, 1
    substr rx677_tgt, rx677_tgt, rx677_off
  rx677_start:
    eq $I10, 1, rx677_restart
    if_null rx677_debug, debug_688
    rx677_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan681_done
    goto rxscan681_scan
  rxscan681_loop:
    (rx677_pos) = rx677_cur."from"()
    inc rx677_pos
    rx677_cur."!cursor_from"(rx677_pos)
    ge rx677_pos, rx677_eos, rxscan681_done
  rxscan681_scan:
    set_addr $I10, rxscan681_loop
    rx677_cur."!mark_push"(0, rx677_pos, $I10)
  rxscan681_done:
.annotate 'line', 326
  # rx subcapture "sym"
    set_addr $I10, rxcap_682_fail
    rx677_cur."!mark_push"(0, rx677_pos, $I10)
  # rx literal  "my"
    add $I11, rx677_pos, 2
    gt $I11, rx677_eos, rx677_fail
    sub $I11, rx677_pos, rx677_off
    substr $S10, rx677_tgt, $I11, 2
    ne $S10, "my", rx677_fail
    add rx677_pos, 2
    set_addr $I10, rxcap_682_fail
    ($I12, $I11) = rx677_cur."!mark_peek"($I10)
    rx677_cur."!cursor_pos"($I11)
    ($P10) = rx677_cur."!cursor_start"()
    $P10."!cursor_pass"(rx677_pos, "")
    rx677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_682_done
  rxcap_682_fail:
    goto rx677_fail
  rxcap_682_done:
  # rx subrule "scoped" subtype=capture negate=
    rx677_cur."!cursor_pos"(rx677_pos)
    $P10 = rx677_cur."scoped"("my")
    unless $P10, rx677_fail
    rx677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx677_pos = $P10."pos"()
  # rx pass
    rx677_cur."!cursor_pass"(rx677_pos, "scope_declarator:sym<my>")
    if_null rx677_debug, debug_689
    rx677_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx677_pos)
  debug_689:
    .return (rx677_cur)
  rx677_restart:
.annotate 'line', 4
    if_null rx677_debug, debug_690
    rx677_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_690:
  rx677_fail:
    (rx677_rep, rx677_pos, $I10, $P10) = rx677_cur."!mark_fail"(0)
    lt rx677_pos, -1, rx677_done
    eq rx677_pos, -1, rx677_fail
    jump $I10
  rx677_done:
    rx677_cur."!cursor_fail"()
    if_null rx677_debug, debug_691
    rx677_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_691:
    .return (rx677_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("150_1297619321.796") :method
.annotate 'line', 4
    $P679 = self."!PREFIX__!subrule"("scoped", "my")
    new $P680, "ResizablePMCArray"
    push $P680, $P679
    .return ($P680)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("151_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx684_tgt
    .local int rx684_pos
    .local int rx684_off
    .local int rx684_eos
    .local int rx684_rep
    .local pmc rx684_cur
    .local pmc rx684_debug
    (rx684_cur, rx684_pos, rx684_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx684_cur
    .local pmc match
    .lex "$/", match
    length rx684_eos, rx684_tgt
    gt rx684_pos, rx684_eos, rx684_done
    set rx684_off, 0
    lt rx684_pos, 2, rx684_start
    sub rx684_off, rx684_pos, 1
    substr rx684_tgt, rx684_tgt, rx684_off
  rx684_start:
    eq $I10, 1, rx684_restart
    if_null rx684_debug, debug_692
    rx684_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan688_done
    goto rxscan688_scan
  rxscan688_loop:
    (rx684_pos) = rx684_cur."from"()
    inc rx684_pos
    rx684_cur."!cursor_from"(rx684_pos)
    ge rx684_pos, rx684_eos, rxscan688_done
  rxscan688_scan:
    set_addr $I10, rxscan688_loop
    rx684_cur."!mark_push"(0, rx684_pos, $I10)
  rxscan688_done:
.annotate 'line', 327
  # rx subcapture "sym"
    set_addr $I10, rxcap_689_fail
    rx684_cur."!mark_push"(0, rx684_pos, $I10)
  # rx literal  "our"
    add $I11, rx684_pos, 3
    gt $I11, rx684_eos, rx684_fail
    sub $I11, rx684_pos, rx684_off
    substr $S10, rx684_tgt, $I11, 3
    ne $S10, "our", rx684_fail
    add rx684_pos, 3
    set_addr $I10, rxcap_689_fail
    ($I12, $I11) = rx684_cur."!mark_peek"($I10)
    rx684_cur."!cursor_pos"($I11)
    ($P10) = rx684_cur."!cursor_start"()
    $P10."!cursor_pass"(rx684_pos, "")
    rx684_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_689_done
  rxcap_689_fail:
    goto rx684_fail
  rxcap_689_done:
  # rx subrule "scoped" subtype=capture negate=
    rx684_cur."!cursor_pos"(rx684_pos)
    $P10 = rx684_cur."scoped"("our")
    unless $P10, rx684_fail
    rx684_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx684_pos = $P10."pos"()
  # rx pass
    rx684_cur."!cursor_pass"(rx684_pos, "scope_declarator:sym<our>")
    if_null rx684_debug, debug_693
    rx684_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx684_pos)
  debug_693:
    .return (rx684_cur)
  rx684_restart:
.annotate 'line', 4
    if_null rx684_debug, debug_694
    rx684_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_694:
  rx684_fail:
    (rx684_rep, rx684_pos, $I10, $P10) = rx684_cur."!mark_fail"(0)
    lt rx684_pos, -1, rx684_done
    eq rx684_pos, -1, rx684_fail
    jump $I10
  rx684_done:
    rx684_cur."!cursor_fail"()
    if_null rx684_debug, debug_695
    rx684_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_695:
    .return (rx684_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("152_1297619321.796") :method
.annotate 'line', 4
    $P686 = self."!PREFIX__!subrule"("scoped", "our")
    new $P687, "ResizablePMCArray"
    push $P687, $P686
    .return ($P687)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("153_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx691_tgt
    .local int rx691_pos
    .local int rx691_off
    .local int rx691_eos
    .local int rx691_rep
    .local pmc rx691_cur
    .local pmc rx691_debug
    (rx691_cur, rx691_pos, rx691_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx691_cur
    .local pmc match
    .lex "$/", match
    length rx691_eos, rx691_tgt
    gt rx691_pos, rx691_eos, rx691_done
    set rx691_off, 0
    lt rx691_pos, 2, rx691_start
    sub rx691_off, rx691_pos, 1
    substr rx691_tgt, rx691_tgt, rx691_off
  rx691_start:
    eq $I10, 1, rx691_restart
    if_null rx691_debug, debug_696
    rx691_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan695_done
    goto rxscan695_scan
  rxscan695_loop:
    (rx691_pos) = rx691_cur."from"()
    inc rx691_pos
    rx691_cur."!cursor_from"(rx691_pos)
    ge rx691_pos, rx691_eos, rxscan695_done
  rxscan695_scan:
    set_addr $I10, rxscan695_loop
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  rxscan695_done:
.annotate 'line', 328
  # rx subcapture "sym"
    set_addr $I10, rxcap_696_fail
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  # rx literal  "has"
    add $I11, rx691_pos, 3
    gt $I11, rx691_eos, rx691_fail
    sub $I11, rx691_pos, rx691_off
    substr $S10, rx691_tgt, $I11, 3
    ne $S10, "has", rx691_fail
    add rx691_pos, 3
    set_addr $I10, rxcap_696_fail
    ($I12, $I11) = rx691_cur."!mark_peek"($I10)
    rx691_cur."!cursor_pos"($I11)
    ($P10) = rx691_cur."!cursor_start"()
    $P10."!cursor_pass"(rx691_pos, "")
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_696_done
  rxcap_696_fail:
    goto rx691_fail
  rxcap_696_done:
  # rx subrule "scoped" subtype=capture negate=
    rx691_cur."!cursor_pos"(rx691_pos)
    $P10 = rx691_cur."scoped"("has")
    unless $P10, rx691_fail
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx691_pos = $P10."pos"()
  # rx pass
    rx691_cur."!cursor_pass"(rx691_pos, "scope_declarator:sym<has>")
    if_null rx691_debug, debug_697
    rx691_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx691_pos)
  debug_697:
    .return (rx691_cur)
  rx691_restart:
.annotate 'line', 4
    if_null rx691_debug, debug_698
    rx691_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_698:
  rx691_fail:
    (rx691_rep, rx691_pos, $I10, $P10) = rx691_cur."!mark_fail"(0)
    lt rx691_pos, -1, rx691_done
    eq rx691_pos, -1, rx691_fail
    jump $I10
  rx691_done:
    rx691_cur."!cursor_fail"()
    if_null rx691_debug, debug_699
    rx691_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_699:
    .return (rx691_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("154_1297619321.796") :method
.annotate 'line', 4
    $P693 = self."!PREFIX__!subrule"("scoped", "has")
    new $P694, "ResizablePMCArray"
    push $P694, $P693
    .return ($P694)
.end


.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("155_1297619321.796") :method :outer("11_1297619321.796")
    .param pmc param_698
.annotate 'line', 330
    .lex "$*SCOPE", param_698
.annotate 'line', 4
    .local string rx699_tgt
    .local int rx699_pos
    .local int rx699_off
    .local int rx699_eos
    .local int rx699_rep
    .local pmc rx699_cur
    .local pmc rx699_debug
    (rx699_cur, rx699_pos, rx699_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx699_cur
    .local pmc match
    .lex "$/", match
    length rx699_eos, rx699_tgt
    gt rx699_pos, rx699_eos, rx699_done
    set rx699_off, 0
    lt rx699_pos, 2, rx699_start
    sub rx699_off, rx699_pos, 1
    substr rx699_tgt, rx699_tgt, rx699_off
  rx699_start:
    eq $I10, 1, rx699_restart
    if_null rx699_debug, debug_700
    rx699_cur."!cursor_debug"("START", "scoped")
  debug_700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan704_done
    goto rxscan704_scan
  rxscan704_loop:
    (rx699_pos) = rx699_cur."from"()
    inc rx699_pos
    rx699_cur."!cursor_from"(rx699_pos)
    ge rx699_pos, rx699_eos, rxscan704_done
  rxscan704_scan:
    set_addr $I10, rxscan704_loop
    rx699_cur."!mark_push"(0, rx699_pos, $I10)
  rxscan704_done:
  alt705_0:
.annotate 'line', 330
    set_addr $I10, alt705_1
    rx699_cur."!mark_push"(0, rx699_pos, $I10)
.annotate 'line', 331
  # rx subrule "ws" subtype=method negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."ws"()
    unless $P10, rx699_fail
    rx699_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."declarator"()
    unless $P10, rx699_fail
    rx699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx699_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."ws"()
    unless $P10, rx699_fail
    rx699_pos = $P10."pos"()
    goto alt705_end
  alt705_1:
.annotate 'line', 332
  # rx subrule "ws" subtype=method negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."ws"()
    unless $P10, rx699_fail
    rx699_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."multi_declarator"()
    unless $P10, rx699_fail
    rx699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx699_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."ws"()
    unless $P10, rx699_fail
    rx699_pos = $P10."pos"()
  alt705_end:
.annotate 'line', 330
  # rx pass
    rx699_cur."!cursor_pass"(rx699_pos, "scoped")
    if_null rx699_debug, debug_701
    rx699_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx699_pos)
  debug_701:
    .return (rx699_cur)
  rx699_restart:
.annotate 'line', 4
    if_null rx699_debug, debug_702
    rx699_cur."!cursor_debug"("NEXT", "scoped")
  debug_702:
  rx699_fail:
    (rx699_rep, rx699_pos, $I10, $P10) = rx699_cur."!mark_fail"(0)
    lt rx699_pos, -1, rx699_done
    eq rx699_pos, -1, rx699_fail
    jump $I10
  rx699_done:
    rx699_cur."!cursor_fail"()
    if_null rx699_debug, debug_703
    rx699_cur."!cursor_debug"("FAIL", "scoped")
  debug_703:
    .return (rx699_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("156_1297619321.796") :method
.annotate 'line', 4
    $P701 = self."!PREFIX__!subrule"("ws", "")
    $P702 = self."!PREFIX__!subrule"("ws", "")
    new $P703, "ResizablePMCArray"
    push $P703, $P701
    push $P703, $P702
    .return ($P703)
.end


.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("157_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx711_tgt
    .local int rx711_pos
    .local int rx711_off
    .local int rx711_eos
    .local int rx711_rep
    .local pmc rx711_cur
    .local pmc rx711_debug
    (rx711_cur, rx711_pos, rx711_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx711_cur
    .local pmc match
    .lex "$/", match
    length rx711_eos, rx711_tgt
    gt rx711_pos, rx711_eos, rx711_done
    set rx711_off, 0
    lt rx711_pos, 2, rx711_start
    sub rx711_off, rx711_pos, 1
    substr rx711_tgt, rx711_tgt, rx711_off
  rx711_start:
    eq $I10, 1, rx711_restart
    if_null rx711_debug, debug_704
    rx711_cur."!cursor_debug"("START", "typename")
  debug_704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan715_done
    goto rxscan715_scan
  rxscan715_loop:
    (rx711_pos) = rx711_cur."from"()
    inc rx711_pos
    rx711_cur."!cursor_from"(rx711_pos)
    ge rx711_pos, rx711_eos, rxscan715_done
  rxscan715_scan:
    set_addr $I10, rxscan715_loop
    rx711_cur."!mark_push"(0, rx711_pos, $I10)
  rxscan715_done:
.annotate 'line', 335
  # rx subrule "name" subtype=capture negate=
    rx711_cur."!cursor_pos"(rx711_pos)
    $P10 = rx711_cur."name"()
    unless $P10, rx711_fail
    rx711_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx711_pos = $P10."pos"()
  # rx pass
    rx711_cur."!cursor_pass"(rx711_pos, "typename")
    if_null rx711_debug, debug_705
    rx711_cur."!cursor_debug"("PASS", "typename", " at pos=", rx711_pos)
  debug_705:
    .return (rx711_cur)
  rx711_restart:
.annotate 'line', 4
    if_null rx711_debug, debug_706
    rx711_cur."!cursor_debug"("NEXT", "typename")
  debug_706:
  rx711_fail:
    (rx711_rep, rx711_pos, $I10, $P10) = rx711_cur."!mark_fail"(0)
    lt rx711_pos, -1, rx711_done
    eq rx711_pos, -1, rx711_fail
    jump $I10
  rx711_done:
    rx711_cur."!cursor_fail"()
    if_null rx711_debug, debug_707
    rx711_cur."!cursor_debug"("FAIL", "typename")
  debug_707:
    .return (rx711_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("158_1297619321.796") :method
.annotate 'line', 4
    $P713 = self."!PREFIX__!subrule"("name", "")
    new $P714, "ResizablePMCArray"
    push $P714, $P713
    .return ($P714)
.end


.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("159_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx717_tgt
    .local int rx717_pos
    .local int rx717_off
    .local int rx717_eos
    .local int rx717_rep
    .local pmc rx717_cur
    .local pmc rx717_debug
    (rx717_cur, rx717_pos, rx717_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx717_cur
    .local pmc match
    .lex "$/", match
    length rx717_eos, rx717_tgt
    gt rx717_pos, rx717_eos, rx717_done
    set rx717_off, 0
    lt rx717_pos, 2, rx717_start
    sub rx717_off, rx717_pos, 1
    substr rx717_tgt, rx717_tgt, rx717_off
  rx717_start:
    eq $I10, 1, rx717_restart
    if_null rx717_debug, debug_708
    rx717_cur."!cursor_debug"("START", "declarator")
  debug_708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan722_done
    goto rxscan722_scan
  rxscan722_loop:
    (rx717_pos) = rx717_cur."from"()
    inc rx717_pos
    rx717_cur."!cursor_from"(rx717_pos)
    ge rx717_pos, rx717_eos, rxscan722_done
  rxscan722_scan:
    set_addr $I10, rxscan722_loop
    rx717_cur."!mark_push"(0, rx717_pos, $I10)
  rxscan722_done:
  alt723_0:
.annotate 'line', 337
    set_addr $I10, alt723_1
    rx717_cur."!mark_push"(0, rx717_pos, $I10)
.annotate 'line', 338
  # rx subrule "variable_declarator" subtype=capture negate=
    rx717_cur."!cursor_pos"(rx717_pos)
    $P10 = rx717_cur."variable_declarator"()
    unless $P10, rx717_fail
    rx717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx717_pos = $P10."pos"()
    goto alt723_end
  alt723_1:
.annotate 'line', 339
  # rx subrule "routine_declarator" subtype=capture negate=
    rx717_cur."!cursor_pos"(rx717_pos)
    $P10 = rx717_cur."routine_declarator"()
    unless $P10, rx717_fail
    rx717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx717_pos = $P10."pos"()
  alt723_end:
.annotate 'line', 337
  # rx pass
    rx717_cur."!cursor_pass"(rx717_pos, "declarator")
    if_null rx717_debug, debug_709
    rx717_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx717_pos)
  debug_709:
    .return (rx717_cur)
  rx717_restart:
.annotate 'line', 4
    if_null rx717_debug, debug_710
    rx717_cur."!cursor_debug"("NEXT", "declarator")
  debug_710:
  rx717_fail:
    (rx717_rep, rx717_pos, $I10, $P10) = rx717_cur."!mark_fail"(0)
    lt rx717_pos, -1, rx717_done
    eq rx717_pos, -1, rx717_fail
    jump $I10
  rx717_done:
    rx717_cur."!cursor_fail"()
    if_null rx717_debug, debug_711
    rx717_cur."!cursor_debug"("FAIL", "declarator")
  debug_711:
    .return (rx717_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("160_1297619321.796") :method
.annotate 'line', 4
    $P719 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P720 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P721, "ResizablePMCArray"
    push $P721, $P719
    push $P721, $P720
    .return ($P721)
.end


.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("161_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx725_tgt
    .local int rx725_pos
    .local int rx725_off
    .local int rx725_eos
    .local int rx725_rep
    .local pmc rx725_cur
    .local pmc rx725_debug
    (rx725_cur, rx725_pos, rx725_tgt, $I10) = self."!cursor_start"()
    rx725_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx725_cur
    .local pmc match
    .lex "$/", match
    length rx725_eos, rx725_tgt
    gt rx725_pos, rx725_eos, rx725_done
    set rx725_off, 0
    lt rx725_pos, 2, rx725_start
    sub rx725_off, rx725_pos, 1
    substr rx725_tgt, rx725_tgt, rx725_off
  rx725_start:
    eq $I10, 1, rx725_restart
    if_null rx725_debug, debug_712
    rx725_cur."!cursor_debug"("START", "variable_declarator")
  debug_712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan729_done
    goto rxscan729_scan
  rxscan729_loop:
    (rx725_pos) = rx725_cur."from"()
    inc rx725_pos
    rx725_cur."!cursor_from"(rx725_pos)
    ge rx725_pos, rx725_eos, rxscan729_done
  rxscan729_scan:
    set_addr $I10, rxscan729_loop
    rx725_cur."!mark_push"(0, rx725_pos, $I10)
  rxscan729_done:
.annotate 'line', 342
  # rx subrule "ws" subtype=method negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."ws"()
    unless $P10, rx725_fail
    rx725_pos = $P10."pos"()
  # rx rxquantr731 ** 0..1
    set_addr $I10, rxquantr731_done
    rx725_cur."!mark_push"(0, rx725_pos, $I10)
  rxquantr731_loop:
  # rx subrule "typename" subtype=capture negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."typename"()
    unless $P10, rx725_fail
    goto rxsubrule732_pass
  rxsubrule732_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx725_fail
  rxsubrule732_pass:
    set_addr $I10, rxsubrule732_back
    rx725_cur."!mark_push"(0, rx725_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx725_pos = $P10."pos"()
    set_addr $I10, rxquantr731_done
    (rx725_rep) = rx725_cur."!mark_commit"($I10)
  rxquantr731_done:
  # rx subrule "ws" subtype=method negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."ws"()
    unless $P10, rx725_fail
    rx725_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."variable"()
    unless $P10, rx725_fail
    rx725_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx725_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."ws"()
    unless $P10, rx725_fail
    rx725_pos = $P10."pos"()
  # rx pass
    rx725_cur."!cursor_pass"(rx725_pos, "variable_declarator")
    if_null rx725_debug, debug_713
    rx725_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx725_pos)
  debug_713:
    .return (rx725_cur)
  rx725_restart:
.annotate 'line', 4
    if_null rx725_debug, debug_714
    rx725_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_714:
  rx725_fail:
    (rx725_rep, rx725_pos, $I10, $P10) = rx725_cur."!mark_fail"(0)
    lt rx725_pos, -1, rx725_done
    eq rx725_pos, -1, rx725_fail
    jump $I10
  rx725_done:
    rx725_cur."!cursor_fail"()
    if_null rx725_debug, debug_715
    rx725_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_715:
    .return (rx725_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("162_1297619321.796") :method
.annotate 'line', 4
    $P727 = self."!PREFIX__!subrule"("ws", "")
    new $P728, "ResizablePMCArray"
    push $P728, $P727
    .return ($P728)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("163_1297619321.796")
    .param pmc param_736
.annotate 'line', 344
    .lex "self", param_736
    $P737 = param_736."!protoregex"("routine_declarator")
    .return ($P737)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("164_1297619321.796")
    .param pmc param_739
.annotate 'line', 344
    .lex "self", param_739
    $P740 = param_739."!PREFIX__!protoregex"("routine_declarator")
    .return ($P740)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("165_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx742_tgt
    .local int rx742_pos
    .local int rx742_off
    .local int rx742_eos
    .local int rx742_rep
    .local pmc rx742_cur
    .local pmc rx742_debug
    (rx742_cur, rx742_pos, rx742_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx742_cur
    .local pmc match
    .lex "$/", match
    length rx742_eos, rx742_tgt
    gt rx742_pos, rx742_eos, rx742_done
    set rx742_off, 0
    lt rx742_pos, 2, rx742_start
    sub rx742_off, rx742_pos, 1
    substr rx742_tgt, rx742_tgt, rx742_off
  rx742_start:
    eq $I10, 1, rx742_restart
    if_null rx742_debug, debug_716
    rx742_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_716:
    $I10 = self.'from'()
    ne $I10, -1, rxscan746_done
    goto rxscan746_scan
  rxscan746_loop:
    (rx742_pos) = rx742_cur."from"()
    inc rx742_pos
    rx742_cur."!cursor_from"(rx742_pos)
    ge rx742_pos, rx742_eos, rxscan746_done
  rxscan746_scan:
    set_addr $I10, rxscan746_loop
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  rxscan746_done:
.annotate 'line', 345
  # rx subcapture "sym"
    set_addr $I10, rxcap_747_fail
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  # rx literal  "sub"
    add $I11, rx742_pos, 3
    gt $I11, rx742_eos, rx742_fail
    sub $I11, rx742_pos, rx742_off
    substr $S10, rx742_tgt, $I11, 3
    ne $S10, "sub", rx742_fail
    add rx742_pos, 3
    set_addr $I10, rxcap_747_fail
    ($I12, $I11) = rx742_cur."!mark_peek"($I10)
    rx742_cur."!cursor_pos"($I11)
    ($P10) = rx742_cur."!cursor_start"()
    $P10."!cursor_pass"(rx742_pos, "")
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_747_done
  rxcap_747_fail:
    goto rx742_fail
  rxcap_747_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx742_cur."!cursor_pos"(rx742_pos)
    $P10 = rx742_cur."routine_def"()
    unless $P10, rx742_fail
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx742_pos = $P10."pos"()
  # rx pass
    rx742_cur."!cursor_pass"(rx742_pos, "routine_declarator:sym<sub>")
    if_null rx742_debug, debug_717
    rx742_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx742_pos)
  debug_717:
    .return (rx742_cur)
  rx742_restart:
.annotate 'line', 4
    if_null rx742_debug, debug_718
    rx742_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_718:
  rx742_fail:
    (rx742_rep, rx742_pos, $I10, $P10) = rx742_cur."!mark_fail"(0)
    lt rx742_pos, -1, rx742_done
    eq rx742_pos, -1, rx742_fail
    jump $I10
  rx742_done:
    rx742_cur."!cursor_fail"()
    if_null rx742_debug, debug_719
    rx742_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_719:
    .return (rx742_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("166_1297619321.796") :method
.annotate 'line', 4
    $P744 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P745, "ResizablePMCArray"
    push $P745, $P744
    .return ($P745)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("167_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx749_tgt
    .local int rx749_pos
    .local int rx749_off
    .local int rx749_eos
    .local int rx749_rep
    .local pmc rx749_cur
    .local pmc rx749_debug
    (rx749_cur, rx749_pos, rx749_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx749_cur
    .local pmc match
    .lex "$/", match
    length rx749_eos, rx749_tgt
    gt rx749_pos, rx749_eos, rx749_done
    set rx749_off, 0
    lt rx749_pos, 2, rx749_start
    sub rx749_off, rx749_pos, 1
    substr rx749_tgt, rx749_tgt, rx749_off
  rx749_start:
    eq $I10, 1, rx749_restart
    if_null rx749_debug, debug_720
    rx749_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_720:
    $I10 = self.'from'()
    ne $I10, -1, rxscan753_done
    goto rxscan753_scan
  rxscan753_loop:
    (rx749_pos) = rx749_cur."from"()
    inc rx749_pos
    rx749_cur."!cursor_from"(rx749_pos)
    ge rx749_pos, rx749_eos, rxscan753_done
  rxscan753_scan:
    set_addr $I10, rxscan753_loop
    rx749_cur."!mark_push"(0, rx749_pos, $I10)
  rxscan753_done:
.annotate 'line', 346
  # rx subcapture "sym"
    set_addr $I10, rxcap_754_fail
    rx749_cur."!mark_push"(0, rx749_pos, $I10)
  # rx literal  "method"
    add $I11, rx749_pos, 6
    gt $I11, rx749_eos, rx749_fail
    sub $I11, rx749_pos, rx749_off
    substr $S10, rx749_tgt, $I11, 6
    ne $S10, "method", rx749_fail
    add rx749_pos, 6
    set_addr $I10, rxcap_754_fail
    ($I12, $I11) = rx749_cur."!mark_peek"($I10)
    rx749_cur."!cursor_pos"($I11)
    ($P10) = rx749_cur."!cursor_start"()
    $P10."!cursor_pass"(rx749_pos, "")
    rx749_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_754_done
  rxcap_754_fail:
    goto rx749_fail
  rxcap_754_done:
  # rx subrule "method_def" subtype=capture negate=
    rx749_cur."!cursor_pos"(rx749_pos)
    $P10 = rx749_cur."method_def"()
    unless $P10, rx749_fail
    rx749_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx749_pos = $P10."pos"()
  # rx pass
    rx749_cur."!cursor_pass"(rx749_pos, "routine_declarator:sym<method>")
    if_null rx749_debug, debug_721
    rx749_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx749_pos)
  debug_721:
    .return (rx749_cur)
  rx749_restart:
.annotate 'line', 4
    if_null rx749_debug, debug_722
    rx749_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_722:
  rx749_fail:
    (rx749_rep, rx749_pos, $I10, $P10) = rx749_cur."!mark_fail"(0)
    lt rx749_pos, -1, rx749_done
    eq rx749_pos, -1, rx749_fail
    jump $I10
  rx749_done:
    rx749_cur."!cursor_fail"()
    if_null rx749_debug, debug_723
    rx749_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_723:
    .return (rx749_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("168_1297619321.796") :method
.annotate 'line', 4
    $P751 = self."!PREFIX__!subrule"("method_def", "method")
    new $P752, "ResizablePMCArray"
    push $P752, $P751
    .return ($P752)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("169_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 349
    new $P756, "Undef"
    .lex "$*RETURN_USED", $P756
.annotate 'line', 4
    .local string rx757_tgt
    .local int rx757_pos
    .local int rx757_off
    .local int rx757_eos
    .local int rx757_rep
    .local pmc rx757_cur
    .local pmc rx757_debug
    (rx757_cur, rx757_pos, rx757_tgt, $I10) = self."!cursor_start"()
    rx757_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx757_cur
    .local pmc match
    .lex "$/", match
    length rx757_eos, rx757_tgt
    gt rx757_pos, rx757_eos, rx757_done
    set rx757_off, 0
    lt rx757_pos, 2, rx757_start
    sub rx757_off, rx757_pos, 1
    substr rx757_tgt, rx757_tgt, rx757_off
  rx757_start:
    eq $I10, 1, rx757_restart
    if_null rx757_debug, debug_724
    rx757_cur."!cursor_debug"("START", "routine_def")
  debug_724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan761_done
    goto rxscan761_scan
  rxscan761_loop:
    (rx757_pos) = rx757_cur."from"()
    inc rx757_pos
    rx757_cur."!cursor_from"(rx757_pos)
    ge rx757_pos, rx757_eos, rxscan761_done
  rxscan761_scan:
    set_addr $I10, rxscan761_loop
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxscan761_done:
.annotate 'line', 348
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
.annotate 'line', 349
    rx757_cur."!cursor_pos"(rx757_pos)
    new $P763, "Integer"
    assign $P763, 0
    store_lex "$*RETURN_USED", $P763
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
.annotate 'line', 350
  # rx rxquantr765 ** 0..1
    set_addr $I10, rxquantr765_done
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxquantr765_loop:
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_768_fail
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  # rx rxquantr767 ** 0..1
    set_addr $I10, rxquantr767_done
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxquantr767_loop:
  # rx literal  "&"
    add $I11, rx757_pos, 1
    gt $I11, rx757_eos, rx757_fail
    sub $I11, rx757_pos, rx757_off
    ord $I11, rx757_tgt, $I11
    ne $I11, 38, rx757_fail
    add rx757_pos, 1
    set_addr $I10, rxquantr767_done
    (rx757_rep) = rx757_cur."!mark_commit"($I10)
  rxquantr767_done:
    set_addr $I10, rxcap_768_fail
    ($I12, $I11) = rx757_cur."!mark_peek"($I10)
    rx757_cur."!cursor_pos"($I11)
    ($P10) = rx757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx757_pos, "")
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_768_done
  rxcap_768_fail:
    goto rx757_fail
  rxcap_768_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."deflongname"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
    set_addr $I10, rxquantr765_done
    (rx757_rep) = rx757_cur."!mark_commit"($I10)
  rxquantr765_done:
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
.annotate 'line', 351
  # rx subrule "newpad" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."newpad"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  alt772_0:
.annotate 'line', 352
    set_addr $I10, alt772_1
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx757_pos, 1
    gt $I11, rx757_eos, rx757_fail
    sub $I11, rx757_pos, rx757_off
    ord $I11, rx757_tgt, $I11
    ne $I11, 40, rx757_fail
    add rx757_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."signature"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx757_pos, 1
    gt $I11, rx757_eos, rx757_fail
    sub $I11, rx757_pos, rx757_off
    ord $I11, rx757_tgt, $I11
    ne $I11, 41, rx757_fail
    add rx757_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
    goto alt772_end
  alt772_1:
.annotate 'line', 353
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  alt772_end:
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
.annotate 'line', 354
  # rx rxquantr780 ** 0..*
    set_addr $I10, rxquantr780_done
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxquantr780_loop:
  # rx subrule "trait" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."trait"()
    unless $P10, rx757_fail
    goto rxsubrule781_pass
  rxsubrule781_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx757_fail
  rxsubrule781_pass:
    set_addr $I10, rxsubrule781_back
    rx757_cur."!mark_push"(0, rx757_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx757_pos = $P10."pos"()
    set_addr $I10, rxquantr780_done
    (rx757_rep) = rx757_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr780_done
    rx757_cur."!mark_push"(rx757_rep, rx757_pos, $I10)
    goto rxquantr780_loop
  rxquantr780_done:
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  alt783_0:
.annotate 'line', 355
    set_addr $I10, alt783_1
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
.annotate 'line', 356
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."onlystar"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
    goto alt783_end
  alt783_1:
.annotate 'line', 357
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."blockoid"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx757_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
  alt783_end:
.annotate 'line', 358
  # rx subrule "ws" subtype=method negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."ws"()
    unless $P10, rx757_fail
    rx757_pos = $P10."pos"()
.annotate 'line', 348
  # rx pass
    rx757_cur."!cursor_pass"(rx757_pos, "routine_def")
    if_null rx757_debug, debug_725
    rx757_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx757_pos)
  debug_725:
    .return (rx757_cur)
  rx757_restart:
.annotate 'line', 4
    if_null rx757_debug, debug_726
    rx757_cur."!cursor_debug"("NEXT", "routine_def")
  debug_726:
  rx757_fail:
    (rx757_rep, rx757_pos, $I10, $P10) = rx757_cur."!mark_fail"(0)
    lt rx757_pos, -1, rx757_done
    eq rx757_pos, -1, rx757_fail
    jump $I10
  rx757_done:
    rx757_cur."!cursor_fail"()
    if_null rx757_debug, debug_727
    rx757_cur."!cursor_debug"("FAIL", "routine_def")
  debug_727:
    .return (rx757_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("170_1297619321.796") :method
.annotate 'line', 4
    $P759 = self."!PREFIX__!subrule"("ws", "")
    new $P760, "ResizablePMCArray"
    push $P760, $P759
    .return ($P760)
.end


.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("171_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P820 = "173_1297619321.796" 
    capture_lex $P820
.annotate 'line', 362
    new $P790, "Undef"
    .lex "$*RETURN_USED", $P790
.annotate 'line', 363
    new $P791, "Undef"
    .lex "$*INVOCANT_OK", $P791
.annotate 'line', 4
    .local string rx792_tgt
    .local int rx792_pos
    .local int rx792_off
    .local int rx792_eos
    .local int rx792_rep
    .local pmc rx792_cur
    .local pmc rx792_debug
    (rx792_cur, rx792_pos, rx792_tgt, $I10) = self."!cursor_start"()
    rx792_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx792_cur
    .local pmc match
    .lex "$/", match
    length rx792_eos, rx792_tgt
    gt rx792_pos, rx792_eos, rx792_done
    set rx792_off, 0
    lt rx792_pos, 2, rx792_start
    sub rx792_off, rx792_pos, 1
    substr rx792_tgt, rx792_tgt, rx792_off
  rx792_start:
    eq $I10, 1, rx792_restart
    if_null rx792_debug, debug_728
    rx792_cur."!cursor_debug"("START", "method_def")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan796_done
    goto rxscan796_scan
  rxscan796_loop:
    (rx792_pos) = rx792_cur."from"()
    inc rx792_pos
    rx792_cur."!cursor_from"(rx792_pos)
    ge rx792_pos, rx792_eos, rxscan796_done
  rxscan796_scan:
    set_addr $I10, rxscan796_loop
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxscan796_done:
.annotate 'line', 361
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 362
    rx792_cur."!cursor_pos"(rx792_pos)
    new $P798, "Integer"
    assign $P798, 0
    store_lex "$*RETURN_USED", $P798
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 363
    rx792_cur."!cursor_pos"(rx792_pos)
    new $P800, "Integer"
    assign $P800, 1
    store_lex "$*INVOCANT_OK", $P800
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 364
  # rx subcapture "private"
    set_addr $I10, rxcap_803_fail
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  # rx rxquantr802 ** 0..1
    set_addr $I10, rxquantr802_done
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxquantr802_loop:
  # rx literal  "!"
    add $I11, rx792_pos, 1
    gt $I11, rx792_eos, rx792_fail
    sub $I11, rx792_pos, rx792_off
    ord $I11, rx792_tgt, $I11
    ne $I11, 33, rx792_fail
    add rx792_pos, 1
    set_addr $I10, rxquantr802_done
    (rx792_rep) = rx792_cur."!mark_commit"($I10)
  rxquantr802_done:
    set_addr $I10, rxcap_803_fail
    ($I12, $I11) = rx792_cur."!mark_peek"($I10)
    rx792_cur."!cursor_pos"($I11)
    ($P10) = rx792_cur."!cursor_start"()
    $P10."!cursor_pass"(rx792_pos, "")
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_803_done
  rxcap_803_fail:
    goto rx792_fail
  rxcap_803_done:
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 365
  # rx rxquantr805 ** 0..1
    set_addr $I10, rxquantr805_done
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxquantr805_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."deflongname"()
    unless $P10, rx792_fail
    goto rxsubrule806_pass
  rxsubrule806_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx792_fail
  rxsubrule806_pass:
    set_addr $I10, rxsubrule806_back
    rx792_cur."!mark_push"(0, rx792_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx792_pos = $P10."pos"()
    set_addr $I10, rxquantr805_done
    (rx792_rep) = rx792_cur."!mark_commit"($I10)
  rxquantr805_done:
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 366
  # rx subrule "newpad" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."newpad"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  alt809_0:
.annotate 'line', 367
    set_addr $I10, alt809_1
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx792_pos, 1
    gt $I11, rx792_eos, rx792_fail
    sub $I11, rx792_pos, rx792_off
    ord $I11, rx792_tgt, $I11
    ne $I11, 40, rx792_fail
    add rx792_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."signature"()
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx792_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx792_pos, 1
    gt $I11, rx792_eos, rx792_fail
    sub $I11, rx792_pos, rx792_off
    ord $I11, rx792_tgt, $I11
    ne $I11, 41, rx792_fail
    add rx792_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
    goto alt809_end
  alt809_1:
.annotate 'line', 368
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  alt809_end:
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 369
    rx792_cur."!cursor_pos"(rx792_pos)
    find_lex $P817, unicode:"$\x{a2}"
    $P818 = $P817."MATCH"()
    store_lex "$/", $P818
    .const 'Sub' $P820 = "173_1297619321.796" 
    capture_lex $P820
    $P822 = $P820()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 370
  # rx rxquantr824 ** 0..*
    set_addr $I10, rxquantr824_done
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxquantr824_loop:
  # rx subrule "trait" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."trait"()
    unless $P10, rx792_fail
    goto rxsubrule825_pass
  rxsubrule825_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx792_fail
  rxsubrule825_pass:
    set_addr $I10, rxsubrule825_back
    rx792_cur."!mark_push"(0, rx792_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx792_pos = $P10."pos"()
    set_addr $I10, rxquantr824_done
    (rx792_rep) = rx792_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr824_done
    rx792_cur."!mark_push"(rx792_rep, rx792_pos, $I10)
    goto rxquantr824_loop
  rxquantr824_done:
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  alt827_0:
.annotate 'line', 371
    set_addr $I10, alt827_1
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
.annotate 'line', 372
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."onlystar"()
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx792_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
    goto alt827_end
  alt827_1:
.annotate 'line', 373
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."blockoid"()
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx792_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
  alt827_end:
.annotate 'line', 374
  # rx subrule "ws" subtype=method negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."ws"()
    unless $P10, rx792_fail
    rx792_pos = $P10."pos"()
.annotate 'line', 361
  # rx pass
    rx792_cur."!cursor_pass"(rx792_pos, "method_def")
    if_null rx792_debug, debug_729
    rx792_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx792_pos)
  debug_729:
    .return (rx792_cur)
  rx792_restart:
.annotate 'line', 4
    if_null rx792_debug, debug_730
    rx792_cur."!cursor_debug"("NEXT", "method_def")
  debug_730:
  rx792_fail:
    (rx792_rep, rx792_pos, $I10, $P10) = rx792_cur."!mark_fail"(0)
    lt rx792_pos, -1, rx792_done
    eq rx792_pos, -1, rx792_fail
    jump $I10
  rx792_done:
    rx792_cur."!cursor_fail"()
    if_null rx792_debug, debug_731
    rx792_cur."!cursor_debug"("FAIL", "method_def")
  debug_731:
    .return (rx792_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("172_1297619321.796") :method
.annotate 'line', 4
    $P794 = self."!PREFIX__!subrule"("ws", "")
    new $P795, "ResizablePMCArray"
    push $P795, $P794
    .return ($P795)
.end


.namespace ["NQP";"Grammar"]
.sub "_block819"  :anon :subid("173_1297619321.796") :outer("171_1297619321.796")
.annotate 'line', 369
    new $P821, "Integer"
    assign $P821, 0
    store_dynamic_lex "$*INVOCANT_OK", $P821
    .return ($P821)
.end


.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("174_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P841 = "176_1297619321.796" 
    capture_lex $P841
    .local string rx834_tgt
    .local int rx834_pos
    .local int rx834_off
    .local int rx834_eos
    .local int rx834_rep
    .local pmc rx834_cur
    .local pmc rx834_debug
    (rx834_cur, rx834_pos, rx834_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx834_cur
    .local pmc match
    .lex "$/", match
    length rx834_eos, rx834_tgt
    gt rx834_pos, rx834_eos, rx834_done
    set rx834_off, 0
    lt rx834_pos, 2, rx834_start
    sub rx834_off, rx834_pos, 1
    substr rx834_tgt, rx834_tgt, rx834_off
  rx834_start:
    eq $I10, 1, rx834_restart
    if_null rx834_debug, debug_732
    rx834_cur."!cursor_debug"("START", "onlystar")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan837_done
    goto rxscan837_scan
  rxscan837_loop:
    (rx834_pos) = rx834_cur."from"()
    inc rx834_pos
    rx834_cur."!cursor_from"(rx834_pos)
    ge rx834_pos, rx834_eos, rxscan837_done
  rxscan837_scan:
    set_addr $I10, rxscan837_loop
    rx834_cur."!mark_push"(0, rx834_pos, $I10)
  rxscan837_done:
.annotate 'line', 378
    rx834_cur."!cursor_pos"(rx834_pos)
    find_lex $P838, unicode:"$\x{a2}"
    $P839 = $P838."MATCH"()
    store_lex "$/", $P839
    .const 'Sub' $P841 = "176_1297619321.796" 
    capture_lex $P841
    $P845 = $P841()
    unless $P845, rx834_fail
.annotate 'line', 379
  # rx literal  "{"
    add $I11, rx834_pos, 1
    gt $I11, rx834_eos, rx834_fail
    sub $I11, rx834_pos, rx834_off
    ord $I11, rx834_tgt, $I11
    ne $I11, 123, rx834_fail
    add rx834_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx834_cur."!cursor_pos"(rx834_pos)
    $P10 = rx834_cur."ws"()
    unless $P10, rx834_fail
    rx834_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx834_pos, 1
    gt $I11, rx834_eos, rx834_fail
    sub $I11, rx834_pos, rx834_off
    ord $I11, rx834_tgt, $I11
    ne $I11, 42, rx834_fail
    add rx834_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx834_cur."!cursor_pos"(rx834_pos)
    $P10 = rx834_cur."ws"()
    unless $P10, rx834_fail
    rx834_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx834_pos, 1
    gt $I11, rx834_eos, rx834_fail
    sub $I11, rx834_pos, rx834_off
    ord $I11, rx834_tgt, $I11
    ne $I11, 125, rx834_fail
    add rx834_pos, 1
.annotate 'line', 380
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx834_cur."!cursor_pos"(rx834_pos)
    $P10 = rx834_cur."ENDSTMT"()
    unless $P10, rx834_fail
.annotate 'line', 381
  # rx subrule "finishpad" subtype=method negate=
    rx834_cur."!cursor_pos"(rx834_pos)
    $P10 = rx834_cur."finishpad"()
    unless $P10, rx834_fail
    rx834_pos = $P10."pos"()
.annotate 'line', 377
  # rx pass
    rx834_cur."!cursor_pass"(rx834_pos, "onlystar")
    if_null rx834_debug, debug_735
    rx834_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx834_pos)
  debug_735:
    .return (rx834_cur)
  rx834_restart:
.annotate 'line', 4
    if_null rx834_debug, debug_736
    rx834_cur."!cursor_debug"("NEXT", "onlystar")
  debug_736:
  rx834_fail:
    (rx834_rep, rx834_pos, $I10, $P10) = rx834_cur."!mark_fail"(0)
    lt rx834_pos, -1, rx834_done
    eq rx834_pos, -1, rx834_fail
    jump $I10
  rx834_done:
    rx834_cur."!cursor_fail"()
    if_null rx834_debug, debug_737
    rx834_cur."!cursor_debug"("FAIL", "onlystar")
  debug_737:
    .return (rx834_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("175_1297619321.796") :method
.annotate 'line', 4
    new $P836, "ResizablePMCArray"
    push $P836, ""
    .return ($P836)
.end


.namespace ["NQP";"Grammar"]
.sub "_block840"  :anon :subid("176_1297619321.796") :outer("174_1297619321.796")
.annotate 'line', 378
    find_dynamic_lex $P842, "$*MULTINESS"
    unless_null $P842, vivify_733
    get_hll_global $P842, "$MULTINESS"
    unless_null $P842, vivify_734
    die "Contextual $*MULTINESS not found"
  vivify_734:
  vivify_733:
    set $S843, $P842
    iseq $I844, $S843, "proto"
    .return ($I844)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("177_1297619321.796")
    .param pmc param_847
.annotate 'line', 384
    .lex "self", param_847
    $P848 = param_847."!protoregex"("multi_declarator")
    .return ($P848)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("178_1297619321.796")
    .param pmc param_850
.annotate 'line', 384
    .lex "self", param_850
    $P851 = param_850."!PREFIX__!protoregex"("multi_declarator")
    .return ($P851)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("179_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 386
    new $P853, "Undef"
    .lex "$*MULTINESS", $P853
.annotate 'line', 4
    .local string rx854_tgt
    .local int rx854_pos
    .local int rx854_off
    .local int rx854_eos
    .local int rx854_rep
    .local pmc rx854_cur
    .local pmc rx854_debug
    (rx854_cur, rx854_pos, rx854_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx854_cur
    .local pmc match
    .lex "$/", match
    length rx854_eos, rx854_tgt
    gt rx854_pos, rx854_eos, rx854_done
    set rx854_off, 0
    lt rx854_pos, 2, rx854_start
    sub rx854_off, rx854_pos, 1
    substr rx854_tgt, rx854_tgt, rx854_off
  rx854_start:
    eq $I10, 1, rx854_restart
    if_null rx854_debug, debug_738
    rx854_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_738:
    $I10 = self.'from'()
    ne $I10, -1, rxscan858_done
    goto rxscan858_scan
  rxscan858_loop:
    (rx854_pos) = rx854_cur."from"()
    inc rx854_pos
    rx854_cur."!cursor_from"(rx854_pos)
    ge rx854_pos, rx854_eos, rxscan858_done
  rxscan858_scan:
    set_addr $I10, rxscan858_loop
    rx854_cur."!mark_push"(0, rx854_pos, $I10)
  rxscan858_done:
.annotate 'line', 386
    rx854_cur."!cursor_pos"(rx854_pos)
    new $P859, "String"
    assign $P859, "multi"
    store_lex "$*MULTINESS", $P859
.annotate 'line', 387
  # rx subcapture "sym"
    set_addr $I10, rxcap_860_fail
    rx854_cur."!mark_push"(0, rx854_pos, $I10)
  # rx literal  "multi"
    add $I11, rx854_pos, 5
    gt $I11, rx854_eos, rx854_fail
    sub $I11, rx854_pos, rx854_off
    substr $S10, rx854_tgt, $I11, 5
    ne $S10, "multi", rx854_fail
    add rx854_pos, 5
    set_addr $I10, rxcap_860_fail
    ($I12, $I11) = rx854_cur."!mark_peek"($I10)
    rx854_cur."!cursor_pos"($I11)
    ($P10) = rx854_cur."!cursor_start"()
    $P10."!cursor_pass"(rx854_pos, "")
    rx854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_860_done
  rxcap_860_fail:
    goto rx854_fail
  rxcap_860_done:
.annotate 'line', 388
  # rx subrule "ws" subtype=method negate=
    rx854_cur."!cursor_pos"(rx854_pos)
    $P10 = rx854_cur."ws"()
    unless $P10, rx854_fail
    rx854_pos = $P10."pos"()
  alt861_0:
    set_addr $I10, alt861_1
    rx854_cur."!mark_push"(0, rx854_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx854_cur."!cursor_pos"(rx854_pos)
    $P10 = rx854_cur."declarator"()
    unless $P10, rx854_fail
    rx854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx854_pos = $P10."pos"()
    goto alt861_end
  alt861_1:
    set_addr $I10, alt861_2
    rx854_cur."!mark_push"(0, rx854_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx854_cur."!cursor_pos"(rx854_pos)
    $P10 = rx854_cur."routine_def"()
    unless $P10, rx854_fail
    rx854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx854_pos = $P10."pos"()
    goto alt861_end
  alt861_2:
  # rx subrule "panic" subtype=method negate=
    rx854_cur."!cursor_pos"(rx854_pos)
    $P10 = rx854_cur."panic"("Malformed multi")
    unless $P10, rx854_fail
    rx854_pos = $P10."pos"()
  alt861_end:
.annotate 'line', 385
  # rx pass
    rx854_cur."!cursor_pass"(rx854_pos, "multi_declarator:sym<multi>")
    if_null rx854_debug, debug_739
    rx854_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx854_pos)
  debug_739:
    .return (rx854_cur)
  rx854_restart:
.annotate 'line', 4
    if_null rx854_debug, debug_740
    rx854_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_740:
  rx854_fail:
    (rx854_rep, rx854_pos, $I10, $P10) = rx854_cur."!mark_fail"(0)
    lt rx854_pos, -1, rx854_done
    eq rx854_pos, -1, rx854_fail
    jump $I10
  rx854_done:
    rx854_cur."!cursor_fail"()
    if_null rx854_debug, debug_741
    rx854_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_741:
    .return (rx854_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("180_1297619321.796") :method
.annotate 'line', 4
    $P856 = self."!PREFIX__!subrule"("ws", "multi")
    new $P857, "ResizablePMCArray"
    push $P857, $P856
    .return ($P857)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("181_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 391
    new $P863, "Undef"
    .lex "$*MULTINESS", $P863
.annotate 'line', 4
    .local string rx864_tgt
    .local int rx864_pos
    .local int rx864_off
    .local int rx864_eos
    .local int rx864_rep
    .local pmc rx864_cur
    .local pmc rx864_debug
    (rx864_cur, rx864_pos, rx864_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx864_cur
    .local pmc match
    .lex "$/", match
    length rx864_eos, rx864_tgt
    gt rx864_pos, rx864_eos, rx864_done
    set rx864_off, 0
    lt rx864_pos, 2, rx864_start
    sub rx864_off, rx864_pos, 1
    substr rx864_tgt, rx864_tgt, rx864_off
  rx864_start:
    eq $I10, 1, rx864_restart
    if_null rx864_debug, debug_742
    rx864_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_742:
    $I10 = self.'from'()
    ne $I10, -1, rxscan868_done
    goto rxscan868_scan
  rxscan868_loop:
    (rx864_pos) = rx864_cur."from"()
    inc rx864_pos
    rx864_cur."!cursor_from"(rx864_pos)
    ge rx864_pos, rx864_eos, rxscan868_done
  rxscan868_scan:
    set_addr $I10, rxscan868_loop
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  rxscan868_done:
.annotate 'line', 391
    rx864_cur."!cursor_pos"(rx864_pos)
    new $P869, "String"
    assign $P869, "proto"
    store_lex "$*MULTINESS", $P869
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_870_fail
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx literal  "proto"
    add $I11, rx864_pos, 5
    gt $I11, rx864_eos, rx864_fail
    sub $I11, rx864_pos, rx864_off
    substr $S10, rx864_tgt, $I11, 5
    ne $S10, "proto", rx864_fail
    add rx864_pos, 5
    set_addr $I10, rxcap_870_fail
    ($I12, $I11) = rx864_cur."!mark_peek"($I10)
    rx864_cur."!cursor_pos"($I11)
    ($P10) = rx864_cur."!cursor_start"()
    $P10."!cursor_pass"(rx864_pos, "")
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_870_done
  rxcap_870_fail:
    goto rx864_fail
  rxcap_870_done:
.annotate 'line', 393
  # rx subrule "ws" subtype=method negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."ws"()
    unless $P10, rx864_fail
    rx864_pos = $P10."pos"()
  alt871_0:
    set_addr $I10, alt871_1
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."declarator"()
    unless $P10, rx864_fail
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx864_pos = $P10."pos"()
    goto alt871_end
  alt871_1:
    set_addr $I10, alt871_2
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."routine_def"()
    unless $P10, rx864_fail
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx864_pos = $P10."pos"()
    goto alt871_end
  alt871_2:
  # rx subrule "panic" subtype=method negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."panic"("Malformed proto")
    unless $P10, rx864_fail
    rx864_pos = $P10."pos"()
  alt871_end:
.annotate 'line', 390
  # rx pass
    rx864_cur."!cursor_pass"(rx864_pos, "multi_declarator:sym<proto>")
    if_null rx864_debug, debug_743
    rx864_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx864_pos)
  debug_743:
    .return (rx864_cur)
  rx864_restart:
.annotate 'line', 4
    if_null rx864_debug, debug_744
    rx864_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_744:
  rx864_fail:
    (rx864_rep, rx864_pos, $I10, $P10) = rx864_cur."!mark_fail"(0)
    lt rx864_pos, -1, rx864_done
    eq rx864_pos, -1, rx864_fail
    jump $I10
  rx864_done:
    rx864_cur."!cursor_fail"()
    if_null rx864_debug, debug_745
    rx864_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_745:
    .return (rx864_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("182_1297619321.796") :method
.annotate 'line', 4
    $P866 = self."!PREFIX__!subrule"("ws", "proto")
    new $P867, "ResizablePMCArray"
    push $P867, $P866
    .return ($P867)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("183_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 396
    new $P873, "Undef"
    .lex "$*MULTINESS", $P873
.annotate 'line', 4
    .local string rx874_tgt
    .local int rx874_pos
    .local int rx874_off
    .local int rx874_eos
    .local int rx874_rep
    .local pmc rx874_cur
    .local pmc rx874_debug
    (rx874_cur, rx874_pos, rx874_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx874_cur
    .local pmc match
    .lex "$/", match
    length rx874_eos, rx874_tgt
    gt rx874_pos, rx874_eos, rx874_done
    set rx874_off, 0
    lt rx874_pos, 2, rx874_start
    sub rx874_off, rx874_pos, 1
    substr rx874_tgt, rx874_tgt, rx874_off
  rx874_start:
    eq $I10, 1, rx874_restart
    if_null rx874_debug, debug_746
    rx874_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_746:
    $I10 = self.'from'()
    ne $I10, -1, rxscan878_done
    goto rxscan878_scan
  rxscan878_loop:
    (rx874_pos) = rx874_cur."from"()
    inc rx874_pos
    rx874_cur."!cursor_from"(rx874_pos)
    ge rx874_pos, rx874_eos, rxscan878_done
  rxscan878_scan:
    set_addr $I10, rxscan878_loop
    rx874_cur."!mark_push"(0, rx874_pos, $I10)
  rxscan878_done:
.annotate 'line', 396
    rx874_cur."!cursor_pos"(rx874_pos)
    new $P879, "String"
    assign $P879, ""
    store_lex "$*MULTINESS", $P879
.annotate 'line', 397
  # rx subrule "declarator" subtype=capture negate=
    rx874_cur."!cursor_pos"(rx874_pos)
    $P10 = rx874_cur."declarator"()
    unless $P10, rx874_fail
    rx874_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx874_pos = $P10."pos"()
.annotate 'line', 395
  # rx pass
    rx874_cur."!cursor_pass"(rx874_pos, "multi_declarator:sym<null>")
    if_null rx874_debug, debug_747
    rx874_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx874_pos)
  debug_747:
    .return (rx874_cur)
  rx874_restart:
.annotate 'line', 4
    if_null rx874_debug, debug_748
    rx874_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_748:
  rx874_fail:
    (rx874_rep, rx874_pos, $I10, $P10) = rx874_cur."!mark_fail"(0)
    lt rx874_pos, -1, rx874_done
    eq rx874_pos, -1, rx874_fail
    jump $I10
  rx874_done:
    rx874_cur."!cursor_fail"()
    if_null rx874_debug, debug_749
    rx874_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_749:
    .return (rx874_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("184_1297619321.796") :method
.annotate 'line', 4
    $P876 = self."!PREFIX__!subrule"("declarator", "")
    new $P877, "ResizablePMCArray"
    push $P877, $P876
    .return ($P877)
.end


.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("185_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P889 = "187_1297619321.796" 
    capture_lex $P889
    .local string rx881_tgt
    .local int rx881_pos
    .local int rx881_off
    .local int rx881_eos
    .local int rx881_rep
    .local pmc rx881_cur
    .local pmc rx881_debug
    (rx881_cur, rx881_pos, rx881_tgt, $I10) = self."!cursor_start"()
    rx881_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx881_cur
    .local pmc match
    .lex "$/", match
    length rx881_eos, rx881_tgt
    gt rx881_pos, rx881_eos, rx881_done
    set rx881_off, 0
    lt rx881_pos, 2, rx881_start
    sub rx881_off, rx881_pos, 1
    substr rx881_tgt, rx881_tgt, rx881_off
  rx881_start:
    eq $I10, 1, rx881_restart
    if_null rx881_debug, debug_750
    rx881_cur."!cursor_debug"("START", "signature")
  debug_750:
    $I10 = self.'from'()
    ne $I10, -1, rxscan884_done
    goto rxscan884_scan
  rxscan884_loop:
    (rx881_pos) = rx881_cur."from"()
    inc rx881_pos
    rx881_cur."!cursor_from"(rx881_pos)
    ge rx881_pos, rx881_eos, rxscan884_done
  rxscan884_scan:
    set_addr $I10, rxscan884_loop
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
  rxscan884_done:
.annotate 'line', 401
  # rx rxquantr885 ** 0..1
    set_addr $I10, rxquantr885_done
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
  rxquantr885_loop:
    rx881_cur."!cursor_pos"(rx881_pos)
    find_lex $P886, unicode:"$\x{a2}"
    $P887 = $P886."MATCH"()
    store_lex "$/", $P887
    .const 'Sub' $P889 = "187_1297619321.796" 
    capture_lex $P889
    $P891 = $P889()
    unless $P891, rx881_fail
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."parameter"()
    unless $P10, rx881_fail
    rx881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx881_pos, 1
    gt $I11, rx881_eos, rx881_fail
    sub $I11, rx881_pos, rx881_off
    ord $I11, rx881_tgt, $I11
    ne $I11, 58, rx881_fail
    add rx881_pos, 1
    set_addr $I10, rxquantr885_done
    (rx881_rep) = rx881_cur."!mark_commit"($I10)
  rxquantr885_done:
.annotate 'line', 402
  # rx rxquantr892 ** 0..1
    set_addr $I10, rxquantr892_done
    rx881_cur."!mark_push"(0, rx881_pos, $I10)
  rxquantr892_loop:
  # rx rxquantr893 ** 1..*
    set_addr $I10, rxquantr893_done
    rx881_cur."!mark_push"(0, -1, $I10)
  rxquantr893_loop:
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."parameter"()
    unless $P10, rx881_fail
    rx881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx881_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx881_cur."!cursor_pos"(rx881_pos)
    $P10 = rx881_cur."ws"()
    unless $P10, rx881_fail
    rx881_pos = $P10."pos"()
    set_addr $I10, rxquantr893_done
    (rx881_rep) = rx881_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr893_done
    rx881_cur."!mark_push"(rx881_rep, rx881_pos, $I10)
  # rx literal  ","
    add $I11, rx881_pos, 1
    gt $I11, rx881_eos, rx881_fail
    sub $I11, rx881_pos, rx881_off
    ord $I11, rx881_tgt, $I11
    ne $I11, 44, rx881_fail
    add rx881_pos, 1
    goto rxquantr893_loop
  rxquantr893_done:
    set_addr $I10, rxquantr892_done
    (rx881_rep) = rx881_cur."!mark_commit"($I10)
  rxquantr892_done:
.annotate 'line', 400
  # rx pass
    rx881_cur."!cursor_pass"(rx881_pos, "signature")
    if_null rx881_debug, debug_753
    rx881_cur."!cursor_debug"("PASS", "signature", " at pos=", rx881_pos)
  debug_753:
    .return (rx881_cur)
  rx881_restart:
.annotate 'line', 4
    if_null rx881_debug, debug_754
    rx881_cur."!cursor_debug"("NEXT", "signature")
  debug_754:
  rx881_fail:
    (rx881_rep, rx881_pos, $I10, $P10) = rx881_cur."!mark_fail"(0)
    lt rx881_pos, -1, rx881_done
    eq rx881_pos, -1, rx881_fail
    jump $I10
  rx881_done:
    rx881_cur."!cursor_fail"()
    if_null rx881_debug, debug_755
    rx881_cur."!cursor_debug"("FAIL", "signature")
  debug_755:
    .return (rx881_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("186_1297619321.796") :method
.annotate 'line', 4
    new $P883, "ResizablePMCArray"
    push $P883, ""
    .return ($P883)
.end


.namespace ["NQP";"Grammar"]
.sub "_block888"  :anon :subid("187_1297619321.796") :outer("185_1297619321.796")
.annotate 'line', 401
    find_dynamic_lex $P890, "$*INVOCANT_OK"
    unless_null $P890, vivify_751
    get_hll_global $P890, "$INVOCANT_OK"
    unless_null $P890, vivify_752
    die "Contextual $*INVOCANT_OK not found"
  vivify_752:
  vivify_751:
    .return ($P890)
.end


.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("188_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx895_tgt
    .local int rx895_pos
    .local int rx895_off
    .local int rx895_eos
    .local int rx895_rep
    .local pmc rx895_cur
    .local pmc rx895_debug
    (rx895_cur, rx895_pos, rx895_tgt, $I10) = self."!cursor_start"()
    rx895_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx895_cur
    .local pmc match
    .lex "$/", match
    length rx895_eos, rx895_tgt
    gt rx895_pos, rx895_eos, rx895_done
    set rx895_off, 0
    lt rx895_pos, 2, rx895_start
    sub rx895_off, rx895_pos, 1
    substr rx895_tgt, rx895_tgt, rx895_off
  rx895_start:
    eq $I10, 1, rx895_restart
    if_null rx895_debug, debug_756
    rx895_cur."!cursor_debug"("START", "parameter")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan898_done
    goto rxscan898_scan
  rxscan898_loop:
    (rx895_pos) = rx895_cur."from"()
    inc rx895_pos
    rx895_cur."!cursor_from"(rx895_pos)
    ge rx895_pos, rx895_eos, rxscan898_done
  rxscan898_scan:
    set_addr $I10, rxscan898_loop
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxscan898_done:
.annotate 'line', 406
  # rx rxquantr899 ** 0..*
    set_addr $I10, rxquantr899_done
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxquantr899_loop:
  # rx subrule "typename" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."typename"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx895_pos = $P10."pos"()
  # rx rxquantr900 ** 0..1
    set_addr $I10, rxquantr900_done
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxquantr900_loop:
  # rx literal  ":"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 58, rx895_fail
    add rx895_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_901_fail
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx895_pos, rx895_eos, rx895_fail
    sub $I10, rx895_pos, rx895_off
    substr $S10, rx895_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx895_fail
    inc rx895_pos
    set_addr $I10, rxcap_901_fail
    ($I12, $I11) = rx895_cur."!mark_peek"($I10)
    rx895_cur."!cursor_pos"($I11)
    ($P10) = rx895_cur."!cursor_start"()
    $P10."!cursor_pass"(rx895_pos, "")
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_901_done
  rxcap_901_fail:
    goto rx895_fail
  rxcap_901_done:
    set_addr $I10, rxquantr900_done
    (rx895_rep) = rx895_cur."!mark_commit"($I10)
  rxquantr900_done:
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
    set_addr $I10, rxquantr899_done
    (rx895_rep) = rx895_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr899_done
    rx895_cur."!mark_push"(rx895_rep, rx895_pos, $I10)
    goto rxquantr899_loop
  rxquantr899_done:
  alt902_0:
.annotate 'line', 407
    set_addr $I10, alt902_1
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
.annotate 'line', 408
  # rx subcapture "quant"
    set_addr $I10, rxcap_903_fail
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  # rx literal  "*"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 42, rx895_fail
    add rx895_pos, 1
    set_addr $I10, rxcap_903_fail
    ($I12, $I11) = rx895_cur."!mark_peek"($I10)
    rx895_cur."!cursor_pos"($I11)
    ($P10) = rx895_cur."!cursor_start"()
    $P10."!cursor_pass"(rx895_pos, "")
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_903_done
  rxcap_903_fail:
    goto rx895_fail
  rxcap_903_done:
  # rx subrule "param_var" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."param_var"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx895_pos = $P10."pos"()
    goto alt902_end
  alt902_1:
  alt904_0:
.annotate 'line', 409
    set_addr $I10, alt904_1
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."param_var"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx895_pos = $P10."pos"()
    goto alt904_end
  alt904_1:
  # rx subrule "named_param" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."named_param"()
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx895_pos = $P10."pos"()
  alt904_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_906_fail
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  alt905_0:
    set_addr $I10, alt905_1
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  # rx literal  "?"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 63, rx895_fail
    add rx895_pos, 1
    goto alt905_end
  alt905_1:
    set_addr $I10, alt905_2
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  # rx literal  "!"
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 33, rx895_fail
    add rx895_pos, 1
    goto alt905_end
  alt905_2:
  alt905_end:
    set_addr $I10, rxcap_906_fail
    ($I12, $I11) = rx895_cur."!mark_peek"($I10)
    rx895_cur."!cursor_pos"($I11)
    ($P10) = rx895_cur."!cursor_start"()
    $P10."!cursor_pass"(rx895_pos, "")
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_906_done
  rxcap_906_fail:
    goto rx895_fail
  rxcap_906_done:
  alt902_end:
.annotate 'line', 411
  # rx rxquantr907 ** 0..1
    set_addr $I10, rxquantr907_done
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxquantr907_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."default_value"()
    unless $P10, rx895_fail
    goto rxsubrule908_pass
  rxsubrule908_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx895_fail
  rxsubrule908_pass:
    set_addr $I10, rxsubrule908_back
    rx895_cur."!mark_push"(0, rx895_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx895_pos = $P10."pos"()
    set_addr $I10, rxquantr907_done
    (rx895_rep) = rx895_cur."!mark_commit"($I10)
  rxquantr907_done:
.annotate 'line', 405
  # rx pass
    rx895_cur."!cursor_pass"(rx895_pos, "parameter")
    if_null rx895_debug, debug_757
    rx895_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx895_pos)
  debug_757:
    .return (rx895_cur)
  rx895_restart:
.annotate 'line', 4
    if_null rx895_debug, debug_758
    rx895_cur."!cursor_debug"("NEXT", "parameter")
  debug_758:
  rx895_fail:
    (rx895_rep, rx895_pos, $I10, $P10) = rx895_cur."!mark_fail"(0)
    lt rx895_pos, -1, rx895_done
    eq rx895_pos, -1, rx895_fail
    jump $I10
  rx895_done:
    rx895_cur."!cursor_fail"()
    if_null rx895_debug, debug_759
    rx895_cur."!cursor_debug"("FAIL", "parameter")
  debug_759:
    .return (rx895_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("189_1297619321.796") :method
.annotate 'line', 4
    new $P897, "ResizablePMCArray"
    push $P897, ""
    .return ($P897)
.end


.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("190_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx910_tgt
    .local int rx910_pos
    .local int rx910_off
    .local int rx910_eos
    .local int rx910_rep
    .local pmc rx910_cur
    .local pmc rx910_debug
    (rx910_cur, rx910_pos, rx910_tgt, $I10) = self."!cursor_start"()
    rx910_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx910_cur
    .local pmc match
    .lex "$/", match
    length rx910_eos, rx910_tgt
    gt rx910_pos, rx910_eos, rx910_done
    set rx910_off, 0
    lt rx910_pos, 2, rx910_start
    sub rx910_off, rx910_pos, 1
    substr rx910_tgt, rx910_tgt, rx910_off
  rx910_start:
    eq $I10, 1, rx910_restart
    if_null rx910_debug, debug_760
    rx910_cur."!cursor_debug"("START", "param_var")
  debug_760:
    $I10 = self.'from'()
    ne $I10, -1, rxscan914_done
    goto rxscan914_scan
  rxscan914_loop:
    (rx910_pos) = rx910_cur."from"()
    inc rx910_pos
    rx910_cur."!cursor_from"(rx910_pos)
    ge rx910_pos, rx910_eos, rxscan914_done
  rxscan914_scan:
    set_addr $I10, rxscan914_loop
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  rxscan914_done:
.annotate 'line', 415
  # rx subrule "sigil" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."sigil"()
    unless $P10, rx910_fail
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx910_pos = $P10."pos"()
  # rx rxquantr915 ** 0..1
    set_addr $I10, rxquantr915_done
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  rxquantr915_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."twigil"()
    unless $P10, rx910_fail
    goto rxsubrule916_pass
  rxsubrule916_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx910_fail
  rxsubrule916_pass:
    set_addr $I10, rxsubrule916_back
    rx910_cur."!mark_push"(0, rx910_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx910_pos = $P10."pos"()
    set_addr $I10, rxquantr915_done
    (rx910_rep) = rx910_cur."!mark_commit"($I10)
  rxquantr915_done:
  alt917_0:
.annotate 'line', 416
    set_addr $I10, alt917_1
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx910_cur."!cursor_pos"(rx910_pos)
    $P10 = rx910_cur."ident"()
    unless $P10, rx910_fail
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx910_pos = $P10."pos"()
    goto alt917_end
  alt917_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_918_fail
    rx910_cur."!mark_push"(0, rx910_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx910_pos, rx910_eos, rx910_fail
    sub $I10, rx910_pos, rx910_off
    substr $S10, rx910_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx910_fail
    inc rx910_pos
    set_addr $I10, rxcap_918_fail
    ($I12, $I11) = rx910_cur."!mark_peek"($I10)
    rx910_cur."!cursor_pos"($I11)
    ($P10) = rx910_cur."!cursor_start"()
    $P10."!cursor_pass"(rx910_pos, "")
    rx910_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_918_done
  rxcap_918_fail:
    goto rx910_fail
  rxcap_918_done:
  alt917_end:
.annotate 'line', 414
  # rx pass
    rx910_cur."!cursor_pass"(rx910_pos, "param_var")
    if_null rx910_debug, debug_761
    rx910_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx910_pos)
  debug_761:
    .return (rx910_cur)
  rx910_restart:
.annotate 'line', 4
    if_null rx910_debug, debug_762
    rx910_cur."!cursor_debug"("NEXT", "param_var")
  debug_762:
  rx910_fail:
    (rx910_rep, rx910_pos, $I10, $P10) = rx910_cur."!mark_fail"(0)
    lt rx910_pos, -1, rx910_done
    eq rx910_pos, -1, rx910_fail
    jump $I10
  rx910_done:
    rx910_cur."!cursor_fail"()
    if_null rx910_debug, debug_763
    rx910_cur."!cursor_debug"("FAIL", "param_var")
  debug_763:
    .return (rx910_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("191_1297619321.796") :method
.annotate 'line', 4
    $P912 = self."!PREFIX__!subrule"("sigil", "")
    new $P913, "ResizablePMCArray"
    push $P913, $P912
    .return ($P913)
.end


.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("192_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx920_tgt
    .local int rx920_pos
    .local int rx920_off
    .local int rx920_eos
    .local int rx920_rep
    .local pmc rx920_cur
    .local pmc rx920_debug
    (rx920_cur, rx920_pos, rx920_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx920_cur
    .local pmc match
    .lex "$/", match
    length rx920_eos, rx920_tgt
    gt rx920_pos, rx920_eos, rx920_done
    set rx920_off, 0
    lt rx920_pos, 2, rx920_start
    sub rx920_off, rx920_pos, 1
    substr rx920_tgt, rx920_tgt, rx920_off
  rx920_start:
    eq $I10, 1, rx920_restart
    if_null rx920_debug, debug_764
    rx920_cur."!cursor_debug"("START", "named_param")
  debug_764:
    $I10 = self.'from'()
    ne $I10, -1, rxscan924_done
    goto rxscan924_scan
  rxscan924_loop:
    (rx920_pos) = rx920_cur."from"()
    inc rx920_pos
    rx920_cur."!cursor_from"(rx920_pos)
    ge rx920_pos, rx920_eos, rxscan924_done
  rxscan924_scan:
    set_addr $I10, rxscan924_loop
    rx920_cur."!mark_push"(0, rx920_pos, $I10)
  rxscan924_done:
.annotate 'line', 420
  # rx literal  ":"
    add $I11, rx920_pos, 1
    gt $I11, rx920_eos, rx920_fail
    sub $I11, rx920_pos, rx920_off
    ord $I11, rx920_tgt, $I11
    ne $I11, 58, rx920_fail
    add rx920_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx920_cur."!cursor_pos"(rx920_pos)
    $P10 = rx920_cur."param_var"()
    unless $P10, rx920_fail
    rx920_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx920_pos = $P10."pos"()
.annotate 'line', 419
  # rx pass
    rx920_cur."!cursor_pass"(rx920_pos, "named_param")
    if_null rx920_debug, debug_765
    rx920_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx920_pos)
  debug_765:
    .return (rx920_cur)
  rx920_restart:
.annotate 'line', 4
    if_null rx920_debug, debug_766
    rx920_cur."!cursor_debug"("NEXT", "named_param")
  debug_766:
  rx920_fail:
    (rx920_rep, rx920_pos, $I10, $P10) = rx920_cur."!mark_fail"(0)
    lt rx920_pos, -1, rx920_done
    eq rx920_pos, -1, rx920_fail
    jump $I10
  rx920_done:
    rx920_cur."!cursor_fail"()
    if_null rx920_debug, debug_767
    rx920_cur."!cursor_debug"("FAIL", "named_param")
  debug_767:
    .return (rx920_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("193_1297619321.796") :method
.annotate 'line', 4
    $P922 = self."!PREFIX__!subrule"("param_var", ":")
    new $P923, "ResizablePMCArray"
    push $P923, $P922
    .return ($P923)
.end


.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("194_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx926_tgt
    .local int rx926_pos
    .local int rx926_off
    .local int rx926_eos
    .local int rx926_rep
    .local pmc rx926_cur
    .local pmc rx926_debug
    (rx926_cur, rx926_pos, rx926_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx926_cur
    .local pmc match
    .lex "$/", match
    length rx926_eos, rx926_tgt
    gt rx926_pos, rx926_eos, rx926_done
    set rx926_off, 0
    lt rx926_pos, 2, rx926_start
    sub rx926_off, rx926_pos, 1
    substr rx926_tgt, rx926_tgt, rx926_off
  rx926_start:
    eq $I10, 1, rx926_restart
    if_null rx926_debug, debug_768
    rx926_cur."!cursor_debug"("START", "default_value")
  debug_768:
    $I10 = self.'from'()
    ne $I10, -1, rxscan930_done
    goto rxscan930_scan
  rxscan930_loop:
    (rx926_pos) = rx926_cur."from"()
    inc rx926_pos
    rx926_cur."!cursor_from"(rx926_pos)
    ge rx926_pos, rx926_eos, rxscan930_done
  rxscan930_scan:
    set_addr $I10, rxscan930_loop
    rx926_cur."!mark_push"(0, rx926_pos, $I10)
  rxscan930_done:
.annotate 'line', 423
  # rx subrule "ws" subtype=method negate=
    rx926_cur."!cursor_pos"(rx926_pos)
    $P10 = rx926_cur."ws"()
    unless $P10, rx926_fail
    rx926_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx926_pos, 1
    gt $I11, rx926_eos, rx926_fail
    sub $I11, rx926_pos, rx926_off
    ord $I11, rx926_tgt, $I11
    ne $I11, 61, rx926_fail
    add rx926_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx926_cur."!cursor_pos"(rx926_pos)
    $P10 = rx926_cur."ws"()
    unless $P10, rx926_fail
    rx926_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx926_cur."!cursor_pos"(rx926_pos)
    $P10 = rx926_cur."EXPR"("i=")
    unless $P10, rx926_fail
    rx926_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx926_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx926_cur."!cursor_pos"(rx926_pos)
    $P10 = rx926_cur."ws"()
    unless $P10, rx926_fail
    rx926_pos = $P10."pos"()
  # rx pass
    rx926_cur."!cursor_pass"(rx926_pos, "default_value")
    if_null rx926_debug, debug_769
    rx926_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx926_pos)
  debug_769:
    .return (rx926_cur)
  rx926_restart:
.annotate 'line', 4
    if_null rx926_debug, debug_770
    rx926_cur."!cursor_debug"("NEXT", "default_value")
  debug_770:
  rx926_fail:
    (rx926_rep, rx926_pos, $I10, $P10) = rx926_cur."!mark_fail"(0)
    lt rx926_pos, -1, rx926_done
    eq rx926_pos, -1, rx926_fail
    jump $I10
  rx926_done:
    rx926_cur."!cursor_fail"()
    if_null rx926_debug, debug_771
    rx926_cur."!cursor_debug"("FAIL", "default_value")
  debug_771:
    .return (rx926_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("195_1297619321.796") :method
.annotate 'line', 4
    $P928 = self."!PREFIX__!subrule"("ws", "")
    new $P929, "ResizablePMCArray"
    push $P929, $P928
    .return ($P929)
.end


.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("196_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx935_tgt
    .local int rx935_pos
    .local int rx935_off
    .local int rx935_eos
    .local int rx935_rep
    .local pmc rx935_cur
    .local pmc rx935_debug
    (rx935_cur, rx935_pos, rx935_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx935_cur
    .local pmc match
    .lex "$/", match
    length rx935_eos, rx935_tgt
    gt rx935_pos, rx935_eos, rx935_done
    set rx935_off, 0
    lt rx935_pos, 2, rx935_start
    sub rx935_off, rx935_pos, 1
    substr rx935_tgt, rx935_tgt, rx935_off
  rx935_start:
    eq $I10, 1, rx935_restart
    if_null rx935_debug, debug_772
    rx935_cur."!cursor_debug"("START", "trait")
  debug_772:
    $I10 = self.'from'()
    ne $I10, -1, rxscan939_done
    goto rxscan939_scan
  rxscan939_loop:
    (rx935_pos) = rx935_cur."from"()
    inc rx935_pos
    rx935_cur."!cursor_from"(rx935_pos)
    ge rx935_pos, rx935_eos, rxscan939_done
  rxscan939_scan:
    set_addr $I10, rxscan939_loop
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  rxscan939_done:
.annotate 'line', 425
  # rx subrule "ws" subtype=method negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."ws"()
    unless $P10, rx935_fail
    rx935_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."trait_mod"()
    unless $P10, rx935_fail
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx935_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."ws"()
    unless $P10, rx935_fail
    rx935_pos = $P10."pos"()
  # rx pass
    rx935_cur."!cursor_pass"(rx935_pos, "trait")
    if_null rx935_debug, debug_773
    rx935_cur."!cursor_debug"("PASS", "trait", " at pos=", rx935_pos)
  debug_773:
    .return (rx935_cur)
  rx935_restart:
.annotate 'line', 4
    if_null rx935_debug, debug_774
    rx935_cur."!cursor_debug"("NEXT", "trait")
  debug_774:
  rx935_fail:
    (rx935_rep, rx935_pos, $I10, $P10) = rx935_cur."!mark_fail"(0)
    lt rx935_pos, -1, rx935_done
    eq rx935_pos, -1, rx935_fail
    jump $I10
  rx935_done:
    rx935_cur."!cursor_fail"()
    if_null rx935_debug, debug_775
    rx935_cur."!cursor_debug"("FAIL", "trait")
  debug_775:
    .return (rx935_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("197_1297619321.796") :method
.annotate 'line', 4
    $P937 = self."!PREFIX__!subrule"("ws", "")
    new $P938, "ResizablePMCArray"
    push $P938, $P937
    .return ($P938)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("198_1297619321.796")
    .param pmc param_943
.annotate 'line', 427
    .lex "self", param_943
    $P944 = param_943."!protoregex"("trait_mod")
    .return ($P944)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("199_1297619321.796")
    .param pmc param_946
.annotate 'line', 427
    .lex "self", param_946
    $P947 = param_946."!PREFIX__!protoregex"("trait_mod")
    .return ($P947)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("200_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx949_tgt
    .local int rx949_pos
    .local int rx949_off
    .local int rx949_eos
    .local int rx949_rep
    .local pmc rx949_cur
    .local pmc rx949_debug
    (rx949_cur, rx949_pos, rx949_tgt, $I10) = self."!cursor_start"()
    rx949_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx949_cur
    .local pmc match
    .lex "$/", match
    length rx949_eos, rx949_tgt
    gt rx949_pos, rx949_eos, rx949_done
    set rx949_off, 0
    lt rx949_pos, 2, rx949_start
    sub rx949_off, rx949_pos, 1
    substr rx949_tgt, rx949_tgt, rx949_off
  rx949_start:
    eq $I10, 1, rx949_restart
    if_null rx949_debug, debug_776
    rx949_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan953_done
    goto rxscan953_scan
  rxscan953_loop:
    (rx949_pos) = rx949_cur."from"()
    inc rx949_pos
    rx949_cur."!cursor_from"(rx949_pos)
    ge rx949_pos, rx949_eos, rxscan953_done
  rxscan953_scan:
    set_addr $I10, rxscan953_loop
    rx949_cur."!mark_push"(0, rx949_pos, $I10)
  rxscan953_done:
.annotate 'line', 428
  # rx subcapture "sym"
    set_addr $I10, rxcap_954_fail
    rx949_cur."!mark_push"(0, rx949_pos, $I10)
  # rx literal  "is"
    add $I11, rx949_pos, 2
    gt $I11, rx949_eos, rx949_fail
    sub $I11, rx949_pos, rx949_off
    substr $S10, rx949_tgt, $I11, 2
    ne $S10, "is", rx949_fail
    add rx949_pos, 2
    set_addr $I10, rxcap_954_fail
    ($I12, $I11) = rx949_cur."!mark_peek"($I10)
    rx949_cur."!cursor_pos"($I11)
    ($P10) = rx949_cur."!cursor_start"()
    $P10."!cursor_pass"(rx949_pos, "")
    rx949_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_954_done
  rxcap_954_fail:
    goto rx949_fail
  rxcap_954_done:
  # rx subrule "ws" subtype=method negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."ws"()
    unless $P10, rx949_fail
    rx949_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."deflongname"()
    unless $P10, rx949_fail
    rx949_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx949_pos = $P10."pos"()
  # rx rxquantr956 ** 0..1
    set_addr $I10, rxquantr956_done
    rx949_cur."!mark_push"(0, rx949_pos, $I10)
  rxquantr956_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."circumfix"()
    unless $P10, rx949_fail
    goto rxsubrule957_pass
  rxsubrule957_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx949_fail
  rxsubrule957_pass:
    set_addr $I10, rxsubrule957_back
    rx949_cur."!mark_push"(0, rx949_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx949_pos = $P10."pos"()
    set_addr $I10, rxquantr956_done
    (rx949_rep) = rx949_cur."!mark_commit"($I10)
  rxquantr956_done:
  # rx subrule "ws" subtype=method negate=
    rx949_cur."!cursor_pos"(rx949_pos)
    $P10 = rx949_cur."ws"()
    unless $P10, rx949_fail
    rx949_pos = $P10."pos"()
  # rx pass
    rx949_cur."!cursor_pass"(rx949_pos, "trait_mod:sym<is>")
    if_null rx949_debug, debug_777
    rx949_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx949_pos)
  debug_777:
    .return (rx949_cur)
  rx949_restart:
.annotate 'line', 4
    if_null rx949_debug, debug_778
    rx949_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_778:
  rx949_fail:
    (rx949_rep, rx949_pos, $I10, $P10) = rx949_cur."!mark_fail"(0)
    lt rx949_pos, -1, rx949_done
    eq rx949_pos, -1, rx949_fail
    jump $I10
  rx949_done:
    rx949_cur."!cursor_fail"()
    if_null rx949_debug, debug_779
    rx949_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_779:
    .return (rx949_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("201_1297619321.796") :method
.annotate 'line', 4
    $P951 = self."!PREFIX__!subrule"("ws", "is")
    new $P952, "ResizablePMCArray"
    push $P952, $P951
    .return ($P952)
.end


.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("202_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx960_tgt
    .local int rx960_pos
    .local int rx960_off
    .local int rx960_eos
    .local int rx960_rep
    .local pmc rx960_cur
    .local pmc rx960_debug
    (rx960_cur, rx960_pos, rx960_tgt, $I10) = self."!cursor_start"()
    rx960_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx960_cur
    .local pmc match
    .lex "$/", match
    length rx960_eos, rx960_tgt
    gt rx960_pos, rx960_eos, rx960_done
    set rx960_off, 0
    lt rx960_pos, 2, rx960_start
    sub rx960_off, rx960_pos, 1
    substr rx960_tgt, rx960_tgt, rx960_off
  rx960_start:
    eq $I10, 1, rx960_restart
    if_null rx960_debug, debug_780
    rx960_cur."!cursor_debug"("START", "regex_declarator")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan964_done
    goto rxscan964_scan
  rxscan964_loop:
    (rx960_pos) = rx960_cur."from"()
    inc rx960_pos
    rx960_cur."!cursor_from"(rx960_pos)
    ge rx960_pos, rx960_eos, rxscan964_done
  rxscan964_scan:
    set_addr $I10, rxscan964_loop
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  rxscan964_done:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  alt966_0:
.annotate 'line', 431
    set_addr $I10, alt966_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
.annotate 'line', 432
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_968_fail
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "proto"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "proto", rx960_fail
    add rx960_pos, 5
    set_addr $I10, rxcap_968_fail
    ($I12, $I11) = rx960_cur."!mark_peek"($I10)
    rx960_cur."!cursor_pos"($I11)
    ($P10) = rx960_cur."!cursor_start"()
    $P10."!cursor_pass"(rx960_pos, "")
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_968_done
  rxcap_968_fail:
    goto rx960_fail
  rxcap_968_done:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  alt970_0:
    set_addr $I10, alt970_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "regex"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "regex", rx960_fail
    add rx960_pos, 5
    goto alt970_end
  alt970_1:
    set_addr $I10, alt970_2
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "token"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "token", rx960_fail
    add rx960_pos, 5
    goto alt970_end
  alt970_2:
  # rx literal  "rule"
    add $I11, rx960_pos, 4
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 4
    ne $S10, "rule", rx960_fail
    add rx960_pos, 4
  alt970_end:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 433
  # rx subrule "deflongname" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."deflongname"()
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx960_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  alt973_0:
.annotate 'line', 434
    set_addr $I10, alt973_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
.annotate 'line', 435
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 123, rx960_fail
    add rx960_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "<...>", rx960_fail
    add rx960_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 125, rx960_fail
    add rx960_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ENDSTMT"()
    unless $P10, rx960_fail
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
    goto alt973_end
  alt973_1:
.annotate 'line', 436
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."panic"("Proto regex body must be <...>")
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  alt973_end:
.annotate 'line', 437
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 432
    goto alt966_end
  alt966_1:
.annotate 'line', 438
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_983_fail
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  alt982_0:
    set_addr $I10, alt982_1
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "regex"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "regex", rx960_fail
    add rx960_pos, 5
    goto alt982_end
  alt982_1:
    set_addr $I10, alt982_2
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  # rx literal  "token"
    add $I11, rx960_pos, 5
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 5
    ne $S10, "token", rx960_fail
    add rx960_pos, 5
    goto alt982_end
  alt982_2:
  # rx literal  "rule"
    add $I11, rx960_pos, 4
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    substr $S10, rx960_tgt, $I11, 4
    ne $S10, "rule", rx960_fail
    add rx960_pos, 4
  alt982_end:
    set_addr $I10, rxcap_983_fail
    ($I12, $I11) = rx960_cur."!mark_peek"($I10)
    rx960_cur."!cursor_pos"($I11)
    ($P10) = rx960_cur."!cursor_start"()
    $P10."!cursor_pass"(rx960_pos, "")
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_983_done
  rxcap_983_fail:
    goto rx960_fail
  rxcap_983_done:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 439
  # rx subrule "deflongname" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."deflongname"()
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx960_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 440
  # rx subrule "newpad" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."newpad"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 441
  # rx rxquantr987 ** 0..1
    set_addr $I10, rxquantr987_done
    rx960_cur."!mark_push"(0, rx960_pos, $I10)
  rxquantr987_loop:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 40, rx960_fail
    add rx960_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."signature"()
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx960_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 41, rx960_fail
    add rx960_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
    set_addr $I10, rxquantr987_done
    (rx960_rep) = rx960_cur."!mark_commit"($I10)
  rxquantr987_done:
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 442
  # rx reduce name="regex_declarator" key="open"
    rx960_cur."!cursor_pos"(rx960_pos)
    rx960_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 443
  # rx literal  "{"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 123, rx960_fail
    add rx960_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."LANG"("Regex", "nibbler")
    unless $P10, rx960_fail
    rx960_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx960_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx960_pos, 1
    gt $I11, rx960_eos, rx960_fail
    sub $I11, rx960_pos, rx960_off
    ord $I11, rx960_tgt, $I11
    ne $I11, 125, rx960_fail
    add rx960_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ENDSTMT"()
    unless $P10, rx960_fail
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
  alt966_end:
.annotate 'line', 444
  # rx subrule "ws" subtype=method negate=
    rx960_cur."!cursor_pos"(rx960_pos)
    $P10 = rx960_cur."ws"()
    unless $P10, rx960_fail
    rx960_pos = $P10."pos"()
.annotate 'line', 430
  # rx pass
    rx960_cur."!cursor_pass"(rx960_pos, "regex_declarator")
    if_null rx960_debug, debug_781
    rx960_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx960_pos)
  debug_781:
    .return (rx960_cur)
  rx960_restart:
.annotate 'line', 4
    if_null rx960_debug, debug_782
    rx960_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_782:
  rx960_fail:
    (rx960_rep, rx960_pos, $I10, $P10) = rx960_cur."!mark_fail"(0)
    lt rx960_pos, -1, rx960_done
    eq rx960_pos, -1, rx960_fail
    jump $I10
  rx960_done:
    rx960_cur."!cursor_fail"()
    if_null rx960_debug, debug_783
    rx960_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_783:
    .return (rx960_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("203_1297619321.796") :method
.annotate 'line', 4
    $P962 = self."!PREFIX__!subrule"("ws", "")
    new $P963, "ResizablePMCArray"
    push $P963, $P962
    .return ($P963)
.end


.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("204_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx997_tgt
    .local int rx997_pos
    .local int rx997_off
    .local int rx997_eos
    .local int rx997_rep
    .local pmc rx997_cur
    .local pmc rx997_debug
    (rx997_cur, rx997_pos, rx997_tgt, $I10) = self."!cursor_start"()
    rx997_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx997_cur
    .local pmc match
    .lex "$/", match
    length rx997_eos, rx997_tgt
    gt rx997_pos, rx997_eos, rx997_done
    set rx997_off, 0
    lt rx997_pos, 2, rx997_start
    sub rx997_off, rx997_pos, 1
    substr rx997_tgt, rx997_tgt, rx997_off
  rx997_start:
    eq $I10, 1, rx997_restart
    if_null rx997_debug, debug_784
    rx997_cur."!cursor_debug"("START", "dotty")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1001_done
    goto rxscan1001_scan
  rxscan1001_loop:
    (rx997_pos) = rx997_cur."from"()
    inc rx997_pos
    rx997_cur."!cursor_from"(rx997_pos)
    ge rx997_pos, rx997_eos, rxscan1001_done
  rxscan1001_scan:
    set_addr $I10, rxscan1001_loop
    rx997_cur."!mark_push"(0, rx997_pos, $I10)
  rxscan1001_done:
.annotate 'line', 448
  # rx literal  "."
    add $I11, rx997_pos, 1
    gt $I11, rx997_eos, rx997_fail
    sub $I11, rx997_pos, rx997_off
    ord $I11, rx997_tgt, $I11
    ne $I11, 46, rx997_fail
    add rx997_pos, 1
  alt1002_0:
.annotate 'line', 449
    set_addr $I10, alt1002_1
    rx997_cur."!mark_push"(0, rx997_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx997_cur."!cursor_pos"(rx997_pos)
    $P10 = rx997_cur."deflongname"()
    unless $P10, rx997_fail
    rx997_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx997_pos = $P10."pos"()
    goto alt1002_end
  alt1002_1:
.annotate 'line', 450
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx997_pos, rx997_off
    substr $S10, rx997_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx997_fail
  # rx subrule "quote" subtype=capture negate=
    rx997_cur."!cursor_pos"(rx997_pos)
    $P10 = rx997_cur."quote"()
    unless $P10, rx997_fail
    rx997_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx997_pos = $P10."pos"()
  alt1003_0:
.annotate 'line', 451
    set_addr $I10, alt1003_1
    rx997_cur."!mark_push"(0, rx997_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx997_pos, rx997_off
    substr $S10, rx997_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx997_fail
    goto alt1003_end
  alt1003_1:
  # rx subrule "panic" subtype=method negate=
    rx997_cur."!cursor_pos"(rx997_pos)
    $P10 = rx997_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx997_fail
    rx997_pos = $P10."pos"()
  alt1003_end:
  alt1002_end:
.annotate 'line', 457
  # rx rxquantr1004 ** 0..1
    set_addr $I10, rxquantr1004_done
    rx997_cur."!mark_push"(0, rx997_pos, $I10)
  rxquantr1004_loop:
  alt1005_0:
.annotate 'line', 454
    set_addr $I10, alt1005_1
    rx997_cur."!mark_push"(0, rx997_pos, $I10)
.annotate 'line', 455
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx997_pos, rx997_off
    substr $S10, rx997_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx997_fail
  # rx subrule "args" subtype=capture negate=
    rx997_cur."!cursor_pos"(rx997_pos)
    $P10 = rx997_cur."args"()
    unless $P10, rx997_fail
    rx997_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx997_pos = $P10."pos"()
    goto alt1005_end
  alt1005_1:
.annotate 'line', 456
  # rx literal  ":"
    add $I11, rx997_pos, 1
    gt $I11, rx997_eos, rx997_fail
    sub $I11, rx997_pos, rx997_off
    ord $I11, rx997_tgt, $I11
    ne $I11, 58, rx997_fail
    add rx997_pos, 1
  # rx charclass s
    ge rx997_pos, rx997_eos, rx997_fail
    sub $I10, rx997_pos, rx997_off
    is_cclass $I11, 32, rx997_tgt, $I10
    unless $I11, rx997_fail
    inc rx997_pos
  # rx subrule "arglist" subtype=capture negate=
    rx997_cur."!cursor_pos"(rx997_pos)
    $P10 = rx997_cur."arglist"()
    unless $P10, rx997_fail
    rx997_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx997_pos = $P10."pos"()
  alt1005_end:
.annotate 'line', 457
    set_addr $I10, rxquantr1004_done
    (rx997_rep) = rx997_cur."!mark_commit"($I10)
  rxquantr1004_done:
.annotate 'line', 447
  # rx pass
    rx997_cur."!cursor_pass"(rx997_pos, "dotty")
    if_null rx997_debug, debug_785
    rx997_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx997_pos)
  debug_785:
    .return (rx997_cur)
  rx997_restart:
.annotate 'line', 4
    if_null rx997_debug, debug_786
    rx997_cur."!cursor_debug"("NEXT", "dotty")
  debug_786:
  rx997_fail:
    (rx997_rep, rx997_pos, $I10, $P10) = rx997_cur."!mark_fail"(0)
    lt rx997_pos, -1, rx997_done
    eq rx997_pos, -1, rx997_fail
    jump $I10
  rx997_done:
    rx997_cur."!cursor_fail"()
    if_null rx997_debug, debug_787
    rx997_cur."!cursor_debug"("FAIL", "dotty")
  debug_787:
    .return (rx997_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("205_1297619321.796") :method
.annotate 'line', 4
    $P999 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1000, "ResizablePMCArray"
    push $P1000, "'"
    push $P1000, "\""
    push $P1000, $P999
    .return ($P1000)
.end


.namespace ["NQP";"Grammar"]
.sub "term"  :subid("206_1297619321.796")
    .param pmc param_1007
.annotate 'line', 461
    .lex "self", param_1007
    $P1008 = param_1007."!protoregex"("term")
    .return ($P1008)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("207_1297619321.796")
    .param pmc param_1010
.annotate 'line', 461
    .lex "self", param_1010
    $P1011 = param_1010."!PREFIX__!protoregex"("term")
    .return ($P1011)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("208_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1013_tgt
    .local int rx1013_pos
    .local int rx1013_off
    .local int rx1013_eos
    .local int rx1013_rep
    .local pmc rx1013_cur
    .local pmc rx1013_debug
    (rx1013_cur, rx1013_pos, rx1013_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1013_cur
    .local pmc match
    .lex "$/", match
    length rx1013_eos, rx1013_tgt
    gt rx1013_pos, rx1013_eos, rx1013_done
    set rx1013_off, 0
    lt rx1013_pos, 2, rx1013_start
    sub rx1013_off, rx1013_pos, 1
    substr rx1013_tgt, rx1013_tgt, rx1013_off
  rx1013_start:
    eq $I10, 1, rx1013_restart
    if_null rx1013_debug, debug_788
    rx1013_cur."!cursor_debug"("START", "term:sym<self>")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1016_done
    goto rxscan1016_scan
  rxscan1016_loop:
    (rx1013_pos) = rx1013_cur."from"()
    inc rx1013_pos
    rx1013_cur."!cursor_from"(rx1013_pos)
    ge rx1013_pos, rx1013_eos, rxscan1016_done
  rxscan1016_scan:
    set_addr $I10, rxscan1016_loop
    rx1013_cur."!mark_push"(0, rx1013_pos, $I10)
  rxscan1016_done:
.annotate 'line', 463
  # rx subcapture "sym"
    set_addr $I10, rxcap_1017_fail
    rx1013_cur."!mark_push"(0, rx1013_pos, $I10)
  # rx literal  "self"
    add $I11, rx1013_pos, 4
    gt $I11, rx1013_eos, rx1013_fail
    sub $I11, rx1013_pos, rx1013_off
    substr $S10, rx1013_tgt, $I11, 4
    ne $S10, "self", rx1013_fail
    add rx1013_pos, 4
    set_addr $I10, rxcap_1017_fail
    ($I12, $I11) = rx1013_cur."!mark_peek"($I10)
    rx1013_cur."!cursor_pos"($I11)
    ($P10) = rx1013_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1013_pos, "")
    rx1013_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1017_done
  rxcap_1017_fail:
    goto rx1013_fail
  rxcap_1017_done:
  # rxanchor rwb
    le rx1013_pos, 0, rx1013_fail
    sub $I10, rx1013_pos, rx1013_off
    is_cclass $I11, 8192, rx1013_tgt, $I10
    if $I11, rx1013_fail
    dec $I10
    is_cclass $I11, 8192, rx1013_tgt, $I10
    unless $I11, rx1013_fail
  # rx pass
    rx1013_cur."!cursor_pass"(rx1013_pos, "term:sym<self>")
    if_null rx1013_debug, debug_789
    rx1013_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1013_pos)
  debug_789:
    .return (rx1013_cur)
  rx1013_restart:
.annotate 'line', 4
    if_null rx1013_debug, debug_790
    rx1013_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_790:
  rx1013_fail:
    (rx1013_rep, rx1013_pos, $I10, $P10) = rx1013_cur."!mark_fail"(0)
    lt rx1013_pos, -1, rx1013_done
    eq rx1013_pos, -1, rx1013_fail
    jump $I10
  rx1013_done:
    rx1013_cur."!cursor_fail"()
    if_null rx1013_debug, debug_791
    rx1013_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_791:
    .return (rx1013_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("209_1297619321.796") :method
.annotate 'line', 4
    new $P1015, "ResizablePMCArray"
    push $P1015, "self"
    .return ($P1015)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("210_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1019_tgt
    .local int rx1019_pos
    .local int rx1019_off
    .local int rx1019_eos
    .local int rx1019_rep
    .local pmc rx1019_cur
    .local pmc rx1019_debug
    (rx1019_cur, rx1019_pos, rx1019_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1019_cur
    .local pmc match
    .lex "$/", match
    length rx1019_eos, rx1019_tgt
    gt rx1019_pos, rx1019_eos, rx1019_done
    set rx1019_off, 0
    lt rx1019_pos, 2, rx1019_start
    sub rx1019_off, rx1019_pos, 1
    substr rx1019_tgt, rx1019_tgt, rx1019_off
  rx1019_start:
    eq $I10, 1, rx1019_restart
    if_null rx1019_debug, debug_792
    rx1019_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_792:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1023_done
    goto rxscan1023_scan
  rxscan1023_loop:
    (rx1019_pos) = rx1019_cur."from"()
    inc rx1019_pos
    rx1019_cur."!cursor_from"(rx1019_pos)
    ge rx1019_pos, rx1019_eos, rxscan1023_done
  rxscan1023_scan:
    set_addr $I10, rxscan1023_loop
    rx1019_cur."!mark_push"(0, rx1019_pos, $I10)
  rxscan1023_done:
.annotate 'line', 466
  # rx subrule "deflongname" subtype=capture negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."deflongname"()
    unless $P10, rx1019_fail
    rx1019_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1019_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1019_pos, rx1019_off
    substr $S10, rx1019_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1019_fail
  # rx subrule "args" subtype=capture negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."args"()
    unless $P10, rx1019_fail
    rx1019_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1019_pos = $P10."pos"()
.annotate 'line', 465
  # rx pass
    rx1019_cur."!cursor_pass"(rx1019_pos, "term:sym<identifier>")
    if_null rx1019_debug, debug_793
    rx1019_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1019_pos)
  debug_793:
    .return (rx1019_cur)
  rx1019_restart:
.annotate 'line', 4
    if_null rx1019_debug, debug_794
    rx1019_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_794:
  rx1019_fail:
    (rx1019_rep, rx1019_pos, $I10, $P10) = rx1019_cur."!mark_fail"(0)
    lt rx1019_pos, -1, rx1019_done
    eq rx1019_pos, -1, rx1019_fail
    jump $I10
  rx1019_done:
    rx1019_cur."!cursor_fail"()
    if_null rx1019_debug, debug_795
    rx1019_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_795:
    .return (rx1019_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("211_1297619321.796") :method
.annotate 'line', 4
    $P1021 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1022, "ResizablePMCArray"
    push $P1022, $P1021
    .return ($P1022)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("212_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1025_tgt
    .local int rx1025_pos
    .local int rx1025_off
    .local int rx1025_eos
    .local int rx1025_rep
    .local pmc rx1025_cur
    .local pmc rx1025_debug
    (rx1025_cur, rx1025_pos, rx1025_tgt, $I10) = self."!cursor_start"()
    rx1025_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1025_cur
    .local pmc match
    .lex "$/", match
    length rx1025_eos, rx1025_tgt
    gt rx1025_pos, rx1025_eos, rx1025_done
    set rx1025_off, 0
    lt rx1025_pos, 2, rx1025_start
    sub rx1025_off, rx1025_pos, 1
    substr rx1025_tgt, rx1025_tgt, rx1025_off
  rx1025_start:
    eq $I10, 1, rx1025_restart
    if_null rx1025_debug, debug_796
    rx1025_cur."!cursor_debug"("START", "term:sym<name>")
  debug_796:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1029_done
    goto rxscan1029_scan
  rxscan1029_loop:
    (rx1025_pos) = rx1025_cur."from"()
    inc rx1025_pos
    rx1025_cur."!cursor_from"(rx1025_pos)
    ge rx1025_pos, rx1025_eos, rxscan1029_done
  rxscan1029_scan:
    set_addr $I10, rxscan1029_loop
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  rxscan1029_done:
.annotate 'line', 470
  # rx subrule "name" subtype=capture negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."name"()
    unless $P10, rx1025_fail
    rx1025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1025_pos = $P10."pos"()
  # rx rxquantr1030 ** 0..1
    set_addr $I10, rxquantr1030_done
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  rxquantr1030_loop:
  # rx subrule "args" subtype=capture negate=
    rx1025_cur."!cursor_pos"(rx1025_pos)
    $P10 = rx1025_cur."args"()
    unless $P10, rx1025_fail
    goto rxsubrule1031_pass
  rxsubrule1031_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1025_fail
  rxsubrule1031_pass:
    set_addr $I10, rxsubrule1031_back
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1025_pos = $P10."pos"()
    set_addr $I10, rxquantr1030_done
    (rx1025_rep) = rx1025_cur."!mark_commit"($I10)
  rxquantr1030_done:
.annotate 'line', 469
  # rx pass
    rx1025_cur."!cursor_pass"(rx1025_pos, "term:sym<name>")
    if_null rx1025_debug, debug_797
    rx1025_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1025_pos)
  debug_797:
    .return (rx1025_cur)
  rx1025_restart:
.annotate 'line', 4
    if_null rx1025_debug, debug_798
    rx1025_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_798:
  rx1025_fail:
    (rx1025_rep, rx1025_pos, $I10, $P10) = rx1025_cur."!mark_fail"(0)
    lt rx1025_pos, -1, rx1025_done
    eq rx1025_pos, -1, rx1025_fail
    jump $I10
  rx1025_done:
    rx1025_cur."!cursor_fail"()
    if_null rx1025_debug, debug_799
    rx1025_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_799:
    .return (rx1025_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("213_1297619321.796") :method
.annotate 'line', 4
    $P1027 = self."!PREFIX__!subrule"("name", "")
    new $P1028, "ResizablePMCArray"
    push $P1028, $P1027
    .return ($P1028)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("214_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1033_tgt
    .local int rx1033_pos
    .local int rx1033_off
    .local int rx1033_eos
    .local int rx1033_rep
    .local pmc rx1033_cur
    .local pmc rx1033_debug
    (rx1033_cur, rx1033_pos, rx1033_tgt, $I10) = self."!cursor_start"()
    rx1033_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1033_cur
    .local pmc match
    .lex "$/", match
    length rx1033_eos, rx1033_tgt
    gt rx1033_pos, rx1033_eos, rx1033_done
    set rx1033_off, 0
    lt rx1033_pos, 2, rx1033_start
    sub rx1033_off, rx1033_pos, 1
    substr rx1033_tgt, rx1033_tgt, rx1033_off
  rx1033_start:
    eq $I10, 1, rx1033_restart
    if_null rx1033_debug, debug_800
    rx1033_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_800:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1036_done
    goto rxscan1036_scan
  rxscan1036_loop:
    (rx1033_pos) = rx1033_cur."from"()
    inc rx1033_pos
    rx1033_cur."!cursor_from"(rx1033_pos)
    ge rx1033_pos, rx1033_eos, rxscan1036_done
  rxscan1036_scan:
    set_addr $I10, rxscan1036_loop
    rx1033_cur."!mark_push"(0, rx1033_pos, $I10)
  rxscan1036_done:
.annotate 'line', 474
  # rx literal  "pir::"
    add $I11, rx1033_pos, 5
    gt $I11, rx1033_eos, rx1033_fail
    sub $I11, rx1033_pos, rx1033_off
    substr $S10, rx1033_tgt, $I11, 5
    ne $S10, "pir::", rx1033_fail
    add rx1033_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1037_fail
    rx1033_cur."!mark_push"(0, rx1033_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1033_pos, rx1033_off
    find_not_cclass $I11, 8192, rx1033_tgt, $I10, rx1033_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1033_fail
    add rx1033_pos, rx1033_off, $I11
    set_addr $I10, rxcap_1037_fail
    ($I12, $I11) = rx1033_cur."!mark_peek"($I10)
    rx1033_cur."!cursor_pos"($I11)
    ($P10) = rx1033_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1033_pos, "")
    rx1033_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1037_done
  rxcap_1037_fail:
    goto rx1033_fail
  rxcap_1037_done:
  # rx rxquantr1038 ** 0..1
    set_addr $I10, rxquantr1038_done
    rx1033_cur."!mark_push"(0, rx1033_pos, $I10)
  rxquantr1038_loop:
  # rx subrule "args" subtype=capture negate=
    rx1033_cur."!cursor_pos"(rx1033_pos)
    $P10 = rx1033_cur."args"()
    unless $P10, rx1033_fail
    goto rxsubrule1039_pass
  rxsubrule1039_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1033_fail
  rxsubrule1039_pass:
    set_addr $I10, rxsubrule1039_back
    rx1033_cur."!mark_push"(0, rx1033_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1033_pos = $P10."pos"()
    set_addr $I10, rxquantr1038_done
    (rx1033_rep) = rx1033_cur."!mark_commit"($I10)
  rxquantr1038_done:
.annotate 'line', 473
  # rx pass
    rx1033_cur."!cursor_pass"(rx1033_pos, "term:sym<pir::op>")
    if_null rx1033_debug, debug_801
    rx1033_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1033_pos)
  debug_801:
    .return (rx1033_cur)
  rx1033_restart:
.annotate 'line', 4
    if_null rx1033_debug, debug_802
    rx1033_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_802:
  rx1033_fail:
    (rx1033_rep, rx1033_pos, $I10, $P10) = rx1033_cur."!mark_fail"(0)
    lt rx1033_pos, -1, rx1033_done
    eq rx1033_pos, -1, rx1033_fail
    jump $I10
  rx1033_done:
    rx1033_cur."!cursor_fail"()
    if_null rx1033_debug, debug_803
    rx1033_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_803:
    .return (rx1033_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("215_1297619321.796") :method
.annotate 'line', 4
    new $P1035, "ResizablePMCArray"
    push $P1035, "pir::"
    .return ($P1035)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("216_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P1049 = "218_1297619321.796" 
    capture_lex $P1049
    .local string rx1041_tgt
    .local int rx1041_pos
    .local int rx1041_off
    .local int rx1041_eos
    .local int rx1041_rep
    .local pmc rx1041_cur
    .local pmc rx1041_debug
    (rx1041_cur, rx1041_pos, rx1041_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1041_cur
    .local pmc match
    .lex "$/", match
    length rx1041_eos, rx1041_tgt
    gt rx1041_pos, rx1041_eos, rx1041_done
    set rx1041_off, 0
    lt rx1041_pos, 2, rx1041_start
    sub rx1041_off, rx1041_pos, 1
    substr rx1041_tgt, rx1041_tgt, rx1041_off
  rx1041_start:
    eq $I10, 1, rx1041_restart
    if_null rx1041_debug, debug_804
    rx1041_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_804:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1044_done
    goto rxscan1044_scan
  rxscan1044_loop:
    (rx1041_pos) = rx1041_cur."from"()
    inc rx1041_pos
    rx1041_cur."!cursor_from"(rx1041_pos)
    ge rx1041_pos, rx1041_eos, rxscan1044_done
  rxscan1044_scan:
    set_addr $I10, rxscan1044_loop
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  rxscan1044_done:
.annotate 'line', 478
  # rx literal  "{*}"
    add $I11, rx1041_pos, 3
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 3
    ne $S10, "{*}", rx1041_fail
    add rx1041_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ENDSTMT"()
    unless $P10, rx1041_fail
  alt1045_0:
.annotate 'line', 479
    set_addr $I10, alt1045_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
    rx1041_cur."!cursor_pos"(rx1041_pos)
    find_lex $P1046, unicode:"$\x{a2}"
    $P1047 = $P1046."MATCH"()
    store_lex "$/", $P1047
    .const 'Sub' $P1049 = "218_1297619321.796" 
    capture_lex $P1049
    $P1053 = $P1049()
    unless $P1053, rx1041_fail
    goto alt1045_end
  alt1045_1:
  # rx subrule "panic" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1045_end:
.annotate 'line', 477
  # rx pass
    rx1041_cur."!cursor_pass"(rx1041_pos, "term:sym<onlystar>")
    if_null rx1041_debug, debug_807
    rx1041_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1041_pos)
  debug_807:
    .return (rx1041_cur)
  rx1041_restart:
.annotate 'line', 4
    if_null rx1041_debug, debug_808
    rx1041_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_808:
  rx1041_fail:
    (rx1041_rep, rx1041_pos, $I10, $P10) = rx1041_cur."!mark_fail"(0)
    lt rx1041_pos, -1, rx1041_done
    eq rx1041_pos, -1, rx1041_fail
    jump $I10
  rx1041_done:
    rx1041_cur."!cursor_fail"()
    if_null rx1041_debug, debug_809
    rx1041_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_809:
    .return (rx1041_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("217_1297619321.796") :method
.annotate 'line', 4
    new $P1043, "ResizablePMCArray"
    push $P1043, "{*}"
    .return ($P1043)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1048"  :anon :subid("218_1297619321.796") :outer("216_1297619321.796")
.annotate 'line', 479
    find_dynamic_lex $P1050, "$*MULTINESS"
    unless_null $P1050, vivify_805
    get_hll_global $P1050, "$MULTINESS"
    unless_null $P1050, vivify_806
    die "Contextual $*MULTINESS not found"
  vivify_806:
  vivify_805:
    set $S1051, $P1050
    iseq $I1052, $S1051, "proto"
    .return ($I1052)
.end


.namespace ["NQP";"Grammar"]
.sub "args"  :subid("219_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1055_tgt
    .local int rx1055_pos
    .local int rx1055_off
    .local int rx1055_eos
    .local int rx1055_rep
    .local pmc rx1055_cur
    .local pmc rx1055_debug
    (rx1055_cur, rx1055_pos, rx1055_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1055_cur
    .local pmc match
    .lex "$/", match
    length rx1055_eos, rx1055_tgt
    gt rx1055_pos, rx1055_eos, rx1055_done
    set rx1055_off, 0
    lt rx1055_pos, 2, rx1055_start
    sub rx1055_off, rx1055_pos, 1
    substr rx1055_tgt, rx1055_tgt, rx1055_off
  rx1055_start:
    eq $I10, 1, rx1055_restart
    if_null rx1055_debug, debug_810
    rx1055_cur."!cursor_debug"("START", "args")
  debug_810:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1059_done
    goto rxscan1059_scan
  rxscan1059_loop:
    (rx1055_pos) = rx1055_cur."from"()
    inc rx1055_pos
    rx1055_cur."!cursor_from"(rx1055_pos)
    ge rx1055_pos, rx1055_eos, rxscan1059_done
  rxscan1059_scan:
    set_addr $I10, rxscan1059_loop
    rx1055_cur."!mark_push"(0, rx1055_pos, $I10)
  rxscan1059_done:
.annotate 'line', 483
  # rx literal  "("
    add $I11, rx1055_pos, 1
    gt $I11, rx1055_eos, rx1055_fail
    sub $I11, rx1055_pos, rx1055_off
    ord $I11, rx1055_tgt, $I11
    ne $I11, 40, rx1055_fail
    add rx1055_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1055_cur."!cursor_pos"(rx1055_pos)
    $P10 = rx1055_cur."arglist"()
    unless $P10, rx1055_fail
    rx1055_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1055_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1055_pos, 1
    gt $I11, rx1055_eos, rx1055_fail
    sub $I11, rx1055_pos, rx1055_off
    ord $I11, rx1055_tgt, $I11
    ne $I11, 41, rx1055_fail
    add rx1055_pos, 1
  # rx pass
    rx1055_cur."!cursor_pass"(rx1055_pos, "args")
    if_null rx1055_debug, debug_811
    rx1055_cur."!cursor_debug"("PASS", "args", " at pos=", rx1055_pos)
  debug_811:
    .return (rx1055_cur)
  rx1055_restart:
.annotate 'line', 4
    if_null rx1055_debug, debug_812
    rx1055_cur."!cursor_debug"("NEXT", "args")
  debug_812:
  rx1055_fail:
    (rx1055_rep, rx1055_pos, $I10, $P10) = rx1055_cur."!mark_fail"(0)
    lt rx1055_pos, -1, rx1055_done
    eq rx1055_pos, -1, rx1055_fail
    jump $I10
  rx1055_done:
    rx1055_cur."!cursor_fail"()
    if_null rx1055_debug, debug_813
    rx1055_cur."!cursor_debug"("FAIL", "args")
  debug_813:
    .return (rx1055_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("220_1297619321.796") :method
.annotate 'line', 4
    $P1057 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1058, "ResizablePMCArray"
    push $P1058, $P1057
    .return ($P1058)
.end


.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("221_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1061_tgt
    .local int rx1061_pos
    .local int rx1061_off
    .local int rx1061_eos
    .local int rx1061_rep
    .local pmc rx1061_cur
    .local pmc rx1061_debug
    (rx1061_cur, rx1061_pos, rx1061_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1061_cur
    .local pmc match
    .lex "$/", match
    length rx1061_eos, rx1061_tgt
    gt rx1061_pos, rx1061_eos, rx1061_done
    set rx1061_off, 0
    lt rx1061_pos, 2, rx1061_start
    sub rx1061_off, rx1061_pos, 1
    substr rx1061_tgt, rx1061_tgt, rx1061_off
  rx1061_start:
    eq $I10, 1, rx1061_restart
    if_null rx1061_debug, debug_814
    rx1061_cur."!cursor_debug"("START", "arglist")
  debug_814:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1065_done
    goto rxscan1065_scan
  rxscan1065_loop:
    (rx1061_pos) = rx1061_cur."from"()
    inc rx1061_pos
    rx1061_cur."!cursor_from"(rx1061_pos)
    ge rx1061_pos, rx1061_eos, rxscan1065_done
  rxscan1065_scan:
    set_addr $I10, rxscan1065_loop
    rx1061_cur."!mark_push"(0, rx1061_pos, $I10)
  rxscan1065_done:
.annotate 'line', 487
  # rx subrule "ws" subtype=method negate=
    rx1061_cur."!cursor_pos"(rx1061_pos)
    $P10 = rx1061_cur."ws"()
    unless $P10, rx1061_fail
    rx1061_pos = $P10."pos"()
  alt1066_0:
.annotate 'line', 488
    set_addr $I10, alt1066_1
    rx1061_cur."!mark_push"(0, rx1061_pos, $I10)
.annotate 'line', 489
  # rx subrule "EXPR" subtype=capture negate=
    rx1061_cur."!cursor_pos"(rx1061_pos)
    $P10 = rx1061_cur."EXPR"("f=")
    unless $P10, rx1061_fail
    rx1061_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1061_pos = $P10."pos"()
    goto alt1066_end
  alt1066_1:
  alt1066_end:
.annotate 'line', 486
  # rx pass
    rx1061_cur."!cursor_pass"(rx1061_pos, "arglist")
    if_null rx1061_debug, debug_815
    rx1061_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1061_pos)
  debug_815:
    .return (rx1061_cur)
  rx1061_restart:
.annotate 'line', 4
    if_null rx1061_debug, debug_816
    rx1061_cur."!cursor_debug"("NEXT", "arglist")
  debug_816:
  rx1061_fail:
    (rx1061_rep, rx1061_pos, $I10, $P10) = rx1061_cur."!mark_fail"(0)
    lt rx1061_pos, -1, rx1061_done
    eq rx1061_pos, -1, rx1061_fail
    jump $I10
  rx1061_done:
    rx1061_cur."!cursor_fail"()
    if_null rx1061_debug, debug_817
    rx1061_cur."!cursor_debug"("FAIL", "arglist")
  debug_817:
    .return (rx1061_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("222_1297619321.796") :method
.annotate 'line', 4
    $P1063 = self."!PREFIX__!subrule"("ws", "")
    new $P1064, "ResizablePMCArray"
    push $P1064, $P1063
    .return ($P1064)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("223_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1068_tgt
    .local int rx1068_pos
    .local int rx1068_off
    .local int rx1068_eos
    .local int rx1068_rep
    .local pmc rx1068_cur
    .local pmc rx1068_debug
    (rx1068_cur, rx1068_pos, rx1068_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1068_cur
    .local pmc match
    .lex "$/", match
    length rx1068_eos, rx1068_tgt
    gt rx1068_pos, rx1068_eos, rx1068_done
    set rx1068_off, 0
    lt rx1068_pos, 2, rx1068_start
    sub rx1068_off, rx1068_pos, 1
    substr rx1068_tgt, rx1068_tgt, rx1068_off
  rx1068_start:
    eq $I10, 1, rx1068_restart
    if_null rx1068_debug, debug_818
    rx1068_cur."!cursor_debug"("START", "term:sym<value>")
  debug_818:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1072_done
    goto rxscan1072_scan
  rxscan1072_loop:
    (rx1068_pos) = rx1068_cur."from"()
    inc rx1068_pos
    rx1068_cur."!cursor_from"(rx1068_pos)
    ge rx1068_pos, rx1068_eos, rxscan1072_done
  rxscan1072_scan:
    set_addr $I10, rxscan1072_loop
    rx1068_cur."!mark_push"(0, rx1068_pos, $I10)
  rxscan1072_done:
.annotate 'line', 495
  # rx subrule "value" subtype=capture negate=
    rx1068_cur."!cursor_pos"(rx1068_pos)
    $P10 = rx1068_cur."value"()
    unless $P10, rx1068_fail
    rx1068_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1068_pos = $P10."pos"()
  # rx pass
    rx1068_cur."!cursor_pass"(rx1068_pos, "term:sym<value>")
    if_null rx1068_debug, debug_819
    rx1068_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1068_pos)
  debug_819:
    .return (rx1068_cur)
  rx1068_restart:
.annotate 'line', 4
    if_null rx1068_debug, debug_820
    rx1068_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_820:
  rx1068_fail:
    (rx1068_rep, rx1068_pos, $I10, $P10) = rx1068_cur."!mark_fail"(0)
    lt rx1068_pos, -1, rx1068_done
    eq rx1068_pos, -1, rx1068_fail
    jump $I10
  rx1068_done:
    rx1068_cur."!cursor_fail"()
    if_null rx1068_debug, debug_821
    rx1068_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_821:
    .return (rx1068_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("224_1297619321.796") :method
.annotate 'line', 4
    $P1070 = self."!PREFIX__!subrule"("value", "")
    new $P1071, "ResizablePMCArray"
    push $P1071, $P1070
    .return ($P1071)
.end


.namespace ["NQP";"Grammar"]
.sub "value"  :subid("225_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1074_tgt
    .local int rx1074_pos
    .local int rx1074_off
    .local int rx1074_eos
    .local int rx1074_rep
    .local pmc rx1074_cur
    .local pmc rx1074_debug
    (rx1074_cur, rx1074_pos, rx1074_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1074_cur
    .local pmc match
    .lex "$/", match
    length rx1074_eos, rx1074_tgt
    gt rx1074_pos, rx1074_eos, rx1074_done
    set rx1074_off, 0
    lt rx1074_pos, 2, rx1074_start
    sub rx1074_off, rx1074_pos, 1
    substr rx1074_tgt, rx1074_tgt, rx1074_off
  rx1074_start:
    eq $I10, 1, rx1074_restart
    if_null rx1074_debug, debug_822
    rx1074_cur."!cursor_debug"("START", "value")
  debug_822:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1079_done
    goto rxscan1079_scan
  rxscan1079_loop:
    (rx1074_pos) = rx1074_cur."from"()
    inc rx1074_pos
    rx1074_cur."!cursor_from"(rx1074_pos)
    ge rx1074_pos, rx1074_eos, rxscan1079_done
  rxscan1079_scan:
    set_addr $I10, rxscan1079_loop
    rx1074_cur."!mark_push"(0, rx1074_pos, $I10)
  rxscan1079_done:
  alt1080_0:
.annotate 'line', 497
    set_addr $I10, alt1080_1
    rx1074_cur."!mark_push"(0, rx1074_pos, $I10)
.annotate 'line', 498
  # rx subrule "quote" subtype=capture negate=
    rx1074_cur."!cursor_pos"(rx1074_pos)
    $P10 = rx1074_cur."quote"()
    unless $P10, rx1074_fail
    rx1074_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1074_pos = $P10."pos"()
    goto alt1080_end
  alt1080_1:
.annotate 'line', 499
  # rx subrule "number" subtype=capture negate=
    rx1074_cur."!cursor_pos"(rx1074_pos)
    $P10 = rx1074_cur."number"()
    unless $P10, rx1074_fail
    rx1074_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1074_pos = $P10."pos"()
  alt1080_end:
.annotate 'line', 497
  # rx pass
    rx1074_cur."!cursor_pass"(rx1074_pos, "value")
    if_null rx1074_debug, debug_823
    rx1074_cur."!cursor_debug"("PASS", "value", " at pos=", rx1074_pos)
  debug_823:
    .return (rx1074_cur)
  rx1074_restart:
.annotate 'line', 4
    if_null rx1074_debug, debug_824
    rx1074_cur."!cursor_debug"("NEXT", "value")
  debug_824:
  rx1074_fail:
    (rx1074_rep, rx1074_pos, $I10, $P10) = rx1074_cur."!mark_fail"(0)
    lt rx1074_pos, -1, rx1074_done
    eq rx1074_pos, -1, rx1074_fail
    jump $I10
  rx1074_done:
    rx1074_cur."!cursor_fail"()
    if_null rx1074_debug, debug_825
    rx1074_cur."!cursor_debug"("FAIL", "value")
  debug_825:
    .return (rx1074_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("226_1297619321.796") :method
.annotate 'line', 4
    $P1076 = self."!PREFIX__!subrule"("number", "")
    $P1077 = self."!PREFIX__!subrule"("quote", "")
    new $P1078, "ResizablePMCArray"
    push $P1078, $P1076
    push $P1078, $P1077
    .return ($P1078)
.end


.namespace ["NQP";"Grammar"]
.sub "number"  :subid("227_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1082_tgt
    .local int rx1082_pos
    .local int rx1082_off
    .local int rx1082_eos
    .local int rx1082_rep
    .local pmc rx1082_cur
    .local pmc rx1082_debug
    (rx1082_cur, rx1082_pos, rx1082_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1082_cur
    .local pmc match
    .lex "$/", match
    length rx1082_eos, rx1082_tgt
    gt rx1082_pos, rx1082_eos, rx1082_done
    set rx1082_off, 0
    lt rx1082_pos, 2, rx1082_start
    sub rx1082_off, rx1082_pos, 1
    substr rx1082_tgt, rx1082_tgt, rx1082_off
  rx1082_start:
    eq $I10, 1, rx1082_restart
    if_null rx1082_debug, debug_826
    rx1082_cur."!cursor_debug"("START", "number")
  debug_826:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1085_done
    goto rxscan1085_scan
  rxscan1085_loop:
    (rx1082_pos) = rx1082_cur."from"()
    inc rx1082_pos
    rx1082_cur."!cursor_from"(rx1082_pos)
    ge rx1082_pos, rx1082_eos, rxscan1085_done
  rxscan1085_scan:
    set_addr $I10, rxscan1085_loop
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  rxscan1085_done:
.annotate 'line', 503
  # rx subcapture "sign"
    set_addr $I10, rxcap_1087_fail
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1082_pos, rx1082_off
    set rx1082_rep, 0
    sub $I12, rx1082_eos, rx1082_pos
    le $I12, 1, rxenumcharlistq1086_loop
    set $I12, 1
  rxenumcharlistq1086_loop:
    le $I12, 0, rxenumcharlistq1086_done
    substr $S10, rx1082_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1086_done
    inc rx1082_rep
  rxenumcharlistq1086_done:
    add rx1082_pos, rx1082_pos, rx1082_rep
    set_addr $I10, rxcap_1087_fail
    ($I12, $I11) = rx1082_cur."!mark_peek"($I10)
    rx1082_cur."!cursor_pos"($I11)
    ($P10) = rx1082_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1082_pos, "")
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1087_done
  rxcap_1087_fail:
    goto rx1082_fail
  rxcap_1087_done:
  alt1088_0:
.annotate 'line', 504
    set_addr $I10, alt1088_1
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."dec_number"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1082_pos = $P10."pos"()
    goto alt1088_end
  alt1088_1:
  # rx subrule "integer" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."integer"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1082_pos = $P10."pos"()
  alt1088_end:
.annotate 'line', 502
  # rx pass
    rx1082_cur."!cursor_pass"(rx1082_pos, "number")
    if_null rx1082_debug, debug_827
    rx1082_cur."!cursor_debug"("PASS", "number", " at pos=", rx1082_pos)
  debug_827:
    .return (rx1082_cur)
  rx1082_restart:
.annotate 'line', 4
    if_null rx1082_debug, debug_828
    rx1082_cur."!cursor_debug"("NEXT", "number")
  debug_828:
  rx1082_fail:
    (rx1082_rep, rx1082_pos, $I10, $P10) = rx1082_cur."!mark_fail"(0)
    lt rx1082_pos, -1, rx1082_done
    eq rx1082_pos, -1, rx1082_fail
    jump $I10
  rx1082_done:
    rx1082_cur."!cursor_fail"()
    if_null rx1082_debug, debug_829
    rx1082_cur."!cursor_debug"("FAIL", "number")
  debug_829:
    .return (rx1082_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("228_1297619321.796") :method
.annotate 'line', 4
    new $P1084, "ResizablePMCArray"
    push $P1084, ""
    .return ($P1084)
.end


.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("229_1297619321.796")
    .param pmc param_1090
.annotate 'line', 507
    .lex "self", param_1090
    $P1091 = param_1090."!protoregex"("quote")
    .return ($P1091)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("230_1297619321.796")
    .param pmc param_1093
.annotate 'line', 507
    .lex "self", param_1093
    $P1094 = param_1093."!PREFIX__!protoregex"("quote")
    .return ($P1094)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("231_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1096_tgt
    .local int rx1096_pos
    .local int rx1096_off
    .local int rx1096_eos
    .local int rx1096_rep
    .local pmc rx1096_cur
    .local pmc rx1096_debug
    (rx1096_cur, rx1096_pos, rx1096_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1096_cur
    .local pmc match
    .lex "$/", match
    length rx1096_eos, rx1096_tgt
    gt rx1096_pos, rx1096_eos, rx1096_done
    set rx1096_off, 0
    lt rx1096_pos, 2, rx1096_start
    sub rx1096_off, rx1096_pos, 1
    substr rx1096_tgt, rx1096_tgt, rx1096_off
  rx1096_start:
    eq $I10, 1, rx1096_restart
    if_null rx1096_debug, debug_830
    rx1096_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_830:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1099_done
    goto rxscan1099_scan
  rxscan1099_loop:
    (rx1096_pos) = rx1096_cur."from"()
    inc rx1096_pos
    rx1096_cur."!cursor_from"(rx1096_pos)
    ge rx1096_pos, rx1096_eos, rxscan1099_done
  rxscan1099_scan:
    set_addr $I10, rxscan1099_loop
    rx1096_cur."!mark_push"(0, rx1096_pos, $I10)
  rxscan1099_done:
.annotate 'line', 508
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1096_pos, rx1096_off
    substr $S10, rx1096_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1096_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1096_cur."!cursor_pos"(rx1096_pos)
    $P10 = rx1096_cur."quote_EXPR"(":q")
    unless $P10, rx1096_fail
    rx1096_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1096_pos = $P10."pos"()
  # rx pass
    rx1096_cur."!cursor_pass"(rx1096_pos, "quote:sym<apos>")
    if_null rx1096_debug, debug_831
    rx1096_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1096_pos)
  debug_831:
    .return (rx1096_cur)
  rx1096_restart:
.annotate 'line', 4
    if_null rx1096_debug, debug_832
    rx1096_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_832:
  rx1096_fail:
    (rx1096_rep, rx1096_pos, $I10, $P10) = rx1096_cur."!mark_fail"(0)
    lt rx1096_pos, -1, rx1096_done
    eq rx1096_pos, -1, rx1096_fail
    jump $I10
  rx1096_done:
    rx1096_cur."!cursor_fail"()
    if_null rx1096_debug, debug_833
    rx1096_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_833:
    .return (rx1096_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("232_1297619321.796") :method
.annotate 'line', 4
    new $P1098, "ResizablePMCArray"
    push $P1098, "'"
    .return ($P1098)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("233_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1101_tgt
    .local int rx1101_pos
    .local int rx1101_off
    .local int rx1101_eos
    .local int rx1101_rep
    .local pmc rx1101_cur
    .local pmc rx1101_debug
    (rx1101_cur, rx1101_pos, rx1101_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1101_cur
    .local pmc match
    .lex "$/", match
    length rx1101_eos, rx1101_tgt
    gt rx1101_pos, rx1101_eos, rx1101_done
    set rx1101_off, 0
    lt rx1101_pos, 2, rx1101_start
    sub rx1101_off, rx1101_pos, 1
    substr rx1101_tgt, rx1101_tgt, rx1101_off
  rx1101_start:
    eq $I10, 1, rx1101_restart
    if_null rx1101_debug, debug_834
    rx1101_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_834:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1104_done
    goto rxscan1104_scan
  rxscan1104_loop:
    (rx1101_pos) = rx1101_cur."from"()
    inc rx1101_pos
    rx1101_cur."!cursor_from"(rx1101_pos)
    ge rx1101_pos, rx1101_eos, rxscan1104_done
  rxscan1104_scan:
    set_addr $I10, rxscan1104_loop
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10)
  rxscan1104_done:
.annotate 'line', 509
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1101_pos, rx1101_off
    substr $S10, rx1101_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1101_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."quote_EXPR"(":qq")
    unless $P10, rx1101_fail
    rx1101_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1101_pos = $P10."pos"()
  # rx pass
    rx1101_cur."!cursor_pass"(rx1101_pos, "quote:sym<dblq>")
    if_null rx1101_debug, debug_835
    rx1101_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1101_pos)
  debug_835:
    .return (rx1101_cur)
  rx1101_restart:
.annotate 'line', 4
    if_null rx1101_debug, debug_836
    rx1101_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_836:
  rx1101_fail:
    (rx1101_rep, rx1101_pos, $I10, $P10) = rx1101_cur."!mark_fail"(0)
    lt rx1101_pos, -1, rx1101_done
    eq rx1101_pos, -1, rx1101_fail
    jump $I10
  rx1101_done:
    rx1101_cur."!cursor_fail"()
    if_null rx1101_debug, debug_837
    rx1101_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_837:
    .return (rx1101_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("234_1297619321.796") :method
.annotate 'line', 4
    new $P1103, "ResizablePMCArray"
    push $P1103, "\""
    .return ($P1103)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("235_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1106_tgt
    .local int rx1106_pos
    .local int rx1106_off
    .local int rx1106_eos
    .local int rx1106_rep
    .local pmc rx1106_cur
    .local pmc rx1106_debug
    (rx1106_cur, rx1106_pos, rx1106_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1106_cur
    .local pmc match
    .lex "$/", match
    length rx1106_eos, rx1106_tgt
    gt rx1106_pos, rx1106_eos, rx1106_done
    set rx1106_off, 0
    lt rx1106_pos, 2, rx1106_start
    sub rx1106_off, rx1106_pos, 1
    substr rx1106_tgt, rx1106_tgt, rx1106_off
  rx1106_start:
    eq $I10, 1, rx1106_restart
    if_null rx1106_debug, debug_838
    rx1106_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_838:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1110_done
    goto rxscan1110_scan
  rxscan1110_loop:
    (rx1106_pos) = rx1106_cur."from"()
    inc rx1106_pos
    rx1106_cur."!cursor_from"(rx1106_pos)
    ge rx1106_pos, rx1106_eos, rxscan1110_done
  rxscan1110_scan:
    set_addr $I10, rxscan1110_loop
    rx1106_cur."!mark_push"(0, rx1106_pos, $I10)
  rxscan1110_done:
.annotate 'line', 510
  # rx literal  "q"
    add $I11, rx1106_pos, 1
    gt $I11, rx1106_eos, rx1106_fail
    sub $I11, rx1106_pos, rx1106_off
    ord $I11, rx1106_tgt, $I11
    ne $I11, 113, rx1106_fail
    add rx1106_pos, 1
  # rxanchor rwb
    le rx1106_pos, 0, rx1106_fail
    sub $I10, rx1106_pos, rx1106_off
    is_cclass $I11, 8192, rx1106_tgt, $I10
    if $I11, rx1106_fail
    dec $I10
    is_cclass $I11, 8192, rx1106_tgt, $I10
    unless $I11, rx1106_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1106_pos, rx1106_off
    substr $S10, rx1106_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1106_fail
  # rx subrule "ws" subtype=method negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."ws"()
    unless $P10, rx1106_fail
    rx1106_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."quote_EXPR"(":q")
    unless $P10, rx1106_fail
    rx1106_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1106_pos = $P10."pos"()
  # rx pass
    rx1106_cur."!cursor_pass"(rx1106_pos, "quote:sym<q>")
    if_null rx1106_debug, debug_839
    rx1106_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1106_pos)
  debug_839:
    .return (rx1106_cur)
  rx1106_restart:
.annotate 'line', 4
    if_null rx1106_debug, debug_840
    rx1106_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_840:
  rx1106_fail:
    (rx1106_rep, rx1106_pos, $I10, $P10) = rx1106_cur."!mark_fail"(0)
    lt rx1106_pos, -1, rx1106_done
    eq rx1106_pos, -1, rx1106_fail
    jump $I10
  rx1106_done:
    rx1106_cur."!cursor_fail"()
    if_null rx1106_debug, debug_841
    rx1106_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_841:
    .return (rx1106_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("236_1297619321.796") :method
.annotate 'line', 4
    $P1108 = self."!PREFIX__!subrule"("ws", "q")
    new $P1109, "ResizablePMCArray"
    push $P1109, $P1108
    .return ($P1109)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("237_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1112_tgt
    .local int rx1112_pos
    .local int rx1112_off
    .local int rx1112_eos
    .local int rx1112_rep
    .local pmc rx1112_cur
    .local pmc rx1112_debug
    (rx1112_cur, rx1112_pos, rx1112_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1112_cur
    .local pmc match
    .lex "$/", match
    length rx1112_eos, rx1112_tgt
    gt rx1112_pos, rx1112_eos, rx1112_done
    set rx1112_off, 0
    lt rx1112_pos, 2, rx1112_start
    sub rx1112_off, rx1112_pos, 1
    substr rx1112_tgt, rx1112_tgt, rx1112_off
  rx1112_start:
    eq $I10, 1, rx1112_restart
    if_null rx1112_debug, debug_842
    rx1112_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_842:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1116_done
    goto rxscan1116_scan
  rxscan1116_loop:
    (rx1112_pos) = rx1112_cur."from"()
    inc rx1112_pos
    rx1112_cur."!cursor_from"(rx1112_pos)
    ge rx1112_pos, rx1112_eos, rxscan1116_done
  rxscan1116_scan:
    set_addr $I10, rxscan1116_loop
    rx1112_cur."!mark_push"(0, rx1112_pos, $I10)
  rxscan1116_done:
.annotate 'line', 511
  # rx literal  "qq"
    add $I11, rx1112_pos, 2
    gt $I11, rx1112_eos, rx1112_fail
    sub $I11, rx1112_pos, rx1112_off
    substr $S10, rx1112_tgt, $I11, 2
    ne $S10, "qq", rx1112_fail
    add rx1112_pos, 2
  # rxanchor rwb
    le rx1112_pos, 0, rx1112_fail
    sub $I10, rx1112_pos, rx1112_off
    is_cclass $I11, 8192, rx1112_tgt, $I10
    if $I11, rx1112_fail
    dec $I10
    is_cclass $I11, 8192, rx1112_tgt, $I10
    unless $I11, rx1112_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1112_pos, rx1112_off
    substr $S10, rx1112_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1112_fail
  # rx subrule "ws" subtype=method negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."ws"()
    unless $P10, rx1112_fail
    rx1112_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."quote_EXPR"(":qq")
    unless $P10, rx1112_fail
    rx1112_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1112_pos = $P10."pos"()
  # rx pass
    rx1112_cur."!cursor_pass"(rx1112_pos, "quote:sym<qq>")
    if_null rx1112_debug, debug_843
    rx1112_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1112_pos)
  debug_843:
    .return (rx1112_cur)
  rx1112_restart:
.annotate 'line', 4
    if_null rx1112_debug, debug_844
    rx1112_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_844:
  rx1112_fail:
    (rx1112_rep, rx1112_pos, $I10, $P10) = rx1112_cur."!mark_fail"(0)
    lt rx1112_pos, -1, rx1112_done
    eq rx1112_pos, -1, rx1112_fail
    jump $I10
  rx1112_done:
    rx1112_cur."!cursor_fail"()
    if_null rx1112_debug, debug_845
    rx1112_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_845:
    .return (rx1112_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("238_1297619321.796") :method
.annotate 'line', 4
    $P1114 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1115, "ResizablePMCArray"
    push $P1115, $P1114
    .return ($P1115)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("239_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1118_tgt
    .local int rx1118_pos
    .local int rx1118_off
    .local int rx1118_eos
    .local int rx1118_rep
    .local pmc rx1118_cur
    .local pmc rx1118_debug
    (rx1118_cur, rx1118_pos, rx1118_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1118_cur
    .local pmc match
    .lex "$/", match
    length rx1118_eos, rx1118_tgt
    gt rx1118_pos, rx1118_eos, rx1118_done
    set rx1118_off, 0
    lt rx1118_pos, 2, rx1118_start
    sub rx1118_off, rx1118_pos, 1
    substr rx1118_tgt, rx1118_tgt, rx1118_off
  rx1118_start:
    eq $I10, 1, rx1118_restart
    if_null rx1118_debug, debug_846
    rx1118_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_846:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1122_done
    goto rxscan1122_scan
  rxscan1122_loop:
    (rx1118_pos) = rx1118_cur."from"()
    inc rx1118_pos
    rx1118_cur."!cursor_from"(rx1118_pos)
    ge rx1118_pos, rx1118_eos, rxscan1122_done
  rxscan1122_scan:
    set_addr $I10, rxscan1122_loop
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  rxscan1122_done:
.annotate 'line', 512
  # rx literal  "Q"
    add $I11, rx1118_pos, 1
    gt $I11, rx1118_eos, rx1118_fail
    sub $I11, rx1118_pos, rx1118_off
    ord $I11, rx1118_tgt, $I11
    ne $I11, 81, rx1118_fail
    add rx1118_pos, 1
  # rxanchor rwb
    le rx1118_pos, 0, rx1118_fail
    sub $I10, rx1118_pos, rx1118_off
    is_cclass $I11, 8192, rx1118_tgt, $I10
    if $I11, rx1118_fail
    dec $I10
    is_cclass $I11, 8192, rx1118_tgt, $I10
    unless $I11, rx1118_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1118_pos, rx1118_off
    substr $S10, rx1118_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1118_fail
  # rx subrule "ws" subtype=method negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."ws"()
    unless $P10, rx1118_fail
    rx1118_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."quote_EXPR"()
    unless $P10, rx1118_fail
    rx1118_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1118_pos = $P10."pos"()
  # rx pass
    rx1118_cur."!cursor_pass"(rx1118_pos, "quote:sym<Q>")
    if_null rx1118_debug, debug_847
    rx1118_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1118_pos)
  debug_847:
    .return (rx1118_cur)
  rx1118_restart:
.annotate 'line', 4
    if_null rx1118_debug, debug_848
    rx1118_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_848:
  rx1118_fail:
    (rx1118_rep, rx1118_pos, $I10, $P10) = rx1118_cur."!mark_fail"(0)
    lt rx1118_pos, -1, rx1118_done
    eq rx1118_pos, -1, rx1118_fail
    jump $I10
  rx1118_done:
    rx1118_cur."!cursor_fail"()
    if_null rx1118_debug, debug_849
    rx1118_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_849:
    .return (rx1118_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("240_1297619321.796") :method
.annotate 'line', 4
    $P1120 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1121, "ResizablePMCArray"
    push $P1121, $P1120
    .return ($P1121)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("241_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1124_tgt
    .local int rx1124_pos
    .local int rx1124_off
    .local int rx1124_eos
    .local int rx1124_rep
    .local pmc rx1124_cur
    .local pmc rx1124_debug
    (rx1124_cur, rx1124_pos, rx1124_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1124_cur
    .local pmc match
    .lex "$/", match
    length rx1124_eos, rx1124_tgt
    gt rx1124_pos, rx1124_eos, rx1124_done
    set rx1124_off, 0
    lt rx1124_pos, 2, rx1124_start
    sub rx1124_off, rx1124_pos, 1
    substr rx1124_tgt, rx1124_tgt, rx1124_off
  rx1124_start:
    eq $I10, 1, rx1124_restart
    if_null rx1124_debug, debug_850
    rx1124_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_850:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1128_done
    goto rxscan1128_scan
  rxscan1128_loop:
    (rx1124_pos) = rx1124_cur."from"()
    inc rx1124_pos
    rx1124_cur."!cursor_from"(rx1124_pos)
    ge rx1124_pos, rx1124_eos, rxscan1128_done
  rxscan1128_scan:
    set_addr $I10, rxscan1128_loop
    rx1124_cur."!mark_push"(0, rx1124_pos, $I10)
  rxscan1128_done:
.annotate 'line', 513
  # rx literal  "Q:PIR"
    add $I11, rx1124_pos, 5
    gt $I11, rx1124_eos, rx1124_fail
    sub $I11, rx1124_pos, rx1124_off
    substr $S10, rx1124_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1124_fail
    add rx1124_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."ws"()
    unless $P10, rx1124_fail
    rx1124_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."quote_EXPR"()
    unless $P10, rx1124_fail
    rx1124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1124_pos = $P10."pos"()
  # rx pass
    rx1124_cur."!cursor_pass"(rx1124_pos, "quote:sym<Q:PIR>")
    if_null rx1124_debug, debug_851
    rx1124_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1124_pos)
  debug_851:
    .return (rx1124_cur)
  rx1124_restart:
.annotate 'line', 4
    if_null rx1124_debug, debug_852
    rx1124_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_852:
  rx1124_fail:
    (rx1124_rep, rx1124_pos, $I10, $P10) = rx1124_cur."!mark_fail"(0)
    lt rx1124_pos, -1, rx1124_done
    eq rx1124_pos, -1, rx1124_fail
    jump $I10
  rx1124_done:
    rx1124_cur."!cursor_fail"()
    if_null rx1124_debug, debug_853
    rx1124_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_853:
    .return (rx1124_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("242_1297619321.796") :method
.annotate 'line', 4
    $P1126 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1127, "ResizablePMCArray"
    push $P1127, $P1126
    .return ($P1127)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("243_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1130_tgt
    .local int rx1130_pos
    .local int rx1130_off
    .local int rx1130_eos
    .local int rx1130_rep
    .local pmc rx1130_cur
    .local pmc rx1130_debug
    (rx1130_cur, rx1130_pos, rx1130_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1130_cur
    .local pmc match
    .lex "$/", match
    length rx1130_eos, rx1130_tgt
    gt rx1130_pos, rx1130_eos, rx1130_done
    set rx1130_off, 0
    lt rx1130_pos, 2, rx1130_start
    sub rx1130_off, rx1130_pos, 1
    substr rx1130_tgt, rx1130_tgt, rx1130_off
  rx1130_start:
    eq $I10, 1, rx1130_restart
    if_null rx1130_debug, debug_854
    rx1130_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_854:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1134_done
    goto rxscan1134_scan
  rxscan1134_loop:
    (rx1130_pos) = rx1130_cur."from"()
    inc rx1130_pos
    rx1130_cur."!cursor_from"(rx1130_pos)
    ge rx1130_pos, rx1130_eos, rxscan1134_done
  rxscan1134_scan:
    set_addr $I10, rxscan1134_loop
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxscan1134_done:
.annotate 'line', 515
  # rx literal  "/"
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 47, rx1130_fail
    add rx1130_pos, 1
.annotate 'line', 516
  # rx subrule "newpad" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."newpad"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 517
  # rx reduce name="quote:sym</ />" key="open"
    rx1130_cur."!cursor_pos"(rx1130_pos)
    rx1130_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 518
  # rx subrule "LANG" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1130_pos = $P10."pos"()
.annotate 'line', 519
  # rx literal  "/"
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 47, rx1130_fail
    add rx1130_pos, 1
.annotate 'line', 514
  # rx pass
    rx1130_cur."!cursor_pass"(rx1130_pos, "quote:sym</ />")
    if_null rx1130_debug, debug_855
    rx1130_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1130_pos)
  debug_855:
    .return (rx1130_cur)
  rx1130_restart:
.annotate 'line', 4
    if_null rx1130_debug, debug_856
    rx1130_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_856:
  rx1130_fail:
    (rx1130_rep, rx1130_pos, $I10, $P10) = rx1130_cur."!mark_fail"(0)
    lt rx1130_pos, -1, rx1130_done
    eq rx1130_pos, -1, rx1130_fail
    jump $I10
  rx1130_done:
    rx1130_cur."!cursor_fail"()
    if_null rx1130_debug, debug_857
    rx1130_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_857:
    .return (rx1130_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("244_1297619321.796") :method
.annotate 'line', 4
    $P1132 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1133, "ResizablePMCArray"
    push $P1133, $P1132
    .return ($P1133)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("245_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1136_tgt
    .local int rx1136_pos
    .local int rx1136_off
    .local int rx1136_eos
    .local int rx1136_rep
    .local pmc rx1136_cur
    .local pmc rx1136_debug
    (rx1136_cur, rx1136_pos, rx1136_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1136_cur
    .local pmc match
    .lex "$/", match
    length rx1136_eos, rx1136_tgt
    gt rx1136_pos, rx1136_eos, rx1136_done
    set rx1136_off, 0
    lt rx1136_pos, 2, rx1136_start
    sub rx1136_off, rx1136_pos, 1
    substr rx1136_tgt, rx1136_tgt, rx1136_off
  rx1136_start:
    eq $I10, 1, rx1136_restart
    if_null rx1136_debug, debug_858
    rx1136_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_858:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1139_done
    goto rxscan1139_scan
  rxscan1139_loop:
    (rx1136_pos) = rx1136_cur."from"()
    inc rx1136_pos
    rx1136_cur."!cursor_from"(rx1136_pos)
    ge rx1136_pos, rx1136_eos, rxscan1139_done
  rxscan1139_scan:
    set_addr $I10, rxscan1139_loop
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  rxscan1139_done:
.annotate 'line', 522
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1136_pos, rx1136_off
    substr $S10, rx1136_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1136_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."quotemod_check"("s")
    unless $P10, rx1136_fail
  # rx subrule "variable" subtype=capture negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."variable"()
    unless $P10, rx1136_fail
    rx1136_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1136_pos = $P10."pos"()
  # rx pass
    rx1136_cur."!cursor_pass"(rx1136_pos, "quote_escape:sym<$>")
    if_null rx1136_debug, debug_859
    rx1136_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1136_pos)
  debug_859:
    .return (rx1136_cur)
  rx1136_restart:
.annotate 'line', 4
    if_null rx1136_debug, debug_860
    rx1136_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_860:
  rx1136_fail:
    (rx1136_rep, rx1136_pos, $I10, $P10) = rx1136_cur."!mark_fail"(0)
    lt rx1136_pos, -1, rx1136_done
    eq rx1136_pos, -1, rx1136_fail
    jump $I10
  rx1136_done:
    rx1136_cur."!cursor_fail"()
    if_null rx1136_debug, debug_861
    rx1136_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_861:
    .return (rx1136_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("246_1297619321.796") :method
.annotate 'line', 4
    new $P1138, "ResizablePMCArray"
    push $P1138, "$"
    .return ($P1138)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("247_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1141_tgt
    .local int rx1141_pos
    .local int rx1141_off
    .local int rx1141_eos
    .local int rx1141_rep
    .local pmc rx1141_cur
    .local pmc rx1141_debug
    (rx1141_cur, rx1141_pos, rx1141_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1141_cur
    .local pmc match
    .lex "$/", match
    length rx1141_eos, rx1141_tgt
    gt rx1141_pos, rx1141_eos, rx1141_done
    set rx1141_off, 0
    lt rx1141_pos, 2, rx1141_start
    sub rx1141_off, rx1141_pos, 1
    substr rx1141_tgt, rx1141_tgt, rx1141_off
  rx1141_start:
    eq $I10, 1, rx1141_restart
    if_null rx1141_debug, debug_862
    rx1141_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_862:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1144_done
    goto rxscan1144_scan
  rxscan1144_loop:
    (rx1141_pos) = rx1141_cur."from"()
    inc rx1141_pos
    rx1141_cur."!cursor_from"(rx1141_pos)
    ge rx1141_pos, rx1141_eos, rxscan1144_done
  rxscan1144_scan:
    set_addr $I10, rxscan1144_loop
    rx1141_cur."!mark_push"(0, rx1141_pos, $I10)
  rxscan1144_done:
.annotate 'line', 523
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1141_pos, rx1141_off
    substr $S10, rx1141_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1141_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1141_cur."!cursor_pos"(rx1141_pos)
    $P10 = rx1141_cur."quotemod_check"("c")
    unless $P10, rx1141_fail
  # rx subrule "block" subtype=capture negate=
    rx1141_cur."!cursor_pos"(rx1141_pos)
    $P10 = rx1141_cur."block"()
    unless $P10, rx1141_fail
    rx1141_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1141_pos = $P10."pos"()
  # rx pass
    rx1141_cur."!cursor_pass"(rx1141_pos, "quote_escape:sym<{ }>")
    if_null rx1141_debug, debug_863
    rx1141_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1141_pos)
  debug_863:
    .return (rx1141_cur)
  rx1141_restart:
.annotate 'line', 4
    if_null rx1141_debug, debug_864
    rx1141_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_864:
  rx1141_fail:
    (rx1141_rep, rx1141_pos, $I10, $P10) = rx1141_cur."!mark_fail"(0)
    lt rx1141_pos, -1, rx1141_done
    eq rx1141_pos, -1, rx1141_fail
    jump $I10
  rx1141_done:
    rx1141_cur."!cursor_fail"()
    if_null rx1141_debug, debug_865
    rx1141_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_865:
    .return (rx1141_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("248_1297619321.796") :method
.annotate 'line', 4
    new $P1143, "ResizablePMCArray"
    push $P1143, "{"
    .return ($P1143)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("249_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1146_tgt
    .local int rx1146_pos
    .local int rx1146_off
    .local int rx1146_eos
    .local int rx1146_rep
    .local pmc rx1146_cur
    .local pmc rx1146_debug
    (rx1146_cur, rx1146_pos, rx1146_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1146_cur
    .local pmc match
    .lex "$/", match
    length rx1146_eos, rx1146_tgt
    gt rx1146_pos, rx1146_eos, rx1146_done
    set rx1146_off, 0
    lt rx1146_pos, 2, rx1146_start
    sub rx1146_off, rx1146_pos, 1
    substr rx1146_tgt, rx1146_tgt, rx1146_off
  rx1146_start:
    eq $I10, 1, rx1146_restart
    if_null rx1146_debug, debug_866
    rx1146_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_866:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1149_done
    goto rxscan1149_scan
  rxscan1149_loop:
    (rx1146_pos) = rx1146_cur."from"()
    inc rx1146_pos
    rx1146_cur."!cursor_from"(rx1146_pos)
    ge rx1146_pos, rx1146_eos, rxscan1149_done
  rxscan1149_scan:
    set_addr $I10, rxscan1149_loop
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  rxscan1149_done:
.annotate 'line', 524
  # rx literal  "\\e"
    add $I11, rx1146_pos, 2
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I11, 2
    ne $S10, "\\e", rx1146_fail
    add rx1146_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."quotemod_check"("b")
    unless $P10, rx1146_fail
  # rx pass
    rx1146_cur."!cursor_pass"(rx1146_pos, "quote_escape:sym<esc>")
    if_null rx1146_debug, debug_867
    rx1146_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1146_pos)
  debug_867:
    .return (rx1146_cur)
  rx1146_restart:
.annotate 'line', 4
    if_null rx1146_debug, debug_868
    rx1146_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_868:
  rx1146_fail:
    (rx1146_rep, rx1146_pos, $I10, $P10) = rx1146_cur."!mark_fail"(0)
    lt rx1146_pos, -1, rx1146_done
    eq rx1146_pos, -1, rx1146_fail
    jump $I10
  rx1146_done:
    rx1146_cur."!cursor_fail"()
    if_null rx1146_debug, debug_869
    rx1146_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_869:
    .return (rx1146_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("250_1297619321.796") :method
.annotate 'line', 4
    new $P1148, "ResizablePMCArray"
    push $P1148, "\\e"
    .return ($P1148)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("251_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1151_tgt
    .local int rx1151_pos
    .local int rx1151_off
    .local int rx1151_eos
    .local int rx1151_rep
    .local pmc rx1151_cur
    .local pmc rx1151_debug
    (rx1151_cur, rx1151_pos, rx1151_tgt, $I10) = self."!cursor_start"()
    rx1151_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1151_cur
    .local pmc match
    .lex "$/", match
    length rx1151_eos, rx1151_tgt
    gt rx1151_pos, rx1151_eos, rx1151_done
    set rx1151_off, 0
    lt rx1151_pos, 2, rx1151_start
    sub rx1151_off, rx1151_pos, 1
    substr rx1151_tgt, rx1151_tgt, rx1151_off
  rx1151_start:
    eq $I10, 1, rx1151_restart
    if_null rx1151_debug, debug_870
    rx1151_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_870:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1155_done
    goto rxscan1155_scan
  rxscan1155_loop:
    (rx1151_pos) = rx1151_cur."from"()
    inc rx1151_pos
    rx1151_cur."!cursor_from"(rx1151_pos)
    ge rx1151_pos, rx1151_eos, rxscan1155_done
  rxscan1155_scan:
    set_addr $I10, rxscan1155_loop
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
  rxscan1155_done:
.annotate 'line', 526
  # rx literal  "("
    add $I11, rx1151_pos, 1
    gt $I11, rx1151_eos, rx1151_fail
    sub $I11, rx1151_pos, rx1151_off
    ord $I11, rx1151_tgt, $I11
    ne $I11, 40, rx1151_fail
    add rx1151_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."ws"()
    unless $P10, rx1151_fail
    rx1151_pos = $P10."pos"()
  # rx rxquantr1156 ** 0..1
    set_addr $I10, rxquantr1156_done
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
  rxquantr1156_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."EXPR"()
    unless $P10, rx1151_fail
    goto rxsubrule1157_pass
  rxsubrule1157_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1151_fail
  rxsubrule1157_pass:
    set_addr $I10, rxsubrule1157_back
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1151_pos = $P10."pos"()
    set_addr $I10, rxquantr1156_done
    (rx1151_rep) = rx1151_cur."!mark_commit"($I10)
  rxquantr1156_done:
  # rx literal  ")"
    add $I11, rx1151_pos, 1
    gt $I11, rx1151_eos, rx1151_fail
    sub $I11, rx1151_pos, rx1151_off
    ord $I11, rx1151_tgt, $I11
    ne $I11, 41, rx1151_fail
    add rx1151_pos, 1
  # rx pass
    rx1151_cur."!cursor_pass"(rx1151_pos, "circumfix:sym<( )>")
    if_null rx1151_debug, debug_871
    rx1151_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1151_pos)
  debug_871:
    .return (rx1151_cur)
  rx1151_restart:
.annotate 'line', 4
    if_null rx1151_debug, debug_872
    rx1151_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_872:
  rx1151_fail:
    (rx1151_rep, rx1151_pos, $I10, $P10) = rx1151_cur."!mark_fail"(0)
    lt rx1151_pos, -1, rx1151_done
    eq rx1151_pos, -1, rx1151_fail
    jump $I10
  rx1151_done:
    rx1151_cur."!cursor_fail"()
    if_null rx1151_debug, debug_873
    rx1151_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_873:
    .return (rx1151_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("252_1297619321.796") :method
.annotate 'line', 4
    $P1153 = self."!PREFIX__!subrule"("ws", "(")
    new $P1154, "ResizablePMCArray"
    push $P1154, $P1153
    .return ($P1154)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("253_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1159_tgt
    .local int rx1159_pos
    .local int rx1159_off
    .local int rx1159_eos
    .local int rx1159_rep
    .local pmc rx1159_cur
    .local pmc rx1159_debug
    (rx1159_cur, rx1159_pos, rx1159_tgt, $I10) = self."!cursor_start"()
    rx1159_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1159_cur
    .local pmc match
    .lex "$/", match
    length rx1159_eos, rx1159_tgt
    gt rx1159_pos, rx1159_eos, rx1159_done
    set rx1159_off, 0
    lt rx1159_pos, 2, rx1159_start
    sub rx1159_off, rx1159_pos, 1
    substr rx1159_tgt, rx1159_tgt, rx1159_off
  rx1159_start:
    eq $I10, 1, rx1159_restart
    if_null rx1159_debug, debug_874
    rx1159_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_874:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1163_done
    goto rxscan1163_scan
  rxscan1163_loop:
    (rx1159_pos) = rx1159_cur."from"()
    inc rx1159_pos
    rx1159_cur."!cursor_from"(rx1159_pos)
    ge rx1159_pos, rx1159_eos, rxscan1163_done
  rxscan1163_scan:
    set_addr $I10, rxscan1163_loop
    rx1159_cur."!mark_push"(0, rx1159_pos, $I10)
  rxscan1163_done:
.annotate 'line', 527
  # rx literal  "["
    add $I11, rx1159_pos, 1
    gt $I11, rx1159_eos, rx1159_fail
    sub $I11, rx1159_pos, rx1159_off
    ord $I11, rx1159_tgt, $I11
    ne $I11, 91, rx1159_fail
    add rx1159_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1159_cur."!cursor_pos"(rx1159_pos)
    $P10 = rx1159_cur."ws"()
    unless $P10, rx1159_fail
    rx1159_pos = $P10."pos"()
  # rx rxquantr1164 ** 0..1
    set_addr $I10, rxquantr1164_done
    rx1159_cur."!mark_push"(0, rx1159_pos, $I10)
  rxquantr1164_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1159_cur."!cursor_pos"(rx1159_pos)
    $P10 = rx1159_cur."EXPR"()
    unless $P10, rx1159_fail
    goto rxsubrule1165_pass
  rxsubrule1165_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1159_fail
  rxsubrule1165_pass:
    set_addr $I10, rxsubrule1165_back
    rx1159_cur."!mark_push"(0, rx1159_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1159_pos = $P10."pos"()
    set_addr $I10, rxquantr1164_done
    (rx1159_rep) = rx1159_cur."!mark_commit"($I10)
  rxquantr1164_done:
  # rx literal  "]"
    add $I11, rx1159_pos, 1
    gt $I11, rx1159_eos, rx1159_fail
    sub $I11, rx1159_pos, rx1159_off
    ord $I11, rx1159_tgt, $I11
    ne $I11, 93, rx1159_fail
    add rx1159_pos, 1
  # rx pass
    rx1159_cur."!cursor_pass"(rx1159_pos, "circumfix:sym<[ ]>")
    if_null rx1159_debug, debug_875
    rx1159_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1159_pos)
  debug_875:
    .return (rx1159_cur)
  rx1159_restart:
.annotate 'line', 4
    if_null rx1159_debug, debug_876
    rx1159_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_876:
  rx1159_fail:
    (rx1159_rep, rx1159_pos, $I10, $P10) = rx1159_cur."!mark_fail"(0)
    lt rx1159_pos, -1, rx1159_done
    eq rx1159_pos, -1, rx1159_fail
    jump $I10
  rx1159_done:
    rx1159_cur."!cursor_fail"()
    if_null rx1159_debug, debug_877
    rx1159_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_877:
    .return (rx1159_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("254_1297619321.796") :method
.annotate 'line', 4
    $P1161 = self."!PREFIX__!subrule"("ws", "[")
    new $P1162, "ResizablePMCArray"
    push $P1162, $P1161
    .return ($P1162)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("255_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1167_tgt
    .local int rx1167_pos
    .local int rx1167_off
    .local int rx1167_eos
    .local int rx1167_rep
    .local pmc rx1167_cur
    .local pmc rx1167_debug
    (rx1167_cur, rx1167_pos, rx1167_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1167_cur
    .local pmc match
    .lex "$/", match
    length rx1167_eos, rx1167_tgt
    gt rx1167_pos, rx1167_eos, rx1167_done
    set rx1167_off, 0
    lt rx1167_pos, 2, rx1167_start
    sub rx1167_off, rx1167_pos, 1
    substr rx1167_tgt, rx1167_tgt, rx1167_off
  rx1167_start:
    eq $I10, 1, rx1167_restart
    if_null rx1167_debug, debug_878
    rx1167_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_878:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1170_done
    goto rxscan1170_scan
  rxscan1170_loop:
    (rx1167_pos) = rx1167_cur."from"()
    inc rx1167_pos
    rx1167_cur."!cursor_from"(rx1167_pos)
    ge rx1167_pos, rx1167_eos, rxscan1170_done
  rxscan1170_scan:
    set_addr $I10, rxscan1170_loop
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  rxscan1170_done:
.annotate 'line', 528
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1167_pos, rx1167_off
    substr $S10, rx1167_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1167_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1167_cur."!cursor_pos"(rx1167_pos)
    $P10 = rx1167_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1167_fail
    rx1167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1167_pos = $P10."pos"()
  # rx pass
    rx1167_cur."!cursor_pass"(rx1167_pos, "circumfix:sym<ang>")
    if_null rx1167_debug, debug_879
    rx1167_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1167_pos)
  debug_879:
    .return (rx1167_cur)
  rx1167_restart:
.annotate 'line', 4
    if_null rx1167_debug, debug_880
    rx1167_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_880:
  rx1167_fail:
    (rx1167_rep, rx1167_pos, $I10, $P10) = rx1167_cur."!mark_fail"(0)
    lt rx1167_pos, -1, rx1167_done
    eq rx1167_pos, -1, rx1167_fail
    jump $I10
  rx1167_done:
    rx1167_cur."!cursor_fail"()
    if_null rx1167_debug, debug_881
    rx1167_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_881:
    .return (rx1167_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("256_1297619321.796") :method
.annotate 'line', 4
    new $P1169, "ResizablePMCArray"
    push $P1169, "<"
    .return ($P1169)
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("257_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1172_tgt
    .local int rx1172_pos
    .local int rx1172_off
    .local int rx1172_eos
    .local int rx1172_rep
    .local pmc rx1172_cur
    .local pmc rx1172_debug
    (rx1172_cur, rx1172_pos, rx1172_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1172_cur
    .local pmc match
    .lex "$/", match
    length rx1172_eos, rx1172_tgt
    gt rx1172_pos, rx1172_eos, rx1172_done
    set rx1172_off, 0
    lt rx1172_pos, 2, rx1172_start
    sub rx1172_off, rx1172_pos, 1
    substr rx1172_tgt, rx1172_tgt, rx1172_off
  rx1172_start:
    eq $I10, 1, rx1172_restart
    if_null rx1172_debug, debug_882
    rx1172_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_882:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1175_done
    goto rxscan1175_scan
  rxscan1175_loop:
    (rx1172_pos) = rx1172_cur."from"()
    inc rx1172_pos
    rx1172_cur."!cursor_from"(rx1172_pos)
    ge rx1172_pos, rx1172_eos, rxscan1175_done
  rxscan1175_scan:
    set_addr $I10, rxscan1175_loop
    rx1172_cur."!mark_push"(0, rx1172_pos, $I10)
  rxscan1175_done:
.annotate 'line', 529
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1172_pos, rx1172_off
    substr $S10, rx1172_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1172_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1172_fail
    rx1172_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1172_pos = $P10."pos"()
  # rx pass
    rx1172_cur."!cursor_pass"(rx1172_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1172_debug, debug_883
    rx1172_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1172_pos)
  debug_883:
    .return (rx1172_cur)
  rx1172_restart:
.annotate 'line', 4
    if_null rx1172_debug, debug_884
    rx1172_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_884:
  rx1172_fail:
    (rx1172_rep, rx1172_pos, $I10, $P10) = rx1172_cur."!mark_fail"(0)
    lt rx1172_pos, -1, rx1172_done
    eq rx1172_pos, -1, rx1172_fail
    jump $I10
  rx1172_done:
    rx1172_cur."!cursor_fail"()
    if_null rx1172_debug, debug_885
    rx1172_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_885:
    .return (rx1172_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("258_1297619321.796") :method
.annotate 'line', 4
    new $P1174, "ResizablePMCArray"
    push $P1174, unicode:"\x{ab}"
    .return ($P1174)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("259_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1177_tgt
    .local int rx1177_pos
    .local int rx1177_off
    .local int rx1177_eos
    .local int rx1177_rep
    .local pmc rx1177_cur
    .local pmc rx1177_debug
    (rx1177_cur, rx1177_pos, rx1177_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1177_cur
    .local pmc match
    .lex "$/", match
    length rx1177_eos, rx1177_tgt
    gt rx1177_pos, rx1177_eos, rx1177_done
    set rx1177_off, 0
    lt rx1177_pos, 2, rx1177_start
    sub rx1177_off, rx1177_pos, 1
    substr rx1177_tgt, rx1177_tgt, rx1177_off
  rx1177_start:
    eq $I10, 1, rx1177_restart
    if_null rx1177_debug, debug_886
    rx1177_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_886:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1180_done
    goto rxscan1180_scan
  rxscan1180_loop:
    (rx1177_pos) = rx1177_cur."from"()
    inc rx1177_pos
    rx1177_cur."!cursor_from"(rx1177_pos)
    ge rx1177_pos, rx1177_eos, rxscan1180_done
  rxscan1180_scan:
    set_addr $I10, rxscan1180_loop
    rx1177_cur."!mark_push"(0, rx1177_pos, $I10)
  rxscan1180_done:
.annotate 'line', 530
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1177_pos, rx1177_off
    substr $S10, rx1177_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1177_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1177_cur."!cursor_pos"(rx1177_pos)
    $P10 = rx1177_cur."pblock"()
    unless $P10, rx1177_fail
    rx1177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1177_pos = $P10."pos"()
  # rx pass
    rx1177_cur."!cursor_pass"(rx1177_pos, "circumfix:sym<{ }>")
    if_null rx1177_debug, debug_887
    rx1177_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1177_pos)
  debug_887:
    .return (rx1177_cur)
  rx1177_restart:
.annotate 'line', 4
    if_null rx1177_debug, debug_888
    rx1177_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_888:
  rx1177_fail:
    (rx1177_rep, rx1177_pos, $I10, $P10) = rx1177_cur."!mark_fail"(0)
    lt rx1177_pos, -1, rx1177_done
    eq rx1177_pos, -1, rx1177_fail
    jump $I10
  rx1177_done:
    rx1177_cur."!cursor_fail"()
    if_null rx1177_debug, debug_889
    rx1177_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_889:
    .return (rx1177_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("260_1297619321.796") :method
.annotate 'line', 4
    new $P1179, "ResizablePMCArray"
    push $P1179, "{"
    .return ($P1179)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("261_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1182_tgt
    .local int rx1182_pos
    .local int rx1182_off
    .local int rx1182_eos
    .local int rx1182_rep
    .local pmc rx1182_cur
    .local pmc rx1182_debug
    (rx1182_cur, rx1182_pos, rx1182_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1182_cur
    .local pmc match
    .lex "$/", match
    length rx1182_eos, rx1182_tgt
    gt rx1182_pos, rx1182_eos, rx1182_done
    set rx1182_off, 0
    lt rx1182_pos, 2, rx1182_start
    sub rx1182_off, rx1182_pos, 1
    substr rx1182_tgt, rx1182_tgt, rx1182_off
  rx1182_start:
    eq $I10, 1, rx1182_restart
    if_null rx1182_debug, debug_890
    rx1182_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_890:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1186_done
    goto rxscan1186_scan
  rxscan1186_loop:
    (rx1182_pos) = rx1182_cur."from"()
    inc rx1182_pos
    rx1182_cur."!cursor_from"(rx1182_pos)
    ge rx1182_pos, rx1182_eos, rxscan1186_done
  rxscan1186_scan:
    set_addr $I10, rxscan1186_loop
    rx1182_cur."!mark_push"(0, rx1182_pos, $I10)
  rxscan1186_done:
.annotate 'line', 531
  # rx subrule "sigil" subtype=capture negate=
    rx1182_cur."!cursor_pos"(rx1182_pos)
    $P10 = rx1182_cur."sigil"()
    unless $P10, rx1182_fail
    rx1182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1182_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1182_pos, 1
    gt $I11, rx1182_eos, rx1182_fail
    sub $I11, rx1182_pos, rx1182_off
    ord $I11, rx1182_tgt, $I11
    ne $I11, 40, rx1182_fail
    add rx1182_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1182_cur."!cursor_pos"(rx1182_pos)
    $P10 = rx1182_cur."semilist"()
    unless $P10, rx1182_fail
    rx1182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1182_pos = $P10."pos"()
  alt1187_0:
    set_addr $I10, alt1187_1
    rx1182_cur."!mark_push"(0, rx1182_pos, $I10)
  # rx literal  ")"
    add $I11, rx1182_pos, 1
    gt $I11, rx1182_eos, rx1182_fail
    sub $I11, rx1182_pos, rx1182_off
    ord $I11, rx1182_tgt, $I11
    ne $I11, 41, rx1182_fail
    add rx1182_pos, 1
    goto alt1187_end
  alt1187_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1182_cur."!cursor_pos"(rx1182_pos)
    $P10 = rx1182_cur."FAILGOAL"("')'")
    unless $P10, rx1182_fail
    goto rxsubrule1189_pass
  rxsubrule1189_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1182_fail
  rxsubrule1189_pass:
    set_addr $I10, rxsubrule1189_back
    rx1182_cur."!mark_push"(0, rx1182_pos, $I10, $P10)
    rx1182_pos = $P10."pos"()
  alt1187_end:
  # rx pass
    rx1182_cur."!cursor_pass"(rx1182_pos, "circumfix:sym<sigil>")
    if_null rx1182_debug, debug_891
    rx1182_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1182_pos)
  debug_891:
    .return (rx1182_cur)
  rx1182_restart:
.annotate 'line', 4
    if_null rx1182_debug, debug_892
    rx1182_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_892:
  rx1182_fail:
    (rx1182_rep, rx1182_pos, $I10, $P10) = rx1182_cur."!mark_fail"(0)
    lt rx1182_pos, -1, rx1182_done
    eq rx1182_pos, -1, rx1182_fail
    jump $I10
  rx1182_done:
    rx1182_cur."!cursor_fail"()
    if_null rx1182_debug, debug_893
    rx1182_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_893:
    .return (rx1182_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("262_1297619321.796") :method
.annotate 'line', 4
    $P1184 = self."!PREFIX__!subrule"("sigil", "")
    new $P1185, "ResizablePMCArray"
    push $P1185, $P1184
    .return ($P1185)
.end


.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("263_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1191_tgt
    .local int rx1191_pos
    .local int rx1191_off
    .local int rx1191_eos
    .local int rx1191_rep
    .local pmc rx1191_cur
    .local pmc rx1191_debug
    (rx1191_cur, rx1191_pos, rx1191_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1191_cur
    .local pmc match
    .lex "$/", match
    length rx1191_eos, rx1191_tgt
    gt rx1191_pos, rx1191_eos, rx1191_done
    set rx1191_off, 0
    lt rx1191_pos, 2, rx1191_start
    sub rx1191_off, rx1191_pos, 1
    substr rx1191_tgt, rx1191_tgt, rx1191_off
  rx1191_start:
    eq $I10, 1, rx1191_restart
    if_null rx1191_debug, debug_894
    rx1191_cur."!cursor_debug"("START", "semilist")
  debug_894:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1195_done
    goto rxscan1195_scan
  rxscan1195_loop:
    (rx1191_pos) = rx1191_cur."from"()
    inc rx1191_pos
    rx1191_cur."!cursor_from"(rx1191_pos)
    ge rx1191_pos, rx1191_eos, rxscan1195_done
  rxscan1195_scan:
    set_addr $I10, rxscan1195_loop
    rx1191_cur."!mark_push"(0, rx1191_pos, $I10)
  rxscan1195_done:
.annotate 'line', 533
  # rx subrule "ws" subtype=method negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."ws"()
    unless $P10, rx1191_fail
    rx1191_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."statement"()
    unless $P10, rx1191_fail
    rx1191_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1191_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."ws"()
    unless $P10, rx1191_fail
    rx1191_pos = $P10."pos"()
  # rx pass
    rx1191_cur."!cursor_pass"(rx1191_pos, "semilist")
    if_null rx1191_debug, debug_895
    rx1191_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1191_pos)
  debug_895:
    .return (rx1191_cur)
  rx1191_restart:
.annotate 'line', 4
    if_null rx1191_debug, debug_896
    rx1191_cur."!cursor_debug"("NEXT", "semilist")
  debug_896:
  rx1191_fail:
    (rx1191_rep, rx1191_pos, $I10, $P10) = rx1191_cur."!mark_fail"(0)
    lt rx1191_pos, -1, rx1191_done
    eq rx1191_pos, -1, rx1191_fail
    jump $I10
  rx1191_done:
    rx1191_cur."!cursor_fail"()
    if_null rx1191_debug, debug_897
    rx1191_cur."!cursor_debug"("FAIL", "semilist")
  debug_897:
    .return (rx1191_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("264_1297619321.796") :method
.annotate 'line', 4
    $P1193 = self."!PREFIX__!subrule"("ws", "")
    new $P1194, "ResizablePMCArray"
    push $P1194, $P1193
    .return ($P1194)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1198"  :anon :subid("265_1297619321.796") :outer("11_1297619321.796")
.annotate 'line', 4
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post898") :outer("265_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P1199 = "265_1297619321.796" 
    .local pmc block
    set block, $P1199
.annotate 'line', 538
    get_hll_global $P1200, ["NQP"], "Grammar"
    $P1200."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 539
    get_hll_global $P1201, ["NQP"], "Grammar"
    $P1201."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 540
    get_hll_global $P1202, ["NQP"], "Grammar"
    $P1202."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 541
    get_hll_global $P1203, ["NQP"], "Grammar"
    $P1203."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 542
    get_hll_global $P1204, ["NQP"], "Grammar"
    $P1204."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 543
    get_hll_global $P1205, ["NQP"], "Grammar"
    $P1205."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 544
    get_hll_global $P1206, ["NQP"], "Grammar"
    $P1206."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 545
    get_hll_global $P1207, ["NQP"], "Grammar"
    $P1207."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 546
    get_hll_global $P1208, ["NQP"], "Grammar"
    $P1208."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 547
    get_hll_global $P1209, ["NQP"], "Grammar"
    $P1209."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 548
    get_hll_global $P1210, ["NQP"], "Grammar"
    $P1210."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 549
    get_hll_global $P1211, ["NQP"], "Grammar"
    $P1211."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 550
    get_hll_global $P1212, ["NQP"], "Grammar"
    $P1212."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 551
    get_hll_global $P1213, ["NQP"], "Grammar"
    $P1213."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 552
    get_hll_global $P1214, ["NQP"], "Grammar"
    $P1214."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("266_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1216_tgt
    .local int rx1216_pos
    .local int rx1216_off
    .local int rx1216_eos
    .local int rx1216_rep
    .local pmc rx1216_cur
    .local pmc rx1216_debug
    (rx1216_cur, rx1216_pos, rx1216_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1216_cur
    .local pmc match
    .lex "$/", match
    length rx1216_eos, rx1216_tgt
    gt rx1216_pos, rx1216_eos, rx1216_done
    set rx1216_off, 0
    lt rx1216_pos, 2, rx1216_start
    sub rx1216_off, rx1216_pos, 1
    substr rx1216_tgt, rx1216_tgt, rx1216_off
  rx1216_start:
    eq $I10, 1, rx1216_restart
    if_null rx1216_debug, debug_899
    rx1216_cur."!cursor_debug"("START", "infixish")
  debug_899:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1219_done
    goto rxscan1219_scan
  rxscan1219_loop:
    (rx1216_pos) = rx1216_cur."from"()
    inc rx1216_pos
    rx1216_cur."!cursor_from"(rx1216_pos)
    ge rx1216_pos, rx1216_eos, rxscan1219_done
  rxscan1219_scan:
    set_addr $I10, rxscan1219_loop
    rx1216_cur."!mark_push"(0, rx1216_pos, $I10)
  rxscan1219_done:
.annotate 'line', 556
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1216_cur."!cursor_pos"(rx1216_pos)
    $P10 = rx1216_cur."infixstopper"()
    if $P10, rx1216_fail
  # rx subrule "infix" subtype=capture negate=
    rx1216_cur."!cursor_pos"(rx1216_pos)
    $P10 = rx1216_cur."infix"()
    unless $P10, rx1216_fail
    rx1216_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1216_pos = $P10."pos"()
  # rx pass
    rx1216_cur."!cursor_pass"(rx1216_pos, "infixish")
    if_null rx1216_debug, debug_900
    rx1216_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1216_pos)
  debug_900:
    .return (rx1216_cur)
  rx1216_restart:
.annotate 'line', 4
    if_null rx1216_debug, debug_901
    rx1216_cur."!cursor_debug"("NEXT", "infixish")
  debug_901:
  rx1216_fail:
    (rx1216_rep, rx1216_pos, $I10, $P10) = rx1216_cur."!mark_fail"(0)
    lt rx1216_pos, -1, rx1216_done
    eq rx1216_pos, -1, rx1216_fail
    jump $I10
  rx1216_done:
    rx1216_cur."!cursor_fail"()
    if_null rx1216_debug, debug_902
    rx1216_cur."!cursor_debug"("FAIL", "infixish")
  debug_902:
    .return (rx1216_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("267_1297619321.796") :method
.annotate 'line', 4
    new $P1218, "ResizablePMCArray"
    push $P1218, ""
    .return ($P1218)
.end


.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("268_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1221_tgt
    .local int rx1221_pos
    .local int rx1221_off
    .local int rx1221_eos
    .local int rx1221_rep
    .local pmc rx1221_cur
    .local pmc rx1221_debug
    (rx1221_cur, rx1221_pos, rx1221_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1221_cur
    .local pmc match
    .lex "$/", match
    length rx1221_eos, rx1221_tgt
    gt rx1221_pos, rx1221_eos, rx1221_done
    set rx1221_off, 0
    lt rx1221_pos, 2, rx1221_start
    sub rx1221_off, rx1221_pos, 1
    substr rx1221_tgt, rx1221_tgt, rx1221_off
  rx1221_start:
    eq $I10, 1, rx1221_restart
    if_null rx1221_debug, debug_903
    rx1221_cur."!cursor_debug"("START", "infixstopper")
  debug_903:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1221_pos) = rx1221_cur."from"()
    inc rx1221_pos
    rx1221_cur."!cursor_from"(rx1221_pos)
    ge rx1221_pos, rx1221_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxscan1224_done:
.annotate 'line', 557
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."lambda"()
    unless $P10, rx1221_fail
  # rx pass
    rx1221_cur."!cursor_pass"(rx1221_pos, "infixstopper")
    if_null rx1221_debug, debug_904
    rx1221_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1221_pos)
  debug_904:
    .return (rx1221_cur)
  rx1221_restart:
.annotate 'line', 4
    if_null rx1221_debug, debug_905
    rx1221_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_905:
  rx1221_fail:
    (rx1221_rep, rx1221_pos, $I10, $P10) = rx1221_cur."!mark_fail"(0)
    lt rx1221_pos, -1, rx1221_done
    eq rx1221_pos, -1, rx1221_fail
    jump $I10
  rx1221_done:
    rx1221_cur."!cursor_fail"()
    if_null rx1221_debug, debug_906
    rx1221_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_906:
    .return (rx1221_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("269_1297619321.796") :method
.annotate 'line', 4
    new $P1223, "ResizablePMCArray"
    push $P1223, ""
    .return ($P1223)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("270_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1226_tgt
    .local int rx1226_pos
    .local int rx1226_off
    .local int rx1226_eos
    .local int rx1226_rep
    .local pmc rx1226_cur
    .local pmc rx1226_debug
    (rx1226_cur, rx1226_pos, rx1226_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1226_cur
    .local pmc match
    .lex "$/", match
    length rx1226_eos, rx1226_tgt
    gt rx1226_pos, rx1226_eos, rx1226_done
    set rx1226_off, 0
    lt rx1226_pos, 2, rx1226_start
    sub rx1226_off, rx1226_pos, 1
    substr rx1226_tgt, rx1226_tgt, rx1226_off
  rx1226_start:
    eq $I10, 1, rx1226_restart
    if_null rx1226_debug, debug_907
    rx1226_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_907:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1230_done
    goto rxscan1230_scan
  rxscan1230_loop:
    (rx1226_pos) = rx1226_cur."from"()
    inc rx1226_pos
    rx1226_cur."!cursor_from"(rx1226_pos)
    ge rx1226_pos, rx1226_eos, rxscan1230_done
  rxscan1230_scan:
    set_addr $I10, rxscan1230_loop
    rx1226_cur."!mark_push"(0, rx1226_pos, $I10)
  rxscan1230_done:
.annotate 'line', 560
  # rx literal  "["
    add $I11, rx1226_pos, 1
    gt $I11, rx1226_eos, rx1226_fail
    sub $I11, rx1226_pos, rx1226_off
    ord $I11, rx1226_tgt, $I11
    ne $I11, 91, rx1226_fail
    add rx1226_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."ws"()
    unless $P10, rx1226_fail
    rx1226_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."EXPR"()
    unless $P10, rx1226_fail
    rx1226_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1226_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1226_pos, 1
    gt $I11, rx1226_eos, rx1226_fail
    sub $I11, rx1226_pos, rx1226_off
    ord $I11, rx1226_tgt, $I11
    ne $I11, 93, rx1226_fail
    add rx1226_pos, 1
.annotate 'line', 561
  # rx subrule "O" subtype=capture negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."O"("%methodop")
    unless $P10, rx1226_fail
    rx1226_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1226_pos = $P10."pos"()
.annotate 'line', 559
  # rx pass
    rx1226_cur."!cursor_pass"(rx1226_pos, "postcircumfix:sym<[ ]>")
    if_null rx1226_debug, debug_908
    rx1226_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1226_pos)
  debug_908:
    .return (rx1226_cur)
  rx1226_restart:
.annotate 'line', 4
    if_null rx1226_debug, debug_909
    rx1226_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_909:
  rx1226_fail:
    (rx1226_rep, rx1226_pos, $I10, $P10) = rx1226_cur."!mark_fail"(0)
    lt rx1226_pos, -1, rx1226_done
    eq rx1226_pos, -1, rx1226_fail
    jump $I10
  rx1226_done:
    rx1226_cur."!cursor_fail"()
    if_null rx1226_debug, debug_910
    rx1226_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_910:
    .return (rx1226_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("271_1297619321.796") :method
.annotate 'line', 4
    $P1228 = self."!PREFIX__!subrule"("ws", "[")
    new $P1229, "ResizablePMCArray"
    push $P1229, $P1228
    .return ($P1229)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("272_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1232_tgt
    .local int rx1232_pos
    .local int rx1232_off
    .local int rx1232_eos
    .local int rx1232_rep
    .local pmc rx1232_cur
    .local pmc rx1232_debug
    (rx1232_cur, rx1232_pos, rx1232_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1232_cur
    .local pmc match
    .lex "$/", match
    length rx1232_eos, rx1232_tgt
    gt rx1232_pos, rx1232_eos, rx1232_done
    set rx1232_off, 0
    lt rx1232_pos, 2, rx1232_start
    sub rx1232_off, rx1232_pos, 1
    substr rx1232_tgt, rx1232_tgt, rx1232_off
  rx1232_start:
    eq $I10, 1, rx1232_restart
    if_null rx1232_debug, debug_911
    rx1232_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_911:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1236_done
    goto rxscan1236_scan
  rxscan1236_loop:
    (rx1232_pos) = rx1232_cur."from"()
    inc rx1232_pos
    rx1232_cur."!cursor_from"(rx1232_pos)
    ge rx1232_pos, rx1232_eos, rxscan1236_done
  rxscan1236_scan:
    set_addr $I10, rxscan1236_loop
    rx1232_cur."!mark_push"(0, rx1232_pos, $I10)
  rxscan1236_done:
.annotate 'line', 565
  # rx literal  "{"
    add $I11, rx1232_pos, 1
    gt $I11, rx1232_eos, rx1232_fail
    sub $I11, rx1232_pos, rx1232_off
    ord $I11, rx1232_tgt, $I11
    ne $I11, 123, rx1232_fail
    add rx1232_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1232_cur."!cursor_pos"(rx1232_pos)
    $P10 = rx1232_cur."ws"()
    unless $P10, rx1232_fail
    rx1232_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1232_cur."!cursor_pos"(rx1232_pos)
    $P10 = rx1232_cur."EXPR"()
    unless $P10, rx1232_fail
    rx1232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1232_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1232_pos, 1
    gt $I11, rx1232_eos, rx1232_fail
    sub $I11, rx1232_pos, rx1232_off
    ord $I11, rx1232_tgt, $I11
    ne $I11, 125, rx1232_fail
    add rx1232_pos, 1
.annotate 'line', 566
  # rx subrule "O" subtype=capture negate=
    rx1232_cur."!cursor_pos"(rx1232_pos)
    $P10 = rx1232_cur."O"("%methodop")
    unless $P10, rx1232_fail
    rx1232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1232_pos = $P10."pos"()
.annotate 'line', 564
  # rx pass
    rx1232_cur."!cursor_pass"(rx1232_pos, "postcircumfix:sym<{ }>")
    if_null rx1232_debug, debug_912
    rx1232_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1232_pos)
  debug_912:
    .return (rx1232_cur)
  rx1232_restart:
.annotate 'line', 4
    if_null rx1232_debug, debug_913
    rx1232_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_913:
  rx1232_fail:
    (rx1232_rep, rx1232_pos, $I10, $P10) = rx1232_cur."!mark_fail"(0)
    lt rx1232_pos, -1, rx1232_done
    eq rx1232_pos, -1, rx1232_fail
    jump $I10
  rx1232_done:
    rx1232_cur."!cursor_fail"()
    if_null rx1232_debug, debug_914
    rx1232_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_914:
    .return (rx1232_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("273_1297619321.796") :method
.annotate 'line', 4
    $P1234 = self."!PREFIX__!subrule"("ws", "{")
    new $P1235, "ResizablePMCArray"
    push $P1235, $P1234
    .return ($P1235)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("274_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1238_tgt
    .local int rx1238_pos
    .local int rx1238_off
    .local int rx1238_eos
    .local int rx1238_rep
    .local pmc rx1238_cur
    .local pmc rx1238_debug
    (rx1238_cur, rx1238_pos, rx1238_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1238_cur
    .local pmc match
    .lex "$/", match
    length rx1238_eos, rx1238_tgt
    gt rx1238_pos, rx1238_eos, rx1238_done
    set rx1238_off, 0
    lt rx1238_pos, 2, rx1238_start
    sub rx1238_off, rx1238_pos, 1
    substr rx1238_tgt, rx1238_tgt, rx1238_off
  rx1238_start:
    eq $I10, 1, rx1238_restart
    if_null rx1238_debug, debug_915
    rx1238_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_915:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1241_done
    goto rxscan1241_scan
  rxscan1241_loop:
    (rx1238_pos) = rx1238_cur."from"()
    inc rx1238_pos
    rx1238_cur."!cursor_from"(rx1238_pos)
    ge rx1238_pos, rx1238_eos, rxscan1241_done
  rxscan1241_scan:
    set_addr $I10, rxscan1241_loop
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
  rxscan1241_done:
.annotate 'line', 570
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1238_pos, rx1238_off
    substr $S10, rx1238_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1238_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."quote_EXPR"(":q")
    unless $P10, rx1238_fail
    rx1238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1238_pos = $P10."pos"()
.annotate 'line', 571
  # rx subrule "O" subtype=capture negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."O"("%methodop")
    unless $P10, rx1238_fail
    rx1238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1238_pos = $P10."pos"()
.annotate 'line', 569
  # rx pass
    rx1238_cur."!cursor_pass"(rx1238_pos, "postcircumfix:sym<ang>")
    if_null rx1238_debug, debug_916
    rx1238_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1238_pos)
  debug_916:
    .return (rx1238_cur)
  rx1238_restart:
.annotate 'line', 4
    if_null rx1238_debug, debug_917
    rx1238_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_917:
  rx1238_fail:
    (rx1238_rep, rx1238_pos, $I10, $P10) = rx1238_cur."!mark_fail"(0)
    lt rx1238_pos, -1, rx1238_done
    eq rx1238_pos, -1, rx1238_fail
    jump $I10
  rx1238_done:
    rx1238_cur."!cursor_fail"()
    if_null rx1238_debug, debug_918
    rx1238_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_918:
    .return (rx1238_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("275_1297619321.796") :method
.annotate 'line', 4
    new $P1240, "ResizablePMCArray"
    push $P1240, "<"
    .return ($P1240)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("276_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1243_tgt
    .local int rx1243_pos
    .local int rx1243_off
    .local int rx1243_eos
    .local int rx1243_rep
    .local pmc rx1243_cur
    .local pmc rx1243_debug
    (rx1243_cur, rx1243_pos, rx1243_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1243_cur
    .local pmc match
    .lex "$/", match
    length rx1243_eos, rx1243_tgt
    gt rx1243_pos, rx1243_eos, rx1243_done
    set rx1243_off, 0
    lt rx1243_pos, 2, rx1243_start
    sub rx1243_off, rx1243_pos, 1
    substr rx1243_tgt, rx1243_tgt, rx1243_off
  rx1243_start:
    eq $I10, 1, rx1243_restart
    if_null rx1243_debug, debug_919
    rx1243_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_919:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1247_done
    goto rxscan1247_scan
  rxscan1247_loop:
    (rx1243_pos) = rx1243_cur."from"()
    inc rx1243_pos
    rx1243_cur."!cursor_from"(rx1243_pos)
    ge rx1243_pos, rx1243_eos, rxscan1247_done
  rxscan1247_scan:
    set_addr $I10, rxscan1247_loop
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  rxscan1247_done:
.annotate 'line', 575
  # rx literal  "("
    add $I11, rx1243_pos, 1
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    ord $I11, rx1243_tgt, $I11
    ne $I11, 40, rx1243_fail
    add rx1243_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."ws"()
    unless $P10, rx1243_fail
    rx1243_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."arglist"()
    unless $P10, rx1243_fail
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1243_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1243_pos, 1
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    ord $I11, rx1243_tgt, $I11
    ne $I11, 41, rx1243_fail
    add rx1243_pos, 1
.annotate 'line', 576
  # rx subrule "O" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."O"("%methodop")
    unless $P10, rx1243_fail
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1243_pos = $P10."pos"()
.annotate 'line', 574
  # rx pass
    rx1243_cur."!cursor_pass"(rx1243_pos, "postcircumfix:sym<( )>")
    if_null rx1243_debug, debug_920
    rx1243_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1243_pos)
  debug_920:
    .return (rx1243_cur)
  rx1243_restart:
.annotate 'line', 4
    if_null rx1243_debug, debug_921
    rx1243_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_921:
  rx1243_fail:
    (rx1243_rep, rx1243_pos, $I10, $P10) = rx1243_cur."!mark_fail"(0)
    lt rx1243_pos, -1, rx1243_done
    eq rx1243_pos, -1, rx1243_fail
    jump $I10
  rx1243_done:
    rx1243_cur."!cursor_fail"()
    if_null rx1243_debug, debug_922
    rx1243_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_922:
    .return (rx1243_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("277_1297619321.796") :method
.annotate 'line', 4
    $P1245 = self."!PREFIX__!subrule"("ws", "(")
    new $P1246, "ResizablePMCArray"
    push $P1246, $P1245
    .return ($P1246)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("278_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1249_tgt
    .local int rx1249_pos
    .local int rx1249_off
    .local int rx1249_eos
    .local int rx1249_rep
    .local pmc rx1249_cur
    .local pmc rx1249_debug
    (rx1249_cur, rx1249_pos, rx1249_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1249_cur
    .local pmc match
    .lex "$/", match
    length rx1249_eos, rx1249_tgt
    gt rx1249_pos, rx1249_eos, rx1249_done
    set rx1249_off, 0
    lt rx1249_pos, 2, rx1249_start
    sub rx1249_off, rx1249_pos, 1
    substr rx1249_tgt, rx1249_tgt, rx1249_off
  rx1249_start:
    eq $I10, 1, rx1249_restart
    if_null rx1249_debug, debug_923
    rx1249_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_923:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1253_done
    goto rxscan1253_scan
  rxscan1253_loop:
    (rx1249_pos) = rx1249_cur."from"()
    inc rx1249_pos
    rx1249_cur."!cursor_from"(rx1249_pos)
    ge rx1249_pos, rx1249_eos, rxscan1253_done
  rxscan1253_scan:
    set_addr $I10, rxscan1253_loop
    rx1249_cur."!mark_push"(0, rx1249_pos, $I10)
  rxscan1253_done:
.annotate 'line', 579
  # rx subrule "dotty" subtype=capture negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."dotty"()
    unless $P10, rx1249_fail
    rx1249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1249_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."O"("%methodop")
    unless $P10, rx1249_fail
    rx1249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1249_pos = $P10."pos"()
  # rx pass
    rx1249_cur."!cursor_pass"(rx1249_pos, "postfix:sym<.>")
    if_null rx1249_debug, debug_924
    rx1249_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1249_pos)
  debug_924:
    .return (rx1249_cur)
  rx1249_restart:
.annotate 'line', 4
    if_null rx1249_debug, debug_925
    rx1249_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_925:
  rx1249_fail:
    (rx1249_rep, rx1249_pos, $I10, $P10) = rx1249_cur."!mark_fail"(0)
    lt rx1249_pos, -1, rx1249_done
    eq rx1249_pos, -1, rx1249_fail
    jump $I10
  rx1249_done:
    rx1249_cur."!cursor_fail"()
    if_null rx1249_debug, debug_926
    rx1249_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_926:
    .return (rx1249_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("279_1297619321.796") :method
.annotate 'line', 4
    $P1251 = self."!PREFIX__!subrule"("dotty", "")
    new $P1252, "ResizablePMCArray"
    push $P1252, $P1251
    .return ($P1252)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("280_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1255_tgt
    .local int rx1255_pos
    .local int rx1255_off
    .local int rx1255_eos
    .local int rx1255_rep
    .local pmc rx1255_cur
    .local pmc rx1255_debug
    (rx1255_cur, rx1255_pos, rx1255_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1255_cur
    .local pmc match
    .lex "$/", match
    length rx1255_eos, rx1255_tgt
    gt rx1255_pos, rx1255_eos, rx1255_done
    set rx1255_off, 0
    lt rx1255_pos, 2, rx1255_start
    sub rx1255_off, rx1255_pos, 1
    substr rx1255_tgt, rx1255_tgt, rx1255_off
  rx1255_start:
    eq $I10, 1, rx1255_restart
    if_null rx1255_debug, debug_927
    rx1255_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_927:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1259_done
    goto rxscan1259_scan
  rxscan1259_loop:
    (rx1255_pos) = rx1255_cur."from"()
    inc rx1255_pos
    rx1255_cur."!cursor_from"(rx1255_pos)
    ge rx1255_pos, rx1255_eos, rxscan1259_done
  rxscan1259_scan:
    set_addr $I10, rxscan1259_loop
    rx1255_cur."!mark_push"(0, rx1255_pos, $I10)
  rxscan1259_done:
.annotate 'line', 581
  # rx subcapture "sym"
    set_addr $I10, rxcap_1260_fail
    rx1255_cur."!mark_push"(0, rx1255_pos, $I10)
  # rx literal  "++"
    add $I11, rx1255_pos, 2
    gt $I11, rx1255_eos, rx1255_fail
    sub $I11, rx1255_pos, rx1255_off
    substr $S10, rx1255_tgt, $I11, 2
    ne $S10, "++", rx1255_fail
    add rx1255_pos, 2
    set_addr $I10, rxcap_1260_fail
    ($I12, $I11) = rx1255_cur."!mark_peek"($I10)
    rx1255_cur."!cursor_pos"($I11)
    ($P10) = rx1255_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1255_pos, "")
    rx1255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1260_done
  rxcap_1260_fail:
    goto rx1255_fail
  rxcap_1260_done:
  # rx subrule "O" subtype=capture negate=
    rx1255_cur."!cursor_pos"(rx1255_pos)
    $P10 = rx1255_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1255_fail
    rx1255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1255_pos = $P10."pos"()
  # rx pass
    rx1255_cur."!cursor_pass"(rx1255_pos, "prefix:sym<++>")
    if_null rx1255_debug, debug_928
    rx1255_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1255_pos)
  debug_928:
    .return (rx1255_cur)
  rx1255_restart:
.annotate 'line', 4
    if_null rx1255_debug, debug_929
    rx1255_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_929:
  rx1255_fail:
    (rx1255_rep, rx1255_pos, $I10, $P10) = rx1255_cur."!mark_fail"(0)
    lt rx1255_pos, -1, rx1255_done
    eq rx1255_pos, -1, rx1255_fail
    jump $I10
  rx1255_done:
    rx1255_cur."!cursor_fail"()
    if_null rx1255_debug, debug_930
    rx1255_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_930:
    .return (rx1255_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("281_1297619321.796") :method
.annotate 'line', 4
    $P1257 = self."!PREFIX__!subrule"("O", "++")
    new $P1258, "ResizablePMCArray"
    push $P1258, $P1257
    .return ($P1258)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("282_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1262_tgt
    .local int rx1262_pos
    .local int rx1262_off
    .local int rx1262_eos
    .local int rx1262_rep
    .local pmc rx1262_cur
    .local pmc rx1262_debug
    (rx1262_cur, rx1262_pos, rx1262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1262_cur
    .local pmc match
    .lex "$/", match
    length rx1262_eos, rx1262_tgt
    gt rx1262_pos, rx1262_eos, rx1262_done
    set rx1262_off, 0
    lt rx1262_pos, 2, rx1262_start
    sub rx1262_off, rx1262_pos, 1
    substr rx1262_tgt, rx1262_tgt, rx1262_off
  rx1262_start:
    eq $I10, 1, rx1262_restart
    if_null rx1262_debug, debug_931
    rx1262_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_931:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1266_done
    goto rxscan1266_scan
  rxscan1266_loop:
    (rx1262_pos) = rx1262_cur."from"()
    inc rx1262_pos
    rx1262_cur."!cursor_from"(rx1262_pos)
    ge rx1262_pos, rx1262_eos, rxscan1266_done
  rxscan1266_scan:
    set_addr $I10, rxscan1266_loop
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
  rxscan1266_done:
.annotate 'line', 582
  # rx subcapture "sym"
    set_addr $I10, rxcap_1267_fail
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
  # rx literal  "--"
    add $I11, rx1262_pos, 2
    gt $I11, rx1262_eos, rx1262_fail
    sub $I11, rx1262_pos, rx1262_off
    substr $S10, rx1262_tgt, $I11, 2
    ne $S10, "--", rx1262_fail
    add rx1262_pos, 2
    set_addr $I10, rxcap_1267_fail
    ($I12, $I11) = rx1262_cur."!mark_peek"($I10)
    rx1262_cur."!cursor_pos"($I11)
    ($P10) = rx1262_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1262_pos, "")
    rx1262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1267_done
  rxcap_1267_fail:
    goto rx1262_fail
  rxcap_1267_done:
  # rx subrule "O" subtype=capture negate=
    rx1262_cur."!cursor_pos"(rx1262_pos)
    $P10 = rx1262_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1262_fail
    rx1262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1262_pos = $P10."pos"()
  # rx pass
    rx1262_cur."!cursor_pass"(rx1262_pos, "prefix:sym<-->")
    if_null rx1262_debug, debug_932
    rx1262_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1262_pos)
  debug_932:
    .return (rx1262_cur)
  rx1262_restart:
.annotate 'line', 4
    if_null rx1262_debug, debug_933
    rx1262_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_933:
  rx1262_fail:
    (rx1262_rep, rx1262_pos, $I10, $P10) = rx1262_cur."!mark_fail"(0)
    lt rx1262_pos, -1, rx1262_done
    eq rx1262_pos, -1, rx1262_fail
    jump $I10
  rx1262_done:
    rx1262_cur."!cursor_fail"()
    if_null rx1262_debug, debug_934
    rx1262_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_934:
    .return (rx1262_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("283_1297619321.796") :method
.annotate 'line', 4
    $P1264 = self."!PREFIX__!subrule"("O", "--")
    new $P1265, "ResizablePMCArray"
    push $P1265, $P1264
    .return ($P1265)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("284_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1269_tgt
    .local int rx1269_pos
    .local int rx1269_off
    .local int rx1269_eos
    .local int rx1269_rep
    .local pmc rx1269_cur
    .local pmc rx1269_debug
    (rx1269_cur, rx1269_pos, rx1269_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1269_cur
    .local pmc match
    .lex "$/", match
    length rx1269_eos, rx1269_tgt
    gt rx1269_pos, rx1269_eos, rx1269_done
    set rx1269_off, 0
    lt rx1269_pos, 2, rx1269_start
    sub rx1269_off, rx1269_pos, 1
    substr rx1269_tgt, rx1269_tgt, rx1269_off
  rx1269_start:
    eq $I10, 1, rx1269_restart
    if_null rx1269_debug, debug_935
    rx1269_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_935:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1273_done
    goto rxscan1273_scan
  rxscan1273_loop:
    (rx1269_pos) = rx1269_cur."from"()
    inc rx1269_pos
    rx1269_cur."!cursor_from"(rx1269_pos)
    ge rx1269_pos, rx1269_eos, rxscan1273_done
  rxscan1273_scan:
    set_addr $I10, rxscan1273_loop
    rx1269_cur."!mark_push"(0, rx1269_pos, $I10)
  rxscan1273_done:
.annotate 'line', 585
  # rx subcapture "sym"
    set_addr $I10, rxcap_1274_fail
    rx1269_cur."!mark_push"(0, rx1269_pos, $I10)
  # rx literal  "++"
    add $I11, rx1269_pos, 2
    gt $I11, rx1269_eos, rx1269_fail
    sub $I11, rx1269_pos, rx1269_off
    substr $S10, rx1269_tgt, $I11, 2
    ne $S10, "++", rx1269_fail
    add rx1269_pos, 2
    set_addr $I10, rxcap_1274_fail
    ($I12, $I11) = rx1269_cur."!mark_peek"($I10)
    rx1269_cur."!cursor_pos"($I11)
    ($P10) = rx1269_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1269_pos, "")
    rx1269_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1274_done
  rxcap_1274_fail:
    goto rx1269_fail
  rxcap_1274_done:
  # rx subrule "O" subtype=capture negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."O"("%autoincrement")
    unless $P10, rx1269_fail
    rx1269_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1269_pos = $P10."pos"()
  # rx pass
    rx1269_cur."!cursor_pass"(rx1269_pos, "postfix:sym<++>")
    if_null rx1269_debug, debug_936
    rx1269_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1269_pos)
  debug_936:
    .return (rx1269_cur)
  rx1269_restart:
.annotate 'line', 4
    if_null rx1269_debug, debug_937
    rx1269_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_937:
  rx1269_fail:
    (rx1269_rep, rx1269_pos, $I10, $P10) = rx1269_cur."!mark_fail"(0)
    lt rx1269_pos, -1, rx1269_done
    eq rx1269_pos, -1, rx1269_fail
    jump $I10
  rx1269_done:
    rx1269_cur."!cursor_fail"()
    if_null rx1269_debug, debug_938
    rx1269_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_938:
    .return (rx1269_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("285_1297619321.796") :method
.annotate 'line', 4
    $P1271 = self."!PREFIX__!subrule"("O", "++")
    new $P1272, "ResizablePMCArray"
    push $P1272, $P1271
    .return ($P1272)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("286_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1276_tgt
    .local int rx1276_pos
    .local int rx1276_off
    .local int rx1276_eos
    .local int rx1276_rep
    .local pmc rx1276_cur
    .local pmc rx1276_debug
    (rx1276_cur, rx1276_pos, rx1276_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1276_cur
    .local pmc match
    .lex "$/", match
    length rx1276_eos, rx1276_tgt
    gt rx1276_pos, rx1276_eos, rx1276_done
    set rx1276_off, 0
    lt rx1276_pos, 2, rx1276_start
    sub rx1276_off, rx1276_pos, 1
    substr rx1276_tgt, rx1276_tgt, rx1276_off
  rx1276_start:
    eq $I10, 1, rx1276_restart
    if_null rx1276_debug, debug_939
    rx1276_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_939:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1280_done
    goto rxscan1280_scan
  rxscan1280_loop:
    (rx1276_pos) = rx1276_cur."from"()
    inc rx1276_pos
    rx1276_cur."!cursor_from"(rx1276_pos)
    ge rx1276_pos, rx1276_eos, rxscan1280_done
  rxscan1280_scan:
    set_addr $I10, rxscan1280_loop
    rx1276_cur."!mark_push"(0, rx1276_pos, $I10)
  rxscan1280_done:
.annotate 'line', 586
  # rx subcapture "sym"
    set_addr $I10, rxcap_1281_fail
    rx1276_cur."!mark_push"(0, rx1276_pos, $I10)
  # rx literal  "--"
    add $I11, rx1276_pos, 2
    gt $I11, rx1276_eos, rx1276_fail
    sub $I11, rx1276_pos, rx1276_off
    substr $S10, rx1276_tgt, $I11, 2
    ne $S10, "--", rx1276_fail
    add rx1276_pos, 2
    set_addr $I10, rxcap_1281_fail
    ($I12, $I11) = rx1276_cur."!mark_peek"($I10)
    rx1276_cur."!cursor_pos"($I11)
    ($P10) = rx1276_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1276_pos, "")
    rx1276_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1281_done
  rxcap_1281_fail:
    goto rx1276_fail
  rxcap_1281_done:
  # rx subrule "O" subtype=capture negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."O"("%autoincrement")
    unless $P10, rx1276_fail
    rx1276_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1276_pos = $P10."pos"()
  # rx pass
    rx1276_cur."!cursor_pass"(rx1276_pos, "postfix:sym<-->")
    if_null rx1276_debug, debug_940
    rx1276_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1276_pos)
  debug_940:
    .return (rx1276_cur)
  rx1276_restart:
.annotate 'line', 4
    if_null rx1276_debug, debug_941
    rx1276_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_941:
  rx1276_fail:
    (rx1276_rep, rx1276_pos, $I10, $P10) = rx1276_cur."!mark_fail"(0)
    lt rx1276_pos, -1, rx1276_done
    eq rx1276_pos, -1, rx1276_fail
    jump $I10
  rx1276_done:
    rx1276_cur."!cursor_fail"()
    if_null rx1276_debug, debug_942
    rx1276_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_942:
    .return (rx1276_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("287_1297619321.796") :method
.annotate 'line', 4
    $P1278 = self."!PREFIX__!subrule"("O", "--")
    new $P1279, "ResizablePMCArray"
    push $P1279, $P1278
    .return ($P1279)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("288_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1283_tgt
    .local int rx1283_pos
    .local int rx1283_off
    .local int rx1283_eos
    .local int rx1283_rep
    .local pmc rx1283_cur
    .local pmc rx1283_debug
    (rx1283_cur, rx1283_pos, rx1283_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1283_cur
    .local pmc match
    .lex "$/", match
    length rx1283_eos, rx1283_tgt
    gt rx1283_pos, rx1283_eos, rx1283_done
    set rx1283_off, 0
    lt rx1283_pos, 2, rx1283_start
    sub rx1283_off, rx1283_pos, 1
    substr rx1283_tgt, rx1283_tgt, rx1283_off
  rx1283_start:
    eq $I10, 1, rx1283_restart
    if_null rx1283_debug, debug_943
    rx1283_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_943:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1287_done
    goto rxscan1287_scan
  rxscan1287_loop:
    (rx1283_pos) = rx1283_cur."from"()
    inc rx1283_pos
    rx1283_cur."!cursor_from"(rx1283_pos)
    ge rx1283_pos, rx1283_eos, rxscan1287_done
  rxscan1287_scan:
    set_addr $I10, rxscan1287_loop
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  rxscan1287_done:
.annotate 'line', 588
  # rx subcapture "sym"
    set_addr $I10, rxcap_1288_fail
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "**"
    add $I11, rx1283_pos, 2
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 2
    ne $S10, "**", rx1283_fail
    add rx1283_pos, 2
    set_addr $I10, rxcap_1288_fail
    ($I12, $I11) = rx1283_cur."!mark_peek"($I10)
    rx1283_cur."!cursor_pos"($I11)
    ($P10) = rx1283_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1283_pos, "")
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1288_done
  rxcap_1288_fail:
    goto rx1283_fail
  rxcap_1288_done:
  # rx subrule "O" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1283_pos = $P10."pos"()
  # rx pass
    rx1283_cur."!cursor_pass"(rx1283_pos, "infix:sym<**>")
    if_null rx1283_debug, debug_944
    rx1283_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1283_pos)
  debug_944:
    .return (rx1283_cur)
  rx1283_restart:
.annotate 'line', 4
    if_null rx1283_debug, debug_945
    rx1283_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_945:
  rx1283_fail:
    (rx1283_rep, rx1283_pos, $I10, $P10) = rx1283_cur."!mark_fail"(0)
    lt rx1283_pos, -1, rx1283_done
    eq rx1283_pos, -1, rx1283_fail
    jump $I10
  rx1283_done:
    rx1283_cur."!cursor_fail"()
    if_null rx1283_debug, debug_946
    rx1283_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_946:
    .return (rx1283_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("289_1297619321.796") :method
.annotate 'line', 4
    $P1285 = self."!PREFIX__!subrule"("O", "**")
    new $P1286, "ResizablePMCArray"
    push $P1286, $P1285
    .return ($P1286)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("290_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1290_tgt
    .local int rx1290_pos
    .local int rx1290_off
    .local int rx1290_eos
    .local int rx1290_rep
    .local pmc rx1290_cur
    .local pmc rx1290_debug
    (rx1290_cur, rx1290_pos, rx1290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1290_cur
    .local pmc match
    .lex "$/", match
    length rx1290_eos, rx1290_tgt
    gt rx1290_pos, rx1290_eos, rx1290_done
    set rx1290_off, 0
    lt rx1290_pos, 2, rx1290_start
    sub rx1290_off, rx1290_pos, 1
    substr rx1290_tgt, rx1290_tgt, rx1290_off
  rx1290_start:
    eq $I10, 1, rx1290_restart
    if_null rx1290_debug, debug_947
    rx1290_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_947:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1294_done
    goto rxscan1294_scan
  rxscan1294_loop:
    (rx1290_pos) = rx1290_cur."from"()
    inc rx1290_pos
    rx1290_cur."!cursor_from"(rx1290_pos)
    ge rx1290_pos, rx1290_eos, rxscan1294_done
  rxscan1294_scan:
    set_addr $I10, rxscan1294_loop
    rx1290_cur."!mark_push"(0, rx1290_pos, $I10)
  rxscan1294_done:
.annotate 'line', 590
  # rx subcapture "sym"
    set_addr $I10, rxcap_1295_fail
    rx1290_cur."!mark_push"(0, rx1290_pos, $I10)
  # rx literal  "+"
    add $I11, rx1290_pos, 1
    gt $I11, rx1290_eos, rx1290_fail
    sub $I11, rx1290_pos, rx1290_off
    ord $I11, rx1290_tgt, $I11
    ne $I11, 43, rx1290_fail
    add rx1290_pos, 1
    set_addr $I10, rxcap_1295_fail
    ($I12, $I11) = rx1290_cur."!mark_peek"($I10)
    rx1290_cur."!cursor_pos"($I11)
    ($P10) = rx1290_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1290_pos, "")
    rx1290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1295_done
  rxcap_1295_fail:
    goto rx1290_fail
  rxcap_1295_done:
  # rx subrule "O" subtype=capture negate=
    rx1290_cur."!cursor_pos"(rx1290_pos)
    $P10 = rx1290_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1290_fail
    rx1290_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1290_pos = $P10."pos"()
  # rx pass
    rx1290_cur."!cursor_pass"(rx1290_pos, "prefix:sym<+>")
    if_null rx1290_debug, debug_948
    rx1290_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1290_pos)
  debug_948:
    .return (rx1290_cur)
  rx1290_restart:
.annotate 'line', 4
    if_null rx1290_debug, debug_949
    rx1290_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_949:
  rx1290_fail:
    (rx1290_rep, rx1290_pos, $I10, $P10) = rx1290_cur."!mark_fail"(0)
    lt rx1290_pos, -1, rx1290_done
    eq rx1290_pos, -1, rx1290_fail
    jump $I10
  rx1290_done:
    rx1290_cur."!cursor_fail"()
    if_null rx1290_debug, debug_950
    rx1290_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_950:
    .return (rx1290_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("291_1297619321.796") :method
.annotate 'line', 4
    $P1292 = self."!PREFIX__!subrule"("O", "+")
    new $P1293, "ResizablePMCArray"
    push $P1293, $P1292
    .return ($P1293)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("292_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1297_tgt
    .local int rx1297_pos
    .local int rx1297_off
    .local int rx1297_eos
    .local int rx1297_rep
    .local pmc rx1297_cur
    .local pmc rx1297_debug
    (rx1297_cur, rx1297_pos, rx1297_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1297_cur
    .local pmc match
    .lex "$/", match
    length rx1297_eos, rx1297_tgt
    gt rx1297_pos, rx1297_eos, rx1297_done
    set rx1297_off, 0
    lt rx1297_pos, 2, rx1297_start
    sub rx1297_off, rx1297_pos, 1
    substr rx1297_tgt, rx1297_tgt, rx1297_off
  rx1297_start:
    eq $I10, 1, rx1297_restart
    if_null rx1297_debug, debug_951
    rx1297_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_951:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1301_done
    goto rxscan1301_scan
  rxscan1301_loop:
    (rx1297_pos) = rx1297_cur."from"()
    inc rx1297_pos
    rx1297_cur."!cursor_from"(rx1297_pos)
    ge rx1297_pos, rx1297_eos, rxscan1301_done
  rxscan1301_scan:
    set_addr $I10, rxscan1301_loop
    rx1297_cur."!mark_push"(0, rx1297_pos, $I10)
  rxscan1301_done:
.annotate 'line', 591
  # rx subcapture "sym"
    set_addr $I10, rxcap_1302_fail
    rx1297_cur."!mark_push"(0, rx1297_pos, $I10)
  # rx literal  "~"
    add $I11, rx1297_pos, 1
    gt $I11, rx1297_eos, rx1297_fail
    sub $I11, rx1297_pos, rx1297_off
    ord $I11, rx1297_tgt, $I11
    ne $I11, 126, rx1297_fail
    add rx1297_pos, 1
    set_addr $I10, rxcap_1302_fail
    ($I12, $I11) = rx1297_cur."!mark_peek"($I10)
    rx1297_cur."!cursor_pos"($I11)
    ($P10) = rx1297_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1297_pos, "")
    rx1297_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1302_done
  rxcap_1302_fail:
    goto rx1297_fail
  rxcap_1302_done:
  # rx subrule "O" subtype=capture negate=
    rx1297_cur."!cursor_pos"(rx1297_pos)
    $P10 = rx1297_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1297_fail
    rx1297_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1297_pos = $P10."pos"()
  # rx pass
    rx1297_cur."!cursor_pass"(rx1297_pos, "prefix:sym<~>")
    if_null rx1297_debug, debug_952
    rx1297_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1297_pos)
  debug_952:
    .return (rx1297_cur)
  rx1297_restart:
.annotate 'line', 4
    if_null rx1297_debug, debug_953
    rx1297_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_953:
  rx1297_fail:
    (rx1297_rep, rx1297_pos, $I10, $P10) = rx1297_cur."!mark_fail"(0)
    lt rx1297_pos, -1, rx1297_done
    eq rx1297_pos, -1, rx1297_fail
    jump $I10
  rx1297_done:
    rx1297_cur."!cursor_fail"()
    if_null rx1297_debug, debug_954
    rx1297_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_954:
    .return (rx1297_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("293_1297619321.796") :method
.annotate 'line', 4
    $P1299 = self."!PREFIX__!subrule"("O", "~")
    new $P1300, "ResizablePMCArray"
    push $P1300, $P1299
    .return ($P1300)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("294_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1304_tgt
    .local int rx1304_pos
    .local int rx1304_off
    .local int rx1304_eos
    .local int rx1304_rep
    .local pmc rx1304_cur
    .local pmc rx1304_debug
    (rx1304_cur, rx1304_pos, rx1304_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1304_cur
    .local pmc match
    .lex "$/", match
    length rx1304_eos, rx1304_tgt
    gt rx1304_pos, rx1304_eos, rx1304_done
    set rx1304_off, 0
    lt rx1304_pos, 2, rx1304_start
    sub rx1304_off, rx1304_pos, 1
    substr rx1304_tgt, rx1304_tgt, rx1304_off
  rx1304_start:
    eq $I10, 1, rx1304_restart
    if_null rx1304_debug, debug_955
    rx1304_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_955:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1307_done
    goto rxscan1307_scan
  rxscan1307_loop:
    (rx1304_pos) = rx1304_cur."from"()
    inc rx1304_pos
    rx1304_cur."!cursor_from"(rx1304_pos)
    ge rx1304_pos, rx1304_eos, rxscan1307_done
  rxscan1307_scan:
    set_addr $I10, rxscan1307_loop
    rx1304_cur."!mark_push"(0, rx1304_pos, $I10)
  rxscan1307_done:
.annotate 'line', 592
  # rx subcapture "sym"
    set_addr $I10, rxcap_1308_fail
    rx1304_cur."!mark_push"(0, rx1304_pos, $I10)
  # rx literal  "-"
    add $I11, rx1304_pos, 1
    gt $I11, rx1304_eos, rx1304_fail
    sub $I11, rx1304_pos, rx1304_off
    ord $I11, rx1304_tgt, $I11
    ne $I11, 45, rx1304_fail
    add rx1304_pos, 1
    set_addr $I10, rxcap_1308_fail
    ($I12, $I11) = rx1304_cur."!mark_peek"($I10)
    rx1304_cur."!cursor_pos"($I11)
    ($P10) = rx1304_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1304_pos, "")
    rx1304_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1308_done
  rxcap_1308_fail:
    goto rx1304_fail
  rxcap_1308_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1304_pos, rx1304_off
    substr $S10, rx1304_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1304_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."number"()
    if $P10, rx1304_fail
  # rx subrule "O" subtype=capture negate=
    rx1304_cur."!cursor_pos"(rx1304_pos)
    $P10 = rx1304_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1304_fail
    rx1304_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1304_pos = $P10."pos"()
  # rx pass
    rx1304_cur."!cursor_pass"(rx1304_pos, "prefix:sym<->")
    if_null rx1304_debug, debug_956
    rx1304_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1304_pos)
  debug_956:
    .return (rx1304_cur)
  rx1304_restart:
.annotate 'line', 4
    if_null rx1304_debug, debug_957
    rx1304_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_957:
  rx1304_fail:
    (rx1304_rep, rx1304_pos, $I10, $P10) = rx1304_cur."!mark_fail"(0)
    lt rx1304_pos, -1, rx1304_done
    eq rx1304_pos, -1, rx1304_fail
    jump $I10
  rx1304_done:
    rx1304_cur."!cursor_fail"()
    if_null rx1304_debug, debug_958
    rx1304_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_958:
    .return (rx1304_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("295_1297619321.796") :method
.annotate 'line', 4
    new $P1306, "ResizablePMCArray"
    push $P1306, "-"
    .return ($P1306)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("296_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1310_tgt
    .local int rx1310_pos
    .local int rx1310_off
    .local int rx1310_eos
    .local int rx1310_rep
    .local pmc rx1310_cur
    .local pmc rx1310_debug
    (rx1310_cur, rx1310_pos, rx1310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1310_cur
    .local pmc match
    .lex "$/", match
    length rx1310_eos, rx1310_tgt
    gt rx1310_pos, rx1310_eos, rx1310_done
    set rx1310_off, 0
    lt rx1310_pos, 2, rx1310_start
    sub rx1310_off, rx1310_pos, 1
    substr rx1310_tgt, rx1310_tgt, rx1310_off
  rx1310_start:
    eq $I10, 1, rx1310_restart
    if_null rx1310_debug, debug_959
    rx1310_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_959:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1314_done
    goto rxscan1314_scan
  rxscan1314_loop:
    (rx1310_pos) = rx1310_cur."from"()
    inc rx1310_pos
    rx1310_cur."!cursor_from"(rx1310_pos)
    ge rx1310_pos, rx1310_eos, rxscan1314_done
  rxscan1314_scan:
    set_addr $I10, rxscan1314_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  rxscan1314_done:
.annotate 'line', 593
  # rx subcapture "sym"
    set_addr $I10, rxcap_1315_fail
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  # rx literal  "?"
    add $I11, rx1310_pos, 1
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    ord $I11, rx1310_tgt, $I11
    ne $I11, 63, rx1310_fail
    add rx1310_pos, 1
    set_addr $I10, rxcap_1315_fail
    ($I12, $I11) = rx1310_cur."!mark_peek"($I10)
    rx1310_cur."!cursor_pos"($I11)
    ($P10) = rx1310_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1310_pos, "")
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1315_done
  rxcap_1315_fail:
    goto rx1310_fail
  rxcap_1315_done:
  # rx subrule "O" subtype=capture negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1310_fail
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1310_pos = $P10."pos"()
  # rx pass
    rx1310_cur."!cursor_pass"(rx1310_pos, "prefix:sym<?>")
    if_null rx1310_debug, debug_960
    rx1310_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1310_pos)
  debug_960:
    .return (rx1310_cur)
  rx1310_restart:
.annotate 'line', 4
    if_null rx1310_debug, debug_961
    rx1310_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_961:
  rx1310_fail:
    (rx1310_rep, rx1310_pos, $I10, $P10) = rx1310_cur."!mark_fail"(0)
    lt rx1310_pos, -1, rx1310_done
    eq rx1310_pos, -1, rx1310_fail
    jump $I10
  rx1310_done:
    rx1310_cur."!cursor_fail"()
    if_null rx1310_debug, debug_962
    rx1310_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_962:
    .return (rx1310_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("297_1297619321.796") :method
.annotate 'line', 4
    $P1312 = self."!PREFIX__!subrule"("O", "?")
    new $P1313, "ResizablePMCArray"
    push $P1313, $P1312
    .return ($P1313)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("298_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1317_tgt
    .local int rx1317_pos
    .local int rx1317_off
    .local int rx1317_eos
    .local int rx1317_rep
    .local pmc rx1317_cur
    .local pmc rx1317_debug
    (rx1317_cur, rx1317_pos, rx1317_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1317_cur
    .local pmc match
    .lex "$/", match
    length rx1317_eos, rx1317_tgt
    gt rx1317_pos, rx1317_eos, rx1317_done
    set rx1317_off, 0
    lt rx1317_pos, 2, rx1317_start
    sub rx1317_off, rx1317_pos, 1
    substr rx1317_tgt, rx1317_tgt, rx1317_off
  rx1317_start:
    eq $I10, 1, rx1317_restart
    if_null rx1317_debug, debug_963
    rx1317_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_963:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1321_done
    goto rxscan1321_scan
  rxscan1321_loop:
    (rx1317_pos) = rx1317_cur."from"()
    inc rx1317_pos
    rx1317_cur."!cursor_from"(rx1317_pos)
    ge rx1317_pos, rx1317_eos, rxscan1321_done
  rxscan1321_scan:
    set_addr $I10, rxscan1321_loop
    rx1317_cur."!mark_push"(0, rx1317_pos, $I10)
  rxscan1321_done:
.annotate 'line', 594
  # rx subcapture "sym"
    set_addr $I10, rxcap_1322_fail
    rx1317_cur."!mark_push"(0, rx1317_pos, $I10)
  # rx literal  "!"
    add $I11, rx1317_pos, 1
    gt $I11, rx1317_eos, rx1317_fail
    sub $I11, rx1317_pos, rx1317_off
    ord $I11, rx1317_tgt, $I11
    ne $I11, 33, rx1317_fail
    add rx1317_pos, 1
    set_addr $I10, rxcap_1322_fail
    ($I12, $I11) = rx1317_cur."!mark_peek"($I10)
    rx1317_cur."!cursor_pos"($I11)
    ($P10) = rx1317_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1317_pos, "")
    rx1317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1322_done
  rxcap_1322_fail:
    goto rx1317_fail
  rxcap_1322_done:
  # rx subrule "O" subtype=capture negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1317_fail
    rx1317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1317_pos = $P10."pos"()
  # rx pass
    rx1317_cur."!cursor_pass"(rx1317_pos, "prefix:sym<!>")
    if_null rx1317_debug, debug_964
    rx1317_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1317_pos)
  debug_964:
    .return (rx1317_cur)
  rx1317_restart:
.annotate 'line', 4
    if_null rx1317_debug, debug_965
    rx1317_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_965:
  rx1317_fail:
    (rx1317_rep, rx1317_pos, $I10, $P10) = rx1317_cur."!mark_fail"(0)
    lt rx1317_pos, -1, rx1317_done
    eq rx1317_pos, -1, rx1317_fail
    jump $I10
  rx1317_done:
    rx1317_cur."!cursor_fail"()
    if_null rx1317_debug, debug_966
    rx1317_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_966:
    .return (rx1317_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("299_1297619321.796") :method
.annotate 'line', 4
    $P1319 = self."!PREFIX__!subrule"("O", "!")
    new $P1320, "ResizablePMCArray"
    push $P1320, $P1319
    .return ($P1320)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("300_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1324_tgt
    .local int rx1324_pos
    .local int rx1324_off
    .local int rx1324_eos
    .local int rx1324_rep
    .local pmc rx1324_cur
    .local pmc rx1324_debug
    (rx1324_cur, rx1324_pos, rx1324_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1324_cur
    .local pmc match
    .lex "$/", match
    length rx1324_eos, rx1324_tgt
    gt rx1324_pos, rx1324_eos, rx1324_done
    set rx1324_off, 0
    lt rx1324_pos, 2, rx1324_start
    sub rx1324_off, rx1324_pos, 1
    substr rx1324_tgt, rx1324_tgt, rx1324_off
  rx1324_start:
    eq $I10, 1, rx1324_restart
    if_null rx1324_debug, debug_967
    rx1324_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_967:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1328_done
    goto rxscan1328_scan
  rxscan1328_loop:
    (rx1324_pos) = rx1324_cur."from"()
    inc rx1324_pos
    rx1324_cur."!cursor_from"(rx1324_pos)
    ge rx1324_pos, rx1324_eos, rxscan1328_done
  rxscan1328_scan:
    set_addr $I10, rxscan1328_loop
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  rxscan1328_done:
.annotate 'line', 595
  # rx subcapture "sym"
    set_addr $I10, rxcap_1329_fail
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  # rx literal  "|"
    add $I11, rx1324_pos, 1
    gt $I11, rx1324_eos, rx1324_fail
    sub $I11, rx1324_pos, rx1324_off
    ord $I11, rx1324_tgt, $I11
    ne $I11, 124, rx1324_fail
    add rx1324_pos, 1
    set_addr $I10, rxcap_1329_fail
    ($I12, $I11) = rx1324_cur."!mark_peek"($I10)
    rx1324_cur."!cursor_pos"($I11)
    ($P10) = rx1324_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1324_pos, "")
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1329_done
  rxcap_1329_fail:
    goto rx1324_fail
  rxcap_1329_done:
  # rx subrule "O" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."O"("%symbolic_unary")
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1324_pos = $P10."pos"()
  # rx pass
    rx1324_cur."!cursor_pass"(rx1324_pos, "prefix:sym<|>")
    if_null rx1324_debug, debug_968
    rx1324_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1324_pos)
  debug_968:
    .return (rx1324_cur)
  rx1324_restart:
.annotate 'line', 4
    if_null rx1324_debug, debug_969
    rx1324_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_969:
  rx1324_fail:
    (rx1324_rep, rx1324_pos, $I10, $P10) = rx1324_cur."!mark_fail"(0)
    lt rx1324_pos, -1, rx1324_done
    eq rx1324_pos, -1, rx1324_fail
    jump $I10
  rx1324_done:
    rx1324_cur."!cursor_fail"()
    if_null rx1324_debug, debug_970
    rx1324_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_970:
    .return (rx1324_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("301_1297619321.796") :method
.annotate 'line', 4
    $P1326 = self."!PREFIX__!subrule"("O", "|")
    new $P1327, "ResizablePMCArray"
    push $P1327, $P1326
    .return ($P1327)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("302_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1331_tgt
    .local int rx1331_pos
    .local int rx1331_off
    .local int rx1331_eos
    .local int rx1331_rep
    .local pmc rx1331_cur
    .local pmc rx1331_debug
    (rx1331_cur, rx1331_pos, rx1331_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1331_cur
    .local pmc match
    .lex "$/", match
    length rx1331_eos, rx1331_tgt
    gt rx1331_pos, rx1331_eos, rx1331_done
    set rx1331_off, 0
    lt rx1331_pos, 2, rx1331_start
    sub rx1331_off, rx1331_pos, 1
    substr rx1331_tgt, rx1331_tgt, rx1331_off
  rx1331_start:
    eq $I10, 1, rx1331_restart
    if_null rx1331_debug, debug_971
    rx1331_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_971:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1335_done
    goto rxscan1335_scan
  rxscan1335_loop:
    (rx1331_pos) = rx1331_cur."from"()
    inc rx1331_pos
    rx1331_cur."!cursor_from"(rx1331_pos)
    ge rx1331_pos, rx1331_eos, rxscan1335_done
  rxscan1335_scan:
    set_addr $I10, rxscan1335_loop
    rx1331_cur."!mark_push"(0, rx1331_pos, $I10)
  rxscan1335_done:
.annotate 'line', 597
  # rx subcapture "sym"
    set_addr $I10, rxcap_1336_fail
    rx1331_cur."!mark_push"(0, rx1331_pos, $I10)
  # rx literal  "*"
    add $I11, rx1331_pos, 1
    gt $I11, rx1331_eos, rx1331_fail
    sub $I11, rx1331_pos, rx1331_off
    ord $I11, rx1331_tgt, $I11
    ne $I11, 42, rx1331_fail
    add rx1331_pos, 1
    set_addr $I10, rxcap_1336_fail
    ($I12, $I11) = rx1331_cur."!mark_peek"($I10)
    rx1331_cur."!cursor_pos"($I11)
    ($P10) = rx1331_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1331_pos, "")
    rx1331_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1336_done
  rxcap_1336_fail:
    goto rx1331_fail
  rxcap_1336_done:
  # rx subrule "O" subtype=capture negate=
    rx1331_cur."!cursor_pos"(rx1331_pos)
    $P10 = rx1331_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1331_fail
    rx1331_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1331_pos = $P10."pos"()
  # rx pass
    rx1331_cur."!cursor_pass"(rx1331_pos, "infix:sym<*>")
    if_null rx1331_debug, debug_972
    rx1331_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1331_pos)
  debug_972:
    .return (rx1331_cur)
  rx1331_restart:
.annotate 'line', 4
    if_null rx1331_debug, debug_973
    rx1331_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_973:
  rx1331_fail:
    (rx1331_rep, rx1331_pos, $I10, $P10) = rx1331_cur."!mark_fail"(0)
    lt rx1331_pos, -1, rx1331_done
    eq rx1331_pos, -1, rx1331_fail
    jump $I10
  rx1331_done:
    rx1331_cur."!cursor_fail"()
    if_null rx1331_debug, debug_974
    rx1331_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_974:
    .return (rx1331_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("303_1297619321.796") :method
.annotate 'line', 4
    $P1333 = self."!PREFIX__!subrule"("O", "*")
    new $P1334, "ResizablePMCArray"
    push $P1334, $P1333
    .return ($P1334)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("304_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1338_tgt
    .local int rx1338_pos
    .local int rx1338_off
    .local int rx1338_eos
    .local int rx1338_rep
    .local pmc rx1338_cur
    .local pmc rx1338_debug
    (rx1338_cur, rx1338_pos, rx1338_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1338_cur
    .local pmc match
    .lex "$/", match
    length rx1338_eos, rx1338_tgt
    gt rx1338_pos, rx1338_eos, rx1338_done
    set rx1338_off, 0
    lt rx1338_pos, 2, rx1338_start
    sub rx1338_off, rx1338_pos, 1
    substr rx1338_tgt, rx1338_tgt, rx1338_off
  rx1338_start:
    eq $I10, 1, rx1338_restart
    if_null rx1338_debug, debug_975
    rx1338_cur."!cursor_debug"("START", "infix:sym</>")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1342_done
    goto rxscan1342_scan
  rxscan1342_loop:
    (rx1338_pos) = rx1338_cur."from"()
    inc rx1338_pos
    rx1338_cur."!cursor_from"(rx1338_pos)
    ge rx1338_pos, rx1338_eos, rxscan1342_done
  rxscan1342_scan:
    set_addr $I10, rxscan1342_loop
    rx1338_cur."!mark_push"(0, rx1338_pos, $I10)
  rxscan1342_done:
.annotate 'line', 598
  # rx subcapture "sym"
    set_addr $I10, rxcap_1343_fail
    rx1338_cur."!mark_push"(0, rx1338_pos, $I10)
  # rx literal  "/"
    add $I11, rx1338_pos, 1
    gt $I11, rx1338_eos, rx1338_fail
    sub $I11, rx1338_pos, rx1338_off
    ord $I11, rx1338_tgt, $I11
    ne $I11, 47, rx1338_fail
    add rx1338_pos, 1
    set_addr $I10, rxcap_1343_fail
    ($I12, $I11) = rx1338_cur."!mark_peek"($I10)
    rx1338_cur."!cursor_pos"($I11)
    ($P10) = rx1338_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1338_pos, "")
    rx1338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1343_done
  rxcap_1343_fail:
    goto rx1338_fail
  rxcap_1343_done:
  # rx subrule "O" subtype=capture negate=
    rx1338_cur."!cursor_pos"(rx1338_pos)
    $P10 = rx1338_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1338_fail
    rx1338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1338_pos = $P10."pos"()
  # rx pass
    rx1338_cur."!cursor_pass"(rx1338_pos, "infix:sym</>")
    if_null rx1338_debug, debug_976
    rx1338_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1338_pos)
  debug_976:
    .return (rx1338_cur)
  rx1338_restart:
.annotate 'line', 4
    if_null rx1338_debug, debug_977
    rx1338_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_977:
  rx1338_fail:
    (rx1338_rep, rx1338_pos, $I10, $P10) = rx1338_cur."!mark_fail"(0)
    lt rx1338_pos, -1, rx1338_done
    eq rx1338_pos, -1, rx1338_fail
    jump $I10
  rx1338_done:
    rx1338_cur."!cursor_fail"()
    if_null rx1338_debug, debug_978
    rx1338_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_978:
    .return (rx1338_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("305_1297619321.796") :method
.annotate 'line', 4
    $P1340 = self."!PREFIX__!subrule"("O", "/")
    new $P1341, "ResizablePMCArray"
    push $P1341, $P1340
    .return ($P1341)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("306_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1345_tgt
    .local int rx1345_pos
    .local int rx1345_off
    .local int rx1345_eos
    .local int rx1345_rep
    .local pmc rx1345_cur
    .local pmc rx1345_debug
    (rx1345_cur, rx1345_pos, rx1345_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1345_cur
    .local pmc match
    .lex "$/", match
    length rx1345_eos, rx1345_tgt
    gt rx1345_pos, rx1345_eos, rx1345_done
    set rx1345_off, 0
    lt rx1345_pos, 2, rx1345_start
    sub rx1345_off, rx1345_pos, 1
    substr rx1345_tgt, rx1345_tgt, rx1345_off
  rx1345_start:
    eq $I10, 1, rx1345_restart
    if_null rx1345_debug, debug_979
    rx1345_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1349_done
    goto rxscan1349_scan
  rxscan1349_loop:
    (rx1345_pos) = rx1345_cur."from"()
    inc rx1345_pos
    rx1345_cur."!cursor_from"(rx1345_pos)
    ge rx1345_pos, rx1345_eos, rxscan1349_done
  rxscan1349_scan:
    set_addr $I10, rxscan1349_loop
    rx1345_cur."!mark_push"(0, rx1345_pos, $I10)
  rxscan1349_done:
.annotate 'line', 599
  # rx subcapture "sym"
    set_addr $I10, rxcap_1350_fail
    rx1345_cur."!mark_push"(0, rx1345_pos, $I10)
  # rx literal  "%"
    add $I11, rx1345_pos, 1
    gt $I11, rx1345_eos, rx1345_fail
    sub $I11, rx1345_pos, rx1345_off
    ord $I11, rx1345_tgt, $I11
    ne $I11, 37, rx1345_fail
    add rx1345_pos, 1
    set_addr $I10, rxcap_1350_fail
    ($I12, $I11) = rx1345_cur."!mark_peek"($I10)
    rx1345_cur."!cursor_pos"($I11)
    ($P10) = rx1345_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1345_pos, "")
    rx1345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1350_done
  rxcap_1350_fail:
    goto rx1345_fail
  rxcap_1350_done:
  # rx subrule "O" subtype=capture negate=
    rx1345_cur."!cursor_pos"(rx1345_pos)
    $P10 = rx1345_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1345_fail
    rx1345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1345_pos = $P10."pos"()
  # rx pass
    rx1345_cur."!cursor_pass"(rx1345_pos, "infix:sym<%>")
    if_null rx1345_debug, debug_980
    rx1345_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1345_pos)
  debug_980:
    .return (rx1345_cur)
  rx1345_restart:
.annotate 'line', 4
    if_null rx1345_debug, debug_981
    rx1345_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_981:
  rx1345_fail:
    (rx1345_rep, rx1345_pos, $I10, $P10) = rx1345_cur."!mark_fail"(0)
    lt rx1345_pos, -1, rx1345_done
    eq rx1345_pos, -1, rx1345_fail
    jump $I10
  rx1345_done:
    rx1345_cur."!cursor_fail"()
    if_null rx1345_debug, debug_982
    rx1345_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_982:
    .return (rx1345_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("307_1297619321.796") :method
.annotate 'line', 4
    $P1347 = self."!PREFIX__!subrule"("O", "%")
    new $P1348, "ResizablePMCArray"
    push $P1348, $P1347
    .return ($P1348)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("308_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1352_tgt
    .local int rx1352_pos
    .local int rx1352_off
    .local int rx1352_eos
    .local int rx1352_rep
    .local pmc rx1352_cur
    .local pmc rx1352_debug
    (rx1352_cur, rx1352_pos, rx1352_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1352_cur
    .local pmc match
    .lex "$/", match
    length rx1352_eos, rx1352_tgt
    gt rx1352_pos, rx1352_eos, rx1352_done
    set rx1352_off, 0
    lt rx1352_pos, 2, rx1352_start
    sub rx1352_off, rx1352_pos, 1
    substr rx1352_tgt, rx1352_tgt, rx1352_off
  rx1352_start:
    eq $I10, 1, rx1352_restart
    if_null rx1352_debug, debug_983
    rx1352_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1356_done
    goto rxscan1356_scan
  rxscan1356_loop:
    (rx1352_pos) = rx1352_cur."from"()
    inc rx1352_pos
    rx1352_cur."!cursor_from"(rx1352_pos)
    ge rx1352_pos, rx1352_eos, rxscan1356_done
  rxscan1356_scan:
    set_addr $I10, rxscan1356_loop
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxscan1356_done:
.annotate 'line', 600
  # rx subcapture "sym"
    set_addr $I10, rxcap_1357_fail
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1352_pos, 2
    gt $I11, rx1352_eos, rx1352_fail
    sub $I11, rx1352_pos, rx1352_off
    substr $S10, rx1352_tgt, $I11, 2
    ne $S10, "+&", rx1352_fail
    add rx1352_pos, 2
    set_addr $I10, rxcap_1357_fail
    ($I12, $I11) = rx1352_cur."!mark_peek"($I10)
    rx1352_cur."!cursor_pos"($I11)
    ($P10) = rx1352_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1352_pos, "")
    rx1352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1357_done
  rxcap_1357_fail:
    goto rx1352_fail
  rxcap_1357_done:
  # rx subrule "O" subtype=capture negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1352_fail
    rx1352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1352_pos = $P10."pos"()
  # rx pass
    rx1352_cur."!cursor_pass"(rx1352_pos, "infix:sym<+&>")
    if_null rx1352_debug, debug_984
    rx1352_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1352_pos)
  debug_984:
    .return (rx1352_cur)
  rx1352_restart:
.annotate 'line', 4
    if_null rx1352_debug, debug_985
    rx1352_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_985:
  rx1352_fail:
    (rx1352_rep, rx1352_pos, $I10, $P10) = rx1352_cur."!mark_fail"(0)
    lt rx1352_pos, -1, rx1352_done
    eq rx1352_pos, -1, rx1352_fail
    jump $I10
  rx1352_done:
    rx1352_cur."!cursor_fail"()
    if_null rx1352_debug, debug_986
    rx1352_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_986:
    .return (rx1352_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("309_1297619321.796") :method
.annotate 'line', 4
    $P1354 = self."!PREFIX__!subrule"("O", "+&")
    new $P1355, "ResizablePMCArray"
    push $P1355, $P1354
    .return ($P1355)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("310_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1359_tgt
    .local int rx1359_pos
    .local int rx1359_off
    .local int rx1359_eos
    .local int rx1359_rep
    .local pmc rx1359_cur
    .local pmc rx1359_debug
    (rx1359_cur, rx1359_pos, rx1359_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1359_cur
    .local pmc match
    .lex "$/", match
    length rx1359_eos, rx1359_tgt
    gt rx1359_pos, rx1359_eos, rx1359_done
    set rx1359_off, 0
    lt rx1359_pos, 2, rx1359_start
    sub rx1359_off, rx1359_pos, 1
    substr rx1359_tgt, rx1359_tgt, rx1359_off
  rx1359_start:
    eq $I10, 1, rx1359_restart
    if_null rx1359_debug, debug_987
    rx1359_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1363_done
    goto rxscan1363_scan
  rxscan1363_loop:
    (rx1359_pos) = rx1359_cur."from"()
    inc rx1359_pos
    rx1359_cur."!cursor_from"(rx1359_pos)
    ge rx1359_pos, rx1359_eos, rxscan1363_done
  rxscan1363_scan:
    set_addr $I10, rxscan1363_loop
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  rxscan1363_done:
.annotate 'line', 602
  # rx subcapture "sym"
    set_addr $I10, rxcap_1364_fail
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  # rx literal  "+"
    add $I11, rx1359_pos, 1
    gt $I11, rx1359_eos, rx1359_fail
    sub $I11, rx1359_pos, rx1359_off
    ord $I11, rx1359_tgt, $I11
    ne $I11, 43, rx1359_fail
    add rx1359_pos, 1
    set_addr $I10, rxcap_1364_fail
    ($I12, $I11) = rx1359_cur."!mark_peek"($I10)
    rx1359_cur."!cursor_pos"($I11)
    ($P10) = rx1359_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1359_pos, "")
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1364_done
  rxcap_1364_fail:
    goto rx1359_fail
  rxcap_1364_done:
  # rx subrule "O" subtype=capture negate=
    rx1359_cur."!cursor_pos"(rx1359_pos)
    $P10 = rx1359_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1359_fail
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1359_pos = $P10."pos"()
  # rx pass
    rx1359_cur."!cursor_pass"(rx1359_pos, "infix:sym<+>")
    if_null rx1359_debug, debug_988
    rx1359_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1359_pos)
  debug_988:
    .return (rx1359_cur)
  rx1359_restart:
.annotate 'line', 4
    if_null rx1359_debug, debug_989
    rx1359_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_989:
  rx1359_fail:
    (rx1359_rep, rx1359_pos, $I10, $P10) = rx1359_cur."!mark_fail"(0)
    lt rx1359_pos, -1, rx1359_done
    eq rx1359_pos, -1, rx1359_fail
    jump $I10
  rx1359_done:
    rx1359_cur."!cursor_fail"()
    if_null rx1359_debug, debug_990
    rx1359_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_990:
    .return (rx1359_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("311_1297619321.796") :method
.annotate 'line', 4
    $P1361 = self."!PREFIX__!subrule"("O", "+")
    new $P1362, "ResizablePMCArray"
    push $P1362, $P1361
    .return ($P1362)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("312_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1366_tgt
    .local int rx1366_pos
    .local int rx1366_off
    .local int rx1366_eos
    .local int rx1366_rep
    .local pmc rx1366_cur
    .local pmc rx1366_debug
    (rx1366_cur, rx1366_pos, rx1366_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1366_cur
    .local pmc match
    .lex "$/", match
    length rx1366_eos, rx1366_tgt
    gt rx1366_pos, rx1366_eos, rx1366_done
    set rx1366_off, 0
    lt rx1366_pos, 2, rx1366_start
    sub rx1366_off, rx1366_pos, 1
    substr rx1366_tgt, rx1366_tgt, rx1366_off
  rx1366_start:
    eq $I10, 1, rx1366_restart
    if_null rx1366_debug, debug_991
    rx1366_cur."!cursor_debug"("START", "infix:sym<->")
  debug_991:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1370_done
    goto rxscan1370_scan
  rxscan1370_loop:
    (rx1366_pos) = rx1366_cur."from"()
    inc rx1366_pos
    rx1366_cur."!cursor_from"(rx1366_pos)
    ge rx1366_pos, rx1366_eos, rxscan1370_done
  rxscan1370_scan:
    set_addr $I10, rxscan1370_loop
    rx1366_cur."!mark_push"(0, rx1366_pos, $I10)
  rxscan1370_done:
.annotate 'line', 603
  # rx subcapture "sym"
    set_addr $I10, rxcap_1371_fail
    rx1366_cur."!mark_push"(0, rx1366_pos, $I10)
  # rx literal  "-"
    add $I11, rx1366_pos, 1
    gt $I11, rx1366_eos, rx1366_fail
    sub $I11, rx1366_pos, rx1366_off
    ord $I11, rx1366_tgt, $I11
    ne $I11, 45, rx1366_fail
    add rx1366_pos, 1
    set_addr $I10, rxcap_1371_fail
    ($I12, $I11) = rx1366_cur."!mark_peek"($I10)
    rx1366_cur."!cursor_pos"($I11)
    ($P10) = rx1366_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1366_pos, "")
    rx1366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1371_done
  rxcap_1371_fail:
    goto rx1366_fail
  rxcap_1371_done:
  # rx subrule "O" subtype=capture negate=
    rx1366_cur."!cursor_pos"(rx1366_pos)
    $P10 = rx1366_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1366_fail
    rx1366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1366_pos = $P10."pos"()
  # rx pass
    rx1366_cur."!cursor_pass"(rx1366_pos, "infix:sym<->")
    if_null rx1366_debug, debug_992
    rx1366_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1366_pos)
  debug_992:
    .return (rx1366_cur)
  rx1366_restart:
.annotate 'line', 4
    if_null rx1366_debug, debug_993
    rx1366_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_993:
  rx1366_fail:
    (rx1366_rep, rx1366_pos, $I10, $P10) = rx1366_cur."!mark_fail"(0)
    lt rx1366_pos, -1, rx1366_done
    eq rx1366_pos, -1, rx1366_fail
    jump $I10
  rx1366_done:
    rx1366_cur."!cursor_fail"()
    if_null rx1366_debug, debug_994
    rx1366_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_994:
    .return (rx1366_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("313_1297619321.796") :method
.annotate 'line', 4
    $P1368 = self."!PREFIX__!subrule"("O", "-")
    new $P1369, "ResizablePMCArray"
    push $P1369, $P1368
    .return ($P1369)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("314_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1373_tgt
    .local int rx1373_pos
    .local int rx1373_off
    .local int rx1373_eos
    .local int rx1373_rep
    .local pmc rx1373_cur
    .local pmc rx1373_debug
    (rx1373_cur, rx1373_pos, rx1373_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1373_cur
    .local pmc match
    .lex "$/", match
    length rx1373_eos, rx1373_tgt
    gt rx1373_pos, rx1373_eos, rx1373_done
    set rx1373_off, 0
    lt rx1373_pos, 2, rx1373_start
    sub rx1373_off, rx1373_pos, 1
    substr rx1373_tgt, rx1373_tgt, rx1373_off
  rx1373_start:
    eq $I10, 1, rx1373_restart
    if_null rx1373_debug, debug_995
    rx1373_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_995:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1377_done
    goto rxscan1377_scan
  rxscan1377_loop:
    (rx1373_pos) = rx1373_cur."from"()
    inc rx1373_pos
    rx1373_cur."!cursor_from"(rx1373_pos)
    ge rx1373_pos, rx1373_eos, rxscan1377_done
  rxscan1377_scan:
    set_addr $I10, rxscan1377_loop
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  rxscan1377_done:
.annotate 'line', 604
  # rx subcapture "sym"
    set_addr $I10, rxcap_1378_fail
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1373_pos, 2
    gt $I11, rx1373_eos, rx1373_fail
    sub $I11, rx1373_pos, rx1373_off
    substr $S10, rx1373_tgt, $I11, 2
    ne $S10, "+|", rx1373_fail
    add rx1373_pos, 2
    set_addr $I10, rxcap_1378_fail
    ($I12, $I11) = rx1373_cur."!mark_peek"($I10)
    rx1373_cur."!cursor_pos"($I11)
    ($P10) = rx1373_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1373_pos, "")
    rx1373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1378_done
  rxcap_1378_fail:
    goto rx1373_fail
  rxcap_1378_done:
  # rx subrule "O" subtype=capture negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1373_fail
    rx1373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1373_pos = $P10."pos"()
  # rx pass
    rx1373_cur."!cursor_pass"(rx1373_pos, "infix:sym<+|>")
    if_null rx1373_debug, debug_996
    rx1373_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1373_pos)
  debug_996:
    .return (rx1373_cur)
  rx1373_restart:
.annotate 'line', 4
    if_null rx1373_debug, debug_997
    rx1373_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_997:
  rx1373_fail:
    (rx1373_rep, rx1373_pos, $I10, $P10) = rx1373_cur."!mark_fail"(0)
    lt rx1373_pos, -1, rx1373_done
    eq rx1373_pos, -1, rx1373_fail
    jump $I10
  rx1373_done:
    rx1373_cur."!cursor_fail"()
    if_null rx1373_debug, debug_998
    rx1373_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_998:
    .return (rx1373_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("315_1297619321.796") :method
.annotate 'line', 4
    $P1375 = self."!PREFIX__!subrule"("O", "+|")
    new $P1376, "ResizablePMCArray"
    push $P1376, $P1375
    .return ($P1376)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("316_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1380_tgt
    .local int rx1380_pos
    .local int rx1380_off
    .local int rx1380_eos
    .local int rx1380_rep
    .local pmc rx1380_cur
    .local pmc rx1380_debug
    (rx1380_cur, rx1380_pos, rx1380_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1380_cur
    .local pmc match
    .lex "$/", match
    length rx1380_eos, rx1380_tgt
    gt rx1380_pos, rx1380_eos, rx1380_done
    set rx1380_off, 0
    lt rx1380_pos, 2, rx1380_start
    sub rx1380_off, rx1380_pos, 1
    substr rx1380_tgt, rx1380_tgt, rx1380_off
  rx1380_start:
    eq $I10, 1, rx1380_restart
    if_null rx1380_debug, debug_999
    rx1380_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_999:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1384_done
    goto rxscan1384_scan
  rxscan1384_loop:
    (rx1380_pos) = rx1380_cur."from"()
    inc rx1380_pos
    rx1380_cur."!cursor_from"(rx1380_pos)
    ge rx1380_pos, rx1380_eos, rxscan1384_done
  rxscan1384_scan:
    set_addr $I10, rxscan1384_loop
    rx1380_cur."!mark_push"(0, rx1380_pos, $I10)
  rxscan1384_done:
.annotate 'line', 605
  # rx subcapture "sym"
    set_addr $I10, rxcap_1385_fail
    rx1380_cur."!mark_push"(0, rx1380_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1380_pos, 2
    gt $I11, rx1380_eos, rx1380_fail
    sub $I11, rx1380_pos, rx1380_off
    substr $S10, rx1380_tgt, $I11, 2
    ne $S10, "+^", rx1380_fail
    add rx1380_pos, 2
    set_addr $I10, rxcap_1385_fail
    ($I12, $I11) = rx1380_cur."!mark_peek"($I10)
    rx1380_cur."!cursor_pos"($I11)
    ($P10) = rx1380_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1380_pos, "")
    rx1380_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1385_done
  rxcap_1385_fail:
    goto rx1380_fail
  rxcap_1385_done:
  # rx subrule "O" subtype=capture negate=
    rx1380_cur."!cursor_pos"(rx1380_pos)
    $P10 = rx1380_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1380_fail
    rx1380_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1380_pos = $P10."pos"()
  # rx pass
    rx1380_cur."!cursor_pass"(rx1380_pos, "infix:sym<+^>")
    if_null rx1380_debug, debug_1000
    rx1380_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1380_pos)
  debug_1000:
    .return (rx1380_cur)
  rx1380_restart:
.annotate 'line', 4
    if_null rx1380_debug, debug_1001
    rx1380_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1001:
  rx1380_fail:
    (rx1380_rep, rx1380_pos, $I10, $P10) = rx1380_cur."!mark_fail"(0)
    lt rx1380_pos, -1, rx1380_done
    eq rx1380_pos, -1, rx1380_fail
    jump $I10
  rx1380_done:
    rx1380_cur."!cursor_fail"()
    if_null rx1380_debug, debug_1002
    rx1380_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1002:
    .return (rx1380_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("317_1297619321.796") :method
.annotate 'line', 4
    $P1382 = self."!PREFIX__!subrule"("O", "+^")
    new $P1383, "ResizablePMCArray"
    push $P1383, $P1382
    .return ($P1383)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("318_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1387_tgt
    .local int rx1387_pos
    .local int rx1387_off
    .local int rx1387_eos
    .local int rx1387_rep
    .local pmc rx1387_cur
    .local pmc rx1387_debug
    (rx1387_cur, rx1387_pos, rx1387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1387_cur
    .local pmc match
    .lex "$/", match
    length rx1387_eos, rx1387_tgt
    gt rx1387_pos, rx1387_eos, rx1387_done
    set rx1387_off, 0
    lt rx1387_pos, 2, rx1387_start
    sub rx1387_off, rx1387_pos, 1
    substr rx1387_tgt, rx1387_tgt, rx1387_off
  rx1387_start:
    eq $I10, 1, rx1387_restart
    if_null rx1387_debug, debug_1003
    rx1387_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1391_done
    goto rxscan1391_scan
  rxscan1391_loop:
    (rx1387_pos) = rx1387_cur."from"()
    inc rx1387_pos
    rx1387_cur."!cursor_from"(rx1387_pos)
    ge rx1387_pos, rx1387_eos, rxscan1391_done
  rxscan1391_scan:
    set_addr $I10, rxscan1391_loop
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  rxscan1391_done:
.annotate 'line', 607
  # rx subcapture "sym"
    set_addr $I10, rxcap_1392_fail
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  # rx literal  "~"
    add $I11, rx1387_pos, 1
    gt $I11, rx1387_eos, rx1387_fail
    sub $I11, rx1387_pos, rx1387_off
    ord $I11, rx1387_tgt, $I11
    ne $I11, 126, rx1387_fail
    add rx1387_pos, 1
    set_addr $I10, rxcap_1392_fail
    ($I12, $I11) = rx1387_cur."!mark_peek"($I10)
    rx1387_cur."!cursor_pos"($I11)
    ($P10) = rx1387_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1387_pos, "")
    rx1387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1392_done
  rxcap_1392_fail:
    goto rx1387_fail
  rxcap_1392_done:
  # rx subrule "O" subtype=capture negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1387_fail
    rx1387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1387_pos = $P10."pos"()
  # rx pass
    rx1387_cur."!cursor_pass"(rx1387_pos, "infix:sym<~>")
    if_null rx1387_debug, debug_1004
    rx1387_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1387_pos)
  debug_1004:
    .return (rx1387_cur)
  rx1387_restart:
.annotate 'line', 4
    if_null rx1387_debug, debug_1005
    rx1387_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1005:
  rx1387_fail:
    (rx1387_rep, rx1387_pos, $I10, $P10) = rx1387_cur."!mark_fail"(0)
    lt rx1387_pos, -1, rx1387_done
    eq rx1387_pos, -1, rx1387_fail
    jump $I10
  rx1387_done:
    rx1387_cur."!cursor_fail"()
    if_null rx1387_debug, debug_1006
    rx1387_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1006:
    .return (rx1387_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("319_1297619321.796") :method
.annotate 'line', 4
    $P1389 = self."!PREFIX__!subrule"("O", "~")
    new $P1390, "ResizablePMCArray"
    push $P1390, $P1389
    .return ($P1390)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("320_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1394_tgt
    .local int rx1394_pos
    .local int rx1394_off
    .local int rx1394_eos
    .local int rx1394_rep
    .local pmc rx1394_cur
    .local pmc rx1394_debug
    (rx1394_cur, rx1394_pos, rx1394_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1394_cur
    .local pmc match
    .lex "$/", match
    length rx1394_eos, rx1394_tgt
    gt rx1394_pos, rx1394_eos, rx1394_done
    set rx1394_off, 0
    lt rx1394_pos, 2, rx1394_start
    sub rx1394_off, rx1394_pos, 1
    substr rx1394_tgt, rx1394_tgt, rx1394_off
  rx1394_start:
    eq $I10, 1, rx1394_restart
    if_null rx1394_debug, debug_1007
    rx1394_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1007:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1398_done
    goto rxscan1398_scan
  rxscan1398_loop:
    (rx1394_pos) = rx1394_cur."from"()
    inc rx1394_pos
    rx1394_cur."!cursor_from"(rx1394_pos)
    ge rx1394_pos, rx1394_eos, rxscan1398_done
  rxscan1398_scan:
    set_addr $I10, rxscan1398_loop
    rx1394_cur."!mark_push"(0, rx1394_pos, $I10)
  rxscan1398_done:
.annotate 'line', 609
  # rx subcapture "sym"
    set_addr $I10, rxcap_1399_fail
    rx1394_cur."!mark_push"(0, rx1394_pos, $I10)
  # rx literal  "=="
    add $I11, rx1394_pos, 2
    gt $I11, rx1394_eos, rx1394_fail
    sub $I11, rx1394_pos, rx1394_off
    substr $S10, rx1394_tgt, $I11, 2
    ne $S10, "==", rx1394_fail
    add rx1394_pos, 2
    set_addr $I10, rxcap_1399_fail
    ($I12, $I11) = rx1394_cur."!mark_peek"($I10)
    rx1394_cur."!cursor_pos"($I11)
    ($P10) = rx1394_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1394_pos, "")
    rx1394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1399_done
  rxcap_1399_fail:
    goto rx1394_fail
  rxcap_1399_done:
  # rx subrule "O" subtype=capture negate=
    rx1394_cur."!cursor_pos"(rx1394_pos)
    $P10 = rx1394_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1394_fail
    rx1394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1394_pos = $P10."pos"()
  # rx pass
    rx1394_cur."!cursor_pass"(rx1394_pos, "infix:sym<==>")
    if_null rx1394_debug, debug_1008
    rx1394_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1394_pos)
  debug_1008:
    .return (rx1394_cur)
  rx1394_restart:
.annotate 'line', 4
    if_null rx1394_debug, debug_1009
    rx1394_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1009:
  rx1394_fail:
    (rx1394_rep, rx1394_pos, $I10, $P10) = rx1394_cur."!mark_fail"(0)
    lt rx1394_pos, -1, rx1394_done
    eq rx1394_pos, -1, rx1394_fail
    jump $I10
  rx1394_done:
    rx1394_cur."!cursor_fail"()
    if_null rx1394_debug, debug_1010
    rx1394_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1010:
    .return (rx1394_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("321_1297619321.796") :method
.annotate 'line', 4
    $P1396 = self."!PREFIX__!subrule"("O", "==")
    new $P1397, "ResizablePMCArray"
    push $P1397, $P1396
    .return ($P1397)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("322_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1401_tgt
    .local int rx1401_pos
    .local int rx1401_off
    .local int rx1401_eos
    .local int rx1401_rep
    .local pmc rx1401_cur
    .local pmc rx1401_debug
    (rx1401_cur, rx1401_pos, rx1401_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1401_cur
    .local pmc match
    .lex "$/", match
    length rx1401_eos, rx1401_tgt
    gt rx1401_pos, rx1401_eos, rx1401_done
    set rx1401_off, 0
    lt rx1401_pos, 2, rx1401_start
    sub rx1401_off, rx1401_pos, 1
    substr rx1401_tgt, rx1401_tgt, rx1401_off
  rx1401_start:
    eq $I10, 1, rx1401_restart
    if_null rx1401_debug, debug_1011
    rx1401_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1011:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1405_done
    goto rxscan1405_scan
  rxscan1405_loop:
    (rx1401_pos) = rx1401_cur."from"()
    inc rx1401_pos
    rx1401_cur."!cursor_from"(rx1401_pos)
    ge rx1401_pos, rx1401_eos, rxscan1405_done
  rxscan1405_scan:
    set_addr $I10, rxscan1405_loop
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  rxscan1405_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1406_fail
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  # rx literal  "!="
    add $I11, rx1401_pos, 2
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    substr $S10, rx1401_tgt, $I11, 2
    ne $S10, "!=", rx1401_fail
    add rx1401_pos, 2
    set_addr $I10, rxcap_1406_fail
    ($I12, $I11) = rx1401_cur."!mark_peek"($I10)
    rx1401_cur."!cursor_pos"($I11)
    ($P10) = rx1401_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1401_pos, "")
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1406_done
  rxcap_1406_fail:
    goto rx1401_fail
  rxcap_1406_done:
  # rx subrule "O" subtype=capture negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1401_fail
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1401_pos = $P10."pos"()
  # rx pass
    rx1401_cur."!cursor_pass"(rx1401_pos, "infix:sym<!=>")
    if_null rx1401_debug, debug_1012
    rx1401_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1401_pos)
  debug_1012:
    .return (rx1401_cur)
  rx1401_restart:
.annotate 'line', 4
    if_null rx1401_debug, debug_1013
    rx1401_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1013:
  rx1401_fail:
    (rx1401_rep, rx1401_pos, $I10, $P10) = rx1401_cur."!mark_fail"(0)
    lt rx1401_pos, -1, rx1401_done
    eq rx1401_pos, -1, rx1401_fail
    jump $I10
  rx1401_done:
    rx1401_cur."!cursor_fail"()
    if_null rx1401_debug, debug_1014
    rx1401_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1014:
    .return (rx1401_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("323_1297619321.796") :method
.annotate 'line', 4
    $P1403 = self."!PREFIX__!subrule"("O", "!=")
    new $P1404, "ResizablePMCArray"
    push $P1404, $P1403
    .return ($P1404)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("324_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1408_tgt
    .local int rx1408_pos
    .local int rx1408_off
    .local int rx1408_eos
    .local int rx1408_rep
    .local pmc rx1408_cur
    .local pmc rx1408_debug
    (rx1408_cur, rx1408_pos, rx1408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1408_cur
    .local pmc match
    .lex "$/", match
    length rx1408_eos, rx1408_tgt
    gt rx1408_pos, rx1408_eos, rx1408_done
    set rx1408_off, 0
    lt rx1408_pos, 2, rx1408_start
    sub rx1408_off, rx1408_pos, 1
    substr rx1408_tgt, rx1408_tgt, rx1408_off
  rx1408_start:
    eq $I10, 1, rx1408_restart
    if_null rx1408_debug, debug_1015
    rx1408_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1015:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1412_done
    goto rxscan1412_scan
  rxscan1412_loop:
    (rx1408_pos) = rx1408_cur."from"()
    inc rx1408_pos
    rx1408_cur."!cursor_from"(rx1408_pos)
    ge rx1408_pos, rx1408_eos, rxscan1412_done
  rxscan1412_scan:
    set_addr $I10, rxscan1412_loop
    rx1408_cur."!mark_push"(0, rx1408_pos, $I10)
  rxscan1412_done:
.annotate 'line', 611
  # rx subcapture "sym"
    set_addr $I10, rxcap_1413_fail
    rx1408_cur."!mark_push"(0, rx1408_pos, $I10)
  # rx literal  "<="
    add $I11, rx1408_pos, 2
    gt $I11, rx1408_eos, rx1408_fail
    sub $I11, rx1408_pos, rx1408_off
    substr $S10, rx1408_tgt, $I11, 2
    ne $S10, "<=", rx1408_fail
    add rx1408_pos, 2
    set_addr $I10, rxcap_1413_fail
    ($I12, $I11) = rx1408_cur."!mark_peek"($I10)
    rx1408_cur."!cursor_pos"($I11)
    ($P10) = rx1408_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1408_pos, "")
    rx1408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1413_done
  rxcap_1413_fail:
    goto rx1408_fail
  rxcap_1413_done:
  # rx subrule "O" subtype=capture negate=
    rx1408_cur."!cursor_pos"(rx1408_pos)
    $P10 = rx1408_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1408_fail
    rx1408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1408_pos = $P10."pos"()
  # rx pass
    rx1408_cur."!cursor_pass"(rx1408_pos, "infix:sym<<=>")
    if_null rx1408_debug, debug_1016
    rx1408_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1408_pos)
  debug_1016:
    .return (rx1408_cur)
  rx1408_restart:
.annotate 'line', 4
    if_null rx1408_debug, debug_1017
    rx1408_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1017:
  rx1408_fail:
    (rx1408_rep, rx1408_pos, $I10, $P10) = rx1408_cur."!mark_fail"(0)
    lt rx1408_pos, -1, rx1408_done
    eq rx1408_pos, -1, rx1408_fail
    jump $I10
  rx1408_done:
    rx1408_cur."!cursor_fail"()
    if_null rx1408_debug, debug_1018
    rx1408_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1018:
    .return (rx1408_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("325_1297619321.796") :method
.annotate 'line', 4
    $P1410 = self."!PREFIX__!subrule"("O", "<=")
    new $P1411, "ResizablePMCArray"
    push $P1411, $P1410
    .return ($P1411)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("326_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1415_tgt
    .local int rx1415_pos
    .local int rx1415_off
    .local int rx1415_eos
    .local int rx1415_rep
    .local pmc rx1415_cur
    .local pmc rx1415_debug
    (rx1415_cur, rx1415_pos, rx1415_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1415_cur
    .local pmc match
    .lex "$/", match
    length rx1415_eos, rx1415_tgt
    gt rx1415_pos, rx1415_eos, rx1415_done
    set rx1415_off, 0
    lt rx1415_pos, 2, rx1415_start
    sub rx1415_off, rx1415_pos, 1
    substr rx1415_tgt, rx1415_tgt, rx1415_off
  rx1415_start:
    eq $I10, 1, rx1415_restart
    if_null rx1415_debug, debug_1019
    rx1415_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1019:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1419_done
    goto rxscan1419_scan
  rxscan1419_loop:
    (rx1415_pos) = rx1415_cur."from"()
    inc rx1415_pos
    rx1415_cur."!cursor_from"(rx1415_pos)
    ge rx1415_pos, rx1415_eos, rxscan1419_done
  rxscan1419_scan:
    set_addr $I10, rxscan1419_loop
    rx1415_cur."!mark_push"(0, rx1415_pos, $I10)
  rxscan1419_done:
.annotate 'line', 612
  # rx subcapture "sym"
    set_addr $I10, rxcap_1420_fail
    rx1415_cur."!mark_push"(0, rx1415_pos, $I10)
  # rx literal  ">="
    add $I11, rx1415_pos, 2
    gt $I11, rx1415_eos, rx1415_fail
    sub $I11, rx1415_pos, rx1415_off
    substr $S10, rx1415_tgt, $I11, 2
    ne $S10, ">=", rx1415_fail
    add rx1415_pos, 2
    set_addr $I10, rxcap_1420_fail
    ($I12, $I11) = rx1415_cur."!mark_peek"($I10)
    rx1415_cur."!cursor_pos"($I11)
    ($P10) = rx1415_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1415_pos, "")
    rx1415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1420_done
  rxcap_1420_fail:
    goto rx1415_fail
  rxcap_1420_done:
  # rx subrule "O" subtype=capture negate=
    rx1415_cur."!cursor_pos"(rx1415_pos)
    $P10 = rx1415_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1415_fail
    rx1415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1415_pos = $P10."pos"()
  # rx pass
    rx1415_cur."!cursor_pass"(rx1415_pos, "infix:sym<>=>")
    if_null rx1415_debug, debug_1020
    rx1415_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1415_pos)
  debug_1020:
    .return (rx1415_cur)
  rx1415_restart:
.annotate 'line', 4
    if_null rx1415_debug, debug_1021
    rx1415_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1021:
  rx1415_fail:
    (rx1415_rep, rx1415_pos, $I10, $P10) = rx1415_cur."!mark_fail"(0)
    lt rx1415_pos, -1, rx1415_done
    eq rx1415_pos, -1, rx1415_fail
    jump $I10
  rx1415_done:
    rx1415_cur."!cursor_fail"()
    if_null rx1415_debug, debug_1022
    rx1415_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1022:
    .return (rx1415_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("327_1297619321.796") :method
.annotate 'line', 4
    $P1417 = self."!PREFIX__!subrule"("O", ">=")
    new $P1418, "ResizablePMCArray"
    push $P1418, $P1417
    .return ($P1418)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("328_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1422_tgt
    .local int rx1422_pos
    .local int rx1422_off
    .local int rx1422_eos
    .local int rx1422_rep
    .local pmc rx1422_cur
    .local pmc rx1422_debug
    (rx1422_cur, rx1422_pos, rx1422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1422_cur
    .local pmc match
    .lex "$/", match
    length rx1422_eos, rx1422_tgt
    gt rx1422_pos, rx1422_eos, rx1422_done
    set rx1422_off, 0
    lt rx1422_pos, 2, rx1422_start
    sub rx1422_off, rx1422_pos, 1
    substr rx1422_tgt, rx1422_tgt, rx1422_off
  rx1422_start:
    eq $I10, 1, rx1422_restart
    if_null rx1422_debug, debug_1023
    rx1422_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1023:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1426_done
    goto rxscan1426_scan
  rxscan1426_loop:
    (rx1422_pos) = rx1422_cur."from"()
    inc rx1422_pos
    rx1422_cur."!cursor_from"(rx1422_pos)
    ge rx1422_pos, rx1422_eos, rxscan1426_done
  rxscan1426_scan:
    set_addr $I10, rxscan1426_loop
    rx1422_cur."!mark_push"(0, rx1422_pos, $I10)
  rxscan1426_done:
.annotate 'line', 613
  # rx subcapture "sym"
    set_addr $I10, rxcap_1427_fail
    rx1422_cur."!mark_push"(0, rx1422_pos, $I10)
  # rx literal  "<"
    add $I11, rx1422_pos, 1
    gt $I11, rx1422_eos, rx1422_fail
    sub $I11, rx1422_pos, rx1422_off
    ord $I11, rx1422_tgt, $I11
    ne $I11, 60, rx1422_fail
    add rx1422_pos, 1
    set_addr $I10, rxcap_1427_fail
    ($I12, $I11) = rx1422_cur."!mark_peek"($I10)
    rx1422_cur."!cursor_pos"($I11)
    ($P10) = rx1422_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1422_pos, "")
    rx1422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1427_done
  rxcap_1427_fail:
    goto rx1422_fail
  rxcap_1427_done:
  # rx subrule "O" subtype=capture negate=
    rx1422_cur."!cursor_pos"(rx1422_pos)
    $P10 = rx1422_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1422_fail
    rx1422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1422_pos = $P10."pos"()
  # rx pass
    rx1422_cur."!cursor_pass"(rx1422_pos, "infix:sym<<>")
    if_null rx1422_debug, debug_1024
    rx1422_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1422_pos)
  debug_1024:
    .return (rx1422_cur)
  rx1422_restart:
.annotate 'line', 4
    if_null rx1422_debug, debug_1025
    rx1422_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1025:
  rx1422_fail:
    (rx1422_rep, rx1422_pos, $I10, $P10) = rx1422_cur."!mark_fail"(0)
    lt rx1422_pos, -1, rx1422_done
    eq rx1422_pos, -1, rx1422_fail
    jump $I10
  rx1422_done:
    rx1422_cur."!cursor_fail"()
    if_null rx1422_debug, debug_1026
    rx1422_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1026:
    .return (rx1422_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("329_1297619321.796") :method
.annotate 'line', 4
    $P1424 = self."!PREFIX__!subrule"("O", "<")
    new $P1425, "ResizablePMCArray"
    push $P1425, $P1424
    .return ($P1425)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("330_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1429_tgt
    .local int rx1429_pos
    .local int rx1429_off
    .local int rx1429_eos
    .local int rx1429_rep
    .local pmc rx1429_cur
    .local pmc rx1429_debug
    (rx1429_cur, rx1429_pos, rx1429_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1429_cur
    .local pmc match
    .lex "$/", match
    length rx1429_eos, rx1429_tgt
    gt rx1429_pos, rx1429_eos, rx1429_done
    set rx1429_off, 0
    lt rx1429_pos, 2, rx1429_start
    sub rx1429_off, rx1429_pos, 1
    substr rx1429_tgt, rx1429_tgt, rx1429_off
  rx1429_start:
    eq $I10, 1, rx1429_restart
    if_null rx1429_debug, debug_1027
    rx1429_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1027:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1433_done
    goto rxscan1433_scan
  rxscan1433_loop:
    (rx1429_pos) = rx1429_cur."from"()
    inc rx1429_pos
    rx1429_cur."!cursor_from"(rx1429_pos)
    ge rx1429_pos, rx1429_eos, rxscan1433_done
  rxscan1433_scan:
    set_addr $I10, rxscan1433_loop
    rx1429_cur."!mark_push"(0, rx1429_pos, $I10)
  rxscan1433_done:
.annotate 'line', 614
  # rx subcapture "sym"
    set_addr $I10, rxcap_1434_fail
    rx1429_cur."!mark_push"(0, rx1429_pos, $I10)
  # rx literal  ">"
    add $I11, rx1429_pos, 1
    gt $I11, rx1429_eos, rx1429_fail
    sub $I11, rx1429_pos, rx1429_off
    ord $I11, rx1429_tgt, $I11
    ne $I11, 62, rx1429_fail
    add rx1429_pos, 1
    set_addr $I10, rxcap_1434_fail
    ($I12, $I11) = rx1429_cur."!mark_peek"($I10)
    rx1429_cur."!cursor_pos"($I11)
    ($P10) = rx1429_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1429_pos, "")
    rx1429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1434_done
  rxcap_1434_fail:
    goto rx1429_fail
  rxcap_1434_done:
  # rx subrule "O" subtype=capture negate=
    rx1429_cur."!cursor_pos"(rx1429_pos)
    $P10 = rx1429_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1429_fail
    rx1429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1429_pos = $P10."pos"()
  # rx pass
    rx1429_cur."!cursor_pass"(rx1429_pos, "infix:sym<>>")
    if_null rx1429_debug, debug_1028
    rx1429_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1429_pos)
  debug_1028:
    .return (rx1429_cur)
  rx1429_restart:
.annotate 'line', 4
    if_null rx1429_debug, debug_1029
    rx1429_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1029:
  rx1429_fail:
    (rx1429_rep, rx1429_pos, $I10, $P10) = rx1429_cur."!mark_fail"(0)
    lt rx1429_pos, -1, rx1429_done
    eq rx1429_pos, -1, rx1429_fail
    jump $I10
  rx1429_done:
    rx1429_cur."!cursor_fail"()
    if_null rx1429_debug, debug_1030
    rx1429_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1030:
    .return (rx1429_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("331_1297619321.796") :method
.annotate 'line', 4
    $P1431 = self."!PREFIX__!subrule"("O", ">")
    new $P1432, "ResizablePMCArray"
    push $P1432, $P1431
    .return ($P1432)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("332_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1436_tgt
    .local int rx1436_pos
    .local int rx1436_off
    .local int rx1436_eos
    .local int rx1436_rep
    .local pmc rx1436_cur
    .local pmc rx1436_debug
    (rx1436_cur, rx1436_pos, rx1436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1436_cur
    .local pmc match
    .lex "$/", match
    length rx1436_eos, rx1436_tgt
    gt rx1436_pos, rx1436_eos, rx1436_done
    set rx1436_off, 0
    lt rx1436_pos, 2, rx1436_start
    sub rx1436_off, rx1436_pos, 1
    substr rx1436_tgt, rx1436_tgt, rx1436_off
  rx1436_start:
    eq $I10, 1, rx1436_restart
    if_null rx1436_debug, debug_1031
    rx1436_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1031:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1440_done
    goto rxscan1440_scan
  rxscan1440_loop:
    (rx1436_pos) = rx1436_cur."from"()
    inc rx1436_pos
    rx1436_cur."!cursor_from"(rx1436_pos)
    ge rx1436_pos, rx1436_eos, rxscan1440_done
  rxscan1440_scan:
    set_addr $I10, rxscan1440_loop
    rx1436_cur."!mark_push"(0, rx1436_pos, $I10)
  rxscan1440_done:
.annotate 'line', 615
  # rx subcapture "sym"
    set_addr $I10, rxcap_1441_fail
    rx1436_cur."!mark_push"(0, rx1436_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1436_pos, 2
    gt $I11, rx1436_eos, rx1436_fail
    sub $I11, rx1436_pos, rx1436_off
    substr $S10, rx1436_tgt, $I11, 2
    ne $S10, "eq", rx1436_fail
    add rx1436_pos, 2
    set_addr $I10, rxcap_1441_fail
    ($I12, $I11) = rx1436_cur."!mark_peek"($I10)
    rx1436_cur."!cursor_pos"($I11)
    ($P10) = rx1436_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1436_pos, "")
    rx1436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1441_done
  rxcap_1441_fail:
    goto rx1436_fail
  rxcap_1441_done:
  # rx subrule "O" subtype=capture negate=
    rx1436_cur."!cursor_pos"(rx1436_pos)
    $P10 = rx1436_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1436_fail
    rx1436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1436_pos = $P10."pos"()
  # rx pass
    rx1436_cur."!cursor_pass"(rx1436_pos, "infix:sym<eq>")
    if_null rx1436_debug, debug_1032
    rx1436_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1436_pos)
  debug_1032:
    .return (rx1436_cur)
  rx1436_restart:
.annotate 'line', 4
    if_null rx1436_debug, debug_1033
    rx1436_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1033:
  rx1436_fail:
    (rx1436_rep, rx1436_pos, $I10, $P10) = rx1436_cur."!mark_fail"(0)
    lt rx1436_pos, -1, rx1436_done
    eq rx1436_pos, -1, rx1436_fail
    jump $I10
  rx1436_done:
    rx1436_cur."!cursor_fail"()
    if_null rx1436_debug, debug_1034
    rx1436_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1034:
    .return (rx1436_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("333_1297619321.796") :method
.annotate 'line', 4
    $P1438 = self."!PREFIX__!subrule"("O", "eq")
    new $P1439, "ResizablePMCArray"
    push $P1439, $P1438
    .return ($P1439)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("334_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1443_tgt
    .local int rx1443_pos
    .local int rx1443_off
    .local int rx1443_eos
    .local int rx1443_rep
    .local pmc rx1443_cur
    .local pmc rx1443_debug
    (rx1443_cur, rx1443_pos, rx1443_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1443_cur
    .local pmc match
    .lex "$/", match
    length rx1443_eos, rx1443_tgt
    gt rx1443_pos, rx1443_eos, rx1443_done
    set rx1443_off, 0
    lt rx1443_pos, 2, rx1443_start
    sub rx1443_off, rx1443_pos, 1
    substr rx1443_tgt, rx1443_tgt, rx1443_off
  rx1443_start:
    eq $I10, 1, rx1443_restart
    if_null rx1443_debug, debug_1035
    rx1443_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1035:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1447_done
    goto rxscan1447_scan
  rxscan1447_loop:
    (rx1443_pos) = rx1443_cur."from"()
    inc rx1443_pos
    rx1443_cur."!cursor_from"(rx1443_pos)
    ge rx1443_pos, rx1443_eos, rxscan1447_done
  rxscan1447_scan:
    set_addr $I10, rxscan1447_loop
    rx1443_cur."!mark_push"(0, rx1443_pos, $I10)
  rxscan1447_done:
.annotate 'line', 616
  # rx subcapture "sym"
    set_addr $I10, rxcap_1448_fail
    rx1443_cur."!mark_push"(0, rx1443_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1443_pos, 2
    gt $I11, rx1443_eos, rx1443_fail
    sub $I11, rx1443_pos, rx1443_off
    substr $S10, rx1443_tgt, $I11, 2
    ne $S10, "ne", rx1443_fail
    add rx1443_pos, 2
    set_addr $I10, rxcap_1448_fail
    ($I12, $I11) = rx1443_cur."!mark_peek"($I10)
    rx1443_cur."!cursor_pos"($I11)
    ($P10) = rx1443_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1443_pos, "")
    rx1443_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1448_done
  rxcap_1448_fail:
    goto rx1443_fail
  rxcap_1448_done:
  # rx subrule "O" subtype=capture negate=
    rx1443_cur."!cursor_pos"(rx1443_pos)
    $P10 = rx1443_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1443_fail
    rx1443_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1443_pos = $P10."pos"()
  # rx pass
    rx1443_cur."!cursor_pass"(rx1443_pos, "infix:sym<ne>")
    if_null rx1443_debug, debug_1036
    rx1443_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1443_pos)
  debug_1036:
    .return (rx1443_cur)
  rx1443_restart:
.annotate 'line', 4
    if_null rx1443_debug, debug_1037
    rx1443_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1037:
  rx1443_fail:
    (rx1443_rep, rx1443_pos, $I10, $P10) = rx1443_cur."!mark_fail"(0)
    lt rx1443_pos, -1, rx1443_done
    eq rx1443_pos, -1, rx1443_fail
    jump $I10
  rx1443_done:
    rx1443_cur."!cursor_fail"()
    if_null rx1443_debug, debug_1038
    rx1443_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1038:
    .return (rx1443_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("335_1297619321.796") :method
.annotate 'line', 4
    $P1445 = self."!PREFIX__!subrule"("O", "ne")
    new $P1446, "ResizablePMCArray"
    push $P1446, $P1445
    .return ($P1446)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("336_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1450_tgt
    .local int rx1450_pos
    .local int rx1450_off
    .local int rx1450_eos
    .local int rx1450_rep
    .local pmc rx1450_cur
    .local pmc rx1450_debug
    (rx1450_cur, rx1450_pos, rx1450_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1450_cur
    .local pmc match
    .lex "$/", match
    length rx1450_eos, rx1450_tgt
    gt rx1450_pos, rx1450_eos, rx1450_done
    set rx1450_off, 0
    lt rx1450_pos, 2, rx1450_start
    sub rx1450_off, rx1450_pos, 1
    substr rx1450_tgt, rx1450_tgt, rx1450_off
  rx1450_start:
    eq $I10, 1, rx1450_restart
    if_null rx1450_debug, debug_1039
    rx1450_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1039:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1454_done
    goto rxscan1454_scan
  rxscan1454_loop:
    (rx1450_pos) = rx1450_cur."from"()
    inc rx1450_pos
    rx1450_cur."!cursor_from"(rx1450_pos)
    ge rx1450_pos, rx1450_eos, rxscan1454_done
  rxscan1454_scan:
    set_addr $I10, rxscan1454_loop
    rx1450_cur."!mark_push"(0, rx1450_pos, $I10)
  rxscan1454_done:
.annotate 'line', 617
  # rx subcapture "sym"
    set_addr $I10, rxcap_1455_fail
    rx1450_cur."!mark_push"(0, rx1450_pos, $I10)
  # rx literal  "le"
    add $I11, rx1450_pos, 2
    gt $I11, rx1450_eos, rx1450_fail
    sub $I11, rx1450_pos, rx1450_off
    substr $S10, rx1450_tgt, $I11, 2
    ne $S10, "le", rx1450_fail
    add rx1450_pos, 2
    set_addr $I10, rxcap_1455_fail
    ($I12, $I11) = rx1450_cur."!mark_peek"($I10)
    rx1450_cur."!cursor_pos"($I11)
    ($P10) = rx1450_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1450_pos, "")
    rx1450_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1455_done
  rxcap_1455_fail:
    goto rx1450_fail
  rxcap_1455_done:
  # rx subrule "O" subtype=capture negate=
    rx1450_cur."!cursor_pos"(rx1450_pos)
    $P10 = rx1450_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1450_fail
    rx1450_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1450_pos = $P10."pos"()
  # rx pass
    rx1450_cur."!cursor_pass"(rx1450_pos, "infix:sym<le>")
    if_null rx1450_debug, debug_1040
    rx1450_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1450_pos)
  debug_1040:
    .return (rx1450_cur)
  rx1450_restart:
.annotate 'line', 4
    if_null rx1450_debug, debug_1041
    rx1450_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1041:
  rx1450_fail:
    (rx1450_rep, rx1450_pos, $I10, $P10) = rx1450_cur."!mark_fail"(0)
    lt rx1450_pos, -1, rx1450_done
    eq rx1450_pos, -1, rx1450_fail
    jump $I10
  rx1450_done:
    rx1450_cur."!cursor_fail"()
    if_null rx1450_debug, debug_1042
    rx1450_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1042:
    .return (rx1450_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("337_1297619321.796") :method
.annotate 'line', 4
    $P1452 = self."!PREFIX__!subrule"("O", "le")
    new $P1453, "ResizablePMCArray"
    push $P1453, $P1452
    .return ($P1453)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("338_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1457_tgt
    .local int rx1457_pos
    .local int rx1457_off
    .local int rx1457_eos
    .local int rx1457_rep
    .local pmc rx1457_cur
    .local pmc rx1457_debug
    (rx1457_cur, rx1457_pos, rx1457_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1457_cur
    .local pmc match
    .lex "$/", match
    length rx1457_eos, rx1457_tgt
    gt rx1457_pos, rx1457_eos, rx1457_done
    set rx1457_off, 0
    lt rx1457_pos, 2, rx1457_start
    sub rx1457_off, rx1457_pos, 1
    substr rx1457_tgt, rx1457_tgt, rx1457_off
  rx1457_start:
    eq $I10, 1, rx1457_restart
    if_null rx1457_debug, debug_1043
    rx1457_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1043:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1461_done
    goto rxscan1461_scan
  rxscan1461_loop:
    (rx1457_pos) = rx1457_cur."from"()
    inc rx1457_pos
    rx1457_cur."!cursor_from"(rx1457_pos)
    ge rx1457_pos, rx1457_eos, rxscan1461_done
  rxscan1461_scan:
    set_addr $I10, rxscan1461_loop
    rx1457_cur."!mark_push"(0, rx1457_pos, $I10)
  rxscan1461_done:
.annotate 'line', 618
  # rx subcapture "sym"
    set_addr $I10, rxcap_1462_fail
    rx1457_cur."!mark_push"(0, rx1457_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1457_pos, 2
    gt $I11, rx1457_eos, rx1457_fail
    sub $I11, rx1457_pos, rx1457_off
    substr $S10, rx1457_tgt, $I11, 2
    ne $S10, "ge", rx1457_fail
    add rx1457_pos, 2
    set_addr $I10, rxcap_1462_fail
    ($I12, $I11) = rx1457_cur."!mark_peek"($I10)
    rx1457_cur."!cursor_pos"($I11)
    ($P10) = rx1457_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1457_pos, "")
    rx1457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1462_done
  rxcap_1462_fail:
    goto rx1457_fail
  rxcap_1462_done:
  # rx subrule "O" subtype=capture negate=
    rx1457_cur."!cursor_pos"(rx1457_pos)
    $P10 = rx1457_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1457_fail
    rx1457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1457_pos = $P10."pos"()
  # rx pass
    rx1457_cur."!cursor_pass"(rx1457_pos, "infix:sym<ge>")
    if_null rx1457_debug, debug_1044
    rx1457_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1457_pos)
  debug_1044:
    .return (rx1457_cur)
  rx1457_restart:
.annotate 'line', 4
    if_null rx1457_debug, debug_1045
    rx1457_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1045:
  rx1457_fail:
    (rx1457_rep, rx1457_pos, $I10, $P10) = rx1457_cur."!mark_fail"(0)
    lt rx1457_pos, -1, rx1457_done
    eq rx1457_pos, -1, rx1457_fail
    jump $I10
  rx1457_done:
    rx1457_cur."!cursor_fail"()
    if_null rx1457_debug, debug_1046
    rx1457_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1046:
    .return (rx1457_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("339_1297619321.796") :method
.annotate 'line', 4
    $P1459 = self."!PREFIX__!subrule"("O", "ge")
    new $P1460, "ResizablePMCArray"
    push $P1460, $P1459
    .return ($P1460)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("340_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1464_tgt
    .local int rx1464_pos
    .local int rx1464_off
    .local int rx1464_eos
    .local int rx1464_rep
    .local pmc rx1464_cur
    .local pmc rx1464_debug
    (rx1464_cur, rx1464_pos, rx1464_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1464_cur
    .local pmc match
    .lex "$/", match
    length rx1464_eos, rx1464_tgt
    gt rx1464_pos, rx1464_eos, rx1464_done
    set rx1464_off, 0
    lt rx1464_pos, 2, rx1464_start
    sub rx1464_off, rx1464_pos, 1
    substr rx1464_tgt, rx1464_tgt, rx1464_off
  rx1464_start:
    eq $I10, 1, rx1464_restart
    if_null rx1464_debug, debug_1047
    rx1464_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1047:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1468_done
    goto rxscan1468_scan
  rxscan1468_loop:
    (rx1464_pos) = rx1464_cur."from"()
    inc rx1464_pos
    rx1464_cur."!cursor_from"(rx1464_pos)
    ge rx1464_pos, rx1464_eos, rxscan1468_done
  rxscan1468_scan:
    set_addr $I10, rxscan1468_loop
    rx1464_cur."!mark_push"(0, rx1464_pos, $I10)
  rxscan1468_done:
.annotate 'line', 619
  # rx subcapture "sym"
    set_addr $I10, rxcap_1469_fail
    rx1464_cur."!mark_push"(0, rx1464_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1464_pos, 2
    gt $I11, rx1464_eos, rx1464_fail
    sub $I11, rx1464_pos, rx1464_off
    substr $S10, rx1464_tgt, $I11, 2
    ne $S10, "lt", rx1464_fail
    add rx1464_pos, 2
    set_addr $I10, rxcap_1469_fail
    ($I12, $I11) = rx1464_cur."!mark_peek"($I10)
    rx1464_cur."!cursor_pos"($I11)
    ($P10) = rx1464_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1464_pos, "")
    rx1464_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1469_done
  rxcap_1469_fail:
    goto rx1464_fail
  rxcap_1469_done:
  # rx subrule "O" subtype=capture negate=
    rx1464_cur."!cursor_pos"(rx1464_pos)
    $P10 = rx1464_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1464_fail
    rx1464_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1464_pos = $P10."pos"()
  # rx pass
    rx1464_cur."!cursor_pass"(rx1464_pos, "infix:sym<lt>")
    if_null rx1464_debug, debug_1048
    rx1464_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1464_pos)
  debug_1048:
    .return (rx1464_cur)
  rx1464_restart:
.annotate 'line', 4
    if_null rx1464_debug, debug_1049
    rx1464_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1049:
  rx1464_fail:
    (rx1464_rep, rx1464_pos, $I10, $P10) = rx1464_cur."!mark_fail"(0)
    lt rx1464_pos, -1, rx1464_done
    eq rx1464_pos, -1, rx1464_fail
    jump $I10
  rx1464_done:
    rx1464_cur."!cursor_fail"()
    if_null rx1464_debug, debug_1050
    rx1464_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1050:
    .return (rx1464_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("341_1297619321.796") :method
.annotate 'line', 4
    $P1466 = self."!PREFIX__!subrule"("O", "lt")
    new $P1467, "ResizablePMCArray"
    push $P1467, $P1466
    .return ($P1467)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("342_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1471_tgt
    .local int rx1471_pos
    .local int rx1471_off
    .local int rx1471_eos
    .local int rx1471_rep
    .local pmc rx1471_cur
    .local pmc rx1471_debug
    (rx1471_cur, rx1471_pos, rx1471_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1471_cur
    .local pmc match
    .lex "$/", match
    length rx1471_eos, rx1471_tgt
    gt rx1471_pos, rx1471_eos, rx1471_done
    set rx1471_off, 0
    lt rx1471_pos, 2, rx1471_start
    sub rx1471_off, rx1471_pos, 1
    substr rx1471_tgt, rx1471_tgt, rx1471_off
  rx1471_start:
    eq $I10, 1, rx1471_restart
    if_null rx1471_debug, debug_1051
    rx1471_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1051:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1475_done
    goto rxscan1475_scan
  rxscan1475_loop:
    (rx1471_pos) = rx1471_cur."from"()
    inc rx1471_pos
    rx1471_cur."!cursor_from"(rx1471_pos)
    ge rx1471_pos, rx1471_eos, rxscan1475_done
  rxscan1475_scan:
    set_addr $I10, rxscan1475_loop
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
  rxscan1475_done:
.annotate 'line', 620
  # rx subcapture "sym"
    set_addr $I10, rxcap_1476_fail
    rx1471_cur."!mark_push"(0, rx1471_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1471_pos, 2
    gt $I11, rx1471_eos, rx1471_fail
    sub $I11, rx1471_pos, rx1471_off
    substr $S10, rx1471_tgt, $I11, 2
    ne $S10, "gt", rx1471_fail
    add rx1471_pos, 2
    set_addr $I10, rxcap_1476_fail
    ($I12, $I11) = rx1471_cur."!mark_peek"($I10)
    rx1471_cur."!cursor_pos"($I11)
    ($P10) = rx1471_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1471_pos, "")
    rx1471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1476_done
  rxcap_1476_fail:
    goto rx1471_fail
  rxcap_1476_done:
  # rx subrule "O" subtype=capture negate=
    rx1471_cur."!cursor_pos"(rx1471_pos)
    $P10 = rx1471_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1471_fail
    rx1471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1471_pos = $P10."pos"()
  # rx pass
    rx1471_cur."!cursor_pass"(rx1471_pos, "infix:sym<gt>")
    if_null rx1471_debug, debug_1052
    rx1471_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1471_pos)
  debug_1052:
    .return (rx1471_cur)
  rx1471_restart:
.annotate 'line', 4
    if_null rx1471_debug, debug_1053
    rx1471_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1053:
  rx1471_fail:
    (rx1471_rep, rx1471_pos, $I10, $P10) = rx1471_cur."!mark_fail"(0)
    lt rx1471_pos, -1, rx1471_done
    eq rx1471_pos, -1, rx1471_fail
    jump $I10
  rx1471_done:
    rx1471_cur."!cursor_fail"()
    if_null rx1471_debug, debug_1054
    rx1471_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1054:
    .return (rx1471_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("343_1297619321.796") :method
.annotate 'line', 4
    $P1473 = self."!PREFIX__!subrule"("O", "gt")
    new $P1474, "ResizablePMCArray"
    push $P1474, $P1473
    .return ($P1474)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("344_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1478_tgt
    .local int rx1478_pos
    .local int rx1478_off
    .local int rx1478_eos
    .local int rx1478_rep
    .local pmc rx1478_cur
    .local pmc rx1478_debug
    (rx1478_cur, rx1478_pos, rx1478_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1478_cur
    .local pmc match
    .lex "$/", match
    length rx1478_eos, rx1478_tgt
    gt rx1478_pos, rx1478_eos, rx1478_done
    set rx1478_off, 0
    lt rx1478_pos, 2, rx1478_start
    sub rx1478_off, rx1478_pos, 1
    substr rx1478_tgt, rx1478_tgt, rx1478_off
  rx1478_start:
    eq $I10, 1, rx1478_restart
    if_null rx1478_debug, debug_1055
    rx1478_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1055:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1482_done
    goto rxscan1482_scan
  rxscan1482_loop:
    (rx1478_pos) = rx1478_cur."from"()
    inc rx1478_pos
    rx1478_cur."!cursor_from"(rx1478_pos)
    ge rx1478_pos, rx1478_eos, rxscan1482_done
  rxscan1482_scan:
    set_addr $I10, rxscan1482_loop
    rx1478_cur."!mark_push"(0, rx1478_pos, $I10)
  rxscan1482_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1483_fail
    rx1478_cur."!mark_push"(0, rx1478_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1478_pos, 3
    gt $I11, rx1478_eos, rx1478_fail
    sub $I11, rx1478_pos, rx1478_off
    substr $S10, rx1478_tgt, $I11, 3
    ne $S10, "=:=", rx1478_fail
    add rx1478_pos, 3
    set_addr $I10, rxcap_1483_fail
    ($I12, $I11) = rx1478_cur."!mark_peek"($I10)
    rx1478_cur."!cursor_pos"($I11)
    ($P10) = rx1478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1478_pos, "")
    rx1478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1483_done
  rxcap_1483_fail:
    goto rx1478_fail
  rxcap_1483_done:
  # rx subrule "O" subtype=capture negate=
    rx1478_cur."!cursor_pos"(rx1478_pos)
    $P10 = rx1478_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1478_fail
    rx1478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1478_pos = $P10."pos"()
  # rx pass
    rx1478_cur."!cursor_pass"(rx1478_pos, "infix:sym<=:=>")
    if_null rx1478_debug, debug_1056
    rx1478_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1478_pos)
  debug_1056:
    .return (rx1478_cur)
  rx1478_restart:
.annotate 'line', 4
    if_null rx1478_debug, debug_1057
    rx1478_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1057:
  rx1478_fail:
    (rx1478_rep, rx1478_pos, $I10, $P10) = rx1478_cur."!mark_fail"(0)
    lt rx1478_pos, -1, rx1478_done
    eq rx1478_pos, -1, rx1478_fail
    jump $I10
  rx1478_done:
    rx1478_cur."!cursor_fail"()
    if_null rx1478_debug, debug_1058
    rx1478_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1058:
    .return (rx1478_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("345_1297619321.796") :method
.annotate 'line', 4
    $P1480 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1481, "ResizablePMCArray"
    push $P1481, $P1480
    .return ($P1481)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("346_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1485_tgt
    .local int rx1485_pos
    .local int rx1485_off
    .local int rx1485_eos
    .local int rx1485_rep
    .local pmc rx1485_cur
    .local pmc rx1485_debug
    (rx1485_cur, rx1485_pos, rx1485_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1485_cur
    .local pmc match
    .lex "$/", match
    length rx1485_eos, rx1485_tgt
    gt rx1485_pos, rx1485_eos, rx1485_done
    set rx1485_off, 0
    lt rx1485_pos, 2, rx1485_start
    sub rx1485_off, rx1485_pos, 1
    substr rx1485_tgt, rx1485_tgt, rx1485_off
  rx1485_start:
    eq $I10, 1, rx1485_restart
    if_null rx1485_debug, debug_1059
    rx1485_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1059:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1489_done
    goto rxscan1489_scan
  rxscan1489_loop:
    (rx1485_pos) = rx1485_cur."from"()
    inc rx1485_pos
    rx1485_cur."!cursor_from"(rx1485_pos)
    ge rx1485_pos, rx1485_eos, rxscan1489_done
  rxscan1489_scan:
    set_addr $I10, rxscan1489_loop
    rx1485_cur."!mark_push"(0, rx1485_pos, $I10)
  rxscan1489_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1490_fail
    rx1485_cur."!mark_push"(0, rx1485_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1485_pos, 2
    gt $I11, rx1485_eos, rx1485_fail
    sub $I11, rx1485_pos, rx1485_off
    substr $S10, rx1485_tgt, $I11, 2
    ne $S10, "~~", rx1485_fail
    add rx1485_pos, 2
    set_addr $I10, rxcap_1490_fail
    ($I12, $I11) = rx1485_cur."!mark_peek"($I10)
    rx1485_cur."!cursor_pos"($I11)
    ($P10) = rx1485_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1485_pos, "")
    rx1485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1490_done
  rxcap_1490_fail:
    goto rx1485_fail
  rxcap_1490_done:
  # rx subrule "O" subtype=capture negate=
    rx1485_cur."!cursor_pos"(rx1485_pos)
    $P10 = rx1485_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1485_fail
    rx1485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1485_pos = $P10."pos"()
  # rx pass
    rx1485_cur."!cursor_pass"(rx1485_pos, "infix:sym<~~>")
    if_null rx1485_debug, debug_1060
    rx1485_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1485_pos)
  debug_1060:
    .return (rx1485_cur)
  rx1485_restart:
.annotate 'line', 4
    if_null rx1485_debug, debug_1061
    rx1485_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1061:
  rx1485_fail:
    (rx1485_rep, rx1485_pos, $I10, $P10) = rx1485_cur."!mark_fail"(0)
    lt rx1485_pos, -1, rx1485_done
    eq rx1485_pos, -1, rx1485_fail
    jump $I10
  rx1485_done:
    rx1485_cur."!cursor_fail"()
    if_null rx1485_debug, debug_1062
    rx1485_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1062:
    .return (rx1485_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("347_1297619321.796") :method
.annotate 'line', 4
    $P1487 = self."!PREFIX__!subrule"("O", "~~")
    new $P1488, "ResizablePMCArray"
    push $P1488, $P1487
    .return ($P1488)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("348_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1492_tgt
    .local int rx1492_pos
    .local int rx1492_off
    .local int rx1492_eos
    .local int rx1492_rep
    .local pmc rx1492_cur
    .local pmc rx1492_debug
    (rx1492_cur, rx1492_pos, rx1492_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1492_cur
    .local pmc match
    .lex "$/", match
    length rx1492_eos, rx1492_tgt
    gt rx1492_pos, rx1492_eos, rx1492_done
    set rx1492_off, 0
    lt rx1492_pos, 2, rx1492_start
    sub rx1492_off, rx1492_pos, 1
    substr rx1492_tgt, rx1492_tgt, rx1492_off
  rx1492_start:
    eq $I10, 1, rx1492_restart
    if_null rx1492_debug, debug_1063
    rx1492_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1063:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1496_done
    goto rxscan1496_scan
  rxscan1496_loop:
    (rx1492_pos) = rx1492_cur."from"()
    inc rx1492_pos
    rx1492_cur."!cursor_from"(rx1492_pos)
    ge rx1492_pos, rx1492_eos, rxscan1496_done
  rxscan1496_scan:
    set_addr $I10, rxscan1496_loop
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  rxscan1496_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1497_fail
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1492_pos, 2
    gt $I11, rx1492_eos, rx1492_fail
    sub $I11, rx1492_pos, rx1492_off
    substr $S10, rx1492_tgt, $I11, 2
    ne $S10, "&&", rx1492_fail
    add rx1492_pos, 2
    set_addr $I10, rxcap_1497_fail
    ($I12, $I11) = rx1492_cur."!mark_peek"($I10)
    rx1492_cur."!cursor_pos"($I11)
    ($P10) = rx1492_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1492_pos, "")
    rx1492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1497_done
  rxcap_1497_fail:
    goto rx1492_fail
  rxcap_1497_done:
  # rx subrule "O" subtype=capture negate=
    rx1492_cur."!cursor_pos"(rx1492_pos)
    $P10 = rx1492_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1492_fail
    rx1492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1492_pos = $P10."pos"()
  # rx pass
    rx1492_cur."!cursor_pass"(rx1492_pos, "infix:sym<&&>")
    if_null rx1492_debug, debug_1064
    rx1492_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1492_pos)
  debug_1064:
    .return (rx1492_cur)
  rx1492_restart:
.annotate 'line', 4
    if_null rx1492_debug, debug_1065
    rx1492_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1065:
  rx1492_fail:
    (rx1492_rep, rx1492_pos, $I10, $P10) = rx1492_cur."!mark_fail"(0)
    lt rx1492_pos, -1, rx1492_done
    eq rx1492_pos, -1, rx1492_fail
    jump $I10
  rx1492_done:
    rx1492_cur."!cursor_fail"()
    if_null rx1492_debug, debug_1066
    rx1492_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1066:
    .return (rx1492_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("349_1297619321.796") :method
.annotate 'line', 4
    $P1494 = self."!PREFIX__!subrule"("O", "&&")
    new $P1495, "ResizablePMCArray"
    push $P1495, $P1494
    .return ($P1495)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("350_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1499_tgt
    .local int rx1499_pos
    .local int rx1499_off
    .local int rx1499_eos
    .local int rx1499_rep
    .local pmc rx1499_cur
    .local pmc rx1499_debug
    (rx1499_cur, rx1499_pos, rx1499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1499_cur
    .local pmc match
    .lex "$/", match
    length rx1499_eos, rx1499_tgt
    gt rx1499_pos, rx1499_eos, rx1499_done
    set rx1499_off, 0
    lt rx1499_pos, 2, rx1499_start
    sub rx1499_off, rx1499_pos, 1
    substr rx1499_tgt, rx1499_tgt, rx1499_off
  rx1499_start:
    eq $I10, 1, rx1499_restart
    if_null rx1499_debug, debug_1067
    rx1499_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1067:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1503_done
    goto rxscan1503_scan
  rxscan1503_loop:
    (rx1499_pos) = rx1499_cur."from"()
    inc rx1499_pos
    rx1499_cur."!cursor_from"(rx1499_pos)
    ge rx1499_pos, rx1499_eos, rxscan1503_done
  rxscan1503_scan:
    set_addr $I10, rxscan1503_loop
    rx1499_cur."!mark_push"(0, rx1499_pos, $I10)
  rxscan1503_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1504_fail
    rx1499_cur."!mark_push"(0, rx1499_pos, $I10)
  # rx literal  "||"
    add $I11, rx1499_pos, 2
    gt $I11, rx1499_eos, rx1499_fail
    sub $I11, rx1499_pos, rx1499_off
    substr $S10, rx1499_tgt, $I11, 2
    ne $S10, "||", rx1499_fail
    add rx1499_pos, 2
    set_addr $I10, rxcap_1504_fail
    ($I12, $I11) = rx1499_cur."!mark_peek"($I10)
    rx1499_cur."!cursor_pos"($I11)
    ($P10) = rx1499_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1499_pos, "")
    rx1499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1504_done
  rxcap_1504_fail:
    goto rx1499_fail
  rxcap_1504_done:
  # rx subrule "O" subtype=capture negate=
    rx1499_cur."!cursor_pos"(rx1499_pos)
    $P10 = rx1499_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1499_fail
    rx1499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1499_pos = $P10."pos"()
  # rx pass
    rx1499_cur."!cursor_pass"(rx1499_pos, "infix:sym<||>")
    if_null rx1499_debug, debug_1068
    rx1499_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1499_pos)
  debug_1068:
    .return (rx1499_cur)
  rx1499_restart:
.annotate 'line', 4
    if_null rx1499_debug, debug_1069
    rx1499_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1069:
  rx1499_fail:
    (rx1499_rep, rx1499_pos, $I10, $P10) = rx1499_cur."!mark_fail"(0)
    lt rx1499_pos, -1, rx1499_done
    eq rx1499_pos, -1, rx1499_fail
    jump $I10
  rx1499_done:
    rx1499_cur."!cursor_fail"()
    if_null rx1499_debug, debug_1070
    rx1499_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1070:
    .return (rx1499_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("351_1297619321.796") :method
.annotate 'line', 4
    $P1501 = self."!PREFIX__!subrule"("O", "||")
    new $P1502, "ResizablePMCArray"
    push $P1502, $P1501
    .return ($P1502)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("352_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1506_tgt
    .local int rx1506_pos
    .local int rx1506_off
    .local int rx1506_eos
    .local int rx1506_rep
    .local pmc rx1506_cur
    .local pmc rx1506_debug
    (rx1506_cur, rx1506_pos, rx1506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1506_cur
    .local pmc match
    .lex "$/", match
    length rx1506_eos, rx1506_tgt
    gt rx1506_pos, rx1506_eos, rx1506_done
    set rx1506_off, 0
    lt rx1506_pos, 2, rx1506_start
    sub rx1506_off, rx1506_pos, 1
    substr rx1506_tgt, rx1506_tgt, rx1506_off
  rx1506_start:
    eq $I10, 1, rx1506_restart
    if_null rx1506_debug, debug_1071
    rx1506_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1071:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1510_done
    goto rxscan1510_scan
  rxscan1510_loop:
    (rx1506_pos) = rx1506_cur."from"()
    inc rx1506_pos
    rx1506_cur."!cursor_from"(rx1506_pos)
    ge rx1506_pos, rx1506_eos, rxscan1510_done
  rxscan1510_scan:
    set_addr $I10, rxscan1510_loop
    rx1506_cur."!mark_push"(0, rx1506_pos, $I10)
  rxscan1510_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1511_fail
    rx1506_cur."!mark_push"(0, rx1506_pos, $I10)
  # rx literal  "//"
    add $I11, rx1506_pos, 2
    gt $I11, rx1506_eos, rx1506_fail
    sub $I11, rx1506_pos, rx1506_off
    substr $S10, rx1506_tgt, $I11, 2
    ne $S10, "//", rx1506_fail
    add rx1506_pos, 2
    set_addr $I10, rxcap_1511_fail
    ($I12, $I11) = rx1506_cur."!mark_peek"($I10)
    rx1506_cur."!cursor_pos"($I11)
    ($P10) = rx1506_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1506_pos, "")
    rx1506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1511_done
  rxcap_1511_fail:
    goto rx1506_fail
  rxcap_1511_done:
  # rx subrule "O" subtype=capture negate=
    rx1506_cur."!cursor_pos"(rx1506_pos)
    $P10 = rx1506_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1506_fail
    rx1506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1506_pos = $P10."pos"()
  # rx pass
    rx1506_cur."!cursor_pass"(rx1506_pos, "infix:sym<//>")
    if_null rx1506_debug, debug_1072
    rx1506_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1506_pos)
  debug_1072:
    .return (rx1506_cur)
  rx1506_restart:
.annotate 'line', 4
    if_null rx1506_debug, debug_1073
    rx1506_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1073:
  rx1506_fail:
    (rx1506_rep, rx1506_pos, $I10, $P10) = rx1506_cur."!mark_fail"(0)
    lt rx1506_pos, -1, rx1506_done
    eq rx1506_pos, -1, rx1506_fail
    jump $I10
  rx1506_done:
    rx1506_cur."!cursor_fail"()
    if_null rx1506_debug, debug_1074
    rx1506_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1074:
    .return (rx1506_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("353_1297619321.796") :method
.annotate 'line', 4
    $P1508 = self."!PREFIX__!subrule"("O", "//")
    new $P1509, "ResizablePMCArray"
    push $P1509, $P1508
    .return ($P1509)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("354_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1513_tgt
    .local int rx1513_pos
    .local int rx1513_off
    .local int rx1513_eos
    .local int rx1513_rep
    .local pmc rx1513_cur
    .local pmc rx1513_debug
    (rx1513_cur, rx1513_pos, rx1513_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1513_cur
    .local pmc match
    .lex "$/", match
    length rx1513_eos, rx1513_tgt
    gt rx1513_pos, rx1513_eos, rx1513_done
    set rx1513_off, 0
    lt rx1513_pos, 2, rx1513_start
    sub rx1513_off, rx1513_pos, 1
    substr rx1513_tgt, rx1513_tgt, rx1513_off
  rx1513_start:
    eq $I10, 1, rx1513_restart
    if_null rx1513_debug, debug_1075
    rx1513_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1075:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1517_done
    goto rxscan1517_scan
  rxscan1517_loop:
    (rx1513_pos) = rx1513_cur."from"()
    inc rx1513_pos
    rx1513_cur."!cursor_from"(rx1513_pos)
    ge rx1513_pos, rx1513_eos, rxscan1517_done
  rxscan1517_scan:
    set_addr $I10, rxscan1517_loop
    rx1513_cur."!mark_push"(0, rx1513_pos, $I10)
  rxscan1517_done:
.annotate 'line', 630
  # rx literal  "??"
    add $I11, rx1513_pos, 2
    gt $I11, rx1513_eos, rx1513_fail
    sub $I11, rx1513_pos, rx1513_off
    substr $S10, rx1513_tgt, $I11, 2
    ne $S10, "??", rx1513_fail
    add rx1513_pos, 2
.annotate 'line', 631
  # rx subrule "ws" subtype=method negate=
    rx1513_cur."!cursor_pos"(rx1513_pos)
    $P10 = rx1513_cur."ws"()
    unless $P10, rx1513_fail
    rx1513_pos = $P10."pos"()
.annotate 'line', 632
  # rx subrule "EXPR" subtype=capture negate=
    rx1513_cur."!cursor_pos"(rx1513_pos)
    $P10 = rx1513_cur."EXPR"("i=")
    unless $P10, rx1513_fail
    rx1513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1513_pos = $P10."pos"()
.annotate 'line', 633
  # rx literal  "!!"
    add $I11, rx1513_pos, 2
    gt $I11, rx1513_eos, rx1513_fail
    sub $I11, rx1513_pos, rx1513_off
    substr $S10, rx1513_tgt, $I11, 2
    ne $S10, "!!", rx1513_fail
    add rx1513_pos, 2
.annotate 'line', 634
  # rx subrule "O" subtype=capture negate=
    rx1513_cur."!cursor_pos"(rx1513_pos)
    $P10 = rx1513_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1513_fail
    rx1513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1513_pos = $P10."pos"()
.annotate 'line', 629
  # rx pass
    rx1513_cur."!cursor_pass"(rx1513_pos, "infix:sym<?? !!>")
    if_null rx1513_debug, debug_1076
    rx1513_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1513_pos)
  debug_1076:
    .return (rx1513_cur)
  rx1513_restart:
.annotate 'line', 4
    if_null rx1513_debug, debug_1077
    rx1513_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1077:
  rx1513_fail:
    (rx1513_rep, rx1513_pos, $I10, $P10) = rx1513_cur."!mark_fail"(0)
    lt rx1513_pos, -1, rx1513_done
    eq rx1513_pos, -1, rx1513_fail
    jump $I10
  rx1513_done:
    rx1513_cur."!cursor_fail"()
    if_null rx1513_debug, debug_1078
    rx1513_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1078:
    .return (rx1513_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("355_1297619321.796") :method
.annotate 'line', 4
    $P1515 = self."!PREFIX__!subrule"("ws", "??")
    new $P1516, "ResizablePMCArray"
    push $P1516, $P1515
    .return ($P1516)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("356_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1519_tgt
    .local int rx1519_pos
    .local int rx1519_off
    .local int rx1519_eos
    .local int rx1519_rep
    .local pmc rx1519_cur
    .local pmc rx1519_debug
    (rx1519_cur, rx1519_pos, rx1519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1519_cur
    .local pmc match
    .lex "$/", match
    length rx1519_eos, rx1519_tgt
    gt rx1519_pos, rx1519_eos, rx1519_done
    set rx1519_off, 0
    lt rx1519_pos, 2, rx1519_start
    sub rx1519_off, rx1519_pos, 1
    substr rx1519_tgt, rx1519_tgt, rx1519_off
  rx1519_start:
    eq $I10, 1, rx1519_restart
    if_null rx1519_debug, debug_1079
    rx1519_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1079:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1523_done
    goto rxscan1523_scan
  rxscan1523_loop:
    (rx1519_pos) = rx1519_cur."from"()
    inc rx1519_pos
    rx1519_cur."!cursor_from"(rx1519_pos)
    ge rx1519_pos, rx1519_eos, rxscan1523_done
  rxscan1523_scan:
    set_addr $I10, rxscan1523_loop
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  rxscan1523_done:
.annotate 'line', 638
  # rx subcapture "sym"
    set_addr $I10, rxcap_1524_fail
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  # rx literal  "="
    add $I11, rx1519_pos, 1
    gt $I11, rx1519_eos, rx1519_fail
    sub $I11, rx1519_pos, rx1519_off
    ord $I11, rx1519_tgt, $I11
    ne $I11, 61, rx1519_fail
    add rx1519_pos, 1
    set_addr $I10, rxcap_1524_fail
    ($I12, $I11) = rx1519_cur."!mark_peek"($I10)
    rx1519_cur."!cursor_pos"($I11)
    ($P10) = rx1519_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1519_pos, "")
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1524_done
  rxcap_1524_fail:
    goto rx1519_fail
  rxcap_1524_done:
  # rx subrule "panic" subtype=method negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1519_fail
    rx1519_pos = $P10."pos"()
.annotate 'line', 637
  # rx pass
    rx1519_cur."!cursor_pass"(rx1519_pos, "infix:sym<=>")
    if_null rx1519_debug, debug_1080
    rx1519_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1519_pos)
  debug_1080:
    .return (rx1519_cur)
  rx1519_restart:
.annotate 'line', 4
    if_null rx1519_debug, debug_1081
    rx1519_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1081:
  rx1519_fail:
    (rx1519_rep, rx1519_pos, $I10, $P10) = rx1519_cur."!mark_fail"(0)
    lt rx1519_pos, -1, rx1519_done
    eq rx1519_pos, -1, rx1519_fail
    jump $I10
  rx1519_done:
    rx1519_cur."!cursor_fail"()
    if_null rx1519_debug, debug_1082
    rx1519_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1082:
    .return (rx1519_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("357_1297619321.796") :method
.annotate 'line', 4
    $P1521 = self."!PREFIX__!subrule"("panic", "=")
    new $P1522, "ResizablePMCArray"
    push $P1522, $P1521
    .return ($P1522)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("358_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1526_tgt
    .local int rx1526_pos
    .local int rx1526_off
    .local int rx1526_eos
    .local int rx1526_rep
    .local pmc rx1526_cur
    .local pmc rx1526_debug
    (rx1526_cur, rx1526_pos, rx1526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1526_cur
    .local pmc match
    .lex "$/", match
    length rx1526_eos, rx1526_tgt
    gt rx1526_pos, rx1526_eos, rx1526_done
    set rx1526_off, 0
    lt rx1526_pos, 2, rx1526_start
    sub rx1526_off, rx1526_pos, 1
    substr rx1526_tgt, rx1526_tgt, rx1526_off
  rx1526_start:
    eq $I10, 1, rx1526_restart
    if_null rx1526_debug, debug_1083
    rx1526_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1083:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1530_done
    goto rxscan1530_scan
  rxscan1530_loop:
    (rx1526_pos) = rx1526_cur."from"()
    inc rx1526_pos
    rx1526_cur."!cursor_from"(rx1526_pos)
    ge rx1526_pos, rx1526_eos, rxscan1530_done
  rxscan1530_scan:
    set_addr $I10, rxscan1530_loop
    rx1526_cur."!mark_push"(0, rx1526_pos, $I10)
  rxscan1530_done:
.annotate 'line', 640
  # rx subcapture "sym"
    set_addr $I10, rxcap_1531_fail
    rx1526_cur."!mark_push"(0, rx1526_pos, $I10)
  # rx literal  ":="
    add $I11, rx1526_pos, 2
    gt $I11, rx1526_eos, rx1526_fail
    sub $I11, rx1526_pos, rx1526_off
    substr $S10, rx1526_tgt, $I11, 2
    ne $S10, ":=", rx1526_fail
    add rx1526_pos, 2
    set_addr $I10, rxcap_1531_fail
    ($I12, $I11) = rx1526_cur."!mark_peek"($I10)
    rx1526_cur."!cursor_pos"($I11)
    ($P10) = rx1526_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1526_pos, "")
    rx1526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1531_done
  rxcap_1531_fail:
    goto rx1526_fail
  rxcap_1531_done:
  # rx subrule "O" subtype=capture negate=
    rx1526_cur."!cursor_pos"(rx1526_pos)
    $P10 = rx1526_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1526_fail
    rx1526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1526_pos = $P10."pos"()
  # rx pass
    rx1526_cur."!cursor_pass"(rx1526_pos, "infix:sym<:=>")
    if_null rx1526_debug, debug_1084
    rx1526_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1526_pos)
  debug_1084:
    .return (rx1526_cur)
  rx1526_restart:
.annotate 'line', 4
    if_null rx1526_debug, debug_1085
    rx1526_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1085:
  rx1526_fail:
    (rx1526_rep, rx1526_pos, $I10, $P10) = rx1526_cur."!mark_fail"(0)
    lt rx1526_pos, -1, rx1526_done
    eq rx1526_pos, -1, rx1526_fail
    jump $I10
  rx1526_done:
    rx1526_cur."!cursor_fail"()
    if_null rx1526_debug, debug_1086
    rx1526_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1086:
    .return (rx1526_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("359_1297619321.796") :method
.annotate 'line', 4
    $P1528 = self."!PREFIX__!subrule"("O", ":=")
    new $P1529, "ResizablePMCArray"
    push $P1529, $P1528
    .return ($P1529)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("360_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1533_tgt
    .local int rx1533_pos
    .local int rx1533_off
    .local int rx1533_eos
    .local int rx1533_rep
    .local pmc rx1533_cur
    .local pmc rx1533_debug
    (rx1533_cur, rx1533_pos, rx1533_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1533_cur
    .local pmc match
    .lex "$/", match
    length rx1533_eos, rx1533_tgt
    gt rx1533_pos, rx1533_eos, rx1533_done
    set rx1533_off, 0
    lt rx1533_pos, 2, rx1533_start
    sub rx1533_off, rx1533_pos, 1
    substr rx1533_tgt, rx1533_tgt, rx1533_off
  rx1533_start:
    eq $I10, 1, rx1533_restart
    if_null rx1533_debug, debug_1087
    rx1533_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1087:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1537_done
    goto rxscan1537_scan
  rxscan1537_loop:
    (rx1533_pos) = rx1533_cur."from"()
    inc rx1533_pos
    rx1533_cur."!cursor_from"(rx1533_pos)
    ge rx1533_pos, rx1533_eos, rxscan1537_done
  rxscan1537_scan:
    set_addr $I10, rxscan1537_loop
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  rxscan1537_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1538_fail
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  # rx literal  "::="
    add $I11, rx1533_pos, 3
    gt $I11, rx1533_eos, rx1533_fail
    sub $I11, rx1533_pos, rx1533_off
    substr $S10, rx1533_tgt, $I11, 3
    ne $S10, "::=", rx1533_fail
    add rx1533_pos, 3
    set_addr $I10, rxcap_1538_fail
    ($I12, $I11) = rx1533_cur."!mark_peek"($I10)
    rx1533_cur."!cursor_pos"($I11)
    ($P10) = rx1533_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1533_pos, "")
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1538_done
  rxcap_1538_fail:
    goto rx1533_fail
  rxcap_1538_done:
  # rx subrule "O" subtype=capture negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1533_fail
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1533_pos = $P10."pos"()
  # rx pass
    rx1533_cur."!cursor_pass"(rx1533_pos, "infix:sym<::=>")
    if_null rx1533_debug, debug_1088
    rx1533_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1533_pos)
  debug_1088:
    .return (rx1533_cur)
  rx1533_restart:
.annotate 'line', 4
    if_null rx1533_debug, debug_1089
    rx1533_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1089:
  rx1533_fail:
    (rx1533_rep, rx1533_pos, $I10, $P10) = rx1533_cur."!mark_fail"(0)
    lt rx1533_pos, -1, rx1533_done
    eq rx1533_pos, -1, rx1533_fail
    jump $I10
  rx1533_done:
    rx1533_cur."!cursor_fail"()
    if_null rx1533_debug, debug_1090
    rx1533_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1090:
    .return (rx1533_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("361_1297619321.796") :method
.annotate 'line', 4
    $P1535 = self."!PREFIX__!subrule"("O", "::=")
    new $P1536, "ResizablePMCArray"
    push $P1536, $P1535
    .return ($P1536)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("362_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1540_tgt
    .local int rx1540_pos
    .local int rx1540_off
    .local int rx1540_eos
    .local int rx1540_rep
    .local pmc rx1540_cur
    .local pmc rx1540_debug
    (rx1540_cur, rx1540_pos, rx1540_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1540_cur
    .local pmc match
    .lex "$/", match
    length rx1540_eos, rx1540_tgt
    gt rx1540_pos, rx1540_eos, rx1540_done
    set rx1540_off, 0
    lt rx1540_pos, 2, rx1540_start
    sub rx1540_off, rx1540_pos, 1
    substr rx1540_tgt, rx1540_tgt, rx1540_off
  rx1540_start:
    eq $I10, 1, rx1540_restart
    if_null rx1540_debug, debug_1091
    rx1540_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1091:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1544_done
    goto rxscan1544_scan
  rxscan1544_loop:
    (rx1540_pos) = rx1540_cur."from"()
    inc rx1540_pos
    rx1540_cur."!cursor_from"(rx1540_pos)
    ge rx1540_pos, rx1540_eos, rxscan1544_done
  rxscan1544_scan:
    set_addr $I10, rxscan1544_loop
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  rxscan1544_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1545_fail
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  # rx literal  ","
    add $I11, rx1540_pos, 1
    gt $I11, rx1540_eos, rx1540_fail
    sub $I11, rx1540_pos, rx1540_off
    ord $I11, rx1540_tgt, $I11
    ne $I11, 44, rx1540_fail
    add rx1540_pos, 1
    set_addr $I10, rxcap_1545_fail
    ($I12, $I11) = rx1540_cur."!mark_peek"($I10)
    rx1540_cur."!cursor_pos"($I11)
    ($P10) = rx1540_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1540_pos, "")
    rx1540_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1545_done
  rxcap_1545_fail:
    goto rx1540_fail
  rxcap_1545_done:
  # rx subrule "O" subtype=capture negate=
    rx1540_cur."!cursor_pos"(rx1540_pos)
    $P10 = rx1540_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1540_fail
    rx1540_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1540_pos = $P10."pos"()
  # rx pass
    rx1540_cur."!cursor_pass"(rx1540_pos, "infix:sym<,>")
    if_null rx1540_debug, debug_1092
    rx1540_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1540_pos)
  debug_1092:
    .return (rx1540_cur)
  rx1540_restart:
.annotate 'line', 4
    if_null rx1540_debug, debug_1093
    rx1540_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1093:
  rx1540_fail:
    (rx1540_rep, rx1540_pos, $I10, $P10) = rx1540_cur."!mark_fail"(0)
    lt rx1540_pos, -1, rx1540_done
    eq rx1540_pos, -1, rx1540_fail
    jump $I10
  rx1540_done:
    rx1540_cur."!cursor_fail"()
    if_null rx1540_debug, debug_1094
    rx1540_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1094:
    .return (rx1540_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("363_1297619321.796") :method
.annotate 'line', 4
    $P1542 = self."!PREFIX__!subrule"("O", ",")
    new $P1543, "ResizablePMCArray"
    push $P1543, $P1542
    .return ($P1543)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("364_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P1555 = "366_1297619321.796" 
    capture_lex $P1555
    .local string rx1547_tgt
    .local int rx1547_pos
    .local int rx1547_off
    .local int rx1547_eos
    .local int rx1547_rep
    .local pmc rx1547_cur
    .local pmc rx1547_debug
    (rx1547_cur, rx1547_pos, rx1547_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1547_cur
    .local pmc match
    .lex "$/", match
    length rx1547_eos, rx1547_tgt
    gt rx1547_pos, rx1547_eos, rx1547_done
    set rx1547_off, 0
    lt rx1547_pos, 2, rx1547_start
    sub rx1547_off, rx1547_pos, 1
    substr rx1547_tgt, rx1547_tgt, rx1547_off
  rx1547_start:
    eq $I10, 1, rx1547_restart
    if_null rx1547_debug, debug_1095
    rx1547_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1095:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1550_done
    goto rxscan1550_scan
  rxscan1550_loop:
    (rx1547_pos) = rx1547_cur."from"()
    inc rx1547_pos
    rx1547_cur."!cursor_from"(rx1547_pos)
    ge rx1547_pos, rx1547_eos, rxscan1550_done
  rxscan1550_scan:
    set_addr $I10, rxscan1550_loop
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  rxscan1550_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1551_fail
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  # rx literal  "return"
    add $I11, rx1547_pos, 6
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 6
    ne $S10, "return", rx1547_fail
    add rx1547_pos, 6
    set_addr $I10, rxcap_1551_fail
    ($I12, $I11) = rx1547_cur."!mark_peek"($I10)
    rx1547_cur."!cursor_pos"($I11)
    ($P10) = rx1547_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1547_pos, "")
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1551_done
  rxcap_1551_fail:
    goto rx1547_fail
  rxcap_1551_done:
  # rx charclass s
    ge rx1547_pos, rx1547_eos, rx1547_fail
    sub $I10, rx1547_pos, rx1547_off
    is_cclass $I11, 32, rx1547_tgt, $I10
    unless $I11, rx1547_fail
    inc rx1547_pos
  # rx subrule "O" subtype=capture negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1547_fail
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1547_pos = $P10."pos"()
    rx1547_cur."!cursor_pos"(rx1547_pos)
    find_lex $P1552, unicode:"$\x{a2}"
    $P1553 = $P1552."MATCH"()
    store_lex "$/", $P1553
    .const 'Sub' $P1555 = "366_1297619321.796" 
    capture_lex $P1555
    $P1557 = $P1555()
  # rx pass
    rx1547_cur."!cursor_pass"(rx1547_pos, "prefix:sym<return>")
    if_null rx1547_debug, debug_1096
    rx1547_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1547_pos)
  debug_1096:
    .return (rx1547_cur)
  rx1547_restart:
.annotate 'line', 4
    if_null rx1547_debug, debug_1097
    rx1547_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1097:
  rx1547_fail:
    (rx1547_rep, rx1547_pos, $I10, $P10) = rx1547_cur."!mark_fail"(0)
    lt rx1547_pos, -1, rx1547_done
    eq rx1547_pos, -1, rx1547_fail
    jump $I10
  rx1547_done:
    rx1547_cur."!cursor_fail"()
    if_null rx1547_debug, debug_1098
    rx1547_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1098:
    .return (rx1547_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("365_1297619321.796") :method
.annotate 'line', 4
    new $P1549, "ResizablePMCArray"
    push $P1549, "return"
    .return ($P1549)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1554"  :anon :subid("366_1297619321.796") :outer("364_1297619321.796")
.annotate 'line', 645
    new $P1556, "Integer"
    assign $P1556, 1
    store_dynamic_lex "$*RETURN_USED", $P1556
    .return ($P1556)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("367_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1559_tgt
    .local int rx1559_pos
    .local int rx1559_off
    .local int rx1559_eos
    .local int rx1559_rep
    .local pmc rx1559_cur
    .local pmc rx1559_debug
    (rx1559_cur, rx1559_pos, rx1559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1559_cur
    .local pmc match
    .lex "$/", match
    length rx1559_eos, rx1559_tgt
    gt rx1559_pos, rx1559_eos, rx1559_done
    set rx1559_off, 0
    lt rx1559_pos, 2, rx1559_start
    sub rx1559_off, rx1559_pos, 1
    substr rx1559_tgt, rx1559_tgt, rx1559_off
  rx1559_start:
    eq $I10, 1, rx1559_restart
    if_null rx1559_debug, debug_1099
    rx1559_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1099:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1559_pos) = rx1559_cur."from"()
    inc rx1559_pos
    rx1559_cur."!cursor_from"(rx1559_pos)
    ge rx1559_pos, rx1559_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  rxscan1562_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1563_fail
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  # rx literal  "make"
    add $I11, rx1559_pos, 4
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    substr $S10, rx1559_tgt, $I11, 4
    ne $S10, "make", rx1559_fail
    add rx1559_pos, 4
    set_addr $I10, rxcap_1563_fail
    ($I12, $I11) = rx1559_cur."!mark_peek"($I10)
    rx1559_cur."!cursor_pos"($I11)
    ($P10) = rx1559_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1559_pos, "")
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1563_done
  rxcap_1563_fail:
    goto rx1559_fail
  rxcap_1563_done:
  # rx charclass s
    ge rx1559_pos, rx1559_eos, rx1559_fail
    sub $I10, rx1559_pos, rx1559_off
    is_cclass $I11, 32, rx1559_tgt, $I10
    unless $I11, rx1559_fail
    inc rx1559_pos
  # rx subrule "O" subtype=capture negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."O"("%list_prefix")
    unless $P10, rx1559_fail
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1559_pos = $P10."pos"()
  # rx pass
    rx1559_cur."!cursor_pass"(rx1559_pos, "prefix:sym<make>")
    if_null rx1559_debug, debug_1100
    rx1559_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1559_pos)
  debug_1100:
    .return (rx1559_cur)
  rx1559_restart:
.annotate 'line', 4
    if_null rx1559_debug, debug_1101
    rx1559_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1101:
  rx1559_fail:
    (rx1559_rep, rx1559_pos, $I10, $P10) = rx1559_cur."!mark_fail"(0)
    lt rx1559_pos, -1, rx1559_done
    eq rx1559_pos, -1, rx1559_fail
    jump $I10
  rx1559_done:
    rx1559_cur."!cursor_fail"()
    if_null rx1559_debug, debug_1102
    rx1559_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1102:
    .return (rx1559_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("368_1297619321.796") :method
.annotate 'line', 4
    new $P1561, "ResizablePMCArray"
    push $P1561, "make"
    .return ($P1561)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("369_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1565_tgt
    .local int rx1565_pos
    .local int rx1565_off
    .local int rx1565_eos
    .local int rx1565_rep
    .local pmc rx1565_cur
    .local pmc rx1565_debug
    (rx1565_cur, rx1565_pos, rx1565_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1565_cur
    .local pmc match
    .lex "$/", match
    length rx1565_eos, rx1565_tgt
    gt rx1565_pos, rx1565_eos, rx1565_done
    set rx1565_off, 0
    lt rx1565_pos, 2, rx1565_start
    sub rx1565_off, rx1565_pos, 1
    substr rx1565_tgt, rx1565_tgt, rx1565_off
  rx1565_start:
    eq $I10, 1, rx1565_restart
    if_null rx1565_debug, debug_1103
    rx1565_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1103:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1568_done
    goto rxscan1568_scan
  rxscan1568_loop:
    (rx1565_pos) = rx1565_cur."from"()
    inc rx1565_pos
    rx1565_cur."!cursor_from"(rx1565_pos)
    ge rx1565_pos, rx1565_eos, rxscan1568_done
  rxscan1568_scan:
    set_addr $I10, rxscan1568_loop
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  rxscan1568_done:
.annotate 'line', 647
  # rx subcapture "sym"
    set_addr $I10, rxcap_1569_fail
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  # rx literal  "last"
    add $I11, rx1565_pos, 4
    gt $I11, rx1565_eos, rx1565_fail
    sub $I11, rx1565_pos, rx1565_off
    substr $S10, rx1565_tgt, $I11, 4
    ne $S10, "last", rx1565_fail
    add rx1565_pos, 4
    set_addr $I10, rxcap_1569_fail
    ($I12, $I11) = rx1565_cur."!mark_peek"($I10)
    rx1565_cur."!cursor_pos"($I11)
    ($P10) = rx1565_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1565_pos, "")
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1569_done
  rxcap_1569_fail:
    goto rx1565_fail
  rxcap_1569_done:
  # rx pass
    rx1565_cur."!cursor_pass"(rx1565_pos, "term:sym<last>")
    if_null rx1565_debug, debug_1104
    rx1565_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1565_pos)
  debug_1104:
    .return (rx1565_cur)
  rx1565_restart:
.annotate 'line', 4
    if_null rx1565_debug, debug_1105
    rx1565_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1105:
  rx1565_fail:
    (rx1565_rep, rx1565_pos, $I10, $P10) = rx1565_cur."!mark_fail"(0)
    lt rx1565_pos, -1, rx1565_done
    eq rx1565_pos, -1, rx1565_fail
    jump $I10
  rx1565_done:
    rx1565_cur."!cursor_fail"()
    if_null rx1565_debug, debug_1106
    rx1565_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1106:
    .return (rx1565_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("370_1297619321.796") :method
.annotate 'line', 4
    new $P1567, "ResizablePMCArray"
    push $P1567, "last"
    .return ($P1567)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("371_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1571_tgt
    .local int rx1571_pos
    .local int rx1571_off
    .local int rx1571_eos
    .local int rx1571_rep
    .local pmc rx1571_cur
    .local pmc rx1571_debug
    (rx1571_cur, rx1571_pos, rx1571_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1571_cur
    .local pmc match
    .lex "$/", match
    length rx1571_eos, rx1571_tgt
    gt rx1571_pos, rx1571_eos, rx1571_done
    set rx1571_off, 0
    lt rx1571_pos, 2, rx1571_start
    sub rx1571_off, rx1571_pos, 1
    substr rx1571_tgt, rx1571_tgt, rx1571_off
  rx1571_start:
    eq $I10, 1, rx1571_restart
    if_null rx1571_debug, debug_1107
    rx1571_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1107:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1571_pos) = rx1571_cur."from"()
    inc rx1571_pos
    rx1571_cur."!cursor_from"(rx1571_pos)
    ge rx1571_pos, rx1571_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  rxscan1574_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1575_fail
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  # rx literal  "next"
    add $I11, rx1571_pos, 4
    gt $I11, rx1571_eos, rx1571_fail
    sub $I11, rx1571_pos, rx1571_off
    substr $S10, rx1571_tgt, $I11, 4
    ne $S10, "next", rx1571_fail
    add rx1571_pos, 4
    set_addr $I10, rxcap_1575_fail
    ($I12, $I11) = rx1571_cur."!mark_peek"($I10)
    rx1571_cur."!cursor_pos"($I11)
    ($P10) = rx1571_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1571_pos, "")
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1575_done
  rxcap_1575_fail:
    goto rx1571_fail
  rxcap_1575_done:
  # rx pass
    rx1571_cur."!cursor_pass"(rx1571_pos, "term:sym<next>")
    if_null rx1571_debug, debug_1108
    rx1571_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1571_pos)
  debug_1108:
    .return (rx1571_cur)
  rx1571_restart:
.annotate 'line', 4
    if_null rx1571_debug, debug_1109
    rx1571_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1109:
  rx1571_fail:
    (rx1571_rep, rx1571_pos, $I10, $P10) = rx1571_cur."!mark_fail"(0)
    lt rx1571_pos, -1, rx1571_done
    eq rx1571_pos, -1, rx1571_fail
    jump $I10
  rx1571_done:
    rx1571_cur."!cursor_fail"()
    if_null rx1571_debug, debug_1110
    rx1571_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1110:
    .return (rx1571_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("372_1297619321.796") :method
.annotate 'line', 4
    new $P1573, "ResizablePMCArray"
    push $P1573, "next"
    .return ($P1573)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("373_1297619321.796") :method :outer("11_1297619321.796")
.annotate 'line', 4
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1111
    rx1577_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1111:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1580_done
    goto rxscan1580_scan
  rxscan1580_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1580_done
  rxscan1580_scan:
    set_addr $I10, rxscan1580_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1580_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1581_fail
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1577_pos, 4
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 4
    ne $S10, "redo", rx1577_fail
    add rx1577_pos, 4
    set_addr $I10, rxcap_1581_fail
    ($I12, $I11) = rx1577_cur."!mark_peek"($I10)
    rx1577_cur."!cursor_pos"($I11)
    ($P10) = rx1577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1577_pos, "")
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1581_done
  rxcap_1581_fail:
    goto rx1577_fail
  rxcap_1581_done:
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "term:sym<redo>")
    if_null rx1577_debug, debug_1112
    rx1577_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1577_pos)
  debug_1112:
    .return (rx1577_cur)
  rx1577_restart:
.annotate 'line', 4
    if_null rx1577_debug, debug_1113
    rx1577_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1113:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1114
    rx1577_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1114:
    .return (rx1577_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("374_1297619321.796") :method
.annotate 'line', 4
    new $P1579, "ResizablePMCArray"
    push $P1579, "redo"
    .return ($P1579)
.end


.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("375_1297619321.796") :outer("11_1297619321.796")
    .param pmc param_1583
    .param pmc param_1584
.annotate 'line', 651
    .lex "self", param_1583
    .lex "$/", param_1584
.annotate 'line', 653
    new $P1585, "Undef"
    .lex "$t", $P1585
    find_lex $P1586, "$/"
    unless_null $P1586, vivify_1115
    $P1586 = root_new ['parrot';'ResizablePMCArray']
  vivify_1115:
    set $P1587, $P1586[0]
    unless_null $P1587, vivify_1116
    new $P1587, "Undef"
  vivify_1116:
    store_lex "$t", $P1587
    find_lex $P1588, "$/"
    unless_null $P1588, vivify_1117
    $P1588 = root_new ['parrot';'ResizablePMCArray']
  vivify_1117:
    set $P1589, $P1588[1]
    unless_null $P1589, vivify_1118
    new $P1589, "Undef"
  vivify_1118:
    find_lex $P1590, "$/"
    unless_null $P1590, vivify_1119
    $P1590 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1590
  vivify_1119:
    set $P1590[0], $P1589
    find_lex $P1591, "$t"
    find_lex $P1592, "$/"
    unless_null $P1592, vivify_1120
    $P1592 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1592
  vivify_1120:
    set $P1592[1], $P1591
.annotate 'line', 651
    .return ($P1591)
.end


.namespace ["NQP";"Regex"]
.sub "_block1593"  :subid("376_1297619321.796") :outer("11_1297619321.796")
.annotate 'line', 657
    .const 'Sub' $P1658 = "397_1297619321.796" 
    capture_lex $P1658
    .const 'Sub' $P1651 = "395_1297619321.796" 
    capture_lex $P1651
    .const 'Sub' $P1646 = "393_1297619321.796" 
    capture_lex $P1646
    .const 'Sub' $P1634 = "390_1297619321.796" 
    capture_lex $P1634
    .const 'Sub' $P1624 = "387_1297619321.796" 
    capture_lex $P1624
    .const 'Sub' $P1619 = "385_1297619321.796" 
    capture_lex $P1619
    .const 'Sub' $P1610 = "382_1297619321.796" 
    capture_lex $P1610
    .const 'Sub' $P1605 = "380_1297619321.796" 
    capture_lex $P1605
    .const 'Sub' $P1596 = "377_1297619321.796" 
    capture_lex $P1596
    get_global $P1595, "$?CLASS"
    .const 'Sub' $P1651 = "395_1297619321.796" 
    capture_lex $P1651
    .return ($P1651)
.end


.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1121") :outer("376_1297619321.796")
.annotate 'line', 657
    get_hll_global $P1594, ["NQP";"Regex"], "_block1593" 
    .local pmc block
    set block, $P1594
    .const 'Sub' $P1658 = "397_1297619321.796" 
    capture_lex $P1658
    $P1658()
.end


.namespace ["NQP";"Regex"]
.sub "_block1657"  :anon :subid("397_1297619321.796") :outer("376_1297619321.796")
.annotate 'line', 657
    get_hll_global $P1659, "NQPClassHOW"
    $P1660 = $P1659."new_type"("Regex" :named("name"))
    .local pmc type_obj
    set type_obj, $P1660
    set_hll_global ["NQP"], "Regex", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1661, type_obj
    .const 'Sub' $P1662 = "377_1297619321.796" 
    $P1661."add_method"(type_obj, "metachar:sym<:my>", $P1662)
    get_how $P1663, type_obj
    get_global $P1664, "!PREFIX__metachar:sym<:my>"
    $P1663."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P1664)
    get_how $P1665, type_obj
    .const 'Sub' $P1666 = "380_1297619321.796" 
    $P1665."add_method"(type_obj, "metachar:sym<{ }>", $P1666)
    get_how $P1667, type_obj
    get_global $P1668, "!PREFIX__metachar:sym<{ }>"
    $P1667."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P1668)
    get_how $P1669, type_obj
    .const 'Sub' $P1670 = "382_1297619321.796" 
    $P1669."add_method"(type_obj, "metachar:sym<nqpvar>", $P1670)
    get_how $P1671, type_obj
    get_global $P1672, "!PREFIX__metachar:sym<nqpvar>"
    $P1671."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P1672)
    get_how $P1673, type_obj
    .const 'Sub' $P1674 = "385_1297619321.796" 
    $P1673."add_method"(type_obj, "assertion:sym<{ }>", $P1674)
    get_how $P1675, type_obj
    get_global $P1676, "!PREFIX__assertion:sym<{ }>"
    $P1675."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P1676)
    get_how $P1677, type_obj
    .const 'Sub' $P1678 = "387_1297619321.796" 
    $P1677."add_method"(type_obj, "assertion:sym<?{ }>", $P1678)
    get_how $P1679, type_obj
    get_global $P1680, "!PREFIX__assertion:sym<?{ }>"
    $P1679."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P1680)
    get_how $P1681, type_obj
    .const 'Sub' $P1682 = "390_1297619321.796" 
    $P1681."add_method"(type_obj, "assertion:sym<name>", $P1682)
    get_how $P1683, type_obj
    get_global $P1684, "!PREFIX__assertion:sym<name>"
    $P1683."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P1684)
    get_how $P1685, type_obj
    .const 'Sub' $P1686 = "393_1297619321.796" 
    $P1685."add_method"(type_obj, "assertion:sym<var>", $P1686)
    get_how $P1687, type_obj
    get_global $P1688, "!PREFIX__assertion:sym<var>"
    $P1687."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P1688)
    get_how $P1689, type_obj
    .const 'Sub' $P1690 = "395_1297619321.796" 
    $P1689."add_method"(type_obj, "codeblock", $P1690)
    get_how $P1691, type_obj
    get_global $P1692, "!PREFIX__codeblock"
    $P1691."add_method"(type_obj, "!PREFIX__codeblock", $P1692)
    get_how $P1693, type_obj
    get_hll_global $P1694, ["Regex";"P6Regex"], "Grammar"
    $P1693."add_parent"(type_obj, $P1694)
    get_how $P1695, type_obj
    $P1696 = $P1695."compose"(type_obj)
    .return ($P1696)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("377_1297619321.796") :method :outer("376_1297619321.796")
.annotate 'line', 657
    .const 'Sub' $P1602 = "379_1297619321.796" 
    capture_lex $P1602
    .local string rx1597_tgt
    .local int rx1597_pos
    .local int rx1597_off
    .local int rx1597_eos
    .local int rx1597_rep
    .local pmc rx1597_cur
    .local pmc rx1597_debug
    (rx1597_cur, rx1597_pos, rx1597_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1597_cur
    .local pmc match
    .lex "$/", match
    length rx1597_eos, rx1597_tgt
    gt rx1597_pos, rx1597_eos, rx1597_done
    set rx1597_off, 0
    lt rx1597_pos, 2, rx1597_start
    sub rx1597_off, rx1597_pos, 1
    substr rx1597_tgt, rx1597_tgt, rx1597_off
  rx1597_start:
    eq $I10, 1, rx1597_restart
    if_null rx1597_debug, debug_1122
    rx1597_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1122:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1600_done
    goto rxscan1600_scan
  rxscan1600_loop:
    (rx1597_pos) = rx1597_cur."from"()
    inc rx1597_pos
    rx1597_cur."!cursor_from"(rx1597_pos)
    ge rx1597_pos, rx1597_eos, rxscan1600_done
  rxscan1600_scan:
    set_addr $I10, rxscan1600_loop
    rx1597_cur."!mark_push"(0, rx1597_pos, $I10)
  rxscan1600_done:
.annotate 'line', 659
  # rx literal  ":"
    add $I11, rx1597_pos, 1
    gt $I11, rx1597_eos, rx1597_fail
    sub $I11, rx1597_pos, rx1597_off
    ord $I11, rx1597_tgt, $I11
    ne $I11, 58, rx1597_fail
    add rx1597_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1597_cur."!cursor_pos"(rx1597_pos)
    .const 'Sub' $P1602 = "379_1297619321.796" 
    capture_lex $P1602
    $P10 = rx1597_cur."before"($P1602)
    unless $P10, rx1597_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1597_cur."!cursor_pos"(rx1597_pos)
    $P10 = rx1597_cur."LANG"("MAIN", "statement")
    unless $P10, rx1597_fail
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1597_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1597_cur."!cursor_pos"(rx1597_pos)
    $P10 = rx1597_cur."ws"()
    unless $P10, rx1597_fail
    rx1597_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1597_pos, 1
    gt $I11, rx1597_eos, rx1597_fail
    sub $I11, rx1597_pos, rx1597_off
    ord $I11, rx1597_tgt, $I11
    ne $I11, 59, rx1597_fail
    add rx1597_pos, 1
.annotate 'line', 658
  # rx pass
    rx1597_cur."!cursor_pass"(rx1597_pos, "metachar:sym<:my>")
    if_null rx1597_debug, debug_1127
    rx1597_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1597_pos)
  debug_1127:
    .return (rx1597_cur)
  rx1597_restart:
.annotate 'line', 657
    if_null rx1597_debug, debug_1128
    rx1597_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1128:
  rx1597_fail:
    (rx1597_rep, rx1597_pos, $I10, $P10) = rx1597_cur."!mark_fail"(0)
    lt rx1597_pos, -1, rx1597_done
    eq rx1597_pos, -1, rx1597_fail
    jump $I10
  rx1597_done:
    rx1597_cur."!cursor_fail"()
    if_null rx1597_debug, debug_1129
    rx1597_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1129:
    .return (rx1597_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("378_1297619321.796") :method
.annotate 'line', 657
    new $P1599, "ResizablePMCArray"
    push $P1599, ":"
    .return ($P1599)
.end


.namespace ["NQP";"Regex"]
.sub "_block1601"  :anon :subid("379_1297619321.796") :method :outer("377_1297619321.796")
.annotate 'line', 659
    .local string rx1603_tgt
    .local int rx1603_pos
    .local int rx1603_off
    .local int rx1603_eos
    .local int rx1603_rep
    .local pmc rx1603_cur
    .local pmc rx1603_debug
    (rx1603_cur, rx1603_pos, rx1603_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1603_cur
    .local pmc match
    .lex "$/", match
    length rx1603_eos, rx1603_tgt
    gt rx1603_pos, rx1603_eos, rx1603_done
    set rx1603_off, 0
    lt rx1603_pos, 2, rx1603_start
    sub rx1603_off, rx1603_pos, 1
    substr rx1603_tgt, rx1603_tgt, rx1603_off
  rx1603_start:
    eq $I10, 1, rx1603_restart
    if_null rx1603_debug, debug_1123
    rx1603_cur."!cursor_debug"("START", "")
  debug_1123:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1604_done
    goto rxscan1604_scan
  rxscan1604_loop:
    (rx1603_pos) = rx1603_cur."from"()
    inc rx1603_pos
    rx1603_cur."!cursor_from"(rx1603_pos)
    ge rx1603_pos, rx1603_eos, rxscan1604_done
  rxscan1604_scan:
    set_addr $I10, rxscan1604_loop
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  rxscan1604_done:
  # rx literal  "my"
    add $I11, rx1603_pos, 2
    gt $I11, rx1603_eos, rx1603_fail
    sub $I11, rx1603_pos, rx1603_off
    substr $S10, rx1603_tgt, $I11, 2
    ne $S10, "my", rx1603_fail
    add rx1603_pos, 2
  # rx pass
    rx1603_cur."!cursor_pass"(rx1603_pos, "")
    if_null rx1603_debug, debug_1124
    rx1603_cur."!cursor_debug"("PASS", "", " at pos=", rx1603_pos)
  debug_1124:
    .return (rx1603_cur)
  rx1603_restart:
    if_null rx1603_debug, debug_1125
    rx1603_cur."!cursor_debug"("NEXT", "")
  debug_1125:
  rx1603_fail:
    (rx1603_rep, rx1603_pos, $I10, $P10) = rx1603_cur."!mark_fail"(0)
    lt rx1603_pos, -1, rx1603_done
    eq rx1603_pos, -1, rx1603_fail
    jump $I10
  rx1603_done:
    rx1603_cur."!cursor_fail"()
    if_null rx1603_debug, debug_1126
    rx1603_cur."!cursor_debug"("FAIL", "")
  debug_1126:
    .return (rx1603_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("380_1297619321.796") :method :outer("376_1297619321.796")
.annotate 'line', 657
    .local string rx1606_tgt
    .local int rx1606_pos
    .local int rx1606_off
    .local int rx1606_eos
    .local int rx1606_rep
    .local pmc rx1606_cur
    .local pmc rx1606_debug
    (rx1606_cur, rx1606_pos, rx1606_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1606_cur
    .local pmc match
    .lex "$/", match
    length rx1606_eos, rx1606_tgt
    gt rx1606_pos, rx1606_eos, rx1606_done
    set rx1606_off, 0
    lt rx1606_pos, 2, rx1606_start
    sub rx1606_off, rx1606_pos, 1
    substr rx1606_tgt, rx1606_tgt, rx1606_off
  rx1606_start:
    eq $I10, 1, rx1606_restart
    if_null rx1606_debug, debug_1130
    rx1606_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1609_done
    goto rxscan1609_scan
  rxscan1609_loop:
    (rx1606_pos) = rx1606_cur."from"()
    inc rx1606_pos
    rx1606_cur."!cursor_from"(rx1606_pos)
    ge rx1606_pos, rx1606_eos, rxscan1609_done
  rxscan1609_scan:
    set_addr $I10, rxscan1609_loop
    rx1606_cur."!mark_push"(0, rx1606_pos, $I10)
  rxscan1609_done:
.annotate 'line', 663
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1606_pos, rx1606_off
    substr $S10, rx1606_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1606_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1606_cur."!cursor_pos"(rx1606_pos)
    $P10 = rx1606_cur."codeblock"()
    unless $P10, rx1606_fail
    rx1606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1606_pos = $P10."pos"()
.annotate 'line', 662
  # rx pass
    rx1606_cur."!cursor_pass"(rx1606_pos, "metachar:sym<{ }>")
    if_null rx1606_debug, debug_1131
    rx1606_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1606_pos)
  debug_1131:
    .return (rx1606_cur)
  rx1606_restart:
.annotate 'line', 657
    if_null rx1606_debug, debug_1132
    rx1606_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1132:
  rx1606_fail:
    (rx1606_rep, rx1606_pos, $I10, $P10) = rx1606_cur."!mark_fail"(0)
    lt rx1606_pos, -1, rx1606_done
    eq rx1606_pos, -1, rx1606_fail
    jump $I10
  rx1606_done:
    rx1606_cur."!cursor_fail"()
    if_null rx1606_debug, debug_1133
    rx1606_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1133:
    .return (rx1606_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("381_1297619321.796") :method
.annotate 'line', 657
    new $P1608, "ResizablePMCArray"
    push $P1608, "{"
    .return ($P1608)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("382_1297619321.796") :method :outer("376_1297619321.796")
.annotate 'line', 657
    .const 'Sub' $P1616 = "384_1297619321.796" 
    capture_lex $P1616
    .local string rx1611_tgt
    .local int rx1611_pos
    .local int rx1611_off
    .local int rx1611_eos
    .local int rx1611_rep
    .local pmc rx1611_cur
    .local pmc rx1611_debug
    (rx1611_cur, rx1611_pos, rx1611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1611_cur
    .local pmc match
    .lex "$/", match
    length rx1611_eos, rx1611_tgt
    gt rx1611_pos, rx1611_eos, rx1611_done
    set rx1611_off, 0
    lt rx1611_pos, 2, rx1611_start
    sub rx1611_off, rx1611_pos, 1
    substr rx1611_tgt, rx1611_tgt, rx1611_off
  rx1611_start:
    eq $I10, 1, rx1611_restart
    if_null rx1611_debug, debug_1134
    rx1611_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1134:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1614_done
    goto rxscan1614_scan
  rxscan1614_loop:
    (rx1611_pos) = rx1611_cur."from"()
    inc rx1611_pos
    rx1611_cur."!cursor_from"(rx1611_pos)
    ge rx1611_pos, rx1611_eos, rxscan1614_done
  rxscan1614_scan:
    set_addr $I10, rxscan1614_loop
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  rxscan1614_done:
.annotate 'line', 667
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1611_pos, rx1611_off
    substr $S10, rx1611_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1611_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    .const 'Sub' $P1616 = "384_1297619321.796" 
    capture_lex $P1616
    $P10 = rx1611_cur."before"($P1616)
    unless $P10, rx1611_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."LANG"("MAIN", "variable")
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1611_pos = $P10."pos"()
.annotate 'line', 666
  # rx pass
    rx1611_cur."!cursor_pass"(rx1611_pos, "metachar:sym<nqpvar>")
    if_null rx1611_debug, debug_1139
    rx1611_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1611_pos)
  debug_1139:
    .return (rx1611_cur)
  rx1611_restart:
.annotate 'line', 657
    if_null rx1611_debug, debug_1140
    rx1611_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1140:
  rx1611_fail:
    (rx1611_rep, rx1611_pos, $I10, $P10) = rx1611_cur."!mark_fail"(0)
    lt rx1611_pos, -1, rx1611_done
    eq rx1611_pos, -1, rx1611_fail
    jump $I10
  rx1611_done:
    rx1611_cur."!cursor_fail"()
    if_null rx1611_debug, debug_1141
    rx1611_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1141:
    .return (rx1611_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("383_1297619321.796") :method
.annotate 'line', 657
    new $P1613, "ResizablePMCArray"
    push $P1613, "$"
    push $P1613, "@"
    .return ($P1613)
.end


.namespace ["NQP";"Regex"]
.sub "_block1615"  :anon :subid("384_1297619321.796") :method :outer("382_1297619321.796")
.annotate 'line', 667
    .local string rx1617_tgt
    .local int rx1617_pos
    .local int rx1617_off
    .local int rx1617_eos
    .local int rx1617_rep
    .local pmc rx1617_cur
    .local pmc rx1617_debug
    (rx1617_cur, rx1617_pos, rx1617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1617_cur
    .local pmc match
    .lex "$/", match
    length rx1617_eos, rx1617_tgt
    gt rx1617_pos, rx1617_eos, rx1617_done
    set rx1617_off, 0
    lt rx1617_pos, 2, rx1617_start
    sub rx1617_off, rx1617_pos, 1
    substr rx1617_tgt, rx1617_tgt, rx1617_off
  rx1617_start:
    eq $I10, 1, rx1617_restart
    if_null rx1617_debug, debug_1135
    rx1617_cur."!cursor_debug"("START", "")
  debug_1135:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1618_done
    goto rxscan1618_scan
  rxscan1618_loop:
    (rx1617_pos) = rx1617_cur."from"()
    inc rx1617_pos
    rx1617_cur."!cursor_from"(rx1617_pos)
    ge rx1617_pos, rx1617_eos, rxscan1618_done
  rxscan1618_scan:
    set_addr $I10, rxscan1618_loop
    rx1617_cur."!mark_push"(0, rx1617_pos, $I10)
  rxscan1618_done:
  # rx charclass .
    ge rx1617_pos, rx1617_eos, rx1617_fail
    inc rx1617_pos
  # rx charclass w
    ge rx1617_pos, rx1617_eos, rx1617_fail
    sub $I10, rx1617_pos, rx1617_off
    is_cclass $I11, 8192, rx1617_tgt, $I10
    unless $I11, rx1617_fail
    inc rx1617_pos
  # rx pass
    rx1617_cur."!cursor_pass"(rx1617_pos, "")
    if_null rx1617_debug, debug_1136
    rx1617_cur."!cursor_debug"("PASS", "", " at pos=", rx1617_pos)
  debug_1136:
    .return (rx1617_cur)
  rx1617_restart:
    if_null rx1617_debug, debug_1137
    rx1617_cur."!cursor_debug"("NEXT", "")
  debug_1137:
  rx1617_fail:
    (rx1617_rep, rx1617_pos, $I10, $P10) = rx1617_cur."!mark_fail"(0)
    lt rx1617_pos, -1, rx1617_done
    eq rx1617_pos, -1, rx1617_fail
    jump $I10
  rx1617_done:
    rx1617_cur."!cursor_fail"()
    if_null rx1617_debug, debug_1138
    rx1617_cur."!cursor_debug"("FAIL", "")
  debug_1138:
    .return (rx1617_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("385_1297619321.796") :method :outer("376_1297619321.796")
.annotate 'line', 657
    .local string rx1620_tgt
    .local int rx1620_pos
    .local int rx1620_off
    .local int rx1620_eos
    .local int rx1620_rep
    .local pmc rx1620_cur
    .local pmc rx1620_debug
    (rx1620_cur, rx1620_pos, rx1620_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1620_cur
    .local pmc match
    .lex "$/", match
    length rx1620_eos, rx1620_tgt
    gt rx1620_pos, rx1620_eos, rx1620_done
    set rx1620_off, 0
    lt rx1620_pos, 2, rx1620_start
    sub rx1620_off, rx1620_pos, 1
    substr rx1620_tgt, rx1620_tgt, rx1620_off
  rx1620_start:
    eq $I10, 1, rx1620_restart
    if_null rx1620_debug, debug_1142
    rx1620_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1623_done
    goto rxscan1623_scan
  rxscan1623_loop:
    (rx1620_pos) = rx1620_cur."from"()
    inc rx1620_pos
    rx1620_cur."!cursor_from"(rx1620_pos)
    ge rx1620_pos, rx1620_eos, rxscan1623_done
  rxscan1623_scan:
    set_addr $I10, rxscan1623_loop
    rx1620_cur."!mark_push"(0, rx1620_pos, $I10)
  rxscan1623_done:
.annotate 'line', 671
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1620_pos, rx1620_off
    substr $S10, rx1620_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1620_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1620_cur."!cursor_pos"(rx1620_pos)
    $P10 = rx1620_cur."codeblock"()
    unless $P10, rx1620_fail
    rx1620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1620_pos = $P10."pos"()
.annotate 'line', 670
  # rx pass
    rx1620_cur."!cursor_pass"(rx1620_pos, "assertion:sym<{ }>")
    if_null rx1620_debug, debug_1143
    rx1620_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1620_pos)
  debug_1143:
    .return (rx1620_cur)
  rx1620_restart:
.annotate 'line', 657
    if_null rx1620_debug, debug_1144
    rx1620_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1144:
  rx1620_fail:
    (rx1620_rep, rx1620_pos, $I10, $P10) = rx1620_cur."!mark_fail"(0)
    lt rx1620_pos, -1, rx1620_done
    eq rx1620_pos, -1, rx1620_fail
    jump $I10
  rx1620_done:
    rx1620_cur."!cursor_fail"()
    if_null rx1620_debug, debug_1145
    rx1620_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1145:
    .return (rx1620_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("386_1297619321.796") :method
.annotate 'line', 657
    new $P1622, "ResizablePMCArray"
    push $P1622, "{"
    .return ($P1622)
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("387_1297619321.796") :method :outer("376_1297619321.796")
.annotate 'line', 657
    .const 'Sub' $P1630 = "389_1297619321.796" 
    capture_lex $P1630
    .local string rx1625_tgt
    .local int rx1625_pos
    .local int rx1625_off
    .local int rx1625_eos
    .local int rx1625_rep
    .local pmc rx1625_cur
    .local pmc rx1625_debug
    (rx1625_cur, rx1625_pos, rx1625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1625_cur
    .local pmc match
    .lex "$/", match
    length rx1625_eos, rx1625_tgt
    gt rx1625_pos, rx1625_eos, rx1625_done
    set rx1625_off, 0
    lt rx1625_pos, 2, rx1625_start
    sub rx1625_off, rx1625_pos, 1
    substr rx1625_tgt, rx1625_tgt, rx1625_off
  rx1625_start:
    eq $I10, 1, rx1625_restart
    if_null rx1625_debug, debug_1146
    rx1625_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1146:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1628_done
    goto rxscan1628_scan
  rxscan1628_loop:
    (rx1625_pos) = rx1625_cur."from"()
    inc rx1625_pos
    rx1625_cur."!cursor_from"(rx1625_pos)
    ge rx1625_pos, rx1625_eos, rxscan1628_done
  rxscan1628_scan:
    set_addr $I10, rxscan1628_loop
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  rxscan1628_done:
.annotate 'line', 675
  # rx subcapture "zw"
    set_addr $I10, rxcap_1633_fail
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1625_pos, rx1625_eos, rx1625_fail
    sub $I10, rx1625_pos, rx1625_off
    substr $S10, rx1625_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1625_fail
    inc rx1625_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1625_cur."!cursor_pos"(rx1625_pos)
    .const 'Sub' $P1630 = "389_1297619321.796" 
    capture_lex $P1630
    $P10 = rx1625_cur."before"($P1630)
    unless $P10, rx1625_fail
    set_addr $I10, rxcap_1633_fail
    ($I12, $I11) = rx1625_cur."!mark_peek"($I10)
    rx1625_cur."!cursor_pos"($I11)
    ($P10) = rx1625_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1625_pos, "")
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1633_done
  rxcap_1633_fail:
    goto rx1625_fail
  rxcap_1633_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1625_cur."!cursor_pos"(rx1625_pos)
    $P10 = rx1625_cur."codeblock"()
    unless $P10, rx1625_fail
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1625_pos = $P10."pos"()
.annotate 'line', 674
  # rx pass
    rx1625_cur."!cursor_pass"(rx1625_pos, "assertion:sym<?{ }>")
    if_null rx1625_debug, debug_1151
    rx1625_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1625_pos)
  debug_1151:
    .return (rx1625_cur)
  rx1625_restart:
.annotate 'line', 657
    if_null rx1625_debug, debug_1152
    rx1625_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1152:
  rx1625_fail:
    (rx1625_rep, rx1625_pos, $I10, $P10) = rx1625_cur."!mark_fail"(0)
    lt rx1625_pos, -1, rx1625_done
    eq rx1625_pos, -1, rx1625_fail
    jump $I10
  rx1625_done:
    rx1625_cur."!cursor_fail"()
    if_null rx1625_debug, debug_1153
    rx1625_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1153:
    .return (rx1625_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("388_1297619321.796") :method
.annotate 'line', 657
    new $P1627, "ResizablePMCArray"
    push $P1627, "!"
    push $P1627, "?"
    .return ($P1627)
.end


.namespace ["NQP";"Regex"]
.sub "_block1629"  :anon :subid("389_1297619321.796") :method :outer("387_1297619321.796")
.annotate 'line', 675
    .local string rx1631_tgt
    .local int rx1631_pos
    .local int rx1631_off
    .local int rx1631_eos
    .local int rx1631_rep
    .local pmc rx1631_cur
    .local pmc rx1631_debug
    (rx1631_cur, rx1631_pos, rx1631_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1631_cur
    .local pmc match
    .lex "$/", match
    length rx1631_eos, rx1631_tgt
    gt rx1631_pos, rx1631_eos, rx1631_done
    set rx1631_off, 0
    lt rx1631_pos, 2, rx1631_start
    sub rx1631_off, rx1631_pos, 1
    substr rx1631_tgt, rx1631_tgt, rx1631_off
  rx1631_start:
    eq $I10, 1, rx1631_restart
    if_null rx1631_debug, debug_1147
    rx1631_cur."!cursor_debug"("START", "")
  debug_1147:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1632_done
    goto rxscan1632_scan
  rxscan1632_loop:
    (rx1631_pos) = rx1631_cur."from"()
    inc rx1631_pos
    rx1631_cur."!cursor_from"(rx1631_pos)
    ge rx1631_pos, rx1631_eos, rxscan1632_done
  rxscan1632_scan:
    set_addr $I10, rxscan1632_loop
    rx1631_cur."!mark_push"(0, rx1631_pos, $I10)
  rxscan1632_done:
  # rx literal  "{"
    add $I11, rx1631_pos, 1
    gt $I11, rx1631_eos, rx1631_fail
    sub $I11, rx1631_pos, rx1631_off
    ord $I11, rx1631_tgt, $I11
    ne $I11, 123, rx1631_fail
    add rx1631_pos, 1
  # rx pass
    rx1631_cur."!cursor_pass"(rx1631_pos, "")
    if_null rx1631_debug, debug_1148
    rx1631_cur."!cursor_debug"("PASS", "", " at pos=", rx1631_pos)
  debug_1148:
    .return (rx1631_cur)
  rx1631_restart:
    if_null rx1631_debug, debug_1149
    rx1631_cur."!cursor_debug"("NEXT", "")
  debug_1149:
  rx1631_fail:
    (rx1631_rep, rx1631_pos, $I10, $P10) = rx1631_cur."!mark_fail"(0)
    lt rx1631_pos, -1, rx1631_done
    eq rx1631_pos, -1, rx1631_fail
    jump $I10
  rx1631_done:
    rx1631_cur."!cursor_fail"()
    if_null rx1631_debug, debug_1150
    rx1631_cur."!cursor_debug"("FAIL", "")
  debug_1150:
    .return (rx1631_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("390_1297619321.796") :method :outer("376_1297619321.796")
.annotate 'line', 657
    .const 'Sub' $P1643 = "392_1297619321.796" 
    capture_lex $P1643
    .local string rx1635_tgt
    .local int rx1635_pos
    .local int rx1635_off
    .local int rx1635_eos
    .local int rx1635_rep
    .local pmc rx1635_cur
    .local pmc rx1635_debug
    (rx1635_cur, rx1635_pos, rx1635_tgt, $I10) = self."!cursor_start"()
    rx1635_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1635_cur
    .local pmc match
    .lex "$/", match
    length rx1635_eos, rx1635_tgt
    gt rx1635_pos, rx1635_eos, rx1635_done
    set rx1635_off, 0
    lt rx1635_pos, 2, rx1635_start
    sub rx1635_off, rx1635_pos, 1
    substr rx1635_tgt, rx1635_tgt, rx1635_off
  rx1635_start:
    eq $I10, 1, rx1635_restart
    if_null rx1635_debug, debug_1154
    rx1635_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1154:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1639_done
    goto rxscan1639_scan
  rxscan1639_loop:
    (rx1635_pos) = rx1635_cur."from"()
    inc rx1635_pos
    rx1635_cur."!cursor_from"(rx1635_pos)
    ge rx1635_pos, rx1635_eos, rxscan1639_done
  rxscan1639_scan:
    set_addr $I10, rxscan1639_loop
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  rxscan1639_done:
.annotate 'line', 679
  # rx subrule "identifier" subtype=capture negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    $P10 = rx1635_cur."identifier"()
    unless $P10, rx1635_fail
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1635_pos = $P10."pos"()
.annotate 'line', 686
  # rx rxquantr1640 ** 0..1
    set_addr $I10, rxquantr1640_done
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  rxquantr1640_loop:
  alt1641_0:
.annotate 'line', 680
    set_addr $I10, alt1641_1
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
.annotate 'line', 681
  # rx subrule "before" subtype=zerowidth negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    .const 'Sub' $P1643 = "392_1297619321.796" 
    capture_lex $P1643
    $P10 = rx1635_cur."before"($P1643)
    unless $P10, rx1635_fail
    goto alt1641_end
  alt1641_1:
    set_addr $I10, alt1641_2
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
.annotate 'line', 682
  # rx literal  "="
    add $I11, rx1635_pos, 1
    gt $I11, rx1635_eos, rx1635_fail
    sub $I11, rx1635_pos, rx1635_off
    ord $I11, rx1635_tgt, $I11
    ne $I11, 61, rx1635_fail
    add rx1635_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    $P10 = rx1635_cur."assertion"()
    unless $P10, rx1635_fail
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1635_pos = $P10."pos"()
    goto alt1641_end
  alt1641_2:
    set_addr $I10, alt1641_3
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
.annotate 'line', 683
  # rx literal  ":"
    add $I11, rx1635_pos, 1
    gt $I11, rx1635_eos, rx1635_fail
    sub $I11, rx1635_pos, rx1635_off
    ord $I11, rx1635_tgt, $I11
    ne $I11, 58, rx1635_fail
    add rx1635_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    $P10 = rx1635_cur."arglist"()
    unless $P10, rx1635_fail
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1635_pos = $P10."pos"()
    goto alt1641_end
  alt1641_3:
    set_addr $I10, alt1641_4
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
.annotate 'line', 684
  # rx literal  "("
    add $I11, rx1635_pos, 1
    gt $I11, rx1635_eos, rx1635_fail
    sub $I11, rx1635_pos, rx1635_off
    ord $I11, rx1635_tgt, $I11
    ne $I11, 40, rx1635_fail
    add rx1635_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    $P10 = rx1635_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1635_fail
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1635_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1635_pos, 1
    gt $I11, rx1635_eos, rx1635_fail
    sub $I11, rx1635_pos, rx1635_off
    ord $I11, rx1635_tgt, $I11
    ne $I11, 41, rx1635_fail
    add rx1635_pos, 1
    goto alt1641_end
  alt1641_4:
.annotate 'line', 685
  # rx subrule "normspace" subtype=method negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    $P10 = rx1635_cur."normspace"()
    unless $P10, rx1635_fail
    rx1635_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    $P10 = rx1635_cur."nibbler"()
    unless $P10, rx1635_fail
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1635_pos = $P10."pos"()
  alt1641_end:
.annotate 'line', 686
    set_addr $I10, rxquantr1640_done
    (rx1635_rep) = rx1635_cur."!mark_commit"($I10)
  rxquantr1640_done:
.annotate 'line', 678
  # rx pass
    rx1635_cur."!cursor_pass"(rx1635_pos, "assertion:sym<name>")
    if_null rx1635_debug, debug_1159
    rx1635_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1635_pos)
  debug_1159:
    .return (rx1635_cur)
  rx1635_restart:
.annotate 'line', 657
    if_null rx1635_debug, debug_1160
    rx1635_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1160:
  rx1635_fail:
    (rx1635_rep, rx1635_pos, $I10, $P10) = rx1635_cur."!mark_fail"(0)
    lt rx1635_pos, -1, rx1635_done
    eq rx1635_pos, -1, rx1635_fail
    jump $I10
  rx1635_done:
    rx1635_cur."!cursor_fail"()
    if_null rx1635_debug, debug_1161
    rx1635_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1161:
    .return (rx1635_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("391_1297619321.796") :method
.annotate 'line', 657
    $P1637 = self."!PREFIX__!subrule"("identifier", "")
    new $P1638, "ResizablePMCArray"
    push $P1638, $P1637
    .return ($P1638)
.end


.namespace ["NQP";"Regex"]
.sub "_block1642"  :anon :subid("392_1297619321.796") :method :outer("390_1297619321.796")
.annotate 'line', 681
    .local string rx1644_tgt
    .local int rx1644_pos
    .local int rx1644_off
    .local int rx1644_eos
    .local int rx1644_rep
    .local pmc rx1644_cur
    .local pmc rx1644_debug
    (rx1644_cur, rx1644_pos, rx1644_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1644_cur
    .local pmc match
    .lex "$/", match
    length rx1644_eos, rx1644_tgt
    gt rx1644_pos, rx1644_eos, rx1644_done
    set rx1644_off, 0
    lt rx1644_pos, 2, rx1644_start
    sub rx1644_off, rx1644_pos, 1
    substr rx1644_tgt, rx1644_tgt, rx1644_off
  rx1644_start:
    eq $I10, 1, rx1644_restart
    if_null rx1644_debug, debug_1155
    rx1644_cur."!cursor_debug"("START", "")
  debug_1155:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1645_done
    goto rxscan1645_scan
  rxscan1645_loop:
    (rx1644_pos) = rx1644_cur."from"()
    inc rx1644_pos
    rx1644_cur."!cursor_from"(rx1644_pos)
    ge rx1644_pos, rx1644_eos, rxscan1645_done
  rxscan1645_scan:
    set_addr $I10, rxscan1645_loop
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  rxscan1645_done:
  # rx literal  ">"
    add $I11, rx1644_pos, 1
    gt $I11, rx1644_eos, rx1644_fail
    sub $I11, rx1644_pos, rx1644_off
    ord $I11, rx1644_tgt, $I11
    ne $I11, 62, rx1644_fail
    add rx1644_pos, 1
  # rx pass
    rx1644_cur."!cursor_pass"(rx1644_pos, "")
    if_null rx1644_debug, debug_1156
    rx1644_cur."!cursor_debug"("PASS", "", " at pos=", rx1644_pos)
  debug_1156:
    .return (rx1644_cur)
  rx1644_restart:
    if_null rx1644_debug, debug_1157
    rx1644_cur."!cursor_debug"("NEXT", "")
  debug_1157:
  rx1644_fail:
    (rx1644_rep, rx1644_pos, $I10, $P10) = rx1644_cur."!mark_fail"(0)
    lt rx1644_pos, -1, rx1644_done
    eq rx1644_pos, -1, rx1644_fail
    jump $I10
  rx1644_done:
    rx1644_cur."!cursor_fail"()
    if_null rx1644_debug, debug_1158
    rx1644_cur."!cursor_debug"("FAIL", "")
  debug_1158:
    .return (rx1644_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("393_1297619321.796") :method :outer("376_1297619321.796")
.annotate 'line', 657
    .local string rx1647_tgt
    .local int rx1647_pos
    .local int rx1647_off
    .local int rx1647_eos
    .local int rx1647_rep
    .local pmc rx1647_cur
    .local pmc rx1647_debug
    (rx1647_cur, rx1647_pos, rx1647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1647_cur
    .local pmc match
    .lex "$/", match
    length rx1647_eos, rx1647_tgt
    gt rx1647_pos, rx1647_eos, rx1647_done
    set rx1647_off, 0
    lt rx1647_pos, 2, rx1647_start
    sub rx1647_off, rx1647_pos, 1
    substr rx1647_tgt, rx1647_tgt, rx1647_off
  rx1647_start:
    eq $I10, 1, rx1647_restart
    if_null rx1647_debug, debug_1162
    rx1647_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1162:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1650_done
    goto rxscan1650_scan
  rxscan1650_loop:
    (rx1647_pos) = rx1647_cur."from"()
    inc rx1647_pos
    rx1647_cur."!cursor_from"(rx1647_pos)
    ge rx1647_pos, rx1647_eos, rxscan1650_done
  rxscan1650_scan:
    set_addr $I10, rxscan1650_loop
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  rxscan1650_done:
.annotate 'line', 690
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1647_pos, rx1647_off
    substr $S10, rx1647_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1647_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."LANG"("MAIN", "variable")
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1647_pos = $P10."pos"()
.annotate 'line', 689
  # rx pass
    rx1647_cur."!cursor_pass"(rx1647_pos, "assertion:sym<var>")
    if_null rx1647_debug, debug_1163
    rx1647_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1647_pos)
  debug_1163:
    .return (rx1647_cur)
  rx1647_restart:
.annotate 'line', 657
    if_null rx1647_debug, debug_1164
    rx1647_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1164:
  rx1647_fail:
    (rx1647_rep, rx1647_pos, $I10, $P10) = rx1647_cur."!mark_fail"(0)
    lt rx1647_pos, -1, rx1647_done
    eq rx1647_pos, -1, rx1647_fail
    jump $I10
  rx1647_done:
    rx1647_cur."!cursor_fail"()
    if_null rx1647_debug, debug_1165
    rx1647_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1165:
    .return (rx1647_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("394_1297619321.796") :method
.annotate 'line', 657
    new $P1649, "ResizablePMCArray"
    push $P1649, "$"
    push $P1649, "@"
    .return ($P1649)
.end


.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("395_1297619321.796") :method :outer("376_1297619321.796")
.annotate 'line', 657
    .local string rx1652_tgt
    .local int rx1652_pos
    .local int rx1652_off
    .local int rx1652_eos
    .local int rx1652_rep
    .local pmc rx1652_cur
    .local pmc rx1652_debug
    (rx1652_cur, rx1652_pos, rx1652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1652_cur
    .local pmc match
    .lex "$/", match
    length rx1652_eos, rx1652_tgt
    gt rx1652_pos, rx1652_eos, rx1652_done
    set rx1652_off, 0
    lt rx1652_pos, 2, rx1652_start
    sub rx1652_off, rx1652_pos, 1
    substr rx1652_tgt, rx1652_tgt, rx1652_off
  rx1652_start:
    eq $I10, 1, rx1652_restart
    if_null rx1652_debug, debug_1166
    rx1652_cur."!cursor_debug"("START", "codeblock")
  debug_1166:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1656_done
    goto rxscan1656_scan
  rxscan1656_loop:
    (rx1652_pos) = rx1652_cur."from"()
    inc rx1652_pos
    rx1652_cur."!cursor_from"(rx1652_pos)
    ge rx1652_pos, rx1652_eos, rxscan1656_done
  rxscan1656_scan:
    set_addr $I10, rxscan1656_loop
    rx1652_cur."!mark_push"(0, rx1652_pos, $I10)
  rxscan1656_done:
.annotate 'line', 694
  # rx subrule "LANG" subtype=capture negate=
    rx1652_cur."!cursor_pos"(rx1652_pos)
    $P10 = rx1652_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1652_fail
    rx1652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1652_pos = $P10."pos"()
.annotate 'line', 693
  # rx pass
    rx1652_cur."!cursor_pass"(rx1652_pos, "codeblock")
    if_null rx1652_debug, debug_1167
    rx1652_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1652_pos)
  debug_1167:
    .return (rx1652_cur)
  rx1652_restart:
.annotate 'line', 657
    if_null rx1652_debug, debug_1168
    rx1652_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1168:
  rx1652_fail:
    (rx1652_rep, rx1652_pos, $I10, $P10) = rx1652_cur."!mark_fail"(0)
    lt rx1652_pos, -1, rx1652_done
    eq rx1652_pos, -1, rx1652_fail
    jump $I10
  rx1652_done:
    rx1652_cur."!cursor_fail"()
    if_null rx1652_debug, debug_1169
    rx1652_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1169:
    .return (rx1652_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("396_1297619321.796") :method
.annotate 'line', 657
    $P1654 = self."!PREFIX__!subrule"("LANG", "")
    new $P1655, "ResizablePMCArray"
    push $P1655, $P1654
    .return ($P1655)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1698" :load :anon :subid("398_1297619321.796")
.annotate 'line', 4
    .const 'Sub' $P1700 = "11_1297619321.796" 
    $P1701 = $P1700()
    .return ($P1701)
.end


.namespace []
.sub "_block2415" :load :anon :subid("400_1297619321.796")
.annotate 'line', 1
    .const 'Sub' $P2417 = "10_1297619321.796" 
    $P2418 = $P2417()
    .return ($P2418)
.end

### .include 'gen/nqp-actions.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1297619360.562")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Actions"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
    $P3212 = $P15()
.annotate 'line', 1
    .return ($P3212)
    .const 'Sub' $P3214 = "168_1297619360.562" 
    .return ($P3214)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block14"  :subid("11_1297619360.562") :outer("10_1297619360.562")
.annotate 'line', 3
    .const 'Sub' $P2993 = "167_1297619360.562" 
    capture_lex $P2993
    get_hll_global $P2867, ["NQP";"RegexActions"], "_block2866" 
    capture_lex $P2867
    .const 'Sub' $P2858 = "156_1297619360.562" 
    capture_lex $P2858
    .const 'Sub' $P2853 = "155_1297619360.562" 
    capture_lex $P2853
    .const 'Sub' $P2848 = "154_1297619360.562" 
    capture_lex $P2848
    .const 'Sub' $P2843 = "153_1297619360.562" 
    capture_lex $P2843
    .const 'Sub' $P2832 = "152_1297619360.562" 
    capture_lex $P2832
    .const 'Sub' $P2824 = "151_1297619360.562" 
    capture_lex $P2824
    .const 'Sub' $P2816 = "150_1297619360.562" 
    capture_lex $P2816
    .const 'Sub' $P2808 = "149_1297619360.562" 
    capture_lex $P2808
    .const 'Sub' $P2803 = "148_1297619360.562" 
    capture_lex $P2803
    .const 'Sub' $P2791 = "147_1297619360.562" 
    capture_lex $P2791
    .const 'Sub' $P2783 = "146_1297619360.562" 
    capture_lex $P2783
    .const 'Sub' $P2745 = "145_1297619360.562" 
    capture_lex $P2745
    .const 'Sub' $P2733 = "144_1297619360.562" 
    capture_lex $P2733
    .const 'Sub' $P2725 = "143_1297619360.562" 
    capture_lex $P2725
    .const 'Sub' $P2717 = "142_1297619360.562" 
    capture_lex $P2717
    .const 'Sub' $P2709 = "141_1297619360.562" 
    capture_lex $P2709
    .const 'Sub' $P2701 = "140_1297619360.562" 
    capture_lex $P2701
    .const 'Sub' $P2693 = "139_1297619360.562" 
    capture_lex $P2693
    .const 'Sub' $P2667 = "138_1297619360.562" 
    capture_lex $P2667
    .const 'Sub' $P2652 = "137_1297619360.562" 
    capture_lex $P2652
    .const 'Sub' $P2644 = "136_1297619360.562" 
    capture_lex $P2644
    .const 'Sub' $P2633 = "135_1297619360.562" 
    capture_lex $P2633
    .const 'Sub' $P2622 = "134_1297619360.562" 
    capture_lex $P2622
    .const 'Sub' $P2611 = "133_1297619360.562" 
    capture_lex $P2611
    .const 'Sub' $P2603 = "132_1297619360.562" 
    capture_lex $P2603
    .const 'Sub' $P2576 = "131_1297619360.562" 
    capture_lex $P2576
    .const 'Sub' $P2554 = "130_1297619360.562" 
    capture_lex $P2554
    .const 'Sub' $P2546 = "129_1297619360.562" 
    capture_lex $P2546
    .const 'Sub' $P2538 = "128_1297619360.562" 
    capture_lex $P2538
    .const 'Sub' $P2513 = "127_1297619360.562" 
    capture_lex $P2513
    .const 'Sub' $P2497 = "126_1297619360.562" 
    capture_lex $P2497
    .const 'Sub' $P2489 = "125_1297619360.562" 
    capture_lex $P2489
    .const 'Sub' $P2481 = "124_1297619360.562" 
    capture_lex $P2481
    .const 'Sub' $P2379 = "121_1297619360.562" 
    capture_lex $P2379
    .const 'Sub' $P2371 = "120_1297619360.562" 
    capture_lex $P2371
    .const 'Sub' $P2364 = "119_1297619360.562" 
    capture_lex $P2364
    .const 'Sub' $P2337 = "118_1297619360.562" 
    capture_lex $P2337
    .const 'Sub' $P2297 = "117_1297619360.562" 
    capture_lex $P2297
    .const 'Sub' $P2283 = "116_1297619360.562" 
    capture_lex $P2283
    .const 'Sub' $P2276 = "115_1297619360.562" 
    capture_lex $P2276
    .const 'Sub' $P2232 = "114_1297619360.562" 
    capture_lex $P2232
    .const 'Sub' $P2067 = "110_1297619360.562" 
    capture_lex $P2067
    .const 'Sub' $P2004 = "108_1297619360.562" 
    capture_lex $P2004
    .const 'Sub' $P1996 = "107_1297619360.562" 
    capture_lex $P1996
    .const 'Sub' $P1981 = "106_1297619360.562" 
    capture_lex $P1981
    .const 'Sub' $P1966 = "105_1297619360.562" 
    capture_lex $P1966
    .const 'Sub' $P1948 = "104_1297619360.562" 
    capture_lex $P1948
    .const 'Sub' $P1849 = "103_1297619360.562" 
    capture_lex $P1849
    .const 'Sub' $P1805 = "100_1297619360.562" 
    capture_lex $P1805
    .const 'Sub' $P1680 = "97_1297619360.562" 
    capture_lex $P1680
    .const 'Sub' $P1438 = "90_1297619360.562" 
    capture_lex $P1438
    .const 'Sub' $P1430 = "89_1297619360.562" 
    capture_lex $P1430
    .const 'Sub' $P1422 = "88_1297619360.562" 
    capture_lex $P1422
    .const 'Sub' $P1321 = "84_1297619360.562" 
    capture_lex $P1321
    .const 'Sub' $P1313 = "83_1297619360.562" 
    capture_lex $P1313
    .const 'Sub' $P1298 = "82_1297619360.562" 
    capture_lex $P1298
    .const 'Sub' $P1283 = "81_1297619360.562" 
    capture_lex $P1283
    .const 'Sub' $P1268 = "80_1297619360.562" 
    capture_lex $P1268
    .const 'Sub' $P1253 = "79_1297619360.562" 
    capture_lex $P1253
    .const 'Sub' $P1245 = "78_1297619360.562" 
    capture_lex $P1245
    .const 'Sub' $P1237 = "77_1297619360.562" 
    capture_lex $P1237
    .const 'Sub' $P1229 = "76_1297619360.562" 
    capture_lex $P1229
    .const 'Sub' $P1015 = "72_1297619360.562" 
    capture_lex $P1015
    .const 'Sub' $P1007 = "71_1297619360.562" 
    capture_lex $P1007
    .const 'Sub' $P999 = "70_1297619360.562" 
    capture_lex $P999
    .const 'Sub' $P991 = "69_1297619360.562" 
    capture_lex $P991
    .const 'Sub' $P983 = "68_1297619360.562" 
    capture_lex $P983
    .const 'Sub' $P975 = "67_1297619360.562" 
    capture_lex $P975
    .const 'Sub' $P967 = "66_1297619360.562" 
    capture_lex $P967
    .const 'Sub' $P877 = "64_1297619360.562" 
    capture_lex $P877
    .const 'Sub' $P853 = "63_1297619360.562" 
    capture_lex $P853
    .const 'Sub' $P839 = "62_1297619360.562" 
    capture_lex $P839
    .const 'Sub' $P831 = "61_1297619360.562" 
    capture_lex $P831
    .const 'Sub' $P823 = "60_1297619360.562" 
    capture_lex $P823
    .const 'Sub' $P815 = "59_1297619360.562" 
    capture_lex $P815
    .const 'Sub' $P807 = "58_1297619360.562" 
    capture_lex $P807
    .const 'Sub' $P799 = "57_1297619360.562" 
    capture_lex $P799
    .const 'Sub' $P791 = "56_1297619360.562" 
    capture_lex $P791
    .const 'Sub' $P783 = "55_1297619360.562" 
    capture_lex $P783
    .const 'Sub' $P775 = "54_1297619360.562" 
    capture_lex $P775
    .const 'Sub' $P767 = "53_1297619360.562" 
    capture_lex $P767
    .const 'Sub' $P759 = "52_1297619360.562" 
    capture_lex $P759
    .const 'Sub' $P751 = "51_1297619360.562" 
    capture_lex $P751
    .const 'Sub' $P743 = "50_1297619360.562" 
    capture_lex $P743
    .const 'Sub' $P735 = "49_1297619360.562" 
    capture_lex $P735
    .const 'Sub' $P719 = "48_1297619360.562" 
    capture_lex $P719
    .const 'Sub' $P686 = "47_1297619360.562" 
    capture_lex $P686
    .const 'Sub' $P672 = "46_1297619360.562" 
    capture_lex $P672
    .const 'Sub' $P653 = "45_1297619360.562" 
    capture_lex $P653
    .const 'Sub' $P635 = "44_1297619360.562" 
    capture_lex $P635
    .const 'Sub' $P611 = "43_1297619360.562" 
    capture_lex $P611
    .const 'Sub' $P577 = "42_1297619360.562" 
    capture_lex $P577
    .const 'Sub' $P562 = "41_1297619360.562" 
    capture_lex $P562
    .const 'Sub' $P550 = "40_1297619360.562" 
    capture_lex $P550
    .const 'Sub' $P499 = "38_1297619360.562" 
    capture_lex $P499
    .const 'Sub' $P490 = "37_1297619360.562" 
    capture_lex $P490
    .const 'Sub' $P479 = "36_1297619360.562" 
    capture_lex $P479
    .const 'Sub' $P461 = "35_1297619360.562" 
    capture_lex $P461
    .const 'Sub' $P453 = "34_1297619360.562" 
    capture_lex $P453
    .const 'Sub' $P445 = "33_1297619360.562" 
    capture_lex $P445
    .const 'Sub' $P431 = "32_1297619360.562" 
    capture_lex $P431
    .const 'Sub' $P350 = "30_1297619360.562" 
    capture_lex $P350
    .const 'Sub' $P309 = "28_1297619360.562" 
    capture_lex $P309
    .const 'Sub' $P275 = "27_1297619360.562" 
    capture_lex $P275
    .const 'Sub' $P244 = "26_1297619360.562" 
    capture_lex $P244
    .const 'Sub' $P236 = "25_1297619360.562" 
    capture_lex $P236
    .const 'Sub' $P228 = "23_1297619360.562" 
    capture_lex $P228
    .const 'Sub' $P214 = "22_1297619360.562" 
    capture_lex $P214
    .const 'Sub' $P149 = "20_1297619360.562" 
    capture_lex $P149
    .const 'Sub' $P139 = "19_1297619360.562" 
    capture_lex $P139
    .const 'Sub' $P91 = "18_1297619360.562" 
    capture_lex $P91
    .const 'Sub' $P78 = "17_1297619360.562" 
    capture_lex $P78
    .const 'Sub' $P60 = "16_1297619360.562" 
    capture_lex $P60
    .const 'Sub' $P27 = "13_1297619360.562" 
    capture_lex $P27
    .const 'Sub' $P19 = "12_1297619360.562" 
    capture_lex $P19
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "RegexActions"
    get_global $P18, "@BLOCK"
    unless_null $P18, vivify_170
    $P18 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P18
  vivify_170:
.annotate 'line', 9
    .const 'Sub' $P19 = "12_1297619360.562" 
    newclosure $P26, $P19
    .lex "xblock_immediate", $P26
.annotate 'line', 14
    .const 'Sub' $P27 = "13_1297619360.562" 
    newclosure $P59, $P27
    .lex "block_immediate", $P59
.annotate 'line', 24
    .const 'Sub' $P60 = "16_1297619360.562" 
    newclosure $P77, $P60
    .lex "vivitype", $P77
.annotate 'line', 43
    .const 'Sub' $P78 = "17_1297619360.562" 
    newclosure $P90, $P78
    .lex "colonpair_str", $P90
.annotate 'line', 223
    .const 'Sub' $P91 = "18_1297619360.562" 
    newclosure $P138, $P91
    .lex "push_block_handler", $P138
.annotate 'line', 762
    .const 'Sub' $P139 = "19_1297619360.562" 
    newclosure $P148, $P139
    .lex "only_star_block", $P148
.annotate 'line', 771
    .const 'Sub' $P149 = "20_1297619360.562" 
    newclosure $P213, $P149
    .lex "attach_multi_signature", $P213
.annotate 'line', 1241
    .const 'Sub' $P214 = "22_1297619360.562" 
    newclosure $P225, $P214
    .lex "control", $P225
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P226, "@BLOCK"
    .const 'Sub' $P228 = "23_1297619360.562" 
    capture_lex $P228
    $P228()
    find_lex $P233, "xblock_immediate"
    find_lex $P234, "block_immediate"
    find_lex $P235, "vivitype"
.annotate 'line', 35
    find_lex $P274, "colonpair_str"
.annotate 'line', 216
    find_lex $P671, "push_block_handler"
.annotate 'line', 690
    find_lex $P1803, "only_star_block"
    find_lex $P1804, "attach_multi_signature"
.annotate 'line', 1232
    find_lex $P2842, "control"
.annotate 'line', 1259
    get_hll_global $P2867, ["NQP";"RegexActions"], "_block2866" 
    capture_lex $P2867
    $P2987 = $P2867()
.annotate 'line', 3
    .return ($P2987)
    .const 'Sub' $P2989 = "166_1297619360.562" 
    .return ($P2989)
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post169") :outer("11_1297619360.562")
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P2993 = "167_1297619360.562" 
    capture_lex $P2993
    $P2993()
.end


.namespace ["NQP";"Actions"]
.sub "_block2992"  :anon :subid("167_1297619360.562") :outer("11_1297619360.562")
.annotate 'line', 3
    get_hll_global $P2994, "NQPClassHOW"
    $P2995 = $P2994."new_type"("Actions" :named("name"))
    .local pmc type_obj
    set type_obj, $P2995
    set_hll_global ["NQP"], "Actions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2996, type_obj
    .const 'Sub' $P2997 = "25_1297619360.562" 
    $P2996."add_method"(type_obj, "TOP", $P2997)
    get_how $P2998, type_obj
    .const 'Sub' $P2999 = "26_1297619360.562" 
    $P2998."add_method"(type_obj, "deflongname", $P2999)
    get_how $P3000, type_obj
    .const 'Sub' $P3001 = "27_1297619360.562" 
    $P3000."add_method"(type_obj, "comp_unit", $P3001)
    get_how $P3002, type_obj
    .const 'Sub' $P3003 = "28_1297619360.562" 
    $P3002."add_method"(type_obj, "statementlist", $P3003)
    get_how $P3004, type_obj
    .const 'Sub' $P3005 = "30_1297619360.562" 
    $P3004."add_method"(type_obj, "statement", $P3005)
    get_how $P3006, type_obj
    .const 'Sub' $P3007 = "32_1297619360.562" 
    $P3006."add_method"(type_obj, "xblock", $P3007)
    get_how $P3008, type_obj
    .const 'Sub' $P3009 = "33_1297619360.562" 
    $P3008."add_method"(type_obj, "pblock", $P3009)
    get_how $P3010, type_obj
    .const 'Sub' $P3011 = "34_1297619360.562" 
    $P3010."add_method"(type_obj, "block", $P3011)
    get_how $P3012, type_obj
    .const 'Sub' $P3013 = "35_1297619360.562" 
    $P3012."add_method"(type_obj, "blockoid", $P3013)
    get_how $P3014, type_obj
    .const 'Sub' $P3015 = "36_1297619360.562" 
    $P3014."add_method"(type_obj, "newpad", $P3015)
    get_how $P3016, type_obj
    .const 'Sub' $P3017 = "37_1297619360.562" 
    $P3016."add_method"(type_obj, "outerctx", $P3017)
    get_how $P3018, type_obj
    .const 'Sub' $P3019 = "38_1297619360.562" 
    $P3018."add_method"(type_obj, "statement_control:sym<if>", $P3019)
    get_how $P3020, type_obj
    .const 'Sub' $P3021 = "40_1297619360.562" 
    $P3020."add_method"(type_obj, "statement_control:sym<unless>", $P3021)
    get_how $P3022, type_obj
    .const 'Sub' $P3023 = "41_1297619360.562" 
    $P3022."add_method"(type_obj, "statement_control:sym<while>", $P3023)
    get_how $P3024, type_obj
    .const 'Sub' $P3025 = "42_1297619360.562" 
    $P3024."add_method"(type_obj, "statement_control:sym<repeat>", $P3025)
    get_how $P3026, type_obj
    .const 'Sub' $P3027 = "43_1297619360.562" 
    $P3026."add_method"(type_obj, "statement_control:sym<for>", $P3027)
    get_how $P3028, type_obj
    .const 'Sub' $P3029 = "44_1297619360.562" 
    $P3028."add_method"(type_obj, "statement_control:sym<CATCH>", $P3029)
    get_how $P3030, type_obj
    .const 'Sub' $P3031 = "45_1297619360.562" 
    $P3030."add_method"(type_obj, "statement_control:sym<CONTROL>", $P3031)
    get_how $P3032, type_obj
    .const 'Sub' $P3033 = "46_1297619360.562" 
    $P3032."add_method"(type_obj, "statement_prefix:sym<INIT>", $P3033)
    get_how $P3034, type_obj
    .const 'Sub' $P3035 = "47_1297619360.562" 
    $P3034."add_method"(type_obj, "statement_prefix:sym<try>", $P3035)
    get_how $P3036, type_obj
    .const 'Sub' $P3037 = "48_1297619360.562" 
    $P3036."add_method"(type_obj, "blorst", $P3037)
    get_how $P3038, type_obj
    .const 'Sub' $P3039 = "49_1297619360.562" 
    $P3038."add_method"(type_obj, "statement_mod_cond:sym<if>", $P3039)
    get_how $P3040, type_obj
    .const 'Sub' $P3041 = "50_1297619360.562" 
    $P3040."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P3041)
    get_how $P3042, type_obj
    .const 'Sub' $P3043 = "51_1297619360.562" 
    $P3042."add_method"(type_obj, "statement_mod_loop:sym<while>", $P3043)
    get_how $P3044, type_obj
    .const 'Sub' $P3045 = "52_1297619360.562" 
    $P3044."add_method"(type_obj, "statement_mod_loop:sym<until>", $P3045)
    get_how $P3046, type_obj
    .const 'Sub' $P3047 = "53_1297619360.562" 
    $P3046."add_method"(type_obj, "term:sym<fatarrow>", $P3047)
    get_how $P3048, type_obj
    .const 'Sub' $P3049 = "54_1297619360.562" 
    $P3048."add_method"(type_obj, "term:sym<colonpair>", $P3049)
    get_how $P3050, type_obj
    .const 'Sub' $P3051 = "55_1297619360.562" 
    $P3050."add_method"(type_obj, "term:sym<variable>", $P3051)
    get_how $P3052, type_obj
    .const 'Sub' $P3053 = "56_1297619360.562" 
    $P3052."add_method"(type_obj, "term:sym<package_declarator>", $P3053)
    get_how $P3054, type_obj
    .const 'Sub' $P3055 = "57_1297619360.562" 
    $P3054."add_method"(type_obj, "term:sym<scope_declarator>", $P3055)
    get_how $P3056, type_obj
    .const 'Sub' $P3057 = "58_1297619360.562" 
    $P3056."add_method"(type_obj, "term:sym<routine_declarator>", $P3057)
    get_how $P3058, type_obj
    .const 'Sub' $P3059 = "59_1297619360.562" 
    $P3058."add_method"(type_obj, "term:sym<regex_declarator>", $P3059)
    get_how $P3060, type_obj
    .const 'Sub' $P3061 = "60_1297619360.562" 
    $P3060."add_method"(type_obj, "term:sym<statement_prefix>", $P3061)
    get_how $P3062, type_obj
    .const 'Sub' $P3063 = "61_1297619360.562" 
    $P3062."add_method"(type_obj, "term:sym<lambda>", $P3063)
    get_how $P3064, type_obj
    .const 'Sub' $P3065 = "62_1297619360.562" 
    $P3064."add_method"(type_obj, "fatarrow", $P3065)
    get_how $P3066, type_obj
    .const 'Sub' $P3067 = "63_1297619360.562" 
    $P3066."add_method"(type_obj, "colonpair", $P3067)
    get_how $P3068, type_obj
    .const 'Sub' $P3069 = "64_1297619360.562" 
    $P3068."add_method"(type_obj, "variable", $P3069)
    get_how $P3070, type_obj
    .const 'Sub' $P3071 = "66_1297619360.562" 
    $P3070."add_method"(type_obj, "package_declarator:sym<module>", $P3071)
    get_how $P3072, type_obj
    .const 'Sub' $P3073 = "67_1297619360.562" 
    $P3072."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3073)
    get_how $P3074, type_obj
    .const 'Sub' $P3075 = "68_1297619360.562" 
    $P3074."add_method"(type_obj, "package_declarator:sym<class>", $P3075)
    get_how $P3076, type_obj
    .const 'Sub' $P3077 = "69_1297619360.562" 
    $P3076."add_method"(type_obj, "package_declarator:sym<grammar>", $P3077)
    get_how $P3078, type_obj
    .const 'Sub' $P3079 = "70_1297619360.562" 
    $P3078."add_method"(type_obj, "package_declarator:sym<role>", $P3079)
    get_how $P3080, type_obj
    .const 'Sub' $P3081 = "71_1297619360.562" 
    $P3080."add_method"(type_obj, "package_declarator:sym<native>", $P3081)
    get_how $P3082, type_obj
    .const 'Sub' $P3083 = "72_1297619360.562" 
    $P3082."add_method"(type_obj, "package_def", $P3083)
    get_how $P3084, type_obj
    .const 'Sub' $P3085 = "76_1297619360.562" 
    $P3084."add_method"(type_obj, "scope_declarator:sym<my>", $P3085)
    get_how $P3086, type_obj
    .const 'Sub' $P3087 = "77_1297619360.562" 
    $P3086."add_method"(type_obj, "scope_declarator:sym<our>", $P3087)
    get_how $P3088, type_obj
    .const 'Sub' $P3089 = "78_1297619360.562" 
    $P3088."add_method"(type_obj, "scope_declarator:sym<has>", $P3089)
    get_how $P3090, type_obj
    .const 'Sub' $P3091 = "79_1297619360.562" 
    $P3090."add_method"(type_obj, "scoped", $P3091)
    get_how $P3092, type_obj
    .const 'Sub' $P3093 = "80_1297619360.562" 
    $P3092."add_method"(type_obj, "declarator", $P3093)
    get_how $P3094, type_obj
    .const 'Sub' $P3095 = "81_1297619360.562" 
    $P3094."add_method"(type_obj, "multi_declarator:sym<multi>", $P3095)
    get_how $P3096, type_obj
    .const 'Sub' $P3097 = "82_1297619360.562" 
    $P3096."add_method"(type_obj, "multi_declarator:sym<proto>", $P3097)
    get_how $P3098, type_obj
    .const 'Sub' $P3099 = "83_1297619360.562" 
    $P3098."add_method"(type_obj, "multi_declarator:sym<null>", $P3099)
    get_how $P3100, type_obj
    .const 'Sub' $P3101 = "84_1297619360.562" 
    $P3100."add_method"(type_obj, "variable_declarator", $P3101)
    get_how $P3102, type_obj
    .const 'Sub' $P3103 = "88_1297619360.562" 
    $P3102."add_method"(type_obj, "routine_declarator:sym<sub>", $P3103)
    get_how $P3104, type_obj
    .const 'Sub' $P3105 = "89_1297619360.562" 
    $P3104."add_method"(type_obj, "routine_declarator:sym<method>", $P3105)
    get_how $P3106, type_obj
    .const 'Sub' $P3107 = "90_1297619360.562" 
    $P3106."add_method"(type_obj, "routine_def", $P3107)
    get_how $P3108, type_obj
    .const 'Sub' $P3109 = "97_1297619360.562" 
    $P3108."add_method"(type_obj, "method_def", $P3109)
    get_how $P3110, type_obj
    .const 'Sub' $P3111 = "100_1297619360.562" 
    $P3110."add_method"(type_obj, "signature", $P3111)
    get_how $P3112, type_obj
    .const 'Sub' $P3113 = "103_1297619360.562" 
    $P3112."add_method"(type_obj, "parameter", $P3113)
    get_how $P3114, type_obj
    .const 'Sub' $P3115 = "104_1297619360.562" 
    $P3114."add_method"(type_obj, "param_var", $P3115)
    get_how $P3116, type_obj
    .const 'Sub' $P3117 = "105_1297619360.562" 
    $P3116."add_method"(type_obj, "named_param", $P3117)
    get_how $P3118, type_obj
    .const 'Sub' $P3119 = "106_1297619360.562" 
    $P3118."add_method"(type_obj, "typename", $P3119)
    get_how $P3120, type_obj
    .const 'Sub' $P3121 = "107_1297619360.562" 
    $P3120."add_method"(type_obj, "trait", $P3121)
    get_how $P3122, type_obj
    .const 'Sub' $P3123 = "108_1297619360.562" 
    $P3122."add_method"(type_obj, "trait_mod:sym<is>", $P3123)
    get_how $P3124, type_obj
    .const 'Sub' $P3125 = "110_1297619360.562" 
    $P3124."add_method"(type_obj, "regex_declarator", $P3125)
    get_how $P3126, type_obj
    .const 'Sub' $P3127 = "114_1297619360.562" 
    $P3126."add_method"(type_obj, "dotty", $P3127)
    get_how $P3128, type_obj
    .const 'Sub' $P3129 = "115_1297619360.562" 
    $P3128."add_method"(type_obj, "term:sym<self>", $P3129)
    get_how $P3130, type_obj
    .const 'Sub' $P3131 = "116_1297619360.562" 
    $P3130."add_method"(type_obj, "term:sym<identifier>", $P3131)
    get_how $P3132, type_obj
    .const 'Sub' $P3133 = "117_1297619360.562" 
    $P3132."add_method"(type_obj, "term:sym<name>", $P3133)
    get_how $P3134, type_obj
    .const 'Sub' $P3135 = "118_1297619360.562" 
    $P3134."add_method"(type_obj, "term:sym<pir::op>", $P3135)
    get_how $P3136, type_obj
    .const 'Sub' $P3137 = "119_1297619360.562" 
    $P3136."add_method"(type_obj, "term:sym<onlystar>", $P3137)
    get_how $P3138, type_obj
    .const 'Sub' $P3139 = "120_1297619360.562" 
    $P3138."add_method"(type_obj, "args", $P3139)
    get_how $P3140, type_obj
    .const 'Sub' $P3141 = "121_1297619360.562" 
    $P3140."add_method"(type_obj, "arglist", $P3141)
    get_how $P3142, type_obj
    .const 'Sub' $P3143 = "124_1297619360.562" 
    $P3142."add_method"(type_obj, "term:sym<multi_declarator>", $P3143)
    get_how $P3144, type_obj
    .const 'Sub' $P3145 = "125_1297619360.562" 
    $P3144."add_method"(type_obj, "term:sym<value>", $P3145)
    get_how $P3146, type_obj
    .const 'Sub' $P3147 = "126_1297619360.562" 
    $P3146."add_method"(type_obj, "circumfix:sym<( )>", $P3147)
    get_how $P3148, type_obj
    .const 'Sub' $P3149 = "127_1297619360.562" 
    $P3148."add_method"(type_obj, "circumfix:sym<[ ]>", $P3149)
    get_how $P3150, type_obj
    .const 'Sub' $P3151 = "128_1297619360.562" 
    $P3150."add_method"(type_obj, "circumfix:sym<ang>", $P3151)
    get_how $P3152, type_obj
    .const 'Sub' $P3153 = "129_1297619360.562" 
    $P3152."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3153)
    get_how $P3154, type_obj
    .const 'Sub' $P3155 = "130_1297619360.562" 
    $P3154."add_method"(type_obj, "circumfix:sym<{ }>", $P3155)
    get_how $P3156, type_obj
    .const 'Sub' $P3157 = "131_1297619360.562" 
    $P3156."add_method"(type_obj, "circumfix:sym<sigil>", $P3157)
    get_how $P3158, type_obj
    .const 'Sub' $P3159 = "132_1297619360.562" 
    $P3158."add_method"(type_obj, "semilist", $P3159)
    get_how $P3160, type_obj
    .const 'Sub' $P3161 = "133_1297619360.562" 
    $P3160."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3161)
    get_how $P3162, type_obj
    .const 'Sub' $P3163 = "134_1297619360.562" 
    $P3162."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3163)
    get_how $P3164, type_obj
    .const 'Sub' $P3165 = "135_1297619360.562" 
    $P3164."add_method"(type_obj, "postcircumfix:sym<ang>", $P3165)
    get_how $P3166, type_obj
    .const 'Sub' $P3167 = "136_1297619360.562" 
    $P3166."add_method"(type_obj, "postcircumfix:sym<( )>", $P3167)
    get_how $P3168, type_obj
    .const 'Sub' $P3169 = "137_1297619360.562" 
    $P3168."add_method"(type_obj, "value", $P3169)
    get_how $P3170, type_obj
    .const 'Sub' $P3171 = "138_1297619360.562" 
    $P3170."add_method"(type_obj, "number", $P3171)
    get_how $P3172, type_obj
    .const 'Sub' $P3173 = "139_1297619360.562" 
    $P3172."add_method"(type_obj, "quote:sym<apos>", $P3173)
    get_how $P3174, type_obj
    .const 'Sub' $P3175 = "140_1297619360.562" 
    $P3174."add_method"(type_obj, "quote:sym<dblq>", $P3175)
    get_how $P3176, type_obj
    .const 'Sub' $P3177 = "141_1297619360.562" 
    $P3176."add_method"(type_obj, "quote:sym<qq>", $P3177)
    get_how $P3178, type_obj
    .const 'Sub' $P3179 = "142_1297619360.562" 
    $P3178."add_method"(type_obj, "quote:sym<q>", $P3179)
    get_how $P3180, type_obj
    .const 'Sub' $P3181 = "143_1297619360.562" 
    $P3180."add_method"(type_obj, "quote:sym<Q>", $P3181)
    get_how $P3182, type_obj
    .const 'Sub' $P3183 = "144_1297619360.562" 
    $P3182."add_method"(type_obj, "quote:sym<Q:PIR>", $P3183)
    get_how $P3184, type_obj
    .const 'Sub' $P3185 = "145_1297619360.562" 
    $P3184."add_method"(type_obj, "quote:sym</ />", $P3185)
    get_how $P3186, type_obj
    .const 'Sub' $P3187 = "146_1297619360.562" 
    $P3186."add_method"(type_obj, "quote_escape:sym<$>", $P3187)
    get_how $P3188, type_obj
    .const 'Sub' $P3189 = "147_1297619360.562" 
    $P3188."add_method"(type_obj, "quote_escape:sym<{ }>", $P3189)
    get_how $P3190, type_obj
    .const 'Sub' $P3191 = "148_1297619360.562" 
    $P3190."add_method"(type_obj, "quote_escape:sym<esc>", $P3191)
    get_how $P3192, type_obj
    .const 'Sub' $P3193 = "149_1297619360.562" 
    $P3192."add_method"(type_obj, "postfix:sym<.>", $P3193)
    get_how $P3194, type_obj
    .const 'Sub' $P3195 = "150_1297619360.562" 
    $P3194."add_method"(type_obj, "postfix:sym<++>", $P3195)
    get_how $P3196, type_obj
    .const 'Sub' $P3197 = "151_1297619360.562" 
    $P3196."add_method"(type_obj, "postfix:sym<-->", $P3197)
    get_how $P3198, type_obj
    .const 'Sub' $P3199 = "152_1297619360.562" 
    $P3198."add_method"(type_obj, "prefix:sym<make>", $P3199)
    get_how $P3200, type_obj
    .const 'Sub' $P3201 = "153_1297619360.562" 
    $P3200."add_method"(type_obj, "term:sym<next>", $P3201)
    get_how $P3202, type_obj
    .const 'Sub' $P3203 = "154_1297619360.562" 
    $P3202."add_method"(type_obj, "term:sym<last>", $P3203)
    get_how $P3204, type_obj
    .const 'Sub' $P3205 = "155_1297619360.562" 
    $P3204."add_method"(type_obj, "term:sym<redo>", $P3205)
    get_how $P3206, type_obj
    .const 'Sub' $P3207 = "156_1297619360.562" 
    $P3206."add_method"(type_obj, "infix:sym<~~>", $P3207)
    get_how $P3208, type_obj
    get_hll_global $P3209, ["HLL"], "Actions"
    $P3208."add_parent"(type_obj, $P3209)
    get_how $P3210, type_obj
    $P3211 = $P3210."compose"(type_obj)
    .return ($P3211)
.end


.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_20
.annotate 'line', 9
    .lex "$xblock", param_20
.annotate 'line', 10
    find_lex $P21, "$xblock"
    unless_null $P21, vivify_171
    $P21 = root_new ['parrot';'ResizablePMCArray']
  vivify_171:
    set $P22, $P21[1]
    unless_null $P22, vivify_172
    new $P22, "Undef"
  vivify_172:
    $P23 = "block_immediate"($P22)
    find_lex $P24, "$xblock"
    unless_null $P24, vivify_173
    $P24 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P24
  vivify_173:
    set $P24[1], $P23
    find_lex $P25, "$xblock"
.annotate 'line', 9
    .return ($P25)
.end


.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_28
.annotate 'line', 14
    .const 'Sub' $P38 = "14_1297619360.562" 
    capture_lex $P38
    .lex "$block", param_28
.annotate 'line', 15
    find_lex $P29, "$block"
    $P29."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P33, "$block"
    $P34 = $P33."symtable"()
    unless $P34, unless_32
    set $P31, $P34
    goto unless_32_end
  unless_32:
    find_lex $P35, "$block"
    $P36 = $P35."handlers"()
    set $P31, $P36
  unless_32_end:
    if $P31, unless_30_end
    .const 'Sub' $P38 = "14_1297619360.562" 
    capture_lex $P38
    $P38()
  unless_30_end:
    find_lex $P58, "$block"
.annotate 'line', 14
    .return ($P58)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block37"  :anon :subid("14_1297619360.562") :outer("13_1297619360.562")
.annotate 'line', 16
    .const 'Sub' $P49 = "15_1297619360.562" 
    capture_lex $P49
.annotate 'line', 17
    new $P39, "Undef"
    .lex "$stmts", $P39
    get_hll_global $P40, ["PAST"], "Stmts"
    find_lex $P41, "$block"
    $P42 = $P40."new"($P41 :named("node"))
    store_lex "$stmts", $P42
.annotate 'line', 18
    find_lex $P44, "$block"
    $P45 = $P44."list"()
    defined $I46, $P45
    unless $I46, for_undef_174
    iter $P43, $P45
    new $P55, 'ExceptionHandler'
    set_label $P55, loop54_handler
    $P55."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P55
  loop54_test:
    unless $P43, loop54_done
    shift $P47, $P43
  loop54_redo:
    .const 'Sub' $P49 = "15_1297619360.562" 
    capture_lex $P49
    $P49($P47)
  loop54_next:
    goto loop54_test
  loop54_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P56, exception, 'type'
    eq $P56, .CONTROL_LOOP_NEXT, loop54_next
    eq $P56, .CONTROL_LOOP_REDO, loop54_redo
  loop54_done:
    pop_eh 
  for_undef_174:
.annotate 'line', 19
    find_lex $P57, "$stmts"
    store_lex "$block", $P57
.annotate 'line', 16
    .return ($P57)
.end


.namespace ["NQP";"Actions"]
.sub "_block48"  :anon :subid("15_1297619360.562") :outer("14_1297619360.562")
    .param pmc param_50
.annotate 'line', 18
    .lex "$_", param_50
    find_lex $P51, "$stmts"
    find_lex $P52, "$_"
    $P53 = $P51."push"($P52)
    .return ($P53)
.end


.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_61
.annotate 'line', 24
    .lex "$sigil", param_61
.annotate 'line', 25
    find_lex $P64, "$sigil"
    set $S65, $P64
    iseq $I66, $S65, "%"
    if $I66, if_63
.annotate 'line', 27
    find_lex $P71, "$sigil"
    set $S72, $P71
    iseq $I73, $S72, "@"
    if $I73, if_70
    new $P76, "String"
    assign $P76, "Undef"
    set $P69, $P76
    goto if_70_end
  if_70:
.annotate 'line', 28
    get_hll_global $P74, ["PAST"], "Op"
    $P75 = $P74."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P69, $P75
  if_70_end:
    set $P62, $P69
.annotate 'line', 25
    goto if_63_end
  if_63:
.annotate 'line', 26
    get_hll_global $P67, ["PAST"], "Op"
    $P68 = $P67."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P62, $P68
  if_63_end:
.annotate 'line', 24
    .return ($P62)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_79
.annotate 'line', 43
    .lex "$ast", param_79
.annotate 'line', 44
    get_hll_global $P82, ["PAST"], "Op"
    find_lex $P83, "$ast"
    $P84 = $P82."ACCEPTS"($P83)
    if $P84, if_81
.annotate 'line', 46
    find_lex $P88, "$ast"
    $P89 = $P88."value"()
    set $P80, $P89
.annotate 'line', 44
    goto if_81_end
  if_81:
.annotate 'line', 45
    find_lex $P85, "$ast"
    $P86 = $P85."list"()
    join $S87, " ", $P86
    new $P80, 'String'
    set $P80, $S87
  if_81_end:
.annotate 'line', 43
    .return ($P80)
.end


.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_92
    .param pmc param_93
.annotate 'line', 223
    .lex "$/", param_92
    .lex "$block", param_93
.annotate 'line', 224
    get_global $P95, "@BLOCK"
    unless_null $P95, vivify_175
    $P95 = root_new ['parrot';'ResizablePMCArray']
  vivify_175:
    set $P96, $P95[0]
    unless_null $P96, vivify_176
    new $P96, "Undef"
  vivify_176:
    $P97 = $P96."handlers"()
    if $P97, unless_94_end
.annotate 'line', 225
    get_global $P98, "@BLOCK"
    unless_null $P98, vivify_177
    $P98 = root_new ['parrot';'ResizablePMCArray']
  vivify_177:
    set $P99, $P98[0]
    unless_null $P99, vivify_178
    new $P99, "Undef"
  vivify_178:
    new $P100, "ResizablePMCArray"
    $P99."handlers"($P100)
  unless_94_end:
.annotate 'line', 227
    find_lex $P102, "$block"
    $P103 = $P102."arity"()
    if $P103, unless_101_end
.annotate 'line', 228
    find_lex $P104, "$block"
.annotate 'line', 229
    get_hll_global $P105, ["PAST"], "Op"
.annotate 'line', 230
    get_hll_global $P106, ["PAST"], "Var"
    $P107 = $P106."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 231
    get_hll_global $P108, ["PAST"], "Var"
    $P109 = $P108."new"("lexical" :named("scope"), "$_" :named("name"))
    $P110 = $P105."new"($P107, $P109, "bind" :named("pasttype"))
.annotate 'line', 229
    $P104."unshift"($P110)
.annotate 'line', 234
    find_lex $P111, "$block"
    get_hll_global $P112, ["PAST"], "Var"
    $P113 = $P112."new"("$_" :named("name"), "parameter" :named("scope"))
    $P111."unshift"($P113)
.annotate 'line', 235
    find_lex $P114, "$block"
    $P114."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 236
    find_lex $P115, "$block"
    $P115."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 237
    find_lex $P116, "$block"
    $P116."arity"(1)
  unless_101_end:
.annotate 'line', 239
    find_lex $P117, "$block"
    $P117."blocktype"("declaration")
.annotate 'line', 240
    get_global $P118, "@BLOCK"
    unless_null $P118, vivify_179
    $P118 = root_new ['parrot';'ResizablePMCArray']
  vivify_179:
    set $P119, $P118[0]
    unless_null $P119, vivify_180
    new $P119, "Undef"
  vivify_180:
    $P120 = $P119."handlers"()
.annotate 'line', 241
    get_hll_global $P121, ["PAST"], "Control"
    find_lex $P122, "$/"
.annotate 'line', 243
    get_hll_global $P123, ["PAST"], "Stmts"
.annotate 'line', 244
    get_hll_global $P124, ["PAST"], "Op"
    find_lex $P125, "$block"
.annotate 'line', 246
    get_hll_global $P126, ["PAST"], "Var"
    $P127 = $P126."new"("register" :named("scope"), "exception" :named("name"))
    $P128 = $P124."new"($P125, $P127, "call" :named("pasttype"))
.annotate 'line', 248
    get_hll_global $P129, ["PAST"], "Op"
.annotate 'line', 249
    get_hll_global $P130, ["PAST"], "Var"
.annotate 'line', 250
    get_hll_global $P131, ["PAST"], "Var"
    $P132 = $P131."new"("register" :named("scope"), "exception" :named("name"))
    $P133 = $P130."new"($P132, "handled", "keyed" :named("scope"))
.annotate 'line', 249
    $P134 = $P129."new"($P133, 1, "bind" :named("pasttype"))
.annotate 'line', 248
    $P135 = $P123."new"($P128, $P134)
.annotate 'line', 243
    $P136 = $P121."new"($P135, $P122 :named("node"))
.annotate 'line', 241
    $P137 = $P120."unshift"($P136)
.annotate 'line', 223
    .return ($P137)
.end


.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("19_1297619360.562") :outer("11_1297619360.562")
.annotate 'line', 763
    new $P140, "Undef"
    .lex "$past", $P140
    get_global $P141, "@BLOCK"
    $P142 = $P141."shift"()
    store_lex "$past", $P142
.annotate 'line', 764
    find_lex $P143, "$past"
    $P143."closure"(1)
.annotate 'line', 765
    find_lex $P144, "$past"
    get_hll_global $P145, ["PAST"], "Op"
    $P146 = $P145."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P144."push"($P146)
    find_lex $P147, "$past"
.annotate 'line', 762
    .return ($P147)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("20_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_150
.annotate 'line', 771
    .const 'Sub' $P164 = "21_1297619360.562" 
    capture_lex $P164
    .lex "$routine", param_150
.annotate 'line', 775
    new $P151, "Undef"
    .lex "$types", $P151
.annotate 'line', 776
    new $P152, "Undef"
    .lex "$definednesses", $P152
.annotate 'line', 775
    get_hll_global $P153, ["PAST"], "Op"
    $P154 = $P153."new"("list" :named("pasttype"))
    store_lex "$types", $P154
.annotate 'line', 776
    get_hll_global $P155, ["PAST"], "Op"
    $P156 = $P155."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P156
.annotate 'line', 777
    find_lex $P158, "$routine"
    unless_null $P158, vivify_181
    $P158 = root_new ['parrot';'ResizablePMCArray']
  vivify_181:
    set $P159, $P158[0]
    unless_null $P159, vivify_182
    new $P159, "Undef"
  vivify_182:
    $P160 = $P159."list"()
    defined $I161, $P160
    unless $I161, for_undef_183
    iter $P157, $P160
    new $P202, 'ExceptionHandler'
    set_label $P202, loop201_handler
    $P202."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P202
  loop201_test:
    unless $P157, loop201_done
    shift $P162, $P157
  loop201_redo:
    .const 'Sub' $P164 = "21_1297619360.562" 
    capture_lex $P164
    $P164($P162)
  loop201_next:
    goto loop201_test
  loop201_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P203, exception, 'type'
    eq $P203, .CONTROL_LOOP_NEXT, loop201_next
    eq $P203, .CONTROL_LOOP_REDO, loop201_redo
  loop201_done:
    pop_eh 
  for_undef_183:
.annotate 'line', 784
    find_lex $P204, "$routine"
    $P205 = $P204."loadinit"()
    get_hll_global $P206, ["PAST"], "Op"
.annotate 'line', 785
    get_hll_global $P207, ["PAST"], "Var"
    $P208 = $P207."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P209, "$types"
    find_lex $P210, "$definednesses"
    $P211 = $P206."new"($P208, $P209, $P210, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 784
    $P212 = $P205."push"($P211)
.annotate 'line', 771
    .return ($P212)
.end


.namespace ["NQP";"Actions"]
.sub "_block163"  :anon :subid("21_1297619360.562") :outer("20_1297619360.562")
    .param pmc param_165
.annotate 'line', 777
    .lex "$_", param_165
.annotate 'line', 778
    get_hll_global $P170, ["PAST"], "Var"
    find_lex $P171, "$_"
    $P172 = $P170."ACCEPTS"($P171)
    if $P172, if_169
    set $P168, $P172
    goto if_169_end
  if_169:
    find_lex $P173, "$_"
    $S174 = $P173."scope"()
    iseq $I175, $S174, "parameter"
    new $P168, 'Integer'
    set $P168, $I175
  if_169_end:
    if $P168, if_167
    set $P166, $P168
    goto if_167_end
  if_167:
.annotate 'line', 779
    find_lex $P176, "$types"
    find_lex $P178, "$_"
    $P179 = $P178."multitype"()
    set $P177, $P179
    defined $I181, $P177
    if $I181, default_180
    get_hll_global $P182, ["PAST"], "Op"
    $P183 = $P182."new"("null P" :named("pirop"))
    set $P177, $P183
  default_180:
    $P176."push"($P177)
.annotate 'line', 780
    find_lex $P184, "$definednesses"
    find_lex $P187, "$_"
    unless_null $P187, vivify_184
    $P187 = root_new ['parrot';'Hash']
  vivify_184:
    set $P188, $P187["definedness"]
    unless_null $P188, vivify_185
    new $P188, "Undef"
  vivify_185:
    set $S189, $P188
    iseq $I190, $S189, "D"
    if $I190, if_186
.annotate 'line', 781
    find_lex $P194, "$_"
    unless_null $P194, vivify_186
    $P194 = root_new ['parrot';'Hash']
  vivify_186:
    set $P195, $P194["definedness"]
    unless_null $P195, vivify_187
    new $P195, "Undef"
  vivify_187:
    set $S196, $P195
    iseq $I197, $S196, "U"
    if $I197, if_193
    new $P199, "Integer"
    assign $P199, 0
    set $P192, $P199
    goto if_193_end
  if_193:
    new $P198, "Integer"
    assign $P198, 2
    set $P192, $P198
  if_193_end:
    set $P185, $P192
.annotate 'line', 780
    goto if_186_end
  if_186:
    new $P191, "Integer"
    assign $P191, 1
    set $P185, $P191
  if_186_end:
    $P200 = $P184."push"($P185)
.annotate 'line', 778
    set $P166, $P200
  if_167_end:
.annotate 'line', 777
    .return ($P166)
.end


.namespace ["NQP";"Actions"]
.sub "control"  :subid("22_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_215
    .param pmc param_216
.annotate 'line', 1241
    .lex "$/", param_215
    .lex "$type", param_216
.annotate 'line', 1242
    find_lex $P217, "$/"
    get_hll_global $P218, ["PAST"], "Op"
    find_lex $P219, "$/"
.annotate 'line', 1246
    get_hll_global $P220, ["PAST"], "Val"
    find_lex $P221, "$type"
    $P222 = $P220."new"($P221 :named("value"), "!except_types" :named("returns"))
    $P223 = $P218."new"(0, $P222, $P219 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1242
    $P224 = $P217."!make"($P223)
.annotate 'line', 1241
    .return ($P224)
.end


.namespace ["NQP";"Actions"]
.sub "_block227"  :anon :subid("23_1297619360.562") :outer("11_1297619360.562")
.annotate 'line', 3
    .const 'Sub' $P230 = "24_1297619360.562" 
    capture_lex $P230
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post188") :outer("23_1297619360.562")
.annotate 'line', 3
    .const 'Sub' $P228 = "23_1297619360.562" 
    .local pmc block
    set block, $P228
.annotate 'line', 5
    .const 'Sub' $P230 = "24_1297619360.562" 
    capture_lex $P230
    $P230()
.end


.namespace ["NQP";"Actions"]
.sub "_block229"  :anon :subid("24_1297619360.562") :outer("23_1297619360.562")
.annotate 'line', 6
    get_global $P231, "@BLOCK"
    unless_null $P231, vivify_189
    $P231 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P231
  vivify_189:
 $P232 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P232
.annotate 'line', 5
    .return ($P232)
.end


.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("25_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_237
    .param pmc param_238
.annotate 'line', 33
    .lex "self", param_237
    .lex "$/", param_238
    find_lex $P239, "$/"
    find_lex $P240, "$/"
    unless_null $P240, vivify_190
    $P240 = root_new ['parrot';'Hash']
  vivify_190:
    set $P241, $P240["comp_unit"]
    unless_null $P241, vivify_191
    new $P241, "Undef"
  vivify_191:
    $P242 = $P241."ast"()
    $P243 = $P239."!make"($P242)
    .return ($P243)
.end


.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("26_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_245
    .param pmc param_246
.annotate 'line', 35
    .lex "self", param_245
    .lex "$/", param_246
.annotate 'line', 36
    find_lex $P247, "$/"
.annotate 'line', 37
    find_lex $P250, "$/"
    unless_null $P250, vivify_192
    $P250 = root_new ['parrot';'Hash']
  vivify_192:
    set $P251, $P250["colonpair"]
    unless_null $P251, vivify_193
    new $P251, "Undef"
  vivify_193:
    if $P251, if_249
.annotate 'line', 39
    find_lex $P271, "$/"
    set $S272, $P271
    new $P248, 'String'
    set $P248, $S272
.annotate 'line', 37
    goto if_249_end
  if_249:
    find_lex $P252, "$/"
    unless_null $P252, vivify_194
    $P252 = root_new ['parrot';'Hash']
  vivify_194:
    set $P253, $P252["identifier"]
    unless_null $P253, vivify_195
    new $P253, "Undef"
  vivify_195:
    set $S254, $P253
    new $P255, 'String'
    set $P255, $S254
    concat $P256, $P255, ":"
    find_lex $P257, "$/"
    unless_null $P257, vivify_196
    $P257 = root_new ['parrot';'Hash']
  vivify_196:
    set $P258, $P257["colonpair"]
    unless_null $P258, vivify_197
    $P258 = root_new ['parrot';'ResizablePMCArray']
  vivify_197:
    set $P259, $P258[0]
    unless_null $P259, vivify_198
    new $P259, "Undef"
  vivify_198:
    $P260 = $P259."ast"()
    $S261 = $P260."named"()
    concat $P262, $P256, $S261
    concat $P263, $P262, "<"
.annotate 'line', 38
    find_lex $P264, "$/"
    unless_null $P264, vivify_199
    $P264 = root_new ['parrot';'Hash']
  vivify_199:
    set $P265, $P264["colonpair"]
    unless_null $P265, vivify_200
    $P265 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $P266, $P265[0]
    unless_null $P266, vivify_201
    new $P266, "Undef"
  vivify_201:
    $P267 = $P266."ast"()
    $S268 = "colonpair_str"($P267)
    concat $P269, $P263, $S268
    concat $P270, $P269, ">"
    set $P248, $P270
  if_249_end:
.annotate 'line', 37
    $P273 = $P247."!make"($P248)
.annotate 'line', 35
    .return ($P273)
.end


.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("27_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_276
    .param pmc param_277
.annotate 'line', 49
    .lex "self", param_276
    .lex "$/", param_277
.annotate 'line', 50
    new $P278, "Undef"
    .lex "$mainline", $P278
.annotate 'line', 51
    new $P279, "Undef"
    .lex "$unit", $P279
.annotate 'line', 50
    find_lex $P280, "$/"
    unless_null $P280, vivify_202
    $P280 = root_new ['parrot';'Hash']
  vivify_202:
    set $P281, $P280["statementlist"]
    unless_null $P281, vivify_203
    new $P281, "Undef"
  vivify_203:
    $P282 = $P281."ast"()
    store_lex "$mainline", $P282
.annotate 'line', 51
    get_global $P283, "@BLOCK"
    $P284 = $P283."shift"()
    store_lex "$unit", $P284
.annotate 'line', 55
    find_lex $P285, "$unit"
    find_lex $P286, "self"
    $P287 = $P286."CTXSAVE"()
    $P285."push"($P287)
.annotate 'line', 58
    find_lex $P288, "$unit"
    $P288."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 59
    find_lex $P289, "$unit"
    get_hll_global $P290, ["PAST"], "Op"
    $P291 = $P290."new"("nqp_dynop_setup v" :named("pirop"))
    $P289."unshift"($P291)
.annotate 'line', 64
    find_lex $P292, "$unit"
.annotate 'line', 65
    get_hll_global $P293, ["PAST"], "Op"
    find_lex $P294, "$mainline"
    $P295 = $P293."new"($P294, "return" :named("pirop"))
    $P292."push"($P295)
.annotate 'line', 70
    find_lex $P296, "$unit"
.annotate 'line', 71
    get_hll_global $P297, ["PAST"], "Block"
.annotate 'line', 73
    get_hll_global $P298, ["PAST"], "Op"
    get_hll_global $P299, ["PAST"], "Val"
    find_lex $P300, "$unit"
    $P301 = $P299."new"($P300 :named("value"))
    $P302 = $P298."new"($P301, "call" :named("pasttype"))
    $P303 = $P297."new"($P302, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 71
    $P296."push"($P303)
.annotate 'line', 76
    find_lex $P304, "$unit"
    find_lex $P305, "$/"
    $P304."node"($P305)
.annotate 'line', 77
    find_lex $P306, "$/"
    find_lex $P307, "$unit"
    $P308 = $P306."!make"($P307)
.annotate 'line', 49
    .return ($P308)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("28_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_310
    .param pmc param_311
.annotate 'line', 80
    .const 'Sub' $P325 = "29_1297619360.562" 
    capture_lex $P325
    .lex "self", param_310
    .lex "$/", param_311
.annotate 'line', 81
    new $P312, "Undef"
    .lex "$past", $P312
    get_hll_global $P313, ["PAST"], "Stmts"
    find_lex $P314, "$/"
    $P315 = $P313."new"($P314 :named("node"))
    store_lex "$past", $P315
.annotate 'line', 82
    find_lex $P317, "$/"
    unless_null $P317, vivify_204
    $P317 = root_new ['parrot';'Hash']
  vivify_204:
    set $P318, $P317["statement"]
    unless_null $P318, vivify_205
    new $P318, "Undef"
  vivify_205:
    unless $P318, if_316_end
.annotate 'line', 83
    find_lex $P320, "$/"
    unless_null $P320, vivify_206
    $P320 = root_new ['parrot';'Hash']
  vivify_206:
    set $P321, $P320["statement"]
    unless_null $P321, vivify_207
    new $P321, "Undef"
  vivify_207:
    defined $I322, $P321
    unless $I322, for_undef_208
    iter $P319, $P321
    new $P345, 'ExceptionHandler'
    set_label $P345, loop344_handler
    $P345."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P345
  loop344_test:
    unless $P319, loop344_done
    shift $P323, $P319
  loop344_redo:
    .const 'Sub' $P325 = "29_1297619360.562" 
    capture_lex $P325
    $P325($P323)
  loop344_next:
    goto loop344_test
  loop344_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P346, exception, 'type'
    eq $P346, .CONTROL_LOOP_NEXT, loop344_next
    eq $P346, .CONTROL_LOOP_REDO, loop344_redo
  loop344_done:
    pop_eh 
  for_undef_208:
  if_316_end:
.annotate 'line', 90
    find_lex $P347, "$/"
    find_lex $P348, "$past"
    $P349 = $P347."!make"($P348)
.annotate 'line', 80
    .return ($P349)
.end


.namespace ["NQP";"Actions"]
.sub "_block324"  :anon :subid("29_1297619360.562") :outer("28_1297619360.562")
    .param pmc param_327
.annotate 'line', 84
    new $P326, "Undef"
    .lex "$ast", $P326
    .lex "$_", param_327
    find_lex $P328, "$_"
    $P329 = $P328."ast"()
    store_lex "$ast", $P329
.annotate 'line', 85
    find_lex $P331, "$ast"
    unless_null $P331, vivify_209
    $P331 = root_new ['parrot';'Hash']
  vivify_209:
    set $P332, $P331["sink"]
    unless_null $P332, vivify_210
    new $P332, "Undef"
  vivify_210:
    defined $I333, $P332
    unless $I333, if_330_end
    find_lex $P334, "$ast"
    unless_null $P334, vivify_211
    $P334 = root_new ['parrot';'Hash']
  vivify_211:
    set $P335, $P334["sink"]
    unless_null $P335, vivify_212
    new $P335, "Undef"
  vivify_212:
    store_lex "$ast", $P335
  if_330_end:
.annotate 'line', 86
    find_lex $P337, "$ast"
    unless_null $P337, vivify_213
    $P337 = root_new ['parrot';'Hash']
  vivify_213:
    set $P338, $P337["bareblock"]
    unless_null $P338, vivify_214
    new $P338, "Undef"
  vivify_214:
    unless $P338, if_336_end
    find_lex $P339, "$ast"
    $P340 = "block_immediate"($P339)
    store_lex "$ast", $P340
  if_336_end:
.annotate 'line', 87
    find_lex $P341, "$past"
    find_lex $P342, "$ast"
    $P343 = $P341."push"($P342)
.annotate 'line', 83
    .return ($P343)
.end


.namespace ["NQP";"Actions"]
.sub "statement"  :subid("30_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_351
    .param pmc param_352
    .param pmc param_353 :optional
    .param int has_param_353 :opt_flag
.annotate 'line', 93
    .const 'Sub' $P361 = "31_1297619360.562" 
    capture_lex $P361
    .lex "self", param_351
    .lex "$/", param_352
    if has_param_353, optparam_215
    new $P354, "Undef"
    set param_353, $P354
  optparam_215:
    .lex "$key", param_353
.annotate 'line', 94
    new $P355, "Undef"
    .lex "$past", $P355
.annotate 'line', 93
    find_lex $P356, "$past"
.annotate 'line', 95
    find_lex $P358, "$/"
    unless_null $P358, vivify_216
    $P358 = root_new ['parrot';'Hash']
  vivify_216:
    set $P359, $P358["EXPR"]
    unless_null $P359, vivify_217
    new $P359, "Undef"
  vivify_217:
    if $P359, if_357
.annotate 'line', 116
    find_lex $P422, "$/"
    unless_null $P422, vivify_218
    $P422 = root_new ['parrot';'Hash']
  vivify_218:
    set $P423, $P422["statement_control"]
    unless_null $P423, vivify_219
    new $P423, "Undef"
  vivify_219:
    if $P423, if_421
.annotate 'line', 117
    new $P427, "Integer"
    assign $P427, 0
    store_lex "$past", $P427
    goto if_421_end
  if_421:
.annotate 'line', 116
    find_lex $P424, "$/"
    unless_null $P424, vivify_220
    $P424 = root_new ['parrot';'Hash']
  vivify_220:
    set $P425, $P424["statement_control"]
    unless_null $P425, vivify_221
    new $P425, "Undef"
  vivify_221:
    $P426 = $P425."ast"()
    store_lex "$past", $P426
  if_421_end:
    goto if_357_end
  if_357:
.annotate 'line', 95
    .const 'Sub' $P361 = "31_1297619360.562" 
    capture_lex $P361
    $P361()
  if_357_end:
.annotate 'line', 118
    find_lex $P428, "$/"
    find_lex $P429, "$past"
    $P430 = $P428."!make"($P429)
.annotate 'line', 93
    .return ($P430)
.end


.namespace ["NQP";"Actions"]
.sub "_block360"  :anon :subid("31_1297619360.562") :outer("30_1297619360.562")
.annotate 'line', 96
    new $P362, "Undef"
    .lex "$mc", $P362
.annotate 'line', 97
    new $P363, "Undef"
    .lex "$ml", $P363
.annotate 'line', 96
    find_lex $P364, "$/"
    unless_null $P364, vivify_222
    $P364 = root_new ['parrot';'Hash']
  vivify_222:
    set $P365, $P364["statement_mod_cond"]
    unless_null $P365, vivify_223
    $P365 = root_new ['parrot';'ResizablePMCArray']
  vivify_223:
    set $P366, $P365[0]
    unless_null $P366, vivify_224
    new $P366, "Undef"
  vivify_224:
    store_lex "$mc", $P366
.annotate 'line', 97
    find_lex $P367, "$/"
    unless_null $P367, vivify_225
    $P367 = root_new ['parrot';'Hash']
  vivify_225:
    set $P368, $P367["statement_mod_loop"]
    unless_null $P368, vivify_226
    $P368 = root_new ['parrot';'ResizablePMCArray']
  vivify_226:
    set $P369, $P368[0]
    unless_null $P369, vivify_227
    new $P369, "Undef"
  vivify_227:
    store_lex "$ml", $P369
.annotate 'line', 98
    find_lex $P370, "$/"
    unless_null $P370, vivify_228
    $P370 = root_new ['parrot';'Hash']
  vivify_228:
    set $P371, $P370["EXPR"]
    unless_null $P371, vivify_229
    new $P371, "Undef"
  vivify_229:
    $P372 = $P371."ast"()
    store_lex "$past", $P372
.annotate 'line', 99
    find_lex $P374, "$mc"
    unless $P374, if_373_end
.annotate 'line', 100
    get_hll_global $P375, ["PAST"], "Op"
    find_lex $P376, "$mc"
    unless_null $P376, vivify_230
    $P376 = root_new ['parrot';'Hash']
  vivify_230:
    set $P377, $P376["cond"]
    unless_null $P377, vivify_231
    new $P377, "Undef"
  vivify_231:
    $P378 = $P377."ast"()
    find_lex $P379, "$past"
    find_lex $P380, "$mc"
    unless_null $P380, vivify_232
    $P380 = root_new ['parrot';'Hash']
  vivify_232:
    set $P381, $P380["sym"]
    unless_null $P381, vivify_233
    new $P381, "Undef"
  vivify_233:
    set $S382, $P381
    find_lex $P383, "$/"
    $P384 = $P375."new"($P378, $P379, $S382 :named("pasttype"), $P383 :named("node"))
    store_lex "$past", $P384
  if_373_end:
.annotate 'line', 102
    find_lex $P387, "$ml"
    if $P387, if_386
    set $P385, $P387
    goto if_386_end
  if_386:
.annotate 'line', 103
    find_lex $P390, "$ml"
    unless_null $P390, vivify_234
    $P390 = root_new ['parrot';'Hash']
  vivify_234:
    set $P391, $P390["sym"]
    unless_null $P391, vivify_235
    new $P391, "Undef"
  vivify_235:
    set $S392, $P391
    iseq $I393, $S392, "for"
    if $I393, if_389
.annotate 'line', 112
    get_hll_global $P411, ["PAST"], "Op"
    find_lex $P412, "$ml"
    unless_null $P412, vivify_236
    $P412 = root_new ['parrot';'Hash']
  vivify_236:
    set $P413, $P412["cond"]
    unless_null $P413, vivify_237
    new $P413, "Undef"
  vivify_237:
    $P414 = $P413."ast"()
    find_lex $P415, "$past"
    find_lex $P416, "$ml"
    unless_null $P416, vivify_238
    $P416 = root_new ['parrot';'Hash']
  vivify_238:
    set $P417, $P416["sym"]
    unless_null $P417, vivify_239
    new $P417, "Undef"
  vivify_239:
    set $S418, $P417
    find_lex $P419, "$/"
    $P420 = $P411."new"($P414, $P415, $S418 :named("pasttype"), $P419 :named("node"))
    store_lex "$past", $P420
.annotate 'line', 111
    set $P388, $P420
.annotate 'line', 103
    goto if_389_end
  if_389:
.annotate 'line', 104
    get_hll_global $P394, ["PAST"], "Block"
.annotate 'line', 105
    get_hll_global $P395, ["PAST"], "Var"
    $P396 = $P395."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P397, "$past"
    $P398 = $P394."new"($P396, $P397, "immediate" :named("blocktype"))
.annotate 'line', 104
    store_lex "$past", $P398
.annotate 'line', 107
    find_lex $P399, "$past"
    $P399."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 108
    find_lex $P400, "$past"
    $P400."arity"(1)
.annotate 'line', 109
    get_hll_global $P401, ["PAST"], "Op"
    find_lex $P402, "$ml"
    unless_null $P402, vivify_240
    $P402 = root_new ['parrot';'Hash']
  vivify_240:
    set $P403, $P402["cond"]
    unless_null $P403, vivify_241
    new $P403, "Undef"
  vivify_241:
    $P404 = $P403."ast"()
    find_lex $P405, "$past"
    find_lex $P406, "$ml"
    unless_null $P406, vivify_242
    $P406 = root_new ['parrot';'Hash']
  vivify_242:
    set $P407, $P406["sym"]
    unless_null $P407, vivify_243
    new $P407, "Undef"
  vivify_243:
    set $S408, $P407
    find_lex $P409, "$/"
    $P410 = $P401."new"($P404, $P405, $S408 :named("pasttype"), $P409 :named("node"))
    store_lex "$past", $P410
.annotate 'line', 103
    set $P388, $P410
  if_389_end:
.annotate 'line', 102
    set $P385, $P388
  if_386_end:
.annotate 'line', 95
    .return ($P385)
.end


.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("32_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_432
    .param pmc param_433
.annotate 'line', 121
    .lex "self", param_432
    .lex "$/", param_433
.annotate 'line', 122
    find_lex $P434, "$/"
    get_hll_global $P435, ["PAST"], "Op"
    find_lex $P436, "$/"
    unless_null $P436, vivify_244
    $P436 = root_new ['parrot';'Hash']
  vivify_244:
    set $P437, $P436["EXPR"]
    unless_null $P437, vivify_245
    new $P437, "Undef"
  vivify_245:
    $P438 = $P437."ast"()
    find_lex $P439, "$/"
    unless_null $P439, vivify_246
    $P439 = root_new ['parrot';'Hash']
  vivify_246:
    set $P440, $P439["pblock"]
    unless_null $P440, vivify_247
    new $P440, "Undef"
  vivify_247:
    $P441 = $P440."ast"()
    find_lex $P442, "$/"
    $P443 = $P435."new"($P438, $P441, "if" :named("pasttype"), $P442 :named("node"))
    $P444 = $P434."!make"($P443)
.annotate 'line', 121
    .return ($P444)
.end


.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("33_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_446
    .param pmc param_447
.annotate 'line', 125
    .lex "self", param_446
    .lex "$/", param_447
.annotate 'line', 126
    find_lex $P448, "$/"
    find_lex $P449, "$/"
    unless_null $P449, vivify_248
    $P449 = root_new ['parrot';'Hash']
  vivify_248:
    set $P450, $P449["blockoid"]
    unless_null $P450, vivify_249
    new $P450, "Undef"
  vivify_249:
    $P451 = $P450."ast"()
    $P452 = $P448."!make"($P451)
.annotate 'line', 125
    .return ($P452)
.end


.namespace ["NQP";"Actions"]
.sub "block"  :subid("34_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_454
    .param pmc param_455
.annotate 'line', 129
    .lex "self", param_454
    .lex "$/", param_455
.annotate 'line', 130
    find_lex $P456, "$/"
    find_lex $P457, "$/"
    unless_null $P457, vivify_250
    $P457 = root_new ['parrot';'Hash']
  vivify_250:
    set $P458, $P457["blockoid"]
    unless_null $P458, vivify_251
    new $P458, "Undef"
  vivify_251:
    $P459 = $P458."ast"()
    $P460 = $P456."!make"($P459)
.annotate 'line', 129
    .return ($P460)
.end


.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("35_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_462
    .param pmc param_463
.annotate 'line', 133
    .lex "self", param_462
    .lex "$/", param_463
.annotate 'line', 134
    new $P464, "Undef"
    .lex "$past", $P464
.annotate 'line', 135
    new $P465, "Undef"
    .lex "$BLOCK", $P465
.annotate 'line', 134
    find_lex $P466, "$/"
    unless_null $P466, vivify_252
    $P466 = root_new ['parrot';'Hash']
  vivify_252:
    set $P467, $P466["statementlist"]
    unless_null $P467, vivify_253
    new $P467, "Undef"
  vivify_253:
    $P468 = $P467."ast"()
    store_lex "$past", $P468
.annotate 'line', 135
    get_global $P469, "@BLOCK"
    $P470 = $P469."shift"()
    store_lex "$BLOCK", $P470
.annotate 'line', 136
    find_lex $P471, "$BLOCK"
    find_lex $P472, "$past"
    $P471."push"($P472)
.annotate 'line', 137
    find_lex $P473, "$BLOCK"
    find_lex $P474, "$/"
    $P473."node"($P474)
.annotate 'line', 138
    find_lex $P475, "$BLOCK"
    $P475."closure"(1)
.annotate 'line', 139
    find_lex $P476, "$/"
    find_lex $P477, "$BLOCK"
    $P478 = $P476."!make"($P477)
.annotate 'line', 133
    .return ($P478)
.end


.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("36_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_480
    .param pmc param_481
.annotate 'line', 142
    .lex "self", param_480
    .lex "$/", param_481
.annotate 'line', 143
    get_global $P482, "@BLOCK"
    unless_null $P482, vivify_254
    $P482 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P482
  vivify_254:
.annotate 'line', 142
    get_global $P483, "@BLOCK"
.annotate 'line', 144
    get_global $P484, "@BLOCK"
    get_hll_global $P485, ["PAST"], "Block"
    get_hll_global $P486, ["PAST"], "Stmts"
    $P487 = $P486."new"()
    $P488 = $P485."new"($P487)
    $P489 = $P484."unshift"($P488)
.annotate 'line', 142
    .return ($P489)
.end


.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("37_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_491
    .param pmc param_492
.annotate 'line', 147
    .lex "self", param_491
    .lex "$/", param_492
.annotate 'line', 148
    get_global $P493, "@BLOCK"
    unless_null $P493, vivify_255
    $P493 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P493
  vivify_255:
.annotate 'line', 147
    get_global $P494, "@BLOCK"
.annotate 'line', 149
    find_lex $P495, "self"
    get_global $P496, "@BLOCK"
    unless_null $P496, vivify_256
    $P496 = root_new ['parrot';'ResizablePMCArray']
  vivify_256:
    set $P497, $P496[0]
    unless_null $P497, vivify_257
    new $P497, "Undef"
  vivify_257:
    $P498 = $P495."SET_BLOCK_OUTER_CTX"($P497)
.annotate 'line', 147
    .return ($P498)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("38_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_500
    .param pmc param_501
.annotate 'line', 154
    .const 'Sub' $P529 = "39_1297619360.562" 
    capture_lex $P529
    .lex "self", param_500
    .lex "$/", param_501
.annotate 'line', 155
    new $P502, "Undef"
    .lex "$count", $P502
.annotate 'line', 156
    new $P503, "Undef"
    .lex "$past", $P503
.annotate 'line', 155
    find_lex $P504, "$/"
    unless_null $P504, vivify_258
    $P504 = root_new ['parrot';'Hash']
  vivify_258:
    set $P505, $P504["xblock"]
    unless_null $P505, vivify_259
    new $P505, "Undef"
  vivify_259:
    set $N506, $P505
    new $P507, 'Float'
    set $P507, $N506
    sub $P508, $P507, 1
    store_lex "$count", $P508
.annotate 'line', 156
    find_lex $P509, "$count"
    set $I510, $P509
    find_lex $P511, "$/"
    unless_null $P511, vivify_260
    $P511 = root_new ['parrot';'Hash']
  vivify_260:
    set $P512, $P511["xblock"]
    unless_null $P512, vivify_261
    $P512 = root_new ['parrot';'ResizablePMCArray']
  vivify_261:
    set $P513, $P512[$I510]
    unless_null $P513, vivify_262
    new $P513, "Undef"
  vivify_262:
    $P514 = $P513."ast"()
    $P515 = "xblock_immediate"($P514)
    store_lex "$past", $P515
.annotate 'line', 157
    find_lex $P517, "$/"
    unless_null $P517, vivify_263
    $P517 = root_new ['parrot';'Hash']
  vivify_263:
    set $P518, $P517["else"]
    unless_null $P518, vivify_264
    new $P518, "Undef"
  vivify_264:
    unless $P518, if_516_end
.annotate 'line', 158
    find_lex $P519, "$past"
    find_lex $P520, "$/"
    unless_null $P520, vivify_265
    $P520 = root_new ['parrot';'Hash']
  vivify_265:
    set $P521, $P520["else"]
    unless_null $P521, vivify_266
    $P521 = root_new ['parrot';'ResizablePMCArray']
  vivify_266:
    set $P522, $P521[0]
    unless_null $P522, vivify_267
    new $P522, "Undef"
  vivify_267:
    $P523 = $P522."ast"()
    $P524 = "block_immediate"($P523)
    $P519."push"($P524)
  if_516_end:
.annotate 'line', 161
    new $P545, 'ExceptionHandler'
    set_label $P545, loop544_handler
    $P545."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P545
  loop544_test:
    find_lex $P525, "$count"
    set $N526, $P525
    isgt $I527, $N526, 0.0
    unless $I527, loop544_done
  loop544_redo:
    .const 'Sub' $P529 = "39_1297619360.562" 
    capture_lex $P529
    $P529()
  loop544_next:
    goto loop544_test
  loop544_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P546, exception, 'type'
    eq $P546, .CONTROL_LOOP_NEXT, loop544_next
    eq $P546, .CONTROL_LOOP_REDO, loop544_redo
  loop544_done:
    pop_eh 
.annotate 'line', 167
    find_lex $P547, "$/"
    find_lex $P548, "$past"
    $P549 = $P547."!make"($P548)
.annotate 'line', 154
    .return ($P549)
.end


.namespace ["NQP";"Actions"]
.sub "_block528"  :anon :subid("39_1297619360.562") :outer("38_1297619360.562")
.annotate 'line', 163
    new $P530, "Undef"
    .lex "$else", $P530
.annotate 'line', 161
    find_lex $P531, "$count"
    clone $P532, $P531
    dec $P531
.annotate 'line', 163
    find_lex $P533, "$past"
    store_lex "$else", $P533
.annotate 'line', 164
    find_lex $P534, "$count"
    set $I535, $P534
    find_lex $P536, "$/"
    unless_null $P536, vivify_268
    $P536 = root_new ['parrot';'Hash']
  vivify_268:
    set $P537, $P536["xblock"]
    unless_null $P537, vivify_269
    $P537 = root_new ['parrot';'ResizablePMCArray']
  vivify_269:
    set $P538, $P537[$I535]
    unless_null $P538, vivify_270
    new $P538, "Undef"
  vivify_270:
    $P539 = $P538."ast"()
    $P540 = "xblock_immediate"($P539)
    store_lex "$past", $P540
.annotate 'line', 165
    find_lex $P541, "$past"
    find_lex $P542, "$else"
    $P543 = $P541."push"($P542)
.annotate 'line', 161
    .return ($P543)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("40_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_551
    .param pmc param_552
.annotate 'line', 170
    .lex "self", param_551
    .lex "$/", param_552
.annotate 'line', 171
    new $P553, "Undef"
    .lex "$past", $P553
    find_lex $P554, "$/"
    unless_null $P554, vivify_271
    $P554 = root_new ['parrot';'Hash']
  vivify_271:
    set $P555, $P554["xblock"]
    unless_null $P555, vivify_272
    new $P555, "Undef"
  vivify_272:
    $P556 = $P555."ast"()
    $P557 = "xblock_immediate"($P556)
    store_lex "$past", $P557
.annotate 'line', 172
    find_lex $P558, "$past"
    $P558."pasttype"("unless")
.annotate 'line', 173
    find_lex $P559, "$/"
    find_lex $P560, "$past"
    $P561 = $P559."!make"($P560)
.annotate 'line', 170
    .return ($P561)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("41_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_563
    .param pmc param_564
.annotate 'line', 176
    .lex "self", param_563
    .lex "$/", param_564
.annotate 'line', 177
    new $P565, "Undef"
    .lex "$past", $P565
    find_lex $P566, "$/"
    unless_null $P566, vivify_273
    $P566 = root_new ['parrot';'Hash']
  vivify_273:
    set $P567, $P566["xblock"]
    unless_null $P567, vivify_274
    new $P567, "Undef"
  vivify_274:
    $P568 = $P567."ast"()
    $P569 = "xblock_immediate"($P568)
    store_lex "$past", $P569
.annotate 'line', 178
    find_lex $P570, "$past"
    find_lex $P571, "$/"
    unless_null $P571, vivify_275
    $P571 = root_new ['parrot';'Hash']
  vivify_275:
    set $P572, $P571["sym"]
    unless_null $P572, vivify_276
    new $P572, "Undef"
  vivify_276:
    set $S573, $P572
    $P570."pasttype"($S573)
.annotate 'line', 179
    find_lex $P574, "$/"
    find_lex $P575, "$past"
    $P576 = $P574."!make"($P575)
.annotate 'line', 176
    .return ($P576)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("42_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_578
    .param pmc param_579
.annotate 'line', 182
    .lex "self", param_578
    .lex "$/", param_579
.annotate 'line', 183
    new $P580, "Undef"
    .lex "$pasttype", $P580
.annotate 'line', 184
    new $P581, "Undef"
    .lex "$past", $P581
.annotate 'line', 183
    new $P582, "String"
    assign $P582, "repeat_"
    find_lex $P583, "$/"
    unless_null $P583, vivify_277
    $P583 = root_new ['parrot';'Hash']
  vivify_277:
    set $P584, $P583["wu"]
    unless_null $P584, vivify_278
    new $P584, "Undef"
  vivify_278:
    set $S585, $P584
    concat $P586, $P582, $S585
    store_lex "$pasttype", $P586
    find_lex $P587, "$past"
.annotate 'line', 185
    find_lex $P589, "$/"
    unless_null $P589, vivify_279
    $P589 = root_new ['parrot';'Hash']
  vivify_279:
    set $P590, $P589["xblock"]
    unless_null $P590, vivify_280
    new $P590, "Undef"
  vivify_280:
    if $P590, if_588
.annotate 'line', 190
    get_hll_global $P597, ["PAST"], "Op"
    find_lex $P598, "$/"
    unless_null $P598, vivify_281
    $P598 = root_new ['parrot';'Hash']
  vivify_281:
    set $P599, $P598["EXPR"]
    unless_null $P599, vivify_282
    new $P599, "Undef"
  vivify_282:
    $P600 = $P599."ast"()
    find_lex $P601, "$/"
    unless_null $P601, vivify_283
    $P601 = root_new ['parrot';'Hash']
  vivify_283:
    set $P602, $P601["pblock"]
    unless_null $P602, vivify_284
    new $P602, "Undef"
  vivify_284:
    $P603 = $P602."ast"()
    $P604 = "block_immediate"($P603)
    find_lex $P605, "$pasttype"
    find_lex $P606, "$/"
    $P607 = $P597."new"($P600, $P604, $P605 :named("pasttype"), $P606 :named("node"))
    store_lex "$past", $P607
.annotate 'line', 189
    goto if_588_end
  if_588:
.annotate 'line', 186
    find_lex $P591, "$/"
    unless_null $P591, vivify_285
    $P591 = root_new ['parrot';'Hash']
  vivify_285:
    set $P592, $P591["xblock"]
    unless_null $P592, vivify_286
    new $P592, "Undef"
  vivify_286:
    $P593 = $P592."ast"()
    $P594 = "xblock_immediate"($P593)
    store_lex "$past", $P594
.annotate 'line', 187
    find_lex $P595, "$past"
    find_lex $P596, "$pasttype"
    $P595."pasttype"($P596)
  if_588_end:
.annotate 'line', 193
    find_lex $P608, "$/"
    find_lex $P609, "$past"
    $P610 = $P608."!make"($P609)
.annotate 'line', 182
    .return ($P610)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("43_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_612
    .param pmc param_613
.annotate 'line', 196
    .lex "self", param_612
    .lex "$/", param_613
.annotate 'line', 197
    new $P614, "Undef"
    .lex "$past", $P614
.annotate 'line', 199
    new $P615, "Undef"
    .lex "$block", $P615
.annotate 'line', 197
    find_lex $P616, "$/"
    unless_null $P616, vivify_287
    $P616 = root_new ['parrot';'Hash']
  vivify_287:
    set $P617, $P616["xblock"]
    unless_null $P617, vivify_288
    new $P617, "Undef"
  vivify_288:
    $P618 = $P617."ast"()
    store_lex "$past", $P618
.annotate 'line', 198
    find_lex $P619, "$past"
    $P619."pasttype"("for")
.annotate 'line', 199
    find_lex $P620, "$past"
    unless_null $P620, vivify_289
    $P620 = root_new ['parrot';'ResizablePMCArray']
  vivify_289:
    set $P621, $P620[1]
    unless_null $P621, vivify_290
    new $P621, "Undef"
  vivify_290:
    store_lex "$block", $P621
.annotate 'line', 200
    find_lex $P623, "$block"
    $P624 = $P623."arity"()
    if $P624, unless_622_end
.annotate 'line', 201
    find_lex $P625, "$block"
    unless_null $P625, vivify_291
    $P625 = root_new ['parrot';'ResizablePMCArray']
  vivify_291:
    set $P626, $P625[0]
    unless_null $P626, vivify_292
    new $P626, "Undef"
  vivify_292:
    get_hll_global $P627, ["PAST"], "Var"
    $P628 = $P627."new"("$_" :named("name"), "parameter" :named("scope"))
    $P626."push"($P628)
.annotate 'line', 202
    find_lex $P629, "$block"
    $P629."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 203
    find_lex $P630, "$block"
    $P630."arity"(1)
  unless_622_end:
.annotate 'line', 205
    find_lex $P631, "$block"
    $P631."blocktype"("immediate")
.annotate 'line', 206
    find_lex $P632, "$/"
    find_lex $P633, "$past"
    $P634 = $P632."!make"($P633)
.annotate 'line', 196
    .return ($P634)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("44_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_636
    .param pmc param_637
.annotate 'line', 209
    .lex "self", param_636
    .lex "$/", param_637
.annotate 'line', 210
    new $P638, "Undef"
    .lex "$block", $P638
    find_lex $P639, "$/"
    unless_null $P639, vivify_293
    $P639 = root_new ['parrot';'Hash']
  vivify_293:
    set $P640, $P639["block"]
    unless_null $P640, vivify_294
    new $P640, "Undef"
  vivify_294:
    $P641 = $P640."ast"()
    store_lex "$block", $P641
.annotate 'line', 211
    find_lex $P642, "$/"
    find_lex $P643, "$block"
    "push_block_handler"($P642, $P643)
.annotate 'line', 212
    get_global $P644, "@BLOCK"
    unless_null $P644, vivify_295
    $P644 = root_new ['parrot';'ResizablePMCArray']
  vivify_295:
    set $P645, $P644[0]
    unless_null $P645, vivify_296
    new $P645, "Undef"
  vivify_296:
    $P646 = $P645."handlers"()
    set $P647, $P646[0]
    unless_null $P647, vivify_297
    new $P647, "Undef"
  vivify_297:
    $P647."handle_types_except"("CONTROL")
.annotate 'line', 213
    find_lex $P648, "$/"
    get_hll_global $P649, ["PAST"], "Stmts"
    find_lex $P650, "$/"
    $P651 = $P649."new"($P650 :named("node"))
    $P652 = $P648."!make"($P651)
.annotate 'line', 209
    .return ($P652)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("45_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_654
    .param pmc param_655
.annotate 'line', 216
    .lex "self", param_654
    .lex "$/", param_655
.annotate 'line', 217
    new $P656, "Undef"
    .lex "$block", $P656
    find_lex $P657, "$/"
    unless_null $P657, vivify_298
    $P657 = root_new ['parrot';'Hash']
  vivify_298:
    set $P658, $P657["block"]
    unless_null $P658, vivify_299
    new $P658, "Undef"
  vivify_299:
    $P659 = $P658."ast"()
    store_lex "$block", $P659
.annotate 'line', 218
    find_lex $P660, "$/"
    find_lex $P661, "$block"
    "push_block_handler"($P660, $P661)
.annotate 'line', 219
    get_global $P662, "@BLOCK"
    unless_null $P662, vivify_300
    $P662 = root_new ['parrot';'ResizablePMCArray']
  vivify_300:
    set $P663, $P662[0]
    unless_null $P663, vivify_301
    new $P663, "Undef"
  vivify_301:
    $P664 = $P663."handlers"()
    set $P665, $P664[0]
    unless_null $P665, vivify_302
    new $P665, "Undef"
  vivify_302:
    $P665."handle_types"("CONTROL")
.annotate 'line', 220
    find_lex $P666, "$/"
    get_hll_global $P667, ["PAST"], "Stmts"
    find_lex $P668, "$/"
    $P669 = $P667."new"($P668 :named("node"))
    $P670 = $P666."!make"($P669)
.annotate 'line', 216
    .return ($P670)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("46_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_673
    .param pmc param_674
.annotate 'line', 260
    .lex "self", param_673
    .lex "$/", param_674
.annotate 'line', 261
    new $P675, "Undef"
    .lex "$init_block", $P675
    get_hll_global $P676, ["PAST"], "Block"
    $P677 = $P676."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P677
.annotate 'line', 262
    find_lex $P678, "$init_block"
    $P679 = $P678."loadinit"()
    find_lex $P680, "$/"
    unless_null $P680, vivify_303
    $P680 = root_new ['parrot';'Hash']
  vivify_303:
    set $P681, $P680["blorst"]
    unless_null $P681, vivify_304
    new $P681, "Undef"
  vivify_304:
    $P682 = $P681."ast"()
    $P679."push"($P682)
.annotate 'line', 263
    find_lex $P683, "$/"
    find_lex $P684, "$init_block"
    $P685 = $P683."!make"($P684)
.annotate 'line', 260
    .return ($P685)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("47_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_687
    .param pmc param_688
.annotate 'line', 266
    .lex "self", param_687
    .lex "$/", param_688
.annotate 'line', 267
    new $P689, "Undef"
    .lex "$past", $P689
    find_lex $P690, "$/"
    unless_null $P690, vivify_305
    $P690 = root_new ['parrot';'Hash']
  vivify_305:
    set $P691, $P690["blorst"]
    unless_null $P691, vivify_306
    new $P691, "Undef"
  vivify_306:
    $P692 = $P691."ast"()
    store_lex "$past", $P692
.annotate 'line', 268
    get_hll_global $P694, ["PAST"], "Block"
    find_lex $P695, "$past"
    $P696 = $P694."ACCEPTS"($P695)
    if $P696, unless_693_end
.annotate 'line', 269
    get_hll_global $P697, ["PAST"], "Block"
    find_lex $P698, "$past"
    find_lex $P699, "$/"
    $P700 = $P697."new"($P698, "immediate" :named("blocktype"), $P699 :named("node"))
    store_lex "$past", $P700
  unless_693_end:
.annotate 'line', 271
    find_lex $P702, "$past"
    $P703 = $P702."handlers"()
    if $P703, unless_701_end
.annotate 'line', 272
    find_lex $P704, "$past"
    get_hll_global $P705, ["PAST"], "Control"
.annotate 'line', 274
    get_hll_global $P706, ["PAST"], "Stmts"
.annotate 'line', 275
    get_hll_global $P707, ["PAST"], "Op"
.annotate 'line', 276
    get_hll_global $P708, ["PAST"], "Var"
.annotate 'line', 277
    get_hll_global $P709, ["PAST"], "Var"
    $P710 = $P709."new"("register" :named("scope"), "exception" :named("name"))
    $P711 = $P708."new"($P710, "handled", "keyed" :named("scope"))
.annotate 'line', 276
    $P712 = $P707."new"($P711, 1, "bind" :named("pasttype"))
.annotate 'line', 275
    $P713 = $P706."new"($P712)
.annotate 'line', 274
    $P714 = $P705."new"($P713, "CONTROL" :named("handle_types_except"))
.annotate 'line', 272
    new $P715, "ResizablePMCArray"
    push $P715, $P714
    $P704."handlers"($P715)
  unless_701_end:
.annotate 'line', 286
    find_lex $P716, "$/"
    find_lex $P717, "$past"
    $P718 = $P716."!make"($P717)
.annotate 'line', 266
    .return ($P718)
.end


.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("48_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_720
    .param pmc param_721
.annotate 'line', 289
    .lex "self", param_720
    .lex "$/", param_721
.annotate 'line', 290
    find_lex $P722, "$/"
.annotate 'line', 291
    find_lex $P725, "$/"
    unless_null $P725, vivify_307
    $P725 = root_new ['parrot';'Hash']
  vivify_307:
    set $P726, $P725["block"]
    unless_null $P726, vivify_308
    new $P726, "Undef"
  vivify_308:
    if $P726, if_724
.annotate 'line', 292
    find_lex $P731, "$/"
    unless_null $P731, vivify_309
    $P731 = root_new ['parrot';'Hash']
  vivify_309:
    set $P732, $P731["statement"]
    unless_null $P732, vivify_310
    new $P732, "Undef"
  vivify_310:
    $P733 = $P732."ast"()
    set $P723, $P733
.annotate 'line', 291
    goto if_724_end
  if_724:
    find_lex $P727, "$/"
    unless_null $P727, vivify_311
    $P727 = root_new ['parrot';'Hash']
  vivify_311:
    set $P728, $P727["block"]
    unless_null $P728, vivify_312
    new $P728, "Undef"
  vivify_312:
    $P729 = $P728."ast"()
    $P730 = "block_immediate"($P729)
    set $P723, $P730
  if_724_end:
    $P734 = $P722."!make"($P723)
.annotate 'line', 289
    .return ($P734)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("49_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_736
    .param pmc param_737
.annotate 'line', 297
    .lex "self", param_736
    .lex "$/", param_737
    find_lex $P738, "$/"
    find_lex $P739, "$/"
    unless_null $P739, vivify_313
    $P739 = root_new ['parrot';'Hash']
  vivify_313:
    set $P740, $P739["cond"]
    unless_null $P740, vivify_314
    new $P740, "Undef"
  vivify_314:
    $P741 = $P740."ast"()
    $P742 = $P738."!make"($P741)
    .return ($P742)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("50_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_744
    .param pmc param_745
.annotate 'line', 298
    .lex "self", param_744
    .lex "$/", param_745
    find_lex $P746, "$/"
    find_lex $P747, "$/"
    unless_null $P747, vivify_315
    $P747 = root_new ['parrot';'Hash']
  vivify_315:
    set $P748, $P747["cond"]
    unless_null $P748, vivify_316
    new $P748, "Undef"
  vivify_316:
    $P749 = $P748."ast"()
    $P750 = $P746."!make"($P749)
    .return ($P750)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("51_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_752
    .param pmc param_753
.annotate 'line', 300
    .lex "self", param_752
    .lex "$/", param_753
    find_lex $P754, "$/"
    find_lex $P755, "$/"
    unless_null $P755, vivify_317
    $P755 = root_new ['parrot';'Hash']
  vivify_317:
    set $P756, $P755["cond"]
    unless_null $P756, vivify_318
    new $P756, "Undef"
  vivify_318:
    $P757 = $P756."ast"()
    $P758 = $P754."!make"($P757)
    .return ($P758)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("52_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_760
    .param pmc param_761
.annotate 'line', 301
    .lex "self", param_760
    .lex "$/", param_761
    find_lex $P762, "$/"
    find_lex $P763, "$/"
    unless_null $P763, vivify_319
    $P763 = root_new ['parrot';'Hash']
  vivify_319:
    set $P764, $P763["cond"]
    unless_null $P764, vivify_320
    new $P764, "Undef"
  vivify_320:
    $P765 = $P764."ast"()
    $P766 = $P762."!make"($P765)
    .return ($P766)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("53_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_768
    .param pmc param_769
.annotate 'line', 305
    .lex "self", param_768
    .lex "$/", param_769
    find_lex $P770, "$/"
    find_lex $P771, "$/"
    unless_null $P771, vivify_321
    $P771 = root_new ['parrot';'Hash']
  vivify_321:
    set $P772, $P771["fatarrow"]
    unless_null $P772, vivify_322
    new $P772, "Undef"
  vivify_322:
    $P773 = $P772."ast"()
    $P774 = $P770."!make"($P773)
    .return ($P774)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("54_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_776
    .param pmc param_777
.annotate 'line', 306
    .lex "self", param_776
    .lex "$/", param_777
    find_lex $P778, "$/"
    find_lex $P779, "$/"
    unless_null $P779, vivify_323
    $P779 = root_new ['parrot';'Hash']
  vivify_323:
    set $P780, $P779["colonpair"]
    unless_null $P780, vivify_324
    new $P780, "Undef"
  vivify_324:
    $P781 = $P780."ast"()
    $P782 = $P778."!make"($P781)
    .return ($P782)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("55_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_784
    .param pmc param_785
.annotate 'line', 307
    .lex "self", param_784
    .lex "$/", param_785
    find_lex $P786, "$/"
    find_lex $P787, "$/"
    unless_null $P787, vivify_325
    $P787 = root_new ['parrot';'Hash']
  vivify_325:
    set $P788, $P787["variable"]
    unless_null $P788, vivify_326
    new $P788, "Undef"
  vivify_326:
    $P789 = $P788."ast"()
    $P790 = $P786."!make"($P789)
    .return ($P790)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("56_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_792
    .param pmc param_793
.annotate 'line', 308
    .lex "self", param_792
    .lex "$/", param_793
    find_lex $P794, "$/"
    find_lex $P795, "$/"
    unless_null $P795, vivify_327
    $P795 = root_new ['parrot';'Hash']
  vivify_327:
    set $P796, $P795["package_declarator"]
    unless_null $P796, vivify_328
    new $P796, "Undef"
  vivify_328:
    $P797 = $P796."ast"()
    $P798 = $P794."!make"($P797)
    .return ($P798)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("57_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_800
    .param pmc param_801
.annotate 'line', 309
    .lex "self", param_800
    .lex "$/", param_801
    find_lex $P802, "$/"
    find_lex $P803, "$/"
    unless_null $P803, vivify_329
    $P803 = root_new ['parrot';'Hash']
  vivify_329:
    set $P804, $P803["scope_declarator"]
    unless_null $P804, vivify_330
    new $P804, "Undef"
  vivify_330:
    $P805 = $P804."ast"()
    $P806 = $P802."!make"($P805)
    .return ($P806)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("58_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_808
    .param pmc param_809
.annotate 'line', 310
    .lex "self", param_808
    .lex "$/", param_809
    find_lex $P810, "$/"
    find_lex $P811, "$/"
    unless_null $P811, vivify_331
    $P811 = root_new ['parrot';'Hash']
  vivify_331:
    set $P812, $P811["routine_declarator"]
    unless_null $P812, vivify_332
    new $P812, "Undef"
  vivify_332:
    $P813 = $P812."ast"()
    $P814 = $P810."!make"($P813)
    .return ($P814)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("59_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_816
    .param pmc param_817
.annotate 'line', 311
    .lex "self", param_816
    .lex "$/", param_817
    find_lex $P818, "$/"
    find_lex $P819, "$/"
    unless_null $P819, vivify_333
    $P819 = root_new ['parrot';'Hash']
  vivify_333:
    set $P820, $P819["regex_declarator"]
    unless_null $P820, vivify_334
    new $P820, "Undef"
  vivify_334:
    $P821 = $P820."ast"()
    $P822 = $P818."!make"($P821)
    .return ($P822)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("60_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_824
    .param pmc param_825
.annotate 'line', 312
    .lex "self", param_824
    .lex "$/", param_825
    find_lex $P826, "$/"
    find_lex $P827, "$/"
    unless_null $P827, vivify_335
    $P827 = root_new ['parrot';'Hash']
  vivify_335:
    set $P828, $P827["statement_prefix"]
    unless_null $P828, vivify_336
    new $P828, "Undef"
  vivify_336:
    $P829 = $P828."ast"()
    $P830 = $P826."!make"($P829)
    .return ($P830)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("61_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_832
    .param pmc param_833
.annotate 'line', 313
    .lex "self", param_832
    .lex "$/", param_833
    find_lex $P834, "$/"
    find_lex $P835, "$/"
    unless_null $P835, vivify_337
    $P835 = root_new ['parrot';'Hash']
  vivify_337:
    set $P836, $P835["pblock"]
    unless_null $P836, vivify_338
    new $P836, "Undef"
  vivify_338:
    $P837 = $P836."ast"()
    $P838 = $P834."!make"($P837)
    .return ($P838)
.end


.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("62_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_840
    .param pmc param_841
.annotate 'line', 315
    .lex "self", param_840
    .lex "$/", param_841
.annotate 'line', 316
    new $P842, "Undef"
    .lex "$past", $P842
    find_lex $P843, "$/"
    unless_null $P843, vivify_339
    $P843 = root_new ['parrot';'Hash']
  vivify_339:
    set $P844, $P843["val"]
    unless_null $P844, vivify_340
    new $P844, "Undef"
  vivify_340:
    $P845 = $P844."ast"()
    store_lex "$past", $P845
.annotate 'line', 317
    find_lex $P846, "$past"
    find_lex $P847, "$/"
    unless_null $P847, vivify_341
    $P847 = root_new ['parrot';'Hash']
  vivify_341:
    set $P848, $P847["key"]
    unless_null $P848, vivify_342
    new $P848, "Undef"
  vivify_342:
    $P849 = $P848."Str"()
    $P846."named"($P849)
.annotate 'line', 318
    find_lex $P850, "$/"
    find_lex $P851, "$past"
    $P852 = $P850."!make"($P851)
.annotate 'line', 315
    .return ($P852)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("63_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_854
    .param pmc param_855
.annotate 'line', 321
    .lex "self", param_854
    .lex "$/", param_855
.annotate 'line', 322
    new $P856, "Undef"
    .lex "$past", $P856
.annotate 'line', 323
    find_lex $P859, "$/"
    unless_null $P859, vivify_343
    $P859 = root_new ['parrot';'Hash']
  vivify_343:
    set $P860, $P859["circumfix"]
    unless_null $P860, vivify_344
    new $P860, "Undef"
  vivify_344:
    if $P860, if_858
.annotate 'line', 324
    get_hll_global $P865, ["PAST"], "Val"
    find_lex $P866, "$/"
    unless_null $P866, vivify_345
    $P866 = root_new ['parrot';'Hash']
  vivify_345:
    set $P867, $P866["not"]
    unless_null $P867, vivify_346
    new $P867, "Undef"
  vivify_346:
    isfalse $I868, $P867
    $P869 = $P865."new"($I868 :named("value"))
    set $P857, $P869
.annotate 'line', 323
    goto if_858_end
  if_858:
    find_lex $P861, "$/"
    unless_null $P861, vivify_347
    $P861 = root_new ['parrot';'Hash']
  vivify_347:
    set $P862, $P861["circumfix"]
    unless_null $P862, vivify_348
    $P862 = root_new ['parrot';'ResizablePMCArray']
  vivify_348:
    set $P863, $P862[0]
    unless_null $P863, vivify_349
    new $P863, "Undef"
  vivify_349:
    $P864 = $P863."ast"()
    set $P857, $P864
  if_858_end:
    store_lex "$past", $P857
.annotate 'line', 325
    find_lex $P870, "$past"
    find_lex $P871, "$/"
    unless_null $P871, vivify_350
    $P871 = root_new ['parrot';'Hash']
  vivify_350:
    set $P872, $P871["identifier"]
    unless_null $P872, vivify_351
    new $P872, "Undef"
  vivify_351:
    set $S873, $P872
    $P870."named"($S873)
.annotate 'line', 326
    find_lex $P874, "$/"
    find_lex $P875, "$past"
    $P876 = $P874."!make"($P875)
.annotate 'line', 321
    .return ($P876)
.end


.namespace ["NQP";"Actions"]
.sub "variable"  :subid("64_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_878
    .param pmc param_879
.annotate 'line', 329
    .const 'Sub' $P892 = "65_1297619360.562" 
    capture_lex $P892
    .lex "self", param_878
    .lex "$/", param_879
.annotate 'line', 330
    new $P880, "Undef"
    .lex "$past", $P880
.annotate 'line', 329
    find_lex $P881, "$past"
.annotate 'line', 331
    find_lex $P883, "$/"
    unless_null $P883, vivify_352
    $P883 = root_new ['parrot';'Hash']
  vivify_352:
    set $P884, $P883["postcircumfix"]
    unless_null $P884, vivify_353
    new $P884, "Undef"
  vivify_353:
    if $P884, if_882
.annotate 'line', 335
    .const 'Sub' $P892 = "65_1297619360.562" 
    capture_lex $P892
    $P892()
    goto if_882_end
  if_882:
.annotate 'line', 332
    find_lex $P885, "$/"
    unless_null $P885, vivify_370
    $P885 = root_new ['parrot';'Hash']
  vivify_370:
    set $P886, $P885["postcircumfix"]
    unless_null $P886, vivify_371
    new $P886, "Undef"
  vivify_371:
    $P887 = $P886."ast"()
    store_lex "$past", $P887
.annotate 'line', 333
    find_lex $P888, "$past"
    get_hll_global $P889, ["PAST"], "Var"
    $P890 = $P889."new"("$/" :named("name"))
    $P888."unshift"($P890)
  if_882_end:
.annotate 'line', 365
    find_lex $P964, "$/"
    find_lex $P965, "$past"
    $P966 = $P964."!make"($P965)
.annotate 'line', 329
    .return ($P966)
.end


.namespace ["NQP";"Actions"]
.sub "_block891"  :anon :subid("65_1297619360.562") :outer("64_1297619360.562")
.annotate 'line', 336
    $P893 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P893
    get_hll_global $P894, ["NQP"], "Compiler"
    find_lex $P895, "$/"
    set $S896, $P895
    $P897 = $P894."parse_name"($S896)
    store_lex "@name", $P897
.annotate 'line', 337
    get_hll_global $P898, ["PAST"], "Var"
    find_lex $P899, "@name"
    $P900 = $P899."pop"()
    set $S901, $P900
    $P902 = $P898."new"($S901 :named("name"))
    store_lex "$past", $P902
.annotate 'line', 338
    find_lex $P904, "@name"
    unless $P904, if_903_end
.annotate 'line', 339
    find_lex $P906, "@name"
    unless_null $P906, vivify_354
    $P906 = root_new ['parrot';'ResizablePMCArray']
  vivify_354:
    set $P907, $P906[0]
    unless_null $P907, vivify_355
    new $P907, "Undef"
  vivify_355:
    set $S908, $P907
    iseq $I909, $S908, "GLOBAL"
    unless $I909, if_905_end
    find_lex $P910, "@name"
    $P910."shift"()
  if_905_end:
.annotate 'line', 340
    find_lex $P911, "$past"
    find_lex $P912, "@name"
    $P911."namespace"($P912)
.annotate 'line', 341
    find_lex $P913, "$past"
    $P913."scope"("package")
.annotate 'line', 342
    find_lex $P914, "$past"
    find_lex $P915, "$/"
    unless_null $P915, vivify_356
    $P915 = root_new ['parrot';'Hash']
  vivify_356:
    set $P916, $P915["sigil"]
    unless_null $P916, vivify_357
    new $P916, "Undef"
  vivify_357:
    $P917 = "vivitype"($P916)
    $P914."viviself"($P917)
.annotate 'line', 343
    find_lex $P918, "$past"
    $P918."lvalue"(1)
  if_903_end:
.annotate 'line', 345
    find_lex $P921, "$/"
    unless_null $P921, vivify_358
    $P921 = root_new ['parrot';'Hash']
  vivify_358:
    set $P922, $P921["twigil"]
    unless_null $P922, vivify_359
    $P922 = root_new ['parrot';'ResizablePMCArray']
  vivify_359:
    set $P923, $P922[0]
    unless_null $P923, vivify_360
    new $P923, "Undef"
  vivify_360:
    set $S924, $P923
    iseq $I925, $S924, "*"
    if $I925, if_920
.annotate 'line', 358
    find_lex $P947, "$/"
    unless_null $P947, vivify_361
    $P947 = root_new ['parrot';'Hash']
  vivify_361:
    set $P948, $P947["twigil"]
    unless_null $P948, vivify_362
    $P948 = root_new ['parrot';'ResizablePMCArray']
  vivify_362:
    set $P949, $P948[0]
    unless_null $P949, vivify_363
    new $P949, "Undef"
  vivify_363:
    set $S950, $P949
    iseq $I951, $S950, "!"
    if $I951, if_946
    new $P945, 'Integer'
    set $P945, $I951
    goto if_946_end
  if_946:
.annotate 'line', 359
    find_lex $P952, "$past"
    get_hll_global $P953, ["PAST"], "Var"
    $P954 = $P953."new"("self" :named("name"))
    $P952."push"($P954)
.annotate 'line', 360
    find_lex $P955, "$past"
    $P955."scope"("attribute")
.annotate 'line', 361
    find_lex $P956, "$past"
    find_lex $P957, "$/"
    unless_null $P957, vivify_364
    $P957 = root_new ['parrot';'Hash']
  vivify_364:
    set $P958, $P957["sigil"]
    unless_null $P958, vivify_365
    new $P958, "Undef"
  vivify_365:
    $P959 = "vivitype"($P958)
    $P956."viviself"($P959)
.annotate 'line', 362
    find_lex $P960, "$past"
    get_hll_global $P961, ["PAST"], "Var"
    $P962 = $P961."new"("$?CLASS" :named("name"))
    $P963 = $P960."push"($P962)
.annotate 'line', 358
    set $P945, $P963
  if_946_end:
    set $P919, $P945
.annotate 'line', 345
    goto if_920_end
  if_920:
.annotate 'line', 346
    find_lex $P926, "$past"
    $P926."scope"("contextual")
.annotate 'line', 347
    find_lex $P927, "$past"
.annotate 'line', 348
    get_hll_global $P928, ["PAST"], "Var"
.annotate 'line', 350
    find_lex $P929, "$/"
    unless_null $P929, vivify_366
    $P929 = root_new ['parrot';'Hash']
  vivify_366:
    set $P930, $P929["sigil"]
    unless_null $P930, vivify_367
    new $P930, "Undef"
  vivify_367:
    set $S931, $P930
    new $P932, 'String'
    set $P932, $S931
    find_lex $P933, "$/"
    unless_null $P933, vivify_368
    $P933 = root_new ['parrot';'Hash']
  vivify_368:
    set $P934, $P933["desigilname"]
    unless_null $P934, vivify_369
    new $P934, "Undef"
  vivify_369:
    concat $P935, $P932, $P934
.annotate 'line', 352
    get_hll_global $P936, ["PAST"], "Op"
    new $P937, "String"
    assign $P937, "Contextual "
    find_lex $P938, "$/"
    set $S939, $P938
    concat $P940, $P937, $S939
    concat $P941, $P940, " not found"
    $P942 = $P936."new"($P941, "die" :named("pirop"))
    $P943 = $P928."new"("package" :named("scope"), "" :named("namespace"), $P935 :named("name"), $P942 :named("viviself"))
.annotate 'line', 348
    $P944 = $P927."viviself"($P943)
.annotate 'line', 345
    set $P919, $P944
  if_920_end:
.annotate 'line', 335
    .return ($P919)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("66_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_968
    .param pmc param_969
.annotate 'line', 368
    .lex "self", param_968
    .lex "$/", param_969
    find_lex $P970, "$/"
    find_lex $P971, "$/"
    unless_null $P971, vivify_372
    $P971 = root_new ['parrot';'Hash']
  vivify_372:
    set $P972, $P971["package_def"]
    unless_null $P972, vivify_373
    new $P972, "Undef"
  vivify_373:
    $P973 = $P972."ast"()
    $P974 = $P970."!make"($P973)
    .return ($P974)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("67_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_976
    .param pmc param_977
.annotate 'line', 369
    .lex "self", param_976
    .lex "$/", param_977
    find_lex $P978, "$/"
    find_lex $P979, "$/"
    unless_null $P979, vivify_374
    $P979 = root_new ['parrot';'Hash']
  vivify_374:
    set $P980, $P979["package_def"]
    unless_null $P980, vivify_375
    new $P980, "Undef"
  vivify_375:
    $P981 = $P980."ast"()
    $P982 = $P978."!make"($P981)
    .return ($P982)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("68_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_984
    .param pmc param_985
.annotate 'line', 370
    .lex "self", param_984
    .lex "$/", param_985
    find_lex $P986, "$/"
    find_lex $P987, "$/"
    unless_null $P987, vivify_376
    $P987 = root_new ['parrot';'Hash']
  vivify_376:
    set $P988, $P987["package_def"]
    unless_null $P988, vivify_377
    new $P988, "Undef"
  vivify_377:
    $P989 = $P988."ast"()
    $P990 = $P986."!make"($P989)
    .return ($P990)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("69_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_992
    .param pmc param_993
.annotate 'line', 371
    .lex "self", param_992
    .lex "$/", param_993
    find_lex $P994, "$/"
    find_lex $P995, "$/"
    unless_null $P995, vivify_378
    $P995 = root_new ['parrot';'Hash']
  vivify_378:
    set $P996, $P995["package_def"]
    unless_null $P996, vivify_379
    new $P996, "Undef"
  vivify_379:
    $P997 = $P996."ast"()
    $P998 = $P994."!make"($P997)
    .return ($P998)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("70_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1000
    .param pmc param_1001
.annotate 'line', 372
    .lex "self", param_1000
    .lex "$/", param_1001
    find_lex $P1002, "$/"
    find_lex $P1003, "$/"
    unless_null $P1003, vivify_380
    $P1003 = root_new ['parrot';'Hash']
  vivify_380:
    set $P1004, $P1003["package_def"]
    unless_null $P1004, vivify_381
    new $P1004, "Undef"
  vivify_381:
    $P1005 = $P1004."ast"()
    $P1006 = $P1002."!make"($P1005)
    .return ($P1006)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("71_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1008
    .param pmc param_1009
.annotate 'line', 373
    .lex "self", param_1008
    .lex "$/", param_1009
    find_lex $P1010, "$/"
    find_lex $P1011, "$/"
    unless_null $P1011, vivify_382
    $P1011 = root_new ['parrot';'Hash']
  vivify_382:
    set $P1012, $P1011["package_def"]
    unless_null $P1012, vivify_383
    new $P1012, "Undef"
  vivify_383:
    $P1013 = $P1012."ast"()
    $P1014 = $P1010."!make"($P1013)
    .return ($P1014)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("72_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1016
    .param pmc param_1017
.annotate 'line', 375
    .const 'Sub' $P1176 = "75_1297619360.562" 
    capture_lex $P1176
    .const 'Sub' $P1125 = "74_1297619360.562" 
    capture_lex $P1125
    .const 'Sub' $P1083 = "73_1297619360.562" 
    capture_lex $P1083
    .lex "self", param_1016
    .lex "$/", param_1017
.annotate 'line', 377
    $P1018 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1018
.annotate 'line', 378
    new $P1019, "Undef"
    .lex "$name", $P1019
.annotate 'line', 379
    new $P1020, "Undef"
    .lex "$how", $P1020
.annotate 'line', 382
    new $P1021, "Undef"
    .lex "$past", $P1021
.annotate 'line', 377
    find_lex $P1022, "$/"
    unless_null $P1022, vivify_384
    $P1022 = root_new ['parrot';'Hash']
  vivify_384:
    set $P1023, $P1022["name"]
    unless_null $P1023, vivify_385
    $P1023 = root_new ['parrot';'Hash']
  vivify_385:
    set $P1024, $P1023["identifier"]
    unless_null $P1024, vivify_386
    new $P1024, "Undef"
  vivify_386:
    clone $P1025, $P1024
    store_lex "@ns", $P1025
.annotate 'line', 378
    find_lex $P1026, "@ns"
    $P1027 = $P1026."pop"()
    set $S1028, $P1027
    new $P1029, 'String'
    set $P1029, $S1028
    store_lex "$name", $P1029
.annotate 'line', 379
    find_dynamic_lex $P1030, "$*PKGDECL"
    unless_null $P1030, vivify_387
    get_hll_global $P1030, "$PKGDECL"
    unless_null $P1030, vivify_388
    die "Contextual $*PKGDECL not found"
  vivify_388:
  vivify_387:
    find_dynamic_lex $P1031, "%*HOW"
    unless_null $P1031, vivify_389
    get_hll_global $P1031, "%HOW"
    unless_null $P1031, vivify_390
    die "Contextual %*HOW not found"
  vivify_390:
  vivify_389:
    set $P1032, $P1031[$P1030]
    unless_null $P1032, vivify_391
    new $P1032, "Undef"
  vivify_391:
    store_lex "$how", $P1032
.annotate 'line', 382
    find_lex $P1035, "$/"
    unless_null $P1035, vivify_392
    $P1035 = root_new ['parrot';'Hash']
  vivify_392:
    set $P1036, $P1035["block"]
    unless_null $P1036, vivify_393
    new $P1036, "Undef"
  vivify_393:
    if $P1036, if_1034
    find_lex $P1040, "$/"
    unless_null $P1040, vivify_394
    $P1040 = root_new ['parrot';'Hash']
  vivify_394:
    set $P1041, $P1040["comp_unit"]
    unless_null $P1041, vivify_395
    new $P1041, "Undef"
  vivify_395:
    $P1042 = $P1041."ast"()
    set $P1033, $P1042
    goto if_1034_end
  if_1034:
    find_lex $P1037, "$/"
    unless_null $P1037, vivify_396
    $P1037 = root_new ['parrot';'Hash']
  vivify_396:
    set $P1038, $P1037["block"]
    unless_null $P1038, vivify_397
    new $P1038, "Undef"
  vivify_397:
    $P1039 = $P1038."ast"()
    set $P1033, $P1039
  if_1034_end:
    store_lex "$past", $P1033
.annotate 'line', 383
    find_lex $P1043, "$past"
    find_lex $P1044, "$/"
    unless_null $P1044, vivify_398
    $P1044 = root_new ['parrot';'Hash']
  vivify_398:
    set $P1045, $P1044["name"]
    unless_null $P1045, vivify_399
    $P1045 = root_new ['parrot';'Hash']
  vivify_399:
    set $P1046, $P1045["identifier"]
    unless_null $P1046, vivify_400
    new $P1046, "Undef"
  vivify_400:
    $P1043."namespace"($P1046)
.annotate 'line', 387
    find_dynamic_lex $P1047, "$*PACKAGE-SETUP"
    unless_null $P1047, vivify_401
    get_hll_global $P1047, "$PACKAGE-SETUP"
    unless_null $P1047, vivify_402
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_402:
  vivify_401:
    get_hll_global $P1048, ["PAST"], "Stmts"
.annotate 'line', 388
    get_hll_global $P1049, ["PAST"], "Op"
.annotate 'line', 389
    get_hll_global $P1050, ["PAST"], "Var"
    $P1051 = $P1050."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 390
    get_hll_global $P1052, ["PAST"], "Op"
.annotate 'line', 392
    get_hll_global $P1053, ["PAST"], "Var"
    find_lex $P1054, "$how"
    get_how $P1055, $P1054
    find_lex $P1056, "$how"
    $P1057 = $P1055."name"($P1056)
    $P1058 = $P1053."new"($P1057 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 393
    get_hll_global $P1059, ["PAST"], "Val"
    find_lex $P1060, "$name"
    $P1061 = $P1059."new"($P1060 :named("value"), "name" :named("named"))
    $P1062 = $P1052."new"($P1058, $P1061, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 390
    $P1063 = $P1049."new"($P1051, $P1062, "bind" :named("pasttype"))
.annotate 'line', 396
    get_hll_global $P1064, ["PAST"], "Op"
.annotate 'line', 397
    get_hll_global $P1065, ["PAST"], "Var"
    find_lex $P1066, "$name"
    find_lex $P1067, "@ns"
    $P1068 = $P1065."new"($P1066 :named("name"), $P1067 :named("namespace"), "package" :named("scope"))
.annotate 'line', 398
    get_hll_global $P1069, ["PAST"], "Var"
    $P1070 = $P1069."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1071 = $P1064."new"($P1068, $P1070, "bind" :named("pasttype"))
.annotate 'line', 400
    get_hll_global $P1072, ["PAST"], "Op"
.annotate 'line', 401
    get_hll_global $P1073, ["PAST"], "Var"
    $P1074 = $P1073."new"("$?CLASS" :named("name"))
.annotate 'line', 402
    get_hll_global $P1075, ["PAST"], "Var"
    $P1076 = $P1075."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1077 = $P1072."new"($P1074, $P1076, "bind" :named("pasttype"))
.annotate 'line', 400
    $P1078 = $P1048."new"($P1063, $P1071, $P1077)
.annotate 'line', 387
    $P1047."unshift"($P1078)
.annotate 'line', 407
    find_lex $P1080, "$/"
    unless_null $P1080, vivify_403
    $P1080 = root_new ['parrot';'Hash']
  vivify_403:
    set $P1081, $P1080["repr"]
    unless_null $P1081, vivify_404
    new $P1081, "Undef"
  vivify_404:
    unless $P1081, if_1079_end
    .const 'Sub' $P1083 = "73_1297619360.562" 
    capture_lex $P1083
    $P1083()
  if_1079_end:
.annotate 'line', 418
    find_lex $P1099, "$how"
    can $I1100, $P1099, "parametric"
    if $I1100, if_1098
    new $P1097, 'Integer'
    set $P1097, $I1100
    goto if_1098_end
  if_1098:
    find_lex $P1101, "$how"
    find_lex $P1102, "$how"
    $P1103 = $P1101."parametric"($P1102)
    set $P1097, $P1103
  if_1098_end:
    if $P1097, if_1096
.annotate 'line', 425
    find_lex $P1116, "$past"
    $P1116."blocktype"("immediate")
.annotate 'line', 426
    find_lex $P1117, "$past"
    get_hll_global $P1118, ["PAST"], "Var"
    $P1119 = $P1118."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P1117."unshift"($P1119)
.annotate 'line', 427
    find_lex $P1120, "$past"
    $P1120."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 424
    goto if_1096_end
  if_1096:
.annotate 'line', 419
    find_lex $P1104, "$past"
    $P1104."blocktype"("declaration")
.annotate 'line', 420
    find_lex $P1105, "$past"
    get_hll_global $P1106, ["PAST"], "Var"
    $P1107 = $P1106."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P1105."unshift"($P1107)
.annotate 'line', 421
    find_lex $P1108, "$past"
    $P1108."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 422
    find_dynamic_lex $P1109, "$*PACKAGE-SETUP"
    unless_null $P1109, vivify_413
    get_hll_global $P1109, "$PACKAGE-SETUP"
    unless_null $P1109, vivify_414
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_414:
  vivify_413:
    set $P1110, $P1109[0]
    unless_null $P1110, vivify_415
    $P1110 = root_new ['parrot';'ResizablePMCArray']
  vivify_415:
    set $P1111, $P1110[0]
    unless_null $P1111, vivify_416
    $P1111 = root_new ['parrot';'ResizablePMCArray']
  vivify_416:
    set $P1112, $P1111[1]
    unless_null $P1112, vivify_417
    new $P1112, "Undef"
  vivify_417:
    get_hll_global $P1113, ["PAST"], "Val"
    find_lex $P1114, "$past"
    $P1115 = $P1113."new"($P1114 :named("value"), "body_block" :named("named"))
    $P1112."push"($P1115)
  if_1096_end:
.annotate 'line', 432
    find_lex $P1122, "$/"
    unless_null $P1122, vivify_418
    $P1122 = root_new ['parrot';'Hash']
  vivify_418:
    set $P1123, $P1122["parent"]
    unless_null $P1123, vivify_419
    new $P1123, "Undef"
  vivify_419:
    if $P1123, if_1121
.annotate 'line', 446
    find_dynamic_lex $P1153, "$*PKGDECL"
    unless_null $P1153, vivify_420
    get_hll_global $P1153, "$PKGDECL"
    unless_null $P1153, vivify_421
    die "Contextual $*PKGDECL not found"
  vivify_421:
  vivify_420:
    set $S1154, $P1153
    iseq $I1155, $S1154, "grammar"
    unless $I1155, if_1152_end
.annotate 'line', 447
    find_dynamic_lex $P1156, "$*PACKAGE-SETUP"
    unless_null $P1156, vivify_422
    get_hll_global $P1156, "$PACKAGE-SETUP"
    unless_null $P1156, vivify_423
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_423:
  vivify_422:
    get_hll_global $P1157, ["PAST"], "Op"
.annotate 'line', 449
    get_hll_global $P1158, ["PAST"], "Op"
.annotate 'line', 452
    get_hll_global $P1159, ["PAST"], "Var"
    $P1160 = $P1159."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1161 = $P1158."new"($P1160, "get_how PP" :named("pirop"))
.annotate 'line', 454
    get_hll_global $P1162, ["PAST"], "Var"
    $P1163 = $P1162."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 455
    get_hll_global $P1164, ["PAST"], "Var"
    $P1165 = $P1164."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P1166 = $P1157."new"($P1161, $P1163, $P1165, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 447
    $P1156."push"($P1166)
  if_1152_end:
.annotate 'line', 446
    goto if_1121_end
  if_1121:
.annotate 'line', 432
    .const 'Sub' $P1125 = "74_1297619360.562" 
    capture_lex $P1125
    $P1125()
  if_1121_end:
.annotate 'line', 460
    find_lex $P1168, "$/"
    unless_null $P1168, vivify_430
    $P1168 = root_new ['parrot';'Hash']
  vivify_430:
    set $P1169, $P1168["role"]
    unless_null $P1169, vivify_431
    new $P1169, "Undef"
  vivify_431:
    unless $P1169, if_1167_end
.annotate 'line', 461
    find_lex $P1171, "$/"
    unless_null $P1171, vivify_432
    $P1171 = root_new ['parrot';'Hash']
  vivify_432:
    set $P1172, $P1171["role"]
    unless_null $P1172, vivify_433
    new $P1172, "Undef"
  vivify_433:
    defined $I1173, $P1172
    unless $I1173, for_undef_434
    iter $P1170, $P1172
    new $P1203, 'ExceptionHandler'
    set_label $P1203, loop1202_handler
    $P1203."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1203
  loop1202_test:
    unless $P1170, loop1202_done
    shift $P1174, $P1170
  loop1202_redo:
    .const 'Sub' $P1176 = "75_1297619360.562" 
    capture_lex $P1176
    $P1176($P1174)
  loop1202_next:
    goto loop1202_test
  loop1202_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1204, exception, 'type'
    eq $P1204, .CONTROL_LOOP_NEXT, loop1202_next
    eq $P1204, .CONTROL_LOOP_REDO, loop1202_redo
  loop1202_done:
    pop_eh 
  for_undef_434:
  if_1167_end:
.annotate 'line', 478
    find_dynamic_lex $P1205, "$*PACKAGE-SETUP"
    unless_null $P1205, vivify_439
    get_hll_global $P1205, "$PACKAGE-SETUP"
    unless_null $P1205, vivify_440
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_440:
  vivify_439:
    get_hll_global $P1206, ["PAST"], "Op"
.annotate 'line', 480
    get_hll_global $P1207, ["PAST"], "Op"
.annotate 'line', 483
    get_hll_global $P1208, ["PAST"], "Var"
    $P1209 = $P1208."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1210 = $P1207."new"($P1209, "get_how PP" :named("pirop"))
.annotate 'line', 485
    get_hll_global $P1211, ["PAST"], "Var"
    $P1212 = $P1211."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1213 = $P1206."new"($P1210, $P1212, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 478
    $P1205."push"($P1213)
.annotate 'line', 489
    get_global $P1214, "@BLOCK"
    unless_null $P1214, vivify_441
    $P1214 = root_new ['parrot';'ResizablePMCArray']
  vivify_441:
    set $P1215, $P1214[0]
    unless_null $P1215, vivify_442
    $P1215 = root_new ['parrot';'ResizablePMCArray']
  vivify_442:
    set $P1216, $P1215[0]
    unless_null $P1216, vivify_443
    new $P1216, "Undef"
  vivify_443:
    get_hll_global $P1217, ["PAST"], "Var"
    find_lex $P1218, "$name"
    find_lex $P1219, "@ns"
    $P1220 = $P1217."new"($P1218 :named("name"), $P1219 :named("namespace"), "package" :named("scope"), 1 :named("isdecl"))
    $P1216."unshift"($P1220)
.annotate 'line', 492
    find_lex $P1221, "$past"
    $P1222 = $P1221."loadinit"()
    get_hll_global $P1223, ["PAST"], "Block"
    find_dynamic_lex $P1224, "$*PACKAGE-SETUP"
    unless_null $P1224, vivify_444
    get_hll_global $P1224, "$PACKAGE-SETUP"
    unless_null $P1224, vivify_445
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_445:
  vivify_444:
    $P1225 = $P1223."new"($P1224, "immediate" :named("blocktype"))
    $P1222."push"($P1225)
.annotate 'line', 494
    find_lex $P1226, "$/"
    find_lex $P1227, "$past"
    $P1228 = $P1226."!make"($P1227)
.annotate 'line', 375
    .return ($P1228)
.end


.namespace ["NQP";"Actions"]
.sub "_block1082"  :anon :subid("73_1297619360.562") :outer("72_1297619360.562")
.annotate 'line', 408
    new $P1084, "Undef"
    .lex "$repr_name", $P1084
    find_lex $P1085, "$/"
    unless_null $P1085, vivify_405
    $P1085 = root_new ['parrot';'Hash']
  vivify_405:
    set $P1086, $P1085["repr"]
    unless_null $P1086, vivify_406
    $P1086 = root_new ['parrot';'ResizablePMCArray']
  vivify_406:
    set $P1087, $P1086[0]
    unless_null $P1087, vivify_407
    new $P1087, "Undef"
  vivify_407:
    $P1088 = $P1087."ast"()
    store_lex "$repr_name", $P1088
.annotate 'line', 409
    find_lex $P1089, "$repr_name"
    $P1089."named"("repr")
.annotate 'line', 410
    find_dynamic_lex $P1090, "$*PACKAGE-SETUP"
    unless_null $P1090, vivify_408
    get_hll_global $P1090, "$PACKAGE-SETUP"
    unless_null $P1090, vivify_409
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_409:
  vivify_408:
    set $P1091, $P1090[0]
    unless_null $P1091, vivify_410
    $P1091 = root_new ['parrot';'ResizablePMCArray']
  vivify_410:
    set $P1092, $P1091[0]
    unless_null $P1092, vivify_411
    $P1092 = root_new ['parrot';'ResizablePMCArray']
  vivify_411:
    set $P1093, $P1092[1]
    unless_null $P1093, vivify_412
    new $P1093, "Undef"
  vivify_412:
    find_lex $P1094, "$repr_name"
    $P1095 = $P1093."push"($P1094)
.annotate 'line', 407
    .return ($P1095)
.end


.namespace ["NQP";"Actions"]
.sub "_block1124"  :anon :subid("74_1297619360.562") :outer("72_1297619360.562")
.annotate 'line', 433
    $P1126 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1126
.annotate 'line', 434
    new $P1127, "Undef"
    .lex "$name", $P1127
.annotate 'line', 433
    find_lex $P1128, "$/"
    unless_null $P1128, vivify_424
    $P1128 = root_new ['parrot';'Hash']
  vivify_424:
    set $P1129, $P1128["parent"]
    unless_null $P1129, vivify_425
    $P1129 = root_new ['parrot';'ResizablePMCArray']
  vivify_425:
    set $P1130, $P1129[0]
    unless_null $P1130, vivify_426
    $P1130 = root_new ['parrot';'Hash']
  vivify_426:
    set $P1131, $P1130["identifier"]
    unless_null $P1131, vivify_427
    new $P1131, "Undef"
  vivify_427:
    clone $P1132, $P1131
    store_lex "@ns", $P1132
.annotate 'line', 434
    find_lex $P1133, "@ns"
    $P1134 = $P1133."pop"()
    set $S1135, $P1134
    new $P1136, 'String'
    set $P1136, $S1135
    store_lex "$name", $P1136
.annotate 'line', 435
    find_dynamic_lex $P1137, "$*PACKAGE-SETUP"
    unless_null $P1137, vivify_428
    get_hll_global $P1137, "$PACKAGE-SETUP"
    unless_null $P1137, vivify_429
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_429:
  vivify_428:
    get_hll_global $P1138, ["PAST"], "Op"
.annotate 'line', 437
    get_hll_global $P1139, ["PAST"], "Op"
.annotate 'line', 440
    get_hll_global $P1140, ["PAST"], "Var"
    $P1141 = $P1140."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1142 = $P1139."new"($P1141, "get_how PP" :named("pirop"))
.annotate 'line', 442
    get_hll_global $P1143, ["PAST"], "Var"
    $P1144 = $P1143."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 443
    get_hll_global $P1145, ["PAST"], "Var"
    find_lex $P1146, "$name"
    set $S1147, $P1146
    find_lex $P1148, "@ns"
    $P1149 = $P1145."new"($S1147 :named("name"), $P1148 :named("namespace"), "package" :named("scope"))
    $P1150 = $P1138."new"($P1142, $P1144, $P1149, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 435
    $P1151 = $P1137."push"($P1150)
.annotate 'line', 432
    .return ($P1151)
.end


.namespace ["NQP";"Actions"]
.sub "_block1175"  :anon :subid("75_1297619360.562") :outer("72_1297619360.562")
    .param pmc param_1179
.annotate 'line', 462
    $P1177 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1177
.annotate 'line', 463
    new $P1178, "Undef"
    .lex "$name", $P1178
    .lex "$_", param_1179
.annotate 'line', 462
    find_lex $P1180, "$_"
    unless_null $P1180, vivify_435
    $P1180 = root_new ['parrot';'Hash']
  vivify_435:
    set $P1181, $P1180["identifier"]
    unless_null $P1181, vivify_436
    new $P1181, "Undef"
  vivify_436:
    clone $P1182, $P1181
    store_lex "@ns", $P1182
.annotate 'line', 463
    find_lex $P1183, "@ns"
    $P1184 = $P1183."pop"()
    set $S1185, $P1184
    new $P1186, 'String'
    set $P1186, $S1185
    store_lex "$name", $P1186
.annotate 'line', 464
    find_dynamic_lex $P1187, "$*PACKAGE-SETUP"
    unless_null $P1187, vivify_437
    get_hll_global $P1187, "$PACKAGE-SETUP"
    unless_null $P1187, vivify_438
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_438:
  vivify_437:
    get_hll_global $P1188, ["PAST"], "Op"
.annotate 'line', 466
    get_hll_global $P1189, ["PAST"], "Op"
.annotate 'line', 469
    get_hll_global $P1190, ["PAST"], "Var"
    $P1191 = $P1190."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1192 = $P1189."new"($P1191, "get_how PP" :named("pirop"))
.annotate 'line', 471
    get_hll_global $P1193, ["PAST"], "Var"
    $P1194 = $P1193."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 472
    get_hll_global $P1195, ["PAST"], "Var"
    find_lex $P1196, "$name"
    set $S1197, $P1196
    find_lex $P1198, "@ns"
    $P1199 = $P1195."new"($S1197 :named("name"), $P1198 :named("namespace"), "package" :named("scope"))
    $P1200 = $P1188."new"($P1192, $P1194, $P1199, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 464
    $P1201 = $P1187."push"($P1200)
.annotate 'line', 461
    .return ($P1201)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("76_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1230
    .param pmc param_1231
.annotate 'line', 497
    .lex "self", param_1230
    .lex "$/", param_1231
    find_lex $P1232, "$/"
    find_lex $P1233, "$/"
    unless_null $P1233, vivify_446
    $P1233 = root_new ['parrot';'Hash']
  vivify_446:
    set $P1234, $P1233["scoped"]
    unless_null $P1234, vivify_447
    new $P1234, "Undef"
  vivify_447:
    $P1235 = $P1234."ast"()
    $P1236 = $P1232."!make"($P1235)
    .return ($P1236)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("77_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1238
    .param pmc param_1239
.annotate 'line', 498
    .lex "self", param_1238
    .lex "$/", param_1239
    find_lex $P1240, "$/"
    find_lex $P1241, "$/"
    unless_null $P1241, vivify_448
    $P1241 = root_new ['parrot';'Hash']
  vivify_448:
    set $P1242, $P1241["scoped"]
    unless_null $P1242, vivify_449
    new $P1242, "Undef"
  vivify_449:
    $P1243 = $P1242."ast"()
    $P1244 = $P1240."!make"($P1243)
    .return ($P1244)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("78_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1246
    .param pmc param_1247
.annotate 'line', 499
    .lex "self", param_1246
    .lex "$/", param_1247
    find_lex $P1248, "$/"
    find_lex $P1249, "$/"
    unless_null $P1249, vivify_450
    $P1249 = root_new ['parrot';'Hash']
  vivify_450:
    set $P1250, $P1249["scoped"]
    unless_null $P1250, vivify_451
    new $P1250, "Undef"
  vivify_451:
    $P1251 = $P1250."ast"()
    $P1252 = $P1248."!make"($P1251)
    .return ($P1252)
.end


.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("79_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1254
    .param pmc param_1255
.annotate 'line', 501
    .lex "self", param_1254
    .lex "$/", param_1255
.annotate 'line', 502
    find_lex $P1256, "$/"
.annotate 'line', 503
    find_lex $P1259, "$/"
    unless_null $P1259, vivify_452
    $P1259 = root_new ['parrot';'Hash']
  vivify_452:
    set $P1260, $P1259["declarator"]
    unless_null $P1260, vivify_453
    new $P1260, "Undef"
  vivify_453:
    if $P1260, if_1258
.annotate 'line', 504
    find_lex $P1264, "$/"
    unless_null $P1264, vivify_454
    $P1264 = root_new ['parrot';'Hash']
  vivify_454:
    set $P1265, $P1264["multi_declarator"]
    unless_null $P1265, vivify_455
    new $P1265, "Undef"
  vivify_455:
    $P1266 = $P1265."ast"()
    set $P1257, $P1266
.annotate 'line', 503
    goto if_1258_end
  if_1258:
    find_lex $P1261, "$/"
    unless_null $P1261, vivify_456
    $P1261 = root_new ['parrot';'Hash']
  vivify_456:
    set $P1262, $P1261["declarator"]
    unless_null $P1262, vivify_457
    new $P1262, "Undef"
  vivify_457:
    $P1263 = $P1262."ast"()
    set $P1257, $P1263
  if_1258_end:
    $P1267 = $P1256."!make"($P1257)
.annotate 'line', 501
    .return ($P1267)
.end


.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("80_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1269
    .param pmc param_1270
.annotate 'line', 507
    .lex "self", param_1269
    .lex "$/", param_1270
.annotate 'line', 508
    find_lex $P1271, "$/"
.annotate 'line', 509
    find_lex $P1274, "$/"
    unless_null $P1274, vivify_458
    $P1274 = root_new ['parrot';'Hash']
  vivify_458:
    set $P1275, $P1274["routine_declarator"]
    unless_null $P1275, vivify_459
    new $P1275, "Undef"
  vivify_459:
    if $P1275, if_1273
.annotate 'line', 510
    find_lex $P1279, "$/"
    unless_null $P1279, vivify_460
    $P1279 = root_new ['parrot';'Hash']
  vivify_460:
    set $P1280, $P1279["variable_declarator"]
    unless_null $P1280, vivify_461
    new $P1280, "Undef"
  vivify_461:
    $P1281 = $P1280."ast"()
    set $P1272, $P1281
.annotate 'line', 509
    goto if_1273_end
  if_1273:
    find_lex $P1276, "$/"
    unless_null $P1276, vivify_462
    $P1276 = root_new ['parrot';'Hash']
  vivify_462:
    set $P1277, $P1276["routine_declarator"]
    unless_null $P1277, vivify_463
    new $P1277, "Undef"
  vivify_463:
    $P1278 = $P1277."ast"()
    set $P1272, $P1278
  if_1273_end:
    $P1282 = $P1271."!make"($P1272)
.annotate 'line', 507
    .return ($P1282)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("81_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1284
    .param pmc param_1285
.annotate 'line', 513
    .lex "self", param_1284
    .lex "$/", param_1285
    find_lex $P1286, "$/"
    find_lex $P1289, "$/"
    unless_null $P1289, vivify_464
    $P1289 = root_new ['parrot';'Hash']
  vivify_464:
    set $P1290, $P1289["declarator"]
    unless_null $P1290, vivify_465
    new $P1290, "Undef"
  vivify_465:
    if $P1290, if_1288
    find_lex $P1294, "$/"
    unless_null $P1294, vivify_466
    $P1294 = root_new ['parrot';'Hash']
  vivify_466:
    set $P1295, $P1294["routine_def"]
    unless_null $P1295, vivify_467
    new $P1295, "Undef"
  vivify_467:
    $P1296 = $P1295."ast"()
    set $P1287, $P1296
    goto if_1288_end
  if_1288:
    find_lex $P1291, "$/"
    unless_null $P1291, vivify_468
    $P1291 = root_new ['parrot';'Hash']
  vivify_468:
    set $P1292, $P1291["declarator"]
    unless_null $P1292, vivify_469
    new $P1292, "Undef"
  vivify_469:
    $P1293 = $P1292."ast"()
    set $P1287, $P1293
  if_1288_end:
    $P1297 = $P1286."!make"($P1287)
    .return ($P1297)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("82_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1299
    .param pmc param_1300
.annotate 'line', 514
    .lex "self", param_1299
    .lex "$/", param_1300
    find_lex $P1301, "$/"
    find_lex $P1304, "$/"
    unless_null $P1304, vivify_470
    $P1304 = root_new ['parrot';'Hash']
  vivify_470:
    set $P1305, $P1304["declarator"]
    unless_null $P1305, vivify_471
    new $P1305, "Undef"
  vivify_471:
    if $P1305, if_1303
    find_lex $P1309, "$/"
    unless_null $P1309, vivify_472
    $P1309 = root_new ['parrot';'Hash']
  vivify_472:
    set $P1310, $P1309["routine_def"]
    unless_null $P1310, vivify_473
    new $P1310, "Undef"
  vivify_473:
    $P1311 = $P1310."ast"()
    set $P1302, $P1311
    goto if_1303_end
  if_1303:
    find_lex $P1306, "$/"
    unless_null $P1306, vivify_474
    $P1306 = root_new ['parrot';'Hash']
  vivify_474:
    set $P1307, $P1306["declarator"]
    unless_null $P1307, vivify_475
    new $P1307, "Undef"
  vivify_475:
    $P1308 = $P1307."ast"()
    set $P1302, $P1308
  if_1303_end:
    $P1312 = $P1301."!make"($P1302)
    .return ($P1312)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("83_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1314
    .param pmc param_1315
.annotate 'line', 515
    .lex "self", param_1314
    .lex "$/", param_1315
    find_lex $P1316, "$/"
    find_lex $P1317, "$/"
    unless_null $P1317, vivify_476
    $P1317 = root_new ['parrot';'Hash']
  vivify_476:
    set $P1318, $P1317["declarator"]
    unless_null $P1318, vivify_477
    new $P1318, "Undef"
  vivify_477:
    $P1319 = $P1318."ast"()
    $P1320 = $P1316."!make"($P1319)
    .return ($P1320)
.end


.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("84_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1322
    .param pmc param_1323
.annotate 'line', 518
    .const 'Sub' $P1395 = "87_1297619360.562" 
    capture_lex $P1395
    .const 'Sub' $P1350 = "85_1297619360.562" 
    capture_lex $P1350
    .lex "self", param_1322
    .lex "$/", param_1323
.annotate 'line', 519
    new $P1324, "Undef"
    .lex "$past", $P1324
.annotate 'line', 520
    new $P1325, "Undef"
    .lex "$sigil", $P1325
.annotate 'line', 521
    new $P1326, "Undef"
    .lex "$name", $P1326
.annotate 'line', 522
    new $P1327, "Undef"
    .lex "$BLOCK", $P1327
.annotate 'line', 519
    find_lex $P1328, "$/"
    unless_null $P1328, vivify_478
    $P1328 = root_new ['parrot';'Hash']
  vivify_478:
    set $P1329, $P1328["variable"]
    unless_null $P1329, vivify_479
    new $P1329, "Undef"
  vivify_479:
    $P1330 = $P1329."ast"()
    store_lex "$past", $P1330
.annotate 'line', 520
    find_lex $P1331, "$/"
    unless_null $P1331, vivify_480
    $P1331 = root_new ['parrot';'Hash']
  vivify_480:
    set $P1332, $P1331["variable"]
    unless_null $P1332, vivify_481
    $P1332 = root_new ['parrot';'Hash']
  vivify_481:
    set $P1333, $P1332["sigil"]
    unless_null $P1333, vivify_482
    new $P1333, "Undef"
  vivify_482:
    store_lex "$sigil", $P1333
.annotate 'line', 521
    find_lex $P1334, "$past"
    $P1335 = $P1334."name"()
    store_lex "$name", $P1335
.annotate 'line', 522
    get_global $P1336, "@BLOCK"
    unless_null $P1336, vivify_483
    $P1336 = root_new ['parrot';'ResizablePMCArray']
  vivify_483:
    set $P1337, $P1336[0]
    unless_null $P1337, vivify_484
    new $P1337, "Undef"
  vivify_484:
    store_lex "$BLOCK", $P1337
.annotate 'line', 523
    find_lex $P1339, "$BLOCK"
    find_lex $P1340, "$name"
    $P1341 = $P1339."symbol"($P1340)
    unless $P1341, if_1338_end
.annotate 'line', 524
    find_lex $P1342, "$/"
    $P1343 = $P1342."CURSOR"()
    find_lex $P1344, "$name"
    $P1343."panic"("Redeclaration of symbol ", $P1344)
  if_1338_end:
.annotate 'line', 526
    find_dynamic_lex $P1346, "$*SCOPE"
    unless_null $P1346, vivify_485
    get_hll_global $P1346, "$SCOPE"
    unless_null $P1346, vivify_486
    die "Contextual $*SCOPE not found"
  vivify_486:
  vivify_485:
    set $S1347, $P1346
    iseq $I1348, $S1347, "has"
    if $I1348, if_1345
.annotate 'line', 551
    .const 'Sub' $P1395 = "87_1297619360.562" 
    capture_lex $P1395
    $P1395()
    goto if_1345_end
  if_1345:
.annotate 'line', 526
    .const 'Sub' $P1350 = "85_1297619360.562" 
    capture_lex $P1350
    $P1350()
  if_1345_end:
.annotate 'line', 559
    find_lex $P1419, "$/"
    find_lex $P1420, "$past"
    $P1421 = $P1419."!make"($P1420)
.annotate 'line', 518
    .return ($P1421)
.end


.namespace ["NQP";"Actions"]
.sub "_block1394"  :anon :subid("87_1297619360.562") :outer("84_1297619360.562")
.annotate 'line', 552
    new $P1396, "Undef"
    .lex "$scope", $P1396
.annotate 'line', 553
    new $P1397, "Undef"
    .lex "$decl", $P1397
.annotate 'line', 552
    find_dynamic_lex $P1400, "$*SCOPE"
    unless_null $P1400, vivify_487
    get_hll_global $P1400, "$SCOPE"
    unless_null $P1400, vivify_488
    die "Contextual $*SCOPE not found"
  vivify_488:
  vivify_487:
    set $S1401, $P1400
    iseq $I1402, $S1401, "our"
    if $I1402, if_1399
    new $P1404, "String"
    assign $P1404, "lexical"
    set $P1398, $P1404
    goto if_1399_end
  if_1399:
    new $P1403, "String"
    assign $P1403, "package"
    set $P1398, $P1403
  if_1399_end:
    store_lex "$scope", $P1398
.annotate 'line', 553
    get_hll_global $P1405, ["PAST"], "Var"
    find_lex $P1406, "$name"
    find_lex $P1407, "$scope"
.annotate 'line', 554
    find_lex $P1408, "$sigil"
    $P1409 = "vivitype"($P1408)
    find_lex $P1410, "$/"
    $P1411 = $P1405."new"($P1406 :named("name"), $P1407 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1409 :named("viviself"), $P1410 :named("node"))
.annotate 'line', 553
    store_lex "$decl", $P1411
.annotate 'line', 556
    find_lex $P1412, "$BLOCK"
    find_lex $P1413, "$name"
    find_lex $P1414, "$scope"
    $P1412."symbol"($P1413, $P1414 :named("scope"))
.annotate 'line', 557
    find_lex $P1415, "$BLOCK"
    unless_null $P1415, vivify_489
    $P1415 = root_new ['parrot';'ResizablePMCArray']
  vivify_489:
    set $P1416, $P1415[0]
    unless_null $P1416, vivify_490
    new $P1416, "Undef"
  vivify_490:
    find_lex $P1417, "$decl"
    $P1418 = $P1416."push"($P1417)
.annotate 'line', 551
    .return ($P1418)
.end


.namespace ["NQP";"Actions"]
.sub "_block1349"  :anon :subid("85_1297619360.562") :outer("84_1297619360.562")
.annotate 'line', 526
    .const 'Sub' $P1380 = "86_1297619360.562" 
    capture_lex $P1380
.annotate 'line', 528
    new $P1351, "Undef"
    .lex "$meta-attr-type", $P1351
.annotate 'line', 536
    new $P1352, "Undef"
    .lex "$meta_args", $P1352
.annotate 'line', 528
    find_dynamic_lex $P1355, "$*PKGDECL"
    unless_null $P1355, vivify_491
    get_hll_global $P1355, "$PKGDECL"
    unless_null $P1355, vivify_492
    die "Contextual $*PKGDECL not found"
  vivify_492:
  vivify_491:
    find_dynamic_lex $P1356, "%*HOW-METAATTR"
    unless_null $P1356, vivify_493
    get_hll_global $P1356, "%HOW-METAATTR"
    unless_null $P1356, vivify_494
    die "Contextual %*HOW-METAATTR not found"
  vivify_494:
  vivify_493:
    set $P1357, $P1356[$P1355]
    unless_null $P1357, vivify_495
    new $P1357, "Undef"
  vivify_495:
    unless $P1357, unless_1354
    set $P1353, $P1357
    goto unless_1354_end
  unless_1354:
    find_dynamic_lex $P1358, "$*DEFAULT-METAATTR"
    unless_null $P1358, vivify_496
    get_hll_global $P1358, "$DEFAULT-METAATTR"
    unless_null $P1358, vivify_497
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_497:
  vivify_496:
    set $P1353, $P1358
  unless_1354_end:
    store_lex "$meta-attr-type", $P1353
.annotate 'line', 529
    find_dynamic_lex $P1359, "$*PACKAGE-SETUP"
    unless_null $P1359, vivify_498
    get_hll_global $P1359, "$PACKAGE-SETUP"
    unless_null $P1359, vivify_499
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_499:
  vivify_498:
    get_hll_global $P1360, ["PAST"], "Op"
.annotate 'line', 531
    get_hll_global $P1361, ["PAST"], "Op"
.annotate 'line', 533
    get_hll_global $P1362, ["PAST"], "Var"
    $P1363 = $P1362."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1364 = $P1361."new"($P1363, "get_how PP" :named("pirop"))
.annotate 'line', 535
    get_hll_global $P1365, ["PAST"], "Var"
    $P1366 = $P1365."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 536
    get_hll_global $P1367, ["PAST"], "Op"
.annotate 'line', 538
    get_hll_global $P1368, ["PAST"], "Var"
    find_lex $P1369, "$meta-attr-type"
    $P1370 = $P1368."new"($P1369 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 539
    get_hll_global $P1371, ["PAST"], "Val"
    find_lex $P1372, "$name"
    $P1373 = $P1371."new"($P1372 :named("value"), "name" :named("named"))
    $P1374 = $P1367."new"($P1370, $P1373, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 536
    store_lex "$meta_args", $P1374
    $P1375 = $P1360."new"($P1364, $P1366, $P1374, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 529
    $P1359."push"($P1375)
.annotate 'line', 542
    find_lex $P1377, "$/"
    unless_null $P1377, vivify_500
    $P1377 = root_new ['parrot';'Hash']
  vivify_500:
    set $P1378, $P1377["typename"]
    unless_null $P1378, vivify_501
    new $P1378, "Undef"
  vivify_501:
    unless $P1378, if_1376_end
    .const 'Sub' $P1380 = "86_1297619360.562" 
    capture_lex $P1380
    $P1380()
  if_1376_end:
.annotate 'line', 548
    find_lex $P1390, "$BLOCK"
    find_lex $P1391, "$name"
    $P1390."symbol"($P1391, "attribute" :named("scope"))
.annotate 'line', 549
    get_hll_global $P1392, ["PAST"], "Stmts"
    $P1393 = $P1392."new"()
    store_lex "$past", $P1393
.annotate 'line', 526
    .return ($P1393)
.end


.namespace ["NQP";"Actions"]
.sub "_block1379"  :anon :subid("86_1297619360.562") :outer("85_1297619360.562")
.annotate 'line', 543
    new $P1381, "Undef"
    .lex "$type", $P1381
    find_lex $P1382, "$/"
    unless_null $P1382, vivify_502
    $P1382 = root_new ['parrot';'Hash']
  vivify_502:
    set $P1383, $P1382["typename"]
    unless_null $P1383, vivify_503
    $P1383 = root_new ['parrot';'ResizablePMCArray']
  vivify_503:
    set $P1384, $P1383[0]
    unless_null $P1384, vivify_504
    new $P1384, "Undef"
  vivify_504:
    $P1385 = $P1384."ast"()
    store_lex "$type", $P1385
.annotate 'line', 544
    find_lex $P1386, "$type"
    $P1386."named"("type")
.annotate 'line', 545
    find_lex $P1387, "$meta_args"
    find_lex $P1388, "$type"
    $P1389 = $P1387."push"($P1388)
.annotate 'line', 542
    .return ($P1389)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("88_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1423
    .param pmc param_1424
.annotate 'line', 562
    .lex "self", param_1423
    .lex "$/", param_1424
    find_lex $P1425, "$/"
    find_lex $P1426, "$/"
    unless_null $P1426, vivify_505
    $P1426 = root_new ['parrot';'Hash']
  vivify_505:
    set $P1427, $P1426["routine_def"]
    unless_null $P1427, vivify_506
    new $P1427, "Undef"
  vivify_506:
    $P1428 = $P1427."ast"()
    $P1429 = $P1425."!make"($P1428)
    .return ($P1429)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("89_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1431
    .param pmc param_1432
.annotate 'line', 563
    .lex "self", param_1431
    .lex "$/", param_1432
    find_lex $P1433, "$/"
    find_lex $P1434, "$/"
    unless_null $P1434, vivify_507
    $P1434 = root_new ['parrot';'Hash']
  vivify_507:
    set $P1435, $P1434["method_def"]
    unless_null $P1435, vivify_508
    new $P1435, "Undef"
  vivify_508:
    $P1436 = $P1435."ast"()
    $P1437 = $P1433."!make"($P1436)
    .return ($P1437)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("90_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1439
    .param pmc param_1440
.annotate 'line', 565
    .const 'Sub' $P1668 = "96_1297619360.562" 
    capture_lex $P1668
    .const 'Sub' $P1460 = "91_1297619360.562" 
    capture_lex $P1460
    .lex "self", param_1439
    .lex "$/", param_1440
.annotate 'line', 568
    new $P1441, "Undef"
    .lex "$past", $P1441
.annotate 'line', 579
    new $P1442, "Undef"
    .lex "$block", $P1442
.annotate 'line', 565
    find_lex $P1443, "$past"
.annotate 'line', 569
    find_lex $P1445, "$/"
    unless_null $P1445, vivify_509
    $P1445 = root_new ['parrot';'Hash']
  vivify_509:
    set $P1446, $P1445["onlystar"]
    unless_null $P1446, vivify_510
    new $P1446, "Undef"
  vivify_510:
    if $P1446, if_1444
.annotate 'line', 573
    find_lex $P1448, "$/"
    unless_null $P1448, vivify_511
    $P1448 = root_new ['parrot';'Hash']
  vivify_511:
    set $P1449, $P1448["blockoid"]
    unless_null $P1449, vivify_512
    new $P1449, "Undef"
  vivify_512:
    $P1450 = $P1449."ast"()
    store_lex "$past", $P1450
.annotate 'line', 574
    find_lex $P1451, "$past"
    $P1451."blocktype"("declaration")
.annotate 'line', 575
    find_dynamic_lex $P1453, "$*RETURN_USED"
    unless_null $P1453, vivify_513
    get_hll_global $P1453, "$RETURN_USED"
    unless_null $P1453, vivify_514
    die "Contextual $*RETURN_USED not found"
  vivify_514:
  vivify_513:
    unless $P1453, if_1452_end
.annotate 'line', 576
    find_lex $P1454, "$past"
    $P1454."control"("return_pir")
  if_1452_end:
.annotate 'line', 572
    goto if_1444_end
  if_1444:
.annotate 'line', 570
    $P1447 = "only_star_block"()
    store_lex "$past", $P1447
  if_1444_end:
.annotate 'line', 579
    find_lex $P1455, "$past"
    store_lex "$block", $P1455
.annotate 'line', 581
    find_lex $P1457, "$/"
    unless_null $P1457, vivify_515
    $P1457 = root_new ['parrot';'Hash']
  vivify_515:
    set $P1458, $P1457["deflongname"]
    unless_null $P1458, vivify_516
    new $P1458, "Undef"
  vivify_516:
    unless $P1458, if_1456_end
    .const 'Sub' $P1460 = "91_1297619360.562" 
    capture_lex $P1460
    $P1460()
  if_1456_end:
.annotate 'line', 681
    find_lex $P1657, "$block"
    find_lex $P1658, "$past"
    unless_null $P1658, vivify_577
    $P1658 = root_new ['parrot';'Hash']
    store_lex "$past", $P1658
  vivify_577:
    set $P1658["block_past"], $P1657
.annotate 'line', 682
    find_lex $P1660, "$/"
    unless_null $P1660, vivify_578
    $P1660 = root_new ['parrot';'Hash']
  vivify_578:
    set $P1661, $P1660["trait"]
    unless_null $P1661, vivify_579
    new $P1661, "Undef"
  vivify_579:
    unless $P1661, if_1659_end
.annotate 'line', 683
    find_lex $P1663, "$/"
    unless_null $P1663, vivify_580
    $P1663 = root_new ['parrot';'Hash']
  vivify_580:
    set $P1664, $P1663["trait"]
    unless_null $P1664, vivify_581
    new $P1664, "Undef"
  vivify_581:
    defined $I1665, $P1664
    unless $I1665, for_undef_582
    iter $P1662, $P1664
    new $P1675, 'ExceptionHandler'
    set_label $P1675, loop1674_handler
    $P1675."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1675
  loop1674_test:
    unless $P1662, loop1674_done
    shift $P1666, $P1662
  loop1674_redo:
    .const 'Sub' $P1668 = "96_1297619360.562" 
    capture_lex $P1668
    $P1668($P1666)
  loop1674_next:
    goto loop1674_test
  loop1674_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1676, exception, 'type'
    eq $P1676, .CONTROL_LOOP_NEXT, loop1674_next
    eq $P1676, .CONTROL_LOOP_REDO, loop1674_redo
  loop1674_done:
    pop_eh 
  for_undef_582:
  if_1659_end:
.annotate 'line', 686
    find_lex $P1677, "$/"
    find_lex $P1678, "$past"
    $P1679 = $P1677."!make"($P1678)
.annotate 'line', 565
    .return ($P1679)
.end


.namespace ["NQP";"Actions"]
.sub "_block1459"  :anon :subid("91_1297619360.562") :outer("90_1297619360.562")
.annotate 'line', 581
    .const 'Sub' $P1583 = "95_1297619360.562" 
    capture_lex $P1583
    .const 'Sub' $P1494 = "92_1297619360.562" 
    capture_lex $P1494
.annotate 'line', 582
    new $P1461, "Undef"
    .lex "$name", $P1461
    find_lex $P1462, "$/"
    unless_null $P1462, vivify_517
    $P1462 = root_new ['parrot';'Hash']
  vivify_517:
    set $P1463, $P1462["sigil"]
    unless_null $P1463, vivify_518
    $P1463 = root_new ['parrot';'ResizablePMCArray']
  vivify_518:
    set $P1464, $P1463[0]
    unless_null $P1464, vivify_519
    new $P1464, "Undef"
  vivify_519:
    set $S1465, $P1464
    new $P1466, 'String'
    set $P1466, $S1465
    find_lex $P1467, "$/"
    unless_null $P1467, vivify_520
    $P1467 = root_new ['parrot';'Hash']
  vivify_520:
    set $P1468, $P1467["deflongname"]
    unless_null $P1468, vivify_521
    $P1468 = root_new ['parrot';'ResizablePMCArray']
  vivify_521:
    set $P1469, $P1468[0]
    unless_null $P1469, vivify_522
    new $P1469, "Undef"
  vivify_522:
    $S1470 = $P1469."ast"()
    concat $P1471, $P1466, $S1470
    store_lex "$name", $P1471
.annotate 'line', 583
    find_lex $P1472, "$past"
    find_lex $P1473, "$name"
    $P1472."name"($P1473)
.annotate 'line', 584
    find_dynamic_lex $P1480, "$*SCOPE"
    unless_null $P1480, vivify_523
    get_hll_global $P1480, "$SCOPE"
    unless_null $P1480, vivify_524
    die "Contextual $*SCOPE not found"
  vivify_524:
  vivify_523:
    set $S1481, $P1480
    iseq $I1482, $S1481, ""
    unless $I1482, unless_1479
    new $P1478, 'Integer'
    set $P1478, $I1482
    goto unless_1479_end
  unless_1479:
    find_dynamic_lex $P1483, "$*SCOPE"
    unless_null $P1483, vivify_525
    get_hll_global $P1483, "$SCOPE"
    unless_null $P1483, vivify_526
    die "Contextual $*SCOPE not found"
  vivify_526:
  vivify_525:
    set $S1484, $P1483
    iseq $I1485, $S1484, "my"
    new $P1478, 'Integer'
    set $P1478, $I1485
  unless_1479_end:
    unless $P1478, unless_1477
    set $P1476, $P1478
    goto unless_1477_end
  unless_1477:
    find_dynamic_lex $P1486, "$*SCOPE"
    unless_null $P1486, vivify_527
    get_hll_global $P1486, "$SCOPE"
    unless_null $P1486, vivify_528
    die "Contextual $*SCOPE not found"
  vivify_528:
  vivify_527:
    set $S1487, $P1486
    iseq $I1488, $S1487, "our"
    new $P1476, 'Integer'
    set $P1476, $I1488
  unless_1477_end:
    if $P1476, if_1475
.annotate 'line', 676
    find_lex $P1652, "$/"
    $P1653 = $P1652."CURSOR"()
    find_dynamic_lex $P1654, "$*SCOPE"
    unless_null $P1654, vivify_529
    get_hll_global $P1654, "$SCOPE"
    unless_null $P1654, vivify_530
    die "Contextual $*SCOPE not found"
  vivify_530:
  vivify_529:
    concat $P1655, $P1654, " scoped routines are not supported yet"
    $P1656 = $P1653."panic"($P1655)
.annotate 'line', 675
    set $P1474, $P1656
.annotate 'line', 584
    goto if_1475_end
  if_1475:
.annotate 'line', 585
    find_dynamic_lex $P1490, "$*MULTINESS"
    unless_null $P1490, vivify_531
    get_hll_global $P1490, "$MULTINESS"
    unless_null $P1490, vivify_532
    die "Contextual $*MULTINESS not found"
  vivify_532:
  vivify_531:
    set $S1491, $P1490
    iseq $I1492, $S1491, "multi"
    if $I1492, if_1489
.annotate 'line', 636
    find_dynamic_lex $P1579, "$*MULTINESS"
    unless_null $P1579, vivify_533
    get_hll_global $P1579, "$MULTINESS"
    unless_null $P1579, vivify_534
    die "Contextual $*MULTINESS not found"
  vivify_534:
  vivify_533:
    set $S1580, $P1579
    iseq $I1581, $S1580, "proto"
    if $I1581, if_1578
.annotate 'line', 655
    get_global $P1613, "@BLOCK"
    unless_null $P1613, vivify_535
    $P1613 = root_new ['parrot';'ResizablePMCArray']
  vivify_535:
    set $P1614, $P1613[0]
    unless_null $P1614, vivify_536
    $P1614 = root_new ['parrot';'ResizablePMCArray']
  vivify_536:
    set $P1615, $P1614[0]
    unless_null $P1615, vivify_537
    new $P1615, "Undef"
  vivify_537:
    get_hll_global $P1616, ["PAST"], "Var"
    find_lex $P1617, "$name"
    find_lex $P1618, "$past"
    $P1619 = $P1616."new"($P1617 :named("name"), 1 :named("isdecl"), $P1618 :named("viviself"), "lexical" :named("scope"))
    $P1615."push"($P1619)
.annotate 'line', 657
    get_global $P1620, "@BLOCK"
    unless_null $P1620, vivify_538
    $P1620 = root_new ['parrot';'ResizablePMCArray']
  vivify_538:
    set $P1621, $P1620[0]
    unless_null $P1621, vivify_539
    new $P1621, "Undef"
  vivify_539:
    find_lex $P1622, "$name"
    $P1621."symbol"($P1622, "lexical" :named("scope"))
.annotate 'line', 658
    find_dynamic_lex $P1624, "$*SCOPE"
    unless_null $P1624, vivify_540
    get_hll_global $P1624, "$SCOPE"
    unless_null $P1624, vivify_541
    die "Contextual $*SCOPE not found"
  vivify_541:
  vivify_540:
    set $S1625, $P1624
    iseq $I1626, $S1625, "our"
    unless $I1626, if_1623_end
.annotate 'line', 661
    get_global $P1627, "@BLOCK"
    unless_null $P1627, vivify_542
    $P1627 = root_new ['parrot';'ResizablePMCArray']
  vivify_542:
    set $P1628, $P1627[0]
    unless_null $P1628, vivify_543
    $P1628 = root_new ['parrot';'ResizablePMCArray']
  vivify_543:
    set $P1629, $P1628[0]
    unless_null $P1629, vivify_544
    new $P1629, "Undef"
  vivify_544:
    get_hll_global $P1630, ["PAST"], "Op"
.annotate 'line', 663
    get_hll_global $P1631, ["PAST"], "Var"
    find_lex $P1632, "$name"
    $P1633 = $P1631."new"($P1632 :named("name"), "package" :named("scope"))
.annotate 'line', 664
    get_hll_global $P1634, ["PAST"], "Var"
    find_lex $P1635, "$name"
    $P1636 = $P1634."new"($P1635 :named("name"), "lexical" :named("scope"))
    $P1637 = $P1630."new"($P1633, $P1636, "bind" :named("pasttype"))
.annotate 'line', 661
    $P1629."push"($P1637)
.annotate 'line', 666
    get_global $P1638, "@BLOCK"
    unless_null $P1638, vivify_545
    $P1638 = root_new ['parrot';'ResizablePMCArray']
  vivify_545:
    set $P1639, $P1638[0]
    unless_null $P1639, vivify_546
    new $P1639, "Undef"
  vivify_546:
    $P1640 = $P1639."loadinit"()
    get_hll_global $P1641, ["PAST"], "Op"
.annotate 'line', 668
    get_hll_global $P1642, ["PAST"], "Var"
    find_lex $P1643, "$name"
    $P1644 = $P1642."new"($P1643 :named("name"), "package" :named("scope"))
.annotate 'line', 669
    get_hll_global $P1645, ["PAST"], "Val"
    find_lex $P1646, "$past"
    $P1647 = $P1645."new"($P1646 :named("value"))
    $P1648 = $P1641."new"($P1644, $P1647, "bind" :named("pasttype"))
.annotate 'line', 666
    $P1640."push"($P1648)
  if_1623_end:
.annotate 'line', 654
    goto if_1578_end
  if_1578:
.annotate 'line', 636
    .const 'Sub' $P1583 = "95_1297619360.562" 
    capture_lex $P1583
    $P1583()
  if_1578_end:
    goto if_1489_end
  if_1489:
.annotate 'line', 585
    .const 'Sub' $P1494 = "92_1297619360.562" 
    capture_lex $P1494
    $P1494()
  if_1489_end:
.annotate 'line', 673
    get_hll_global $P1649, ["PAST"], "Var"
    find_lex $P1650, "$name"
    $P1651 = $P1649."new"($P1650 :named("name"))
    store_lex "$past", $P1651
.annotate 'line', 584
    set $P1474, $P1651
  if_1475_end:
.annotate 'line', 581
    .return ($P1474)
.end


.namespace ["NQP";"Actions"]
.sub "_block1582"  :anon :subid("95_1297619360.562") :outer("91_1297619360.562")
.annotate 'line', 641
    new $P1584, "Undef"
    .lex "$cholder", $P1584
.annotate 'line', 640
    find_dynamic_lex $P1586, "$*SCOPE"
    unless_null $P1586, vivify_547
    get_hll_global $P1586, "$SCOPE"
    unless_null $P1586, vivify_548
    die "Contextual $*SCOPE not found"
  vivify_548:
  vivify_547:
    set $S1587, $P1586
    iseq $I1588, $S1587, "our"
    unless $I1588, if_1585_end
    die "our-scoped protos not yet implemented"
  if_1585_end:
.annotate 'line', 641
    get_hll_global $P1589, ["PAST"], "Op"
    $P1590 = $P1589."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1590
.annotate 'line', 642
    get_global $P1591, "@BLOCK"
    unless_null $P1591, vivify_549
    $P1591 = root_new ['parrot';'ResizablePMCArray']
  vivify_549:
    set $P1592, $P1591[0]
    unless_null $P1592, vivify_550
    $P1592 = root_new ['parrot';'ResizablePMCArray']
  vivify_550:
    set $P1593, $P1592[0]
    unless_null $P1593, vivify_551
    new $P1593, "Undef"
  vivify_551:
    get_hll_global $P1594, ["PAST"], "Var"
    find_lex $P1595, "$name"
    find_lex $P1596, "$past"
    $P1597 = $P1594."new"($P1595 :named("name"), 1 :named("isdecl"), $P1596 :named("viviself"), "lexical" :named("scope"))
    $P1593."push"($P1597)
.annotate 'line', 644
    get_global $P1598, "@BLOCK"
    unless_null $P1598, vivify_552
    $P1598 = root_new ['parrot';'ResizablePMCArray']
  vivify_552:
    set $P1599, $P1598[0]
    unless_null $P1599, vivify_553
    $P1599 = root_new ['parrot';'ResizablePMCArray']
  vivify_553:
    set $P1600, $P1599[0]
    unless_null $P1600, vivify_554
    new $P1600, "Undef"
  vivify_554:
    get_hll_global $P1601, ["PAST"], "Op"
.annotate 'line', 646
    get_hll_global $P1602, ["PAST"], "Var"
    find_lex $P1603, "$name"
    $P1604 = $P1602."new"($P1603 :named("name"))
    find_lex $P1605, "$cholder"
    $P1606 = $P1601."new"($P1604, $P1605, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 644
    $P1600."push"($P1606)
.annotate 'line', 649
    get_global $P1607, "@BLOCK"
    unless_null $P1607, vivify_555
    $P1607 = root_new ['parrot';'ResizablePMCArray']
  vivify_555:
    set $P1608, $P1607[0]
    unless_null $P1608, vivify_556
    new $P1608, "Undef"
  vivify_556:
    find_lex $P1609, "$name"
    find_lex $P1610, "$cholder"
    $P1608."symbol"($P1609, "lexical" :named("scope"), 1 :named("proto"), $P1610 :named("cholder"))
.annotate 'line', 652
    find_lex $P1611, "$past"
    $P1612 = $P1611."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 636
    .return ($P1612)
.end


.namespace ["NQP";"Actions"]
.sub "_block1493"  :anon :subid("92_1297619360.562") :outer("91_1297619360.562")
.annotate 'line', 585
    .const 'Sub' $P1512 = "93_1297619360.562" 
    capture_lex $P1512
.annotate 'line', 588
    new $P1495, "Undef"
    .lex "$cholder", $P1495
.annotate 'line', 589
    $P1496 = root_new ['parrot';'Hash']
    .lex "%sym", $P1496
.annotate 'line', 587
    find_dynamic_lex $P1498, "$*SCOPE"
    unless_null $P1498, vivify_557
    get_hll_global $P1498, "$SCOPE"
    unless_null $P1498, vivify_558
    die "Contextual $*SCOPE not found"
  vivify_558:
  vivify_557:
    set $S1499, $P1498
    iseq $I1500, $S1499, "our"
    unless $I1500, if_1497_end
    die "our-scoped multis not yet implemented"
  if_1497_end:
    find_lex $P1501, "$cholder"
.annotate 'line', 589
    get_global $P1502, "@BLOCK"
    unless_null $P1502, vivify_559
    $P1502 = root_new ['parrot';'ResizablePMCArray']
  vivify_559:
    set $P1503, $P1502[0]
    unless_null $P1503, vivify_560
    new $P1503, "Undef"
  vivify_560:
    find_lex $P1504, "$name"
    $P1505 = $P1503."symbol"($P1504)
    store_lex "%sym", $P1505
.annotate 'line', 590
    find_lex $P1507, "%sym"
    unless_null $P1507, vivify_561
    $P1507 = root_new ['parrot';'Hash']
  vivify_561:
    set $P1508, $P1507["cholder"]
    unless_null $P1508, vivify_562
    new $P1508, "Undef"
  vivify_562:
    if $P1508, if_1506
.annotate 'line', 595
    .const 'Sub' $P1512 = "93_1297619360.562" 
    capture_lex $P1512
    $P1512()
    goto if_1506_end
  if_1506:
.annotate 'line', 591
    find_lex $P1509, "%sym"
    unless_null $P1509, vivify_575
    $P1509 = root_new ['parrot';'Hash']
  vivify_575:
    set $P1510, $P1509["cholder"]
    unless_null $P1510, vivify_576
    new $P1510, "Undef"
  vivify_576:
    store_lex "$cholder", $P1510
  if_1506_end:
.annotate 'line', 631
    find_lex $P1574, "$cholder"
    find_lex $P1575, "$past"
    $P1574."push"($P1575)
.annotate 'line', 634
    find_lex $P1576, "$past"
    $P1577 = "attach_multi_signature"($P1576)
.annotate 'line', 585
    .return ($P1577)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1511"  :anon :subid("93_1297619360.562") :outer("92_1297619360.562")
.annotate 'line', 595
    .const 'Sub' $P1526 = "94_1297619360.562" 
    capture_lex $P1526
.annotate 'line', 602
    new $P1513, "Undef"
    .lex "$found_proto", $P1513
.annotate 'line', 620
    new $P1514, "Undef"
    .lex "$dispatch_setup", $P1514
.annotate 'line', 597
    find_lex $P1516, "%sym"
    unless_null $P1516, vivify_563
    $P1516 = root_new ['parrot';'Hash']
  vivify_563:
    set $P1517, $P1516["proto"]
    unless_null $P1517, vivify_564
    new $P1517, "Undef"
  vivify_564:
    unless $P1517, if_1515_end
.annotate 'line', 600
    find_lex $P1518, "$/"
    $P1519 = $P1518."CURSOR"()
    $P1519."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1515_end:
.annotate 'line', 597
    find_lex $P1520, "$found_proto"
.annotate 'line', 603
    get_global $P1522, "@BLOCK"
    defined $I1523, $P1522
    unless $I1523, for_undef_565
    iter $P1521, $P1522
    new $P1548, 'ExceptionHandler'
    set_label $P1548, loop1547_handler
    $P1548."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1548
  loop1547_test:
    unless $P1521, loop1547_done
    shift $P1524, $P1521
  loop1547_redo:
    .const 'Sub' $P1526 = "94_1297619360.562" 
    capture_lex $P1526
    $P1526($P1524)
  loop1547_next:
    goto loop1547_test
  loop1547_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1549, exception, 'type'
    eq $P1549, .CONTROL_LOOP_NEXT, loop1547_next
    eq $P1549, .CONTROL_LOOP_REDO, loop1547_redo
  loop1547_done:
    pop_eh 
  for_undef_565:
.annotate 'line', 614
    find_lex $P1551, "$found_proto"
    if $P1551, unless_1550_end
.annotate 'line', 615
    find_lex $P1552, "$/"
    $P1553 = $P1552."CURSOR"()
    $P1553."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1550_end:
.annotate 'line', 619
    get_hll_global $P1554, ["PAST"], "Op"
    $P1555 = $P1554."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1555
.annotate 'line', 620
    get_hll_global $P1556, ["PAST"], "Op"
.annotate 'line', 622
    get_hll_global $P1557, ["PAST"], "Var"
    find_lex $P1558, "$name"
    $P1559 = $P1557."new"($P1558 :named("name"), "outer" :named("scope"))
    find_lex $P1560, "$cholder"
    $P1561 = $P1556."new"($P1559, $P1560, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 620
    store_lex "$dispatch_setup", $P1561
.annotate 'line', 625
    get_global $P1562, "@BLOCK"
    unless_null $P1562, vivify_570
    $P1562 = root_new ['parrot';'ResizablePMCArray']
  vivify_570:
    set $P1563, $P1562[0]
    unless_null $P1563, vivify_571
    $P1563 = root_new ['parrot';'ResizablePMCArray']
  vivify_571:
    set $P1564, $P1563[0]
    unless_null $P1564, vivify_572
    new $P1564, "Undef"
  vivify_572:
    get_hll_global $P1565, ["PAST"], "Var"
    find_lex $P1566, "$name"
    find_lex $P1567, "$dispatch_setup"
    $P1568 = $P1565."new"($P1566 :named("name"), 1 :named("isdecl"), $P1567 :named("viviself"), "lexical" :named("scope"))
    $P1564."push"($P1568)
.annotate 'line', 627
    get_global $P1569, "@BLOCK"
    unless_null $P1569, vivify_573
    $P1569 = root_new ['parrot';'ResizablePMCArray']
  vivify_573:
    set $P1570, $P1569[0]
    unless_null $P1570, vivify_574
    new $P1570, "Undef"
  vivify_574:
    find_lex $P1571, "$name"
    find_lex $P1572, "$cholder"
    $P1573 = $P1570."symbol"($P1571, "lexical" :named("scope"), $P1572 :named("cholder"))
.annotate 'line', 595
    .return ($P1573)
.end


.namespace ["NQP";"Actions"]
.sub "_block1525"  :anon :subid("94_1297619360.562") :outer("93_1297619360.562")
    .param pmc param_1528
.annotate 'line', 604
    $P1527 = root_new ['parrot';'Hash']
    .lex "%sym", $P1527
    .lex "$_", param_1528
    find_lex $P1529, "$_"
    find_lex $P1530, "$name"
    $P1531 = $P1529."symbol"($P1530)
    store_lex "%sym", $P1531
.annotate 'line', 605
    find_lex $P1536, "%sym"
    unless_null $P1536, vivify_566
    $P1536 = root_new ['parrot';'Hash']
  vivify_566:
    set $P1537, $P1536["proto"]
    unless_null $P1537, vivify_567
    new $P1537, "Undef"
  vivify_567:
    unless $P1537, unless_1535
    set $P1534, $P1537
    goto unless_1535_end
  unless_1535:
    find_lex $P1538, "%sym"
    unless_null $P1538, vivify_568
    $P1538 = root_new ['parrot';'Hash']
  vivify_568:
    set $P1539, $P1538["cholder"]
    unless_null $P1539, vivify_569
    new $P1539, "Undef"
  vivify_569:
    set $P1534, $P1539
  unless_1535_end:
    if $P1534, if_1533
.annotate 'line', 608
    find_lex $P1543, "%sym"
    if $P1543, if_1542
    set $P1541, $P1543
    goto if_1542_end
  if_1542:
.annotate 'line', 609
    find_lex $P1544, "$/"
    $P1545 = $P1544."CURSOR"()
    $P1546 = $P1545."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 608
    set $P1541, $P1546
  if_1542_end:
    set $P1532, $P1541
.annotate 'line', 605
    goto if_1533_end
  if_1533:
.annotate 'line', 606
    new $P1540, "Integer"
    assign $P1540, 1
    store_lex "$found_proto", $P1540
.annotate 'line', 605
    set $P1532, $P1540
  if_1533_end:
.annotate 'line', 603
    .return ($P1532)
.end


.namespace ["NQP";"Actions"]
.sub "_block1667"  :anon :subid("96_1297619360.562") :outer("90_1297619360.562")
    .param pmc param_1669
.annotate 'line', 683
    .lex "$_", param_1669
    find_lex $P1670, "$_"
    $P1671 = $P1670."ast"()
    find_lex $P1672, "$/"
    $P1673 = $P1671($P1672)
    .return ($P1673)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("97_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1681
    .param pmc param_1682
.annotate 'line', 690
    .const 'Sub' $P1794 = "99_1297619360.562" 
    capture_lex $P1794
    .const 'Sub' $P1710 = "98_1297619360.562" 
    capture_lex $P1710
    .lex "self", param_1681
    .lex "$/", param_1682
.annotate 'line', 693
    new $P1683, "Undef"
    .lex "$past", $P1683
.annotate 'line', 690
    find_lex $P1684, "$past"
.annotate 'line', 694
    find_lex $P1686, "$/"
    unless_null $P1686, vivify_583
    $P1686 = root_new ['parrot';'Hash']
  vivify_583:
    set $P1687, $P1686["onlystar"]
    unless_null $P1687, vivify_584
    new $P1687, "Undef"
  vivify_584:
    if $P1687, if_1685
.annotate 'line', 698
    find_lex $P1689, "$/"
    unless_null $P1689, vivify_585
    $P1689 = root_new ['parrot';'Hash']
  vivify_585:
    set $P1690, $P1689["blockoid"]
    unless_null $P1690, vivify_586
    new $P1690, "Undef"
  vivify_586:
    $P1691 = $P1690."ast"()
    store_lex "$past", $P1691
.annotate 'line', 699
    find_lex $P1692, "$past"
    $P1692."blocktype"("declaration")
.annotate 'line', 700
    find_dynamic_lex $P1694, "$*RETURN_USED"
    unless_null $P1694, vivify_587
    get_hll_global $P1694, "$RETURN_USED"
    unless_null $P1694, vivify_588
    die "Contextual $*RETURN_USED not found"
  vivify_588:
  vivify_587:
    unless $P1694, if_1693_end
.annotate 'line', 701
    find_lex $P1695, "$past"
    $P1695."control"("return_pir")
  if_1693_end:
.annotate 'line', 697
    goto if_1685_end
  if_1685:
.annotate 'line', 695
    $P1688 = "only_star_block"()
    store_lex "$past", $P1688
  if_1685_end:
.annotate 'line', 706
    find_lex $P1697, "$past"
    unless_null $P1697, vivify_589
    $P1697 = root_new ['parrot';'Hash']
  vivify_589:
    set $P1698, $P1697["signature_has_invocant"]
    unless_null $P1698, vivify_590
    new $P1698, "Undef"
  vivify_590:
    if $P1698, unless_1696_end
.annotate 'line', 707
    find_lex $P1699, "$past"
    unless_null $P1699, vivify_591
    $P1699 = root_new ['parrot';'ResizablePMCArray']
  vivify_591:
    set $P1700, $P1699[0]
    unless_null $P1700, vivify_592
    new $P1700, "Undef"
  vivify_592:
    get_hll_global $P1701, ["PAST"], "Var"
.annotate 'line', 709
    get_hll_global $P1702, ["PAST"], "Var"
    $P1703 = $P1702."new"("$?CLASS" :named("name"))
    $P1704 = $P1701."new"("self" :named("name"), "parameter" :named("scope"), $P1703 :named("multitype"))
.annotate 'line', 707
    $P1700."unshift"($P1704)
  unless_1696_end:
.annotate 'line', 712
    find_lex $P1705, "$past"
    $P1705."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 715
    find_lex $P1707, "$/"
    unless_null $P1707, vivify_593
    $P1707 = root_new ['parrot';'Hash']
  vivify_593:
    set $P1708, $P1707["deflongname"]
    unless_null $P1708, vivify_594
    new $P1708, "Undef"
  vivify_594:
    unless $P1708, if_1706_end
    .const 'Sub' $P1710 = "98_1297619360.562" 
    capture_lex $P1710
    $P1710()
  if_1706_end:
.annotate 'line', 750
    find_dynamic_lex $P1776, "$*SCOPE"
    unless_null $P1776, vivify_612
    get_hll_global $P1776, "$SCOPE"
    unless_null $P1776, vivify_613
    die "Contextual $*SCOPE not found"
  vivify_613:
  vivify_612:
    set $S1777, $P1776
    iseq $I1778, $S1777, "our"
    unless $I1778, if_1775_end
.annotate 'line', 751
    find_lex $P1779, "$past"
    $P1779."pirflags"(":nsentry")
  if_1775_end:
.annotate 'line', 755
    find_lex $P1780, "$/"
    find_lex $P1781, "$past"
    $P1780."!make"($P1781)
.annotate 'line', 756
    find_lex $P1782, "$past"
    find_lex $P1783, "$past"
    unless_null $P1783, vivify_614
    $P1783 = root_new ['parrot';'Hash']
    store_lex "$past", $P1783
  vivify_614:
    set $P1783["block_past"], $P1782
.annotate 'line', 757
    find_lex $P1786, "$/"
    unless_null $P1786, vivify_615
    $P1786 = root_new ['parrot';'Hash']
  vivify_615:
    set $P1787, $P1786["trait"]
    unless_null $P1787, vivify_616
    new $P1787, "Undef"
  vivify_616:
    if $P1787, if_1785
    set $P1784, $P1787
    goto if_1785_end
  if_1785:
.annotate 'line', 758
    find_lex $P1789, "$/"
    unless_null $P1789, vivify_617
    $P1789 = root_new ['parrot';'Hash']
  vivify_617:
    set $P1790, $P1789["trait"]
    unless_null $P1790, vivify_618
    new $P1790, "Undef"
  vivify_618:
    defined $I1791, $P1790
    unless $I1791, for_undef_619
    iter $P1788, $P1790
    new $P1801, 'ExceptionHandler'
    set_label $P1801, loop1800_handler
    $P1801."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1801
  loop1800_test:
    unless $P1788, loop1800_done
    shift $P1792, $P1788
  loop1800_redo:
    .const 'Sub' $P1794 = "99_1297619360.562" 
    capture_lex $P1794
    $P1794($P1792)
  loop1800_next:
    goto loop1800_test
  loop1800_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1802, exception, 'type'
    eq $P1802, .CONTROL_LOOP_NEXT, loop1800_next
    eq $P1802, .CONTROL_LOOP_REDO, loop1800_redo
  loop1800_done:
    pop_eh 
  for_undef_619:
.annotate 'line', 757
    set $P1784, $P1788
  if_1785_end:
.annotate 'line', 690
    .return ($P1784)
.end


.namespace ["NQP";"Actions"]
.sub "_block1709"  :anon :subid("98_1297619360.562") :outer("97_1297619360.562")
.annotate 'line', 717
    new $P1711, "Undef"
    .lex "$name", $P1711
.annotate 'line', 722
    new $P1712, "Undef"
    .lex "$to_add", $P1712
.annotate 'line', 717
    find_lex $P1713, "$/"
    unless_null $P1713, vivify_595
    $P1713 = root_new ['parrot';'Hash']
  vivify_595:
    set $P1714, $P1713["private"]
    unless_null $P1714, vivify_596
    new $P1714, "Undef"
  vivify_596:
    set $S1715, $P1714
    new $P1716, 'String'
    set $P1716, $S1715
    find_lex $P1717, "$/"
    unless_null $P1717, vivify_597
    $P1717 = root_new ['parrot';'Hash']
  vivify_597:
    set $P1718, $P1717["deflongname"]
    unless_null $P1718, vivify_598
    $P1718 = root_new ['parrot';'ResizablePMCArray']
  vivify_598:
    set $P1719, $P1718[0]
    unless_null $P1719, vivify_599
    new $P1719, "Undef"
  vivify_599:
    $P1720 = $P1719."ast"()
    set $S1721, $P1720
    concat $P1722, $P1716, $S1721
    store_lex "$name", $P1722
.annotate 'line', 718
    find_lex $P1723, "$past"
    find_lex $P1724, "$name"
    $P1723."name"($P1724)
.annotate 'line', 722
    find_dynamic_lex $P1727, "$*MULTINESS"
    unless_null $P1727, vivify_600
    get_hll_global $P1727, "$MULTINESS"
    unless_null $P1727, vivify_601
    die "Contextual $*MULTINESS not found"
  vivify_601:
  vivify_600:
    set $S1728, $P1727
    isne $I1729, $S1728, "proto"
    if $I1729, if_1726
.annotate 'line', 724
    get_hll_global $P1733, ["PAST"], "Op"
.annotate 'line', 726
    get_hll_global $P1734, ["PAST"], "Val"
    find_lex $P1735, "$past"
    $P1736 = $P1734."new"($P1735 :named("value"))
.annotate 'line', 727
    get_hll_global $P1737, ["PAST"], "Op"
    $P1738 = $P1737."new"("list" :named("pasttype"))
    $P1739 = $P1733."new"($P1736, $P1738, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 724
    set $P1725, $P1739
.annotate 'line', 722
    goto if_1726_end
  if_1726:
.annotate 'line', 723
    get_hll_global $P1730, ["PAST"], "Val"
    find_lex $P1731, "$past"
    $P1732 = $P1730."new"($P1731 :named("value"))
    set $P1725, $P1732
  if_1726_end:
.annotate 'line', 722
    store_lex "$to_add", $P1725
.annotate 'line', 729
    find_dynamic_lex $P1741, "$*MULTINESS"
    unless_null $P1741, vivify_602
    get_hll_global $P1741, "$MULTINESS"
    unless_null $P1741, vivify_603
    die "Contextual $*MULTINESS not found"
  vivify_603:
  vivify_602:
    set $S1742, $P1741
    iseq $I1743, $S1742, "proto"
    unless $I1743, if_1740_end
    find_lex $P1744, "$past"
    $P1744."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1740_end:
.annotate 'line', 733
    find_dynamic_lex $P1746, "$*MULTINESS"
    unless_null $P1746, vivify_604
    get_hll_global $P1746, "$MULTINESS"
    unless_null $P1746, vivify_605
    die "Contextual $*MULTINESS not found"
  vivify_605:
  vivify_604:
    set $S1747, $P1746
    iseq $I1748, $S1747, "multi"
    unless $I1748, if_1745_end
    find_lex $P1749, "$past"
    "attach_multi_signature"($P1749)
  if_1745_end:
.annotate 'line', 736
    find_dynamic_lex $P1752, "$*PACKAGE-SETUP"
    unless_null $P1752, vivify_606
    get_hll_global $P1752, "$PACKAGE-SETUP"
    unless_null $P1752, vivify_607
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_607:
  vivify_606:
    defined $I1753, $P1752
    if $I1753, if_1751
    new $P1750, 'Integer'
    set $P1750, $I1753
    goto if_1751_end
  if_1751:
.annotate 'line', 737
    find_dynamic_lex $P1754, "$*PACKAGE-SETUP"
    unless_null $P1754, vivify_608
    get_hll_global $P1754, "$PACKAGE-SETUP"
    unless_null $P1754, vivify_609
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_609:
  vivify_608:
    get_hll_global $P1755, ["PAST"], "Op"
.annotate 'line', 738
    find_dynamic_lex $P1758, "$*MULTINESS"
    unless_null $P1758, vivify_610
    get_hll_global $P1758, "$MULTINESS"
    unless_null $P1758, vivify_611
    die "Contextual $*MULTINESS not found"
  vivify_611:
  vivify_610:
    set $S1759, $P1758
    iseq $I1760, $S1759, "multi"
    if $I1760, if_1757
    new $P1762, "String"
    assign $P1762, "add_method"
    set $P1756, $P1762
    goto if_1757_end
  if_1757:
    new $P1761, "String"
    assign $P1761, "add_multi_method"
    set $P1756, $P1761
  if_1757_end:
.annotate 'line', 739
    get_hll_global $P1763, ["PAST"], "Op"
.annotate 'line', 742
    get_hll_global $P1764, ["PAST"], "Var"
    $P1765 = $P1764."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1766 = $P1763."new"($P1765, "get_how PP" :named("pirop"))
.annotate 'line', 744
    get_hll_global $P1767, ["PAST"], "Var"
    $P1768 = $P1767."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 745
    get_hll_global $P1769, ["PAST"], "Val"
    find_lex $P1770, "$name"
    $P1771 = $P1769."new"($P1770 :named("value"))
    find_lex $P1772, "$to_add"
    $P1773 = $P1755."new"($P1766, $P1768, $P1771, $P1772, "callmethod" :named("pasttype"), $P1756 :named("name"))
.annotate 'line', 737
    $P1774 = $P1754."push"($P1773)
.annotate 'line', 736
    set $P1750, $P1774
  if_1751_end:
.annotate 'line', 715
    .return ($P1750)
.end


.namespace ["NQP";"Actions"]
.sub "_block1793"  :anon :subid("99_1297619360.562") :outer("97_1297619360.562")
    .param pmc param_1795
.annotate 'line', 758
    .lex "$_", param_1795
    find_lex $P1796, "$_"
    $P1797 = $P1796."ast"()
    find_lex $P1798, "$/"
    $P1799 = $P1797($P1798)
    .return ($P1799)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("100_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1806
    .param pmc param_1807
.annotate 'line', 790
    .const 'Sub' $P1840 = "102_1297619360.562" 
    capture_lex $P1840
    .const 'Sub' $P1816 = "101_1297619360.562" 
    capture_lex $P1816
    .lex "self", param_1806
    .lex "$/", param_1807
.annotate 'line', 791
    new $P1808, "Undef"
    .lex "$BLOCKINIT", $P1808
    get_global $P1809, "@BLOCK"
    unless_null $P1809, vivify_620
    $P1809 = root_new ['parrot';'ResizablePMCArray']
  vivify_620:
    set $P1810, $P1809[0]
    unless_null $P1810, vivify_621
    $P1810 = root_new ['parrot';'ResizablePMCArray']
  vivify_621:
    set $P1811, $P1810[0]
    unless_null $P1811, vivify_622
    new $P1811, "Undef"
  vivify_622:
    store_lex "$BLOCKINIT", $P1811
.annotate 'line', 792
    find_lex $P1813, "$/"
    unless_null $P1813, vivify_623
    $P1813 = root_new ['parrot';'Hash']
  vivify_623:
    set $P1814, $P1813["invocant"]
    unless_null $P1814, vivify_624
    new $P1814, "Undef"
  vivify_624:
    unless $P1814, if_1812_end
    .const 'Sub' $P1816 = "101_1297619360.562" 
    capture_lex $P1816
    $P1816()
  if_1812_end:
.annotate 'line', 801
    find_lex $P1835, "$/"
    unless_null $P1835, vivify_630
    $P1835 = root_new ['parrot';'Hash']
  vivify_630:
    set $P1836, $P1835["parameter"]
    unless_null $P1836, vivify_631
    new $P1836, "Undef"
  vivify_631:
    defined $I1837, $P1836
    unless $I1837, for_undef_632
    iter $P1834, $P1836
    new $P1847, 'ExceptionHandler'
    set_label $P1847, loop1846_handler
    $P1847."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1847
  loop1846_test:
    unless $P1834, loop1846_done
    shift $P1838, $P1834
  loop1846_redo:
    .const 'Sub' $P1840 = "102_1297619360.562" 
    capture_lex $P1840
    $P1840($P1838)
  loop1846_next:
    goto loop1846_test
  loop1846_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1848, exception, 'type'
    eq $P1848, .CONTROL_LOOP_NEXT, loop1846_next
    eq $P1848, .CONTROL_LOOP_REDO, loop1846_redo
  loop1846_done:
    pop_eh 
  for_undef_632:
.annotate 'line', 790
    .return ($P1834)
.end


.namespace ["NQP";"Actions"]
.sub "_block1815"  :anon :subid("101_1297619360.562") :outer("100_1297619360.562")
.annotate 'line', 793
    new $P1817, "Undef"
    .lex "$inv", $P1817
    find_lex $P1818, "$/"
    unless_null $P1818, vivify_625
    $P1818 = root_new ['parrot';'Hash']
  vivify_625:
    set $P1819, $P1818["invocant"]
    unless_null $P1819, vivify_626
    $P1819 = root_new ['parrot';'ResizablePMCArray']
  vivify_626:
    set $P1820, $P1819[0]
    unless_null $P1820, vivify_627
    new $P1820, "Undef"
  vivify_627:
    $P1821 = $P1820."ast"()
    store_lex "$inv", $P1821
.annotate 'line', 794
    find_lex $P1822, "$BLOCKINIT"
    find_lex $P1823, "$inv"
    $P1822."push"($P1823)
.annotate 'line', 795
    find_lex $P1824, "$BLOCKINIT"
    get_hll_global $P1825, ["PAST"], "Var"
.annotate 'line', 797
    get_hll_global $P1826, ["PAST"], "Var"
    find_lex $P1827, "$inv"
    $P1828 = $P1827."name"()
    $P1829 = $P1826."new"("lexical" :named("scope"), $P1828 :named("name"))
    $P1830 = $P1825."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1829 :named("viviself"))
.annotate 'line', 795
    $P1824."push"($P1830)
.annotate 'line', 799
    new $P1831, "Integer"
    assign $P1831, 1
    get_global $P1832, "@BLOCK"
    unless_null $P1832, vivify_628
    $P1832 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1832
  vivify_628:
    set $P1833, $P1832[0]
    unless_null $P1833, vivify_629
    $P1833 = root_new ['parrot';'Hash']
    set $P1832[0], $P1833
  vivify_629:
    set $P1833["signature_has_invocant"], $P1831
.annotate 'line', 792
    .return ($P1831)
.end


.namespace ["NQP";"Actions"]
.sub "_block1839"  :anon :subid("102_1297619360.562") :outer("100_1297619360.562")
    .param pmc param_1841
.annotate 'line', 801
    .lex "$_", param_1841
    find_lex $P1842, "$BLOCKINIT"
    find_lex $P1843, "$_"
    $P1844 = $P1843."ast"()
    $P1845 = $P1842."push"($P1844)
    .return ($P1845)
.end


.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("103_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1850
    .param pmc param_1851
.annotate 'line', 804
    .lex "self", param_1850
    .lex "$/", param_1851
.annotate 'line', 805
    new $P1852, "Undef"
    .lex "$quant", $P1852
.annotate 'line', 806
    new $P1853, "Undef"
    .lex "$past", $P1853
.annotate 'line', 805
    find_lex $P1854, "$/"
    unless_null $P1854, vivify_633
    $P1854 = root_new ['parrot';'Hash']
  vivify_633:
    set $P1855, $P1854["quant"]
    unless_null $P1855, vivify_634
    new $P1855, "Undef"
  vivify_634:
    store_lex "$quant", $P1855
    find_lex $P1856, "$past"
.annotate 'line', 807
    find_lex $P1858, "$/"
    unless_null $P1858, vivify_635
    $P1858 = root_new ['parrot';'Hash']
  vivify_635:
    set $P1859, $P1858["named_param"]
    unless_null $P1859, vivify_636
    new $P1859, "Undef"
  vivify_636:
    if $P1859, if_1857
.annotate 'line', 814
    find_lex $P1873, "$/"
    unless_null $P1873, vivify_637
    $P1873 = root_new ['parrot';'Hash']
  vivify_637:
    set $P1874, $P1873["param_var"]
    unless_null $P1874, vivify_638
    new $P1874, "Undef"
  vivify_638:
    $P1875 = $P1874."ast"()
    store_lex "$past", $P1875
.annotate 'line', 815
    find_lex $P1877, "$quant"
    set $S1878, $P1877
    iseq $I1879, $S1878, "*"
    if $I1879, if_1876
.annotate 'line', 819
    find_lex $P1888, "$quant"
    set $S1889, $P1888
    iseq $I1890, $S1889, "?"
    unless $I1890, if_1887_end
.annotate 'line', 820
    find_lex $P1891, "$past"
    find_lex $P1892, "$/"
    unless_null $P1892, vivify_639
    $P1892 = root_new ['parrot';'Hash']
  vivify_639:
    set $P1893, $P1892["param_var"]
    unless_null $P1893, vivify_640
    $P1893 = root_new ['parrot';'Hash']
  vivify_640:
    set $P1894, $P1893["sigil"]
    unless_null $P1894, vivify_641
    new $P1894, "Undef"
  vivify_641:
    $P1895 = "vivitype"($P1894)
    $P1891."viviself"($P1895)
  if_1887_end:
.annotate 'line', 819
    goto if_1876_end
  if_1876:
.annotate 'line', 816
    find_lex $P1880, "$past"
    $P1880."slurpy"(1)
.annotate 'line', 817
    find_lex $P1881, "$past"
    find_lex $P1882, "$/"
    unless_null $P1882, vivify_642
    $P1882 = root_new ['parrot';'Hash']
  vivify_642:
    set $P1883, $P1882["param_var"]
    unless_null $P1883, vivify_643
    $P1883 = root_new ['parrot';'Hash']
  vivify_643:
    set $P1884, $P1883["sigil"]
    unless_null $P1884, vivify_644
    new $P1884, "Undef"
  vivify_644:
    set $S1885, $P1884
    iseq $I1886, $S1885, "%"
    $P1881."named"($I1886)
  if_1876_end:
.annotate 'line', 813
    goto if_1857_end
  if_1857:
.annotate 'line', 808
    find_lex $P1860, "$/"
    unless_null $P1860, vivify_645
    $P1860 = root_new ['parrot';'Hash']
  vivify_645:
    set $P1861, $P1860["named_param"]
    unless_null $P1861, vivify_646
    new $P1861, "Undef"
  vivify_646:
    $P1862 = $P1861."ast"()
    store_lex "$past", $P1862
.annotate 'line', 809
    find_lex $P1864, "$quant"
    set $S1865, $P1864
    isne $I1866, $S1865, "!"
    unless $I1866, if_1863_end
.annotate 'line', 810
    find_lex $P1867, "$past"
    find_lex $P1868, "$/"
    unless_null $P1868, vivify_647
    $P1868 = root_new ['parrot';'Hash']
  vivify_647:
    set $P1869, $P1868["named_param"]
    unless_null $P1869, vivify_648
    $P1869 = root_new ['parrot';'Hash']
  vivify_648:
    set $P1870, $P1869["param_var"]
    unless_null $P1870, vivify_649
    $P1870 = root_new ['parrot';'Hash']
  vivify_649:
    set $P1871, $P1870["sigil"]
    unless_null $P1871, vivify_650
    new $P1871, "Undef"
  vivify_650:
    $P1872 = "vivitype"($P1871)
    $P1867."viviself"($P1872)
  if_1863_end:
  if_1857_end:
.annotate 'line', 823
    find_lex $P1897, "$/"
    unless_null $P1897, vivify_651
    $P1897 = root_new ['parrot';'Hash']
  vivify_651:
    set $P1898, $P1897["default_value"]
    unless_null $P1898, vivify_652
    new $P1898, "Undef"
  vivify_652:
    unless $P1898, if_1896_end
.annotate 'line', 824
    find_lex $P1900, "$quant"
    set $S1901, $P1900
    iseq $I1902, $S1901, "*"
    unless $I1902, if_1899_end
.annotate 'line', 825
    find_lex $P1903, "$/"
    $P1904 = $P1903."CURSOR"()
    $P1904."panic"("Can't put default on slurpy parameter")
  if_1899_end:
.annotate 'line', 827
    find_lex $P1906, "$quant"
    set $S1907, $P1906
    iseq $I1908, $S1907, "!"
    unless $I1908, if_1905_end
.annotate 'line', 828
    find_lex $P1909, "$/"
    $P1910 = $P1909."CURSOR"()
    $P1910."panic"("Can't put default on required parameter")
  if_1905_end:
.annotate 'line', 830
    find_lex $P1911, "$past"
    find_lex $P1912, "$/"
    unless_null $P1912, vivify_653
    $P1912 = root_new ['parrot';'Hash']
  vivify_653:
    set $P1913, $P1912["default_value"]
    unless_null $P1913, vivify_654
    $P1913 = root_new ['parrot';'ResizablePMCArray']
  vivify_654:
    set $P1914, $P1913[0]
    unless_null $P1914, vivify_655
    $P1914 = root_new ['parrot';'Hash']
  vivify_655:
    set $P1915, $P1914["EXPR"]
    unless_null $P1915, vivify_656
    new $P1915, "Undef"
  vivify_656:
    $P1916 = $P1915."ast"()
    $P1911."viviself"($P1916)
  if_1896_end:
.annotate 'line', 832
    find_lex $P1918, "$past"
    $P1919 = $P1918."viviself"()
    if $P1919, unless_1917_end
    get_global $P1920, "@BLOCK"
    unless_null $P1920, vivify_657
    $P1920 = root_new ['parrot';'ResizablePMCArray']
  vivify_657:
    set $P1921, $P1920[0]
    unless_null $P1921, vivify_658
    new $P1921, "Undef"
  vivify_658:
    get_global $P1922, "@BLOCK"
    unless_null $P1922, vivify_659
    $P1922 = root_new ['parrot';'ResizablePMCArray']
  vivify_659:
    set $P1923, $P1922[0]
    unless_null $P1923, vivify_660
    new $P1923, "Undef"
  vivify_660:
    $P1924 = $P1923."arity"()
    set $N1925, $P1924
    new $P1926, 'Float'
    set $P1926, $N1925
    add $P1927, $P1926, 1
    $P1921."arity"($P1927)
  unless_1917_end:
.annotate 'line', 836
    find_lex $P1929, "$/"
    unless_null $P1929, vivify_661
    $P1929 = root_new ['parrot';'Hash']
  vivify_661:
    set $P1930, $P1929["typename"]
    unless_null $P1930, vivify_662
    new $P1930, "Undef"
  vivify_662:
    unless $P1930, if_1928_end
.annotate 'line', 837
    find_lex $P1931, "$past"
    find_lex $P1932, "$/"
    unless_null $P1932, vivify_663
    $P1932 = root_new ['parrot';'Hash']
  vivify_663:
    set $P1933, $P1932["typename"]
    unless_null $P1933, vivify_664
    $P1933 = root_new ['parrot';'ResizablePMCArray']
  vivify_664:
    set $P1934, $P1933[0]
    unless_null $P1934, vivify_665
    new $P1934, "Undef"
  vivify_665:
    $P1935 = $P1934."ast"()
    $P1931."multitype"($P1935)
  if_1928_end:
.annotate 'line', 841
    find_lex $P1937, "$/"
    unless_null $P1937, vivify_666
    $P1937 = root_new ['parrot';'Hash']
  vivify_666:
    set $P1938, $P1937["definedness"]
    unless_null $P1938, vivify_667
    new $P1938, "Undef"
  vivify_667:
    unless $P1938, if_1936_end
.annotate 'line', 842
    find_lex $P1939, "$/"
    unless_null $P1939, vivify_668
    $P1939 = root_new ['parrot';'Hash']
  vivify_668:
    set $P1940, $P1939["definedness"]
    unless_null $P1940, vivify_669
    $P1940 = root_new ['parrot';'ResizablePMCArray']
  vivify_669:
    set $P1941, $P1940[0]
    unless_null $P1941, vivify_670
    new $P1941, "Undef"
  vivify_670:
    set $S1942, $P1941
    new $P1943, 'String'
    set $P1943, $S1942
    find_lex $P1944, "$past"
    unless_null $P1944, vivify_671
    $P1944 = root_new ['parrot';'Hash']
    store_lex "$past", $P1944
  vivify_671:
    set $P1944["definedness"], $P1943
  if_1936_end:
.annotate 'line', 845
    find_lex $P1945, "$/"
    find_lex $P1946, "$past"
    $P1947 = $P1945."!make"($P1946)
.annotate 'line', 804
    .return ($P1947)
.end


.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("104_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1949
    .param pmc param_1950
.annotate 'line', 848
    .lex "self", param_1949
    .lex "$/", param_1950
.annotate 'line', 849
    new $P1951, "Undef"
    .lex "$name", $P1951
.annotate 'line', 850
    new $P1952, "Undef"
    .lex "$past", $P1952
.annotate 'line', 849
    find_lex $P1953, "$/"
    set $S1954, $P1953
    new $P1955, 'String'
    set $P1955, $S1954
    store_lex "$name", $P1955
.annotate 'line', 850
    get_hll_global $P1956, ["PAST"], "Var"
    find_lex $P1957, "$name"
    find_lex $P1958, "$/"
    $P1959 = $P1956."new"($P1957 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P1958 :named("node"))
    store_lex "$past", $P1959
.annotate 'line', 852
    get_global $P1960, "@BLOCK"
    unless_null $P1960, vivify_672
    $P1960 = root_new ['parrot';'ResizablePMCArray']
  vivify_672:
    set $P1961, $P1960[0]
    unless_null $P1961, vivify_673
    new $P1961, "Undef"
  vivify_673:
    find_lex $P1962, "$name"
    $P1961."symbol"($P1962, "lexical" :named("scope"))
.annotate 'line', 853
    find_lex $P1963, "$/"
    find_lex $P1964, "$past"
    $P1965 = $P1963."!make"($P1964)
.annotate 'line', 848
    .return ($P1965)
.end


.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("105_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1967
    .param pmc param_1968
.annotate 'line', 856
    .lex "self", param_1967
    .lex "$/", param_1968
.annotate 'line', 857
    new $P1969, "Undef"
    .lex "$past", $P1969
    find_lex $P1970, "$/"
    unless_null $P1970, vivify_674
    $P1970 = root_new ['parrot';'Hash']
  vivify_674:
    set $P1971, $P1970["param_var"]
    unless_null $P1971, vivify_675
    new $P1971, "Undef"
  vivify_675:
    $P1972 = $P1971."ast"()
    store_lex "$past", $P1972
.annotate 'line', 858
    find_lex $P1973, "$past"
    find_lex $P1974, "$/"
    unless_null $P1974, vivify_676
    $P1974 = root_new ['parrot';'Hash']
  vivify_676:
    set $P1975, $P1974["param_var"]
    unless_null $P1975, vivify_677
    $P1975 = root_new ['parrot';'Hash']
  vivify_677:
    set $P1976, $P1975["name"]
    unless_null $P1976, vivify_678
    new $P1976, "Undef"
  vivify_678:
    set $S1977, $P1976
    $P1973."named"($S1977)
.annotate 'line', 859
    find_lex $P1978, "$/"
    find_lex $P1979, "$past"
    $P1980 = $P1978."!make"($P1979)
.annotate 'line', 856
    .return ($P1980)
.end


.namespace ["NQP";"Actions"]
.sub "typename"  :subid("106_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1982
    .param pmc param_1983
.annotate 'line', 862
    .lex "self", param_1982
    .lex "$/", param_1983
.annotate 'line', 863
    $P1984 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P1984
    get_hll_global $P1985, ["HLL"], "Compiler"
    find_lex $P1986, "$/"
    set $S1987, $P1986
    $P1988 = $P1985."parse_name"($S1987)
    store_lex "@name", $P1988
.annotate 'line', 864
    find_lex $P1989, "$/"
    get_hll_global $P1990, ["PAST"], "Var"
.annotate 'line', 865
    find_lex $P1991, "@name"
    $P1992 = $P1991."pop"()
    find_lex $P1993, "@name"
    $P1994 = $P1990."new"($P1992 :named("name"), $P1993 :named("namespace"), "package" :named("scope"))
.annotate 'line', 864
    $P1995 = $P1989."!make"($P1994)
.annotate 'line', 862
    .return ($P1995)
.end


.namespace ["NQP";"Actions"]
.sub "trait"  :subid("107_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_1997
    .param pmc param_1998
.annotate 'line', 871
    .lex "self", param_1997
    .lex "$/", param_1998
.annotate 'line', 872
    find_lex $P1999, "$/"
    find_lex $P2000, "$/"
    unless_null $P2000, vivify_679
    $P2000 = root_new ['parrot';'Hash']
  vivify_679:
    set $P2001, $P2000["trait_mod"]
    unless_null $P2001, vivify_680
    new $P2001, "Undef"
  vivify_680:
    $P2002 = $P2001."ast"()
    $P2003 = $P1999."!make"($P2002)
.annotate 'line', 871
    .return ($P2003)
.end


.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("108_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2005
    .param pmc param_2006
.annotate 'line', 875
    .const 'Sub' $P2026 = "109_1297619360.562" 
    capture_lex $P2026
    .lex "self", param_2005
    .lex "$/", param_2006
.annotate 'line', 876
    new $P2007, "Undef"
    .lex "$cpast", $P2007
    find_lex $P2008, "$/"
    unless_null $P2008, vivify_681
    $P2008 = root_new ['parrot';'Hash']
  vivify_681:
    set $P2009, $P2008["circumfix"]
    unless_null $P2009, vivify_682
    $P2009 = root_new ['parrot';'ResizablePMCArray']
  vivify_682:
    set $P2010, $P2009[0]
    unless_null $P2010, vivify_683
    new $P2010, "Undef"
  vivify_683:
    $P2011 = $P2010."ast"()
    store_lex "$cpast", $P2011
.annotate 'line', 877
    find_lex $P2014, "$/"
    unless_null $P2014, vivify_684
    $P2014 = root_new ['parrot';'Hash']
  vivify_684:
    set $P2015, $P2014["longname"]
    unless_null $P2015, vivify_685
    new $P2015, "Undef"
  vivify_685:
    set $S2016, $P2015
    iseq $I2017, $S2016, "parrot_vtable"
    if $I2017, if_2013
.annotate 'line', 897
    find_lex $P2052, "$/"
    unless_null $P2052, vivify_686
    $P2052 = root_new ['parrot';'Hash']
  vivify_686:
    set $P2053, $P2052["longname"]
    unless_null $P2053, vivify_687
    new $P2053, "Undef"
  vivify_687:
    set $S2054, $P2053
    iseq $I2055, $S2054, "pirflags"
    if $I2055, if_2051
.annotate 'line', 901
    find_lex $P2059, "$/"
    $P2060 = $P2059."CURSOR"()
    new $P2061, 'String'
    set $P2061, "Trait '"
    find_lex $P2062, "$/"
    unless_null $P2062, vivify_688
    $P2062 = root_new ['parrot';'Hash']
  vivify_688:
    set $P2063, $P2062["longname"]
    unless_null $P2063, vivify_689
    new $P2063, "Undef"
  vivify_689:
    concat $P2064, $P2061, $P2063
    concat $P2065, $P2064, "' not implemented"
    $P2066 = $P2060."panic"($P2065)
.annotate 'line', 900
    set $P2050, $P2066
.annotate 'line', 897
    goto if_2051_end
  if_2051:
.annotate 'line', 898
    find_lex $P2056, "$/"
    $P2057 = $P2056."CURSOR"()
    $P2058 = $P2057."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 897
    set $P2050, $P2058
  if_2051_end:
    set $P2012, $P2050
.annotate 'line', 877
    goto if_2013_end
  if_2013:
.annotate 'line', 880
    get_hll_global $P2019, ["PAST"], "Val"
    find_lex $P2020, "$cpast"
    $P2021 = $P2019."ACCEPTS"($P2020)
    if $P2021, unless_2018_end
.annotate 'line', 879
    find_lex $P2022, "$/"
    $P2023 = $P2022."CURSOR"()
    $P2023."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_2018_end:
.annotate 'line', 881
    find_lex $P2024, "$/"
    .const 'Sub' $P2026 = "109_1297619360.562" 
    newclosure $P2048, $P2026
    $P2049 = $P2024."!make"($P2048)
.annotate 'line', 877
    set $P2012, $P2049
  if_2013_end:
.annotate 'line', 875
    .return ($P2012)
.end


.namespace ["NQP";"Actions"]
.sub "_block2025"  :anon :subid("109_1297619360.562") :outer("108_1297619360.562")
    .param pmc param_2027
.annotate 'line', 881
    .lex "$match", param_2027
.annotate 'line', 882
    new $P2028, "Undef"
    .lex "$meth", $P2028
    find_lex $P2029, "$match"
    $P2030 = $P2029."ast"()
    set $P2031, $P2030["block_past"]
    unless_null $P2031, vivify_690
    new $P2031, "Undef"
  vivify_690:
    store_lex "$meth", $P2031
.annotate 'line', 883
    find_dynamic_lex $P2034, "$*PACKAGE-SETUP"
    unless_null $P2034, vivify_691
    get_hll_global $P2034, "$PACKAGE-SETUP"
    unless_null $P2034, vivify_692
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_692:
  vivify_691:
    defined $I2035, $P2034
    if $I2035, if_2033
    new $P2032, 'Integer'
    set $P2032, $I2035
    goto if_2033_end
  if_2033:
.annotate 'line', 884
    find_dynamic_lex $P2036, "$*PACKAGE-SETUP"
    unless_null $P2036, vivify_693
    get_hll_global $P2036, "$PACKAGE-SETUP"
    unless_null $P2036, vivify_694
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_694:
  vivify_693:
    get_hll_global $P2037, ["PAST"], "Op"
.annotate 'line', 886
    get_hll_global $P2038, ["PAST"], "Op"
.annotate 'line', 889
    get_hll_global $P2039, ["PAST"], "Var"
    $P2040 = $P2039."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2041 = $P2038."new"($P2040, "get_how PP" :named("pirop"))
.annotate 'line', 891
    get_hll_global $P2042, ["PAST"], "Var"
    $P2043 = $P2042."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P2044, "$cpast"
    find_lex $P2045, "$meth"
    $P2046 = $P2037."new"($P2041, $P2043, $P2044, $P2045, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 884
    $P2047 = $P2036."push"($P2046)
.annotate 'line', 883
    set $P2032, $P2047
  if_2033_end:
.annotate 'line', 881
    .return ($P2032)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("110_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2070
    .param pmc param_2071
    .param pmc param_2072 :optional
    .param int has_param_2072 :opt_flag
.annotate 'line', 905
    .const 'Sub' $P2170 = "113_1297619360.562" 
    capture_lex $P2170
    .const 'Sub' $P2142 = "112_1297619360.562" 
    capture_lex $P2142
    .const 'Sub' $P2115 = "111_1297619360.562" 
    capture_lex $P2115
    new $P2069, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2069, control_2068
    push_eh $P2069
    .lex "self", param_2070
    .lex "$/", param_2071
    if has_param_2072, optparam_695
    new $P2073, "Undef"
    set param_2072, $P2073
  optparam_695:
    .lex "$key", param_2072
.annotate 'line', 906
    $P2074 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2074
.annotate 'line', 909
    new $P2075, "Undef"
    .lex "$name", $P2075
.annotate 'line', 910
    new $P2076, "Undef"
    .lex "$past", $P2076
.annotate 'line', 906

        $P2077 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2077
.annotate 'line', 909
    find_lex $P2078, "$/"
    unless_null $P2078, vivify_696
    $P2078 = root_new ['parrot';'Hash']
  vivify_696:
    set $P2079, $P2078["deflongname"]
    unless_null $P2079, vivify_697
    new $P2079, "Undef"
  vivify_697:
    $P2080 = $P2079."ast"()
    set $S2081, $P2080
    new $P2082, 'String'
    set $P2082, $S2081
    store_lex "$name", $P2082
    find_lex $P2083, "$past"
.annotate 'line', 911
    find_lex $P2085, "$/"
    unless_null $P2085, vivify_698
    $P2085 = root_new ['parrot';'Hash']
  vivify_698:
    set $P2086, $P2085["proto"]
    unless_null $P2086, vivify_699
    new $P2086, "Undef"
  vivify_699:
    if $P2086, if_2084
.annotate 'line', 950
    find_lex $P2138, "$key"
    set $S2139, $P2138
    iseq $I2140, $S2139, "open"
    if $I2140, if_2137
.annotate 'line', 963
    .const 'Sub' $P2170 = "113_1297619360.562" 
    capture_lex $P2170
    $P2170()
    goto if_2137_end
  if_2137:
.annotate 'line', 950
    .const 'Sub' $P2142 = "112_1297619360.562" 
    capture_lex $P2142
    $P2142()
  if_2137_end:
    goto if_2084_end
  if_2084:
.annotate 'line', 913
    get_hll_global $P2087, ["PAST"], "Stmts"
.annotate 'line', 914
    get_hll_global $P2088, ["PAST"], "Block"
    find_lex $P2089, "$name"
.annotate 'line', 915
    get_hll_global $P2090, ["PAST"], "Op"
.annotate 'line', 916
    get_hll_global $P2091, ["PAST"], "Var"
    $P2092 = $P2091."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2093, "$name"
    $P2094 = $P2090."new"($P2092, $P2093, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 915
    find_lex $P2095, "$/"
    $P2096 = $P2088."new"($P2094, $P2089 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2095 :named("node"))
.annotate 'line', 925
    get_hll_global $P2097, ["PAST"], "Block"
    new $P2098, "String"
    assign $P2098, "!PREFIX__"
    find_lex $P2099, "$name"
    concat $P2100, $P2098, $P2099
.annotate 'line', 926
    get_hll_global $P2101, ["PAST"], "Op"
.annotate 'line', 927
    get_hll_global $P2102, ["PAST"], "Var"
    $P2103 = $P2102."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2104, "$name"
    $P2105 = $P2101."new"($P2103, $P2104, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 926
    find_lex $P2106, "$/"
    $P2107 = $P2097."new"($P2105, $P2100 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2106 :named("node"))
.annotate 'line', 925
    $P2108 = $P2087."new"($P2096, $P2107)
.annotate 'line', 913
    store_lex "$past", $P2108
.annotate 'line', 937
    find_lex $P2110, "$past"
    $P2111 = $P2110."list"()
    defined $I2112, $P2111
    unless $I2112, for_undef_720
    iter $P2109, $P2111
    new $P2135, 'ExceptionHandler'
    set_label $P2135, loop2134_handler
    $P2135."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2135
  loop2134_test:
    unless $P2109, loop2134_done
    shift $P2113, $P2109
  loop2134_redo:
    .const 'Sub' $P2115 = "111_1297619360.562" 
    capture_lex $P2115
    $P2115($P2113)
  loop2134_next:
    goto loop2134_test
  loop2134_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2136, exception, 'type'
    eq $P2136, .CONTROL_LOOP_NEXT, loop2134_next
    eq $P2136, .CONTROL_LOOP_REDO, loop2134_redo
  loop2134_done:
    pop_eh 
  for_undef_720:
  if_2084_end:
.annotate 'line', 999
    find_lex $P2228, "$/"
    find_lex $P2229, "$past"
    $P2230 = $P2228."!make"($P2229)
.annotate 'line', 905
    .return ($P2230)
  control_2068:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2231, exception, "payload"
    .return ($P2231)
.end


.namespace ["NQP";"Actions"]
.sub "_block2169"  :anon :subid("113_1297619360.562") :outer("110_1297619360.562")
.annotate 'line', 964
    new $P2171, "Undef"
    .lex "$regex", $P2171
.annotate 'line', 965
    get_hll_global $P2172, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2173, "$/"
    unless_null $P2173, vivify_700
    $P2173 = root_new ['parrot';'Hash']
  vivify_700:
    set $P2174, $P2173["p6regex"]
    unless_null $P2174, vivify_701
    new $P2174, "Undef"
  vivify_701:
    $P2175 = $P2174."ast"()
    get_global $P2176, "@BLOCK"
    $P2177 = $P2176."shift"()
    $P2178 = $P2172($P2175, $P2177)
    store_lex "$regex", $P2178
.annotate 'line', 966
    find_lex $P2179, "$regex"
    find_lex $P2180, "$name"
    $P2179."name"($P2180)
.annotate 'line', 968
    get_hll_global $P2181, ["PAST"], "Op"
.annotate 'line', 970
    get_hll_global $P2182, ["PAST"], "Var"
    new $P2183, "ResizablePMCArray"
    push $P2183, "Regex"
    $P2184 = $P2182."new"("Method" :named("name"), $P2183 :named("namespace"), "package" :named("scope"))
    find_lex $P2185, "$regex"
    $P2186 = $P2181."new"($P2184, $P2185, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 968
    store_lex "$past", $P2186
.annotate 'line', 973
    find_dynamic_lex $P2188, "$*PACKAGE-SETUP"
    unless_null $P2188, vivify_702
    get_hll_global $P2188, "$PACKAGE-SETUP"
    unless_null $P2188, vivify_703
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_703:
  vivify_702:
    defined $I2189, $P2188
    unless $I2189, if_2187_end
.annotate 'line', 974
    find_dynamic_lex $P2190, "$*PACKAGE-SETUP"
    unless_null $P2190, vivify_704
    get_hll_global $P2190, "$PACKAGE-SETUP"
    unless_null $P2190, vivify_705
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_705:
  vivify_704:
    get_hll_global $P2191, ["PAST"], "Op"
.annotate 'line', 976
    get_hll_global $P2192, ["PAST"], "Op"
.annotate 'line', 978
    get_hll_global $P2193, ["PAST"], "Var"
    $P2194 = $P2193."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2195 = $P2192."new"($P2194, "get_how PP" :named("pirop"))
.annotate 'line', 980
    get_hll_global $P2196, ["PAST"], "Var"
    $P2197 = $P2196."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 981
    get_hll_global $P2198, ["PAST"], "Val"
    find_lex $P2199, "$name"
    $P2200 = $P2198."new"($P2199 :named("value"))
.annotate 'line', 982
    get_hll_global $P2201, ["PAST"], "Val"
    find_lex $P2202, "$regex"
    $P2203 = $P2201."new"($P2202 :named("value"))
    $P2204 = $P2191."new"($P2195, $P2197, $P2200, $P2203, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 974
    $P2190."push"($P2204)
.annotate 'line', 984
    find_dynamic_lex $P2205, "$*PACKAGE-SETUP"
    unless_null $P2205, vivify_706
    get_hll_global $P2205, "$PACKAGE-SETUP"
    unless_null $P2205, vivify_707
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_707:
  vivify_706:
    get_hll_global $P2206, ["PAST"], "Op"
.annotate 'line', 986
    get_hll_global $P2207, ["PAST"], "Op"
.annotate 'line', 988
    get_hll_global $P2208, ["PAST"], "Var"
    $P2209 = $P2208."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2210 = $P2207."new"($P2209, "get_how PP" :named("pirop"))
.annotate 'line', 990
    get_hll_global $P2211, ["PAST"], "Var"
    $P2212 = $P2211."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 991
    get_hll_global $P2213, ["PAST"], "Val"
    new $P2214, "String"
    assign $P2214, "!PREFIX__"
    find_lex $P2215, "$name"
    concat $P2216, $P2214, $P2215
    $P2217 = $P2213."new"($P2216 :named("value"))
.annotate 'line', 992
    get_hll_global $P2218, ["PAST"], "Var"
    new $P2219, "String"
    assign $P2219, "!PREFIX__"
    find_lex $P2220, "$name"
    concat $P2221, $P2219, $P2220
    $P2222 = $P2218."new"($P2221 :named("name"), "package" :named("scope"))
    $P2223 = $P2206."new"($P2210, $P2212, $P2217, $P2222, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 984
    $P2205."push"($P2223)
  if_2187_end:
.annotate 'line', 996
    find_lex $P2224, "$regex"
    find_lex $P2225, "$past"
    unless_null $P2225, vivify_708
    $P2225 = root_new ['parrot';'Hash']
    store_lex "$past", $P2225
  vivify_708:
    set $P2225["sink"], $P2224
.annotate 'line', 997
    find_lex $P2226, "@MODIFIERS"
    $P2227 = $P2226."shift"()
.annotate 'line', 963
    .return ($P2227)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2141"  :anon :subid("112_1297619360.562") :outer("110_1297619360.562")
.annotate 'line', 951
    $P2143 = root_new ['parrot';'Hash']
    .lex "%h", $P2143
.annotate 'line', 950
    find_lex $P2144, "%h"
.annotate 'line', 952
    find_lex $P2146, "$/"
    unless_null $P2146, vivify_709
    $P2146 = root_new ['parrot';'Hash']
  vivify_709:
    set $P2147, $P2146["sym"]
    unless_null $P2147, vivify_710
    new $P2147, "Undef"
  vivify_710:
    set $S2148, $P2147
    iseq $I2149, $S2148, "token"
    unless $I2149, if_2145_end
    new $P2150, "Integer"
    assign $P2150, 1
    find_lex $P2151, "%h"
    unless_null $P2151, vivify_711
    $P2151 = root_new ['parrot';'Hash']
    store_lex "%h", $P2151
  vivify_711:
    set $P2151["r"], $P2150
  if_2145_end:
.annotate 'line', 953
    find_lex $P2153, "$/"
    unless_null $P2153, vivify_712
    $P2153 = root_new ['parrot';'Hash']
  vivify_712:
    set $P2154, $P2153["sym"]
    unless_null $P2154, vivify_713
    new $P2154, "Undef"
  vivify_713:
    set $S2155, $P2154
    iseq $I2156, $S2155, "rule"
    unless $I2156, if_2152_end
    new $P2157, "Integer"
    assign $P2157, 1
    find_lex $P2158, "%h"
    unless_null $P2158, vivify_714
    $P2158 = root_new ['parrot';'Hash']
    store_lex "%h", $P2158
  vivify_714:
    set $P2158["r"], $P2157
    new $P2159, "Integer"
    assign $P2159, 1
    find_lex $P2160, "%h"
    unless_null $P2160, vivify_715
    $P2160 = root_new ['parrot';'Hash']
    store_lex "%h", $P2160
  vivify_715:
    set $P2160["s"], $P2159
  if_2152_end:
.annotate 'line', 954
    find_lex $P2161, "@MODIFIERS"
    find_lex $P2162, "%h"
    $P2161."unshift"($P2162)
.annotate 'line', 955

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 959
    get_global $P2163, "@BLOCK"
    unless_null $P2163, vivify_716
    $P2163 = root_new ['parrot';'ResizablePMCArray']
  vivify_716:
    set $P2164, $P2163[0]
    unless_null $P2164, vivify_717
    new $P2164, "Undef"
  vivify_717:
    $P2164."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 960
    get_global $P2165, "@BLOCK"
    unless_null $P2165, vivify_718
    $P2165 = root_new ['parrot';'ResizablePMCArray']
  vivify_718:
    set $P2166, $P2165[0]
    unless_null $P2166, vivify_719
    new $P2166, "Undef"
  vivify_719:
    $P2166."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 961
    new $P2167, "Exception"
    set $P2167['type'], .CONTROL_RETURN
    new $P2168, "Integer"
    assign $P2168, 0
    setattribute $P2167, 'payload', $P2168
    throw $P2167
.annotate 'line', 950
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "_block2114"  :anon :subid("111_1297619360.562") :outer("110_1297619360.562")
    .param pmc param_2116
.annotate 'line', 937
    .lex "$_", param_2116
.annotate 'line', 938
    find_dynamic_lex $P2117, "$*PACKAGE-SETUP"
    unless_null $P2117, vivify_721
    get_hll_global $P2117, "$PACKAGE-SETUP"
    unless_null $P2117, vivify_722
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_722:
  vivify_721:
    get_hll_global $P2118, ["PAST"], "Op"
.annotate 'line', 940
    get_hll_global $P2119, ["PAST"], "Op"
.annotate 'line', 942
    get_hll_global $P2120, ["PAST"], "Var"
    $P2121 = $P2120."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2122 = $P2119."new"($P2121, "get_how PP" :named("pirop"))
.annotate 'line', 944
    get_hll_global $P2123, ["PAST"], "Var"
    $P2124 = $P2123."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 945
    get_hll_global $P2125, ["PAST"], "Val"
    find_lex $P2126, "$_"
    $P2127 = $P2126."name"()
    $P2128 = $P2125."new"($P2127 :named("value"))
.annotate 'line', 946
    get_hll_global $P2129, ["PAST"], "Val"
    find_lex $P2130, "$_"
    $P2131 = $P2129."new"($P2130 :named("value"))
    $P2132 = $P2118."new"($P2122, $P2124, $P2128, $P2131, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 938
    $P2133 = $P2117."push"($P2132)
.annotate 'line', 937
    .return ($P2133)
.end


.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("114_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2233
    .param pmc param_2234
.annotate 'line', 1003
    .lex "self", param_2233
    .lex "$/", param_2234
.annotate 'line', 1004
    new $P2235, "Undef"
    .lex "$past", $P2235
    find_lex $P2238, "$/"
    unless_null $P2238, vivify_723
    $P2238 = root_new ['parrot';'Hash']
  vivify_723:
    set $P2239, $P2238["args"]
    unless_null $P2239, vivify_724
    new $P2239, "Undef"
  vivify_724:
    if $P2239, if_2237
    get_hll_global $P2244, ["PAST"], "Op"
    find_lex $P2245, "$/"
    $P2246 = $P2244."new"($P2245 :named("node"))
    set $P2236, $P2246
    goto if_2237_end
  if_2237:
    find_lex $P2240, "$/"
    unless_null $P2240, vivify_725
    $P2240 = root_new ['parrot';'Hash']
  vivify_725:
    set $P2241, $P2240["args"]
    unless_null $P2241, vivify_726
    $P2241 = root_new ['parrot';'ResizablePMCArray']
  vivify_726:
    set $P2242, $P2241[0]
    unless_null $P2242, vivify_727
    new $P2242, "Undef"
  vivify_727:
    $P2243 = $P2242."ast"()
    set $P2236, $P2243
  if_2237_end:
    store_lex "$past", $P2236
.annotate 'line', 1005
    find_lex $P2248, "$/"
    unless_null $P2248, vivify_728
    $P2248 = root_new ['parrot';'Hash']
  vivify_728:
    set $P2249, $P2248["quote"]
    unless_null $P2249, vivify_729
    new $P2249, "Undef"
  vivify_729:
    if $P2249, if_2247
.annotate 'line', 1009
    find_lex $P2256, "$/"
    unless_null $P2256, vivify_730
    $P2256 = root_new ['parrot';'Hash']
  vivify_730:
    set $P2257, $P2256["longname"]
    unless_null $P2257, vivify_731
    new $P2257, "Undef"
  vivify_731:
    set $S2258, $P2257
    iseq $I2259, $S2258, "HOW"
    if $I2259, if_2255
.annotate 'line', 1013
    find_lex $P2263, "$/"
    unless_null $P2263, vivify_732
    $P2263 = root_new ['parrot';'Hash']
  vivify_732:
    set $P2264, $P2263["longname"]
    unless_null $P2264, vivify_733
    new $P2264, "Undef"
  vivify_733:
    set $S2265, $P2264
    iseq $I2266, $S2265, "WHAT"
    if $I2266, if_2262
.annotate 'line', 1017
    find_lex $P2268, "$past"
    find_lex $P2269, "$/"
    unless_null $P2269, vivify_734
    $P2269 = root_new ['parrot';'Hash']
  vivify_734:
    set $P2270, $P2269["longname"]
    unless_null $P2270, vivify_735
    new $P2270, "Undef"
  vivify_735:
    set $S2271, $P2270
    $P2268."name"($S2271)
.annotate 'line', 1018
    find_lex $P2272, "$past"
    $P2272."pasttype"("callmethod")
.annotate 'line', 1016
    goto if_2262_end
  if_2262:
.annotate 'line', 1014
    find_lex $P2267, "$past"
    $P2267."pirop"("get_what PP")
  if_2262_end:
.annotate 'line', 1013
    goto if_2255_end
  if_2255:
.annotate 'line', 1010
    find_lex $P2260, "$past"
    $P2260."pirop"("get_how PP")
.annotate 'line', 1011
    find_lex $P2261, "$past"
    $P2261."pasttype"("pirop")
  if_2255_end:
.annotate 'line', 1009
    goto if_2247_end
  if_2247:
.annotate 'line', 1006
    find_lex $P2250, "$past"
    find_lex $P2251, "$/"
    unless_null $P2251, vivify_736
    $P2251 = root_new ['parrot';'Hash']
  vivify_736:
    set $P2252, $P2251["quote"]
    unless_null $P2252, vivify_737
    new $P2252, "Undef"
  vivify_737:
    $P2253 = $P2252."ast"()
    $P2250."name"($P2253)
.annotate 'line', 1007
    find_lex $P2254, "$past"
    $P2254."pasttype"("callmethod")
  if_2247_end:
.annotate 'line', 1020
    find_lex $P2273, "$/"
    find_lex $P2274, "$past"
    $P2275 = $P2273."!make"($P2274)
.annotate 'line', 1003
    .return ($P2275)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("115_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2277
    .param pmc param_2278
.annotate 'line', 1025
    .lex "self", param_2277
    .lex "$/", param_2278
.annotate 'line', 1026
    find_lex $P2279, "$/"
    get_hll_global $P2280, ["PAST"], "Var"
    $P2281 = $P2280."new"("self" :named("name"))
    $P2282 = $P2279."!make"($P2281)
.annotate 'line', 1025
    .return ($P2282)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("116_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2284
    .param pmc param_2285
.annotate 'line', 1029
    .lex "self", param_2284
    .lex "$/", param_2285
.annotate 'line', 1030
    new $P2286, "Undef"
    .lex "$past", $P2286
    find_lex $P2287, "$/"
    unless_null $P2287, vivify_738
    $P2287 = root_new ['parrot';'Hash']
  vivify_738:
    set $P2288, $P2287["args"]
    unless_null $P2288, vivify_739
    new $P2288, "Undef"
  vivify_739:
    $P2289 = $P2288."ast"()
    store_lex "$past", $P2289
.annotate 'line', 1031
    find_lex $P2290, "$past"
    find_lex $P2291, "$/"
    unless_null $P2291, vivify_740
    $P2291 = root_new ['parrot';'Hash']
  vivify_740:
    set $P2292, $P2291["deflongname"]
    unless_null $P2292, vivify_741
    new $P2292, "Undef"
  vivify_741:
    set $S2293, $P2292
    $P2290."name"($S2293)
.annotate 'line', 1032
    find_lex $P2294, "$/"
    find_lex $P2295, "$past"
    $P2296 = $P2294."!make"($P2295)
.annotate 'line', 1029
    .return ($P2296)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("117_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2298
    .param pmc param_2299
.annotate 'line', 1035
    .lex "self", param_2298
    .lex "$/", param_2299
.annotate 'line', 1036
    $P2300 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2300
.annotate 'line', 1037
    new $P2301, "Undef"
    .lex "$name", $P2301
.annotate 'line', 1039
    new $P2302, "Undef"
    .lex "$var", $P2302
.annotate 'line', 1041
    new $P2303, "Undef"
    .lex "$past", $P2303
.annotate 'line', 1036
    find_lex $P2304, "$/"
    unless_null $P2304, vivify_742
    $P2304 = root_new ['parrot';'Hash']
  vivify_742:
    set $P2305, $P2304["name"]
    unless_null $P2305, vivify_743
    $P2305 = root_new ['parrot';'Hash']
  vivify_743:
    set $P2306, $P2305["identifier"]
    unless_null $P2306, vivify_744
    new $P2306, "Undef"
  vivify_744:
    clone $P2307, $P2306
    store_lex "@ns", $P2307
.annotate 'line', 1037
    find_lex $P2308, "@ns"
    $P2309 = $P2308."pop"()
    store_lex "$name", $P2309
.annotate 'line', 1038
    find_lex $P2313, "@ns"
    if $P2313, if_2312
    set $P2311, $P2313
    goto if_2312_end
  if_2312:
    find_lex $P2314, "@ns"
    unless_null $P2314, vivify_745
    $P2314 = root_new ['parrot';'ResizablePMCArray']
  vivify_745:
    set $P2315, $P2314[0]
    unless_null $P2315, vivify_746
    new $P2315, "Undef"
  vivify_746:
    set $S2316, $P2315
    iseq $I2317, $S2316, "GLOBAL"
    new $P2311, 'Integer'
    set $P2311, $I2317
  if_2312_end:
    unless $P2311, if_2310_end
    find_lex $P2318, "@ns"
    $P2318."shift"()
  if_2310_end:
.annotate 'line', 1040
    get_hll_global $P2319, ["PAST"], "Var"
    find_lex $P2320, "$name"
    set $S2321, $P2320
    find_lex $P2322, "@ns"
    $P2323 = $P2319."new"($S2321 :named("name"), $P2322 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2323
.annotate 'line', 1041
    find_lex $P2324, "$var"
    store_lex "$past", $P2324
.annotate 'line', 1042
    find_lex $P2326, "$/"
    unless_null $P2326, vivify_747
    $P2326 = root_new ['parrot';'Hash']
  vivify_747:
    set $P2327, $P2326["args"]
    unless_null $P2327, vivify_748
    new $P2327, "Undef"
  vivify_748:
    unless $P2327, if_2325_end
.annotate 'line', 1043
    find_lex $P2328, "$/"
    unless_null $P2328, vivify_749
    $P2328 = root_new ['parrot';'Hash']
  vivify_749:
    set $P2329, $P2328["args"]
    unless_null $P2329, vivify_750
    $P2329 = root_new ['parrot';'ResizablePMCArray']
  vivify_750:
    set $P2330, $P2329[0]
    unless_null $P2330, vivify_751
    new $P2330, "Undef"
  vivify_751:
    $P2331 = $P2330."ast"()
    store_lex "$past", $P2331
.annotate 'line', 1044
    find_lex $P2332, "$past"
    find_lex $P2333, "$var"
    $P2332."unshift"($P2333)
  if_2325_end:
.annotate 'line', 1046
    find_lex $P2334, "$/"
    find_lex $P2335, "$past"
    $P2336 = $P2334."!make"($P2335)
.annotate 'line', 1035
    .return ($P2336)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("118_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2338
    .param pmc param_2339
.annotate 'line', 1049
    .lex "self", param_2338
    .lex "$/", param_2339
.annotate 'line', 1050
    new $P2340, "Undef"
    .lex "$past", $P2340
.annotate 'line', 1051
    new $P2341, "Undef"
    .lex "$pirop", $P2341
.annotate 'line', 1050
    find_lex $P2344, "$/"
    unless_null $P2344, vivify_752
    $P2344 = root_new ['parrot';'Hash']
  vivify_752:
    set $P2345, $P2344["args"]
    unless_null $P2345, vivify_753
    new $P2345, "Undef"
  vivify_753:
    if $P2345, if_2343
    get_hll_global $P2350, ["PAST"], "Op"
    find_lex $P2351, "$/"
    $P2352 = $P2350."new"($P2351 :named("node"))
    set $P2342, $P2352
    goto if_2343_end
  if_2343:
    find_lex $P2346, "$/"
    unless_null $P2346, vivify_754
    $P2346 = root_new ['parrot';'Hash']
  vivify_754:
    set $P2347, $P2346["args"]
    unless_null $P2347, vivify_755
    $P2347 = root_new ['parrot';'ResizablePMCArray']
  vivify_755:
    set $P2348, $P2347[0]
    unless_null $P2348, vivify_756
    new $P2348, "Undef"
  vivify_756:
    $P2349 = $P2348."ast"()
    set $P2342, $P2349
  if_2343_end:
    store_lex "$past", $P2342
.annotate 'line', 1051
    find_lex $P2353, "$/"
    unless_null $P2353, vivify_757
    $P2353 = root_new ['parrot';'Hash']
  vivify_757:
    set $P2354, $P2353["op"]
    unless_null $P2354, vivify_758
    new $P2354, "Undef"
  vivify_758:
    set $S2355, $P2354
    new $P2356, 'String'
    set $P2356, $S2355
    store_lex "$pirop", $P2356
.annotate 'line', 1052

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2357 = box $S0
    
    store_lex "$pirop", $P2357
.annotate 'line', 1059
    find_lex $P2358, "$past"
    find_lex $P2359, "$pirop"
    $P2358."pirop"($P2359)
.annotate 'line', 1060
    find_lex $P2360, "$past"
    $P2360."pasttype"("pirop")
.annotate 'line', 1061
    find_lex $P2361, "$/"
    find_lex $P2362, "$past"
    $P2363 = $P2361."!make"($P2362)
.annotate 'line', 1049
    .return ($P2363)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("119_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2365
    .param pmc param_2366
.annotate 'line', 1064
    .lex "self", param_2365
    .lex "$/", param_2366
.annotate 'line', 1065
    find_lex $P2367, "$/"
    get_hll_global $P2368, ["PAST"], "Op"
    $P2369 = $P2368."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2370 = $P2367."!make"($P2369)
.annotate 'line', 1064
    .return ($P2370)
.end


.namespace ["NQP";"Actions"]
.sub "args"  :subid("120_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2372
    .param pmc param_2373
.annotate 'line', 1070
    .lex "self", param_2372
    .lex "$/", param_2373
    find_lex $P2374, "$/"
    find_lex $P2375, "$/"
    unless_null $P2375, vivify_759
    $P2375 = root_new ['parrot';'Hash']
  vivify_759:
    set $P2376, $P2375["arglist"]
    unless_null $P2376, vivify_760
    new $P2376, "Undef"
  vivify_760:
    $P2377 = $P2376."ast"()
    $P2378 = $P2374."!make"($P2377)
    .return ($P2378)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("121_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2380
    .param pmc param_2381
.annotate 'line', 1072
    .const 'Sub' $P2392 = "122_1297619360.562" 
    capture_lex $P2392
    .lex "self", param_2380
    .lex "$/", param_2381
.annotate 'line', 1073
    new $P2382, "Undef"
    .lex "$past", $P2382
.annotate 'line', 1081
    new $P2383, "Undef"
    .lex "$i", $P2383
.annotate 'line', 1082
    new $P2384, "Undef"
    .lex "$n", $P2384
.annotate 'line', 1073
    get_hll_global $P2385, ["PAST"], "Op"
    find_lex $P2386, "$/"
    $P2387 = $P2385."new"("call" :named("pasttype"), $P2386 :named("node"))
    store_lex "$past", $P2387
.annotate 'line', 1074
    find_lex $P2389, "$/"
    unless_null $P2389, vivify_761
    $P2389 = root_new ['parrot';'Hash']
  vivify_761:
    set $P2390, $P2389["EXPR"]
    unless_null $P2390, vivify_762
    new $P2390, "Undef"
  vivify_762:
    unless $P2390, if_2388_end
    .const 'Sub' $P2392 = "122_1297619360.562" 
    capture_lex $P2392
    $P2392()
  if_2388_end:
.annotate 'line', 1081
    new $P2424, "Integer"
    assign $P2424, 0
    store_lex "$i", $P2424
.annotate 'line', 1082
    find_lex $P2425, "$past"
    $P2426 = $P2425."list"()
    set $N2427, $P2426
    new $P2428, 'Float'
    set $P2428, $N2427
    store_lex "$n", $P2428
.annotate 'line', 1083
    new $P2476, 'ExceptionHandler'
    set_label $P2476, loop2475_handler
    $P2476."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2476
  loop2475_test:
    find_lex $P2429, "$i"
    set $N2430, $P2429
    find_lex $P2431, "$n"
    set $N2432, $P2431
    islt $I2433, $N2430, $N2432
    unless $I2433, loop2475_done
  loop2475_redo:
.annotate 'line', 1084
    find_lex $P2435, "$i"
    set $I2436, $P2435
    find_lex $P2437, "$past"
    unless_null $P2437, vivify_766
    $P2437 = root_new ['parrot';'ResizablePMCArray']
  vivify_766:
    set $P2438, $P2437[$I2436]
    unless_null $P2438, vivify_767
    new $P2438, "Undef"
  vivify_767:
    $S2439 = $P2438."name"()
    iseq $I2440, $S2439, "&prefix:<|>"
    unless $I2440, if_2434_end
.annotate 'line', 1085
    find_lex $P2441, "$i"
    set $I2442, $P2441
    find_lex $P2443, "$past"
    unless_null $P2443, vivify_768
    $P2443 = root_new ['parrot';'ResizablePMCArray']
  vivify_768:
    set $P2444, $P2443[$I2442]
    unless_null $P2444, vivify_769
    $P2444 = root_new ['parrot';'ResizablePMCArray']
  vivify_769:
    set $P2445, $P2444[0]
    unless_null $P2445, vivify_770
    new $P2445, "Undef"
  vivify_770:
    find_lex $P2446, "$i"
    set $I2447, $P2446
    find_lex $P2448, "$past"
    unless_null $P2448, vivify_771
    $P2448 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2448
  vivify_771:
    set $P2448[$I2447], $P2445
.annotate 'line', 1086
    find_lex $P2449, "$i"
    set $I2450, $P2449
    find_lex $P2451, "$past"
    unless_null $P2451, vivify_772
    $P2451 = root_new ['parrot';'ResizablePMCArray']
  vivify_772:
    set $P2452, $P2451[$I2450]
    unless_null $P2452, vivify_773
    new $P2452, "Undef"
  vivify_773:
    $P2452."flat"(1)
.annotate 'line', 1087
    find_lex $P2456, "$i"
    set $I2457, $P2456
    find_lex $P2458, "$past"
    unless_null $P2458, vivify_774
    $P2458 = root_new ['parrot';'ResizablePMCArray']
  vivify_774:
    set $P2459, $P2458[$I2457]
    unless_null $P2459, vivify_775
    new $P2459, "Undef"
  vivify_775:
    get_hll_global $P2460, ["PAST"], "Val"
    $P2461 = $P2459."isa"($P2460)
    if $P2461, if_2455
    set $P2454, $P2461
    goto if_2455_end
  if_2455:
.annotate 'line', 1088
    find_lex $P2462, "$i"
    set $I2463, $P2462
    find_lex $P2464, "$past"
    unless_null $P2464, vivify_776
    $P2464 = root_new ['parrot';'ResizablePMCArray']
  vivify_776:
    set $P2465, $P2464[$I2463]
    unless_null $P2465, vivify_777
    new $P2465, "Undef"
  vivify_777:
    $S2466 = $P2465."name"()
    substr $S2467, $S2466, 0, 1
    iseq $I2468, $S2467, "%"
    new $P2454, 'Integer'
    set $P2454, $I2468
  if_2455_end:
    unless $P2454, if_2453_end
.annotate 'line', 1089
    find_lex $P2469, "$i"
    set $I2470, $P2469
    find_lex $P2471, "$past"
    unless_null $P2471, vivify_778
    $P2471 = root_new ['parrot';'ResizablePMCArray']
  vivify_778:
    set $P2472, $P2471[$I2470]
    unless_null $P2472, vivify_779
    new $P2472, "Undef"
  vivify_779:
    $P2472."named"(1)
  if_2453_end:
  if_2434_end:
.annotate 'line', 1084
    find_lex $P2473, "$i"
    clone $P2474, $P2473
    inc $P2473
  loop2475_next:
.annotate 'line', 1083
    goto loop2475_test
  loop2475_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2477, exception, 'type'
    eq $P2477, .CONTROL_LOOP_NEXT, loop2475_next
    eq $P2477, .CONTROL_LOOP_REDO, loop2475_redo
  loop2475_done:
    pop_eh 
.annotate 'line', 1094
    find_lex $P2478, "$/"
    find_lex $P2479, "$past"
    $P2480 = $P2478."!make"($P2479)
.annotate 'line', 1072
    .return ($P2480)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2391"  :anon :subid("122_1297619360.562") :outer("121_1297619360.562")
.annotate 'line', 1074
    .const 'Sub' $P2413 = "123_1297619360.562" 
    capture_lex $P2413
.annotate 'line', 1075
    new $P2393, "Undef"
    .lex "$expr", $P2393
    find_lex $P2394, "$/"
    unless_null $P2394, vivify_763
    $P2394 = root_new ['parrot';'Hash']
  vivify_763:
    set $P2395, $P2394["EXPR"]
    unless_null $P2395, vivify_764
    new $P2395, "Undef"
  vivify_764:
    $P2396 = $P2395."ast"()
    store_lex "$expr", $P2396
.annotate 'line', 1076
    find_lex $P2401, "$expr"
    $S2402 = $P2401."name"()
    iseq $I2403, $S2402, "&infix:<,>"
    if $I2403, if_2400
    new $P2399, 'Integer'
    set $P2399, $I2403
    goto if_2400_end
  if_2400:
    find_lex $P2404, "$expr"
    $P2405 = $P2404."named"()
    isfalse $I2406, $P2405
    new $P2399, 'Integer'
    set $P2399, $I2406
  if_2400_end:
    if $P2399, if_2398
.annotate 'line', 1079
    find_lex $P2421, "$past"
    find_lex $P2422, "$expr"
    $P2423 = $P2421."push"($P2422)
    set $P2397, $P2423
.annotate 'line', 1076
    goto if_2398_end
  if_2398:
.annotate 'line', 1077
    find_lex $P2408, "$expr"
    $P2409 = $P2408."list"()
    defined $I2410, $P2409
    unless $I2410, for_undef_765
    iter $P2407, $P2409
    new $P2419, 'ExceptionHandler'
    set_label $P2419, loop2418_handler
    $P2419."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2419
  loop2418_test:
    unless $P2407, loop2418_done
    shift $P2411, $P2407
  loop2418_redo:
    .const 'Sub' $P2413 = "123_1297619360.562" 
    capture_lex $P2413
    $P2413($P2411)
  loop2418_next:
    goto loop2418_test
  loop2418_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2420, exception, 'type'
    eq $P2420, .CONTROL_LOOP_NEXT, loop2418_next
    eq $P2420, .CONTROL_LOOP_REDO, loop2418_redo
  loop2418_done:
    pop_eh 
  for_undef_765:
.annotate 'line', 1076
    set $P2397, $P2407
  if_2398_end:
.annotate 'line', 1074
    .return ($P2397)
.end


.namespace ["NQP";"Actions"]
.sub "_block2412"  :anon :subid("123_1297619360.562") :outer("122_1297619360.562")
    .param pmc param_2414
.annotate 'line', 1077
    .lex "$_", param_2414
    find_lex $P2415, "$past"
    find_lex $P2416, "$_"
    $P2417 = $P2415."push"($P2416)
    .return ($P2417)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("124_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2482
    .param pmc param_2483
.annotate 'line', 1097
    .lex "self", param_2482
    .lex "$/", param_2483
    find_lex $P2484, "$/"
    find_lex $P2485, "$/"
    unless_null $P2485, vivify_780
    $P2485 = root_new ['parrot';'Hash']
  vivify_780:
    set $P2486, $P2485["multi_declarator"]
    unless_null $P2486, vivify_781
    new $P2486, "Undef"
  vivify_781:
    $P2487 = $P2486."ast"()
    $P2488 = $P2484."!make"($P2487)
    .return ($P2488)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("125_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2490
    .param pmc param_2491
.annotate 'line', 1099
    .lex "self", param_2490
    .lex "$/", param_2491
    find_lex $P2492, "$/"
    find_lex $P2493, "$/"
    unless_null $P2493, vivify_782
    $P2493 = root_new ['parrot';'Hash']
  vivify_782:
    set $P2494, $P2493["value"]
    unless_null $P2494, vivify_783
    new $P2494, "Undef"
  vivify_783:
    $P2495 = $P2494."ast"()
    $P2496 = $P2492."!make"($P2495)
    .return ($P2496)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("126_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2498
    .param pmc param_2499
.annotate 'line', 1101
    .lex "self", param_2498
    .lex "$/", param_2499
.annotate 'line', 1102
    find_lex $P2500, "$/"
.annotate 'line', 1103
    find_lex $P2503, "$/"
    unless_null $P2503, vivify_784
    $P2503 = root_new ['parrot';'Hash']
  vivify_784:
    set $P2504, $P2503["EXPR"]
    unless_null $P2504, vivify_785
    new $P2504, "Undef"
  vivify_785:
    if $P2504, if_2502
.annotate 'line', 1104
    get_hll_global $P2509, ["PAST"], "Op"
    find_lex $P2510, "$/"
    $P2511 = $P2509."new"("list" :named("pasttype"), $P2510 :named("node"))
    set $P2501, $P2511
.annotate 'line', 1103
    goto if_2502_end
  if_2502:
    find_lex $P2505, "$/"
    unless_null $P2505, vivify_786
    $P2505 = root_new ['parrot';'Hash']
  vivify_786:
    set $P2506, $P2505["EXPR"]
    unless_null $P2506, vivify_787
    $P2506 = root_new ['parrot';'ResizablePMCArray']
  vivify_787:
    set $P2507, $P2506[0]
    unless_null $P2507, vivify_788
    new $P2507, "Undef"
  vivify_788:
    $P2508 = $P2507."ast"()
    set $P2501, $P2508
  if_2502_end:
    $P2512 = $P2500."!make"($P2501)
.annotate 'line', 1101
    .return ($P2512)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("127_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2514
    .param pmc param_2515
.annotate 'line', 1107
    .lex "self", param_2514
    .lex "$/", param_2515
.annotate 'line', 1108
    new $P2516, "Undef"
    .lex "$past", $P2516
.annotate 'line', 1107
    find_lex $P2517, "$past"
.annotate 'line', 1109
    find_lex $P2519, "$/"
    unless_null $P2519, vivify_789
    $P2519 = root_new ['parrot';'Hash']
  vivify_789:
    set $P2520, $P2519["EXPR"]
    unless_null $P2520, vivify_790
    new $P2520, "Undef"
  vivify_790:
    if $P2520, if_2518
.annotate 'line', 1116
    get_hll_global $P2532, ["PAST"], "Op"
    $P2533 = $P2532."new"("list" :named("pasttype"))
    store_lex "$past", $P2533
.annotate 'line', 1115
    goto if_2518_end
  if_2518:
.annotate 'line', 1110
    find_lex $P2521, "$/"
    unless_null $P2521, vivify_791
    $P2521 = root_new ['parrot';'Hash']
  vivify_791:
    set $P2522, $P2521["EXPR"]
    unless_null $P2522, vivify_792
    $P2522 = root_new ['parrot';'ResizablePMCArray']
  vivify_792:
    set $P2523, $P2522[0]
    unless_null $P2523, vivify_793
    new $P2523, "Undef"
  vivify_793:
    $P2524 = $P2523."ast"()
    store_lex "$past", $P2524
.annotate 'line', 1111
    find_lex $P2526, "$past"
    $S2527 = $P2526."name"()
    isne $I2528, $S2527, "&infix:<,>"
    unless $I2528, if_2525_end
.annotate 'line', 1112
    get_hll_global $P2529, ["PAST"], "Op"
    find_lex $P2530, "$past"
    $P2531 = $P2529."new"($P2530, "list" :named("pasttype"))
    store_lex "$past", $P2531
  if_2525_end:
  if_2518_end:
.annotate 'line', 1118
    find_lex $P2534, "$past"
    $P2534."name"("&circumfix:<[ ]>")
.annotate 'line', 1119
    find_lex $P2535, "$/"
    find_lex $P2536, "$past"
    $P2537 = $P2535."!make"($P2536)
.annotate 'line', 1107
    .return ($P2537)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("128_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2539
    .param pmc param_2540
.annotate 'line', 1122
    .lex "self", param_2539
    .lex "$/", param_2540
    find_lex $P2541, "$/"
    find_lex $P2542, "$/"
    unless_null $P2542, vivify_794
    $P2542 = root_new ['parrot';'Hash']
  vivify_794:
    set $P2543, $P2542["quote_EXPR"]
    unless_null $P2543, vivify_795
    new $P2543, "Undef"
  vivify_795:
    $P2544 = $P2543."ast"()
    $P2545 = $P2541."!make"($P2544)
    .return ($P2545)
.end


.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("129_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2547
    .param pmc param_2548
.annotate 'line', 1123
    .lex "self", param_2547
    .lex "$/", param_2548
    find_lex $P2549, "$/"
    find_lex $P2550, "$/"
    unless_null $P2550, vivify_796
    $P2550 = root_new ['parrot';'Hash']
  vivify_796:
    set $P2551, $P2550["quote_EXPR"]
    unless_null $P2551, vivify_797
    new $P2551, "Undef"
  vivify_797:
    $P2552 = $P2551."ast"()
    $P2553 = $P2549."!make"($P2552)
    .return ($P2553)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("130_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2555
    .param pmc param_2556
.annotate 'line', 1125
    .lex "self", param_2555
    .lex "$/", param_2556
.annotate 'line', 1126
    new $P2557, "Undef"
    .lex "$past", $P2557
    find_lex $P2560, "$/"
    unless_null $P2560, vivify_798
    $P2560 = root_new ['parrot';'Hash']
  vivify_798:
    set $P2561, $P2560["pblock"]
    unless_null $P2561, vivify_799
    $P2561 = root_new ['parrot';'Hash']
  vivify_799:
    set $P2562, $P2561["blockoid"]
    unless_null $P2562, vivify_800
    $P2562 = root_new ['parrot';'Hash']
  vivify_800:
    set $P2563, $P2562["statementlist"]
    unless_null $P2563, vivify_801
    $P2563 = root_new ['parrot';'Hash']
  vivify_801:
    set $P2564, $P2563["statement"]
    unless_null $P2564, vivify_802
    new $P2564, "Undef"
  vivify_802:
    set $N2565, $P2564
    isgt $I2566, $N2565, 0.0
    if $I2566, if_2559
.annotate 'line', 1128
    $P2570 = "vivitype"("%")
    set $P2558, $P2570
.annotate 'line', 1126
    goto if_2559_end
  if_2559:
.annotate 'line', 1127
    find_lex $P2567, "$/"
    unless_null $P2567, vivify_803
    $P2567 = root_new ['parrot';'Hash']
  vivify_803:
    set $P2568, $P2567["pblock"]
    unless_null $P2568, vivify_804
    new $P2568, "Undef"
  vivify_804:
    $P2569 = $P2568."ast"()
    set $P2558, $P2569
  if_2559_end:
    store_lex "$past", $P2558
.annotate 'line', 1129
    new $P2571, "Integer"
    assign $P2571, 1
    find_lex $P2572, "$past"
    unless_null $P2572, vivify_805
    $P2572 = root_new ['parrot';'Hash']
    store_lex "$past", $P2572
  vivify_805:
    set $P2572["bareblock"], $P2571
.annotate 'line', 1130
    find_lex $P2573, "$/"
    find_lex $P2574, "$past"
    $P2575 = $P2573."!make"($P2574)
.annotate 'line', 1125
    .return ($P2575)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("131_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2577
    .param pmc param_2578
.annotate 'line', 1133
    .lex "self", param_2577
    .lex "$/", param_2578
.annotate 'line', 1134
    new $P2579, "Undef"
    .lex "$name", $P2579
    find_lex $P2582, "$/"
    unless_null $P2582, vivify_806
    $P2582 = root_new ['parrot';'Hash']
  vivify_806:
    set $P2583, $P2582["sigil"]
    unless_null $P2583, vivify_807
    new $P2583, "Undef"
  vivify_807:
    set $S2584, $P2583
    iseq $I2585, $S2584, "@"
    if $I2585, if_2581
.annotate 'line', 1135
    find_lex $P2589, "$/"
    unless_null $P2589, vivify_808
    $P2589 = root_new ['parrot';'Hash']
  vivify_808:
    set $P2590, $P2589["sigil"]
    unless_null $P2590, vivify_809
    new $P2590, "Undef"
  vivify_809:
    set $S2591, $P2590
    iseq $I2592, $S2591, "%"
    if $I2592, if_2588
    new $P2594, "String"
    assign $P2594, "item"
    set $P2587, $P2594
    goto if_2588_end
  if_2588:
    new $P2593, "String"
    assign $P2593, "hash"
    set $P2587, $P2593
  if_2588_end:
    set $P2580, $P2587
.annotate 'line', 1134
    goto if_2581_end
  if_2581:
    new $P2586, "String"
    assign $P2586, "list"
    set $P2580, $P2586
  if_2581_end:
    store_lex "$name", $P2580
.annotate 'line', 1137
    find_lex $P2595, "$/"
    get_hll_global $P2596, ["PAST"], "Op"
    find_lex $P2597, "$name"
    find_lex $P2598, "$/"
    unless_null $P2598, vivify_810
    $P2598 = root_new ['parrot';'Hash']
  vivify_810:
    set $P2599, $P2598["semilist"]
    unless_null $P2599, vivify_811
    new $P2599, "Undef"
  vivify_811:
    $P2600 = $P2599."ast"()
    $P2601 = $P2596."new"($P2600, "callmethod" :named("pasttype"), $P2597 :named("name"))
    $P2602 = $P2595."!make"($P2601)
.annotate 'line', 1133
    .return ($P2602)
.end


.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("132_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2604
    .param pmc param_2605
.annotate 'line', 1140
    .lex "self", param_2604
    .lex "$/", param_2605
    find_lex $P2606, "$/"
    find_lex $P2607, "$/"
    unless_null $P2607, vivify_812
    $P2607 = root_new ['parrot';'Hash']
  vivify_812:
    set $P2608, $P2607["statement"]
    unless_null $P2608, vivify_813
    new $P2608, "Undef"
  vivify_813:
    $P2609 = $P2608."ast"()
    $P2610 = $P2606."!make"($P2609)
    .return ($P2610)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("133_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2612
    .param pmc param_2613
.annotate 'line', 1142
    .lex "self", param_2612
    .lex "$/", param_2613
.annotate 'line', 1143
    find_lex $P2614, "$/"
    get_hll_global $P2615, ["PAST"], "Var"
    find_lex $P2616, "$/"
    unless_null $P2616, vivify_814
    $P2616 = root_new ['parrot';'Hash']
  vivify_814:
    set $P2617, $P2616["EXPR"]
    unless_null $P2617, vivify_815
    new $P2617, "Undef"
  vivify_815:
    $P2618 = $P2617."ast"()
.annotate 'line', 1145
    $P2619 = "vivitype"("@")
    $P2620 = $P2615."new"($P2618, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2619 :named("vivibase"))
.annotate 'line', 1143
    $P2621 = $P2614."!make"($P2620)
.annotate 'line', 1142
    .return ($P2621)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("134_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2623
    .param pmc param_2624
.annotate 'line', 1148
    .lex "self", param_2623
    .lex "$/", param_2624
.annotate 'line', 1149
    find_lex $P2625, "$/"
    get_hll_global $P2626, ["PAST"], "Var"
    find_lex $P2627, "$/"
    unless_null $P2627, vivify_816
    $P2627 = root_new ['parrot';'Hash']
  vivify_816:
    set $P2628, $P2627["EXPR"]
    unless_null $P2628, vivify_817
    new $P2628, "Undef"
  vivify_817:
    $P2629 = $P2628."ast"()
.annotate 'line', 1151
    $P2630 = "vivitype"("%")
    $P2631 = $P2626."new"($P2629, "keyed" :named("scope"), "Undef" :named("viviself"), $P2630 :named("vivibase"))
.annotate 'line', 1149
    $P2632 = $P2625."!make"($P2631)
.annotate 'line', 1148
    .return ($P2632)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("135_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2634
    .param pmc param_2635
.annotate 'line', 1154
    .lex "self", param_2634
    .lex "$/", param_2635
.annotate 'line', 1155
    find_lex $P2636, "$/"
    get_hll_global $P2637, ["PAST"], "Var"
    find_lex $P2638, "$/"
    unless_null $P2638, vivify_818
    $P2638 = root_new ['parrot';'Hash']
  vivify_818:
    set $P2639, $P2638["quote_EXPR"]
    unless_null $P2639, vivify_819
    new $P2639, "Undef"
  vivify_819:
    $P2640 = $P2639."ast"()
.annotate 'line', 1157
    $P2641 = "vivitype"("%")
    $P2642 = $P2637."new"($P2640, "keyed" :named("scope"), "Undef" :named("viviself"), $P2641 :named("vivibase"))
.annotate 'line', 1155
    $P2643 = $P2636."!make"($P2642)
.annotate 'line', 1154
    .return ($P2643)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("136_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2645
    .param pmc param_2646
.annotate 'line', 1160
    .lex "self", param_2645
    .lex "$/", param_2646
.annotate 'line', 1161
    find_lex $P2647, "$/"
    find_lex $P2648, "$/"
    unless_null $P2648, vivify_820
    $P2648 = root_new ['parrot';'Hash']
  vivify_820:
    set $P2649, $P2648["arglist"]
    unless_null $P2649, vivify_821
    new $P2649, "Undef"
  vivify_821:
    $P2650 = $P2649."ast"()
    $P2651 = $P2647."!make"($P2650)
.annotate 'line', 1160
    .return ($P2651)
.end


.namespace ["NQP";"Actions"]
.sub "value"  :subid("137_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2653
    .param pmc param_2654
.annotate 'line', 1164
    .lex "self", param_2653
    .lex "$/", param_2654
.annotate 'line', 1165
    find_lex $P2655, "$/"
    find_lex $P2658, "$/"
    unless_null $P2658, vivify_822
    $P2658 = root_new ['parrot';'Hash']
  vivify_822:
    set $P2659, $P2658["quote"]
    unless_null $P2659, vivify_823
    new $P2659, "Undef"
  vivify_823:
    if $P2659, if_2657
    find_lex $P2663, "$/"
    unless_null $P2663, vivify_824
    $P2663 = root_new ['parrot';'Hash']
  vivify_824:
    set $P2664, $P2663["number"]
    unless_null $P2664, vivify_825
    new $P2664, "Undef"
  vivify_825:
    $P2665 = $P2664."ast"()
    set $P2656, $P2665
    goto if_2657_end
  if_2657:
    find_lex $P2660, "$/"
    unless_null $P2660, vivify_826
    $P2660 = root_new ['parrot';'Hash']
  vivify_826:
    set $P2661, $P2660["quote"]
    unless_null $P2661, vivify_827
    new $P2661, "Undef"
  vivify_827:
    $P2662 = $P2661."ast"()
    set $P2656, $P2662
  if_2657_end:
    $P2666 = $P2655."!make"($P2656)
.annotate 'line', 1164
    .return ($P2666)
.end


.namespace ["NQP";"Actions"]
.sub "number"  :subid("138_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2668
    .param pmc param_2669
.annotate 'line', 1168
    .lex "self", param_2668
    .lex "$/", param_2669
.annotate 'line', 1169
    new $P2670, "Undef"
    .lex "$value", $P2670
    find_lex $P2673, "$/"
    unless_null $P2673, vivify_828
    $P2673 = root_new ['parrot';'Hash']
  vivify_828:
    set $P2674, $P2673["dec_number"]
    unless_null $P2674, vivify_829
    new $P2674, "Undef"
  vivify_829:
    if $P2674, if_2672
    find_lex $P2678, "$/"
    unless_null $P2678, vivify_830
    $P2678 = root_new ['parrot';'Hash']
  vivify_830:
    set $P2679, $P2678["integer"]
    unless_null $P2679, vivify_831
    new $P2679, "Undef"
  vivify_831:
    $P2680 = $P2679."ast"()
    set $P2671, $P2680
    goto if_2672_end
  if_2672:
    find_lex $P2675, "$/"
    unless_null $P2675, vivify_832
    $P2675 = root_new ['parrot';'Hash']
  vivify_832:
    set $P2676, $P2675["dec_number"]
    unless_null $P2676, vivify_833
    new $P2676, "Undef"
  vivify_833:
    $P2677 = $P2676."ast"()
    set $P2671, $P2677
  if_2672_end:
    store_lex "$value", $P2671
.annotate 'line', 1170
    find_lex $P2682, "$/"
    unless_null $P2682, vivify_834
    $P2682 = root_new ['parrot';'Hash']
  vivify_834:
    set $P2683, $P2682["sign"]
    unless_null $P2683, vivify_835
    new $P2683, "Undef"
  vivify_835:
    set $S2684, $P2683
    iseq $I2685, $S2684, "-"
    unless $I2685, if_2681_end
    find_lex $P2686, "$value"
    neg $P2687, $P2686
    store_lex "$value", $P2687
  if_2681_end:
.annotate 'line', 1171
    find_lex $P2688, "$/"
    get_hll_global $P2689, ["PAST"], "Val"
    find_lex $P2690, "$value"
    $P2691 = $P2689."new"($P2690 :named("value"))
    $P2692 = $P2688."!make"($P2691)
.annotate 'line', 1168
    .return ($P2692)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("139_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2694
    .param pmc param_2695
.annotate 'line', 1174
    .lex "self", param_2694
    .lex "$/", param_2695
    find_lex $P2696, "$/"
    find_lex $P2697, "$/"
    unless_null $P2697, vivify_836
    $P2697 = root_new ['parrot';'Hash']
  vivify_836:
    set $P2698, $P2697["quote_EXPR"]
    unless_null $P2698, vivify_837
    new $P2698, "Undef"
  vivify_837:
    $P2699 = $P2698."ast"()
    $P2700 = $P2696."!make"($P2699)
    .return ($P2700)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("140_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2702
    .param pmc param_2703
.annotate 'line', 1175
    .lex "self", param_2702
    .lex "$/", param_2703
    find_lex $P2704, "$/"
    find_lex $P2705, "$/"
    unless_null $P2705, vivify_838
    $P2705 = root_new ['parrot';'Hash']
  vivify_838:
    set $P2706, $P2705["quote_EXPR"]
    unless_null $P2706, vivify_839
    new $P2706, "Undef"
  vivify_839:
    $P2707 = $P2706."ast"()
    $P2708 = $P2704."!make"($P2707)
    .return ($P2708)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("141_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2710
    .param pmc param_2711
.annotate 'line', 1176
    .lex "self", param_2710
    .lex "$/", param_2711
    find_lex $P2712, "$/"
    find_lex $P2713, "$/"
    unless_null $P2713, vivify_840
    $P2713 = root_new ['parrot';'Hash']
  vivify_840:
    set $P2714, $P2713["quote_EXPR"]
    unless_null $P2714, vivify_841
    new $P2714, "Undef"
  vivify_841:
    $P2715 = $P2714."ast"()
    $P2716 = $P2712."!make"($P2715)
    .return ($P2716)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("142_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2718
    .param pmc param_2719
.annotate 'line', 1177
    .lex "self", param_2718
    .lex "$/", param_2719
    find_lex $P2720, "$/"
    find_lex $P2721, "$/"
    unless_null $P2721, vivify_842
    $P2721 = root_new ['parrot';'Hash']
  vivify_842:
    set $P2722, $P2721["quote_EXPR"]
    unless_null $P2722, vivify_843
    new $P2722, "Undef"
  vivify_843:
    $P2723 = $P2722."ast"()
    $P2724 = $P2720."!make"($P2723)
    .return ($P2724)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("143_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2726
    .param pmc param_2727
.annotate 'line', 1178
    .lex "self", param_2726
    .lex "$/", param_2727
    find_lex $P2728, "$/"
    find_lex $P2729, "$/"
    unless_null $P2729, vivify_844
    $P2729 = root_new ['parrot';'Hash']
  vivify_844:
    set $P2730, $P2729["quote_EXPR"]
    unless_null $P2730, vivify_845
    new $P2730, "Undef"
  vivify_845:
    $P2731 = $P2730."ast"()
    $P2732 = $P2728."!make"($P2731)
    .return ($P2732)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("144_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2734
    .param pmc param_2735
.annotate 'line', 1179
    .lex "self", param_2734
    .lex "$/", param_2735
.annotate 'line', 1180
    find_lex $P2736, "$/"
    get_hll_global $P2737, ["PAST"], "Op"
    find_lex $P2738, "$/"
    unless_null $P2738, vivify_846
    $P2738 = root_new ['parrot';'Hash']
  vivify_846:
    set $P2739, $P2738["quote_EXPR"]
    unless_null $P2739, vivify_847
    new $P2739, "Undef"
  vivify_847:
    $P2740 = $P2739."ast"()
    $P2741 = $P2740."value"()
    find_lex $P2742, "$/"
    $P2743 = $P2737."new"($P2741 :named("inline"), "inline" :named("pasttype"), $P2742 :named("node"))
    $P2744 = $P2736."!make"($P2743)
.annotate 'line', 1179
    .return ($P2744)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("145_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2748
    .param pmc param_2749
    .param pmc param_2750 :optional
    .param int has_param_2750 :opt_flag
.annotate 'line', 1185
    new $P2747, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2747, control_2746
    push_eh $P2747
    .lex "self", param_2748
    .lex "$/", param_2749
    if has_param_2750, optparam_848
    new $P2751, "Undef"
    set param_2750, $P2751
  optparam_848:
    .lex "$key", param_2750
.annotate 'line', 1195
    new $P2752, "Undef"
    .lex "$regex", $P2752
.annotate 'line', 1197
    new $P2753, "Undef"
    .lex "$past", $P2753
.annotate 'line', 1186
    find_lex $P2755, "$key"
    set $S2756, $P2755
    iseq $I2757, $S2756, "open"
    unless $I2757, if_2754_end
.annotate 'line', 1187

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1191
    get_global $P2758, "@BLOCK"
    unless_null $P2758, vivify_849
    $P2758 = root_new ['parrot';'ResizablePMCArray']
  vivify_849:
    set $P2759, $P2758[0]
    unless_null $P2759, vivify_850
    new $P2759, "Undef"
  vivify_850:
    $P2759."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1192
    get_global $P2760, "@BLOCK"
    unless_null $P2760, vivify_851
    $P2760 = root_new ['parrot';'ResizablePMCArray']
  vivify_851:
    set $P2761, $P2760[0]
    unless_null $P2761, vivify_852
    new $P2761, "Undef"
  vivify_852:
    $P2761."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1193
    new $P2762, "Exception"
    set $P2762['type'], .CONTROL_RETURN
    new $P2763, "Integer"
    assign $P2763, 0
    setattribute $P2762, 'payload', $P2763
    throw $P2762
  if_2754_end:
.annotate 'line', 1196
    get_hll_global $P2764, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2765, "$/"
    unless_null $P2765, vivify_853
    $P2765 = root_new ['parrot';'Hash']
  vivify_853:
    set $P2766, $P2765["p6regex"]
    unless_null $P2766, vivify_854
    new $P2766, "Undef"
  vivify_854:
    $P2767 = $P2766."ast"()
    get_global $P2768, "@BLOCK"
    $P2769 = $P2768."shift"()
    $P2770 = $P2764($P2767, $P2769)
    store_lex "$regex", $P2770
.annotate 'line', 1198
    get_hll_global $P2771, ["PAST"], "Op"
.annotate 'line', 1200
    get_hll_global $P2772, ["PAST"], "Var"
    new $P2773, "ResizablePMCArray"
    push $P2773, "Regex"
    $P2774 = $P2772."new"("Regex" :named("name"), $P2773 :named("namespace"), "package" :named("scope"))
    find_lex $P2775, "$regex"
    $P2776 = $P2771."new"($P2774, $P2775, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1198
    store_lex "$past", $P2776
.annotate 'line', 1204
    find_lex $P2777, "$regex"
    find_lex $P2778, "$past"
    unless_null $P2778, vivify_855
    $P2778 = root_new ['parrot';'Hash']
    store_lex "$past", $P2778
  vivify_855:
    set $P2778["sink"], $P2777
.annotate 'line', 1205
    find_lex $P2779, "$/"
    find_lex $P2780, "$past"
    $P2781 = $P2779."!make"($P2780)
.annotate 'line', 1185
    .return ($P2781)
  control_2746:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2782, exception, "payload"
    .return ($P2782)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("146_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2784
    .param pmc param_2785
.annotate 'line', 1208
    .lex "self", param_2784
    .lex "$/", param_2785
    find_lex $P2786, "$/"
    find_lex $P2787, "$/"
    unless_null $P2787, vivify_856
    $P2787 = root_new ['parrot';'Hash']
  vivify_856:
    set $P2788, $P2787["variable"]
    unless_null $P2788, vivify_857
    new $P2788, "Undef"
  vivify_857:
    $P2789 = $P2788."ast"()
    $P2790 = $P2786."!make"($P2789)
    .return ($P2790)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("147_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2792
    .param pmc param_2793
.annotate 'line', 1209
    .lex "self", param_2792
    .lex "$/", param_2793
.annotate 'line', 1210
    find_lex $P2794, "$/"
    get_hll_global $P2795, ["PAST"], "Op"
.annotate 'line', 1211
    find_lex $P2796, "$/"
    unless_null $P2796, vivify_858
    $P2796 = root_new ['parrot';'Hash']
  vivify_858:
    set $P2797, $P2796["block"]
    unless_null $P2797, vivify_859
    new $P2797, "Undef"
  vivify_859:
    $P2798 = $P2797."ast"()
    $P2799 = "block_immediate"($P2798)
    find_lex $P2800, "$/"
    $P2801 = $P2795."new"($P2799, "set S*" :named("pirop"), $P2800 :named("node"))
.annotate 'line', 1210
    $P2802 = $P2794."!make"($P2801)
.annotate 'line', 1209
    .return ($P2802)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("148_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2804
    .param pmc param_2805
.annotate 'line', 1214
    .lex "self", param_2804
    .lex "$/", param_2805
    find_lex $P2806, "$/"
    $P2807 = $P2806."!make"("\e")
    .return ($P2807)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("149_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2809
    .param pmc param_2810
.annotate 'line', 1218
    .lex "self", param_2809
    .lex "$/", param_2810
    find_lex $P2811, "$/"
    find_lex $P2812, "$/"
    unless_null $P2812, vivify_860
    $P2812 = root_new ['parrot';'Hash']
  vivify_860:
    set $P2813, $P2812["dotty"]
    unless_null $P2813, vivify_861
    new $P2813, "Undef"
  vivify_861:
    $P2814 = $P2813."ast"()
    $P2815 = $P2811."!make"($P2814)
    .return ($P2815)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("150_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2817
    .param pmc param_2818
.annotate 'line', 1220
    .lex "self", param_2817
    .lex "$/", param_2818
.annotate 'line', 1221
    find_lex $P2819, "$/"
    get_hll_global $P2820, ["PAST"], "Op"
.annotate 'line', 1222
    new $P2821, "ResizablePMCArray"
    push $P2821, "    clone %r, %0"
    push $P2821, "    inc %0"
    $P2822 = $P2820."new"("postfix:<++>" :named("name"), $P2821 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1221
    $P2823 = $P2819."!make"($P2822)
.annotate 'line', 1220
    .return ($P2823)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("151_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2825
    .param pmc param_2826
.annotate 'line', 1226
    .lex "self", param_2825
    .lex "$/", param_2826
.annotate 'line', 1227
    find_lex $P2827, "$/"
    get_hll_global $P2828, ["PAST"], "Op"
.annotate 'line', 1228
    new $P2829, "ResizablePMCArray"
    push $P2829, "    clone %r, %0"
    push $P2829, "    dec %0"
    $P2830 = $P2828."new"("postfix:<-->" :named("name"), $P2829 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1227
    $P2831 = $P2827."!make"($P2830)
.annotate 'line', 1226
    .return ($P2831)
.end


.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("152_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2833
    .param pmc param_2834
.annotate 'line', 1232
    .lex "self", param_2833
    .lex "$/", param_2834
.annotate 'line', 1233
    find_lex $P2835, "$/"
    get_hll_global $P2836, ["PAST"], "Op"
.annotate 'line', 1234
    get_hll_global $P2837, ["PAST"], "Var"
    $P2838 = $P2837."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2839, "$/"
    $P2840 = $P2836."new"($P2838, "callmethod" :named("pasttype"), "!make" :named("name"), $P2839 :named("node"))
.annotate 'line', 1233
    $P2841 = $P2835."!make"($P2840)
.annotate 'line', 1232
    .return ($P2841)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("153_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2844
    .param pmc param_2845
.annotate 'line', 1250
    .lex "self", param_2844
    .lex "$/", param_2845
    find_lex $P2846, "$/"
    $P2847 = "control"($P2846, "CONTROL_LOOP_NEXT")
    .return ($P2847)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("154_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2849
    .param pmc param_2850
.annotate 'line', 1251
    .lex "self", param_2849
    .lex "$/", param_2850
    find_lex $P2851, "$/"
    $P2852 = "control"($P2851, "CONTROL_LOOP_LAST")
    .return ($P2852)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("155_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2854
    .param pmc param_2855
.annotate 'line', 1252
    .lex "self", param_2854
    .lex "$/", param_2855
    find_lex $P2856, "$/"
    $P2857 = "control"($P2856, "CONTROL_LOOP_REDO")
    .return ($P2857)
.end


.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("156_1297619360.562") :outer("11_1297619360.562")
    .param pmc param_2859
    .param pmc param_2860
.annotate 'line', 1254
    .lex "self", param_2859
    .lex "$/", param_2860
.annotate 'line', 1255
    find_lex $P2861, "$/"
    get_hll_global $P2862, ["PAST"], "Op"
    find_lex $P2863, "$/"
    $P2864 = $P2862."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2863 :named("node"))
    $P2865 = $P2861."!make"($P2864)
.annotate 'line', 1254
    .return ($P2865)
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2866"  :subid("157_1297619360.562") :outer("11_1297619360.562")
.annotate 'line', 1259
    .const 'Sub' $P2966 = "165_1297619360.562" 
    capture_lex $P2966
    .const 'Sub' $P2941 = "164_1297619360.562" 
    capture_lex $P2941
    .const 'Sub' $P2930 = "163_1297619360.562" 
    capture_lex $P2930
    .const 'Sub' $P2915 = "162_1297619360.562" 
    capture_lex $P2915
    .const 'Sub' $P2904 = "161_1297619360.562" 
    capture_lex $P2904
    .const 'Sub' $P2893 = "160_1297619360.562" 
    capture_lex $P2893
    .const 'Sub' $P2882 = "159_1297619360.562" 
    capture_lex $P2882
    .const 'Sub' $P2869 = "158_1297619360.562" 
    capture_lex $P2869
    get_global $P2868, "$?CLASS"
.annotate 'line', 1293
    .const 'Sub' $P2941 = "164_1297619360.562" 
    newclosure $P2964, $P2941
.annotate 'line', 1259
    .return ($P2964)
.end


.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post862") :outer("157_1297619360.562")
.annotate 'line', 1259
    get_hll_global $P2867, ["NQP";"RegexActions"], "_block2866" 
    .local pmc block
    set block, $P2867
    .const 'Sub' $P2966 = "165_1297619360.562" 
    capture_lex $P2966
    $P2966()
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2965"  :anon :subid("165_1297619360.562") :outer("157_1297619360.562")
.annotate 'line', 1259
    get_hll_global $P2967, "NQPClassHOW"
    $P2968 = $P2967."new_type"("RegexActions" :named("name"))
    .local pmc type_obj
    set type_obj, $P2968
    set_hll_global ["NQP"], "RegexActions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2969, type_obj
    .const 'Sub' $P2970 = "158_1297619360.562" 
    $P2969."add_method"(type_obj, "metachar:sym<:my>", $P2970)
    get_how $P2971, type_obj
    .const 'Sub' $P2972 = "159_1297619360.562" 
    $P2971."add_method"(type_obj, "metachar:sym<{ }>", $P2972)
    get_how $P2973, type_obj
    .const 'Sub' $P2974 = "160_1297619360.562" 
    $P2973."add_method"(type_obj, "metachar:sym<nqpvar>", $P2974)
    get_how $P2975, type_obj
    .const 'Sub' $P2976 = "161_1297619360.562" 
    $P2975."add_method"(type_obj, "assertion:sym<{ }>", $P2976)
    get_how $P2977, type_obj
    .const 'Sub' $P2978 = "162_1297619360.562" 
    $P2977."add_method"(type_obj, "assertion:sym<?{ }>", $P2978)
    get_how $P2979, type_obj
    .const 'Sub' $P2980 = "163_1297619360.562" 
    $P2979."add_method"(type_obj, "assertion:sym<var>", $P2980)
    get_how $P2981, type_obj
    .const 'Sub' $P2982 = "164_1297619360.562" 
    $P2981."add_method"(type_obj, "codeblock", $P2982)
    get_how $P2983, type_obj
    get_hll_global $P2984, ["Regex";"P6Regex"], "Actions"
    $P2983."add_parent"(type_obj, $P2984)
    get_how $P2985, type_obj
    $P2986 = $P2985."compose"(type_obj)
    .return ($P2986)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("158_1297619360.562") :outer("157_1297619360.562")
    .param pmc param_2870
    .param pmc param_2871
.annotate 'line', 1261
    .lex "self", param_2870
    .lex "$/", param_2871
.annotate 'line', 1262
    new $P2872, "Undef"
    .lex "$past", $P2872
    find_lex $P2873, "$/"
    unless_null $P2873, vivify_863
    $P2873 = root_new ['parrot';'Hash']
  vivify_863:
    set $P2874, $P2873["statement"]
    unless_null $P2874, vivify_864
    new $P2874, "Undef"
  vivify_864:
    $P2875 = $P2874."ast"()
    store_lex "$past", $P2875
.annotate 'line', 1263
    find_lex $P2876, "$/"
    get_hll_global $P2877, ["PAST"], "Regex"
    find_lex $P2878, "$past"
    find_lex $P2879, "$/"
    $P2880 = $P2877."new"($P2878, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P2879 :named("node"))
    $P2881 = $P2876."!make"($P2880)
.annotate 'line', 1261
    .return ($P2881)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("159_1297619360.562") :outer("157_1297619360.562")
    .param pmc param_2883
    .param pmc param_2884
.annotate 'line', 1267
    .lex "self", param_2883
    .lex "$/", param_2884
.annotate 'line', 1268
    find_lex $P2885, "$/"
    get_hll_global $P2886, ["PAST"], "Regex"
    find_lex $P2887, "$/"
    unless_null $P2887, vivify_865
    $P2887 = root_new ['parrot';'Hash']
  vivify_865:
    set $P2888, $P2887["codeblock"]
    unless_null $P2888, vivify_866
    new $P2888, "Undef"
  vivify_866:
    $P2889 = $P2888."ast"()
    find_lex $P2890, "$/"
    $P2891 = $P2886."new"($P2889, "pastnode" :named("pasttype"), $P2890 :named("node"))
    $P2892 = $P2885."!make"($P2891)
.annotate 'line', 1267
    .return ($P2892)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("160_1297619360.562") :outer("157_1297619360.562")
    .param pmc param_2894
    .param pmc param_2895
.annotate 'line', 1272
    .lex "self", param_2894
    .lex "$/", param_2895
.annotate 'line', 1273
    find_lex $P2896, "$/"
    get_hll_global $P2897, ["PAST"], "Regex"
    find_lex $P2898, "$/"
    unless_null $P2898, vivify_867
    $P2898 = root_new ['parrot';'Hash']
  vivify_867:
    set $P2899, $P2898["var"]
    unless_null $P2899, vivify_868
    new $P2899, "Undef"
  vivify_868:
    $P2900 = $P2899."ast"()
    find_lex $P2901, "$/"
    $P2902 = $P2897."new"("!INTERPOLATE", $P2900, "subrule" :named("pasttype"), "method" :named("subtype"), $P2901 :named("node"))
    $P2903 = $P2896."!make"($P2902)
.annotate 'line', 1272
    .return ($P2903)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("161_1297619360.562") :outer("157_1297619360.562")
    .param pmc param_2905
    .param pmc param_2906
.annotate 'line', 1277
    .lex "self", param_2905
    .lex "$/", param_2906
.annotate 'line', 1278
    find_lex $P2907, "$/"
    get_hll_global $P2908, ["PAST"], "Regex"
    find_lex $P2909, "$/"
    unless_null $P2909, vivify_869
    $P2909 = root_new ['parrot';'Hash']
  vivify_869:
    set $P2910, $P2909["codeblock"]
    unless_null $P2910, vivify_870
    new $P2910, "Undef"
  vivify_870:
    $P2911 = $P2910."ast"()
    find_lex $P2912, "$/"
    $P2913 = $P2908."new"("!INTERPOLATE_REGEX", $P2911, "subrule" :named("pasttype"), "method" :named("subtype"), $P2912 :named("node"))
    $P2914 = $P2907."!make"($P2913)
.annotate 'line', 1277
    .return ($P2914)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("162_1297619360.562") :outer("157_1297619360.562")
    .param pmc param_2916
    .param pmc param_2917
.annotate 'line', 1282
    .lex "self", param_2916
    .lex "$/", param_2917
.annotate 'line', 1283
    find_lex $P2918, "$/"
    get_hll_global $P2919, ["PAST"], "Regex"
    find_lex $P2920, "$/"
    unless_null $P2920, vivify_871
    $P2920 = root_new ['parrot';'Hash']
  vivify_871:
    set $P2921, $P2920["codeblock"]
    unless_null $P2921, vivify_872
    new $P2921, "Undef"
  vivify_872:
    $P2922 = $P2921."ast"()
.annotate 'line', 1284
    find_lex $P2923, "$/"
    unless_null $P2923, vivify_873
    $P2923 = root_new ['parrot';'Hash']
  vivify_873:
    set $P2924, $P2923["zw"]
    unless_null $P2924, vivify_874
    new $P2924, "Undef"
  vivify_874:
    set $S2925, $P2924
    iseq $I2926, $S2925, "!"
    find_lex $P2927, "$/"
    $P2928 = $P2919."new"($P2922, "zerowidth" :named("subtype"), $I2926 :named("negate"), "pastnode" :named("pasttype"), $P2927 :named("node"))
.annotate 'line', 1283
    $P2929 = $P2918."!make"($P2928)
.annotate 'line', 1282
    .return ($P2929)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("163_1297619360.562") :outer("157_1297619360.562")
    .param pmc param_2931
    .param pmc param_2932
.annotate 'line', 1288
    .lex "self", param_2931
    .lex "$/", param_2932
.annotate 'line', 1289
    find_lex $P2933, "$/"
    get_hll_global $P2934, ["PAST"], "Regex"
    find_lex $P2935, "$/"
    unless_null $P2935, vivify_875
    $P2935 = root_new ['parrot';'Hash']
  vivify_875:
    set $P2936, $P2935["var"]
    unless_null $P2936, vivify_876
    new $P2936, "Undef"
  vivify_876:
    $P2937 = $P2936."ast"()
    find_lex $P2938, "$/"
    $P2939 = $P2934."new"("!INTERPOLATE_REGEX", $P2937, "subrule" :named("pasttype"), "method" :named("subtype"), $P2938 :named("node"))
    $P2940 = $P2933."!make"($P2939)
.annotate 'line', 1288
    .return ($P2940)
.end


.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("164_1297619360.562") :outer("157_1297619360.562")
    .param pmc param_2942
    .param pmc param_2943
.annotate 'line', 1293
    .lex "self", param_2942
    .lex "$/", param_2943
.annotate 'line', 1294
    new $P2944, "Undef"
    .lex "$block", $P2944
.annotate 'line', 1296
    new $P2945, "Undef"
    .lex "$past", $P2945
.annotate 'line', 1294
    find_lex $P2946, "$/"
    unless_null $P2946, vivify_877
    $P2946 = root_new ['parrot';'Hash']
  vivify_877:
    set $P2947, $P2946["block"]
    unless_null $P2947, vivify_878
    new $P2947, "Undef"
  vivify_878:
    $P2948 = $P2947."ast"()
    store_lex "$block", $P2948
.annotate 'line', 1295
    find_lex $P2949, "$block"
    $P2949."blocktype"("immediate")
.annotate 'line', 1297
    get_hll_global $P2950, ["PAST"], "Stmts"
.annotate 'line', 1298
    get_hll_global $P2951, ["PAST"], "Op"
.annotate 'line', 1299
    get_hll_global $P2952, ["PAST"], "Var"
    $P2953 = $P2952."new"("$/" :named("name"))
.annotate 'line', 1300
    get_hll_global $P2954, ["PAST"], "Op"
.annotate 'line', 1301
    get_hll_global $P2955, ["PAST"], "Var"
    $P2956 = $P2955."new"(unicode:"$\x{a2}" :named("name"))
    $P2957 = $P2954."new"($P2956, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1300
    $P2958 = $P2951."new"($P2953, $P2957, "bind" :named("pasttype"))
.annotate 'line', 1298
    find_lex $P2959, "$block"
    $P2960 = $P2950."new"($P2958, $P2959)
.annotate 'line', 1297
    store_lex "$past", $P2960
.annotate 'line', 1309
    find_lex $P2961, "$/"
    find_lex $P2962, "$past"
    $P2963 = $P2961."!make"($P2962)
.annotate 'line', 1293
    .return ($P2963)
.end


.namespace ["NQP";"Actions"]
.sub "_block2988" :load :anon :subid("166_1297619360.562")
.annotate 'line', 3
    .const 'Sub' $P2990 = "11_1297619360.562" 
    $P2991 = $P2990()
    .return ($P2991)
.end


.namespace []
.sub "_block3213" :load :anon :subid("168_1297619360.562")
.annotate 'line', 1
    .const 'Sub' $P3215 = "10_1297619360.562" 
    $P3216 = $P3215()
    .return ($P3216)
.end

### .include 'gen/nqp-compiler.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1297619366.968")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Compiler"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
    $P25 = $P15()
    .return ($P25)
    .const 'Sub' $P27 = "13_1297619366.968" 
    .return ($P27)
.end


.namespace ["NQP";"Compiler"]
.sub "_block14"  :subid("11_1297619366.968") :outer("10_1297619366.968")
.annotate 'line', 1
    .const 'Sub' $P18 = "12_1297619366.968" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    .return ()
.end


.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post14") :outer("11_1297619366.968")
.annotate 'line', 1
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P18 = "12_1297619366.968" 
    capture_lex $P18
    $P18()
.end


.namespace ["NQP";"Compiler"]
.sub "_block17"  :anon :subid("12_1297619366.968") :outer("11_1297619366.968")
.annotate 'line', 1
    get_hll_global $P19, "NQPClassHOW"
    $P20 = $P19."new_type"("Compiler" :named("name"))
    .local pmc type_obj
    set type_obj, $P20
    set_hll_global ["NQP"], "Compiler", type_obj
    set_global "$?CLASS", type_obj
    get_how $P21, type_obj
    get_hll_global $P22, ["HLL"], "Compiler"
    $P21."add_parent"(type_obj, $P22)
    get_how $P23, type_obj
    $P24 = $P23."compose"(type_obj)
    .return ($P24)
.end


.namespace []
.sub "_block26" :load :anon :subid("13_1297619366.968")
.annotate 'line', 1
    .const 'Sub' $P28 = "10_1297619366.968" 
    $P29 = $P28()
    .return ($P29)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " - "
        print description
  no_description:
    print "\n"

    unless condition goto not_ok
    .return (1)
  not_ok:
    .return (0)
.end

.sub 'skip'
    .param string desc

    print 'ok '
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    print " # SKIP "
    print desc
    print "\n"
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('NQP-rx')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'NQP-rx'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
