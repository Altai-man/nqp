
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1303739803.72")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P7337 = "581_1303739803.72" 
    capture_lex $P7337
    .const 'Sub' $P7183 = "572_1303739803.72" 
    capture_lex $P7183
    .const 'Sub' $P2757 = "406_1303739803.72" 
    capture_lex $P2757
    .const 'Sub' $P2653 = "384_1303739803.72" 
    capture_lex $P2653
    .const 'Sub' $P47 = "12_1303739803.72" 
    capture_lex $P47
    .const 'Sub' $P16 = "11_1303739803.72" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2325
    .const 'Sub' $P16 = "11_1303739803.72" 
    newclosure $P45, $P16
    .lex "MAIN", $P45
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1303739803.72" 
    capture_lex $P47
    $P47()
.annotate 'line', 724
    .const 'Sub' $P2653 = "384_1303739803.72" 
    capture_lex $P2653
    $P2653()
.annotate 'line', 767
    .const 'Sub' $P2757 = "406_1303739803.72" 
    capture_lex $P2757
    $P2757()
.annotate 'line', 2267
    .const 'Sub' $P7183 = "572_1303739803.72" 
    capture_lex $P7183
    $P7183()
.annotate 'line', 2322
    .const 'Sub' $P7337 = "581_1303739803.72" 
    capture_lex $P7337
    $P7337()
    find_lex $P7347, "MAIN"
    find_lex $P7350, "@ARGS"
    if $P7350, if_7349
    set $P7348, $P7350
    goto if_7349_end
  if_7349:
    .const 'Sub' $P7351 = "11_1303739803.72" 
    find_lex $P7352, "@ARGS"
    $P7353 = $P7351($P7352 :flat)
    set $P7348, $P7353
  if_7349_end:
.annotate 'line', 1
    .return ($P7348)
    .const 'Sub' $P7355 = "583_1303739803.72" 
    .return ($P7355)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post584") :outer("10_1303739803.72")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1303739803.72" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P7359, "1303739791.58"
    isnull $I7360, $P7359
    if $I7360, if_7358
    .const 'Sub' $P7468 = "10_1303739803.72" 
    $P7469 = $P7468."get_lexinfo"()
    nqp_get_sc_object $P7470, "1303739791.58", 0
    $P7469."set_static_lexpad_value"("GLOBALish", $P7470)
    .const 'Sub' $P7471 = "10_1303739803.72" 
    $P7472 = $P7471."get_lexinfo"()
    $P7472."finish_static_lexpad"()
    .const 'Sub' $P7473 = "10_1303739803.72" 
    $P7474 = $P7473."get_lexinfo"()
    nqp_get_sc_object $P7475, "1303739791.58", 0
    $P7474."set_static_lexpad_value"("$?PACKAGE", $P7475)
    .const 'Sub' $P7476 = "10_1303739803.72" 
    $P7477 = $P7476."get_lexinfo"()
    $P7477."finish_static_lexpad"()
    nqp_get_sc_object $P7478, "1303739791.58", 1
    set_hll_global ["NQP"], "Grammar", $P7478
    .const 'Sub' $P7479 = "12_1303739803.72" 
    $P7480 = $P7479."get_lexinfo"()
    nqp_get_sc_object $P7481, "1303739791.58", 1
    $P7480."set_static_lexpad_value"("$?PACKAGE", $P7481)
    .const 'Sub' $P7482 = "12_1303739803.72" 
    $P7483 = $P7482."get_lexinfo"()
    $P7483."finish_static_lexpad"()
    .const 'Sub' $P7484 = "12_1303739803.72" 
    $P7485 = $P7484."get_lexinfo"()
    nqp_get_sc_object $P7486, "1303739791.58", 1
    $P7485."set_static_lexpad_value"("$?CLASS", $P7486)
    .const 'Sub' $P7487 = "12_1303739803.72" 
    $P7488 = $P7487."get_lexinfo"()
    $P7488."finish_static_lexpad"()
    nqp_get_sc_object $P7489, "1303739791.58", 2
    set_hll_global ["NQP"], "Regex", $P7489
    .const 'Sub' $P7490 = "384_1303739803.72" 
    $P7491 = $P7490."get_lexinfo"()
    nqp_get_sc_object $P7492, "1303739791.58", 2
    $P7491."set_static_lexpad_value"("$?PACKAGE", $P7492)
    .const 'Sub' $P7493 = "384_1303739803.72" 
    $P7494 = $P7493."get_lexinfo"()
    $P7494."finish_static_lexpad"()
    .const 'Sub' $P7495 = "384_1303739803.72" 
    $P7496 = $P7495."get_lexinfo"()
    nqp_get_sc_object $P7497, "1303739791.58", 2
    $P7496."set_static_lexpad_value"("$?CLASS", $P7497)
    .const 'Sub' $P7498 = "384_1303739803.72" 
    $P7499 = $P7498."get_lexinfo"()
    $P7499."finish_static_lexpad"()
    nqp_get_sc_object $P7500, "1303739791.58", 3
    set_hll_global ["NQP"], "Actions", $P7500
    .const 'Sub' $P7501 = "406_1303739803.72" 
    $P7502 = $P7501."get_lexinfo"()
    nqp_get_sc_object $P7503, "1303739791.58", 3
    $P7502."set_static_lexpad_value"("$?PACKAGE", $P7503)
    .const 'Sub' $P7504 = "406_1303739803.72" 
    $P7505 = $P7504."get_lexinfo"()
    $P7505."finish_static_lexpad"()
    .const 'Sub' $P7506 = "406_1303739803.72" 
    $P7507 = $P7506."get_lexinfo"()
    nqp_get_sc_object $P7508, "1303739791.58", 3
    $P7507."set_static_lexpad_value"("$?CLASS", $P7508)
    .const 'Sub' $P7509 = "406_1303739803.72" 
    $P7510 = $P7509."get_lexinfo"()
    $P7510."finish_static_lexpad"()
    nqp_get_sc_object $P7511, "1303739791.58", 4
    set_hll_global ["NQP"], "RegexActions", $P7511
    .const 'Sub' $P7512 = "572_1303739803.72" 
    $P7513 = $P7512."get_lexinfo"()
    nqp_get_sc_object $P7514, "1303739791.58", 4
    $P7513."set_static_lexpad_value"("$?PACKAGE", $P7514)
    .const 'Sub' $P7515 = "572_1303739803.72" 
    $P7516 = $P7515."get_lexinfo"()
    $P7516."finish_static_lexpad"()
    .const 'Sub' $P7517 = "572_1303739803.72" 
    $P7518 = $P7517."get_lexinfo"()
    nqp_get_sc_object $P7519, "1303739791.58", 4
    $P7518."set_static_lexpad_value"("$?CLASS", $P7519)
    .const 'Sub' $P7520 = "572_1303739803.72" 
    $P7521 = $P7520."get_lexinfo"()
    $P7521."finish_static_lexpad"()
    nqp_get_sc_object $P7522, "1303739791.58", 5
    set_hll_global ["NQP"], "Compiler", $P7522
    .const 'Sub' $P7523 = "581_1303739803.72" 
    $P7524 = $P7523."get_lexinfo"()
    nqp_get_sc_object $P7525, "1303739791.58", 5
    $P7524."set_static_lexpad_value"("$?PACKAGE", $P7525)
    .const 'Sub' $P7526 = "581_1303739803.72" 
    $P7527 = $P7526."get_lexinfo"()
    $P7527."finish_static_lexpad"()
    .const 'Sub' $P7528 = "581_1303739803.72" 
    $P7529 = $P7528."get_lexinfo"()
    nqp_get_sc_object $P7530, "1303739791.58", 5
    $P7529."set_static_lexpad_value"("$?CLASS", $P7530)
    .const 'Sub' $P7531 = "581_1303739803.72" 
    $P7532 = $P7531."get_lexinfo"()
    $P7532."finish_static_lexpad"()
    goto if_7358_end
  if_7358:
    nqp_dynop_setup 
    getinterp $P7361
    get_class $P7362, "LexPad"
    get_class $P7363, "NQPLexPad"
    $P7361."hll_map"($P7362, $P7363)
    nqp_create_sc $P7364, "1303739791.58"
    .local pmc cur_sc
    set cur_sc, $P7364
    get_hll_global $P7365, "KnowHOW"
    $P7366 = $P7365."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P7366, cur_sc
    nqp_set_sc_object "1303739791.58", 0, $P7366
    .const 'Sub' $P7367 = "10_1303739803.72" 
    $P7368 = $P7367."get_lexinfo"()
    nqp_get_sc_object $P7369, "1303739791.58", 0
    $P7368."set_static_lexpad_value"("GLOBALish", $P7369)
    .const 'Sub' $P7370 = "10_1303739803.72" 
    $P7371 = $P7370."get_lexinfo"()
    $P7371."finish_static_lexpad"()
    .const 'Sub' $P7372 = "10_1303739803.72" 
    $P7373 = $P7372."get_lexinfo"()
    nqp_get_sc_object $P7374, "1303739791.58", 0
    $P7373."set_static_lexpad_value"("$?PACKAGE", $P7374)
    .const 'Sub' $P7375 = "10_1303739803.72" 
    $P7376 = $P7375."get_lexinfo"()
    $P7376."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7377, "ModuleLoader"
    $P7378 = $P7377."load_setting"("NQPCORE")
    block."set_outer_ctx"($P7378)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7379, "ModuleLoader"
    nqp_get_sc_object $P7380, "1303739791.58", 0
    $P7379."load_module"("Regex", $P7380)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7381, "ModuleLoader"
    nqp_get_sc_object $P7382, "1303739791.58", 0
    $P7381."load_module"("P6Regex", $P7382)
    get_hll_global $P7383, "NQPClassHOW"
    $P7384 = $P7383."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P7384, cur_sc
    nqp_set_sc_object "1303739791.58", 1, $P7384
    nqp_get_sc_object $P7385, "1303739791.58", 1
    nqp_get_sc_object $P7386, "1303739791.58", 0
    nqp_get_package_through_who $P7387, $P7386, "NQP"
    get_who $P7388, $P7387
    set $P7388["Grammar"], $P7385
    nqp_get_sc_object $P7389, "1303739791.58", 1
    set_hll_global ["NQP"], "Grammar", $P7389
    .const 'Sub' $P7390 = "12_1303739803.72" 
    $P7391 = $P7390."get_lexinfo"()
    nqp_get_sc_object $P7392, "1303739791.58", 1
    $P7391."set_static_lexpad_value"("$?PACKAGE", $P7392)
    .const 'Sub' $P7393 = "12_1303739803.72" 
    $P7394 = $P7393."get_lexinfo"()
    $P7394."finish_static_lexpad"()
    .const 'Sub' $P7395 = "12_1303739803.72" 
    $P7396 = $P7395."get_lexinfo"()
    nqp_get_sc_object $P7397, "1303739791.58", 1
    $P7396."set_static_lexpad_value"("$?CLASS", $P7397)
    .const 'Sub' $P7398 = "12_1303739803.72" 
    $P7399 = $P7398."get_lexinfo"()
    $P7399."finish_static_lexpad"()
    get_hll_global $P7400, "NQPClassHOW"
    $P7401 = $P7400."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P7401, cur_sc
    nqp_set_sc_object "1303739791.58", 2, $P7401
    nqp_get_sc_object $P7402, "1303739791.58", 2
    nqp_get_sc_object $P7403, "1303739791.58", 0
    nqp_get_package_through_who $P7404, $P7403, "NQP"
    get_who $P7405, $P7404
    set $P7405["Regex"], $P7402
    nqp_get_sc_object $P7406, "1303739791.58", 2
    set_hll_global ["NQP"], "Regex", $P7406
    .const 'Sub' $P7407 = "384_1303739803.72" 
    $P7408 = $P7407."get_lexinfo"()
    nqp_get_sc_object $P7409, "1303739791.58", 2
    $P7408."set_static_lexpad_value"("$?PACKAGE", $P7409)
    .const 'Sub' $P7410 = "384_1303739803.72" 
    $P7411 = $P7410."get_lexinfo"()
    $P7411."finish_static_lexpad"()
    .const 'Sub' $P7412 = "384_1303739803.72" 
    $P7413 = $P7412."get_lexinfo"()
    nqp_get_sc_object $P7414, "1303739791.58", 2
    $P7413."set_static_lexpad_value"("$?CLASS", $P7414)
    .const 'Sub' $P7415 = "384_1303739803.72" 
    $P7416 = $P7415."get_lexinfo"()
    $P7416."finish_static_lexpad"()
    get_hll_global $P7417, "NQPClassHOW"
    $P7418 = $P7417."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P7418, cur_sc
    nqp_set_sc_object "1303739791.58", 3, $P7418
    nqp_get_sc_object $P7419, "1303739791.58", 3
    nqp_get_sc_object $P7420, "1303739791.58", 0
    nqp_get_package_through_who $P7421, $P7420, "NQP"
    get_who $P7422, $P7421
    set $P7422["Actions"], $P7419
    nqp_get_sc_object $P7423, "1303739791.58", 3
    set_hll_global ["NQP"], "Actions", $P7423
    .const 'Sub' $P7424 = "406_1303739803.72" 
    $P7425 = $P7424."get_lexinfo"()
    nqp_get_sc_object $P7426, "1303739791.58", 3
    $P7425."set_static_lexpad_value"("$?PACKAGE", $P7426)
    .const 'Sub' $P7427 = "406_1303739803.72" 
    $P7428 = $P7427."get_lexinfo"()
    $P7428."finish_static_lexpad"()
    .const 'Sub' $P7429 = "406_1303739803.72" 
    $P7430 = $P7429."get_lexinfo"()
    nqp_get_sc_object $P7431, "1303739791.58", 3
    $P7430."set_static_lexpad_value"("$?CLASS", $P7431)
    .const 'Sub' $P7432 = "406_1303739803.72" 
    $P7433 = $P7432."get_lexinfo"()
    $P7433."finish_static_lexpad"()
    get_hll_global $P7434, "NQPClassHOW"
    $P7435 = $P7434."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P7435, cur_sc
    nqp_set_sc_object "1303739791.58", 4, $P7435
    nqp_get_sc_object $P7436, "1303739791.58", 4
    nqp_get_sc_object $P7437, "1303739791.58", 0
    nqp_get_package_through_who $P7438, $P7437, "NQP"
    get_who $P7439, $P7438
    set $P7439["RegexActions"], $P7436
    nqp_get_sc_object $P7440, "1303739791.58", 4
    set_hll_global ["NQP"], "RegexActions", $P7440
    .const 'Sub' $P7441 = "572_1303739803.72" 
    $P7442 = $P7441."get_lexinfo"()
    nqp_get_sc_object $P7443, "1303739791.58", 4
    $P7442."set_static_lexpad_value"("$?PACKAGE", $P7443)
    .const 'Sub' $P7444 = "572_1303739803.72" 
    $P7445 = $P7444."get_lexinfo"()
    $P7445."finish_static_lexpad"()
    .const 'Sub' $P7446 = "572_1303739803.72" 
    $P7447 = $P7446."get_lexinfo"()
    nqp_get_sc_object $P7448, "1303739791.58", 4
    $P7447."set_static_lexpad_value"("$?CLASS", $P7448)
    .const 'Sub' $P7449 = "572_1303739803.72" 
    $P7450 = $P7449."get_lexinfo"()
    $P7450."finish_static_lexpad"()
    get_hll_global $P7451, "NQPClassHOW"
    $P7452 = $P7451."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P7452, cur_sc
    nqp_set_sc_object "1303739791.58", 5, $P7452
    nqp_get_sc_object $P7453, "1303739791.58", 5
    nqp_get_sc_object $P7454, "1303739791.58", 0
    nqp_get_package_through_who $P7455, $P7454, "NQP"
    get_who $P7456, $P7455
    set $P7456["Compiler"], $P7453
    nqp_get_sc_object $P7457, "1303739791.58", 5
    set_hll_global ["NQP"], "Compiler", $P7457
    .const 'Sub' $P7458 = "581_1303739803.72" 
    $P7459 = $P7458."get_lexinfo"()
    nqp_get_sc_object $P7460, "1303739791.58", 5
    $P7459."set_static_lexpad_value"("$?PACKAGE", $P7460)
    .const 'Sub' $P7461 = "581_1303739803.72" 
    $P7462 = $P7461."get_lexinfo"()
    $P7462."finish_static_lexpad"()
    .const 'Sub' $P7463 = "581_1303739803.72" 
    $P7464 = $P7463."get_lexinfo"()
    nqp_get_sc_object $P7465, "1303739791.58", 5
    $P7464."set_static_lexpad_value"("$?CLASS", $P7465)
    .const 'Sub' $P7466 = "581_1303739803.72" 
    $P7467 = $P7466."get_lexinfo"()
    $P7467."finish_static_lexpad"()
  if_7358_end:
    nqp_get_sc_object $P7533, "1303739791.58", 0
    set_hll_global "GLOBAL", $P7533
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1303739803.72") :outer("10_1303739803.72")
    .param pmc param_17
.annotate 'line', 2325
    .lex "@ARGS", param_17
.annotate 'line', 2327
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2333
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2327
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2328
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_585
    new $P25, "Undef"
  vivify_585:
    $P25."language"("nqp")
.annotate 'line', 2329
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_586
    new $P26, "Undef"
  vivify_586:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2330
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_587
    new $P31, "Undef"
  vivify_587:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2333
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_588
    new $P36, "Undef"
  vivify_588:
    $P37 = $P36."commandline_options"()
    store_lex "@clo", $P37
.annotate 'line', 2334
    find_lex $P38, "@clo"
    unless_null $P38, vivify_589
    $P38 = root_new ['parrot';'ResizablePMCArray']
  vivify_589:
    $P38."push"("parsetrace")
.annotate 'line', 2335
    find_lex $P39, "@clo"
    unless_null $P39, vivify_590
    $P39 = root_new ['parrot';'ResizablePMCArray']
  vivify_590:
    $P39."push"("setting=s")
.annotate 'line', 2336
    find_lex $P40, "@clo"
    unless_null $P40, vivify_591
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_591:
    $P40."push"("setting-path=s")
.annotate 'line', 2337
    find_lex $P41, "@clo"
    unless_null $P41, vivify_592
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_592:
    $P41."push"("module-path=s")
.annotate 'line', 2340
    find_lex $P42, "$nqpcomp"
    unless_null $P42, vivify_593
    new $P42, "Undef"
  vivify_593:
    find_lex $P43, "@ARGS"
    unless_null $P43, vivify_594
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_594:
    $P44 = $P42."command_line"($P43, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2325
    .return ($P44)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block46"  :subid("12_1303739803.72") :outer("10_1303739803.72")
.annotate 'line', 9
    .const 'Sub' $P1930 = "383_1303739803.72" 
    capture_lex $P1930
    .const 'Sub' $P1917 = "382_1303739803.72" 
    capture_lex $P1917
    .const 'Sub' $P1911 = "380_1303739803.72" 
    capture_lex $P1911
    .const 'Sub' $P1905 = "378_1303739803.72" 
    capture_lex $P1905
    .const 'Sub' $P1899 = "376_1303739803.72" 
    capture_lex $P1899
    .const 'Sub' $P1893 = "374_1303739803.72" 
    capture_lex $P1893
    .const 'Sub' $P1881 = "371_1303739803.72" 
    capture_lex $P1881
    .const 'Sub' $P1874 = "369_1303739803.72" 
    capture_lex $P1874
    .const 'Sub' $P1867 = "367_1303739803.72" 
    capture_lex $P1867
    .const 'Sub' $P1860 = "365_1303739803.72" 
    capture_lex $P1860
    .const 'Sub' $P1853 = "363_1303739803.72" 
    capture_lex $P1853
    .const 'Sub' $P1847 = "361_1303739803.72" 
    capture_lex $P1847
    .const 'Sub' $P1840 = "359_1303739803.72" 
    capture_lex $P1840
    .const 'Sub' $P1833 = "357_1303739803.72" 
    capture_lex $P1833
    .const 'Sub' $P1826 = "355_1303739803.72" 
    capture_lex $P1826
    .const 'Sub' $P1819 = "353_1303739803.72" 
    capture_lex $P1819
    .const 'Sub' $P1812 = "351_1303739803.72" 
    capture_lex $P1812
    .const 'Sub' $P1805 = "349_1303739803.72" 
    capture_lex $P1805
    .const 'Sub' $P1798 = "347_1303739803.72" 
    capture_lex $P1798
    .const 'Sub' $P1791 = "345_1303739803.72" 
    capture_lex $P1791
    .const 'Sub' $P1784 = "343_1303739803.72" 
    capture_lex $P1784
    .const 'Sub' $P1777 = "341_1303739803.72" 
    capture_lex $P1777
    .const 'Sub' $P1770 = "339_1303739803.72" 
    capture_lex $P1770
    .const 'Sub' $P1763 = "337_1303739803.72" 
    capture_lex $P1763
    .const 'Sub' $P1756 = "335_1303739803.72" 
    capture_lex $P1756
    .const 'Sub' $P1749 = "333_1303739803.72" 
    capture_lex $P1749
    .const 'Sub' $P1742 = "331_1303739803.72" 
    capture_lex $P1742
    .const 'Sub' $P1735 = "329_1303739803.72" 
    capture_lex $P1735
    .const 'Sub' $P1728 = "327_1303739803.72" 
    capture_lex $P1728
    .const 'Sub' $P1721 = "325_1303739803.72" 
    capture_lex $P1721
    .const 'Sub' $P1714 = "323_1303739803.72" 
    capture_lex $P1714
    .const 'Sub' $P1707 = "321_1303739803.72" 
    capture_lex $P1707
    .const 'Sub' $P1700 = "319_1303739803.72" 
    capture_lex $P1700
    .const 'Sub' $P1693 = "317_1303739803.72" 
    capture_lex $P1693
    .const 'Sub' $P1686 = "315_1303739803.72" 
    capture_lex $P1686
    .const 'Sub' $P1679 = "313_1303739803.72" 
    capture_lex $P1679
    .const 'Sub' $P1672 = "311_1303739803.72" 
    capture_lex $P1672
    .const 'Sub' $P1665 = "309_1303739803.72" 
    capture_lex $P1665
    .const 'Sub' $P1658 = "307_1303739803.72" 
    capture_lex $P1658
    .const 'Sub' $P1651 = "305_1303739803.72" 
    capture_lex $P1651
    .const 'Sub' $P1644 = "303_1303739803.72" 
    capture_lex $P1644
    .const 'Sub' $P1638 = "301_1303739803.72" 
    capture_lex $P1638
    .const 'Sub' $P1631 = "299_1303739803.72" 
    capture_lex $P1631
    .const 'Sub' $P1624 = "297_1303739803.72" 
    capture_lex $P1624
    .const 'Sub' $P1617 = "295_1303739803.72" 
    capture_lex $P1617
    .const 'Sub' $P1610 = "293_1303739803.72" 
    capture_lex $P1610
    .const 'Sub' $P1603 = "291_1303739803.72" 
    capture_lex $P1603
    .const 'Sub' $P1596 = "289_1303739803.72" 
    capture_lex $P1596
    .const 'Sub' $P1589 = "287_1303739803.72" 
    capture_lex $P1589
    .const 'Sub' $P1583 = "285_1303739803.72" 
    capture_lex $P1583
    .const 'Sub' $P1577 = "283_1303739803.72" 
    capture_lex $P1577
    .const 'Sub' $P1572 = "281_1303739803.72" 
    capture_lex $P1572
    .const 'Sub' $P1566 = "279_1303739803.72" 
    capture_lex $P1566
    .const 'Sub' $P1560 = "277_1303739803.72" 
    capture_lex $P1560
    .const 'Sub' $P1555 = "275_1303739803.72" 
    capture_lex $P1555
    .const 'Sub' $P1550 = "273_1303739803.72" 
    capture_lex $P1550
    .const 'Sub' $P1542 = "271_1303739803.72" 
    capture_lex $P1542
    .const 'Sub' $P1533 = "269_1303739803.72" 
    capture_lex $P1533
    .const 'Sub' $P1528 = "267_1303739803.72" 
    capture_lex $P1528
    .const 'Sub' $P1523 = "265_1303739803.72" 
    capture_lex $P1523
    .const 'Sub' $P1518 = "263_1303739803.72" 
    capture_lex $P1518
    .const 'Sub' $P1510 = "261_1303739803.72" 
    capture_lex $P1510
    .const 'Sub' $P1502 = "259_1303739803.72" 
    capture_lex $P1502
    .const 'Sub' $P1497 = "257_1303739803.72" 
    capture_lex $P1497
    .const 'Sub' $P1492 = "255_1303739803.72" 
    capture_lex $P1492
    .const 'Sub' $P1487 = "253_1303739803.72" 
    capture_lex $P1487
    .const 'Sub' $P1481 = "251_1303739803.72" 
    capture_lex $P1481
    .const 'Sub' $P1474 = "249_1303739803.72" 
    capture_lex $P1474
    .const 'Sub' $P1467 = "247_1303739803.72" 
    capture_lex $P1467
    .const 'Sub' $P1460 = "245_1303739803.72" 
    capture_lex $P1460
    .const 'Sub' $P1453 = "243_1303739803.72" 
    capture_lex $P1453
    .const 'Sub' $P1448 = "241_1303739803.72" 
    capture_lex $P1448
    .const 'Sub' $P1443 = "239_1303739803.72" 
    capture_lex $P1443
    .const 'Sub' $P1429 = "235_1303739803.72" 
    capture_lex $P1429
    .const 'Sub' $P1421 = "233_1303739803.72" 
    capture_lex $P1421
    .const 'Sub' $P1415 = "231_1303739803.72" 
    capture_lex $P1415
    .const 'Sub' $P1408 = "229_1303739803.72" 
    capture_lex $P1408
    .const 'Sub' $P1402 = "227_1303739803.72" 
    capture_lex $P1402
    .const 'Sub' $P1386 = "224_1303739803.72" 
    capture_lex $P1386
    .const 'Sub' $P1378 = "222_1303739803.72" 
    capture_lex $P1378
    .const 'Sub' $P1370 = "220_1303739803.72" 
    capture_lex $P1370
    .const 'Sub' $P1364 = "218_1303739803.72" 
    capture_lex $P1364
    .const 'Sub' $P1358 = "216_1303739803.72" 
    capture_lex $P1358
    .const 'Sub' $P1342 = "212_1303739803.72" 
    capture_lex $P1342
    .const 'Sub' $P1301 = "210_1303739803.72" 
    capture_lex $P1301
    .const 'Sub' $P1290 = "208_1303739803.72" 
    capture_lex $P1290
    .const 'Sub' $P1276 = "204_1303739803.72" 
    capture_lex $P1276
    .const 'Sub' $P1267 = "202_1303739803.72" 
    capture_lex $P1267
    .const 'Sub' $P1261 = "200_1303739803.72" 
    capture_lex $P1261
    .const 'Sub' $P1251 = "198_1303739803.72" 
    capture_lex $P1251
    .const 'Sub' $P1236 = "196_1303739803.72" 
    capture_lex $P1236
    .const 'Sub' $P1220 = "193_1303739803.72" 
    capture_lex $P1220
    .const 'Sub' $P1212 = "191_1303739803.72" 
    capture_lex $P1212
    .const 'Sub' $P1202 = "189_1303739803.72" 
    capture_lex $P1202
    .const 'Sub' $P1192 = "187_1303739803.72" 
    capture_lex $P1192
    .const 'Sub' $P1171 = "182_1303739803.72" 
    capture_lex $P1171
    .const 'Sub' $P1127 = "179_1303739803.72" 
    capture_lex $P1127
    .const 'Sub' $P1093 = "177_1303739803.72" 
    capture_lex $P1093
    .const 'Sub' $P1086 = "175_1303739803.72" 
    capture_lex $P1086
    .const 'Sub' $P1079 = "173_1303739803.72" 
    capture_lex $P1079
    .const 'Sub' $P1062 = "169_1303739803.72" 
    capture_lex $P1062
    .const 'Sub' $P1054 = "167_1303739803.72" 
    capture_lex $P1054
    .const 'Sub' $P1048 = "165_1303739803.72" 
    capture_lex $P1048
    .const 'Sub' $P1032 = "163_1303739803.72" 
    capture_lex $P1032
    .const 'Sub' $P1025 = "161_1303739803.72" 
    capture_lex $P1025
    .const 'Sub' $P1018 = "159_1303739803.72" 
    capture_lex $P1018
    .const 'Sub' $P1011 = "157_1303739803.72" 
    capture_lex $P1011
    .const 'Sub' $P833 = "152_1303739803.72" 
    capture_lex $P833
    .const 'Sub' $P814 = "150_1303739803.72" 
    capture_lex $P814
    .const 'Sub' $P795 = "148_1303739803.72" 
    capture_lex $P795
    .const 'Sub' $P776 = "146_1303739803.72" 
    capture_lex $P776
    .const 'Sub' $P757 = "144_1303739803.72" 
    capture_lex $P757
    .const 'Sub' $P738 = "142_1303739803.72" 
    capture_lex $P738
    .const 'Sub' $P719 = "140_1303739803.72" 
    capture_lex $P719
    .const 'Sub' $P708 = "136_1303739803.72" 
    capture_lex $P708
    .const 'Sub' $P703 = "134_1303739803.72" 
    capture_lex $P703
    .const 'Sub' $P691 = "132_1303739803.72" 
    capture_lex $P691
    .const 'Sub' $P679 = "130_1303739803.72" 
    capture_lex $P679
    .const 'Sub' $P672 = "128_1303739803.72" 
    capture_lex $P672
    .const 'Sub' $P667 = "126_1303739803.72" 
    capture_lex $P667
    .const 'Sub' $P661 = "124_1303739803.72" 
    capture_lex $P661
    .const 'Sub' $P655 = "122_1303739803.72" 
    capture_lex $P655
    .const 'Sub' $P640 = "118_1303739803.72" 
    capture_lex $P640
    .const 'Sub' $P634 = "116_1303739803.72" 
    capture_lex $P634
    .const 'Sub' $P628 = "114_1303739803.72" 
    capture_lex $P628
    .const 'Sub' $P622 = "112_1303739803.72" 
    capture_lex $P622
    .const 'Sub' $P616 = "110_1303739803.72" 
    capture_lex $P616
    .const 'Sub' $P610 = "108_1303739803.72" 
    capture_lex $P610
    .const 'Sub' $P604 = "106_1303739803.72" 
    capture_lex $P604
    .const 'Sub' $P595 = "104_1303739803.72" 
    capture_lex $P595
    .const 'Sub' $P586 = "102_1303739803.72" 
    capture_lex $P586
    .const 'Sub' $P577 = "100_1303739803.72" 
    capture_lex $P577
    .const 'Sub' $P562 = "96_1303739803.72" 
    capture_lex $P562
    .const 'Sub' $P553 = "94_1303739803.72" 
    capture_lex $P553
    .const 'Sub' $P541 = "90_1303739803.72" 
    capture_lex $P541
    .const 'Sub' $P534 = "88_1303739803.72" 
    capture_lex $P534
    .const 'Sub' $P527 = "86_1303739803.72" 
    capture_lex $P527
    .const 'Sub' $P513 = "82_1303739803.72" 
    capture_lex $P513
    .const 'Sub' $P505 = "80_1303739803.72" 
    capture_lex $P505
    .const 'Sub' $P497 = "78_1303739803.72" 
    capture_lex $P497
    .const 'Sub' $P477 = "76_1303739803.72" 
    capture_lex $P477
    .const 'Sub' $P468 = "74_1303739803.72" 
    capture_lex $P468
    .const 'Sub' $P450 = "71_1303739803.72" 
    capture_lex $P450
    .const 'Sub' $P432 = "69_1303739803.72" 
    capture_lex $P432
    .const 'Sub' $P424 = "67_1303739803.72" 
    capture_lex $P424
    .const 'Sub' $P413 = "63_1303739803.72" 
    capture_lex $P413
    .const 'Sub' $P408 = "61_1303739803.72" 
    capture_lex $P408
    .const 'Sub' $P397 = "57_1303739803.72" 
    capture_lex $P397
    .const 'Sub' $P392 = "55_1303739803.72" 
    capture_lex $P392
    .const 'Sub' $P387 = "53_1303739803.72" 
    capture_lex $P387
    .const 'Sub' $P382 = "51_1303739803.72" 
    capture_lex $P382
    .const 'Sub' $P377 = "49_1303739803.72" 
    capture_lex $P377
    .const 'Sub' $P367 = "47_1303739803.72" 
    capture_lex $P367
    .const 'Sub' $P360 = "45_1303739803.72" 
    capture_lex $P360
    .const 'Sub' $P354 = "43_1303739803.72" 
    capture_lex $P354
    .const 'Sub' $P346 = "41_1303739803.72" 
    capture_lex $P346
    .const 'Sub' $P340 = "39_1303739803.72" 
    capture_lex $P340
    .const 'Sub' $P334 = "37_1303739803.72" 
    capture_lex $P334
    .const 'Sub' $P319 = "34_1303739803.72" 
    capture_lex $P319
    .const 'Sub' $P305 = "32_1303739803.72" 
    capture_lex $P305
    .const 'Sub' $P284 = "30_1303739803.72" 
    capture_lex $P284
    .const 'Sub' $P245 = "27_1303739803.72" 
    capture_lex $P245
    .const 'Sub' $P230 = "24_1303739803.72" 
    capture_lex $P230
    .const 'Sub' $P219 = "22_1303739803.72" 
    capture_lex $P219
    .const 'Sub' $P207 = "20_1303739803.72" 
    capture_lex $P207
    .const 'Sub' $P199 = "18_1303739803.72" 
    capture_lex $P199
    .const 'Sub' $P192 = "16_1303739803.72" 
    capture_lex $P192
    .const 'Sub' $P185 = "14_1303739803.72" 
    capture_lex $P185
    .const 'Sub' $P110 = "13_1303739803.72" 
    capture_lex $P110
    .lex "$?PACKAGE", $P48
    .lex "$?CLASS", $P49
.annotate 'line', 605
    get_hll_global $P50, "GLOBAL"
    nqp_get_package_through_who $P51, $P50, "NQP"
    get_who $P52, $P51
    set $P53, $P52["Grammar"]
    $P53."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 606
    get_hll_global $P54, "GLOBAL"
    nqp_get_package_through_who $P55, $P54, "NQP"
    get_who $P56, $P55
    set $P57, $P56["Grammar"]
    $P57."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 607
    get_hll_global $P58, "GLOBAL"
    nqp_get_package_through_who $P59, $P58, "NQP"
    get_who $P60, $P59
    set $P61, $P60["Grammar"]
    $P61."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 608
    get_hll_global $P62, "GLOBAL"
    nqp_get_package_through_who $P63, $P62, "NQP"
    get_who $P64, $P63
    set $P65, $P64["Grammar"]
    $P65."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 609
    get_hll_global $P66, "GLOBAL"
    nqp_get_package_through_who $P67, $P66, "NQP"
    get_who $P68, $P67
    set $P69, $P68["Grammar"]
    $P69."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 610
    get_hll_global $P70, "GLOBAL"
    nqp_get_package_through_who $P71, $P70, "NQP"
    get_who $P72, $P71
    set $P73, $P72["Grammar"]
    $P73."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 611
    get_hll_global $P74, "GLOBAL"
    nqp_get_package_through_who $P75, $P74, "NQP"
    get_who $P76, $P75
    set $P77, $P76["Grammar"]
    $P77."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 612
    get_hll_global $P78, "GLOBAL"
    nqp_get_package_through_who $P79, $P78, "NQP"
    get_who $P80, $P79
    set $P81, $P80["Grammar"]
    $P81."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 613
    get_hll_global $P82, "GLOBAL"
    nqp_get_package_through_who $P83, $P82, "NQP"
    get_who $P84, $P83
    set $P85, $P84["Grammar"]
    $P85."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 614
    get_hll_global $P86, "GLOBAL"
    nqp_get_package_through_who $P87, $P86, "NQP"
    get_who $P88, $P87
    set $P89, $P88["Grammar"]
    $P89."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 615
    get_hll_global $P90, "GLOBAL"
    nqp_get_package_through_who $P91, $P90, "NQP"
    get_who $P92, $P91
    set $P93, $P92["Grammar"]
    $P93."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 616
    get_hll_global $P94, "GLOBAL"
    nqp_get_package_through_who $P95, $P94, "NQP"
    get_who $P96, $P95
    set $P97, $P96["Grammar"]
    $P97."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 617
    get_hll_global $P98, "GLOBAL"
    nqp_get_package_through_who $P99, $P98, "NQP"
    get_who $P100, $P99
    set $P101, $P100["Grammar"]
    $P101."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 618
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P105."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 619
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "NQP"
    get_who $P108, $P107
    set $P109, $P108["Grammar"]
    $P109."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 718
    .const 'Sub' $P1917 = "382_1303739803.72" 
    newclosure $P1928, $P1917
.annotate 'line', 9
    .return ($P1928)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post595") :outer("12_1303739803.72")
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1303739803.72" 
    .local pmc block
    set block, $P47
    .const 'Sub' $P1930 = "383_1303739803.72" 
    capture_lex $P1930
    $P1930()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1929"  :anon :subid("383_1303739803.72") :outer("12_1303739803.72")
.annotate 'line', 9
    nqp_get_sc_object $P1931, "1303739791.58", 1
    .local pmc type_obj
    set type_obj, $P1931
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "13_1303739803.72" 
    $P1932."add_method"(type_obj, "TOP", $P1933)
    get_how $P1934, type_obj
    .const 'Sub' $P1935 = "14_1303739803.72" 
    $P1934."add_method"(type_obj, "identifier", $P1935)
    get_how $P1936, type_obj
    get_global $P1937, "!PREFIX__identifier"
    $P1936."add_method"(type_obj, "!PREFIX__identifier", $P1937)
    get_how $P1938, type_obj
    .const 'Sub' $P1939 = "16_1303739803.72" 
    $P1938."add_method"(type_obj, "name", $P1939)
    get_how $P1940, type_obj
    get_global $P1941, "!PREFIX__name"
    $P1940."add_method"(type_obj, "!PREFIX__name", $P1941)
    get_how $P1942, type_obj
    .const 'Sub' $P1943 = "18_1303739803.72" 
    $P1942."add_method"(type_obj, "deflongname", $P1943)
    get_how $P1944, type_obj
    get_global $P1945, "!PREFIX__deflongname"
    $P1944."add_method"(type_obj, "!PREFIX__deflongname", $P1945)
    get_how $P1946, type_obj
    .const 'Sub' $P1947 = "20_1303739803.72" 
    $P1946."add_method"(type_obj, "ENDSTMT", $P1947)
    get_how $P1948, type_obj
    get_global $P1949, "!PREFIX__ENDSTMT"
    $P1948."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "22_1303739803.72" 
    $P1950."add_method"(type_obj, "ws", $P1951)
    get_how $P1952, type_obj
    get_global $P1953, "!PREFIX__ws"
    $P1952."add_method"(type_obj, "!PREFIX__ws", $P1953)
    get_how $P1954, type_obj
    .const 'Sub' $P1955 = "24_1303739803.72" 
    $P1954."add_method"(type_obj, "unv", $P1955)
    get_how $P1956, type_obj
    get_global $P1957, "!PREFIX__unv"
    $P1956."add_method"(type_obj, "!PREFIX__unv", $P1957)
    get_how $P1958, type_obj
    .const 'Sub' $P1959 = "27_1303739803.72" 
    $P1958."add_method"(type_obj, "pod_comment", $P1959)
    get_how $P1960, type_obj
    get_global $P1961, "!PREFIX__pod_comment"
    $P1960."add_method"(type_obj, "!PREFIX__pod_comment", $P1961)
    get_how $P1962, type_obj
    .const 'Sub' $P1963 = "30_1303739803.72" 
    $P1962."add_method"(type_obj, "comp_unit", $P1963)
    get_how $P1964, type_obj
    get_global $P1965, "!PREFIX__comp_unit"
    $P1964."add_method"(type_obj, "!PREFIX__comp_unit", $P1965)
    get_how $P1966, type_obj
    .const 'Sub' $P1967 = "32_1303739803.72" 
    $P1966."add_method"(type_obj, "statementlist", $P1967)
    get_how $P1968, type_obj
    get_global $P1969, "!PREFIX__statementlist"
    $P1968."add_method"(type_obj, "!PREFIX__statementlist", $P1969)
    get_how $P1970, type_obj
    .const 'Sub' $P1971 = "34_1303739803.72" 
    $P1970."add_method"(type_obj, "statement", $P1971)
    get_how $P1972, type_obj
    get_global $P1973, "!PREFIX__statement"
    $P1972."add_method"(type_obj, "!PREFIX__statement", $P1973)
    get_how $P1974, type_obj
    .const 'Sub' $P1975 = "37_1303739803.72" 
    $P1974."add_method"(type_obj, "eat_terminator", $P1975)
    get_how $P1976, type_obj
    get_global $P1977, "!PREFIX__eat_terminator"
    $P1976."add_method"(type_obj, "!PREFIX__eat_terminator", $P1977)
    get_how $P1978, type_obj
    .const 'Sub' $P1979 = "39_1303739803.72" 
    $P1978."add_method"(type_obj, "xblock", $P1979)
    get_how $P1980, type_obj
    get_global $P1981, "!PREFIX__xblock"
    $P1980."add_method"(type_obj, "!PREFIX__xblock", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "41_1303739803.72" 
    $P1982."add_method"(type_obj, "pblock", $P1983)
    get_how $P1984, type_obj
    get_global $P1985, "!PREFIX__pblock"
    $P1984."add_method"(type_obj, "!PREFIX__pblock", $P1985)
    get_how $P1986, type_obj
    .const 'Sub' $P1987 = "43_1303739803.72" 
    $P1986."add_method"(type_obj, "lambda", $P1987)
    get_how $P1988, type_obj
    get_global $P1989, "!PREFIX__lambda"
    $P1988."add_method"(type_obj, "!PREFIX__lambda", $P1989)
    get_how $P1990, type_obj
    .const 'Sub' $P1991 = "45_1303739803.72" 
    $P1990."add_method"(type_obj, "block", $P1991)
    get_how $P1992, type_obj
    get_global $P1993, "!PREFIX__block"
    $P1992."add_method"(type_obj, "!PREFIX__block", $P1993)
    get_how $P1994, type_obj
    .const 'Sub' $P1995 = "47_1303739803.72" 
    $P1994."add_method"(type_obj, "blockoid", $P1995)
    get_how $P1996, type_obj
    get_global $P1997, "!PREFIX__blockoid"
    $P1996."add_method"(type_obj, "!PREFIX__blockoid", $P1997)
    get_how $P1998, type_obj
    .const 'Sub' $P1999 = "49_1303739803.72" 
    $P1998."add_method"(type_obj, "newpad", $P1999)
    get_how $P2000, type_obj
    get_global $P2001, "!PREFIX__newpad"
    $P2000."add_method"(type_obj, "!PREFIX__newpad", $P2001)
    get_how $P2002, type_obj
    .const 'Sub' $P2003 = "51_1303739803.72" 
    $P2002."add_method"(type_obj, "outerctx", $P2003)
    get_how $P2004, type_obj
    get_global $P2005, "!PREFIX__outerctx"
    $P2004."add_method"(type_obj, "!PREFIX__outerctx", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "53_1303739803.72" 
    $P2006."add_method"(type_obj, "GLOBALish", $P2007)
    get_how $P2008, type_obj
    get_global $P2009, "!PREFIX__GLOBALish"
    $P2008."add_method"(type_obj, "!PREFIX__GLOBALish", $P2009)
    get_how $P2010, type_obj
    .const 'Sub' $P2011 = "55_1303739803.72" 
    $P2010."add_method"(type_obj, "finishpad", $P2011)
    get_how $P2012, type_obj
    get_global $P2013, "!PREFIX__finishpad"
    $P2012."add_method"(type_obj, "!PREFIX__finishpad", $P2013)
    get_how $P2014, type_obj
    .const 'Sub' $P2015 = "57_1303739803.72" 
    $P2014."add_method"(type_obj, "you_are_here", $P2015)
    get_how $P2016, type_obj
    get_global $P2017, "!PREFIX__you_are_here"
    $P2016."add_method"(type_obj, "!PREFIX__you_are_here", $P2017)
    get_how $P2018, type_obj
    .const 'Sub' $P2019 = "59_1303739803.72" 
    $P2018."add_method"(type_obj, "terminator", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "60_1303739803.72" 
    $P2020."add_method"(type_obj, "!PREFIX__terminator", $P2021)
    get_how $P2022, type_obj
    .const 'Sub' $P2023 = "61_1303739803.72" 
    $P2022."add_method"(type_obj, "terminator:sym<;>", $P2023)
    get_how $P2024, type_obj
    get_global $P2025, "!PREFIX__terminator:sym<;>"
    $P2024."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P2025)
    get_how $P2026, type_obj
    .const 'Sub' $P2027 = "63_1303739803.72" 
    $P2026."add_method"(type_obj, "terminator:sym<}>", $P2027)
    get_how $P2028, type_obj
    get_global $P2029, "!PREFIX__terminator:sym<}>"
    $P2028."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P2029)
    get_how $P2030, type_obj
    .const 'Sub' $P2031 = "65_1303739803.72" 
    $P2030."add_method"(type_obj, "statement_control", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "66_1303739803.72" 
    $P2032."add_method"(type_obj, "!PREFIX__statement_control", $P2033)
    get_how $P2034, type_obj
    .const 'Sub' $P2035 = "67_1303739803.72" 
    $P2034."add_method"(type_obj, "statement_control:sym<use>", $P2035)
    get_how $P2036, type_obj
    get_global $P2037, "!PREFIX__statement_control:sym<use>"
    $P2036."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "69_1303739803.72" 
    $P2038."add_method"(type_obj, "statement_control:sym<if>", $P2039)
    get_how $P2040, type_obj
    get_global $P2041, "!PREFIX__statement_control:sym<if>"
    $P2040."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P2041)
    get_how $P2042, type_obj
    .const 'Sub' $P2043 = "71_1303739803.72" 
    $P2042."add_method"(type_obj, "statement_control:sym<unless>", $P2043)
    get_how $P2044, type_obj
    get_global $P2045, "!PREFIX__statement_control:sym<unless>"
    $P2044."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "74_1303739803.72" 
    $P2046."add_method"(type_obj, "statement_control:sym<while>", $P2047)
    get_how $P2048, type_obj
    get_global $P2049, "!PREFIX__statement_control:sym<while>"
    $P2048."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P2049)
    get_how $P2050, type_obj
    .const 'Sub' $P2051 = "76_1303739803.72" 
    $P2050."add_method"(type_obj, "statement_control:sym<repeat>", $P2051)
    get_how $P2052, type_obj
    get_global $P2053, "!PREFIX__statement_control:sym<repeat>"
    $P2052."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P2053)
    get_how $P2054, type_obj
    .const 'Sub' $P2055 = "78_1303739803.72" 
    $P2054."add_method"(type_obj, "statement_control:sym<for>", $P2055)
    get_how $P2056, type_obj
    get_global $P2057, "!PREFIX__statement_control:sym<for>"
    $P2056."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P2057)
    get_how $P2058, type_obj
    .const 'Sub' $P2059 = "80_1303739803.72" 
    $P2058."add_method"(type_obj, "statement_control:sym<CATCH>", $P2059)
    get_how $P2060, type_obj
    get_global $P2061, "!PREFIX__statement_control:sym<CATCH>"
    $P2060."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "82_1303739803.72" 
    $P2062."add_method"(type_obj, "statement_control:sym<CONTROL>", $P2063)
    get_how $P2064, type_obj
    get_global $P2065, "!PREFIX__statement_control:sym<CONTROL>"
    $P2064."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "84_1303739803.72" 
    $P2066."add_method"(type_obj, "statement_prefix", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "85_1303739803.72" 
    $P2068."add_method"(type_obj, "!PREFIX__statement_prefix", $P2069)
    get_how $P2070, type_obj
    .const 'Sub' $P2071 = "86_1303739803.72" 
    $P2070."add_method"(type_obj, "statement_prefix:sym<INIT>", $P2071)
    get_how $P2072, type_obj
    get_global $P2073, "!PREFIX__statement_prefix:sym<INIT>"
    $P2072."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P2073)
    get_how $P2074, type_obj
    .const 'Sub' $P2075 = "88_1303739803.72" 
    $P2074."add_method"(type_obj, "statement_prefix:sym<try>", $P2075)
    get_how $P2076, type_obj
    get_global $P2077, "!PREFIX__statement_prefix:sym<try>"
    $P2076."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "90_1303739803.72" 
    $P2078."add_method"(type_obj, "blorst", $P2079)
    get_how $P2080, type_obj
    get_global $P2081, "!PREFIX__blorst"
    $P2080."add_method"(type_obj, "!PREFIX__blorst", $P2081)
    get_how $P2082, type_obj
    .const 'Sub' $P2083 = "92_1303739803.72" 
    $P2082."add_method"(type_obj, "statement_mod_cond", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "93_1303739803.72" 
    $P2084."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P2085)
    get_how $P2086, type_obj
    .const 'Sub' $P2087 = "94_1303739803.72" 
    $P2086."add_method"(type_obj, "statement_mod_cond:sym<if>", $P2087)
    get_how $P2088, type_obj
    get_global $P2089, "!PREFIX__statement_mod_cond:sym<if>"
    $P2088."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P2089)
    get_how $P2090, type_obj
    .const 'Sub' $P2091 = "96_1303739803.72" 
    $P2090."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P2091)
    get_how $P2092, type_obj
    get_global $P2093, "!PREFIX__statement_mod_cond:sym<unless>"
    $P2092."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P2093)
    get_how $P2094, type_obj
    .const 'Sub' $P2095 = "98_1303739803.72" 
    $P2094."add_method"(type_obj, "statement_mod_loop", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "99_1303739803.72" 
    $P2096."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P2097)
    get_how $P2098, type_obj
    .const 'Sub' $P2099 = "100_1303739803.72" 
    $P2098."add_method"(type_obj, "statement_mod_loop:sym<while>", $P2099)
    get_how $P2100, type_obj
    get_global $P2101, "!PREFIX__statement_mod_loop:sym<while>"
    $P2100."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P2101)
    get_how $P2102, type_obj
    .const 'Sub' $P2103 = "102_1303739803.72" 
    $P2102."add_method"(type_obj, "statement_mod_loop:sym<until>", $P2103)
    get_how $P2104, type_obj
    get_global $P2105, "!PREFIX__statement_mod_loop:sym<until>"
    $P2104."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P2105)
    get_how $P2106, type_obj
    .const 'Sub' $P2107 = "104_1303739803.72" 
    $P2106."add_method"(type_obj, "statement_mod_loop:sym<for>", $P2107)
    get_how $P2108, type_obj
    get_global $P2109, "!PREFIX__statement_mod_loop:sym<for>"
    $P2108."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P2109)
    get_how $P2110, type_obj
    .const 'Sub' $P2111 = "106_1303739803.72" 
    $P2110."add_method"(type_obj, "term:sym<fatarrow>", $P2111)
    get_how $P2112, type_obj
    get_global $P2113, "!PREFIX__term:sym<fatarrow>"
    $P2112."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P2113)
    get_how $P2114, type_obj
    .const 'Sub' $P2115 = "108_1303739803.72" 
    $P2114."add_method"(type_obj, "term:sym<colonpair>", $P2115)
    get_how $P2116, type_obj
    get_global $P2117, "!PREFIX__term:sym<colonpair>"
    $P2116."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P2117)
    get_how $P2118, type_obj
    .const 'Sub' $P2119 = "110_1303739803.72" 
    $P2118."add_method"(type_obj, "term:sym<variable>", $P2119)
    get_how $P2120, type_obj
    get_global $P2121, "!PREFIX__term:sym<variable>"
    $P2120."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P2121)
    get_how $P2122, type_obj
    .const 'Sub' $P2123 = "112_1303739803.72" 
    $P2122."add_method"(type_obj, "term:sym<package_declarator>", $P2123)
    get_how $P2124, type_obj
    get_global $P2125, "!PREFIX__term:sym<package_declarator>"
    $P2124."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P2125)
    get_how $P2126, type_obj
    .const 'Sub' $P2127 = "114_1303739803.72" 
    $P2126."add_method"(type_obj, "term:sym<scope_declarator>", $P2127)
    get_how $P2128, type_obj
    get_global $P2129, "!PREFIX__term:sym<scope_declarator>"
    $P2128."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P2129)
    get_how $P2130, type_obj
    .const 'Sub' $P2131 = "116_1303739803.72" 
    $P2130."add_method"(type_obj, "term:sym<routine_declarator>", $P2131)
    get_how $P2132, type_obj
    get_global $P2133, "!PREFIX__term:sym<routine_declarator>"
    $P2132."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P2133)
    get_how $P2134, type_obj
    .const 'Sub' $P2135 = "118_1303739803.72" 
    $P2134."add_method"(type_obj, "term:sym<multi_declarator>", $P2135)
    get_how $P2136, type_obj
    get_global $P2137, "!PREFIX__term:sym<multi_declarator>"
    $P2136."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P2137)
    get_how $P2138, type_obj
    .const 'Sub' $P2139 = "122_1303739803.72" 
    $P2138."add_method"(type_obj, "term:sym<regex_declarator>", $P2139)
    get_how $P2140, type_obj
    get_global $P2141, "!PREFIX__term:sym<regex_declarator>"
    $P2140."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P2141)
    get_how $P2142, type_obj
    .const 'Sub' $P2143 = "124_1303739803.72" 
    $P2142."add_method"(type_obj, "term:sym<statement_prefix>", $P2143)
    get_how $P2144, type_obj
    get_global $P2145, "!PREFIX__term:sym<statement_prefix>"
    $P2144."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P2145)
    get_how $P2146, type_obj
    .const 'Sub' $P2147 = "126_1303739803.72" 
    $P2146."add_method"(type_obj, "term:sym<lambda>", $P2147)
    get_how $P2148, type_obj
    get_global $P2149, "!PREFIX__term:sym<lambda>"
    $P2148."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P2149)
    get_how $P2150, type_obj
    .const 'Sub' $P2151 = "128_1303739803.72" 
    $P2150."add_method"(type_obj, "fatarrow", $P2151)
    get_how $P2152, type_obj
    get_global $P2153, "!PREFIX__fatarrow"
    $P2152."add_method"(type_obj, "!PREFIX__fatarrow", $P2153)
    get_how $P2154, type_obj
    .const 'Sub' $P2155 = "130_1303739803.72" 
    $P2154."add_method"(type_obj, "colonpair", $P2155)
    get_how $P2156, type_obj
    get_global $P2157, "!PREFIX__colonpair"
    $P2156."add_method"(type_obj, "!PREFIX__colonpair", $P2157)
    get_how $P2158, type_obj
    .const 'Sub' $P2159 = "132_1303739803.72" 
    $P2158."add_method"(type_obj, "variable", $P2159)
    get_how $P2160, type_obj
    get_global $P2161, "!PREFIX__variable"
    $P2160."add_method"(type_obj, "!PREFIX__variable", $P2161)
    get_how $P2162, type_obj
    .const 'Sub' $P2163 = "134_1303739803.72" 
    $P2162."add_method"(type_obj, "sigil", $P2163)
    get_how $P2164, type_obj
    get_global $P2165, "!PREFIX__sigil"
    $P2164."add_method"(type_obj, "!PREFIX__sigil", $P2165)
    get_how $P2166, type_obj
    .const 'Sub' $P2167 = "136_1303739803.72" 
    $P2166."add_method"(type_obj, "twigil", $P2167)
    get_how $P2168, type_obj
    get_global $P2169, "!PREFIX__twigil"
    $P2168."add_method"(type_obj, "!PREFIX__twigil", $P2169)
    get_how $P2170, type_obj
    .const 'Sub' $P2171 = "138_1303739803.72" 
    $P2170."add_method"(type_obj, "package_declarator", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "139_1303739803.72" 
    $P2172."add_method"(type_obj, "!PREFIX__package_declarator", $P2173)
    get_how $P2174, type_obj
    .const 'Sub' $P2175 = "140_1303739803.72" 
    $P2174."add_method"(type_obj, "package_declarator:sym<module>", $P2175)
    get_how $P2176, type_obj
    get_global $P2177, "!PREFIX__package_declarator:sym<module>"
    $P2176."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2177)
    get_how $P2178, type_obj
    .const 'Sub' $P2179 = "142_1303739803.72" 
    $P2178."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2179)
    get_how $P2180, type_obj
    get_global $P2181, "!PREFIX__package_declarator:sym<knowhow>"
    $P2180."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2181)
    get_how $P2182, type_obj
    .const 'Sub' $P2183 = "144_1303739803.72" 
    $P2182."add_method"(type_obj, "package_declarator:sym<class>", $P2183)
    get_how $P2184, type_obj
    get_global $P2185, "!PREFIX__package_declarator:sym<class>"
    $P2184."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2185)
    get_how $P2186, type_obj
    .const 'Sub' $P2187 = "146_1303739803.72" 
    $P2186."add_method"(type_obj, "package_declarator:sym<grammar>", $P2187)
    get_how $P2188, type_obj
    get_global $P2189, "!PREFIX__package_declarator:sym<grammar>"
    $P2188."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2189)
    get_how $P2190, type_obj
    .const 'Sub' $P2191 = "148_1303739803.72" 
    $P2190."add_method"(type_obj, "package_declarator:sym<role>", $P2191)
    get_how $P2192, type_obj
    get_global $P2193, "!PREFIX__package_declarator:sym<role>"
    $P2192."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2193)
    get_how $P2194, type_obj
    .const 'Sub' $P2195 = "150_1303739803.72" 
    $P2194."add_method"(type_obj, "package_declarator:sym<native>", $P2195)
    get_how $P2196, type_obj
    get_global $P2197, "!PREFIX__package_declarator:sym<native>"
    $P2196."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2197)
    get_how $P2198, type_obj
    .const 'Sub' $P2199 = "152_1303739803.72" 
    $P2198."add_method"(type_obj, "package_def", $P2199)
    get_how $P2200, type_obj
    get_global $P2201, "!PREFIX__package_def"
    $P2200."add_method"(type_obj, "!PREFIX__package_def", $P2201)
    get_how $P2202, type_obj
    .const 'Sub' $P2203 = "155_1303739803.72" 
    $P2202."add_method"(type_obj, "scope_declarator", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "156_1303739803.72" 
    $P2204."add_method"(type_obj, "!PREFIX__scope_declarator", $P2205)
    get_how $P2206, type_obj
    .const 'Sub' $P2207 = "157_1303739803.72" 
    $P2206."add_method"(type_obj, "scope_declarator:sym<my>", $P2207)
    get_how $P2208, type_obj
    get_global $P2209, "!PREFIX__scope_declarator:sym<my>"
    $P2208."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2209)
    get_how $P2210, type_obj
    .const 'Sub' $P2211 = "159_1303739803.72" 
    $P2210."add_method"(type_obj, "scope_declarator:sym<our>", $P2211)
    get_how $P2212, type_obj
    get_global $P2213, "!PREFIX__scope_declarator:sym<our>"
    $P2212."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2213)
    get_how $P2214, type_obj
    .const 'Sub' $P2215 = "161_1303739803.72" 
    $P2214."add_method"(type_obj, "scope_declarator:sym<has>", $P2215)
    get_how $P2216, type_obj
    get_global $P2217, "!PREFIX__scope_declarator:sym<has>"
    $P2216."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2217)
    get_how $P2218, type_obj
    .const 'Sub' $P2219 = "163_1303739803.72" 
    $P2218."add_method"(type_obj, "scoped", $P2219)
    get_how $P2220, type_obj
    get_global $P2221, "!PREFIX__scoped"
    $P2220."add_method"(type_obj, "!PREFIX__scoped", $P2221)
    get_how $P2222, type_obj
    .const 'Sub' $P2223 = "165_1303739803.72" 
    $P2222."add_method"(type_obj, "typename", $P2223)
    get_how $P2224, type_obj
    get_global $P2225, "!PREFIX__typename"
    $P2224."add_method"(type_obj, "!PREFIX__typename", $P2225)
    get_how $P2226, type_obj
    .const 'Sub' $P2227 = "167_1303739803.72" 
    $P2226."add_method"(type_obj, "declarator", $P2227)
    get_how $P2228, type_obj
    get_global $P2229, "!PREFIX__declarator"
    $P2228."add_method"(type_obj, "!PREFIX__declarator", $P2229)
    get_how $P2230, type_obj
    .const 'Sub' $P2231 = "169_1303739803.72" 
    $P2230."add_method"(type_obj, "variable_declarator", $P2231)
    get_how $P2232, type_obj
    get_global $P2233, "!PREFIX__variable_declarator"
    $P2232."add_method"(type_obj, "!PREFIX__variable_declarator", $P2233)
    get_how $P2234, type_obj
    .const 'Sub' $P2235 = "171_1303739803.72" 
    $P2234."add_method"(type_obj, "routine_declarator", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "172_1303739803.72" 
    $P2236."add_method"(type_obj, "!PREFIX__routine_declarator", $P2237)
    get_how $P2238, type_obj
    .const 'Sub' $P2239 = "173_1303739803.72" 
    $P2238."add_method"(type_obj, "routine_declarator:sym<sub>", $P2239)
    get_how $P2240, type_obj
    get_global $P2241, "!PREFIX__routine_declarator:sym<sub>"
    $P2240."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2241)
    get_how $P2242, type_obj
    .const 'Sub' $P2243 = "175_1303739803.72" 
    $P2242."add_method"(type_obj, "routine_declarator:sym<method>", $P2243)
    get_how $P2244, type_obj
    get_global $P2245, "!PREFIX__routine_declarator:sym<method>"
    $P2244."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2245)
    get_how $P2246, type_obj
    .const 'Sub' $P2247 = "177_1303739803.72" 
    $P2246."add_method"(type_obj, "routine_def", $P2247)
    get_how $P2248, type_obj
    get_global $P2249, "!PREFIX__routine_def"
    $P2248."add_method"(type_obj, "!PREFIX__routine_def", $P2249)
    get_how $P2250, type_obj
    .const 'Sub' $P2251 = "179_1303739803.72" 
    $P2250."add_method"(type_obj, "method_def", $P2251)
    get_how $P2252, type_obj
    get_global $P2253, "!PREFIX__method_def"
    $P2252."add_method"(type_obj, "!PREFIX__method_def", $P2253)
    get_how $P2254, type_obj
    .const 'Sub' $P2255 = "182_1303739803.72" 
    $P2254."add_method"(type_obj, "onlystar", $P2255)
    get_how $P2256, type_obj
    get_global $P2257, "!PREFIX__onlystar"
    $P2256."add_method"(type_obj, "!PREFIX__onlystar", $P2257)
    get_how $P2258, type_obj
    .const 'Sub' $P2259 = "185_1303739803.72" 
    $P2258."add_method"(type_obj, "multi_declarator", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "186_1303739803.72" 
    $P2260."add_method"(type_obj, "!PREFIX__multi_declarator", $P2261)
    get_how $P2262, type_obj
    .const 'Sub' $P2263 = "187_1303739803.72" 
    $P2262."add_method"(type_obj, "multi_declarator:sym<multi>", $P2263)
    get_how $P2264, type_obj
    get_global $P2265, "!PREFIX__multi_declarator:sym<multi>"
    $P2264."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2265)
    get_how $P2266, type_obj
    .const 'Sub' $P2267 = "189_1303739803.72" 
    $P2266."add_method"(type_obj, "multi_declarator:sym<proto>", $P2267)
    get_how $P2268, type_obj
    get_global $P2269, "!PREFIX__multi_declarator:sym<proto>"
    $P2268."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2269)
    get_how $P2270, type_obj
    .const 'Sub' $P2271 = "191_1303739803.72" 
    $P2270."add_method"(type_obj, "multi_declarator:sym<null>", $P2271)
    get_how $P2272, type_obj
    get_global $P2273, "!PREFIX__multi_declarator:sym<null>"
    $P2272."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2273)
    get_how $P2274, type_obj
    .const 'Sub' $P2275 = "193_1303739803.72" 
    $P2274."add_method"(type_obj, "signature", $P2275)
    get_how $P2276, type_obj
    get_global $P2277, "!PREFIX__signature"
    $P2276."add_method"(type_obj, "!PREFIX__signature", $P2277)
    get_how $P2278, type_obj
    .const 'Sub' $P2279 = "196_1303739803.72" 
    $P2278."add_method"(type_obj, "parameter", $P2279)
    get_how $P2280, type_obj
    get_global $P2281, "!PREFIX__parameter"
    $P2280."add_method"(type_obj, "!PREFIX__parameter", $P2281)
    get_how $P2282, type_obj
    .const 'Sub' $P2283 = "198_1303739803.72" 
    $P2282."add_method"(type_obj, "param_var", $P2283)
    get_how $P2284, type_obj
    get_global $P2285, "!PREFIX__param_var"
    $P2284."add_method"(type_obj, "!PREFIX__param_var", $P2285)
    get_how $P2286, type_obj
    .const 'Sub' $P2287 = "200_1303739803.72" 
    $P2286."add_method"(type_obj, "named_param", $P2287)
    get_how $P2288, type_obj
    get_global $P2289, "!PREFIX__named_param"
    $P2288."add_method"(type_obj, "!PREFIX__named_param", $P2289)
    get_how $P2290, type_obj
    .const 'Sub' $P2291 = "202_1303739803.72" 
    $P2290."add_method"(type_obj, "default_value", $P2291)
    get_how $P2292, type_obj
    get_global $P2293, "!PREFIX__default_value"
    $P2292."add_method"(type_obj, "!PREFIX__default_value", $P2293)
    get_how $P2294, type_obj
    .const 'Sub' $P2295 = "204_1303739803.72" 
    $P2294."add_method"(type_obj, "trait", $P2295)
    get_how $P2296, type_obj
    get_global $P2297, "!PREFIX__trait"
    $P2296."add_method"(type_obj, "!PREFIX__trait", $P2297)
    get_how $P2298, type_obj
    .const 'Sub' $P2299 = "206_1303739803.72" 
    $P2298."add_method"(type_obj, "trait_mod", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "207_1303739803.72" 
    $P2300."add_method"(type_obj, "!PREFIX__trait_mod", $P2301)
    get_how $P2302, type_obj
    .const 'Sub' $P2303 = "208_1303739803.72" 
    $P2302."add_method"(type_obj, "trait_mod:sym<is>", $P2303)
    get_how $P2304, type_obj
    get_global $P2305, "!PREFIX__trait_mod:sym<is>"
    $P2304."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2305)
    get_how $P2306, type_obj
    .const 'Sub' $P2307 = "210_1303739803.72" 
    $P2306."add_method"(type_obj, "regex_declarator", $P2307)
    get_how $P2308, type_obj
    get_global $P2309, "!PREFIX__regex_declarator"
    $P2308."add_method"(type_obj, "!PREFIX__regex_declarator", $P2309)
    get_how $P2310, type_obj
    .const 'Sub' $P2311 = "212_1303739803.72" 
    $P2310."add_method"(type_obj, "dotty", $P2311)
    get_how $P2312, type_obj
    get_global $P2313, "!PREFIX__dotty"
    $P2312."add_method"(type_obj, "!PREFIX__dotty", $P2313)
    get_how $P2314, type_obj
    .const 'Sub' $P2315 = "214_1303739803.72" 
    $P2314."add_method"(type_obj, "term", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "215_1303739803.72" 
    $P2316."add_method"(type_obj, "!PREFIX__term", $P2317)
    get_how $P2318, type_obj
    .const 'Sub' $P2319 = "216_1303739803.72" 
    $P2318."add_method"(type_obj, "term:sym<self>", $P2319)
    get_how $P2320, type_obj
    get_global $P2321, "!PREFIX__term:sym<self>"
    $P2320."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2321)
    get_how $P2322, type_obj
    .const 'Sub' $P2323 = "218_1303739803.72" 
    $P2322."add_method"(type_obj, "term:sym<identifier>", $P2323)
    get_how $P2324, type_obj
    get_global $P2325, "!PREFIX__term:sym<identifier>"
    $P2324."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2325)
    get_how $P2326, type_obj
    .const 'Sub' $P2327 = "220_1303739803.72" 
    $P2326."add_method"(type_obj, "term:sym<name>", $P2327)
    get_how $P2328, type_obj
    get_global $P2329, "!PREFIX__term:sym<name>"
    $P2328."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2329)
    get_how $P2330, type_obj
    .const 'Sub' $P2331 = "222_1303739803.72" 
    $P2330."add_method"(type_obj, "term:sym<pir::op>", $P2331)
    get_how $P2332, type_obj
    get_global $P2333, "!PREFIX__term:sym<pir::op>"
    $P2332."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2333)
    get_how $P2334, type_obj
    .const 'Sub' $P2335 = "224_1303739803.72" 
    $P2334."add_method"(type_obj, "term:sym<onlystar>", $P2335)
    get_how $P2336, type_obj
    get_global $P2337, "!PREFIX__term:sym<onlystar>"
    $P2336."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2337)
    get_how $P2338, type_obj
    .const 'Sub' $P2339 = "227_1303739803.72" 
    $P2338."add_method"(type_obj, "args", $P2339)
    get_how $P2340, type_obj
    get_global $P2341, "!PREFIX__args"
    $P2340."add_method"(type_obj, "!PREFIX__args", $P2341)
    get_how $P2342, type_obj
    .const 'Sub' $P2343 = "229_1303739803.72" 
    $P2342."add_method"(type_obj, "arglist", $P2343)
    get_how $P2344, type_obj
    get_global $P2345, "!PREFIX__arglist"
    $P2344."add_method"(type_obj, "!PREFIX__arglist", $P2345)
    get_how $P2346, type_obj
    .const 'Sub' $P2347 = "231_1303739803.72" 
    $P2346."add_method"(type_obj, "term:sym<value>", $P2347)
    get_how $P2348, type_obj
    get_global $P2349, "!PREFIX__term:sym<value>"
    $P2348."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2349)
    get_how $P2350, type_obj
    .const 'Sub' $P2351 = "233_1303739803.72" 
    $P2350."add_method"(type_obj, "value", $P2351)
    get_how $P2352, type_obj
    get_global $P2353, "!PREFIX__value"
    $P2352."add_method"(type_obj, "!PREFIX__value", $P2353)
    get_how $P2354, type_obj
    .const 'Sub' $P2355 = "235_1303739803.72" 
    $P2354."add_method"(type_obj, "number", $P2355)
    get_how $P2356, type_obj
    get_global $P2357, "!PREFIX__number"
    $P2356."add_method"(type_obj, "!PREFIX__number", $P2357)
    get_how $P2358, type_obj
    .const 'Sub' $P2359 = "237_1303739803.72" 
    $P2358."add_method"(type_obj, "quote", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "238_1303739803.72" 
    $P2360."add_method"(type_obj, "!PREFIX__quote", $P2361)
    get_how $P2362, type_obj
    .const 'Sub' $P2363 = "239_1303739803.72" 
    $P2362."add_method"(type_obj, "quote:sym<apos>", $P2363)
    get_how $P2364, type_obj
    get_global $P2365, "!PREFIX__quote:sym<apos>"
    $P2364."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2365)
    get_how $P2366, type_obj
    .const 'Sub' $P2367 = "241_1303739803.72" 
    $P2366."add_method"(type_obj, "quote:sym<dblq>", $P2367)
    get_how $P2368, type_obj
    get_global $P2369, "!PREFIX__quote:sym<dblq>"
    $P2368."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2369)
    get_how $P2370, type_obj
    .const 'Sub' $P2371 = "243_1303739803.72" 
    $P2370."add_method"(type_obj, "quote:sym<q>", $P2371)
    get_how $P2372, type_obj
    get_global $P2373, "!PREFIX__quote:sym<q>"
    $P2372."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2373)
    get_how $P2374, type_obj
    .const 'Sub' $P2375 = "245_1303739803.72" 
    $P2374."add_method"(type_obj, "quote:sym<qq>", $P2375)
    get_how $P2376, type_obj
    get_global $P2377, "!PREFIX__quote:sym<qq>"
    $P2376."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2377)
    get_how $P2378, type_obj
    .const 'Sub' $P2379 = "247_1303739803.72" 
    $P2378."add_method"(type_obj, "quote:sym<Q>", $P2379)
    get_how $P2380, type_obj
    get_global $P2381, "!PREFIX__quote:sym<Q>"
    $P2380."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2381)
    get_how $P2382, type_obj
    .const 'Sub' $P2383 = "249_1303739803.72" 
    $P2382."add_method"(type_obj, "quote:sym<Q:PIR>", $P2383)
    get_how $P2384, type_obj
    get_global $P2385, "!PREFIX__quote:sym<Q:PIR>"
    $P2384."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2385)
    get_how $P2386, type_obj
    .const 'Sub' $P2387 = "251_1303739803.72" 
    $P2386."add_method"(type_obj, "quote:sym</ />", $P2387)
    get_how $P2388, type_obj
    get_global $P2389, "!PREFIX__quote:sym</ />"
    $P2388."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2389)
    get_how $P2390, type_obj
    .const 'Sub' $P2391 = "253_1303739803.72" 
    $P2390."add_method"(type_obj, "quote_escape:sym<$>", $P2391)
    get_how $P2392, type_obj
    get_global $P2393, "!PREFIX__quote_escape:sym<$>"
    $P2392."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2393)
    get_how $P2394, type_obj
    .const 'Sub' $P2395 = "255_1303739803.72" 
    $P2394."add_method"(type_obj, "quote_escape:sym<{ }>", $P2395)
    get_how $P2396, type_obj
    get_global $P2397, "!PREFIX__quote_escape:sym<{ }>"
    $P2396."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2397)
    get_how $P2398, type_obj
    .const 'Sub' $P2399 = "257_1303739803.72" 
    $P2398."add_method"(type_obj, "quote_escape:sym<esc>", $P2399)
    get_how $P2400, type_obj
    get_global $P2401, "!PREFIX__quote_escape:sym<esc>"
    $P2400."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2401)
    get_how $P2402, type_obj
    .const 'Sub' $P2403 = "259_1303739803.72" 
    $P2402."add_method"(type_obj, "circumfix:sym<( )>", $P2403)
    get_how $P2404, type_obj
    get_global $P2405, "!PREFIX__circumfix:sym<( )>"
    $P2404."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2405)
    get_how $P2406, type_obj
    .const 'Sub' $P2407 = "261_1303739803.72" 
    $P2406."add_method"(type_obj, "circumfix:sym<[ ]>", $P2407)
    get_how $P2408, type_obj
    get_global $P2409, "!PREFIX__circumfix:sym<[ ]>"
    $P2408."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2409)
    get_how $P2410, type_obj
    .const 'Sub' $P2411 = "263_1303739803.72" 
    $P2410."add_method"(type_obj, "circumfix:sym<ang>", $P2411)
    get_how $P2412, type_obj
    get_global $P2413, "!PREFIX__circumfix:sym<ang>"
    $P2412."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2413)
    get_how $P2414, type_obj
    .const 'Sub' $P2415 = "265_1303739803.72" 
    $P2414."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2415)
    get_how $P2416, type_obj
    get_global $P2417, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2416."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2417)
    get_how $P2418, type_obj
    .const 'Sub' $P2419 = "267_1303739803.72" 
    $P2418."add_method"(type_obj, "circumfix:sym<{ }>", $P2419)
    get_how $P2420, type_obj
    get_global $P2421, "!PREFIX__circumfix:sym<{ }>"
    $P2420."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2421)
    get_how $P2422, type_obj
    .const 'Sub' $P2423 = "269_1303739803.72" 
    $P2422."add_method"(type_obj, "circumfix:sym<sigil>", $P2423)
    get_how $P2424, type_obj
    get_global $P2425, "!PREFIX__circumfix:sym<sigil>"
    $P2424."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2425)
    get_how $P2426, type_obj
    .const 'Sub' $P2427 = "271_1303739803.72" 
    $P2426."add_method"(type_obj, "semilist", $P2427)
    get_how $P2428, type_obj
    get_global $P2429, "!PREFIX__semilist"
    $P2428."add_method"(type_obj, "!PREFIX__semilist", $P2429)
    get_how $P2430, type_obj
    .const 'Sub' $P2431 = "273_1303739803.72" 
    $P2430."add_method"(type_obj, "infixish", $P2431)
    get_how $P2432, type_obj
    get_global $P2433, "!PREFIX__infixish"
    $P2432."add_method"(type_obj, "!PREFIX__infixish", $P2433)
    get_how $P2434, type_obj
    .const 'Sub' $P2435 = "275_1303739803.72" 
    $P2434."add_method"(type_obj, "infixstopper", $P2435)
    get_how $P2436, type_obj
    get_global $P2437, "!PREFIX__infixstopper"
    $P2436."add_method"(type_obj, "!PREFIX__infixstopper", $P2437)
    get_how $P2438, type_obj
    .const 'Sub' $P2439 = "277_1303739803.72" 
    $P2438."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2439)
    get_how $P2440, type_obj
    get_global $P2441, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2440."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2441)
    get_how $P2442, type_obj
    .const 'Sub' $P2443 = "279_1303739803.72" 
    $P2442."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2443)
    get_how $P2444, type_obj
    get_global $P2445, "!PREFIX__postcircumfix:sym<{ }>"
    $P2444."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2445)
    get_how $P2446, type_obj
    .const 'Sub' $P2447 = "281_1303739803.72" 
    $P2446."add_method"(type_obj, "postcircumfix:sym<ang>", $P2447)
    get_how $P2448, type_obj
    get_global $P2449, "!PREFIX__postcircumfix:sym<ang>"
    $P2448."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2449)
    get_how $P2450, type_obj
    .const 'Sub' $P2451 = "283_1303739803.72" 
    $P2450."add_method"(type_obj, "postcircumfix:sym<( )>", $P2451)
    get_how $P2452, type_obj
    get_global $P2453, "!PREFIX__postcircumfix:sym<( )>"
    $P2452."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2453)
    get_how $P2454, type_obj
    .const 'Sub' $P2455 = "285_1303739803.72" 
    $P2454."add_method"(type_obj, "postfix:sym<.>", $P2455)
    get_how $P2456, type_obj
    get_global $P2457, "!PREFIX__postfix:sym<.>"
    $P2456."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2457)
    get_how $P2458, type_obj
    .const 'Sub' $P2459 = "287_1303739803.72" 
    $P2458."add_method"(type_obj, "prefix:sym<++>", $P2459)
    get_how $P2460, type_obj
    get_global $P2461, "!PREFIX__prefix:sym<++>"
    $P2460."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2461)
    get_how $P2462, type_obj
    .const 'Sub' $P2463 = "289_1303739803.72" 
    $P2462."add_method"(type_obj, "prefix:sym<-->", $P2463)
    get_how $P2464, type_obj
    get_global $P2465, "!PREFIX__prefix:sym<-->"
    $P2464."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2465)
    get_how $P2466, type_obj
    .const 'Sub' $P2467 = "291_1303739803.72" 
    $P2466."add_method"(type_obj, "postfix:sym<++>", $P2467)
    get_how $P2468, type_obj
    get_global $P2469, "!PREFIX__postfix:sym<++>"
    $P2468."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2469)
    get_how $P2470, type_obj
    .const 'Sub' $P2471 = "293_1303739803.72" 
    $P2470."add_method"(type_obj, "postfix:sym<-->", $P2471)
    get_how $P2472, type_obj
    get_global $P2473, "!PREFIX__postfix:sym<-->"
    $P2472."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2473)
    get_how $P2474, type_obj
    .const 'Sub' $P2475 = "295_1303739803.72" 
    $P2474."add_method"(type_obj, "infix:sym<**>", $P2475)
    get_how $P2476, type_obj
    get_global $P2477, "!PREFIX__infix:sym<**>"
    $P2476."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2477)
    get_how $P2478, type_obj
    .const 'Sub' $P2479 = "297_1303739803.72" 
    $P2478."add_method"(type_obj, "prefix:sym<+>", $P2479)
    get_how $P2480, type_obj
    get_global $P2481, "!PREFIX__prefix:sym<+>"
    $P2480."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2481)
    get_how $P2482, type_obj
    .const 'Sub' $P2483 = "299_1303739803.72" 
    $P2482."add_method"(type_obj, "prefix:sym<~>", $P2483)
    get_how $P2484, type_obj
    get_global $P2485, "!PREFIX__prefix:sym<~>"
    $P2484."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2485)
    get_how $P2486, type_obj
    .const 'Sub' $P2487 = "301_1303739803.72" 
    $P2486."add_method"(type_obj, "prefix:sym<->", $P2487)
    get_how $P2488, type_obj
    get_global $P2489, "!PREFIX__prefix:sym<->"
    $P2488."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2489)
    get_how $P2490, type_obj
    .const 'Sub' $P2491 = "303_1303739803.72" 
    $P2490."add_method"(type_obj, "prefix:sym<?>", $P2491)
    get_how $P2492, type_obj
    get_global $P2493, "!PREFIX__prefix:sym<?>"
    $P2492."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2493)
    get_how $P2494, type_obj
    .const 'Sub' $P2495 = "305_1303739803.72" 
    $P2494."add_method"(type_obj, "prefix:sym<!>", $P2495)
    get_how $P2496, type_obj
    get_global $P2497, "!PREFIX__prefix:sym<!>"
    $P2496."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2497)
    get_how $P2498, type_obj
    .const 'Sub' $P2499 = "307_1303739803.72" 
    $P2498."add_method"(type_obj, "prefix:sym<|>", $P2499)
    get_how $P2500, type_obj
    get_global $P2501, "!PREFIX__prefix:sym<|>"
    $P2500."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2501)
    get_how $P2502, type_obj
    .const 'Sub' $P2503 = "309_1303739803.72" 
    $P2502."add_method"(type_obj, "infix:sym<*>", $P2503)
    get_how $P2504, type_obj
    get_global $P2505, "!PREFIX__infix:sym<*>"
    $P2504."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2505)
    get_how $P2506, type_obj
    .const 'Sub' $P2507 = "311_1303739803.72" 
    $P2506."add_method"(type_obj, "infix:sym</>", $P2507)
    get_how $P2508, type_obj
    get_global $P2509, "!PREFIX__infix:sym</>"
    $P2508."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2509)
    get_how $P2510, type_obj
    .const 'Sub' $P2511 = "313_1303739803.72" 
    $P2510."add_method"(type_obj, "infix:sym<%>", $P2511)
    get_how $P2512, type_obj
    get_global $P2513, "!PREFIX__infix:sym<%>"
    $P2512."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2513)
    get_how $P2514, type_obj
    .const 'Sub' $P2515 = "315_1303739803.72" 
    $P2514."add_method"(type_obj, "infix:sym<+&>", $P2515)
    get_how $P2516, type_obj
    get_global $P2517, "!PREFIX__infix:sym<+&>"
    $P2516."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2517)
    get_how $P2518, type_obj
    .const 'Sub' $P2519 = "317_1303739803.72" 
    $P2518."add_method"(type_obj, "infix:sym<+>", $P2519)
    get_how $P2520, type_obj
    get_global $P2521, "!PREFIX__infix:sym<+>"
    $P2520."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2521)
    get_how $P2522, type_obj
    .const 'Sub' $P2523 = "319_1303739803.72" 
    $P2522."add_method"(type_obj, "infix:sym<->", $P2523)
    get_how $P2524, type_obj
    get_global $P2525, "!PREFIX__infix:sym<->"
    $P2524."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2525)
    get_how $P2526, type_obj
    .const 'Sub' $P2527 = "321_1303739803.72" 
    $P2526."add_method"(type_obj, "infix:sym<+|>", $P2527)
    get_how $P2528, type_obj
    get_global $P2529, "!PREFIX__infix:sym<+|>"
    $P2528."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2529)
    get_how $P2530, type_obj
    .const 'Sub' $P2531 = "323_1303739803.72" 
    $P2530."add_method"(type_obj, "infix:sym<+^>", $P2531)
    get_how $P2532, type_obj
    get_global $P2533, "!PREFIX__infix:sym<+^>"
    $P2532."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2533)
    get_how $P2534, type_obj
    .const 'Sub' $P2535 = "325_1303739803.72" 
    $P2534."add_method"(type_obj, "infix:sym<~>", $P2535)
    get_how $P2536, type_obj
    get_global $P2537, "!PREFIX__infix:sym<~>"
    $P2536."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2537)
    get_how $P2538, type_obj
    .const 'Sub' $P2539 = "327_1303739803.72" 
    $P2538."add_method"(type_obj, "infix:sym<==>", $P2539)
    get_how $P2540, type_obj
    get_global $P2541, "!PREFIX__infix:sym<==>"
    $P2540."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2541)
    get_how $P2542, type_obj
    .const 'Sub' $P2543 = "329_1303739803.72" 
    $P2542."add_method"(type_obj, "infix:sym<!=>", $P2543)
    get_how $P2544, type_obj
    get_global $P2545, "!PREFIX__infix:sym<!=>"
    $P2544."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2545)
    get_how $P2546, type_obj
    .const 'Sub' $P2547 = "331_1303739803.72" 
    $P2546."add_method"(type_obj, "infix:sym<<=>", $P2547)
    get_how $P2548, type_obj
    get_global $P2549, "!PREFIX__infix:sym<<=>"
    $P2548."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2549)
    get_how $P2550, type_obj
    .const 'Sub' $P2551 = "333_1303739803.72" 
    $P2550."add_method"(type_obj, "infix:sym<>=>", $P2551)
    get_how $P2552, type_obj
    get_global $P2553, "!PREFIX__infix:sym<>=>"
    $P2552."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2553)
    get_how $P2554, type_obj
    .const 'Sub' $P2555 = "335_1303739803.72" 
    $P2554."add_method"(type_obj, "infix:sym<<>", $P2555)
    get_how $P2556, type_obj
    get_global $P2557, "!PREFIX__infix:sym<<>"
    $P2556."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2557)
    get_how $P2558, type_obj
    .const 'Sub' $P2559 = "337_1303739803.72" 
    $P2558."add_method"(type_obj, "infix:sym<>>", $P2559)
    get_how $P2560, type_obj
    get_global $P2561, "!PREFIX__infix:sym<>>"
    $P2560."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2561)
    get_how $P2562, type_obj
    .const 'Sub' $P2563 = "339_1303739803.72" 
    $P2562."add_method"(type_obj, "infix:sym<eq>", $P2563)
    get_how $P2564, type_obj
    get_global $P2565, "!PREFIX__infix:sym<eq>"
    $P2564."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2565)
    get_how $P2566, type_obj
    .const 'Sub' $P2567 = "341_1303739803.72" 
    $P2566."add_method"(type_obj, "infix:sym<ne>", $P2567)
    get_how $P2568, type_obj
    get_global $P2569, "!PREFIX__infix:sym<ne>"
    $P2568."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2569)
    get_how $P2570, type_obj
    .const 'Sub' $P2571 = "343_1303739803.72" 
    $P2570."add_method"(type_obj, "infix:sym<le>", $P2571)
    get_how $P2572, type_obj
    get_global $P2573, "!PREFIX__infix:sym<le>"
    $P2572."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2573)
    get_how $P2574, type_obj
    .const 'Sub' $P2575 = "345_1303739803.72" 
    $P2574."add_method"(type_obj, "infix:sym<ge>", $P2575)
    get_how $P2576, type_obj
    get_global $P2577, "!PREFIX__infix:sym<ge>"
    $P2576."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2577)
    get_how $P2578, type_obj
    .const 'Sub' $P2579 = "347_1303739803.72" 
    $P2578."add_method"(type_obj, "infix:sym<lt>", $P2579)
    get_how $P2580, type_obj
    get_global $P2581, "!PREFIX__infix:sym<lt>"
    $P2580."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2581)
    get_how $P2582, type_obj
    .const 'Sub' $P2583 = "349_1303739803.72" 
    $P2582."add_method"(type_obj, "infix:sym<gt>", $P2583)
    get_how $P2584, type_obj
    get_global $P2585, "!PREFIX__infix:sym<gt>"
    $P2584."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2585)
    get_how $P2586, type_obj
    .const 'Sub' $P2587 = "351_1303739803.72" 
    $P2586."add_method"(type_obj, "infix:sym<=:=>", $P2587)
    get_how $P2588, type_obj
    get_global $P2589, "!PREFIX__infix:sym<=:=>"
    $P2588."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2589)
    get_how $P2590, type_obj
    .const 'Sub' $P2591 = "353_1303739803.72" 
    $P2590."add_method"(type_obj, "infix:sym<~~>", $P2591)
    get_how $P2592, type_obj
    get_global $P2593, "!PREFIX__infix:sym<~~>"
    $P2592."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2593)
    get_how $P2594, type_obj
    .const 'Sub' $P2595 = "355_1303739803.72" 
    $P2594."add_method"(type_obj, "infix:sym<&&>", $P2595)
    get_how $P2596, type_obj
    get_global $P2597, "!PREFIX__infix:sym<&&>"
    $P2596."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2597)
    get_how $P2598, type_obj
    .const 'Sub' $P2599 = "357_1303739803.72" 
    $P2598."add_method"(type_obj, "infix:sym<||>", $P2599)
    get_how $P2600, type_obj
    get_global $P2601, "!PREFIX__infix:sym<||>"
    $P2600."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2601)
    get_how $P2602, type_obj
    .const 'Sub' $P2603 = "359_1303739803.72" 
    $P2602."add_method"(type_obj, "infix:sym<//>", $P2603)
    get_how $P2604, type_obj
    get_global $P2605, "!PREFIX__infix:sym<//>"
    $P2604."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2605)
    get_how $P2606, type_obj
    .const 'Sub' $P2607 = "361_1303739803.72" 
    $P2606."add_method"(type_obj, "infix:sym<?? !!>", $P2607)
    get_how $P2608, type_obj
    get_global $P2609, "!PREFIX__infix:sym<?? !!>"
    $P2608."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2609)
    get_how $P2610, type_obj
    .const 'Sub' $P2611 = "363_1303739803.72" 
    $P2610."add_method"(type_obj, "infix:sym<=>", $P2611)
    get_how $P2612, type_obj
    get_global $P2613, "!PREFIX__infix:sym<=>"
    $P2612."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2613)
    get_how $P2614, type_obj
    .const 'Sub' $P2615 = "365_1303739803.72" 
    $P2614."add_method"(type_obj, "infix:sym<:=>", $P2615)
    get_how $P2616, type_obj
    get_global $P2617, "!PREFIX__infix:sym<:=>"
    $P2616."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2617)
    get_how $P2618, type_obj
    .const 'Sub' $P2619 = "367_1303739803.72" 
    $P2618."add_method"(type_obj, "infix:sym<::=>", $P2619)
    get_how $P2620, type_obj
    get_global $P2621, "!PREFIX__infix:sym<::=>"
    $P2620."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2621)
    get_how $P2622, type_obj
    .const 'Sub' $P2623 = "369_1303739803.72" 
    $P2622."add_method"(type_obj, "infix:sym<,>", $P2623)
    get_how $P2624, type_obj
    get_global $P2625, "!PREFIX__infix:sym<,>"
    $P2624."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2625)
    get_how $P2626, type_obj
    .const 'Sub' $P2627 = "371_1303739803.72" 
    $P2626."add_method"(type_obj, "prefix:sym<return>", $P2627)
    get_how $P2628, type_obj
    get_global $P2629, "!PREFIX__prefix:sym<return>"
    $P2628."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2629)
    get_how $P2630, type_obj
    .const 'Sub' $P2631 = "374_1303739803.72" 
    $P2630."add_method"(type_obj, "prefix:sym<make>", $P2631)
    get_how $P2632, type_obj
    get_global $P2633, "!PREFIX__prefix:sym<make>"
    $P2632."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2633)
    get_how $P2634, type_obj
    .const 'Sub' $P2635 = "376_1303739803.72" 
    $P2634."add_method"(type_obj, "term:sym<last>", $P2635)
    get_how $P2636, type_obj
    get_global $P2637, "!PREFIX__term:sym<last>"
    $P2636."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2637)
    get_how $P2638, type_obj
    .const 'Sub' $P2639 = "378_1303739803.72" 
    $P2638."add_method"(type_obj, "term:sym<next>", $P2639)
    get_how $P2640, type_obj
    get_global $P2641, "!PREFIX__term:sym<next>"
    $P2640."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2641)
    get_how $P2642, type_obj
    .const 'Sub' $P2643 = "380_1303739803.72" 
    $P2642."add_method"(type_obj, "term:sym<redo>", $P2643)
    get_how $P2644, type_obj
    get_global $P2645, "!PREFIX__term:sym<redo>"
    $P2644."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2645)
    get_how $P2646, type_obj
    .const 'Sub' $P2647 = "382_1303739803.72" 
    $P2646."add_method"(type_obj, "smartmatch", $P2647)
    get_how $P2648, type_obj
    get_hll_global $P2649, ["HLL"], "Grammar"
    $P2648."add_parent"(type_obj, $P2649)
    get_how $P2650, type_obj
    $P2651 = $P2650."compose"(type_obj)
    .return ($P2651)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1303739803.72") :outer("12_1303739803.72")
    .param pmc param_111
.annotate 'line', 10
    .lex "self", param_111
.annotate 'line', 12
    $P112 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P112
.annotate 'line', 20
    $P113 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P113
.annotate 'line', 24
    new $P114, "Undef"
    .lex "$*DEFAULT-METAATTR", $P114
.annotate 'line', 25
    $P115 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P115
.annotate 'line', 31
    new $P116, "Undef"
    .lex "$*SC", $P116
.annotate 'line', 35
    new $P117, "Undef"
    .lex "$*SCOPE", $P117
.annotate 'line', 36
    new $P118, "Undef"
    .lex "$*MULTINESS", $P118
.annotate 'line', 37
    new $P119, "Undef"
    .lex "$*INVOCANT_OK", $P119
.annotate 'line', 38
    new $P120, "Undef"
    .lex "$*RETURN_USED", $P120
.annotate 'line', 39
    new $P121, "Undef"
    .lex "$*PACKAGE-SETUP", $P121
.annotate 'line', 10
    find_lex $P124, "%*LANG"
    unless_null $P124, vivify_596
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["%LANG"]
    unless_null $P124, vivify_597
    die "Contextual %*LANG not found"
  vivify_597:
  vivify_596:
.annotate 'line', 13
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P126, $P125, "NQP"
    get_who $P127, $P126
    set $P128, $P127["Regex"]
    find_lex $P131, "%*LANG"
    unless_null $P131, vivify_598
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%LANG"]
    unless_null $P131, vivify_599
    die "Contextual %*LANG not found"
  vivify_599:
    store_lex "%*LANG", $P131
  vivify_598:
    set $P131["Regex"], $P128
.annotate 'line', 14
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "NQP"
    get_who $P134, $P133
    set $P135, $P134["RegexActions"]
    find_lex $P138, "%*LANG"
    unless_null $P138, vivify_600
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["%LANG"]
    unless_null $P138, vivify_601
    die "Contextual %*LANG not found"
  vivify_601:
    store_lex "%*LANG", $P138
  vivify_600:
    set $P138["Regex-actions"], $P135
.annotate 'line', 15
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "NQP"
    get_who $P141, $P140
    set $P142, $P141["Grammar"]
    find_lex $P145, "%*LANG"
    unless_null $P145, vivify_602
    get_hll_global $P143, "GLOBAL"
    get_who $P144, $P143
    set $P145, $P144["%LANG"]
    unless_null $P145, vivify_603
    die "Contextual %*LANG not found"
  vivify_603:
    store_lex "%*LANG", $P145
  vivify_602:
    set $P145["MAIN"], $P142
.annotate 'line', 16
    get_hll_global $P146, "GLOBAL"
    nqp_get_package_through_who $P147, $P146, "NQP"
    get_who $P148, $P147
    set $P149, $P148["Actions"]
    find_lex $P152, "%*LANG"
    unless_null $P152, vivify_604
    get_hll_global $P150, "GLOBAL"
    get_who $P151, $P150
    set $P152, $P151["%LANG"]
    unless_null $P152, vivify_605
    die "Contextual %*LANG not found"
  vivify_605:
    store_lex "%*LANG", $P152
  vivify_604:
    set $P152["MAIN-actions"], $P149
    find_lex $P155, "%*HOW"
    unless_null $P155, vivify_606
    get_hll_global $P153, "GLOBAL"
    get_who $P154, $P153
    set $P155, $P154["%HOW"]
    unless_null $P155, vivify_607
    die "Contextual %*HOW not found"
  vivify_607:
  vivify_606:
.annotate 'line', 21
    get_knowhow $P156
    find_lex $P159, "%*HOW"
    unless_null $P159, vivify_608
    get_hll_global $P157, "GLOBAL"
    get_who $P158, $P157
    set $P159, $P158["%HOW"]
    unless_null $P159, vivify_609
    die "Contextual %*HOW not found"
  vivify_609:
    store_lex "%*HOW", $P159
  vivify_608:
    set $P159["knowhow"], $P156
.annotate 'line', 24
    new $P160, "String"
    assign $P160, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P160
    find_lex $P163, "%*HOW-METAATTR"
    unless_null $P163, vivify_610
    get_hll_global $P161, "GLOBAL"
    get_who $P162, $P161
    set $P163, $P162["%HOW-METAATTR"]
    unless_null $P163, vivify_611
    die "Contextual %*HOW-METAATTR not found"
  vivify_611:
  vivify_610:
.annotate 'line', 26
    new $P164, "String"
    assign $P164, "KnowHOWAttribute"
    find_lex $P167, "%*HOW-METAATTR"
    unless_null $P167, vivify_612
    get_hll_global $P165, "GLOBAL"
    get_who $P166, $P165
    set $P167, $P166["%HOW-METAATTR"]
    unless_null $P167, vivify_613
    die "Contextual %*HOW-METAATTR not found"
  vivify_613:
    store_lex "%*HOW-METAATTR", $P167
  vivify_612:
    set $P167["knowhow"], $P164
.annotate 'line', 31
    get_hll_global $P168, "GLOBAL"
    nqp_get_package_through_who $P169, $P168, "HLL"
    nqp_get_package_through_who $P170, $P169, "Compiler"
    get_who $P171, $P170
    set $P172, $P171["SerializationContextBuilder"]
.annotate 'line', 33
    time $N173
    set $S174, $N173
    $P175 = $P172."new"($S174 :named("handle"))
.annotate 'line', 31
    store_lex "$*SC", $P175
.annotate 'line', 35
    new $P176, "String"
    assign $P176, ""
    store_lex "$*SCOPE", $P176
.annotate 'line', 36
    new $P177, "String"
    assign $P177, ""
    store_lex "$*MULTINESS", $P177
.annotate 'line', 37
    new $P178, "Integer"
    assign $P178, 0
    store_lex "$*INVOCANT_OK", $P178
.annotate 'line', 38
    new $P179, "Integer"
    assign $P179, 0
    store_lex "$*RETURN_USED", $P179
    find_lex $P182, "$*PACKAGE-SETUP"
    unless_null $P182, vivify_614
    get_hll_global $P180, "GLOBAL"
    get_who $P181, $P180
    set $P182, $P181["$PACKAGE-SETUP"]
    unless_null $P182, vivify_615
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_615:
  vivify_614:
.annotate 'line', 40
    find_lex $P183, "self"
    $P184 = $P183."comp_unit"()
.annotate 'line', 10
    .return ($P184)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx186_tgt
    .local int rx186_pos
    .local int rx186_off
    .local int rx186_eos
    .local int rx186_rep
    .local pmc rx186_cur
    .local pmc rx186_debug
    (rx186_cur, rx186_pos, rx186_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx186_cur
    .local pmc match
    .lex "$/", match
    length rx186_eos, rx186_tgt
    gt rx186_pos, rx186_eos, rx186_done
    set rx186_off, 0
    lt rx186_pos, 2, rx186_start
    sub rx186_off, rx186_pos, 1
    substr rx186_tgt, rx186_tgt, rx186_off
  rx186_start:
    eq $I10, 1, rx186_restart
    if_null rx186_debug, debug_616
    rx186_cur."!cursor_debug"("START", "identifier")
  debug_616:
    $I10 = self.'from'()
    ne $I10, -1, rxscan190_done
    goto rxscan190_scan
  rxscan190_loop:
    (rx186_pos) = rx186_cur."from"()
    inc rx186_pos
    rx186_cur."!cursor_from"(rx186_pos)
    ge rx186_pos, rx186_eos, rxscan190_done
  rxscan190_scan:
    set_addr $I10, rxscan190_loop
    rx186_cur."!mark_push"(0, rx186_pos, $I10)
  rxscan190_done:
.annotate 'line', 45
  # rx subrule "ident" subtype=method negate=
    rx186_cur."!cursor_pos"(rx186_pos)
    $P10 = rx186_cur."ident"()
    unless $P10, rx186_fail
    rx186_pos = $P10."pos"()
  # rx rxquantr191 ** 0..*
    set_addr $I10, rxquantr191_done
    rx186_cur."!mark_push"(0, rx186_pos, $I10)
  rxquantr191_loop:
  # rx enumcharlist negate=0 
    ge rx186_pos, rx186_eos, rx186_fail
    sub $I10, rx186_pos, rx186_off
    substr $S10, rx186_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx186_fail
    inc rx186_pos
  # rx subrule "ident" subtype=method negate=
    rx186_cur."!cursor_pos"(rx186_pos)
    $P10 = rx186_cur."ident"()
    unless $P10, rx186_fail
    rx186_pos = $P10."pos"()
    set_addr $I10, rxquantr191_done
    (rx186_rep) = rx186_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr191_done
    rx186_cur."!mark_push"(rx186_rep, rx186_pos, $I10)
    goto rxquantr191_loop
  rxquantr191_done:
  # rx pass
    rx186_cur."!cursor_pass"(rx186_pos, "identifier")
    if_null rx186_debug, debug_617
    rx186_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx186_pos)
  debug_617:
    .return (rx186_cur)
  rx186_restart:
.annotate 'line', 10
    if_null rx186_debug, debug_618
    rx186_cur."!cursor_debug"("NEXT", "identifier")
  debug_618:
  rx186_fail:
    (rx186_rep, rx186_pos, $I10, $P10) = rx186_cur."!mark_fail"(0)
    lt rx186_pos, -1, rx186_done
    eq rx186_pos, -1, rx186_fail
    jump $I10
  rx186_done:
    rx186_cur."!cursor_fail"()
    if_null rx186_debug, debug_619
    rx186_cur."!cursor_debug"("FAIL", "identifier")
  debug_619:
    .return (rx186_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1303739803.72") :method
.annotate 'line', 10
    $P188 = self."!PREFIX__!subrule"("ident", "")
    new $P189, "ResizablePMCArray"
    push $P189, $P188
    .return ($P189)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx193_tgt
    .local int rx193_pos
    .local int rx193_off
    .local int rx193_eos
    .local int rx193_rep
    .local pmc rx193_cur
    .local pmc rx193_debug
    (rx193_cur, rx193_pos, rx193_tgt, $I10) = self."!cursor_start"()
    rx193_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx193_cur
    .local pmc match
    .lex "$/", match
    length rx193_eos, rx193_tgt
    gt rx193_pos, rx193_eos, rx193_done
    set rx193_off, 0
    lt rx193_pos, 2, rx193_start
    sub rx193_off, rx193_pos, 1
    substr rx193_tgt, rx193_tgt, rx193_off
  rx193_start:
    eq $I10, 1, rx193_restart
    if_null rx193_debug, debug_620
    rx193_cur."!cursor_debug"("START", "name")
  debug_620:
    $I10 = self.'from'()
    ne $I10, -1, rxscan196_done
    goto rxscan196_scan
  rxscan196_loop:
    (rx193_pos) = rx193_cur."from"()
    inc rx193_pos
    rx193_cur."!cursor_from"(rx193_pos)
    ge rx193_pos, rx193_eos, rxscan196_done
  rxscan196_scan:
    set_addr $I10, rxscan196_loop
    rx193_cur."!mark_push"(0, rx193_pos, $I10)
  rxscan196_done:
.annotate 'line', 47
  # rx rxquantr197 ** 1..*
    set_addr $I10, rxquantr197_done
    rx193_cur."!mark_push"(0, -1, $I10)
  rxquantr197_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx193_cur."!cursor_pos"(rx193_pos)
    $P10 = rx193_cur."identifier"()
    unless $P10, rx193_fail
    goto rxsubrule198_pass
  rxsubrule198_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx193_fail
  rxsubrule198_pass:
    set_addr $I10, rxsubrule198_back
    rx193_cur."!mark_push"(0, rx193_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx193_pos = $P10."pos"()
    set_addr $I10, rxquantr197_done
    (rx193_rep) = rx193_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr197_done
    rx193_cur."!mark_push"(rx193_rep, rx193_pos, $I10)
  # rx literal  "::"
    add $I11, rx193_pos, 2
    gt $I11, rx193_eos, rx193_fail
    sub $I11, rx193_pos, rx193_off
    substr $S10, rx193_tgt, $I11, 2
    ne $S10, "::", rx193_fail
    add rx193_pos, 2
    goto rxquantr197_loop
  rxquantr197_done:
  # rx pass
    rx193_cur."!cursor_pass"(rx193_pos, "name")
    if_null rx193_debug, debug_621
    rx193_cur."!cursor_debug"("PASS", "name", " at pos=", rx193_pos)
  debug_621:
    .return (rx193_cur)
  rx193_restart:
.annotate 'line', 10
    if_null rx193_debug, debug_622
    rx193_cur."!cursor_debug"("NEXT", "name")
  debug_622:
  rx193_fail:
    (rx193_rep, rx193_pos, $I10, $P10) = rx193_cur."!mark_fail"(0)
    lt rx193_pos, -1, rx193_done
    eq rx193_pos, -1, rx193_fail
    jump $I10
  rx193_done:
    rx193_cur."!cursor_fail"()
    if_null rx193_debug, debug_623
    rx193_cur."!cursor_debug"("FAIL", "name")
  debug_623:
    .return (rx193_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1303739803.72") :method
.annotate 'line', 10
    new $P195, "ResizablePMCArray"
    push $P195, ""
    .return ($P195)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx200_tgt
    .local int rx200_pos
    .local int rx200_off
    .local int rx200_eos
    .local int rx200_rep
    .local pmc rx200_cur
    .local pmc rx200_debug
    (rx200_cur, rx200_pos, rx200_tgt, $I10) = self."!cursor_start"()
    rx200_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx200_cur
    .local pmc match
    .lex "$/", match
    length rx200_eos, rx200_tgt
    gt rx200_pos, rx200_eos, rx200_done
    set rx200_off, 0
    lt rx200_pos, 2, rx200_start
    sub rx200_off, rx200_pos, 1
    substr rx200_tgt, rx200_tgt, rx200_off
  rx200_start:
    eq $I10, 1, rx200_restart
    if_null rx200_debug, debug_624
    rx200_cur."!cursor_debug"("START", "deflongname")
  debug_624:
    $I10 = self.'from'()
    ne $I10, -1, rxscan204_done
    goto rxscan204_scan
  rxscan204_loop:
    (rx200_pos) = rx200_cur."from"()
    inc rx200_pos
    rx200_cur."!cursor_from"(rx200_pos)
    ge rx200_pos, rx200_eos, rxscan204_done
  rxscan204_scan:
    set_addr $I10, rxscan204_loop
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxscan204_done:
.annotate 'line', 50
  # rx subrule "identifier" subtype=capture negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."identifier"()
    unless $P10, rx200_fail
    rx200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx200_pos = $P10."pos"()
  # rx rxquantr205 ** 0..1
    set_addr $I10, rxquantr205_done
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxquantr205_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."colonpair"()
    unless $P10, rx200_fail
    goto rxsubrule206_pass
  rxsubrule206_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx200_fail
  rxsubrule206_pass:
    set_addr $I10, rxsubrule206_back
    rx200_cur."!mark_push"(0, rx200_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx200_pos = $P10."pos"()
    set_addr $I10, rxquantr205_done
    (rx200_rep) = rx200_cur."!mark_commit"($I10)
  rxquantr205_done:
.annotate 'line', 49
  # rx pass
    rx200_cur."!cursor_pass"(rx200_pos, "deflongname")
    if_null rx200_debug, debug_625
    rx200_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx200_pos)
  debug_625:
    .return (rx200_cur)
  rx200_restart:
.annotate 'line', 10
    if_null rx200_debug, debug_626
    rx200_cur."!cursor_debug"("NEXT", "deflongname")
  debug_626:
  rx200_fail:
    (rx200_rep, rx200_pos, $I10, $P10) = rx200_cur."!mark_fail"(0)
    lt rx200_pos, -1, rx200_done
    eq rx200_pos, -1, rx200_fail
    jump $I10
  rx200_done:
    rx200_cur."!cursor_fail"()
    if_null rx200_debug, debug_627
    rx200_cur."!cursor_debug"("FAIL", "deflongname")
  debug_627:
    .return (rx200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1303739803.72") :method
.annotate 'line', 10
    $P202 = self."!PREFIX__!subrule"("identifier", "")
    new $P203, "ResizablePMCArray"
    push $P203, $P202
    .return ($P203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx208_tgt
    .local int rx208_pos
    .local int rx208_off
    .local int rx208_eos
    .local int rx208_rep
    .local pmc rx208_cur
    .local pmc rx208_debug
    (rx208_cur, rx208_pos, rx208_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx208_cur
    .local pmc match
    .lex "$/", match
    length rx208_eos, rx208_tgt
    gt rx208_pos, rx208_eos, rx208_done
    set rx208_off, 0
    lt rx208_pos, 2, rx208_start
    sub rx208_off, rx208_pos, 1
    substr rx208_tgt, rx208_tgt, rx208_off
  rx208_start:
    eq $I10, 1, rx208_restart
    if_null rx208_debug, debug_628
    rx208_cur."!cursor_debug"("START", "ENDSTMT")
  debug_628:
    $I10 = self.'from'()
    ne $I10, -1, rxscan211_done
    goto rxscan211_scan
  rxscan211_loop:
    (rx208_pos) = rx208_cur."from"()
    inc rx208_pos
    rx208_cur."!cursor_from"(rx208_pos)
    ge rx208_pos, rx208_eos, rxscan211_done
  rxscan211_scan:
    set_addr $I10, rxscan211_loop
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxscan211_done:
.annotate 'line', 57
  # rx rxquantr212 ** 0..1
    set_addr $I10, rxquantr212_done
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxquantr212_loop:
  alt213_0:
.annotate 'line', 54
    set_addr $I10, alt213_1
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
.annotate 'line', 55
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx208_pos, rx208_off
    set rx208_rep, 0
    sub $I12, rx208_eos, rx208_pos
  rxenumcharlistq214_loop:
    le $I12, 0, rxenumcharlistq214_done
    substr $S10, rx208_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq214_done
    inc rx208_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq214_loop
  rxenumcharlistq214_done:
    add rx208_pos, rx208_pos, rx208_rep
  # rxanchor eol
    sub $I10, rx208_pos, rx208_off
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rxanchor215_done
    ne rx208_pos, rx208_eos, rx208_fail
    eq rx208_pos, 0, rxanchor215_done
    dec $I10
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rx208_fail
  rxanchor215_done:
  # rx subrule "ws" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."ws"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."MARKER"("endstmt")
    unless $P10, rx208_fail
    goto alt213_end
  alt213_1:
.annotate 'line', 56
  # rx rxquantr216 ** 0..1
    set_addr $I10, rxquantr216_done
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxquantr216_loop:
  # rx subrule "unv" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."unv"()
    unless $P10, rx208_fail
    goto rxsubrule217_pass
  rxsubrule217_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx208_fail
  rxsubrule217_pass:
    set_addr $I10, rxsubrule217_back
    rx208_cur."!mark_push"(0, rx208_pos, $I10, $P10)
    rx208_pos = $P10."pos"()
    set_addr $I10, rxquantr216_done
    (rx208_rep) = rx208_cur."!mark_commit"($I10)
  rxquantr216_done:
  # rxanchor eol
    sub $I10, rx208_pos, rx208_off
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rxanchor218_done
    ne rx208_pos, rx208_eos, rx208_fail
    eq rx208_pos, 0, rxanchor218_done
    dec $I10
    is_cclass $I11, 4096, rx208_tgt, $I10
    if $I11, rx208_fail
  rxanchor218_done:
  # rx subrule "ws" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."ws"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."MARKER"("endstmt")
    unless $P10, rx208_fail
  alt213_end:
.annotate 'line', 57
    set_addr $I10, rxquantr212_done
    (rx208_rep) = rx208_cur."!mark_commit"($I10)
  rxquantr212_done:
.annotate 'line', 53
  # rx pass
    rx208_cur."!cursor_pass"(rx208_pos, "ENDSTMT")
    if_null rx208_debug, debug_629
    rx208_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx208_pos)
  debug_629:
    .return (rx208_cur)
  rx208_restart:
.annotate 'line', 10
    if_null rx208_debug, debug_630
    rx208_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_630:
  rx208_fail:
    (rx208_rep, rx208_pos, $I10, $P10) = rx208_cur."!mark_fail"(0)
    lt rx208_pos, -1, rx208_done
    eq rx208_pos, -1, rx208_fail
    jump $I10
  rx208_done:
    rx208_cur."!cursor_fail"()
    if_null rx208_debug, debug_631
    rx208_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_631:
    .return (rx208_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1303739803.72") :method
.annotate 'line', 10
    new $P210, "ResizablePMCArray"
    push $P210, ""
    .return ($P210)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx220_tgt
    .local int rx220_pos
    .local int rx220_off
    .local int rx220_eos
    .local int rx220_rep
    .local pmc rx220_cur
    .local pmc rx220_debug
    (rx220_cur, rx220_pos, rx220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx220_cur
    .local pmc match
    .lex "$/", match
    length rx220_eos, rx220_tgt
    gt rx220_pos, rx220_eos, rx220_done
    set rx220_off, 0
    lt rx220_pos, 2, rx220_start
    sub rx220_off, rx220_pos, 1
    substr rx220_tgt, rx220_tgt, rx220_off
  rx220_start:
    eq $I10, 1, rx220_restart
    if_null rx220_debug, debug_632
    rx220_cur."!cursor_debug"("START", "ws")
  debug_632:
    $I10 = self.'from'()
    ne $I10, -1, rxscan223_done
    goto rxscan223_scan
  rxscan223_loop:
    (rx220_pos) = rx220_cur."from"()
    inc rx220_pos
    rx220_cur."!cursor_from"(rx220_pos)
    ge rx220_pos, rx220_eos, rxscan223_done
  rxscan223_scan:
    set_addr $I10, rxscan223_loop
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxscan223_done:
  alt224_0:
.annotate 'line', 60
    set_addr $I10, alt224_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
.annotate 'line', 61
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."MARKED"("ws")
    unless $P10, rx220_fail
    goto alt224_end
  alt224_1:
.annotate 'line', 62
  # rx subrule "ww" subtype=zerowidth negate=1
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."ww"()
    if $P10, rx220_fail
.annotate 'line', 67
  # rx rxquantr225 ** 0..*
    set_addr $I10, rxquantr225_done
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxquantr225_loop:
  alt226_0:
.annotate 'line', 63
    set_addr $I10, alt226_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx220_pos, rx220_off
    set rx220_rep, 0
    sub $I12, rx220_eos, rx220_pos
  rxenumcharlistq227_loop:
    le $I12, 0, rxenumcharlistq227_done
    substr $S10, rx220_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq227_done
    inc rx220_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq227_loop
  rxenumcharlistq227_done:
    lt rx220_rep, 1, rx220_fail
    add rx220_pos, rx220_pos, rx220_rep
    goto alt226_end
  alt226_1:
    set_addr $I10, alt226_2
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
.annotate 'line', 64
  # rx literal  "#"
    add $I11, rx220_pos, 1
    gt $I11, rx220_eos, rx220_fail
    sub $I11, rx220_pos, rx220_off
    ord $I11, rx220_tgt, $I11
    ne $I11, 35, rx220_fail
    add rx220_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx220_pos, rx220_off
    find_cclass $I11, 4096, rx220_tgt, $I10, rx220_eos
    add rx220_pos, rx220_off, $I11
    goto alt226_end
  alt226_2:
    set_addr $I10, alt226_3
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
.annotate 'line', 65
  # rxanchor bol
    eq rx220_pos, 0, rxanchor228_done
    ge rx220_pos, rx220_eos, rx220_fail
    sub $I10, rx220_pos, rx220_off
    dec $I10
    is_cclass $I11, 4096, rx220_tgt, $I10
    unless $I11, rx220_fail
  rxanchor228_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."pod_comment"()
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
    goto alt226_end
  alt226_3:
.annotate 'line', 66
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx220_pos, rx220_off
    set rx220_rep, 0
    sub $I12, rx220_eos, rx220_pos
  rxenumcharlistq229_loop:
    le $I12, 0, rxenumcharlistq229_done
    substr $S10, rx220_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq229_done
    inc rx220_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq229_loop
  rxenumcharlistq229_done:
    lt rx220_rep, 1, rx220_fail
    add rx220_pos, rx220_pos, rx220_rep
  alt226_end:
.annotate 'line', 67
    set_addr $I10, rxquantr225_done
    (rx220_rep) = rx220_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr225_done
    rx220_cur."!mark_push"(rx220_rep, rx220_pos, $I10)
    goto rxquantr225_loop
  rxquantr225_done:
.annotate 'line', 68
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."MARKER"("ws")
    unless $P10, rx220_fail
  alt224_end:
.annotate 'line', 60
  # rx pass
    rx220_cur."!cursor_pass"(rx220_pos, "ws")
    if_null rx220_debug, debug_633
    rx220_cur."!cursor_debug"("PASS", "ws", " at pos=", rx220_pos)
  debug_633:
    .return (rx220_cur)
  rx220_restart:
.annotate 'line', 10
    if_null rx220_debug, debug_634
    rx220_cur."!cursor_debug"("NEXT", "ws")
  debug_634:
  rx220_fail:
    (rx220_rep, rx220_pos, $I10, $P10) = rx220_cur."!mark_fail"(0)
    lt rx220_pos, -1, rx220_done
    eq rx220_pos, -1, rx220_fail
    jump $I10
  rx220_done:
    rx220_cur."!cursor_fail"()
    if_null rx220_debug, debug_635
    rx220_cur."!cursor_debug"("FAIL", "ws")
  debug_635:
    .return (rx220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1303739803.72") :method
.annotate 'line', 10
    new $P222, "ResizablePMCArray"
    push $P222, ""
    push $P222, ""
    .return ($P222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P238 = "26_1303739803.72" 
    capture_lex $P238
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_636
    rx231_cur."!cursor_debug"("START", "unv")
  debug_636:
    $I10 = self.'from'()
    ne $I10, -1, rxscan234_done
    goto rxscan234_scan
  rxscan234_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan234_done
  rxscan234_scan:
    set_addr $I10, rxscan234_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan234_done:
  alt235_0:
.annotate 'line', 73
    set_addr $I10, alt235_1
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
.annotate 'line', 74
  # rxanchor bol
    eq rx231_pos, 0, rxanchor236_done
    ge rx231_pos, rx231_eos, rx231_fail
    sub $I10, rx231_pos, rx231_off
    dec $I10
    is_cclass $I11, 4096, rx231_tgt, $I10
    unless $I11, rx231_fail
  rxanchor236_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    .const 'Sub' $P238 = "26_1303739803.72" 
    capture_lex $P238
    $P10 = rx231_cur."before"($P238)
    unless $P10, rx231_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."pod_comment"()
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
    goto alt235_end
  alt235_1:
    set_addr $I10, alt235_2
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
.annotate 'line', 75
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx231_pos, rx231_off
    set rx231_rep, 0
    sub $I12, rx231_eos, rx231_pos
  rxenumcharlistq243_loop:
    le $I12, 0, rxenumcharlistq243_done
    substr $S10, rx231_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq243_done
    inc rx231_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq243_loop
  rxenumcharlistq243_done:
    add rx231_pos, rx231_pos, rx231_rep
  # rx literal  "#"
    add $I11, rx231_pos, 1
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    ord $I11, rx231_tgt, $I11
    ne $I11, 35, rx231_fail
    add rx231_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx231_pos, rx231_off
    find_cclass $I11, 4096, rx231_tgt, $I10, rx231_eos
    add rx231_pos, rx231_off, $I11
    goto alt235_end
  alt235_2:
.annotate 'line', 76
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx231_pos, rx231_off
    set rx231_rep, 0
    sub $I12, rx231_eos, rx231_pos
  rxenumcharlistq244_loop:
    le $I12, 0, rxenumcharlistq244_done
    substr $S10, rx231_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq244_done
    inc rx231_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq244_loop
  rxenumcharlistq244_done:
    lt rx231_rep, 1, rx231_fail
    add rx231_pos, rx231_pos, rx231_rep
  alt235_end:
.annotate 'line', 71
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "unv")
    if_null rx231_debug, debug_641
    rx231_cur."!cursor_debug"("PASS", "unv", " at pos=", rx231_pos)
  debug_641:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 10
    if_null rx231_debug, debug_642
    rx231_cur."!cursor_debug"("NEXT", "unv")
  debug_642:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_643
    rx231_cur."!cursor_debug"("FAIL", "unv")
  debug_643:
    .return (rx231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1303739803.72") :method
.annotate 'line', 10
    new $P233, "ResizablePMCArray"
    push $P233, ""
    push $P233, ""
    push $P233, ""
    .return ($P233)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block237"  :anon :subid("26_1303739803.72") :method :outer("24_1303739803.72")
.annotate 'line', 74
    .local string rx239_tgt
    .local int rx239_pos
    .local int rx239_off
    .local int rx239_eos
    .local int rx239_rep
    .local pmc rx239_cur
    .local pmc rx239_debug
    (rx239_cur, rx239_pos, rx239_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx239_cur
    .local pmc match
    .lex "$/", match
    length rx239_eos, rx239_tgt
    gt rx239_pos, rx239_eos, rx239_done
    set rx239_off, 0
    lt rx239_pos, 2, rx239_start
    sub rx239_off, rx239_pos, 1
    substr rx239_tgt, rx239_tgt, rx239_off
  rx239_start:
    eq $I10, 1, rx239_restart
    if_null rx239_debug, debug_637
    rx239_cur."!cursor_debug"("START", "")
  debug_637:
    $I10 = self.'from'()
    ne $I10, -1, rxscan240_done
    goto rxscan240_scan
  rxscan240_loop:
    (rx239_pos) = rx239_cur."from"()
    inc rx239_pos
    rx239_cur."!cursor_from"(rx239_pos)
    ge rx239_pos, rx239_eos, rxscan240_done
  rxscan240_scan:
    set_addr $I10, rxscan240_loop
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  rxscan240_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx239_pos, rx239_off
    set rx239_rep, 0
    sub $I12, rx239_eos, rx239_pos
  rxenumcharlistq241_loop:
    le $I12, 0, rxenumcharlistq241_done
    substr $S10, rx239_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq241_done
    inc rx239_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq241_loop
  rxenumcharlistq241_done:
    add rx239_pos, rx239_pos, rx239_rep
  # rx literal  "="
    add $I11, rx239_pos, 1
    gt $I11, rx239_eos, rx239_fail
    sub $I11, rx239_pos, rx239_off
    ord $I11, rx239_tgt, $I11
    ne $I11, 61, rx239_fail
    add rx239_pos, 1
  alt242_0:
    set_addr $I10, alt242_1
    rx239_cur."!mark_push"(0, rx239_pos, $I10)
  # rx charclass w
    ge rx239_pos, rx239_eos, rx239_fail
    sub $I10, rx239_pos, rx239_off
    is_cclass $I11, 8192, rx239_tgt, $I10
    unless $I11, rx239_fail
    inc rx239_pos
    goto alt242_end
  alt242_1:
  # rx literal  "\\"
    add $I11, rx239_pos, 1
    gt $I11, rx239_eos, rx239_fail
    sub $I11, rx239_pos, rx239_off
    ord $I11, rx239_tgt, $I11
    ne $I11, 92, rx239_fail
    add rx239_pos, 1
  alt242_end:
  # rx pass
    rx239_cur."!cursor_pass"(rx239_pos, "")
    if_null rx239_debug, debug_638
    rx239_cur."!cursor_debug"("PASS", "", " at pos=", rx239_pos)
  debug_638:
    .return (rx239_cur)
  rx239_restart:
    if_null rx239_debug, debug_639
    rx239_cur."!cursor_debug"("NEXT", "")
  debug_639:
  rx239_fail:
    (rx239_rep, rx239_pos, $I10, $P10) = rx239_cur."!mark_fail"(0)
    lt rx239_pos, -1, rx239_done
    eq rx239_pos, -1, rx239_fail
    jump $I10
  rx239_done:
    rx239_cur."!cursor_fail"()
    if_null rx239_debug, debug_640
    rx239_cur."!cursor_debug"("FAIL", "")
  debug_640:
    .return (rx239_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P277 = "29_1303739803.72" 
    capture_lex $P277
    .local string rx246_tgt
    .local int rx246_pos
    .local int rx246_off
    .local int rx246_eos
    .local int rx246_rep
    .local pmc rx246_cur
    .local pmc rx246_debug
    (rx246_cur, rx246_pos, rx246_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx246_cur
    .local pmc match
    .lex "$/", match
    length rx246_eos, rx246_tgt
    gt rx246_pos, rx246_eos, rx246_done
    set rx246_off, 0
    lt rx246_pos, 2, rx246_start
    sub rx246_off, rx246_pos, 1
    substr rx246_tgt, rx246_tgt, rx246_off
  rx246_start:
    eq $I10, 1, rx246_restart
    if_null rx246_debug, debug_644
    rx246_cur."!cursor_debug"("START", "pod_comment")
  debug_644:
    $I10 = self.'from'()
    ne $I10, -1, rxscan249_done
    goto rxscan249_scan
  rxscan249_loop:
    (rx246_pos) = rx246_cur."from"()
    inc rx246_pos
    rx246_cur."!cursor_from"(rx246_pos)
    ge rx246_pos, rx246_eos, rxscan249_done
  rxscan249_scan:
    set_addr $I10, rxscan249_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  rxscan249_done:
.annotate 'line', 81
  # rxanchor bol
    eq rx246_pos, 0, rxanchor250_done
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    dec $I10
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
  rxanchor250_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq251_loop:
    le $I12, 0, rxenumcharlistq251_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq251_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq251_loop
  rxenumcharlistq251_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "="
    add $I11, rx246_pos, 1
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    ord $I11, rx246_tgt, $I11
    ne $I11, 61, rx246_fail
    add rx246_pos, 1
  alt252_0:
.annotate 'line', 82
    set_addr $I10, alt252_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 83
  # rx literal  "begin"
    add $I11, rx246_pos, 5
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 5
    ne $S10, "begin", rx246_fail
    add rx246_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq253_loop:
    le $I12, 0, rxenumcharlistq253_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq253_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq253_loop
  rxenumcharlistq253_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "END"
    add $I11, rx246_pos, 3
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 3
    ne $S10, "END", rx246_fail
    add rx246_pos, 3
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  alt254_0:
.annotate 'line', 84
    set_addr $I10, alt254_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rx rxquantf255 ** 0..*
    set_addr $I10, rxquantf255_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf255_done
  rxquantf255_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf255_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf255_done:
  # rx charclass nl
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
    substr $S10, rx246_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx246_pos, $I11
    inc rx246_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq257_loop:
    le $I12, 0, rxenumcharlistq257_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq257_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq257_loop
  rxenumcharlistq257_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "=end"
    add $I11, rx246_pos, 4
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 4
    ne $S10, "=end", rx246_fail
    add rx246_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq258_loop:
    le $I12, 0, rxenumcharlistq258_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq258_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq258_loop
  rxenumcharlistq258_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "END"
    add $I11, rx246_pos, 3
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 3
    ne $S10, "END", rx246_fail
    add rx246_pos, 3
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
    goto alt254_end
  alt254_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_not_cclass $I11, 65535, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
  alt254_end:
.annotate 'line', 83
    goto alt252_end
  alt252_1:
    set_addr $I10, alt252_2
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 85
  # rx literal  "begin"
    add $I11, rx246_pos, 5
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 5
    ne $S10, "begin", rx246_fail
    add rx246_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq259_loop:
    le $I12, 0, rxenumcharlistq259_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq259_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq259_loop
  rxenumcharlistq259_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx subrule "identifier" subtype=capture negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."identifier"()
    unless $P10, rx246_fail
    rx246_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx246_pos = $P10."pos"()
  alt260_0:
.annotate 'line', 86
    set_addr $I10, alt260_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 87
  # rx rxquantf261 ** 0..*
    set_addr $I10, rxquantf261_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf261_done
  rxquantf261_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf261_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf261_done:
  # rx charclass nl
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
    substr $S10, rx246_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx246_pos, $I11
    inc rx246_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq263_loop:
    le $I12, 0, rxenumcharlistq263_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq263_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq263_loop
  rxenumcharlistq263_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "=end"
    add $I11, rx246_pos, 4
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 4
    ne $S10, "=end", rx246_fail
    add rx246_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq264_loop:
    le $I12, 0, rxenumcharlistq264_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq264_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq264_loop
  rxenumcharlistq264_done:
    lt rx246_rep, 1, rx246_fail
    add rx246_pos, rx246_pos, rx246_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."!BACKREF"("identifier")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
    goto alt260_end
  alt260_1:
.annotate 'line', 88
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("=begin without matching =end")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt260_end:
.annotate 'line', 85
    goto alt252_end
  alt252_2:
    set_addr $I10, alt252_3
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 90
  # rx literal  "begin"
    add $I11, rx246_pos, 5
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 5
    ne $S10, "begin", rx246_fail
    add rx246_pos, 5
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq266_loop:
    le $I12, 0, rxenumcharlistq266_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq266_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq266_loop
  rxenumcharlistq266_done:
    add rx246_pos, rx246_pos, rx246_rep
  alt267_0:
.annotate 'line', 91
    set_addr $I10, alt267_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rxanchor eol
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    if $I11, rxanchor268_done
    ne rx246_pos, rx246_eos, rx246_fail
    eq rx246_pos, 0, rxanchor268_done
    dec $I10
    is_cclass $I11, 4096, rx246_tgt, $I10
    if $I11, rx246_fail
  rxanchor268_done:
    goto alt267_end
  alt267_1:
    set_addr $I10, alt267_2
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rx literal  "#"
    add $I11, rx246_pos, 1
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    ord $I11, rx246_tgt, $I11
    ne $I11, 35, rx246_fail
    add rx246_pos, 1
    goto alt267_end
  alt267_2:
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt267_end:
  alt269_0:
.annotate 'line', 92
    set_addr $I10, alt269_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 93
  # rx rxquantf270 ** 0..*
    set_addr $I10, rxquantf270_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf270_done
  rxquantf270_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf270_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf270_done:
  # rx charclass nl
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
    substr $S10, rx246_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx246_pos, $I11
    inc rx246_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx246_pos, rx246_off
    set rx246_rep, 0
    sub $I12, rx246_eos, rx246_pos
  rxenumcharlistq272_loop:
    le $I12, 0, rxenumcharlistq272_done
    substr $S10, rx246_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq272_done
    inc rx246_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq272_loop
  rxenumcharlistq272_done:
    add rx246_pos, rx246_pos, rx246_rep
  # rx literal  "=end"
    add $I11, rx246_pos, 4
    gt $I11, rx246_eos, rx246_fail
    sub $I11, rx246_pos, rx246_off
    substr $S10, rx246_tgt, $I11, 4
    ne $S10, "=end", rx246_fail
    add rx246_pos, 4
  # rxanchor rwb
    le rx246_pos, 0, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 8192, rx246_tgt, $I10
    if $I11, rx246_fail
    dec $I10
    is_cclass $I11, 8192, rx246_tgt, $I10
    unless $I11, rx246_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
    goto alt269_end
  alt269_1:
.annotate 'line', 94
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("=begin without matching =end")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt269_end:
.annotate 'line', 90
    goto alt252_end
  alt252_3:
    set_addr $I10, alt252_4
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
.annotate 'line', 96
  # rx subrule "identifier" subtype=capture negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."identifier"()
    unless $P10, rx246_fail
    rx246_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx246_pos = $P10."pos"()
.annotate 'line', 97
  # rx rxquantf273 ** 0..*
    set_addr $I10, rxquantf273_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
    goto rxquantf273_done
  rxquantf273_loop:
  # rx charclass .
    ge rx246_pos, rx246_eos, rx246_fail
    inc rx246_pos
    set_addr $I10, rxquantf273_loop
    rx246_cur."!mark_push"(rx246_rep, rx246_pos, $I10)
  rxquantf273_done:
  # rxanchor bol
    eq rx246_pos, 0, rxanchor275_done
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    dec $I10
    is_cclass $I11, 4096, rx246_tgt, $I10
    unless $I11, rx246_fail
  rxanchor275_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    .const 'Sub' $P277 = "29_1303739803.72" 
    capture_lex $P277
    $P10 = rx246_cur."before"($P277)
    unless $P10, rx246_fail
.annotate 'line', 96
    goto alt252_end
  alt252_4:
  alt283_0:
.annotate 'line', 103
    set_addr $I10, alt283_1
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  # rx charclass s
    ge rx246_pos, rx246_eos, rx246_fail
    sub $I10, rx246_pos, rx246_off
    is_cclass $I11, 32, rx246_tgt, $I10
    unless $I11, rx246_fail
    inc rx246_pos
    goto alt283_end
  alt283_1:
  # rx subrule "panic" subtype=method negate=
    rx246_cur."!cursor_pos"(rx246_pos)
    $P10 = rx246_cur."panic"("Illegal pod directive")
    unless $P10, rx246_fail
    rx246_pos = $P10."pos"()
  alt283_end:
.annotate 'line', 104
  # rx charclass_q N r 0..-1
    sub $I10, rx246_pos, rx246_off
    find_cclass $I11, 4096, rx246_tgt, $I10, rx246_eos
    add rx246_pos, rx246_off, $I11
  alt252_end:
.annotate 'line', 80
  # rx pass
    rx246_cur."!cursor_pass"(rx246_pos, "pod_comment")
    if_null rx246_debug, debug_649
    rx246_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx246_pos)
  debug_649:
    .return (rx246_cur)
  rx246_restart:
.annotate 'line', 10
    if_null rx246_debug, debug_650
    rx246_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_650:
  rx246_fail:
    (rx246_rep, rx246_pos, $I10, $P10) = rx246_cur."!mark_fail"(0)
    lt rx246_pos, -1, rx246_done
    eq rx246_pos, -1, rx246_fail
    jump $I10
  rx246_done:
    rx246_cur."!cursor_fail"()
    if_null rx246_debug, debug_651
    rx246_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_651:
    .return (rx246_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1303739803.72") :method
.annotate 'line', 10
    new $P248, "ResizablePMCArray"
    push $P248, ""
    .return ($P248)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block276"  :anon :subid("29_1303739803.72") :method :outer("27_1303739803.72")
.annotate 'line', 97
    .local string rx278_tgt
    .local int rx278_pos
    .local int rx278_off
    .local int rx278_eos
    .local int rx278_rep
    .local pmc rx278_cur
    .local pmc rx278_debug
    (rx278_cur, rx278_pos, rx278_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx278_cur
    .local pmc match
    .lex "$/", match
    length rx278_eos, rx278_tgt
    gt rx278_pos, rx278_eos, rx278_done
    set rx278_off, 0
    lt rx278_pos, 2, rx278_start
    sub rx278_off, rx278_pos, 1
    substr rx278_tgt, rx278_tgt, rx278_off
  rx278_start:
    eq $I10, 1, rx278_restart
    if_null rx278_debug, debug_645
    rx278_cur."!cursor_debug"("START", "")
  debug_645:
    $I10 = self.'from'()
    ne $I10, -1, rxscan279_done
    goto rxscan279_scan
  rxscan279_loop:
    (rx278_pos) = rx278_cur."from"()
    inc rx278_pos
    rx278_cur."!cursor_from"(rx278_pos)
    ge rx278_pos, rx278_eos, rxscan279_done
  rxscan279_scan:
    set_addr $I10, rxscan279_loop
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
  rxscan279_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx278_pos, rx278_off
    set rx278_rep, 0
    sub $I12, rx278_eos, rx278_pos
  rxenumcharlistq280_loop:
    le $I12, 0, rxenumcharlistq280_done
    substr $S10, rx278_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq280_done
    inc rx278_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq280_loop
  rxenumcharlistq280_done:
    add rx278_pos, rx278_pos, rx278_rep
  alt281_0:
    set_addr $I10, alt281_1
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
.annotate 'line', 98
  # rx literal  "="
    add $I11, rx278_pos, 1
    gt $I11, rx278_eos, rx278_fail
    sub $I11, rx278_pos, rx278_off
    ord $I11, rx278_tgt, $I11
    ne $I11, 61, rx278_fail
    add rx278_pos, 1
.annotate 'line', 100
  # rx rxquantr282 ** 0..1
    set_addr $I10, rxquantr282_done
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
  rxquantr282_loop:
.annotate 'line', 99
  # rx literal  "cut"
    add $I11, rx278_pos, 3
    gt $I11, rx278_eos, rx278_fail
    sub $I11, rx278_pos, rx278_off
    substr $S10, rx278_tgt, $I11, 3
    ne $S10, "cut", rx278_fail
    add rx278_pos, 3
  # rxanchor rwb
    le rx278_pos, 0, rx278_fail
    sub $I10, rx278_pos, rx278_off
    is_cclass $I11, 8192, rx278_tgt, $I10
    if $I11, rx278_fail
    dec $I10
    is_cclass $I11, 8192, rx278_tgt, $I10
    unless $I11, rx278_fail
.annotate 'line', 100
  # rx subrule "panic" subtype=method negate=
    rx278_cur."!cursor_pos"(rx278_pos)
    $P10 = rx278_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx278_fail
    rx278_pos = $P10."pos"()
    set_addr $I10, rxquantr282_done
    (rx278_rep) = rx278_cur."!mark_commit"($I10)
  rxquantr282_done:
.annotate 'line', 97
    goto alt281_end
  alt281_1:
.annotate 'line', 101
  # rx charclass nl
    ge rx278_pos, rx278_eos, rx278_fail
    sub $I10, rx278_pos, rx278_off
    is_cclass $I11, 4096, rx278_tgt, $I10
    unless $I11, rx278_fail
    substr $S10, rx278_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx278_pos, $I11
    inc rx278_pos
  alt281_end:
.annotate 'line', 97
  # rx pass
    rx278_cur."!cursor_pass"(rx278_pos, "")
    if_null rx278_debug, debug_646
    rx278_cur."!cursor_debug"("PASS", "", " at pos=", rx278_pos)
  debug_646:
    .return (rx278_cur)
  rx278_restart:
    if_null rx278_debug, debug_647
    rx278_cur."!cursor_debug"("NEXT", "")
  debug_647:
  rx278_fail:
    (rx278_rep, rx278_pos, $I10, $P10) = rx278_cur."!mark_fail"(0)
    lt rx278_pos, -1, rx278_done
    eq rx278_pos, -1, rx278_fail
    jump $I10
  rx278_done:
    rx278_cur."!cursor_fail"()
    if_null rx278_debug, debug_648
    rx278_cur."!cursor_debug"("FAIL", "")
  debug_648:
    .return (rx278_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 112
    new $P285, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P285
.annotate 'line', 113
    new $P286, "Undef"
    .lex "$*MAIN_SUB", $P286
.annotate 'line', 116
    new $P287, "Undef"
    .lex "$*PACKAGE", $P287
.annotate 'line', 117
    new $P288, "Undef"
    .lex "$*GLOBALish", $P288
.annotate 'line', 10
    .local string rx289_tgt
    .local int rx289_pos
    .local int rx289_off
    .local int rx289_eos
    .local int rx289_rep
    .local pmc rx289_cur
    .local pmc rx289_debug
    (rx289_cur, rx289_pos, rx289_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx289_cur
    .local pmc match
    .lex "$/", match
    length rx289_eos, rx289_tgt
    gt rx289_pos, rx289_eos, rx289_done
    set rx289_off, 0
    lt rx289_pos, 2, rx289_start
    sub rx289_off, rx289_pos, 1
    substr rx289_tgt, rx289_tgt, rx289_off
  rx289_start:
    eq $I10, 1, rx289_restart
    if_null rx289_debug, debug_652
    rx289_cur."!cursor_debug"("START", "comp_unit")
  debug_652:
    $I10 = self.'from'()
    ne $I10, -1, rxscan293_done
    goto rxscan293_scan
  rxscan293_loop:
    (rx289_pos) = rx289_cur."from"()
    inc rx289_pos
    rx289_cur."!cursor_from"(rx289_pos)
    ge rx289_pos, rx289_eos, rxscan293_done
  rxscan293_scan:
    set_addr $I10, rxscan293_loop
    rx289_cur."!mark_push"(0, rx289_pos, $I10)
  rxscan293_done:
.annotate 'line', 112
    rx289_cur."!cursor_pos"(rx289_pos)
    new $P294, "Integer"
    assign $P294, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P294
.annotate 'line', 113
    rx289_cur."!cursor_pos"(rx289_pos)
    find_lex $P297, "$*MAIN_SUB"
    unless_null $P297, vivify_653
    get_hll_global $P295, "GLOBAL"
    get_who $P296, $P295
    set $P297, $P296["$MAIN_SUB"]
    unless_null $P297, vivify_654
    die "Contextual $*MAIN_SUB not found"
  vivify_654:
  vivify_653:
.annotate 'line', 114
  # rx subrule "newpad" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."newpad"()
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
.annotate 'line', 116
    rx289_cur."!cursor_pos"(rx289_pos)
    find_lex $P300, "$*PACKAGE"
    unless_null $P300, vivify_655
    get_hll_global $P298, "GLOBAL"
    get_who $P299, $P298
    set $P300, $P299["$PACKAGE"]
    unless_null $P300, vivify_656
    die "Contextual $*PACKAGE not found"
  vivify_656:
  vivify_655:
.annotate 'line', 117
    rx289_cur."!cursor_pos"(rx289_pos)
    find_lex $P303, "$*GLOBALish"
    unless_null $P303, vivify_657
    get_hll_global $P301, "GLOBAL"
    get_who $P302, $P301
    set $P303, $P302["$GLOBALish"]
    unless_null $P303, vivify_658
    die "Contextual $*GLOBALish not found"
  vivify_658:
  vivify_657:
.annotate 'line', 118
  # rx subrule "GLOBALish" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."GLOBALish"()
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
.annotate 'line', 120
  # rx subrule "outerctx" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."outerctx"()
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
.annotate 'line', 122
  # rx subrule "statementlist" subtype=capture negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."statementlist"()
    unless $P10, rx289_fail
    rx289_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx289_pos = $P10."pos"()
  alt304_0:
.annotate 'line', 123
    set_addr $I10, alt304_1
    rx289_cur."!mark_push"(0, rx289_pos, $I10)
  # rxanchor eos
    ne rx289_pos, rx289_eos, rx289_fail
    goto alt304_end
  alt304_1:
  # rx subrule "panic" subtype=method negate=
    rx289_cur."!cursor_pos"(rx289_pos)
    $P10 = rx289_cur."panic"("Confused")
    unless $P10, rx289_fail
    rx289_pos = $P10."pos"()
  alt304_end:
.annotate 'line', 111
  # rx pass
    rx289_cur."!cursor_pass"(rx289_pos, "comp_unit")
    if_null rx289_debug, debug_659
    rx289_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx289_pos)
  debug_659:
    .return (rx289_cur)
  rx289_restart:
.annotate 'line', 10
    if_null rx289_debug, debug_660
    rx289_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_660:
  rx289_fail:
    (rx289_rep, rx289_pos, $I10, $P10) = rx289_cur."!mark_fail"(0)
    lt rx289_pos, -1, rx289_done
    eq rx289_pos, -1, rx289_fail
    jump $I10
  rx289_done:
    rx289_cur."!cursor_fail"()
    if_null rx289_debug, debug_661
    rx289_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_661:
    .return (rx289_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1303739803.72") :method
.annotate 'line', 10
    $P291 = self."!PREFIX__!subrule"("newpad", "")
    new $P292, "ResizablePMCArray"
    push $P292, $P291
    .return ($P292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx306_tgt
    .local int rx306_pos
    .local int rx306_off
    .local int rx306_eos
    .local int rx306_rep
    .local pmc rx306_cur
    .local pmc rx306_debug
    (rx306_cur, rx306_pos, rx306_tgt, $I10) = self."!cursor_start"()
    rx306_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx306_cur
    .local pmc match
    .lex "$/", match
    length rx306_eos, rx306_tgt
    gt rx306_pos, rx306_eos, rx306_done
    set rx306_off, 0
    lt rx306_pos, 2, rx306_start
    sub rx306_off, rx306_pos, 1
    substr rx306_tgt, rx306_tgt, rx306_off
  rx306_start:
    eq $I10, 1, rx306_restart
    if_null rx306_debug, debug_662
    rx306_cur."!cursor_debug"("START", "statementlist")
  debug_662:
    $I10 = self.'from'()
    ne $I10, -1, rxscan311_done
    goto rxscan311_scan
  rxscan311_loop:
    (rx306_pos) = rx306_cur."from"()
    inc rx306_pos
    rx306_cur."!cursor_from"(rx306_pos)
    ge rx306_pos, rx306_eos, rxscan311_done
  rxscan311_scan:
    set_addr $I10, rxscan311_loop
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
  rxscan311_done:
  alt312_0:
.annotate 'line', 126
    set_addr $I10, alt312_1
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
.annotate 'line', 127
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  # rxanchor eos
    ne rx306_pos, rx306_eos, rx306_fail
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
    goto alt312_end
  alt312_1:
.annotate 'line', 128
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  # rx rxquantr316 ** 0..*
    set_addr $I10, rxquantr316_done
    rx306_cur."!mark_push"(0, rx306_pos, $I10)
  rxquantr316_loop:
  # rx subrule "statement" subtype=capture negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."statement"()
    unless $P10, rx306_fail
    rx306_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx306_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."eat_terminator"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
    set_addr $I10, rxquantr316_done
    (rx306_rep) = rx306_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr316_done
    rx306_cur."!mark_push"(rx306_rep, rx306_pos, $I10)
    goto rxquantr316_loop
  rxquantr316_done:
  # rx subrule "ws" subtype=method negate=
    rx306_cur."!cursor_pos"(rx306_pos)
    $P10 = rx306_cur."ws"()
    unless $P10, rx306_fail
    rx306_pos = $P10."pos"()
  alt312_end:
.annotate 'line', 126
  # rx pass
    rx306_cur."!cursor_pass"(rx306_pos, "statementlist")
    if_null rx306_debug, debug_663
    rx306_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx306_pos)
  debug_663:
    .return (rx306_cur)
  rx306_restart:
.annotate 'line', 10
    if_null rx306_debug, debug_664
    rx306_cur."!cursor_debug"("NEXT", "statementlist")
  debug_664:
  rx306_fail:
    (rx306_rep, rx306_pos, $I10, $P10) = rx306_cur."!mark_fail"(0)
    lt rx306_pos, -1, rx306_done
    eq rx306_pos, -1, rx306_fail
    jump $I10
  rx306_done:
    rx306_cur."!cursor_fail"()
    if_null rx306_debug, debug_665
    rx306_cur."!cursor_debug"("FAIL", "statementlist")
  debug_665:
    .return (rx306_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1303739803.72") :method
.annotate 'line', 10
    $P308 = self."!PREFIX__!subrule"("ws", "")
    $P309 = self."!PREFIX__!subrule"("ws", "")
    new $P310, "ResizablePMCArray"
    push $P310, $P308
    push $P310, $P309
    .return ($P310)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P325 = "36_1303739803.72" 
    capture_lex $P325
    .local string rx320_tgt
    .local int rx320_pos
    .local int rx320_off
    .local int rx320_eos
    .local int rx320_rep
    .local pmc rx320_cur
    .local pmc rx320_debug
    (rx320_cur, rx320_pos, rx320_tgt, $I10) = self."!cursor_start"()
    rx320_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx320_cur
    .local pmc match
    .lex "$/", match
    length rx320_eos, rx320_tgt
    gt rx320_pos, rx320_eos, rx320_done
    set rx320_off, 0
    lt rx320_pos, 2, rx320_start
    sub rx320_off, rx320_pos, 1
    substr rx320_tgt, rx320_tgt, rx320_off
  rx320_start:
    eq $I10, 1, rx320_restart
    if_null rx320_debug, debug_666
    rx320_cur."!cursor_debug"("START", "statement")
  debug_666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan323_done
    goto rxscan323_scan
  rxscan323_loop:
    (rx320_pos) = rx320_cur."from"()
    inc rx320_pos
    rx320_cur."!cursor_from"(rx320_pos)
    ge rx320_pos, rx320_eos, rxscan323_done
  rxscan323_scan:
    set_addr $I10, rxscan323_loop
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxscan323_done:
.annotate 'line', 132
  # rx subrule "before" subtype=zerowidth negate=1
    rx320_cur."!cursor_pos"(rx320_pos)
    .const 'Sub' $P325 = "36_1303739803.72" 
    capture_lex $P325
    $P10 = rx320_cur."before"($P325)
    if $P10, rx320_fail
  alt329_0:
.annotate 'line', 133
    set_addr $I10, alt329_1
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
.annotate 'line', 134
  # rx subrule "statement_control" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_control"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx320_pos = $P10."pos"()
    goto alt329_end
  alt329_1:
.annotate 'line', 135
  # rx subrule "EXPR" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."EXPR"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx320_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
.annotate 'line', 140
  # rx rxquantr330 ** 0..1
    set_addr $I10, rxquantr330_done
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxquantr330_loop:
  alt331_0:
.annotate 'line', 136
    set_addr $I10, alt331_1
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
.annotate 'line', 137
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."MARKED"("endstmt")
    unless $P10, rx320_fail
    goto alt331_end
  alt331_1:
    set_addr $I10, alt331_2
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
.annotate 'line', 138
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_mod_cond"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx320_pos = $P10."pos"()
  # rx rxquantr332 ** 0..1
    set_addr $I10, rxquantr332_done
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxquantr332_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_mod_loop"()
    unless $P10, rx320_fail
    goto rxsubrule333_pass
  rxsubrule333_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx320_fail
  rxsubrule333_pass:
    set_addr $I10, rxsubrule333_back
    rx320_cur."!mark_push"(0, rx320_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx320_pos = $P10."pos"()
    set_addr $I10, rxquantr332_done
    (rx320_rep) = rx320_cur."!mark_commit"($I10)
  rxquantr332_done:
    goto alt331_end
  alt331_2:
.annotate 'line', 139
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."statement_mod_loop"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx320_pos = $P10."pos"()
  alt331_end:
.annotate 'line', 140
    set_addr $I10, rxquantr330_done
    (rx320_rep) = rx320_cur."!mark_commit"($I10)
  rxquantr330_done:
  alt329_end:
.annotate 'line', 131
  # rx pass
    rx320_cur."!cursor_pass"(rx320_pos, "statement")
    if_null rx320_debug, debug_671
    rx320_cur."!cursor_debug"("PASS", "statement", " at pos=", rx320_pos)
  debug_671:
    .return (rx320_cur)
  rx320_restart:
.annotate 'line', 10
    if_null rx320_debug, debug_672
    rx320_cur."!cursor_debug"("NEXT", "statement")
  debug_672:
  rx320_fail:
    (rx320_rep, rx320_pos, $I10, $P10) = rx320_cur."!mark_fail"(0)
    lt rx320_pos, -1, rx320_done
    eq rx320_pos, -1, rx320_fail
    jump $I10
  rx320_done:
    rx320_cur."!cursor_fail"()
    if_null rx320_debug, debug_673
    rx320_cur."!cursor_debug"("FAIL", "statement")
  debug_673:
    .return (rx320_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1303739803.72") :method
.annotate 'line', 10
    new $P322, "ResizablePMCArray"
    push $P322, ""
    .return ($P322)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block324"  :anon :subid("36_1303739803.72") :method :outer("34_1303739803.72")
.annotate 'line', 132
    .local string rx326_tgt
    .local int rx326_pos
    .local int rx326_off
    .local int rx326_eos
    .local int rx326_rep
    .local pmc rx326_cur
    .local pmc rx326_debug
    (rx326_cur, rx326_pos, rx326_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx326_cur
    .local pmc match
    .lex "$/", match
    length rx326_eos, rx326_tgt
    gt rx326_pos, rx326_eos, rx326_done
    set rx326_off, 0
    lt rx326_pos, 2, rx326_start
    sub rx326_off, rx326_pos, 1
    substr rx326_tgt, rx326_tgt, rx326_off
  rx326_start:
    eq $I10, 1, rx326_restart
    if_null rx326_debug, debug_667
    rx326_cur."!cursor_debug"("START", "")
  debug_667:
    $I10 = self.'from'()
    ne $I10, -1, rxscan327_done
    goto rxscan327_scan
  rxscan327_loop:
    (rx326_pos) = rx326_cur."from"()
    inc rx326_pos
    rx326_cur."!cursor_from"(rx326_pos)
    ge rx326_pos, rx326_eos, rxscan327_done
  rxscan327_scan:
    set_addr $I10, rxscan327_loop
    rx326_cur."!mark_push"(0, rx326_pos, $I10)
  rxscan327_done:
  alt328_0:
    set_addr $I10, alt328_1
    rx326_cur."!mark_push"(0, rx326_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx326_pos, rx326_eos, rx326_fail
    sub $I10, rx326_pos, rx326_off
    substr $S10, rx326_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx326_fail
    inc rx326_pos
    goto alt328_end
  alt328_1:
  # rxanchor eos
    ne rx326_pos, rx326_eos, rx326_fail
  alt328_end:
  # rx pass
    rx326_cur."!cursor_pass"(rx326_pos, "")
    if_null rx326_debug, debug_668
    rx326_cur."!cursor_debug"("PASS", "", " at pos=", rx326_pos)
  debug_668:
    .return (rx326_cur)
  rx326_restart:
    if_null rx326_debug, debug_669
    rx326_cur."!cursor_debug"("NEXT", "")
  debug_669:
  rx326_fail:
    (rx326_rep, rx326_pos, $I10, $P10) = rx326_cur."!mark_fail"(0)
    lt rx326_pos, -1, rx326_done
    eq rx326_pos, -1, rx326_fail
    jump $I10
  rx326_done:
    rx326_cur."!cursor_fail"()
    if_null rx326_debug, debug_670
    rx326_cur."!cursor_debug"("FAIL", "")
  debug_670:
    .return (rx326_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx335_tgt
    .local int rx335_pos
    .local int rx335_off
    .local int rx335_eos
    .local int rx335_rep
    .local pmc rx335_cur
    .local pmc rx335_debug
    (rx335_cur, rx335_pos, rx335_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx335_cur
    .local pmc match
    .lex "$/", match
    length rx335_eos, rx335_tgt
    gt rx335_pos, rx335_eos, rx335_done
    set rx335_off, 0
    lt rx335_pos, 2, rx335_start
    sub rx335_off, rx335_pos, 1
    substr rx335_tgt, rx335_tgt, rx335_off
  rx335_start:
    eq $I10, 1, rx335_restart
    if_null rx335_debug, debug_674
    rx335_cur."!cursor_debug"("START", "eat_terminator")
  debug_674:
    $I10 = self.'from'()
    ne $I10, -1, rxscan338_done
    goto rxscan338_scan
  rxscan338_loop:
    (rx335_pos) = rx335_cur."from"()
    inc rx335_pos
    rx335_cur."!cursor_from"(rx335_pos)
    ge rx335_pos, rx335_eos, rxscan338_done
  rxscan338_scan:
    set_addr $I10, rxscan338_loop
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
  rxscan338_done:
  alt339_0:
.annotate 'line', 144
    set_addr $I10, alt339_1
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
.annotate 'line', 145
  # rx literal  ";"
    add $I11, rx335_pos, 1
    gt $I11, rx335_eos, rx335_fail
    sub $I11, rx335_pos, rx335_off
    ord $I11, rx335_tgt, $I11
    ne $I11, 59, rx335_fail
    add rx335_pos, 1
    goto alt339_end
  alt339_1:
    set_addr $I10, alt339_2
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
.annotate 'line', 146
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."MARKED"("endstmt")
    unless $P10, rx335_fail
    goto alt339_end
  alt339_2:
    set_addr $I10, alt339_3
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
.annotate 'line', 147
  # rx subrule "terminator" subtype=zerowidth negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."terminator"()
    unless $P10, rx335_fail
    goto alt339_end
  alt339_3:
.annotate 'line', 148
  # rxanchor eos
    ne rx335_pos, rx335_eos, rx335_fail
  alt339_end:
.annotate 'line', 144
  # rx pass
    rx335_cur."!cursor_pass"(rx335_pos, "eat_terminator")
    if_null rx335_debug, debug_675
    rx335_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx335_pos)
  debug_675:
    .return (rx335_cur)
  rx335_restart:
.annotate 'line', 10
    if_null rx335_debug, debug_676
    rx335_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_676:
  rx335_fail:
    (rx335_rep, rx335_pos, $I10, $P10) = rx335_cur."!mark_fail"(0)
    lt rx335_pos, -1, rx335_done
    eq rx335_pos, -1, rx335_fail
    jump $I10
  rx335_done:
    rx335_cur."!cursor_fail"()
    if_null rx335_debug, debug_677
    rx335_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_677:
    .return (rx335_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1303739803.72") :method
.annotate 'line', 10
    new $P337, "ResizablePMCArray"
    push $P337, ""
    push $P337, ""
    push $P337, ""
    push $P337, ";"
    .return ($P337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx341_tgt
    .local int rx341_pos
    .local int rx341_off
    .local int rx341_eos
    .local int rx341_rep
    .local pmc rx341_cur
    .local pmc rx341_debug
    (rx341_cur, rx341_pos, rx341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx341_cur
    .local pmc match
    .lex "$/", match
    length rx341_eos, rx341_tgt
    gt rx341_pos, rx341_eos, rx341_done
    set rx341_off, 0
    lt rx341_pos, 2, rx341_start
    sub rx341_off, rx341_pos, 1
    substr rx341_tgt, rx341_tgt, rx341_off
  rx341_start:
    eq $I10, 1, rx341_restart
    if_null rx341_debug, debug_678
    rx341_cur."!cursor_debug"("START", "xblock")
  debug_678:
    $I10 = self.'from'()
    ne $I10, -1, rxscan345_done
    goto rxscan345_scan
  rxscan345_loop:
    (rx341_pos) = rx341_cur."from"()
    inc rx341_pos
    rx341_cur."!cursor_from"(rx341_pos)
    ge rx341_pos, rx341_eos, rxscan345_done
  rxscan345_scan:
    set_addr $I10, rxscan345_loop
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  rxscan345_done:
.annotate 'line', 152
  # rx subrule "EXPR" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."EXPR"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx341_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."ws"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."pblock"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx341_pos = $P10."pos"()
.annotate 'line', 151
  # rx pass
    rx341_cur."!cursor_pass"(rx341_pos, "xblock")
    if_null rx341_debug, debug_679
    rx341_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx341_pos)
  debug_679:
    .return (rx341_cur)
  rx341_restart:
.annotate 'line', 10
    if_null rx341_debug, debug_680
    rx341_cur."!cursor_debug"("NEXT", "xblock")
  debug_680:
  rx341_fail:
    (rx341_rep, rx341_pos, $I10, $P10) = rx341_cur."!mark_fail"(0)
    lt rx341_pos, -1, rx341_done
    eq rx341_pos, -1, rx341_fail
    jump $I10
  rx341_done:
    rx341_cur."!cursor_fail"()
    if_null rx341_debug, debug_681
    rx341_cur."!cursor_debug"("FAIL", "xblock")
  debug_681:
    .return (rx341_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1303739803.72") :method
.annotate 'line', 10
    $P343 = self."!PREFIX__!subrule"("EXPR", "")
    new $P344, "ResizablePMCArray"
    push $P344, $P343
    .return ($P344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx347_tgt
    .local int rx347_pos
    .local int rx347_off
    .local int rx347_eos
    .local int rx347_rep
    .local pmc rx347_cur
    .local pmc rx347_debug
    (rx347_cur, rx347_pos, rx347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx347_cur
    .local pmc match
    .lex "$/", match
    length rx347_eos, rx347_tgt
    gt rx347_pos, rx347_eos, rx347_done
    set rx347_off, 0
    lt rx347_pos, 2, rx347_start
    sub rx347_off, rx347_pos, 1
    substr rx347_tgt, rx347_tgt, rx347_off
  rx347_start:
    eq $I10, 1, rx347_restart
    if_null rx347_debug, debug_682
    rx347_cur."!cursor_debug"("START", "pblock")
  debug_682:
    $I10 = self.'from'()
    ne $I10, -1, rxscan352_done
    goto rxscan352_scan
  rxscan352_loop:
    (rx347_pos) = rx347_cur."from"()
    inc rx347_pos
    rx347_cur."!cursor_from"(rx347_pos)
    ge rx347_pos, rx347_eos, rxscan352_done
  rxscan352_scan:
    set_addr $I10, rxscan352_loop
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxscan352_done:
  alt353_0:
.annotate 'line', 155
    set_addr $I10, alt353_1
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
.annotate 'line', 156
  # rx subrule "lambda" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."lambda"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "newpad" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."newpad"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 158
  # rx subrule "signature" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."signature"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx347_pos = $P10."pos"()
.annotate 'line', 159
  # rx subrule "blockoid" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."blockoid"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx347_pos = $P10."pos"()
.annotate 'line', 156
    goto alt353_end
  alt353_1:
    set_addr $I10, alt353_2
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
.annotate 'line', 160
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx347_fail
.annotate 'line', 161
  # rx subrule "newpad" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."newpad"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 162
  # rx subrule "blockoid" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."blockoid"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx347_pos = $P10."pos"()
.annotate 'line', 160
    goto alt353_end
  alt353_2:
.annotate 'line', 163
  # rx subrule "panic" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."panic"("Missing block")
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  alt353_end:
.annotate 'line', 155
  # rx pass
    rx347_cur."!cursor_pass"(rx347_pos, "pblock")
    if_null rx347_debug, debug_683
    rx347_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx347_pos)
  debug_683:
    .return (rx347_cur)
  rx347_restart:
.annotate 'line', 10
    if_null rx347_debug, debug_684
    rx347_cur."!cursor_debug"("NEXT", "pblock")
  debug_684:
  rx347_fail:
    (rx347_rep, rx347_pos, $I10, $P10) = rx347_cur."!mark_fail"(0)
    lt rx347_pos, -1, rx347_done
    eq rx347_pos, -1, rx347_fail
    jump $I10
  rx347_done:
    rx347_cur."!cursor_fail"()
    if_null rx347_debug, debug_685
    rx347_cur."!cursor_debug"("FAIL", "pblock")
  debug_685:
    .return (rx347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1303739803.72") :method
.annotate 'line', 10
    $P349 = self."!PREFIX__!subrule"("panic", "")
    $P350 = self."!PREFIX__!subrule"("lambda", "")
    new $P351, "ResizablePMCArray"
    push $P351, $P349
    push $P351, "{"
    push $P351, $P350
    .return ($P351)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx355_tgt
    .local int rx355_pos
    .local int rx355_off
    .local int rx355_eos
    .local int rx355_rep
    .local pmc rx355_cur
    .local pmc rx355_debug
    (rx355_cur, rx355_pos, rx355_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx355_cur
    .local pmc match
    .lex "$/", match
    length rx355_eos, rx355_tgt
    gt rx355_pos, rx355_eos, rx355_done
    set rx355_off, 0
    lt rx355_pos, 2, rx355_start
    sub rx355_off, rx355_pos, 1
    substr rx355_tgt, rx355_tgt, rx355_off
  rx355_start:
    eq $I10, 1, rx355_restart
    if_null rx355_debug, debug_686
    rx355_cur."!cursor_debug"("START", "lambda")
  debug_686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan358_done
    goto rxscan358_scan
  rxscan358_loop:
    (rx355_pos) = rx355_cur."from"()
    inc rx355_pos
    rx355_cur."!cursor_from"(rx355_pos)
    ge rx355_pos, rx355_eos, rxscan358_done
  rxscan358_scan:
    set_addr $I10, rxscan358_loop
    rx355_cur."!mark_push"(0, rx355_pos, $I10)
  rxscan358_done:
  alt359_0:
.annotate 'line', 166
    set_addr $I10, alt359_1
    rx355_cur."!mark_push"(0, rx355_pos, $I10)
  # rx literal  "->"
    add $I11, rx355_pos, 2
    gt $I11, rx355_eos, rx355_fail
    sub $I11, rx355_pos, rx355_off
    substr $S10, rx355_tgt, $I11, 2
    ne $S10, "->", rx355_fail
    add rx355_pos, 2
    goto alt359_end
  alt359_1:
  # rx literal  "<->"
    add $I11, rx355_pos, 3
    gt $I11, rx355_eos, rx355_fail
    sub $I11, rx355_pos, rx355_off
    substr $S10, rx355_tgt, $I11, 3
    ne $S10, "<->", rx355_fail
    add rx355_pos, 3
  alt359_end:
  # rx pass
    rx355_cur."!cursor_pass"(rx355_pos, "lambda")
    if_null rx355_debug, debug_687
    rx355_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx355_pos)
  debug_687:
    .return (rx355_cur)
  rx355_restart:
.annotate 'line', 10
    if_null rx355_debug, debug_688
    rx355_cur."!cursor_debug"("NEXT", "lambda")
  debug_688:
  rx355_fail:
    (rx355_rep, rx355_pos, $I10, $P10) = rx355_cur."!mark_fail"(0)
    lt rx355_pos, -1, rx355_done
    eq rx355_pos, -1, rx355_fail
    jump $I10
  rx355_done:
    rx355_cur."!cursor_fail"()
    if_null rx355_debug, debug_689
    rx355_cur."!cursor_debug"("FAIL", "lambda")
  debug_689:
    .return (rx355_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1303739803.72") :method
.annotate 'line', 10
    new $P357, "ResizablePMCArray"
    push $P357, "<->"
    push $P357, "->"
    .return ($P357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx361_tgt
    .local int rx361_pos
    .local int rx361_off
    .local int rx361_eos
    .local int rx361_rep
    .local pmc rx361_cur
    .local pmc rx361_debug
    (rx361_cur, rx361_pos, rx361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx361_cur
    .local pmc match
    .lex "$/", match
    length rx361_eos, rx361_tgt
    gt rx361_pos, rx361_eos, rx361_done
    set rx361_off, 0
    lt rx361_pos, 2, rx361_start
    sub rx361_off, rx361_pos, 1
    substr rx361_tgt, rx361_tgt, rx361_off
  rx361_start:
    eq $I10, 1, rx361_restart
    if_null rx361_debug, debug_690
    rx361_cur."!cursor_debug"("START", "block")
  debug_690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan365_done
    goto rxscan365_scan
  rxscan365_loop:
    (rx361_pos) = rx361_cur."from"()
    inc rx361_pos
    rx361_cur."!cursor_from"(rx361_pos)
    ge rx361_pos, rx361_eos, rxscan365_done
  rxscan365_scan:
    set_addr $I10, rxscan365_loop
    rx361_cur."!mark_push"(0, rx361_pos, $I10)
  rxscan365_done:
  alt366_0:
.annotate 'line', 169
    set_addr $I10, alt366_1
    rx361_cur."!mark_push"(0, rx361_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx361_pos, rx361_off
    substr $S10, rx361_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx361_fail
    goto alt366_end
  alt366_1:
  # rx subrule "panic" subtype=method negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."panic"("Missing block")
    unless $P10, rx361_fail
    rx361_pos = $P10."pos"()
  alt366_end:
.annotate 'line', 170
  # rx subrule "newpad" subtype=method negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."newpad"()
    unless $P10, rx361_fail
    rx361_pos = $P10."pos"()
.annotate 'line', 171
  # rx subrule "blockoid" subtype=capture negate=
    rx361_cur."!cursor_pos"(rx361_pos)
    $P10 = rx361_cur."blockoid"()
    unless $P10, rx361_fail
    rx361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx361_pos = $P10."pos"()
.annotate 'line', 168
  # rx pass
    rx361_cur."!cursor_pass"(rx361_pos, "block")
    if_null rx361_debug, debug_691
    rx361_cur."!cursor_debug"("PASS", "block", " at pos=", rx361_pos)
  debug_691:
    .return (rx361_cur)
  rx361_restart:
.annotate 'line', 10
    if_null rx361_debug, debug_692
    rx361_cur."!cursor_debug"("NEXT", "block")
  debug_692:
  rx361_fail:
    (rx361_rep, rx361_pos, $I10, $P10) = rx361_cur."!mark_fail"(0)
    lt rx361_pos, -1, rx361_done
    eq rx361_pos, -1, rx361_fail
    jump $I10
  rx361_done:
    rx361_cur."!cursor_fail"()
    if_null rx361_debug, debug_693
    rx361_cur."!cursor_debug"("FAIL", "block")
  debug_693:
    .return (rx361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1303739803.72") :method
.annotate 'line', 10
    $P363 = self."!PREFIX__!subrule"("panic", "")
    new $P364, "ResizablePMCArray"
    push $P364, $P363
    push $P364, "{"
    .return ($P364)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx368_tgt
    .local int rx368_pos
    .local int rx368_off
    .local int rx368_eos
    .local int rx368_rep
    .local pmc rx368_cur
    .local pmc rx368_debug
    (rx368_cur, rx368_pos, rx368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx368_cur
    .local pmc match
    .lex "$/", match
    length rx368_eos, rx368_tgt
    gt rx368_pos, rx368_eos, rx368_done
    set rx368_off, 0
    lt rx368_pos, 2, rx368_start
    sub rx368_off, rx368_pos, 1
    substr rx368_tgt, rx368_tgt, rx368_off
  rx368_start:
    eq $I10, 1, rx368_restart
    if_null rx368_debug, debug_694
    rx368_cur."!cursor_debug"("START", "blockoid")
  debug_694:
    $I10 = self.'from'()
    ne $I10, -1, rxscan372_done
    goto rxscan372_scan
  rxscan372_loop:
    (rx368_pos) = rx368_cur."from"()
    inc rx368_pos
    rx368_cur."!cursor_from"(rx368_pos)
    ge rx368_pos, rx368_eos, rxscan372_done
  rxscan372_scan:
    set_addr $I10, rxscan372_loop
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
  rxscan372_done:
.annotate 'line', 175
  # rx subrule "finishpad" subtype=method negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."finishpad"()
    unless $P10, rx368_fail
    rx368_pos = $P10."pos"()
  alt373_0:
.annotate 'line', 176
    set_addr $I10, alt373_1
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
.annotate 'line', 177
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx368_pos, 14
    gt $I11, rx368_eos, rx368_fail
    sub $I11, rx368_pos, rx368_off
    substr $S10, rx368_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx368_fail
    add rx368_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."you_are_here"()
    unless $P10, rx368_fail
    rx368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx368_pos = $P10."pos"()
    goto alt373_end
  alt373_1:
.annotate 'line', 178
  # rx literal  "{"
    add $I11, rx368_pos, 1
    gt $I11, rx368_eos, rx368_fail
    sub $I11, rx368_pos, rx368_off
    ord $I11, rx368_tgt, $I11
    ne $I11, 123, rx368_fail
    add rx368_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."statementlist"()
    unless $P10, rx368_fail
    rx368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx368_pos = $P10."pos"()
  alt374_0:
    set_addr $I10, alt374_1
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
  # rx literal  "}"
    add $I11, rx368_pos, 1
    gt $I11, rx368_eos, rx368_fail
    sub $I11, rx368_pos, rx368_off
    ord $I11, rx368_tgt, $I11
    ne $I11, 125, rx368_fail
    add rx368_pos, 1
    goto alt374_end
  alt374_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."FAILGOAL"("'}'")
    unless $P10, rx368_fail
    goto rxsubrule376_pass
  rxsubrule376_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx368_fail
  rxsubrule376_pass:
    set_addr $I10, rxsubrule376_back
    rx368_cur."!mark_push"(0, rx368_pos, $I10, $P10)
    rx368_pos = $P10."pos"()
  alt374_end:
  alt373_end:
.annotate 'line', 180
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."ENDSTMT"()
    unless $P10, rx368_fail
.annotate 'line', 174
  # rx pass
    rx368_cur."!cursor_pass"(rx368_pos, "blockoid")
    if_null rx368_debug, debug_695
    rx368_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx368_pos)
  debug_695:
    .return (rx368_cur)
  rx368_restart:
.annotate 'line', 10
    if_null rx368_debug, debug_696
    rx368_cur."!cursor_debug"("NEXT", "blockoid")
  debug_696:
  rx368_fail:
    (rx368_rep, rx368_pos, $I10, $P10) = rx368_cur."!mark_fail"(0)
    lt rx368_pos, -1, rx368_done
    eq rx368_pos, -1, rx368_fail
    jump $I10
  rx368_done:
    rx368_cur."!cursor_fail"()
    if_null rx368_debug, debug_697
    rx368_cur."!cursor_debug"("FAIL", "blockoid")
  debug_697:
    .return (rx368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1303739803.72") :method
.annotate 'line', 10
    $P370 = self."!PREFIX__!subrule"("finishpad", "")
    new $P371, "ResizablePMCArray"
    push $P371, $P370
    .return ($P371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx378_tgt
    .local int rx378_pos
    .local int rx378_off
    .local int rx378_eos
    .local int rx378_rep
    .local pmc rx378_cur
    .local pmc rx378_debug
    (rx378_cur, rx378_pos, rx378_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx378_cur
    .local pmc match
    .lex "$/", match
    length rx378_eos, rx378_tgt
    gt rx378_pos, rx378_eos, rx378_done
    set rx378_off, 0
    lt rx378_pos, 2, rx378_start
    sub rx378_off, rx378_pos, 1
    substr rx378_tgt, rx378_tgt, rx378_off
  rx378_start:
    eq $I10, 1, rx378_restart
    if_null rx378_debug, debug_698
    rx378_cur."!cursor_debug"("START", "newpad")
  debug_698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan381_done
    goto rxscan381_scan
  rxscan381_loop:
    (rx378_pos) = rx378_cur."from"()
    inc rx378_pos
    rx378_cur."!cursor_from"(rx378_pos)
    ge rx378_pos, rx378_eos, rxscan381_done
  rxscan381_scan:
    set_addr $I10, rxscan381_loop
    rx378_cur."!mark_push"(0, rx378_pos, $I10)
  rxscan381_done:
.annotate 'line', 183
  # rx pass
    rx378_cur."!cursor_pass"(rx378_pos, "newpad")
    if_null rx378_debug, debug_699
    rx378_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx378_pos)
  debug_699:
    .return (rx378_cur)
  rx378_restart:
.annotate 'line', 10
    if_null rx378_debug, debug_700
    rx378_cur."!cursor_debug"("NEXT", "newpad")
  debug_700:
  rx378_fail:
    (rx378_rep, rx378_pos, $I10, $P10) = rx378_cur."!mark_fail"(0)
    lt rx378_pos, -1, rx378_done
    eq rx378_pos, -1, rx378_fail
    jump $I10
  rx378_done:
    rx378_cur."!cursor_fail"()
    if_null rx378_debug, debug_701
    rx378_cur."!cursor_debug"("FAIL", "newpad")
  debug_701:
    .return (rx378_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1303739803.72") :method
.annotate 'line', 10
    new $P380, "ResizablePMCArray"
    push $P380, ""
    .return ($P380)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx383_tgt
    .local int rx383_pos
    .local int rx383_off
    .local int rx383_eos
    .local int rx383_rep
    .local pmc rx383_cur
    .local pmc rx383_debug
    (rx383_cur, rx383_pos, rx383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx383_cur
    .local pmc match
    .lex "$/", match
    length rx383_eos, rx383_tgt
    gt rx383_pos, rx383_eos, rx383_done
    set rx383_off, 0
    lt rx383_pos, 2, rx383_start
    sub rx383_off, rx383_pos, 1
    substr rx383_tgt, rx383_tgt, rx383_off
  rx383_start:
    eq $I10, 1, rx383_restart
    if_null rx383_debug, debug_702
    rx383_cur."!cursor_debug"("START", "outerctx")
  debug_702:
    $I10 = self.'from'()
    ne $I10, -1, rxscan386_done
    goto rxscan386_scan
  rxscan386_loop:
    (rx383_pos) = rx383_cur."from"()
    inc rx383_pos
    rx383_cur."!cursor_from"(rx383_pos)
    ge rx383_pos, rx383_eos, rxscan386_done
  rxscan386_scan:
    set_addr $I10, rxscan386_loop
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  rxscan386_done:
.annotate 'line', 184
  # rx pass
    rx383_cur."!cursor_pass"(rx383_pos, "outerctx")
    if_null rx383_debug, debug_703
    rx383_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx383_pos)
  debug_703:
    .return (rx383_cur)
  rx383_restart:
.annotate 'line', 10
    if_null rx383_debug, debug_704
    rx383_cur."!cursor_debug"("NEXT", "outerctx")
  debug_704:
  rx383_fail:
    (rx383_rep, rx383_pos, $I10, $P10) = rx383_cur."!mark_fail"(0)
    lt rx383_pos, -1, rx383_done
    eq rx383_pos, -1, rx383_fail
    jump $I10
  rx383_done:
    rx383_cur."!cursor_fail"()
    if_null rx383_debug, debug_705
    rx383_cur."!cursor_debug"("FAIL", "outerctx")
  debug_705:
    .return (rx383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1303739803.72") :method
.annotate 'line', 10
    new $P385, "ResizablePMCArray"
    push $P385, ""
    .return ($P385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx388_tgt
    .local int rx388_pos
    .local int rx388_off
    .local int rx388_eos
    .local int rx388_rep
    .local pmc rx388_cur
    .local pmc rx388_debug
    (rx388_cur, rx388_pos, rx388_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx388_cur
    .local pmc match
    .lex "$/", match
    length rx388_eos, rx388_tgt
    gt rx388_pos, rx388_eos, rx388_done
    set rx388_off, 0
    lt rx388_pos, 2, rx388_start
    sub rx388_off, rx388_pos, 1
    substr rx388_tgt, rx388_tgt, rx388_off
  rx388_start:
    eq $I10, 1, rx388_restart
    if_null rx388_debug, debug_706
    rx388_cur."!cursor_debug"("START", "GLOBALish")
  debug_706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan391_done
    goto rxscan391_scan
  rxscan391_loop:
    (rx388_pos) = rx388_cur."from"()
    inc rx388_pos
    rx388_cur."!cursor_from"(rx388_pos)
    ge rx388_pos, rx388_eos, rxscan391_done
  rxscan391_scan:
    set_addr $I10, rxscan391_loop
    rx388_cur."!mark_push"(0, rx388_pos, $I10)
  rxscan391_done:
.annotate 'line', 185
  # rx pass
    rx388_cur."!cursor_pass"(rx388_pos, "GLOBALish")
    if_null rx388_debug, debug_707
    rx388_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx388_pos)
  debug_707:
    .return (rx388_cur)
  rx388_restart:
.annotate 'line', 10
    if_null rx388_debug, debug_708
    rx388_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_708:
  rx388_fail:
    (rx388_rep, rx388_pos, $I10, $P10) = rx388_cur."!mark_fail"(0)
    lt rx388_pos, -1, rx388_done
    eq rx388_pos, -1, rx388_fail
    jump $I10
  rx388_done:
    rx388_cur."!cursor_fail"()
    if_null rx388_debug, debug_709
    rx388_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_709:
    .return (rx388_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1303739803.72") :method
.annotate 'line', 10
    new $P390, "ResizablePMCArray"
    push $P390, ""
    .return ($P390)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx393_tgt
    .local int rx393_pos
    .local int rx393_off
    .local int rx393_eos
    .local int rx393_rep
    .local pmc rx393_cur
    .local pmc rx393_debug
    (rx393_cur, rx393_pos, rx393_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx393_cur
    .local pmc match
    .lex "$/", match
    length rx393_eos, rx393_tgt
    gt rx393_pos, rx393_eos, rx393_done
    set rx393_off, 0
    lt rx393_pos, 2, rx393_start
    sub rx393_off, rx393_pos, 1
    substr rx393_tgt, rx393_tgt, rx393_off
  rx393_start:
    eq $I10, 1, rx393_restart
    if_null rx393_debug, debug_710
    rx393_cur."!cursor_debug"("START", "finishpad")
  debug_710:
    $I10 = self.'from'()
    ne $I10, -1, rxscan396_done
    goto rxscan396_scan
  rxscan396_loop:
    (rx393_pos) = rx393_cur."from"()
    inc rx393_pos
    rx393_cur."!cursor_from"(rx393_pos)
    ge rx393_pos, rx393_eos, rxscan396_done
  rxscan396_scan:
    set_addr $I10, rxscan396_loop
    rx393_cur."!mark_push"(0, rx393_pos, $I10)
  rxscan396_done:
.annotate 'line', 186
  # rx pass
    rx393_cur."!cursor_pass"(rx393_pos, "finishpad")
    if_null rx393_debug, debug_711
    rx393_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx393_pos)
  debug_711:
    .return (rx393_cur)
  rx393_restart:
.annotate 'line', 10
    if_null rx393_debug, debug_712
    rx393_cur."!cursor_debug"("NEXT", "finishpad")
  debug_712:
  rx393_fail:
    (rx393_rep, rx393_pos, $I10, $P10) = rx393_cur."!mark_fail"(0)
    lt rx393_pos, -1, rx393_done
    eq rx393_pos, -1, rx393_fail
    jump $I10
  rx393_done:
    rx393_cur."!cursor_fail"()
    if_null rx393_debug, debug_713
    rx393_cur."!cursor_debug"("FAIL", "finishpad")
  debug_713:
    .return (rx393_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1303739803.72") :method
.annotate 'line', 10
    new $P395, "ResizablePMCArray"
    push $P395, ""
    .return ($P395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx398_tgt
    .local int rx398_pos
    .local int rx398_off
    .local int rx398_eos
    .local int rx398_rep
    .local pmc rx398_cur
    .local pmc rx398_debug
    (rx398_cur, rx398_pos, rx398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx398_cur
    .local pmc match
    .lex "$/", match
    length rx398_eos, rx398_tgt
    gt rx398_pos, rx398_eos, rx398_done
    set rx398_off, 0
    lt rx398_pos, 2, rx398_start
    sub rx398_off, rx398_pos, 1
    substr rx398_tgt, rx398_tgt, rx398_off
  rx398_start:
    eq $I10, 1, rx398_restart
    if_null rx398_debug, debug_714
    rx398_cur."!cursor_debug"("START", "you_are_here")
  debug_714:
    $I10 = self.'from'()
    ne $I10, -1, rxscan401_done
    goto rxscan401_scan
  rxscan401_loop:
    (rx398_pos) = rx398_cur."from"()
    inc rx398_pos
    rx398_cur."!cursor_from"(rx398_pos)
    ge rx398_pos, rx398_eos, rxscan401_done
  rxscan401_scan:
    set_addr $I10, rxscan401_loop
    rx398_cur."!mark_push"(0, rx398_pos, $I10)
  rxscan401_done:
.annotate 'line', 187
  # rx pass
    rx398_cur."!cursor_pass"(rx398_pos, "you_are_here")
    if_null rx398_debug, debug_715
    rx398_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx398_pos)
  debug_715:
    .return (rx398_cur)
  rx398_restart:
.annotate 'line', 10
    if_null rx398_debug, debug_716
    rx398_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_716:
  rx398_fail:
    (rx398_rep, rx398_pos, $I10, $P10) = rx398_cur."!mark_fail"(0)
    lt rx398_pos, -1, rx398_done
    eq rx398_pos, -1, rx398_fail
    jump $I10
  rx398_done:
    rx398_cur."!cursor_fail"()
    if_null rx398_debug, debug_717
    rx398_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_717:
    .return (rx398_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1303739803.72") :method
.annotate 'line', 10
    new $P400, "ResizablePMCArray"
    push $P400, ""
    .return ($P400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1303739803.72")
    .param pmc param_403
.annotate 'line', 189
    .lex "self", param_403
    $P404 = param_403."!protoregex"("terminator")
    .return ($P404)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1303739803.72")
    .param pmc param_406
.annotate 'line', 189
    .lex "self", param_406
    $P407 = param_406."!PREFIX__!protoregex"("terminator")
    .return ($P407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx409_tgt
    .local int rx409_pos
    .local int rx409_off
    .local int rx409_eos
    .local int rx409_rep
    .local pmc rx409_cur
    .local pmc rx409_debug
    (rx409_cur, rx409_pos, rx409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx409_cur
    .local pmc match
    .lex "$/", match
    length rx409_eos, rx409_tgt
    gt rx409_pos, rx409_eos, rx409_done
    set rx409_off, 0
    lt rx409_pos, 2, rx409_start
    sub rx409_off, rx409_pos, 1
    substr rx409_tgt, rx409_tgt, rx409_off
  rx409_start:
    eq $I10, 1, rx409_restart
    if_null rx409_debug, debug_718
    rx409_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_718:
    $I10 = self.'from'()
    ne $I10, -1, rxscan412_done
    goto rxscan412_scan
  rxscan412_loop:
    (rx409_pos) = rx409_cur."from"()
    inc rx409_pos
    rx409_cur."!cursor_from"(rx409_pos)
    ge rx409_pos, rx409_eos, rxscan412_done
  rxscan412_scan:
    set_addr $I10, rxscan412_loop
    rx409_cur."!mark_push"(0, rx409_pos, $I10)
  rxscan412_done:
.annotate 'line', 191
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx409_pos, rx409_off
    substr $S10, rx409_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx409_fail
  # rx pass
    rx409_cur."!cursor_pass"(rx409_pos, "terminator:sym<;>")
    if_null rx409_debug, debug_719
    rx409_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx409_pos)
  debug_719:
    .return (rx409_cur)
  rx409_restart:
.annotate 'line', 10
    if_null rx409_debug, debug_720
    rx409_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_720:
  rx409_fail:
    (rx409_rep, rx409_pos, $I10, $P10) = rx409_cur."!mark_fail"(0)
    lt rx409_pos, -1, rx409_done
    eq rx409_pos, -1, rx409_fail
    jump $I10
  rx409_done:
    rx409_cur."!cursor_fail"()
    if_null rx409_debug, debug_721
    rx409_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_721:
    .return (rx409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1303739803.72") :method
.annotate 'line', 10
    new $P411, "ResizablePMCArray"
    push $P411, ";"
    .return ($P411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx414_tgt
    .local int rx414_pos
    .local int rx414_off
    .local int rx414_eos
    .local int rx414_rep
    .local pmc rx414_cur
    .local pmc rx414_debug
    (rx414_cur, rx414_pos, rx414_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx414_cur
    .local pmc match
    .lex "$/", match
    length rx414_eos, rx414_tgt
    gt rx414_pos, rx414_eos, rx414_done
    set rx414_off, 0
    lt rx414_pos, 2, rx414_start
    sub rx414_off, rx414_pos, 1
    substr rx414_tgt, rx414_tgt, rx414_off
  rx414_start:
    eq $I10, 1, rx414_restart
    if_null rx414_debug, debug_722
    rx414_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_722:
    $I10 = self.'from'()
    ne $I10, -1, rxscan417_done
    goto rxscan417_scan
  rxscan417_loop:
    (rx414_pos) = rx414_cur."from"()
    inc rx414_pos
    rx414_cur."!cursor_from"(rx414_pos)
    ge rx414_pos, rx414_eos, rxscan417_done
  rxscan417_scan:
    set_addr $I10, rxscan417_loop
    rx414_cur."!mark_push"(0, rx414_pos, $I10)
  rxscan417_done:
.annotate 'line', 192
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx414_pos, rx414_off
    substr $S10, rx414_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx414_fail
  # rx pass
    rx414_cur."!cursor_pass"(rx414_pos, "terminator:sym<}>")
    if_null rx414_debug, debug_723
    rx414_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx414_pos)
  debug_723:
    .return (rx414_cur)
  rx414_restart:
.annotate 'line', 10
    if_null rx414_debug, debug_724
    rx414_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_724:
  rx414_fail:
    (rx414_rep, rx414_pos, $I10, $P10) = rx414_cur."!mark_fail"(0)
    lt rx414_pos, -1, rx414_done
    eq rx414_pos, -1, rx414_fail
    jump $I10
  rx414_done:
    rx414_cur."!cursor_fail"()
    if_null rx414_debug, debug_725
    rx414_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_725:
    .return (rx414_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1303739803.72") :method
.annotate 'line', 10
    new $P416, "ResizablePMCArray"
    push $P416, "}"
    .return ($P416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1303739803.72")
    .param pmc param_419
.annotate 'line', 196
    .lex "self", param_419
    $P420 = param_419."!protoregex"("statement_control")
    .return ($P420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1303739803.72")
    .param pmc param_422
.annotate 'line', 196
    .lex "self", param_422
    $P423 = param_422."!PREFIX__!protoregex"("statement_control")
    .return ($P423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx425_tgt
    .local int rx425_pos
    .local int rx425_off
    .local int rx425_eos
    .local int rx425_rep
    .local pmc rx425_cur
    .local pmc rx425_debug
    (rx425_cur, rx425_pos, rx425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx425_cur
    .local pmc match
    .lex "$/", match
    length rx425_eos, rx425_tgt
    gt rx425_pos, rx425_eos, rx425_done
    set rx425_off, 0
    lt rx425_pos, 2, rx425_start
    sub rx425_off, rx425_pos, 1
    substr rx425_tgt, rx425_tgt, rx425_off
  rx425_start:
    eq $I10, 1, rx425_restart
    if_null rx425_debug, debug_726
    rx425_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_726:
    $I10 = self.'from'()
    ne $I10, -1, rxscan428_done
    goto rxscan428_scan
  rxscan428_loop:
    (rx425_pos) = rx425_cur."from"()
    inc rx425_pos
    rx425_cur."!cursor_from"(rx425_pos)
    ge rx425_pos, rx425_eos, rxscan428_done
  rxscan428_scan:
    set_addr $I10, rxscan428_loop
    rx425_cur."!mark_push"(0, rx425_pos, $I10)
  rxscan428_done:
.annotate 'line', 199
  # rx subcapture "sym"
    set_addr $I10, rxcap_429_fail
    rx425_cur."!mark_push"(0, rx425_pos, $I10)
  # rx literal  "use"
    add $I11, rx425_pos, 3
    gt $I11, rx425_eos, rx425_fail
    sub $I11, rx425_pos, rx425_off
    substr $S10, rx425_tgt, $I11, 3
    ne $S10, "use", rx425_fail
    add rx425_pos, 3
    set_addr $I10, rxcap_429_fail
    ($I12, $I11) = rx425_cur."!mark_peek"($I10)
    rx425_cur."!cursor_pos"($I11)
    ($P10) = rx425_cur."!cursor_start"()
    $P10."!cursor_pass"(rx425_pos, "")
    rx425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_429_done
  rxcap_429_fail:
    goto rx425_fail
  rxcap_429_done:
  # rx charclass s
    ge rx425_pos, rx425_eos, rx425_fail
    sub $I10, rx425_pos, rx425_off
    is_cclass $I11, 32, rx425_tgt, $I10
    unless $I11, rx425_fail
    inc rx425_pos
  # rx subrule "ws" subtype=method negate=
    rx425_cur."!cursor_pos"(rx425_pos)
    $P10 = rx425_cur."ws"()
    unless $P10, rx425_fail
    rx425_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx425_cur."!cursor_pos"(rx425_pos)
    $P10 = rx425_cur."name"()
    unless $P10, rx425_fail
    rx425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx425_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx425_cur."!cursor_pos"(rx425_pos)
    $P10 = rx425_cur."ws"()
    unless $P10, rx425_fail
    rx425_pos = $P10."pos"()
.annotate 'line', 198
  # rx pass
    rx425_cur."!cursor_pass"(rx425_pos, "statement_control:sym<use>")
    if_null rx425_debug, debug_727
    rx425_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx425_pos)
  debug_727:
    .return (rx425_cur)
  rx425_restart:
.annotate 'line', 10
    if_null rx425_debug, debug_728
    rx425_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_728:
  rx425_fail:
    (rx425_rep, rx425_pos, $I10, $P10) = rx425_cur."!mark_fail"(0)
    lt rx425_pos, -1, rx425_done
    eq rx425_pos, -1, rx425_fail
    jump $I10
  rx425_done:
    rx425_cur."!cursor_fail"()
    if_null rx425_debug, debug_729
    rx425_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_729:
    .return (rx425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1303739803.72") :method
.annotate 'line', 10
    new $P427, "ResizablePMCArray"
    push $P427, "use"
    .return ($P427)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx433_tgt
    .local int rx433_pos
    .local int rx433_off
    .local int rx433_eos
    .local int rx433_rep
    .local pmc rx433_cur
    .local pmc rx433_debug
    (rx433_cur, rx433_pos, rx433_tgt, $I10) = self."!cursor_start"()
    rx433_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx433_cur
    .local pmc match
    .lex "$/", match
    length rx433_eos, rx433_tgt
    gt rx433_pos, rx433_eos, rx433_done
    set rx433_off, 0
    lt rx433_pos, 2, rx433_start
    sub rx433_off, rx433_pos, 1
    substr rx433_tgt, rx433_tgt, rx433_off
  rx433_start:
    eq $I10, 1, rx433_restart
    if_null rx433_debug, debug_730
    rx433_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_730:
    $I10 = self.'from'()
    ne $I10, -1, rxscan436_done
    goto rxscan436_scan
  rxscan436_loop:
    (rx433_pos) = rx433_cur."from"()
    inc rx433_pos
    rx433_cur."!cursor_from"(rx433_pos)
    ge rx433_pos, rx433_eos, rxscan436_done
  rxscan436_scan:
    set_addr $I10, rxscan436_loop
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  rxscan436_done:
.annotate 'line', 203
  # rx subcapture "sym"
    set_addr $I10, rxcap_437_fail
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  # rx literal  "if"
    add $I11, rx433_pos, 2
    gt $I11, rx433_eos, rx433_fail
    sub $I11, rx433_pos, rx433_off
    substr $S10, rx433_tgt, $I11, 2
    ne $S10, "if", rx433_fail
    add rx433_pos, 2
    set_addr $I10, rxcap_437_fail
    ($I12, $I11) = rx433_cur."!mark_peek"($I10)
    rx433_cur."!cursor_pos"($I11)
    ($P10) = rx433_cur."!cursor_start"()
    $P10."!cursor_pass"(rx433_pos, "")
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_437_done
  rxcap_437_fail:
    goto rx433_fail
  rxcap_437_done:
  # rx charclass s
    ge rx433_pos, rx433_eos, rx433_fail
    sub $I10, rx433_pos, rx433_off
    is_cclass $I11, 32, rx433_tgt, $I10
    unless $I11, rx433_fail
    inc rx433_pos
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 204
  # rx subrule "xblock" subtype=capture negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."xblock"()
    unless $P10, rx433_fail
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 205
  # rx rxquantr440 ** 0..*
    set_addr $I10, rxquantr440_done
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  rxquantr440_loop:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx433_pos, 5
    gt $I11, rx433_eos, rx433_fail
    sub $I11, rx433_pos, rx433_off
    substr $S10, rx433_tgt, $I11, 5
    ne $S10, "elsif", rx433_fail
    add rx433_pos, 5
  # rx charclass s
    ge rx433_pos, rx433_eos, rx433_fail
    sub $I10, rx433_pos, rx433_off
    is_cclass $I11, 32, rx433_tgt, $I10
    unless $I11, rx433_fail
    inc rx433_pos
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."xblock"()
    unless $P10, rx433_fail
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
    set_addr $I10, rxquantr440_done
    (rx433_rep) = rx433_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr440_done
    rx433_cur."!mark_push"(rx433_rep, rx433_pos, $I10)
    goto rxquantr440_loop
  rxquantr440_done:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 206
  # rx rxquantr445 ** 0..1
    set_addr $I10, rxquantr445_done
    rx433_cur."!mark_push"(0, rx433_pos, $I10)
  rxquantr445_loop:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx433_pos, 4
    gt $I11, rx433_eos, rx433_fail
    sub $I11, rx433_pos, rx433_off
    substr $S10, rx433_tgt, $I11, 4
    ne $S10, "else", rx433_fail
    add rx433_pos, 4
  # rx charclass s
    ge rx433_pos, rx433_eos, rx433_fail
    sub $I10, rx433_pos, rx433_off
    is_cclass $I11, 32, rx433_tgt, $I10
    unless $I11, rx433_fail
    inc rx433_pos
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."pblock"()
    unless $P10, rx433_fail
    rx433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
    set_addr $I10, rxquantr445_done
    (rx433_rep) = rx433_cur."!mark_commit"($I10)
  rxquantr445_done:
  # rx subrule "ws" subtype=method negate=
    rx433_cur."!cursor_pos"(rx433_pos)
    $P10 = rx433_cur."ws"()
    unless $P10, rx433_fail
    rx433_pos = $P10."pos"()
.annotate 'line', 202
  # rx pass
    rx433_cur."!cursor_pass"(rx433_pos, "statement_control:sym<if>")
    if_null rx433_debug, debug_731
    rx433_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx433_pos)
  debug_731:
    .return (rx433_cur)
  rx433_restart:
.annotate 'line', 10
    if_null rx433_debug, debug_732
    rx433_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_732:
  rx433_fail:
    (rx433_rep, rx433_pos, $I10, $P10) = rx433_cur."!mark_fail"(0)
    lt rx433_pos, -1, rx433_done
    eq rx433_pos, -1, rx433_fail
    jump $I10
  rx433_done:
    rx433_cur."!cursor_fail"()
    if_null rx433_debug, debug_733
    rx433_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_733:
    .return (rx433_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1303739803.72") :method
.annotate 'line', 10
    new $P435, "ResizablePMCArray"
    push $P435, "if"
    .return ($P435)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P461 = "73_1303739803.72" 
    capture_lex $P461
    .local string rx451_tgt
    .local int rx451_pos
    .local int rx451_off
    .local int rx451_eos
    .local int rx451_rep
    .local pmc rx451_cur
    .local pmc rx451_debug
    (rx451_cur, rx451_pos, rx451_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx451_cur
    .local pmc match
    .lex "$/", match
    length rx451_eos, rx451_tgt
    gt rx451_pos, rx451_eos, rx451_done
    set rx451_off, 0
    lt rx451_pos, 2, rx451_start
    sub rx451_off, rx451_pos, 1
    substr rx451_tgt, rx451_tgt, rx451_off
  rx451_start:
    eq $I10, 1, rx451_restart
    if_null rx451_debug, debug_734
    rx451_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_734:
    $I10 = self.'from'()
    ne $I10, -1, rxscan454_done
    goto rxscan454_scan
  rxscan454_loop:
    (rx451_pos) = rx451_cur."from"()
    inc rx451_pos
    rx451_cur."!cursor_from"(rx451_pos)
    ge rx451_pos, rx451_eos, rxscan454_done
  rxscan454_scan:
    set_addr $I10, rxscan454_loop
    rx451_cur."!mark_push"(0, rx451_pos, $I10)
  rxscan454_done:
.annotate 'line', 210
  # rx subcapture "sym"
    set_addr $I10, rxcap_455_fail
    rx451_cur."!mark_push"(0, rx451_pos, $I10)
  # rx literal  "unless"
    add $I11, rx451_pos, 6
    gt $I11, rx451_eos, rx451_fail
    sub $I11, rx451_pos, rx451_off
    substr $S10, rx451_tgt, $I11, 6
    ne $S10, "unless", rx451_fail
    add rx451_pos, 6
    set_addr $I10, rxcap_455_fail
    ($I12, $I11) = rx451_cur."!mark_peek"($I10)
    rx451_cur."!cursor_pos"($I11)
    ($P10) = rx451_cur."!cursor_start"()
    $P10."!cursor_pass"(rx451_pos, "")
    rx451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_455_done
  rxcap_455_fail:
    goto rx451_fail
  rxcap_455_done:
  # rx charclass s
    ge rx451_pos, rx451_eos, rx451_fail
    sub $I10, rx451_pos, rx451_off
    is_cclass $I11, 32, rx451_tgt, $I10
    unless $I11, rx451_fail
    inc rx451_pos
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
.annotate 'line', 211
  # rx subrule "xblock" subtype=capture negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."xblock"()
    unless $P10, rx451_fail
    rx451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx451_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  alt458_0:
.annotate 'line', 212
    set_addr $I10, alt458_1
    rx451_cur."!mark_push"(0, rx451_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx451_cur."!cursor_pos"(rx451_pos)
    .const 'Sub' $P461 = "73_1303739803.72" 
    capture_lex $P461
    $P10 = rx451_cur."before"($P461)
    if $P10, rx451_fail
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
    goto alt458_end
  alt458_1:
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
  alt458_end:
  # rx subrule "ws" subtype=method negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."ws"()
    unless $P10, rx451_fail
    rx451_pos = $P10."pos"()
.annotate 'line', 209
  # rx pass
    rx451_cur."!cursor_pass"(rx451_pos, "statement_control:sym<unless>")
    if_null rx451_debug, debug_739
    rx451_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx451_pos)
  debug_739:
    .return (rx451_cur)
  rx451_restart:
.annotate 'line', 10
    if_null rx451_debug, debug_740
    rx451_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_740:
  rx451_fail:
    (rx451_rep, rx451_pos, $I10, $P10) = rx451_cur."!mark_fail"(0)
    lt rx451_pos, -1, rx451_done
    eq rx451_pos, -1, rx451_fail
    jump $I10
  rx451_done:
    rx451_cur."!cursor_fail"()
    if_null rx451_debug, debug_741
    rx451_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_741:
    .return (rx451_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1303739803.72") :method
.annotate 'line', 10
    new $P453, "ResizablePMCArray"
    push $P453, "unless"
    .return ($P453)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block460"  :anon :subid("73_1303739803.72") :method :outer("71_1303739803.72")
.annotate 'line', 212
    .local string rx462_tgt
    .local int rx462_pos
    .local int rx462_off
    .local int rx462_eos
    .local int rx462_rep
    .local pmc rx462_cur
    .local pmc rx462_debug
    (rx462_cur, rx462_pos, rx462_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx462_cur
    .local pmc match
    .lex "$/", match
    length rx462_eos, rx462_tgt
    gt rx462_pos, rx462_eos, rx462_done
    set rx462_off, 0
    lt rx462_pos, 2, rx462_start
    sub rx462_off, rx462_pos, 1
    substr rx462_tgt, rx462_tgt, rx462_off
  rx462_start:
    eq $I10, 1, rx462_restart
    if_null rx462_debug, debug_735
    rx462_cur."!cursor_debug"("START", "")
  debug_735:
    $I10 = self.'from'()
    ne $I10, -1, rxscan463_done
    goto rxscan463_scan
  rxscan463_loop:
    (rx462_pos) = rx462_cur."from"()
    inc rx462_pos
    rx462_cur."!cursor_from"(rx462_pos)
    ge rx462_pos, rx462_eos, rxscan463_done
  rxscan463_scan:
    set_addr $I10, rxscan463_loop
    rx462_cur."!mark_push"(0, rx462_pos, $I10)
  rxscan463_done:
  # rx literal  "else"
    add $I11, rx462_pos, 4
    gt $I11, rx462_eos, rx462_fail
    sub $I11, rx462_pos, rx462_off
    substr $S10, rx462_tgt, $I11, 4
    ne $S10, "else", rx462_fail
    add rx462_pos, 4
  # rx pass
    rx462_cur."!cursor_pass"(rx462_pos, "")
    if_null rx462_debug, debug_736
    rx462_cur."!cursor_debug"("PASS", "", " at pos=", rx462_pos)
  debug_736:
    .return (rx462_cur)
  rx462_restart:
    if_null rx462_debug, debug_737
    rx462_cur."!cursor_debug"("NEXT", "")
  debug_737:
  rx462_fail:
    (rx462_rep, rx462_pos, $I10, $P10) = rx462_cur."!mark_fail"(0)
    lt rx462_pos, -1, rx462_done
    eq rx462_pos, -1, rx462_fail
    jump $I10
  rx462_done:
    rx462_cur."!cursor_fail"()
    if_null rx462_debug, debug_738
    rx462_cur."!cursor_debug"("FAIL", "")
  debug_738:
    .return (rx462_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx469_tgt
    .local int rx469_pos
    .local int rx469_off
    .local int rx469_eos
    .local int rx469_rep
    .local pmc rx469_cur
    .local pmc rx469_debug
    (rx469_cur, rx469_pos, rx469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx469_cur
    .local pmc match
    .lex "$/", match
    length rx469_eos, rx469_tgt
    gt rx469_pos, rx469_eos, rx469_done
    set rx469_off, 0
    lt rx469_pos, 2, rx469_start
    sub rx469_off, rx469_pos, 1
    substr rx469_tgt, rx469_tgt, rx469_off
  rx469_start:
    eq $I10, 1, rx469_restart
    if_null rx469_debug, debug_742
    rx469_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_742:
    $I10 = self.'from'()
    ne $I10, -1, rxscan472_done
    goto rxscan472_scan
  rxscan472_loop:
    (rx469_pos) = rx469_cur."from"()
    inc rx469_pos
    rx469_cur."!cursor_from"(rx469_pos)
    ge rx469_pos, rx469_eos, rxscan472_done
  rxscan472_scan:
    set_addr $I10, rxscan472_loop
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  rxscan472_done:
.annotate 'line', 216
  # rx subcapture "sym"
    set_addr $I10, rxcap_474_fail
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  alt473_0:
    set_addr $I10, alt473_1
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  # rx literal  "while"
    add $I11, rx469_pos, 5
    gt $I11, rx469_eos, rx469_fail
    sub $I11, rx469_pos, rx469_off
    substr $S10, rx469_tgt, $I11, 5
    ne $S10, "while", rx469_fail
    add rx469_pos, 5
    goto alt473_end
  alt473_1:
  # rx literal  "until"
    add $I11, rx469_pos, 5
    gt $I11, rx469_eos, rx469_fail
    sub $I11, rx469_pos, rx469_off
    substr $S10, rx469_tgt, $I11, 5
    ne $S10, "until", rx469_fail
    add rx469_pos, 5
  alt473_end:
    set_addr $I10, rxcap_474_fail
    ($I12, $I11) = rx469_cur."!mark_peek"($I10)
    rx469_cur."!cursor_pos"($I11)
    ($P10) = rx469_cur."!cursor_start"()
    $P10."!cursor_pass"(rx469_pos, "")
    rx469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_474_done
  rxcap_474_fail:
    goto rx469_fail
  rxcap_474_done:
  # rx charclass s
    ge rx469_pos, rx469_eos, rx469_fail
    sub $I10, rx469_pos, rx469_off
    is_cclass $I11, 32, rx469_tgt, $I10
    unless $I11, rx469_fail
    inc rx469_pos
  # rx subrule "ws" subtype=method negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."ws"()
    unless $P10, rx469_fail
    rx469_pos = $P10."pos"()
.annotate 'line', 217
  # rx subrule "xblock" subtype=capture negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."xblock"()
    unless $P10, rx469_fail
    rx469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx469_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."ws"()
    unless $P10, rx469_fail
    rx469_pos = $P10."pos"()
.annotate 'line', 215
  # rx pass
    rx469_cur."!cursor_pass"(rx469_pos, "statement_control:sym<while>")
    if_null rx469_debug, debug_743
    rx469_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx469_pos)
  debug_743:
    .return (rx469_cur)
  rx469_restart:
.annotate 'line', 10
    if_null rx469_debug, debug_744
    rx469_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_744:
  rx469_fail:
    (rx469_rep, rx469_pos, $I10, $P10) = rx469_cur."!mark_fail"(0)
    lt rx469_pos, -1, rx469_done
    eq rx469_pos, -1, rx469_fail
    jump $I10
  rx469_done:
    rx469_cur."!cursor_fail"()
    if_null rx469_debug, debug_745
    rx469_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_745:
    .return (rx469_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1303739803.72") :method
.annotate 'line', 10
    new $P471, "ResizablePMCArray"
    push $P471, "until"
    push $P471, "while"
    .return ($P471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx478_tgt
    .local int rx478_pos
    .local int rx478_off
    .local int rx478_eos
    .local int rx478_rep
    .local pmc rx478_cur
    .local pmc rx478_debug
    (rx478_cur, rx478_pos, rx478_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx478_cur
    .local pmc match
    .lex "$/", match
    length rx478_eos, rx478_tgt
    gt rx478_pos, rx478_eos, rx478_done
    set rx478_off, 0
    lt rx478_pos, 2, rx478_start
    sub rx478_off, rx478_pos, 1
    substr rx478_tgt, rx478_tgt, rx478_off
  rx478_start:
    eq $I10, 1, rx478_restart
    if_null rx478_debug, debug_746
    rx478_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_746:
    $I10 = self.'from'()
    ne $I10, -1, rxscan481_done
    goto rxscan481_scan
  rxscan481_loop:
    (rx478_pos) = rx478_cur."from"()
    inc rx478_pos
    rx478_cur."!cursor_from"(rx478_pos)
    ge rx478_pos, rx478_eos, rxscan481_done
  rxscan481_scan:
    set_addr $I10, rxscan481_loop
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  rxscan481_done:
.annotate 'line', 221
  # rx subcapture "sym"
    set_addr $I10, rxcap_482_fail
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx478_pos, 6
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 6
    ne $S10, "repeat", rx478_fail
    add rx478_pos, 6
    set_addr $I10, rxcap_482_fail
    ($I12, $I11) = rx478_cur."!mark_peek"($I10)
    rx478_cur."!cursor_pos"($I11)
    ($P10) = rx478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx478_pos, "")
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_482_done
  rxcap_482_fail:
    goto rx478_fail
  rxcap_482_done:
  # rx charclass s
    ge rx478_pos, rx478_eos, rx478_fail
    sub $I10, rx478_pos, rx478_off
    is_cclass $I11, 32, rx478_tgt, $I10
    unless $I11, rx478_fail
    inc rx478_pos
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  alt484_0:
.annotate 'line', 222
    set_addr $I10, alt484_1
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
.annotate 'line', 223
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_487_fail
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  alt486_0:
    set_addr $I10, alt486_1
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  # rx literal  "while"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "while", rx478_fail
    add rx478_pos, 5
    goto alt486_end
  alt486_1:
  # rx literal  "until"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "until", rx478_fail
    add rx478_pos, 5
  alt486_end:
    set_addr $I10, rxcap_487_fail
    ($I12, $I11) = rx478_cur."!mark_peek"($I10)
    rx478_cur."!cursor_pos"($I11)
    ($P10) = rx478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx478_pos, "")
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_487_done
  rxcap_487_fail:
    goto rx478_fail
  rxcap_487_done:
  # rx charclass s
    ge rx478_pos, rx478_eos, rx478_fail
    sub $I10, rx478_pos, rx478_off
    is_cclass $I11, 32, rx478_tgt, $I10
    unless $I11, rx478_fail
    inc rx478_pos
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."xblock"()
    unless $P10, rx478_fail
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx478_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
    goto alt484_end
  alt484_1:
.annotate 'line', 224
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."pblock"()
    unless $P10, rx478_fail
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx478_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_493_fail
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  alt492_0:
    set_addr $I10, alt492_1
    rx478_cur."!mark_push"(0, rx478_pos, $I10)
  # rx literal  "while"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "while", rx478_fail
    add rx478_pos, 5
    goto alt492_end
  alt492_1:
  # rx literal  "until"
    add $I11, rx478_pos, 5
    gt $I11, rx478_eos, rx478_fail
    sub $I11, rx478_pos, rx478_off
    substr $S10, rx478_tgt, $I11, 5
    ne $S10, "until", rx478_fail
    add rx478_pos, 5
  alt492_end:
    set_addr $I10, rxcap_493_fail
    ($I12, $I11) = rx478_cur."!mark_peek"($I10)
    rx478_cur."!cursor_pos"($I11)
    ($P10) = rx478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx478_pos, "")
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_493_done
  rxcap_493_fail:
    goto rx478_fail
  rxcap_493_done:
  # rx charclass s
    ge rx478_pos, rx478_eos, rx478_fail
    sub $I10, rx478_pos, rx478_off
    is_cclass $I11, 32, rx478_tgt, $I10
    unless $I11, rx478_fail
    inc rx478_pos
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."EXPR"()
    unless $P10, rx478_fail
    rx478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx478_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
  alt484_end:
.annotate 'line', 225
  # rx subrule "ws" subtype=method negate=
    rx478_cur."!cursor_pos"(rx478_pos)
    $P10 = rx478_cur."ws"()
    unless $P10, rx478_fail
    rx478_pos = $P10."pos"()
.annotate 'line', 220
  # rx pass
    rx478_cur."!cursor_pass"(rx478_pos, "statement_control:sym<repeat>")
    if_null rx478_debug, debug_747
    rx478_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx478_pos)
  debug_747:
    .return (rx478_cur)
  rx478_restart:
.annotate 'line', 10
    if_null rx478_debug, debug_748
    rx478_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_748:
  rx478_fail:
    (rx478_rep, rx478_pos, $I10, $P10) = rx478_cur."!mark_fail"(0)
    lt rx478_pos, -1, rx478_done
    eq rx478_pos, -1, rx478_fail
    jump $I10
  rx478_done:
    rx478_cur."!cursor_fail"()
    if_null rx478_debug, debug_749
    rx478_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_749:
    .return (rx478_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1303739803.72") :method
.annotate 'line', 10
    new $P480, "ResizablePMCArray"
    push $P480, "repeat"
    .return ($P480)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx498_tgt
    .local int rx498_pos
    .local int rx498_off
    .local int rx498_eos
    .local int rx498_rep
    .local pmc rx498_cur
    .local pmc rx498_debug
    (rx498_cur, rx498_pos, rx498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx498_cur
    .local pmc match
    .lex "$/", match
    length rx498_eos, rx498_tgt
    gt rx498_pos, rx498_eos, rx498_done
    set rx498_off, 0
    lt rx498_pos, 2, rx498_start
    sub rx498_off, rx498_pos, 1
    substr rx498_tgt, rx498_tgt, rx498_off
  rx498_start:
    eq $I10, 1, rx498_restart
    if_null rx498_debug, debug_750
    rx498_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_750:
    $I10 = self.'from'()
    ne $I10, -1, rxscan501_done
    goto rxscan501_scan
  rxscan501_loop:
    (rx498_pos) = rx498_cur."from"()
    inc rx498_pos
    rx498_cur."!cursor_from"(rx498_pos)
    ge rx498_pos, rx498_eos, rxscan501_done
  rxscan501_scan:
    set_addr $I10, rxscan501_loop
    rx498_cur."!mark_push"(0, rx498_pos, $I10)
  rxscan501_done:
.annotate 'line', 229
  # rx subcapture "sym"
    set_addr $I10, rxcap_502_fail
    rx498_cur."!mark_push"(0, rx498_pos, $I10)
  # rx literal  "for"
    add $I11, rx498_pos, 3
    gt $I11, rx498_eos, rx498_fail
    sub $I11, rx498_pos, rx498_off
    substr $S10, rx498_tgt, $I11, 3
    ne $S10, "for", rx498_fail
    add rx498_pos, 3
    set_addr $I10, rxcap_502_fail
    ($I12, $I11) = rx498_cur."!mark_peek"($I10)
    rx498_cur."!cursor_pos"($I11)
    ($P10) = rx498_cur."!cursor_start"()
    $P10."!cursor_pass"(rx498_pos, "")
    rx498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_502_done
  rxcap_502_fail:
    goto rx498_fail
  rxcap_502_done:
  # rx charclass s
    ge rx498_pos, rx498_eos, rx498_fail
    sub $I10, rx498_pos, rx498_off
    is_cclass $I11, 32, rx498_tgt, $I10
    unless $I11, rx498_fail
    inc rx498_pos
  # rx subrule "ws" subtype=method negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."ws"()
    unless $P10, rx498_fail
    rx498_pos = $P10."pos"()
.annotate 'line', 230
  # rx subrule "xblock" subtype=capture negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."xblock"()
    unless $P10, rx498_fail
    rx498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx498_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."ws"()
    unless $P10, rx498_fail
    rx498_pos = $P10."pos"()
.annotate 'line', 228
  # rx pass
    rx498_cur."!cursor_pass"(rx498_pos, "statement_control:sym<for>")
    if_null rx498_debug, debug_751
    rx498_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx498_pos)
  debug_751:
    .return (rx498_cur)
  rx498_restart:
.annotate 'line', 10
    if_null rx498_debug, debug_752
    rx498_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_752:
  rx498_fail:
    (rx498_rep, rx498_pos, $I10, $P10) = rx498_cur."!mark_fail"(0)
    lt rx498_pos, -1, rx498_done
    eq rx498_pos, -1, rx498_fail
    jump $I10
  rx498_done:
    rx498_cur."!cursor_fail"()
    if_null rx498_debug, debug_753
    rx498_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_753:
    .return (rx498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1303739803.72") :method
.annotate 'line', 10
    new $P500, "ResizablePMCArray"
    push $P500, "for"
    .return ($P500)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx506_tgt
    .local int rx506_pos
    .local int rx506_off
    .local int rx506_eos
    .local int rx506_rep
    .local pmc rx506_cur
    .local pmc rx506_debug
    (rx506_cur, rx506_pos, rx506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx506_cur
    .local pmc match
    .lex "$/", match
    length rx506_eos, rx506_tgt
    gt rx506_pos, rx506_eos, rx506_done
    set rx506_off, 0
    lt rx506_pos, 2, rx506_start
    sub rx506_off, rx506_pos, 1
    substr rx506_tgt, rx506_tgt, rx506_off
  rx506_start:
    eq $I10, 1, rx506_restart
    if_null rx506_debug, debug_754
    rx506_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_754:
    $I10 = self.'from'()
    ne $I10, -1, rxscan509_done
    goto rxscan509_scan
  rxscan509_loop:
    (rx506_pos) = rx506_cur."from"()
    inc rx506_pos
    rx506_cur."!cursor_from"(rx506_pos)
    ge rx506_pos, rx506_eos, rxscan509_done
  rxscan509_scan:
    set_addr $I10, rxscan509_loop
    rx506_cur."!mark_push"(0, rx506_pos, $I10)
  rxscan509_done:
.annotate 'line', 234
  # rx subcapture "sym"
    set_addr $I10, rxcap_510_fail
    rx506_cur."!mark_push"(0, rx506_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx506_pos, 5
    gt $I11, rx506_eos, rx506_fail
    sub $I11, rx506_pos, rx506_off
    substr $S10, rx506_tgt, $I11, 5
    ne $S10, "CATCH", rx506_fail
    add rx506_pos, 5
    set_addr $I10, rxcap_510_fail
    ($I12, $I11) = rx506_cur."!mark_peek"($I10)
    rx506_cur."!cursor_pos"($I11)
    ($P10) = rx506_cur."!cursor_start"()
    $P10."!cursor_pass"(rx506_pos, "")
    rx506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_510_done
  rxcap_510_fail:
    goto rx506_fail
  rxcap_510_done:
  # rx charclass s
    ge rx506_pos, rx506_eos, rx506_fail
    sub $I10, rx506_pos, rx506_off
    is_cclass $I11, 32, rx506_tgt, $I10
    unless $I11, rx506_fail
    inc rx506_pos
  # rx subrule "ws" subtype=method negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."ws"()
    unless $P10, rx506_fail
    rx506_pos = $P10."pos"()
.annotate 'line', 235
  # rx subrule "block" subtype=capture negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."block"()
    unless $P10, rx506_fail
    rx506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx506_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."ws"()
    unless $P10, rx506_fail
    rx506_pos = $P10."pos"()
.annotate 'line', 233
  # rx pass
    rx506_cur."!cursor_pass"(rx506_pos, "statement_control:sym<CATCH>")
    if_null rx506_debug, debug_755
    rx506_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx506_pos)
  debug_755:
    .return (rx506_cur)
  rx506_restart:
.annotate 'line', 10
    if_null rx506_debug, debug_756
    rx506_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_756:
  rx506_fail:
    (rx506_rep, rx506_pos, $I10, $P10) = rx506_cur."!mark_fail"(0)
    lt rx506_pos, -1, rx506_done
    eq rx506_pos, -1, rx506_fail
    jump $I10
  rx506_done:
    rx506_cur."!cursor_fail"()
    if_null rx506_debug, debug_757
    rx506_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_757:
    .return (rx506_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1303739803.72") :method
.annotate 'line', 10
    new $P508, "ResizablePMCArray"
    push $P508, "CATCH"
    .return ($P508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx514_tgt
    .local int rx514_pos
    .local int rx514_off
    .local int rx514_eos
    .local int rx514_rep
    .local pmc rx514_cur
    .local pmc rx514_debug
    (rx514_cur, rx514_pos, rx514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx514_cur
    .local pmc match
    .lex "$/", match
    length rx514_eos, rx514_tgt
    gt rx514_pos, rx514_eos, rx514_done
    set rx514_off, 0
    lt rx514_pos, 2, rx514_start
    sub rx514_off, rx514_pos, 1
    substr rx514_tgt, rx514_tgt, rx514_off
  rx514_start:
    eq $I10, 1, rx514_restart
    if_null rx514_debug, debug_758
    rx514_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_758:
    $I10 = self.'from'()
    ne $I10, -1, rxscan517_done
    goto rxscan517_scan
  rxscan517_loop:
    (rx514_pos) = rx514_cur."from"()
    inc rx514_pos
    rx514_cur."!cursor_from"(rx514_pos)
    ge rx514_pos, rx514_eos, rxscan517_done
  rxscan517_scan:
    set_addr $I10, rxscan517_loop
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  rxscan517_done:
.annotate 'line', 239
  # rx subcapture "sym"
    set_addr $I10, rxcap_518_fail
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx514_pos, 7
    gt $I11, rx514_eos, rx514_fail
    sub $I11, rx514_pos, rx514_off
    substr $S10, rx514_tgt, $I11, 7
    ne $S10, "CONTROL", rx514_fail
    add rx514_pos, 7
    set_addr $I10, rxcap_518_fail
    ($I12, $I11) = rx514_cur."!mark_peek"($I10)
    rx514_cur."!cursor_pos"($I11)
    ($P10) = rx514_cur."!cursor_start"()
    $P10."!cursor_pass"(rx514_pos, "")
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_518_done
  rxcap_518_fail:
    goto rx514_fail
  rxcap_518_done:
  # rx charclass s
    ge rx514_pos, rx514_eos, rx514_fail
    sub $I10, rx514_pos, rx514_off
    is_cclass $I11, 32, rx514_tgt, $I10
    unless $I11, rx514_fail
    inc rx514_pos
  # rx subrule "ws" subtype=method negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."ws"()
    unless $P10, rx514_fail
    rx514_pos = $P10."pos"()
.annotate 'line', 240
  # rx subrule "block" subtype=capture negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."block"()
    unless $P10, rx514_fail
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx514_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."ws"()
    unless $P10, rx514_fail
    rx514_pos = $P10."pos"()
.annotate 'line', 238
  # rx pass
    rx514_cur."!cursor_pass"(rx514_pos, "statement_control:sym<CONTROL>")
    if_null rx514_debug, debug_759
    rx514_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx514_pos)
  debug_759:
    .return (rx514_cur)
  rx514_restart:
.annotate 'line', 10
    if_null rx514_debug, debug_760
    rx514_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_760:
  rx514_fail:
    (rx514_rep, rx514_pos, $I10, $P10) = rx514_cur."!mark_fail"(0)
    lt rx514_pos, -1, rx514_done
    eq rx514_pos, -1, rx514_fail
    jump $I10
  rx514_done:
    rx514_cur."!cursor_fail"()
    if_null rx514_debug, debug_761
    rx514_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_761:
    .return (rx514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1303739803.72") :method
.annotate 'line', 10
    new $P516, "ResizablePMCArray"
    push $P516, "CONTROL"
    .return ($P516)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1303739803.72")
    .param pmc param_522
.annotate 'line', 243
    .lex "self", param_522
    $P523 = param_522."!protoregex"("statement_prefix")
    .return ($P523)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1303739803.72")
    .param pmc param_525
.annotate 'line', 243
    .lex "self", param_525
    $P526 = param_525."!PREFIX__!protoregex"("statement_prefix")
    .return ($P526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx528_tgt
    .local int rx528_pos
    .local int rx528_off
    .local int rx528_eos
    .local int rx528_rep
    .local pmc rx528_cur
    .local pmc rx528_debug
    (rx528_cur, rx528_pos, rx528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx528_cur
    .local pmc match
    .lex "$/", match
    length rx528_eos, rx528_tgt
    gt rx528_pos, rx528_eos, rx528_done
    set rx528_off, 0
    lt rx528_pos, 2, rx528_start
    sub rx528_off, rx528_pos, 1
    substr rx528_tgt, rx528_tgt, rx528_off
  rx528_start:
    eq $I10, 1, rx528_restart
    if_null rx528_debug, debug_762
    rx528_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_762:
    $I10 = self.'from'()
    ne $I10, -1, rxscan532_done
    goto rxscan532_scan
  rxscan532_loop:
    (rx528_pos) = rx528_cur."from"()
    inc rx528_pos
    rx528_cur."!cursor_from"(rx528_pos)
    ge rx528_pos, rx528_eos, rxscan532_done
  rxscan532_scan:
    set_addr $I10, rxscan532_loop
    rx528_cur."!mark_push"(0, rx528_pos, $I10)
  rxscan532_done:
.annotate 'line', 244
  # rx subcapture "sym"
    set_addr $I10, rxcap_533_fail
    rx528_cur."!mark_push"(0, rx528_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx528_pos, 4
    gt $I11, rx528_eos, rx528_fail
    sub $I11, rx528_pos, rx528_off
    substr $S10, rx528_tgt, $I11, 4
    ne $S10, "INIT", rx528_fail
    add rx528_pos, 4
    set_addr $I10, rxcap_533_fail
    ($I12, $I11) = rx528_cur."!mark_peek"($I10)
    rx528_cur."!cursor_pos"($I11)
    ($P10) = rx528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx528_pos, "")
    rx528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_533_done
  rxcap_533_fail:
    goto rx528_fail
  rxcap_533_done:
  # rx subrule "blorst" subtype=capture negate=
    rx528_cur."!cursor_pos"(rx528_pos)
    $P10 = rx528_cur."blorst"()
    unless $P10, rx528_fail
    rx528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx528_pos = $P10."pos"()
  # rx pass
    rx528_cur."!cursor_pass"(rx528_pos, "statement_prefix:sym<INIT>")
    if_null rx528_debug, debug_763
    rx528_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx528_pos)
  debug_763:
    .return (rx528_cur)
  rx528_restart:
.annotate 'line', 10
    if_null rx528_debug, debug_764
    rx528_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_764:
  rx528_fail:
    (rx528_rep, rx528_pos, $I10, $P10) = rx528_cur."!mark_fail"(0)
    lt rx528_pos, -1, rx528_done
    eq rx528_pos, -1, rx528_fail
    jump $I10
  rx528_done:
    rx528_cur."!cursor_fail"()
    if_null rx528_debug, debug_765
    rx528_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_765:
    .return (rx528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1303739803.72") :method
.annotate 'line', 10
    $P530 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P531, "ResizablePMCArray"
    push $P531, $P530
    .return ($P531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx535_tgt
    .local int rx535_pos
    .local int rx535_off
    .local int rx535_eos
    .local int rx535_rep
    .local pmc rx535_cur
    .local pmc rx535_debug
    (rx535_cur, rx535_pos, rx535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx535_cur
    .local pmc match
    .lex "$/", match
    length rx535_eos, rx535_tgt
    gt rx535_pos, rx535_eos, rx535_done
    set rx535_off, 0
    lt rx535_pos, 2, rx535_start
    sub rx535_off, rx535_pos, 1
    substr rx535_tgt, rx535_tgt, rx535_off
  rx535_start:
    eq $I10, 1, rx535_restart
    if_null rx535_debug, debug_766
    rx535_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_766:
    $I10 = self.'from'()
    ne $I10, -1, rxscan539_done
    goto rxscan539_scan
  rxscan539_loop:
    (rx535_pos) = rx535_cur."from"()
    inc rx535_pos
    rx535_cur."!cursor_from"(rx535_pos)
    ge rx535_pos, rx535_eos, rxscan539_done
  rxscan539_scan:
    set_addr $I10, rxscan539_loop
    rx535_cur."!mark_push"(0, rx535_pos, $I10)
  rxscan539_done:
.annotate 'line', 247
  # rx subcapture "sym"
    set_addr $I10, rxcap_540_fail
    rx535_cur."!mark_push"(0, rx535_pos, $I10)
  # rx literal  "try"
    add $I11, rx535_pos, 3
    gt $I11, rx535_eos, rx535_fail
    sub $I11, rx535_pos, rx535_off
    substr $S10, rx535_tgt, $I11, 3
    ne $S10, "try", rx535_fail
    add rx535_pos, 3
    set_addr $I10, rxcap_540_fail
    ($I12, $I11) = rx535_cur."!mark_peek"($I10)
    rx535_cur."!cursor_pos"($I11)
    ($P10) = rx535_cur."!cursor_start"()
    $P10."!cursor_pass"(rx535_pos, "")
    rx535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_540_done
  rxcap_540_fail:
    goto rx535_fail
  rxcap_540_done:
.annotate 'line', 248
  # rx subrule "blorst" subtype=capture negate=
    rx535_cur."!cursor_pos"(rx535_pos)
    $P10 = rx535_cur."blorst"()
    unless $P10, rx535_fail
    rx535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx535_pos = $P10."pos"()
.annotate 'line', 246
  # rx pass
    rx535_cur."!cursor_pass"(rx535_pos, "statement_prefix:sym<try>")
    if_null rx535_debug, debug_767
    rx535_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx535_pos)
  debug_767:
    .return (rx535_cur)
  rx535_restart:
.annotate 'line', 10
    if_null rx535_debug, debug_768
    rx535_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_768:
  rx535_fail:
    (rx535_rep, rx535_pos, $I10, $P10) = rx535_cur."!mark_fail"(0)
    lt rx535_pos, -1, rx535_done
    eq rx535_pos, -1, rx535_fail
    jump $I10
  rx535_done:
    rx535_cur."!cursor_fail"()
    if_null rx535_debug, debug_769
    rx535_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_769:
    .return (rx535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1303739803.72") :method
.annotate 'line', 10
    $P537 = self."!PREFIX__!subrule"("blorst", "try")
    new $P538, "ResizablePMCArray"
    push $P538, $P537
    .return ($P538)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx542_tgt
    .local int rx542_pos
    .local int rx542_off
    .local int rx542_eos
    .local int rx542_rep
    .local pmc rx542_cur
    .local pmc rx542_debug
    (rx542_cur, rx542_pos, rx542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx542_cur
    .local pmc match
    .lex "$/", match
    length rx542_eos, rx542_tgt
    gt rx542_pos, rx542_eos, rx542_done
    set rx542_off, 0
    lt rx542_pos, 2, rx542_start
    sub rx542_off, rx542_pos, 1
    substr rx542_tgt, rx542_tgt, rx542_off
  rx542_start:
    eq $I10, 1, rx542_restart
    if_null rx542_debug, debug_770
    rx542_cur."!cursor_debug"("START", "blorst")
  debug_770:
    $I10 = self.'from'()
    ne $I10, -1, rxscan545_done
    goto rxscan545_scan
  rxscan545_loop:
    (rx542_pos) = rx542_cur."from"()
    inc rx542_pos
    rx542_cur."!cursor_from"(rx542_pos)
    ge rx542_pos, rx542_eos, rxscan545_done
  rxscan545_scan:
    set_addr $I10, rxscan545_loop
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  rxscan545_done:
.annotate 'line', 252
  # rx charclass s
    ge rx542_pos, rx542_eos, rx542_fail
    sub $I10, rx542_pos, rx542_off
    is_cclass $I11, 32, rx542_tgt, $I10
    unless $I11, rx542_fail
    inc rx542_pos
  # rx subrule "ws" subtype=method negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."ws"()
    unless $P10, rx542_fail
    rx542_pos = $P10."pos"()
  alt546_0:
    set_addr $I10, alt546_1
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx542_pos, rx542_off
    substr $S10, rx542_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx542_fail
  # rx subrule "block" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."block"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx542_pos = $P10."pos"()
    goto alt546_end
  alt546_1:
  # rx subrule "statement" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."statement"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx542_pos = $P10."pos"()
  alt546_end:
.annotate 'line', 251
  # rx pass
    rx542_cur."!cursor_pass"(rx542_pos, "blorst")
    if_null rx542_debug, debug_771
    rx542_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx542_pos)
  debug_771:
    .return (rx542_cur)
  rx542_restart:
.annotate 'line', 10
    if_null rx542_debug, debug_772
    rx542_cur."!cursor_debug"("NEXT", "blorst")
  debug_772:
  rx542_fail:
    (rx542_rep, rx542_pos, $I10, $P10) = rx542_cur."!mark_fail"(0)
    lt rx542_pos, -1, rx542_done
    eq rx542_pos, -1, rx542_fail
    jump $I10
  rx542_done:
    rx542_cur."!cursor_fail"()
    if_null rx542_debug, debug_773
    rx542_cur."!cursor_debug"("FAIL", "blorst")
  debug_773:
    .return (rx542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1303739803.72") :method
.annotate 'line', 10
    new $P544, "ResizablePMCArray"
    push $P544, ""
    .return ($P544)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1303739803.72")
    .param pmc param_548
.annotate 'line', 257
    .lex "self", param_548
    $P549 = param_548."!protoregex"("statement_mod_cond")
    .return ($P549)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1303739803.72")
    .param pmc param_551
.annotate 'line', 257
    .lex "self", param_551
    $P552 = param_551."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx554_tgt
    .local int rx554_pos
    .local int rx554_off
    .local int rx554_eos
    .local int rx554_rep
    .local pmc rx554_cur
    .local pmc rx554_debug
    (rx554_cur, rx554_pos, rx554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx554_cur
    .local pmc match
    .lex "$/", match
    length rx554_eos, rx554_tgt
    gt rx554_pos, rx554_eos, rx554_done
    set rx554_off, 0
    lt rx554_pos, 2, rx554_start
    sub rx554_off, rx554_pos, 1
    substr rx554_tgt, rx554_tgt, rx554_off
  rx554_start:
    eq $I10, 1, rx554_restart
    if_null rx554_debug, debug_774
    rx554_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_774:
    $I10 = self.'from'()
    ne $I10, -1, rxscan558_done
    goto rxscan558_scan
  rxscan558_loop:
    (rx554_pos) = rx554_cur."from"()
    inc rx554_pos
    rx554_cur."!cursor_from"(rx554_pos)
    ge rx554_pos, rx554_eos, rxscan558_done
  rxscan558_scan:
    set_addr $I10, rxscan558_loop
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  rxscan558_done:
.annotate 'line', 259
  # rx subcapture "sym"
    set_addr $I10, rxcap_559_fail
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  # rx literal  "if"
    add $I11, rx554_pos, 2
    gt $I11, rx554_eos, rx554_fail
    sub $I11, rx554_pos, rx554_off
    substr $S10, rx554_tgt, $I11, 2
    ne $S10, "if", rx554_fail
    add rx554_pos, 2
    set_addr $I10, rxcap_559_fail
    ($I12, $I11) = rx554_cur."!mark_peek"($I10)
    rx554_cur."!cursor_pos"($I11)
    ($P10) = rx554_cur."!cursor_start"()
    $P10."!cursor_pass"(rx554_pos, "")
    rx554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_559_done
  rxcap_559_fail:
    goto rx554_fail
  rxcap_559_done:
  # rx subrule "ws" subtype=method negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."ws"()
    unless $P10, rx554_fail
    rx554_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."EXPR"()
    unless $P10, rx554_fail
    rx554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx554_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."ws"()
    unless $P10, rx554_fail
    rx554_pos = $P10."pos"()
  # rx pass
    rx554_cur."!cursor_pass"(rx554_pos, "statement_mod_cond:sym<if>")
    if_null rx554_debug, debug_775
    rx554_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx554_pos)
  debug_775:
    .return (rx554_cur)
  rx554_restart:
.annotate 'line', 10
    if_null rx554_debug, debug_776
    rx554_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_776:
  rx554_fail:
    (rx554_rep, rx554_pos, $I10, $P10) = rx554_cur."!mark_fail"(0)
    lt rx554_pos, -1, rx554_done
    eq rx554_pos, -1, rx554_fail
    jump $I10
  rx554_done:
    rx554_cur."!cursor_fail"()
    if_null rx554_debug, debug_777
    rx554_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_777:
    .return (rx554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1303739803.72") :method
.annotate 'line', 10
    $P556 = self."!PREFIX__!subrule"("ws", "if")
    new $P557, "ResizablePMCArray"
    push $P557, $P556
    .return ($P557)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx563_tgt
    .local int rx563_pos
    .local int rx563_off
    .local int rx563_eos
    .local int rx563_rep
    .local pmc rx563_cur
    .local pmc rx563_debug
    (rx563_cur, rx563_pos, rx563_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx563_cur
    .local pmc match
    .lex "$/", match
    length rx563_eos, rx563_tgt
    gt rx563_pos, rx563_eos, rx563_done
    set rx563_off, 0
    lt rx563_pos, 2, rx563_start
    sub rx563_off, rx563_pos, 1
    substr rx563_tgt, rx563_tgt, rx563_off
  rx563_start:
    eq $I10, 1, rx563_restart
    if_null rx563_debug, debug_778
    rx563_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_778:
    $I10 = self.'from'()
    ne $I10, -1, rxscan567_done
    goto rxscan567_scan
  rxscan567_loop:
    (rx563_pos) = rx563_cur."from"()
    inc rx563_pos
    rx563_cur."!cursor_from"(rx563_pos)
    ge rx563_pos, rx563_eos, rxscan567_done
  rxscan567_scan:
    set_addr $I10, rxscan567_loop
    rx563_cur."!mark_push"(0, rx563_pos, $I10)
  rxscan567_done:
.annotate 'line', 260
  # rx subcapture "sym"
    set_addr $I10, rxcap_568_fail
    rx563_cur."!mark_push"(0, rx563_pos, $I10)
  # rx literal  "unless"
    add $I11, rx563_pos, 6
    gt $I11, rx563_eos, rx563_fail
    sub $I11, rx563_pos, rx563_off
    substr $S10, rx563_tgt, $I11, 6
    ne $S10, "unless", rx563_fail
    add rx563_pos, 6
    set_addr $I10, rxcap_568_fail
    ($I12, $I11) = rx563_cur."!mark_peek"($I10)
    rx563_cur."!cursor_pos"($I11)
    ($P10) = rx563_cur."!cursor_start"()
    $P10."!cursor_pass"(rx563_pos, "")
    rx563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_568_done
  rxcap_568_fail:
    goto rx563_fail
  rxcap_568_done:
  # rx subrule "ws" subtype=method negate=
    rx563_cur."!cursor_pos"(rx563_pos)
    $P10 = rx563_cur."ws"()
    unless $P10, rx563_fail
    rx563_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx563_cur."!cursor_pos"(rx563_pos)
    $P10 = rx563_cur."EXPR"()
    unless $P10, rx563_fail
    rx563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx563_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx563_cur."!cursor_pos"(rx563_pos)
    $P10 = rx563_cur."ws"()
    unless $P10, rx563_fail
    rx563_pos = $P10."pos"()
  # rx pass
    rx563_cur."!cursor_pass"(rx563_pos, "statement_mod_cond:sym<unless>")
    if_null rx563_debug, debug_779
    rx563_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx563_pos)
  debug_779:
    .return (rx563_cur)
  rx563_restart:
.annotate 'line', 10
    if_null rx563_debug, debug_780
    rx563_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_780:
  rx563_fail:
    (rx563_rep, rx563_pos, $I10, $P10) = rx563_cur."!mark_fail"(0)
    lt rx563_pos, -1, rx563_done
    eq rx563_pos, -1, rx563_fail
    jump $I10
  rx563_done:
    rx563_cur."!cursor_fail"()
    if_null rx563_debug, debug_781
    rx563_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_781:
    .return (rx563_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1303739803.72") :method
.annotate 'line', 10
    $P565 = self."!PREFIX__!subrule"("ws", "unless")
    new $P566, "ResizablePMCArray"
    push $P566, $P565
    .return ($P566)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1303739803.72")
    .param pmc param_572
.annotate 'line', 262
    .lex "self", param_572
    $P573 = param_572."!protoregex"("statement_mod_loop")
    .return ($P573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1303739803.72")
    .param pmc param_575
.annotate 'line', 262
    .lex "self", param_575
    $P576 = param_575."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx578_tgt
    .local int rx578_pos
    .local int rx578_off
    .local int rx578_eos
    .local int rx578_rep
    .local pmc rx578_cur
    .local pmc rx578_debug
    (rx578_cur, rx578_pos, rx578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx578_cur
    .local pmc match
    .lex "$/", match
    length rx578_eos, rx578_tgt
    gt rx578_pos, rx578_eos, rx578_done
    set rx578_off, 0
    lt rx578_pos, 2, rx578_start
    sub rx578_off, rx578_pos, 1
    substr rx578_tgt, rx578_tgt, rx578_off
  rx578_start:
    eq $I10, 1, rx578_restart
    if_null rx578_debug, debug_782
    rx578_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_782:
    $I10 = self.'from'()
    ne $I10, -1, rxscan582_done
    goto rxscan582_scan
  rxscan582_loop:
    (rx578_pos) = rx578_cur."from"()
    inc rx578_pos
    rx578_cur."!cursor_from"(rx578_pos)
    ge rx578_pos, rx578_eos, rxscan582_done
  rxscan582_scan:
    set_addr $I10, rxscan582_loop
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  rxscan582_done:
.annotate 'line', 264
  # rx subcapture "sym"
    set_addr $I10, rxcap_583_fail
    rx578_cur."!mark_push"(0, rx578_pos, $I10)
  # rx literal  "while"
    add $I11, rx578_pos, 5
    gt $I11, rx578_eos, rx578_fail
    sub $I11, rx578_pos, rx578_off
    substr $S10, rx578_tgt, $I11, 5
    ne $S10, "while", rx578_fail
    add rx578_pos, 5
    set_addr $I10, rxcap_583_fail
    ($I12, $I11) = rx578_cur."!mark_peek"($I10)
    rx578_cur."!cursor_pos"($I11)
    ($P10) = rx578_cur."!cursor_start"()
    $P10."!cursor_pass"(rx578_pos, "")
    rx578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_583_done
  rxcap_583_fail:
    goto rx578_fail
  rxcap_583_done:
  # rx subrule "ws" subtype=method negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."ws"()
    unless $P10, rx578_fail
    rx578_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."EXPR"()
    unless $P10, rx578_fail
    rx578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx578_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx578_cur."!cursor_pos"(rx578_pos)
    $P10 = rx578_cur."ws"()
    unless $P10, rx578_fail
    rx578_pos = $P10."pos"()
  # rx pass
    rx578_cur."!cursor_pass"(rx578_pos, "statement_mod_loop:sym<while>")
    if_null rx578_debug, debug_783
    rx578_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx578_pos)
  debug_783:
    .return (rx578_cur)
  rx578_restart:
.annotate 'line', 10
    if_null rx578_debug, debug_784
    rx578_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_784:
  rx578_fail:
    (rx578_rep, rx578_pos, $I10, $P10) = rx578_cur."!mark_fail"(0)
    lt rx578_pos, -1, rx578_done
    eq rx578_pos, -1, rx578_fail
    jump $I10
  rx578_done:
    rx578_cur."!cursor_fail"()
    if_null rx578_debug, debug_785
    rx578_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_785:
    .return (rx578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1303739803.72") :method
.annotate 'line', 10
    $P580 = self."!PREFIX__!subrule"("ws", "while")
    new $P581, "ResizablePMCArray"
    push $P581, $P580
    .return ($P581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx587_tgt
    .local int rx587_pos
    .local int rx587_off
    .local int rx587_eos
    .local int rx587_rep
    .local pmc rx587_cur
    .local pmc rx587_debug
    (rx587_cur, rx587_pos, rx587_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx587_cur
    .local pmc match
    .lex "$/", match
    length rx587_eos, rx587_tgt
    gt rx587_pos, rx587_eos, rx587_done
    set rx587_off, 0
    lt rx587_pos, 2, rx587_start
    sub rx587_off, rx587_pos, 1
    substr rx587_tgt, rx587_tgt, rx587_off
  rx587_start:
    eq $I10, 1, rx587_restart
    if_null rx587_debug, debug_786
    rx587_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_786:
    $I10 = self.'from'()
    ne $I10, -1, rxscan591_done
    goto rxscan591_scan
  rxscan591_loop:
    (rx587_pos) = rx587_cur."from"()
    inc rx587_pos
    rx587_cur."!cursor_from"(rx587_pos)
    ge rx587_pos, rx587_eos, rxscan591_done
  rxscan591_scan:
    set_addr $I10, rxscan591_loop
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  rxscan591_done:
.annotate 'line', 265
  # rx subcapture "sym"
    set_addr $I10, rxcap_592_fail
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  # rx literal  "until"
    add $I11, rx587_pos, 5
    gt $I11, rx587_eos, rx587_fail
    sub $I11, rx587_pos, rx587_off
    substr $S10, rx587_tgt, $I11, 5
    ne $S10, "until", rx587_fail
    add rx587_pos, 5
    set_addr $I10, rxcap_592_fail
    ($I12, $I11) = rx587_cur."!mark_peek"($I10)
    rx587_cur."!cursor_pos"($I11)
    ($P10) = rx587_cur."!cursor_start"()
    $P10."!cursor_pass"(rx587_pos, "")
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_592_done
  rxcap_592_fail:
    goto rx587_fail
  rxcap_592_done:
  # rx subrule "ws" subtype=method negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."ws"()
    unless $P10, rx587_fail
    rx587_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."EXPR"()
    unless $P10, rx587_fail
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx587_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."ws"()
    unless $P10, rx587_fail
    rx587_pos = $P10."pos"()
  # rx pass
    rx587_cur."!cursor_pass"(rx587_pos, "statement_mod_loop:sym<until>")
    if_null rx587_debug, debug_787
    rx587_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx587_pos)
  debug_787:
    .return (rx587_cur)
  rx587_restart:
.annotate 'line', 10
    if_null rx587_debug, debug_788
    rx587_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_788:
  rx587_fail:
    (rx587_rep, rx587_pos, $I10, $P10) = rx587_cur."!mark_fail"(0)
    lt rx587_pos, -1, rx587_done
    eq rx587_pos, -1, rx587_fail
    jump $I10
  rx587_done:
    rx587_cur."!cursor_fail"()
    if_null rx587_debug, debug_789
    rx587_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_789:
    .return (rx587_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1303739803.72") :method
.annotate 'line', 10
    $P589 = self."!PREFIX__!subrule"("ws", "until")
    new $P590, "ResizablePMCArray"
    push $P590, $P589
    .return ($P590)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx596_tgt
    .local int rx596_pos
    .local int rx596_off
    .local int rx596_eos
    .local int rx596_rep
    .local pmc rx596_cur
    .local pmc rx596_debug
    (rx596_cur, rx596_pos, rx596_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx596_cur
    .local pmc match
    .lex "$/", match
    length rx596_eos, rx596_tgt
    gt rx596_pos, rx596_eos, rx596_done
    set rx596_off, 0
    lt rx596_pos, 2, rx596_start
    sub rx596_off, rx596_pos, 1
    substr rx596_tgt, rx596_tgt, rx596_off
  rx596_start:
    eq $I10, 1, rx596_restart
    if_null rx596_debug, debug_790
    rx596_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_790:
    $I10 = self.'from'()
    ne $I10, -1, rxscan600_done
    goto rxscan600_scan
  rxscan600_loop:
    (rx596_pos) = rx596_cur."from"()
    inc rx596_pos
    rx596_cur."!cursor_from"(rx596_pos)
    ge rx596_pos, rx596_eos, rxscan600_done
  rxscan600_scan:
    set_addr $I10, rxscan600_loop
    rx596_cur."!mark_push"(0, rx596_pos, $I10)
  rxscan600_done:
.annotate 'line', 266
  # rx subcapture "sym"
    set_addr $I10, rxcap_601_fail
    rx596_cur."!mark_push"(0, rx596_pos, $I10)
  # rx literal  "for"
    add $I11, rx596_pos, 3
    gt $I11, rx596_eos, rx596_fail
    sub $I11, rx596_pos, rx596_off
    substr $S10, rx596_tgt, $I11, 3
    ne $S10, "for", rx596_fail
    add rx596_pos, 3
    set_addr $I10, rxcap_601_fail
    ($I12, $I11) = rx596_cur."!mark_peek"($I10)
    rx596_cur."!cursor_pos"($I11)
    ($P10) = rx596_cur."!cursor_start"()
    $P10."!cursor_pass"(rx596_pos, "")
    rx596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_601_done
  rxcap_601_fail:
    goto rx596_fail
  rxcap_601_done:
  # rx subrule "ws" subtype=method negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."ws"()
    unless $P10, rx596_fail
    rx596_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."EXPR"()
    unless $P10, rx596_fail
    rx596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx596_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."ws"()
    unless $P10, rx596_fail
    rx596_pos = $P10."pos"()
  # rx pass
    rx596_cur."!cursor_pass"(rx596_pos, "statement_mod_loop:sym<for>")
    if_null rx596_debug, debug_791
    rx596_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx596_pos)
  debug_791:
    .return (rx596_cur)
  rx596_restart:
.annotate 'line', 10
    if_null rx596_debug, debug_792
    rx596_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_792:
  rx596_fail:
    (rx596_rep, rx596_pos, $I10, $P10) = rx596_cur."!mark_fail"(0)
    lt rx596_pos, -1, rx596_done
    eq rx596_pos, -1, rx596_fail
    jump $I10
  rx596_done:
    rx596_cur."!cursor_fail"()
    if_null rx596_debug, debug_793
    rx596_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_793:
    .return (rx596_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1303739803.72") :method
.annotate 'line', 10
    $P598 = self."!PREFIX__!subrule"("ws", "for")
    new $P599, "ResizablePMCArray"
    push $P599, $P598
    .return ($P599)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx605_tgt
    .local int rx605_pos
    .local int rx605_off
    .local int rx605_eos
    .local int rx605_rep
    .local pmc rx605_cur
    .local pmc rx605_debug
    (rx605_cur, rx605_pos, rx605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx605_cur
    .local pmc match
    .lex "$/", match
    length rx605_eos, rx605_tgt
    gt rx605_pos, rx605_eos, rx605_done
    set rx605_off, 0
    lt rx605_pos, 2, rx605_start
    sub rx605_off, rx605_pos, 1
    substr rx605_tgt, rx605_tgt, rx605_off
  rx605_start:
    eq $I10, 1, rx605_restart
    if_null rx605_debug, debug_794
    rx605_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_794:
    $I10 = self.'from'()
    ne $I10, -1, rxscan609_done
    goto rxscan609_scan
  rxscan609_loop:
    (rx605_pos) = rx605_cur."from"()
    inc rx605_pos
    rx605_cur."!cursor_from"(rx605_pos)
    ge rx605_pos, rx605_eos, rxscan609_done
  rxscan609_scan:
    set_addr $I10, rxscan609_loop
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  rxscan609_done:
.annotate 'line', 270
  # rx subrule "fatarrow" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."fatarrow"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx605_pos = $P10."pos"()
  # rx pass
    rx605_cur."!cursor_pass"(rx605_pos, "term:sym<fatarrow>")
    if_null rx605_debug, debug_795
    rx605_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx605_pos)
  debug_795:
    .return (rx605_cur)
  rx605_restart:
.annotate 'line', 10
    if_null rx605_debug, debug_796
    rx605_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_796:
  rx605_fail:
    (rx605_rep, rx605_pos, $I10, $P10) = rx605_cur."!mark_fail"(0)
    lt rx605_pos, -1, rx605_done
    eq rx605_pos, -1, rx605_fail
    jump $I10
  rx605_done:
    rx605_cur."!cursor_fail"()
    if_null rx605_debug, debug_797
    rx605_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_797:
    .return (rx605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1303739803.72") :method
.annotate 'line', 10
    $P607 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P608, "ResizablePMCArray"
    push $P608, $P607
    .return ($P608)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx611_tgt
    .local int rx611_pos
    .local int rx611_off
    .local int rx611_eos
    .local int rx611_rep
    .local pmc rx611_cur
    .local pmc rx611_debug
    (rx611_cur, rx611_pos, rx611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx611_cur
    .local pmc match
    .lex "$/", match
    length rx611_eos, rx611_tgt
    gt rx611_pos, rx611_eos, rx611_done
    set rx611_off, 0
    lt rx611_pos, 2, rx611_start
    sub rx611_off, rx611_pos, 1
    substr rx611_tgt, rx611_tgt, rx611_off
  rx611_start:
    eq $I10, 1, rx611_restart
    if_null rx611_debug, debug_798
    rx611_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_798:
    $I10 = self.'from'()
    ne $I10, -1, rxscan615_done
    goto rxscan615_scan
  rxscan615_loop:
    (rx611_pos) = rx611_cur."from"()
    inc rx611_pos
    rx611_cur."!cursor_from"(rx611_pos)
    ge rx611_pos, rx611_eos, rxscan615_done
  rxscan615_scan:
    set_addr $I10, rxscan615_loop
    rx611_cur."!mark_push"(0, rx611_pos, $I10)
  rxscan615_done:
.annotate 'line', 271
  # rx subrule "colonpair" subtype=capture negate=
    rx611_cur."!cursor_pos"(rx611_pos)
    $P10 = rx611_cur."colonpair"()
    unless $P10, rx611_fail
    rx611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx611_pos = $P10."pos"()
  # rx pass
    rx611_cur."!cursor_pass"(rx611_pos, "term:sym<colonpair>")
    if_null rx611_debug, debug_799
    rx611_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx611_pos)
  debug_799:
    .return (rx611_cur)
  rx611_restart:
.annotate 'line', 10
    if_null rx611_debug, debug_800
    rx611_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_800:
  rx611_fail:
    (rx611_rep, rx611_pos, $I10, $P10) = rx611_cur."!mark_fail"(0)
    lt rx611_pos, -1, rx611_done
    eq rx611_pos, -1, rx611_fail
    jump $I10
  rx611_done:
    rx611_cur."!cursor_fail"()
    if_null rx611_debug, debug_801
    rx611_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_801:
    .return (rx611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1303739803.72") :method
.annotate 'line', 10
    $P613 = self."!PREFIX__!subrule"("colonpair", "")
    new $P614, "ResizablePMCArray"
    push $P614, $P613
    .return ($P614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx617_tgt
    .local int rx617_pos
    .local int rx617_off
    .local int rx617_eos
    .local int rx617_rep
    .local pmc rx617_cur
    .local pmc rx617_debug
    (rx617_cur, rx617_pos, rx617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx617_cur
    .local pmc match
    .lex "$/", match
    length rx617_eos, rx617_tgt
    gt rx617_pos, rx617_eos, rx617_done
    set rx617_off, 0
    lt rx617_pos, 2, rx617_start
    sub rx617_off, rx617_pos, 1
    substr rx617_tgt, rx617_tgt, rx617_off
  rx617_start:
    eq $I10, 1, rx617_restart
    if_null rx617_debug, debug_802
    rx617_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_802:
    $I10 = self.'from'()
    ne $I10, -1, rxscan621_done
    goto rxscan621_scan
  rxscan621_loop:
    (rx617_pos) = rx617_cur."from"()
    inc rx617_pos
    rx617_cur."!cursor_from"(rx617_pos)
    ge rx617_pos, rx617_eos, rxscan621_done
  rxscan621_scan:
    set_addr $I10, rxscan621_loop
    rx617_cur."!mark_push"(0, rx617_pos, $I10)
  rxscan621_done:
.annotate 'line', 272
  # rx subrule "variable" subtype=capture negate=
    rx617_cur."!cursor_pos"(rx617_pos)
    $P10 = rx617_cur."variable"()
    unless $P10, rx617_fail
    rx617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx617_pos = $P10."pos"()
  # rx pass
    rx617_cur."!cursor_pass"(rx617_pos, "term:sym<variable>")
    if_null rx617_debug, debug_803
    rx617_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx617_pos)
  debug_803:
    .return (rx617_cur)
  rx617_restart:
.annotate 'line', 10
    if_null rx617_debug, debug_804
    rx617_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_804:
  rx617_fail:
    (rx617_rep, rx617_pos, $I10, $P10) = rx617_cur."!mark_fail"(0)
    lt rx617_pos, -1, rx617_done
    eq rx617_pos, -1, rx617_fail
    jump $I10
  rx617_done:
    rx617_cur."!cursor_fail"()
    if_null rx617_debug, debug_805
    rx617_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_805:
    .return (rx617_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1303739803.72") :method
.annotate 'line', 10
    $P619 = self."!PREFIX__!subrule"("variable", "")
    new $P620, "ResizablePMCArray"
    push $P620, $P619
    .return ($P620)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx623_tgt
    .local int rx623_pos
    .local int rx623_off
    .local int rx623_eos
    .local int rx623_rep
    .local pmc rx623_cur
    .local pmc rx623_debug
    (rx623_cur, rx623_pos, rx623_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx623_cur
    .local pmc match
    .lex "$/", match
    length rx623_eos, rx623_tgt
    gt rx623_pos, rx623_eos, rx623_done
    set rx623_off, 0
    lt rx623_pos, 2, rx623_start
    sub rx623_off, rx623_pos, 1
    substr rx623_tgt, rx623_tgt, rx623_off
  rx623_start:
    eq $I10, 1, rx623_restart
    if_null rx623_debug, debug_806
    rx623_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_806:
    $I10 = self.'from'()
    ne $I10, -1, rxscan627_done
    goto rxscan627_scan
  rxscan627_loop:
    (rx623_pos) = rx623_cur."from"()
    inc rx623_pos
    rx623_cur."!cursor_from"(rx623_pos)
    ge rx623_pos, rx623_eos, rxscan627_done
  rxscan627_scan:
    set_addr $I10, rxscan627_loop
    rx623_cur."!mark_push"(0, rx623_pos, $I10)
  rxscan627_done:
.annotate 'line', 273
  # rx subrule "package_declarator" subtype=capture negate=
    rx623_cur."!cursor_pos"(rx623_pos)
    $P10 = rx623_cur."package_declarator"()
    unless $P10, rx623_fail
    rx623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx623_pos = $P10."pos"()
  # rx pass
    rx623_cur."!cursor_pass"(rx623_pos, "term:sym<package_declarator>")
    if_null rx623_debug, debug_807
    rx623_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx623_pos)
  debug_807:
    .return (rx623_cur)
  rx623_restart:
.annotate 'line', 10
    if_null rx623_debug, debug_808
    rx623_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_808:
  rx623_fail:
    (rx623_rep, rx623_pos, $I10, $P10) = rx623_cur."!mark_fail"(0)
    lt rx623_pos, -1, rx623_done
    eq rx623_pos, -1, rx623_fail
    jump $I10
  rx623_done:
    rx623_cur."!cursor_fail"()
    if_null rx623_debug, debug_809
    rx623_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_809:
    .return (rx623_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1303739803.72") :method
.annotate 'line', 10
    $P625 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P626, "ResizablePMCArray"
    push $P626, $P625
    .return ($P626)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx629_tgt
    .local int rx629_pos
    .local int rx629_off
    .local int rx629_eos
    .local int rx629_rep
    .local pmc rx629_cur
    .local pmc rx629_debug
    (rx629_cur, rx629_pos, rx629_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx629_cur
    .local pmc match
    .lex "$/", match
    length rx629_eos, rx629_tgt
    gt rx629_pos, rx629_eos, rx629_done
    set rx629_off, 0
    lt rx629_pos, 2, rx629_start
    sub rx629_off, rx629_pos, 1
    substr rx629_tgt, rx629_tgt, rx629_off
  rx629_start:
    eq $I10, 1, rx629_restart
    if_null rx629_debug, debug_810
    rx629_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_810:
    $I10 = self.'from'()
    ne $I10, -1, rxscan633_done
    goto rxscan633_scan
  rxscan633_loop:
    (rx629_pos) = rx629_cur."from"()
    inc rx629_pos
    rx629_cur."!cursor_from"(rx629_pos)
    ge rx629_pos, rx629_eos, rxscan633_done
  rxscan633_scan:
    set_addr $I10, rxscan633_loop
    rx629_cur."!mark_push"(0, rx629_pos, $I10)
  rxscan633_done:
.annotate 'line', 274
  # rx subrule "scope_declarator" subtype=capture negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."scope_declarator"()
    unless $P10, rx629_fail
    rx629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx629_pos = $P10."pos"()
  # rx pass
    rx629_cur."!cursor_pass"(rx629_pos, "term:sym<scope_declarator>")
    if_null rx629_debug, debug_811
    rx629_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx629_pos)
  debug_811:
    .return (rx629_cur)
  rx629_restart:
.annotate 'line', 10
    if_null rx629_debug, debug_812
    rx629_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_812:
  rx629_fail:
    (rx629_rep, rx629_pos, $I10, $P10) = rx629_cur."!mark_fail"(0)
    lt rx629_pos, -1, rx629_done
    eq rx629_pos, -1, rx629_fail
    jump $I10
  rx629_done:
    rx629_cur."!cursor_fail"()
    if_null rx629_debug, debug_813
    rx629_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_813:
    .return (rx629_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1303739803.72") :method
.annotate 'line', 10
    $P631 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P632, "ResizablePMCArray"
    push $P632, $P631
    .return ($P632)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx635_tgt
    .local int rx635_pos
    .local int rx635_off
    .local int rx635_eos
    .local int rx635_rep
    .local pmc rx635_cur
    .local pmc rx635_debug
    (rx635_cur, rx635_pos, rx635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx635_cur
    .local pmc match
    .lex "$/", match
    length rx635_eos, rx635_tgt
    gt rx635_pos, rx635_eos, rx635_done
    set rx635_off, 0
    lt rx635_pos, 2, rx635_start
    sub rx635_off, rx635_pos, 1
    substr rx635_tgt, rx635_tgt, rx635_off
  rx635_start:
    eq $I10, 1, rx635_restart
    if_null rx635_debug, debug_814
    rx635_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_814:
    $I10 = self.'from'()
    ne $I10, -1, rxscan639_done
    goto rxscan639_scan
  rxscan639_loop:
    (rx635_pos) = rx635_cur."from"()
    inc rx635_pos
    rx635_cur."!cursor_from"(rx635_pos)
    ge rx635_pos, rx635_eos, rxscan639_done
  rxscan639_scan:
    set_addr $I10, rxscan639_loop
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  rxscan639_done:
.annotate 'line', 275
  # rx subrule "routine_declarator" subtype=capture negate=
    rx635_cur."!cursor_pos"(rx635_pos)
    $P10 = rx635_cur."routine_declarator"()
    unless $P10, rx635_fail
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx635_pos = $P10."pos"()
  # rx pass
    rx635_cur."!cursor_pass"(rx635_pos, "term:sym<routine_declarator>")
    if_null rx635_debug, debug_815
    rx635_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx635_pos)
  debug_815:
    .return (rx635_cur)
  rx635_restart:
.annotate 'line', 10
    if_null rx635_debug, debug_816
    rx635_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_816:
  rx635_fail:
    (rx635_rep, rx635_pos, $I10, $P10) = rx635_cur."!mark_fail"(0)
    lt rx635_pos, -1, rx635_done
    eq rx635_pos, -1, rx635_fail
    jump $I10
  rx635_done:
    rx635_cur."!cursor_fail"()
    if_null rx635_debug, debug_817
    rx635_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_817:
    .return (rx635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1303739803.72") :method
.annotate 'line', 10
    $P637 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P638, "ResizablePMCArray"
    push $P638, $P637
    .return ($P638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P651 = "121_1303739803.72" 
    capture_lex $P651
    .const 'Sub' $P646 = "120_1303739803.72" 
    capture_lex $P646
    .local string rx641_tgt
    .local int rx641_pos
    .local int rx641_off
    .local int rx641_eos
    .local int rx641_rep
    .local pmc rx641_cur
    .local pmc rx641_debug
    (rx641_cur, rx641_pos, rx641_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx641_cur
    .local pmc match
    .lex "$/", match
    length rx641_eos, rx641_tgt
    gt rx641_pos, rx641_eos, rx641_done
    set rx641_off, 0
    lt rx641_pos, 2, rx641_start
    sub rx641_off, rx641_pos, 1
    substr rx641_tgt, rx641_tgt, rx641_off
  rx641_start:
    eq $I10, 1, rx641_restart
    if_null rx641_debug, debug_818
    rx641_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_818:
    $I10 = self.'from'()
    ne $I10, -1, rxscan644_done
    goto rxscan644_scan
  rxscan644_loop:
    (rx641_pos) = rx641_cur."from"()
    inc rx641_pos
    rx641_cur."!cursor_from"(rx641_pos)
    ge rx641_pos, rx641_eos, rxscan644_done
  rxscan644_scan:
    set_addr $I10, rxscan644_loop
    rx641_cur."!mark_push"(0, rx641_pos, $I10)
  rxscan644_done:
.annotate 'line', 277
  # rx subrule "before" subtype=zerowidth negate=
    rx641_cur."!cursor_pos"(rx641_pos)
    .const 'Sub' $P646 = "120_1303739803.72" 
    capture_lex $P646
    $P10 = rx641_cur."before"($P646)
    unless $P10, rx641_fail
.annotate 'line', 278
  # rx subrule "before" subtype=zerowidth negate=1
    rx641_cur."!cursor_pos"(rx641_pos)
    .const 'Sub' $P651 = "121_1303739803.72" 
    capture_lex $P651
    $P10 = rx641_cur."before"($P651)
    if $P10, rx641_fail
.annotate 'line', 279
  # rx subrule "multi_declarator" subtype=capture negate=
    rx641_cur."!cursor_pos"(rx641_pos)
    $P10 = rx641_cur."multi_declarator"()
    unless $P10, rx641_fail
    rx641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx641_pos = $P10."pos"()
.annotate 'line', 276
  # rx pass
    rx641_cur."!cursor_pass"(rx641_pos, "term:sym<multi_declarator>")
    if_null rx641_debug, debug_827
    rx641_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx641_pos)
  debug_827:
    .return (rx641_cur)
  rx641_restart:
.annotate 'line', 10
    if_null rx641_debug, debug_828
    rx641_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_828:
  rx641_fail:
    (rx641_rep, rx641_pos, $I10, $P10) = rx641_cur."!mark_fail"(0)
    lt rx641_pos, -1, rx641_done
    eq rx641_pos, -1, rx641_fail
    jump $I10
  rx641_done:
    rx641_cur."!cursor_fail"()
    if_null rx641_debug, debug_829
    rx641_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_829:
    .return (rx641_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1303739803.72") :method
.annotate 'line', 10
    new $P643, "ResizablePMCArray"
    push $P643, ""
    .return ($P643)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block645"  :anon :subid("120_1303739803.72") :method :outer("118_1303739803.72")
.annotate 'line', 277
    .local string rx647_tgt
    .local int rx647_pos
    .local int rx647_off
    .local int rx647_eos
    .local int rx647_rep
    .local pmc rx647_cur
    .local pmc rx647_debug
    (rx647_cur, rx647_pos, rx647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx647_cur
    .local pmc match
    .lex "$/", match
    length rx647_eos, rx647_tgt
    gt rx647_pos, rx647_eos, rx647_done
    set rx647_off, 0
    lt rx647_pos, 2, rx647_start
    sub rx647_off, rx647_pos, 1
    substr rx647_tgt, rx647_tgt, rx647_off
  rx647_start:
    eq $I10, 1, rx647_restart
    if_null rx647_debug, debug_819
    rx647_cur."!cursor_debug"("START", "")
  debug_819:
    $I10 = self.'from'()
    ne $I10, -1, rxscan648_done
    goto rxscan648_scan
  rxscan648_loop:
    (rx647_pos) = rx647_cur."from"()
    inc rx647_pos
    rx647_cur."!cursor_from"(rx647_pos)
    ge rx647_pos, rx647_eos, rxscan648_done
  rxscan648_scan:
    set_addr $I10, rxscan648_loop
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  rxscan648_done:
  alt649_0:
    set_addr $I10, alt649_1
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  # rx literal  "multi"
    add $I11, rx647_pos, 5
    gt $I11, rx647_eos, rx647_fail
    sub $I11, rx647_pos, rx647_off
    substr $S10, rx647_tgt, $I11, 5
    ne $S10, "multi", rx647_fail
    add rx647_pos, 5
    goto alt649_end
  alt649_1:
    set_addr $I10, alt649_2
    rx647_cur."!mark_push"(0, rx647_pos, $I10)
  # rx literal  "proto"
    add $I11, rx647_pos, 5
    gt $I11, rx647_eos, rx647_fail
    sub $I11, rx647_pos, rx647_off
    substr $S10, rx647_tgt, $I11, 5
    ne $S10, "proto", rx647_fail
    add rx647_pos, 5
    goto alt649_end
  alt649_2:
  # rx literal  "only"
    add $I11, rx647_pos, 4
    gt $I11, rx647_eos, rx647_fail
    sub $I11, rx647_pos, rx647_off
    substr $S10, rx647_tgt, $I11, 4
    ne $S10, "only", rx647_fail
    add rx647_pos, 4
  alt649_end:
  # rx pass
    rx647_cur."!cursor_pass"(rx647_pos, "")
    if_null rx647_debug, debug_820
    rx647_cur."!cursor_debug"("PASS", "", " at pos=", rx647_pos)
  debug_820:
    .return (rx647_cur)
  rx647_restart:
    if_null rx647_debug, debug_821
    rx647_cur."!cursor_debug"("NEXT", "")
  debug_821:
  rx647_fail:
    (rx647_rep, rx647_pos, $I10, $P10) = rx647_cur."!mark_fail"(0)
    lt rx647_pos, -1, rx647_done
    eq rx647_pos, -1, rx647_fail
    jump $I10
  rx647_done:
    rx647_cur."!cursor_fail"()
    if_null rx647_debug, debug_822
    rx647_cur."!cursor_debug"("FAIL", "")
  debug_822:
    .return (rx647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block650"  :anon :subid("121_1303739803.72") :method :outer("118_1303739803.72")
.annotate 'line', 278
    .local string rx652_tgt
    .local int rx652_pos
    .local int rx652_off
    .local int rx652_eos
    .local int rx652_rep
    .local pmc rx652_cur
    .local pmc rx652_debug
    (rx652_cur, rx652_pos, rx652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx652_cur
    .local pmc match
    .lex "$/", match
    length rx652_eos, rx652_tgt
    gt rx652_pos, rx652_eos, rx652_done
    set rx652_off, 0
    lt rx652_pos, 2, rx652_start
    sub rx652_off, rx652_pos, 1
    substr rx652_tgt, rx652_tgt, rx652_off
  rx652_start:
    eq $I10, 1, rx652_restart
    if_null rx652_debug, debug_823
    rx652_cur."!cursor_debug"("START", "")
  debug_823:
    $I10 = self.'from'()
    ne $I10, -1, rxscan653_done
    goto rxscan653_scan
  rxscan653_loop:
    (rx652_pos) = rx652_cur."from"()
    inc rx652_pos
    rx652_cur."!cursor_from"(rx652_pos)
    ge rx652_pos, rx652_eos, rxscan653_done
  rxscan653_scan:
    set_addr $I10, rxscan653_loop
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  rxscan653_done:
  # rx literal  "proto"
    add $I11, rx652_pos, 5
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 5
    ne $S10, "proto", rx652_fail
    add rx652_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx652_cur."!cursor_pos"(rx652_pos)
    $P10 = rx652_cur."ws"()
    unless $P10, rx652_fail
    rx652_pos = $P10."pos"()
  alt654_0:
    set_addr $I10, alt654_1
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  # rx literal  "regex"
    add $I11, rx652_pos, 5
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 5
    ne $S10, "regex", rx652_fail
    add rx652_pos, 5
    goto alt654_end
  alt654_1:
    set_addr $I10, alt654_2
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  # rx literal  "token"
    add $I11, rx652_pos, 5
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 5
    ne $S10, "token", rx652_fail
    add rx652_pos, 5
    goto alt654_end
  alt654_2:
  # rx literal  "rule"
    add $I11, rx652_pos, 4
    gt $I11, rx652_eos, rx652_fail
    sub $I11, rx652_pos, rx652_off
    substr $S10, rx652_tgt, $I11, 4
    ne $S10, "rule", rx652_fail
    add rx652_pos, 4
  alt654_end:
  # rx pass
    rx652_cur."!cursor_pass"(rx652_pos, "")
    if_null rx652_debug, debug_824
    rx652_cur."!cursor_debug"("PASS", "", " at pos=", rx652_pos)
  debug_824:
    .return (rx652_cur)
  rx652_restart:
    if_null rx652_debug, debug_825
    rx652_cur."!cursor_debug"("NEXT", "")
  debug_825:
  rx652_fail:
    (rx652_rep, rx652_pos, $I10, $P10) = rx652_cur."!mark_fail"(0)
    lt rx652_pos, -1, rx652_done
    eq rx652_pos, -1, rx652_fail
    jump $I10
  rx652_done:
    rx652_cur."!cursor_fail"()
    if_null rx652_debug, debug_826
    rx652_cur."!cursor_debug"("FAIL", "")
  debug_826:
    .return (rx652_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx656_tgt
    .local int rx656_pos
    .local int rx656_off
    .local int rx656_eos
    .local int rx656_rep
    .local pmc rx656_cur
    .local pmc rx656_debug
    (rx656_cur, rx656_pos, rx656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx656_cur
    .local pmc match
    .lex "$/", match
    length rx656_eos, rx656_tgt
    gt rx656_pos, rx656_eos, rx656_done
    set rx656_off, 0
    lt rx656_pos, 2, rx656_start
    sub rx656_off, rx656_pos, 1
    substr rx656_tgt, rx656_tgt, rx656_off
  rx656_start:
    eq $I10, 1, rx656_restart
    if_null rx656_debug, debug_830
    rx656_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_830:
    $I10 = self.'from'()
    ne $I10, -1, rxscan660_done
    goto rxscan660_scan
  rxscan660_loop:
    (rx656_pos) = rx656_cur."from"()
    inc rx656_pos
    rx656_cur."!cursor_from"(rx656_pos)
    ge rx656_pos, rx656_eos, rxscan660_done
  rxscan660_scan:
    set_addr $I10, rxscan660_loop
    rx656_cur."!mark_push"(0, rx656_pos, $I10)
  rxscan660_done:
.annotate 'line', 281
  # rx subrule "regex_declarator" subtype=capture negate=
    rx656_cur."!cursor_pos"(rx656_pos)
    $P10 = rx656_cur."regex_declarator"()
    unless $P10, rx656_fail
    rx656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx656_pos = $P10."pos"()
  # rx pass
    rx656_cur."!cursor_pass"(rx656_pos, "term:sym<regex_declarator>")
    if_null rx656_debug, debug_831
    rx656_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx656_pos)
  debug_831:
    .return (rx656_cur)
  rx656_restart:
.annotate 'line', 10
    if_null rx656_debug, debug_832
    rx656_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_832:
  rx656_fail:
    (rx656_rep, rx656_pos, $I10, $P10) = rx656_cur."!mark_fail"(0)
    lt rx656_pos, -1, rx656_done
    eq rx656_pos, -1, rx656_fail
    jump $I10
  rx656_done:
    rx656_cur."!cursor_fail"()
    if_null rx656_debug, debug_833
    rx656_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_833:
    .return (rx656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1303739803.72") :method
.annotate 'line', 10
    $P658 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P659, "ResizablePMCArray"
    push $P659, $P658
    .return ($P659)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx662_tgt
    .local int rx662_pos
    .local int rx662_off
    .local int rx662_eos
    .local int rx662_rep
    .local pmc rx662_cur
    .local pmc rx662_debug
    (rx662_cur, rx662_pos, rx662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx662_cur
    .local pmc match
    .lex "$/", match
    length rx662_eos, rx662_tgt
    gt rx662_pos, rx662_eos, rx662_done
    set rx662_off, 0
    lt rx662_pos, 2, rx662_start
    sub rx662_off, rx662_pos, 1
    substr rx662_tgt, rx662_tgt, rx662_off
  rx662_start:
    eq $I10, 1, rx662_restart
    if_null rx662_debug, debug_834
    rx662_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_834:
    $I10 = self.'from'()
    ne $I10, -1, rxscan666_done
    goto rxscan666_scan
  rxscan666_loop:
    (rx662_pos) = rx662_cur."from"()
    inc rx662_pos
    rx662_cur."!cursor_from"(rx662_pos)
    ge rx662_pos, rx662_eos, rxscan666_done
  rxscan666_scan:
    set_addr $I10, rxscan666_loop
    rx662_cur."!mark_push"(0, rx662_pos, $I10)
  rxscan666_done:
.annotate 'line', 282
  # rx subrule "statement_prefix" subtype=capture negate=
    rx662_cur."!cursor_pos"(rx662_pos)
    $P10 = rx662_cur."statement_prefix"()
    unless $P10, rx662_fail
    rx662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx662_pos = $P10."pos"()
  # rx pass
    rx662_cur."!cursor_pass"(rx662_pos, "term:sym<statement_prefix>")
    if_null rx662_debug, debug_835
    rx662_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx662_pos)
  debug_835:
    .return (rx662_cur)
  rx662_restart:
.annotate 'line', 10
    if_null rx662_debug, debug_836
    rx662_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_836:
  rx662_fail:
    (rx662_rep, rx662_pos, $I10, $P10) = rx662_cur."!mark_fail"(0)
    lt rx662_pos, -1, rx662_done
    eq rx662_pos, -1, rx662_fail
    jump $I10
  rx662_done:
    rx662_cur."!cursor_fail"()
    if_null rx662_debug, debug_837
    rx662_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_837:
    .return (rx662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1303739803.72") :method
.annotate 'line', 10
    $P664 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P665, "ResizablePMCArray"
    push $P665, $P664
    .return ($P665)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx668_tgt
    .local int rx668_pos
    .local int rx668_off
    .local int rx668_eos
    .local int rx668_rep
    .local pmc rx668_cur
    .local pmc rx668_debug
    (rx668_cur, rx668_pos, rx668_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx668_cur
    .local pmc match
    .lex "$/", match
    length rx668_eos, rx668_tgt
    gt rx668_pos, rx668_eos, rx668_done
    set rx668_off, 0
    lt rx668_pos, 2, rx668_start
    sub rx668_off, rx668_pos, 1
    substr rx668_tgt, rx668_tgt, rx668_off
  rx668_start:
    eq $I10, 1, rx668_restart
    if_null rx668_debug, debug_838
    rx668_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_838:
    $I10 = self.'from'()
    ne $I10, -1, rxscan671_done
    goto rxscan671_scan
  rxscan671_loop:
    (rx668_pos) = rx668_cur."from"()
    inc rx668_pos
    rx668_cur."!cursor_from"(rx668_pos)
    ge rx668_pos, rx668_eos, rxscan671_done
  rxscan671_scan:
    set_addr $I10, rxscan671_loop
    rx668_cur."!mark_push"(0, rx668_pos, $I10)
  rxscan671_done:
.annotate 'line', 283
  # rx subrule "lambda" subtype=zerowidth negate=
    rx668_cur."!cursor_pos"(rx668_pos)
    $P10 = rx668_cur."lambda"()
    unless $P10, rx668_fail
  # rx subrule "pblock" subtype=capture negate=
    rx668_cur."!cursor_pos"(rx668_pos)
    $P10 = rx668_cur."pblock"()
    unless $P10, rx668_fail
    rx668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx668_pos = $P10."pos"()
  # rx pass
    rx668_cur."!cursor_pass"(rx668_pos, "term:sym<lambda>")
    if_null rx668_debug, debug_839
    rx668_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx668_pos)
  debug_839:
    .return (rx668_cur)
  rx668_restart:
.annotate 'line', 10
    if_null rx668_debug, debug_840
    rx668_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_840:
  rx668_fail:
    (rx668_rep, rx668_pos, $I10, $P10) = rx668_cur."!mark_fail"(0)
    lt rx668_pos, -1, rx668_done
    eq rx668_pos, -1, rx668_fail
    jump $I10
  rx668_done:
    rx668_cur."!cursor_fail"()
    if_null rx668_debug, debug_841
    rx668_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_841:
    .return (rx668_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1303739803.72") :method
.annotate 'line', 10
    new $P670, "ResizablePMCArray"
    push $P670, ""
    .return ($P670)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx673_tgt
    .local int rx673_pos
    .local int rx673_off
    .local int rx673_eos
    .local int rx673_rep
    .local pmc rx673_cur
    .local pmc rx673_debug
    (rx673_cur, rx673_pos, rx673_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx673_cur
    .local pmc match
    .lex "$/", match
    length rx673_eos, rx673_tgt
    gt rx673_pos, rx673_eos, rx673_done
    set rx673_off, 0
    lt rx673_pos, 2, rx673_start
    sub rx673_off, rx673_pos, 1
    substr rx673_tgt, rx673_tgt, rx673_off
  rx673_start:
    eq $I10, 1, rx673_restart
    if_null rx673_debug, debug_842
    rx673_cur."!cursor_debug"("START", "fatarrow")
  debug_842:
    $I10 = self.'from'()
    ne $I10, -1, rxscan677_done
    goto rxscan677_scan
  rxscan677_loop:
    (rx673_pos) = rx673_cur."from"()
    inc rx673_pos
    rx673_cur."!cursor_from"(rx673_pos)
    ge rx673_pos, rx673_eos, rxscan677_done
  rxscan677_scan:
    set_addr $I10, rxscan677_loop
    rx673_cur."!mark_push"(0, rx673_pos, $I10)
  rxscan677_done:
.annotate 'line', 286
  # rx subrule "identifier" subtype=capture negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."identifier"()
    unless $P10, rx673_fail
    rx673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx673_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx673_pos, rx673_off
    set rx673_rep, 0
    sub $I12, rx673_eos, rx673_pos
  rxenumcharlistq678_loop:
    le $I12, 0, rxenumcharlistq678_done
    substr $S10, rx673_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq678_done
    inc rx673_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq678_loop
  rxenumcharlistq678_done:
    add rx673_pos, rx673_pos, rx673_rep
  # rx literal  "=>"
    add $I11, rx673_pos, 2
    gt $I11, rx673_eos, rx673_fail
    sub $I11, rx673_pos, rx673_off
    substr $S10, rx673_tgt, $I11, 2
    ne $S10, "=>", rx673_fail
    add rx673_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."ws"()
    unless $P10, rx673_fail
    rx673_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."EXPR"("i=")
    unless $P10, rx673_fail
    rx673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx673_pos = $P10."pos"()
.annotate 'line', 285
  # rx pass
    rx673_cur."!cursor_pass"(rx673_pos, "fatarrow")
    if_null rx673_debug, debug_843
    rx673_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx673_pos)
  debug_843:
    .return (rx673_cur)
  rx673_restart:
.annotate 'line', 10
    if_null rx673_debug, debug_844
    rx673_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_844:
  rx673_fail:
    (rx673_rep, rx673_pos, $I10, $P10) = rx673_cur."!mark_fail"(0)
    lt rx673_pos, -1, rx673_done
    eq rx673_pos, -1, rx673_fail
    jump $I10
  rx673_done:
    rx673_cur."!cursor_fail"()
    if_null rx673_debug, debug_845
    rx673_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_845:
    .return (rx673_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1303739803.72") :method
.annotate 'line', 10
    $P675 = self."!PREFIX__!subrule"("identifier", "")
    new $P676, "ResizablePMCArray"
    push $P676, $P675
    .return ($P676)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx680_tgt
    .local int rx680_pos
    .local int rx680_off
    .local int rx680_eos
    .local int rx680_rep
    .local pmc rx680_cur
    .local pmc rx680_debug
    (rx680_cur, rx680_pos, rx680_tgt, $I10) = self."!cursor_start"()
    rx680_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx680_cur
    .local pmc match
    .lex "$/", match
    length rx680_eos, rx680_tgt
    gt rx680_pos, rx680_eos, rx680_done
    set rx680_off, 0
    lt rx680_pos, 2, rx680_start
    sub rx680_off, rx680_pos, 1
    substr rx680_tgt, rx680_tgt, rx680_off
  rx680_start:
    eq $I10, 1, rx680_restart
    if_null rx680_debug, debug_846
    rx680_cur."!cursor_debug"("START", "colonpair")
  debug_846:
    $I10 = self.'from'()
    ne $I10, -1, rxscan686_done
    goto rxscan686_scan
  rxscan686_loop:
    (rx680_pos) = rx680_cur."from"()
    inc rx680_pos
    rx680_cur."!cursor_from"(rx680_pos)
    ge rx680_pos, rx680_eos, rxscan686_done
  rxscan686_scan:
    set_addr $I10, rxscan686_loop
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
  rxscan686_done:
.annotate 'line', 290
  # rx literal  ":"
    add $I11, rx680_pos, 1
    gt $I11, rx680_eos, rx680_fail
    sub $I11, rx680_pos, rx680_off
    ord $I11, rx680_tgt, $I11
    ne $I11, 58, rx680_fail
    add rx680_pos, 1
  alt687_0:
.annotate 'line', 291
    set_addr $I10, alt687_1
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
.annotate 'line', 292
  # rx subcapture "not"
    set_addr $I10, rxcap_688_fail
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
  # rx literal  "!"
    add $I11, rx680_pos, 1
    gt $I11, rx680_eos, rx680_fail
    sub $I11, rx680_pos, rx680_off
    ord $I11, rx680_tgt, $I11
    ne $I11, 33, rx680_fail
    add rx680_pos, 1
    set_addr $I10, rxcap_688_fail
    ($I12, $I11) = rx680_cur."!mark_peek"($I10)
    rx680_cur."!cursor_pos"($I11)
    ($P10) = rx680_cur."!cursor_start"()
    $P10."!cursor_pass"(rx680_pos, "")
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_688_done
  rxcap_688_fail:
    goto rx680_fail
  rxcap_688_done:
  # rx subrule "identifier" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."identifier"()
    unless $P10, rx680_fail
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx680_pos = $P10."pos"()
    goto alt687_end
  alt687_1:
    set_addr $I10, alt687_2
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
.annotate 'line', 293
  # rx subrule "identifier" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."identifier"()
    unless $P10, rx680_fail
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx680_pos = $P10."pos"()
  # rx rxquantr689 ** 0..1
    set_addr $I10, rxquantr689_done
    rx680_cur."!mark_push"(0, rx680_pos, $I10)
  rxquantr689_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."circumfix"()
    unless $P10, rx680_fail
    goto rxsubrule690_pass
  rxsubrule690_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx680_fail
  rxsubrule690_pass:
    set_addr $I10, rxsubrule690_back
    rx680_cur."!mark_push"(0, rx680_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx680_pos = $P10."pos"()
    set_addr $I10, rxquantr689_done
    (rx680_rep) = rx680_cur."!mark_commit"($I10)
  rxquantr689_done:
    goto alt687_end
  alt687_2:
.annotate 'line', 294
  # rx subrule "circumfix" subtype=capture negate=
    rx680_cur."!cursor_pos"(rx680_pos)
    $P10 = rx680_cur."circumfix"()
    unless $P10, rx680_fail
    rx680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx680_pos = $P10."pos"()
  alt687_end:
.annotate 'line', 289
  # rx pass
    rx680_cur."!cursor_pass"(rx680_pos, "colonpair")
    if_null rx680_debug, debug_847
    rx680_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx680_pos)
  debug_847:
    .return (rx680_cur)
  rx680_restart:
.annotate 'line', 10
    if_null rx680_debug, debug_848
    rx680_cur."!cursor_debug"("NEXT", "colonpair")
  debug_848:
  rx680_fail:
    (rx680_rep, rx680_pos, $I10, $P10) = rx680_cur."!mark_fail"(0)
    lt rx680_pos, -1, rx680_done
    eq rx680_pos, -1, rx680_fail
    jump $I10
  rx680_done:
    rx680_cur."!cursor_fail"()
    if_null rx680_debug, debug_849
    rx680_cur."!cursor_debug"("FAIL", "colonpair")
  debug_849:
    .return (rx680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1303739803.72") :method
.annotate 'line', 10
    $P682 = self."!PREFIX__!subrule"("circumfix", ":")
    $P683 = self."!PREFIX__!subrule"("identifier", ":")
    $P684 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P685, "ResizablePMCArray"
    push $P685, $P682
    push $P685, $P683
    push $P685, $P684
    .return ($P685)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx692_tgt
    .local int rx692_pos
    .local int rx692_off
    .local int rx692_eos
    .local int rx692_rep
    .local pmc rx692_cur
    .local pmc rx692_debug
    (rx692_cur, rx692_pos, rx692_tgt, $I10) = self."!cursor_start"()
    rx692_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx692_cur
    .local pmc match
    .lex "$/", match
    length rx692_eos, rx692_tgt
    gt rx692_pos, rx692_eos, rx692_done
    set rx692_off, 0
    lt rx692_pos, 2, rx692_start
    sub rx692_off, rx692_pos, 1
    substr rx692_tgt, rx692_tgt, rx692_off
  rx692_start:
    eq $I10, 1, rx692_restart
    if_null rx692_debug, debug_850
    rx692_cur."!cursor_debug"("START", "variable")
  debug_850:
    $I10 = self.'from'()
    ne $I10, -1, rxscan697_done
    goto rxscan697_scan
  rxscan697_loop:
    (rx692_pos) = rx692_cur."from"()
    inc rx692_pos
    rx692_cur."!cursor_from"(rx692_pos)
    ge rx692_pos, rx692_eos, rxscan697_done
  rxscan697_scan:
    set_addr $I10, rxscan697_loop
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  rxscan697_done:
  alt698_0:
.annotate 'line', 298
    set_addr $I10, alt698_1
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
.annotate 'line', 299
  # rx subrule "sigil" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."sigil"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx692_pos = $P10."pos"()
  # rx rxquantr699 ** 0..1
    set_addr $I10, rxquantr699_done
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  rxquantr699_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."twigil"()
    unless $P10, rx692_fail
    goto rxsubrule700_pass
  rxsubrule700_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx692_fail
  rxsubrule700_pass:
    set_addr $I10, rxsubrule700_back
    rx692_cur."!mark_push"(0, rx692_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx692_pos = $P10."pos"()
    set_addr $I10, rxquantr699_done
    (rx692_rep) = rx692_cur."!mark_commit"($I10)
  rxquantr699_done:
  # rx subrule "name" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."name"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx692_pos = $P10."pos"()
    goto alt698_end
  alt698_1:
    set_addr $I10, alt698_2
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
.annotate 'line', 300
  # rx subrule "sigil" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."sigil"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx692_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx692_pos, rx692_off
    substr $S10, rx692_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx692_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."postcircumfix"()
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx692_pos = $P10."pos"()
    goto alt698_end
  alt698_2:
.annotate 'line', 301
  # rx subcapture "sigil"
    set_addr $I10, rxcap_701_fail
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  # rx literal  "$"
    add $I11, rx692_pos, 1
    gt $I11, rx692_eos, rx692_fail
    sub $I11, rx692_pos, rx692_off
    ord $I11, rx692_tgt, $I11
    ne $I11, 36, rx692_fail
    add rx692_pos, 1
    set_addr $I10, rxcap_701_fail
    ($I12, $I11) = rx692_cur."!mark_peek"($I10)
    rx692_cur."!cursor_pos"($I11)
    ($P10) = rx692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx692_pos, "")
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_701_done
  rxcap_701_fail:
    goto rx692_fail
  rxcap_701_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_702_fail
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx692_pos, rx692_eos, rx692_fail
    sub $I10, rx692_pos, rx692_off
    substr $S10, rx692_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx692_fail
    inc rx692_pos
    set_addr $I10, rxcap_702_fail
    ($I12, $I11) = rx692_cur."!mark_peek"($I10)
    rx692_cur."!cursor_pos"($I11)
    ($P10) = rx692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx692_pos, "")
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_702_done
  rxcap_702_fail:
    goto rx692_fail
  rxcap_702_done:
  alt698_end:
.annotate 'line', 298
  # rx pass
    rx692_cur."!cursor_pass"(rx692_pos, "variable")
    if_null rx692_debug, debug_851
    rx692_cur."!cursor_debug"("PASS", "variable", " at pos=", rx692_pos)
  debug_851:
    .return (rx692_cur)
  rx692_restart:
.annotate 'line', 10
    if_null rx692_debug, debug_852
    rx692_cur."!cursor_debug"("NEXT", "variable")
  debug_852:
  rx692_fail:
    (rx692_rep, rx692_pos, $I10, $P10) = rx692_cur."!mark_fail"(0)
    lt rx692_pos, -1, rx692_done
    eq rx692_pos, -1, rx692_fail
    jump $I10
  rx692_done:
    rx692_cur."!cursor_fail"()
    if_null rx692_debug, debug_853
    rx692_cur."!cursor_debug"("FAIL", "variable")
  debug_853:
    .return (rx692_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1303739803.72") :method
.annotate 'line', 10
    $P694 = self."!PREFIX__!subrule"("sigil", "")
    $P695 = self."!PREFIX__!subrule"("sigil", "")
    new $P696, "ResizablePMCArray"
    push $P696, "$!"
    push $P696, "$_"
    push $P696, "$/"
    push $P696, $P694
    push $P696, $P695
    .return ($P696)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx704_tgt
    .local int rx704_pos
    .local int rx704_off
    .local int rx704_eos
    .local int rx704_rep
    .local pmc rx704_cur
    .local pmc rx704_debug
    (rx704_cur, rx704_pos, rx704_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx704_cur
    .local pmc match
    .lex "$/", match
    length rx704_eos, rx704_tgt
    gt rx704_pos, rx704_eos, rx704_done
    set rx704_off, 0
    lt rx704_pos, 2, rx704_start
    sub rx704_off, rx704_pos, 1
    substr rx704_tgt, rx704_tgt, rx704_off
  rx704_start:
    eq $I10, 1, rx704_restart
    if_null rx704_debug, debug_854
    rx704_cur."!cursor_debug"("START", "sigil")
  debug_854:
    $I10 = self.'from'()
    ne $I10, -1, rxscan707_done
    goto rxscan707_scan
  rxscan707_loop:
    (rx704_pos) = rx704_cur."from"()
    inc rx704_pos
    rx704_cur."!cursor_from"(rx704_pos)
    ge rx704_pos, rx704_eos, rxscan707_done
  rxscan707_scan:
    set_addr $I10, rxscan707_loop
    rx704_cur."!mark_push"(0, rx704_pos, $I10)
  rxscan707_done:
.annotate 'line', 304
  # rx enumcharlist negate=0 
    ge rx704_pos, rx704_eos, rx704_fail
    sub $I10, rx704_pos, rx704_off
    substr $S10, rx704_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx704_fail
    inc rx704_pos
  # rx pass
    rx704_cur."!cursor_pass"(rx704_pos, "sigil")
    if_null rx704_debug, debug_855
    rx704_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx704_pos)
  debug_855:
    .return (rx704_cur)
  rx704_restart:
.annotate 'line', 10
    if_null rx704_debug, debug_856
    rx704_cur."!cursor_debug"("NEXT", "sigil")
  debug_856:
  rx704_fail:
    (rx704_rep, rx704_pos, $I10, $P10) = rx704_cur."!mark_fail"(0)
    lt rx704_pos, -1, rx704_done
    eq rx704_pos, -1, rx704_fail
    jump $I10
  rx704_done:
    rx704_cur."!cursor_fail"()
    if_null rx704_debug, debug_857
    rx704_cur."!cursor_debug"("FAIL", "sigil")
  debug_857:
    .return (rx704_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1303739803.72") :method
.annotate 'line', 10
    new $P706, "ResizablePMCArray"
    push $P706, "&"
    push $P706, "%"
    push $P706, "@"
    push $P706, "$"
    .return ($P706)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx709_tgt
    .local int rx709_pos
    .local int rx709_off
    .local int rx709_eos
    .local int rx709_rep
    .local pmc rx709_cur
    .local pmc rx709_debug
    (rx709_cur, rx709_pos, rx709_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx709_cur
    .local pmc match
    .lex "$/", match
    length rx709_eos, rx709_tgt
    gt rx709_pos, rx709_eos, rx709_done
    set rx709_off, 0
    lt rx709_pos, 2, rx709_start
    sub rx709_off, rx709_pos, 1
    substr rx709_tgt, rx709_tgt, rx709_off
  rx709_start:
    eq $I10, 1, rx709_restart
    if_null rx709_debug, debug_858
    rx709_cur."!cursor_debug"("START", "twigil")
  debug_858:
    $I10 = self.'from'()
    ne $I10, -1, rxscan712_done
    goto rxscan712_scan
  rxscan712_loop:
    (rx709_pos) = rx709_cur."from"()
    inc rx709_pos
    rx709_cur."!cursor_from"(rx709_pos)
    ge rx709_pos, rx709_eos, rxscan712_done
  rxscan712_scan:
    set_addr $I10, rxscan712_loop
    rx709_cur."!mark_push"(0, rx709_pos, $I10)
  rxscan712_done:
.annotate 'line', 306
  # rx enumcharlist negate=0 
    ge rx709_pos, rx709_eos, rx709_fail
    sub $I10, rx709_pos, rx709_off
    substr $S10, rx709_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx709_fail
    inc rx709_pos
  # rx pass
    rx709_cur."!cursor_pass"(rx709_pos, "twigil")
    if_null rx709_debug, debug_859
    rx709_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx709_pos)
  debug_859:
    .return (rx709_cur)
  rx709_restart:
.annotate 'line', 10
    if_null rx709_debug, debug_860
    rx709_cur."!cursor_debug"("NEXT", "twigil")
  debug_860:
  rx709_fail:
    (rx709_rep, rx709_pos, $I10, $P10) = rx709_cur."!mark_fail"(0)
    lt rx709_pos, -1, rx709_done
    eq rx709_pos, -1, rx709_fail
    jump $I10
  rx709_done:
    rx709_cur."!cursor_fail"()
    if_null rx709_debug, debug_861
    rx709_cur."!cursor_debug"("FAIL", "twigil")
  debug_861:
    .return (rx709_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1303739803.72") :method
.annotate 'line', 10
    new $P711, "ResizablePMCArray"
    push $P711, "?"
    push $P711, "!"
    push $P711, "*"
    .return ($P711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1303739803.72")
    .param pmc param_714
.annotate 'line', 308
    .lex "self", param_714
    $P715 = param_714."!protoregex"("package_declarator")
    .return ($P715)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1303739803.72")
    .param pmc param_717
.annotate 'line', 308
    .lex "self", param_717
    $P718 = param_717."!PREFIX__!protoregex"("package_declarator")
    .return ($P718)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 310
    new $P720, "Undef"
    .lex "$*OUTERPACKAGE", $P720
.annotate 'line', 311
    new $P721, "Undef"
    .lex "$*PACKAGE-SETUP", $P721
.annotate 'line', 312
    new $P722, "Undef"
    .lex "$*PKGDECL", $P722
.annotate 'line', 10
    .local string rx723_tgt
    .local int rx723_pos
    .local int rx723_off
    .local int rx723_eos
    .local int rx723_rep
    .local pmc rx723_cur
    .local pmc rx723_debug
    (rx723_cur, rx723_pos, rx723_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx723_cur
    .local pmc match
    .lex "$/", match
    length rx723_eos, rx723_tgt
    gt rx723_pos, rx723_eos, rx723_done
    set rx723_off, 0
    lt rx723_pos, 2, rx723_start
    sub rx723_off, rx723_pos, 1
    substr rx723_tgt, rx723_tgt, rx723_off
  rx723_start:
    eq $I10, 1, rx723_restart
    if_null rx723_debug, debug_862
    rx723_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_862:
    $I10 = self.'from'()
    ne $I10, -1, rxscan727_done
    goto rxscan727_scan
  rxscan727_loop:
    (rx723_pos) = rx723_cur."from"()
    inc rx723_pos
    rx723_cur."!cursor_from"(rx723_pos)
    ge rx723_pos, rx723_eos, rxscan727_done
  rxscan727_scan:
    set_addr $I10, rxscan727_loop
    rx723_cur."!mark_push"(0, rx723_pos, $I10)
  rxscan727_done:
.annotate 'line', 310
    rx723_cur."!cursor_pos"(rx723_pos)
    find_dynamic_lex $P730, "$*PACKAGE"
    unless_null $P730, vivify_863
    get_hll_global $P728, "GLOBAL"
    get_who $P729, $P728
    set $P730, $P729["$PACKAGE"]
    unless_null $P730, vivify_864
    die "Contextual $*PACKAGE not found"
  vivify_864:
  vivify_863:
    store_lex "$*OUTERPACKAGE", $P730
.annotate 'line', 311
    rx723_cur."!cursor_pos"(rx723_pos)
    get_hll_global $P731, "GLOBAL"
    nqp_get_package_through_who $P732, $P731, "PAST"
    get_who $P733, $P732
    set $P734, $P733["Stmts"]
    $P735 = $P734."new"()
    store_lex "$*PACKAGE-SETUP", $P735
.annotate 'line', 312
    rx723_cur."!cursor_pos"(rx723_pos)
    new $P736, "String"
    assign $P736, "module"
    store_lex "$*PKGDECL", $P736
.annotate 'line', 313
  # rx subcapture "sym"
    set_addr $I10, rxcap_737_fail
    rx723_cur."!mark_push"(0, rx723_pos, $I10)
  # rx literal  "module"
    add $I11, rx723_pos, 6
    gt $I11, rx723_eos, rx723_fail
    sub $I11, rx723_pos, rx723_off
    substr $S10, rx723_tgt, $I11, 6
    ne $S10, "module", rx723_fail
    add rx723_pos, 6
    set_addr $I10, rxcap_737_fail
    ($I12, $I11) = rx723_cur."!mark_peek"($I10)
    rx723_cur."!cursor_pos"($I11)
    ($P10) = rx723_cur."!cursor_start"()
    $P10."!cursor_pass"(rx723_pos, "")
    rx723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_737_done
  rxcap_737_fail:
    goto rx723_fail
  rxcap_737_done:
  # rx subrule "package_def" subtype=capture negate=
    rx723_cur."!cursor_pos"(rx723_pos)
    $P10 = rx723_cur."package_def"()
    unless $P10, rx723_fail
    rx723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx723_pos = $P10."pos"()
.annotate 'line', 309
  # rx pass
    rx723_cur."!cursor_pass"(rx723_pos, "package_declarator:sym<module>")
    if_null rx723_debug, debug_865
    rx723_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx723_pos)
  debug_865:
    .return (rx723_cur)
  rx723_restart:
.annotate 'line', 10
    if_null rx723_debug, debug_866
    rx723_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_866:
  rx723_fail:
    (rx723_rep, rx723_pos, $I10, $P10) = rx723_cur."!mark_fail"(0)
    lt rx723_pos, -1, rx723_done
    eq rx723_pos, -1, rx723_fail
    jump $I10
  rx723_done:
    rx723_cur."!cursor_fail"()
    if_null rx723_debug, debug_867
    rx723_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_867:
    .return (rx723_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1303739803.72") :method
.annotate 'line', 10
    $P725 = self."!PREFIX__!subrule"("package_def", "module")
    new $P726, "ResizablePMCArray"
    push $P726, $P725
    .return ($P726)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 316
    new $P739, "Undef"
    .lex "$*OUTERPACKAGE", $P739
.annotate 'line', 317
    new $P740, "Undef"
    .lex "$*PACKAGE-SETUP", $P740
.annotate 'line', 318
    new $P741, "Undef"
    .lex "$*PKGDECL", $P741
.annotate 'line', 10
    .local string rx742_tgt
    .local int rx742_pos
    .local int rx742_off
    .local int rx742_eos
    .local int rx742_rep
    .local pmc rx742_cur
    .local pmc rx742_debug
    (rx742_cur, rx742_pos, rx742_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx742_cur
    .local pmc match
    .lex "$/", match
    length rx742_eos, rx742_tgt
    gt rx742_pos, rx742_eos, rx742_done
    set rx742_off, 0
    lt rx742_pos, 2, rx742_start
    sub rx742_off, rx742_pos, 1
    substr rx742_tgt, rx742_tgt, rx742_off
  rx742_start:
    eq $I10, 1, rx742_restart
    if_null rx742_debug, debug_868
    rx742_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan746_done
    goto rxscan746_scan
  rxscan746_loop:
    (rx742_pos) = rx742_cur."from"()
    inc rx742_pos
    rx742_cur."!cursor_from"(rx742_pos)
    ge rx742_pos, rx742_eos, rxscan746_done
  rxscan746_scan:
    set_addr $I10, rxscan746_loop
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  rxscan746_done:
.annotate 'line', 316
    rx742_cur."!cursor_pos"(rx742_pos)
    find_dynamic_lex $P749, "$*PACKAGE"
    unless_null $P749, vivify_869
    get_hll_global $P747, "GLOBAL"
    get_who $P748, $P747
    set $P749, $P748["$PACKAGE"]
    unless_null $P749, vivify_870
    die "Contextual $*PACKAGE not found"
  vivify_870:
  vivify_869:
    store_lex "$*OUTERPACKAGE", $P749
.annotate 'line', 317
    rx742_cur."!cursor_pos"(rx742_pos)
    get_hll_global $P750, "GLOBAL"
    nqp_get_package_through_who $P751, $P750, "PAST"
    get_who $P752, $P751
    set $P753, $P752["Stmts"]
    $P754 = $P753."new"()
    store_lex "$*PACKAGE-SETUP", $P754
.annotate 'line', 318
    rx742_cur."!cursor_pos"(rx742_pos)
    new $P755, "String"
    assign $P755, "knowhow"
    store_lex "$*PKGDECL", $P755
.annotate 'line', 319
  # rx subcapture "sym"
    set_addr $I10, rxcap_756_fail
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx742_pos, 7
    gt $I11, rx742_eos, rx742_fail
    sub $I11, rx742_pos, rx742_off
    substr $S10, rx742_tgt, $I11, 7
    ne $S10, "knowhow", rx742_fail
    add rx742_pos, 7
    set_addr $I10, rxcap_756_fail
    ($I12, $I11) = rx742_cur."!mark_peek"($I10)
    rx742_cur."!cursor_pos"($I11)
    ($P10) = rx742_cur."!cursor_start"()
    $P10."!cursor_pass"(rx742_pos, "")
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_756_done
  rxcap_756_fail:
    goto rx742_fail
  rxcap_756_done:
  # rx subrule "package_def" subtype=capture negate=
    rx742_cur."!cursor_pos"(rx742_pos)
    $P10 = rx742_cur."package_def"()
    unless $P10, rx742_fail
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx742_pos = $P10."pos"()
.annotate 'line', 315
  # rx pass
    rx742_cur."!cursor_pass"(rx742_pos, "package_declarator:sym<knowhow>")
    if_null rx742_debug, debug_871
    rx742_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx742_pos)
  debug_871:
    .return (rx742_cur)
  rx742_restart:
.annotate 'line', 10
    if_null rx742_debug, debug_872
    rx742_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_872:
  rx742_fail:
    (rx742_rep, rx742_pos, $I10, $P10) = rx742_cur."!mark_fail"(0)
    lt rx742_pos, -1, rx742_done
    eq rx742_pos, -1, rx742_fail
    jump $I10
  rx742_done:
    rx742_cur."!cursor_fail"()
    if_null rx742_debug, debug_873
    rx742_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_873:
    .return (rx742_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1303739803.72") :method
.annotate 'line', 10
    $P744 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P745, "ResizablePMCArray"
    push $P745, $P744
    .return ($P745)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 322
    new $P758, "Undef"
    .lex "$*OUTERPACKAGE", $P758
.annotate 'line', 323
    new $P759, "Undef"
    .lex "$*PACKAGE-SETUP", $P759
.annotate 'line', 324
    new $P760, "Undef"
    .lex "$*PKGDECL", $P760
.annotate 'line', 10
    .local string rx761_tgt
    .local int rx761_pos
    .local int rx761_off
    .local int rx761_eos
    .local int rx761_rep
    .local pmc rx761_cur
    .local pmc rx761_debug
    (rx761_cur, rx761_pos, rx761_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx761_cur
    .local pmc match
    .lex "$/", match
    length rx761_eos, rx761_tgt
    gt rx761_pos, rx761_eos, rx761_done
    set rx761_off, 0
    lt rx761_pos, 2, rx761_start
    sub rx761_off, rx761_pos, 1
    substr rx761_tgt, rx761_tgt, rx761_off
  rx761_start:
    eq $I10, 1, rx761_restart
    if_null rx761_debug, debug_874
    rx761_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_874:
    $I10 = self.'from'()
    ne $I10, -1, rxscan765_done
    goto rxscan765_scan
  rxscan765_loop:
    (rx761_pos) = rx761_cur."from"()
    inc rx761_pos
    rx761_cur."!cursor_from"(rx761_pos)
    ge rx761_pos, rx761_eos, rxscan765_done
  rxscan765_scan:
    set_addr $I10, rxscan765_loop
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  rxscan765_done:
.annotate 'line', 322
    rx761_cur."!cursor_pos"(rx761_pos)
    find_dynamic_lex $P768, "$*PACKAGE"
    unless_null $P768, vivify_875
    get_hll_global $P766, "GLOBAL"
    get_who $P767, $P766
    set $P768, $P767["$PACKAGE"]
    unless_null $P768, vivify_876
    die "Contextual $*PACKAGE not found"
  vivify_876:
  vivify_875:
    store_lex "$*OUTERPACKAGE", $P768
.annotate 'line', 323
    rx761_cur."!cursor_pos"(rx761_pos)
    get_hll_global $P769, "GLOBAL"
    nqp_get_package_through_who $P770, $P769, "PAST"
    get_who $P771, $P770
    set $P772, $P771["Stmts"]
    $P773 = $P772."new"()
    store_lex "$*PACKAGE-SETUP", $P773
.annotate 'line', 324
    rx761_cur."!cursor_pos"(rx761_pos)
    new $P774, "String"
    assign $P774, "class"
    store_lex "$*PKGDECL", $P774
.annotate 'line', 325
  # rx subcapture "sym"
    set_addr $I10, rxcap_775_fail
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  # rx literal  "class"
    add $I11, rx761_pos, 5
    gt $I11, rx761_eos, rx761_fail
    sub $I11, rx761_pos, rx761_off
    substr $S10, rx761_tgt, $I11, 5
    ne $S10, "class", rx761_fail
    add rx761_pos, 5
    set_addr $I10, rxcap_775_fail
    ($I12, $I11) = rx761_cur."!mark_peek"($I10)
    rx761_cur."!cursor_pos"($I11)
    ($P10) = rx761_cur."!cursor_start"()
    $P10."!cursor_pass"(rx761_pos, "")
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_775_done
  rxcap_775_fail:
    goto rx761_fail
  rxcap_775_done:
  # rx subrule "package_def" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."package_def"()
    unless $P10, rx761_fail
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx761_pos = $P10."pos"()
.annotate 'line', 321
  # rx pass
    rx761_cur."!cursor_pass"(rx761_pos, "package_declarator:sym<class>")
    if_null rx761_debug, debug_877
    rx761_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx761_pos)
  debug_877:
    .return (rx761_cur)
  rx761_restart:
.annotate 'line', 10
    if_null rx761_debug, debug_878
    rx761_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_878:
  rx761_fail:
    (rx761_rep, rx761_pos, $I10, $P10) = rx761_cur."!mark_fail"(0)
    lt rx761_pos, -1, rx761_done
    eq rx761_pos, -1, rx761_fail
    jump $I10
  rx761_done:
    rx761_cur."!cursor_fail"()
    if_null rx761_debug, debug_879
    rx761_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_879:
    .return (rx761_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1303739803.72") :method
.annotate 'line', 10
    $P763 = self."!PREFIX__!subrule"("package_def", "class")
    new $P764, "ResizablePMCArray"
    push $P764, $P763
    .return ($P764)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 328
    new $P777, "Undef"
    .lex "$*OUTERPACKAGE", $P777
.annotate 'line', 329
    new $P778, "Undef"
    .lex "$*PACKAGE-SETUP", $P778
.annotate 'line', 330
    new $P779, "Undef"
    .lex "$*PKGDECL", $P779
.annotate 'line', 10
    .local string rx780_tgt
    .local int rx780_pos
    .local int rx780_off
    .local int rx780_eos
    .local int rx780_rep
    .local pmc rx780_cur
    .local pmc rx780_debug
    (rx780_cur, rx780_pos, rx780_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx780_cur
    .local pmc match
    .lex "$/", match
    length rx780_eos, rx780_tgt
    gt rx780_pos, rx780_eos, rx780_done
    set rx780_off, 0
    lt rx780_pos, 2, rx780_start
    sub rx780_off, rx780_pos, 1
    substr rx780_tgt, rx780_tgt, rx780_off
  rx780_start:
    eq $I10, 1, rx780_restart
    if_null rx780_debug, debug_880
    rx780_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_880:
    $I10 = self.'from'()
    ne $I10, -1, rxscan784_done
    goto rxscan784_scan
  rxscan784_loop:
    (rx780_pos) = rx780_cur."from"()
    inc rx780_pos
    rx780_cur."!cursor_from"(rx780_pos)
    ge rx780_pos, rx780_eos, rxscan784_done
  rxscan784_scan:
    set_addr $I10, rxscan784_loop
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  rxscan784_done:
.annotate 'line', 328
    rx780_cur."!cursor_pos"(rx780_pos)
    find_dynamic_lex $P787, "$*PACKAGE"
    unless_null $P787, vivify_881
    get_hll_global $P785, "GLOBAL"
    get_who $P786, $P785
    set $P787, $P786["$PACKAGE"]
    unless_null $P787, vivify_882
    die "Contextual $*PACKAGE not found"
  vivify_882:
  vivify_881:
    store_lex "$*OUTERPACKAGE", $P787
.annotate 'line', 329
    rx780_cur."!cursor_pos"(rx780_pos)
    get_hll_global $P788, "GLOBAL"
    nqp_get_package_through_who $P789, $P788, "PAST"
    get_who $P790, $P789
    set $P791, $P790["Stmts"]
    $P792 = $P791."new"()
    store_lex "$*PACKAGE-SETUP", $P792
.annotate 'line', 330
    rx780_cur."!cursor_pos"(rx780_pos)
    new $P793, "String"
    assign $P793, "grammar"
    store_lex "$*PKGDECL", $P793
.annotate 'line', 331
  # rx subcapture "sym"
    set_addr $I10, rxcap_794_fail
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx780_pos, 7
    gt $I11, rx780_eos, rx780_fail
    sub $I11, rx780_pos, rx780_off
    substr $S10, rx780_tgt, $I11, 7
    ne $S10, "grammar", rx780_fail
    add rx780_pos, 7
    set_addr $I10, rxcap_794_fail
    ($I12, $I11) = rx780_cur."!mark_peek"($I10)
    rx780_cur."!cursor_pos"($I11)
    ($P10) = rx780_cur."!cursor_start"()
    $P10."!cursor_pass"(rx780_pos, "")
    rx780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_794_done
  rxcap_794_fail:
    goto rx780_fail
  rxcap_794_done:
  # rx subrule "package_def" subtype=capture negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."package_def"()
    unless $P10, rx780_fail
    rx780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx780_pos = $P10."pos"()
.annotate 'line', 327
  # rx pass
    rx780_cur."!cursor_pass"(rx780_pos, "package_declarator:sym<grammar>")
    if_null rx780_debug, debug_883
    rx780_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx780_pos)
  debug_883:
    .return (rx780_cur)
  rx780_restart:
.annotate 'line', 10
    if_null rx780_debug, debug_884
    rx780_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_884:
  rx780_fail:
    (rx780_rep, rx780_pos, $I10, $P10) = rx780_cur."!mark_fail"(0)
    lt rx780_pos, -1, rx780_done
    eq rx780_pos, -1, rx780_fail
    jump $I10
  rx780_done:
    rx780_cur."!cursor_fail"()
    if_null rx780_debug, debug_885
    rx780_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_885:
    .return (rx780_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1303739803.72") :method
.annotate 'line', 10
    $P782 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P783, "ResizablePMCArray"
    push $P783, $P782
    .return ($P783)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 334
    new $P796, "Undef"
    .lex "$*OUTERPACKAGE", $P796
.annotate 'line', 335
    new $P797, "Undef"
    .lex "$*PACKAGE-SETUP", $P797
.annotate 'line', 336
    new $P798, "Undef"
    .lex "$*PKGDECL", $P798
.annotate 'line', 10
    .local string rx799_tgt
    .local int rx799_pos
    .local int rx799_off
    .local int rx799_eos
    .local int rx799_rep
    .local pmc rx799_cur
    .local pmc rx799_debug
    (rx799_cur, rx799_pos, rx799_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx799_cur
    .local pmc match
    .lex "$/", match
    length rx799_eos, rx799_tgt
    gt rx799_pos, rx799_eos, rx799_done
    set rx799_off, 0
    lt rx799_pos, 2, rx799_start
    sub rx799_off, rx799_pos, 1
    substr rx799_tgt, rx799_tgt, rx799_off
  rx799_start:
    eq $I10, 1, rx799_restart
    if_null rx799_debug, debug_886
    rx799_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_886:
    $I10 = self.'from'()
    ne $I10, -1, rxscan803_done
    goto rxscan803_scan
  rxscan803_loop:
    (rx799_pos) = rx799_cur."from"()
    inc rx799_pos
    rx799_cur."!cursor_from"(rx799_pos)
    ge rx799_pos, rx799_eos, rxscan803_done
  rxscan803_scan:
    set_addr $I10, rxscan803_loop
    rx799_cur."!mark_push"(0, rx799_pos, $I10)
  rxscan803_done:
.annotate 'line', 334
    rx799_cur."!cursor_pos"(rx799_pos)
    find_dynamic_lex $P806, "$*PACKAGE"
    unless_null $P806, vivify_887
    get_hll_global $P804, "GLOBAL"
    get_who $P805, $P804
    set $P806, $P805["$PACKAGE"]
    unless_null $P806, vivify_888
    die "Contextual $*PACKAGE not found"
  vivify_888:
  vivify_887:
    store_lex "$*OUTERPACKAGE", $P806
.annotate 'line', 335
    rx799_cur."!cursor_pos"(rx799_pos)
    get_hll_global $P807, "GLOBAL"
    nqp_get_package_through_who $P808, $P807, "PAST"
    get_who $P809, $P808
    set $P810, $P809["Stmts"]
    $P811 = $P810."new"()
    store_lex "$*PACKAGE-SETUP", $P811
.annotate 'line', 336
    rx799_cur."!cursor_pos"(rx799_pos)
    new $P812, "String"
    assign $P812, "role"
    store_lex "$*PKGDECL", $P812
.annotate 'line', 337
  # rx subcapture "sym"
    set_addr $I10, rxcap_813_fail
    rx799_cur."!mark_push"(0, rx799_pos, $I10)
  # rx literal  "role"
    add $I11, rx799_pos, 4
    gt $I11, rx799_eos, rx799_fail
    sub $I11, rx799_pos, rx799_off
    substr $S10, rx799_tgt, $I11, 4
    ne $S10, "role", rx799_fail
    add rx799_pos, 4
    set_addr $I10, rxcap_813_fail
    ($I12, $I11) = rx799_cur."!mark_peek"($I10)
    rx799_cur."!cursor_pos"($I11)
    ($P10) = rx799_cur."!cursor_start"()
    $P10."!cursor_pass"(rx799_pos, "")
    rx799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_813_done
  rxcap_813_fail:
    goto rx799_fail
  rxcap_813_done:
  # rx subrule "package_def" subtype=capture negate=
    rx799_cur."!cursor_pos"(rx799_pos)
    $P10 = rx799_cur."package_def"()
    unless $P10, rx799_fail
    rx799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx799_pos = $P10."pos"()
.annotate 'line', 333
  # rx pass
    rx799_cur."!cursor_pass"(rx799_pos, "package_declarator:sym<role>")
    if_null rx799_debug, debug_889
    rx799_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx799_pos)
  debug_889:
    .return (rx799_cur)
  rx799_restart:
.annotate 'line', 10
    if_null rx799_debug, debug_890
    rx799_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_890:
  rx799_fail:
    (rx799_rep, rx799_pos, $I10, $P10) = rx799_cur."!mark_fail"(0)
    lt rx799_pos, -1, rx799_done
    eq rx799_pos, -1, rx799_fail
    jump $I10
  rx799_done:
    rx799_cur."!cursor_fail"()
    if_null rx799_debug, debug_891
    rx799_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_891:
    .return (rx799_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1303739803.72") :method
.annotate 'line', 10
    $P801 = self."!PREFIX__!subrule"("package_def", "role")
    new $P802, "ResizablePMCArray"
    push $P802, $P801
    .return ($P802)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 340
    new $P815, "Undef"
    .lex "$*OUTERPACKAGE", $P815
.annotate 'line', 341
    new $P816, "Undef"
    .lex "$*PACKAGE-SETUP", $P816
.annotate 'line', 342
    new $P817, "Undef"
    .lex "$*PKGDECL", $P817
.annotate 'line', 10
    .local string rx818_tgt
    .local int rx818_pos
    .local int rx818_off
    .local int rx818_eos
    .local int rx818_rep
    .local pmc rx818_cur
    .local pmc rx818_debug
    (rx818_cur, rx818_pos, rx818_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx818_cur
    .local pmc match
    .lex "$/", match
    length rx818_eos, rx818_tgt
    gt rx818_pos, rx818_eos, rx818_done
    set rx818_off, 0
    lt rx818_pos, 2, rx818_start
    sub rx818_off, rx818_pos, 1
    substr rx818_tgt, rx818_tgt, rx818_off
  rx818_start:
    eq $I10, 1, rx818_restart
    if_null rx818_debug, debug_892
    rx818_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_892:
    $I10 = self.'from'()
    ne $I10, -1, rxscan822_done
    goto rxscan822_scan
  rxscan822_loop:
    (rx818_pos) = rx818_cur."from"()
    inc rx818_pos
    rx818_cur."!cursor_from"(rx818_pos)
    ge rx818_pos, rx818_eos, rxscan822_done
  rxscan822_scan:
    set_addr $I10, rxscan822_loop
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  rxscan822_done:
.annotate 'line', 340
    rx818_cur."!cursor_pos"(rx818_pos)
    find_dynamic_lex $P825, "$*PACKAGE"
    unless_null $P825, vivify_893
    get_hll_global $P823, "GLOBAL"
    get_who $P824, $P823
    set $P825, $P824["$PACKAGE"]
    unless_null $P825, vivify_894
    die "Contextual $*PACKAGE not found"
  vivify_894:
  vivify_893:
    store_lex "$*OUTERPACKAGE", $P825
.annotate 'line', 341
    rx818_cur."!cursor_pos"(rx818_pos)
    get_hll_global $P826, "GLOBAL"
    nqp_get_package_through_who $P827, $P826, "PAST"
    get_who $P828, $P827
    set $P829, $P828["Stmts"]
    $P830 = $P829."new"()
    store_lex "$*PACKAGE-SETUP", $P830
.annotate 'line', 342
    rx818_cur."!cursor_pos"(rx818_pos)
    new $P831, "String"
    assign $P831, "native"
    store_lex "$*PKGDECL", $P831
.annotate 'line', 343
  # rx subcapture "sym"
    set_addr $I10, rxcap_832_fail
    rx818_cur."!mark_push"(0, rx818_pos, $I10)
  # rx literal  "native"
    add $I11, rx818_pos, 6
    gt $I11, rx818_eos, rx818_fail
    sub $I11, rx818_pos, rx818_off
    substr $S10, rx818_tgt, $I11, 6
    ne $S10, "native", rx818_fail
    add rx818_pos, 6
    set_addr $I10, rxcap_832_fail
    ($I12, $I11) = rx818_cur."!mark_peek"($I10)
    rx818_cur."!cursor_pos"($I11)
    ($P10) = rx818_cur."!cursor_start"()
    $P10."!cursor_pass"(rx818_pos, "")
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_832_done
  rxcap_832_fail:
    goto rx818_fail
  rxcap_832_done:
  # rx subrule "package_def" subtype=capture negate=
    rx818_cur."!cursor_pos"(rx818_pos)
    $P10 = rx818_cur."package_def"()
    unless $P10, rx818_fail
    rx818_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx818_pos = $P10."pos"()
.annotate 'line', 339
  # rx pass
    rx818_cur."!cursor_pass"(rx818_pos, "package_declarator:sym<native>")
    if_null rx818_debug, debug_895
    rx818_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx818_pos)
  debug_895:
    .return (rx818_cur)
  rx818_restart:
.annotate 'line', 10
    if_null rx818_debug, debug_896
    rx818_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_896:
  rx818_fail:
    (rx818_rep, rx818_pos, $I10, $P10) = rx818_cur."!mark_fail"(0)
    lt rx818_pos, -1, rx818_done
    eq rx818_pos, -1, rx818_fail
    jump $I10
  rx818_done:
    rx818_cur."!cursor_fail"()
    if_null rx818_debug, debug_897
    rx818_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_897:
    .return (rx818_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1303739803.72") :method
.annotate 'line', 10
    $P820 = self."!PREFIX__!subrule"("package_def", "native")
    new $P821, "ResizablePMCArray"
    push $P821, $P820
    .return ($P821)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P861 = "154_1303739803.72" 
    capture_lex $P861
.annotate 'line', 347
    new $P834, "Undef"
    .lex "$*PACKAGE", $P834
.annotate 'line', 348
    $P835 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P835
.annotate 'line', 10
    .local string rx836_tgt
    .local int rx836_pos
    .local int rx836_off
    .local int rx836_eos
    .local int rx836_rep
    .local pmc rx836_cur
    .local pmc rx836_debug
    (rx836_cur, rx836_pos, rx836_tgt, $I10) = self."!cursor_start"()
    rx836_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx836_cur
    .local pmc match
    .lex "$/", match
    length rx836_eos, rx836_tgt
    gt rx836_pos, rx836_eos, rx836_done
    set rx836_off, 0
    lt rx836_pos, 2, rx836_start
    sub rx836_off, rx836_pos, 1
    substr rx836_tgt, rx836_tgt, rx836_off
  rx836_start:
    eq $I10, 1, rx836_restart
    if_null rx836_debug, debug_898
    rx836_cur."!cursor_debug"("START", "package_def")
  debug_898:
    $I10 = self.'from'()
    ne $I10, -1, rxscan840_done
    goto rxscan840_scan
  rxscan840_loop:
    (rx836_pos) = rx836_cur."from"()
    inc rx836_pos
    rx836_cur."!cursor_from"(rx836_pos)
    ge rx836_pos, rx836_eos, rxscan840_done
  rxscan840_scan:
    set_addr $I10, rxscan840_loop
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxscan840_done:
.annotate 'line', 346
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 347
    rx836_cur."!cursor_pos"(rx836_pos)
    find_lex $P844, "$*PACKAGE"
    unless_null $P844, vivify_899
    get_hll_global $P842, "GLOBAL"
    get_who $P843, $P842
    set $P844, $P843["$PACKAGE"]
    unless_null $P844, vivify_900
    die "Contextual $*PACKAGE not found"
  vivify_900:
  vivify_899:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 348
    rx836_cur."!cursor_pos"(rx836_pos)
    find_lex $P848, "%*ATTR-CHECK"
    unless_null $P848, vivify_901
    get_hll_global $P846, "GLOBAL"
    get_who $P847, $P846
    set $P848, $P847["%ATTR-CHECK"]
    unless_null $P848, vivify_902
    die "Contextual %*ATTR-CHECK not found"
  vivify_902:
  vivify_901:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 350
  # rx subrule "name" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."name"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 351
  # rx rxquantr851 ** 0..1
    set_addr $I10, rxquantr851_done
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxquantr851_loop:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx836_pos, 2
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 2
    ne $S10, "is", rx836_fail
    add rx836_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx836_pos, 5
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 5
    ne $S10, "repr(", rx836_fail
    add rx836_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."quote_EXPR"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx836_pos, 1
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    ord $I11, rx836_tgt, $I11
    ne $I11, 41, rx836_fail
    add rx836_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    set_addr $I10, rxquantr851_done
    (rx836_rep) = rx836_cur."!mark_commit"($I10)
  rxquantr851_done:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 353
    rx836_cur."!cursor_pos"(rx836_pos)
    find_lex $P858, unicode:"$\x{a2}"
    $P859 = $P858."MATCH"()
    store_lex "$/", $P859
    .const 'Sub' $P861 = "154_1303739803.72" 
    capture_lex $P861
    $P983 = $P861()
.annotate 'line', 379
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 381
  # rx rxquantr985 ** 0..1
    set_addr $I10, rxquantr985_done
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxquantr985_loop:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx836_pos, 2
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 2
    ne $S10, "is", rx836_fail
    add rx836_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."name"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    set_addr $I10, rxquantr985_done
    (rx836_rep) = rx836_cur."!mark_commit"($I10)
  rxquantr985_done:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 382
  # rx rxquantr990 ** 0..*
    set_addr $I10, rxquantr990_done
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
  rxquantr990_loop:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx836_pos, 4
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I11, 4
    ne $S10, "does", rx836_fail
    add rx836_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."name"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    set_addr $I10, rxquantr990_done
    (rx836_rep) = rx836_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr990_done
    rx836_cur."!mark_push"(rx836_rep, rx836_pos, $I10)
    goto rxquantr990_loop
  rxquantr990_done:
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  alt995_0:
.annotate 'line', 383
    set_addr $I10, alt995_1
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
.annotate 'line', 384
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx836_pos, 1
    gt $I11, rx836_eos, rx836_fail
    sub $I11, rx836_pos, rx836_off
    ord $I11, rx836_tgt, $I11
    ne $I11, 59, rx836_fail
    add rx836_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."comp_unit"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    goto alt995_end
  alt995_1:
    set_addr $I10, alt995_2
    rx836_cur."!mark_push"(0, rx836_pos, $I10)
.annotate 'line', 385
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx836_pos, rx836_off
    substr $S10, rx836_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx836_fail
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."block"()
    unless $P10, rx836_fail
    rx836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
    goto alt995_end
  alt995_2:
.annotate 'line', 386
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."panic"("Malformed package declaration")
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
  alt995_end:
.annotate 'line', 387
  # rx subrule "ws" subtype=method negate=
    rx836_cur."!cursor_pos"(rx836_pos)
    $P10 = rx836_cur."ws"()
    unless $P10, rx836_fail
    rx836_pos = $P10."pos"()
.annotate 'line', 346
  # rx pass
    rx836_cur."!cursor_pass"(rx836_pos, "package_def")
    if_null rx836_debug, debug_970
    rx836_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx836_pos)
  debug_970:
    .return (rx836_cur)
  rx836_restart:
.annotate 'line', 10
    if_null rx836_debug, debug_971
    rx836_cur."!cursor_debug"("NEXT", "package_def")
  debug_971:
  rx836_fail:
    (rx836_rep, rx836_pos, $I10, $P10) = rx836_cur."!mark_fail"(0)
    lt rx836_pos, -1, rx836_done
    eq rx836_pos, -1, rx836_fail
    jump $I10
  rx836_done:
    rx836_cur."!cursor_fail"()
    if_null rx836_debug, debug_972
    rx836_cur."!cursor_debug"("FAIL", "package_def")
  debug_972:
    .return (rx836_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1303739803.72") :method
.annotate 'line', 10
    $P838 = self."!PREFIX__!subrule"("ws", "")
    new $P839, "ResizablePMCArray"
    push $P839, $P838
    .return ($P839)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block860"  :anon :subid("154_1303739803.72") :outer("152_1303739803.72")
.annotate 'line', 356
    $P862 = root_new ['parrot';'Hash']
    .lex "%args", $P862
.annotate 'line', 353
    find_lex $P863, "%args"
    unless_null $P863, vivify_903
    $P863 = root_new ['parrot';'Hash']
  vivify_903:
.annotate 'line', 357
    find_lex $P864, "$/"
    unless_null $P864, vivify_904
    $P864 = root_new ['parrot';'Hash']
  vivify_904:
    set $P865, $P864["name"]
    unless_null $P865, vivify_905
    new $P865, "Undef"
  vivify_905:
    set $S866, $P865
    new $P867, 'String'
    set $P867, $S866
    find_lex $P868, "%args"
    unless_null $P868, vivify_906
    $P868 = root_new ['parrot';'Hash']
    store_lex "%args", $P868
  vivify_906:
    set $P868["name"], $P867
.annotate 'line', 358
    find_lex $P870, "$/"
    unless_null $P870, vivify_907
    $P870 = root_new ['parrot';'Hash']
  vivify_907:
    set $P871, $P870["repr"]
    unless_null $P871, vivify_908
    new $P871, "Undef"
  vivify_908:
    unless $P871, if_869_end
.annotate 'line', 359
    find_lex $P872, "$/"
    unless_null $P872, vivify_909
    $P872 = root_new ['parrot';'Hash']
  vivify_909:
    set $P873, $P872["repr"]
    unless_null $P873, vivify_910
    $P873 = root_new ['parrot';'ResizablePMCArray']
  vivify_910:
    set $P874, $P873[0]
    unless_null $P874, vivify_911
    $P874 = root_new ['parrot';'Hash']
  vivify_911:
    set $P875, $P874["quote_delimited"]
    unless_null $P875, vivify_912
    $P875 = root_new ['parrot';'Hash']
  vivify_912:
    set $P876, $P875["quote_atom"]
    unless_null $P876, vivify_913
    $P876 = root_new ['parrot';'ResizablePMCArray']
  vivify_913:
    set $P877, $P876[0]
    unless_null $P877, vivify_914
    new $P877, "Undef"
  vivify_914:
    set $S878, $P877
    new $P879, 'String'
    set $P879, $S878
    find_lex $P880, "%args"
    unless_null $P880, vivify_915
    $P880 = root_new ['parrot';'Hash']
    store_lex "%args", $P880
  vivify_915:
    set $P880["repr"], $P879
  if_869_end:
.annotate 'line', 361
    find_dynamic_lex $P883, "$*SC"
    unless_null $P883, vivify_916
    get_hll_global $P881, "GLOBAL"
    get_who $P882, $P881
    set $P883, $P882["$SC"]
    unless_null $P883, vivify_917
    die "Contextual $*SC not found"
  vivify_917:
  vivify_916:
    find_dynamic_lex $P886, "$*PKGDECL"
    unless_null $P886, vivify_918
    get_hll_global $P884, "GLOBAL"
    get_who $P885, $P884
    set $P886, $P885["$PKGDECL"]
    unless_null $P886, vivify_919
    die "Contextual $*PKGDECL not found"
  vivify_919:
  vivify_918:
    find_dynamic_lex $P889, "%*HOW"
    unless_null $P889, vivify_920
    get_hll_global $P887, "GLOBAL"
    get_who $P888, $P887
    set $P889, $P888["%HOW"]
    unless_null $P889, vivify_921
    die "Contextual %*HOW not found"
  vivify_921:
  vivify_920:
    set $P890, $P889[$P886]
    unless_null $P890, vivify_922
    new $P890, "Undef"
  vivify_922:
    find_lex $P891, "%args"
    unless_null $P891, vivify_923
    $P891 = root_new ['parrot';'Hash']
  vivify_923:
    $P892 = $P883."pkg_create_mo"($P890, $P891 :flat)
    store_dynamic_lex "$*PACKAGE", $P892
.annotate 'line', 364
    find_dynamic_lex $P899, "$*SCOPE"
    unless_null $P899, vivify_924
    get_hll_global $P897, "GLOBAL"
    get_who $P898, $P897
    set $P899, $P898["$SCOPE"]
    unless_null $P899, vivify_925
    die "Contextual $*SCOPE not found"
  vivify_925:
  vivify_924:
    set $S900, $P899
    iseq $I901, $S900, "our"
    unless $I901, unless_896
    new $P895, 'Integer'
    set $P895, $I901
    goto unless_896_end
  unless_896:
    find_dynamic_lex $P904, "$*SCOPE"
    unless_null $P904, vivify_926
    get_hll_global $P902, "GLOBAL"
    get_who $P903, $P902
    set $P904, $P903["$SCOPE"]
    unless_null $P904, vivify_927
    die "Contextual $*SCOPE not found"
  vivify_927:
  vivify_926:
    set $S905, $P904
    iseq $I906, $S905, ""
    new $P895, 'Integer'
    set $P895, $I906
  unless_896_end:
    if $P895, if_894
.annotate 'line', 370
    find_dynamic_lex $P947, "$*SCOPE"
    unless_null $P947, vivify_928
    get_hll_global $P945, "GLOBAL"
    get_who $P946, $P945
    set $P947, $P946["$SCOPE"]
    unless_null $P947, vivify_929
    die "Contextual $*SCOPE not found"
  vivify_929:
  vivify_928:
    set $S948, $P947
    iseq $I949, $S948, "my"
    if $I949, if_944
.annotate 'line', 377
    find_lex $P976, "$/"
    unless_null $P976, vivify_930
    new $P976, "Undef"
  vivify_930:
    $P977 = $P976."CURSOR"()
    find_dynamic_lex $P980, "$*SCOPE"
    unless_null $P980, vivify_931
    get_hll_global $P978, "GLOBAL"
    get_who $P979, $P978
    set $P980, $P979["$SCOPE"]
    unless_null $P980, vivify_932
    die "Contextual $*SCOPE not found"
  vivify_932:
  vivify_931:
    concat $P981, $P980, " scoped packages are not supported"
    $P982 = $P977."panic"($P981)
.annotate 'line', 376
    set $P943, $P982
.annotate 'line', 370
    goto if_944_end
  if_944:
.annotate 'line', 371
    find_lex $P951, "$/"
    unless_null $P951, vivify_933
    $P951 = root_new ['parrot';'Hash']
  vivify_933:
    set $P952, $P951["name"]
    unless_null $P952, vivify_934
    $P952 = root_new ['parrot';'Hash']
  vivify_934:
    set $P953, $P952["identifier"]
    unless_null $P953, vivify_935
    new $P953, "Undef"
  vivify_935:
    set $N954, $P953
    isne $I955, $N954, 1.0
    unless $I955, if_950_end
.annotate 'line', 372
    find_lex $P956, "$/"
    unless_null $P956, vivify_936
    $P956 = root_new ['parrot';'Hash']
  vivify_936:
    set $P957, $P956["name"]
    unless_null $P957, vivify_937
    new $P957, "Undef"
  vivify_937:
    $P958 = $P957."CURSOR"()
    $P958."panic"("A my scoped package cannot have a multi-part name yet")
  if_950_end:
.annotate 'line', 374
    find_dynamic_lex $P961, "$*SC"
    unless_null $P961, vivify_938
    get_hll_global $P959, "GLOBAL"
    get_who $P960, $P959
    set $P961, $P960["$SC"]
    unless_null $P961, vivify_939
    die "Contextual $*SC not found"
  vivify_939:
  vivify_938:
    get_hll_global $P962, "GLOBAL"
    nqp_get_package_through_who $P963, $P962, "NQP"
    nqp_get_package_through_who $P964, $P963, "Actions"
    get_who $P965, $P964
    set $P966, $P965["@BLOCK"]
    unless_null $P966, vivify_940
    $P966 = root_new ['parrot';'ResizablePMCArray']
  vivify_940:
    set $P967, $P966[0]
    unless_null $P967, vivify_941
    new $P967, "Undef"
  vivify_941:
    find_lex $P968, "$/"
    unless_null $P968, vivify_942
    $P968 = root_new ['parrot';'Hash']
  vivify_942:
    set $P969, $P968["name"]
    unless_null $P969, vivify_943
    $P969 = root_new ['parrot';'Hash']
  vivify_943:
    set $P970, $P969["identifier"]
    unless_null $P970, vivify_944
    $P970 = root_new ['parrot';'ResizablePMCArray']
  vivify_944:
    set $P971, $P970[0]
    unless_null $P971, vivify_945
    new $P971, "Undef"
  vivify_945:
    find_dynamic_lex $P974, "$*PACKAGE"
    unless_null $P974, vivify_946
    get_hll_global $P972, "GLOBAL"
    get_who $P973, $P972
    set $P974, $P973["$PACKAGE"]
    unless_null $P974, vivify_947
    die "Contextual $*PACKAGE not found"
  vivify_947:
  vivify_946:
    $P975 = $P961."install_lexical_symbol"($P967, $P971, $P974)
.annotate 'line', 370
    set $P943, $P975
  if_944_end:
    set $P893, $P943
.annotate 'line', 364
    goto if_894_end
  if_894:
.annotate 'line', 365
    find_dynamic_lex $P909, "$*SC"
    unless_null $P909, vivify_948
    get_hll_global $P907, "GLOBAL"
    get_who $P908, $P907
    set $P909, $P908["$SC"]
    unless_null $P909, vivify_949
    die "Contextual $*SC not found"
  vivify_949:
  vivify_948:
    find_dynamic_lex $P912, "$*OUTERPACKAGE"
    unless_null $P912, vivify_950
    get_hll_global $P910, "GLOBAL"
    get_who $P911, $P910
    set $P912, $P911["$OUTERPACKAGE"]
    unless_null $P912, vivify_951
    die "Contextual $*OUTERPACKAGE not found"
  vivify_951:
  vivify_950:
    find_lex $P913, "$/"
    unless_null $P913, vivify_952
    $P913 = root_new ['parrot';'Hash']
  vivify_952:
    set $P914, $P913["name"]
    unless_null $P914, vivify_953
    $P914 = root_new ['parrot';'Hash']
  vivify_953:
    set $P915, $P914["identifier"]
    unless_null $P915, vivify_954
    new $P915, "Undef"
  vivify_954:
    find_dynamic_lex $P918, "$*PACKAGE"
    unless_null $P918, vivify_955
    get_hll_global $P916, "GLOBAL"
    get_who $P917, $P916
    set $P918, $P917["$PACKAGE"]
    unless_null $P918, vivify_956
    die "Contextual $*PACKAGE not found"
  vivify_956:
  vivify_955:
    $P909."install_package_symbol"($P912, $P915, $P918)
.annotate 'line', 366
    find_lex $P921, "$/"
    unless_null $P921, vivify_957
    $P921 = root_new ['parrot';'Hash']
  vivify_957:
    set $P922, $P921["name"]
    unless_null $P922, vivify_958
    $P922 = root_new ['parrot';'Hash']
  vivify_958:
    set $P923, $P922["identifier"]
    unless_null $P923, vivify_959
    new $P923, "Undef"
  vivify_959:
    set $N924, $P923
    iseq $I925, $N924, 1.0
    if $I925, if_920
    new $P919, 'Integer'
    set $P919, $I925
    goto if_920_end
  if_920:
.annotate 'line', 367
    find_dynamic_lex $P928, "$*SC"
    unless_null $P928, vivify_960
    get_hll_global $P926, "GLOBAL"
    get_who $P927, $P926
    set $P928, $P927["$SC"]
    unless_null $P928, vivify_961
    die "Contextual $*SC not found"
  vivify_961:
  vivify_960:
    get_hll_global $P929, "GLOBAL"
    nqp_get_package_through_who $P930, $P929, "NQP"
    nqp_get_package_through_who $P931, $P930, "Actions"
    get_who $P932, $P931
    set $P933, $P932["@BLOCK"]
    unless_null $P933, vivify_962
    $P933 = root_new ['parrot';'ResizablePMCArray']
  vivify_962:
    set $P934, $P933[0]
    unless_null $P934, vivify_963
    new $P934, "Undef"
  vivify_963:
    find_lex $P935, "$/"
    unless_null $P935, vivify_964
    $P935 = root_new ['parrot';'Hash']
  vivify_964:
    set $P936, $P935["name"]
    unless_null $P936, vivify_965
    $P936 = root_new ['parrot';'Hash']
  vivify_965:
    set $P937, $P936["identifier"]
    unless_null $P937, vivify_966
    $P937 = root_new ['parrot';'ResizablePMCArray']
  vivify_966:
    set $P938, $P937[0]
    unless_null $P938, vivify_967
    new $P938, "Undef"
  vivify_967:
    find_dynamic_lex $P941, "$*PACKAGE"
    unless_null $P941, vivify_968
    get_hll_global $P939, "GLOBAL"
    get_who $P940, $P939
    set $P941, $P940["$PACKAGE"]
    unless_null $P941, vivify_969
    die "Contextual $*PACKAGE not found"
  vivify_969:
  vivify_968:
    $P942 = $P928."install_lexical_symbol"($P934, $P938, $P941)
.annotate 'line', 366
    set $P919, $P942
  if_920_end:
.annotate 'line', 364
    set $P893, $P919
  if_894_end:
.annotate 'line', 353
    .return ($P893)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1303739803.72")
    .param pmc param_1006
.annotate 'line', 390
    .lex "self", param_1006
    $P1007 = param_1006."!protoregex"("scope_declarator")
    .return ($P1007)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1303739803.72")
    .param pmc param_1009
.annotate 'line', 390
    .lex "self", param_1009
    $P1010 = param_1009."!PREFIX__!protoregex"("scope_declarator")
    .return ($P1010)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1012_tgt
    .local int rx1012_pos
    .local int rx1012_off
    .local int rx1012_eos
    .local int rx1012_rep
    .local pmc rx1012_cur
    .local pmc rx1012_debug
    (rx1012_cur, rx1012_pos, rx1012_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1012_cur
    .local pmc match
    .lex "$/", match
    length rx1012_eos, rx1012_tgt
    gt rx1012_pos, rx1012_eos, rx1012_done
    set rx1012_off, 0
    lt rx1012_pos, 2, rx1012_start
    sub rx1012_off, rx1012_pos, 1
    substr rx1012_tgt, rx1012_tgt, rx1012_off
  rx1012_start:
    eq $I10, 1, rx1012_restart
    if_null rx1012_debug, debug_973
    rx1012_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_973:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1016_done
    goto rxscan1016_scan
  rxscan1016_loop:
    (rx1012_pos) = rx1012_cur."from"()
    inc rx1012_pos
    rx1012_cur."!cursor_from"(rx1012_pos)
    ge rx1012_pos, rx1012_eos, rxscan1016_done
  rxscan1016_scan:
    set_addr $I10, rxscan1016_loop
    rx1012_cur."!mark_push"(0, rx1012_pos, $I10)
  rxscan1016_done:
.annotate 'line', 391
  # rx subcapture "sym"
    set_addr $I10, rxcap_1017_fail
    rx1012_cur."!mark_push"(0, rx1012_pos, $I10)
  # rx literal  "my"
    add $I11, rx1012_pos, 2
    gt $I11, rx1012_eos, rx1012_fail
    sub $I11, rx1012_pos, rx1012_off
    substr $S10, rx1012_tgt, $I11, 2
    ne $S10, "my", rx1012_fail
    add rx1012_pos, 2
    set_addr $I10, rxcap_1017_fail
    ($I12, $I11) = rx1012_cur."!mark_peek"($I10)
    rx1012_cur."!cursor_pos"($I11)
    ($P10) = rx1012_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1012_pos, "")
    rx1012_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1017_done
  rxcap_1017_fail:
    goto rx1012_fail
  rxcap_1017_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1012_cur."!cursor_pos"(rx1012_pos)
    $P10 = rx1012_cur."scoped"("my")
    unless $P10, rx1012_fail
    rx1012_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1012_pos = $P10."pos"()
  # rx pass
    rx1012_cur."!cursor_pass"(rx1012_pos, "scope_declarator:sym<my>")
    if_null rx1012_debug, debug_974
    rx1012_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1012_pos)
  debug_974:
    .return (rx1012_cur)
  rx1012_restart:
.annotate 'line', 10
    if_null rx1012_debug, debug_975
    rx1012_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_975:
  rx1012_fail:
    (rx1012_rep, rx1012_pos, $I10, $P10) = rx1012_cur."!mark_fail"(0)
    lt rx1012_pos, -1, rx1012_done
    eq rx1012_pos, -1, rx1012_fail
    jump $I10
  rx1012_done:
    rx1012_cur."!cursor_fail"()
    if_null rx1012_debug, debug_976
    rx1012_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_976:
    .return (rx1012_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1303739803.72") :method
.annotate 'line', 10
    $P1014 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1015, "ResizablePMCArray"
    push $P1015, $P1014
    .return ($P1015)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1019_tgt
    .local int rx1019_pos
    .local int rx1019_off
    .local int rx1019_eos
    .local int rx1019_rep
    .local pmc rx1019_cur
    .local pmc rx1019_debug
    (rx1019_cur, rx1019_pos, rx1019_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1019_cur
    .local pmc match
    .lex "$/", match
    length rx1019_eos, rx1019_tgt
    gt rx1019_pos, rx1019_eos, rx1019_done
    set rx1019_off, 0
    lt rx1019_pos, 2, rx1019_start
    sub rx1019_off, rx1019_pos, 1
    substr rx1019_tgt, rx1019_tgt, rx1019_off
  rx1019_start:
    eq $I10, 1, rx1019_restart
    if_null rx1019_debug, debug_977
    rx1019_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1023_done
    goto rxscan1023_scan
  rxscan1023_loop:
    (rx1019_pos) = rx1019_cur."from"()
    inc rx1019_pos
    rx1019_cur."!cursor_from"(rx1019_pos)
    ge rx1019_pos, rx1019_eos, rxscan1023_done
  rxscan1023_scan:
    set_addr $I10, rxscan1023_loop
    rx1019_cur."!mark_push"(0, rx1019_pos, $I10)
  rxscan1023_done:
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_1024_fail
    rx1019_cur."!mark_push"(0, rx1019_pos, $I10)
  # rx literal  "our"
    add $I11, rx1019_pos, 3
    gt $I11, rx1019_eos, rx1019_fail
    sub $I11, rx1019_pos, rx1019_off
    substr $S10, rx1019_tgt, $I11, 3
    ne $S10, "our", rx1019_fail
    add rx1019_pos, 3
    set_addr $I10, rxcap_1024_fail
    ($I12, $I11) = rx1019_cur."!mark_peek"($I10)
    rx1019_cur."!cursor_pos"($I11)
    ($P10) = rx1019_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1019_pos, "")
    rx1019_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1024_done
  rxcap_1024_fail:
    goto rx1019_fail
  rxcap_1024_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1019_cur."!cursor_pos"(rx1019_pos)
    $P10 = rx1019_cur."scoped"("our")
    unless $P10, rx1019_fail
    rx1019_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1019_pos = $P10."pos"()
  # rx pass
    rx1019_cur."!cursor_pass"(rx1019_pos, "scope_declarator:sym<our>")
    if_null rx1019_debug, debug_978
    rx1019_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1019_pos)
  debug_978:
    .return (rx1019_cur)
  rx1019_restart:
.annotate 'line', 10
    if_null rx1019_debug, debug_979
    rx1019_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_979:
  rx1019_fail:
    (rx1019_rep, rx1019_pos, $I10, $P10) = rx1019_cur."!mark_fail"(0)
    lt rx1019_pos, -1, rx1019_done
    eq rx1019_pos, -1, rx1019_fail
    jump $I10
  rx1019_done:
    rx1019_cur."!cursor_fail"()
    if_null rx1019_debug, debug_980
    rx1019_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_980:
    .return (rx1019_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1303739803.72") :method
.annotate 'line', 10
    $P1021 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1022, "ResizablePMCArray"
    push $P1022, $P1021
    .return ($P1022)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1026_tgt
    .local int rx1026_pos
    .local int rx1026_off
    .local int rx1026_eos
    .local int rx1026_rep
    .local pmc rx1026_cur
    .local pmc rx1026_debug
    (rx1026_cur, rx1026_pos, rx1026_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1026_cur
    .local pmc match
    .lex "$/", match
    length rx1026_eos, rx1026_tgt
    gt rx1026_pos, rx1026_eos, rx1026_done
    set rx1026_off, 0
    lt rx1026_pos, 2, rx1026_start
    sub rx1026_off, rx1026_pos, 1
    substr rx1026_tgt, rx1026_tgt, rx1026_off
  rx1026_start:
    eq $I10, 1, rx1026_restart
    if_null rx1026_debug, debug_981
    rx1026_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1030_done
    goto rxscan1030_scan
  rxscan1030_loop:
    (rx1026_pos) = rx1026_cur."from"()
    inc rx1026_pos
    rx1026_cur."!cursor_from"(rx1026_pos)
    ge rx1026_pos, rx1026_eos, rxscan1030_done
  rxscan1030_scan:
    set_addr $I10, rxscan1030_loop
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
  rxscan1030_done:
.annotate 'line', 393
  # rx subcapture "sym"
    set_addr $I10, rxcap_1031_fail
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
  # rx literal  "has"
    add $I11, rx1026_pos, 3
    gt $I11, rx1026_eos, rx1026_fail
    sub $I11, rx1026_pos, rx1026_off
    substr $S10, rx1026_tgt, $I11, 3
    ne $S10, "has", rx1026_fail
    add rx1026_pos, 3
    set_addr $I10, rxcap_1031_fail
    ($I12, $I11) = rx1026_cur."!mark_peek"($I10)
    rx1026_cur."!cursor_pos"($I11)
    ($P10) = rx1026_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1026_pos, "")
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1031_done
  rxcap_1031_fail:
    goto rx1026_fail
  rxcap_1031_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1026_cur."!cursor_pos"(rx1026_pos)
    $P10 = rx1026_cur."scoped"("has")
    unless $P10, rx1026_fail
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1026_pos = $P10."pos"()
  # rx pass
    rx1026_cur."!cursor_pass"(rx1026_pos, "scope_declarator:sym<has>")
    if_null rx1026_debug, debug_982
    rx1026_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1026_pos)
  debug_982:
    .return (rx1026_cur)
  rx1026_restart:
.annotate 'line', 10
    if_null rx1026_debug, debug_983
    rx1026_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_983:
  rx1026_fail:
    (rx1026_rep, rx1026_pos, $I10, $P10) = rx1026_cur."!mark_fail"(0)
    lt rx1026_pos, -1, rx1026_done
    eq rx1026_pos, -1, rx1026_fail
    jump $I10
  rx1026_done:
    rx1026_cur."!cursor_fail"()
    if_null rx1026_debug, debug_984
    rx1026_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_984:
    .return (rx1026_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1303739803.72") :method
.annotate 'line', 10
    $P1028 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1029, "ResizablePMCArray"
    push $P1029, $P1028
    .return ($P1029)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1303739803.72") :method :outer("12_1303739803.72")
    .param pmc param_1033
.annotate 'line', 395
    .lex "$*SCOPE", param_1033
.annotate 'line', 10
    .local string rx1034_tgt
    .local int rx1034_pos
    .local int rx1034_off
    .local int rx1034_eos
    .local int rx1034_rep
    .local pmc rx1034_cur
    .local pmc rx1034_debug
    (rx1034_cur, rx1034_pos, rx1034_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1034_cur
    .local pmc match
    .lex "$/", match
    length rx1034_eos, rx1034_tgt
    gt rx1034_pos, rx1034_eos, rx1034_done
    set rx1034_off, 0
    lt rx1034_pos, 2, rx1034_start
    sub rx1034_off, rx1034_pos, 1
    substr rx1034_tgt, rx1034_tgt, rx1034_off
  rx1034_start:
    eq $I10, 1, rx1034_restart
    if_null rx1034_debug, debug_985
    rx1034_cur."!cursor_debug"("START", "scoped")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1040_done
    goto rxscan1040_scan
  rxscan1040_loop:
    (rx1034_pos) = rx1034_cur."from"()
    inc rx1034_pos
    rx1034_cur."!cursor_from"(rx1034_pos)
    ge rx1034_pos, rx1034_eos, rxscan1040_done
  rxscan1040_scan:
    set_addr $I10, rxscan1040_loop
    rx1034_cur."!mark_push"(0, rx1034_pos, $I10)
  rxscan1040_done:
  alt1041_0:
.annotate 'line', 395
    set_addr $I10, alt1041_1
    rx1034_cur."!mark_push"(0, rx1034_pos, $I10)
.annotate 'line', 396
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."declarator"()
    unless $P10, rx1034_fail
    rx1034_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1034_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
    goto alt1041_end
  alt1041_1:
    set_addr $I10, alt1041_2
    rx1034_cur."!mark_push"(0, rx1034_pos, $I10)
.annotate 'line', 397
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."multi_declarator"()
    unless $P10, rx1034_fail
    rx1034_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1034_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
    goto alt1041_end
  alt1041_2:
.annotate 'line', 398
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."package_declarator"()
    unless $P10, rx1034_fail
    rx1034_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1034_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1034_cur."!cursor_pos"(rx1034_pos)
    $P10 = rx1034_cur."ws"()
    unless $P10, rx1034_fail
    rx1034_pos = $P10."pos"()
  alt1041_end:
.annotate 'line', 395
  # rx pass
    rx1034_cur."!cursor_pass"(rx1034_pos, "scoped")
    if_null rx1034_debug, debug_986
    rx1034_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1034_pos)
  debug_986:
    .return (rx1034_cur)
  rx1034_restart:
.annotate 'line', 10
    if_null rx1034_debug, debug_987
    rx1034_cur."!cursor_debug"("NEXT", "scoped")
  debug_987:
  rx1034_fail:
    (rx1034_rep, rx1034_pos, $I10, $P10) = rx1034_cur."!mark_fail"(0)
    lt rx1034_pos, -1, rx1034_done
    eq rx1034_pos, -1, rx1034_fail
    jump $I10
  rx1034_done:
    rx1034_cur."!cursor_fail"()
    if_null rx1034_debug, debug_988
    rx1034_cur."!cursor_debug"("FAIL", "scoped")
  debug_988:
    .return (rx1034_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1303739803.72") :method
.annotate 'line', 10
    $P1036 = self."!PREFIX__!subrule"("ws", "")
    $P1037 = self."!PREFIX__!subrule"("ws", "")
    $P1038 = self."!PREFIX__!subrule"("ws", "")
    new $P1039, "ResizablePMCArray"
    push $P1039, $P1036
    push $P1039, $P1037
    push $P1039, $P1038
    .return ($P1039)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1049_tgt
    .local int rx1049_pos
    .local int rx1049_off
    .local int rx1049_eos
    .local int rx1049_rep
    .local pmc rx1049_cur
    .local pmc rx1049_debug
    (rx1049_cur, rx1049_pos, rx1049_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1049_cur
    .local pmc match
    .lex "$/", match
    length rx1049_eos, rx1049_tgt
    gt rx1049_pos, rx1049_eos, rx1049_done
    set rx1049_off, 0
    lt rx1049_pos, 2, rx1049_start
    sub rx1049_off, rx1049_pos, 1
    substr rx1049_tgt, rx1049_tgt, rx1049_off
  rx1049_start:
    eq $I10, 1, rx1049_restart
    if_null rx1049_debug, debug_989
    rx1049_cur."!cursor_debug"("START", "typename")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1053_done
    goto rxscan1053_scan
  rxscan1053_loop:
    (rx1049_pos) = rx1049_cur."from"()
    inc rx1049_pos
    rx1049_cur."!cursor_from"(rx1049_pos)
    ge rx1049_pos, rx1049_eos, rxscan1053_done
  rxscan1053_scan:
    set_addr $I10, rxscan1053_loop
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  rxscan1053_done:
.annotate 'line', 401
  # rx subrule "name" subtype=capture negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."name"()
    unless $P10, rx1049_fail
    rx1049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1049_pos = $P10."pos"()
  # rx pass
    rx1049_cur."!cursor_pass"(rx1049_pos, "typename")
    if_null rx1049_debug, debug_990
    rx1049_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1049_pos)
  debug_990:
    .return (rx1049_cur)
  rx1049_restart:
.annotate 'line', 10
    if_null rx1049_debug, debug_991
    rx1049_cur."!cursor_debug"("NEXT", "typename")
  debug_991:
  rx1049_fail:
    (rx1049_rep, rx1049_pos, $I10, $P10) = rx1049_cur."!mark_fail"(0)
    lt rx1049_pos, -1, rx1049_done
    eq rx1049_pos, -1, rx1049_fail
    jump $I10
  rx1049_done:
    rx1049_cur."!cursor_fail"()
    if_null rx1049_debug, debug_992
    rx1049_cur."!cursor_debug"("FAIL", "typename")
  debug_992:
    .return (rx1049_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1303739803.72") :method
.annotate 'line', 10
    $P1051 = self."!PREFIX__!subrule"("name", "")
    new $P1052, "ResizablePMCArray"
    push $P1052, $P1051
    .return ($P1052)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("167_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1055_tgt
    .local int rx1055_pos
    .local int rx1055_off
    .local int rx1055_eos
    .local int rx1055_rep
    .local pmc rx1055_cur
    .local pmc rx1055_debug
    (rx1055_cur, rx1055_pos, rx1055_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1055_cur
    .local pmc match
    .lex "$/", match
    length rx1055_eos, rx1055_tgt
    gt rx1055_pos, rx1055_eos, rx1055_done
    set rx1055_off, 0
    lt rx1055_pos, 2, rx1055_start
    sub rx1055_off, rx1055_pos, 1
    substr rx1055_tgt, rx1055_tgt, rx1055_off
  rx1055_start:
    eq $I10, 1, rx1055_restart
    if_null rx1055_debug, debug_993
    rx1055_cur."!cursor_debug"("START", "declarator")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1060_done
    goto rxscan1060_scan
  rxscan1060_loop:
    (rx1055_pos) = rx1055_cur."from"()
    inc rx1055_pos
    rx1055_cur."!cursor_from"(rx1055_pos)
    ge rx1055_pos, rx1055_eos, rxscan1060_done
  rxscan1060_scan:
    set_addr $I10, rxscan1060_loop
    rx1055_cur."!mark_push"(0, rx1055_pos, $I10)
  rxscan1060_done:
  alt1061_0:
.annotate 'line', 403
    set_addr $I10, alt1061_1
    rx1055_cur."!mark_push"(0, rx1055_pos, $I10)
.annotate 'line', 404
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1055_cur."!cursor_pos"(rx1055_pos)
    $P10 = rx1055_cur."variable_declarator"()
    unless $P10, rx1055_fail
    rx1055_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1055_pos = $P10."pos"()
    goto alt1061_end
  alt1061_1:
.annotate 'line', 405
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1055_cur."!cursor_pos"(rx1055_pos)
    $P10 = rx1055_cur."routine_declarator"()
    unless $P10, rx1055_fail
    rx1055_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1055_pos = $P10."pos"()
  alt1061_end:
.annotate 'line', 403
  # rx pass
    rx1055_cur."!cursor_pass"(rx1055_pos, "declarator")
    if_null rx1055_debug, debug_994
    rx1055_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1055_pos)
  debug_994:
    .return (rx1055_cur)
  rx1055_restart:
.annotate 'line', 10
    if_null rx1055_debug, debug_995
    rx1055_cur."!cursor_debug"("NEXT", "declarator")
  debug_995:
  rx1055_fail:
    (rx1055_rep, rx1055_pos, $I10, $P10) = rx1055_cur."!mark_fail"(0)
    lt rx1055_pos, -1, rx1055_done
    eq rx1055_pos, -1, rx1055_fail
    jump $I10
  rx1055_done:
    rx1055_cur."!cursor_fail"()
    if_null rx1055_debug, debug_996
    rx1055_cur."!cursor_debug"("FAIL", "declarator")
  debug_996:
    .return (rx1055_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("168_1303739803.72") :method
.annotate 'line', 10
    $P1057 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1058 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1059, "ResizablePMCArray"
    push $P1059, $P1057
    push $P1059, $P1058
    .return ($P1059)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("169_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1063_tgt
    .local int rx1063_pos
    .local int rx1063_off
    .local int rx1063_eos
    .local int rx1063_rep
    .local pmc rx1063_cur
    .local pmc rx1063_debug
    (rx1063_cur, rx1063_pos, rx1063_tgt, $I10) = self."!cursor_start"()
    rx1063_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx1063_cur
    .local pmc match
    .lex "$/", match
    length rx1063_eos, rx1063_tgt
    gt rx1063_pos, rx1063_eos, rx1063_done
    set rx1063_off, 0
    lt rx1063_pos, 2, rx1063_start
    sub rx1063_off, rx1063_pos, 1
    substr rx1063_tgt, rx1063_tgt, rx1063_off
  rx1063_start:
    eq $I10, 1, rx1063_restart
    if_null rx1063_debug, debug_997
    rx1063_cur."!cursor_debug"("START", "variable_declarator")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1067_done
    goto rxscan1067_scan
  rxscan1067_loop:
    (rx1063_pos) = rx1063_cur."from"()
    inc rx1063_pos
    rx1063_cur."!cursor_from"(rx1063_pos)
    ge rx1063_pos, rx1063_eos, rxscan1067_done
  rxscan1067_scan:
    set_addr $I10, rxscan1067_loop
    rx1063_cur."!mark_push"(0, rx1063_pos, $I10)
  rxscan1067_done:
.annotate 'line', 408
  # rx subrule "ws" subtype=method negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."ws"()
    unless $P10, rx1063_fail
    rx1063_pos = $P10."pos"()
  # rx rxquantr1069 ** 0..1
    set_addr $I10, rxquantr1069_done
    rx1063_cur."!mark_push"(0, rx1063_pos, $I10)
  rxquantr1069_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."typename"()
    unless $P10, rx1063_fail
    goto rxsubrule1070_pass
  rxsubrule1070_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1063_fail
  rxsubrule1070_pass:
    set_addr $I10, rxsubrule1070_back
    rx1063_cur."!mark_push"(0, rx1063_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1063_pos = $P10."pos"()
    set_addr $I10, rxquantr1069_done
    (rx1063_rep) = rx1063_cur."!mark_commit"($I10)
  rxquantr1069_done:
  # rx subrule "ws" subtype=method negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."ws"()
    unless $P10, rx1063_fail
    rx1063_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."variable"()
    unless $P10, rx1063_fail
    rx1063_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1063_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1063_cur."!cursor_pos"(rx1063_pos)
    $P10 = rx1063_cur."ws"()
    unless $P10, rx1063_fail
    rx1063_pos = $P10."pos"()
  # rx pass
    rx1063_cur."!cursor_pass"(rx1063_pos, "variable_declarator")
    if_null rx1063_debug, debug_998
    rx1063_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1063_pos)
  debug_998:
    .return (rx1063_cur)
  rx1063_restart:
.annotate 'line', 10
    if_null rx1063_debug, debug_999
    rx1063_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_999:
  rx1063_fail:
    (rx1063_rep, rx1063_pos, $I10, $P10) = rx1063_cur."!mark_fail"(0)
    lt rx1063_pos, -1, rx1063_done
    eq rx1063_pos, -1, rx1063_fail
    jump $I10
  rx1063_done:
    rx1063_cur."!cursor_fail"()
    if_null rx1063_debug, debug_1000
    rx1063_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1000:
    .return (rx1063_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("170_1303739803.72") :method
.annotate 'line', 10
    $P1065 = self."!PREFIX__!subrule"("ws", "")
    new $P1066, "ResizablePMCArray"
    push $P1066, $P1065
    .return ($P1066)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("171_1303739803.72")
    .param pmc param_1074
.annotate 'line', 410
    .lex "self", param_1074
    $P1075 = param_1074."!protoregex"("routine_declarator")
    .return ($P1075)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("172_1303739803.72")
    .param pmc param_1077
.annotate 'line', 410
    .lex "self", param_1077
    $P1078 = param_1077."!PREFIX__!protoregex"("routine_declarator")
    .return ($P1078)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("173_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1080_tgt
    .local int rx1080_pos
    .local int rx1080_off
    .local int rx1080_eos
    .local int rx1080_rep
    .local pmc rx1080_cur
    .local pmc rx1080_debug
    (rx1080_cur, rx1080_pos, rx1080_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1080_cur
    .local pmc match
    .lex "$/", match
    length rx1080_eos, rx1080_tgt
    gt rx1080_pos, rx1080_eos, rx1080_done
    set rx1080_off, 0
    lt rx1080_pos, 2, rx1080_start
    sub rx1080_off, rx1080_pos, 1
    substr rx1080_tgt, rx1080_tgt, rx1080_off
  rx1080_start:
    eq $I10, 1, rx1080_restart
    if_null rx1080_debug, debug_1001
    rx1080_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1084_done
    goto rxscan1084_scan
  rxscan1084_loop:
    (rx1080_pos) = rx1080_cur."from"()
    inc rx1080_pos
    rx1080_cur."!cursor_from"(rx1080_pos)
    ge rx1080_pos, rx1080_eos, rxscan1084_done
  rxscan1084_scan:
    set_addr $I10, rxscan1084_loop
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxscan1084_done:
.annotate 'line', 411
  # rx subcapture "sym"
    set_addr $I10, rxcap_1085_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1080_pos, 3
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 3
    ne $S10, "sub", rx1080_fail
    add rx1080_pos, 3
    set_addr $I10, rxcap_1085_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1085_done
  rxcap_1085_fail:
    goto rx1080_fail
  rxcap_1085_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."routine_def"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1080_pos = $P10."pos"()
  # rx pass
    rx1080_cur."!cursor_pass"(rx1080_pos, "routine_declarator:sym<sub>")
    if_null rx1080_debug, debug_1002
    rx1080_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1080_pos)
  debug_1002:
    .return (rx1080_cur)
  rx1080_restart:
.annotate 'line', 10
    if_null rx1080_debug, debug_1003
    rx1080_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1003:
  rx1080_fail:
    (rx1080_rep, rx1080_pos, $I10, $P10) = rx1080_cur."!mark_fail"(0)
    lt rx1080_pos, -1, rx1080_done
    eq rx1080_pos, -1, rx1080_fail
    jump $I10
  rx1080_done:
    rx1080_cur."!cursor_fail"()
    if_null rx1080_debug, debug_1004
    rx1080_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1004:
    .return (rx1080_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("174_1303739803.72") :method
.annotate 'line', 10
    $P1082 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P1083, "ResizablePMCArray"
    push $P1083, $P1082
    .return ($P1083)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("175_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1087_tgt
    .local int rx1087_pos
    .local int rx1087_off
    .local int rx1087_eos
    .local int rx1087_rep
    .local pmc rx1087_cur
    .local pmc rx1087_debug
    (rx1087_cur, rx1087_pos, rx1087_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1087_cur
    .local pmc match
    .lex "$/", match
    length rx1087_eos, rx1087_tgt
    gt rx1087_pos, rx1087_eos, rx1087_done
    set rx1087_off, 0
    lt rx1087_pos, 2, rx1087_start
    sub rx1087_off, rx1087_pos, 1
    substr rx1087_tgt, rx1087_tgt, rx1087_off
  rx1087_start:
    eq $I10, 1, rx1087_restart
    if_null rx1087_debug, debug_1005
    rx1087_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1091_done
    goto rxscan1091_scan
  rxscan1091_loop:
    (rx1087_pos) = rx1087_cur."from"()
    inc rx1087_pos
    rx1087_cur."!cursor_from"(rx1087_pos)
    ge rx1087_pos, rx1087_eos, rxscan1091_done
  rxscan1091_scan:
    set_addr $I10, rxscan1091_loop
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
  rxscan1091_done:
.annotate 'line', 412
  # rx subcapture "sym"
    set_addr $I10, rxcap_1092_fail
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
  # rx literal  "method"
    add $I11, rx1087_pos, 6
    gt $I11, rx1087_eos, rx1087_fail
    sub $I11, rx1087_pos, rx1087_off
    substr $S10, rx1087_tgt, $I11, 6
    ne $S10, "method", rx1087_fail
    add rx1087_pos, 6
    set_addr $I10, rxcap_1092_fail
    ($I12, $I11) = rx1087_cur."!mark_peek"($I10)
    rx1087_cur."!cursor_pos"($I11)
    ($P10) = rx1087_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1087_pos, "")
    rx1087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1092_done
  rxcap_1092_fail:
    goto rx1087_fail
  rxcap_1092_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1087_cur."!cursor_pos"(rx1087_pos)
    $P10 = rx1087_cur."method_def"()
    unless $P10, rx1087_fail
    rx1087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1087_pos = $P10."pos"()
  # rx pass
    rx1087_cur."!cursor_pass"(rx1087_pos, "routine_declarator:sym<method>")
    if_null rx1087_debug, debug_1006
    rx1087_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1087_pos)
  debug_1006:
    .return (rx1087_cur)
  rx1087_restart:
.annotate 'line', 10
    if_null rx1087_debug, debug_1007
    rx1087_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1007:
  rx1087_fail:
    (rx1087_rep, rx1087_pos, $I10, $P10) = rx1087_cur."!mark_fail"(0)
    lt rx1087_pos, -1, rx1087_done
    eq rx1087_pos, -1, rx1087_fail
    jump $I10
  rx1087_done:
    rx1087_cur."!cursor_fail"()
    if_null rx1087_debug, debug_1008
    rx1087_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1008:
    .return (rx1087_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("176_1303739803.72") :method
.annotate 'line', 10
    $P1089 = self."!PREFIX__!subrule"("method_def", "method")
    new $P1090, "ResizablePMCArray"
    push $P1090, $P1089
    .return ($P1090)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("177_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 415
    new $P1094, "Undef"
    .lex "$*RETURN_USED", $P1094
.annotate 'line', 10
    .local string rx1095_tgt
    .local int rx1095_pos
    .local int rx1095_off
    .local int rx1095_eos
    .local int rx1095_rep
    .local pmc rx1095_cur
    .local pmc rx1095_debug
    (rx1095_cur, rx1095_pos, rx1095_tgt, $I10) = self."!cursor_start"()
    rx1095_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1095_cur
    .local pmc match
    .lex "$/", match
    length rx1095_eos, rx1095_tgt
    gt rx1095_pos, rx1095_eos, rx1095_done
    set rx1095_off, 0
    lt rx1095_pos, 2, rx1095_start
    sub rx1095_off, rx1095_pos, 1
    substr rx1095_tgt, rx1095_tgt, rx1095_off
  rx1095_start:
    eq $I10, 1, rx1095_restart
    if_null rx1095_debug, debug_1009
    rx1095_cur."!cursor_debug"("START", "routine_def")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1099_done
    goto rxscan1099_scan
  rxscan1099_loop:
    (rx1095_pos) = rx1095_cur."from"()
    inc rx1095_pos
    rx1095_cur."!cursor_from"(rx1095_pos)
    ge rx1095_pos, rx1095_eos, rxscan1099_done
  rxscan1099_scan:
    set_addr $I10, rxscan1099_loop
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxscan1099_done:
.annotate 'line', 414
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 415
    rx1095_cur."!cursor_pos"(rx1095_pos)
    new $P1101, "Integer"
    assign $P1101, 0
    store_lex "$*RETURN_USED", $P1101
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 416
  # rx rxquantr1103 ** 0..1
    set_addr $I10, rxquantr1103_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1103_loop:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1106_fail
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  # rx rxquantr1105 ** 0..1
    set_addr $I10, rxquantr1105_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1105_loop:
  # rx literal  "&"
    add $I11, rx1095_pos, 1
    gt $I11, rx1095_eos, rx1095_fail
    sub $I11, rx1095_pos, rx1095_off
    ord $I11, rx1095_tgt, $I11
    ne $I11, 38, rx1095_fail
    add rx1095_pos, 1
    set_addr $I10, rxquantr1105_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
  rxquantr1105_done:
    set_addr $I10, rxcap_1106_fail
    ($I12, $I11) = rx1095_cur."!mark_peek"($I10)
    rx1095_cur."!cursor_pos"($I11)
    ($P10) = rx1095_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1095_pos, "")
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1106_done
  rxcap_1106_fail:
    goto rx1095_fail
  rxcap_1106_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."deflongname"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
    set_addr $I10, rxquantr1103_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
  rxquantr1103_done:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 417
  # rx subrule "newpad" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."newpad"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1110_0:
.annotate 'line', 418
    set_addr $I10, alt1110_1
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1095_pos, 1
    gt $I11, rx1095_eos, rx1095_fail
    sub $I11, rx1095_pos, rx1095_off
    ord $I11, rx1095_tgt, $I11
    ne $I11, 40, rx1095_fail
    add rx1095_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."signature"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1095_pos, 1
    gt $I11, rx1095_eos, rx1095_fail
    sub $I11, rx1095_pos, rx1095_off
    ord $I11, rx1095_tgt, $I11
    ne $I11, 41, rx1095_fail
    add rx1095_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
    goto alt1110_end
  alt1110_1:
.annotate 'line', 419
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1110_end:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 420
  # rx rxquantr1118 ** 0..*
    set_addr $I10, rxquantr1118_done
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
  rxquantr1118_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."trait"()
    unless $P10, rx1095_fail
    goto rxsubrule1119_pass
  rxsubrule1119_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1095_fail
  rxsubrule1119_pass:
    set_addr $I10, rxsubrule1119_back
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1095_pos = $P10."pos"()
    set_addr $I10, rxquantr1118_done
    (rx1095_rep) = rx1095_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1118_done
    rx1095_cur."!mark_push"(rx1095_rep, rx1095_pos, $I10)
    goto rxquantr1118_loop
  rxquantr1118_done:
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1121_0:
.annotate 'line', 421
    set_addr $I10, alt1121_1
    rx1095_cur."!mark_push"(0, rx1095_pos, $I10)
.annotate 'line', 422
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."onlystar"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
    goto alt1121_end
  alt1121_1:
.annotate 'line', 423
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."blockoid"()
    unless $P10, rx1095_fail
    rx1095_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1095_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
  alt1121_end:
.annotate 'line', 424
  # rx subrule "ws" subtype=method negate=
    rx1095_cur."!cursor_pos"(rx1095_pos)
    $P10 = rx1095_cur."ws"()
    unless $P10, rx1095_fail
    rx1095_pos = $P10."pos"()
.annotate 'line', 414
  # rx pass
    rx1095_cur."!cursor_pass"(rx1095_pos, "routine_def")
    if_null rx1095_debug, debug_1010
    rx1095_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1095_pos)
  debug_1010:
    .return (rx1095_cur)
  rx1095_restart:
.annotate 'line', 10
    if_null rx1095_debug, debug_1011
    rx1095_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1011:
  rx1095_fail:
    (rx1095_rep, rx1095_pos, $I10, $P10) = rx1095_cur."!mark_fail"(0)
    lt rx1095_pos, -1, rx1095_done
    eq rx1095_pos, -1, rx1095_fail
    jump $I10
  rx1095_done:
    rx1095_cur."!cursor_fail"()
    if_null rx1095_debug, debug_1012
    rx1095_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1012:
    .return (rx1095_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("178_1303739803.72") :method
.annotate 'line', 10
    $P1097 = self."!PREFIX__!subrule"("ws", "")
    new $P1098, "ResizablePMCArray"
    push $P1098, $P1097
    .return ($P1098)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("179_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P1158 = "181_1303739803.72" 
    capture_lex $P1158
.annotate 'line', 428
    new $P1128, "Undef"
    .lex "$*RETURN_USED", $P1128
.annotate 'line', 429
    new $P1129, "Undef"
    .lex "$*INVOCANT_OK", $P1129
.annotate 'line', 10
    .local string rx1130_tgt
    .local int rx1130_pos
    .local int rx1130_off
    .local int rx1130_eos
    .local int rx1130_rep
    .local pmc rx1130_cur
    .local pmc rx1130_debug
    (rx1130_cur, rx1130_pos, rx1130_tgt, $I10) = self."!cursor_start"()
    rx1130_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1130_cur
    .local pmc match
    .lex "$/", match
    length rx1130_eos, rx1130_tgt
    gt rx1130_pos, rx1130_eos, rx1130_done
    set rx1130_off, 0
    lt rx1130_pos, 2, rx1130_start
    sub rx1130_off, rx1130_pos, 1
    substr rx1130_tgt, rx1130_tgt, rx1130_off
  rx1130_start:
    eq $I10, 1, rx1130_restart
    if_null rx1130_debug, debug_1013
    rx1130_cur."!cursor_debug"("START", "method_def")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1134_done
    goto rxscan1134_scan
  rxscan1134_loop:
    (rx1130_pos) = rx1130_cur."from"()
    inc rx1130_pos
    rx1130_cur."!cursor_from"(rx1130_pos)
    ge rx1130_pos, rx1130_eos, rxscan1134_done
  rxscan1134_scan:
    set_addr $I10, rxscan1134_loop
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxscan1134_done:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 428
    rx1130_cur."!cursor_pos"(rx1130_pos)
    new $P1136, "Integer"
    assign $P1136, 0
    store_lex "$*RETURN_USED", $P1136
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 429
    rx1130_cur."!cursor_pos"(rx1130_pos)
    new $P1138, "Integer"
    assign $P1138, 1
    store_lex "$*INVOCANT_OK", $P1138
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 430
  # rx subcapture "private"
    set_addr $I10, rxcap_1141_fail
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  # rx rxquantr1140 ** 0..1
    set_addr $I10, rxquantr1140_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1140_loop:
  # rx literal  "!"
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 33, rx1130_fail
    add rx1130_pos, 1
    set_addr $I10, rxquantr1140_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
  rxquantr1140_done:
    set_addr $I10, rxcap_1141_fail
    ($I12, $I11) = rx1130_cur."!mark_peek"($I10)
    rx1130_cur."!cursor_pos"($I11)
    ($P10) = rx1130_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1130_pos, "")
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1141_done
  rxcap_1141_fail:
    goto rx1130_fail
  rxcap_1141_done:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 431
  # rx rxquantr1143 ** 0..1
    set_addr $I10, rxquantr1143_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1143_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."deflongname"()
    unless $P10, rx1130_fail
    goto rxsubrule1144_pass
  rxsubrule1144_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1130_fail
  rxsubrule1144_pass:
    set_addr $I10, rxsubrule1144_back
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1130_pos = $P10."pos"()
    set_addr $I10, rxquantr1143_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
  rxquantr1143_done:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 432
  # rx subrule "newpad" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."newpad"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1147_0:
.annotate 'line', 433
    set_addr $I10, alt1147_1
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 40, rx1130_fail
    add rx1130_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."signature"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 41, rx1130_fail
    add rx1130_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
    goto alt1147_end
  alt1147_1:
.annotate 'line', 434
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1147_end:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 435
    rx1130_cur."!cursor_pos"(rx1130_pos)
    find_lex $P1155, unicode:"$\x{a2}"
    $P1156 = $P1155."MATCH"()
    store_lex "$/", $P1156
    .const 'Sub' $P1158 = "181_1303739803.72" 
    capture_lex $P1158
    $P1160 = $P1158()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 436
  # rx rxquantr1162 ** 0..*
    set_addr $I10, rxquantr1162_done
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxquantr1162_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."trait"()
    unless $P10, rx1130_fail
    goto rxsubrule1163_pass
  rxsubrule1163_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1130_fail
  rxsubrule1163_pass:
    set_addr $I10, rxsubrule1163_back
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1130_pos = $P10."pos"()
    set_addr $I10, rxquantr1162_done
    (rx1130_rep) = rx1130_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1162_done
    rx1130_cur."!mark_push"(rx1130_rep, rx1130_pos, $I10)
    goto rxquantr1162_loop
  rxquantr1162_done:
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1165_0:
.annotate 'line', 437
    set_addr $I10, alt1165_1
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
.annotate 'line', 438
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."onlystar"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
    goto alt1165_end
  alt1165_1:
.annotate 'line', 439
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."blockoid"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1130_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  alt1165_end:
.annotate 'line', 440
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
.annotate 'line', 427
  # rx pass
    rx1130_cur."!cursor_pass"(rx1130_pos, "method_def")
    if_null rx1130_debug, debug_1014
    rx1130_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1130_pos)
  debug_1014:
    .return (rx1130_cur)
  rx1130_restart:
.annotate 'line', 10
    if_null rx1130_debug, debug_1015
    rx1130_cur."!cursor_debug"("NEXT", "method_def")
  debug_1015:
  rx1130_fail:
    (rx1130_rep, rx1130_pos, $I10, $P10) = rx1130_cur."!mark_fail"(0)
    lt rx1130_pos, -1, rx1130_done
    eq rx1130_pos, -1, rx1130_fail
    jump $I10
  rx1130_done:
    rx1130_cur."!cursor_fail"()
    if_null rx1130_debug, debug_1016
    rx1130_cur."!cursor_debug"("FAIL", "method_def")
  debug_1016:
    .return (rx1130_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("180_1303739803.72") :method
.annotate 'line', 10
    $P1132 = self."!PREFIX__!subrule"("ws", "")
    new $P1133, "ResizablePMCArray"
    push $P1133, $P1132
    .return ($P1133)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1157"  :anon :subid("181_1303739803.72") :outer("179_1303739803.72")
.annotate 'line', 435
    new $P1159, "Integer"
    assign $P1159, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1159
    .return ($P1159)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("182_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P1179 = "184_1303739803.72" 
    capture_lex $P1179
    .local string rx1172_tgt
    .local int rx1172_pos
    .local int rx1172_off
    .local int rx1172_eos
    .local int rx1172_rep
    .local pmc rx1172_cur
    .local pmc rx1172_debug
    (rx1172_cur, rx1172_pos, rx1172_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1172_cur
    .local pmc match
    .lex "$/", match
    length rx1172_eos, rx1172_tgt
    gt rx1172_pos, rx1172_eos, rx1172_done
    set rx1172_off, 0
    lt rx1172_pos, 2, rx1172_start
    sub rx1172_off, rx1172_pos, 1
    substr rx1172_tgt, rx1172_tgt, rx1172_off
  rx1172_start:
    eq $I10, 1, rx1172_restart
    if_null rx1172_debug, debug_1017
    rx1172_cur."!cursor_debug"("START", "onlystar")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1175_done
    goto rxscan1175_scan
  rxscan1175_loop:
    (rx1172_pos) = rx1172_cur."from"()
    inc rx1172_pos
    rx1172_cur."!cursor_from"(rx1172_pos)
    ge rx1172_pos, rx1172_eos, rxscan1175_done
  rxscan1175_scan:
    set_addr $I10, rxscan1175_loop
    rx1172_cur."!mark_push"(0, rx1172_pos, $I10)
  rxscan1175_done:
.annotate 'line', 444
    rx1172_cur."!cursor_pos"(rx1172_pos)
    find_lex $P1176, unicode:"$\x{a2}"
    $P1177 = $P1176."MATCH"()
    store_lex "$/", $P1177
    .const 'Sub' $P1179 = "184_1303739803.72" 
    capture_lex $P1179
    $P1185 = $P1179()
    unless $P1185, rx1172_fail
.annotate 'line', 445
  # rx literal  "{"
    add $I11, rx1172_pos, 1
    gt $I11, rx1172_eos, rx1172_fail
    sub $I11, rx1172_pos, rx1172_off
    ord $I11, rx1172_tgt, $I11
    ne $I11, 123, rx1172_fail
    add rx1172_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."ws"()
    unless $P10, rx1172_fail
    rx1172_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1172_pos, 1
    gt $I11, rx1172_eos, rx1172_fail
    sub $I11, rx1172_pos, rx1172_off
    ord $I11, rx1172_tgt, $I11
    ne $I11, 42, rx1172_fail
    add rx1172_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."ws"()
    unless $P10, rx1172_fail
    rx1172_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1172_pos, 1
    gt $I11, rx1172_eos, rx1172_fail
    sub $I11, rx1172_pos, rx1172_off
    ord $I11, rx1172_tgt, $I11
    ne $I11, 125, rx1172_fail
    add rx1172_pos, 1
.annotate 'line', 446
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."ENDSTMT"()
    unless $P10, rx1172_fail
.annotate 'line', 447
  # rx subrule "finishpad" subtype=method negate=
    rx1172_cur."!cursor_pos"(rx1172_pos)
    $P10 = rx1172_cur."finishpad"()
    unless $P10, rx1172_fail
    rx1172_pos = $P10."pos"()
.annotate 'line', 443
  # rx pass
    rx1172_cur."!cursor_pass"(rx1172_pos, "onlystar")
    if_null rx1172_debug, debug_1020
    rx1172_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1172_pos)
  debug_1020:
    .return (rx1172_cur)
  rx1172_restart:
.annotate 'line', 10
    if_null rx1172_debug, debug_1021
    rx1172_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1021:
  rx1172_fail:
    (rx1172_rep, rx1172_pos, $I10, $P10) = rx1172_cur."!mark_fail"(0)
    lt rx1172_pos, -1, rx1172_done
    eq rx1172_pos, -1, rx1172_fail
    jump $I10
  rx1172_done:
    rx1172_cur."!cursor_fail"()
    if_null rx1172_debug, debug_1022
    rx1172_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1022:
    .return (rx1172_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("183_1303739803.72") :method
.annotate 'line', 10
    new $P1174, "ResizablePMCArray"
    push $P1174, ""
    .return ($P1174)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1178"  :anon :subid("184_1303739803.72") :outer("182_1303739803.72")
.annotate 'line', 444
    find_dynamic_lex $P1182, "$*MULTINESS"
    unless_null $P1182, vivify_1018
    get_hll_global $P1180, "GLOBAL"
    get_who $P1181, $P1180
    set $P1182, $P1181["$MULTINESS"]
    unless_null $P1182, vivify_1019
    die "Contextual $*MULTINESS not found"
  vivify_1019:
  vivify_1018:
    set $S1183, $P1182
    iseq $I1184, $S1183, "proto"
    .return ($I1184)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("185_1303739803.72")
    .param pmc param_1187
.annotate 'line', 450
    .lex "self", param_1187
    $P1188 = param_1187."!protoregex"("multi_declarator")
    .return ($P1188)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("186_1303739803.72")
    .param pmc param_1190
.annotate 'line', 450
    .lex "self", param_1190
    $P1191 = param_1190."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1191)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("187_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 452
    new $P1193, "Undef"
    .lex "$*MULTINESS", $P1193
.annotate 'line', 10
    .local string rx1194_tgt
    .local int rx1194_pos
    .local int rx1194_off
    .local int rx1194_eos
    .local int rx1194_rep
    .local pmc rx1194_cur
    .local pmc rx1194_debug
    (rx1194_cur, rx1194_pos, rx1194_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1194_cur
    .local pmc match
    .lex "$/", match
    length rx1194_eos, rx1194_tgt
    gt rx1194_pos, rx1194_eos, rx1194_done
    set rx1194_off, 0
    lt rx1194_pos, 2, rx1194_start
    sub rx1194_off, rx1194_pos, 1
    substr rx1194_tgt, rx1194_tgt, rx1194_off
  rx1194_start:
    eq $I10, 1, rx1194_restart
    if_null rx1194_debug, debug_1023
    rx1194_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1023:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1198_done
    goto rxscan1198_scan
  rxscan1198_loop:
    (rx1194_pos) = rx1194_cur."from"()
    inc rx1194_pos
    rx1194_cur."!cursor_from"(rx1194_pos)
    ge rx1194_pos, rx1194_eos, rxscan1198_done
  rxscan1198_scan:
    set_addr $I10, rxscan1198_loop
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  rxscan1198_done:
.annotate 'line', 452
    rx1194_cur."!cursor_pos"(rx1194_pos)
    new $P1199, "String"
    assign $P1199, "multi"
    store_lex "$*MULTINESS", $P1199
.annotate 'line', 453
  # rx subcapture "sym"
    set_addr $I10, rxcap_1200_fail
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1194_pos, 5
    gt $I11, rx1194_eos, rx1194_fail
    sub $I11, rx1194_pos, rx1194_off
    substr $S10, rx1194_tgt, $I11, 5
    ne $S10, "multi", rx1194_fail
    add rx1194_pos, 5
    set_addr $I10, rxcap_1200_fail
    ($I12, $I11) = rx1194_cur."!mark_peek"($I10)
    rx1194_cur."!cursor_pos"($I11)
    ($P10) = rx1194_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1194_pos, "")
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1200_done
  rxcap_1200_fail:
    goto rx1194_fail
  rxcap_1200_done:
.annotate 'line', 454
  # rx subrule "ws" subtype=method negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."ws"()
    unless $P10, rx1194_fail
    rx1194_pos = $P10."pos"()
  alt1201_0:
    set_addr $I10, alt1201_1
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."declarator"()
    unless $P10, rx1194_fail
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1194_pos = $P10."pos"()
    goto alt1201_end
  alt1201_1:
    set_addr $I10, alt1201_2
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."routine_def"()
    unless $P10, rx1194_fail
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1194_pos = $P10."pos"()
    goto alt1201_end
  alt1201_2:
  # rx subrule "panic" subtype=method negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."panic"("Malformed multi")
    unless $P10, rx1194_fail
    rx1194_pos = $P10."pos"()
  alt1201_end:
.annotate 'line', 451
  # rx pass
    rx1194_cur."!cursor_pass"(rx1194_pos, "multi_declarator:sym<multi>")
    if_null rx1194_debug, debug_1024
    rx1194_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1194_pos)
  debug_1024:
    .return (rx1194_cur)
  rx1194_restart:
.annotate 'line', 10
    if_null rx1194_debug, debug_1025
    rx1194_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1025:
  rx1194_fail:
    (rx1194_rep, rx1194_pos, $I10, $P10) = rx1194_cur."!mark_fail"(0)
    lt rx1194_pos, -1, rx1194_done
    eq rx1194_pos, -1, rx1194_fail
    jump $I10
  rx1194_done:
    rx1194_cur."!cursor_fail"()
    if_null rx1194_debug, debug_1026
    rx1194_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1026:
    .return (rx1194_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("188_1303739803.72") :method
.annotate 'line', 10
    $P1196 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1197, "ResizablePMCArray"
    push $P1197, $P1196
    .return ($P1197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("189_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 457
    new $P1203, "Undef"
    .lex "$*MULTINESS", $P1203
.annotate 'line', 10
    .local string rx1204_tgt
    .local int rx1204_pos
    .local int rx1204_off
    .local int rx1204_eos
    .local int rx1204_rep
    .local pmc rx1204_cur
    .local pmc rx1204_debug
    (rx1204_cur, rx1204_pos, rx1204_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1204_cur
    .local pmc match
    .lex "$/", match
    length rx1204_eos, rx1204_tgt
    gt rx1204_pos, rx1204_eos, rx1204_done
    set rx1204_off, 0
    lt rx1204_pos, 2, rx1204_start
    sub rx1204_off, rx1204_pos, 1
    substr rx1204_tgt, rx1204_tgt, rx1204_off
  rx1204_start:
    eq $I10, 1, rx1204_restart
    if_null rx1204_debug, debug_1027
    rx1204_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1027:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1208_done
    goto rxscan1208_scan
  rxscan1208_loop:
    (rx1204_pos) = rx1204_cur."from"()
    inc rx1204_pos
    rx1204_cur."!cursor_from"(rx1204_pos)
    ge rx1204_pos, rx1204_eos, rxscan1208_done
  rxscan1208_scan:
    set_addr $I10, rxscan1208_loop
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  rxscan1208_done:
.annotate 'line', 457
    rx1204_cur."!cursor_pos"(rx1204_pos)
    new $P1209, "String"
    assign $P1209, "proto"
    store_lex "$*MULTINESS", $P1209
.annotate 'line', 458
  # rx subcapture "sym"
    set_addr $I10, rxcap_1210_fail
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1204_pos, 5
    gt $I11, rx1204_eos, rx1204_fail
    sub $I11, rx1204_pos, rx1204_off
    substr $S10, rx1204_tgt, $I11, 5
    ne $S10, "proto", rx1204_fail
    add rx1204_pos, 5
    set_addr $I10, rxcap_1210_fail
    ($I12, $I11) = rx1204_cur."!mark_peek"($I10)
    rx1204_cur."!cursor_pos"($I11)
    ($P10) = rx1204_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1204_pos, "")
    rx1204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1210_done
  rxcap_1210_fail:
    goto rx1204_fail
  rxcap_1210_done:
.annotate 'line', 459
  # rx subrule "ws" subtype=method negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."ws"()
    unless $P10, rx1204_fail
    rx1204_pos = $P10."pos"()
  alt1211_0:
    set_addr $I10, alt1211_1
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."declarator"()
    unless $P10, rx1204_fail
    rx1204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1204_pos = $P10."pos"()
    goto alt1211_end
  alt1211_1:
    set_addr $I10, alt1211_2
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."routine_def"()
    unless $P10, rx1204_fail
    rx1204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1204_pos = $P10."pos"()
    goto alt1211_end
  alt1211_2:
  # rx subrule "panic" subtype=method negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."panic"("Malformed proto")
    unless $P10, rx1204_fail
    rx1204_pos = $P10."pos"()
  alt1211_end:
.annotate 'line', 456
  # rx pass
    rx1204_cur."!cursor_pass"(rx1204_pos, "multi_declarator:sym<proto>")
    if_null rx1204_debug, debug_1028
    rx1204_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1204_pos)
  debug_1028:
    .return (rx1204_cur)
  rx1204_restart:
.annotate 'line', 10
    if_null rx1204_debug, debug_1029
    rx1204_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1029:
  rx1204_fail:
    (rx1204_rep, rx1204_pos, $I10, $P10) = rx1204_cur."!mark_fail"(0)
    lt rx1204_pos, -1, rx1204_done
    eq rx1204_pos, -1, rx1204_fail
    jump $I10
  rx1204_done:
    rx1204_cur."!cursor_fail"()
    if_null rx1204_debug, debug_1030
    rx1204_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1030:
    .return (rx1204_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("190_1303739803.72") :method
.annotate 'line', 10
    $P1206 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1207, "ResizablePMCArray"
    push $P1207, $P1206
    .return ($P1207)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("191_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 462
    new $P1213, "Undef"
    .lex "$*MULTINESS", $P1213
.annotate 'line', 10
    .local string rx1214_tgt
    .local int rx1214_pos
    .local int rx1214_off
    .local int rx1214_eos
    .local int rx1214_rep
    .local pmc rx1214_cur
    .local pmc rx1214_debug
    (rx1214_cur, rx1214_pos, rx1214_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1214_cur
    .local pmc match
    .lex "$/", match
    length rx1214_eos, rx1214_tgt
    gt rx1214_pos, rx1214_eos, rx1214_done
    set rx1214_off, 0
    lt rx1214_pos, 2, rx1214_start
    sub rx1214_off, rx1214_pos, 1
    substr rx1214_tgt, rx1214_tgt, rx1214_off
  rx1214_start:
    eq $I10, 1, rx1214_restart
    if_null rx1214_debug, debug_1031
    rx1214_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1031:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1218_done
    goto rxscan1218_scan
  rxscan1218_loop:
    (rx1214_pos) = rx1214_cur."from"()
    inc rx1214_pos
    rx1214_cur."!cursor_from"(rx1214_pos)
    ge rx1214_pos, rx1214_eos, rxscan1218_done
  rxscan1218_scan:
    set_addr $I10, rxscan1218_loop
    rx1214_cur."!mark_push"(0, rx1214_pos, $I10)
  rxscan1218_done:
.annotate 'line', 462
    rx1214_cur."!cursor_pos"(rx1214_pos)
    new $P1219, "String"
    assign $P1219, ""
    store_lex "$*MULTINESS", $P1219
.annotate 'line', 463
  # rx subrule "declarator" subtype=capture negate=
    rx1214_cur."!cursor_pos"(rx1214_pos)
    $P10 = rx1214_cur."declarator"()
    unless $P10, rx1214_fail
    rx1214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1214_pos = $P10."pos"()
.annotate 'line', 461
  # rx pass
    rx1214_cur."!cursor_pass"(rx1214_pos, "multi_declarator:sym<null>")
    if_null rx1214_debug, debug_1032
    rx1214_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1214_pos)
  debug_1032:
    .return (rx1214_cur)
  rx1214_restart:
.annotate 'line', 10
    if_null rx1214_debug, debug_1033
    rx1214_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1033:
  rx1214_fail:
    (rx1214_rep, rx1214_pos, $I10, $P10) = rx1214_cur."!mark_fail"(0)
    lt rx1214_pos, -1, rx1214_done
    eq rx1214_pos, -1, rx1214_fail
    jump $I10
  rx1214_done:
    rx1214_cur."!cursor_fail"()
    if_null rx1214_debug, debug_1034
    rx1214_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1034:
    .return (rx1214_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("192_1303739803.72") :method
.annotate 'line', 10
    $P1216 = self."!PREFIX__!subrule"("declarator", "")
    new $P1217, "ResizablePMCArray"
    push $P1217, $P1216
    .return ($P1217)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("193_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P1229 = "195_1303739803.72" 
    capture_lex $P1229
    .local string rx1221_tgt
    .local int rx1221_pos
    .local int rx1221_off
    .local int rx1221_eos
    .local int rx1221_rep
    .local pmc rx1221_cur
    .local pmc rx1221_debug
    (rx1221_cur, rx1221_pos, rx1221_tgt, $I10) = self."!cursor_start"()
    rx1221_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1221_cur
    .local pmc match
    .lex "$/", match
    length rx1221_eos, rx1221_tgt
    gt rx1221_pos, rx1221_eos, rx1221_done
    set rx1221_off, 0
    lt rx1221_pos, 2, rx1221_start
    sub rx1221_off, rx1221_pos, 1
    substr rx1221_tgt, rx1221_tgt, rx1221_off
  rx1221_start:
    eq $I10, 1, rx1221_restart
    if_null rx1221_debug, debug_1035
    rx1221_cur."!cursor_debug"("START", "signature")
  debug_1035:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1221_pos) = rx1221_cur."from"()
    inc rx1221_pos
    rx1221_cur."!cursor_from"(rx1221_pos)
    ge rx1221_pos, rx1221_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxscan1224_done:
.annotate 'line', 467
  # rx rxquantr1225 ** 0..1
    set_addr $I10, rxquantr1225_done
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxquantr1225_loop:
    rx1221_cur."!cursor_pos"(rx1221_pos)
    find_lex $P1226, unicode:"$\x{a2}"
    $P1227 = $P1226."MATCH"()
    store_lex "$/", $P1227
    .const 'Sub' $P1229 = "195_1303739803.72" 
    capture_lex $P1229
    $P1233 = $P1229()
    unless $P1233, rx1221_fail
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."parameter"()
    unless $P10, rx1221_fail
    rx1221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1221_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1221_pos, 1
    gt $I11, rx1221_eos, rx1221_fail
    sub $I11, rx1221_pos, rx1221_off
    ord $I11, rx1221_tgt, $I11
    ne $I11, 58, rx1221_fail
    add rx1221_pos, 1
    set_addr $I10, rxquantr1225_done
    (rx1221_rep) = rx1221_cur."!mark_commit"($I10)
  rxquantr1225_done:
.annotate 'line', 468
  # rx rxquantr1234 ** 0..1
    set_addr $I10, rxquantr1234_done
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxquantr1234_loop:
  # rx rxquantr1235 ** 1..*
    set_addr $I10, rxquantr1235_done
    rx1221_cur."!mark_push"(0, -1, $I10)
  rxquantr1235_loop:
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."parameter"()
    unless $P10, rx1221_fail
    rx1221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1221_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."ws"()
    unless $P10, rx1221_fail
    rx1221_pos = $P10."pos"()
    set_addr $I10, rxquantr1235_done
    (rx1221_rep) = rx1221_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1235_done
    rx1221_cur."!mark_push"(rx1221_rep, rx1221_pos, $I10)
  # rx literal  ","
    add $I11, rx1221_pos, 1
    gt $I11, rx1221_eos, rx1221_fail
    sub $I11, rx1221_pos, rx1221_off
    ord $I11, rx1221_tgt, $I11
    ne $I11, 44, rx1221_fail
    add rx1221_pos, 1
    goto rxquantr1235_loop
  rxquantr1235_done:
    set_addr $I10, rxquantr1234_done
    (rx1221_rep) = rx1221_cur."!mark_commit"($I10)
  rxquantr1234_done:
.annotate 'line', 466
  # rx pass
    rx1221_cur."!cursor_pass"(rx1221_pos, "signature")
    if_null rx1221_debug, debug_1038
    rx1221_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1221_pos)
  debug_1038:
    .return (rx1221_cur)
  rx1221_restart:
.annotate 'line', 10
    if_null rx1221_debug, debug_1039
    rx1221_cur."!cursor_debug"("NEXT", "signature")
  debug_1039:
  rx1221_fail:
    (rx1221_rep, rx1221_pos, $I10, $P10) = rx1221_cur."!mark_fail"(0)
    lt rx1221_pos, -1, rx1221_done
    eq rx1221_pos, -1, rx1221_fail
    jump $I10
  rx1221_done:
    rx1221_cur."!cursor_fail"()
    if_null rx1221_debug, debug_1040
    rx1221_cur."!cursor_debug"("FAIL", "signature")
  debug_1040:
    .return (rx1221_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("194_1303739803.72") :method
.annotate 'line', 10
    new $P1223, "ResizablePMCArray"
    push $P1223, ""
    .return ($P1223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1228"  :anon :subid("195_1303739803.72") :outer("193_1303739803.72")
.annotate 'line', 467
    find_dynamic_lex $P1232, "$*INVOCANT_OK"
    unless_null $P1232, vivify_1036
    get_hll_global $P1230, "GLOBAL"
    get_who $P1231, $P1230
    set $P1232, $P1231["$INVOCANT_OK"]
    unless_null $P1232, vivify_1037
    die "Contextual $*INVOCANT_OK not found"
  vivify_1037:
  vivify_1036:
    .return ($P1232)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("196_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1237_tgt
    .local int rx1237_pos
    .local int rx1237_off
    .local int rx1237_eos
    .local int rx1237_rep
    .local pmc rx1237_cur
    .local pmc rx1237_debug
    (rx1237_cur, rx1237_pos, rx1237_tgt, $I10) = self."!cursor_start"()
    rx1237_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1237_cur
    .local pmc match
    .lex "$/", match
    length rx1237_eos, rx1237_tgt
    gt rx1237_pos, rx1237_eos, rx1237_done
    set rx1237_off, 0
    lt rx1237_pos, 2, rx1237_start
    sub rx1237_off, rx1237_pos, 1
    substr rx1237_tgt, rx1237_tgt, rx1237_off
  rx1237_start:
    eq $I10, 1, rx1237_restart
    if_null rx1237_debug, debug_1041
    rx1237_cur."!cursor_debug"("START", "parameter")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1240_done
    goto rxscan1240_scan
  rxscan1240_loop:
    (rx1237_pos) = rx1237_cur."from"()
    inc rx1237_pos
    rx1237_cur."!cursor_from"(rx1237_pos)
    ge rx1237_pos, rx1237_eos, rxscan1240_done
  rxscan1240_scan:
    set_addr $I10, rxscan1240_loop
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxscan1240_done:
.annotate 'line', 472
  # rx rxquantr1241 ** 0..*
    set_addr $I10, rxquantr1241_done
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxquantr1241_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."typename"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1237_pos = $P10."pos"()
  # rx rxquantr1242 ** 0..1
    set_addr $I10, rxquantr1242_done
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxquantr1242_loop:
  # rx literal  ":"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 58, rx1237_fail
    add rx1237_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1243_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1237_pos, rx1237_eos, rx1237_fail
    sub $I10, rx1237_pos, rx1237_off
    substr $S10, rx1237_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1237_fail
    inc rx1237_pos
    set_addr $I10, rxcap_1243_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1243_done
  rxcap_1243_fail:
    goto rx1237_fail
  rxcap_1243_done:
    set_addr $I10, rxquantr1242_done
    (rx1237_rep) = rx1237_cur."!mark_commit"($I10)
  rxquantr1242_done:
  # rx subrule "ws" subtype=method negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."ws"()
    unless $P10, rx1237_fail
    rx1237_pos = $P10."pos"()
    set_addr $I10, rxquantr1241_done
    (rx1237_rep) = rx1237_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1241_done
    rx1237_cur."!mark_push"(rx1237_rep, rx1237_pos, $I10)
    goto rxquantr1241_loop
  rxquantr1241_done:
  alt1244_0:
.annotate 'line', 473
    set_addr $I10, alt1244_1
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
.annotate 'line', 474
  # rx subcapture "quant"
    set_addr $I10, rxcap_1245_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "*"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 42, rx1237_fail
    add rx1237_pos, 1
    set_addr $I10, rxcap_1245_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1245_done
  rxcap_1245_fail:
    goto rx1237_fail
  rxcap_1245_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."param_var"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1237_pos = $P10."pos"()
    goto alt1244_end
  alt1244_1:
  alt1246_0:
.annotate 'line', 475
    set_addr $I10, alt1246_1
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."param_var"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1237_pos = $P10."pos"()
    goto alt1246_end
  alt1246_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."named_param"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1237_pos = $P10."pos"()
  alt1246_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1248_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  alt1247_0:
    set_addr $I10, alt1247_1
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "?"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 63, rx1237_fail
    add rx1237_pos, 1
    goto alt1247_end
  alt1247_1:
    set_addr $I10, alt1247_2
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "!"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 33, rx1237_fail
    add rx1237_pos, 1
    goto alt1247_end
  alt1247_2:
  alt1247_end:
    set_addr $I10, rxcap_1248_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1248_done
  rxcap_1248_fail:
    goto rx1237_fail
  rxcap_1248_done:
  alt1244_end:
.annotate 'line', 477
  # rx rxquantr1249 ** 0..1
    set_addr $I10, rxquantr1249_done
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxquantr1249_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."default_value"()
    unless $P10, rx1237_fail
    goto rxsubrule1250_pass
  rxsubrule1250_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1237_fail
  rxsubrule1250_pass:
    set_addr $I10, rxsubrule1250_back
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1237_pos = $P10."pos"()
    set_addr $I10, rxquantr1249_done
    (rx1237_rep) = rx1237_cur."!mark_commit"($I10)
  rxquantr1249_done:
.annotate 'line', 471
  # rx pass
    rx1237_cur."!cursor_pass"(rx1237_pos, "parameter")
    if_null rx1237_debug, debug_1042
    rx1237_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1237_pos)
  debug_1042:
    .return (rx1237_cur)
  rx1237_restart:
.annotate 'line', 10
    if_null rx1237_debug, debug_1043
    rx1237_cur."!cursor_debug"("NEXT", "parameter")
  debug_1043:
  rx1237_fail:
    (rx1237_rep, rx1237_pos, $I10, $P10) = rx1237_cur."!mark_fail"(0)
    lt rx1237_pos, -1, rx1237_done
    eq rx1237_pos, -1, rx1237_fail
    jump $I10
  rx1237_done:
    rx1237_cur."!cursor_fail"()
    if_null rx1237_debug, debug_1044
    rx1237_cur."!cursor_debug"("FAIL", "parameter")
  debug_1044:
    .return (rx1237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("197_1303739803.72") :method
.annotate 'line', 10
    new $P1239, "ResizablePMCArray"
    push $P1239, ""
    .return ($P1239)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("198_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1252_tgt
    .local int rx1252_pos
    .local int rx1252_off
    .local int rx1252_eos
    .local int rx1252_rep
    .local pmc rx1252_cur
    .local pmc rx1252_debug
    (rx1252_cur, rx1252_pos, rx1252_tgt, $I10) = self."!cursor_start"()
    rx1252_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1252_cur
    .local pmc match
    .lex "$/", match
    length rx1252_eos, rx1252_tgt
    gt rx1252_pos, rx1252_eos, rx1252_done
    set rx1252_off, 0
    lt rx1252_pos, 2, rx1252_start
    sub rx1252_off, rx1252_pos, 1
    substr rx1252_tgt, rx1252_tgt, rx1252_off
  rx1252_start:
    eq $I10, 1, rx1252_restart
    if_null rx1252_debug, debug_1045
    rx1252_cur."!cursor_debug"("START", "param_var")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1256_done
    goto rxscan1256_scan
  rxscan1256_loop:
    (rx1252_pos) = rx1252_cur."from"()
    inc rx1252_pos
    rx1252_cur."!cursor_from"(rx1252_pos)
    ge rx1252_pos, rx1252_eos, rxscan1256_done
  rxscan1256_scan:
    set_addr $I10, rxscan1256_loop
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxscan1256_done:
.annotate 'line', 481
  # rx subrule "sigil" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."sigil"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1252_pos = $P10."pos"()
  # rx rxquantr1257 ** 0..1
    set_addr $I10, rxquantr1257_done
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxquantr1257_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."twigil"()
    unless $P10, rx1252_fail
    goto rxsubrule1258_pass
  rxsubrule1258_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1252_fail
  rxsubrule1258_pass:
    set_addr $I10, rxsubrule1258_back
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1252_pos = $P10."pos"()
    set_addr $I10, rxquantr1257_done
    (rx1252_rep) = rx1252_cur."!mark_commit"($I10)
  rxquantr1257_done:
  alt1259_0:
.annotate 'line', 482
    set_addr $I10, alt1259_1
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."ident"()
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1252_pos = $P10."pos"()
    goto alt1259_end
  alt1259_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1260_fail
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1252_pos, rx1252_eos, rx1252_fail
    sub $I10, rx1252_pos, rx1252_off
    substr $S10, rx1252_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1252_fail
    inc rx1252_pos
    set_addr $I10, rxcap_1260_fail
    ($I12, $I11) = rx1252_cur."!mark_peek"($I10)
    rx1252_cur."!cursor_pos"($I11)
    ($P10) = rx1252_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1252_pos, "")
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1260_done
  rxcap_1260_fail:
    goto rx1252_fail
  rxcap_1260_done:
  alt1259_end:
.annotate 'line', 480
  # rx pass
    rx1252_cur."!cursor_pass"(rx1252_pos, "param_var")
    if_null rx1252_debug, debug_1046
    rx1252_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1252_pos)
  debug_1046:
    .return (rx1252_cur)
  rx1252_restart:
.annotate 'line', 10
    if_null rx1252_debug, debug_1047
    rx1252_cur."!cursor_debug"("NEXT", "param_var")
  debug_1047:
  rx1252_fail:
    (rx1252_rep, rx1252_pos, $I10, $P10) = rx1252_cur."!mark_fail"(0)
    lt rx1252_pos, -1, rx1252_done
    eq rx1252_pos, -1, rx1252_fail
    jump $I10
  rx1252_done:
    rx1252_cur."!cursor_fail"()
    if_null rx1252_debug, debug_1048
    rx1252_cur."!cursor_debug"("FAIL", "param_var")
  debug_1048:
    .return (rx1252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("199_1303739803.72") :method
.annotate 'line', 10
    $P1254 = self."!PREFIX__!subrule"("sigil", "")
    new $P1255, "ResizablePMCArray"
    push $P1255, $P1254
    .return ($P1255)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("200_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1262_tgt
    .local int rx1262_pos
    .local int rx1262_off
    .local int rx1262_eos
    .local int rx1262_rep
    .local pmc rx1262_cur
    .local pmc rx1262_debug
    (rx1262_cur, rx1262_pos, rx1262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1262_cur
    .local pmc match
    .lex "$/", match
    length rx1262_eos, rx1262_tgt
    gt rx1262_pos, rx1262_eos, rx1262_done
    set rx1262_off, 0
    lt rx1262_pos, 2, rx1262_start
    sub rx1262_off, rx1262_pos, 1
    substr rx1262_tgt, rx1262_tgt, rx1262_off
  rx1262_start:
    eq $I10, 1, rx1262_restart
    if_null rx1262_debug, debug_1049
    rx1262_cur."!cursor_debug"("START", "named_param")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1266_done
    goto rxscan1266_scan
  rxscan1266_loop:
    (rx1262_pos) = rx1262_cur."from"()
    inc rx1262_pos
    rx1262_cur."!cursor_from"(rx1262_pos)
    ge rx1262_pos, rx1262_eos, rxscan1266_done
  rxscan1266_scan:
    set_addr $I10, rxscan1266_loop
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
  rxscan1266_done:
.annotate 'line', 486
  # rx literal  ":"
    add $I11, rx1262_pos, 1
    gt $I11, rx1262_eos, rx1262_fail
    sub $I11, rx1262_pos, rx1262_off
    ord $I11, rx1262_tgt, $I11
    ne $I11, 58, rx1262_fail
    add rx1262_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1262_cur."!cursor_pos"(rx1262_pos)
    $P10 = rx1262_cur."param_var"()
    unless $P10, rx1262_fail
    rx1262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1262_pos = $P10."pos"()
.annotate 'line', 485
  # rx pass
    rx1262_cur."!cursor_pass"(rx1262_pos, "named_param")
    if_null rx1262_debug, debug_1050
    rx1262_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1262_pos)
  debug_1050:
    .return (rx1262_cur)
  rx1262_restart:
.annotate 'line', 10
    if_null rx1262_debug, debug_1051
    rx1262_cur."!cursor_debug"("NEXT", "named_param")
  debug_1051:
  rx1262_fail:
    (rx1262_rep, rx1262_pos, $I10, $P10) = rx1262_cur."!mark_fail"(0)
    lt rx1262_pos, -1, rx1262_done
    eq rx1262_pos, -1, rx1262_fail
    jump $I10
  rx1262_done:
    rx1262_cur."!cursor_fail"()
    if_null rx1262_debug, debug_1052
    rx1262_cur."!cursor_debug"("FAIL", "named_param")
  debug_1052:
    .return (rx1262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("201_1303739803.72") :method
.annotate 'line', 10
    $P1264 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1265, "ResizablePMCArray"
    push $P1265, $P1264
    .return ($P1265)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("202_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1268_tgt
    .local int rx1268_pos
    .local int rx1268_off
    .local int rx1268_eos
    .local int rx1268_rep
    .local pmc rx1268_cur
    .local pmc rx1268_debug
    (rx1268_cur, rx1268_pos, rx1268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1268_cur
    .local pmc match
    .lex "$/", match
    length rx1268_eos, rx1268_tgt
    gt rx1268_pos, rx1268_eos, rx1268_done
    set rx1268_off, 0
    lt rx1268_pos, 2, rx1268_start
    sub rx1268_off, rx1268_pos, 1
    substr rx1268_tgt, rx1268_tgt, rx1268_off
  rx1268_start:
    eq $I10, 1, rx1268_restart
    if_null rx1268_debug, debug_1053
    rx1268_cur."!cursor_debug"("START", "default_value")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1272_done
    goto rxscan1272_scan
  rxscan1272_loop:
    (rx1268_pos) = rx1268_cur."from"()
    inc rx1268_pos
    rx1268_cur."!cursor_from"(rx1268_pos)
    ge rx1268_pos, rx1268_eos, rxscan1272_done
  rxscan1272_scan:
    set_addr $I10, rxscan1272_loop
    rx1268_cur."!mark_push"(0, rx1268_pos, $I10)
  rxscan1272_done:
.annotate 'line', 489
  # rx subrule "ws" subtype=method negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."ws"()
    unless $P10, rx1268_fail
    rx1268_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1268_pos, 1
    gt $I11, rx1268_eos, rx1268_fail
    sub $I11, rx1268_pos, rx1268_off
    ord $I11, rx1268_tgt, $I11
    ne $I11, 61, rx1268_fail
    add rx1268_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."ws"()
    unless $P10, rx1268_fail
    rx1268_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."EXPR"("i=")
    unless $P10, rx1268_fail
    rx1268_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1268_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."ws"()
    unless $P10, rx1268_fail
    rx1268_pos = $P10."pos"()
  # rx pass
    rx1268_cur."!cursor_pass"(rx1268_pos, "default_value")
    if_null rx1268_debug, debug_1054
    rx1268_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1268_pos)
  debug_1054:
    .return (rx1268_cur)
  rx1268_restart:
.annotate 'line', 10
    if_null rx1268_debug, debug_1055
    rx1268_cur."!cursor_debug"("NEXT", "default_value")
  debug_1055:
  rx1268_fail:
    (rx1268_rep, rx1268_pos, $I10, $P10) = rx1268_cur."!mark_fail"(0)
    lt rx1268_pos, -1, rx1268_done
    eq rx1268_pos, -1, rx1268_fail
    jump $I10
  rx1268_done:
    rx1268_cur."!cursor_fail"()
    if_null rx1268_debug, debug_1056
    rx1268_cur."!cursor_debug"("FAIL", "default_value")
  debug_1056:
    .return (rx1268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("203_1303739803.72") :method
.annotate 'line', 10
    $P1270 = self."!PREFIX__!subrule"("ws", "")
    new $P1271, "ResizablePMCArray"
    push $P1271, $P1270
    .return ($P1271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("204_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1277_tgt
    .local int rx1277_pos
    .local int rx1277_off
    .local int rx1277_eos
    .local int rx1277_rep
    .local pmc rx1277_cur
    .local pmc rx1277_debug
    (rx1277_cur, rx1277_pos, rx1277_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1277_cur
    .local pmc match
    .lex "$/", match
    length rx1277_eos, rx1277_tgt
    gt rx1277_pos, rx1277_eos, rx1277_done
    set rx1277_off, 0
    lt rx1277_pos, 2, rx1277_start
    sub rx1277_off, rx1277_pos, 1
    substr rx1277_tgt, rx1277_tgt, rx1277_off
  rx1277_start:
    eq $I10, 1, rx1277_restart
    if_null rx1277_debug, debug_1057
    rx1277_cur."!cursor_debug"("START", "trait")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1281_done
    goto rxscan1281_scan
  rxscan1281_loop:
    (rx1277_pos) = rx1277_cur."from"()
    inc rx1277_pos
    rx1277_cur."!cursor_from"(rx1277_pos)
    ge rx1277_pos, rx1277_eos, rxscan1281_done
  rxscan1281_scan:
    set_addr $I10, rxscan1281_loop
    rx1277_cur."!mark_push"(0, rx1277_pos, $I10)
  rxscan1281_done:
.annotate 'line', 491
  # rx subrule "ws" subtype=method negate=
    rx1277_cur."!cursor_pos"(rx1277_pos)
    $P10 = rx1277_cur."ws"()
    unless $P10, rx1277_fail
    rx1277_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1277_cur."!cursor_pos"(rx1277_pos)
    $P10 = rx1277_cur."trait_mod"()
    unless $P10, rx1277_fail
    rx1277_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1277_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1277_cur."!cursor_pos"(rx1277_pos)
    $P10 = rx1277_cur."ws"()
    unless $P10, rx1277_fail
    rx1277_pos = $P10."pos"()
  # rx pass
    rx1277_cur."!cursor_pass"(rx1277_pos, "trait")
    if_null rx1277_debug, debug_1058
    rx1277_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1277_pos)
  debug_1058:
    .return (rx1277_cur)
  rx1277_restart:
.annotate 'line', 10
    if_null rx1277_debug, debug_1059
    rx1277_cur."!cursor_debug"("NEXT", "trait")
  debug_1059:
  rx1277_fail:
    (rx1277_rep, rx1277_pos, $I10, $P10) = rx1277_cur."!mark_fail"(0)
    lt rx1277_pos, -1, rx1277_done
    eq rx1277_pos, -1, rx1277_fail
    jump $I10
  rx1277_done:
    rx1277_cur."!cursor_fail"()
    if_null rx1277_debug, debug_1060
    rx1277_cur."!cursor_debug"("FAIL", "trait")
  debug_1060:
    .return (rx1277_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("205_1303739803.72") :method
.annotate 'line', 10
    $P1279 = self."!PREFIX__!subrule"("ws", "")
    new $P1280, "ResizablePMCArray"
    push $P1280, $P1279
    .return ($P1280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("206_1303739803.72")
    .param pmc param_1285
.annotate 'line', 493
    .lex "self", param_1285
    $P1286 = param_1285."!protoregex"("trait_mod")
    .return ($P1286)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("207_1303739803.72")
    .param pmc param_1288
.annotate 'line', 493
    .lex "self", param_1288
    $P1289 = param_1288."!PREFIX__!protoregex"("trait_mod")
    .return ($P1289)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("208_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1291_tgt
    .local int rx1291_pos
    .local int rx1291_off
    .local int rx1291_eos
    .local int rx1291_rep
    .local pmc rx1291_cur
    .local pmc rx1291_debug
    (rx1291_cur, rx1291_pos, rx1291_tgt, $I10) = self."!cursor_start"()
    rx1291_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1291_cur
    .local pmc match
    .lex "$/", match
    length rx1291_eos, rx1291_tgt
    gt rx1291_pos, rx1291_eos, rx1291_done
    set rx1291_off, 0
    lt rx1291_pos, 2, rx1291_start
    sub rx1291_off, rx1291_pos, 1
    substr rx1291_tgt, rx1291_tgt, rx1291_off
  rx1291_start:
    eq $I10, 1, rx1291_restart
    if_null rx1291_debug, debug_1061
    rx1291_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1295_done
    goto rxscan1295_scan
  rxscan1295_loop:
    (rx1291_pos) = rx1291_cur."from"()
    inc rx1291_pos
    rx1291_cur."!cursor_from"(rx1291_pos)
    ge rx1291_pos, rx1291_eos, rxscan1295_done
  rxscan1295_scan:
    set_addr $I10, rxscan1295_loop
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  rxscan1295_done:
.annotate 'line', 494
  # rx subcapture "sym"
    set_addr $I10, rxcap_1296_fail
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  # rx literal  "is"
    add $I11, rx1291_pos, 2
    gt $I11, rx1291_eos, rx1291_fail
    sub $I11, rx1291_pos, rx1291_off
    substr $S10, rx1291_tgt, $I11, 2
    ne $S10, "is", rx1291_fail
    add rx1291_pos, 2
    set_addr $I10, rxcap_1296_fail
    ($I12, $I11) = rx1291_cur."!mark_peek"($I10)
    rx1291_cur."!cursor_pos"($I11)
    ($P10) = rx1291_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1291_pos, "")
    rx1291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1296_done
  rxcap_1296_fail:
    goto rx1291_fail
  rxcap_1296_done:
  # rx subrule "ws" subtype=method negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."ws"()
    unless $P10, rx1291_fail
    rx1291_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."deflongname"()
    unless $P10, rx1291_fail
    rx1291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1291_pos = $P10."pos"()
  # rx rxquantr1298 ** 0..1
    set_addr $I10, rxquantr1298_done
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  rxquantr1298_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."circumfix"()
    unless $P10, rx1291_fail
    goto rxsubrule1299_pass
  rxsubrule1299_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1291_fail
  rxsubrule1299_pass:
    set_addr $I10, rxsubrule1299_back
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1291_pos = $P10."pos"()
    set_addr $I10, rxquantr1298_done
    (rx1291_rep) = rx1291_cur."!mark_commit"($I10)
  rxquantr1298_done:
  # rx subrule "ws" subtype=method negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."ws"()
    unless $P10, rx1291_fail
    rx1291_pos = $P10."pos"()
  # rx pass
    rx1291_cur."!cursor_pass"(rx1291_pos, "trait_mod:sym<is>")
    if_null rx1291_debug, debug_1062
    rx1291_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1291_pos)
  debug_1062:
    .return (rx1291_cur)
  rx1291_restart:
.annotate 'line', 10
    if_null rx1291_debug, debug_1063
    rx1291_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1063:
  rx1291_fail:
    (rx1291_rep, rx1291_pos, $I10, $P10) = rx1291_cur."!mark_fail"(0)
    lt rx1291_pos, -1, rx1291_done
    eq rx1291_pos, -1, rx1291_fail
    jump $I10
  rx1291_done:
    rx1291_cur."!cursor_fail"()
    if_null rx1291_debug, debug_1064
    rx1291_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1064:
    .return (rx1291_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("209_1303739803.72") :method
.annotate 'line', 10
    $P1293 = self."!PREFIX__!subrule"("ws", "is")
    new $P1294, "ResizablePMCArray"
    push $P1294, $P1293
    .return ($P1294)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("210_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1302_tgt
    .local int rx1302_pos
    .local int rx1302_off
    .local int rx1302_eos
    .local int rx1302_rep
    .local pmc rx1302_cur
    .local pmc rx1302_debug
    (rx1302_cur, rx1302_pos, rx1302_tgt, $I10) = self."!cursor_start"()
    rx1302_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1302_cur
    .local pmc match
    .lex "$/", match
    length rx1302_eos, rx1302_tgt
    gt rx1302_pos, rx1302_eos, rx1302_done
    set rx1302_off, 0
    lt rx1302_pos, 2, rx1302_start
    sub rx1302_off, rx1302_pos, 1
    substr rx1302_tgt, rx1302_tgt, rx1302_off
  rx1302_start:
    eq $I10, 1, rx1302_restart
    if_null rx1302_debug, debug_1065
    rx1302_cur."!cursor_debug"("START", "regex_declarator")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1306_done
    goto rxscan1306_scan
  rxscan1306_loop:
    (rx1302_pos) = rx1302_cur."from"()
    inc rx1302_pos
    rx1302_cur."!cursor_from"(rx1302_pos)
    ge rx1302_pos, rx1302_eos, rxscan1306_done
  rxscan1306_scan:
    set_addr $I10, rxscan1306_loop
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxscan1306_done:
.annotate 'line', 496
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1308_0:
.annotate 'line', 497
    set_addr $I10, alt1308_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
.annotate 'line', 498
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1310_fail
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "proto", rx1302_fail
    add rx1302_pos, 5
    set_addr $I10, rxcap_1310_fail
    ($I12, $I11) = rx1302_cur."!mark_peek"($I10)
    rx1302_cur."!cursor_pos"($I11)
    ($P10) = rx1302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1302_pos, "")
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1310_done
  rxcap_1310_fail:
    goto rx1302_fail
  rxcap_1310_done:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1312_0:
    set_addr $I10, alt1312_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "regex", rx1302_fail
    add rx1302_pos, 5
    goto alt1312_end
  alt1312_1:
    set_addr $I10, alt1312_2
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "token"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "token", rx1302_fail
    add rx1302_pos, 5
    goto alt1312_end
  alt1312_2:
  # rx literal  "rule"
    add $I11, rx1302_pos, 4
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 4
    ne $S10, "rule", rx1302_fail
    add rx1302_pos, 4
  alt1312_end:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 499
  # rx subrule "deflongname" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."deflongname"()
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1315_0:
.annotate 'line', 500
    set_addr $I10, alt1315_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
.annotate 'line', 501
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 123, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "<...>", rx1302_fail
    add rx1302_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 125, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ENDSTMT"()
    unless $P10, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
    goto alt1315_end
  alt1315_1:
    set_addr $I10, alt1315_2
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
.annotate 'line', 502
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 123, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1302_pos, 3
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 3
    ne $S10, "<*>", rx1302_fail
    add rx1302_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 125, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ENDSTMT"()
    unless $P10, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
    goto alt1315_end
  alt1315_2:
.annotate 'line', 503
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1315_end:
.annotate 'line', 504
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 498
    goto alt1308_end
  alt1308_1:
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1329_fail
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  alt1328_0:
    set_addr $I10, alt1328_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "regex", rx1302_fail
    add rx1302_pos, 5
    goto alt1328_end
  alt1328_1:
    set_addr $I10, alt1328_2
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "token"
    add $I11, rx1302_pos, 5
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 5
    ne $S10, "token", rx1302_fail
    add rx1302_pos, 5
    goto alt1328_end
  alt1328_2:
  # rx literal  "rule"
    add $I11, rx1302_pos, 4
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    substr $S10, rx1302_tgt, $I11, 4
    ne $S10, "rule", rx1302_fail
    add rx1302_pos, 4
  alt1328_end:
    set_addr $I10, rxcap_1329_fail
    ($I12, $I11) = rx1302_cur."!mark_peek"($I10)
    rx1302_cur."!cursor_pos"($I11)
    ($P10) = rx1302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1302_pos, "")
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1329_done
  rxcap_1329_fail:
    goto rx1302_fail
  rxcap_1329_done:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 506
  # rx subrule "deflongname" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."deflongname"()
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 507
  # rx subrule "newpad" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."newpad"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 508
  # rx rxquantr1333 ** 0..1
    set_addr $I10, rxquantr1333_done
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxquantr1333_loop:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 40, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."signature"()
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 41, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
    set_addr $I10, rxquantr1333_done
    (rx1302_rep) = rx1302_cur."!mark_commit"($I10)
  rxquantr1333_done:
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 509
  # rx reduce name="regex_declarator" key="open"
    rx1302_cur."!cursor_pos"(rx1302_pos)
    rx1302_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 510
  # rx literal  "{"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 123, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1302_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 125, rx1302_fail
    add rx1302_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ENDSTMT"()
    unless $P10, rx1302_fail
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
  alt1308_end:
.annotate 'line', 511
  # rx subrule "ws" subtype=method negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."ws"()
    unless $P10, rx1302_fail
    rx1302_pos = $P10."pos"()
.annotate 'line', 496
  # rx pass
    rx1302_cur."!cursor_pass"(rx1302_pos, "regex_declarator")
    if_null rx1302_debug, debug_1066
    rx1302_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1302_pos)
  debug_1066:
    .return (rx1302_cur)
  rx1302_restart:
.annotate 'line', 10
    if_null rx1302_debug, debug_1067
    rx1302_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1067:
  rx1302_fail:
    (rx1302_rep, rx1302_pos, $I10, $P10) = rx1302_cur."!mark_fail"(0)
    lt rx1302_pos, -1, rx1302_done
    eq rx1302_pos, -1, rx1302_fail
    jump $I10
  rx1302_done:
    rx1302_cur."!cursor_fail"()
    if_null rx1302_debug, debug_1068
    rx1302_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1068:
    .return (rx1302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("211_1303739803.72") :method
.annotate 'line', 10
    $P1304 = self."!PREFIX__!subrule"("ws", "")
    new $P1305, "ResizablePMCArray"
    push $P1305, $P1304
    .return ($P1305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("212_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1343_tgt
    .local int rx1343_pos
    .local int rx1343_off
    .local int rx1343_eos
    .local int rx1343_rep
    .local pmc rx1343_cur
    .local pmc rx1343_debug
    (rx1343_cur, rx1343_pos, rx1343_tgt, $I10) = self."!cursor_start"()
    rx1343_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1343_cur
    .local pmc match
    .lex "$/", match
    length rx1343_eos, rx1343_tgt
    gt rx1343_pos, rx1343_eos, rx1343_done
    set rx1343_off, 0
    lt rx1343_pos, 2, rx1343_start
    sub rx1343_off, rx1343_pos, 1
    substr rx1343_tgt, rx1343_tgt, rx1343_off
  rx1343_start:
    eq $I10, 1, rx1343_restart
    if_null rx1343_debug, debug_1069
    rx1343_cur."!cursor_debug"("START", "dotty")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1343_pos) = rx1343_cur."from"()
    inc rx1343_pos
    rx1343_cur."!cursor_from"(rx1343_pos)
    ge rx1343_pos, rx1343_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxscan1347_done:
.annotate 'line', 515
  # rx literal  "."
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 46, rx1343_fail
    add rx1343_pos, 1
  alt1348_0:
.annotate 'line', 516
    set_addr $I10, alt1348_1
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."deflongname"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1343_pos = $P10."pos"()
    goto alt1348_end
  alt1348_1:
.annotate 'line', 517
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1343_pos, rx1343_off
    substr $S10, rx1343_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1343_fail
  # rx subrule "quote" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."quote"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1343_pos = $P10."pos"()
  alt1349_0:
.annotate 'line', 518
    set_addr $I10, alt1349_1
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1343_pos, rx1343_off
    substr $S10, rx1343_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1343_fail
    goto alt1349_end
  alt1349_1:
  # rx subrule "panic" subtype=method negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1343_fail
    rx1343_pos = $P10."pos"()
  alt1349_end:
  alt1348_end:
.annotate 'line', 524
  # rx rxquantr1350 ** 0..1
    set_addr $I10, rxquantr1350_done
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxquantr1350_loop:
  alt1351_0:
.annotate 'line', 521
    set_addr $I10, alt1351_1
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
.annotate 'line', 522
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1343_pos, rx1343_off
    substr $S10, rx1343_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1343_fail
  # rx subrule "args" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."args"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1343_pos = $P10."pos"()
    goto alt1351_end
  alt1351_1:
.annotate 'line', 523
  # rx literal  ":"
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 58, rx1343_fail
    add rx1343_pos, 1
  # rx charclass s
    ge rx1343_pos, rx1343_eos, rx1343_fail
    sub $I10, rx1343_pos, rx1343_off
    is_cclass $I11, 32, rx1343_tgt, $I10
    unless $I11, rx1343_fail
    inc rx1343_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."arglist"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1343_pos = $P10."pos"()
  alt1351_end:
.annotate 'line', 524
    set_addr $I10, rxquantr1350_done
    (rx1343_rep) = rx1343_cur."!mark_commit"($I10)
  rxquantr1350_done:
.annotate 'line', 514
  # rx pass
    rx1343_cur."!cursor_pass"(rx1343_pos, "dotty")
    if_null rx1343_debug, debug_1070
    rx1343_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1343_pos)
  debug_1070:
    .return (rx1343_cur)
  rx1343_restart:
.annotate 'line', 10
    if_null rx1343_debug, debug_1071
    rx1343_cur."!cursor_debug"("NEXT", "dotty")
  debug_1071:
  rx1343_fail:
    (rx1343_rep, rx1343_pos, $I10, $P10) = rx1343_cur."!mark_fail"(0)
    lt rx1343_pos, -1, rx1343_done
    eq rx1343_pos, -1, rx1343_fail
    jump $I10
  rx1343_done:
    rx1343_cur."!cursor_fail"()
    if_null rx1343_debug, debug_1072
    rx1343_cur."!cursor_debug"("FAIL", "dotty")
  debug_1072:
    .return (rx1343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("213_1303739803.72") :method
.annotate 'line', 10
    $P1345 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1346, "ResizablePMCArray"
    push $P1346, "'"
    push $P1346, "\""
    push $P1346, $P1345
    .return ($P1346)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("214_1303739803.72")
    .param pmc param_1353
.annotate 'line', 528
    .lex "self", param_1353
    $P1354 = param_1353."!protoregex"("term")
    .return ($P1354)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("215_1303739803.72")
    .param pmc param_1356
.annotate 'line', 528
    .lex "self", param_1356
    $P1357 = param_1356."!PREFIX__!protoregex"("term")
    .return ($P1357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("216_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1359_tgt
    .local int rx1359_pos
    .local int rx1359_off
    .local int rx1359_eos
    .local int rx1359_rep
    .local pmc rx1359_cur
    .local pmc rx1359_debug
    (rx1359_cur, rx1359_pos, rx1359_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1359_cur
    .local pmc match
    .lex "$/", match
    length rx1359_eos, rx1359_tgt
    gt rx1359_pos, rx1359_eos, rx1359_done
    set rx1359_off, 0
    lt rx1359_pos, 2, rx1359_start
    sub rx1359_off, rx1359_pos, 1
    substr rx1359_tgt, rx1359_tgt, rx1359_off
  rx1359_start:
    eq $I10, 1, rx1359_restart
    if_null rx1359_debug, debug_1073
    rx1359_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1362_done
    goto rxscan1362_scan
  rxscan1362_loop:
    (rx1359_pos) = rx1359_cur."from"()
    inc rx1359_pos
    rx1359_cur."!cursor_from"(rx1359_pos)
    ge rx1359_pos, rx1359_eos, rxscan1362_done
  rxscan1362_scan:
    set_addr $I10, rxscan1362_loop
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  rxscan1362_done:
.annotate 'line', 530
  # rx subcapture "sym"
    set_addr $I10, rxcap_1363_fail
    rx1359_cur."!mark_push"(0, rx1359_pos, $I10)
  # rx literal  "self"
    add $I11, rx1359_pos, 4
    gt $I11, rx1359_eos, rx1359_fail
    sub $I11, rx1359_pos, rx1359_off
    substr $S10, rx1359_tgt, $I11, 4
    ne $S10, "self", rx1359_fail
    add rx1359_pos, 4
    set_addr $I10, rxcap_1363_fail
    ($I12, $I11) = rx1359_cur."!mark_peek"($I10)
    rx1359_cur."!cursor_pos"($I11)
    ($P10) = rx1359_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1359_pos, "")
    rx1359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1363_done
  rxcap_1363_fail:
    goto rx1359_fail
  rxcap_1363_done:
  # rxanchor rwb
    le rx1359_pos, 0, rx1359_fail
    sub $I10, rx1359_pos, rx1359_off
    is_cclass $I11, 8192, rx1359_tgt, $I10
    if $I11, rx1359_fail
    dec $I10
    is_cclass $I11, 8192, rx1359_tgt, $I10
    unless $I11, rx1359_fail
  # rx pass
    rx1359_cur."!cursor_pass"(rx1359_pos, "term:sym<self>")
    if_null rx1359_debug, debug_1074
    rx1359_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1359_pos)
  debug_1074:
    .return (rx1359_cur)
  rx1359_restart:
.annotate 'line', 10
    if_null rx1359_debug, debug_1075
    rx1359_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1075:
  rx1359_fail:
    (rx1359_rep, rx1359_pos, $I10, $P10) = rx1359_cur."!mark_fail"(0)
    lt rx1359_pos, -1, rx1359_done
    eq rx1359_pos, -1, rx1359_fail
    jump $I10
  rx1359_done:
    rx1359_cur."!cursor_fail"()
    if_null rx1359_debug, debug_1076
    rx1359_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1076:
    .return (rx1359_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("217_1303739803.72") :method
.annotate 'line', 10
    new $P1361, "ResizablePMCArray"
    push $P1361, "self"
    .return ($P1361)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("218_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1365_tgt
    .local int rx1365_pos
    .local int rx1365_off
    .local int rx1365_eos
    .local int rx1365_rep
    .local pmc rx1365_cur
    .local pmc rx1365_debug
    (rx1365_cur, rx1365_pos, rx1365_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1365_cur
    .local pmc match
    .lex "$/", match
    length rx1365_eos, rx1365_tgt
    gt rx1365_pos, rx1365_eos, rx1365_done
    set rx1365_off, 0
    lt rx1365_pos, 2, rx1365_start
    sub rx1365_off, rx1365_pos, 1
    substr rx1365_tgt, rx1365_tgt, rx1365_off
  rx1365_start:
    eq $I10, 1, rx1365_restart
    if_null rx1365_debug, debug_1077
    rx1365_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1369_done
    goto rxscan1369_scan
  rxscan1369_loop:
    (rx1365_pos) = rx1365_cur."from"()
    inc rx1365_pos
    rx1365_cur."!cursor_from"(rx1365_pos)
    ge rx1365_pos, rx1365_eos, rxscan1369_done
  rxscan1369_scan:
    set_addr $I10, rxscan1369_loop
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxscan1369_done:
.annotate 'line', 533
  # rx subrule "deflongname" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."deflongname"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1365_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1365_fail
  # rx subrule "args" subtype=capture negate=
    rx1365_cur."!cursor_pos"(rx1365_pos)
    $P10 = rx1365_cur."args"()
    unless $P10, rx1365_fail
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1365_pos = $P10."pos"()
.annotate 'line', 532
  # rx pass
    rx1365_cur."!cursor_pass"(rx1365_pos, "term:sym<identifier>")
    if_null rx1365_debug, debug_1078
    rx1365_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1365_pos)
  debug_1078:
    .return (rx1365_cur)
  rx1365_restart:
.annotate 'line', 10
    if_null rx1365_debug, debug_1079
    rx1365_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1079:
  rx1365_fail:
    (rx1365_rep, rx1365_pos, $I10, $P10) = rx1365_cur."!mark_fail"(0)
    lt rx1365_pos, -1, rx1365_done
    eq rx1365_pos, -1, rx1365_fail
    jump $I10
  rx1365_done:
    rx1365_cur."!cursor_fail"()
    if_null rx1365_debug, debug_1080
    rx1365_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1080:
    .return (rx1365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("219_1303739803.72") :method
.annotate 'line', 10
    $P1367 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1368, "ResizablePMCArray"
    push $P1368, $P1367
    .return ($P1368)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("220_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1371_tgt
    .local int rx1371_pos
    .local int rx1371_off
    .local int rx1371_eos
    .local int rx1371_rep
    .local pmc rx1371_cur
    .local pmc rx1371_debug
    (rx1371_cur, rx1371_pos, rx1371_tgt, $I10) = self."!cursor_start"()
    rx1371_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1371_cur
    .local pmc match
    .lex "$/", match
    length rx1371_eos, rx1371_tgt
    gt rx1371_pos, rx1371_eos, rx1371_done
    set rx1371_off, 0
    lt rx1371_pos, 2, rx1371_start
    sub rx1371_off, rx1371_pos, 1
    substr rx1371_tgt, rx1371_tgt, rx1371_off
  rx1371_start:
    eq $I10, 1, rx1371_restart
    if_null rx1371_debug, debug_1081
    rx1371_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1375_done
    goto rxscan1375_scan
  rxscan1375_loop:
    (rx1371_pos) = rx1371_cur."from"()
    inc rx1371_pos
    rx1371_cur."!cursor_from"(rx1371_pos)
    ge rx1371_pos, rx1371_eos, rxscan1375_done
  rxscan1375_scan:
    set_addr $I10, rxscan1375_loop
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  rxscan1375_done:
.annotate 'line', 537
  # rx subrule "name" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."name"()
    unless $P10, rx1371_fail
    rx1371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1371_pos = $P10."pos"()
  # rx rxquantr1376 ** 0..1
    set_addr $I10, rxquantr1376_done
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  rxquantr1376_loop:
  # rx subrule "args" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."args"()
    unless $P10, rx1371_fail
    goto rxsubrule1377_pass
  rxsubrule1377_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1371_fail
  rxsubrule1377_pass:
    set_addr $I10, rxsubrule1377_back
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1371_pos = $P10."pos"()
    set_addr $I10, rxquantr1376_done
    (rx1371_rep) = rx1371_cur."!mark_commit"($I10)
  rxquantr1376_done:
.annotate 'line', 536
  # rx pass
    rx1371_cur."!cursor_pass"(rx1371_pos, "term:sym<name>")
    if_null rx1371_debug, debug_1082
    rx1371_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1371_pos)
  debug_1082:
    .return (rx1371_cur)
  rx1371_restart:
.annotate 'line', 10
    if_null rx1371_debug, debug_1083
    rx1371_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1083:
  rx1371_fail:
    (rx1371_rep, rx1371_pos, $I10, $P10) = rx1371_cur."!mark_fail"(0)
    lt rx1371_pos, -1, rx1371_done
    eq rx1371_pos, -1, rx1371_fail
    jump $I10
  rx1371_done:
    rx1371_cur."!cursor_fail"()
    if_null rx1371_debug, debug_1084
    rx1371_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1084:
    .return (rx1371_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("221_1303739803.72") :method
.annotate 'line', 10
    $P1373 = self."!PREFIX__!subrule"("name", "")
    new $P1374, "ResizablePMCArray"
    push $P1374, $P1373
    .return ($P1374)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("222_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1379_tgt
    .local int rx1379_pos
    .local int rx1379_off
    .local int rx1379_eos
    .local int rx1379_rep
    .local pmc rx1379_cur
    .local pmc rx1379_debug
    (rx1379_cur, rx1379_pos, rx1379_tgt, $I10) = self."!cursor_start"()
    rx1379_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1379_cur
    .local pmc match
    .lex "$/", match
    length rx1379_eos, rx1379_tgt
    gt rx1379_pos, rx1379_eos, rx1379_done
    set rx1379_off, 0
    lt rx1379_pos, 2, rx1379_start
    sub rx1379_off, rx1379_pos, 1
    substr rx1379_tgt, rx1379_tgt, rx1379_off
  rx1379_start:
    eq $I10, 1, rx1379_restart
    if_null rx1379_debug, debug_1085
    rx1379_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1382_done
    goto rxscan1382_scan
  rxscan1382_loop:
    (rx1379_pos) = rx1379_cur."from"()
    inc rx1379_pos
    rx1379_cur."!cursor_from"(rx1379_pos)
    ge rx1379_pos, rx1379_eos, rxscan1382_done
  rxscan1382_scan:
    set_addr $I10, rxscan1382_loop
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  rxscan1382_done:
.annotate 'line', 541
  # rx literal  "pir::"
    add $I11, rx1379_pos, 5
    gt $I11, rx1379_eos, rx1379_fail
    sub $I11, rx1379_pos, rx1379_off
    substr $S10, rx1379_tgt, $I11, 5
    ne $S10, "pir::", rx1379_fail
    add rx1379_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1383_fail
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1379_pos, rx1379_off
    find_not_cclass $I11, 8192, rx1379_tgt, $I10, rx1379_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1379_fail
    add rx1379_pos, rx1379_off, $I11
    set_addr $I10, rxcap_1383_fail
    ($I12, $I11) = rx1379_cur."!mark_peek"($I10)
    rx1379_cur."!cursor_pos"($I11)
    ($P10) = rx1379_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1379_pos, "")
    rx1379_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1383_done
  rxcap_1383_fail:
    goto rx1379_fail
  rxcap_1383_done:
  # rx rxquantr1384 ** 0..1
    set_addr $I10, rxquantr1384_done
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10)
  rxquantr1384_loop:
  # rx subrule "args" subtype=capture negate=
    rx1379_cur."!cursor_pos"(rx1379_pos)
    $P10 = rx1379_cur."args"()
    unless $P10, rx1379_fail
    goto rxsubrule1385_pass
  rxsubrule1385_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1379_fail
  rxsubrule1385_pass:
    set_addr $I10, rxsubrule1385_back
    rx1379_cur."!mark_push"(0, rx1379_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1379_pos = $P10."pos"()
    set_addr $I10, rxquantr1384_done
    (rx1379_rep) = rx1379_cur."!mark_commit"($I10)
  rxquantr1384_done:
.annotate 'line', 540
  # rx pass
    rx1379_cur."!cursor_pass"(rx1379_pos, "term:sym<pir::op>")
    if_null rx1379_debug, debug_1086
    rx1379_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1379_pos)
  debug_1086:
    .return (rx1379_cur)
  rx1379_restart:
.annotate 'line', 10
    if_null rx1379_debug, debug_1087
    rx1379_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1087:
  rx1379_fail:
    (rx1379_rep, rx1379_pos, $I10, $P10) = rx1379_cur."!mark_fail"(0)
    lt rx1379_pos, -1, rx1379_done
    eq rx1379_pos, -1, rx1379_fail
    jump $I10
  rx1379_done:
    rx1379_cur."!cursor_fail"()
    if_null rx1379_debug, debug_1088
    rx1379_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1088:
    .return (rx1379_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("223_1303739803.72") :method
.annotate 'line', 10
    new $P1381, "ResizablePMCArray"
    push $P1381, "pir::"
    .return ($P1381)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("224_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P1395 = "226_1303739803.72" 
    capture_lex $P1395
    .local string rx1387_tgt
    .local int rx1387_pos
    .local int rx1387_off
    .local int rx1387_eos
    .local int rx1387_rep
    .local pmc rx1387_cur
    .local pmc rx1387_debug
    (rx1387_cur, rx1387_pos, rx1387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1387_cur
    .local pmc match
    .lex "$/", match
    length rx1387_eos, rx1387_tgt
    gt rx1387_pos, rx1387_eos, rx1387_done
    set rx1387_off, 0
    lt rx1387_pos, 2, rx1387_start
    sub rx1387_off, rx1387_pos, 1
    substr rx1387_tgt, rx1387_tgt, rx1387_off
  rx1387_start:
    eq $I10, 1, rx1387_restart
    if_null rx1387_debug, debug_1089
    rx1387_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1390_done
    goto rxscan1390_scan
  rxscan1390_loop:
    (rx1387_pos) = rx1387_cur."from"()
    inc rx1387_pos
    rx1387_cur."!cursor_from"(rx1387_pos)
    ge rx1387_pos, rx1387_eos, rxscan1390_done
  rxscan1390_scan:
    set_addr $I10, rxscan1390_loop
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  rxscan1390_done:
.annotate 'line', 545
  # rx literal  "{*}"
    add $I11, rx1387_pos, 3
    gt $I11, rx1387_eos, rx1387_fail
    sub $I11, rx1387_pos, rx1387_off
    substr $S10, rx1387_tgt, $I11, 3
    ne $S10, "{*}", rx1387_fail
    add rx1387_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."ENDSTMT"()
    unless $P10, rx1387_fail
  alt1391_0:
.annotate 'line', 546
    set_addr $I10, alt1391_1
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
    rx1387_cur."!cursor_pos"(rx1387_pos)
    find_lex $P1392, unicode:"$\x{a2}"
    $P1393 = $P1392."MATCH"()
    store_lex "$/", $P1393
    .const 'Sub' $P1395 = "226_1303739803.72" 
    capture_lex $P1395
    $P1401 = $P1395()
    unless $P1401, rx1387_fail
    goto alt1391_end
  alt1391_1:
  # rx subrule "panic" subtype=method negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1387_fail
    rx1387_pos = $P10."pos"()
  alt1391_end:
.annotate 'line', 544
  # rx pass
    rx1387_cur."!cursor_pass"(rx1387_pos, "term:sym<onlystar>")
    if_null rx1387_debug, debug_1092
    rx1387_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1387_pos)
  debug_1092:
    .return (rx1387_cur)
  rx1387_restart:
.annotate 'line', 10
    if_null rx1387_debug, debug_1093
    rx1387_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1093:
  rx1387_fail:
    (rx1387_rep, rx1387_pos, $I10, $P10) = rx1387_cur."!mark_fail"(0)
    lt rx1387_pos, -1, rx1387_done
    eq rx1387_pos, -1, rx1387_fail
    jump $I10
  rx1387_done:
    rx1387_cur."!cursor_fail"()
    if_null rx1387_debug, debug_1094
    rx1387_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1094:
    .return (rx1387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("225_1303739803.72") :method
.annotate 'line', 10
    new $P1389, "ResizablePMCArray"
    push $P1389, "{*}"
    .return ($P1389)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1394"  :anon :subid("226_1303739803.72") :outer("224_1303739803.72")
.annotate 'line', 546
    find_dynamic_lex $P1398, "$*MULTINESS"
    unless_null $P1398, vivify_1090
    get_hll_global $P1396, "GLOBAL"
    get_who $P1397, $P1396
    set $P1398, $P1397["$MULTINESS"]
    unless_null $P1398, vivify_1091
    die "Contextual $*MULTINESS not found"
  vivify_1091:
  vivify_1090:
    set $S1399, $P1398
    iseq $I1400, $S1399, "proto"
    .return ($I1400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("227_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1403_tgt
    .local int rx1403_pos
    .local int rx1403_off
    .local int rx1403_eos
    .local int rx1403_rep
    .local pmc rx1403_cur
    .local pmc rx1403_debug
    (rx1403_cur, rx1403_pos, rx1403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1403_cur
    .local pmc match
    .lex "$/", match
    length rx1403_eos, rx1403_tgt
    gt rx1403_pos, rx1403_eos, rx1403_done
    set rx1403_off, 0
    lt rx1403_pos, 2, rx1403_start
    sub rx1403_off, rx1403_pos, 1
    substr rx1403_tgt, rx1403_tgt, rx1403_off
  rx1403_start:
    eq $I10, 1, rx1403_restart
    if_null rx1403_debug, debug_1095
    rx1403_cur."!cursor_debug"("START", "args")
  debug_1095:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1407_done
    goto rxscan1407_scan
  rxscan1407_loop:
    (rx1403_pos) = rx1403_cur."from"()
    inc rx1403_pos
    rx1403_cur."!cursor_from"(rx1403_pos)
    ge rx1403_pos, rx1403_eos, rxscan1407_done
  rxscan1407_scan:
    set_addr $I10, rxscan1407_loop
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  rxscan1407_done:
.annotate 'line', 550
  # rx literal  "("
    add $I11, rx1403_pos, 1
    gt $I11, rx1403_eos, rx1403_fail
    sub $I11, rx1403_pos, rx1403_off
    ord $I11, rx1403_tgt, $I11
    ne $I11, 40, rx1403_fail
    add rx1403_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."arglist"()
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1403_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1403_pos, 1
    gt $I11, rx1403_eos, rx1403_fail
    sub $I11, rx1403_pos, rx1403_off
    ord $I11, rx1403_tgt, $I11
    ne $I11, 41, rx1403_fail
    add rx1403_pos, 1
  # rx pass
    rx1403_cur."!cursor_pass"(rx1403_pos, "args")
    if_null rx1403_debug, debug_1096
    rx1403_cur."!cursor_debug"("PASS", "args", " at pos=", rx1403_pos)
  debug_1096:
    .return (rx1403_cur)
  rx1403_restart:
.annotate 'line', 10
    if_null rx1403_debug, debug_1097
    rx1403_cur."!cursor_debug"("NEXT", "args")
  debug_1097:
  rx1403_fail:
    (rx1403_rep, rx1403_pos, $I10, $P10) = rx1403_cur."!mark_fail"(0)
    lt rx1403_pos, -1, rx1403_done
    eq rx1403_pos, -1, rx1403_fail
    jump $I10
  rx1403_done:
    rx1403_cur."!cursor_fail"()
    if_null rx1403_debug, debug_1098
    rx1403_cur."!cursor_debug"("FAIL", "args")
  debug_1098:
    .return (rx1403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("228_1303739803.72") :method
.annotate 'line', 10
    $P1405 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1406, "ResizablePMCArray"
    push $P1406, $P1405
    .return ($P1406)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("229_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1409_tgt
    .local int rx1409_pos
    .local int rx1409_off
    .local int rx1409_eos
    .local int rx1409_rep
    .local pmc rx1409_cur
    .local pmc rx1409_debug
    (rx1409_cur, rx1409_pos, rx1409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1409_cur
    .local pmc match
    .lex "$/", match
    length rx1409_eos, rx1409_tgt
    gt rx1409_pos, rx1409_eos, rx1409_done
    set rx1409_off, 0
    lt rx1409_pos, 2, rx1409_start
    sub rx1409_off, rx1409_pos, 1
    substr rx1409_tgt, rx1409_tgt, rx1409_off
  rx1409_start:
    eq $I10, 1, rx1409_restart
    if_null rx1409_debug, debug_1099
    rx1409_cur."!cursor_debug"("START", "arglist")
  debug_1099:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1413_done
    goto rxscan1413_scan
  rxscan1413_loop:
    (rx1409_pos) = rx1409_cur."from"()
    inc rx1409_pos
    rx1409_cur."!cursor_from"(rx1409_pos)
    ge rx1409_pos, rx1409_eos, rxscan1413_done
  rxscan1413_scan:
    set_addr $I10, rxscan1413_loop
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  rxscan1413_done:
.annotate 'line', 554
  # rx subrule "ws" subtype=method negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."ws"()
    unless $P10, rx1409_fail
    rx1409_pos = $P10."pos"()
  alt1414_0:
.annotate 'line', 555
    set_addr $I10, alt1414_1
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
.annotate 'line', 556
  # rx subrule "EXPR" subtype=capture negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."EXPR"("f=")
    unless $P10, rx1409_fail
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1409_pos = $P10."pos"()
    goto alt1414_end
  alt1414_1:
  alt1414_end:
.annotate 'line', 553
  # rx pass
    rx1409_cur."!cursor_pass"(rx1409_pos, "arglist")
    if_null rx1409_debug, debug_1100
    rx1409_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1409_pos)
  debug_1100:
    .return (rx1409_cur)
  rx1409_restart:
.annotate 'line', 10
    if_null rx1409_debug, debug_1101
    rx1409_cur."!cursor_debug"("NEXT", "arglist")
  debug_1101:
  rx1409_fail:
    (rx1409_rep, rx1409_pos, $I10, $P10) = rx1409_cur."!mark_fail"(0)
    lt rx1409_pos, -1, rx1409_done
    eq rx1409_pos, -1, rx1409_fail
    jump $I10
  rx1409_done:
    rx1409_cur."!cursor_fail"()
    if_null rx1409_debug, debug_1102
    rx1409_cur."!cursor_debug"("FAIL", "arglist")
  debug_1102:
    .return (rx1409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("230_1303739803.72") :method
.annotate 'line', 10
    $P1411 = self."!PREFIX__!subrule"("ws", "")
    new $P1412, "ResizablePMCArray"
    push $P1412, $P1411
    .return ($P1412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("231_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1416_tgt
    .local int rx1416_pos
    .local int rx1416_off
    .local int rx1416_eos
    .local int rx1416_rep
    .local pmc rx1416_cur
    .local pmc rx1416_debug
    (rx1416_cur, rx1416_pos, rx1416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1416_cur
    .local pmc match
    .lex "$/", match
    length rx1416_eos, rx1416_tgt
    gt rx1416_pos, rx1416_eos, rx1416_done
    set rx1416_off, 0
    lt rx1416_pos, 2, rx1416_start
    sub rx1416_off, rx1416_pos, 1
    substr rx1416_tgt, rx1416_tgt, rx1416_off
  rx1416_start:
    eq $I10, 1, rx1416_restart
    if_null rx1416_debug, debug_1103
    rx1416_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1103:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1420_done
    goto rxscan1420_scan
  rxscan1420_loop:
    (rx1416_pos) = rx1416_cur."from"()
    inc rx1416_pos
    rx1416_cur."!cursor_from"(rx1416_pos)
    ge rx1416_pos, rx1416_eos, rxscan1420_done
  rxscan1420_scan:
    set_addr $I10, rxscan1420_loop
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  rxscan1420_done:
.annotate 'line', 562
  # rx subrule "value" subtype=capture negate=
    rx1416_cur."!cursor_pos"(rx1416_pos)
    $P10 = rx1416_cur."value"()
    unless $P10, rx1416_fail
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1416_pos = $P10."pos"()
  # rx pass
    rx1416_cur."!cursor_pass"(rx1416_pos, "term:sym<value>")
    if_null rx1416_debug, debug_1104
    rx1416_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1416_pos)
  debug_1104:
    .return (rx1416_cur)
  rx1416_restart:
.annotate 'line', 10
    if_null rx1416_debug, debug_1105
    rx1416_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1105:
  rx1416_fail:
    (rx1416_rep, rx1416_pos, $I10, $P10) = rx1416_cur."!mark_fail"(0)
    lt rx1416_pos, -1, rx1416_done
    eq rx1416_pos, -1, rx1416_fail
    jump $I10
  rx1416_done:
    rx1416_cur."!cursor_fail"()
    if_null rx1416_debug, debug_1106
    rx1416_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1106:
    .return (rx1416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("232_1303739803.72") :method
.annotate 'line', 10
    $P1418 = self."!PREFIX__!subrule"("value", "")
    new $P1419, "ResizablePMCArray"
    push $P1419, $P1418
    .return ($P1419)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("233_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1422_tgt
    .local int rx1422_pos
    .local int rx1422_off
    .local int rx1422_eos
    .local int rx1422_rep
    .local pmc rx1422_cur
    .local pmc rx1422_debug
    (rx1422_cur, rx1422_pos, rx1422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1422_cur
    .local pmc match
    .lex "$/", match
    length rx1422_eos, rx1422_tgt
    gt rx1422_pos, rx1422_eos, rx1422_done
    set rx1422_off, 0
    lt rx1422_pos, 2, rx1422_start
    sub rx1422_off, rx1422_pos, 1
    substr rx1422_tgt, rx1422_tgt, rx1422_off
  rx1422_start:
    eq $I10, 1, rx1422_restart
    if_null rx1422_debug, debug_1107
    rx1422_cur."!cursor_debug"("START", "value")
  debug_1107:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1427_done
    goto rxscan1427_scan
  rxscan1427_loop:
    (rx1422_pos) = rx1422_cur."from"()
    inc rx1422_pos
    rx1422_cur."!cursor_from"(rx1422_pos)
    ge rx1422_pos, rx1422_eos, rxscan1427_done
  rxscan1427_scan:
    set_addr $I10, rxscan1427_loop
    rx1422_cur."!mark_push"(0, rx1422_pos, $I10)
  rxscan1427_done:
  alt1428_0:
.annotate 'line', 564
    set_addr $I10, alt1428_1
    rx1422_cur."!mark_push"(0, rx1422_pos, $I10)
.annotate 'line', 565
  # rx subrule "quote" subtype=capture negate=
    rx1422_cur."!cursor_pos"(rx1422_pos)
    $P10 = rx1422_cur."quote"()
    unless $P10, rx1422_fail
    rx1422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1422_pos = $P10."pos"()
    goto alt1428_end
  alt1428_1:
.annotate 'line', 566
  # rx subrule "number" subtype=capture negate=
    rx1422_cur."!cursor_pos"(rx1422_pos)
    $P10 = rx1422_cur."number"()
    unless $P10, rx1422_fail
    rx1422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1422_pos = $P10."pos"()
  alt1428_end:
.annotate 'line', 564
  # rx pass
    rx1422_cur."!cursor_pass"(rx1422_pos, "value")
    if_null rx1422_debug, debug_1108
    rx1422_cur."!cursor_debug"("PASS", "value", " at pos=", rx1422_pos)
  debug_1108:
    .return (rx1422_cur)
  rx1422_restart:
.annotate 'line', 10
    if_null rx1422_debug, debug_1109
    rx1422_cur."!cursor_debug"("NEXT", "value")
  debug_1109:
  rx1422_fail:
    (rx1422_rep, rx1422_pos, $I10, $P10) = rx1422_cur."!mark_fail"(0)
    lt rx1422_pos, -1, rx1422_done
    eq rx1422_pos, -1, rx1422_fail
    jump $I10
  rx1422_done:
    rx1422_cur."!cursor_fail"()
    if_null rx1422_debug, debug_1110
    rx1422_cur."!cursor_debug"("FAIL", "value")
  debug_1110:
    .return (rx1422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("234_1303739803.72") :method
.annotate 'line', 10
    $P1424 = self."!PREFIX__!subrule"("number", "")
    $P1425 = self."!PREFIX__!subrule"("quote", "")
    new $P1426, "ResizablePMCArray"
    push $P1426, $P1424
    push $P1426, $P1425
    .return ($P1426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("235_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1111
    rx1430_cur."!cursor_debug"("START", "number")
  debug_1111:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1433_done
    goto rxscan1433_scan
  rxscan1433_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1433_done
  rxscan1433_scan:
    set_addr $I10, rxscan1433_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1433_done:
.annotate 'line', 570
  # rx subcapture "sign"
    set_addr $I10, rxcap_1435_fail
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1430_pos, rx1430_off
    set rx1430_rep, 0
    sub $I12, rx1430_eos, rx1430_pos
    le $I12, 1, rxenumcharlistq1434_loop
    set $I12, 1
  rxenumcharlistq1434_loop:
    le $I12, 0, rxenumcharlistq1434_done
    substr $S10, rx1430_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1434_done
    inc rx1430_rep
  rxenumcharlistq1434_done:
    add rx1430_pos, rx1430_pos, rx1430_rep
    set_addr $I10, rxcap_1435_fail
    ($I12, $I11) = rx1430_cur."!mark_peek"($I10)
    rx1430_cur."!cursor_pos"($I11)
    ($P10) = rx1430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1430_pos, "")
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1435_done
  rxcap_1435_fail:
    goto rx1430_fail
  rxcap_1435_done:
  alt1436_0:
.annotate 'line', 571
    set_addr $I10, alt1436_1
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."dec_number"()
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1430_pos = $P10."pos"()
    goto alt1436_end
  alt1436_1:
  # rx subrule "integer" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."integer"()
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1430_pos = $P10."pos"()
  alt1436_end:
.annotate 'line', 569
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "number")
    if_null rx1430_debug, debug_1112
    rx1430_cur."!cursor_debug"("PASS", "number", " at pos=", rx1430_pos)
  debug_1112:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 10
    if_null rx1430_debug, debug_1113
    rx1430_cur."!cursor_debug"("NEXT", "number")
  debug_1113:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1114
    rx1430_cur."!cursor_debug"("FAIL", "number")
  debug_1114:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("236_1303739803.72") :method
.annotate 'line', 10
    new $P1432, "ResizablePMCArray"
    push $P1432, ""
    .return ($P1432)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("237_1303739803.72")
    .param pmc param_1438
.annotate 'line', 574
    .lex "self", param_1438
    $P1439 = param_1438."!protoregex"("quote")
    .return ($P1439)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("238_1303739803.72")
    .param pmc param_1441
.annotate 'line', 574
    .lex "self", param_1441
    $P1442 = param_1441."!PREFIX__!protoregex"("quote")
    .return ($P1442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("239_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1444_tgt
    .local int rx1444_pos
    .local int rx1444_off
    .local int rx1444_eos
    .local int rx1444_rep
    .local pmc rx1444_cur
    .local pmc rx1444_debug
    (rx1444_cur, rx1444_pos, rx1444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1444_cur
    .local pmc match
    .lex "$/", match
    length rx1444_eos, rx1444_tgt
    gt rx1444_pos, rx1444_eos, rx1444_done
    set rx1444_off, 0
    lt rx1444_pos, 2, rx1444_start
    sub rx1444_off, rx1444_pos, 1
    substr rx1444_tgt, rx1444_tgt, rx1444_off
  rx1444_start:
    eq $I10, 1, rx1444_restart
    if_null rx1444_debug, debug_1115
    rx1444_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1115:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1447_done
    goto rxscan1447_scan
  rxscan1447_loop:
    (rx1444_pos) = rx1444_cur."from"()
    inc rx1444_pos
    rx1444_cur."!cursor_from"(rx1444_pos)
    ge rx1444_pos, rx1444_eos, rxscan1447_done
  rxscan1447_scan:
    set_addr $I10, rxscan1447_loop
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  rxscan1447_done:
.annotate 'line', 575
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1444_pos, rx1444_off
    substr $S10, rx1444_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1444_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."quote_EXPR"(":q")
    unless $P10, rx1444_fail
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1444_pos = $P10."pos"()
  # rx pass
    rx1444_cur."!cursor_pass"(rx1444_pos, "quote:sym<apos>")
    if_null rx1444_debug, debug_1116
    rx1444_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1444_pos)
  debug_1116:
    .return (rx1444_cur)
  rx1444_restart:
.annotate 'line', 10
    if_null rx1444_debug, debug_1117
    rx1444_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1117:
  rx1444_fail:
    (rx1444_rep, rx1444_pos, $I10, $P10) = rx1444_cur."!mark_fail"(0)
    lt rx1444_pos, -1, rx1444_done
    eq rx1444_pos, -1, rx1444_fail
    jump $I10
  rx1444_done:
    rx1444_cur."!cursor_fail"()
    if_null rx1444_debug, debug_1118
    rx1444_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1118:
    .return (rx1444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("240_1303739803.72") :method
.annotate 'line', 10
    new $P1446, "ResizablePMCArray"
    push $P1446, "'"
    .return ($P1446)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("241_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1449_tgt
    .local int rx1449_pos
    .local int rx1449_off
    .local int rx1449_eos
    .local int rx1449_rep
    .local pmc rx1449_cur
    .local pmc rx1449_debug
    (rx1449_cur, rx1449_pos, rx1449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1449_cur
    .local pmc match
    .lex "$/", match
    length rx1449_eos, rx1449_tgt
    gt rx1449_pos, rx1449_eos, rx1449_done
    set rx1449_off, 0
    lt rx1449_pos, 2, rx1449_start
    sub rx1449_off, rx1449_pos, 1
    substr rx1449_tgt, rx1449_tgt, rx1449_off
  rx1449_start:
    eq $I10, 1, rx1449_restart
    if_null rx1449_debug, debug_1119
    rx1449_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1119:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1452_done
    goto rxscan1452_scan
  rxscan1452_loop:
    (rx1449_pos) = rx1449_cur."from"()
    inc rx1449_pos
    rx1449_cur."!cursor_from"(rx1449_pos)
    ge rx1449_pos, rx1449_eos, rxscan1452_done
  rxscan1452_scan:
    set_addr $I10, rxscan1452_loop
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxscan1452_done:
.annotate 'line', 576
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1449_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."quote_EXPR"(":qq")
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1449_pos = $P10."pos"()
  # rx pass
    rx1449_cur."!cursor_pass"(rx1449_pos, "quote:sym<dblq>")
    if_null rx1449_debug, debug_1120
    rx1449_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1449_pos)
  debug_1120:
    .return (rx1449_cur)
  rx1449_restart:
.annotate 'line', 10
    if_null rx1449_debug, debug_1121
    rx1449_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1121:
  rx1449_fail:
    (rx1449_rep, rx1449_pos, $I10, $P10) = rx1449_cur."!mark_fail"(0)
    lt rx1449_pos, -1, rx1449_done
    eq rx1449_pos, -1, rx1449_fail
    jump $I10
  rx1449_done:
    rx1449_cur."!cursor_fail"()
    if_null rx1449_debug, debug_1122
    rx1449_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1122:
    .return (rx1449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("242_1303739803.72") :method
.annotate 'line', 10
    new $P1451, "ResizablePMCArray"
    push $P1451, "\""
    .return ($P1451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("243_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1454_tgt
    .local int rx1454_pos
    .local int rx1454_off
    .local int rx1454_eos
    .local int rx1454_rep
    .local pmc rx1454_cur
    .local pmc rx1454_debug
    (rx1454_cur, rx1454_pos, rx1454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1454_cur
    .local pmc match
    .lex "$/", match
    length rx1454_eos, rx1454_tgt
    gt rx1454_pos, rx1454_eos, rx1454_done
    set rx1454_off, 0
    lt rx1454_pos, 2, rx1454_start
    sub rx1454_off, rx1454_pos, 1
    substr rx1454_tgt, rx1454_tgt, rx1454_off
  rx1454_start:
    eq $I10, 1, rx1454_restart
    if_null rx1454_debug, debug_1123
    rx1454_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1123:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1458_done
    goto rxscan1458_scan
  rxscan1458_loop:
    (rx1454_pos) = rx1454_cur."from"()
    inc rx1454_pos
    rx1454_cur."!cursor_from"(rx1454_pos)
    ge rx1454_pos, rx1454_eos, rxscan1458_done
  rxscan1458_scan:
    set_addr $I10, rxscan1458_loop
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  rxscan1458_done:
.annotate 'line', 577
  # rx subcapture "sym"
    set_addr $I10, rxcap_1459_fail
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  # rx literal  "q"
    add $I11, rx1454_pos, 1
    gt $I11, rx1454_eos, rx1454_fail
    sub $I11, rx1454_pos, rx1454_off
    ord $I11, rx1454_tgt, $I11
    ne $I11, 113, rx1454_fail
    add rx1454_pos, 1
    set_addr $I10, rxcap_1459_fail
    ($I12, $I11) = rx1454_cur."!mark_peek"($I10)
    rx1454_cur."!cursor_pos"($I11)
    ($P10) = rx1454_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1454_pos, "")
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1459_done
  rxcap_1459_fail:
    goto rx1454_fail
  rxcap_1459_done:
  # rxanchor rwb
    le rx1454_pos, 0, rx1454_fail
    sub $I10, rx1454_pos, rx1454_off
    is_cclass $I11, 8192, rx1454_tgt, $I10
    if $I11, rx1454_fail
    dec $I10
    is_cclass $I11, 8192, rx1454_tgt, $I10
    unless $I11, rx1454_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1454_pos, rx1454_off
    substr $S10, rx1454_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1454_fail
  # rx subrule "ws" subtype=method negate=
    rx1454_cur."!cursor_pos"(rx1454_pos)
    $P10 = rx1454_cur."ws"()
    unless $P10, rx1454_fail
    rx1454_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1454_cur."!cursor_pos"(rx1454_pos)
    $P10 = rx1454_cur."quote_EXPR"(":q")
    unless $P10, rx1454_fail
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1454_pos = $P10."pos"()
  # rx pass
    rx1454_cur."!cursor_pass"(rx1454_pos, "quote:sym<q>")
    if_null rx1454_debug, debug_1124
    rx1454_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1454_pos)
  debug_1124:
    .return (rx1454_cur)
  rx1454_restart:
.annotate 'line', 10
    if_null rx1454_debug, debug_1125
    rx1454_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1125:
  rx1454_fail:
    (rx1454_rep, rx1454_pos, $I10, $P10) = rx1454_cur."!mark_fail"(0)
    lt rx1454_pos, -1, rx1454_done
    eq rx1454_pos, -1, rx1454_fail
    jump $I10
  rx1454_done:
    rx1454_cur."!cursor_fail"()
    if_null rx1454_debug, debug_1126
    rx1454_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1126:
    .return (rx1454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("244_1303739803.72") :method
.annotate 'line', 10
    $P1456 = self."!PREFIX__!subrule"("ws", "q")
    new $P1457, "ResizablePMCArray"
    push $P1457, $P1456
    .return ($P1457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("245_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1461_tgt
    .local int rx1461_pos
    .local int rx1461_off
    .local int rx1461_eos
    .local int rx1461_rep
    .local pmc rx1461_cur
    .local pmc rx1461_debug
    (rx1461_cur, rx1461_pos, rx1461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1461_cur
    .local pmc match
    .lex "$/", match
    length rx1461_eos, rx1461_tgt
    gt rx1461_pos, rx1461_eos, rx1461_done
    set rx1461_off, 0
    lt rx1461_pos, 2, rx1461_start
    sub rx1461_off, rx1461_pos, 1
    substr rx1461_tgt, rx1461_tgt, rx1461_off
  rx1461_start:
    eq $I10, 1, rx1461_restart
    if_null rx1461_debug, debug_1127
    rx1461_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1127:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1465_done
    goto rxscan1465_scan
  rxscan1465_loop:
    (rx1461_pos) = rx1461_cur."from"()
    inc rx1461_pos
    rx1461_cur."!cursor_from"(rx1461_pos)
    ge rx1461_pos, rx1461_eos, rxscan1465_done
  rxscan1465_scan:
    set_addr $I10, rxscan1465_loop
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  rxscan1465_done:
.annotate 'line', 578
  # rx subcapture "sym"
    set_addr $I10, rxcap_1466_fail
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1461_pos, 2
    gt $I11, rx1461_eos, rx1461_fail
    sub $I11, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I11, 2
    ne $S10, "qq", rx1461_fail
    add rx1461_pos, 2
    set_addr $I10, rxcap_1466_fail
    ($I12, $I11) = rx1461_cur."!mark_peek"($I10)
    rx1461_cur."!cursor_pos"($I11)
    ($P10) = rx1461_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1461_pos, "")
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1466_done
  rxcap_1466_fail:
    goto rx1461_fail
  rxcap_1466_done:
  # rxanchor rwb
    le rx1461_pos, 0, rx1461_fail
    sub $I10, rx1461_pos, rx1461_off
    is_cclass $I11, 8192, rx1461_tgt, $I10
    if $I11, rx1461_fail
    dec $I10
    is_cclass $I11, 8192, rx1461_tgt, $I10
    unless $I11, rx1461_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1461_fail
  # rx subrule "ws" subtype=method negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."ws"()
    unless $P10, rx1461_fail
    rx1461_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."quote_EXPR"(":qq")
    unless $P10, rx1461_fail
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1461_pos = $P10."pos"()
  # rx pass
    rx1461_cur."!cursor_pass"(rx1461_pos, "quote:sym<qq>")
    if_null rx1461_debug, debug_1128
    rx1461_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1461_pos)
  debug_1128:
    .return (rx1461_cur)
  rx1461_restart:
.annotate 'line', 10
    if_null rx1461_debug, debug_1129
    rx1461_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1129:
  rx1461_fail:
    (rx1461_rep, rx1461_pos, $I10, $P10) = rx1461_cur."!mark_fail"(0)
    lt rx1461_pos, -1, rx1461_done
    eq rx1461_pos, -1, rx1461_fail
    jump $I10
  rx1461_done:
    rx1461_cur."!cursor_fail"()
    if_null rx1461_debug, debug_1130
    rx1461_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1130:
    .return (rx1461_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("246_1303739803.72") :method
.annotate 'line', 10
    $P1463 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1464, "ResizablePMCArray"
    push $P1464, $P1463
    .return ($P1464)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("247_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1468_tgt
    .local int rx1468_pos
    .local int rx1468_off
    .local int rx1468_eos
    .local int rx1468_rep
    .local pmc rx1468_cur
    .local pmc rx1468_debug
    (rx1468_cur, rx1468_pos, rx1468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1468_cur
    .local pmc match
    .lex "$/", match
    length rx1468_eos, rx1468_tgt
    gt rx1468_pos, rx1468_eos, rx1468_done
    set rx1468_off, 0
    lt rx1468_pos, 2, rx1468_start
    sub rx1468_off, rx1468_pos, 1
    substr rx1468_tgt, rx1468_tgt, rx1468_off
  rx1468_start:
    eq $I10, 1, rx1468_restart
    if_null rx1468_debug, debug_1131
    rx1468_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1131:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1472_done
    goto rxscan1472_scan
  rxscan1472_loop:
    (rx1468_pos) = rx1468_cur."from"()
    inc rx1468_pos
    rx1468_cur."!cursor_from"(rx1468_pos)
    ge rx1468_pos, rx1468_eos, rxscan1472_done
  rxscan1472_scan:
    set_addr $I10, rxscan1472_loop
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  rxscan1472_done:
.annotate 'line', 579
  # rx subcapture "sym"
    set_addr $I10, rxcap_1473_fail
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1468_pos, 1
    gt $I11, rx1468_eos, rx1468_fail
    sub $I11, rx1468_pos, rx1468_off
    ord $I11, rx1468_tgt, $I11
    ne $I11, 81, rx1468_fail
    add rx1468_pos, 1
    set_addr $I10, rxcap_1473_fail
    ($I12, $I11) = rx1468_cur."!mark_peek"($I10)
    rx1468_cur."!cursor_pos"($I11)
    ($P10) = rx1468_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1468_pos, "")
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1473_done
  rxcap_1473_fail:
    goto rx1468_fail
  rxcap_1473_done:
  # rxanchor rwb
    le rx1468_pos, 0, rx1468_fail
    sub $I10, rx1468_pos, rx1468_off
    is_cclass $I11, 8192, rx1468_tgt, $I10
    if $I11, rx1468_fail
    dec $I10
    is_cclass $I11, 8192, rx1468_tgt, $I10
    unless $I11, rx1468_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1468_pos, rx1468_off
    substr $S10, rx1468_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1468_fail
  # rx subrule "ws" subtype=method negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."ws"()
    unless $P10, rx1468_fail
    rx1468_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."quote_EXPR"()
    unless $P10, rx1468_fail
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1468_pos = $P10."pos"()
  # rx pass
    rx1468_cur."!cursor_pass"(rx1468_pos, "quote:sym<Q>")
    if_null rx1468_debug, debug_1132
    rx1468_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1468_pos)
  debug_1132:
    .return (rx1468_cur)
  rx1468_restart:
.annotate 'line', 10
    if_null rx1468_debug, debug_1133
    rx1468_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1133:
  rx1468_fail:
    (rx1468_rep, rx1468_pos, $I10, $P10) = rx1468_cur."!mark_fail"(0)
    lt rx1468_pos, -1, rx1468_done
    eq rx1468_pos, -1, rx1468_fail
    jump $I10
  rx1468_done:
    rx1468_cur."!cursor_fail"()
    if_null rx1468_debug, debug_1134
    rx1468_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1134:
    .return (rx1468_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("248_1303739803.72") :method
.annotate 'line', 10
    $P1470 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1471, "ResizablePMCArray"
    push $P1471, $P1470
    .return ($P1471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("249_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1475_tgt
    .local int rx1475_pos
    .local int rx1475_off
    .local int rx1475_eos
    .local int rx1475_rep
    .local pmc rx1475_cur
    .local pmc rx1475_debug
    (rx1475_cur, rx1475_pos, rx1475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1475_cur
    .local pmc match
    .lex "$/", match
    length rx1475_eos, rx1475_tgt
    gt rx1475_pos, rx1475_eos, rx1475_done
    set rx1475_off, 0
    lt rx1475_pos, 2, rx1475_start
    sub rx1475_off, rx1475_pos, 1
    substr rx1475_tgt, rx1475_tgt, rx1475_off
  rx1475_start:
    eq $I10, 1, rx1475_restart
    if_null rx1475_debug, debug_1135
    rx1475_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1135:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1479_done
    goto rxscan1479_scan
  rxscan1479_loop:
    (rx1475_pos) = rx1475_cur."from"()
    inc rx1475_pos
    rx1475_cur."!cursor_from"(rx1475_pos)
    ge rx1475_pos, rx1475_eos, rxscan1479_done
  rxscan1479_scan:
    set_addr $I10, rxscan1479_loop
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  rxscan1479_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1480_fail
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1475_pos, 5
    gt $I11, rx1475_eos, rx1475_fail
    sub $I11, rx1475_pos, rx1475_off
    substr $S10, rx1475_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1475_fail
    add rx1475_pos, 5
    set_addr $I10, rxcap_1480_fail
    ($I12, $I11) = rx1475_cur."!mark_peek"($I10)
    rx1475_cur."!cursor_pos"($I11)
    ($P10) = rx1475_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1475_pos, "")
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1480_done
  rxcap_1480_fail:
    goto rx1475_fail
  rxcap_1480_done:
  # rx subrule "ws" subtype=method negate=
    rx1475_cur."!cursor_pos"(rx1475_pos)
    $P10 = rx1475_cur."ws"()
    unless $P10, rx1475_fail
    rx1475_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1475_cur."!cursor_pos"(rx1475_pos)
    $P10 = rx1475_cur."quote_EXPR"()
    unless $P10, rx1475_fail
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1475_pos = $P10."pos"()
  # rx pass
    rx1475_cur."!cursor_pass"(rx1475_pos, "quote:sym<Q:PIR>")
    if_null rx1475_debug, debug_1136
    rx1475_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1475_pos)
  debug_1136:
    .return (rx1475_cur)
  rx1475_restart:
.annotate 'line', 10
    if_null rx1475_debug, debug_1137
    rx1475_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1137:
  rx1475_fail:
    (rx1475_rep, rx1475_pos, $I10, $P10) = rx1475_cur."!mark_fail"(0)
    lt rx1475_pos, -1, rx1475_done
    eq rx1475_pos, -1, rx1475_fail
    jump $I10
  rx1475_done:
    rx1475_cur."!cursor_fail"()
    if_null rx1475_debug, debug_1138
    rx1475_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1138:
    .return (rx1475_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("250_1303739803.72") :method
.annotate 'line', 10
    $P1477 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1478, "ResizablePMCArray"
    push $P1478, $P1477
    .return ($P1478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("251_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1482_tgt
    .local int rx1482_pos
    .local int rx1482_off
    .local int rx1482_eos
    .local int rx1482_rep
    .local pmc rx1482_cur
    .local pmc rx1482_debug
    (rx1482_cur, rx1482_pos, rx1482_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1482_cur
    .local pmc match
    .lex "$/", match
    length rx1482_eos, rx1482_tgt
    gt rx1482_pos, rx1482_eos, rx1482_done
    set rx1482_off, 0
    lt rx1482_pos, 2, rx1482_start
    sub rx1482_off, rx1482_pos, 1
    substr rx1482_tgt, rx1482_tgt, rx1482_off
  rx1482_start:
    eq $I10, 1, rx1482_restart
    if_null rx1482_debug, debug_1139
    rx1482_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1139:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1486_done
    goto rxscan1486_scan
  rxscan1486_loop:
    (rx1482_pos) = rx1482_cur."from"()
    inc rx1482_pos
    rx1482_cur."!cursor_from"(rx1482_pos)
    ge rx1482_pos, rx1482_eos, rxscan1486_done
  rxscan1486_scan:
    set_addr $I10, rxscan1486_loop
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  rxscan1486_done:
.annotate 'line', 582
  # rx literal  "/"
    add $I11, rx1482_pos, 1
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    ord $I11, rx1482_tgt, $I11
    ne $I11, 47, rx1482_fail
    add rx1482_pos, 1
.annotate 'line', 583
  # rx subrule "newpad" subtype=method negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."newpad"()
    unless $P10, rx1482_fail
    rx1482_pos = $P10."pos"()
.annotate 'line', 584
  # rx reduce name="quote:sym</ />" key="open"
    rx1482_cur."!cursor_pos"(rx1482_pos)
    rx1482_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 585
  # rx subrule "LANG" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1482_pos = $P10."pos"()
.annotate 'line', 586
  # rx literal  "/"
    add $I11, rx1482_pos, 1
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    ord $I11, rx1482_tgt, $I11
    ne $I11, 47, rx1482_fail
    add rx1482_pos, 1
.annotate 'line', 581
  # rx pass
    rx1482_cur."!cursor_pass"(rx1482_pos, "quote:sym</ />")
    if_null rx1482_debug, debug_1140
    rx1482_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1482_pos)
  debug_1140:
    .return (rx1482_cur)
  rx1482_restart:
.annotate 'line', 10
    if_null rx1482_debug, debug_1141
    rx1482_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1141:
  rx1482_fail:
    (rx1482_rep, rx1482_pos, $I10, $P10) = rx1482_cur."!mark_fail"(0)
    lt rx1482_pos, -1, rx1482_done
    eq rx1482_pos, -1, rx1482_fail
    jump $I10
  rx1482_done:
    rx1482_cur."!cursor_fail"()
    if_null rx1482_debug, debug_1142
    rx1482_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1142:
    .return (rx1482_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("252_1303739803.72") :method
.annotate 'line', 10
    $P1484 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1485, "ResizablePMCArray"
    push $P1485, $P1484
    .return ($P1485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("253_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1488_tgt
    .local int rx1488_pos
    .local int rx1488_off
    .local int rx1488_eos
    .local int rx1488_rep
    .local pmc rx1488_cur
    .local pmc rx1488_debug
    (rx1488_cur, rx1488_pos, rx1488_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1488_cur
    .local pmc match
    .lex "$/", match
    length rx1488_eos, rx1488_tgt
    gt rx1488_pos, rx1488_eos, rx1488_done
    set rx1488_off, 0
    lt rx1488_pos, 2, rx1488_start
    sub rx1488_off, rx1488_pos, 1
    substr rx1488_tgt, rx1488_tgt, rx1488_off
  rx1488_start:
    eq $I10, 1, rx1488_restart
    if_null rx1488_debug, debug_1143
    rx1488_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1143:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1491_done
    goto rxscan1491_scan
  rxscan1491_loop:
    (rx1488_pos) = rx1488_cur."from"()
    inc rx1488_pos
    rx1488_cur."!cursor_from"(rx1488_pos)
    ge rx1488_pos, rx1488_eos, rxscan1491_done
  rxscan1491_scan:
    set_addr $I10, rxscan1491_loop
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  rxscan1491_done:
.annotate 'line', 589
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1488_pos, rx1488_off
    substr $S10, rx1488_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1488_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."quotemod_check"("s")
    unless $P10, rx1488_fail
  # rx subrule "variable" subtype=capture negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."variable"()
    unless $P10, rx1488_fail
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1488_pos = $P10."pos"()
  # rx pass
    rx1488_cur."!cursor_pass"(rx1488_pos, "quote_escape:sym<$>")
    if_null rx1488_debug, debug_1144
    rx1488_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1488_pos)
  debug_1144:
    .return (rx1488_cur)
  rx1488_restart:
.annotate 'line', 10
    if_null rx1488_debug, debug_1145
    rx1488_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1145:
  rx1488_fail:
    (rx1488_rep, rx1488_pos, $I10, $P10) = rx1488_cur."!mark_fail"(0)
    lt rx1488_pos, -1, rx1488_done
    eq rx1488_pos, -1, rx1488_fail
    jump $I10
  rx1488_done:
    rx1488_cur."!cursor_fail"()
    if_null rx1488_debug, debug_1146
    rx1488_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1146:
    .return (rx1488_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("254_1303739803.72") :method
.annotate 'line', 10
    new $P1490, "ResizablePMCArray"
    push $P1490, "$"
    .return ($P1490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("255_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1493_tgt
    .local int rx1493_pos
    .local int rx1493_off
    .local int rx1493_eos
    .local int rx1493_rep
    .local pmc rx1493_cur
    .local pmc rx1493_debug
    (rx1493_cur, rx1493_pos, rx1493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1493_cur
    .local pmc match
    .lex "$/", match
    length rx1493_eos, rx1493_tgt
    gt rx1493_pos, rx1493_eos, rx1493_done
    set rx1493_off, 0
    lt rx1493_pos, 2, rx1493_start
    sub rx1493_off, rx1493_pos, 1
    substr rx1493_tgt, rx1493_tgt, rx1493_off
  rx1493_start:
    eq $I10, 1, rx1493_restart
    if_null rx1493_debug, debug_1147
    rx1493_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1147:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1496_done
    goto rxscan1496_scan
  rxscan1496_loop:
    (rx1493_pos) = rx1493_cur."from"()
    inc rx1493_pos
    rx1493_cur."!cursor_from"(rx1493_pos)
    ge rx1493_pos, rx1493_eos, rxscan1496_done
  rxscan1496_scan:
    set_addr $I10, rxscan1496_loop
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  rxscan1496_done:
.annotate 'line', 590
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1493_pos, rx1493_off
    substr $S10, rx1493_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1493_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."quotemod_check"("c")
    unless $P10, rx1493_fail
  # rx subrule "block" subtype=capture negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."block"()
    unless $P10, rx1493_fail
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1493_pos = $P10."pos"()
  # rx pass
    rx1493_cur."!cursor_pass"(rx1493_pos, "quote_escape:sym<{ }>")
    if_null rx1493_debug, debug_1148
    rx1493_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1493_pos)
  debug_1148:
    .return (rx1493_cur)
  rx1493_restart:
.annotate 'line', 10
    if_null rx1493_debug, debug_1149
    rx1493_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1149:
  rx1493_fail:
    (rx1493_rep, rx1493_pos, $I10, $P10) = rx1493_cur."!mark_fail"(0)
    lt rx1493_pos, -1, rx1493_done
    eq rx1493_pos, -1, rx1493_fail
    jump $I10
  rx1493_done:
    rx1493_cur."!cursor_fail"()
    if_null rx1493_debug, debug_1150
    rx1493_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1150:
    .return (rx1493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("256_1303739803.72") :method
.annotate 'line', 10
    new $P1495, "ResizablePMCArray"
    push $P1495, "{"
    .return ($P1495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("257_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1498_tgt
    .local int rx1498_pos
    .local int rx1498_off
    .local int rx1498_eos
    .local int rx1498_rep
    .local pmc rx1498_cur
    .local pmc rx1498_debug
    (rx1498_cur, rx1498_pos, rx1498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1498_cur
    .local pmc match
    .lex "$/", match
    length rx1498_eos, rx1498_tgt
    gt rx1498_pos, rx1498_eos, rx1498_done
    set rx1498_off, 0
    lt rx1498_pos, 2, rx1498_start
    sub rx1498_off, rx1498_pos, 1
    substr rx1498_tgt, rx1498_tgt, rx1498_off
  rx1498_start:
    eq $I10, 1, rx1498_restart
    if_null rx1498_debug, debug_1151
    rx1498_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1151:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1501_done
    goto rxscan1501_scan
  rxscan1501_loop:
    (rx1498_pos) = rx1498_cur."from"()
    inc rx1498_pos
    rx1498_cur."!cursor_from"(rx1498_pos)
    ge rx1498_pos, rx1498_eos, rxscan1501_done
  rxscan1501_scan:
    set_addr $I10, rxscan1501_loop
    rx1498_cur."!mark_push"(0, rx1498_pos, $I10)
  rxscan1501_done:
.annotate 'line', 591
  # rx literal  "\\e"
    add $I11, rx1498_pos, 2
    gt $I11, rx1498_eos, rx1498_fail
    sub $I11, rx1498_pos, rx1498_off
    substr $S10, rx1498_tgt, $I11, 2
    ne $S10, "\\e", rx1498_fail
    add rx1498_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1498_cur."!cursor_pos"(rx1498_pos)
    $P10 = rx1498_cur."quotemod_check"("b")
    unless $P10, rx1498_fail
  # rx pass
    rx1498_cur."!cursor_pass"(rx1498_pos, "quote_escape:sym<esc>")
    if_null rx1498_debug, debug_1152
    rx1498_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1498_pos)
  debug_1152:
    .return (rx1498_cur)
  rx1498_restart:
.annotate 'line', 10
    if_null rx1498_debug, debug_1153
    rx1498_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1153:
  rx1498_fail:
    (rx1498_rep, rx1498_pos, $I10, $P10) = rx1498_cur."!mark_fail"(0)
    lt rx1498_pos, -1, rx1498_done
    eq rx1498_pos, -1, rx1498_fail
    jump $I10
  rx1498_done:
    rx1498_cur."!cursor_fail"()
    if_null rx1498_debug, debug_1154
    rx1498_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1154:
    .return (rx1498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("258_1303739803.72") :method
.annotate 'line', 10
    new $P1500, "ResizablePMCArray"
    push $P1500, "\\e"
    .return ($P1500)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("259_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1503_tgt
    .local int rx1503_pos
    .local int rx1503_off
    .local int rx1503_eos
    .local int rx1503_rep
    .local pmc rx1503_cur
    .local pmc rx1503_debug
    (rx1503_cur, rx1503_pos, rx1503_tgt, $I10) = self."!cursor_start"()
    rx1503_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1503_cur
    .local pmc match
    .lex "$/", match
    length rx1503_eos, rx1503_tgt
    gt rx1503_pos, rx1503_eos, rx1503_done
    set rx1503_off, 0
    lt rx1503_pos, 2, rx1503_start
    sub rx1503_off, rx1503_pos, 1
    substr rx1503_tgt, rx1503_tgt, rx1503_off
  rx1503_start:
    eq $I10, 1, rx1503_restart
    if_null rx1503_debug, debug_1155
    rx1503_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1155:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1507_done
    goto rxscan1507_scan
  rxscan1507_loop:
    (rx1503_pos) = rx1503_cur."from"()
    inc rx1503_pos
    rx1503_cur."!cursor_from"(rx1503_pos)
    ge rx1503_pos, rx1503_eos, rxscan1507_done
  rxscan1507_scan:
    set_addr $I10, rxscan1507_loop
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  rxscan1507_done:
.annotate 'line', 593
  # rx literal  "("
    add $I11, rx1503_pos, 1
    gt $I11, rx1503_eos, rx1503_fail
    sub $I11, rx1503_pos, rx1503_off
    ord $I11, rx1503_tgt, $I11
    ne $I11, 40, rx1503_fail
    add rx1503_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1503_cur."!cursor_pos"(rx1503_pos)
    $P10 = rx1503_cur."ws"()
    unless $P10, rx1503_fail
    rx1503_pos = $P10."pos"()
  # rx rxquantr1508 ** 0..1
    set_addr $I10, rxquantr1508_done
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10)
  rxquantr1508_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1503_cur."!cursor_pos"(rx1503_pos)
    $P10 = rx1503_cur."EXPR"()
    unless $P10, rx1503_fail
    goto rxsubrule1509_pass
  rxsubrule1509_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1503_fail
  rxsubrule1509_pass:
    set_addr $I10, rxsubrule1509_back
    rx1503_cur."!mark_push"(0, rx1503_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1503_pos = $P10."pos"()
    set_addr $I10, rxquantr1508_done
    (rx1503_rep) = rx1503_cur."!mark_commit"($I10)
  rxquantr1508_done:
  # rx literal  ")"
    add $I11, rx1503_pos, 1
    gt $I11, rx1503_eos, rx1503_fail
    sub $I11, rx1503_pos, rx1503_off
    ord $I11, rx1503_tgt, $I11
    ne $I11, 41, rx1503_fail
    add rx1503_pos, 1
  # rx pass
    rx1503_cur."!cursor_pass"(rx1503_pos, "circumfix:sym<( )>")
    if_null rx1503_debug, debug_1156
    rx1503_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1503_pos)
  debug_1156:
    .return (rx1503_cur)
  rx1503_restart:
.annotate 'line', 10
    if_null rx1503_debug, debug_1157
    rx1503_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1157:
  rx1503_fail:
    (rx1503_rep, rx1503_pos, $I10, $P10) = rx1503_cur."!mark_fail"(0)
    lt rx1503_pos, -1, rx1503_done
    eq rx1503_pos, -1, rx1503_fail
    jump $I10
  rx1503_done:
    rx1503_cur."!cursor_fail"()
    if_null rx1503_debug, debug_1158
    rx1503_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1158:
    .return (rx1503_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("260_1303739803.72") :method
.annotate 'line', 10
    $P1505 = self."!PREFIX__!subrule"("ws", "(")
    new $P1506, "ResizablePMCArray"
    push $P1506, $P1505
    .return ($P1506)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("261_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1511_tgt
    .local int rx1511_pos
    .local int rx1511_off
    .local int rx1511_eos
    .local int rx1511_rep
    .local pmc rx1511_cur
    .local pmc rx1511_debug
    (rx1511_cur, rx1511_pos, rx1511_tgt, $I10) = self."!cursor_start"()
    rx1511_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1511_cur
    .local pmc match
    .lex "$/", match
    length rx1511_eos, rx1511_tgt
    gt rx1511_pos, rx1511_eos, rx1511_done
    set rx1511_off, 0
    lt rx1511_pos, 2, rx1511_start
    sub rx1511_off, rx1511_pos, 1
    substr rx1511_tgt, rx1511_tgt, rx1511_off
  rx1511_start:
    eq $I10, 1, rx1511_restart
    if_null rx1511_debug, debug_1159
    rx1511_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1159:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1515_done
    goto rxscan1515_scan
  rxscan1515_loop:
    (rx1511_pos) = rx1511_cur."from"()
    inc rx1511_pos
    rx1511_cur."!cursor_from"(rx1511_pos)
    ge rx1511_pos, rx1511_eos, rxscan1515_done
  rxscan1515_scan:
    set_addr $I10, rxscan1515_loop
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxscan1515_done:
.annotate 'line', 594
  # rx literal  "["
    add $I11, rx1511_pos, 1
    gt $I11, rx1511_eos, rx1511_fail
    sub $I11, rx1511_pos, rx1511_off
    ord $I11, rx1511_tgt, $I11
    ne $I11, 91, rx1511_fail
    add rx1511_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."ws"()
    unless $P10, rx1511_fail
    rx1511_pos = $P10."pos"()
  # rx rxquantr1516 ** 0..1
    set_addr $I10, rxquantr1516_done
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxquantr1516_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."EXPR"()
    unless $P10, rx1511_fail
    goto rxsubrule1517_pass
  rxsubrule1517_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1511_fail
  rxsubrule1517_pass:
    set_addr $I10, rxsubrule1517_back
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1511_pos = $P10."pos"()
    set_addr $I10, rxquantr1516_done
    (rx1511_rep) = rx1511_cur."!mark_commit"($I10)
  rxquantr1516_done:
  # rx literal  "]"
    add $I11, rx1511_pos, 1
    gt $I11, rx1511_eos, rx1511_fail
    sub $I11, rx1511_pos, rx1511_off
    ord $I11, rx1511_tgt, $I11
    ne $I11, 93, rx1511_fail
    add rx1511_pos, 1
  # rx pass
    rx1511_cur."!cursor_pass"(rx1511_pos, "circumfix:sym<[ ]>")
    if_null rx1511_debug, debug_1160
    rx1511_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1511_pos)
  debug_1160:
    .return (rx1511_cur)
  rx1511_restart:
.annotate 'line', 10
    if_null rx1511_debug, debug_1161
    rx1511_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1161:
  rx1511_fail:
    (rx1511_rep, rx1511_pos, $I10, $P10) = rx1511_cur."!mark_fail"(0)
    lt rx1511_pos, -1, rx1511_done
    eq rx1511_pos, -1, rx1511_fail
    jump $I10
  rx1511_done:
    rx1511_cur."!cursor_fail"()
    if_null rx1511_debug, debug_1162
    rx1511_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1162:
    .return (rx1511_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("262_1303739803.72") :method
.annotate 'line', 10
    $P1513 = self."!PREFIX__!subrule"("ws", "[")
    new $P1514, "ResizablePMCArray"
    push $P1514, $P1513
    .return ($P1514)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("263_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1519_tgt
    .local int rx1519_pos
    .local int rx1519_off
    .local int rx1519_eos
    .local int rx1519_rep
    .local pmc rx1519_cur
    .local pmc rx1519_debug
    (rx1519_cur, rx1519_pos, rx1519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1519_cur
    .local pmc match
    .lex "$/", match
    length rx1519_eos, rx1519_tgt
    gt rx1519_pos, rx1519_eos, rx1519_done
    set rx1519_off, 0
    lt rx1519_pos, 2, rx1519_start
    sub rx1519_off, rx1519_pos, 1
    substr rx1519_tgt, rx1519_tgt, rx1519_off
  rx1519_start:
    eq $I10, 1, rx1519_restart
    if_null rx1519_debug, debug_1163
    rx1519_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1163:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1522_done
    goto rxscan1522_scan
  rxscan1522_loop:
    (rx1519_pos) = rx1519_cur."from"()
    inc rx1519_pos
    rx1519_cur."!cursor_from"(rx1519_pos)
    ge rx1519_pos, rx1519_eos, rxscan1522_done
  rxscan1522_scan:
    set_addr $I10, rxscan1522_loop
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  rxscan1522_done:
.annotate 'line', 595
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1519_pos, rx1519_off
    substr $S10, rx1519_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1519_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1519_fail
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1519_pos = $P10."pos"()
  # rx pass
    rx1519_cur."!cursor_pass"(rx1519_pos, "circumfix:sym<ang>")
    if_null rx1519_debug, debug_1164
    rx1519_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1519_pos)
  debug_1164:
    .return (rx1519_cur)
  rx1519_restart:
.annotate 'line', 10
    if_null rx1519_debug, debug_1165
    rx1519_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1165:
  rx1519_fail:
    (rx1519_rep, rx1519_pos, $I10, $P10) = rx1519_cur."!mark_fail"(0)
    lt rx1519_pos, -1, rx1519_done
    eq rx1519_pos, -1, rx1519_fail
    jump $I10
  rx1519_done:
    rx1519_cur."!cursor_fail"()
    if_null rx1519_debug, debug_1166
    rx1519_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1166:
    .return (rx1519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("264_1303739803.72") :method
.annotate 'line', 10
    new $P1521, "ResizablePMCArray"
    push $P1521, "<"
    .return ($P1521)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("265_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1524_tgt
    .local int rx1524_pos
    .local int rx1524_off
    .local int rx1524_eos
    .local int rx1524_rep
    .local pmc rx1524_cur
    .local pmc rx1524_debug
    (rx1524_cur, rx1524_pos, rx1524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1524_cur
    .local pmc match
    .lex "$/", match
    length rx1524_eos, rx1524_tgt
    gt rx1524_pos, rx1524_eos, rx1524_done
    set rx1524_off, 0
    lt rx1524_pos, 2, rx1524_start
    sub rx1524_off, rx1524_pos, 1
    substr rx1524_tgt, rx1524_tgt, rx1524_off
  rx1524_start:
    eq $I10, 1, rx1524_restart
    if_null rx1524_debug, debug_1167
    rx1524_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1167:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1527_done
    goto rxscan1527_scan
  rxscan1527_loop:
    (rx1524_pos) = rx1524_cur."from"()
    inc rx1524_pos
    rx1524_cur."!cursor_from"(rx1524_pos)
    ge rx1524_pos, rx1524_eos, rxscan1527_done
  rxscan1527_scan:
    set_addr $I10, rxscan1527_loop
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  rxscan1527_done:
.annotate 'line', 596
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1524_pos, rx1524_off
    substr $S10, rx1524_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1524_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1524_fail
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1524_pos = $P10."pos"()
  # rx pass
    rx1524_cur."!cursor_pass"(rx1524_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1524_debug, debug_1168
    rx1524_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1524_pos)
  debug_1168:
    .return (rx1524_cur)
  rx1524_restart:
.annotate 'line', 10
    if_null rx1524_debug, debug_1169
    rx1524_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1169:
  rx1524_fail:
    (rx1524_rep, rx1524_pos, $I10, $P10) = rx1524_cur."!mark_fail"(0)
    lt rx1524_pos, -1, rx1524_done
    eq rx1524_pos, -1, rx1524_fail
    jump $I10
  rx1524_done:
    rx1524_cur."!cursor_fail"()
    if_null rx1524_debug, debug_1170
    rx1524_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1170:
    .return (rx1524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("266_1303739803.72") :method
.annotate 'line', 10
    new $P1526, "ResizablePMCArray"
    push $P1526, unicode:"\x{ab}"
    .return ($P1526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("267_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1529_tgt
    .local int rx1529_pos
    .local int rx1529_off
    .local int rx1529_eos
    .local int rx1529_rep
    .local pmc rx1529_cur
    .local pmc rx1529_debug
    (rx1529_cur, rx1529_pos, rx1529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1529_cur
    .local pmc match
    .lex "$/", match
    length rx1529_eos, rx1529_tgt
    gt rx1529_pos, rx1529_eos, rx1529_done
    set rx1529_off, 0
    lt rx1529_pos, 2, rx1529_start
    sub rx1529_off, rx1529_pos, 1
    substr rx1529_tgt, rx1529_tgt, rx1529_off
  rx1529_start:
    eq $I10, 1, rx1529_restart
    if_null rx1529_debug, debug_1171
    rx1529_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1171:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1532_done
    goto rxscan1532_scan
  rxscan1532_loop:
    (rx1529_pos) = rx1529_cur."from"()
    inc rx1529_pos
    rx1529_cur."!cursor_from"(rx1529_pos)
    ge rx1529_pos, rx1529_eos, rxscan1532_done
  rxscan1532_scan:
    set_addr $I10, rxscan1532_loop
    rx1529_cur."!mark_push"(0, rx1529_pos, $I10)
  rxscan1532_done:
.annotate 'line', 597
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1529_pos, rx1529_off
    substr $S10, rx1529_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1529_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1529_cur."!cursor_pos"(rx1529_pos)
    $P10 = rx1529_cur."pblock"()
    unless $P10, rx1529_fail
    rx1529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1529_pos = $P10."pos"()
  # rx pass
    rx1529_cur."!cursor_pass"(rx1529_pos, "circumfix:sym<{ }>")
    if_null rx1529_debug, debug_1172
    rx1529_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1529_pos)
  debug_1172:
    .return (rx1529_cur)
  rx1529_restart:
.annotate 'line', 10
    if_null rx1529_debug, debug_1173
    rx1529_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1173:
  rx1529_fail:
    (rx1529_rep, rx1529_pos, $I10, $P10) = rx1529_cur."!mark_fail"(0)
    lt rx1529_pos, -1, rx1529_done
    eq rx1529_pos, -1, rx1529_fail
    jump $I10
  rx1529_done:
    rx1529_cur."!cursor_fail"()
    if_null rx1529_debug, debug_1174
    rx1529_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1174:
    .return (rx1529_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("268_1303739803.72") :method
.annotate 'line', 10
    new $P1531, "ResizablePMCArray"
    push $P1531, "{"
    .return ($P1531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("269_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1534_tgt
    .local int rx1534_pos
    .local int rx1534_off
    .local int rx1534_eos
    .local int rx1534_rep
    .local pmc rx1534_cur
    .local pmc rx1534_debug
    (rx1534_cur, rx1534_pos, rx1534_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1534_cur
    .local pmc match
    .lex "$/", match
    length rx1534_eos, rx1534_tgt
    gt rx1534_pos, rx1534_eos, rx1534_done
    set rx1534_off, 0
    lt rx1534_pos, 2, rx1534_start
    sub rx1534_off, rx1534_pos, 1
    substr rx1534_tgt, rx1534_tgt, rx1534_off
  rx1534_start:
    eq $I10, 1, rx1534_restart
    if_null rx1534_debug, debug_1175
    rx1534_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1175:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1534_pos) = rx1534_cur."from"()
    inc rx1534_pos
    rx1534_cur."!cursor_from"(rx1534_pos)
    ge rx1534_pos, rx1534_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  rxscan1538_done:
.annotate 'line', 598
  # rx subrule "sigil" subtype=capture negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."sigil"()
    unless $P10, rx1534_fail
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1534_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1534_pos, 1
    gt $I11, rx1534_eos, rx1534_fail
    sub $I11, rx1534_pos, rx1534_off
    ord $I11, rx1534_tgt, $I11
    ne $I11, 40, rx1534_fail
    add rx1534_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."semilist"()
    unless $P10, rx1534_fail
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1534_pos = $P10."pos"()
  alt1539_0:
    set_addr $I10, alt1539_1
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  # rx literal  ")"
    add $I11, rx1534_pos, 1
    gt $I11, rx1534_eos, rx1534_fail
    sub $I11, rx1534_pos, rx1534_off
    ord $I11, rx1534_tgt, $I11
    ne $I11, 41, rx1534_fail
    add rx1534_pos, 1
    goto alt1539_end
  alt1539_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."FAILGOAL"("')'")
    unless $P10, rx1534_fail
    goto rxsubrule1541_pass
  rxsubrule1541_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1534_fail
  rxsubrule1541_pass:
    set_addr $I10, rxsubrule1541_back
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10, $P10)
    rx1534_pos = $P10."pos"()
  alt1539_end:
  # rx pass
    rx1534_cur."!cursor_pass"(rx1534_pos, "circumfix:sym<sigil>")
    if_null rx1534_debug, debug_1176
    rx1534_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1534_pos)
  debug_1176:
    .return (rx1534_cur)
  rx1534_restart:
.annotate 'line', 10
    if_null rx1534_debug, debug_1177
    rx1534_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1177:
  rx1534_fail:
    (rx1534_rep, rx1534_pos, $I10, $P10) = rx1534_cur."!mark_fail"(0)
    lt rx1534_pos, -1, rx1534_done
    eq rx1534_pos, -1, rx1534_fail
    jump $I10
  rx1534_done:
    rx1534_cur."!cursor_fail"()
    if_null rx1534_debug, debug_1178
    rx1534_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1178:
    .return (rx1534_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("270_1303739803.72") :method
.annotate 'line', 10
    $P1536 = self."!PREFIX__!subrule"("sigil", "")
    new $P1537, "ResizablePMCArray"
    push $P1537, $P1536
    .return ($P1537)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("271_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1179
    rx1543_cur."!cursor_debug"("START", "semilist")
  debug_1179:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1547_done
    goto rxscan1547_scan
  rxscan1547_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1547_done
  rxscan1547_scan:
    set_addr $I10, rxscan1547_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1547_done:
.annotate 'line', 600
  # rx subrule "ws" subtype=method negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."ws"()
    unless $P10, rx1543_fail
    rx1543_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."statement"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1543_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."ws"()
    unless $P10, rx1543_fail
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "semilist")
    if_null rx1543_debug, debug_1180
    rx1543_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1543_pos)
  debug_1180:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 10
    if_null rx1543_debug, debug_1181
    rx1543_cur."!cursor_debug"("NEXT", "semilist")
  debug_1181:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1182
    rx1543_cur."!cursor_debug"("FAIL", "semilist")
  debug_1182:
    .return (rx1543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("272_1303739803.72") :method
.annotate 'line', 10
    $P1545 = self."!PREFIX__!subrule"("ws", "")
    new $P1546, "ResizablePMCArray"
    push $P1546, $P1545
    .return ($P1546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("273_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1551_tgt
    .local int rx1551_pos
    .local int rx1551_off
    .local int rx1551_eos
    .local int rx1551_rep
    .local pmc rx1551_cur
    .local pmc rx1551_debug
    (rx1551_cur, rx1551_pos, rx1551_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1551_cur
    .local pmc match
    .lex "$/", match
    length rx1551_eos, rx1551_tgt
    gt rx1551_pos, rx1551_eos, rx1551_done
    set rx1551_off, 0
    lt rx1551_pos, 2, rx1551_start
    sub rx1551_off, rx1551_pos, 1
    substr rx1551_tgt, rx1551_tgt, rx1551_off
  rx1551_start:
    eq $I10, 1, rx1551_restart
    if_null rx1551_debug, debug_1183
    rx1551_cur."!cursor_debug"("START", "infixish")
  debug_1183:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1554_done
    goto rxscan1554_scan
  rxscan1554_loop:
    (rx1551_pos) = rx1551_cur."from"()
    inc rx1551_pos
    rx1551_cur."!cursor_from"(rx1551_pos)
    ge rx1551_pos, rx1551_eos, rxscan1554_done
  rxscan1554_scan:
    set_addr $I10, rxscan1554_loop
    rx1551_cur."!mark_push"(0, rx1551_pos, $I10)
  rxscan1554_done:
.annotate 'line', 623
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1551_cur."!cursor_pos"(rx1551_pos)
    $P10 = rx1551_cur."infixstopper"()
    if $P10, rx1551_fail
  # rx subrule "infix" subtype=capture negate=
    rx1551_cur."!cursor_pos"(rx1551_pos)
    $P10 = rx1551_cur."infix"()
    unless $P10, rx1551_fail
    rx1551_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1551_pos = $P10."pos"()
  # rx pass
    rx1551_cur."!cursor_pass"(rx1551_pos, "infixish")
    if_null rx1551_debug, debug_1184
    rx1551_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1551_pos)
  debug_1184:
    .return (rx1551_cur)
  rx1551_restart:
.annotate 'line', 10
    if_null rx1551_debug, debug_1185
    rx1551_cur."!cursor_debug"("NEXT", "infixish")
  debug_1185:
  rx1551_fail:
    (rx1551_rep, rx1551_pos, $I10, $P10) = rx1551_cur."!mark_fail"(0)
    lt rx1551_pos, -1, rx1551_done
    eq rx1551_pos, -1, rx1551_fail
    jump $I10
  rx1551_done:
    rx1551_cur."!cursor_fail"()
    if_null rx1551_debug, debug_1186
    rx1551_cur."!cursor_debug"("FAIL", "infixish")
  debug_1186:
    .return (rx1551_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("274_1303739803.72") :method
.annotate 'line', 10
    new $P1553, "ResizablePMCArray"
    push $P1553, ""
    .return ($P1553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("275_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1556_tgt
    .local int rx1556_pos
    .local int rx1556_off
    .local int rx1556_eos
    .local int rx1556_rep
    .local pmc rx1556_cur
    .local pmc rx1556_debug
    (rx1556_cur, rx1556_pos, rx1556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1556_cur
    .local pmc match
    .lex "$/", match
    length rx1556_eos, rx1556_tgt
    gt rx1556_pos, rx1556_eos, rx1556_done
    set rx1556_off, 0
    lt rx1556_pos, 2, rx1556_start
    sub rx1556_off, rx1556_pos, 1
    substr rx1556_tgt, rx1556_tgt, rx1556_off
  rx1556_start:
    eq $I10, 1, rx1556_restart
    if_null rx1556_debug, debug_1187
    rx1556_cur."!cursor_debug"("START", "infixstopper")
  debug_1187:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1559_done
    goto rxscan1559_scan
  rxscan1559_loop:
    (rx1556_pos) = rx1556_cur."from"()
    inc rx1556_pos
    rx1556_cur."!cursor_from"(rx1556_pos)
    ge rx1556_pos, rx1556_eos, rxscan1559_done
  rxscan1559_scan:
    set_addr $I10, rxscan1559_loop
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  rxscan1559_done:
.annotate 'line', 624
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1556_cur."!cursor_pos"(rx1556_pos)
    $P10 = rx1556_cur."lambda"()
    unless $P10, rx1556_fail
  # rx pass
    rx1556_cur."!cursor_pass"(rx1556_pos, "infixstopper")
    if_null rx1556_debug, debug_1188
    rx1556_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1556_pos)
  debug_1188:
    .return (rx1556_cur)
  rx1556_restart:
.annotate 'line', 10
    if_null rx1556_debug, debug_1189
    rx1556_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1189:
  rx1556_fail:
    (rx1556_rep, rx1556_pos, $I10, $P10) = rx1556_cur."!mark_fail"(0)
    lt rx1556_pos, -1, rx1556_done
    eq rx1556_pos, -1, rx1556_fail
    jump $I10
  rx1556_done:
    rx1556_cur."!cursor_fail"()
    if_null rx1556_debug, debug_1190
    rx1556_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1190:
    .return (rx1556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("276_1303739803.72") :method
.annotate 'line', 10
    new $P1558, "ResizablePMCArray"
    push $P1558, ""
    .return ($P1558)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("277_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1561_tgt
    .local int rx1561_pos
    .local int rx1561_off
    .local int rx1561_eos
    .local int rx1561_rep
    .local pmc rx1561_cur
    .local pmc rx1561_debug
    (rx1561_cur, rx1561_pos, rx1561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1561_cur
    .local pmc match
    .lex "$/", match
    length rx1561_eos, rx1561_tgt
    gt rx1561_pos, rx1561_eos, rx1561_done
    set rx1561_off, 0
    lt rx1561_pos, 2, rx1561_start
    sub rx1561_off, rx1561_pos, 1
    substr rx1561_tgt, rx1561_tgt, rx1561_off
  rx1561_start:
    eq $I10, 1, rx1561_restart
    if_null rx1561_debug, debug_1191
    rx1561_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1191:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1565_done
    goto rxscan1565_scan
  rxscan1565_loop:
    (rx1561_pos) = rx1561_cur."from"()
    inc rx1561_pos
    rx1561_cur."!cursor_from"(rx1561_pos)
    ge rx1561_pos, rx1561_eos, rxscan1565_done
  rxscan1565_scan:
    set_addr $I10, rxscan1565_loop
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxscan1565_done:
.annotate 'line', 627
  # rx literal  "["
    add $I11, rx1561_pos, 1
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    ord $I11, rx1561_tgt, $I11
    ne $I11, 91, rx1561_fail
    add rx1561_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."ws"()
    unless $P10, rx1561_fail
    rx1561_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."EXPR"()
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1561_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1561_pos, 1
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    ord $I11, rx1561_tgt, $I11
    ne $I11, 93, rx1561_fail
    add rx1561_pos, 1
.annotate 'line', 628
  # rx subrule "O" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."O"("%methodop")
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1561_pos = $P10."pos"()
.annotate 'line', 626
  # rx pass
    rx1561_cur."!cursor_pass"(rx1561_pos, "postcircumfix:sym<[ ]>")
    if_null rx1561_debug, debug_1192
    rx1561_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1561_pos)
  debug_1192:
    .return (rx1561_cur)
  rx1561_restart:
.annotate 'line', 10
    if_null rx1561_debug, debug_1193
    rx1561_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1193:
  rx1561_fail:
    (rx1561_rep, rx1561_pos, $I10, $P10) = rx1561_cur."!mark_fail"(0)
    lt rx1561_pos, -1, rx1561_done
    eq rx1561_pos, -1, rx1561_fail
    jump $I10
  rx1561_done:
    rx1561_cur."!cursor_fail"()
    if_null rx1561_debug, debug_1194
    rx1561_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1194:
    .return (rx1561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("278_1303739803.72") :method
.annotate 'line', 10
    $P1563 = self."!PREFIX__!subrule"("ws", "[")
    new $P1564, "ResizablePMCArray"
    push $P1564, $P1563
    .return ($P1564)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("279_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1567_tgt
    .local int rx1567_pos
    .local int rx1567_off
    .local int rx1567_eos
    .local int rx1567_rep
    .local pmc rx1567_cur
    .local pmc rx1567_debug
    (rx1567_cur, rx1567_pos, rx1567_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1567_cur
    .local pmc match
    .lex "$/", match
    length rx1567_eos, rx1567_tgt
    gt rx1567_pos, rx1567_eos, rx1567_done
    set rx1567_off, 0
    lt rx1567_pos, 2, rx1567_start
    sub rx1567_off, rx1567_pos, 1
    substr rx1567_tgt, rx1567_tgt, rx1567_off
  rx1567_start:
    eq $I10, 1, rx1567_restart
    if_null rx1567_debug, debug_1195
    rx1567_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1195:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1571_done
    goto rxscan1571_scan
  rxscan1571_loop:
    (rx1567_pos) = rx1567_cur."from"()
    inc rx1567_pos
    rx1567_cur."!cursor_from"(rx1567_pos)
    ge rx1567_pos, rx1567_eos, rxscan1571_done
  rxscan1571_scan:
    set_addr $I10, rxscan1571_loop
    rx1567_cur."!mark_push"(0, rx1567_pos, $I10)
  rxscan1571_done:
.annotate 'line', 632
  # rx literal  "{"
    add $I11, rx1567_pos, 1
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    ord $I11, rx1567_tgt, $I11
    ne $I11, 123, rx1567_fail
    add rx1567_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."ws"()
    unless $P10, rx1567_fail
    rx1567_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."EXPR"()
    unless $P10, rx1567_fail
    rx1567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1567_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1567_pos, 1
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    ord $I11, rx1567_tgt, $I11
    ne $I11, 125, rx1567_fail
    add rx1567_pos, 1
.annotate 'line', 633
  # rx subrule "O" subtype=capture negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."O"("%methodop")
    unless $P10, rx1567_fail
    rx1567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1567_pos = $P10."pos"()
.annotate 'line', 631
  # rx pass
    rx1567_cur."!cursor_pass"(rx1567_pos, "postcircumfix:sym<{ }>")
    if_null rx1567_debug, debug_1196
    rx1567_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1567_pos)
  debug_1196:
    .return (rx1567_cur)
  rx1567_restart:
.annotate 'line', 10
    if_null rx1567_debug, debug_1197
    rx1567_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1197:
  rx1567_fail:
    (rx1567_rep, rx1567_pos, $I10, $P10) = rx1567_cur."!mark_fail"(0)
    lt rx1567_pos, -1, rx1567_done
    eq rx1567_pos, -1, rx1567_fail
    jump $I10
  rx1567_done:
    rx1567_cur."!cursor_fail"()
    if_null rx1567_debug, debug_1198
    rx1567_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1198:
    .return (rx1567_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("280_1303739803.72") :method
.annotate 'line', 10
    $P1569 = self."!PREFIX__!subrule"("ws", "{")
    new $P1570, "ResizablePMCArray"
    push $P1570, $P1569
    .return ($P1570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("281_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1573_tgt
    .local int rx1573_pos
    .local int rx1573_off
    .local int rx1573_eos
    .local int rx1573_rep
    .local pmc rx1573_cur
    .local pmc rx1573_debug
    (rx1573_cur, rx1573_pos, rx1573_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1573_cur
    .local pmc match
    .lex "$/", match
    length rx1573_eos, rx1573_tgt
    gt rx1573_pos, rx1573_eos, rx1573_done
    set rx1573_off, 0
    lt rx1573_pos, 2, rx1573_start
    sub rx1573_off, rx1573_pos, 1
    substr rx1573_tgt, rx1573_tgt, rx1573_off
  rx1573_start:
    eq $I10, 1, rx1573_restart
    if_null rx1573_debug, debug_1199
    rx1573_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1199:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1576_done
    goto rxscan1576_scan
  rxscan1576_loop:
    (rx1573_pos) = rx1573_cur."from"()
    inc rx1573_pos
    rx1573_cur."!cursor_from"(rx1573_pos)
    ge rx1573_pos, rx1573_eos, rxscan1576_done
  rxscan1576_scan:
    set_addr $I10, rxscan1576_loop
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  rxscan1576_done:
.annotate 'line', 637
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1573_pos, rx1573_off
    substr $S10, rx1573_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1573_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."quote_EXPR"(":q")
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1573_pos = $P10."pos"()
.annotate 'line', 638
  # rx subrule "O" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."O"("%methodop")
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1573_pos = $P10."pos"()
.annotate 'line', 636
  # rx pass
    rx1573_cur."!cursor_pass"(rx1573_pos, "postcircumfix:sym<ang>")
    if_null rx1573_debug, debug_1200
    rx1573_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1573_pos)
  debug_1200:
    .return (rx1573_cur)
  rx1573_restart:
.annotate 'line', 10
    if_null rx1573_debug, debug_1201
    rx1573_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1201:
  rx1573_fail:
    (rx1573_rep, rx1573_pos, $I10, $P10) = rx1573_cur."!mark_fail"(0)
    lt rx1573_pos, -1, rx1573_done
    eq rx1573_pos, -1, rx1573_fail
    jump $I10
  rx1573_done:
    rx1573_cur."!cursor_fail"()
    if_null rx1573_debug, debug_1202
    rx1573_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1202:
    .return (rx1573_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("282_1303739803.72") :method
.annotate 'line', 10
    new $P1575, "ResizablePMCArray"
    push $P1575, "<"
    .return ($P1575)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("283_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1578_tgt
    .local int rx1578_pos
    .local int rx1578_off
    .local int rx1578_eos
    .local int rx1578_rep
    .local pmc rx1578_cur
    .local pmc rx1578_debug
    (rx1578_cur, rx1578_pos, rx1578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1578_cur
    .local pmc match
    .lex "$/", match
    length rx1578_eos, rx1578_tgt
    gt rx1578_pos, rx1578_eos, rx1578_done
    set rx1578_off, 0
    lt rx1578_pos, 2, rx1578_start
    sub rx1578_off, rx1578_pos, 1
    substr rx1578_tgt, rx1578_tgt, rx1578_off
  rx1578_start:
    eq $I10, 1, rx1578_restart
    if_null rx1578_debug, debug_1203
    rx1578_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1203:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1582_done
    goto rxscan1582_scan
  rxscan1582_loop:
    (rx1578_pos) = rx1578_cur."from"()
    inc rx1578_pos
    rx1578_cur."!cursor_from"(rx1578_pos)
    ge rx1578_pos, rx1578_eos, rxscan1582_done
  rxscan1582_scan:
    set_addr $I10, rxscan1582_loop
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  rxscan1582_done:
.annotate 'line', 642
  # rx literal  "("
    add $I11, rx1578_pos, 1
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    ord $I11, rx1578_tgt, $I11
    ne $I11, 40, rx1578_fail
    add rx1578_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."ws"()
    unless $P10, rx1578_fail
    rx1578_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."arglist"()
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1578_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1578_pos, 1
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    ord $I11, rx1578_tgt, $I11
    ne $I11, 41, rx1578_fail
    add rx1578_pos, 1
.annotate 'line', 643
  # rx subrule "O" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."O"("%methodop")
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1578_pos = $P10."pos"()
.annotate 'line', 641
  # rx pass
    rx1578_cur."!cursor_pass"(rx1578_pos, "postcircumfix:sym<( )>")
    if_null rx1578_debug, debug_1204
    rx1578_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1578_pos)
  debug_1204:
    .return (rx1578_cur)
  rx1578_restart:
.annotate 'line', 10
    if_null rx1578_debug, debug_1205
    rx1578_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1205:
  rx1578_fail:
    (rx1578_rep, rx1578_pos, $I10, $P10) = rx1578_cur."!mark_fail"(0)
    lt rx1578_pos, -1, rx1578_done
    eq rx1578_pos, -1, rx1578_fail
    jump $I10
  rx1578_done:
    rx1578_cur."!cursor_fail"()
    if_null rx1578_debug, debug_1206
    rx1578_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1206:
    .return (rx1578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("284_1303739803.72") :method
.annotate 'line', 10
    $P1580 = self."!PREFIX__!subrule"("ws", "(")
    new $P1581, "ResizablePMCArray"
    push $P1581, $P1580
    .return ($P1581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("285_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1207
    rx1584_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1207:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1588_done:
.annotate 'line', 646
  # rx subrule "dotty" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."dotty"()
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1584_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."O"("%methodop")
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1584_pos = $P10."pos"()
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "postfix:sym<.>")
    if_null rx1584_debug, debug_1208
    rx1584_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1584_pos)
  debug_1208:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 10
    if_null rx1584_debug, debug_1209
    rx1584_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1209:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1210
    rx1584_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1210:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("286_1303739803.72") :method
.annotate 'line', 10
    $P1586 = self."!PREFIX__!subrule"("dotty", "")
    new $P1587, "ResizablePMCArray"
    push $P1587, $P1586
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("287_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1590_tgt
    .local int rx1590_pos
    .local int rx1590_off
    .local int rx1590_eos
    .local int rx1590_rep
    .local pmc rx1590_cur
    .local pmc rx1590_debug
    (rx1590_cur, rx1590_pos, rx1590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1590_cur
    .local pmc match
    .lex "$/", match
    length rx1590_eos, rx1590_tgt
    gt rx1590_pos, rx1590_eos, rx1590_done
    set rx1590_off, 0
    lt rx1590_pos, 2, rx1590_start
    sub rx1590_off, rx1590_pos, 1
    substr rx1590_tgt, rx1590_tgt, rx1590_off
  rx1590_start:
    eq $I10, 1, rx1590_restart
    if_null rx1590_debug, debug_1211
    rx1590_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1211:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1594_done
    goto rxscan1594_scan
  rxscan1594_loop:
    (rx1590_pos) = rx1590_cur."from"()
    inc rx1590_pos
    rx1590_cur."!cursor_from"(rx1590_pos)
    ge rx1590_pos, rx1590_eos, rxscan1594_done
  rxscan1594_scan:
    set_addr $I10, rxscan1594_loop
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  rxscan1594_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1595_fail
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  # rx literal  "++"
    add $I11, rx1590_pos, 2
    gt $I11, rx1590_eos, rx1590_fail
    sub $I11, rx1590_pos, rx1590_off
    substr $S10, rx1590_tgt, $I11, 2
    ne $S10, "++", rx1590_fail
    add rx1590_pos, 2
    set_addr $I10, rxcap_1595_fail
    ($I12, $I11) = rx1590_cur."!mark_peek"($I10)
    rx1590_cur."!cursor_pos"($I11)
    ($P10) = rx1590_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1590_pos, "")
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1595_done
  rxcap_1595_fail:
    goto rx1590_fail
  rxcap_1595_done:
  # rx subrule "O" subtype=capture negate=
    rx1590_cur."!cursor_pos"(rx1590_pos)
    $P10 = rx1590_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1590_fail
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1590_pos = $P10."pos"()
  # rx pass
    rx1590_cur."!cursor_pass"(rx1590_pos, "prefix:sym<++>")
    if_null rx1590_debug, debug_1212
    rx1590_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1590_pos)
  debug_1212:
    .return (rx1590_cur)
  rx1590_restart:
.annotate 'line', 10
    if_null rx1590_debug, debug_1213
    rx1590_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1213:
  rx1590_fail:
    (rx1590_rep, rx1590_pos, $I10, $P10) = rx1590_cur."!mark_fail"(0)
    lt rx1590_pos, -1, rx1590_done
    eq rx1590_pos, -1, rx1590_fail
    jump $I10
  rx1590_done:
    rx1590_cur."!cursor_fail"()
    if_null rx1590_debug, debug_1214
    rx1590_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1214:
    .return (rx1590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("288_1303739803.72") :method
.annotate 'line', 10
    $P1592 = self."!PREFIX__!subrule"("O", "++")
    new $P1593, "ResizablePMCArray"
    push $P1593, $P1592
    .return ($P1593)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("289_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1597_tgt
    .local int rx1597_pos
    .local int rx1597_off
    .local int rx1597_eos
    .local int rx1597_rep
    .local pmc rx1597_cur
    .local pmc rx1597_debug
    (rx1597_cur, rx1597_pos, rx1597_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1597_cur
    .local pmc match
    .lex "$/", match
    length rx1597_eos, rx1597_tgt
    gt rx1597_pos, rx1597_eos, rx1597_done
    set rx1597_off, 0
    lt rx1597_pos, 2, rx1597_start
    sub rx1597_off, rx1597_pos, 1
    substr rx1597_tgt, rx1597_tgt, rx1597_off
  rx1597_start:
    eq $I10, 1, rx1597_restart
    if_null rx1597_debug, debug_1215
    rx1597_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1215:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1601_done
    goto rxscan1601_scan
  rxscan1601_loop:
    (rx1597_pos) = rx1597_cur."from"()
    inc rx1597_pos
    rx1597_cur."!cursor_from"(rx1597_pos)
    ge rx1597_pos, rx1597_eos, rxscan1601_done
  rxscan1601_scan:
    set_addr $I10, rxscan1601_loop
    rx1597_cur."!mark_push"(0, rx1597_pos, $I10)
  rxscan1601_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1602_fail
    rx1597_cur."!mark_push"(0, rx1597_pos, $I10)
  # rx literal  "--"
    add $I11, rx1597_pos, 2
    gt $I11, rx1597_eos, rx1597_fail
    sub $I11, rx1597_pos, rx1597_off
    substr $S10, rx1597_tgt, $I11, 2
    ne $S10, "--", rx1597_fail
    add rx1597_pos, 2
    set_addr $I10, rxcap_1602_fail
    ($I12, $I11) = rx1597_cur."!mark_peek"($I10)
    rx1597_cur."!cursor_pos"($I11)
    ($P10) = rx1597_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1597_pos, "")
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1602_done
  rxcap_1602_fail:
    goto rx1597_fail
  rxcap_1602_done:
  # rx subrule "O" subtype=capture negate=
    rx1597_cur."!cursor_pos"(rx1597_pos)
    $P10 = rx1597_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1597_fail
    rx1597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1597_pos = $P10."pos"()
  # rx pass
    rx1597_cur."!cursor_pass"(rx1597_pos, "prefix:sym<-->")
    if_null rx1597_debug, debug_1216
    rx1597_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1597_pos)
  debug_1216:
    .return (rx1597_cur)
  rx1597_restart:
.annotate 'line', 10
    if_null rx1597_debug, debug_1217
    rx1597_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1217:
  rx1597_fail:
    (rx1597_rep, rx1597_pos, $I10, $P10) = rx1597_cur."!mark_fail"(0)
    lt rx1597_pos, -1, rx1597_done
    eq rx1597_pos, -1, rx1597_fail
    jump $I10
  rx1597_done:
    rx1597_cur."!cursor_fail"()
    if_null rx1597_debug, debug_1218
    rx1597_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1218:
    .return (rx1597_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("290_1303739803.72") :method
.annotate 'line', 10
    $P1599 = self."!PREFIX__!subrule"("O", "--")
    new $P1600, "ResizablePMCArray"
    push $P1600, $P1599
    .return ($P1600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("291_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1604_tgt
    .local int rx1604_pos
    .local int rx1604_off
    .local int rx1604_eos
    .local int rx1604_rep
    .local pmc rx1604_cur
    .local pmc rx1604_debug
    (rx1604_cur, rx1604_pos, rx1604_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1604_cur
    .local pmc match
    .lex "$/", match
    length rx1604_eos, rx1604_tgt
    gt rx1604_pos, rx1604_eos, rx1604_done
    set rx1604_off, 0
    lt rx1604_pos, 2, rx1604_start
    sub rx1604_off, rx1604_pos, 1
    substr rx1604_tgt, rx1604_tgt, rx1604_off
  rx1604_start:
    eq $I10, 1, rx1604_restart
    if_null rx1604_debug, debug_1219
    rx1604_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1219:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1608_done
    goto rxscan1608_scan
  rxscan1608_loop:
    (rx1604_pos) = rx1604_cur."from"()
    inc rx1604_pos
    rx1604_cur."!cursor_from"(rx1604_pos)
    ge rx1604_pos, rx1604_eos, rxscan1608_done
  rxscan1608_scan:
    set_addr $I10, rxscan1608_loop
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxscan1608_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1609_fail
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  # rx literal  "++"
    add $I11, rx1604_pos, 2
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    substr $S10, rx1604_tgt, $I11, 2
    ne $S10, "++", rx1604_fail
    add rx1604_pos, 2
    set_addr $I10, rxcap_1609_fail
    ($I12, $I11) = rx1604_cur."!mark_peek"($I10)
    rx1604_cur."!cursor_pos"($I11)
    ($P10) = rx1604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1604_pos, "")
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1609_done
  rxcap_1609_fail:
    goto rx1604_fail
  rxcap_1609_done:
  # rx subrule "O" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."O"("%autoincrement")
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1604_pos = $P10."pos"()
  # rx pass
    rx1604_cur."!cursor_pass"(rx1604_pos, "postfix:sym<++>")
    if_null rx1604_debug, debug_1220
    rx1604_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1604_pos)
  debug_1220:
    .return (rx1604_cur)
  rx1604_restart:
.annotate 'line', 10
    if_null rx1604_debug, debug_1221
    rx1604_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1221:
  rx1604_fail:
    (rx1604_rep, rx1604_pos, $I10, $P10) = rx1604_cur."!mark_fail"(0)
    lt rx1604_pos, -1, rx1604_done
    eq rx1604_pos, -1, rx1604_fail
    jump $I10
  rx1604_done:
    rx1604_cur."!cursor_fail"()
    if_null rx1604_debug, debug_1222
    rx1604_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1222:
    .return (rx1604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("292_1303739803.72") :method
.annotate 'line', 10
    $P1606 = self."!PREFIX__!subrule"("O", "++")
    new $P1607, "ResizablePMCArray"
    push $P1607, $P1606
    .return ($P1607)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("293_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1611_tgt
    .local int rx1611_pos
    .local int rx1611_off
    .local int rx1611_eos
    .local int rx1611_rep
    .local pmc rx1611_cur
    .local pmc rx1611_debug
    (rx1611_cur, rx1611_pos, rx1611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1611_cur
    .local pmc match
    .lex "$/", match
    length rx1611_eos, rx1611_tgt
    gt rx1611_pos, rx1611_eos, rx1611_done
    set rx1611_off, 0
    lt rx1611_pos, 2, rx1611_start
    sub rx1611_off, rx1611_pos, 1
    substr rx1611_tgt, rx1611_tgt, rx1611_off
  rx1611_start:
    eq $I10, 1, rx1611_restart
    if_null rx1611_debug, debug_1223
    rx1611_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1223:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1615_done
    goto rxscan1615_scan
  rxscan1615_loop:
    (rx1611_pos) = rx1611_cur."from"()
    inc rx1611_pos
    rx1611_cur."!cursor_from"(rx1611_pos)
    ge rx1611_pos, rx1611_eos, rxscan1615_done
  rxscan1615_scan:
    set_addr $I10, rxscan1615_loop
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  rxscan1615_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1616_fail
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  # rx literal  "--"
    add $I11, rx1611_pos, 2
    gt $I11, rx1611_eos, rx1611_fail
    sub $I11, rx1611_pos, rx1611_off
    substr $S10, rx1611_tgt, $I11, 2
    ne $S10, "--", rx1611_fail
    add rx1611_pos, 2
    set_addr $I10, rxcap_1616_fail
    ($I12, $I11) = rx1611_cur."!mark_peek"($I10)
    rx1611_cur."!cursor_pos"($I11)
    ($P10) = rx1611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1611_pos, "")
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1616_done
  rxcap_1616_fail:
    goto rx1611_fail
  rxcap_1616_done:
  # rx subrule "O" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."O"("%autoincrement")
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1611_pos = $P10."pos"()
  # rx pass
    rx1611_cur."!cursor_pass"(rx1611_pos, "postfix:sym<-->")
    if_null rx1611_debug, debug_1224
    rx1611_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1611_pos)
  debug_1224:
    .return (rx1611_cur)
  rx1611_restart:
.annotate 'line', 10
    if_null rx1611_debug, debug_1225
    rx1611_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1225:
  rx1611_fail:
    (rx1611_rep, rx1611_pos, $I10, $P10) = rx1611_cur."!mark_fail"(0)
    lt rx1611_pos, -1, rx1611_done
    eq rx1611_pos, -1, rx1611_fail
    jump $I10
  rx1611_done:
    rx1611_cur."!cursor_fail"()
    if_null rx1611_debug, debug_1226
    rx1611_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1226:
    .return (rx1611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("294_1303739803.72") :method
.annotate 'line', 10
    $P1613 = self."!PREFIX__!subrule"("O", "--")
    new $P1614, "ResizablePMCArray"
    push $P1614, $P1613
    .return ($P1614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("295_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1618_tgt
    .local int rx1618_pos
    .local int rx1618_off
    .local int rx1618_eos
    .local int rx1618_rep
    .local pmc rx1618_cur
    .local pmc rx1618_debug
    (rx1618_cur, rx1618_pos, rx1618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1618_cur
    .local pmc match
    .lex "$/", match
    length rx1618_eos, rx1618_tgt
    gt rx1618_pos, rx1618_eos, rx1618_done
    set rx1618_off, 0
    lt rx1618_pos, 2, rx1618_start
    sub rx1618_off, rx1618_pos, 1
    substr rx1618_tgt, rx1618_tgt, rx1618_off
  rx1618_start:
    eq $I10, 1, rx1618_restart
    if_null rx1618_debug, debug_1227
    rx1618_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1227:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1618_pos) = rx1618_cur."from"()
    inc rx1618_pos
    rx1618_cur."!cursor_from"(rx1618_pos)
    ge rx1618_pos, rx1618_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  rxscan1622_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1623_fail
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  # rx literal  "**"
    add $I11, rx1618_pos, 2
    gt $I11, rx1618_eos, rx1618_fail
    sub $I11, rx1618_pos, rx1618_off
    substr $S10, rx1618_tgt, $I11, 2
    ne $S10, "**", rx1618_fail
    add rx1618_pos, 2
    set_addr $I10, rxcap_1623_fail
    ($I12, $I11) = rx1618_cur."!mark_peek"($I10)
    rx1618_cur."!cursor_pos"($I11)
    ($P10) = rx1618_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1618_pos, "")
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1623_done
  rxcap_1623_fail:
    goto rx1618_fail
  rxcap_1623_done:
  # rx subrule "O" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1618_pos = $P10."pos"()
  # rx pass
    rx1618_cur."!cursor_pass"(rx1618_pos, "infix:sym<**>")
    if_null rx1618_debug, debug_1228
    rx1618_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1618_pos)
  debug_1228:
    .return (rx1618_cur)
  rx1618_restart:
.annotate 'line', 10
    if_null rx1618_debug, debug_1229
    rx1618_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1229:
  rx1618_fail:
    (rx1618_rep, rx1618_pos, $I10, $P10) = rx1618_cur."!mark_fail"(0)
    lt rx1618_pos, -1, rx1618_done
    eq rx1618_pos, -1, rx1618_fail
    jump $I10
  rx1618_done:
    rx1618_cur."!cursor_fail"()
    if_null rx1618_debug, debug_1230
    rx1618_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1230:
    .return (rx1618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("296_1303739803.72") :method
.annotate 'line', 10
    $P1620 = self."!PREFIX__!subrule"("O", "**")
    new $P1621, "ResizablePMCArray"
    push $P1621, $P1620
    .return ($P1621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("297_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1625_tgt
    .local int rx1625_pos
    .local int rx1625_off
    .local int rx1625_eos
    .local int rx1625_rep
    .local pmc rx1625_cur
    .local pmc rx1625_debug
    (rx1625_cur, rx1625_pos, rx1625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1625_cur
    .local pmc match
    .lex "$/", match
    length rx1625_eos, rx1625_tgt
    gt rx1625_pos, rx1625_eos, rx1625_done
    set rx1625_off, 0
    lt rx1625_pos, 2, rx1625_start
    sub rx1625_off, rx1625_pos, 1
    substr rx1625_tgt, rx1625_tgt, rx1625_off
  rx1625_start:
    eq $I10, 1, rx1625_restart
    if_null rx1625_debug, debug_1231
    rx1625_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1231:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1629_done
    goto rxscan1629_scan
  rxscan1629_loop:
    (rx1625_pos) = rx1625_cur."from"()
    inc rx1625_pos
    rx1625_cur."!cursor_from"(rx1625_pos)
    ge rx1625_pos, rx1625_eos, rxscan1629_done
  rxscan1629_scan:
    set_addr $I10, rxscan1629_loop
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  rxscan1629_done:
.annotate 'line', 657
  # rx subcapture "sym"
    set_addr $I10, rxcap_1630_fail
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  # rx literal  "+"
    add $I11, rx1625_pos, 1
    gt $I11, rx1625_eos, rx1625_fail
    sub $I11, rx1625_pos, rx1625_off
    ord $I11, rx1625_tgt, $I11
    ne $I11, 43, rx1625_fail
    add rx1625_pos, 1
    set_addr $I10, rxcap_1630_fail
    ($I12, $I11) = rx1625_cur."!mark_peek"($I10)
    rx1625_cur."!cursor_pos"($I11)
    ($P10) = rx1625_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1625_pos, "")
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1630_done
  rxcap_1630_fail:
    goto rx1625_fail
  rxcap_1630_done:
  # rx subrule "O" subtype=capture negate=
    rx1625_cur."!cursor_pos"(rx1625_pos)
    $P10 = rx1625_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1625_fail
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1625_pos = $P10."pos"()
  # rx pass
    rx1625_cur."!cursor_pass"(rx1625_pos, "prefix:sym<+>")
    if_null rx1625_debug, debug_1232
    rx1625_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1625_pos)
  debug_1232:
    .return (rx1625_cur)
  rx1625_restart:
.annotate 'line', 10
    if_null rx1625_debug, debug_1233
    rx1625_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1233:
  rx1625_fail:
    (rx1625_rep, rx1625_pos, $I10, $P10) = rx1625_cur."!mark_fail"(0)
    lt rx1625_pos, -1, rx1625_done
    eq rx1625_pos, -1, rx1625_fail
    jump $I10
  rx1625_done:
    rx1625_cur."!cursor_fail"()
    if_null rx1625_debug, debug_1234
    rx1625_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1234:
    .return (rx1625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("298_1303739803.72") :method
.annotate 'line', 10
    $P1627 = self."!PREFIX__!subrule"("O", "+")
    new $P1628, "ResizablePMCArray"
    push $P1628, $P1627
    .return ($P1628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("299_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1632_tgt
    .local int rx1632_pos
    .local int rx1632_off
    .local int rx1632_eos
    .local int rx1632_rep
    .local pmc rx1632_cur
    .local pmc rx1632_debug
    (rx1632_cur, rx1632_pos, rx1632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1632_cur
    .local pmc match
    .lex "$/", match
    length rx1632_eos, rx1632_tgt
    gt rx1632_pos, rx1632_eos, rx1632_done
    set rx1632_off, 0
    lt rx1632_pos, 2, rx1632_start
    sub rx1632_off, rx1632_pos, 1
    substr rx1632_tgt, rx1632_tgt, rx1632_off
  rx1632_start:
    eq $I10, 1, rx1632_restart
    if_null rx1632_debug, debug_1235
    rx1632_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1235:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1636_done
    goto rxscan1636_scan
  rxscan1636_loop:
    (rx1632_pos) = rx1632_cur."from"()
    inc rx1632_pos
    rx1632_cur."!cursor_from"(rx1632_pos)
    ge rx1632_pos, rx1632_eos, rxscan1636_done
  rxscan1636_scan:
    set_addr $I10, rxscan1636_loop
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  rxscan1636_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1637_fail
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  # rx literal  "~"
    add $I11, rx1632_pos, 1
    gt $I11, rx1632_eos, rx1632_fail
    sub $I11, rx1632_pos, rx1632_off
    ord $I11, rx1632_tgt, $I11
    ne $I11, 126, rx1632_fail
    add rx1632_pos, 1
    set_addr $I10, rxcap_1637_fail
    ($I12, $I11) = rx1632_cur."!mark_peek"($I10)
    rx1632_cur."!cursor_pos"($I11)
    ($P10) = rx1632_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1632_pos, "")
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1637_done
  rxcap_1637_fail:
    goto rx1632_fail
  rxcap_1637_done:
  # rx subrule "O" subtype=capture negate=
    rx1632_cur."!cursor_pos"(rx1632_pos)
    $P10 = rx1632_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1632_fail
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1632_pos = $P10."pos"()
  # rx pass
    rx1632_cur."!cursor_pass"(rx1632_pos, "prefix:sym<~>")
    if_null rx1632_debug, debug_1236
    rx1632_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1632_pos)
  debug_1236:
    .return (rx1632_cur)
  rx1632_restart:
.annotate 'line', 10
    if_null rx1632_debug, debug_1237
    rx1632_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1237:
  rx1632_fail:
    (rx1632_rep, rx1632_pos, $I10, $P10) = rx1632_cur."!mark_fail"(0)
    lt rx1632_pos, -1, rx1632_done
    eq rx1632_pos, -1, rx1632_fail
    jump $I10
  rx1632_done:
    rx1632_cur."!cursor_fail"()
    if_null rx1632_debug, debug_1238
    rx1632_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1238:
    .return (rx1632_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("300_1303739803.72") :method
.annotate 'line', 10
    $P1634 = self."!PREFIX__!subrule"("O", "~")
    new $P1635, "ResizablePMCArray"
    push $P1635, $P1634
    .return ($P1635)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("301_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1639_tgt
    .local int rx1639_pos
    .local int rx1639_off
    .local int rx1639_eos
    .local int rx1639_rep
    .local pmc rx1639_cur
    .local pmc rx1639_debug
    (rx1639_cur, rx1639_pos, rx1639_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1639_cur
    .local pmc match
    .lex "$/", match
    length rx1639_eos, rx1639_tgt
    gt rx1639_pos, rx1639_eos, rx1639_done
    set rx1639_off, 0
    lt rx1639_pos, 2, rx1639_start
    sub rx1639_off, rx1639_pos, 1
    substr rx1639_tgt, rx1639_tgt, rx1639_off
  rx1639_start:
    eq $I10, 1, rx1639_restart
    if_null rx1639_debug, debug_1239
    rx1639_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1239:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1642_done
    goto rxscan1642_scan
  rxscan1642_loop:
    (rx1639_pos) = rx1639_cur."from"()
    inc rx1639_pos
    rx1639_cur."!cursor_from"(rx1639_pos)
    ge rx1639_pos, rx1639_eos, rxscan1642_done
  rxscan1642_scan:
    set_addr $I10, rxscan1642_loop
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
  rxscan1642_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1643_fail
    rx1639_cur."!mark_push"(0, rx1639_pos, $I10)
  # rx literal  "-"
    add $I11, rx1639_pos, 1
    gt $I11, rx1639_eos, rx1639_fail
    sub $I11, rx1639_pos, rx1639_off
    ord $I11, rx1639_tgt, $I11
    ne $I11, 45, rx1639_fail
    add rx1639_pos, 1
    set_addr $I10, rxcap_1643_fail
    ($I12, $I11) = rx1639_cur."!mark_peek"($I10)
    rx1639_cur."!cursor_pos"($I11)
    ($P10) = rx1639_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1639_pos, "")
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1643_done
  rxcap_1643_fail:
    goto rx1639_fail
  rxcap_1643_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1639_pos, rx1639_off
    substr $S10, rx1639_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1639_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."number"()
    if $P10, rx1639_fail
  # rx subrule "O" subtype=capture negate=
    rx1639_cur."!cursor_pos"(rx1639_pos)
    $P10 = rx1639_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1639_fail
    rx1639_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1639_pos = $P10."pos"()
  # rx pass
    rx1639_cur."!cursor_pass"(rx1639_pos, "prefix:sym<->")
    if_null rx1639_debug, debug_1240
    rx1639_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1639_pos)
  debug_1240:
    .return (rx1639_cur)
  rx1639_restart:
.annotate 'line', 10
    if_null rx1639_debug, debug_1241
    rx1639_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1241:
  rx1639_fail:
    (rx1639_rep, rx1639_pos, $I10, $P10) = rx1639_cur."!mark_fail"(0)
    lt rx1639_pos, -1, rx1639_done
    eq rx1639_pos, -1, rx1639_fail
    jump $I10
  rx1639_done:
    rx1639_cur."!cursor_fail"()
    if_null rx1639_debug, debug_1242
    rx1639_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1242:
    .return (rx1639_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("302_1303739803.72") :method
.annotate 'line', 10
    new $P1641, "ResizablePMCArray"
    push $P1641, "-"
    .return ($P1641)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("303_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1645_tgt
    .local int rx1645_pos
    .local int rx1645_off
    .local int rx1645_eos
    .local int rx1645_rep
    .local pmc rx1645_cur
    .local pmc rx1645_debug
    (rx1645_cur, rx1645_pos, rx1645_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1645_cur
    .local pmc match
    .lex "$/", match
    length rx1645_eos, rx1645_tgt
    gt rx1645_pos, rx1645_eos, rx1645_done
    set rx1645_off, 0
    lt rx1645_pos, 2, rx1645_start
    sub rx1645_off, rx1645_pos, 1
    substr rx1645_tgt, rx1645_tgt, rx1645_off
  rx1645_start:
    eq $I10, 1, rx1645_restart
    if_null rx1645_debug, debug_1243
    rx1645_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1243:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1649_done
    goto rxscan1649_scan
  rxscan1649_loop:
    (rx1645_pos) = rx1645_cur."from"()
    inc rx1645_pos
    rx1645_cur."!cursor_from"(rx1645_pos)
    ge rx1645_pos, rx1645_eos, rxscan1649_done
  rxscan1649_scan:
    set_addr $I10, rxscan1649_loop
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
  rxscan1649_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1650_fail
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
  # rx literal  "?"
    add $I11, rx1645_pos, 1
    gt $I11, rx1645_eos, rx1645_fail
    sub $I11, rx1645_pos, rx1645_off
    ord $I11, rx1645_tgt, $I11
    ne $I11, 63, rx1645_fail
    add rx1645_pos, 1
    set_addr $I10, rxcap_1650_fail
    ($I12, $I11) = rx1645_cur."!mark_peek"($I10)
    rx1645_cur."!cursor_pos"($I11)
    ($P10) = rx1645_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1645_pos, "")
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1650_done
  rxcap_1650_fail:
    goto rx1645_fail
  rxcap_1650_done:
  # rx subrule "O" subtype=capture negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1645_fail
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1645_pos = $P10."pos"()
  # rx pass
    rx1645_cur."!cursor_pass"(rx1645_pos, "prefix:sym<?>")
    if_null rx1645_debug, debug_1244
    rx1645_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1645_pos)
  debug_1244:
    .return (rx1645_cur)
  rx1645_restart:
.annotate 'line', 10
    if_null rx1645_debug, debug_1245
    rx1645_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1245:
  rx1645_fail:
    (rx1645_rep, rx1645_pos, $I10, $P10) = rx1645_cur."!mark_fail"(0)
    lt rx1645_pos, -1, rx1645_done
    eq rx1645_pos, -1, rx1645_fail
    jump $I10
  rx1645_done:
    rx1645_cur."!cursor_fail"()
    if_null rx1645_debug, debug_1246
    rx1645_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1246:
    .return (rx1645_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("304_1303739803.72") :method
.annotate 'line', 10
    $P1647 = self."!PREFIX__!subrule"("O", "?")
    new $P1648, "ResizablePMCArray"
    push $P1648, $P1647
    .return ($P1648)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("305_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1652_tgt
    .local int rx1652_pos
    .local int rx1652_off
    .local int rx1652_eos
    .local int rx1652_rep
    .local pmc rx1652_cur
    .local pmc rx1652_debug
    (rx1652_cur, rx1652_pos, rx1652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1652_cur
    .local pmc match
    .lex "$/", match
    length rx1652_eos, rx1652_tgt
    gt rx1652_pos, rx1652_eos, rx1652_done
    set rx1652_off, 0
    lt rx1652_pos, 2, rx1652_start
    sub rx1652_off, rx1652_pos, 1
    substr rx1652_tgt, rx1652_tgt, rx1652_off
  rx1652_start:
    eq $I10, 1, rx1652_restart
    if_null rx1652_debug, debug_1247
    rx1652_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1247:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1656_done
    goto rxscan1656_scan
  rxscan1656_loop:
    (rx1652_pos) = rx1652_cur."from"()
    inc rx1652_pos
    rx1652_cur."!cursor_from"(rx1652_pos)
    ge rx1652_pos, rx1652_eos, rxscan1656_done
  rxscan1656_scan:
    set_addr $I10, rxscan1656_loop
    rx1652_cur."!mark_push"(0, rx1652_pos, $I10)
  rxscan1656_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1657_fail
    rx1652_cur."!mark_push"(0, rx1652_pos, $I10)
  # rx literal  "!"
    add $I11, rx1652_pos, 1
    gt $I11, rx1652_eos, rx1652_fail
    sub $I11, rx1652_pos, rx1652_off
    ord $I11, rx1652_tgt, $I11
    ne $I11, 33, rx1652_fail
    add rx1652_pos, 1
    set_addr $I10, rxcap_1657_fail
    ($I12, $I11) = rx1652_cur."!mark_peek"($I10)
    rx1652_cur."!cursor_pos"($I11)
    ($P10) = rx1652_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1652_pos, "")
    rx1652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1657_done
  rxcap_1657_fail:
    goto rx1652_fail
  rxcap_1657_done:
  # rx subrule "O" subtype=capture negate=
    rx1652_cur."!cursor_pos"(rx1652_pos)
    $P10 = rx1652_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1652_fail
    rx1652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1652_pos = $P10."pos"()
  # rx pass
    rx1652_cur."!cursor_pass"(rx1652_pos, "prefix:sym<!>")
    if_null rx1652_debug, debug_1248
    rx1652_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1652_pos)
  debug_1248:
    .return (rx1652_cur)
  rx1652_restart:
.annotate 'line', 10
    if_null rx1652_debug, debug_1249
    rx1652_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1249:
  rx1652_fail:
    (rx1652_rep, rx1652_pos, $I10, $P10) = rx1652_cur."!mark_fail"(0)
    lt rx1652_pos, -1, rx1652_done
    eq rx1652_pos, -1, rx1652_fail
    jump $I10
  rx1652_done:
    rx1652_cur."!cursor_fail"()
    if_null rx1652_debug, debug_1250
    rx1652_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1250:
    .return (rx1652_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("306_1303739803.72") :method
.annotate 'line', 10
    $P1654 = self."!PREFIX__!subrule"("O", "!")
    new $P1655, "ResizablePMCArray"
    push $P1655, $P1654
    .return ($P1655)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("307_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1659_tgt
    .local int rx1659_pos
    .local int rx1659_off
    .local int rx1659_eos
    .local int rx1659_rep
    .local pmc rx1659_cur
    .local pmc rx1659_debug
    (rx1659_cur, rx1659_pos, rx1659_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1659_cur
    .local pmc match
    .lex "$/", match
    length rx1659_eos, rx1659_tgt
    gt rx1659_pos, rx1659_eos, rx1659_done
    set rx1659_off, 0
    lt rx1659_pos, 2, rx1659_start
    sub rx1659_off, rx1659_pos, 1
    substr rx1659_tgt, rx1659_tgt, rx1659_off
  rx1659_start:
    eq $I10, 1, rx1659_restart
    if_null rx1659_debug, debug_1251
    rx1659_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1251:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1663_done
    goto rxscan1663_scan
  rxscan1663_loop:
    (rx1659_pos) = rx1659_cur."from"()
    inc rx1659_pos
    rx1659_cur."!cursor_from"(rx1659_pos)
    ge rx1659_pos, rx1659_eos, rxscan1663_done
  rxscan1663_scan:
    set_addr $I10, rxscan1663_loop
    rx1659_cur."!mark_push"(0, rx1659_pos, $I10)
  rxscan1663_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1664_fail
    rx1659_cur."!mark_push"(0, rx1659_pos, $I10)
  # rx literal  "|"
    add $I11, rx1659_pos, 1
    gt $I11, rx1659_eos, rx1659_fail
    sub $I11, rx1659_pos, rx1659_off
    ord $I11, rx1659_tgt, $I11
    ne $I11, 124, rx1659_fail
    add rx1659_pos, 1
    set_addr $I10, rxcap_1664_fail
    ($I12, $I11) = rx1659_cur."!mark_peek"($I10)
    rx1659_cur."!cursor_pos"($I11)
    ($P10) = rx1659_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1659_pos, "")
    rx1659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1664_done
  rxcap_1664_fail:
    goto rx1659_fail
  rxcap_1664_done:
  # rx subrule "O" subtype=capture negate=
    rx1659_cur."!cursor_pos"(rx1659_pos)
    $P10 = rx1659_cur."O"("%symbolic_unary")
    unless $P10, rx1659_fail
    rx1659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1659_pos = $P10."pos"()
  # rx pass
    rx1659_cur."!cursor_pass"(rx1659_pos, "prefix:sym<|>")
    if_null rx1659_debug, debug_1252
    rx1659_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1659_pos)
  debug_1252:
    .return (rx1659_cur)
  rx1659_restart:
.annotate 'line', 10
    if_null rx1659_debug, debug_1253
    rx1659_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1253:
  rx1659_fail:
    (rx1659_rep, rx1659_pos, $I10, $P10) = rx1659_cur."!mark_fail"(0)
    lt rx1659_pos, -1, rx1659_done
    eq rx1659_pos, -1, rx1659_fail
    jump $I10
  rx1659_done:
    rx1659_cur."!cursor_fail"()
    if_null rx1659_debug, debug_1254
    rx1659_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1254:
    .return (rx1659_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("308_1303739803.72") :method
.annotate 'line', 10
    $P1661 = self."!PREFIX__!subrule"("O", "|")
    new $P1662, "ResizablePMCArray"
    push $P1662, $P1661
    .return ($P1662)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("309_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1666_tgt
    .local int rx1666_pos
    .local int rx1666_off
    .local int rx1666_eos
    .local int rx1666_rep
    .local pmc rx1666_cur
    .local pmc rx1666_debug
    (rx1666_cur, rx1666_pos, rx1666_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1666_cur
    .local pmc match
    .lex "$/", match
    length rx1666_eos, rx1666_tgt
    gt rx1666_pos, rx1666_eos, rx1666_done
    set rx1666_off, 0
    lt rx1666_pos, 2, rx1666_start
    sub rx1666_off, rx1666_pos, 1
    substr rx1666_tgt, rx1666_tgt, rx1666_off
  rx1666_start:
    eq $I10, 1, rx1666_restart
    if_null rx1666_debug, debug_1255
    rx1666_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1255:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1670_done
    goto rxscan1670_scan
  rxscan1670_loop:
    (rx1666_pos) = rx1666_cur."from"()
    inc rx1666_pos
    rx1666_cur."!cursor_from"(rx1666_pos)
    ge rx1666_pos, rx1666_eos, rxscan1670_done
  rxscan1670_scan:
    set_addr $I10, rxscan1670_loop
    rx1666_cur."!mark_push"(0, rx1666_pos, $I10)
  rxscan1670_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1671_fail
    rx1666_cur."!mark_push"(0, rx1666_pos, $I10)
  # rx literal  "*"
    add $I11, rx1666_pos, 1
    gt $I11, rx1666_eos, rx1666_fail
    sub $I11, rx1666_pos, rx1666_off
    ord $I11, rx1666_tgt, $I11
    ne $I11, 42, rx1666_fail
    add rx1666_pos, 1
    set_addr $I10, rxcap_1671_fail
    ($I12, $I11) = rx1666_cur."!mark_peek"($I10)
    rx1666_cur."!cursor_pos"($I11)
    ($P10) = rx1666_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1666_pos, "")
    rx1666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1671_done
  rxcap_1671_fail:
    goto rx1666_fail
  rxcap_1671_done:
  # rx subrule "O" subtype=capture negate=
    rx1666_cur."!cursor_pos"(rx1666_pos)
    $P10 = rx1666_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1666_fail
    rx1666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1666_pos = $P10."pos"()
  # rx pass
    rx1666_cur."!cursor_pass"(rx1666_pos, "infix:sym<*>")
    if_null rx1666_debug, debug_1256
    rx1666_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1666_pos)
  debug_1256:
    .return (rx1666_cur)
  rx1666_restart:
.annotate 'line', 10
    if_null rx1666_debug, debug_1257
    rx1666_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1257:
  rx1666_fail:
    (rx1666_rep, rx1666_pos, $I10, $P10) = rx1666_cur."!mark_fail"(0)
    lt rx1666_pos, -1, rx1666_done
    eq rx1666_pos, -1, rx1666_fail
    jump $I10
  rx1666_done:
    rx1666_cur."!cursor_fail"()
    if_null rx1666_debug, debug_1258
    rx1666_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1258:
    .return (rx1666_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("310_1303739803.72") :method
.annotate 'line', 10
    $P1668 = self."!PREFIX__!subrule"("O", "*")
    new $P1669, "ResizablePMCArray"
    push $P1669, $P1668
    .return ($P1669)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("311_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1673_tgt
    .local int rx1673_pos
    .local int rx1673_off
    .local int rx1673_eos
    .local int rx1673_rep
    .local pmc rx1673_cur
    .local pmc rx1673_debug
    (rx1673_cur, rx1673_pos, rx1673_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1673_cur
    .local pmc match
    .lex "$/", match
    length rx1673_eos, rx1673_tgt
    gt rx1673_pos, rx1673_eos, rx1673_done
    set rx1673_off, 0
    lt rx1673_pos, 2, rx1673_start
    sub rx1673_off, rx1673_pos, 1
    substr rx1673_tgt, rx1673_tgt, rx1673_off
  rx1673_start:
    eq $I10, 1, rx1673_restart
    if_null rx1673_debug, debug_1259
    rx1673_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1259:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1677_done
    goto rxscan1677_scan
  rxscan1677_loop:
    (rx1673_pos) = rx1673_cur."from"()
    inc rx1673_pos
    rx1673_cur."!cursor_from"(rx1673_pos)
    ge rx1673_pos, rx1673_eos, rxscan1677_done
  rxscan1677_scan:
    set_addr $I10, rxscan1677_loop
    rx1673_cur."!mark_push"(0, rx1673_pos, $I10)
  rxscan1677_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1678_fail
    rx1673_cur."!mark_push"(0, rx1673_pos, $I10)
  # rx literal  "/"
    add $I11, rx1673_pos, 1
    gt $I11, rx1673_eos, rx1673_fail
    sub $I11, rx1673_pos, rx1673_off
    ord $I11, rx1673_tgt, $I11
    ne $I11, 47, rx1673_fail
    add rx1673_pos, 1
    set_addr $I10, rxcap_1678_fail
    ($I12, $I11) = rx1673_cur."!mark_peek"($I10)
    rx1673_cur."!cursor_pos"($I11)
    ($P10) = rx1673_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1673_pos, "")
    rx1673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1678_done
  rxcap_1678_fail:
    goto rx1673_fail
  rxcap_1678_done:
  # rx subrule "O" subtype=capture negate=
    rx1673_cur."!cursor_pos"(rx1673_pos)
    $P10 = rx1673_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1673_fail
    rx1673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1673_pos = $P10."pos"()
  # rx pass
    rx1673_cur."!cursor_pass"(rx1673_pos, "infix:sym</>")
    if_null rx1673_debug, debug_1260
    rx1673_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1673_pos)
  debug_1260:
    .return (rx1673_cur)
  rx1673_restart:
.annotate 'line', 10
    if_null rx1673_debug, debug_1261
    rx1673_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1261:
  rx1673_fail:
    (rx1673_rep, rx1673_pos, $I10, $P10) = rx1673_cur."!mark_fail"(0)
    lt rx1673_pos, -1, rx1673_done
    eq rx1673_pos, -1, rx1673_fail
    jump $I10
  rx1673_done:
    rx1673_cur."!cursor_fail"()
    if_null rx1673_debug, debug_1262
    rx1673_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1262:
    .return (rx1673_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("312_1303739803.72") :method
.annotate 'line', 10
    $P1675 = self."!PREFIX__!subrule"("O", "/")
    new $P1676, "ResizablePMCArray"
    push $P1676, $P1675
    .return ($P1676)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("313_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1680_tgt
    .local int rx1680_pos
    .local int rx1680_off
    .local int rx1680_eos
    .local int rx1680_rep
    .local pmc rx1680_cur
    .local pmc rx1680_debug
    (rx1680_cur, rx1680_pos, rx1680_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1680_cur
    .local pmc match
    .lex "$/", match
    length rx1680_eos, rx1680_tgt
    gt rx1680_pos, rx1680_eos, rx1680_done
    set rx1680_off, 0
    lt rx1680_pos, 2, rx1680_start
    sub rx1680_off, rx1680_pos, 1
    substr rx1680_tgt, rx1680_tgt, rx1680_off
  rx1680_start:
    eq $I10, 1, rx1680_restart
    if_null rx1680_debug, debug_1263
    rx1680_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1263:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1684_done
    goto rxscan1684_scan
  rxscan1684_loop:
    (rx1680_pos) = rx1680_cur."from"()
    inc rx1680_pos
    rx1680_cur."!cursor_from"(rx1680_pos)
    ge rx1680_pos, rx1680_eos, rxscan1684_done
  rxscan1684_scan:
    set_addr $I10, rxscan1684_loop
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  rxscan1684_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_1685_fail
    rx1680_cur."!mark_push"(0, rx1680_pos, $I10)
  # rx literal  "%"
    add $I11, rx1680_pos, 1
    gt $I11, rx1680_eos, rx1680_fail
    sub $I11, rx1680_pos, rx1680_off
    ord $I11, rx1680_tgt, $I11
    ne $I11, 37, rx1680_fail
    add rx1680_pos, 1
    set_addr $I10, rxcap_1685_fail
    ($I12, $I11) = rx1680_cur."!mark_peek"($I10)
    rx1680_cur."!cursor_pos"($I11)
    ($P10) = rx1680_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1680_pos, "")
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1685_done
  rxcap_1685_fail:
    goto rx1680_fail
  rxcap_1685_done:
  # rx subrule "O" subtype=capture negate=
    rx1680_cur."!cursor_pos"(rx1680_pos)
    $P10 = rx1680_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1680_fail
    rx1680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1680_pos = $P10."pos"()
  # rx pass
    rx1680_cur."!cursor_pass"(rx1680_pos, "infix:sym<%>")
    if_null rx1680_debug, debug_1264
    rx1680_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1680_pos)
  debug_1264:
    .return (rx1680_cur)
  rx1680_restart:
.annotate 'line', 10
    if_null rx1680_debug, debug_1265
    rx1680_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1265:
  rx1680_fail:
    (rx1680_rep, rx1680_pos, $I10, $P10) = rx1680_cur."!mark_fail"(0)
    lt rx1680_pos, -1, rx1680_done
    eq rx1680_pos, -1, rx1680_fail
    jump $I10
  rx1680_done:
    rx1680_cur."!cursor_fail"()
    if_null rx1680_debug, debug_1266
    rx1680_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1266:
    .return (rx1680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("314_1303739803.72") :method
.annotate 'line', 10
    $P1682 = self."!PREFIX__!subrule"("O", "%")
    new $P1683, "ResizablePMCArray"
    push $P1683, $P1682
    .return ($P1683)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("315_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1687_tgt
    .local int rx1687_pos
    .local int rx1687_off
    .local int rx1687_eos
    .local int rx1687_rep
    .local pmc rx1687_cur
    .local pmc rx1687_debug
    (rx1687_cur, rx1687_pos, rx1687_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1687_cur
    .local pmc match
    .lex "$/", match
    length rx1687_eos, rx1687_tgt
    gt rx1687_pos, rx1687_eos, rx1687_done
    set rx1687_off, 0
    lt rx1687_pos, 2, rx1687_start
    sub rx1687_off, rx1687_pos, 1
    substr rx1687_tgt, rx1687_tgt, rx1687_off
  rx1687_start:
    eq $I10, 1, rx1687_restart
    if_null rx1687_debug, debug_1267
    rx1687_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1267:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1691_done
    goto rxscan1691_scan
  rxscan1691_loop:
    (rx1687_pos) = rx1687_cur."from"()
    inc rx1687_pos
    rx1687_cur."!cursor_from"(rx1687_pos)
    ge rx1687_pos, rx1687_eos, rxscan1691_done
  rxscan1691_scan:
    set_addr $I10, rxscan1691_loop
    rx1687_cur."!mark_push"(0, rx1687_pos, $I10)
  rxscan1691_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1692_fail
    rx1687_cur."!mark_push"(0, rx1687_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1687_pos, 2
    gt $I11, rx1687_eos, rx1687_fail
    sub $I11, rx1687_pos, rx1687_off
    substr $S10, rx1687_tgt, $I11, 2
    ne $S10, "+&", rx1687_fail
    add rx1687_pos, 2
    set_addr $I10, rxcap_1692_fail
    ($I12, $I11) = rx1687_cur."!mark_peek"($I10)
    rx1687_cur."!cursor_pos"($I11)
    ($P10) = rx1687_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1687_pos, "")
    rx1687_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1692_done
  rxcap_1692_fail:
    goto rx1687_fail
  rxcap_1692_done:
  # rx subrule "O" subtype=capture negate=
    rx1687_cur."!cursor_pos"(rx1687_pos)
    $P10 = rx1687_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1687_fail
    rx1687_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1687_pos = $P10."pos"()
  # rx pass
    rx1687_cur."!cursor_pass"(rx1687_pos, "infix:sym<+&>")
    if_null rx1687_debug, debug_1268
    rx1687_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1687_pos)
  debug_1268:
    .return (rx1687_cur)
  rx1687_restart:
.annotate 'line', 10
    if_null rx1687_debug, debug_1269
    rx1687_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1269:
  rx1687_fail:
    (rx1687_rep, rx1687_pos, $I10, $P10) = rx1687_cur."!mark_fail"(0)
    lt rx1687_pos, -1, rx1687_done
    eq rx1687_pos, -1, rx1687_fail
    jump $I10
  rx1687_done:
    rx1687_cur."!cursor_fail"()
    if_null rx1687_debug, debug_1270
    rx1687_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1270:
    .return (rx1687_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("316_1303739803.72") :method
.annotate 'line', 10
    $P1689 = self."!PREFIX__!subrule"("O", "+&")
    new $P1690, "ResizablePMCArray"
    push $P1690, $P1689
    .return ($P1690)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("317_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1694_tgt
    .local int rx1694_pos
    .local int rx1694_off
    .local int rx1694_eos
    .local int rx1694_rep
    .local pmc rx1694_cur
    .local pmc rx1694_debug
    (rx1694_cur, rx1694_pos, rx1694_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1694_cur
    .local pmc match
    .lex "$/", match
    length rx1694_eos, rx1694_tgt
    gt rx1694_pos, rx1694_eos, rx1694_done
    set rx1694_off, 0
    lt rx1694_pos, 2, rx1694_start
    sub rx1694_off, rx1694_pos, 1
    substr rx1694_tgt, rx1694_tgt, rx1694_off
  rx1694_start:
    eq $I10, 1, rx1694_restart
    if_null rx1694_debug, debug_1271
    rx1694_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1271:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1698_done
    goto rxscan1698_scan
  rxscan1698_loop:
    (rx1694_pos) = rx1694_cur."from"()
    inc rx1694_pos
    rx1694_cur."!cursor_from"(rx1694_pos)
    ge rx1694_pos, rx1694_eos, rxscan1698_done
  rxscan1698_scan:
    set_addr $I10, rxscan1698_loop
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  rxscan1698_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1699_fail
    rx1694_cur."!mark_push"(0, rx1694_pos, $I10)
  # rx literal  "+"
    add $I11, rx1694_pos, 1
    gt $I11, rx1694_eos, rx1694_fail
    sub $I11, rx1694_pos, rx1694_off
    ord $I11, rx1694_tgt, $I11
    ne $I11, 43, rx1694_fail
    add rx1694_pos, 1
    set_addr $I10, rxcap_1699_fail
    ($I12, $I11) = rx1694_cur."!mark_peek"($I10)
    rx1694_cur."!cursor_pos"($I11)
    ($P10) = rx1694_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1694_pos, "")
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1699_done
  rxcap_1699_fail:
    goto rx1694_fail
  rxcap_1699_done:
  # rx subrule "O" subtype=capture negate=
    rx1694_cur."!cursor_pos"(rx1694_pos)
    $P10 = rx1694_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1694_fail
    rx1694_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1694_pos = $P10."pos"()
  # rx pass
    rx1694_cur."!cursor_pass"(rx1694_pos, "infix:sym<+>")
    if_null rx1694_debug, debug_1272
    rx1694_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1694_pos)
  debug_1272:
    .return (rx1694_cur)
  rx1694_restart:
.annotate 'line', 10
    if_null rx1694_debug, debug_1273
    rx1694_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1273:
  rx1694_fail:
    (rx1694_rep, rx1694_pos, $I10, $P10) = rx1694_cur."!mark_fail"(0)
    lt rx1694_pos, -1, rx1694_done
    eq rx1694_pos, -1, rx1694_fail
    jump $I10
  rx1694_done:
    rx1694_cur."!cursor_fail"()
    if_null rx1694_debug, debug_1274
    rx1694_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1274:
    .return (rx1694_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("318_1303739803.72") :method
.annotate 'line', 10
    $P1696 = self."!PREFIX__!subrule"("O", "+")
    new $P1697, "ResizablePMCArray"
    push $P1697, $P1696
    .return ($P1697)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("319_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1701_tgt
    .local int rx1701_pos
    .local int rx1701_off
    .local int rx1701_eos
    .local int rx1701_rep
    .local pmc rx1701_cur
    .local pmc rx1701_debug
    (rx1701_cur, rx1701_pos, rx1701_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1701_cur
    .local pmc match
    .lex "$/", match
    length rx1701_eos, rx1701_tgt
    gt rx1701_pos, rx1701_eos, rx1701_done
    set rx1701_off, 0
    lt rx1701_pos, 2, rx1701_start
    sub rx1701_off, rx1701_pos, 1
    substr rx1701_tgt, rx1701_tgt, rx1701_off
  rx1701_start:
    eq $I10, 1, rx1701_restart
    if_null rx1701_debug, debug_1275
    rx1701_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1275:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1705_done
    goto rxscan1705_scan
  rxscan1705_loop:
    (rx1701_pos) = rx1701_cur."from"()
    inc rx1701_pos
    rx1701_cur."!cursor_from"(rx1701_pos)
    ge rx1701_pos, rx1701_eos, rxscan1705_done
  rxscan1705_scan:
    set_addr $I10, rxscan1705_loop
    rx1701_cur."!mark_push"(0, rx1701_pos, $I10)
  rxscan1705_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1706_fail
    rx1701_cur."!mark_push"(0, rx1701_pos, $I10)
  # rx literal  "-"
    add $I11, rx1701_pos, 1
    gt $I11, rx1701_eos, rx1701_fail
    sub $I11, rx1701_pos, rx1701_off
    ord $I11, rx1701_tgt, $I11
    ne $I11, 45, rx1701_fail
    add rx1701_pos, 1
    set_addr $I10, rxcap_1706_fail
    ($I12, $I11) = rx1701_cur."!mark_peek"($I10)
    rx1701_cur."!cursor_pos"($I11)
    ($P10) = rx1701_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1701_pos, "")
    rx1701_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1706_done
  rxcap_1706_fail:
    goto rx1701_fail
  rxcap_1706_done:
  # rx subrule "O" subtype=capture negate=
    rx1701_cur."!cursor_pos"(rx1701_pos)
    $P10 = rx1701_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1701_fail
    rx1701_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1701_pos = $P10."pos"()
  # rx pass
    rx1701_cur."!cursor_pass"(rx1701_pos, "infix:sym<->")
    if_null rx1701_debug, debug_1276
    rx1701_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1701_pos)
  debug_1276:
    .return (rx1701_cur)
  rx1701_restart:
.annotate 'line', 10
    if_null rx1701_debug, debug_1277
    rx1701_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1277:
  rx1701_fail:
    (rx1701_rep, rx1701_pos, $I10, $P10) = rx1701_cur."!mark_fail"(0)
    lt rx1701_pos, -1, rx1701_done
    eq rx1701_pos, -1, rx1701_fail
    jump $I10
  rx1701_done:
    rx1701_cur."!cursor_fail"()
    if_null rx1701_debug, debug_1278
    rx1701_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1278:
    .return (rx1701_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("320_1303739803.72") :method
.annotate 'line', 10
    $P1703 = self."!PREFIX__!subrule"("O", "-")
    new $P1704, "ResizablePMCArray"
    push $P1704, $P1703
    .return ($P1704)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("321_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1708_tgt
    .local int rx1708_pos
    .local int rx1708_off
    .local int rx1708_eos
    .local int rx1708_rep
    .local pmc rx1708_cur
    .local pmc rx1708_debug
    (rx1708_cur, rx1708_pos, rx1708_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1708_cur
    .local pmc match
    .lex "$/", match
    length rx1708_eos, rx1708_tgt
    gt rx1708_pos, rx1708_eos, rx1708_done
    set rx1708_off, 0
    lt rx1708_pos, 2, rx1708_start
    sub rx1708_off, rx1708_pos, 1
    substr rx1708_tgt, rx1708_tgt, rx1708_off
  rx1708_start:
    eq $I10, 1, rx1708_restart
    if_null rx1708_debug, debug_1279
    rx1708_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1279:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1712_done
    goto rxscan1712_scan
  rxscan1712_loop:
    (rx1708_pos) = rx1708_cur."from"()
    inc rx1708_pos
    rx1708_cur."!cursor_from"(rx1708_pos)
    ge rx1708_pos, rx1708_eos, rxscan1712_done
  rxscan1712_scan:
    set_addr $I10, rxscan1712_loop
    rx1708_cur."!mark_push"(0, rx1708_pos, $I10)
  rxscan1712_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1713_fail
    rx1708_cur."!mark_push"(0, rx1708_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1708_pos, 2
    gt $I11, rx1708_eos, rx1708_fail
    sub $I11, rx1708_pos, rx1708_off
    substr $S10, rx1708_tgt, $I11, 2
    ne $S10, "+|", rx1708_fail
    add rx1708_pos, 2
    set_addr $I10, rxcap_1713_fail
    ($I12, $I11) = rx1708_cur."!mark_peek"($I10)
    rx1708_cur."!cursor_pos"($I11)
    ($P10) = rx1708_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1708_pos, "")
    rx1708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1713_done
  rxcap_1713_fail:
    goto rx1708_fail
  rxcap_1713_done:
  # rx subrule "O" subtype=capture negate=
    rx1708_cur."!cursor_pos"(rx1708_pos)
    $P10 = rx1708_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1708_fail
    rx1708_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1708_pos = $P10."pos"()
  # rx pass
    rx1708_cur."!cursor_pass"(rx1708_pos, "infix:sym<+|>")
    if_null rx1708_debug, debug_1280
    rx1708_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1708_pos)
  debug_1280:
    .return (rx1708_cur)
  rx1708_restart:
.annotate 'line', 10
    if_null rx1708_debug, debug_1281
    rx1708_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1281:
  rx1708_fail:
    (rx1708_rep, rx1708_pos, $I10, $P10) = rx1708_cur."!mark_fail"(0)
    lt rx1708_pos, -1, rx1708_done
    eq rx1708_pos, -1, rx1708_fail
    jump $I10
  rx1708_done:
    rx1708_cur."!cursor_fail"()
    if_null rx1708_debug, debug_1282
    rx1708_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1282:
    .return (rx1708_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("322_1303739803.72") :method
.annotate 'line', 10
    $P1710 = self."!PREFIX__!subrule"("O", "+|")
    new $P1711, "ResizablePMCArray"
    push $P1711, $P1710
    .return ($P1711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("323_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1715_tgt
    .local int rx1715_pos
    .local int rx1715_off
    .local int rx1715_eos
    .local int rx1715_rep
    .local pmc rx1715_cur
    .local pmc rx1715_debug
    (rx1715_cur, rx1715_pos, rx1715_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1715_cur
    .local pmc match
    .lex "$/", match
    length rx1715_eos, rx1715_tgt
    gt rx1715_pos, rx1715_eos, rx1715_done
    set rx1715_off, 0
    lt rx1715_pos, 2, rx1715_start
    sub rx1715_off, rx1715_pos, 1
    substr rx1715_tgt, rx1715_tgt, rx1715_off
  rx1715_start:
    eq $I10, 1, rx1715_restart
    if_null rx1715_debug, debug_1283
    rx1715_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1283:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1719_done
    goto rxscan1719_scan
  rxscan1719_loop:
    (rx1715_pos) = rx1715_cur."from"()
    inc rx1715_pos
    rx1715_cur."!cursor_from"(rx1715_pos)
    ge rx1715_pos, rx1715_eos, rxscan1719_done
  rxscan1719_scan:
    set_addr $I10, rxscan1719_loop
    rx1715_cur."!mark_push"(0, rx1715_pos, $I10)
  rxscan1719_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1720_fail
    rx1715_cur."!mark_push"(0, rx1715_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1715_pos, 2
    gt $I11, rx1715_eos, rx1715_fail
    sub $I11, rx1715_pos, rx1715_off
    substr $S10, rx1715_tgt, $I11, 2
    ne $S10, "+^", rx1715_fail
    add rx1715_pos, 2
    set_addr $I10, rxcap_1720_fail
    ($I12, $I11) = rx1715_cur."!mark_peek"($I10)
    rx1715_cur."!cursor_pos"($I11)
    ($P10) = rx1715_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1715_pos, "")
    rx1715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1720_done
  rxcap_1720_fail:
    goto rx1715_fail
  rxcap_1720_done:
  # rx subrule "O" subtype=capture negate=
    rx1715_cur."!cursor_pos"(rx1715_pos)
    $P10 = rx1715_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1715_fail
    rx1715_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1715_pos = $P10."pos"()
  # rx pass
    rx1715_cur."!cursor_pass"(rx1715_pos, "infix:sym<+^>")
    if_null rx1715_debug, debug_1284
    rx1715_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1715_pos)
  debug_1284:
    .return (rx1715_cur)
  rx1715_restart:
.annotate 'line', 10
    if_null rx1715_debug, debug_1285
    rx1715_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1285:
  rx1715_fail:
    (rx1715_rep, rx1715_pos, $I10, $P10) = rx1715_cur."!mark_fail"(0)
    lt rx1715_pos, -1, rx1715_done
    eq rx1715_pos, -1, rx1715_fail
    jump $I10
  rx1715_done:
    rx1715_cur."!cursor_fail"()
    if_null rx1715_debug, debug_1286
    rx1715_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1286:
    .return (rx1715_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("324_1303739803.72") :method
.annotate 'line', 10
    $P1717 = self."!PREFIX__!subrule"("O", "+^")
    new $P1718, "ResizablePMCArray"
    push $P1718, $P1717
    .return ($P1718)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("325_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1722_tgt
    .local int rx1722_pos
    .local int rx1722_off
    .local int rx1722_eos
    .local int rx1722_rep
    .local pmc rx1722_cur
    .local pmc rx1722_debug
    (rx1722_cur, rx1722_pos, rx1722_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1722_cur
    .local pmc match
    .lex "$/", match
    length rx1722_eos, rx1722_tgt
    gt rx1722_pos, rx1722_eos, rx1722_done
    set rx1722_off, 0
    lt rx1722_pos, 2, rx1722_start
    sub rx1722_off, rx1722_pos, 1
    substr rx1722_tgt, rx1722_tgt, rx1722_off
  rx1722_start:
    eq $I10, 1, rx1722_restart
    if_null rx1722_debug, debug_1287
    rx1722_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1287:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1726_done
    goto rxscan1726_scan
  rxscan1726_loop:
    (rx1722_pos) = rx1722_cur."from"()
    inc rx1722_pos
    rx1722_cur."!cursor_from"(rx1722_pos)
    ge rx1722_pos, rx1722_eos, rxscan1726_done
  rxscan1726_scan:
    set_addr $I10, rxscan1726_loop
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  rxscan1726_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1727_fail
    rx1722_cur."!mark_push"(0, rx1722_pos, $I10)
  # rx literal  "~"
    add $I11, rx1722_pos, 1
    gt $I11, rx1722_eos, rx1722_fail
    sub $I11, rx1722_pos, rx1722_off
    ord $I11, rx1722_tgt, $I11
    ne $I11, 126, rx1722_fail
    add rx1722_pos, 1
    set_addr $I10, rxcap_1727_fail
    ($I12, $I11) = rx1722_cur."!mark_peek"($I10)
    rx1722_cur."!cursor_pos"($I11)
    ($P10) = rx1722_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1722_pos, "")
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1727_done
  rxcap_1727_fail:
    goto rx1722_fail
  rxcap_1727_done:
  # rx subrule "O" subtype=capture negate=
    rx1722_cur."!cursor_pos"(rx1722_pos)
    $P10 = rx1722_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1722_fail
    rx1722_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1722_pos = $P10."pos"()
  # rx pass
    rx1722_cur."!cursor_pass"(rx1722_pos, "infix:sym<~>")
    if_null rx1722_debug, debug_1288
    rx1722_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1722_pos)
  debug_1288:
    .return (rx1722_cur)
  rx1722_restart:
.annotate 'line', 10
    if_null rx1722_debug, debug_1289
    rx1722_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1289:
  rx1722_fail:
    (rx1722_rep, rx1722_pos, $I10, $P10) = rx1722_cur."!mark_fail"(0)
    lt rx1722_pos, -1, rx1722_done
    eq rx1722_pos, -1, rx1722_fail
    jump $I10
  rx1722_done:
    rx1722_cur."!cursor_fail"()
    if_null rx1722_debug, debug_1290
    rx1722_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1290:
    .return (rx1722_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("326_1303739803.72") :method
.annotate 'line', 10
    $P1724 = self."!PREFIX__!subrule"("O", "~")
    new $P1725, "ResizablePMCArray"
    push $P1725, $P1724
    .return ($P1725)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("327_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1729_tgt
    .local int rx1729_pos
    .local int rx1729_off
    .local int rx1729_eos
    .local int rx1729_rep
    .local pmc rx1729_cur
    .local pmc rx1729_debug
    (rx1729_cur, rx1729_pos, rx1729_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1729_cur
    .local pmc match
    .lex "$/", match
    length rx1729_eos, rx1729_tgt
    gt rx1729_pos, rx1729_eos, rx1729_done
    set rx1729_off, 0
    lt rx1729_pos, 2, rx1729_start
    sub rx1729_off, rx1729_pos, 1
    substr rx1729_tgt, rx1729_tgt, rx1729_off
  rx1729_start:
    eq $I10, 1, rx1729_restart
    if_null rx1729_debug, debug_1291
    rx1729_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1291:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1733_done
    goto rxscan1733_scan
  rxscan1733_loop:
    (rx1729_pos) = rx1729_cur."from"()
    inc rx1729_pos
    rx1729_cur."!cursor_from"(rx1729_pos)
    ge rx1729_pos, rx1729_eos, rxscan1733_done
  rxscan1733_scan:
    set_addr $I10, rxscan1733_loop
    rx1729_cur."!mark_push"(0, rx1729_pos, $I10)
  rxscan1733_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_1734_fail
    rx1729_cur."!mark_push"(0, rx1729_pos, $I10)
  # rx literal  "=="
    add $I11, rx1729_pos, 2
    gt $I11, rx1729_eos, rx1729_fail
    sub $I11, rx1729_pos, rx1729_off
    substr $S10, rx1729_tgt, $I11, 2
    ne $S10, "==", rx1729_fail
    add rx1729_pos, 2
    set_addr $I10, rxcap_1734_fail
    ($I12, $I11) = rx1729_cur."!mark_peek"($I10)
    rx1729_cur."!cursor_pos"($I11)
    ($P10) = rx1729_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1729_pos, "")
    rx1729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1734_done
  rxcap_1734_fail:
    goto rx1729_fail
  rxcap_1734_done:
  # rx subrule "O" subtype=capture negate=
    rx1729_cur."!cursor_pos"(rx1729_pos)
    $P10 = rx1729_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1729_fail
    rx1729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1729_pos = $P10."pos"()
  # rx pass
    rx1729_cur."!cursor_pass"(rx1729_pos, "infix:sym<==>")
    if_null rx1729_debug, debug_1292
    rx1729_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1729_pos)
  debug_1292:
    .return (rx1729_cur)
  rx1729_restart:
.annotate 'line', 10
    if_null rx1729_debug, debug_1293
    rx1729_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1293:
  rx1729_fail:
    (rx1729_rep, rx1729_pos, $I10, $P10) = rx1729_cur."!mark_fail"(0)
    lt rx1729_pos, -1, rx1729_done
    eq rx1729_pos, -1, rx1729_fail
    jump $I10
  rx1729_done:
    rx1729_cur."!cursor_fail"()
    if_null rx1729_debug, debug_1294
    rx1729_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1294:
    .return (rx1729_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("328_1303739803.72") :method
.annotate 'line', 10
    $P1731 = self."!PREFIX__!subrule"("O", "==")
    new $P1732, "ResizablePMCArray"
    push $P1732, $P1731
    .return ($P1732)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("329_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1736_tgt
    .local int rx1736_pos
    .local int rx1736_off
    .local int rx1736_eos
    .local int rx1736_rep
    .local pmc rx1736_cur
    .local pmc rx1736_debug
    (rx1736_cur, rx1736_pos, rx1736_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1736_cur
    .local pmc match
    .lex "$/", match
    length rx1736_eos, rx1736_tgt
    gt rx1736_pos, rx1736_eos, rx1736_done
    set rx1736_off, 0
    lt rx1736_pos, 2, rx1736_start
    sub rx1736_off, rx1736_pos, 1
    substr rx1736_tgt, rx1736_tgt, rx1736_off
  rx1736_start:
    eq $I10, 1, rx1736_restart
    if_null rx1736_debug, debug_1295
    rx1736_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1295:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1740_done
    goto rxscan1740_scan
  rxscan1740_loop:
    (rx1736_pos) = rx1736_cur."from"()
    inc rx1736_pos
    rx1736_cur."!cursor_from"(rx1736_pos)
    ge rx1736_pos, rx1736_eos, rxscan1740_done
  rxscan1740_scan:
    set_addr $I10, rxscan1740_loop
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  rxscan1740_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1741_fail
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  # rx literal  "!="
    add $I11, rx1736_pos, 2
    gt $I11, rx1736_eos, rx1736_fail
    sub $I11, rx1736_pos, rx1736_off
    substr $S10, rx1736_tgt, $I11, 2
    ne $S10, "!=", rx1736_fail
    add rx1736_pos, 2
    set_addr $I10, rxcap_1741_fail
    ($I12, $I11) = rx1736_cur."!mark_peek"($I10)
    rx1736_cur."!cursor_pos"($I11)
    ($P10) = rx1736_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1736_pos, "")
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1741_done
  rxcap_1741_fail:
    goto rx1736_fail
  rxcap_1741_done:
  # rx subrule "O" subtype=capture negate=
    rx1736_cur."!cursor_pos"(rx1736_pos)
    $P10 = rx1736_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1736_fail
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1736_pos = $P10."pos"()
  # rx pass
    rx1736_cur."!cursor_pass"(rx1736_pos, "infix:sym<!=>")
    if_null rx1736_debug, debug_1296
    rx1736_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1736_pos)
  debug_1296:
    .return (rx1736_cur)
  rx1736_restart:
.annotate 'line', 10
    if_null rx1736_debug, debug_1297
    rx1736_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1297:
  rx1736_fail:
    (rx1736_rep, rx1736_pos, $I10, $P10) = rx1736_cur."!mark_fail"(0)
    lt rx1736_pos, -1, rx1736_done
    eq rx1736_pos, -1, rx1736_fail
    jump $I10
  rx1736_done:
    rx1736_cur."!cursor_fail"()
    if_null rx1736_debug, debug_1298
    rx1736_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1298:
    .return (rx1736_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("330_1303739803.72") :method
.annotate 'line', 10
    $P1738 = self."!PREFIX__!subrule"("O", "!=")
    new $P1739, "ResizablePMCArray"
    push $P1739, $P1738
    .return ($P1739)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("331_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1743_tgt
    .local int rx1743_pos
    .local int rx1743_off
    .local int rx1743_eos
    .local int rx1743_rep
    .local pmc rx1743_cur
    .local pmc rx1743_debug
    (rx1743_cur, rx1743_pos, rx1743_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1743_cur
    .local pmc match
    .lex "$/", match
    length rx1743_eos, rx1743_tgt
    gt rx1743_pos, rx1743_eos, rx1743_done
    set rx1743_off, 0
    lt rx1743_pos, 2, rx1743_start
    sub rx1743_off, rx1743_pos, 1
    substr rx1743_tgt, rx1743_tgt, rx1743_off
  rx1743_start:
    eq $I10, 1, rx1743_restart
    if_null rx1743_debug, debug_1299
    rx1743_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1299:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1747_done
    goto rxscan1747_scan
  rxscan1747_loop:
    (rx1743_pos) = rx1743_cur."from"()
    inc rx1743_pos
    rx1743_cur."!cursor_from"(rx1743_pos)
    ge rx1743_pos, rx1743_eos, rxscan1747_done
  rxscan1747_scan:
    set_addr $I10, rxscan1747_loop
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10)
  rxscan1747_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_1748_fail
    rx1743_cur."!mark_push"(0, rx1743_pos, $I10)
  # rx literal  "<="
    add $I11, rx1743_pos, 2
    gt $I11, rx1743_eos, rx1743_fail
    sub $I11, rx1743_pos, rx1743_off
    substr $S10, rx1743_tgt, $I11, 2
    ne $S10, "<=", rx1743_fail
    add rx1743_pos, 2
    set_addr $I10, rxcap_1748_fail
    ($I12, $I11) = rx1743_cur."!mark_peek"($I10)
    rx1743_cur."!cursor_pos"($I11)
    ($P10) = rx1743_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1743_pos, "")
    rx1743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1748_done
  rxcap_1748_fail:
    goto rx1743_fail
  rxcap_1748_done:
  # rx subrule "O" subtype=capture negate=
    rx1743_cur."!cursor_pos"(rx1743_pos)
    $P10 = rx1743_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1743_fail
    rx1743_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1743_pos = $P10."pos"()
  # rx pass
    rx1743_cur."!cursor_pass"(rx1743_pos, "infix:sym<<=>")
    if_null rx1743_debug, debug_1300
    rx1743_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1743_pos)
  debug_1300:
    .return (rx1743_cur)
  rx1743_restart:
.annotate 'line', 10
    if_null rx1743_debug, debug_1301
    rx1743_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1301:
  rx1743_fail:
    (rx1743_rep, rx1743_pos, $I10, $P10) = rx1743_cur."!mark_fail"(0)
    lt rx1743_pos, -1, rx1743_done
    eq rx1743_pos, -1, rx1743_fail
    jump $I10
  rx1743_done:
    rx1743_cur."!cursor_fail"()
    if_null rx1743_debug, debug_1302
    rx1743_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1302:
    .return (rx1743_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("332_1303739803.72") :method
.annotate 'line', 10
    $P1745 = self."!PREFIX__!subrule"("O", "<=")
    new $P1746, "ResizablePMCArray"
    push $P1746, $P1745
    .return ($P1746)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("333_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1750_tgt
    .local int rx1750_pos
    .local int rx1750_off
    .local int rx1750_eos
    .local int rx1750_rep
    .local pmc rx1750_cur
    .local pmc rx1750_debug
    (rx1750_cur, rx1750_pos, rx1750_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1750_cur
    .local pmc match
    .lex "$/", match
    length rx1750_eos, rx1750_tgt
    gt rx1750_pos, rx1750_eos, rx1750_done
    set rx1750_off, 0
    lt rx1750_pos, 2, rx1750_start
    sub rx1750_off, rx1750_pos, 1
    substr rx1750_tgt, rx1750_tgt, rx1750_off
  rx1750_start:
    eq $I10, 1, rx1750_restart
    if_null rx1750_debug, debug_1303
    rx1750_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1303:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1754_done
    goto rxscan1754_scan
  rxscan1754_loop:
    (rx1750_pos) = rx1750_cur."from"()
    inc rx1750_pos
    rx1750_cur."!cursor_from"(rx1750_pos)
    ge rx1750_pos, rx1750_eos, rxscan1754_done
  rxscan1754_scan:
    set_addr $I10, rxscan1754_loop
    rx1750_cur."!mark_push"(0, rx1750_pos, $I10)
  rxscan1754_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1755_fail
    rx1750_cur."!mark_push"(0, rx1750_pos, $I10)
  # rx literal  ">="
    add $I11, rx1750_pos, 2
    gt $I11, rx1750_eos, rx1750_fail
    sub $I11, rx1750_pos, rx1750_off
    substr $S10, rx1750_tgt, $I11, 2
    ne $S10, ">=", rx1750_fail
    add rx1750_pos, 2
    set_addr $I10, rxcap_1755_fail
    ($I12, $I11) = rx1750_cur."!mark_peek"($I10)
    rx1750_cur."!cursor_pos"($I11)
    ($P10) = rx1750_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1750_pos, "")
    rx1750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1755_done
  rxcap_1755_fail:
    goto rx1750_fail
  rxcap_1755_done:
  # rx subrule "O" subtype=capture negate=
    rx1750_cur."!cursor_pos"(rx1750_pos)
    $P10 = rx1750_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1750_fail
    rx1750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1750_pos = $P10."pos"()
  # rx pass
    rx1750_cur."!cursor_pass"(rx1750_pos, "infix:sym<>=>")
    if_null rx1750_debug, debug_1304
    rx1750_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1750_pos)
  debug_1304:
    .return (rx1750_cur)
  rx1750_restart:
.annotate 'line', 10
    if_null rx1750_debug, debug_1305
    rx1750_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1305:
  rx1750_fail:
    (rx1750_rep, rx1750_pos, $I10, $P10) = rx1750_cur."!mark_fail"(0)
    lt rx1750_pos, -1, rx1750_done
    eq rx1750_pos, -1, rx1750_fail
    jump $I10
  rx1750_done:
    rx1750_cur."!cursor_fail"()
    if_null rx1750_debug, debug_1306
    rx1750_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1306:
    .return (rx1750_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("334_1303739803.72") :method
.annotate 'line', 10
    $P1752 = self."!PREFIX__!subrule"("O", ">=")
    new $P1753, "ResizablePMCArray"
    push $P1753, $P1752
    .return ($P1753)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("335_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1757_tgt
    .local int rx1757_pos
    .local int rx1757_off
    .local int rx1757_eos
    .local int rx1757_rep
    .local pmc rx1757_cur
    .local pmc rx1757_debug
    (rx1757_cur, rx1757_pos, rx1757_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1757_cur
    .local pmc match
    .lex "$/", match
    length rx1757_eos, rx1757_tgt
    gt rx1757_pos, rx1757_eos, rx1757_done
    set rx1757_off, 0
    lt rx1757_pos, 2, rx1757_start
    sub rx1757_off, rx1757_pos, 1
    substr rx1757_tgt, rx1757_tgt, rx1757_off
  rx1757_start:
    eq $I10, 1, rx1757_restart
    if_null rx1757_debug, debug_1307
    rx1757_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1307:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1761_done
    goto rxscan1761_scan
  rxscan1761_loop:
    (rx1757_pos) = rx1757_cur."from"()
    inc rx1757_pos
    rx1757_cur."!cursor_from"(rx1757_pos)
    ge rx1757_pos, rx1757_eos, rxscan1761_done
  rxscan1761_scan:
    set_addr $I10, rxscan1761_loop
    rx1757_cur."!mark_push"(0, rx1757_pos, $I10)
  rxscan1761_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1762_fail
    rx1757_cur."!mark_push"(0, rx1757_pos, $I10)
  # rx literal  "<"
    add $I11, rx1757_pos, 1
    gt $I11, rx1757_eos, rx1757_fail
    sub $I11, rx1757_pos, rx1757_off
    ord $I11, rx1757_tgt, $I11
    ne $I11, 60, rx1757_fail
    add rx1757_pos, 1
    set_addr $I10, rxcap_1762_fail
    ($I12, $I11) = rx1757_cur."!mark_peek"($I10)
    rx1757_cur."!cursor_pos"($I11)
    ($P10) = rx1757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1757_pos, "")
    rx1757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1762_done
  rxcap_1762_fail:
    goto rx1757_fail
  rxcap_1762_done:
  # rx subrule "O" subtype=capture negate=
    rx1757_cur."!cursor_pos"(rx1757_pos)
    $P10 = rx1757_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1757_fail
    rx1757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1757_pos = $P10."pos"()
  # rx pass
    rx1757_cur."!cursor_pass"(rx1757_pos, "infix:sym<<>")
    if_null rx1757_debug, debug_1308
    rx1757_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1757_pos)
  debug_1308:
    .return (rx1757_cur)
  rx1757_restart:
.annotate 'line', 10
    if_null rx1757_debug, debug_1309
    rx1757_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1309:
  rx1757_fail:
    (rx1757_rep, rx1757_pos, $I10, $P10) = rx1757_cur."!mark_fail"(0)
    lt rx1757_pos, -1, rx1757_done
    eq rx1757_pos, -1, rx1757_fail
    jump $I10
  rx1757_done:
    rx1757_cur."!cursor_fail"()
    if_null rx1757_debug, debug_1310
    rx1757_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1310:
    .return (rx1757_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("336_1303739803.72") :method
.annotate 'line', 10
    $P1759 = self."!PREFIX__!subrule"("O", "<")
    new $P1760, "ResizablePMCArray"
    push $P1760, $P1759
    .return ($P1760)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("337_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1764_tgt
    .local int rx1764_pos
    .local int rx1764_off
    .local int rx1764_eos
    .local int rx1764_rep
    .local pmc rx1764_cur
    .local pmc rx1764_debug
    (rx1764_cur, rx1764_pos, rx1764_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1764_cur
    .local pmc match
    .lex "$/", match
    length rx1764_eos, rx1764_tgt
    gt rx1764_pos, rx1764_eos, rx1764_done
    set rx1764_off, 0
    lt rx1764_pos, 2, rx1764_start
    sub rx1764_off, rx1764_pos, 1
    substr rx1764_tgt, rx1764_tgt, rx1764_off
  rx1764_start:
    eq $I10, 1, rx1764_restart
    if_null rx1764_debug, debug_1311
    rx1764_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1311:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1768_done
    goto rxscan1768_scan
  rxscan1768_loop:
    (rx1764_pos) = rx1764_cur."from"()
    inc rx1764_pos
    rx1764_cur."!cursor_from"(rx1764_pos)
    ge rx1764_pos, rx1764_eos, rxscan1768_done
  rxscan1768_scan:
    set_addr $I10, rxscan1768_loop
    rx1764_cur."!mark_push"(0, rx1764_pos, $I10)
  rxscan1768_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1769_fail
    rx1764_cur."!mark_push"(0, rx1764_pos, $I10)
  # rx literal  ">"
    add $I11, rx1764_pos, 1
    gt $I11, rx1764_eos, rx1764_fail
    sub $I11, rx1764_pos, rx1764_off
    ord $I11, rx1764_tgt, $I11
    ne $I11, 62, rx1764_fail
    add rx1764_pos, 1
    set_addr $I10, rxcap_1769_fail
    ($I12, $I11) = rx1764_cur."!mark_peek"($I10)
    rx1764_cur."!cursor_pos"($I11)
    ($P10) = rx1764_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1764_pos, "")
    rx1764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1769_done
  rxcap_1769_fail:
    goto rx1764_fail
  rxcap_1769_done:
  # rx subrule "O" subtype=capture negate=
    rx1764_cur."!cursor_pos"(rx1764_pos)
    $P10 = rx1764_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1764_fail
    rx1764_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1764_pos = $P10."pos"()
  # rx pass
    rx1764_cur."!cursor_pass"(rx1764_pos, "infix:sym<>>")
    if_null rx1764_debug, debug_1312
    rx1764_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1764_pos)
  debug_1312:
    .return (rx1764_cur)
  rx1764_restart:
.annotate 'line', 10
    if_null rx1764_debug, debug_1313
    rx1764_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1313:
  rx1764_fail:
    (rx1764_rep, rx1764_pos, $I10, $P10) = rx1764_cur."!mark_fail"(0)
    lt rx1764_pos, -1, rx1764_done
    eq rx1764_pos, -1, rx1764_fail
    jump $I10
  rx1764_done:
    rx1764_cur."!cursor_fail"()
    if_null rx1764_debug, debug_1314
    rx1764_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1314:
    .return (rx1764_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("338_1303739803.72") :method
.annotate 'line', 10
    $P1766 = self."!PREFIX__!subrule"("O", ">")
    new $P1767, "ResizablePMCArray"
    push $P1767, $P1766
    .return ($P1767)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("339_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1771_tgt
    .local int rx1771_pos
    .local int rx1771_off
    .local int rx1771_eos
    .local int rx1771_rep
    .local pmc rx1771_cur
    .local pmc rx1771_debug
    (rx1771_cur, rx1771_pos, rx1771_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1771_cur
    .local pmc match
    .lex "$/", match
    length rx1771_eos, rx1771_tgt
    gt rx1771_pos, rx1771_eos, rx1771_done
    set rx1771_off, 0
    lt rx1771_pos, 2, rx1771_start
    sub rx1771_off, rx1771_pos, 1
    substr rx1771_tgt, rx1771_tgt, rx1771_off
  rx1771_start:
    eq $I10, 1, rx1771_restart
    if_null rx1771_debug, debug_1315
    rx1771_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1315:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1775_done
    goto rxscan1775_scan
  rxscan1775_loop:
    (rx1771_pos) = rx1771_cur."from"()
    inc rx1771_pos
    rx1771_cur."!cursor_from"(rx1771_pos)
    ge rx1771_pos, rx1771_eos, rxscan1775_done
  rxscan1775_scan:
    set_addr $I10, rxscan1775_loop
    rx1771_cur."!mark_push"(0, rx1771_pos, $I10)
  rxscan1775_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1776_fail
    rx1771_cur."!mark_push"(0, rx1771_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1771_pos, 2
    gt $I11, rx1771_eos, rx1771_fail
    sub $I11, rx1771_pos, rx1771_off
    substr $S10, rx1771_tgt, $I11, 2
    ne $S10, "eq", rx1771_fail
    add rx1771_pos, 2
    set_addr $I10, rxcap_1776_fail
    ($I12, $I11) = rx1771_cur."!mark_peek"($I10)
    rx1771_cur."!cursor_pos"($I11)
    ($P10) = rx1771_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1771_pos, "")
    rx1771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1776_done
  rxcap_1776_fail:
    goto rx1771_fail
  rxcap_1776_done:
  # rx subrule "O" subtype=capture negate=
    rx1771_cur."!cursor_pos"(rx1771_pos)
    $P10 = rx1771_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1771_fail
    rx1771_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1771_pos = $P10."pos"()
  # rx pass
    rx1771_cur."!cursor_pass"(rx1771_pos, "infix:sym<eq>")
    if_null rx1771_debug, debug_1316
    rx1771_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1771_pos)
  debug_1316:
    .return (rx1771_cur)
  rx1771_restart:
.annotate 'line', 10
    if_null rx1771_debug, debug_1317
    rx1771_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1317:
  rx1771_fail:
    (rx1771_rep, rx1771_pos, $I10, $P10) = rx1771_cur."!mark_fail"(0)
    lt rx1771_pos, -1, rx1771_done
    eq rx1771_pos, -1, rx1771_fail
    jump $I10
  rx1771_done:
    rx1771_cur."!cursor_fail"()
    if_null rx1771_debug, debug_1318
    rx1771_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1318:
    .return (rx1771_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("340_1303739803.72") :method
.annotate 'line', 10
    $P1773 = self."!PREFIX__!subrule"("O", "eq")
    new $P1774, "ResizablePMCArray"
    push $P1774, $P1773
    .return ($P1774)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("341_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1778_tgt
    .local int rx1778_pos
    .local int rx1778_off
    .local int rx1778_eos
    .local int rx1778_rep
    .local pmc rx1778_cur
    .local pmc rx1778_debug
    (rx1778_cur, rx1778_pos, rx1778_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1778_cur
    .local pmc match
    .lex "$/", match
    length rx1778_eos, rx1778_tgt
    gt rx1778_pos, rx1778_eos, rx1778_done
    set rx1778_off, 0
    lt rx1778_pos, 2, rx1778_start
    sub rx1778_off, rx1778_pos, 1
    substr rx1778_tgt, rx1778_tgt, rx1778_off
  rx1778_start:
    eq $I10, 1, rx1778_restart
    if_null rx1778_debug, debug_1319
    rx1778_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1319:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1782_done
    goto rxscan1782_scan
  rxscan1782_loop:
    (rx1778_pos) = rx1778_cur."from"()
    inc rx1778_pos
    rx1778_cur."!cursor_from"(rx1778_pos)
    ge rx1778_pos, rx1778_eos, rxscan1782_done
  rxscan1782_scan:
    set_addr $I10, rxscan1782_loop
    rx1778_cur."!mark_push"(0, rx1778_pos, $I10)
  rxscan1782_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1783_fail
    rx1778_cur."!mark_push"(0, rx1778_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1778_pos, 2
    gt $I11, rx1778_eos, rx1778_fail
    sub $I11, rx1778_pos, rx1778_off
    substr $S10, rx1778_tgt, $I11, 2
    ne $S10, "ne", rx1778_fail
    add rx1778_pos, 2
    set_addr $I10, rxcap_1783_fail
    ($I12, $I11) = rx1778_cur."!mark_peek"($I10)
    rx1778_cur."!cursor_pos"($I11)
    ($P10) = rx1778_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1778_pos, "")
    rx1778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1783_done
  rxcap_1783_fail:
    goto rx1778_fail
  rxcap_1783_done:
  # rx subrule "O" subtype=capture negate=
    rx1778_cur."!cursor_pos"(rx1778_pos)
    $P10 = rx1778_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1778_fail
    rx1778_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1778_pos = $P10."pos"()
  # rx pass
    rx1778_cur."!cursor_pass"(rx1778_pos, "infix:sym<ne>")
    if_null rx1778_debug, debug_1320
    rx1778_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1778_pos)
  debug_1320:
    .return (rx1778_cur)
  rx1778_restart:
.annotate 'line', 10
    if_null rx1778_debug, debug_1321
    rx1778_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1321:
  rx1778_fail:
    (rx1778_rep, rx1778_pos, $I10, $P10) = rx1778_cur."!mark_fail"(0)
    lt rx1778_pos, -1, rx1778_done
    eq rx1778_pos, -1, rx1778_fail
    jump $I10
  rx1778_done:
    rx1778_cur."!cursor_fail"()
    if_null rx1778_debug, debug_1322
    rx1778_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1322:
    .return (rx1778_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("342_1303739803.72") :method
.annotate 'line', 10
    $P1780 = self."!PREFIX__!subrule"("O", "ne")
    new $P1781, "ResizablePMCArray"
    push $P1781, $P1780
    .return ($P1781)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("343_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1785_tgt
    .local int rx1785_pos
    .local int rx1785_off
    .local int rx1785_eos
    .local int rx1785_rep
    .local pmc rx1785_cur
    .local pmc rx1785_debug
    (rx1785_cur, rx1785_pos, rx1785_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1785_cur
    .local pmc match
    .lex "$/", match
    length rx1785_eos, rx1785_tgt
    gt rx1785_pos, rx1785_eos, rx1785_done
    set rx1785_off, 0
    lt rx1785_pos, 2, rx1785_start
    sub rx1785_off, rx1785_pos, 1
    substr rx1785_tgt, rx1785_tgt, rx1785_off
  rx1785_start:
    eq $I10, 1, rx1785_restart
    if_null rx1785_debug, debug_1323
    rx1785_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1323:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1789_done
    goto rxscan1789_scan
  rxscan1789_loop:
    (rx1785_pos) = rx1785_cur."from"()
    inc rx1785_pos
    rx1785_cur."!cursor_from"(rx1785_pos)
    ge rx1785_pos, rx1785_eos, rxscan1789_done
  rxscan1789_scan:
    set_addr $I10, rxscan1789_loop
    rx1785_cur."!mark_push"(0, rx1785_pos, $I10)
  rxscan1789_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1790_fail
    rx1785_cur."!mark_push"(0, rx1785_pos, $I10)
  # rx literal  "le"
    add $I11, rx1785_pos, 2
    gt $I11, rx1785_eos, rx1785_fail
    sub $I11, rx1785_pos, rx1785_off
    substr $S10, rx1785_tgt, $I11, 2
    ne $S10, "le", rx1785_fail
    add rx1785_pos, 2
    set_addr $I10, rxcap_1790_fail
    ($I12, $I11) = rx1785_cur."!mark_peek"($I10)
    rx1785_cur."!cursor_pos"($I11)
    ($P10) = rx1785_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1785_pos, "")
    rx1785_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1790_done
  rxcap_1790_fail:
    goto rx1785_fail
  rxcap_1790_done:
  # rx subrule "O" subtype=capture negate=
    rx1785_cur."!cursor_pos"(rx1785_pos)
    $P10 = rx1785_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1785_fail
    rx1785_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1785_pos = $P10."pos"()
  # rx pass
    rx1785_cur."!cursor_pass"(rx1785_pos, "infix:sym<le>")
    if_null rx1785_debug, debug_1324
    rx1785_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1785_pos)
  debug_1324:
    .return (rx1785_cur)
  rx1785_restart:
.annotate 'line', 10
    if_null rx1785_debug, debug_1325
    rx1785_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1325:
  rx1785_fail:
    (rx1785_rep, rx1785_pos, $I10, $P10) = rx1785_cur."!mark_fail"(0)
    lt rx1785_pos, -1, rx1785_done
    eq rx1785_pos, -1, rx1785_fail
    jump $I10
  rx1785_done:
    rx1785_cur."!cursor_fail"()
    if_null rx1785_debug, debug_1326
    rx1785_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1326:
    .return (rx1785_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("344_1303739803.72") :method
.annotate 'line', 10
    $P1787 = self."!PREFIX__!subrule"("O", "le")
    new $P1788, "ResizablePMCArray"
    push $P1788, $P1787
    .return ($P1788)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("345_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1792_tgt
    .local int rx1792_pos
    .local int rx1792_off
    .local int rx1792_eos
    .local int rx1792_rep
    .local pmc rx1792_cur
    .local pmc rx1792_debug
    (rx1792_cur, rx1792_pos, rx1792_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1792_cur
    .local pmc match
    .lex "$/", match
    length rx1792_eos, rx1792_tgt
    gt rx1792_pos, rx1792_eos, rx1792_done
    set rx1792_off, 0
    lt rx1792_pos, 2, rx1792_start
    sub rx1792_off, rx1792_pos, 1
    substr rx1792_tgt, rx1792_tgt, rx1792_off
  rx1792_start:
    eq $I10, 1, rx1792_restart
    if_null rx1792_debug, debug_1327
    rx1792_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1327:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1796_done
    goto rxscan1796_scan
  rxscan1796_loop:
    (rx1792_pos) = rx1792_cur."from"()
    inc rx1792_pos
    rx1792_cur."!cursor_from"(rx1792_pos)
    ge rx1792_pos, rx1792_eos, rxscan1796_done
  rxscan1796_scan:
    set_addr $I10, rxscan1796_loop
    rx1792_cur."!mark_push"(0, rx1792_pos, $I10)
  rxscan1796_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1797_fail
    rx1792_cur."!mark_push"(0, rx1792_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1792_pos, 2
    gt $I11, rx1792_eos, rx1792_fail
    sub $I11, rx1792_pos, rx1792_off
    substr $S10, rx1792_tgt, $I11, 2
    ne $S10, "ge", rx1792_fail
    add rx1792_pos, 2
    set_addr $I10, rxcap_1797_fail
    ($I12, $I11) = rx1792_cur."!mark_peek"($I10)
    rx1792_cur."!cursor_pos"($I11)
    ($P10) = rx1792_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1792_pos, "")
    rx1792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1797_done
  rxcap_1797_fail:
    goto rx1792_fail
  rxcap_1797_done:
  # rx subrule "O" subtype=capture negate=
    rx1792_cur."!cursor_pos"(rx1792_pos)
    $P10 = rx1792_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1792_fail
    rx1792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1792_pos = $P10."pos"()
  # rx pass
    rx1792_cur."!cursor_pass"(rx1792_pos, "infix:sym<ge>")
    if_null rx1792_debug, debug_1328
    rx1792_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1792_pos)
  debug_1328:
    .return (rx1792_cur)
  rx1792_restart:
.annotate 'line', 10
    if_null rx1792_debug, debug_1329
    rx1792_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1329:
  rx1792_fail:
    (rx1792_rep, rx1792_pos, $I10, $P10) = rx1792_cur."!mark_fail"(0)
    lt rx1792_pos, -1, rx1792_done
    eq rx1792_pos, -1, rx1792_fail
    jump $I10
  rx1792_done:
    rx1792_cur."!cursor_fail"()
    if_null rx1792_debug, debug_1330
    rx1792_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1330:
    .return (rx1792_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("346_1303739803.72") :method
.annotate 'line', 10
    $P1794 = self."!PREFIX__!subrule"("O", "ge")
    new $P1795, "ResizablePMCArray"
    push $P1795, $P1794
    .return ($P1795)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("347_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1799_tgt
    .local int rx1799_pos
    .local int rx1799_off
    .local int rx1799_eos
    .local int rx1799_rep
    .local pmc rx1799_cur
    .local pmc rx1799_debug
    (rx1799_cur, rx1799_pos, rx1799_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1799_cur
    .local pmc match
    .lex "$/", match
    length rx1799_eos, rx1799_tgt
    gt rx1799_pos, rx1799_eos, rx1799_done
    set rx1799_off, 0
    lt rx1799_pos, 2, rx1799_start
    sub rx1799_off, rx1799_pos, 1
    substr rx1799_tgt, rx1799_tgt, rx1799_off
  rx1799_start:
    eq $I10, 1, rx1799_restart
    if_null rx1799_debug, debug_1331
    rx1799_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1331:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1803_done
    goto rxscan1803_scan
  rxscan1803_loop:
    (rx1799_pos) = rx1799_cur."from"()
    inc rx1799_pos
    rx1799_cur."!cursor_from"(rx1799_pos)
    ge rx1799_pos, rx1799_eos, rxscan1803_done
  rxscan1803_scan:
    set_addr $I10, rxscan1803_loop
    rx1799_cur."!mark_push"(0, rx1799_pos, $I10)
  rxscan1803_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1804_fail
    rx1799_cur."!mark_push"(0, rx1799_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1799_pos, 2
    gt $I11, rx1799_eos, rx1799_fail
    sub $I11, rx1799_pos, rx1799_off
    substr $S10, rx1799_tgt, $I11, 2
    ne $S10, "lt", rx1799_fail
    add rx1799_pos, 2
    set_addr $I10, rxcap_1804_fail
    ($I12, $I11) = rx1799_cur."!mark_peek"($I10)
    rx1799_cur."!cursor_pos"($I11)
    ($P10) = rx1799_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1799_pos, "")
    rx1799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1804_done
  rxcap_1804_fail:
    goto rx1799_fail
  rxcap_1804_done:
  # rx subrule "O" subtype=capture negate=
    rx1799_cur."!cursor_pos"(rx1799_pos)
    $P10 = rx1799_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1799_fail
    rx1799_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1799_pos = $P10."pos"()
  # rx pass
    rx1799_cur."!cursor_pass"(rx1799_pos, "infix:sym<lt>")
    if_null rx1799_debug, debug_1332
    rx1799_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1799_pos)
  debug_1332:
    .return (rx1799_cur)
  rx1799_restart:
.annotate 'line', 10
    if_null rx1799_debug, debug_1333
    rx1799_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1333:
  rx1799_fail:
    (rx1799_rep, rx1799_pos, $I10, $P10) = rx1799_cur."!mark_fail"(0)
    lt rx1799_pos, -1, rx1799_done
    eq rx1799_pos, -1, rx1799_fail
    jump $I10
  rx1799_done:
    rx1799_cur."!cursor_fail"()
    if_null rx1799_debug, debug_1334
    rx1799_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1334:
    .return (rx1799_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("348_1303739803.72") :method
.annotate 'line', 10
    $P1801 = self."!PREFIX__!subrule"("O", "lt")
    new $P1802, "ResizablePMCArray"
    push $P1802, $P1801
    .return ($P1802)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("349_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1806_tgt
    .local int rx1806_pos
    .local int rx1806_off
    .local int rx1806_eos
    .local int rx1806_rep
    .local pmc rx1806_cur
    .local pmc rx1806_debug
    (rx1806_cur, rx1806_pos, rx1806_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1806_cur
    .local pmc match
    .lex "$/", match
    length rx1806_eos, rx1806_tgt
    gt rx1806_pos, rx1806_eos, rx1806_done
    set rx1806_off, 0
    lt rx1806_pos, 2, rx1806_start
    sub rx1806_off, rx1806_pos, 1
    substr rx1806_tgt, rx1806_tgt, rx1806_off
  rx1806_start:
    eq $I10, 1, rx1806_restart
    if_null rx1806_debug, debug_1335
    rx1806_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1335:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1810_done
    goto rxscan1810_scan
  rxscan1810_loop:
    (rx1806_pos) = rx1806_cur."from"()
    inc rx1806_pos
    rx1806_cur."!cursor_from"(rx1806_pos)
    ge rx1806_pos, rx1806_eos, rxscan1810_done
  rxscan1810_scan:
    set_addr $I10, rxscan1810_loop
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  rxscan1810_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1811_fail
    rx1806_cur."!mark_push"(0, rx1806_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1806_pos, 2
    gt $I11, rx1806_eos, rx1806_fail
    sub $I11, rx1806_pos, rx1806_off
    substr $S10, rx1806_tgt, $I11, 2
    ne $S10, "gt", rx1806_fail
    add rx1806_pos, 2
    set_addr $I10, rxcap_1811_fail
    ($I12, $I11) = rx1806_cur."!mark_peek"($I10)
    rx1806_cur."!cursor_pos"($I11)
    ($P10) = rx1806_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1806_pos, "")
    rx1806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1811_done
  rxcap_1811_fail:
    goto rx1806_fail
  rxcap_1811_done:
  # rx subrule "O" subtype=capture negate=
    rx1806_cur."!cursor_pos"(rx1806_pos)
    $P10 = rx1806_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1806_fail
    rx1806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1806_pos = $P10."pos"()
  # rx pass
    rx1806_cur."!cursor_pass"(rx1806_pos, "infix:sym<gt>")
    if_null rx1806_debug, debug_1336
    rx1806_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1806_pos)
  debug_1336:
    .return (rx1806_cur)
  rx1806_restart:
.annotate 'line', 10
    if_null rx1806_debug, debug_1337
    rx1806_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1337:
  rx1806_fail:
    (rx1806_rep, rx1806_pos, $I10, $P10) = rx1806_cur."!mark_fail"(0)
    lt rx1806_pos, -1, rx1806_done
    eq rx1806_pos, -1, rx1806_fail
    jump $I10
  rx1806_done:
    rx1806_cur."!cursor_fail"()
    if_null rx1806_debug, debug_1338
    rx1806_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1338:
    .return (rx1806_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("350_1303739803.72") :method
.annotate 'line', 10
    $P1808 = self."!PREFIX__!subrule"("O", "gt")
    new $P1809, "ResizablePMCArray"
    push $P1809, $P1808
    .return ($P1809)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("351_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1813_tgt
    .local int rx1813_pos
    .local int rx1813_off
    .local int rx1813_eos
    .local int rx1813_rep
    .local pmc rx1813_cur
    .local pmc rx1813_debug
    (rx1813_cur, rx1813_pos, rx1813_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1813_cur
    .local pmc match
    .lex "$/", match
    length rx1813_eos, rx1813_tgt
    gt rx1813_pos, rx1813_eos, rx1813_done
    set rx1813_off, 0
    lt rx1813_pos, 2, rx1813_start
    sub rx1813_off, rx1813_pos, 1
    substr rx1813_tgt, rx1813_tgt, rx1813_off
  rx1813_start:
    eq $I10, 1, rx1813_restart
    if_null rx1813_debug, debug_1339
    rx1813_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1339:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1817_done
    goto rxscan1817_scan
  rxscan1817_loop:
    (rx1813_pos) = rx1813_cur."from"()
    inc rx1813_pos
    rx1813_cur."!cursor_from"(rx1813_pos)
    ge rx1813_pos, rx1813_eos, rxscan1817_done
  rxscan1817_scan:
    set_addr $I10, rxscan1817_loop
    rx1813_cur."!mark_push"(0, rx1813_pos, $I10)
  rxscan1817_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1818_fail
    rx1813_cur."!mark_push"(0, rx1813_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1813_pos, 3
    gt $I11, rx1813_eos, rx1813_fail
    sub $I11, rx1813_pos, rx1813_off
    substr $S10, rx1813_tgt, $I11, 3
    ne $S10, "=:=", rx1813_fail
    add rx1813_pos, 3
    set_addr $I10, rxcap_1818_fail
    ($I12, $I11) = rx1813_cur."!mark_peek"($I10)
    rx1813_cur."!cursor_pos"($I11)
    ($P10) = rx1813_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1813_pos, "")
    rx1813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1818_done
  rxcap_1818_fail:
    goto rx1813_fail
  rxcap_1818_done:
  # rx subrule "O" subtype=capture negate=
    rx1813_cur."!cursor_pos"(rx1813_pos)
    $P10 = rx1813_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1813_fail
    rx1813_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1813_pos = $P10."pos"()
  # rx pass
    rx1813_cur."!cursor_pass"(rx1813_pos, "infix:sym<=:=>")
    if_null rx1813_debug, debug_1340
    rx1813_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1813_pos)
  debug_1340:
    .return (rx1813_cur)
  rx1813_restart:
.annotate 'line', 10
    if_null rx1813_debug, debug_1341
    rx1813_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1341:
  rx1813_fail:
    (rx1813_rep, rx1813_pos, $I10, $P10) = rx1813_cur."!mark_fail"(0)
    lt rx1813_pos, -1, rx1813_done
    eq rx1813_pos, -1, rx1813_fail
    jump $I10
  rx1813_done:
    rx1813_cur."!cursor_fail"()
    if_null rx1813_debug, debug_1342
    rx1813_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1342:
    .return (rx1813_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("352_1303739803.72") :method
.annotate 'line', 10
    $P1815 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1816, "ResizablePMCArray"
    push $P1816, $P1815
    .return ($P1816)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("353_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1820_tgt
    .local int rx1820_pos
    .local int rx1820_off
    .local int rx1820_eos
    .local int rx1820_rep
    .local pmc rx1820_cur
    .local pmc rx1820_debug
    (rx1820_cur, rx1820_pos, rx1820_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1820_cur
    .local pmc match
    .lex "$/", match
    length rx1820_eos, rx1820_tgt
    gt rx1820_pos, rx1820_eos, rx1820_done
    set rx1820_off, 0
    lt rx1820_pos, 2, rx1820_start
    sub rx1820_off, rx1820_pos, 1
    substr rx1820_tgt, rx1820_tgt, rx1820_off
  rx1820_start:
    eq $I10, 1, rx1820_restart
    if_null rx1820_debug, debug_1343
    rx1820_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1343:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1824_done
    goto rxscan1824_scan
  rxscan1824_loop:
    (rx1820_pos) = rx1820_cur."from"()
    inc rx1820_pos
    rx1820_cur."!cursor_from"(rx1820_pos)
    ge rx1820_pos, rx1820_eos, rxscan1824_done
  rxscan1824_scan:
    set_addr $I10, rxscan1824_loop
    rx1820_cur."!mark_push"(0, rx1820_pos, $I10)
  rxscan1824_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1825_fail
    rx1820_cur."!mark_push"(0, rx1820_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1820_pos, 2
    gt $I11, rx1820_eos, rx1820_fail
    sub $I11, rx1820_pos, rx1820_off
    substr $S10, rx1820_tgt, $I11, 2
    ne $S10, "~~", rx1820_fail
    add rx1820_pos, 2
    set_addr $I10, rxcap_1825_fail
    ($I12, $I11) = rx1820_cur."!mark_peek"($I10)
    rx1820_cur."!cursor_pos"($I11)
    ($P10) = rx1820_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1820_pos, "")
    rx1820_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1825_done
  rxcap_1825_fail:
    goto rx1820_fail
  rxcap_1825_done:
  # rx subrule "O" subtype=capture negate=
    rx1820_cur."!cursor_pos"(rx1820_pos)
    $P10 = rx1820_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1820_fail
    rx1820_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1820_pos = $P10."pos"()
  # rx pass
    rx1820_cur."!cursor_pass"(rx1820_pos, "infix:sym<~~>")
    if_null rx1820_debug, debug_1344
    rx1820_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1820_pos)
  debug_1344:
    .return (rx1820_cur)
  rx1820_restart:
.annotate 'line', 10
    if_null rx1820_debug, debug_1345
    rx1820_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1345:
  rx1820_fail:
    (rx1820_rep, rx1820_pos, $I10, $P10) = rx1820_cur."!mark_fail"(0)
    lt rx1820_pos, -1, rx1820_done
    eq rx1820_pos, -1, rx1820_fail
    jump $I10
  rx1820_done:
    rx1820_cur."!cursor_fail"()
    if_null rx1820_debug, debug_1346
    rx1820_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1346:
    .return (rx1820_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("354_1303739803.72") :method
.annotate 'line', 10
    $P1822 = self."!PREFIX__!subrule"("O", "~~")
    new $P1823, "ResizablePMCArray"
    push $P1823, $P1822
    .return ($P1823)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("355_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1827_tgt
    .local int rx1827_pos
    .local int rx1827_off
    .local int rx1827_eos
    .local int rx1827_rep
    .local pmc rx1827_cur
    .local pmc rx1827_debug
    (rx1827_cur, rx1827_pos, rx1827_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1827_cur
    .local pmc match
    .lex "$/", match
    length rx1827_eos, rx1827_tgt
    gt rx1827_pos, rx1827_eos, rx1827_done
    set rx1827_off, 0
    lt rx1827_pos, 2, rx1827_start
    sub rx1827_off, rx1827_pos, 1
    substr rx1827_tgt, rx1827_tgt, rx1827_off
  rx1827_start:
    eq $I10, 1, rx1827_restart
    if_null rx1827_debug, debug_1347
    rx1827_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1347:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1831_done
    goto rxscan1831_scan
  rxscan1831_loop:
    (rx1827_pos) = rx1827_cur."from"()
    inc rx1827_pos
    rx1827_cur."!cursor_from"(rx1827_pos)
    ge rx1827_pos, rx1827_eos, rxscan1831_done
  rxscan1831_scan:
    set_addr $I10, rxscan1831_loop
    rx1827_cur."!mark_push"(0, rx1827_pos, $I10)
  rxscan1831_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1832_fail
    rx1827_cur."!mark_push"(0, rx1827_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1827_pos, 2
    gt $I11, rx1827_eos, rx1827_fail
    sub $I11, rx1827_pos, rx1827_off
    substr $S10, rx1827_tgt, $I11, 2
    ne $S10, "&&", rx1827_fail
    add rx1827_pos, 2
    set_addr $I10, rxcap_1832_fail
    ($I12, $I11) = rx1827_cur."!mark_peek"($I10)
    rx1827_cur."!cursor_pos"($I11)
    ($P10) = rx1827_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1827_pos, "")
    rx1827_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1832_done
  rxcap_1832_fail:
    goto rx1827_fail
  rxcap_1832_done:
  # rx subrule "O" subtype=capture negate=
    rx1827_cur."!cursor_pos"(rx1827_pos)
    $P10 = rx1827_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1827_fail
    rx1827_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1827_pos = $P10."pos"()
  # rx pass
    rx1827_cur."!cursor_pass"(rx1827_pos, "infix:sym<&&>")
    if_null rx1827_debug, debug_1348
    rx1827_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1827_pos)
  debug_1348:
    .return (rx1827_cur)
  rx1827_restart:
.annotate 'line', 10
    if_null rx1827_debug, debug_1349
    rx1827_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1349:
  rx1827_fail:
    (rx1827_rep, rx1827_pos, $I10, $P10) = rx1827_cur."!mark_fail"(0)
    lt rx1827_pos, -1, rx1827_done
    eq rx1827_pos, -1, rx1827_fail
    jump $I10
  rx1827_done:
    rx1827_cur."!cursor_fail"()
    if_null rx1827_debug, debug_1350
    rx1827_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1350:
    .return (rx1827_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("356_1303739803.72") :method
.annotate 'line', 10
    $P1829 = self."!PREFIX__!subrule"("O", "&&")
    new $P1830, "ResizablePMCArray"
    push $P1830, $P1829
    .return ($P1830)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("357_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1834_tgt
    .local int rx1834_pos
    .local int rx1834_off
    .local int rx1834_eos
    .local int rx1834_rep
    .local pmc rx1834_cur
    .local pmc rx1834_debug
    (rx1834_cur, rx1834_pos, rx1834_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1834_cur
    .local pmc match
    .lex "$/", match
    length rx1834_eos, rx1834_tgt
    gt rx1834_pos, rx1834_eos, rx1834_done
    set rx1834_off, 0
    lt rx1834_pos, 2, rx1834_start
    sub rx1834_off, rx1834_pos, 1
    substr rx1834_tgt, rx1834_tgt, rx1834_off
  rx1834_start:
    eq $I10, 1, rx1834_restart
    if_null rx1834_debug, debug_1351
    rx1834_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1351:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1838_done
    goto rxscan1838_scan
  rxscan1838_loop:
    (rx1834_pos) = rx1834_cur."from"()
    inc rx1834_pos
    rx1834_cur."!cursor_from"(rx1834_pos)
    ge rx1834_pos, rx1834_eos, rxscan1838_done
  rxscan1838_scan:
    set_addr $I10, rxscan1838_loop
    rx1834_cur."!mark_push"(0, rx1834_pos, $I10)
  rxscan1838_done:
.annotate 'line', 693
  # rx subcapture "sym"
    set_addr $I10, rxcap_1839_fail
    rx1834_cur."!mark_push"(0, rx1834_pos, $I10)
  # rx literal  "||"
    add $I11, rx1834_pos, 2
    gt $I11, rx1834_eos, rx1834_fail
    sub $I11, rx1834_pos, rx1834_off
    substr $S10, rx1834_tgt, $I11, 2
    ne $S10, "||", rx1834_fail
    add rx1834_pos, 2
    set_addr $I10, rxcap_1839_fail
    ($I12, $I11) = rx1834_cur."!mark_peek"($I10)
    rx1834_cur."!cursor_pos"($I11)
    ($P10) = rx1834_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1834_pos, "")
    rx1834_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1839_done
  rxcap_1839_fail:
    goto rx1834_fail
  rxcap_1839_done:
  # rx subrule "O" subtype=capture negate=
    rx1834_cur."!cursor_pos"(rx1834_pos)
    $P10 = rx1834_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1834_fail
    rx1834_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1834_pos = $P10."pos"()
  # rx pass
    rx1834_cur."!cursor_pass"(rx1834_pos, "infix:sym<||>")
    if_null rx1834_debug, debug_1352
    rx1834_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1834_pos)
  debug_1352:
    .return (rx1834_cur)
  rx1834_restart:
.annotate 'line', 10
    if_null rx1834_debug, debug_1353
    rx1834_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1353:
  rx1834_fail:
    (rx1834_rep, rx1834_pos, $I10, $P10) = rx1834_cur."!mark_fail"(0)
    lt rx1834_pos, -1, rx1834_done
    eq rx1834_pos, -1, rx1834_fail
    jump $I10
  rx1834_done:
    rx1834_cur."!cursor_fail"()
    if_null rx1834_debug, debug_1354
    rx1834_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1354:
    .return (rx1834_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("358_1303739803.72") :method
.annotate 'line', 10
    $P1836 = self."!PREFIX__!subrule"("O", "||")
    new $P1837, "ResizablePMCArray"
    push $P1837, $P1836
    .return ($P1837)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("359_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1841_tgt
    .local int rx1841_pos
    .local int rx1841_off
    .local int rx1841_eos
    .local int rx1841_rep
    .local pmc rx1841_cur
    .local pmc rx1841_debug
    (rx1841_cur, rx1841_pos, rx1841_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1841_cur
    .local pmc match
    .lex "$/", match
    length rx1841_eos, rx1841_tgt
    gt rx1841_pos, rx1841_eos, rx1841_done
    set rx1841_off, 0
    lt rx1841_pos, 2, rx1841_start
    sub rx1841_off, rx1841_pos, 1
    substr rx1841_tgt, rx1841_tgt, rx1841_off
  rx1841_start:
    eq $I10, 1, rx1841_restart
    if_null rx1841_debug, debug_1355
    rx1841_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1355:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1845_done
    goto rxscan1845_scan
  rxscan1845_loop:
    (rx1841_pos) = rx1841_cur."from"()
    inc rx1841_pos
    rx1841_cur."!cursor_from"(rx1841_pos)
    ge rx1841_pos, rx1841_eos, rxscan1845_done
  rxscan1845_scan:
    set_addr $I10, rxscan1845_loop
    rx1841_cur."!mark_push"(0, rx1841_pos, $I10)
  rxscan1845_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1846_fail
    rx1841_cur."!mark_push"(0, rx1841_pos, $I10)
  # rx literal  "//"
    add $I11, rx1841_pos, 2
    gt $I11, rx1841_eos, rx1841_fail
    sub $I11, rx1841_pos, rx1841_off
    substr $S10, rx1841_tgt, $I11, 2
    ne $S10, "//", rx1841_fail
    add rx1841_pos, 2
    set_addr $I10, rxcap_1846_fail
    ($I12, $I11) = rx1841_cur."!mark_peek"($I10)
    rx1841_cur."!cursor_pos"($I11)
    ($P10) = rx1841_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1841_pos, "")
    rx1841_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1846_done
  rxcap_1846_fail:
    goto rx1841_fail
  rxcap_1846_done:
  # rx subrule "O" subtype=capture negate=
    rx1841_cur."!cursor_pos"(rx1841_pos)
    $P10 = rx1841_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1841_fail
    rx1841_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1841_pos = $P10."pos"()
  # rx pass
    rx1841_cur."!cursor_pass"(rx1841_pos, "infix:sym<//>")
    if_null rx1841_debug, debug_1356
    rx1841_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1841_pos)
  debug_1356:
    .return (rx1841_cur)
  rx1841_restart:
.annotate 'line', 10
    if_null rx1841_debug, debug_1357
    rx1841_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1357:
  rx1841_fail:
    (rx1841_rep, rx1841_pos, $I10, $P10) = rx1841_cur."!mark_fail"(0)
    lt rx1841_pos, -1, rx1841_done
    eq rx1841_pos, -1, rx1841_fail
    jump $I10
  rx1841_done:
    rx1841_cur."!cursor_fail"()
    if_null rx1841_debug, debug_1358
    rx1841_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1358:
    .return (rx1841_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("360_1303739803.72") :method
.annotate 'line', 10
    $P1843 = self."!PREFIX__!subrule"("O", "//")
    new $P1844, "ResizablePMCArray"
    push $P1844, $P1843
    .return ($P1844)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("361_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1848_tgt
    .local int rx1848_pos
    .local int rx1848_off
    .local int rx1848_eos
    .local int rx1848_rep
    .local pmc rx1848_cur
    .local pmc rx1848_debug
    (rx1848_cur, rx1848_pos, rx1848_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1848_cur
    .local pmc match
    .lex "$/", match
    length rx1848_eos, rx1848_tgt
    gt rx1848_pos, rx1848_eos, rx1848_done
    set rx1848_off, 0
    lt rx1848_pos, 2, rx1848_start
    sub rx1848_off, rx1848_pos, 1
    substr rx1848_tgt, rx1848_tgt, rx1848_off
  rx1848_start:
    eq $I10, 1, rx1848_restart
    if_null rx1848_debug, debug_1359
    rx1848_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1359:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1852_done
    goto rxscan1852_scan
  rxscan1852_loop:
    (rx1848_pos) = rx1848_cur."from"()
    inc rx1848_pos
    rx1848_cur."!cursor_from"(rx1848_pos)
    ge rx1848_pos, rx1848_eos, rxscan1852_done
  rxscan1852_scan:
    set_addr $I10, rxscan1852_loop
    rx1848_cur."!mark_push"(0, rx1848_pos, $I10)
  rxscan1852_done:
.annotate 'line', 697
  # rx literal  "??"
    add $I11, rx1848_pos, 2
    gt $I11, rx1848_eos, rx1848_fail
    sub $I11, rx1848_pos, rx1848_off
    substr $S10, rx1848_tgt, $I11, 2
    ne $S10, "??", rx1848_fail
    add rx1848_pos, 2
.annotate 'line', 698
  # rx subrule "ws" subtype=method negate=
    rx1848_cur."!cursor_pos"(rx1848_pos)
    $P10 = rx1848_cur."ws"()
    unless $P10, rx1848_fail
    rx1848_pos = $P10."pos"()
.annotate 'line', 699
  # rx subrule "EXPR" subtype=capture negate=
    rx1848_cur."!cursor_pos"(rx1848_pos)
    $P10 = rx1848_cur."EXPR"("i=")
    unless $P10, rx1848_fail
    rx1848_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1848_pos = $P10."pos"()
.annotate 'line', 700
  # rx literal  "!!"
    add $I11, rx1848_pos, 2
    gt $I11, rx1848_eos, rx1848_fail
    sub $I11, rx1848_pos, rx1848_off
    substr $S10, rx1848_tgt, $I11, 2
    ne $S10, "!!", rx1848_fail
    add rx1848_pos, 2
.annotate 'line', 701
  # rx subrule "O" subtype=capture negate=
    rx1848_cur."!cursor_pos"(rx1848_pos)
    $P10 = rx1848_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1848_fail
    rx1848_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1848_pos = $P10."pos"()
.annotate 'line', 696
  # rx pass
    rx1848_cur."!cursor_pass"(rx1848_pos, "infix:sym<?? !!>")
    if_null rx1848_debug, debug_1360
    rx1848_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1848_pos)
  debug_1360:
    .return (rx1848_cur)
  rx1848_restart:
.annotate 'line', 10
    if_null rx1848_debug, debug_1361
    rx1848_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1361:
  rx1848_fail:
    (rx1848_rep, rx1848_pos, $I10, $P10) = rx1848_cur."!mark_fail"(0)
    lt rx1848_pos, -1, rx1848_done
    eq rx1848_pos, -1, rx1848_fail
    jump $I10
  rx1848_done:
    rx1848_cur."!cursor_fail"()
    if_null rx1848_debug, debug_1362
    rx1848_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1362:
    .return (rx1848_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("362_1303739803.72") :method
.annotate 'line', 10
    $P1850 = self."!PREFIX__!subrule"("ws", "??")
    new $P1851, "ResizablePMCArray"
    push $P1851, $P1850
    .return ($P1851)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("363_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1854_tgt
    .local int rx1854_pos
    .local int rx1854_off
    .local int rx1854_eos
    .local int rx1854_rep
    .local pmc rx1854_cur
    .local pmc rx1854_debug
    (rx1854_cur, rx1854_pos, rx1854_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1854_cur
    .local pmc match
    .lex "$/", match
    length rx1854_eos, rx1854_tgt
    gt rx1854_pos, rx1854_eos, rx1854_done
    set rx1854_off, 0
    lt rx1854_pos, 2, rx1854_start
    sub rx1854_off, rx1854_pos, 1
    substr rx1854_tgt, rx1854_tgt, rx1854_off
  rx1854_start:
    eq $I10, 1, rx1854_restart
    if_null rx1854_debug, debug_1363
    rx1854_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1363:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1858_done
    goto rxscan1858_scan
  rxscan1858_loop:
    (rx1854_pos) = rx1854_cur."from"()
    inc rx1854_pos
    rx1854_cur."!cursor_from"(rx1854_pos)
    ge rx1854_pos, rx1854_eos, rxscan1858_done
  rxscan1858_scan:
    set_addr $I10, rxscan1858_loop
    rx1854_cur."!mark_push"(0, rx1854_pos, $I10)
  rxscan1858_done:
.annotate 'line', 705
  # rx subcapture "sym"
    set_addr $I10, rxcap_1859_fail
    rx1854_cur."!mark_push"(0, rx1854_pos, $I10)
  # rx literal  "="
    add $I11, rx1854_pos, 1
    gt $I11, rx1854_eos, rx1854_fail
    sub $I11, rx1854_pos, rx1854_off
    ord $I11, rx1854_tgt, $I11
    ne $I11, 61, rx1854_fail
    add rx1854_pos, 1
    set_addr $I10, rxcap_1859_fail
    ($I12, $I11) = rx1854_cur."!mark_peek"($I10)
    rx1854_cur."!cursor_pos"($I11)
    ($P10) = rx1854_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1854_pos, "")
    rx1854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1859_done
  rxcap_1859_fail:
    goto rx1854_fail
  rxcap_1859_done:
  # rx subrule "panic" subtype=method negate=
    rx1854_cur."!cursor_pos"(rx1854_pos)
    $P10 = rx1854_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1854_fail
    rx1854_pos = $P10."pos"()
.annotate 'line', 704
  # rx pass
    rx1854_cur."!cursor_pass"(rx1854_pos, "infix:sym<=>")
    if_null rx1854_debug, debug_1364
    rx1854_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1854_pos)
  debug_1364:
    .return (rx1854_cur)
  rx1854_restart:
.annotate 'line', 10
    if_null rx1854_debug, debug_1365
    rx1854_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1365:
  rx1854_fail:
    (rx1854_rep, rx1854_pos, $I10, $P10) = rx1854_cur."!mark_fail"(0)
    lt rx1854_pos, -1, rx1854_done
    eq rx1854_pos, -1, rx1854_fail
    jump $I10
  rx1854_done:
    rx1854_cur."!cursor_fail"()
    if_null rx1854_debug, debug_1366
    rx1854_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1366:
    .return (rx1854_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("364_1303739803.72") :method
.annotate 'line', 10
    $P1856 = self."!PREFIX__!subrule"("panic", "=")
    new $P1857, "ResizablePMCArray"
    push $P1857, $P1856
    .return ($P1857)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("365_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1861_tgt
    .local int rx1861_pos
    .local int rx1861_off
    .local int rx1861_eos
    .local int rx1861_rep
    .local pmc rx1861_cur
    .local pmc rx1861_debug
    (rx1861_cur, rx1861_pos, rx1861_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1861_cur
    .local pmc match
    .lex "$/", match
    length rx1861_eos, rx1861_tgt
    gt rx1861_pos, rx1861_eos, rx1861_done
    set rx1861_off, 0
    lt rx1861_pos, 2, rx1861_start
    sub rx1861_off, rx1861_pos, 1
    substr rx1861_tgt, rx1861_tgt, rx1861_off
  rx1861_start:
    eq $I10, 1, rx1861_restart
    if_null rx1861_debug, debug_1367
    rx1861_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1367:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1865_done
    goto rxscan1865_scan
  rxscan1865_loop:
    (rx1861_pos) = rx1861_cur."from"()
    inc rx1861_pos
    rx1861_cur."!cursor_from"(rx1861_pos)
    ge rx1861_pos, rx1861_eos, rxscan1865_done
  rxscan1865_scan:
    set_addr $I10, rxscan1865_loop
    rx1861_cur."!mark_push"(0, rx1861_pos, $I10)
  rxscan1865_done:
.annotate 'line', 707
  # rx subcapture "sym"
    set_addr $I10, rxcap_1866_fail
    rx1861_cur."!mark_push"(0, rx1861_pos, $I10)
  # rx literal  ":="
    add $I11, rx1861_pos, 2
    gt $I11, rx1861_eos, rx1861_fail
    sub $I11, rx1861_pos, rx1861_off
    substr $S10, rx1861_tgt, $I11, 2
    ne $S10, ":=", rx1861_fail
    add rx1861_pos, 2
    set_addr $I10, rxcap_1866_fail
    ($I12, $I11) = rx1861_cur."!mark_peek"($I10)
    rx1861_cur."!cursor_pos"($I11)
    ($P10) = rx1861_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1861_pos, "")
    rx1861_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1866_done
  rxcap_1866_fail:
    goto rx1861_fail
  rxcap_1866_done:
  # rx subrule "O" subtype=capture negate=
    rx1861_cur."!cursor_pos"(rx1861_pos)
    $P10 = rx1861_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1861_fail
    rx1861_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1861_pos = $P10."pos"()
  # rx pass
    rx1861_cur."!cursor_pass"(rx1861_pos, "infix:sym<:=>")
    if_null rx1861_debug, debug_1368
    rx1861_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1861_pos)
  debug_1368:
    .return (rx1861_cur)
  rx1861_restart:
.annotate 'line', 10
    if_null rx1861_debug, debug_1369
    rx1861_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1369:
  rx1861_fail:
    (rx1861_rep, rx1861_pos, $I10, $P10) = rx1861_cur."!mark_fail"(0)
    lt rx1861_pos, -1, rx1861_done
    eq rx1861_pos, -1, rx1861_fail
    jump $I10
  rx1861_done:
    rx1861_cur."!cursor_fail"()
    if_null rx1861_debug, debug_1370
    rx1861_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1370:
    .return (rx1861_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("366_1303739803.72") :method
.annotate 'line', 10
    $P1863 = self."!PREFIX__!subrule"("O", ":=")
    new $P1864, "ResizablePMCArray"
    push $P1864, $P1863
    .return ($P1864)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("367_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1868_tgt
    .local int rx1868_pos
    .local int rx1868_off
    .local int rx1868_eos
    .local int rx1868_rep
    .local pmc rx1868_cur
    .local pmc rx1868_debug
    (rx1868_cur, rx1868_pos, rx1868_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1868_cur
    .local pmc match
    .lex "$/", match
    length rx1868_eos, rx1868_tgt
    gt rx1868_pos, rx1868_eos, rx1868_done
    set rx1868_off, 0
    lt rx1868_pos, 2, rx1868_start
    sub rx1868_off, rx1868_pos, 1
    substr rx1868_tgt, rx1868_tgt, rx1868_off
  rx1868_start:
    eq $I10, 1, rx1868_restart
    if_null rx1868_debug, debug_1371
    rx1868_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1371:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1872_done
    goto rxscan1872_scan
  rxscan1872_loop:
    (rx1868_pos) = rx1868_cur."from"()
    inc rx1868_pos
    rx1868_cur."!cursor_from"(rx1868_pos)
    ge rx1868_pos, rx1868_eos, rxscan1872_done
  rxscan1872_scan:
    set_addr $I10, rxscan1872_loop
    rx1868_cur."!mark_push"(0, rx1868_pos, $I10)
  rxscan1872_done:
.annotate 'line', 708
  # rx subcapture "sym"
    set_addr $I10, rxcap_1873_fail
    rx1868_cur."!mark_push"(0, rx1868_pos, $I10)
  # rx literal  "::="
    add $I11, rx1868_pos, 3
    gt $I11, rx1868_eos, rx1868_fail
    sub $I11, rx1868_pos, rx1868_off
    substr $S10, rx1868_tgt, $I11, 3
    ne $S10, "::=", rx1868_fail
    add rx1868_pos, 3
    set_addr $I10, rxcap_1873_fail
    ($I12, $I11) = rx1868_cur."!mark_peek"($I10)
    rx1868_cur."!cursor_pos"($I11)
    ($P10) = rx1868_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1868_pos, "")
    rx1868_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1873_done
  rxcap_1873_fail:
    goto rx1868_fail
  rxcap_1873_done:
  # rx subrule "O" subtype=capture negate=
    rx1868_cur."!cursor_pos"(rx1868_pos)
    $P10 = rx1868_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1868_fail
    rx1868_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1868_pos = $P10."pos"()
  # rx pass
    rx1868_cur."!cursor_pass"(rx1868_pos, "infix:sym<::=>")
    if_null rx1868_debug, debug_1372
    rx1868_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1868_pos)
  debug_1372:
    .return (rx1868_cur)
  rx1868_restart:
.annotate 'line', 10
    if_null rx1868_debug, debug_1373
    rx1868_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1373:
  rx1868_fail:
    (rx1868_rep, rx1868_pos, $I10, $P10) = rx1868_cur."!mark_fail"(0)
    lt rx1868_pos, -1, rx1868_done
    eq rx1868_pos, -1, rx1868_fail
    jump $I10
  rx1868_done:
    rx1868_cur."!cursor_fail"()
    if_null rx1868_debug, debug_1374
    rx1868_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1374:
    .return (rx1868_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("368_1303739803.72") :method
.annotate 'line', 10
    $P1870 = self."!PREFIX__!subrule"("O", "::=")
    new $P1871, "ResizablePMCArray"
    push $P1871, $P1870
    .return ($P1871)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("369_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1875_tgt
    .local int rx1875_pos
    .local int rx1875_off
    .local int rx1875_eos
    .local int rx1875_rep
    .local pmc rx1875_cur
    .local pmc rx1875_debug
    (rx1875_cur, rx1875_pos, rx1875_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1875_cur
    .local pmc match
    .lex "$/", match
    length rx1875_eos, rx1875_tgt
    gt rx1875_pos, rx1875_eos, rx1875_done
    set rx1875_off, 0
    lt rx1875_pos, 2, rx1875_start
    sub rx1875_off, rx1875_pos, 1
    substr rx1875_tgt, rx1875_tgt, rx1875_off
  rx1875_start:
    eq $I10, 1, rx1875_restart
    if_null rx1875_debug, debug_1375
    rx1875_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1375:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1879_done
    goto rxscan1879_scan
  rxscan1879_loop:
    (rx1875_pos) = rx1875_cur."from"()
    inc rx1875_pos
    rx1875_cur."!cursor_from"(rx1875_pos)
    ge rx1875_pos, rx1875_eos, rxscan1879_done
  rxscan1879_scan:
    set_addr $I10, rxscan1879_loop
    rx1875_cur."!mark_push"(0, rx1875_pos, $I10)
  rxscan1879_done:
.annotate 'line', 710
  # rx subcapture "sym"
    set_addr $I10, rxcap_1880_fail
    rx1875_cur."!mark_push"(0, rx1875_pos, $I10)
  # rx literal  ","
    add $I11, rx1875_pos, 1
    gt $I11, rx1875_eos, rx1875_fail
    sub $I11, rx1875_pos, rx1875_off
    ord $I11, rx1875_tgt, $I11
    ne $I11, 44, rx1875_fail
    add rx1875_pos, 1
    set_addr $I10, rxcap_1880_fail
    ($I12, $I11) = rx1875_cur."!mark_peek"($I10)
    rx1875_cur."!cursor_pos"($I11)
    ($P10) = rx1875_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1875_pos, "")
    rx1875_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1880_done
  rxcap_1880_fail:
    goto rx1875_fail
  rxcap_1880_done:
  # rx subrule "O" subtype=capture negate=
    rx1875_cur."!cursor_pos"(rx1875_pos)
    $P10 = rx1875_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1875_fail
    rx1875_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1875_pos = $P10."pos"()
  # rx pass
    rx1875_cur."!cursor_pass"(rx1875_pos, "infix:sym<,>")
    if_null rx1875_debug, debug_1376
    rx1875_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1875_pos)
  debug_1376:
    .return (rx1875_cur)
  rx1875_restart:
.annotate 'line', 10
    if_null rx1875_debug, debug_1377
    rx1875_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1377:
  rx1875_fail:
    (rx1875_rep, rx1875_pos, $I10, $P10) = rx1875_cur."!mark_fail"(0)
    lt rx1875_pos, -1, rx1875_done
    eq rx1875_pos, -1, rx1875_fail
    jump $I10
  rx1875_done:
    rx1875_cur."!cursor_fail"()
    if_null rx1875_debug, debug_1378
    rx1875_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1378:
    .return (rx1875_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("370_1303739803.72") :method
.annotate 'line', 10
    $P1877 = self."!PREFIX__!subrule"("O", ",")
    new $P1878, "ResizablePMCArray"
    push $P1878, $P1877
    .return ($P1878)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("371_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .const 'Sub' $P1890 = "373_1303739803.72" 
    capture_lex $P1890
    .local string rx1882_tgt
    .local int rx1882_pos
    .local int rx1882_off
    .local int rx1882_eos
    .local int rx1882_rep
    .local pmc rx1882_cur
    .local pmc rx1882_debug
    (rx1882_cur, rx1882_pos, rx1882_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1882_cur
    .local pmc match
    .lex "$/", match
    length rx1882_eos, rx1882_tgt
    gt rx1882_pos, rx1882_eos, rx1882_done
    set rx1882_off, 0
    lt rx1882_pos, 2, rx1882_start
    sub rx1882_off, rx1882_pos, 1
    substr rx1882_tgt, rx1882_tgt, rx1882_off
  rx1882_start:
    eq $I10, 1, rx1882_restart
    if_null rx1882_debug, debug_1379
    rx1882_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1379:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1885_done
    goto rxscan1885_scan
  rxscan1885_loop:
    (rx1882_pos) = rx1882_cur."from"()
    inc rx1882_pos
    rx1882_cur."!cursor_from"(rx1882_pos)
    ge rx1882_pos, rx1882_eos, rxscan1885_done
  rxscan1885_scan:
    set_addr $I10, rxscan1885_loop
    rx1882_cur."!mark_push"(0, rx1882_pos, $I10)
  rxscan1885_done:
.annotate 'line', 712
  # rx subcapture "sym"
    set_addr $I10, rxcap_1886_fail
    rx1882_cur."!mark_push"(0, rx1882_pos, $I10)
  # rx literal  "return"
    add $I11, rx1882_pos, 6
    gt $I11, rx1882_eos, rx1882_fail
    sub $I11, rx1882_pos, rx1882_off
    substr $S10, rx1882_tgt, $I11, 6
    ne $S10, "return", rx1882_fail
    add rx1882_pos, 6
    set_addr $I10, rxcap_1886_fail
    ($I12, $I11) = rx1882_cur."!mark_peek"($I10)
    rx1882_cur."!cursor_pos"($I11)
    ($P10) = rx1882_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1882_pos, "")
    rx1882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1886_done
  rxcap_1886_fail:
    goto rx1882_fail
  rxcap_1886_done:
  # rx charclass s
    ge rx1882_pos, rx1882_eos, rx1882_fail
    sub $I10, rx1882_pos, rx1882_off
    is_cclass $I11, 32, rx1882_tgt, $I10
    unless $I11, rx1882_fail
    inc rx1882_pos
  # rx subrule "O" subtype=capture negate=
    rx1882_cur."!cursor_pos"(rx1882_pos)
    $P10 = rx1882_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1882_fail
    rx1882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1882_pos = $P10."pos"()
    rx1882_cur."!cursor_pos"(rx1882_pos)
    find_lex $P1887, unicode:"$\x{a2}"
    $P1888 = $P1887."MATCH"()
    store_lex "$/", $P1888
    .const 'Sub' $P1890 = "373_1303739803.72" 
    capture_lex $P1890
    $P1892 = $P1890()
  # rx pass
    rx1882_cur."!cursor_pass"(rx1882_pos, "prefix:sym<return>")
    if_null rx1882_debug, debug_1380
    rx1882_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1882_pos)
  debug_1380:
    .return (rx1882_cur)
  rx1882_restart:
.annotate 'line', 10
    if_null rx1882_debug, debug_1381
    rx1882_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1381:
  rx1882_fail:
    (rx1882_rep, rx1882_pos, $I10, $P10) = rx1882_cur."!mark_fail"(0)
    lt rx1882_pos, -1, rx1882_done
    eq rx1882_pos, -1, rx1882_fail
    jump $I10
  rx1882_done:
    rx1882_cur."!cursor_fail"()
    if_null rx1882_debug, debug_1382
    rx1882_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1382:
    .return (rx1882_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("372_1303739803.72") :method
.annotate 'line', 10
    new $P1884, "ResizablePMCArray"
    push $P1884, "return"
    .return ($P1884)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1889"  :anon :subid("373_1303739803.72") :outer("371_1303739803.72")
.annotate 'line', 712
    new $P1891, "Integer"
    assign $P1891, 1
    store_dynamic_lex "$*RETURN_USED", $P1891
    .return ($P1891)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("374_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1894_tgt
    .local int rx1894_pos
    .local int rx1894_off
    .local int rx1894_eos
    .local int rx1894_rep
    .local pmc rx1894_cur
    .local pmc rx1894_debug
    (rx1894_cur, rx1894_pos, rx1894_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1894_cur
    .local pmc match
    .lex "$/", match
    length rx1894_eos, rx1894_tgt
    gt rx1894_pos, rx1894_eos, rx1894_done
    set rx1894_off, 0
    lt rx1894_pos, 2, rx1894_start
    sub rx1894_off, rx1894_pos, 1
    substr rx1894_tgt, rx1894_tgt, rx1894_off
  rx1894_start:
    eq $I10, 1, rx1894_restart
    if_null rx1894_debug, debug_1383
    rx1894_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1383:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1897_done
    goto rxscan1897_scan
  rxscan1897_loop:
    (rx1894_pos) = rx1894_cur."from"()
    inc rx1894_pos
    rx1894_cur."!cursor_from"(rx1894_pos)
    ge rx1894_pos, rx1894_eos, rxscan1897_done
  rxscan1897_scan:
    set_addr $I10, rxscan1897_loop
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  rxscan1897_done:
.annotate 'line', 713
  # rx subcapture "sym"
    set_addr $I10, rxcap_1898_fail
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  # rx literal  "make"
    add $I11, rx1894_pos, 4
    gt $I11, rx1894_eos, rx1894_fail
    sub $I11, rx1894_pos, rx1894_off
    substr $S10, rx1894_tgt, $I11, 4
    ne $S10, "make", rx1894_fail
    add rx1894_pos, 4
    set_addr $I10, rxcap_1898_fail
    ($I12, $I11) = rx1894_cur."!mark_peek"($I10)
    rx1894_cur."!cursor_pos"($I11)
    ($P10) = rx1894_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1894_pos, "")
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1898_done
  rxcap_1898_fail:
    goto rx1894_fail
  rxcap_1898_done:
  # rx charclass s
    ge rx1894_pos, rx1894_eos, rx1894_fail
    sub $I10, rx1894_pos, rx1894_off
    is_cclass $I11, 32, rx1894_tgt, $I10
    unless $I11, rx1894_fail
    inc rx1894_pos
  # rx subrule "O" subtype=capture negate=
    rx1894_cur."!cursor_pos"(rx1894_pos)
    $P10 = rx1894_cur."O"("%list_prefix")
    unless $P10, rx1894_fail
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1894_pos = $P10."pos"()
  # rx pass
    rx1894_cur."!cursor_pass"(rx1894_pos, "prefix:sym<make>")
    if_null rx1894_debug, debug_1384
    rx1894_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1894_pos)
  debug_1384:
    .return (rx1894_cur)
  rx1894_restart:
.annotate 'line', 10
    if_null rx1894_debug, debug_1385
    rx1894_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1385:
  rx1894_fail:
    (rx1894_rep, rx1894_pos, $I10, $P10) = rx1894_cur."!mark_fail"(0)
    lt rx1894_pos, -1, rx1894_done
    eq rx1894_pos, -1, rx1894_fail
    jump $I10
  rx1894_done:
    rx1894_cur."!cursor_fail"()
    if_null rx1894_debug, debug_1386
    rx1894_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1386:
    .return (rx1894_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("375_1303739803.72") :method
.annotate 'line', 10
    new $P1896, "ResizablePMCArray"
    push $P1896, "make"
    .return ($P1896)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("376_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1900_tgt
    .local int rx1900_pos
    .local int rx1900_off
    .local int rx1900_eos
    .local int rx1900_rep
    .local pmc rx1900_cur
    .local pmc rx1900_debug
    (rx1900_cur, rx1900_pos, rx1900_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1900_cur
    .local pmc match
    .lex "$/", match
    length rx1900_eos, rx1900_tgt
    gt rx1900_pos, rx1900_eos, rx1900_done
    set rx1900_off, 0
    lt rx1900_pos, 2, rx1900_start
    sub rx1900_off, rx1900_pos, 1
    substr rx1900_tgt, rx1900_tgt, rx1900_off
  rx1900_start:
    eq $I10, 1, rx1900_restart
    if_null rx1900_debug, debug_1387
    rx1900_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1387:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1903_done
    goto rxscan1903_scan
  rxscan1903_loop:
    (rx1900_pos) = rx1900_cur."from"()
    inc rx1900_pos
    rx1900_cur."!cursor_from"(rx1900_pos)
    ge rx1900_pos, rx1900_eos, rxscan1903_done
  rxscan1903_scan:
    set_addr $I10, rxscan1903_loop
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  rxscan1903_done:
.annotate 'line', 714
  # rx subcapture "sym"
    set_addr $I10, rxcap_1904_fail
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  # rx literal  "last"
    add $I11, rx1900_pos, 4
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 4
    ne $S10, "last", rx1900_fail
    add rx1900_pos, 4
    set_addr $I10, rxcap_1904_fail
    ($I12, $I11) = rx1900_cur."!mark_peek"($I10)
    rx1900_cur."!cursor_pos"($I11)
    ($P10) = rx1900_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1900_pos, "")
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1904_done
  rxcap_1904_fail:
    goto rx1900_fail
  rxcap_1904_done:
  # rx pass
    rx1900_cur."!cursor_pass"(rx1900_pos, "term:sym<last>")
    if_null rx1900_debug, debug_1388
    rx1900_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1900_pos)
  debug_1388:
    .return (rx1900_cur)
  rx1900_restart:
.annotate 'line', 10
    if_null rx1900_debug, debug_1389
    rx1900_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1389:
  rx1900_fail:
    (rx1900_rep, rx1900_pos, $I10, $P10) = rx1900_cur."!mark_fail"(0)
    lt rx1900_pos, -1, rx1900_done
    eq rx1900_pos, -1, rx1900_fail
    jump $I10
  rx1900_done:
    rx1900_cur."!cursor_fail"()
    if_null rx1900_debug, debug_1390
    rx1900_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1390:
    .return (rx1900_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("377_1303739803.72") :method
.annotate 'line', 10
    new $P1902, "ResizablePMCArray"
    push $P1902, "last"
    .return ($P1902)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("378_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1906_tgt
    .local int rx1906_pos
    .local int rx1906_off
    .local int rx1906_eos
    .local int rx1906_rep
    .local pmc rx1906_cur
    .local pmc rx1906_debug
    (rx1906_cur, rx1906_pos, rx1906_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1906_cur
    .local pmc match
    .lex "$/", match
    length rx1906_eos, rx1906_tgt
    gt rx1906_pos, rx1906_eos, rx1906_done
    set rx1906_off, 0
    lt rx1906_pos, 2, rx1906_start
    sub rx1906_off, rx1906_pos, 1
    substr rx1906_tgt, rx1906_tgt, rx1906_off
  rx1906_start:
    eq $I10, 1, rx1906_restart
    if_null rx1906_debug, debug_1391
    rx1906_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1391:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1909_done
    goto rxscan1909_scan
  rxscan1909_loop:
    (rx1906_pos) = rx1906_cur."from"()
    inc rx1906_pos
    rx1906_cur."!cursor_from"(rx1906_pos)
    ge rx1906_pos, rx1906_eos, rxscan1909_done
  rxscan1909_scan:
    set_addr $I10, rxscan1909_loop
    rx1906_cur."!mark_push"(0, rx1906_pos, $I10)
  rxscan1909_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1910_fail
    rx1906_cur."!mark_push"(0, rx1906_pos, $I10)
  # rx literal  "next"
    add $I11, rx1906_pos, 4
    gt $I11, rx1906_eos, rx1906_fail
    sub $I11, rx1906_pos, rx1906_off
    substr $S10, rx1906_tgt, $I11, 4
    ne $S10, "next", rx1906_fail
    add rx1906_pos, 4
    set_addr $I10, rxcap_1910_fail
    ($I12, $I11) = rx1906_cur."!mark_peek"($I10)
    rx1906_cur."!cursor_pos"($I11)
    ($P10) = rx1906_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1906_pos, "")
    rx1906_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1910_done
  rxcap_1910_fail:
    goto rx1906_fail
  rxcap_1910_done:
  # rx pass
    rx1906_cur."!cursor_pass"(rx1906_pos, "term:sym<next>")
    if_null rx1906_debug, debug_1392
    rx1906_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1906_pos)
  debug_1392:
    .return (rx1906_cur)
  rx1906_restart:
.annotate 'line', 10
    if_null rx1906_debug, debug_1393
    rx1906_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1393:
  rx1906_fail:
    (rx1906_rep, rx1906_pos, $I10, $P10) = rx1906_cur."!mark_fail"(0)
    lt rx1906_pos, -1, rx1906_done
    eq rx1906_pos, -1, rx1906_fail
    jump $I10
  rx1906_done:
    rx1906_cur."!cursor_fail"()
    if_null rx1906_debug, debug_1394
    rx1906_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1394:
    .return (rx1906_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("379_1303739803.72") :method
.annotate 'line', 10
    new $P1908, "ResizablePMCArray"
    push $P1908, "next"
    .return ($P1908)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("380_1303739803.72") :method :outer("12_1303739803.72")
.annotate 'line', 10
    .local string rx1912_tgt
    .local int rx1912_pos
    .local int rx1912_off
    .local int rx1912_eos
    .local int rx1912_rep
    .local pmc rx1912_cur
    .local pmc rx1912_debug
    (rx1912_cur, rx1912_pos, rx1912_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1912_cur
    .local pmc match
    .lex "$/", match
    length rx1912_eos, rx1912_tgt
    gt rx1912_pos, rx1912_eos, rx1912_done
    set rx1912_off, 0
    lt rx1912_pos, 2, rx1912_start
    sub rx1912_off, rx1912_pos, 1
    substr rx1912_tgt, rx1912_tgt, rx1912_off
  rx1912_start:
    eq $I10, 1, rx1912_restart
    if_null rx1912_debug, debug_1395
    rx1912_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1395:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1915_done
    goto rxscan1915_scan
  rxscan1915_loop:
    (rx1912_pos) = rx1912_cur."from"()
    inc rx1912_pos
    rx1912_cur."!cursor_from"(rx1912_pos)
    ge rx1912_pos, rx1912_eos, rxscan1915_done
  rxscan1915_scan:
    set_addr $I10, rxscan1915_loop
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  rxscan1915_done:
.annotate 'line', 716
  # rx subcapture "sym"
    set_addr $I10, rxcap_1916_fail
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1912_pos, 4
    gt $I11, rx1912_eos, rx1912_fail
    sub $I11, rx1912_pos, rx1912_off
    substr $S10, rx1912_tgt, $I11, 4
    ne $S10, "redo", rx1912_fail
    add rx1912_pos, 4
    set_addr $I10, rxcap_1916_fail
    ($I12, $I11) = rx1912_cur."!mark_peek"($I10)
    rx1912_cur."!cursor_pos"($I11)
    ($P10) = rx1912_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1912_pos, "")
    rx1912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1916_done
  rxcap_1916_fail:
    goto rx1912_fail
  rxcap_1916_done:
  # rx pass
    rx1912_cur."!cursor_pass"(rx1912_pos, "term:sym<redo>")
    if_null rx1912_debug, debug_1396
    rx1912_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1912_pos)
  debug_1396:
    .return (rx1912_cur)
  rx1912_restart:
.annotate 'line', 10
    if_null rx1912_debug, debug_1397
    rx1912_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1397:
  rx1912_fail:
    (rx1912_rep, rx1912_pos, $I10, $P10) = rx1912_cur."!mark_fail"(0)
    lt rx1912_pos, -1, rx1912_done
    eq rx1912_pos, -1, rx1912_fail
    jump $I10
  rx1912_done:
    rx1912_cur."!cursor_fail"()
    if_null rx1912_debug, debug_1398
    rx1912_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1398:
    .return (rx1912_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("381_1303739803.72") :method
.annotate 'line', 10
    new $P1914, "ResizablePMCArray"
    push $P1914, "redo"
    .return ($P1914)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("382_1303739803.72") :outer("12_1303739803.72")
    .param pmc param_1918
    .param pmc param_1919
.annotate 'line', 718
    .lex "self", param_1918
    .lex "$/", param_1919
.annotate 'line', 720
    new $P1920, "Undef"
    .lex "$t", $P1920
    find_lex $P1921, "$/"
    unless_null $P1921, vivify_1399
    $P1921 = root_new ['parrot';'ResizablePMCArray']
  vivify_1399:
    set $P1922, $P1921[0]
    unless_null $P1922, vivify_1400
    new $P1922, "Undef"
  vivify_1400:
    store_lex "$t", $P1922
    find_lex $P1923, "$/"
    unless_null $P1923, vivify_1401
    $P1923 = root_new ['parrot';'ResizablePMCArray']
  vivify_1401:
    set $P1924, $P1923[1]
    unless_null $P1924, vivify_1402
    new $P1924, "Undef"
  vivify_1402:
    find_lex $P1925, "$/"
    unless_null $P1925, vivify_1403
    $P1925 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1925
  vivify_1403:
    set $P1925[0], $P1924
    find_lex $P1926, "$t"
    unless_null $P1926, vivify_1404
    new $P1926, "Undef"
  vivify_1404:
    find_lex $P1927, "$/"
    unless_null $P1927, vivify_1405
    $P1927 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1927
  vivify_1405:
    set $P1927[1], $P1926
.annotate 'line', 718
    .return ($P1926)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2652"  :subid("384_1303739803.72") :outer("10_1303739803.72")
.annotate 'line', 724
    .const 'Sub' $P2718 = "405_1303739803.72" 
    capture_lex $P2718
    .const 'Sub' $P2711 = "403_1303739803.72" 
    capture_lex $P2711
    .const 'Sub' $P2706 = "401_1303739803.72" 
    capture_lex $P2706
    .const 'Sub' $P2694 = "398_1303739803.72" 
    capture_lex $P2694
    .const 'Sub' $P2684 = "395_1303739803.72" 
    capture_lex $P2684
    .const 'Sub' $P2679 = "393_1303739803.72" 
    capture_lex $P2679
    .const 'Sub' $P2670 = "390_1303739803.72" 
    capture_lex $P2670
    .const 'Sub' $P2665 = "388_1303739803.72" 
    capture_lex $P2665
    .const 'Sub' $P2656 = "385_1303739803.72" 
    capture_lex $P2656
    .lex "$?PACKAGE", $P2654
    .lex "$?CLASS", $P2655
    .const 'Sub' $P2711 = "403_1303739803.72" 
    capture_lex $P2711
    .return ($P2711)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1406") :outer("384_1303739803.72")
.annotate 'line', 724
    .const 'Sub' $P2653 = "384_1303739803.72" 
    .local pmc block
    set block, $P2653
    .const 'Sub' $P2718 = "405_1303739803.72" 
    capture_lex $P2718
    $P2718()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2717"  :anon :subid("405_1303739803.72") :outer("384_1303739803.72")
.annotate 'line', 724
    nqp_get_sc_object $P2719, "1303739791.58", 2
    .local pmc type_obj
    set type_obj, $P2719
    get_how $P2720, type_obj
    .const 'Sub' $P2721 = "385_1303739803.72" 
    $P2720."add_method"(type_obj, "metachar:sym<:my>", $P2721)
    get_how $P2722, type_obj
    get_global $P2723, "!PREFIX__metachar:sym<:my>"
    $P2722."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2723)
    get_how $P2724, type_obj
    .const 'Sub' $P2725 = "388_1303739803.72" 
    $P2724."add_method"(type_obj, "metachar:sym<{ }>", $P2725)
    get_how $P2726, type_obj
    get_global $P2727, "!PREFIX__metachar:sym<{ }>"
    $P2726."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2727)
    get_how $P2728, type_obj
    .const 'Sub' $P2729 = "390_1303739803.72" 
    $P2728."add_method"(type_obj, "metachar:sym<nqpvar>", $P2729)
    get_how $P2730, type_obj
    get_global $P2731, "!PREFIX__metachar:sym<nqpvar>"
    $P2730."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2731)
    get_how $P2732, type_obj
    .const 'Sub' $P2733 = "393_1303739803.72" 
    $P2732."add_method"(type_obj, "assertion:sym<{ }>", $P2733)
    get_how $P2734, type_obj
    get_global $P2735, "!PREFIX__assertion:sym<{ }>"
    $P2734."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2735)
    get_how $P2736, type_obj
    .const 'Sub' $P2737 = "395_1303739803.72" 
    $P2736."add_method"(type_obj, "assertion:sym<?{ }>", $P2737)
    get_how $P2738, type_obj
    get_global $P2739, "!PREFIX__assertion:sym<?{ }>"
    $P2738."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2739)
    get_how $P2740, type_obj
    .const 'Sub' $P2741 = "398_1303739803.72" 
    $P2740."add_method"(type_obj, "assertion:sym<name>", $P2741)
    get_how $P2742, type_obj
    get_global $P2743, "!PREFIX__assertion:sym<name>"
    $P2742."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2743)
    get_how $P2744, type_obj
    .const 'Sub' $P2745 = "401_1303739803.72" 
    $P2744."add_method"(type_obj, "assertion:sym<var>", $P2745)
    get_how $P2746, type_obj
    get_global $P2747, "!PREFIX__assertion:sym<var>"
    $P2746."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2747)
    get_how $P2748, type_obj
    .const 'Sub' $P2749 = "403_1303739803.72" 
    $P2748."add_method"(type_obj, "codeblock", $P2749)
    get_how $P2750, type_obj
    get_global $P2751, "!PREFIX__codeblock"
    $P2750."add_method"(type_obj, "!PREFIX__codeblock", $P2751)
    get_how $P2752, type_obj
    get_hll_global $P2753, ["Regex";"P6Regex"], "Grammar"
    $P2752."add_parent"(type_obj, $P2753)
    get_how $P2754, type_obj
    $P2755 = $P2754."compose"(type_obj)
    .return ($P2755)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("385_1303739803.72") :method :outer("384_1303739803.72")
.annotate 'line', 724
    .const 'Sub' $P2662 = "387_1303739803.72" 
    capture_lex $P2662
    .local string rx2657_tgt
    .local int rx2657_pos
    .local int rx2657_off
    .local int rx2657_eos
    .local int rx2657_rep
    .local pmc rx2657_cur
    .local pmc rx2657_debug
    (rx2657_cur, rx2657_pos, rx2657_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2657_cur
    .local pmc match
    .lex "$/", match
    length rx2657_eos, rx2657_tgt
    gt rx2657_pos, rx2657_eos, rx2657_done
    set rx2657_off, 0
    lt rx2657_pos, 2, rx2657_start
    sub rx2657_off, rx2657_pos, 1
    substr rx2657_tgt, rx2657_tgt, rx2657_off
  rx2657_start:
    eq $I10, 1, rx2657_restart
    if_null rx2657_debug, debug_1407
    rx2657_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1407:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2660_done
    goto rxscan2660_scan
  rxscan2660_loop:
    (rx2657_pos) = rx2657_cur."from"()
    inc rx2657_pos
    rx2657_cur."!cursor_from"(rx2657_pos)
    ge rx2657_pos, rx2657_eos, rxscan2660_done
  rxscan2660_scan:
    set_addr $I10, rxscan2660_loop
    rx2657_cur."!mark_push"(0, rx2657_pos, $I10)
  rxscan2660_done:
.annotate 'line', 726
  # rx literal  ":"
    add $I11, rx2657_pos, 1
    gt $I11, rx2657_eos, rx2657_fail
    sub $I11, rx2657_pos, rx2657_off
    ord $I11, rx2657_tgt, $I11
    ne $I11, 58, rx2657_fail
    add rx2657_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2657_cur."!cursor_pos"(rx2657_pos)
    .const 'Sub' $P2662 = "387_1303739803.72" 
    capture_lex $P2662
    $P10 = rx2657_cur."before"($P2662)
    unless $P10, rx2657_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2657_cur."!cursor_pos"(rx2657_pos)
    $P10 = rx2657_cur."LANG"("MAIN", "statement")
    unless $P10, rx2657_fail
    rx2657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2657_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2657_cur."!cursor_pos"(rx2657_pos)
    $P10 = rx2657_cur."ws"()
    unless $P10, rx2657_fail
    rx2657_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2657_pos, 1
    gt $I11, rx2657_eos, rx2657_fail
    sub $I11, rx2657_pos, rx2657_off
    ord $I11, rx2657_tgt, $I11
    ne $I11, 59, rx2657_fail
    add rx2657_pos, 1
.annotate 'line', 725
  # rx pass
    rx2657_cur."!cursor_pass"(rx2657_pos, "metachar:sym<:my>")
    if_null rx2657_debug, debug_1412
    rx2657_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2657_pos)
  debug_1412:
    .return (rx2657_cur)
  rx2657_restart:
.annotate 'line', 724
    if_null rx2657_debug, debug_1413
    rx2657_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1413:
  rx2657_fail:
    (rx2657_rep, rx2657_pos, $I10, $P10) = rx2657_cur."!mark_fail"(0)
    lt rx2657_pos, -1, rx2657_done
    eq rx2657_pos, -1, rx2657_fail
    jump $I10
  rx2657_done:
    rx2657_cur."!cursor_fail"()
    if_null rx2657_debug, debug_1414
    rx2657_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1414:
    .return (rx2657_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("386_1303739803.72") :method
.annotate 'line', 724
    new $P2659, "ResizablePMCArray"
    push $P2659, ":"
    .return ($P2659)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2661"  :anon :subid("387_1303739803.72") :method :outer("385_1303739803.72")
.annotate 'line', 726
    .local string rx2663_tgt
    .local int rx2663_pos
    .local int rx2663_off
    .local int rx2663_eos
    .local int rx2663_rep
    .local pmc rx2663_cur
    .local pmc rx2663_debug
    (rx2663_cur, rx2663_pos, rx2663_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2663_cur
    .local pmc match
    .lex "$/", match
    length rx2663_eos, rx2663_tgt
    gt rx2663_pos, rx2663_eos, rx2663_done
    set rx2663_off, 0
    lt rx2663_pos, 2, rx2663_start
    sub rx2663_off, rx2663_pos, 1
    substr rx2663_tgt, rx2663_tgt, rx2663_off
  rx2663_start:
    eq $I10, 1, rx2663_restart
    if_null rx2663_debug, debug_1408
    rx2663_cur."!cursor_debug"("START", "")
  debug_1408:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2664_done
    goto rxscan2664_scan
  rxscan2664_loop:
    (rx2663_pos) = rx2663_cur."from"()
    inc rx2663_pos
    rx2663_cur."!cursor_from"(rx2663_pos)
    ge rx2663_pos, rx2663_eos, rxscan2664_done
  rxscan2664_scan:
    set_addr $I10, rxscan2664_loop
    rx2663_cur."!mark_push"(0, rx2663_pos, $I10)
  rxscan2664_done:
  # rx literal  "my"
    add $I11, rx2663_pos, 2
    gt $I11, rx2663_eos, rx2663_fail
    sub $I11, rx2663_pos, rx2663_off
    substr $S10, rx2663_tgt, $I11, 2
    ne $S10, "my", rx2663_fail
    add rx2663_pos, 2
  # rx pass
    rx2663_cur."!cursor_pass"(rx2663_pos, "")
    if_null rx2663_debug, debug_1409
    rx2663_cur."!cursor_debug"("PASS", "", " at pos=", rx2663_pos)
  debug_1409:
    .return (rx2663_cur)
  rx2663_restart:
    if_null rx2663_debug, debug_1410
    rx2663_cur."!cursor_debug"("NEXT", "")
  debug_1410:
  rx2663_fail:
    (rx2663_rep, rx2663_pos, $I10, $P10) = rx2663_cur."!mark_fail"(0)
    lt rx2663_pos, -1, rx2663_done
    eq rx2663_pos, -1, rx2663_fail
    jump $I10
  rx2663_done:
    rx2663_cur."!cursor_fail"()
    if_null rx2663_debug, debug_1411
    rx2663_cur."!cursor_debug"("FAIL", "")
  debug_1411:
    .return (rx2663_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("388_1303739803.72") :method :outer("384_1303739803.72")
.annotate 'line', 724
    .local string rx2666_tgt
    .local int rx2666_pos
    .local int rx2666_off
    .local int rx2666_eos
    .local int rx2666_rep
    .local pmc rx2666_cur
    .local pmc rx2666_debug
    (rx2666_cur, rx2666_pos, rx2666_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2666_cur
    .local pmc match
    .lex "$/", match
    length rx2666_eos, rx2666_tgt
    gt rx2666_pos, rx2666_eos, rx2666_done
    set rx2666_off, 0
    lt rx2666_pos, 2, rx2666_start
    sub rx2666_off, rx2666_pos, 1
    substr rx2666_tgt, rx2666_tgt, rx2666_off
  rx2666_start:
    eq $I10, 1, rx2666_restart
    if_null rx2666_debug, debug_1415
    rx2666_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1415:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2669_done
    goto rxscan2669_scan
  rxscan2669_loop:
    (rx2666_pos) = rx2666_cur."from"()
    inc rx2666_pos
    rx2666_cur."!cursor_from"(rx2666_pos)
    ge rx2666_pos, rx2666_eos, rxscan2669_done
  rxscan2669_scan:
    set_addr $I10, rxscan2669_loop
    rx2666_cur."!mark_push"(0, rx2666_pos, $I10)
  rxscan2669_done:
.annotate 'line', 730
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2666_pos, rx2666_off
    substr $S10, rx2666_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2666_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2666_cur."!cursor_pos"(rx2666_pos)
    $P10 = rx2666_cur."codeblock"()
    unless $P10, rx2666_fail
    rx2666_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2666_pos = $P10."pos"()
.annotate 'line', 729
  # rx pass
    rx2666_cur."!cursor_pass"(rx2666_pos, "metachar:sym<{ }>")
    if_null rx2666_debug, debug_1416
    rx2666_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2666_pos)
  debug_1416:
    .return (rx2666_cur)
  rx2666_restart:
.annotate 'line', 724
    if_null rx2666_debug, debug_1417
    rx2666_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1417:
  rx2666_fail:
    (rx2666_rep, rx2666_pos, $I10, $P10) = rx2666_cur."!mark_fail"(0)
    lt rx2666_pos, -1, rx2666_done
    eq rx2666_pos, -1, rx2666_fail
    jump $I10
  rx2666_done:
    rx2666_cur."!cursor_fail"()
    if_null rx2666_debug, debug_1418
    rx2666_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1418:
    .return (rx2666_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("389_1303739803.72") :method
.annotate 'line', 724
    new $P2668, "ResizablePMCArray"
    push $P2668, "{"
    .return ($P2668)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("390_1303739803.72") :method :outer("384_1303739803.72")
.annotate 'line', 724
    .const 'Sub' $P2676 = "392_1303739803.72" 
    capture_lex $P2676
    .local string rx2671_tgt
    .local int rx2671_pos
    .local int rx2671_off
    .local int rx2671_eos
    .local int rx2671_rep
    .local pmc rx2671_cur
    .local pmc rx2671_debug
    (rx2671_cur, rx2671_pos, rx2671_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2671_cur
    .local pmc match
    .lex "$/", match
    length rx2671_eos, rx2671_tgt
    gt rx2671_pos, rx2671_eos, rx2671_done
    set rx2671_off, 0
    lt rx2671_pos, 2, rx2671_start
    sub rx2671_off, rx2671_pos, 1
    substr rx2671_tgt, rx2671_tgt, rx2671_off
  rx2671_start:
    eq $I10, 1, rx2671_restart
    if_null rx2671_debug, debug_1419
    rx2671_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1419:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2674_done
    goto rxscan2674_scan
  rxscan2674_loop:
    (rx2671_pos) = rx2671_cur."from"()
    inc rx2671_pos
    rx2671_cur."!cursor_from"(rx2671_pos)
    ge rx2671_pos, rx2671_eos, rxscan2674_done
  rxscan2674_scan:
    set_addr $I10, rxscan2674_loop
    rx2671_cur."!mark_push"(0, rx2671_pos, $I10)
  rxscan2674_done:
.annotate 'line', 734
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2671_pos, rx2671_off
    substr $S10, rx2671_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2671_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2671_cur."!cursor_pos"(rx2671_pos)
    .const 'Sub' $P2676 = "392_1303739803.72" 
    capture_lex $P2676
    $P10 = rx2671_cur."before"($P2676)
    unless $P10, rx2671_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2671_cur."!cursor_pos"(rx2671_pos)
    $P10 = rx2671_cur."LANG"("MAIN", "variable")
    unless $P10, rx2671_fail
    rx2671_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2671_pos = $P10."pos"()
.annotate 'line', 733
  # rx pass
    rx2671_cur."!cursor_pass"(rx2671_pos, "metachar:sym<nqpvar>")
    if_null rx2671_debug, debug_1424
    rx2671_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2671_pos)
  debug_1424:
    .return (rx2671_cur)
  rx2671_restart:
.annotate 'line', 724
    if_null rx2671_debug, debug_1425
    rx2671_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1425:
  rx2671_fail:
    (rx2671_rep, rx2671_pos, $I10, $P10) = rx2671_cur."!mark_fail"(0)
    lt rx2671_pos, -1, rx2671_done
    eq rx2671_pos, -1, rx2671_fail
    jump $I10
  rx2671_done:
    rx2671_cur."!cursor_fail"()
    if_null rx2671_debug, debug_1426
    rx2671_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1426:
    .return (rx2671_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("391_1303739803.72") :method
.annotate 'line', 724
    new $P2673, "ResizablePMCArray"
    push $P2673, "$"
    push $P2673, "@"
    .return ($P2673)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2675"  :anon :subid("392_1303739803.72") :method :outer("390_1303739803.72")
.annotate 'line', 734
    .local string rx2677_tgt
    .local int rx2677_pos
    .local int rx2677_off
    .local int rx2677_eos
    .local int rx2677_rep
    .local pmc rx2677_cur
    .local pmc rx2677_debug
    (rx2677_cur, rx2677_pos, rx2677_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2677_cur
    .local pmc match
    .lex "$/", match
    length rx2677_eos, rx2677_tgt
    gt rx2677_pos, rx2677_eos, rx2677_done
    set rx2677_off, 0
    lt rx2677_pos, 2, rx2677_start
    sub rx2677_off, rx2677_pos, 1
    substr rx2677_tgt, rx2677_tgt, rx2677_off
  rx2677_start:
    eq $I10, 1, rx2677_restart
    if_null rx2677_debug, debug_1420
    rx2677_cur."!cursor_debug"("START", "")
  debug_1420:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2678_done
    goto rxscan2678_scan
  rxscan2678_loop:
    (rx2677_pos) = rx2677_cur."from"()
    inc rx2677_pos
    rx2677_cur."!cursor_from"(rx2677_pos)
    ge rx2677_pos, rx2677_eos, rxscan2678_done
  rxscan2678_scan:
    set_addr $I10, rxscan2678_loop
    rx2677_cur."!mark_push"(0, rx2677_pos, $I10)
  rxscan2678_done:
  # rx charclass .
    ge rx2677_pos, rx2677_eos, rx2677_fail
    inc rx2677_pos
  # rx charclass w
    ge rx2677_pos, rx2677_eos, rx2677_fail
    sub $I10, rx2677_pos, rx2677_off
    is_cclass $I11, 8192, rx2677_tgt, $I10
    unless $I11, rx2677_fail
    inc rx2677_pos
  # rx pass
    rx2677_cur."!cursor_pass"(rx2677_pos, "")
    if_null rx2677_debug, debug_1421
    rx2677_cur."!cursor_debug"("PASS", "", " at pos=", rx2677_pos)
  debug_1421:
    .return (rx2677_cur)
  rx2677_restart:
    if_null rx2677_debug, debug_1422
    rx2677_cur."!cursor_debug"("NEXT", "")
  debug_1422:
  rx2677_fail:
    (rx2677_rep, rx2677_pos, $I10, $P10) = rx2677_cur."!mark_fail"(0)
    lt rx2677_pos, -1, rx2677_done
    eq rx2677_pos, -1, rx2677_fail
    jump $I10
  rx2677_done:
    rx2677_cur."!cursor_fail"()
    if_null rx2677_debug, debug_1423
    rx2677_cur."!cursor_debug"("FAIL", "")
  debug_1423:
    .return (rx2677_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("393_1303739803.72") :method :outer("384_1303739803.72")
.annotate 'line', 724
    .local string rx2680_tgt
    .local int rx2680_pos
    .local int rx2680_off
    .local int rx2680_eos
    .local int rx2680_rep
    .local pmc rx2680_cur
    .local pmc rx2680_debug
    (rx2680_cur, rx2680_pos, rx2680_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2680_cur
    .local pmc match
    .lex "$/", match
    length rx2680_eos, rx2680_tgt
    gt rx2680_pos, rx2680_eos, rx2680_done
    set rx2680_off, 0
    lt rx2680_pos, 2, rx2680_start
    sub rx2680_off, rx2680_pos, 1
    substr rx2680_tgt, rx2680_tgt, rx2680_off
  rx2680_start:
    eq $I10, 1, rx2680_restart
    if_null rx2680_debug, debug_1427
    rx2680_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1427:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2683_done
    goto rxscan2683_scan
  rxscan2683_loop:
    (rx2680_pos) = rx2680_cur."from"()
    inc rx2680_pos
    rx2680_cur."!cursor_from"(rx2680_pos)
    ge rx2680_pos, rx2680_eos, rxscan2683_done
  rxscan2683_scan:
    set_addr $I10, rxscan2683_loop
    rx2680_cur."!mark_push"(0, rx2680_pos, $I10)
  rxscan2683_done:
.annotate 'line', 738
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2680_pos, rx2680_off
    substr $S10, rx2680_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2680_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2680_cur."!cursor_pos"(rx2680_pos)
    $P10 = rx2680_cur."codeblock"()
    unless $P10, rx2680_fail
    rx2680_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2680_pos = $P10."pos"()
.annotate 'line', 737
  # rx pass
    rx2680_cur."!cursor_pass"(rx2680_pos, "assertion:sym<{ }>")
    if_null rx2680_debug, debug_1428
    rx2680_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2680_pos)
  debug_1428:
    .return (rx2680_cur)
  rx2680_restart:
.annotate 'line', 724
    if_null rx2680_debug, debug_1429
    rx2680_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1429:
  rx2680_fail:
    (rx2680_rep, rx2680_pos, $I10, $P10) = rx2680_cur."!mark_fail"(0)
    lt rx2680_pos, -1, rx2680_done
    eq rx2680_pos, -1, rx2680_fail
    jump $I10
  rx2680_done:
    rx2680_cur."!cursor_fail"()
    if_null rx2680_debug, debug_1430
    rx2680_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1430:
    .return (rx2680_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("394_1303739803.72") :method
.annotate 'line', 724
    new $P2682, "ResizablePMCArray"
    push $P2682, "{"
    .return ($P2682)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("395_1303739803.72") :method :outer("384_1303739803.72")
.annotate 'line', 724
    .const 'Sub' $P2690 = "397_1303739803.72" 
    capture_lex $P2690
    .local string rx2685_tgt
    .local int rx2685_pos
    .local int rx2685_off
    .local int rx2685_eos
    .local int rx2685_rep
    .local pmc rx2685_cur
    .local pmc rx2685_debug
    (rx2685_cur, rx2685_pos, rx2685_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2685_cur
    .local pmc match
    .lex "$/", match
    length rx2685_eos, rx2685_tgt
    gt rx2685_pos, rx2685_eos, rx2685_done
    set rx2685_off, 0
    lt rx2685_pos, 2, rx2685_start
    sub rx2685_off, rx2685_pos, 1
    substr rx2685_tgt, rx2685_tgt, rx2685_off
  rx2685_start:
    eq $I10, 1, rx2685_restart
    if_null rx2685_debug, debug_1431
    rx2685_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1431:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2688_done
    goto rxscan2688_scan
  rxscan2688_loop:
    (rx2685_pos) = rx2685_cur."from"()
    inc rx2685_pos
    rx2685_cur."!cursor_from"(rx2685_pos)
    ge rx2685_pos, rx2685_eos, rxscan2688_done
  rxscan2688_scan:
    set_addr $I10, rxscan2688_loop
    rx2685_cur."!mark_push"(0, rx2685_pos, $I10)
  rxscan2688_done:
.annotate 'line', 742
  # rx subcapture "zw"
    set_addr $I10, rxcap_2693_fail
    rx2685_cur."!mark_push"(0, rx2685_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2685_pos, rx2685_eos, rx2685_fail
    sub $I10, rx2685_pos, rx2685_off
    substr $S10, rx2685_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2685_fail
    inc rx2685_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2685_cur."!cursor_pos"(rx2685_pos)
    .const 'Sub' $P2690 = "397_1303739803.72" 
    capture_lex $P2690
    $P10 = rx2685_cur."before"($P2690)
    unless $P10, rx2685_fail
    set_addr $I10, rxcap_2693_fail
    ($I12, $I11) = rx2685_cur."!mark_peek"($I10)
    rx2685_cur."!cursor_pos"($I11)
    ($P10) = rx2685_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2685_pos, "")
    rx2685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2693_done
  rxcap_2693_fail:
    goto rx2685_fail
  rxcap_2693_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2685_cur."!cursor_pos"(rx2685_pos)
    $P10 = rx2685_cur."codeblock"()
    unless $P10, rx2685_fail
    rx2685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2685_pos = $P10."pos"()
.annotate 'line', 741
  # rx pass
    rx2685_cur."!cursor_pass"(rx2685_pos, "assertion:sym<?{ }>")
    if_null rx2685_debug, debug_1436
    rx2685_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2685_pos)
  debug_1436:
    .return (rx2685_cur)
  rx2685_restart:
.annotate 'line', 724
    if_null rx2685_debug, debug_1437
    rx2685_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1437:
  rx2685_fail:
    (rx2685_rep, rx2685_pos, $I10, $P10) = rx2685_cur."!mark_fail"(0)
    lt rx2685_pos, -1, rx2685_done
    eq rx2685_pos, -1, rx2685_fail
    jump $I10
  rx2685_done:
    rx2685_cur."!cursor_fail"()
    if_null rx2685_debug, debug_1438
    rx2685_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1438:
    .return (rx2685_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("396_1303739803.72") :method
.annotate 'line', 724
    new $P2687, "ResizablePMCArray"
    push $P2687, "!"
    push $P2687, "?"
    .return ($P2687)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2689"  :anon :subid("397_1303739803.72") :method :outer("395_1303739803.72")
.annotate 'line', 742
    .local string rx2691_tgt
    .local int rx2691_pos
    .local int rx2691_off
    .local int rx2691_eos
    .local int rx2691_rep
    .local pmc rx2691_cur
    .local pmc rx2691_debug
    (rx2691_cur, rx2691_pos, rx2691_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2691_cur
    .local pmc match
    .lex "$/", match
    length rx2691_eos, rx2691_tgt
    gt rx2691_pos, rx2691_eos, rx2691_done
    set rx2691_off, 0
    lt rx2691_pos, 2, rx2691_start
    sub rx2691_off, rx2691_pos, 1
    substr rx2691_tgt, rx2691_tgt, rx2691_off
  rx2691_start:
    eq $I10, 1, rx2691_restart
    if_null rx2691_debug, debug_1432
    rx2691_cur."!cursor_debug"("START", "")
  debug_1432:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2692_done
    goto rxscan2692_scan
  rxscan2692_loop:
    (rx2691_pos) = rx2691_cur."from"()
    inc rx2691_pos
    rx2691_cur."!cursor_from"(rx2691_pos)
    ge rx2691_pos, rx2691_eos, rxscan2692_done
  rxscan2692_scan:
    set_addr $I10, rxscan2692_loop
    rx2691_cur."!mark_push"(0, rx2691_pos, $I10)
  rxscan2692_done:
  # rx literal  "{"
    add $I11, rx2691_pos, 1
    gt $I11, rx2691_eos, rx2691_fail
    sub $I11, rx2691_pos, rx2691_off
    ord $I11, rx2691_tgt, $I11
    ne $I11, 123, rx2691_fail
    add rx2691_pos, 1
  # rx pass
    rx2691_cur."!cursor_pass"(rx2691_pos, "")
    if_null rx2691_debug, debug_1433
    rx2691_cur."!cursor_debug"("PASS", "", " at pos=", rx2691_pos)
  debug_1433:
    .return (rx2691_cur)
  rx2691_restart:
    if_null rx2691_debug, debug_1434
    rx2691_cur."!cursor_debug"("NEXT", "")
  debug_1434:
  rx2691_fail:
    (rx2691_rep, rx2691_pos, $I10, $P10) = rx2691_cur."!mark_fail"(0)
    lt rx2691_pos, -1, rx2691_done
    eq rx2691_pos, -1, rx2691_fail
    jump $I10
  rx2691_done:
    rx2691_cur."!cursor_fail"()
    if_null rx2691_debug, debug_1435
    rx2691_cur."!cursor_debug"("FAIL", "")
  debug_1435:
    .return (rx2691_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("398_1303739803.72") :method :outer("384_1303739803.72")
.annotate 'line', 724
    .const 'Sub' $P2703 = "400_1303739803.72" 
    capture_lex $P2703
    .local string rx2695_tgt
    .local int rx2695_pos
    .local int rx2695_off
    .local int rx2695_eos
    .local int rx2695_rep
    .local pmc rx2695_cur
    .local pmc rx2695_debug
    (rx2695_cur, rx2695_pos, rx2695_tgt, $I10) = self."!cursor_start"()
    rx2695_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2695_cur
    .local pmc match
    .lex "$/", match
    length rx2695_eos, rx2695_tgt
    gt rx2695_pos, rx2695_eos, rx2695_done
    set rx2695_off, 0
    lt rx2695_pos, 2, rx2695_start
    sub rx2695_off, rx2695_pos, 1
    substr rx2695_tgt, rx2695_tgt, rx2695_off
  rx2695_start:
    eq $I10, 1, rx2695_restart
    if_null rx2695_debug, debug_1439
    rx2695_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1439:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2699_done
    goto rxscan2699_scan
  rxscan2699_loop:
    (rx2695_pos) = rx2695_cur."from"()
    inc rx2695_pos
    rx2695_cur."!cursor_from"(rx2695_pos)
    ge rx2695_pos, rx2695_eos, rxscan2699_done
  rxscan2699_scan:
    set_addr $I10, rxscan2699_loop
    rx2695_cur."!mark_push"(0, rx2695_pos, $I10)
  rxscan2699_done:
.annotate 'line', 746
  # rx subrule "identifier" subtype=capture negate=
    rx2695_cur."!cursor_pos"(rx2695_pos)
    $P10 = rx2695_cur."identifier"()
    unless $P10, rx2695_fail
    rx2695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2695_pos = $P10."pos"()
.annotate 'line', 753
  # rx rxquantr2700 ** 0..1
    set_addr $I10, rxquantr2700_done
    rx2695_cur."!mark_push"(0, rx2695_pos, $I10)
  rxquantr2700_loop:
  alt2701_0:
.annotate 'line', 747
    set_addr $I10, alt2701_1
    rx2695_cur."!mark_push"(0, rx2695_pos, $I10)
.annotate 'line', 748
  # rx subrule "before" subtype=zerowidth negate=
    rx2695_cur."!cursor_pos"(rx2695_pos)
    .const 'Sub' $P2703 = "400_1303739803.72" 
    capture_lex $P2703
    $P10 = rx2695_cur."before"($P2703)
    unless $P10, rx2695_fail
    goto alt2701_end
  alt2701_1:
    set_addr $I10, alt2701_2
    rx2695_cur."!mark_push"(0, rx2695_pos, $I10)
.annotate 'line', 749
  # rx literal  "="
    add $I11, rx2695_pos, 1
    gt $I11, rx2695_eos, rx2695_fail
    sub $I11, rx2695_pos, rx2695_off
    ord $I11, rx2695_tgt, $I11
    ne $I11, 61, rx2695_fail
    add rx2695_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2695_cur."!cursor_pos"(rx2695_pos)
    $P10 = rx2695_cur."assertion"()
    unless $P10, rx2695_fail
    rx2695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2695_pos = $P10."pos"()
    goto alt2701_end
  alt2701_2:
    set_addr $I10, alt2701_3
    rx2695_cur."!mark_push"(0, rx2695_pos, $I10)
.annotate 'line', 750
  # rx literal  ":"
    add $I11, rx2695_pos, 1
    gt $I11, rx2695_eos, rx2695_fail
    sub $I11, rx2695_pos, rx2695_off
    ord $I11, rx2695_tgt, $I11
    ne $I11, 58, rx2695_fail
    add rx2695_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2695_cur."!cursor_pos"(rx2695_pos)
    $P10 = rx2695_cur."arglist"()
    unless $P10, rx2695_fail
    rx2695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2695_pos = $P10."pos"()
    goto alt2701_end
  alt2701_3:
    set_addr $I10, alt2701_4
    rx2695_cur."!mark_push"(0, rx2695_pos, $I10)
.annotate 'line', 751
  # rx literal  "("
    add $I11, rx2695_pos, 1
    gt $I11, rx2695_eos, rx2695_fail
    sub $I11, rx2695_pos, rx2695_off
    ord $I11, rx2695_tgt, $I11
    ne $I11, 40, rx2695_fail
    add rx2695_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2695_cur."!cursor_pos"(rx2695_pos)
    $P10 = rx2695_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2695_fail
    rx2695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2695_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2695_pos, 1
    gt $I11, rx2695_eos, rx2695_fail
    sub $I11, rx2695_pos, rx2695_off
    ord $I11, rx2695_tgt, $I11
    ne $I11, 41, rx2695_fail
    add rx2695_pos, 1
    goto alt2701_end
  alt2701_4:
.annotate 'line', 752
  # rx subrule "normspace" subtype=method negate=
    rx2695_cur."!cursor_pos"(rx2695_pos)
    $P10 = rx2695_cur."normspace"()
    unless $P10, rx2695_fail
    rx2695_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2695_cur."!cursor_pos"(rx2695_pos)
    $P10 = rx2695_cur."nibbler"()
    unless $P10, rx2695_fail
    rx2695_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2695_pos = $P10."pos"()
  alt2701_end:
.annotate 'line', 753
    set_addr $I10, rxquantr2700_done
    (rx2695_rep) = rx2695_cur."!mark_commit"($I10)
  rxquantr2700_done:
.annotate 'line', 745
  # rx pass
    rx2695_cur."!cursor_pass"(rx2695_pos, "assertion:sym<name>")
    if_null rx2695_debug, debug_1444
    rx2695_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2695_pos)
  debug_1444:
    .return (rx2695_cur)
  rx2695_restart:
.annotate 'line', 724
    if_null rx2695_debug, debug_1445
    rx2695_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1445:
  rx2695_fail:
    (rx2695_rep, rx2695_pos, $I10, $P10) = rx2695_cur."!mark_fail"(0)
    lt rx2695_pos, -1, rx2695_done
    eq rx2695_pos, -1, rx2695_fail
    jump $I10
  rx2695_done:
    rx2695_cur."!cursor_fail"()
    if_null rx2695_debug, debug_1446
    rx2695_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1446:
    .return (rx2695_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("399_1303739803.72") :method
.annotate 'line', 724
    $P2697 = self."!PREFIX__!subrule"("identifier", "")
    new $P2698, "ResizablePMCArray"
    push $P2698, $P2697
    .return ($P2698)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2702"  :anon :subid("400_1303739803.72") :method :outer("398_1303739803.72")
.annotate 'line', 748
    .local string rx2704_tgt
    .local int rx2704_pos
    .local int rx2704_off
    .local int rx2704_eos
    .local int rx2704_rep
    .local pmc rx2704_cur
    .local pmc rx2704_debug
    (rx2704_cur, rx2704_pos, rx2704_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2704_cur
    .local pmc match
    .lex "$/", match
    length rx2704_eos, rx2704_tgt
    gt rx2704_pos, rx2704_eos, rx2704_done
    set rx2704_off, 0
    lt rx2704_pos, 2, rx2704_start
    sub rx2704_off, rx2704_pos, 1
    substr rx2704_tgt, rx2704_tgt, rx2704_off
  rx2704_start:
    eq $I10, 1, rx2704_restart
    if_null rx2704_debug, debug_1440
    rx2704_cur."!cursor_debug"("START", "")
  debug_1440:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2705_done
    goto rxscan2705_scan
  rxscan2705_loop:
    (rx2704_pos) = rx2704_cur."from"()
    inc rx2704_pos
    rx2704_cur."!cursor_from"(rx2704_pos)
    ge rx2704_pos, rx2704_eos, rxscan2705_done
  rxscan2705_scan:
    set_addr $I10, rxscan2705_loop
    rx2704_cur."!mark_push"(0, rx2704_pos, $I10)
  rxscan2705_done:
  # rx literal  ">"
    add $I11, rx2704_pos, 1
    gt $I11, rx2704_eos, rx2704_fail
    sub $I11, rx2704_pos, rx2704_off
    ord $I11, rx2704_tgt, $I11
    ne $I11, 62, rx2704_fail
    add rx2704_pos, 1
  # rx pass
    rx2704_cur."!cursor_pass"(rx2704_pos, "")
    if_null rx2704_debug, debug_1441
    rx2704_cur."!cursor_debug"("PASS", "", " at pos=", rx2704_pos)
  debug_1441:
    .return (rx2704_cur)
  rx2704_restart:
    if_null rx2704_debug, debug_1442
    rx2704_cur."!cursor_debug"("NEXT", "")
  debug_1442:
  rx2704_fail:
    (rx2704_rep, rx2704_pos, $I10, $P10) = rx2704_cur."!mark_fail"(0)
    lt rx2704_pos, -1, rx2704_done
    eq rx2704_pos, -1, rx2704_fail
    jump $I10
  rx2704_done:
    rx2704_cur."!cursor_fail"()
    if_null rx2704_debug, debug_1443
    rx2704_cur."!cursor_debug"("FAIL", "")
  debug_1443:
    .return (rx2704_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("401_1303739803.72") :method :outer("384_1303739803.72")
.annotate 'line', 724
    .local string rx2707_tgt
    .local int rx2707_pos
    .local int rx2707_off
    .local int rx2707_eos
    .local int rx2707_rep
    .local pmc rx2707_cur
    .local pmc rx2707_debug
    (rx2707_cur, rx2707_pos, rx2707_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2707_cur
    .local pmc match
    .lex "$/", match
    length rx2707_eos, rx2707_tgt
    gt rx2707_pos, rx2707_eos, rx2707_done
    set rx2707_off, 0
    lt rx2707_pos, 2, rx2707_start
    sub rx2707_off, rx2707_pos, 1
    substr rx2707_tgt, rx2707_tgt, rx2707_off
  rx2707_start:
    eq $I10, 1, rx2707_restart
    if_null rx2707_debug, debug_1447
    rx2707_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1447:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2710_done
    goto rxscan2710_scan
  rxscan2710_loop:
    (rx2707_pos) = rx2707_cur."from"()
    inc rx2707_pos
    rx2707_cur."!cursor_from"(rx2707_pos)
    ge rx2707_pos, rx2707_eos, rxscan2710_done
  rxscan2710_scan:
    set_addr $I10, rxscan2710_loop
    rx2707_cur."!mark_push"(0, rx2707_pos, $I10)
  rxscan2710_done:
.annotate 'line', 757
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2707_pos, rx2707_off
    substr $S10, rx2707_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2707_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2707_cur."!cursor_pos"(rx2707_pos)
    $P10 = rx2707_cur."LANG"("MAIN", "variable")
    unless $P10, rx2707_fail
    rx2707_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2707_pos = $P10."pos"()
.annotate 'line', 756
  # rx pass
    rx2707_cur."!cursor_pass"(rx2707_pos, "assertion:sym<var>")
    if_null rx2707_debug, debug_1448
    rx2707_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2707_pos)
  debug_1448:
    .return (rx2707_cur)
  rx2707_restart:
.annotate 'line', 724
    if_null rx2707_debug, debug_1449
    rx2707_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1449:
  rx2707_fail:
    (rx2707_rep, rx2707_pos, $I10, $P10) = rx2707_cur."!mark_fail"(0)
    lt rx2707_pos, -1, rx2707_done
    eq rx2707_pos, -1, rx2707_fail
    jump $I10
  rx2707_done:
    rx2707_cur."!cursor_fail"()
    if_null rx2707_debug, debug_1450
    rx2707_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1450:
    .return (rx2707_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("402_1303739803.72") :method
.annotate 'line', 724
    new $P2709, "ResizablePMCArray"
    push $P2709, "$"
    push $P2709, "@"
    .return ($P2709)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("403_1303739803.72") :method :outer("384_1303739803.72")
.annotate 'line', 724
    .local string rx2712_tgt
    .local int rx2712_pos
    .local int rx2712_off
    .local int rx2712_eos
    .local int rx2712_rep
    .local pmc rx2712_cur
    .local pmc rx2712_debug
    (rx2712_cur, rx2712_pos, rx2712_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2712_cur
    .local pmc match
    .lex "$/", match
    length rx2712_eos, rx2712_tgt
    gt rx2712_pos, rx2712_eos, rx2712_done
    set rx2712_off, 0
    lt rx2712_pos, 2, rx2712_start
    sub rx2712_off, rx2712_pos, 1
    substr rx2712_tgt, rx2712_tgt, rx2712_off
  rx2712_start:
    eq $I10, 1, rx2712_restart
    if_null rx2712_debug, debug_1451
    rx2712_cur."!cursor_debug"("START", "codeblock")
  debug_1451:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2716_done
    goto rxscan2716_scan
  rxscan2716_loop:
    (rx2712_pos) = rx2712_cur."from"()
    inc rx2712_pos
    rx2712_cur."!cursor_from"(rx2712_pos)
    ge rx2712_pos, rx2712_eos, rxscan2716_done
  rxscan2716_scan:
    set_addr $I10, rxscan2716_loop
    rx2712_cur."!mark_push"(0, rx2712_pos, $I10)
  rxscan2716_done:
.annotate 'line', 761
  # rx subrule "LANG" subtype=capture negate=
    rx2712_cur."!cursor_pos"(rx2712_pos)
    $P10 = rx2712_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2712_fail
    rx2712_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2712_pos = $P10."pos"()
.annotate 'line', 760
  # rx pass
    rx2712_cur."!cursor_pass"(rx2712_pos, "codeblock")
    if_null rx2712_debug, debug_1452
    rx2712_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2712_pos)
  debug_1452:
    .return (rx2712_cur)
  rx2712_restart:
.annotate 'line', 724
    if_null rx2712_debug, debug_1453
    rx2712_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1453:
  rx2712_fail:
    (rx2712_rep, rx2712_pos, $I10, $P10) = rx2712_cur."!mark_fail"(0)
    lt rx2712_pos, -1, rx2712_done
    eq rx2712_pos, -1, rx2712_fail
    jump $I10
  rx2712_done:
    rx2712_cur."!cursor_fail"()
    if_null rx2712_debug, debug_1454
    rx2712_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1454:
    .return (rx2712_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("404_1303739803.72") :method
.annotate 'line', 724
    $P2714 = self."!PREFIX__!subrule"("LANG", "")
    new $P2715, "ResizablePMCArray"
    push $P2715, $P2714
    .return ($P2715)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2756"  :subid("406_1303739803.72") :outer("10_1303739803.72")
.annotate 'line', 767
    .const 'Sub' $P6958 = "571_1303739803.72" 
    capture_lex $P6958
    .const 'Sub' $P6941 = "570_1303739803.72" 
    capture_lex $P6941
    .const 'Sub' $P6936 = "569_1303739803.72" 
    capture_lex $P6936
    .const 'Sub' $P6931 = "568_1303739803.72" 
    capture_lex $P6931
    .const 'Sub' $P6926 = "567_1303739803.72" 
    capture_lex $P6926
    .const 'Sub' $P6909 = "566_1303739803.72" 
    capture_lex $P6909
    .const 'Sub' $P6898 = "565_1303739803.72" 
    capture_lex $P6898
    .const 'Sub' $P6887 = "564_1303739803.72" 
    capture_lex $P6887
    .const 'Sub' $P6879 = "563_1303739803.72" 
    capture_lex $P6879
    .const 'Sub' $P6874 = "562_1303739803.72" 
    capture_lex $P6874
    .const 'Sub' $P6859 = "561_1303739803.72" 
    capture_lex $P6859
    .const 'Sub' $P6851 = "560_1303739803.72" 
    capture_lex $P6851
    .const 'Sub' $P6790 = "559_1303739803.72" 
    capture_lex $P6790
    .const 'Sub' $P6775 = "558_1303739803.72" 
    capture_lex $P6775
    .const 'Sub' $P6767 = "557_1303739803.72" 
    capture_lex $P6767
    .const 'Sub' $P6759 = "556_1303739803.72" 
    capture_lex $P6759
    .const 'Sub' $P6751 = "555_1303739803.72" 
    capture_lex $P6751
    .const 'Sub' $P6743 = "554_1303739803.72" 
    capture_lex $P6743
    .const 'Sub' $P6735 = "553_1303739803.72" 
    capture_lex $P6735
    .const 'Sub' $P6706 = "552_1303739803.72" 
    capture_lex $P6706
    .const 'Sub' $P6691 = "551_1303739803.72" 
    capture_lex $P6691
    .const 'Sub' $P6683 = "550_1303739803.72" 
    capture_lex $P6683
    .const 'Sub' $P6669 = "549_1303739803.72" 
    capture_lex $P6669
    .const 'Sub' $P6655 = "548_1303739803.72" 
    capture_lex $P6655
    .const 'Sub' $P6641 = "547_1303739803.72" 
    capture_lex $P6641
    .const 'Sub' $P6633 = "546_1303739803.72" 
    capture_lex $P6633
    .const 'Sub' $P6603 = "545_1303739803.72" 
    capture_lex $P6603
    .const 'Sub' $P6565 = "543_1303739803.72" 
    capture_lex $P6565
    .const 'Sub' $P6557 = "542_1303739803.72" 
    capture_lex $P6557
    .const 'Sub' $P6549 = "541_1303739803.72" 
    capture_lex $P6549
    .const 'Sub' $P6518 = "540_1303739803.72" 
    capture_lex $P6518
    .const 'Sub' $P6499 = "539_1303739803.72" 
    capture_lex $P6499
    .const 'Sub' $P6491 = "538_1303739803.72" 
    capture_lex $P6491
    .const 'Sub' $P6483 = "537_1303739803.72" 
    capture_lex $P6483
    .const 'Sub' $P6375 = "534_1303739803.72" 
    capture_lex $P6375
    .const 'Sub' $P6367 = "533_1303739803.72" 
    capture_lex $P6367
    .const 'Sub' $P6357 = "532_1303739803.72" 
    capture_lex $P6357
    .const 'Sub' $P6323 = "531_1303739803.72" 
    capture_lex $P6323
    .const 'Sub' $P6281 = "529_1303739803.72" 
    capture_lex $P6281
    .const 'Sub' $P6267 = "528_1303739803.72" 
    capture_lex $P6267
    .const 'Sub' $P6257 = "527_1303739803.72" 
    capture_lex $P6257
    .const 'Sub' $P6205 = "526_1303739803.72" 
    capture_lex $P6205
    .const 'Sub' $P5929 = "522_1303739803.72" 
    capture_lex $P5929
    .const 'Sub' $P5847 = "520_1303739803.72" 
    capture_lex $P5847
    .const 'Sub' $P5839 = "519_1303739803.72" 
    capture_lex $P5839
    .const 'Sub' $P5818 = "518_1303739803.72" 
    capture_lex $P5818
    .const 'Sub' $P5803 = "517_1303739803.72" 
    capture_lex $P5803
    .const 'Sub' $P5780 = "516_1303739803.72" 
    capture_lex $P5780
    .const 'Sub' $P5677 = "515_1303739803.72" 
    capture_lex $P5677
    .const 'Sub' $P5623 = "512_1303739803.72" 
    capture_lex $P5623
    .const 'Sub' $P5441 = "509_1303739803.72" 
    capture_lex $P5441
    .const 'Sub' $P5070 = "502_1303739803.72" 
    capture_lex $P5070
    .const 'Sub' $P5062 = "501_1303739803.72" 
    capture_lex $P5062
    .const 'Sub' $P5054 = "500_1303739803.72" 
    capture_lex $P5054
    .const 'Sub' $P4907 = "497_1303739803.72" 
    capture_lex $P4907
    .const 'Sub' $P4899 = "496_1303739803.72" 
    capture_lex $P4899
    .const 'Sub' $P4884 = "495_1303739803.72" 
    capture_lex $P4884
    .const 'Sub' $P4869 = "494_1303739803.72" 
    capture_lex $P4869
    .const 'Sub' $P4854 = "493_1303739803.72" 
    capture_lex $P4854
    .const 'Sub' $P4832 = "492_1303739803.72" 
    capture_lex $P4832
    .const 'Sub' $P4824 = "491_1303739803.72" 
    capture_lex $P4824
    .const 'Sub' $P4816 = "490_1303739803.72" 
    capture_lex $P4816
    .const 'Sub' $P4808 = "489_1303739803.72" 
    capture_lex $P4808
    .const 'Sub' $P4476 = "486_1303739803.72" 
    capture_lex $P4476
    .const 'Sub' $P4468 = "485_1303739803.72" 
    capture_lex $P4468
    .const 'Sub' $P4460 = "484_1303739803.72" 
    capture_lex $P4460
    .const 'Sub' $P4452 = "483_1303739803.72" 
    capture_lex $P4452
    .const 'Sub' $P4444 = "482_1303739803.72" 
    capture_lex $P4444
    .const 'Sub' $P4436 = "481_1303739803.72" 
    capture_lex $P4436
    .const 'Sub' $P4428 = "480_1303739803.72" 
    capture_lex $P4428
    .const 'Sub' $P4286 = "477_1303739803.72" 
    capture_lex $P4286
    .const 'Sub' $P4259 = "476_1303739803.72" 
    capture_lex $P4259
    .const 'Sub' $P4245 = "475_1303739803.72" 
    capture_lex $P4245
    .const 'Sub' $P4237 = "474_1303739803.72" 
    capture_lex $P4237
    .const 'Sub' $P4229 = "473_1303739803.72" 
    capture_lex $P4229
    .const 'Sub' $P4221 = "472_1303739803.72" 
    capture_lex $P4221
    .const 'Sub' $P4213 = "471_1303739803.72" 
    capture_lex $P4213
    .const 'Sub' $P4205 = "470_1303739803.72" 
    capture_lex $P4205
    .const 'Sub' $P4197 = "469_1303739803.72" 
    capture_lex $P4197
    .const 'Sub' $P4189 = "468_1303739803.72" 
    capture_lex $P4189
    .const 'Sub' $P4181 = "467_1303739803.72" 
    capture_lex $P4181
    .const 'Sub' $P4173 = "466_1303739803.72" 
    capture_lex $P4173
    .const 'Sub' $P4165 = "465_1303739803.72" 
    capture_lex $P4165
    .const 'Sub' $P4157 = "464_1303739803.72" 
    capture_lex $P4157
    .const 'Sub' $P4149 = "463_1303739803.72" 
    capture_lex $P4149
    .const 'Sub' $P4141 = "462_1303739803.72" 
    capture_lex $P4141
    .const 'Sub' $P4125 = "461_1303739803.72" 
    capture_lex $P4125
    .const 'Sub' $P4071 = "460_1303739803.72" 
    capture_lex $P4071
    .const 'Sub' $P4054 = "459_1303739803.72" 
    capture_lex $P4054
    .const 'Sub' $P4030 = "458_1303739803.72" 
    capture_lex $P4030
    .const 'Sub' $P4007 = "457_1303739803.72" 
    capture_lex $P4007
    .const 'Sub' $P3980 = "456_1303739803.72" 
    capture_lex $P3980
    .const 'Sub' $P3943 = "455_1303739803.72" 
    capture_lex $P3943
    .const 'Sub' $P3928 = "454_1303739803.72" 
    capture_lex $P3928
    .const 'Sub' $P3916 = "453_1303739803.72" 
    capture_lex $P3916
    .const 'Sub' $P3865 = "451_1303739803.72" 
    capture_lex $P3865
    .const 'Sub' $P3840 = "450_1303739803.72" 
    capture_lex $P3840
    .const 'Sub' $P3833 = "449_1303739803.72" 
    capture_lex $P3833
    .const 'Sub' $P3791 = "448_1303739803.72" 
    capture_lex $P3791
    .const 'Sub' $P3741 = "446_1303739803.72" 
    capture_lex $P3741
    .const 'Sub' $P3724 = "445_1303739803.72" 
    capture_lex $P3724
    .const 'Sub' $P3685 = "443_1303739803.72" 
    capture_lex $P3685
    .const 'Sub' $P3677 = "442_1303739803.72" 
    capture_lex $P3677
    .const 'Sub' $P3669 = "441_1303739803.72" 
    capture_lex $P3669
    .const 'Sub' $P3652 = "440_1303739803.72" 
    capture_lex $P3652
    .const 'Sub' $P3556 = "438_1303739803.72" 
    capture_lex $P3556
    .const 'Sub' $P3512 = "436_1303739803.72" 
    capture_lex $P3512
    .const 'Sub' $P3397 = "435_1303739803.72" 
    capture_lex $P3397
    .const 'Sub' $P3366 = "434_1303739803.72" 
    capture_lex $P3366
    .const 'Sub' $P3358 = "433_1303739803.72" 
    capture_lex $P3358
    .const 'Sub' $P3229 = "427_1303739803.72" 
    capture_lex $P3229
    .const 'Sub' $P3194 = "425_1303739803.72" 
    capture_lex $P3194
    .const 'Sub' $P3189 = "424_1303739803.72" 
    capture_lex $P3189
    .const 'Sub' $P3184 = "423_1303739803.72" 
    capture_lex $P3184
    .const 'Sub' $P3071 = "420_1303739803.72" 
    capture_lex $P3071
    .const 'Sub' $P3053 = "419_1303739803.72" 
    capture_lex $P3053
    .const 'Sub' $P2970 = "417_1303739803.72" 
    capture_lex $P2970
    .const 'Sub' $P2955 = "416_1303739803.72" 
    capture_lex $P2955
    .const 'Sub' $P2868 = "415_1303739803.72" 
    capture_lex $P2868
    .const 'Sub' $P2842 = "413_1303739803.72" 
    capture_lex $P2842
    .const 'Sub' $P2826 = "412_1303739803.72" 
    capture_lex $P2826
    .const 'Sub' $P2802 = "411_1303739803.72" 
    capture_lex $P2802
    .const 'Sub' $P2766 = "408_1303739803.72" 
    capture_lex $P2766
    .const 'Sub' $P2758 = "407_1303739803.72" 
    capture_lex $P2758
.annotate 'line', 771
    .const 'Sub' $P2758 = "407_1303739803.72" 
    newclosure $P2765, $P2758
    .lex "xblock_immediate", $P2765
.annotate 'line', 776
    .const 'Sub' $P2766 = "408_1303739803.72" 
    newclosure $P2801, $P2766
    .lex "block_immediate", $P2801
.annotate 'line', 786
    .const 'Sub' $P2802 = "411_1303739803.72" 
    newclosure $P2825, $P2802
    .lex "vivitype", $P2825
.annotate 'line', 805
    .const 'Sub' $P2826 = "412_1303739803.72" 
    newclosure $P2841, $P2826
    .lex "colonpair_str", $P2841
.annotate 'line', 968
    .const 'Sub' $P2842 = "413_1303739803.72" 
    newclosure $P2867, $P2842
    .lex "import_HOW_exports", $P2867
.annotate 'line', 1073
    .const 'Sub' $P2868 = "415_1303739803.72" 
    newclosure $P2954, $P2868
    .lex "push_block_handler", $P2954
.annotate 'line', 1638
    .const 'Sub' $P2955 = "416_1303739803.72" 
    newclosure $P2969, $P2955
    .lex "only_star_block", $P2969
.annotate 'line', 1647
    .const 'Sub' $P2970 = "417_1303739803.72" 
    newclosure $P3052, $P2970
    .lex "attach_multi_signature", $P3052
.annotate 'line', 2117
    .const 'Sub' $P3053 = "419_1303739803.72" 
    newclosure $P3070, $P3053
    .lex "control", $P3070
.annotate 'line', 2136
    .const 'Sub' $P3071 = "420_1303739803.72" 
    newclosure $P3183, $P3071
    .lex "lexical_package_lookup", $P3183
.annotate 'line', 2185
    .const 'Sub' $P3184 = "423_1303739803.72" 
    newclosure $P3188, $P3184
    .lex "is_lexical", $P3188
.annotate 'line', 2191
    .const 'Sub' $P3189 = "424_1303739803.72" 
    newclosure $P3193, $P3189
    .lex "is_package", $P3193
.annotate 'line', 2197
    .const 'Sub' $P3194 = "425_1303739803.72" 
    newclosure $P3228, $P3194
    .lex "is_scope", $P3228
.annotate 'line', 2210
    .const 'Sub' $P3229 = "427_1303739803.72" 
    newclosure $P3349, $P3229
    .lex "find_sym", $P3349
.annotate 'line', 767
    .lex "$?PACKAGE", $P3350
    .lex "$?CLASS", $P3351
.annotate 'line', 769
    new $P3352, "ResizablePMCArray"
    find_lex $P3353, "$?PACKAGE"
    get_who $P3354, $P3353
    set $P3354["@BLOCK"], $P3352
    find_lex $P3355, "xblock_immediate"
    find_lex $P3356, "block_immediate"
    find_lex $P3357, "vivitype"
.annotate 'line', 797
    find_lex $P3396, "colonpair_str"
.annotate 'line', 951
    find_lex $P3790, "import_HOW_exports"
.annotate 'line', 1066
    find_lex $P4053, "push_block_handler"
.annotate 'line', 1563
    find_lex $P5621, "only_star_block"
    find_lex $P5622, "attach_multi_signature"
.annotate 'line', 2108
    find_lex $P6925, "control"
.annotate 'line', 2130
    find_lex $P6952, "lexical_package_lookup"
    find_lex $P6953, "is_lexical"
    find_lex $P6954, "is_package"
    find_lex $P6955, "is_scope"
    find_lex $P6956, "find_sym"
.annotate 'line', 767
    .return ($P6956)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1455") :outer("406_1303739803.72")
.annotate 'line', 767
    .const 'Sub' $P2757 = "406_1303739803.72" 
    .local pmc block
    set block, $P2757
    .const 'Sub' $P6958 = "571_1303739803.72" 
    capture_lex $P6958
    $P6958()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6957"  :anon :subid("571_1303739803.72") :outer("406_1303739803.72")
.annotate 'line', 767
    nqp_get_sc_object $P6959, "1303739791.58", 3
    .local pmc type_obj
    set type_obj, $P6959
    get_how $P6960, type_obj
    .const 'Sub' $P6961 = "433_1303739803.72" 
    $P6960."add_method"(type_obj, "TOP", $P6961)
    get_how $P6962, type_obj
    .const 'Sub' $P6963 = "434_1303739803.72" 
    $P6962."add_method"(type_obj, "deflongname", $P6963)
    get_how $P6964, type_obj
    .const 'Sub' $P6965 = "435_1303739803.72" 
    $P6964."add_method"(type_obj, "comp_unit", $P6965)
    get_how $P6966, type_obj
    .const 'Sub' $P6967 = "436_1303739803.72" 
    $P6966."add_method"(type_obj, "statementlist", $P6967)
    get_how $P6968, type_obj
    .const 'Sub' $P6969 = "438_1303739803.72" 
    $P6968."add_method"(type_obj, "statement", $P6969)
    get_how $P6970, type_obj
    .const 'Sub' $P6971 = "440_1303739803.72" 
    $P6970."add_method"(type_obj, "xblock", $P6971)
    get_how $P6972, type_obj
    .const 'Sub' $P6973 = "441_1303739803.72" 
    $P6972."add_method"(type_obj, "pblock", $P6973)
    get_how $P6974, type_obj
    .const 'Sub' $P6975 = "442_1303739803.72" 
    $P6974."add_method"(type_obj, "block", $P6975)
    get_how $P6976, type_obj
    .const 'Sub' $P6977 = "443_1303739803.72" 
    $P6976."add_method"(type_obj, "blockoid", $P6977)
    get_how $P6978, type_obj
    .const 'Sub' $P6979 = "445_1303739803.72" 
    $P6978."add_method"(type_obj, "newpad", $P6979)
    get_how $P6980, type_obj
    .const 'Sub' $P6981 = "446_1303739803.72" 
    $P6980."add_method"(type_obj, "outerctx", $P6981)
    get_how $P6982, type_obj
    .const 'Sub' $P6983 = "448_1303739803.72" 
    $P6982."add_method"(type_obj, "GLOBALish", $P6983)
    get_how $P6984, type_obj
    .const 'Sub' $P6985 = "449_1303739803.72" 
    $P6984."add_method"(type_obj, "you_are_here", $P6985)
    get_how $P6986, type_obj
    .const 'Sub' $P6987 = "450_1303739803.72" 
    $P6986."add_method"(type_obj, "statement_control:sym<use>", $P6987)
    get_how $P6988, type_obj
    .const 'Sub' $P6989 = "451_1303739803.72" 
    $P6988."add_method"(type_obj, "statement_control:sym<if>", $P6989)
    get_how $P6990, type_obj
    .const 'Sub' $P6991 = "453_1303739803.72" 
    $P6990."add_method"(type_obj, "statement_control:sym<unless>", $P6991)
    get_how $P6992, type_obj
    .const 'Sub' $P6993 = "454_1303739803.72" 
    $P6992."add_method"(type_obj, "statement_control:sym<while>", $P6993)
    get_how $P6994, type_obj
    .const 'Sub' $P6995 = "455_1303739803.72" 
    $P6994."add_method"(type_obj, "statement_control:sym<repeat>", $P6995)
    get_how $P6996, type_obj
    .const 'Sub' $P6997 = "456_1303739803.72" 
    $P6996."add_method"(type_obj, "statement_control:sym<for>", $P6997)
    get_how $P6998, type_obj
    .const 'Sub' $P6999 = "457_1303739803.72" 
    $P6998."add_method"(type_obj, "statement_control:sym<CATCH>", $P6999)
    get_how $P7000, type_obj
    .const 'Sub' $P7001 = "458_1303739803.72" 
    $P7000."add_method"(type_obj, "statement_control:sym<CONTROL>", $P7001)
    get_how $P7002, type_obj
    .const 'Sub' $P7003 = "459_1303739803.72" 
    $P7002."add_method"(type_obj, "statement_prefix:sym<INIT>", $P7003)
    get_how $P7004, type_obj
    .const 'Sub' $P7005 = "460_1303739803.72" 
    $P7004."add_method"(type_obj, "statement_prefix:sym<try>", $P7005)
    get_how $P7006, type_obj
    .const 'Sub' $P7007 = "461_1303739803.72" 
    $P7006."add_method"(type_obj, "blorst", $P7007)
    get_how $P7008, type_obj
    .const 'Sub' $P7009 = "462_1303739803.72" 
    $P7008."add_method"(type_obj, "statement_mod_cond:sym<if>", $P7009)
    get_how $P7010, type_obj
    .const 'Sub' $P7011 = "463_1303739803.72" 
    $P7010."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P7011)
    get_how $P7012, type_obj
    .const 'Sub' $P7013 = "464_1303739803.72" 
    $P7012."add_method"(type_obj, "statement_mod_loop:sym<while>", $P7013)
    get_how $P7014, type_obj
    .const 'Sub' $P7015 = "465_1303739803.72" 
    $P7014."add_method"(type_obj, "statement_mod_loop:sym<until>", $P7015)
    get_how $P7016, type_obj
    .const 'Sub' $P7017 = "466_1303739803.72" 
    $P7016."add_method"(type_obj, "term:sym<fatarrow>", $P7017)
    get_how $P7018, type_obj
    .const 'Sub' $P7019 = "467_1303739803.72" 
    $P7018."add_method"(type_obj, "term:sym<colonpair>", $P7019)
    get_how $P7020, type_obj
    .const 'Sub' $P7021 = "468_1303739803.72" 
    $P7020."add_method"(type_obj, "term:sym<variable>", $P7021)
    get_how $P7022, type_obj
    .const 'Sub' $P7023 = "469_1303739803.72" 
    $P7022."add_method"(type_obj, "term:sym<package_declarator>", $P7023)
    get_how $P7024, type_obj
    .const 'Sub' $P7025 = "470_1303739803.72" 
    $P7024."add_method"(type_obj, "term:sym<scope_declarator>", $P7025)
    get_how $P7026, type_obj
    .const 'Sub' $P7027 = "471_1303739803.72" 
    $P7026."add_method"(type_obj, "term:sym<routine_declarator>", $P7027)
    get_how $P7028, type_obj
    .const 'Sub' $P7029 = "472_1303739803.72" 
    $P7028."add_method"(type_obj, "term:sym<regex_declarator>", $P7029)
    get_how $P7030, type_obj
    .const 'Sub' $P7031 = "473_1303739803.72" 
    $P7030."add_method"(type_obj, "term:sym<statement_prefix>", $P7031)
    get_how $P7032, type_obj
    .const 'Sub' $P7033 = "474_1303739803.72" 
    $P7032."add_method"(type_obj, "term:sym<lambda>", $P7033)
    get_how $P7034, type_obj
    .const 'Sub' $P7035 = "475_1303739803.72" 
    $P7034."add_method"(type_obj, "fatarrow", $P7035)
    get_how $P7036, type_obj
    .const 'Sub' $P7037 = "476_1303739803.72" 
    $P7036."add_method"(type_obj, "colonpair", $P7037)
    get_how $P7038, type_obj
    .const 'Sub' $P7039 = "477_1303739803.72" 
    $P7038."add_method"(type_obj, "variable", $P7039)
    get_how $P7040, type_obj
    .const 'Sub' $P7041 = "480_1303739803.72" 
    $P7040."add_method"(type_obj, "package_declarator:sym<module>", $P7041)
    get_how $P7042, type_obj
    .const 'Sub' $P7043 = "481_1303739803.72" 
    $P7042."add_method"(type_obj, "package_declarator:sym<knowhow>", $P7043)
    get_how $P7044, type_obj
    .const 'Sub' $P7045 = "482_1303739803.72" 
    $P7044."add_method"(type_obj, "package_declarator:sym<class>", $P7045)
    get_how $P7046, type_obj
    .const 'Sub' $P7047 = "483_1303739803.72" 
    $P7046."add_method"(type_obj, "package_declarator:sym<grammar>", $P7047)
    get_how $P7048, type_obj
    .const 'Sub' $P7049 = "484_1303739803.72" 
    $P7048."add_method"(type_obj, "package_declarator:sym<role>", $P7049)
    get_how $P7050, type_obj
    .const 'Sub' $P7051 = "485_1303739803.72" 
    $P7050."add_method"(type_obj, "package_declarator:sym<native>", $P7051)
    get_how $P7052, type_obj
    .const 'Sub' $P7053 = "486_1303739803.72" 
    $P7052."add_method"(type_obj, "package_def", $P7053)
    get_how $P7054, type_obj
    .const 'Sub' $P7055 = "489_1303739803.72" 
    $P7054."add_method"(type_obj, "scope_declarator:sym<my>", $P7055)
    get_how $P7056, type_obj
    .const 'Sub' $P7057 = "490_1303739803.72" 
    $P7056."add_method"(type_obj, "scope_declarator:sym<our>", $P7057)
    get_how $P7058, type_obj
    .const 'Sub' $P7059 = "491_1303739803.72" 
    $P7058."add_method"(type_obj, "scope_declarator:sym<has>", $P7059)
    get_how $P7060, type_obj
    .const 'Sub' $P7061 = "492_1303739803.72" 
    $P7060."add_method"(type_obj, "scoped", $P7061)
    get_how $P7062, type_obj
    .const 'Sub' $P7063 = "493_1303739803.72" 
    $P7062."add_method"(type_obj, "declarator", $P7063)
    get_how $P7064, type_obj
    .const 'Sub' $P7065 = "494_1303739803.72" 
    $P7064."add_method"(type_obj, "multi_declarator:sym<multi>", $P7065)
    get_how $P7066, type_obj
    .const 'Sub' $P7067 = "495_1303739803.72" 
    $P7066."add_method"(type_obj, "multi_declarator:sym<proto>", $P7067)
    get_how $P7068, type_obj
    .const 'Sub' $P7069 = "496_1303739803.72" 
    $P7068."add_method"(type_obj, "multi_declarator:sym<null>", $P7069)
    get_how $P7070, type_obj
    .const 'Sub' $P7071 = "497_1303739803.72" 
    $P7070."add_method"(type_obj, "variable_declarator", $P7071)
    get_how $P7072, type_obj
    .const 'Sub' $P7073 = "500_1303739803.72" 
    $P7072."add_method"(type_obj, "routine_declarator:sym<sub>", $P7073)
    get_how $P7074, type_obj
    .const 'Sub' $P7075 = "501_1303739803.72" 
    $P7074."add_method"(type_obj, "routine_declarator:sym<method>", $P7075)
    get_how $P7076, type_obj
    .const 'Sub' $P7077 = "502_1303739803.72" 
    $P7076."add_method"(type_obj, "routine_def", $P7077)
    get_how $P7078, type_obj
    .const 'Sub' $P7079 = "509_1303739803.72" 
    $P7078."add_method"(type_obj, "method_def", $P7079)
    get_how $P7080, type_obj
    .const 'Sub' $P7081 = "512_1303739803.72" 
    $P7080."add_method"(type_obj, "signature", $P7081)
    get_how $P7082, type_obj
    .const 'Sub' $P7083 = "515_1303739803.72" 
    $P7082."add_method"(type_obj, "parameter", $P7083)
    get_how $P7084, type_obj
    .const 'Sub' $P7085 = "516_1303739803.72" 
    $P7084."add_method"(type_obj, "param_var", $P7085)
    get_how $P7086, type_obj
    .const 'Sub' $P7087 = "517_1303739803.72" 
    $P7086."add_method"(type_obj, "named_param", $P7087)
    get_how $P7088, type_obj
    .const 'Sub' $P7089 = "518_1303739803.72" 
    $P7088."add_method"(type_obj, "typename", $P7089)
    get_how $P7090, type_obj
    .const 'Sub' $P7091 = "519_1303739803.72" 
    $P7090."add_method"(type_obj, "trait", $P7091)
    get_how $P7092, type_obj
    .const 'Sub' $P7093 = "520_1303739803.72" 
    $P7092."add_method"(type_obj, "trait_mod:sym<is>", $P7093)
    get_how $P7094, type_obj
    .const 'Sub' $P7095 = "522_1303739803.72" 
    $P7094."add_method"(type_obj, "regex_declarator", $P7095)
    get_how $P7096, type_obj
    .const 'Sub' $P7097 = "526_1303739803.72" 
    $P7096."add_method"(type_obj, "dotty", $P7097)
    get_how $P7098, type_obj
    .const 'Sub' $P7099 = "527_1303739803.72" 
    $P7098."add_method"(type_obj, "term:sym<self>", $P7099)
    get_how $P7100, type_obj
    .const 'Sub' $P7101 = "528_1303739803.72" 
    $P7100."add_method"(type_obj, "term:sym<identifier>", $P7101)
    get_how $P7102, type_obj
    .const 'Sub' $P7103 = "529_1303739803.72" 
    $P7102."add_method"(type_obj, "term:sym<name>", $P7103)
    get_how $P7104, type_obj
    .const 'Sub' $P7105 = "531_1303739803.72" 
    $P7104."add_method"(type_obj, "term:sym<pir::op>", $P7105)
    get_how $P7106, type_obj
    .const 'Sub' $P7107 = "532_1303739803.72" 
    $P7106."add_method"(type_obj, "term:sym<onlystar>", $P7107)
    get_how $P7108, type_obj
    .const 'Sub' $P7109 = "533_1303739803.72" 
    $P7108."add_method"(type_obj, "args", $P7109)
    get_how $P7110, type_obj
    .const 'Sub' $P7111 = "534_1303739803.72" 
    $P7110."add_method"(type_obj, "arglist", $P7111)
    get_how $P7112, type_obj
    .const 'Sub' $P7113 = "537_1303739803.72" 
    $P7112."add_method"(type_obj, "term:sym<multi_declarator>", $P7113)
    get_how $P7114, type_obj
    .const 'Sub' $P7115 = "538_1303739803.72" 
    $P7114."add_method"(type_obj, "term:sym<value>", $P7115)
    get_how $P7116, type_obj
    .const 'Sub' $P7117 = "539_1303739803.72" 
    $P7116."add_method"(type_obj, "circumfix:sym<( )>", $P7117)
    get_how $P7118, type_obj
    .const 'Sub' $P7119 = "540_1303739803.72" 
    $P7118."add_method"(type_obj, "circumfix:sym<[ ]>", $P7119)
    get_how $P7120, type_obj
    .const 'Sub' $P7121 = "541_1303739803.72" 
    $P7120."add_method"(type_obj, "circumfix:sym<ang>", $P7121)
    get_how $P7122, type_obj
    .const 'Sub' $P7123 = "542_1303739803.72" 
    $P7122."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P7123)
    get_how $P7124, type_obj
    .const 'Sub' $P7125 = "543_1303739803.72" 
    $P7124."add_method"(type_obj, "circumfix:sym<{ }>", $P7125)
    get_how $P7126, type_obj
    .const 'Sub' $P7127 = "545_1303739803.72" 
    $P7126."add_method"(type_obj, "circumfix:sym<sigil>", $P7127)
    get_how $P7128, type_obj
    .const 'Sub' $P7129 = "546_1303739803.72" 
    $P7128."add_method"(type_obj, "semilist", $P7129)
    get_how $P7130, type_obj
    .const 'Sub' $P7131 = "547_1303739803.72" 
    $P7130."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P7131)
    get_how $P7132, type_obj
    .const 'Sub' $P7133 = "548_1303739803.72" 
    $P7132."add_method"(type_obj, "postcircumfix:sym<{ }>", $P7133)
    get_how $P7134, type_obj
    .const 'Sub' $P7135 = "549_1303739803.72" 
    $P7134."add_method"(type_obj, "postcircumfix:sym<ang>", $P7135)
    get_how $P7136, type_obj
    .const 'Sub' $P7137 = "550_1303739803.72" 
    $P7136."add_method"(type_obj, "postcircumfix:sym<( )>", $P7137)
    get_how $P7138, type_obj
    .const 'Sub' $P7139 = "551_1303739803.72" 
    $P7138."add_method"(type_obj, "value", $P7139)
    get_how $P7140, type_obj
    .const 'Sub' $P7141 = "552_1303739803.72" 
    $P7140."add_method"(type_obj, "number", $P7141)
    get_how $P7142, type_obj
    .const 'Sub' $P7143 = "553_1303739803.72" 
    $P7142."add_method"(type_obj, "quote:sym<apos>", $P7143)
    get_how $P7144, type_obj
    .const 'Sub' $P7145 = "554_1303739803.72" 
    $P7144."add_method"(type_obj, "quote:sym<dblq>", $P7145)
    get_how $P7146, type_obj
    .const 'Sub' $P7147 = "555_1303739803.72" 
    $P7146."add_method"(type_obj, "quote:sym<qq>", $P7147)
    get_how $P7148, type_obj
    .const 'Sub' $P7149 = "556_1303739803.72" 
    $P7148."add_method"(type_obj, "quote:sym<q>", $P7149)
    get_how $P7150, type_obj
    .const 'Sub' $P7151 = "557_1303739803.72" 
    $P7150."add_method"(type_obj, "quote:sym<Q>", $P7151)
    get_how $P7152, type_obj
    .const 'Sub' $P7153 = "558_1303739803.72" 
    $P7152."add_method"(type_obj, "quote:sym<Q:PIR>", $P7153)
    get_how $P7154, type_obj
    .const 'Sub' $P7155 = "559_1303739803.72" 
    $P7154."add_method"(type_obj, "quote:sym</ />", $P7155)
    get_how $P7156, type_obj
    .const 'Sub' $P7157 = "560_1303739803.72" 
    $P7156."add_method"(type_obj, "quote_escape:sym<$>", $P7157)
    get_how $P7158, type_obj
    .const 'Sub' $P7159 = "561_1303739803.72" 
    $P7158."add_method"(type_obj, "quote_escape:sym<{ }>", $P7159)
    get_how $P7160, type_obj
    .const 'Sub' $P7161 = "562_1303739803.72" 
    $P7160."add_method"(type_obj, "quote_escape:sym<esc>", $P7161)
    get_how $P7162, type_obj
    .const 'Sub' $P7163 = "563_1303739803.72" 
    $P7162."add_method"(type_obj, "postfix:sym<.>", $P7163)
    get_how $P7164, type_obj
    .const 'Sub' $P7165 = "564_1303739803.72" 
    $P7164."add_method"(type_obj, "postfix:sym<++>", $P7165)
    get_how $P7166, type_obj
    .const 'Sub' $P7167 = "565_1303739803.72" 
    $P7166."add_method"(type_obj, "postfix:sym<-->", $P7167)
    get_how $P7168, type_obj
    .const 'Sub' $P7169 = "566_1303739803.72" 
    $P7168."add_method"(type_obj, "prefix:sym<make>", $P7169)
    get_how $P7170, type_obj
    .const 'Sub' $P7171 = "567_1303739803.72" 
    $P7170."add_method"(type_obj, "term:sym<next>", $P7171)
    get_how $P7172, type_obj
    .const 'Sub' $P7173 = "568_1303739803.72" 
    $P7172."add_method"(type_obj, "term:sym<last>", $P7173)
    get_how $P7174, type_obj
    .const 'Sub' $P7175 = "569_1303739803.72" 
    $P7174."add_method"(type_obj, "term:sym<redo>", $P7175)
    get_how $P7176, type_obj
    .const 'Sub' $P7177 = "570_1303739803.72" 
    $P7176."add_method"(type_obj, "infix:sym<~~>", $P7177)
    get_how $P7178, type_obj
    get_hll_global $P7179, ["HLL"], "Actions"
    $P7178."add_parent"(type_obj, $P7179)
    get_how $P7180, type_obj
    $P7181 = $P7180."compose"(type_obj)
    .return ($P7181)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("407_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_2759
.annotate 'line', 771
    .lex "$xblock", param_2759
.annotate 'line', 772
    find_lex $P2760, "$xblock"
    unless_null $P2760, vivify_1456
    $P2760 = root_new ['parrot';'ResizablePMCArray']
  vivify_1456:
    set $P2761, $P2760[1]
    unless_null $P2761, vivify_1457
    new $P2761, "Undef"
  vivify_1457:
    $P2762 = "block_immediate"($P2761)
    find_lex $P2763, "$xblock"
    unless_null $P2763, vivify_1458
    $P2763 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2763
  vivify_1458:
    set $P2763[1], $P2762
    find_lex $P2764, "$xblock"
    unless_null $P2764, vivify_1459
    new $P2764, "Undef"
  vivify_1459:
.annotate 'line', 771
    .return ($P2764)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("408_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_2767
.annotate 'line', 776
    .const 'Sub' $P2777 = "409_1303739803.72" 
    capture_lex $P2777
    .lex "$block", param_2767
.annotate 'line', 777
    find_lex $P2768, "$block"
    unless_null $P2768, vivify_1460
    new $P2768, "Undef"
  vivify_1460:
    $P2768."blocktype"("immediate")
.annotate 'line', 778
    find_lex $P2772, "$block"
    unless_null $P2772, vivify_1461
    new $P2772, "Undef"
  vivify_1461:
    $P2773 = $P2772."symtable"()
    unless $P2773, unless_2771
    set $P2770, $P2773
    goto unless_2771_end
  unless_2771:
    find_lex $P2774, "$block"
    unless_null $P2774, vivify_1462
    new $P2774, "Undef"
  vivify_1462:
    $P2775 = $P2774."handlers"()
    set $P2770, $P2775
  unless_2771_end:
    if $P2770, unless_2769_end
    .const 'Sub' $P2777 = "409_1303739803.72" 
    capture_lex $P2777
    $P2777()
  unless_2769_end:
    find_lex $P2800, "$block"
    unless_null $P2800, vivify_1469
    new $P2800, "Undef"
  vivify_1469:
.annotate 'line', 776
    .return ($P2800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2776"  :anon :subid("409_1303739803.72") :outer("408_1303739803.72")
.annotate 'line', 778
    .const 'Sub' $P2791 = "410_1303739803.72" 
    capture_lex $P2791
.annotate 'line', 779
    new $P2778, "Undef"
    .lex "$stmts", $P2778
    get_hll_global $P2779, "GLOBAL"
    nqp_get_package_through_who $P2780, $P2779, "PAST"
    get_who $P2781, $P2780
    set $P2782, $P2781["Stmts"]
    find_lex $P2783, "$block"
    unless_null $P2783, vivify_1463
    new $P2783, "Undef"
  vivify_1463:
    $P2784 = $P2782."new"($P2783 :named("node"))
    store_lex "$stmts", $P2784
.annotate 'line', 780
    find_lex $P2786, "$block"
    unless_null $P2786, vivify_1464
    new $P2786, "Undef"
  vivify_1464:
    $P2787 = $P2786."list"()
    defined $I2788, $P2787
    unless $I2788, for_undef_1465
    iter $P2785, $P2787
    new $P2797, 'ExceptionHandler'
    set_label $P2797, loop2796_handler
    $P2797."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2797
  loop2796_test:
    unless $P2785, loop2796_done
    shift $P2789, $P2785
  loop2796_redo:
    .const 'Sub' $P2791 = "410_1303739803.72" 
    capture_lex $P2791
    $P2791($P2789)
  loop2796_next:
    goto loop2796_test
  loop2796_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2798, exception, 'type'
    eq $P2798, .CONTROL_LOOP_NEXT, loop2796_next
    eq $P2798, .CONTROL_LOOP_REDO, loop2796_redo
  loop2796_done:
    pop_eh 
  for_undef_1465:
.annotate 'line', 781
    find_lex $P2799, "$stmts"
    unless_null $P2799, vivify_1468
    new $P2799, "Undef"
  vivify_1468:
    store_lex "$block", $P2799
.annotate 'line', 778
    .return ($P2799)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2790"  :anon :subid("410_1303739803.72") :outer("409_1303739803.72")
    .param pmc param_2792
.annotate 'line', 780
    .lex "$_", param_2792
    find_lex $P2793, "$stmts"
    unless_null $P2793, vivify_1466
    new $P2793, "Undef"
  vivify_1466:
    find_lex $P2794, "$_"
    unless_null $P2794, vivify_1467
    new $P2794, "Undef"
  vivify_1467:
    $P2795 = $P2793."push"($P2794)
    .return ($P2795)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("411_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_2803
.annotate 'line', 786
    .lex "$sigil", param_2803
.annotate 'line', 787
    find_lex $P2806, "$sigil"
    unless_null $P2806, vivify_1470
    new $P2806, "Undef"
  vivify_1470:
    set $S2807, $P2806
    iseq $I2808, $S2807, "%"
    if $I2808, if_2805
.annotate 'line', 789
    find_lex $P2816, "$sigil"
    unless_null $P2816, vivify_1471
    new $P2816, "Undef"
  vivify_1471:
    set $S2817, $P2816
    iseq $I2818, $S2817, "@"
    if $I2818, if_2815
    new $P2824, "String"
    assign $P2824, "Undef"
    set $P2814, $P2824
    goto if_2815_end
  if_2815:
.annotate 'line', 790
    get_hll_global $P2819, "GLOBAL"
    nqp_get_package_through_who $P2820, $P2819, "PAST"
    get_who $P2821, $P2820
    set $P2822, $P2821["Op"]
    $P2823 = $P2822."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2814, $P2823
  if_2815_end:
    set $P2804, $P2814
.annotate 'line', 787
    goto if_2805_end
  if_2805:
.annotate 'line', 788
    get_hll_global $P2809, "GLOBAL"
    nqp_get_package_through_who $P2810, $P2809, "PAST"
    get_who $P2811, $P2810
    set $P2812, $P2811["Op"]
    $P2813 = $P2812."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2804, $P2813
  if_2805_end:
.annotate 'line', 786
    .return ($P2804)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("412_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_2827
.annotate 'line', 805
    .lex "$ast", param_2827
.annotate 'line', 806
    get_hll_global $P2830, "GLOBAL"
    nqp_get_package_through_who $P2831, $P2830, "PAST"
    get_who $P2832, $P2831
    set $P2833, $P2832["Op"]
    find_lex $P2834, "$ast"
    unless_null $P2834, vivify_1472
    new $P2834, "Undef"
  vivify_1472:
    $P2835 = $P2833."ACCEPTS"($P2834)
    if $P2835, if_2829
.annotate 'line', 808
    find_lex $P2839, "$ast"
    unless_null $P2839, vivify_1473
    new $P2839, "Undef"
  vivify_1473:
    $P2840 = $P2839."value"()
    set $P2828, $P2840
.annotate 'line', 806
    goto if_2829_end
  if_2829:
.annotate 'line', 807
    find_lex $P2836, "$ast"
    unless_null $P2836, vivify_1474
    new $P2836, "Undef"
  vivify_1474:
    $P2837 = $P2836."list"()
    join $S2838, " ", $P2837
    new $P2828, 'String'
    set $P2828, $S2838
  if_2829_end:
.annotate 'line', 805
    .return ($P2828)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("413_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_2843
.annotate 'line', 968
    .const 'Sub' $P2855 = "414_1303739803.72" 
    capture_lex $P2855
    .lex "$UNIT", param_2843
.annotate 'line', 970
    find_lex $P2846, "$UNIT"
    unless_null $P2846, vivify_1475
    new $P2846, "Undef"
  vivify_1475:
    exists $I2847, $P2846["EXPORTHOW"]
    if $I2847, if_2845
    new $P2844, 'Integer'
    set $P2844, $I2847
    goto if_2845_end
  if_2845:
.annotate 'line', 971
    find_lex $P2849, "$UNIT"
    unless_null $P2849, vivify_1476
    $P2849 = root_new ['parrot';'Hash']
  vivify_1476:
    set $P2850, $P2849["EXPORTHOW"]
    unless_null $P2850, vivify_1477
    new $P2850, "Undef"
  vivify_1477:
    get_who $P2851, $P2850
    defined $I2852, $P2851
    unless $I2852, for_undef_1478
    iter $P2848, $P2851
    new $P2865, 'ExceptionHandler'
    set_label $P2865, loop2864_handler
    $P2865."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2865
  loop2864_test:
    unless $P2848, loop2864_done
    shift $P2853, $P2848
  loop2864_redo:
    .const 'Sub' $P2855 = "414_1303739803.72" 
    capture_lex $P2855
    $P2855($P2853)
  loop2864_next:
    goto loop2864_test
  loop2864_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2866, exception, 'type'
    eq $P2866, .CONTROL_LOOP_NEXT, loop2864_next
    eq $P2866, .CONTROL_LOOP_REDO, loop2864_redo
  loop2864_done:
    pop_eh 
  for_undef_1478:
.annotate 'line', 970
    set $P2844, $P2848
  if_2845_end:
.annotate 'line', 968
    .return ($P2844)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2854"  :anon :subid("414_1303739803.72") :outer("413_1303739803.72")
    .param pmc param_2856
.annotate 'line', 971
    .lex "$_", param_2856
.annotate 'line', 972
    find_lex $P2857, "$_"
    unless_null $P2857, vivify_1479
    new $P2857, "Undef"
  vivify_1479:
    $P2858 = $P2857."value"()
    find_lex $P2859, "$_"
    unless_null $P2859, vivify_1480
    new $P2859, "Undef"
  vivify_1480:
    $P2860 = $P2859."key"()
    find_dynamic_lex $P2863, "%*HOW"
    unless_null $P2863, vivify_1481
    get_hll_global $P2861, "GLOBAL"
    get_who $P2862, $P2861
    set $P2863, $P2862["%HOW"]
    unless_null $P2863, vivify_1482
    die "Contextual %*HOW not found"
  vivify_1482:
    store_dynamic_lex "%*HOW", $P2863
  vivify_1481:
    set $P2863[$P2860], $P2858
.annotate 'line', 971
    .return ($P2858)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("415_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_2869
    .param pmc param_2870
.annotate 'line', 1073
    .lex "$/", param_2869
    .lex "$block", param_2870
.annotate 'line', 1074
    find_lex $P2872, "$?PACKAGE"
    get_who $P2873, $P2872
    set $P2874, $P2873["@BLOCK"]
    unless_null $P2874, vivify_1483
    $P2874 = root_new ['parrot';'ResizablePMCArray']
  vivify_1483:
    set $P2875, $P2874[0]
    unless_null $P2875, vivify_1484
    new $P2875, "Undef"
  vivify_1484:
    $P2876 = $P2875."handlers"()
    if $P2876, unless_2871_end
.annotate 'line', 1075
    find_lex $P2877, "$?PACKAGE"
    get_who $P2878, $P2877
    set $P2879, $P2878["@BLOCK"]
    unless_null $P2879, vivify_1485
    $P2879 = root_new ['parrot';'ResizablePMCArray']
  vivify_1485:
    set $P2880, $P2879[0]
    unless_null $P2880, vivify_1486
    new $P2880, "Undef"
  vivify_1486:
    new $P2881, "ResizablePMCArray"
    $P2880."handlers"($P2881)
  unless_2871_end:
.annotate 'line', 1077
    find_lex $P2883, "$block"
    unless_null $P2883, vivify_1487
    new $P2883, "Undef"
  vivify_1487:
    $P2884 = $P2883."arity"()
    if $P2884, unless_2882_end
.annotate 'line', 1078
    find_lex $P2885, "$block"
    unless_null $P2885, vivify_1488
    new $P2885, "Undef"
  vivify_1488:
.annotate 'line', 1079
    get_hll_global $P2886, "GLOBAL"
    nqp_get_package_through_who $P2887, $P2886, "PAST"
    get_who $P2888, $P2887
    set $P2889, $P2888["Op"]
.annotate 'line', 1080
    get_hll_global $P2890, "GLOBAL"
    nqp_get_package_through_who $P2891, $P2890, "PAST"
    get_who $P2892, $P2891
    set $P2893, $P2892["Var"]
    $P2894 = $P2893."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1081
    get_hll_global $P2895, "GLOBAL"
    nqp_get_package_through_who $P2896, $P2895, "PAST"
    get_who $P2897, $P2896
    set $P2898, $P2897["Var"]
    $P2899 = $P2898."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2900 = $P2889."new"($P2894, $P2899, "bind" :named("pasttype"))
.annotate 'line', 1079
    $P2885."unshift"($P2900)
.annotate 'line', 1084
    find_lex $P2901, "$block"
    unless_null $P2901, vivify_1489
    new $P2901, "Undef"
  vivify_1489:
    get_hll_global $P2902, "GLOBAL"
    nqp_get_package_through_who $P2903, $P2902, "PAST"
    get_who $P2904, $P2903
    set $P2905, $P2904["Var"]
    $P2906 = $P2905."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2901."unshift"($P2906)
.annotate 'line', 1085
    find_lex $P2907, "$block"
    unless_null $P2907, vivify_1490
    new $P2907, "Undef"
  vivify_1490:
    $P2907."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1086
    find_lex $P2908, "$block"
    unless_null $P2908, vivify_1491
    new $P2908, "Undef"
  vivify_1491:
    $P2908."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1087
    find_lex $P2909, "$block"
    unless_null $P2909, vivify_1492
    new $P2909, "Undef"
  vivify_1492:
    $P2909."arity"(1)
  unless_2882_end:
.annotate 'line', 1089
    find_lex $P2910, "$block"
    unless_null $P2910, vivify_1493
    new $P2910, "Undef"
  vivify_1493:
    $P2910."blocktype"("declaration")
.annotate 'line', 1090
    find_lex $P2911, "$?PACKAGE"
    get_who $P2912, $P2911
    set $P2913, $P2912["@BLOCK"]
    unless_null $P2913, vivify_1494
    $P2913 = root_new ['parrot';'ResizablePMCArray']
  vivify_1494:
    set $P2914, $P2913[0]
    unless_null $P2914, vivify_1495
    new $P2914, "Undef"
  vivify_1495:
    $P2915 = $P2914."handlers"()
.annotate 'line', 1091
    get_hll_global $P2916, "GLOBAL"
    nqp_get_package_through_who $P2917, $P2916, "PAST"
    get_who $P2918, $P2917
    set $P2919, $P2918["Control"]
    find_lex $P2920, "$/"
    unless_null $P2920, vivify_1496
    new $P2920, "Undef"
  vivify_1496:
.annotate 'line', 1093
    get_hll_global $P2921, "GLOBAL"
    nqp_get_package_through_who $P2922, $P2921, "PAST"
    get_who $P2923, $P2922
    set $P2924, $P2923["Stmts"]
.annotate 'line', 1094
    get_hll_global $P2925, "GLOBAL"
    nqp_get_package_through_who $P2926, $P2925, "PAST"
    get_who $P2927, $P2926
    set $P2928, $P2927["Op"]
    find_lex $P2929, "$block"
    unless_null $P2929, vivify_1497
    new $P2929, "Undef"
  vivify_1497:
.annotate 'line', 1096
    get_hll_global $P2930, "GLOBAL"
    nqp_get_package_through_who $P2931, $P2930, "PAST"
    get_who $P2932, $P2931
    set $P2933, $P2932["Var"]
    $P2934 = $P2933."new"("register" :named("scope"), "exception" :named("name"))
    $P2935 = $P2928."new"($P2929, $P2934, "call" :named("pasttype"))
.annotate 'line', 1098
    get_hll_global $P2936, "GLOBAL"
    nqp_get_package_through_who $P2937, $P2936, "PAST"
    get_who $P2938, $P2937
    set $P2939, $P2938["Op"]
.annotate 'line', 1099
    get_hll_global $P2940, "GLOBAL"
    nqp_get_package_through_who $P2941, $P2940, "PAST"
    get_who $P2942, $P2941
    set $P2943, $P2942["Var"]
.annotate 'line', 1100
    get_hll_global $P2944, "GLOBAL"
    nqp_get_package_through_who $P2945, $P2944, "PAST"
    get_who $P2946, $P2945
    set $P2947, $P2946["Var"]
    $P2948 = $P2947."new"("register" :named("scope"), "exception" :named("name"))
    $P2949 = $P2943."new"($P2948, "handled", "keyed" :named("scope"))
.annotate 'line', 1099
    $P2950 = $P2939."new"($P2949, 1, "bind" :named("pasttype"))
.annotate 'line', 1098
    $P2951 = $P2924."new"($P2935, $P2950)
.annotate 'line', 1093
    $P2952 = $P2919."new"($P2951, $P2920 :named("node"))
.annotate 'line', 1091
    $P2953 = $P2915."unshift"($P2952)
.annotate 'line', 1073
    .return ($P2953)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("416_1303739803.72") :outer("406_1303739803.72")
.annotate 'line', 1639
    new $P2956, "Undef"
    .lex "$past", $P2956
    find_lex $P2957, "$?PACKAGE"
    get_who $P2958, $P2957
    set $P2959, $P2958["@BLOCK"]
    unless_null $P2959, vivify_1498
    $P2959 = root_new ['parrot';'ResizablePMCArray']
  vivify_1498:
    $P2960 = $P2959."shift"()
    store_lex "$past", $P2960
.annotate 'line', 1640
    find_lex $P2961, "$past"
    unless_null $P2961, vivify_1499
    new $P2961, "Undef"
  vivify_1499:
    $P2961."closure"(1)
.annotate 'line', 1641
    find_lex $P2962, "$past"
    unless_null $P2962, vivify_1500
    new $P2962, "Undef"
  vivify_1500:
    get_hll_global $P2963, "GLOBAL"
    nqp_get_package_through_who $P2964, $P2963, "PAST"
    get_who $P2965, $P2964
    set $P2966, $P2965["Op"]
    $P2967 = $P2966."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2962."push"($P2967)
    find_lex $P2968, "$past"
    unless_null $P2968, vivify_1501
    new $P2968, "Undef"
  vivify_1501:
.annotate 'line', 1638
    .return ($P2968)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("417_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_2971
.annotate 'line', 1647
    .const 'Sub' $P2991 = "418_1303739803.72" 
    capture_lex $P2991
    .lex "$routine", param_2971
.annotate 'line', 1651
    new $P2972, "Undef"
    .lex "$types", $P2972
.annotate 'line', 1652
    new $P2973, "Undef"
    .lex "$definednesses", $P2973
.annotate 'line', 1651
    get_hll_global $P2974, "GLOBAL"
    nqp_get_package_through_who $P2975, $P2974, "PAST"
    get_who $P2976, $P2975
    set $P2977, $P2976["Op"]
    $P2978 = $P2977."new"("list" :named("pasttype"))
    store_lex "$types", $P2978
.annotate 'line', 1652
    get_hll_global $P2979, "GLOBAL"
    nqp_get_package_through_who $P2980, $P2979, "PAST"
    get_who $P2981, $P2980
    set $P2982, $P2981["Op"]
    $P2983 = $P2982."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2983
.annotate 'line', 1653
    find_lex $P2985, "$routine"
    unless_null $P2985, vivify_1502
    $P2985 = root_new ['parrot';'ResizablePMCArray']
  vivify_1502:
    set $P2986, $P2985[0]
    unless_null $P2986, vivify_1503
    new $P2986, "Undef"
  vivify_1503:
    $P2987 = $P2986."list"()
    defined $I2988, $P2987
    unless $I2988, for_undef_1504
    iter $P2984, $P2987
    new $P3035, 'ExceptionHandler'
    set_label $P3035, loop3034_handler
    $P3035."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3035
  loop3034_test:
    unless $P2984, loop3034_done
    shift $P2989, $P2984
  loop3034_redo:
    .const 'Sub' $P2991 = "418_1303739803.72" 
    capture_lex $P2991
    $P2991($P2989)
  loop3034_next:
    goto loop3034_test
  loop3034_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3036, exception, 'type'
    eq $P3036, .CONTROL_LOOP_NEXT, loop3034_next
    eq $P3036, .CONTROL_LOOP_REDO, loop3034_redo
  loop3034_done:
    pop_eh 
  for_undef_1504:
.annotate 'line', 1660
    find_lex $P3037, "$routine"
    unless_null $P3037, vivify_1514
    new $P3037, "Undef"
  vivify_1514:
    $P3038 = $P3037."loadinit"()
    get_hll_global $P3039, "GLOBAL"
    nqp_get_package_through_who $P3040, $P3039, "PAST"
    get_who $P3041, $P3040
    set $P3042, $P3041["Op"]
.annotate 'line', 1661
    get_hll_global $P3043, "GLOBAL"
    nqp_get_package_through_who $P3044, $P3043, "PAST"
    get_who $P3045, $P3044
    set $P3046, $P3045["Var"]
    $P3047 = $P3046."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P3048, "$types"
    unless_null $P3048, vivify_1515
    new $P3048, "Undef"
  vivify_1515:
    find_lex $P3049, "$definednesses"
    unless_null $P3049, vivify_1516
    new $P3049, "Undef"
  vivify_1516:
    $P3050 = $P3042."new"($P3047, $P3048, $P3049, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1660
    $P3051 = $P3038."push"($P3050)
.annotate 'line', 1647
    .return ($P3051)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2990"  :anon :subid("418_1303739803.72") :outer("417_1303739803.72")
    .param pmc param_2992
.annotate 'line', 1653
    .lex "$_", param_2992
.annotate 'line', 1654
    get_hll_global $P2997, "GLOBAL"
    nqp_get_package_through_who $P2998, $P2997, "PAST"
    get_who $P2999, $P2998
    set $P3000, $P2999["Var"]
    find_lex $P3001, "$_"
    unless_null $P3001, vivify_1505
    new $P3001, "Undef"
  vivify_1505:
    $P3002 = $P3000."ACCEPTS"($P3001)
    if $P3002, if_2996
    set $P2995, $P3002
    goto if_2996_end
  if_2996:
    find_lex $P3003, "$_"
    unless_null $P3003, vivify_1506
    new $P3003, "Undef"
  vivify_1506:
    $S3004 = $P3003."scope"()
    iseq $I3005, $S3004, "parameter"
    new $P2995, 'Integer'
    set $P2995, $I3005
  if_2996_end:
    if $P2995, if_2994
    set $P2993, $P2995
    goto if_2994_end
  if_2994:
.annotate 'line', 1655
    find_lex $P3006, "$types"
    unless_null $P3006, vivify_1507
    new $P3006, "Undef"
  vivify_1507:
    find_lex $P3008, "$_"
    unless_null $P3008, vivify_1508
    new $P3008, "Undef"
  vivify_1508:
    $P3009 = $P3008."multitype"()
    set $P3007, $P3009
    defined $I3011, $P3007
    if $I3011, default_3010
    get_hll_global $P3012, "GLOBAL"
    nqp_get_package_through_who $P3013, $P3012, "PAST"
    get_who $P3014, $P3013
    set $P3015, $P3014["Op"]
    $P3016 = $P3015."new"("null P" :named("pirop"))
    set $P3007, $P3016
  default_3010:
    $P3006."push"($P3007)
.annotate 'line', 1656
    find_lex $P3017, "$definednesses"
    unless_null $P3017, vivify_1509
    new $P3017, "Undef"
  vivify_1509:
    find_lex $P3020, "$_"
    unless_null $P3020, vivify_1510
    $P3020 = root_new ['parrot';'Hash']
  vivify_1510:
    set $P3021, $P3020["definedness"]
    unless_null $P3021, vivify_1511
    new $P3021, "Undef"
  vivify_1511:
    set $S3022, $P3021
    iseq $I3023, $S3022, "D"
    if $I3023, if_3019
.annotate 'line', 1657
    find_lex $P3027, "$_"
    unless_null $P3027, vivify_1512
    $P3027 = root_new ['parrot';'Hash']
  vivify_1512:
    set $P3028, $P3027["definedness"]
    unless_null $P3028, vivify_1513
    new $P3028, "Undef"
  vivify_1513:
    set $S3029, $P3028
    iseq $I3030, $S3029, "U"
    if $I3030, if_3026
    new $P3032, "Integer"
    assign $P3032, 0
    set $P3025, $P3032
    goto if_3026_end
  if_3026:
    new $P3031, "Integer"
    assign $P3031, 2
    set $P3025, $P3031
  if_3026_end:
    set $P3018, $P3025
.annotate 'line', 1656
    goto if_3019_end
  if_3019:
    new $P3024, "Integer"
    assign $P3024, 1
    set $P3018, $P3024
  if_3019_end:
    $P3033 = $P3017."push"($P3018)
.annotate 'line', 1654
    set $P2993, $P3033
  if_2994_end:
.annotate 'line', 1653
    .return ($P2993)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("419_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3054
    .param pmc param_3055
.annotate 'line', 2117
    .lex "$/", param_3054
    .lex "$type", param_3055
.annotate 'line', 2118
    find_lex $P3056, "$/"
    get_hll_global $P3057, "GLOBAL"
    nqp_get_package_through_who $P3058, $P3057, "PAST"
    get_who $P3059, $P3058
    set $P3060, $P3059["Op"]
    find_lex $P3061, "$/"
    unless_null $P3061, vivify_1517
    new $P3061, "Undef"
  vivify_1517:
.annotate 'line', 2122
    get_hll_global $P3062, "GLOBAL"
    nqp_get_package_through_who $P3063, $P3062, "PAST"
    get_who $P3064, $P3063
    set $P3065, $P3064["Val"]
    find_lex $P3066, "$type"
    unless_null $P3066, vivify_1518
    new $P3066, "Undef"
  vivify_1518:
    $P3067 = $P3065."new"($P3066 :named("value"), "!except_types" :named("returns"))
    $P3068 = $P3060."new"(0, $P3067, $P3061 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2118
    $P3069 = $P3056."!make"($P3068)
.annotate 'line', 2117
    .return ($P3069)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("420_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3074
    .param pmc param_3075
.annotate 'line', 2136
    .const 'Sub' $P3128 = "421_1303739803.72" 
    capture_lex $P3128
    new $P3073, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3073, control_3072
    push_eh $P3073
    .lex "@name", param_3074
    .lex "$/", param_3075
.annotate 'line', 2142
    new $P3076, "Undef"
    .lex "$final_name", $P3076
.annotate 'line', 2143
    new $P3077, "Undef"
    .lex "$lookup", $P3077
.annotate 'line', 2138
    find_lex $P3079, "@name"
    unless_null $P3079, vivify_1519
    $P3079 = root_new ['parrot';'ResizablePMCArray']
  vivify_1519:
    set $N3080, $P3079
    iseq $I3081, $N3080, 0.0
    unless $I3081, if_3078_end
    find_lex $P3082, "$/"
    unless_null $P3082, vivify_1520
    new $P3082, "Undef"
  vivify_1520:
    $P3083 = $P3082."CURSOR"()
    $P3083."panic"("Cannot compile empty name")
  if_3078_end:
.annotate 'line', 2142
    find_lex $P3084, "@name"
    unless_null $P3084, vivify_1521
    $P3084 = root_new ['parrot';'ResizablePMCArray']
  vivify_1521:
    $P3085 = $P3084."pop"()
    store_lex "$final_name", $P3085
.annotate 'line', 2143
    get_hll_global $P3086, "GLOBAL"
    nqp_get_package_through_who $P3087, $P3086, "PAST"
    get_who $P3088, $P3087
    set $P3089, $P3088["Var"]
    find_lex $P3090, "$final_name"
    unless_null $P3090, vivify_1522
    new $P3090, "Undef"
  vivify_1522:
    set $S3091, $P3090
    $P3092 = $P3089."new"($S3091, "keyed" :named("scope"))
    store_lex "$lookup", $P3092
.annotate 'line', 2147
    find_lex $P3094, "@name"
    unless_null $P3094, vivify_1523
    $P3094 = root_new ['parrot';'ResizablePMCArray']
  vivify_1523:
    set $N3095, $P3094
    iseq $I3096, $N3095, 0.0
    if $I3096, if_3093
.annotate 'line', 2165
    .const 'Sub' $P3128 = "421_1303739803.72" 
    capture_lex $P3128
    $P3128()
    goto if_3093_end
  if_3093:
.annotate 'line', 2148
    find_lex $P3097, "$lookup"
    unless_null $P3097, vivify_1536
    new $P3097, "Undef"
  vivify_1536:
    get_hll_global $P3098, "GLOBAL"
    nqp_get_package_through_who $P3099, $P3098, "PAST"
    get_who $P3100, $P3099
    set $P3101, $P3100["Op"]
.annotate 'line', 2150
    get_hll_global $P3102, "GLOBAL"
    nqp_get_package_through_who $P3103, $P3102, "PAST"
    get_who $P3104, $P3103
    set $P3105, $P3104["Var"]
    $P3106 = $P3105."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P3107 = $P3101."new"($P3106, "get_who PP" :named("pirop"))
.annotate 'line', 2148
    $P3097."unshift"($P3107)
.annotate 'line', 2152
    find_lex $P3108, "$lookup"
    unless_null $P3108, vivify_1537
    new $P3108, "Undef"
  vivify_1537:
    get_hll_global $P3109, "GLOBAL"
    nqp_get_package_through_who $P3110, $P3109, "PAST"
    get_who $P3111, $P3110
    set $P3112, $P3111["Var"]
.annotate 'line', 2154
    get_hll_global $P3113, "GLOBAL"
    nqp_get_package_through_who $P3114, $P3113, "PAST"
    get_who $P3115, $P3114
    set $P3116, $P3115["Op"]
.annotate 'line', 2156
    get_hll_global $P3117, "GLOBAL"
    nqp_get_package_through_who $P3118, $P3117, "PAST"
    get_who $P3119, $P3118
    set $P3120, $P3119["Var"]
    new $P3121, "ResizablePMCArray"
    $P3122 = $P3120."new"("GLOBAL" :named("name"), $P3121 :named("namespace"), "package" :named("scope"))
    $P3123 = $P3116."new"($P3122, "get_who PP" :named("pirop"))
.annotate 'line', 2158
    find_lex $P3124, "$final_name"
    unless_null $P3124, vivify_1538
    new $P3124, "Undef"
  vivify_1538:
    set $S3125, $P3124
    $P3126 = $P3112."new"($P3123, $S3125, "keyed" :named("scope"))
.annotate 'line', 2152
    $P3108."viviself"($P3126)
  if_3093_end:
.annotate 'line', 2180
    new $P3180, "Exception"
    set $P3180['type'], .CONTROL_RETURN
    find_lex $P3181, "$lookup"
    unless_null $P3181, vivify_1539
    new $P3181, "Undef"
  vivify_1539:
    setattribute $P3180, 'payload', $P3181
    throw $P3180
.annotate 'line', 2136
    .return ()
  control_3072:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3182, exception, "payload"
    .return ($P3182)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3127"  :anon :subid("421_1303739803.72") :outer("420_1303739803.72")
.annotate 'line', 2165
    .const 'Sub' $P3159 = "422_1303739803.72" 
    capture_lex $P3159
.annotate 'line', 2166
    new $P3129, "Undef"
    .lex "$path", $P3129
    find_lex $P3132, "@name"
    unless_null $P3132, vivify_1524
    $P3132 = root_new ['parrot';'ResizablePMCArray']
  vivify_1524:
    set $P3133, $P3132[0]
    unless_null $P3133, vivify_1525
    new $P3133, "Undef"
  vivify_1525:
    $P3134 = "is_lexical"($P3133)
    if $P3134, if_3131
.annotate 'line', 2168
    get_hll_global $P3142, "GLOBAL"
    nqp_get_package_through_who $P3143, $P3142, "PAST"
    get_who $P3144, $P3143
    set $P3145, $P3144["Var"]
    new $P3146, "ResizablePMCArray"
    $P3147 = $P3145."new"("GLOBAL" :named("name"), $P3146 :named("namespace"), "package" :named("scope"))
    set $P3130, $P3147
.annotate 'line', 2166
    goto if_3131_end
  if_3131:
.annotate 'line', 2167
    get_hll_global $P3135, "GLOBAL"
    nqp_get_package_through_who $P3136, $P3135, "PAST"
    get_who $P3137, $P3136
    set $P3138, $P3137["Var"]
    find_lex $P3139, "@name"
    unless_null $P3139, vivify_1526
    $P3139 = root_new ['parrot';'ResizablePMCArray']
  vivify_1526:
    $P3140 = $P3139."shift"()
    $P3141 = $P3138."new"($P3140 :named("name"), "lexical" :named("scope"))
    set $P3130, $P3141
  if_3131_end:
.annotate 'line', 2166
    store_lex "$path", $P3130
.annotate 'line', 2169
    find_lex $P3149, "@name"
    unless_null $P3149, vivify_1527
    $P3149 = root_new ['parrot';'ResizablePMCArray']
  vivify_1527:
    set $P3150, $P3149[0]
    unless_null $P3150, vivify_1528
    new $P3150, "Undef"
  vivify_1528:
    set $S3151, $P3150
    iseq $I3152, $S3151, "GLOBAL"
    unless $I3152, if_3148_end
.annotate 'line', 2170
    find_lex $P3153, "@name"
    unless_null $P3153, vivify_1529
    $P3153 = root_new ['parrot';'ResizablePMCArray']
  vivify_1529:
    $P3153."shift"()
  if_3148_end:
.annotate 'line', 2172
    find_lex $P3155, "@name"
    unless_null $P3155, vivify_1530
    $P3155 = root_new ['parrot';'ResizablePMCArray']
  vivify_1530:
    defined $I3156, $P3155
    unless $I3156, for_undef_1531
    iter $P3154, $P3155
    new $P3170, 'ExceptionHandler'
    set_label $P3170, loop3169_handler
    $P3170."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3170
  loop3169_test:
    unless $P3154, loop3169_done
    shift $P3157, $P3154
  loop3169_redo:
    .const 'Sub' $P3159 = "422_1303739803.72" 
    capture_lex $P3159
    $P3159($P3157)
  loop3169_next:
    goto loop3169_test
  loop3169_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3171, exception, 'type'
    eq $P3171, .CONTROL_LOOP_NEXT, loop3169_next
    eq $P3171, .CONTROL_LOOP_REDO, loop3169_redo
  loop3169_done:
    pop_eh 
  for_undef_1531:
.annotate 'line', 2177
    find_lex $P3172, "$lookup"
    unless_null $P3172, vivify_1534
    new $P3172, "Undef"
  vivify_1534:
    get_hll_global $P3173, "GLOBAL"
    nqp_get_package_through_who $P3174, $P3173, "PAST"
    get_who $P3175, $P3174
    set $P3176, $P3175["Op"]
    find_lex $P3177, "$path"
    unless_null $P3177, vivify_1535
    new $P3177, "Undef"
  vivify_1535:
    $P3178 = $P3176."new"($P3177, "get_who PP" :named("pirop"))
    $P3179 = $P3172."unshift"($P3178)
.annotate 'line', 2165
    .return ($P3179)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3158"  :anon :subid("422_1303739803.72") :outer("421_1303739803.72")
    .param pmc param_3160
.annotate 'line', 2172
    .lex "$_", param_3160
.annotate 'line', 2173
    get_hll_global $P3161, "GLOBAL"
    nqp_get_package_through_who $P3162, $P3161, "PAST"
    get_who $P3163, $P3162
    set $P3164, $P3163["Op"]
    find_lex $P3165, "$path"
    unless_null $P3165, vivify_1532
    new $P3165, "Undef"
  vivify_1532:
.annotate 'line', 2175
    find_lex $P3166, "$_"
    unless_null $P3166, vivify_1533
    new $P3166, "Undef"
  vivify_1533:
    set $S3167, $P3166
    $P3168 = $P3164."new"($P3165, $S3167, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2173
    store_lex "$path", $P3168
.annotate 'line', 2172
    .return ($P3168)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("423_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3185
.annotate 'line', 2185
    .lex "$name", param_3185
.annotate 'line', 2186
    find_lex $P3186, "$name"
    unless_null $P3186, vivify_1540
    new $P3186, "Undef"
  vivify_1540:
    $P3187 = "is_scope"($P3186, "lexical")
.annotate 'line', 2185
    .return ($P3187)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("424_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3190
.annotate 'line', 2191
    .lex "$name", param_3190
.annotate 'line', 2192
    find_lex $P3191, "$name"
    unless_null $P3191, vivify_1541
    new $P3191, "Undef"
  vivify_1541:
    $P3192 = "is_scope"($P3191, "package")
.annotate 'line', 2191
    .return ($P3192)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("425_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3197
    .param pmc param_3198
.annotate 'line', 2197
    .const 'Sub' $P3206 = "426_1303739803.72" 
    capture_lex $P3206
    new $P3196, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3196, control_3195
    push_eh $P3196
    .lex "$name", param_3197
    .lex "$wanted_scope", param_3198
.annotate 'line', 2198
    find_lex $P3200, "$?PACKAGE"
    get_who $P3201, $P3200
    set $P3202, $P3201["@BLOCK"]
    unless_null $P3202, vivify_1542
    $P3202 = root_new ['parrot';'ResizablePMCArray']
  vivify_1542:
    defined $I3203, $P3202
    unless $I3203, for_undef_1543
    iter $P3199, $P3202
    new $P3225, 'ExceptionHandler'
    set_label $P3225, loop3224_handler
    $P3225."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3225
  loop3224_test:
    unless $P3199, loop3224_done
    shift $P3204, $P3199
  loop3224_redo:
    .const 'Sub' $P3206 = "426_1303739803.72" 
    capture_lex $P3206
    $P3206($P3204)
  loop3224_next:
    goto loop3224_test
  loop3224_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3226, exception, 'type'
    eq $P3226, .CONTROL_LOOP_NEXT, loop3224_next
    eq $P3226, .CONTROL_LOOP_REDO, loop3224_redo
  loop3224_done:
    pop_eh 
  for_undef_1543:
.annotate 'line', 2197
    .return (0)
  control_3195:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3227, exception, "payload"
    .return ($P3227)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3205"  :anon :subid("426_1303739803.72") :outer("425_1303739803.72")
    .param pmc param_3208
.annotate 'line', 2199
    $P3207 = root_new ['parrot';'Hash']
    .lex "%sym", $P3207
    .lex "$_", param_3208
    find_lex $P3209, "$_"
    unless_null $P3209, vivify_1544
    new $P3209, "Undef"
  vivify_1544:
    find_lex $P3210, "$name"
    unless_null $P3210, vivify_1545
    new $P3210, "Undef"
  vivify_1545:
    $P3211 = $P3209."symbol"($P3210)
    store_lex "%sym", $P3211
.annotate 'line', 2200
    find_lex $P3214, "%sym"
    unless_null $P3214, vivify_1546
    $P3214 = root_new ['parrot';'Hash']
  vivify_1546:
    set $N3215, $P3214
    if $N3215, if_3213
    new $P3212, 'Float'
    set $P3212, $N3215
    goto if_3213_end
  if_3213:
.annotate 'line', 2201
    new $P3216, "Exception"
    set $P3216['type'], .CONTROL_RETURN
    find_lex $P3217, "%sym"
    unless_null $P3217, vivify_1547
    $P3217 = root_new ['parrot';'Hash']
  vivify_1547:
    set $P3218, $P3217["scope"]
    unless_null $P3218, vivify_1548
    new $P3218, "Undef"
  vivify_1548:
    set $S3219, $P3218
    find_lex $P3220, "$wanted_scope"
    unless_null $P3220, vivify_1549
    new $P3220, "Undef"
  vivify_1549:
    set $S3221, $P3220
    iseq $I3222, $S3219, $S3221
    new $P3223, 'Integer'
    set $P3223, $I3222
    setattribute $P3216, 'payload', $P3223
    throw $P3216
  if_3213_end:
.annotate 'line', 2198
    .return ($P3212)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("427_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3232
    .param pmc param_3233
.annotate 'line', 2210
    .const 'Sub' $P3327 = "432_1303739803.72" 
    capture_lex $P3327
    .const 'Sub' $P3287 = "430_1303739803.72" 
    capture_lex $P3287
    .const 'Sub' $P3245 = "428_1303739803.72" 
    capture_lex $P3245
    new $P3231, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3231, control_3230
    push_eh $P3231
    .lex "@name", param_3232
    .lex "$/", param_3233
.annotate 'line', 2234
    new $P3234, "Undef"
    .lex "$result", $P3234
.annotate 'line', 2212
    find_lex $P3236, "@name"
    unless_null $P3236, vivify_1550
    $P3236 = root_new ['parrot';'ResizablePMCArray']
  vivify_1550:
    set $N3237, $P3236
    if $N3237, unless_3235_end
    find_lex $P3238, "$/"
    unless_null $P3238, vivify_1551
    new $P3238, "Undef"
  vivify_1551:
    $P3239 = $P3238."CURSOR"()
    $P3239."panic"("Cannot look up empty name")
  unless_3235_end:
.annotate 'line', 2216
    find_lex $P3241, "@name"
    unless_null $P3241, vivify_1552
    $P3241 = root_new ['parrot';'ResizablePMCArray']
  vivify_1552:
    set $N3242, $P3241
    iseq $I3243, $N3242, 1.0
    unless $I3243, if_3240_end
    .const 'Sub' $P3245 = "428_1303739803.72" 
    capture_lex $P3245
    $P3245()
  if_3240_end:
.annotate 'line', 2234
    find_dynamic_lex $P3281, "$*GLOBALish"
    unless_null $P3281, vivify_1564
    get_hll_global $P3279, "GLOBAL"
    get_who $P3280, $P3279
    set $P3281, $P3280["$GLOBALish"]
    unless_null $P3281, vivify_1565
    die "Contextual $*GLOBALish not found"
  vivify_1565:
  vivify_1564:
    store_lex "$result", $P3281
.annotate 'line', 2235
    find_lex $P3283, "@name"
    unless_null $P3283, vivify_1566
    $P3283 = root_new ['parrot';'ResizablePMCArray']
  vivify_1566:
    set $N3284, $P3283
    isge $I3285, $N3284, 2.0
    unless $I3285, if_3282_end
    .const 'Sub' $P3287 = "430_1303739803.72" 
    capture_lex $P3287
    $P3287()
  if_3282_end:
.annotate 'line', 2253
    find_lex $P3323, "@name"
    unless_null $P3323, vivify_1579
    $P3323 = root_new ['parrot';'ResizablePMCArray']
  vivify_1579:
    defined $I3324, $P3323
    unless $I3324, for_undef_1580
    iter $P3322, $P3323
    new $P3345, 'ExceptionHandler'
    set_label $P3345, loop3344_handler
    $P3345."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3345
  loop3344_test:
    unless $P3322, loop3344_done
    shift $P3325, $P3322
  loop3344_redo:
    .const 'Sub' $P3327 = "432_1303739803.72" 
    capture_lex $P3327
    $P3327($P3325)
  loop3344_next:
    goto loop3344_test
  loop3344_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3346, exception, 'type'
    eq $P3346, .CONTROL_LOOP_NEXT, loop3344_next
    eq $P3346, .CONTROL_LOOP_REDO, loop3344_redo
  loop3344_done:
    pop_eh 
  for_undef_1580:
    find_lex $P3347, "$result"
    unless_null $P3347, vivify_1587
    new $P3347, "Undef"
  vivify_1587:
.annotate 'line', 2210
    .return ($P3347)
  control_3230:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3348, exception, "payload"
    .return ($P3348)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3244"  :anon :subid("428_1303739803.72") :outer("427_1303739803.72")
.annotate 'line', 2216
    .const 'Sub' $P3256 = "429_1303739803.72" 
    capture_lex $P3256
.annotate 'line', 2217
    new $P3246, "Undef"
    .lex "$final_name", $P3246
    find_lex $P3247, "@name"
    unless_null $P3247, vivify_1553
    $P3247 = root_new ['parrot';'ResizablePMCArray']
  vivify_1553:
    set $P3248, $P3247[0]
    unless_null $P3248, vivify_1554
    new $P3248, "Undef"
  vivify_1554:
    store_lex "$final_name", $P3248
.annotate 'line', 2218
    find_lex $P3250, "$?PACKAGE"
    get_who $P3251, $P3250
    set $P3252, $P3251["@BLOCK"]
    unless_null $P3252, vivify_1555
    $P3252 = root_new ['parrot';'ResizablePMCArray']
  vivify_1555:
    defined $I3253, $P3252
    unless $I3253, for_undef_1556
    iter $P3249, $P3252
    new $P3277, 'ExceptionHandler'
    set_label $P3277, loop3276_handler
    $P3277."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3277
  loop3276_test:
    unless $P3249, loop3276_done
    shift $P3254, $P3249
  loop3276_redo:
    .const 'Sub' $P3256 = "429_1303739803.72" 
    capture_lex $P3256
    $P3256($P3254)
  loop3276_next:
    goto loop3276_test
  loop3276_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3278, exception, 'type'
    eq $P3278, .CONTROL_LOOP_NEXT, loop3276_next
    eq $P3278, .CONTROL_LOOP_REDO, loop3276_redo
  loop3276_done:
    pop_eh 
  for_undef_1556:
.annotate 'line', 2216
    .return ($P3249)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3255"  :anon :subid("429_1303739803.72") :outer("428_1303739803.72")
    .param pmc param_3258
.annotate 'line', 2219
    $P3257 = root_new ['parrot';'Hash']
    .lex "%sym", $P3257
    .lex "$_", param_3258
    find_lex $P3259, "$_"
    unless_null $P3259, vivify_1557
    new $P3259, "Undef"
  vivify_1557:
    find_lex $P3260, "$final_name"
    unless_null $P3260, vivify_1558
    new $P3260, "Undef"
  vivify_1558:
    $P3261 = $P3259."symbol"($P3260)
    store_lex "%sym", $P3261
.annotate 'line', 2220
    find_lex $P3264, "%sym"
    unless_null $P3264, vivify_1559
    $P3264 = root_new ['parrot';'Hash']
  vivify_1559:
    set $N3265, $P3264
    if $N3265, if_3263
    new $P3262, 'Float'
    set $P3262, $N3265
    goto if_3263_end
  if_3263:
.annotate 'line', 2221
    find_lex $P3268, "%sym"
    unless_null $P3268, vivify_1560
    $P3268 = root_new ['parrot';'Hash']
  vivify_1560:
    exists $I3269, $P3268["value"]
    if $I3269, if_3267
.annotate 'line', 2225
    new $P3273, 'String'
    set $P3273, "No compile-time value for "
    find_lex $P3274, "$final_name"
    unless_null $P3274, vivify_1561
    new $P3274, "Undef"
  vivify_1561:
    concat $P3275, $P3273, $P3274
    die $P3275
.annotate 'line', 2224
    goto if_3267_end
  if_3267:
.annotate 'line', 2222
    new $P3270, "Exception"
    set $P3270['type'], .CONTROL_RETURN
    find_lex $P3271, "%sym"
    unless_null $P3271, vivify_1562
    $P3271 = root_new ['parrot';'Hash']
  vivify_1562:
    set $P3272, $P3271["value"]
    unless_null $P3272, vivify_1563
    new $P3272, "Undef"
  vivify_1563:
    setattribute $P3270, 'payload', $P3272
    throw $P3270
  if_3267_end:
.annotate 'line', 2220
    set $P3262, $P3266
  if_3263_end:
.annotate 'line', 2218
    .return ($P3262)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3286"  :anon :subid("430_1303739803.72") :outer("427_1303739803.72")
.annotate 'line', 2235
    .const 'Sub' $P3298 = "431_1303739803.72" 
    capture_lex $P3298
.annotate 'line', 2236
    new $P3288, "Undef"
    .lex "$first", $P3288
    find_lex $P3289, "@name"
    unless_null $P3289, vivify_1567
    $P3289 = root_new ['parrot';'ResizablePMCArray']
  vivify_1567:
    set $P3290, $P3289[0]
    unless_null $P3290, vivify_1568
    new $P3290, "Undef"
  vivify_1568:
    store_lex "$first", $P3290
.annotate 'line', 2237
    find_lex $P3292, "$?PACKAGE"
    get_who $P3293, $P3292
    set $P3294, $P3293["@BLOCK"]
    unless_null $P3294, vivify_1569
    $P3294 = root_new ['parrot';'ResizablePMCArray']
  vivify_1569:
    defined $I3295, $P3294
    unless $I3295, for_undef_1570
    iter $P3291, $P3294
    new $P3320, 'ExceptionHandler'
    set_label $P3320, loop3319_handler
    $P3320."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3320
  loop3319_test:
    unless $P3291, loop3319_done
    shift $P3296, $P3291
  loop3319_redo:
    .const 'Sub' $P3298 = "431_1303739803.72" 
    capture_lex $P3298
    $P3298($P3296)
  loop3319_next:
    goto loop3319_test
  loop3319_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3321, exception, 'type'
    eq $P3321, .CONTROL_LOOP_NEXT, loop3319_next
    eq $P3321, .CONTROL_LOOP_REDO, loop3319_redo
  loop3319_done:
    pop_eh 
  for_undef_1570:
.annotate 'line', 2235
    .return ($P3291)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3297"  :anon :subid("431_1303739803.72") :outer("430_1303739803.72")
    .param pmc param_3300
.annotate 'line', 2238
    $P3299 = root_new ['parrot';'Hash']
    .lex "%sym", $P3299
    .lex "$_", param_3300
    find_lex $P3301, "$_"
    unless_null $P3301, vivify_1571
    new $P3301, "Undef"
  vivify_1571:
    find_lex $P3302, "$first"
    unless_null $P3302, vivify_1572
    new $P3302, "Undef"
  vivify_1572:
    $P3303 = $P3301."symbol"($P3302)
    store_lex "%sym", $P3303
.annotate 'line', 2239
    find_lex $P3306, "%sym"
    unless_null $P3306, vivify_1573
    $P3306 = root_new ['parrot';'Hash']
  vivify_1573:
    set $N3307, $P3306
    if $N3307, if_3305
    new $P3304, 'Float'
    set $P3304, $N3307
    goto if_3305_end
  if_3305:
.annotate 'line', 2240
    find_lex $P3310, "%sym"
    unless_null $P3310, vivify_1574
    $P3310 = root_new ['parrot';'Hash']
  vivify_1574:
    exists $I3311, $P3310["value"]
    if $I3311, if_3309
.annotate 'line', 2246
    new $P3316, 'String'
    set $P3316, "No compile-time value for "
    find_lex $P3317, "$first"
    unless_null $P3317, vivify_1575
    new $P3317, "Undef"
  vivify_1575:
    concat $P3318, $P3316, $P3317
    die $P3318
.annotate 'line', 2245
    goto if_3309_end
  if_3309:
.annotate 'line', 2241
    find_lex $P3312, "%sym"
    unless_null $P3312, vivify_1576
    $P3312 = root_new ['parrot';'Hash']
  vivify_1576:
    set $P3313, $P3312["value"]
    unless_null $P3313, vivify_1577
    new $P3313, "Undef"
  vivify_1577:
    store_lex "$result", $P3313
.annotate 'line', 2242
    find_lex $P3314, "@name"
    unless_null $P3314, vivify_1578
    $P3314 = root_new ['parrot';'ResizablePMCArray']
  vivify_1578:
    $P3314."shift"()
.annotate 'line', 2243
    set $I3315, .CONTROL_LOOP_LAST
    die 0, $I3315
  if_3309_end:
.annotate 'line', 2239
    set $P3304, $P3308
  if_3305_end:
.annotate 'line', 2237
    .return ($P3304)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3326"  :anon :subid("432_1303739803.72") :outer("427_1303739803.72")
    .param pmc param_3328
.annotate 'line', 2253
    .lex "$_", param_3328
.annotate 'line', 2254
    find_lex $P3333, "$_"
    unless_null $P3333, vivify_1581
    new $P3333, "Undef"
  vivify_1581:
    set $S3334, $P3333
    find_lex $P3331, "$result"
    unless_null $P3331, vivify_1582
    new $P3331, "Undef"
  vivify_1582:
    get_who $P3332, $P3331
    exists $I3335, $P3332[$S3334]
    if $I3335, if_3330
.annotate 'line', 2258
    new $P3340, "String"
    assign $P3340, "Could not locate compile-time value for symbol "
.annotate 'line', 2259
    find_lex $P3341, "@name"
    unless_null $P3341, vivify_1583
    $P3341 = root_new ['parrot';'ResizablePMCArray']
  vivify_1583:
    join $S3342, "::", $P3341
    concat $P3343, $P3340, $S3342
.annotate 'line', 2258
    die $P3343
.annotate 'line', 2257
    goto if_3330_end
  if_3330:
.annotate 'line', 2255
    find_lex $P3336, "$_"
    unless_null $P3336, vivify_1584
    new $P3336, "Undef"
  vivify_1584:
    find_lex $P3337, "$result"
    unless_null $P3337, vivify_1585
    new $P3337, "Undef"
  vivify_1585:
    get_who $P3338, $P3337
    set $P3339, $P3338[$P3336]
    unless_null $P3339, vivify_1586
    new $P3339, "Undef"
  vivify_1586:
    store_lex "$result", $P3339
.annotate 'line', 2254
    set $P3329, $P3339
  if_3330_end:
.annotate 'line', 2253
    .return ($P3329)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("433_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3359
    .param pmc param_3360
.annotate 'line', 795
    .lex "self", param_3359
    .lex "$/", param_3360
    find_lex $P3361, "$/"
    find_lex $P3362, "$/"
    unless_null $P3362, vivify_1588
    $P3362 = root_new ['parrot';'Hash']
  vivify_1588:
    set $P3363, $P3362["comp_unit"]
    unless_null $P3363, vivify_1589
    new $P3363, "Undef"
  vivify_1589:
    $P3364 = $P3363."ast"()
    $P3365 = $P3361."!make"($P3364)
    .return ($P3365)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("434_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3367
    .param pmc param_3368
.annotate 'line', 797
    .lex "self", param_3367
    .lex "$/", param_3368
.annotate 'line', 798
    find_lex $P3369, "$/"
.annotate 'line', 799
    find_lex $P3372, "$/"
    unless_null $P3372, vivify_1590
    $P3372 = root_new ['parrot';'Hash']
  vivify_1590:
    set $P3373, $P3372["colonpair"]
    unless_null $P3373, vivify_1591
    new $P3373, "Undef"
  vivify_1591:
    if $P3373, if_3371
.annotate 'line', 801
    find_lex $P3393, "$/"
    unless_null $P3393, vivify_1592
    new $P3393, "Undef"
  vivify_1592:
    set $S3394, $P3393
    new $P3370, 'String'
    set $P3370, $S3394
.annotate 'line', 799
    goto if_3371_end
  if_3371:
    find_lex $P3374, "$/"
    unless_null $P3374, vivify_1593
    $P3374 = root_new ['parrot';'Hash']
  vivify_1593:
    set $P3375, $P3374["identifier"]
    unless_null $P3375, vivify_1594
    new $P3375, "Undef"
  vivify_1594:
    set $S3376, $P3375
    new $P3377, 'String'
    set $P3377, $S3376
    concat $P3378, $P3377, ":"
    find_lex $P3379, "$/"
    unless_null $P3379, vivify_1595
    $P3379 = root_new ['parrot';'Hash']
  vivify_1595:
    set $P3380, $P3379["colonpair"]
    unless_null $P3380, vivify_1596
    $P3380 = root_new ['parrot';'ResizablePMCArray']
  vivify_1596:
    set $P3381, $P3380[0]
    unless_null $P3381, vivify_1597
    new $P3381, "Undef"
  vivify_1597:
    $P3382 = $P3381."ast"()
    $S3383 = $P3382."named"()
    concat $P3384, $P3378, $S3383
    concat $P3385, $P3384, "<"
.annotate 'line', 800
    find_lex $P3386, "$/"
    unless_null $P3386, vivify_1598
    $P3386 = root_new ['parrot';'Hash']
  vivify_1598:
    set $P3387, $P3386["colonpair"]
    unless_null $P3387, vivify_1599
    $P3387 = root_new ['parrot';'ResizablePMCArray']
  vivify_1599:
    set $P3388, $P3387[0]
    unless_null $P3388, vivify_1600
    new $P3388, "Undef"
  vivify_1600:
    $P3389 = $P3388."ast"()
    $S3390 = "colonpair_str"($P3389)
    concat $P3391, $P3385, $S3390
    concat $P3392, $P3391, ">"
    set $P3370, $P3392
  if_3371_end:
.annotate 'line', 799
    $P3395 = $P3369."!make"($P3370)
.annotate 'line', 797
    .return ($P3395)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("435_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3398
    .param pmc param_3399
.annotate 'line', 811
    .lex "self", param_3398
    .lex "$/", param_3399
.annotate 'line', 812
    new $P3400, "Undef"
    .lex "$mainline", $P3400
.annotate 'line', 813
    new $P3401, "Undef"
    .lex "$unit", $P3401
.annotate 'line', 812
    find_lex $P3402, "$/"
    unless_null $P3402, vivify_1601
    $P3402 = root_new ['parrot';'Hash']
  vivify_1601:
    set $P3403, $P3402["statementlist"]
    unless_null $P3403, vivify_1602
    new $P3403, "Undef"
  vivify_1602:
    $P3404 = $P3403."ast"()
    store_lex "$mainline", $P3404
.annotate 'line', 813
    find_lex $P3405, "$?PACKAGE"
    get_who $P3406, $P3405
    set $P3407, $P3406["@BLOCK"]
    unless_null $P3407, vivify_1603
    $P3407 = root_new ['parrot';'ResizablePMCArray']
  vivify_1603:
    $P3408 = $P3407."shift"()
    store_lex "$unit", $P3408
.annotate 'line', 817
    find_lex $P3409, "$unit"
    unless_null $P3409, vivify_1604
    new $P3409, "Undef"
  vivify_1604:
    $P3410 = $P3409."loadinit"()
    find_dynamic_lex $P3413, "$*SC"
    unless_null $P3413, vivify_1605
    get_hll_global $P3411, "GLOBAL"
    get_who $P3412, $P3411
    set $P3413, $P3412["$SC"]
    unless_null $P3413, vivify_1606
    die "Contextual $*SC not found"
  vivify_1606:
  vivify_1605:
    $P3414 = $P3413."to_past"()
    $P3410."push"($P3414)
.annotate 'line', 823
    find_lex $P3415, "$unit"
    unless_null $P3415, vivify_1607
    new $P3415, "Undef"
  vivify_1607:
    $P3416 = $P3415."loadinit"()
    get_hll_global $P3417, "GLOBAL"
    nqp_get_package_through_who $P3418, $P3417, "PAST"
    get_who $P3419, $P3418
    set $P3420, $P3419["Op"]
.annotate 'line', 825
    get_hll_global $P3421, "GLOBAL"
    nqp_get_package_through_who $P3422, $P3421, "PAST"
    get_who $P3423, $P3422
    set $P3424, $P3423["Var"]
    new $P3425, "ResizablePMCArray"
    $P3426 = $P3424."new"("GLOBAL" :named("name"), $P3425 :named("namespace"), "package" :named("scope"))
.annotate 'line', 826
    find_dynamic_lex $P3429, "$*SC"
    unless_null $P3429, vivify_1608
    get_hll_global $P3427, "GLOBAL"
    get_who $P3428, $P3427
    set $P3429, $P3428["$SC"]
    unless_null $P3429, vivify_1609
    die "Contextual $*SC not found"
  vivify_1609:
  vivify_1608:
    find_dynamic_lex $P3432, "$*PACKAGE"
    unless_null $P3432, vivify_1610
    get_hll_global $P3430, "GLOBAL"
    get_who $P3431, $P3430
    set $P3432, $P3431["$PACKAGE"]
    unless_null $P3432, vivify_1611
    die "Contextual $*PACKAGE not found"
  vivify_1611:
  vivify_1610:
    $P3433 = $P3429."get_slot_past_for_object"($P3432)
    $P3434 = $P3420."new"($P3426, $P3433, "bind" :named("pasttype"))
.annotate 'line', 823
    $P3416."push"($P3434)
.annotate 'line', 832
    find_dynamic_lex $P3438, "$*HAS_YOU_ARE_HERE"
    unless_null $P3438, vivify_1612
    get_hll_global $P3436, "GLOBAL"
    get_who $P3437, $P3436
    set $P3438, $P3437["$HAS_YOU_ARE_HERE"]
    unless_null $P3438, vivify_1613
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1613:
  vivify_1612:
    if $P3438, unless_3435_end
.annotate 'line', 833
    find_lex $P3439, "$unit"
    unless_null $P3439, vivify_1614
    new $P3439, "Undef"
  vivify_1614:
    find_lex $P3440, "self"
    $P3441 = $P3440."CTXSAVE"()
    $P3439."push"($P3441)
  unless_3435_end:
.annotate 'line', 837
    find_lex $P3442, "$unit"
    unless_null $P3442, vivify_1615
    new $P3442, "Undef"
  vivify_1615:
    $P3442."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 841
    find_dynamic_lex $P3446, "$*MAIN_SUB"
    unless_null $P3446, vivify_1616
    get_hll_global $P3444, "GLOBAL"
    get_who $P3445, $P3444
    set $P3446, $P3445["$MAIN_SUB"]
    unless_null $P3446, vivify_1617
    die "Contextual $*MAIN_SUB not found"
  vivify_1617:
  vivify_1616:
    unless $P3446, if_3443_end
.annotate 'line', 842
    find_lex $P3447, "$unit"
    unless_null $P3447, vivify_1618
    new $P3447, "Undef"
  vivify_1618:
    get_hll_global $P3448, "GLOBAL"
    nqp_get_package_through_who $P3449, $P3448, "PAST"
    get_who $P3450, $P3449
    set $P3451, $P3450["Var"]
    $P3452 = $P3451."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3447."unshift"($P3452)
.annotate 'line', 843
    find_lex $P3453, "$mainline"
    unless_null $P3453, vivify_1619
    new $P3453, "Undef"
  vivify_1619:
    get_hll_global $P3454, "GLOBAL"
    nqp_get_package_through_who $P3455, $P3454, "PAST"
    get_who $P3456, $P3455
    set $P3457, $P3456["Op"]
.annotate 'line', 845
    get_hll_global $P3458, "GLOBAL"
    nqp_get_package_through_who $P3459, $P3458, "PAST"
    get_who $P3460, $P3459
    set $P3461, $P3460["Var"]
    $P3462 = $P3461."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 846
    get_hll_global $P3463, "GLOBAL"
    nqp_get_package_through_who $P3464, $P3463, "PAST"
    get_who $P3465, $P3464
    set $P3466, $P3465["Op"]
.annotate 'line', 847
    get_hll_global $P3467, "GLOBAL"
    nqp_get_package_through_who $P3468, $P3467, "PAST"
    get_who $P3469, $P3468
    set $P3470, $P3469["Val"]
    find_dynamic_lex $P3473, "$*MAIN_SUB"
    unless_null $P3473, vivify_1620
    get_hll_global $P3471, "GLOBAL"
    get_who $P3472, $P3471
    set $P3473, $P3472["$MAIN_SUB"]
    unless_null $P3473, vivify_1621
    die "Contextual $*MAIN_SUB not found"
  vivify_1621:
  vivify_1620:
    $P3474 = $P3470."new"($P3473 :named("value"))
.annotate 'line', 848
    get_hll_global $P3475, "GLOBAL"
    nqp_get_package_through_who $P3476, $P3475, "PAST"
    get_who $P3477, $P3476
    set $P3478, $P3477["Var"]
    $P3479 = $P3478."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3480 = $P3466."new"($P3474, $P3479, "call" :named("pasttype"))
.annotate 'line', 846
    $P3481 = $P3457."new"($P3462, $P3480, "if" :named("pasttype"))
.annotate 'line', 843
    $P3453."push"($P3481)
  if_3443_end:
.annotate 'line', 856
    find_lex $P3482, "$unit"
    unless_null $P3482, vivify_1622
    new $P3482, "Undef"
  vivify_1622:
.annotate 'line', 857
    get_hll_global $P3483, "GLOBAL"
    nqp_get_package_through_who $P3484, $P3483, "PAST"
    get_who $P3485, $P3484
    set $P3486, $P3485["Op"]
    find_lex $P3487, "$mainline"
    unless_null $P3487, vivify_1623
    new $P3487, "Undef"
  vivify_1623:
    $P3488 = $P3486."new"($P3487, "return" :named("pirop"))
    $P3482."push"($P3488)
.annotate 'line', 862
    find_lex $P3489, "$unit"
    unless_null $P3489, vivify_1624
    new $P3489, "Undef"
  vivify_1624:
.annotate 'line', 863
    get_hll_global $P3490, "GLOBAL"
    nqp_get_package_through_who $P3491, $P3490, "PAST"
    get_who $P3492, $P3491
    set $P3493, $P3492["Block"]
.annotate 'line', 865
    get_hll_global $P3494, "GLOBAL"
    nqp_get_package_through_who $P3495, $P3494, "PAST"
    get_who $P3496, $P3495
    set $P3497, $P3496["Op"]
    get_hll_global $P3498, "GLOBAL"
    nqp_get_package_through_who $P3499, $P3498, "PAST"
    get_who $P3500, $P3499
    set $P3501, $P3500["Val"]
    find_lex $P3502, "$unit"
    unless_null $P3502, vivify_1625
    new $P3502, "Undef"
  vivify_1625:
    $P3503 = $P3501."new"($P3502 :named("value"))
    $P3504 = $P3497."new"($P3503, "call" :named("pasttype"))
    $P3505 = $P3493."new"($P3504, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 863
    $P3489."push"($P3505)
.annotate 'line', 868
    find_lex $P3506, "$unit"
    unless_null $P3506, vivify_1626
    new $P3506, "Undef"
  vivify_1626:
    find_lex $P3507, "$/"
    unless_null $P3507, vivify_1627
    new $P3507, "Undef"
  vivify_1627:
    $P3506."node"($P3507)
.annotate 'line', 871
    find_lex $P3508, "$unit"
    unless_null $P3508, vivify_1628
    new $P3508, "Undef"
  vivify_1628:
    $P3508."hll"("nqp")
.annotate 'line', 873
    find_lex $P3509, "$/"
    find_lex $P3510, "$unit"
    unless_null $P3510, vivify_1629
    new $P3510, "Undef"
  vivify_1629:
    $P3511 = $P3509."!make"($P3510)
.annotate 'line', 811
    .return ($P3511)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("436_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3513
    .param pmc param_3514
.annotate 'line', 876
    .const 'Sub' $P3531 = "437_1303739803.72" 
    capture_lex $P3531
    .lex "self", param_3513
    .lex "$/", param_3514
.annotate 'line', 877
    new $P3515, "Undef"
    .lex "$past", $P3515
    get_hll_global $P3516, "GLOBAL"
    nqp_get_package_through_who $P3517, $P3516, "PAST"
    get_who $P3518, $P3517
    set $P3519, $P3518["Stmts"]
    find_lex $P3520, "$/"
    unless_null $P3520, vivify_1630
    new $P3520, "Undef"
  vivify_1630:
    $P3521 = $P3519."new"($P3520 :named("node"))
    store_lex "$past", $P3521
.annotate 'line', 878
    find_lex $P3523, "$/"
    unless_null $P3523, vivify_1631
    $P3523 = root_new ['parrot';'Hash']
  vivify_1631:
    set $P3524, $P3523["statement"]
    unless_null $P3524, vivify_1632
    new $P3524, "Undef"
  vivify_1632:
    unless $P3524, if_3522_end
.annotate 'line', 879
    find_lex $P3526, "$/"
    unless_null $P3526, vivify_1633
    $P3526 = root_new ['parrot';'Hash']
  vivify_1633:
    set $P3527, $P3526["statement"]
    unless_null $P3527, vivify_1634
    new $P3527, "Undef"
  vivify_1634:
    defined $I3528, $P3527
    unless $I3528, for_undef_1635
    iter $P3525, $P3527
    new $P3551, 'ExceptionHandler'
    set_label $P3551, loop3550_handler
    $P3551."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3551
  loop3550_test:
    unless $P3525, loop3550_done
    shift $P3529, $P3525
  loop3550_redo:
    .const 'Sub' $P3531 = "437_1303739803.72" 
    capture_lex $P3531
    $P3531($P3529)
  loop3550_next:
    goto loop3550_test
  loop3550_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3552, exception, 'type'
    eq $P3552, .CONTROL_LOOP_NEXT, loop3550_next
    eq $P3552, .CONTROL_LOOP_REDO, loop3550_redo
  loop3550_done:
    pop_eh 
  for_undef_1635:
  if_3522_end:
.annotate 'line', 886
    find_lex $P3553, "$/"
    find_lex $P3554, "$past"
    unless_null $P3554, vivify_1646
    new $P3554, "Undef"
  vivify_1646:
    $P3555 = $P3553."!make"($P3554)
.annotate 'line', 876
    .return ($P3555)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3530"  :anon :subid("437_1303739803.72") :outer("436_1303739803.72")
    .param pmc param_3533
.annotate 'line', 880
    new $P3532, "Undef"
    .lex "$ast", $P3532
    .lex "$_", param_3533
    find_lex $P3534, "$_"
    unless_null $P3534, vivify_1636
    new $P3534, "Undef"
  vivify_1636:
    $P3535 = $P3534."ast"()
    store_lex "$ast", $P3535
.annotate 'line', 881
    find_lex $P3537, "$ast"
    unless_null $P3537, vivify_1637
    $P3537 = root_new ['parrot';'Hash']
  vivify_1637:
    set $P3538, $P3537["sink"]
    unless_null $P3538, vivify_1638
    new $P3538, "Undef"
  vivify_1638:
    defined $I3539, $P3538
    unless $I3539, if_3536_end
    find_lex $P3540, "$ast"
    unless_null $P3540, vivify_1639
    $P3540 = root_new ['parrot';'Hash']
  vivify_1639:
    set $P3541, $P3540["sink"]
    unless_null $P3541, vivify_1640
    new $P3541, "Undef"
  vivify_1640:
    store_lex "$ast", $P3541
  if_3536_end:
.annotate 'line', 882
    find_lex $P3543, "$ast"
    unless_null $P3543, vivify_1641
    $P3543 = root_new ['parrot';'Hash']
  vivify_1641:
    set $P3544, $P3543["bareblock"]
    unless_null $P3544, vivify_1642
    new $P3544, "Undef"
  vivify_1642:
    unless $P3544, if_3542_end
    find_lex $P3545, "$ast"
    unless_null $P3545, vivify_1643
    new $P3545, "Undef"
  vivify_1643:
    $P3546 = "block_immediate"($P3545)
    store_lex "$ast", $P3546
  if_3542_end:
.annotate 'line', 883
    find_lex $P3547, "$past"
    unless_null $P3547, vivify_1644
    new $P3547, "Undef"
  vivify_1644:
    find_lex $P3548, "$ast"
    unless_null $P3548, vivify_1645
    new $P3548, "Undef"
  vivify_1645:
    $P3549 = $P3547."push"($P3548)
.annotate 'line', 879
    .return ($P3549)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("438_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3557
    .param pmc param_3558
    .param pmc param_3559 :optional
    .param int has_param_3559 :opt_flag
.annotate 'line', 889
    .const 'Sub' $P3567 = "439_1303739803.72" 
    capture_lex $P3567
    .lex "self", param_3557
    .lex "$/", param_3558
    if has_param_3559, optparam_1647
    new $P3560, "Undef"
    set param_3559, $P3560
  optparam_1647:
    .lex "$key", param_3559
.annotate 'line', 890
    new $P3561, "Undef"
    .lex "$past", $P3561
.annotate 'line', 889
    find_lex $P3562, "$past"
    unless_null $P3562, vivify_1648
    new $P3562, "Undef"
  vivify_1648:
.annotate 'line', 891
    find_lex $P3564, "$/"
    unless_null $P3564, vivify_1649
    $P3564 = root_new ['parrot';'Hash']
  vivify_1649:
    set $P3565, $P3564["EXPR"]
    unless_null $P3565, vivify_1650
    new $P3565, "Undef"
  vivify_1650:
    if $P3565, if_3563
.annotate 'line', 912
    find_lex $P3643, "$/"
    unless_null $P3643, vivify_1651
    $P3643 = root_new ['parrot';'Hash']
  vivify_1651:
    set $P3644, $P3643["statement_control"]
    unless_null $P3644, vivify_1652
    new $P3644, "Undef"
  vivify_1652:
    if $P3644, if_3642
.annotate 'line', 913
    new $P3648, "Integer"
    assign $P3648, 0
    store_lex "$past", $P3648
    goto if_3642_end
  if_3642:
.annotate 'line', 912
    find_lex $P3645, "$/"
    unless_null $P3645, vivify_1653
    $P3645 = root_new ['parrot';'Hash']
  vivify_1653:
    set $P3646, $P3645["statement_control"]
    unless_null $P3646, vivify_1654
    new $P3646, "Undef"
  vivify_1654:
    $P3647 = $P3646."ast"()
    store_lex "$past", $P3647
  if_3642_end:
    goto if_3563_end
  if_3563:
.annotate 'line', 891
    .const 'Sub' $P3567 = "439_1303739803.72" 
    capture_lex $P3567
    $P3567()
  if_3563_end:
.annotate 'line', 914
    find_lex $P3649, "$/"
    find_lex $P3650, "$past"
    unless_null $P3650, vivify_1688
    new $P3650, "Undef"
  vivify_1688:
    $P3651 = $P3649."!make"($P3650)
.annotate 'line', 889
    .return ($P3651)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3566"  :anon :subid("439_1303739803.72") :outer("438_1303739803.72")
.annotate 'line', 892
    new $P3568, "Undef"
    .lex "$mc", $P3568
.annotate 'line', 893
    new $P3569, "Undef"
    .lex "$ml", $P3569
.annotate 'line', 892
    find_lex $P3570, "$/"
    unless_null $P3570, vivify_1655
    $P3570 = root_new ['parrot';'Hash']
  vivify_1655:
    set $P3571, $P3570["statement_mod_cond"]
    unless_null $P3571, vivify_1656
    $P3571 = root_new ['parrot';'ResizablePMCArray']
  vivify_1656:
    set $P3572, $P3571[0]
    unless_null $P3572, vivify_1657
    new $P3572, "Undef"
  vivify_1657:
    store_lex "$mc", $P3572
.annotate 'line', 893
    find_lex $P3573, "$/"
    unless_null $P3573, vivify_1658
    $P3573 = root_new ['parrot';'Hash']
  vivify_1658:
    set $P3574, $P3573["statement_mod_loop"]
    unless_null $P3574, vivify_1659
    $P3574 = root_new ['parrot';'ResizablePMCArray']
  vivify_1659:
    set $P3575, $P3574[0]
    unless_null $P3575, vivify_1660
    new $P3575, "Undef"
  vivify_1660:
    store_lex "$ml", $P3575
.annotate 'line', 894
    find_lex $P3576, "$/"
    unless_null $P3576, vivify_1661
    $P3576 = root_new ['parrot';'Hash']
  vivify_1661:
    set $P3577, $P3576["EXPR"]
    unless_null $P3577, vivify_1662
    new $P3577, "Undef"
  vivify_1662:
    $P3578 = $P3577."ast"()
    store_lex "$past", $P3578
.annotate 'line', 895
    find_lex $P3580, "$mc"
    unless_null $P3580, vivify_1663
    new $P3580, "Undef"
  vivify_1663:
    unless $P3580, if_3579_end
.annotate 'line', 896
    get_hll_global $P3581, "GLOBAL"
    nqp_get_package_through_who $P3582, $P3581, "PAST"
    get_who $P3583, $P3582
    set $P3584, $P3583["Op"]
    find_lex $P3585, "$mc"
    unless_null $P3585, vivify_1664
    $P3585 = root_new ['parrot';'Hash']
  vivify_1664:
    set $P3586, $P3585["cond"]
    unless_null $P3586, vivify_1665
    new $P3586, "Undef"
  vivify_1665:
    $P3587 = $P3586."ast"()
    find_lex $P3588, "$past"
    unless_null $P3588, vivify_1666
    new $P3588, "Undef"
  vivify_1666:
    find_lex $P3589, "$mc"
    unless_null $P3589, vivify_1667
    $P3589 = root_new ['parrot';'Hash']
  vivify_1667:
    set $P3590, $P3589["sym"]
    unless_null $P3590, vivify_1668
    new $P3590, "Undef"
  vivify_1668:
    set $S3591, $P3590
    find_lex $P3592, "$/"
    unless_null $P3592, vivify_1669
    new $P3592, "Undef"
  vivify_1669:
    $P3593 = $P3584."new"($P3587, $P3588, $S3591 :named("pasttype"), $P3592 :named("node"))
    store_lex "$past", $P3593
  if_3579_end:
.annotate 'line', 898
    find_lex $P3596, "$ml"
    unless_null $P3596, vivify_1670
    new $P3596, "Undef"
  vivify_1670:
    if $P3596, if_3595
    set $P3594, $P3596
    goto if_3595_end
  if_3595:
.annotate 'line', 899
    find_lex $P3599, "$ml"
    unless_null $P3599, vivify_1671
    $P3599 = root_new ['parrot';'Hash']
  vivify_1671:
    set $P3600, $P3599["sym"]
    unless_null $P3600, vivify_1672
    new $P3600, "Undef"
  vivify_1672:
    set $S3601, $P3600
    iseq $I3602, $S3601, "for"
    if $I3602, if_3598
.annotate 'line', 908
    get_hll_global $P3629, "GLOBAL"
    nqp_get_package_through_who $P3630, $P3629, "PAST"
    get_who $P3631, $P3630
    set $P3632, $P3631["Op"]
    find_lex $P3633, "$ml"
    unless_null $P3633, vivify_1673
    $P3633 = root_new ['parrot';'Hash']
  vivify_1673:
    set $P3634, $P3633["cond"]
    unless_null $P3634, vivify_1674
    new $P3634, "Undef"
  vivify_1674:
    $P3635 = $P3634."ast"()
    find_lex $P3636, "$past"
    unless_null $P3636, vivify_1675
    new $P3636, "Undef"
  vivify_1675:
    find_lex $P3637, "$ml"
    unless_null $P3637, vivify_1676
    $P3637 = root_new ['parrot';'Hash']
  vivify_1676:
    set $P3638, $P3637["sym"]
    unless_null $P3638, vivify_1677
    new $P3638, "Undef"
  vivify_1677:
    set $S3639, $P3638
    find_lex $P3640, "$/"
    unless_null $P3640, vivify_1678
    new $P3640, "Undef"
  vivify_1678:
    $P3641 = $P3632."new"($P3635, $P3636, $S3639 :named("pasttype"), $P3640 :named("node"))
    store_lex "$past", $P3641
.annotate 'line', 907
    set $P3597, $P3641
.annotate 'line', 899
    goto if_3598_end
  if_3598:
.annotate 'line', 900
    get_hll_global $P3603, "GLOBAL"
    nqp_get_package_through_who $P3604, $P3603, "PAST"
    get_who $P3605, $P3604
    set $P3606, $P3605["Block"]
.annotate 'line', 901
    get_hll_global $P3607, "GLOBAL"
    nqp_get_package_through_who $P3608, $P3607, "PAST"
    get_who $P3609, $P3608
    set $P3610, $P3609["Var"]
    $P3611 = $P3610."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3612, "$past"
    unless_null $P3612, vivify_1679
    new $P3612, "Undef"
  vivify_1679:
    $P3613 = $P3606."new"($P3611, $P3612, "immediate" :named("blocktype"))
.annotate 'line', 900
    store_lex "$past", $P3613
.annotate 'line', 903
    find_lex $P3614, "$past"
    unless_null $P3614, vivify_1680
    new $P3614, "Undef"
  vivify_1680:
    $P3614."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 904
    find_lex $P3615, "$past"
    unless_null $P3615, vivify_1681
    new $P3615, "Undef"
  vivify_1681:
    $P3615."arity"(1)
.annotate 'line', 905
    get_hll_global $P3616, "GLOBAL"
    nqp_get_package_through_who $P3617, $P3616, "PAST"
    get_who $P3618, $P3617
    set $P3619, $P3618["Op"]
    find_lex $P3620, "$ml"
    unless_null $P3620, vivify_1682
    $P3620 = root_new ['parrot';'Hash']
  vivify_1682:
    set $P3621, $P3620["cond"]
    unless_null $P3621, vivify_1683
    new $P3621, "Undef"
  vivify_1683:
    $P3622 = $P3621."ast"()
    find_lex $P3623, "$past"
    unless_null $P3623, vivify_1684
    new $P3623, "Undef"
  vivify_1684:
    find_lex $P3624, "$ml"
    unless_null $P3624, vivify_1685
    $P3624 = root_new ['parrot';'Hash']
  vivify_1685:
    set $P3625, $P3624["sym"]
    unless_null $P3625, vivify_1686
    new $P3625, "Undef"
  vivify_1686:
    set $S3626, $P3625
    find_lex $P3627, "$/"
    unless_null $P3627, vivify_1687
    new $P3627, "Undef"
  vivify_1687:
    $P3628 = $P3619."new"($P3622, $P3623, $S3626 :named("pasttype"), $P3627 :named("node"))
    store_lex "$past", $P3628
.annotate 'line', 899
    set $P3597, $P3628
  if_3598_end:
.annotate 'line', 898
    set $P3594, $P3597
  if_3595_end:
.annotate 'line', 891
    .return ($P3594)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("440_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3653
    .param pmc param_3654
.annotate 'line', 917
    .lex "self", param_3653
    .lex "$/", param_3654
.annotate 'line', 918
    find_lex $P3655, "$/"
    get_hll_global $P3656, "GLOBAL"
    nqp_get_package_through_who $P3657, $P3656, "PAST"
    get_who $P3658, $P3657
    set $P3659, $P3658["Op"]
    find_lex $P3660, "$/"
    unless_null $P3660, vivify_1689
    $P3660 = root_new ['parrot';'Hash']
  vivify_1689:
    set $P3661, $P3660["EXPR"]
    unless_null $P3661, vivify_1690
    new $P3661, "Undef"
  vivify_1690:
    $P3662 = $P3661."ast"()
    find_lex $P3663, "$/"
    unless_null $P3663, vivify_1691
    $P3663 = root_new ['parrot';'Hash']
  vivify_1691:
    set $P3664, $P3663["pblock"]
    unless_null $P3664, vivify_1692
    new $P3664, "Undef"
  vivify_1692:
    $P3665 = $P3664."ast"()
    find_lex $P3666, "$/"
    unless_null $P3666, vivify_1693
    new $P3666, "Undef"
  vivify_1693:
    $P3667 = $P3659."new"($P3662, $P3665, "if" :named("pasttype"), $P3666 :named("node"))
    $P3668 = $P3655."!make"($P3667)
.annotate 'line', 917
    .return ($P3668)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("441_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3670
    .param pmc param_3671
.annotate 'line', 921
    .lex "self", param_3670
    .lex "$/", param_3671
.annotate 'line', 922
    find_lex $P3672, "$/"
    find_lex $P3673, "$/"
    unless_null $P3673, vivify_1694
    $P3673 = root_new ['parrot';'Hash']
  vivify_1694:
    set $P3674, $P3673["blockoid"]
    unless_null $P3674, vivify_1695
    new $P3674, "Undef"
  vivify_1695:
    $P3675 = $P3674."ast"()
    $P3676 = $P3672."!make"($P3675)
.annotate 'line', 921
    .return ($P3676)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("442_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3678
    .param pmc param_3679
.annotate 'line', 925
    .lex "self", param_3678
    .lex "$/", param_3679
.annotate 'line', 926
    find_lex $P3680, "$/"
    find_lex $P3681, "$/"
    unless_null $P3681, vivify_1696
    $P3681 = root_new ['parrot';'Hash']
  vivify_1696:
    set $P3682, $P3681["blockoid"]
    unless_null $P3682, vivify_1697
    new $P3682, "Undef"
  vivify_1697:
    $P3683 = $P3682."ast"()
    $P3684 = $P3680."!make"($P3683)
.annotate 'line', 925
    .return ($P3684)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("443_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3686
    .param pmc param_3687
.annotate 'line', 929
    .const 'Sub' $P3698 = "444_1303739803.72" 
    capture_lex $P3698
    .lex "self", param_3686
    .lex "$/", param_3687
.annotate 'line', 930
    new $P3688, "Undef"
    .lex "$BLOCK", $P3688
    find_lex $P3689, "$?PACKAGE"
    get_who $P3690, $P3689
    set $P3691, $P3690["@BLOCK"]
    unless_null $P3691, vivify_1698
    $P3691 = root_new ['parrot';'ResizablePMCArray']
  vivify_1698:
    $P3692 = $P3691."shift"()
    store_lex "$BLOCK", $P3692
.annotate 'line', 931
    find_lex $P3695, "$/"
    unless_null $P3695, vivify_1699
    $P3695 = root_new ['parrot';'Hash']
  vivify_1699:
    set $P3696, $P3695["statementlist"]
    unless_null $P3696, vivify_1700
    new $P3696, "Undef"
  vivify_1700:
    if $P3696, if_3694
.annotate 'line', 939
    find_dynamic_lex $P3715, "$*HAS_YOU_ARE_HERE"
    unless_null $P3715, vivify_1701
    get_hll_global $P3713, "GLOBAL"
    get_who $P3714, $P3713
    set $P3715, $P3714["$HAS_YOU_ARE_HERE"]
    unless_null $P3715, vivify_1702
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1702:
  vivify_1701:
    unless $P3715, if_3712_end
.annotate 'line', 940
    find_lex $P3716, "$/"
    unless_null $P3716, vivify_1703
    new $P3716, "Undef"
  vivify_1703:
    $P3717 = $P3716."CURSOR"()
    $P3717."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3712_end:
.annotate 'line', 942
    new $P3718, "Integer"
    assign $P3718, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3718
.annotate 'line', 943
    find_lex $P3719, "$/"
    find_lex $P3720, "$/"
    unless_null $P3720, vivify_1704
    $P3720 = root_new ['parrot';'Hash']
  vivify_1704:
    set $P3721, $P3720["you_are_here"]
    unless_null $P3721, vivify_1705
    new $P3721, "Undef"
  vivify_1705:
    $P3722 = $P3721."ast"()
    $P3723 = $P3719."!make"($P3722)
.annotate 'line', 938
    set $P3693, $P3723
.annotate 'line', 931
    goto if_3694_end
  if_3694:
    .const 'Sub' $P3698 = "444_1303739803.72" 
    capture_lex $P3698
    $P3711 = $P3698()
    set $P3693, $P3711
  if_3694_end:
.annotate 'line', 929
    .return ($P3693)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3697"  :anon :subid("444_1303739803.72") :outer("443_1303739803.72")
.annotate 'line', 932
    new $P3699, "Undef"
    .lex "$past", $P3699
    find_lex $P3700, "$/"
    unless_null $P3700, vivify_1706
    $P3700 = root_new ['parrot';'Hash']
  vivify_1706:
    set $P3701, $P3700["statementlist"]
    unless_null $P3701, vivify_1707
    new $P3701, "Undef"
  vivify_1707:
    $P3702 = $P3701."ast"()
    store_lex "$past", $P3702
.annotate 'line', 933
    find_lex $P3703, "$BLOCK"
    unless_null $P3703, vivify_1708
    new $P3703, "Undef"
  vivify_1708:
    find_lex $P3704, "$past"
    unless_null $P3704, vivify_1709
    new $P3704, "Undef"
  vivify_1709:
    $P3703."push"($P3704)
.annotate 'line', 934
    find_lex $P3705, "$BLOCK"
    unless_null $P3705, vivify_1710
    new $P3705, "Undef"
  vivify_1710:
    find_lex $P3706, "$/"
    unless_null $P3706, vivify_1711
    new $P3706, "Undef"
  vivify_1711:
    $P3705."node"($P3706)
.annotate 'line', 935
    find_lex $P3707, "$BLOCK"
    unless_null $P3707, vivify_1712
    new $P3707, "Undef"
  vivify_1712:
    $P3707."closure"(1)
.annotate 'line', 936
    find_dynamic_lex $P3708, "$/"
    find_lex $P3709, "$BLOCK"
    unless_null $P3709, vivify_1713
    new $P3709, "Undef"
  vivify_1713:
    $P3710 = $P3708."!make"($P3709)
.annotate 'line', 931
    .return ($P3710)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("445_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3725
    .param pmc param_3726
.annotate 'line', 947
    .lex "self", param_3725
    .lex "$/", param_3726
.annotate 'line', 948
    find_lex $P3727, "$?PACKAGE"
    get_who $P3728, $P3727
    set $P3729, $P3728["@BLOCK"]
    unless_null $P3729, vivify_1714
    $P3729 = root_new ['parrot';'ResizablePMCArray']
  vivify_1714:
    get_hll_global $P3730, "GLOBAL"
    nqp_get_package_through_who $P3731, $P3730, "PAST"
    get_who $P3732, $P3731
    set $P3733, $P3732["Block"]
    get_hll_global $P3734, "GLOBAL"
    nqp_get_package_through_who $P3735, $P3734, "PAST"
    get_who $P3736, $P3735
    set $P3737, $P3736["Stmts"]
    $P3738 = $P3737."new"()
    $P3739 = $P3733."new"($P3738)
    $P3740 = $P3729."unshift"($P3739)
.annotate 'line', 947
    .return ($P3740)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("446_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3742
    .param pmc param_3743
.annotate 'line', 951
    .const 'Sub' $P3752 = "447_1303739803.72" 
    capture_lex $P3752
    .lex "self", param_3742
    .lex "$/", param_3743
.annotate 'line', 952
    find_dynamic_lex $P3747, "%*COMPILING"
    unless_null $P3747, vivify_1715
    get_hll_global $P3745, "GLOBAL"
    get_who $P3746, $P3745
    set $P3747, $P3746["%COMPILING"]
    unless_null $P3747, vivify_1716
    die "Contextual %*COMPILING not found"
  vivify_1716:
  vivify_1715:
    set $P3748, $P3747["%?OPTIONS"]
    unless_null $P3748, vivify_1717
    $P3748 = root_new ['parrot';'Hash']
  vivify_1717:
    set $P3749, $P3748["outer_ctx"]
    unless_null $P3749, vivify_1718
    new $P3749, "Undef"
  vivify_1718:
    defined $I3750, $P3749
    if $I3750, unless_3744_end
    .const 'Sub' $P3752 = "447_1303739803.72" 
    capture_lex $P3752
    $P3752()
  unless_3744_end:
.annotate 'line', 965
    find_lex $P3784, "self"
    find_lex $P3785, "$?PACKAGE"
    get_who $P3786, $P3785
    set $P3787, $P3786["@BLOCK"]
    unless_null $P3787, vivify_1734
    $P3787 = root_new ['parrot';'ResizablePMCArray']
  vivify_1734:
    set $P3788, $P3787[0]
    unless_null $P3788, vivify_1735
    new $P3788, "Undef"
  vivify_1735:
    $P3789 = $P3784."SET_BLOCK_OUTER_CTX"($P3788)
.annotate 'line', 951
    .return ($P3789)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3751"  :anon :subid("447_1303739803.72") :outer("446_1303739803.72")
.annotate 'line', 955
    new $P3753, "Undef"
    .lex "$SETTING", $P3753
    find_dynamic_lex $P3756, "$*SC"
    unless_null $P3756, vivify_1719
    get_hll_global $P3754, "GLOBAL"
    get_who $P3755, $P3754
    set $P3756, $P3755["$SC"]
    unless_null $P3756, vivify_1720
    die "Contextual $*SC not found"
  vivify_1720:
  vivify_1719:
    find_dynamic_lex $P3760, "%*COMPILING"
    unless_null $P3760, vivify_1721
    get_hll_global $P3758, "GLOBAL"
    get_who $P3759, $P3758
    set $P3760, $P3759["%COMPILING"]
    unless_null $P3760, vivify_1722
    die "Contextual %*COMPILING not found"
  vivify_1722:
  vivify_1721:
    set $P3761, $P3760["%?OPTIONS"]
    unless_null $P3761, vivify_1723
    $P3761 = root_new ['parrot';'Hash']
  vivify_1723:
    set $P3762, $P3761["setting"]
    unless_null $P3762, vivify_1724
    new $P3762, "Undef"
  vivify_1724:
    set $P3757, $P3762
    defined $I3764, $P3757
    if $I3764, default_3763
    new $P3765, "String"
    assign $P3765, "NQPCORE"
    set $P3757, $P3765
  default_3763:
    $P3766 = $P3756."load_setting"($P3757)
    store_lex "$SETTING", $P3766
.annotate 'line', 960
    find_dynamic_lex $P3771, "%*COMPILING"
    unless_null $P3771, vivify_1725
    get_hll_global $P3769, "GLOBAL"
    get_who $P3770, $P3769
    set $P3771, $P3770["%COMPILING"]
    unless_null $P3771, vivify_1726
    die "Contextual %*COMPILING not found"
  vivify_1726:
  vivify_1725:
    set $P3772, $P3771["%?OPTIONS"]
    unless_null $P3772, vivify_1727
    $P3772 = root_new ['parrot';'Hash']
  vivify_1727:
    set $P3773, $P3772["setting"]
    unless_null $P3773, vivify_1728
    new $P3773, "Undef"
  vivify_1728:
    set $S3774, $P3773
    iseq $I3775, $S3774, "NULL"
    unless $I3775, unless_3768
    new $P3767, 'Integer'
    set $P3767, $I3775
    goto unless_3768_end
  unless_3768:
.annotate 'line', 961
    find_lex $P3776, "$SETTING"
    unless_null $P3776, vivify_1729
    new $P3776, "Undef"
  vivify_1729:
    "import_HOW_exports"($P3776)
.annotate 'line', 962
    find_dynamic_lex $P3779, "$*SC"
    unless_null $P3779, vivify_1730
    get_hll_global $P3777, "GLOBAL"
    get_who $P3778, $P3777
    set $P3779, $P3778["$SC"]
    unless_null $P3779, vivify_1731
    die "Contextual $*SC not found"
  vivify_1731:
  vivify_1730:
    find_dynamic_lex $P3782, "$*GLOBALish"
    unless_null $P3782, vivify_1732
    get_hll_global $P3780, "GLOBAL"
    get_who $P3781, $P3780
    set $P3782, $P3781["$GLOBALish"]
    unless_null $P3782, vivify_1733
    die "Contextual $*GLOBALish not found"
  vivify_1733:
  vivify_1732:
    $P3783 = $P3779."load_module"("Regex", $P3782)
.annotate 'line', 960
    set $P3767, $P3783
  unless_3768_end:
.annotate 'line', 952
    .return ($P3767)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("448_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3792
    .param pmc param_3793
.annotate 'line', 977
    .lex "self", param_3792
    .lex "$/", param_3793
.annotate 'line', 981
    find_dynamic_lex $P3796, "$*SC"
    unless_null $P3796, vivify_1736
    get_hll_global $P3794, "GLOBAL"
    get_who $P3795, $P3794
    set $P3796, $P3795["$SC"]
    unless_null $P3796, vivify_1737
    die "Contextual $*SC not found"
  vivify_1737:
  vivify_1736:
    find_dynamic_lex $P3799, "%*HOW"
    unless_null $P3799, vivify_1738
    get_hll_global $P3797, "GLOBAL"
    get_who $P3798, $P3797
    set $P3799, $P3798["%HOW"]
    unless_null $P3799, vivify_1739
    die "Contextual %*HOW not found"
  vivify_1739:
  vivify_1738:
    set $P3800, $P3799["knowhow"]
    unless_null $P3800, vivify_1740
    new $P3800, "Undef"
  vivify_1740:
    $P3801 = $P3796."pkg_create_mo"($P3800, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3801
.annotate 'line', 982
    find_dynamic_lex $P3804, "$*GLOBALish"
    unless_null $P3804, vivify_1741
    get_hll_global $P3802, "GLOBAL"
    get_who $P3803, $P3802
    set $P3804, $P3803["$GLOBALish"]
    unless_null $P3804, vivify_1742
    die "Contextual $*GLOBALish not found"
  vivify_1742:
  vivify_1741:
    get_how $P3805, $P3804
    find_dynamic_lex $P3808, "$*GLOBALish"
    unless_null $P3808, vivify_1743
    get_hll_global $P3806, "GLOBAL"
    get_who $P3807, $P3806
    set $P3808, $P3807["$GLOBALish"]
    unless_null $P3808, vivify_1744
    die "Contextual $*GLOBALish not found"
  vivify_1744:
  vivify_1743:
    $P3805."compose"($P3808)
.annotate 'line', 983
    find_dynamic_lex $P3811, "$*SC"
    unless_null $P3811, vivify_1745
    get_hll_global $P3809, "GLOBAL"
    get_who $P3810, $P3809
    set $P3811, $P3810["$SC"]
    unless_null $P3811, vivify_1746
    die "Contextual $*SC not found"
  vivify_1746:
  vivify_1745:
    find_lex $P3812, "$?PACKAGE"
    get_who $P3813, $P3812
    set $P3814, $P3813["@BLOCK"]
    unless_null $P3814, vivify_1747
    $P3814 = root_new ['parrot';'ResizablePMCArray']
  vivify_1747:
    set $P3815, $P3814[0]
    unless_null $P3815, vivify_1748
    new $P3815, "Undef"
  vivify_1748:
    find_dynamic_lex $P3818, "$*GLOBALish"
    unless_null $P3818, vivify_1749
    get_hll_global $P3816, "GLOBAL"
    get_who $P3817, $P3816
    set $P3818, $P3817["$GLOBALish"]
    unless_null $P3818, vivify_1750
    die "Contextual $*GLOBALish not found"
  vivify_1750:
  vivify_1749:
    $P3811."install_lexical_symbol"($P3815, "GLOBALish", $P3818)
.annotate 'line', 986
    find_dynamic_lex $P3821, "$*GLOBALish"
    unless_null $P3821, vivify_1751
    get_hll_global $P3819, "GLOBAL"
    get_who $P3820, $P3819
    set $P3821, $P3820["$GLOBALish"]
    unless_null $P3821, vivify_1752
    die "Contextual $*GLOBALish not found"
  vivify_1752:
  vivify_1751:
    store_dynamic_lex "$*PACKAGE", $P3821
.annotate 'line', 987
    find_dynamic_lex $P3824, "$*SC"
    unless_null $P3824, vivify_1753
    get_hll_global $P3822, "GLOBAL"
    get_who $P3823, $P3822
    set $P3824, $P3823["$SC"]
    unless_null $P3824, vivify_1754
    die "Contextual $*SC not found"
  vivify_1754:
  vivify_1753:
    find_lex $P3825, "$?PACKAGE"
    get_who $P3826, $P3825
    set $P3827, $P3826["@BLOCK"]
    unless_null $P3827, vivify_1755
    $P3827 = root_new ['parrot';'ResizablePMCArray']
  vivify_1755:
    set $P3828, $P3827[0]
    unless_null $P3828, vivify_1756
    new $P3828, "Undef"
  vivify_1756:
    find_dynamic_lex $P3831, "$*PACKAGE"
    unless_null $P3831, vivify_1757
    get_hll_global $P3829, "GLOBAL"
    get_who $P3830, $P3829
    set $P3831, $P3830["$PACKAGE"]
    unless_null $P3831, vivify_1758
    die "Contextual $*PACKAGE not found"
  vivify_1758:
  vivify_1757:
    $P3832 = $P3824."install_lexical_symbol"($P3828, "$?PACKAGE", $P3831)
.annotate 'line', 977
    .return ($P3832)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("449_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3834
    .param pmc param_3835
.annotate 'line', 990
    .lex "self", param_3834
    .lex "$/", param_3835
.annotate 'line', 991
    find_lex $P3836, "$/"
    find_lex $P3837, "self"
    $P3838 = $P3837."CTXSAVE"()
    $P3839 = $P3836."!make"($P3838)
.annotate 'line', 990
    .return ($P3839)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("450_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3841
    .param pmc param_3842
.annotate 'line', 996
    .lex "self", param_3841
    .lex "$/", param_3842
.annotate 'line', 997
    new $P3843, "Undef"
    .lex "$module", $P3843
    find_dynamic_lex $P3846, "$*SC"
    unless_null $P3846, vivify_1759
    get_hll_global $P3844, "GLOBAL"
    get_who $P3845, $P3844
    set $P3846, $P3845["$SC"]
    unless_null $P3846, vivify_1760
    die "Contextual $*SC not found"
  vivify_1760:
  vivify_1759:
    find_lex $P3847, "$/"
    unless_null $P3847, vivify_1761
    $P3847 = root_new ['parrot';'Hash']
  vivify_1761:
    set $P3848, $P3847["name"]
    unless_null $P3848, vivify_1762
    new $P3848, "Undef"
  vivify_1762:
    set $S3849, $P3848
    find_dynamic_lex $P3852, "$*GLOBALish"
    unless_null $P3852, vivify_1763
    get_hll_global $P3850, "GLOBAL"
    get_who $P3851, $P3850
    set $P3852, $P3851["$GLOBALish"]
    unless_null $P3852, vivify_1764
    die "Contextual $*GLOBALish not found"
  vivify_1764:
  vivify_1763:
    $P3853 = $P3846."load_module"($S3849, $P3852)
    store_lex "$module", $P3853
.annotate 'line', 998
    find_lex $P3855, "$module"
    unless_null $P3855, vivify_1765
    new $P3855, "Undef"
  vivify_1765:
    defined $I3856, $P3855
    unless $I3856, if_3854_end
.annotate 'line', 999
    find_lex $P3857, "$module"
    unless_null $P3857, vivify_1766
    new $P3857, "Undef"
  vivify_1766:
    "import_HOW_exports"($P3857)
  if_3854_end:
.annotate 'line', 1001
    find_lex $P3858, "$/"
    get_hll_global $P3859, "GLOBAL"
    nqp_get_package_through_who $P3860, $P3859, "PAST"
    get_who $P3861, $P3860
    set $P3862, $P3861["Stmts"]
    $P3863 = $P3862."new"()
    $P3864 = $P3858."!make"($P3863)
.annotate 'line', 996
    .return ($P3864)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("451_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3866
    .param pmc param_3867
.annotate 'line', 1004
    .const 'Sub' $P3895 = "452_1303739803.72" 
    capture_lex $P3895
    .lex "self", param_3866
    .lex "$/", param_3867
.annotate 'line', 1005
    new $P3868, "Undef"
    .lex "$count", $P3868
.annotate 'line', 1006
    new $P3869, "Undef"
    .lex "$past", $P3869
.annotate 'line', 1005
    find_lex $P3870, "$/"
    unless_null $P3870, vivify_1767
    $P3870 = root_new ['parrot';'Hash']
  vivify_1767:
    set $P3871, $P3870["xblock"]
    unless_null $P3871, vivify_1768
    new $P3871, "Undef"
  vivify_1768:
    set $N3872, $P3871
    new $P3873, 'Float'
    set $P3873, $N3872
    sub $P3874, $P3873, 1
    store_lex "$count", $P3874
.annotate 'line', 1006
    find_lex $P3875, "$count"
    unless_null $P3875, vivify_1769
    new $P3875, "Undef"
  vivify_1769:
    set $I3876, $P3875
    find_lex $P3877, "$/"
    unless_null $P3877, vivify_1770
    $P3877 = root_new ['parrot';'Hash']
  vivify_1770:
    set $P3878, $P3877["xblock"]
    unless_null $P3878, vivify_1771
    $P3878 = root_new ['parrot';'ResizablePMCArray']
  vivify_1771:
    set $P3879, $P3878[$I3876]
    unless_null $P3879, vivify_1772
    new $P3879, "Undef"
  vivify_1772:
    $P3880 = $P3879."ast"()
    $P3881 = "xblock_immediate"($P3880)
    store_lex "$past", $P3881
.annotate 'line', 1007
    find_lex $P3883, "$/"
    unless_null $P3883, vivify_1773
    $P3883 = root_new ['parrot';'Hash']
  vivify_1773:
    set $P3884, $P3883["else"]
    unless_null $P3884, vivify_1774
    new $P3884, "Undef"
  vivify_1774:
    unless $P3884, if_3882_end
.annotate 'line', 1008
    find_lex $P3885, "$past"
    unless_null $P3885, vivify_1775
    new $P3885, "Undef"
  vivify_1775:
    find_lex $P3886, "$/"
    unless_null $P3886, vivify_1776
    $P3886 = root_new ['parrot';'Hash']
  vivify_1776:
    set $P3887, $P3886["else"]
    unless_null $P3887, vivify_1777
    $P3887 = root_new ['parrot';'ResizablePMCArray']
  vivify_1777:
    set $P3888, $P3887[0]
    unless_null $P3888, vivify_1778
    new $P3888, "Undef"
  vivify_1778:
    $P3889 = $P3888."ast"()
    $P3890 = "block_immediate"($P3889)
    $P3885."push"($P3890)
  if_3882_end:
.annotate 'line', 1011
    new $P3911, 'ExceptionHandler'
    set_label $P3911, loop3910_handler
    $P3911."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3911
  loop3910_test:
    find_lex $P3891, "$count"
    unless_null $P3891, vivify_1779
    new $P3891, "Undef"
  vivify_1779:
    set $N3892, $P3891
    isgt $I3893, $N3892, 0.0
    unless $I3893, loop3910_done
  loop3910_redo:
    .const 'Sub' $P3895 = "452_1303739803.72" 
    capture_lex $P3895
    $P3895()
  loop3910_next:
    goto loop3910_test
  loop3910_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3912, exception, 'type'
    eq $P3912, .CONTROL_LOOP_NEXT, loop3910_next
    eq $P3912, .CONTROL_LOOP_REDO, loop3910_redo
  loop3910_done:
    pop_eh 
.annotate 'line', 1017
    find_lex $P3913, "$/"
    find_lex $P3914, "$past"
    unless_null $P3914, vivify_1788
    new $P3914, "Undef"
  vivify_1788:
    $P3915 = $P3913."!make"($P3914)
.annotate 'line', 1004
    .return ($P3915)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3894"  :anon :subid("452_1303739803.72") :outer("451_1303739803.72")
.annotate 'line', 1013
    new $P3896, "Undef"
    .lex "$else", $P3896
.annotate 'line', 1011
    find_lex $P3897, "$count"
    unless_null $P3897, vivify_1780
    new $P3897, "Undef"
  vivify_1780:
    clone $P3898, $P3897
    dec $P3897
.annotate 'line', 1013
    find_lex $P3899, "$past"
    unless_null $P3899, vivify_1781
    new $P3899, "Undef"
  vivify_1781:
    store_lex "$else", $P3899
.annotate 'line', 1014
    find_lex $P3900, "$count"
    unless_null $P3900, vivify_1782
    new $P3900, "Undef"
  vivify_1782:
    set $I3901, $P3900
    find_lex $P3902, "$/"
    unless_null $P3902, vivify_1783
    $P3902 = root_new ['parrot';'Hash']
  vivify_1783:
    set $P3903, $P3902["xblock"]
    unless_null $P3903, vivify_1784
    $P3903 = root_new ['parrot';'ResizablePMCArray']
  vivify_1784:
    set $P3904, $P3903[$I3901]
    unless_null $P3904, vivify_1785
    new $P3904, "Undef"
  vivify_1785:
    $P3905 = $P3904."ast"()
    $P3906 = "xblock_immediate"($P3905)
    store_lex "$past", $P3906
.annotate 'line', 1015
    find_lex $P3907, "$past"
    unless_null $P3907, vivify_1786
    new $P3907, "Undef"
  vivify_1786:
    find_lex $P3908, "$else"
    unless_null $P3908, vivify_1787
    new $P3908, "Undef"
  vivify_1787:
    $P3909 = $P3907."push"($P3908)
.annotate 'line', 1011
    .return ($P3909)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("453_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3917
    .param pmc param_3918
.annotate 'line', 1020
    .lex "self", param_3917
    .lex "$/", param_3918
.annotate 'line', 1021
    new $P3919, "Undef"
    .lex "$past", $P3919
    find_lex $P3920, "$/"
    unless_null $P3920, vivify_1789
    $P3920 = root_new ['parrot';'Hash']
  vivify_1789:
    set $P3921, $P3920["xblock"]
    unless_null $P3921, vivify_1790
    new $P3921, "Undef"
  vivify_1790:
    $P3922 = $P3921."ast"()
    $P3923 = "xblock_immediate"($P3922)
    store_lex "$past", $P3923
.annotate 'line', 1022
    find_lex $P3924, "$past"
    unless_null $P3924, vivify_1791
    new $P3924, "Undef"
  vivify_1791:
    $P3924."pasttype"("unless")
.annotate 'line', 1023
    find_lex $P3925, "$/"
    find_lex $P3926, "$past"
    unless_null $P3926, vivify_1792
    new $P3926, "Undef"
  vivify_1792:
    $P3927 = $P3925."!make"($P3926)
.annotate 'line', 1020
    .return ($P3927)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("454_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3929
    .param pmc param_3930
.annotate 'line', 1026
    .lex "self", param_3929
    .lex "$/", param_3930
.annotate 'line', 1027
    new $P3931, "Undef"
    .lex "$past", $P3931
    find_lex $P3932, "$/"
    unless_null $P3932, vivify_1793
    $P3932 = root_new ['parrot';'Hash']
  vivify_1793:
    set $P3933, $P3932["xblock"]
    unless_null $P3933, vivify_1794
    new $P3933, "Undef"
  vivify_1794:
    $P3934 = $P3933."ast"()
    $P3935 = "xblock_immediate"($P3934)
    store_lex "$past", $P3935
.annotate 'line', 1028
    find_lex $P3936, "$past"
    unless_null $P3936, vivify_1795
    new $P3936, "Undef"
  vivify_1795:
    find_lex $P3937, "$/"
    unless_null $P3937, vivify_1796
    $P3937 = root_new ['parrot';'Hash']
  vivify_1796:
    set $P3938, $P3937["sym"]
    unless_null $P3938, vivify_1797
    new $P3938, "Undef"
  vivify_1797:
    set $S3939, $P3938
    $P3936."pasttype"($S3939)
.annotate 'line', 1029
    find_lex $P3940, "$/"
    find_lex $P3941, "$past"
    unless_null $P3941, vivify_1798
    new $P3941, "Undef"
  vivify_1798:
    $P3942 = $P3940."!make"($P3941)
.annotate 'line', 1026
    .return ($P3942)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("455_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3944
    .param pmc param_3945
.annotate 'line', 1032
    .lex "self", param_3944
    .lex "$/", param_3945
.annotate 'line', 1033
    new $P3946, "Undef"
    .lex "$pasttype", $P3946
.annotate 'line', 1034
    new $P3947, "Undef"
    .lex "$past", $P3947
.annotate 'line', 1033
    new $P3948, "String"
    assign $P3948, "repeat_"
    find_lex $P3949, "$/"
    unless_null $P3949, vivify_1799
    $P3949 = root_new ['parrot';'Hash']
  vivify_1799:
    set $P3950, $P3949["wu"]
    unless_null $P3950, vivify_1800
    new $P3950, "Undef"
  vivify_1800:
    set $S3951, $P3950
    concat $P3952, $P3948, $S3951
    store_lex "$pasttype", $P3952
    find_lex $P3953, "$past"
    unless_null $P3953, vivify_1801
    new $P3953, "Undef"
  vivify_1801:
.annotate 'line', 1035
    find_lex $P3955, "$/"
    unless_null $P3955, vivify_1802
    $P3955 = root_new ['parrot';'Hash']
  vivify_1802:
    set $P3956, $P3955["xblock"]
    unless_null $P3956, vivify_1803
    new $P3956, "Undef"
  vivify_1803:
    if $P3956, if_3954
.annotate 'line', 1040
    get_hll_global $P3963, "GLOBAL"
    nqp_get_package_through_who $P3964, $P3963, "PAST"
    get_who $P3965, $P3964
    set $P3966, $P3965["Op"]
    find_lex $P3967, "$/"
    unless_null $P3967, vivify_1804
    $P3967 = root_new ['parrot';'Hash']
  vivify_1804:
    set $P3968, $P3967["EXPR"]
    unless_null $P3968, vivify_1805
    new $P3968, "Undef"
  vivify_1805:
    $P3969 = $P3968."ast"()
    find_lex $P3970, "$/"
    unless_null $P3970, vivify_1806
    $P3970 = root_new ['parrot';'Hash']
  vivify_1806:
    set $P3971, $P3970["pblock"]
    unless_null $P3971, vivify_1807
    new $P3971, "Undef"
  vivify_1807:
    $P3972 = $P3971."ast"()
    $P3973 = "block_immediate"($P3972)
    find_lex $P3974, "$pasttype"
    unless_null $P3974, vivify_1808
    new $P3974, "Undef"
  vivify_1808:
    find_lex $P3975, "$/"
    unless_null $P3975, vivify_1809
    new $P3975, "Undef"
  vivify_1809:
    $P3976 = $P3966."new"($P3969, $P3973, $P3974 :named("pasttype"), $P3975 :named("node"))
    store_lex "$past", $P3976
.annotate 'line', 1039
    goto if_3954_end
  if_3954:
.annotate 'line', 1036
    find_lex $P3957, "$/"
    unless_null $P3957, vivify_1810
    $P3957 = root_new ['parrot';'Hash']
  vivify_1810:
    set $P3958, $P3957["xblock"]
    unless_null $P3958, vivify_1811
    new $P3958, "Undef"
  vivify_1811:
    $P3959 = $P3958."ast"()
    $P3960 = "xblock_immediate"($P3959)
    store_lex "$past", $P3960
.annotate 'line', 1037
    find_lex $P3961, "$past"
    unless_null $P3961, vivify_1812
    new $P3961, "Undef"
  vivify_1812:
    find_lex $P3962, "$pasttype"
    unless_null $P3962, vivify_1813
    new $P3962, "Undef"
  vivify_1813:
    $P3961."pasttype"($P3962)
  if_3954_end:
.annotate 'line', 1043
    find_lex $P3977, "$/"
    find_lex $P3978, "$past"
    unless_null $P3978, vivify_1814
    new $P3978, "Undef"
  vivify_1814:
    $P3979 = $P3977."!make"($P3978)
.annotate 'line', 1032
    .return ($P3979)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("456_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_3981
    .param pmc param_3982
.annotate 'line', 1046
    .lex "self", param_3981
    .lex "$/", param_3982
.annotate 'line', 1047
    new $P3983, "Undef"
    .lex "$past", $P3983
.annotate 'line', 1049
    new $P3984, "Undef"
    .lex "$block", $P3984
.annotate 'line', 1047
    find_lex $P3985, "$/"
    unless_null $P3985, vivify_1815
    $P3985 = root_new ['parrot';'Hash']
  vivify_1815:
    set $P3986, $P3985["xblock"]
    unless_null $P3986, vivify_1816
    new $P3986, "Undef"
  vivify_1816:
    $P3987 = $P3986."ast"()
    store_lex "$past", $P3987
.annotate 'line', 1048
    find_lex $P3988, "$past"
    unless_null $P3988, vivify_1817
    new $P3988, "Undef"
  vivify_1817:
    $P3988."pasttype"("for")
.annotate 'line', 1049
    find_lex $P3989, "$past"
    unless_null $P3989, vivify_1818
    $P3989 = root_new ['parrot';'ResizablePMCArray']
  vivify_1818:
    set $P3990, $P3989[1]
    unless_null $P3990, vivify_1819
    new $P3990, "Undef"
  vivify_1819:
    store_lex "$block", $P3990
.annotate 'line', 1050
    find_lex $P3992, "$block"
    unless_null $P3992, vivify_1820
    new $P3992, "Undef"
  vivify_1820:
    $P3993 = $P3992."arity"()
    if $P3993, unless_3991_end
.annotate 'line', 1051
    find_lex $P3994, "$block"
    unless_null $P3994, vivify_1821
    $P3994 = root_new ['parrot';'ResizablePMCArray']
  vivify_1821:
    set $P3995, $P3994[0]
    unless_null $P3995, vivify_1822
    new $P3995, "Undef"
  vivify_1822:
    get_hll_global $P3996, "GLOBAL"
    nqp_get_package_through_who $P3997, $P3996, "PAST"
    get_who $P3998, $P3997
    set $P3999, $P3998["Var"]
    $P4000 = $P3999."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3995."push"($P4000)
.annotate 'line', 1052
    find_lex $P4001, "$block"
    unless_null $P4001, vivify_1823
    new $P4001, "Undef"
  vivify_1823:
    $P4001."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1053
    find_lex $P4002, "$block"
    unless_null $P4002, vivify_1824
    new $P4002, "Undef"
  vivify_1824:
    $P4002."arity"(1)
  unless_3991_end:
.annotate 'line', 1055
    find_lex $P4003, "$block"
    unless_null $P4003, vivify_1825
    new $P4003, "Undef"
  vivify_1825:
    $P4003."blocktype"("immediate")
.annotate 'line', 1056
    find_lex $P4004, "$/"
    find_lex $P4005, "$past"
    unless_null $P4005, vivify_1826
    new $P4005, "Undef"
  vivify_1826:
    $P4006 = $P4004."!make"($P4005)
.annotate 'line', 1046
    .return ($P4006)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("457_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4008
    .param pmc param_4009
.annotate 'line', 1059
    .lex "self", param_4008
    .lex "$/", param_4009
.annotate 'line', 1060
    new $P4010, "Undef"
    .lex "$block", $P4010
    find_lex $P4011, "$/"
    unless_null $P4011, vivify_1827
    $P4011 = root_new ['parrot';'Hash']
  vivify_1827:
    set $P4012, $P4011["block"]
    unless_null $P4012, vivify_1828
    new $P4012, "Undef"
  vivify_1828:
    $P4013 = $P4012."ast"()
    store_lex "$block", $P4013
.annotate 'line', 1061
    find_lex $P4014, "$/"
    unless_null $P4014, vivify_1829
    new $P4014, "Undef"
  vivify_1829:
    find_lex $P4015, "$block"
    unless_null $P4015, vivify_1830
    new $P4015, "Undef"
  vivify_1830:
    "push_block_handler"($P4014, $P4015)
.annotate 'line', 1062
    find_lex $P4016, "$?PACKAGE"
    get_who $P4017, $P4016
    set $P4018, $P4017["@BLOCK"]
    unless_null $P4018, vivify_1831
    $P4018 = root_new ['parrot';'ResizablePMCArray']
  vivify_1831:
    set $P4019, $P4018[0]
    unless_null $P4019, vivify_1832
    new $P4019, "Undef"
  vivify_1832:
    $P4020 = $P4019."handlers"()
    set $P4021, $P4020[0]
    unless_null $P4021, vivify_1833
    new $P4021, "Undef"
  vivify_1833:
    $P4021."handle_types_except"("CONTROL")
.annotate 'line', 1063
    find_lex $P4022, "$/"
    get_hll_global $P4023, "GLOBAL"
    nqp_get_package_through_who $P4024, $P4023, "PAST"
    get_who $P4025, $P4024
    set $P4026, $P4025["Stmts"]
    find_lex $P4027, "$/"
    unless_null $P4027, vivify_1834
    new $P4027, "Undef"
  vivify_1834:
    $P4028 = $P4026."new"($P4027 :named("node"))
    $P4029 = $P4022."!make"($P4028)
.annotate 'line', 1059
    .return ($P4029)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("458_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4031
    .param pmc param_4032
.annotate 'line', 1066
    .lex "self", param_4031
    .lex "$/", param_4032
.annotate 'line', 1067
    new $P4033, "Undef"
    .lex "$block", $P4033
    find_lex $P4034, "$/"
    unless_null $P4034, vivify_1835
    $P4034 = root_new ['parrot';'Hash']
  vivify_1835:
    set $P4035, $P4034["block"]
    unless_null $P4035, vivify_1836
    new $P4035, "Undef"
  vivify_1836:
    $P4036 = $P4035."ast"()
    store_lex "$block", $P4036
.annotate 'line', 1068
    find_lex $P4037, "$/"
    unless_null $P4037, vivify_1837
    new $P4037, "Undef"
  vivify_1837:
    find_lex $P4038, "$block"
    unless_null $P4038, vivify_1838
    new $P4038, "Undef"
  vivify_1838:
    "push_block_handler"($P4037, $P4038)
.annotate 'line', 1069
    find_lex $P4039, "$?PACKAGE"
    get_who $P4040, $P4039
    set $P4041, $P4040["@BLOCK"]
    unless_null $P4041, vivify_1839
    $P4041 = root_new ['parrot';'ResizablePMCArray']
  vivify_1839:
    set $P4042, $P4041[0]
    unless_null $P4042, vivify_1840
    new $P4042, "Undef"
  vivify_1840:
    $P4043 = $P4042."handlers"()
    set $P4044, $P4043[0]
    unless_null $P4044, vivify_1841
    new $P4044, "Undef"
  vivify_1841:
    $P4044."handle_types"("CONTROL")
.annotate 'line', 1070
    find_lex $P4045, "$/"
    get_hll_global $P4046, "GLOBAL"
    nqp_get_package_through_who $P4047, $P4046, "PAST"
    get_who $P4048, $P4047
    set $P4049, $P4048["Stmts"]
    find_lex $P4050, "$/"
    unless_null $P4050, vivify_1842
    new $P4050, "Undef"
  vivify_1842:
    $P4051 = $P4049."new"($P4050 :named("node"))
    $P4052 = $P4045."!make"($P4051)
.annotate 'line', 1066
    .return ($P4052)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("459_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4055
    .param pmc param_4056
.annotate 'line', 1110
    .lex "self", param_4055
    .lex "$/", param_4056
.annotate 'line', 1111
    find_lex $P4057, "$?PACKAGE"
    get_who $P4058, $P4057
    set $P4059, $P4058["@BLOCK"]
    unless_null $P4059, vivify_1843
    $P4059 = root_new ['parrot';'ResizablePMCArray']
  vivify_1843:
    set $P4060, $P4059[0]
    unless_null $P4060, vivify_1844
    new $P4060, "Undef"
  vivify_1844:
    find_lex $P4061, "$/"
    unless_null $P4061, vivify_1845
    $P4061 = root_new ['parrot';'Hash']
  vivify_1845:
    set $P4062, $P4061["blorst"]
    unless_null $P4062, vivify_1846
    new $P4062, "Undef"
  vivify_1846:
    $P4063 = $P4062."ast"()
    $P4060."push"($P4063)
.annotate 'line', 1112
    find_lex $P4064, "$/"
    get_hll_global $P4065, "GLOBAL"
    nqp_get_package_through_who $P4066, $P4065, "PAST"
    get_who $P4067, $P4066
    set $P4068, $P4067["Stmts"]
    $P4069 = $P4068."new"()
    $P4070 = $P4064."!make"($P4069)
.annotate 'line', 1110
    .return ($P4070)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("460_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4072
    .param pmc param_4073
.annotate 'line', 1115
    .lex "self", param_4072
    .lex "$/", param_4073
.annotate 'line', 1116
    new $P4074, "Undef"
    .lex "$past", $P4074
    find_lex $P4075, "$/"
    unless_null $P4075, vivify_1847
    $P4075 = root_new ['parrot';'Hash']
  vivify_1847:
    set $P4076, $P4075["blorst"]
    unless_null $P4076, vivify_1848
    new $P4076, "Undef"
  vivify_1848:
    $P4077 = $P4076."ast"()
    store_lex "$past", $P4077
.annotate 'line', 1117
    get_hll_global $P4079, "GLOBAL"
    nqp_get_package_through_who $P4080, $P4079, "PAST"
    get_who $P4081, $P4080
    set $P4082, $P4081["Block"]
    find_lex $P4083, "$past"
    unless_null $P4083, vivify_1849
    new $P4083, "Undef"
  vivify_1849:
    $P4084 = $P4082."ACCEPTS"($P4083)
    if $P4084, unless_4078_end
.annotate 'line', 1118
    get_hll_global $P4085, "GLOBAL"
    nqp_get_package_through_who $P4086, $P4085, "PAST"
    get_who $P4087, $P4086
    set $P4088, $P4087["Block"]
    find_lex $P4089, "$past"
    unless_null $P4089, vivify_1850
    new $P4089, "Undef"
  vivify_1850:
    find_lex $P4090, "$/"
    unless_null $P4090, vivify_1851
    new $P4090, "Undef"
  vivify_1851:
    $P4091 = $P4088."new"($P4089, "immediate" :named("blocktype"), $P4090 :named("node"))
    store_lex "$past", $P4091
  unless_4078_end:
.annotate 'line', 1120
    find_lex $P4093, "$past"
    unless_null $P4093, vivify_1852
    new $P4093, "Undef"
  vivify_1852:
    $P4094 = $P4093."handlers"()
    if $P4094, unless_4092_end
.annotate 'line', 1121
    find_lex $P4095, "$past"
    unless_null $P4095, vivify_1853
    new $P4095, "Undef"
  vivify_1853:
    get_hll_global $P4096, "GLOBAL"
    nqp_get_package_through_who $P4097, $P4096, "PAST"
    get_who $P4098, $P4097
    set $P4099, $P4098["Control"]
.annotate 'line', 1123
    get_hll_global $P4100, "GLOBAL"
    nqp_get_package_through_who $P4101, $P4100, "PAST"
    get_who $P4102, $P4101
    set $P4103, $P4102["Stmts"]
.annotate 'line', 1124
    get_hll_global $P4104, "GLOBAL"
    nqp_get_package_through_who $P4105, $P4104, "PAST"
    get_who $P4106, $P4105
    set $P4107, $P4106["Op"]
.annotate 'line', 1125
    get_hll_global $P4108, "GLOBAL"
    nqp_get_package_through_who $P4109, $P4108, "PAST"
    get_who $P4110, $P4109
    set $P4111, $P4110["Var"]
.annotate 'line', 1126
    get_hll_global $P4112, "GLOBAL"
    nqp_get_package_through_who $P4113, $P4112, "PAST"
    get_who $P4114, $P4113
    set $P4115, $P4114["Var"]
    $P4116 = $P4115."new"("register" :named("scope"), "exception" :named("name"))
    $P4117 = $P4111."new"($P4116, "handled", "keyed" :named("scope"))
.annotate 'line', 1125
    $P4118 = $P4107."new"($P4117, 1, "bind" :named("pasttype"))
.annotate 'line', 1124
    $P4119 = $P4103."new"($P4118)
.annotate 'line', 1123
    $P4120 = $P4099."new"($P4119, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1121
    new $P4121, "ResizablePMCArray"
    push $P4121, $P4120
    $P4095."handlers"($P4121)
  unless_4092_end:
.annotate 'line', 1135
    find_lex $P4122, "$/"
    find_lex $P4123, "$past"
    unless_null $P4123, vivify_1854
    new $P4123, "Undef"
  vivify_1854:
    $P4124 = $P4122."!make"($P4123)
.annotate 'line', 1115
    .return ($P4124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("461_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4126
    .param pmc param_4127
.annotate 'line', 1138
    .lex "self", param_4126
    .lex "$/", param_4127
.annotate 'line', 1139
    find_lex $P4128, "$/"
.annotate 'line', 1140
    find_lex $P4131, "$/"
    unless_null $P4131, vivify_1855
    $P4131 = root_new ['parrot';'Hash']
  vivify_1855:
    set $P4132, $P4131["block"]
    unless_null $P4132, vivify_1856
    new $P4132, "Undef"
  vivify_1856:
    if $P4132, if_4130
.annotate 'line', 1141
    find_lex $P4137, "$/"
    unless_null $P4137, vivify_1857
    $P4137 = root_new ['parrot';'Hash']
  vivify_1857:
    set $P4138, $P4137["statement"]
    unless_null $P4138, vivify_1858
    new $P4138, "Undef"
  vivify_1858:
    $P4139 = $P4138."ast"()
    set $P4129, $P4139
.annotate 'line', 1140
    goto if_4130_end
  if_4130:
    find_lex $P4133, "$/"
    unless_null $P4133, vivify_1859
    $P4133 = root_new ['parrot';'Hash']
  vivify_1859:
    set $P4134, $P4133["block"]
    unless_null $P4134, vivify_1860
    new $P4134, "Undef"
  vivify_1860:
    $P4135 = $P4134."ast"()
    $P4136 = "block_immediate"($P4135)
    set $P4129, $P4136
  if_4130_end:
    $P4140 = $P4128."!make"($P4129)
.annotate 'line', 1138
    .return ($P4140)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("462_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4142
    .param pmc param_4143
.annotate 'line', 1146
    .lex "self", param_4142
    .lex "$/", param_4143
    find_lex $P4144, "$/"
    find_lex $P4145, "$/"
    unless_null $P4145, vivify_1861
    $P4145 = root_new ['parrot';'Hash']
  vivify_1861:
    set $P4146, $P4145["cond"]
    unless_null $P4146, vivify_1862
    new $P4146, "Undef"
  vivify_1862:
    $P4147 = $P4146."ast"()
    $P4148 = $P4144."!make"($P4147)
    .return ($P4148)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("463_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4150
    .param pmc param_4151
.annotate 'line', 1147
    .lex "self", param_4150
    .lex "$/", param_4151
    find_lex $P4152, "$/"
    find_lex $P4153, "$/"
    unless_null $P4153, vivify_1863
    $P4153 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P4154, $P4153["cond"]
    unless_null $P4154, vivify_1864
    new $P4154, "Undef"
  vivify_1864:
    $P4155 = $P4154."ast"()
    $P4156 = $P4152."!make"($P4155)
    .return ($P4156)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("464_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4158
    .param pmc param_4159
.annotate 'line', 1149
    .lex "self", param_4158
    .lex "$/", param_4159
    find_lex $P4160, "$/"
    find_lex $P4161, "$/"
    unless_null $P4161, vivify_1865
    $P4161 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P4162, $P4161["cond"]
    unless_null $P4162, vivify_1866
    new $P4162, "Undef"
  vivify_1866:
    $P4163 = $P4162."ast"()
    $P4164 = $P4160."!make"($P4163)
    .return ($P4164)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("465_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4166
    .param pmc param_4167
.annotate 'line', 1150
    .lex "self", param_4166
    .lex "$/", param_4167
    find_lex $P4168, "$/"
    find_lex $P4169, "$/"
    unless_null $P4169, vivify_1867
    $P4169 = root_new ['parrot';'Hash']
  vivify_1867:
    set $P4170, $P4169["cond"]
    unless_null $P4170, vivify_1868
    new $P4170, "Undef"
  vivify_1868:
    $P4171 = $P4170."ast"()
    $P4172 = $P4168."!make"($P4171)
    .return ($P4172)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("466_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4174
    .param pmc param_4175
.annotate 'line', 1154
    .lex "self", param_4174
    .lex "$/", param_4175
    find_lex $P4176, "$/"
    find_lex $P4177, "$/"
    unless_null $P4177, vivify_1869
    $P4177 = root_new ['parrot';'Hash']
  vivify_1869:
    set $P4178, $P4177["fatarrow"]
    unless_null $P4178, vivify_1870
    new $P4178, "Undef"
  vivify_1870:
    $P4179 = $P4178."ast"()
    $P4180 = $P4176."!make"($P4179)
    .return ($P4180)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("467_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4182
    .param pmc param_4183
.annotate 'line', 1155
    .lex "self", param_4182
    .lex "$/", param_4183
    find_lex $P4184, "$/"
    find_lex $P4185, "$/"
    unless_null $P4185, vivify_1871
    $P4185 = root_new ['parrot';'Hash']
  vivify_1871:
    set $P4186, $P4185["colonpair"]
    unless_null $P4186, vivify_1872
    new $P4186, "Undef"
  vivify_1872:
    $P4187 = $P4186."ast"()
    $P4188 = $P4184."!make"($P4187)
    .return ($P4188)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("468_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4190
    .param pmc param_4191
.annotate 'line', 1156
    .lex "self", param_4190
    .lex "$/", param_4191
    find_lex $P4192, "$/"
    find_lex $P4193, "$/"
    unless_null $P4193, vivify_1873
    $P4193 = root_new ['parrot';'Hash']
  vivify_1873:
    set $P4194, $P4193["variable"]
    unless_null $P4194, vivify_1874
    new $P4194, "Undef"
  vivify_1874:
    $P4195 = $P4194."ast"()
    $P4196 = $P4192."!make"($P4195)
    .return ($P4196)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("469_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4198
    .param pmc param_4199
.annotate 'line', 1157
    .lex "self", param_4198
    .lex "$/", param_4199
    find_lex $P4200, "$/"
    find_lex $P4201, "$/"
    unless_null $P4201, vivify_1875
    $P4201 = root_new ['parrot';'Hash']
  vivify_1875:
    set $P4202, $P4201["package_declarator"]
    unless_null $P4202, vivify_1876
    new $P4202, "Undef"
  vivify_1876:
    $P4203 = $P4202."ast"()
    $P4204 = $P4200."!make"($P4203)
    .return ($P4204)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("470_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4206
    .param pmc param_4207
.annotate 'line', 1158
    .lex "self", param_4206
    .lex "$/", param_4207
    find_lex $P4208, "$/"
    find_lex $P4209, "$/"
    unless_null $P4209, vivify_1877
    $P4209 = root_new ['parrot';'Hash']
  vivify_1877:
    set $P4210, $P4209["scope_declarator"]
    unless_null $P4210, vivify_1878
    new $P4210, "Undef"
  vivify_1878:
    $P4211 = $P4210."ast"()
    $P4212 = $P4208."!make"($P4211)
    .return ($P4212)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("471_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4214
    .param pmc param_4215
.annotate 'line', 1159
    .lex "self", param_4214
    .lex "$/", param_4215
    find_lex $P4216, "$/"
    find_lex $P4217, "$/"
    unless_null $P4217, vivify_1879
    $P4217 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P4218, $P4217["routine_declarator"]
    unless_null $P4218, vivify_1880
    new $P4218, "Undef"
  vivify_1880:
    $P4219 = $P4218."ast"()
    $P4220 = $P4216."!make"($P4219)
    .return ($P4220)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("472_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4222
    .param pmc param_4223
.annotate 'line', 1160
    .lex "self", param_4222
    .lex "$/", param_4223
    find_lex $P4224, "$/"
    find_lex $P4225, "$/"
    unless_null $P4225, vivify_1881
    $P4225 = root_new ['parrot';'Hash']
  vivify_1881:
    set $P4226, $P4225["regex_declarator"]
    unless_null $P4226, vivify_1882
    new $P4226, "Undef"
  vivify_1882:
    $P4227 = $P4226."ast"()
    $P4228 = $P4224."!make"($P4227)
    .return ($P4228)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("473_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4230
    .param pmc param_4231
.annotate 'line', 1161
    .lex "self", param_4230
    .lex "$/", param_4231
    find_lex $P4232, "$/"
    find_lex $P4233, "$/"
    unless_null $P4233, vivify_1883
    $P4233 = root_new ['parrot';'Hash']
  vivify_1883:
    set $P4234, $P4233["statement_prefix"]
    unless_null $P4234, vivify_1884
    new $P4234, "Undef"
  vivify_1884:
    $P4235 = $P4234."ast"()
    $P4236 = $P4232."!make"($P4235)
    .return ($P4236)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("474_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4238
    .param pmc param_4239
.annotate 'line', 1162
    .lex "self", param_4238
    .lex "$/", param_4239
    find_lex $P4240, "$/"
    find_lex $P4241, "$/"
    unless_null $P4241, vivify_1885
    $P4241 = root_new ['parrot';'Hash']
  vivify_1885:
    set $P4242, $P4241["pblock"]
    unless_null $P4242, vivify_1886
    new $P4242, "Undef"
  vivify_1886:
    $P4243 = $P4242."ast"()
    $P4244 = $P4240."!make"($P4243)
    .return ($P4244)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("475_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4246
    .param pmc param_4247
.annotate 'line', 1164
    .lex "self", param_4246
    .lex "$/", param_4247
.annotate 'line', 1165
    new $P4248, "Undef"
    .lex "$past", $P4248
    find_lex $P4249, "$/"
    unless_null $P4249, vivify_1887
    $P4249 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P4250, $P4249["val"]
    unless_null $P4250, vivify_1888
    new $P4250, "Undef"
  vivify_1888:
    $P4251 = $P4250."ast"()
    store_lex "$past", $P4251
.annotate 'line', 1166
    find_lex $P4252, "$past"
    unless_null $P4252, vivify_1889
    new $P4252, "Undef"
  vivify_1889:
    find_lex $P4253, "$/"
    unless_null $P4253, vivify_1890
    $P4253 = root_new ['parrot';'Hash']
  vivify_1890:
    set $P4254, $P4253["key"]
    unless_null $P4254, vivify_1891
    new $P4254, "Undef"
  vivify_1891:
    $P4255 = $P4254."Str"()
    $P4252."named"($P4255)
.annotate 'line', 1167
    find_lex $P4256, "$/"
    find_lex $P4257, "$past"
    unless_null $P4257, vivify_1892
    new $P4257, "Undef"
  vivify_1892:
    $P4258 = $P4256."!make"($P4257)
.annotate 'line', 1164
    .return ($P4258)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("476_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4260
    .param pmc param_4261
.annotate 'line', 1170
    .lex "self", param_4260
    .lex "$/", param_4261
.annotate 'line', 1171
    new $P4262, "Undef"
    .lex "$past", $P4262
.annotate 'line', 1172
    find_lex $P4265, "$/"
    unless_null $P4265, vivify_1893
    $P4265 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P4266, $P4265["circumfix"]
    unless_null $P4266, vivify_1894
    new $P4266, "Undef"
  vivify_1894:
    if $P4266, if_4264
.annotate 'line', 1173
    get_hll_global $P4271, "GLOBAL"
    nqp_get_package_through_who $P4272, $P4271, "PAST"
    get_who $P4273, $P4272
    set $P4274, $P4273["Val"]
    find_lex $P4275, "$/"
    unless_null $P4275, vivify_1895
    $P4275 = root_new ['parrot';'Hash']
  vivify_1895:
    set $P4276, $P4275["not"]
    unless_null $P4276, vivify_1896
    new $P4276, "Undef"
  vivify_1896:
    isfalse $I4277, $P4276
    $P4278 = $P4274."new"($I4277 :named("value"))
    set $P4263, $P4278
.annotate 'line', 1172
    goto if_4264_end
  if_4264:
    find_lex $P4267, "$/"
    unless_null $P4267, vivify_1897
    $P4267 = root_new ['parrot';'Hash']
  vivify_1897:
    set $P4268, $P4267["circumfix"]
    unless_null $P4268, vivify_1898
    $P4268 = root_new ['parrot';'ResizablePMCArray']
  vivify_1898:
    set $P4269, $P4268[0]
    unless_null $P4269, vivify_1899
    new $P4269, "Undef"
  vivify_1899:
    $P4270 = $P4269."ast"()
    set $P4263, $P4270
  if_4264_end:
    store_lex "$past", $P4263
.annotate 'line', 1174
    find_lex $P4279, "$past"
    unless_null $P4279, vivify_1900
    new $P4279, "Undef"
  vivify_1900:
    find_lex $P4280, "$/"
    unless_null $P4280, vivify_1901
    $P4280 = root_new ['parrot';'Hash']
  vivify_1901:
    set $P4281, $P4280["identifier"]
    unless_null $P4281, vivify_1902
    new $P4281, "Undef"
  vivify_1902:
    set $S4282, $P4281
    $P4279."named"($S4282)
.annotate 'line', 1175
    find_lex $P4283, "$/"
    find_lex $P4284, "$past"
    unless_null $P4284, vivify_1903
    new $P4284, "Undef"
  vivify_1903:
    $P4285 = $P4283."!make"($P4284)
.annotate 'line', 1170
    .return ($P4285)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("477_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4287
    .param pmc param_4288
.annotate 'line', 1178
    .const 'Sub' $P4304 = "478_1303739803.72" 
    capture_lex $P4304
    .lex "self", param_4287
    .lex "$/", param_4288
.annotate 'line', 1179
    new $P4289, "Undef"
    .lex "$past", $P4289
.annotate 'line', 1178
    find_lex $P4290, "$past"
    unless_null $P4290, vivify_1904
    new $P4290, "Undef"
  vivify_1904:
.annotate 'line', 1180
    find_lex $P4292, "$/"
    unless_null $P4292, vivify_1905
    $P4292 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P4293, $P4292["postcircumfix"]
    unless_null $P4293, vivify_1906
    new $P4293, "Undef"
  vivify_1906:
    if $P4293, if_4291
.annotate 'line', 1184
    .const 'Sub' $P4304 = "478_1303739803.72" 
    capture_lex $P4304
    $P4304()
    goto if_4291_end
  if_4291:
.annotate 'line', 1181
    find_lex $P4294, "$/"
    unless_null $P4294, vivify_1945
    $P4294 = root_new ['parrot';'Hash']
  vivify_1945:
    set $P4295, $P4294["postcircumfix"]
    unless_null $P4295, vivify_1946
    new $P4295, "Undef"
  vivify_1946:
    $P4296 = $P4295."ast"()
    store_lex "$past", $P4296
.annotate 'line', 1182
    find_lex $P4297, "$past"
    unless_null $P4297, vivify_1947
    new $P4297, "Undef"
  vivify_1947:
    get_hll_global $P4298, "GLOBAL"
    nqp_get_package_through_who $P4299, $P4298, "PAST"
    get_who $P4300, $P4299
    set $P4301, $P4300["Var"]
    $P4302 = $P4301."new"("$/" :named("name"))
    $P4297."unshift"($P4302)
  if_4291_end:
.annotate 'line', 1222
    find_lex $P4425, "$/"
    find_lex $P4426, "$past"
    unless_null $P4426, vivify_1948
    new $P4426, "Undef"
  vivify_1948:
    $P4427 = $P4425."!make"($P4426)
.annotate 'line', 1178
    .return ($P4427)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4303"  :anon :subid("478_1303739803.72") :outer("477_1303739803.72")
.annotate 'line', 1184
    .const 'Sub' $P4339 = "479_1303739803.72" 
    capture_lex $P4339
.annotate 'line', 1185
    $P4305 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4305
    get_hll_global $P4306, "GLOBAL"
    nqp_get_package_through_who $P4307, $P4306, "NQP"
    get_who $P4308, $P4307
    set $P4309, $P4308["Compiler"]
    find_lex $P4310, "$/"
    unless_null $P4310, vivify_1907
    new $P4310, "Undef"
  vivify_1907:
    set $S4311, $P4310
    $P4312 = $P4309."parse_name"($S4311)
    store_lex "@name", $P4312
.annotate 'line', 1186
    find_lex $P4315, "@name"
    unless_null $P4315, vivify_1908
    $P4315 = root_new ['parrot';'ResizablePMCArray']
  vivify_1908:
    set $N4316, $P4315
    isgt $I4317, $N4316, 1.0
    if $I4317, if_4314
.annotate 'line', 1193
    find_lex $P4333, "$/"
    unless_null $P4333, vivify_1909
    $P4333 = root_new ['parrot';'Hash']
  vivify_1909:
    set $P4334, $P4333["twigil"]
    unless_null $P4334, vivify_1910
    $P4334 = root_new ['parrot';'ResizablePMCArray']
  vivify_1910:
    set $P4335, $P4334[0]
    unless_null $P4335, vivify_1911
    new $P4335, "Undef"
  vivify_1911:
    set $S4336, $P4335
    iseq $I4337, $S4336, "*"
    if $I4337, if_4332
.annotate 'line', 1204
    find_lex $P4374, "$/"
    unless_null $P4374, vivify_1912
    $P4374 = root_new ['parrot';'Hash']
  vivify_1912:
    set $P4375, $P4374["twigil"]
    unless_null $P4375, vivify_1913
    $P4375 = root_new ['parrot';'ResizablePMCArray']
  vivify_1913:
    set $P4376, $P4375[0]
    unless_null $P4376, vivify_1914
    new $P4376, "Undef"
  vivify_1914:
    set $S4377, $P4376
    iseq $I4378, $S4377, "!"
    if $I4378, if_4373
.annotate 'line', 1212
    find_lex $P4402, "@name"
    unless_null $P4402, vivify_1915
    $P4402 = root_new ['parrot';'ResizablePMCArray']
  vivify_1915:
    set $P4403, $P4402[0]
    unless_null $P4403, vivify_1916
    new $P4403, "Undef"
  vivify_1916:
    set $S4404, $P4403
    $P4405 = "is_package"($S4404)
    if $P4405, if_4401
.annotate 'line', 1217
    get_hll_global $P4414, "GLOBAL"
    nqp_get_package_through_who $P4415, $P4414, "PAST"
    get_who $P4416, $P4415
    set $P4417, $P4416["Var"]
.annotate 'line', 1218
    find_lex $P4418, "@name"
    unless_null $P4418, vivify_1917
    $P4418 = root_new ['parrot';'ResizablePMCArray']
  vivify_1917:
    $P4419 = $P4418."pop"()
    set $S4420, $P4419
    find_lex $P4421, "$/"
    unless_null $P4421, vivify_1918
    $P4421 = root_new ['parrot';'Hash']
  vivify_1918:
    set $P4422, $P4421["sigil"]
    unless_null $P4422, vivify_1919
    new $P4422, "Undef"
  vivify_1919:
    $P4423 = "vivitype"($P4422)
    $P4424 = $P4417."new"($S4420 :named("name"), $P4423 :named("viviself"))
.annotate 'line', 1217
    store_lex "$past", $P4424
.annotate 'line', 1216
    set $P4400, $P4424
.annotate 'line', 1212
    goto if_4401_end
  if_4401:
.annotate 'line', 1213
    find_lex $P4406, "@name"
    unless_null $P4406, vivify_1920
    $P4406 = root_new ['parrot';'ResizablePMCArray']
  vivify_1920:
    find_lex $P4407, "$/"
    unless_null $P4407, vivify_1921
    new $P4407, "Undef"
  vivify_1921:
    $P4408 = "lexical_package_lookup"($P4406, $P4407)
    store_lex "$past", $P4408
.annotate 'line', 1214
    find_lex $P4409, "$past"
    unless_null $P4409, vivify_1922
    new $P4409, "Undef"
  vivify_1922:
    find_lex $P4410, "$/"
    unless_null $P4410, vivify_1923
    $P4410 = root_new ['parrot';'Hash']
  vivify_1923:
    set $P4411, $P4410["sigil"]
    unless_null $P4411, vivify_1924
    new $P4411, "Undef"
  vivify_1924:
    $P4412 = "vivitype"($P4411)
    $P4413 = $P4409."viviself"($P4412)
.annotate 'line', 1212
    set $P4400, $P4413
  if_4401_end:
    set $P4372, $P4400
.annotate 'line', 1204
    goto if_4373_end
  if_4373:
.annotate 'line', 1205
    get_hll_global $P4379, "GLOBAL"
    nqp_get_package_through_who $P4380, $P4379, "PAST"
    get_who $P4381, $P4380
    set $P4382, $P4381["Var"]
.annotate 'line', 1206
    find_lex $P4383, "@name"
    unless_null $P4383, vivify_1925
    $P4383 = root_new ['parrot';'ResizablePMCArray']
  vivify_1925:
    $P4384 = $P4383."pop"()
    set $S4385, $P4384
.annotate 'line', 1207
    find_lex $P4386, "$/"
    unless_null $P4386, vivify_1926
    $P4386 = root_new ['parrot';'Hash']
  vivify_1926:
    set $P4387, $P4386["sigil"]
    unless_null $P4387, vivify_1927
    new $P4387, "Undef"
  vivify_1927:
    $P4388 = "vivitype"($P4387)
.annotate 'line', 1208
    get_hll_global $P4389, "GLOBAL"
    nqp_get_package_through_who $P4390, $P4389, "PAST"
    get_who $P4391, $P4390
    set $P4392, $P4391["Var"]
    $P4393 = $P4392."new"("self" :named("name"))
.annotate 'line', 1209
    get_hll_global $P4394, "GLOBAL"
    nqp_get_package_through_who $P4395, $P4394, "PAST"
    get_who $P4396, $P4395
    set $P4397, $P4396["Var"]
    $P4398 = $P4397."new"("$?CLASS" :named("name"))
    $P4399 = $P4382."new"($P4393, $P4398, $S4385 :named("name"), "attribute" :named("scope"), $P4388 :named("viviself"))
.annotate 'line', 1205
    store_lex "$past", $P4399
.annotate 'line', 1204
    set $P4372, $P4399
  if_4373_end:
    set $P4331, $P4372
.annotate 'line', 1193
    goto if_4332_end
  if_4332:
    .const 'Sub' $P4339 = "479_1303739803.72" 
    capture_lex $P4339
    $P4371 = $P4339()
    set $P4331, $P4371
  if_4332_end:
    set $P4313, $P4331
.annotate 'line', 1186
    goto if_4314_end
  if_4314:
.annotate 'line', 1187
    find_lex $P4319, "$/"
    unless_null $P4319, vivify_1937
    $P4319 = root_new ['parrot';'Hash']
  vivify_1937:
    set $P4320, $P4319["twigil"]
    unless_null $P4320, vivify_1938
    new $P4320, "Undef"
  vivify_1938:
    unless $P4320, if_4318_end
.annotate 'line', 1188
    find_lex $P4321, "$/"
    unless_null $P4321, vivify_1939
    new $P4321, "Undef"
  vivify_1939:
    $P4322 = $P4321."CURSOR"()
    $P4322."panic"("Twigil not allowed on multi-part name")
  if_4318_end:
.annotate 'line', 1190
    find_lex $P4323, "@name"
    unless_null $P4323, vivify_1940
    $P4323 = root_new ['parrot';'ResizablePMCArray']
  vivify_1940:
    find_lex $P4324, "$/"
    unless_null $P4324, vivify_1941
    new $P4324, "Undef"
  vivify_1941:
    $P4325 = "lexical_package_lookup"($P4323, $P4324)
    store_lex "$past", $P4325
.annotate 'line', 1191
    find_lex $P4326, "$past"
    unless_null $P4326, vivify_1942
    new $P4326, "Undef"
  vivify_1942:
    find_lex $P4327, "$/"
    unless_null $P4327, vivify_1943
    $P4327 = root_new ['parrot';'Hash']
  vivify_1943:
    set $P4328, $P4327["sigil"]
    unless_null $P4328, vivify_1944
    new $P4328, "Undef"
  vivify_1944:
    $P4329 = "vivitype"($P4328)
    $P4330 = $P4326."viviself"($P4329)
.annotate 'line', 1186
    set $P4313, $P4330
  if_4314_end:
.annotate 'line', 1184
    .return ($P4313)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4338"  :anon :subid("479_1303739803.72") :outer("478_1303739803.72")
.annotate 'line', 1194
    new $P4340, "Undef"
    .lex "$global_fallback", $P4340
    find_lex $P4341, "$/"
    unless_null $P4341, vivify_1928
    $P4341 = root_new ['parrot';'Hash']
  vivify_1928:
    set $P4342, $P4341["sigil"]
    unless_null $P4342, vivify_1929
    new $P4342, "Undef"
  vivify_1929:
    set $S4343, $P4342
    new $P4344, 'String'
    set $P4344, $S4343
    find_lex $P4345, "$/"
    unless_null $P4345, vivify_1930
    $P4345 = root_new ['parrot';'Hash']
  vivify_1930:
    set $P4346, $P4345["desigilname"]
    unless_null $P4346, vivify_1931
    new $P4346, "Undef"
  vivify_1931:
    concat $P4347, $P4344, $P4346
    new $P4348, "ResizablePMCArray"
    push $P4348, "GLOBAL"
    push $P4348, $P4347
    find_lex $P4349, "$/"
    unless_null $P4349, vivify_1932
    new $P4349, "Undef"
  vivify_1932:
    $P4350 = "lexical_package_lookup"($P4348, $P4349)
    store_lex "$global_fallback", $P4350
.annotate 'line', 1195
    find_lex $P4351, "$global_fallback"
    unless_null $P4351, vivify_1933
    new $P4351, "Undef"
  vivify_1933:
    get_hll_global $P4352, "GLOBAL"
    nqp_get_package_through_who $P4353, $P4352, "PAST"
    get_who $P4354, $P4353
    set $P4355, $P4354["Op"]
.annotate 'line', 1196
    new $P4356, "String"
    assign $P4356, "Contextual "
    find_lex $P4357, "$/"
    unless_null $P4357, vivify_1934
    new $P4357, "Undef"
  vivify_1934:
    set $S4358, $P4357
    concat $P4359, $P4356, $S4358
    concat $P4360, $P4359, " not found"
    $P4361 = $P4355."new"($P4360, "die" :named("pirop"))
.annotate 'line', 1195
    $P4351."viviself"($P4361)
.annotate 'line', 1199
    get_hll_global $P4362, "GLOBAL"
    nqp_get_package_through_who $P4363, $P4362, "PAST"
    get_who $P4364, $P4363
    set $P4365, $P4364["Var"]
.annotate 'line', 1200
    find_lex $P4366, "@name"
    unless_null $P4366, vivify_1935
    $P4366 = root_new ['parrot';'ResizablePMCArray']
  vivify_1935:
    $P4367 = $P4366."pop"()
    set $S4368, $P4367
    find_lex $P4369, "$global_fallback"
    unless_null $P4369, vivify_1936
    new $P4369, "Undef"
  vivify_1936:
    $P4370 = $P4365."new"($S4368 :named("name"), "contextual" :named("scope"), $P4369 :named("viviself"))
.annotate 'line', 1199
    store_lex "$past", $P4370
.annotate 'line', 1193
    .return ($P4370)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("480_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4429
    .param pmc param_4430
.annotate 'line', 1225
    .lex "self", param_4429
    .lex "$/", param_4430
    find_lex $P4431, "$/"
    find_lex $P4432, "$/"
    unless_null $P4432, vivify_1949
    $P4432 = root_new ['parrot';'Hash']
  vivify_1949:
    set $P4433, $P4432["package_def"]
    unless_null $P4433, vivify_1950
    new $P4433, "Undef"
  vivify_1950:
    $P4434 = $P4433."ast"()
    $P4435 = $P4431."!make"($P4434)
    .return ($P4435)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("481_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4437
    .param pmc param_4438
.annotate 'line', 1226
    .lex "self", param_4437
    .lex "$/", param_4438
    find_lex $P4439, "$/"
    find_lex $P4440, "$/"
    unless_null $P4440, vivify_1951
    $P4440 = root_new ['parrot';'Hash']
  vivify_1951:
    set $P4441, $P4440["package_def"]
    unless_null $P4441, vivify_1952
    new $P4441, "Undef"
  vivify_1952:
    $P4442 = $P4441."ast"()
    $P4443 = $P4439."!make"($P4442)
    .return ($P4443)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("482_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4445
    .param pmc param_4446
.annotate 'line', 1227
    .lex "self", param_4445
    .lex "$/", param_4446
    find_lex $P4447, "$/"
    find_lex $P4448, "$/"
    unless_null $P4448, vivify_1953
    $P4448 = root_new ['parrot';'Hash']
  vivify_1953:
    set $P4449, $P4448["package_def"]
    unless_null $P4449, vivify_1954
    new $P4449, "Undef"
  vivify_1954:
    $P4450 = $P4449."ast"()
    $P4451 = $P4447."!make"($P4450)
    .return ($P4451)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("483_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4453
    .param pmc param_4454
.annotate 'line', 1228
    .lex "self", param_4453
    .lex "$/", param_4454
    find_lex $P4455, "$/"
    find_lex $P4456, "$/"
    unless_null $P4456, vivify_1955
    $P4456 = root_new ['parrot';'Hash']
  vivify_1955:
    set $P4457, $P4456["package_def"]
    unless_null $P4457, vivify_1956
    new $P4457, "Undef"
  vivify_1956:
    $P4458 = $P4457."ast"()
    $P4459 = $P4455."!make"($P4458)
    .return ($P4459)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("484_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4461
    .param pmc param_4462
.annotate 'line', 1229
    .lex "self", param_4461
    .lex "$/", param_4462
    find_lex $P4463, "$/"
    find_lex $P4464, "$/"
    unless_null $P4464, vivify_1957
    $P4464 = root_new ['parrot';'Hash']
  vivify_1957:
    set $P4465, $P4464["package_def"]
    unless_null $P4465, vivify_1958
    new $P4465, "Undef"
  vivify_1958:
    $P4466 = $P4465."ast"()
    $P4467 = $P4463."!make"($P4466)
    .return ($P4467)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("485_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4469
    .param pmc param_4470
.annotate 'line', 1230
    .lex "self", param_4469
    .lex "$/", param_4470
    find_lex $P4471, "$/"
    find_lex $P4472, "$/"
    unless_null $P4472, vivify_1959
    $P4472 = root_new ['parrot';'Hash']
  vivify_1959:
    set $P4473, $P4472["package_def"]
    unless_null $P4473, vivify_1960
    new $P4473, "Undef"
  vivify_1960:
    $P4474 = $P4473."ast"()
    $P4475 = $P4471."!make"($P4474)
    .return ($P4475)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("486_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4477
    .param pmc param_4478
.annotate 'line', 1232
    .const 'Sub' $P4726 = "488_1303739803.72" 
    capture_lex $P4726
    .const 'Sub' $P4628 = "487_1303739803.72" 
    capture_lex $P4628
    .lex "self", param_4477
    .lex "$/", param_4478
.annotate 'line', 1234
    $P4479 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4479
.annotate 'line', 1235
    new $P4480, "Undef"
    .lex "$name", $P4480
.annotate 'line', 1236
    new $P4481, "Undef"
    .lex "$how", $P4481
.annotate 'line', 1239
    new $P4482, "Undef"
    .lex "$past", $P4482
.annotate 'line', 1234
    find_lex $P4483, "$/"
    unless_null $P4483, vivify_1961
    $P4483 = root_new ['parrot';'Hash']
  vivify_1961:
    set $P4484, $P4483["name"]
    unless_null $P4484, vivify_1962
    $P4484 = root_new ['parrot';'Hash']
  vivify_1962:
    set $P4485, $P4484["identifier"]
    unless_null $P4485, vivify_1963
    new $P4485, "Undef"
  vivify_1963:
    clone $P4486, $P4485
    store_lex "@ns", $P4486
.annotate 'line', 1235
    find_lex $P4487, "@ns"
    unless_null $P4487, vivify_1964
    $P4487 = root_new ['parrot';'ResizablePMCArray']
  vivify_1964:
    $P4488 = $P4487."pop"()
    set $S4489, $P4488
    new $P4490, 'String'
    set $P4490, $S4489
    store_lex "$name", $P4490
.annotate 'line', 1236
    find_dynamic_lex $P4493, "$*PKGDECL"
    unless_null $P4493, vivify_1965
    get_hll_global $P4491, "GLOBAL"
    get_who $P4492, $P4491
    set $P4493, $P4492["$PKGDECL"]
    unless_null $P4493, vivify_1966
    die "Contextual $*PKGDECL not found"
  vivify_1966:
  vivify_1965:
    find_dynamic_lex $P4496, "%*HOW"
    unless_null $P4496, vivify_1967
    get_hll_global $P4494, "GLOBAL"
    get_who $P4495, $P4494
    set $P4496, $P4495["%HOW"]
    unless_null $P4496, vivify_1968
    die "Contextual %*HOW not found"
  vivify_1968:
  vivify_1967:
    set $P4497, $P4496[$P4493]
    unless_null $P4497, vivify_1969
    new $P4497, "Undef"
  vivify_1969:
    store_lex "$how", $P4497
.annotate 'line', 1239
    find_lex $P4500, "$/"
    unless_null $P4500, vivify_1970
    $P4500 = root_new ['parrot';'Hash']
  vivify_1970:
    set $P4501, $P4500["block"]
    unless_null $P4501, vivify_1971
    new $P4501, "Undef"
  vivify_1971:
    if $P4501, if_4499
    find_lex $P4505, "$/"
    unless_null $P4505, vivify_1972
    $P4505 = root_new ['parrot';'Hash']
  vivify_1972:
    set $P4506, $P4505["comp_unit"]
    unless_null $P4506, vivify_1973
    new $P4506, "Undef"
  vivify_1973:
    $P4507 = $P4506."ast"()
    set $P4498, $P4507
    goto if_4499_end
  if_4499:
    find_lex $P4502, "$/"
    unless_null $P4502, vivify_1974
    $P4502 = root_new ['parrot';'Hash']
  vivify_1974:
    set $P4503, $P4502["block"]
    unless_null $P4503, vivify_1975
    new $P4503, "Undef"
  vivify_1975:
    $P4504 = $P4503."ast"()
    set $P4498, $P4504
  if_4499_end:
    store_lex "$past", $P4498
.annotate 'line', 1240
    find_dynamic_lex $P4513, "$*SCOPE"
    unless_null $P4513, vivify_1976
    get_hll_global $P4511, "GLOBAL"
    get_who $P4512, $P4511
    set $P4513, $P4512["$SCOPE"]
    unless_null $P4513, vivify_1977
    die "Contextual $*SCOPE not found"
  vivify_1977:
  vivify_1976:
    set $S4514, $P4513
    iseq $I4515, $S4514, "our"
    unless $I4515, unless_4510
    new $P4509, 'Integer'
    set $P4509, $I4515
    goto unless_4510_end
  unless_4510:
    find_dynamic_lex $P4518, "$*SCOPE"
    unless_null $P4518, vivify_1978
    get_hll_global $P4516, "GLOBAL"
    get_who $P4517, $P4516
    set $P4518, $P4517["$SCOPE"]
    unless_null $P4518, vivify_1979
    die "Contextual $*SCOPE not found"
  vivify_1979:
  vivify_1978:
    set $S4519, $P4518
    iseq $I4520, $S4519, ""
    new $P4509, 'Integer'
    set $P4509, $I4520
  unless_4510_end:
    unless $P4509, if_4508_end
.annotate 'line', 1241
    find_lex $P4521, "$past"
    unless_null $P4521, vivify_1980
    new $P4521, "Undef"
  vivify_1980:
    find_lex $P4522, "$/"
    unless_null $P4522, vivify_1981
    $P4522 = root_new ['parrot';'Hash']
  vivify_1981:
    set $P4523, $P4522["name"]
    unless_null $P4523, vivify_1982
    $P4523 = root_new ['parrot';'Hash']
  vivify_1982:
    set $P4524, $P4523["identifier"]
    unless_null $P4524, vivify_1983
    new $P4524, "Undef"
  vivify_1983:
    $P4521."namespace"($P4524)
  if_4508_end:
.annotate 'line', 1245
    find_dynamic_lex $P4527, "$*PACKAGE-SETUP"
    unless_null $P4527, vivify_1984
    get_hll_global $P4525, "GLOBAL"
    get_who $P4526, $P4525
    set $P4527, $P4526["$PACKAGE-SETUP"]
    unless_null $P4527, vivify_1985
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1985:
  vivify_1984:
    get_hll_global $P4528, "GLOBAL"
    nqp_get_package_through_who $P4529, $P4528, "PAST"
    get_who $P4530, $P4529
    set $P4531, $P4530["Stmts"]
.annotate 'line', 1246
    get_hll_global $P4532, "GLOBAL"
    nqp_get_package_through_who $P4533, $P4532, "PAST"
    get_who $P4534, $P4533
    set $P4535, $P4534["Op"]
.annotate 'line', 1247
    get_hll_global $P4536, "GLOBAL"
    nqp_get_package_through_who $P4537, $P4536, "PAST"
    get_who $P4538, $P4537
    set $P4539, $P4538["Var"]
    $P4540 = $P4539."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1248
    find_dynamic_lex $P4543, "$*SC"
    unless_null $P4543, vivify_1986
    get_hll_global $P4541, "GLOBAL"
    get_who $P4542, $P4541
    set $P4543, $P4542["$SC"]
    unless_null $P4543, vivify_1987
    die "Contextual $*SC not found"
  vivify_1987:
  vivify_1986:
    find_dynamic_lex $P4546, "$*PACKAGE"
    unless_null $P4546, vivify_1988
    get_hll_global $P4544, "GLOBAL"
    get_who $P4545, $P4544
    set $P4546, $P4545["$PACKAGE"]
    unless_null $P4546, vivify_1989
    die "Contextual $*PACKAGE not found"
  vivify_1989:
  vivify_1988:
    $P4547 = $P4543."get_slot_past_for_object"($P4546)
    $P4548 = $P4535."new"($P4540, $P4547, "bind" :named("pasttype"))
.annotate 'line', 1246
    $P4549 = $P4531."new"($P4548)
.annotate 'line', 1245
    $P4527."unshift"($P4549)
.annotate 'line', 1257
    find_lex $P4553, "$how"
    unless_null $P4553, vivify_1990
    new $P4553, "Undef"
  vivify_1990:
    can $I4554, $P4553, "parametric"
    if $I4554, if_4552
    new $P4551, 'Integer'
    set $P4551, $I4554
    goto if_4552_end
  if_4552:
    find_lex $P4555, "$how"
    unless_null $P4555, vivify_1991
    new $P4555, "Undef"
  vivify_1991:
    find_lex $P4556, "$how"
    unless_null $P4556, vivify_1992
    new $P4556, "Undef"
  vivify_1992:
    $P4557 = $P4555."parametric"($P4556)
    set $P4551, $P4557
  if_4552_end:
    if $P4551, if_4550
.annotate 'line', 1275
    find_lex $P4609, "$past"
    unless_null $P4609, vivify_1993
    new $P4609, "Undef"
  vivify_1993:
    $P4609."blocktype"("immediate")
.annotate 'line', 1276
    find_dynamic_lex $P4612, "$*SC"
    unless_null $P4612, vivify_1994
    get_hll_global $P4610, "GLOBAL"
    get_who $P4611, $P4610
    set $P4612, $P4611["$SC"]
    unless_null $P4612, vivify_1995
    die "Contextual $*SC not found"
  vivify_1995:
  vivify_1994:
    find_lex $P4613, "$past"
    unless_null $P4613, vivify_1996
    new $P4613, "Undef"
  vivify_1996:
    find_dynamic_lex $P4616, "$*PACKAGE"
    unless_null $P4616, vivify_1997
    get_hll_global $P4614, "GLOBAL"
    get_who $P4615, $P4614
    set $P4616, $P4615["$PACKAGE"]
    unless_null $P4616, vivify_1998
    die "Contextual $*PACKAGE not found"
  vivify_1998:
  vivify_1997:
    $P4612."install_lexical_symbol"($P4613, "$?PACKAGE", $P4616)
.annotate 'line', 1277
    find_dynamic_lex $P4619, "$*SC"
    unless_null $P4619, vivify_1999
    get_hll_global $P4617, "GLOBAL"
    get_who $P4618, $P4617
    set $P4619, $P4618["$SC"]
    unless_null $P4619, vivify_2000
    die "Contextual $*SC not found"
  vivify_2000:
  vivify_1999:
    find_lex $P4620, "$past"
    unless_null $P4620, vivify_2001
    new $P4620, "Undef"
  vivify_2001:
    find_dynamic_lex $P4623, "$*PACKAGE"
    unless_null $P4623, vivify_2002
    get_hll_global $P4621, "GLOBAL"
    get_who $P4622, $P4621
    set $P4623, $P4622["$PACKAGE"]
    unless_null $P4623, vivify_2003
    die "Contextual $*PACKAGE not found"
  vivify_2003:
  vivify_2002:
    $P4619."install_lexical_symbol"($P4620, "$?CLASS", $P4623)
.annotate 'line', 1274
    goto if_4550_end
  if_4550:
.annotate 'line', 1258
    find_lex $P4558, "$past"
    unless_null $P4558, vivify_2004
    new $P4558, "Undef"
  vivify_2004:
    $P4558."blocktype"("declaration")
.annotate 'line', 1259
    find_lex $P4559, "$past"
    unless_null $P4559, vivify_2005
    new $P4559, "Undef"
  vivify_2005:
    get_hll_global $P4560, "GLOBAL"
    nqp_get_package_through_who $P4561, $P4560, "PAST"
    get_who $P4562, $P4561
    set $P4563, $P4562["Var"]
    $P4564 = $P4563."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4559."unshift"($P4564)
.annotate 'line', 1260
    find_lex $P4565, "$past"
    unless_null $P4565, vivify_2006
    new $P4565, "Undef"
  vivify_2006:
    $P4565."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1261
    find_dynamic_lex $P4568, "$*PACKAGE-SETUP"
    unless_null $P4568, vivify_2007
    get_hll_global $P4566, "GLOBAL"
    get_who $P4567, $P4566
    set $P4568, $P4567["$PACKAGE-SETUP"]
    unless_null $P4568, vivify_2008
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2008:
  vivify_2007:
    get_hll_global $P4569, "GLOBAL"
    nqp_get_package_through_who $P4570, $P4569, "PAST"
    get_who $P4571, $P4570
    set $P4572, $P4571["Op"]
.annotate 'line', 1263
    get_hll_global $P4573, "GLOBAL"
    nqp_get_package_through_who $P4574, $P4573, "PAST"
    get_who $P4575, $P4574
    set $P4576, $P4575["Op"]
.annotate 'line', 1266
    get_hll_global $P4577, "GLOBAL"
    nqp_get_package_through_who $P4578, $P4577, "PAST"
    get_who $P4579, $P4578
    set $P4580, $P4579["Var"]
    $P4581 = $P4580."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4582 = $P4576."new"($P4581, "get_how PP" :named("pirop"))
.annotate 'line', 1268
    get_hll_global $P4583, "GLOBAL"
    nqp_get_package_through_who $P4584, $P4583, "PAST"
    get_who $P4585, $P4584
    set $P4586, $P4585["Var"]
    $P4587 = $P4586."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1269
    get_hll_global $P4588, "GLOBAL"
    nqp_get_package_through_who $P4589, $P4588, "PAST"
    get_who $P4590, $P4589
    set $P4591, $P4590["Val"]
    find_lex $P4592, "$past"
    unless_null $P4592, vivify_2009
    new $P4592, "Undef"
  vivify_2009:
    $P4593 = $P4591."new"($P4592 :named("value"))
    $P4594 = $P4572."new"($P4582, $P4587, $P4593, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1261
    $P4568."push"($P4594)
.annotate 'line', 1271
    find_dynamic_lex $P4597, "$*SC"
    unless_null $P4597, vivify_2010
    get_hll_global $P4595, "GLOBAL"
    get_who $P4596, $P4595
    set $P4597, $P4596["$SC"]
    unless_null $P4597, vivify_2011
    die "Contextual $*SC not found"
  vivify_2011:
  vivify_2010:
    find_lex $P4598, "$past"
    unless_null $P4598, vivify_2012
    new $P4598, "Undef"
  vivify_2012:
    find_dynamic_lex $P4601, "$*PACKAGE"
    unless_null $P4601, vivify_2013
    get_hll_global $P4599, "GLOBAL"
    get_who $P4600, $P4599
    set $P4601, $P4600["$PACKAGE"]
    unless_null $P4601, vivify_2014
    die "Contextual $*PACKAGE not found"
  vivify_2014:
  vivify_2013:
    $P4597."install_lexical_symbol"($P4598, "$?PACKAGE", $P4601)
.annotate 'line', 1272
    find_dynamic_lex $P4604, "$*SC"
    unless_null $P4604, vivify_2015
    get_hll_global $P4602, "GLOBAL"
    get_who $P4603, $P4602
    set $P4604, $P4603["$SC"]
    unless_null $P4604, vivify_2016
    die "Contextual $*SC not found"
  vivify_2016:
  vivify_2015:
    find_lex $P4605, "$past"
    unless_null $P4605, vivify_2017
    new $P4605, "Undef"
  vivify_2017:
    find_dynamic_lex $P4608, "$*PACKAGE"
    unless_null $P4608, vivify_2018
    get_hll_global $P4606, "GLOBAL"
    get_who $P4607, $P4606
    set $P4608, $P4607["$PACKAGE"]
    unless_null $P4608, vivify_2019
    die "Contextual $*PACKAGE not found"
  vivify_2019:
  vivify_2018:
    $P4604."install_lexical_symbol"($P4605, "$?ROLE", $P4608)
  if_4550_end:
.annotate 'line', 1282
    find_lex $P4625, "$/"
    unless_null $P4625, vivify_2020
    $P4625 = root_new ['parrot';'Hash']
  vivify_2020:
    set $P4626, $P4625["parent"]
    unless_null $P4626, vivify_2021
    new $P4626, "Undef"
  vivify_2021:
    if $P4626, if_4624
.annotate 'line', 1296
    find_lex $P4673, "$how"
    unless_null $P4673, vivify_2022
    new $P4673, "Undef"
  vivify_2022:
    can $I4674, $P4673, "set_default_parent"
    unless $I4674, if_4672_end
.annotate 'line', 1298
    find_dynamic_lex $P4677, "$*PACKAGE-SETUP"
    unless_null $P4677, vivify_2023
    get_hll_global $P4675, "GLOBAL"
    get_who $P4676, $P4675
    set $P4677, $P4676["$PACKAGE-SETUP"]
    unless_null $P4677, vivify_2024
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2024:
  vivify_2023:
    get_hll_global $P4678, "GLOBAL"
    nqp_get_package_through_who $P4679, $P4678, "PAST"
    get_who $P4680, $P4679
    set $P4681, $P4680["Op"]
.annotate 'line', 1300
    get_hll_global $P4682, "GLOBAL"
    nqp_get_package_through_who $P4683, $P4682, "PAST"
    get_who $P4684, $P4683
    set $P4685, $P4684["Op"]
.annotate 'line', 1303
    get_hll_global $P4686, "GLOBAL"
    nqp_get_package_through_who $P4687, $P4686, "PAST"
    get_who $P4688, $P4687
    set $P4689, $P4688["Var"]
    $P4690 = $P4689."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4691 = $P4685."new"($P4690, "get_how PP" :named("pirop"))
.annotate 'line', 1305
    get_hll_global $P4692, "GLOBAL"
    nqp_get_package_through_who $P4693, $P4692, "PAST"
    get_who $P4694, $P4693
    set $P4695, $P4694["Var"]
    $P4696 = $P4695."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1306
    find_dynamic_lex $P4701, "$*PKGDECL"
    unless_null $P4701, vivify_2025
    get_hll_global $P4699, "GLOBAL"
    get_who $P4700, $P4699
    set $P4701, $P4700["$PKGDECL"]
    unless_null $P4701, vivify_2026
    die "Contextual $*PKGDECL not found"
  vivify_2026:
  vivify_2025:
    set $S4702, $P4701
    iseq $I4703, $S4702, "grammar"
    if $I4703, if_4698
.annotate 'line', 1308
    find_dynamic_lex $P4711, "$*SC"
    unless_null $P4711, vivify_2027
    get_hll_global $P4709, "GLOBAL"
    get_who $P4710, $P4709
    set $P4711, $P4710["$SC"]
    unless_null $P4711, vivify_2028
    die "Contextual $*SC not found"
  vivify_2028:
  vivify_2027:
    new $P4712, "ResizablePMCArray"
    push $P4712, "NQPMu"
    find_lex $P4713, "$/"
    unless_null $P4713, vivify_2029
    new $P4713, "Undef"
  vivify_2029:
    $P4714 = "find_sym"($P4712, $P4713)
    $P4715 = $P4711."get_object_sc_ref_past"($P4714)
    set $P4697, $P4715
.annotate 'line', 1306
    goto if_4698_end
  if_4698:
.annotate 'line', 1307
    get_hll_global $P4704, "GLOBAL"
    nqp_get_package_through_who $P4705, $P4704, "PAST"
    get_who $P4706, $P4705
    set $P4707, $P4706["Var"]
    $P4708 = $P4707."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    set $P4697, $P4708
  if_4698_end:
.annotate 'line', 1306
    $P4716 = $P4681."new"($P4691, $P4696, $P4697, "callmethod" :named("pasttype"), "set_default_parent" :named("name"))
.annotate 'line', 1298
    $P4677."push"($P4716)
  if_4672_end:
.annotate 'line', 1296
    goto if_4624_end
  if_4624:
.annotate 'line', 1282
    .const 'Sub' $P4628 = "487_1303739803.72" 
    capture_lex $P4628
    $P4628()
  if_4624_end:
.annotate 'line', 1313
    find_lex $P4718, "$/"
    unless_null $P4718, vivify_2039
    $P4718 = root_new ['parrot';'Hash']
  vivify_2039:
    set $P4719, $P4718["role"]
    unless_null $P4719, vivify_2040
    new $P4719, "Undef"
  vivify_2040:
    unless $P4719, if_4717_end
.annotate 'line', 1314
    find_lex $P4721, "$/"
    unless_null $P4721, vivify_2041
    $P4721 = root_new ['parrot';'Hash']
  vivify_2041:
    set $P4722, $P4721["role"]
    unless_null $P4722, vivify_2042
    new $P4722, "Undef"
  vivify_2042:
    defined $I4723, $P4722
    unless $I4723, for_undef_2043
    iter $P4720, $P4722
    new $P4770, 'ExceptionHandler'
    set_label $P4770, loop4769_handler
    $P4770."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4770
  loop4769_test:
    unless $P4720, loop4769_done
    shift $P4724, $P4720
  loop4769_redo:
    .const 'Sub' $P4726 = "488_1303739803.72" 
    capture_lex $P4726
    $P4726($P4724)
  loop4769_next:
    goto loop4769_test
  loop4769_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4771, exception, 'type'
    eq $P4771, .CONTROL_LOOP_NEXT, loop4769_next
    eq $P4771, .CONTROL_LOOP_REDO, loop4769_redo
  loop4769_done:
    pop_eh 
  for_undef_2043:
  if_4717_end:
.annotate 'line', 1331
    find_dynamic_lex $P4774, "$*PACKAGE-SETUP"
    unless_null $P4774, vivify_2051
    get_hll_global $P4772, "GLOBAL"
    get_who $P4773, $P4772
    set $P4774, $P4773["$PACKAGE-SETUP"]
    unless_null $P4774, vivify_2052
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2052:
  vivify_2051:
    get_hll_global $P4775, "GLOBAL"
    nqp_get_package_through_who $P4776, $P4775, "PAST"
    get_who $P4777, $P4776
    set $P4778, $P4777["Op"]
.annotate 'line', 1333
    get_hll_global $P4779, "GLOBAL"
    nqp_get_package_through_who $P4780, $P4779, "PAST"
    get_who $P4781, $P4780
    set $P4782, $P4781["Op"]
.annotate 'line', 1336
    get_hll_global $P4783, "GLOBAL"
    nqp_get_package_through_who $P4784, $P4783, "PAST"
    get_who $P4785, $P4784
    set $P4786, $P4785["Var"]
    $P4787 = $P4786."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4788 = $P4782."new"($P4787, "get_how PP" :named("pirop"))
.annotate 'line', 1338
    get_hll_global $P4789, "GLOBAL"
    nqp_get_package_through_who $P4790, $P4789, "PAST"
    get_who $P4791, $P4790
    set $P4792, $P4791["Var"]
    $P4793 = $P4792."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4794 = $P4778."new"($P4788, $P4793, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1331
    $P4774."push"($P4794)
.annotate 'line', 1342
    find_lex $P4795, "$past"
    unless_null $P4795, vivify_2053
    new $P4795, "Undef"
  vivify_2053:
    $P4796 = $P4795."loadinit"()
    get_hll_global $P4797, "GLOBAL"
    nqp_get_package_through_who $P4798, $P4797, "PAST"
    get_who $P4799, $P4798
    set $P4800, $P4799["Block"]
    find_dynamic_lex $P4803, "$*PACKAGE-SETUP"
    unless_null $P4803, vivify_2054
    get_hll_global $P4801, "GLOBAL"
    get_who $P4802, $P4801
    set $P4803, $P4802["$PACKAGE-SETUP"]
    unless_null $P4803, vivify_2055
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2055:
  vivify_2054:
    $P4804 = $P4800."new"($P4803, "immediate" :named("blocktype"))
    $P4796."push"($P4804)
.annotate 'line', 1344
    find_lex $P4805, "$/"
    find_lex $P4806, "$past"
    unless_null $P4806, vivify_2056
    new $P4806, "Undef"
  vivify_2056:
    $P4807 = $P4805."!make"($P4806)
.annotate 'line', 1232
    .return ($P4807)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4627"  :anon :subid("487_1303739803.72") :outer("486_1303739803.72")
.annotate 'line', 1283
    $P4629 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4629
.annotate 'line', 1284
    new $P4630, "Undef"
    .lex "$name", $P4630
.annotate 'line', 1283
    find_lex $P4631, "$/"
    unless_null $P4631, vivify_2030
    $P4631 = root_new ['parrot';'Hash']
  vivify_2030:
    set $P4632, $P4631["parent"]
    unless_null $P4632, vivify_2031
    $P4632 = root_new ['parrot';'ResizablePMCArray']
  vivify_2031:
    set $P4633, $P4632[0]
    unless_null $P4633, vivify_2032
    $P4633 = root_new ['parrot';'Hash']
  vivify_2032:
    set $P4634, $P4633["identifier"]
    unless_null $P4634, vivify_2033
    new $P4634, "Undef"
  vivify_2033:
    clone $P4635, $P4634
    store_lex "@ns", $P4635
.annotate 'line', 1284
    find_lex $P4636, "@ns"
    unless_null $P4636, vivify_2034
    $P4636 = root_new ['parrot';'ResizablePMCArray']
  vivify_2034:
    $P4637 = $P4636."pop"()
    set $S4638, $P4637
    new $P4639, 'String'
    set $P4639, $S4638
    store_lex "$name", $P4639
.annotate 'line', 1285
    find_dynamic_lex $P4642, "$*PACKAGE-SETUP"
    unless_null $P4642, vivify_2035
    get_hll_global $P4640, "GLOBAL"
    get_who $P4641, $P4640
    set $P4642, $P4641["$PACKAGE-SETUP"]
    unless_null $P4642, vivify_2036
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2036:
  vivify_2035:
    get_hll_global $P4643, "GLOBAL"
    nqp_get_package_through_who $P4644, $P4643, "PAST"
    get_who $P4645, $P4644
    set $P4646, $P4645["Op"]
.annotate 'line', 1287
    get_hll_global $P4647, "GLOBAL"
    nqp_get_package_through_who $P4648, $P4647, "PAST"
    get_who $P4649, $P4648
    set $P4650, $P4649["Op"]
.annotate 'line', 1290
    get_hll_global $P4651, "GLOBAL"
    nqp_get_package_through_who $P4652, $P4651, "PAST"
    get_who $P4653, $P4652
    set $P4654, $P4653["Var"]
    $P4655 = $P4654."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4656 = $P4650."new"($P4655, "get_how PP" :named("pirop"))
.annotate 'line', 1292
    get_hll_global $P4657, "GLOBAL"
    nqp_get_package_through_who $P4658, $P4657, "PAST"
    get_who $P4659, $P4658
    set $P4660, $P4659["Var"]
    $P4661 = $P4660."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1293
    get_hll_global $P4662, "GLOBAL"
    nqp_get_package_through_who $P4663, $P4662, "PAST"
    get_who $P4664, $P4663
    set $P4665, $P4664["Var"]
    find_lex $P4666, "$name"
    unless_null $P4666, vivify_2037
    new $P4666, "Undef"
  vivify_2037:
    set $S4667, $P4666
    find_lex $P4668, "@ns"
    unless_null $P4668, vivify_2038
    $P4668 = root_new ['parrot';'ResizablePMCArray']
  vivify_2038:
    $P4669 = $P4665."new"($S4667 :named("name"), $P4668 :named("namespace"), "package" :named("scope"))
    $P4670 = $P4646."new"($P4656, $P4661, $P4669, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1285
    $P4671 = $P4642."push"($P4670)
.annotate 'line', 1282
    .return ($P4671)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4725"  :anon :subid("488_1303739803.72") :outer("486_1303739803.72")
    .param pmc param_4729
.annotate 'line', 1315
    $P4727 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4727
.annotate 'line', 1316
    new $P4728, "Undef"
    .lex "$name", $P4728
    .lex "$_", param_4729
.annotate 'line', 1315
    find_lex $P4730, "$_"
    unless_null $P4730, vivify_2044
    $P4730 = root_new ['parrot';'Hash']
  vivify_2044:
    set $P4731, $P4730["identifier"]
    unless_null $P4731, vivify_2045
    new $P4731, "Undef"
  vivify_2045:
    clone $P4732, $P4731
    store_lex "@ns", $P4732
.annotate 'line', 1316
    find_lex $P4733, "@ns"
    unless_null $P4733, vivify_2046
    $P4733 = root_new ['parrot';'ResizablePMCArray']
  vivify_2046:
    $P4734 = $P4733."pop"()
    set $S4735, $P4734
    new $P4736, 'String'
    set $P4736, $S4735
    store_lex "$name", $P4736
.annotate 'line', 1317
    find_dynamic_lex $P4739, "$*PACKAGE-SETUP"
    unless_null $P4739, vivify_2047
    get_hll_global $P4737, "GLOBAL"
    get_who $P4738, $P4737
    set $P4739, $P4738["$PACKAGE-SETUP"]
    unless_null $P4739, vivify_2048
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2048:
  vivify_2047:
    get_hll_global $P4740, "GLOBAL"
    nqp_get_package_through_who $P4741, $P4740, "PAST"
    get_who $P4742, $P4741
    set $P4743, $P4742["Op"]
.annotate 'line', 1319
    get_hll_global $P4744, "GLOBAL"
    nqp_get_package_through_who $P4745, $P4744, "PAST"
    get_who $P4746, $P4745
    set $P4747, $P4746["Op"]
.annotate 'line', 1322
    get_hll_global $P4748, "GLOBAL"
    nqp_get_package_through_who $P4749, $P4748, "PAST"
    get_who $P4750, $P4749
    set $P4751, $P4750["Var"]
    $P4752 = $P4751."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4753 = $P4747."new"($P4752, "get_how PP" :named("pirop"))
.annotate 'line', 1324
    get_hll_global $P4754, "GLOBAL"
    nqp_get_package_through_who $P4755, $P4754, "PAST"
    get_who $P4756, $P4755
    set $P4757, $P4756["Var"]
    $P4758 = $P4757."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1325
    get_hll_global $P4759, "GLOBAL"
    nqp_get_package_through_who $P4760, $P4759, "PAST"
    get_who $P4761, $P4760
    set $P4762, $P4761["Var"]
    find_lex $P4763, "$name"
    unless_null $P4763, vivify_2049
    new $P4763, "Undef"
  vivify_2049:
    set $S4764, $P4763
    find_lex $P4765, "@ns"
    unless_null $P4765, vivify_2050
    $P4765 = root_new ['parrot';'ResizablePMCArray']
  vivify_2050:
    $P4766 = $P4762."new"($S4764 :named("name"), $P4765 :named("namespace"), "package" :named("scope"))
    $P4767 = $P4743."new"($P4753, $P4758, $P4766, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1317
    $P4768 = $P4739."push"($P4767)
.annotate 'line', 1314
    .return ($P4768)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("489_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4809
    .param pmc param_4810
.annotate 'line', 1347
    .lex "self", param_4809
    .lex "$/", param_4810
    find_lex $P4811, "$/"
    find_lex $P4812, "$/"
    unless_null $P4812, vivify_2057
    $P4812 = root_new ['parrot';'Hash']
  vivify_2057:
    set $P4813, $P4812["scoped"]
    unless_null $P4813, vivify_2058
    new $P4813, "Undef"
  vivify_2058:
    $P4814 = $P4813."ast"()
    $P4815 = $P4811."!make"($P4814)
    .return ($P4815)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("490_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4817
    .param pmc param_4818
.annotate 'line', 1348
    .lex "self", param_4817
    .lex "$/", param_4818
    find_lex $P4819, "$/"
    find_lex $P4820, "$/"
    unless_null $P4820, vivify_2059
    $P4820 = root_new ['parrot';'Hash']
  vivify_2059:
    set $P4821, $P4820["scoped"]
    unless_null $P4821, vivify_2060
    new $P4821, "Undef"
  vivify_2060:
    $P4822 = $P4821."ast"()
    $P4823 = $P4819."!make"($P4822)
    .return ($P4823)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("491_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4825
    .param pmc param_4826
.annotate 'line', 1349
    .lex "self", param_4825
    .lex "$/", param_4826
    find_lex $P4827, "$/"
    find_lex $P4828, "$/"
    unless_null $P4828, vivify_2061
    $P4828 = root_new ['parrot';'Hash']
  vivify_2061:
    set $P4829, $P4828["scoped"]
    unless_null $P4829, vivify_2062
    new $P4829, "Undef"
  vivify_2062:
    $P4830 = $P4829."ast"()
    $P4831 = $P4827."!make"($P4830)
    .return ($P4831)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("492_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4833
    .param pmc param_4834
.annotate 'line', 1351
    .lex "self", param_4833
    .lex "$/", param_4834
.annotate 'line', 1352
    find_lex $P4835, "$/"
    find_lex $P4838, "$/"
    unless_null $P4838, vivify_2063
    $P4838 = root_new ['parrot';'Hash']
  vivify_2063:
    set $P4839, $P4838["declarator"]
    unless_null $P4839, vivify_2064
    new $P4839, "Undef"
  vivify_2064:
    if $P4839, if_4837
.annotate 'line', 1353
    find_lex $P4845, "$/"
    unless_null $P4845, vivify_2065
    $P4845 = root_new ['parrot';'Hash']
  vivify_2065:
    set $P4846, $P4845["multi_declarator"]
    unless_null $P4846, vivify_2066
    new $P4846, "Undef"
  vivify_2066:
    if $P4846, if_4844
.annotate 'line', 1354
    find_lex $P4850, "$/"
    unless_null $P4850, vivify_2067
    $P4850 = root_new ['parrot';'Hash']
  vivify_2067:
    set $P4851, $P4850["package_declarator"]
    unless_null $P4851, vivify_2068
    new $P4851, "Undef"
  vivify_2068:
    $P4852 = $P4851."ast"()
    set $P4843, $P4852
.annotate 'line', 1353
    goto if_4844_end
  if_4844:
    find_lex $P4847, "$/"
    unless_null $P4847, vivify_2069
    $P4847 = root_new ['parrot';'Hash']
  vivify_2069:
    set $P4848, $P4847["multi_declarator"]
    unless_null $P4848, vivify_2070
    new $P4848, "Undef"
  vivify_2070:
    $P4849 = $P4848."ast"()
    set $P4843, $P4849
  if_4844_end:
    set $P4836, $P4843
.annotate 'line', 1352
    goto if_4837_end
  if_4837:
    find_lex $P4840, "$/"
    unless_null $P4840, vivify_2071
    $P4840 = root_new ['parrot';'Hash']
  vivify_2071:
    set $P4841, $P4840["declarator"]
    unless_null $P4841, vivify_2072
    new $P4841, "Undef"
  vivify_2072:
    $P4842 = $P4841."ast"()
    set $P4836, $P4842
  if_4837_end:
    $P4853 = $P4835."!make"($P4836)
.annotate 'line', 1351
    .return ($P4853)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("493_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4855
    .param pmc param_4856
.annotate 'line', 1357
    .lex "self", param_4855
    .lex "$/", param_4856
.annotate 'line', 1358
    find_lex $P4857, "$/"
.annotate 'line', 1359
    find_lex $P4860, "$/"
    unless_null $P4860, vivify_2073
    $P4860 = root_new ['parrot';'Hash']
  vivify_2073:
    set $P4861, $P4860["routine_declarator"]
    unless_null $P4861, vivify_2074
    new $P4861, "Undef"
  vivify_2074:
    if $P4861, if_4859
.annotate 'line', 1360
    find_lex $P4865, "$/"
    unless_null $P4865, vivify_2075
    $P4865 = root_new ['parrot';'Hash']
  vivify_2075:
    set $P4866, $P4865["variable_declarator"]
    unless_null $P4866, vivify_2076
    new $P4866, "Undef"
  vivify_2076:
    $P4867 = $P4866."ast"()
    set $P4858, $P4867
.annotate 'line', 1359
    goto if_4859_end
  if_4859:
    find_lex $P4862, "$/"
    unless_null $P4862, vivify_2077
    $P4862 = root_new ['parrot';'Hash']
  vivify_2077:
    set $P4863, $P4862["routine_declarator"]
    unless_null $P4863, vivify_2078
    new $P4863, "Undef"
  vivify_2078:
    $P4864 = $P4863."ast"()
    set $P4858, $P4864
  if_4859_end:
    $P4868 = $P4857."!make"($P4858)
.annotate 'line', 1357
    .return ($P4868)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("494_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4870
    .param pmc param_4871
.annotate 'line', 1363
    .lex "self", param_4870
    .lex "$/", param_4871
    find_lex $P4872, "$/"
    find_lex $P4875, "$/"
    unless_null $P4875, vivify_2079
    $P4875 = root_new ['parrot';'Hash']
  vivify_2079:
    set $P4876, $P4875["declarator"]
    unless_null $P4876, vivify_2080
    new $P4876, "Undef"
  vivify_2080:
    if $P4876, if_4874
    find_lex $P4880, "$/"
    unless_null $P4880, vivify_2081
    $P4880 = root_new ['parrot';'Hash']
  vivify_2081:
    set $P4881, $P4880["routine_def"]
    unless_null $P4881, vivify_2082
    new $P4881, "Undef"
  vivify_2082:
    $P4882 = $P4881."ast"()
    set $P4873, $P4882
    goto if_4874_end
  if_4874:
    find_lex $P4877, "$/"
    unless_null $P4877, vivify_2083
    $P4877 = root_new ['parrot';'Hash']
  vivify_2083:
    set $P4878, $P4877["declarator"]
    unless_null $P4878, vivify_2084
    new $P4878, "Undef"
  vivify_2084:
    $P4879 = $P4878."ast"()
    set $P4873, $P4879
  if_4874_end:
    $P4883 = $P4872."!make"($P4873)
    .return ($P4883)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("495_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4885
    .param pmc param_4886
.annotate 'line', 1364
    .lex "self", param_4885
    .lex "$/", param_4886
    find_lex $P4887, "$/"
    find_lex $P4890, "$/"
    unless_null $P4890, vivify_2085
    $P4890 = root_new ['parrot';'Hash']
  vivify_2085:
    set $P4891, $P4890["declarator"]
    unless_null $P4891, vivify_2086
    new $P4891, "Undef"
  vivify_2086:
    if $P4891, if_4889
    find_lex $P4895, "$/"
    unless_null $P4895, vivify_2087
    $P4895 = root_new ['parrot';'Hash']
  vivify_2087:
    set $P4896, $P4895["routine_def"]
    unless_null $P4896, vivify_2088
    new $P4896, "Undef"
  vivify_2088:
    $P4897 = $P4896."ast"()
    set $P4888, $P4897
    goto if_4889_end
  if_4889:
    find_lex $P4892, "$/"
    unless_null $P4892, vivify_2089
    $P4892 = root_new ['parrot';'Hash']
  vivify_2089:
    set $P4893, $P4892["declarator"]
    unless_null $P4893, vivify_2090
    new $P4893, "Undef"
  vivify_2090:
    $P4894 = $P4893."ast"()
    set $P4888, $P4894
  if_4889_end:
    $P4898 = $P4887."!make"($P4888)
    .return ($P4898)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("496_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4900
    .param pmc param_4901
.annotate 'line', 1365
    .lex "self", param_4900
    .lex "$/", param_4901
    find_lex $P4902, "$/"
    find_lex $P4903, "$/"
    unless_null $P4903, vivify_2091
    $P4903 = root_new ['parrot';'Hash']
  vivify_2091:
    set $P4904, $P4903["declarator"]
    unless_null $P4904, vivify_2092
    new $P4904, "Undef"
  vivify_2092:
    $P4905 = $P4904."ast"()
    $P4906 = $P4902."!make"($P4905)
    .return ($P4906)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("497_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_4908
    .param pmc param_4909
.annotate 'line', 1368
    .const 'Sub' $P4943 = "498_1303739803.72" 
    capture_lex $P4943
    .lex "self", param_4908
    .lex "$/", param_4909
.annotate 'line', 1369
    new $P4910, "Undef"
    .lex "$past", $P4910
.annotate 'line', 1370
    new $P4911, "Undef"
    .lex "$sigil", $P4911
.annotate 'line', 1371
    new $P4912, "Undef"
    .lex "$name", $P4912
.annotate 'line', 1372
    new $P4913, "Undef"
    .lex "$BLOCK", $P4913
.annotate 'line', 1369
    find_lex $P4914, "$/"
    unless_null $P4914, vivify_2093
    $P4914 = root_new ['parrot';'Hash']
  vivify_2093:
    set $P4915, $P4914["variable"]
    unless_null $P4915, vivify_2094
    new $P4915, "Undef"
  vivify_2094:
    $P4916 = $P4915."ast"()
    store_lex "$past", $P4916
.annotate 'line', 1370
    find_lex $P4917, "$/"
    unless_null $P4917, vivify_2095
    $P4917 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P4918, $P4917["variable"]
    unless_null $P4918, vivify_2096
    $P4918 = root_new ['parrot';'Hash']
  vivify_2096:
    set $P4919, $P4918["sigil"]
    unless_null $P4919, vivify_2097
    new $P4919, "Undef"
  vivify_2097:
    store_lex "$sigil", $P4919
.annotate 'line', 1371
    find_lex $P4920, "$past"
    unless_null $P4920, vivify_2098
    new $P4920, "Undef"
  vivify_2098:
    $P4921 = $P4920."name"()
    store_lex "$name", $P4921
.annotate 'line', 1372
    find_lex $P4922, "$?PACKAGE"
    get_who $P4923, $P4922
    set $P4924, $P4923["@BLOCK"]
    unless_null $P4924, vivify_2099
    $P4924 = root_new ['parrot';'ResizablePMCArray']
  vivify_2099:
    set $P4925, $P4924[0]
    unless_null $P4925, vivify_2100
    new $P4925, "Undef"
  vivify_2100:
    store_lex "$BLOCK", $P4925
.annotate 'line', 1373
    find_lex $P4929, "$name"
    unless_null $P4929, vivify_2101
    new $P4929, "Undef"
  vivify_2101:
    if $P4929, if_4928
    set $P4927, $P4929
    goto if_4928_end
  if_4928:
    find_lex $P4930, "$BLOCK"
    unless_null $P4930, vivify_2102
    new $P4930, "Undef"
  vivify_2102:
    find_lex $P4931, "$name"
    unless_null $P4931, vivify_2103
    new $P4931, "Undef"
  vivify_2103:
    $P4932 = $P4930."symbol"($P4931)
    set $P4927, $P4932
  if_4928_end:
    unless $P4927, if_4926_end
.annotate 'line', 1374
    find_lex $P4933, "$/"
    unless_null $P4933, vivify_2104
    new $P4933, "Undef"
  vivify_2104:
    $P4934 = $P4933."CURSOR"()
    find_lex $P4935, "$name"
    unless_null $P4935, vivify_2105
    new $P4935, "Undef"
  vivify_2105:
    $P4934."panic"("Redeclaration of symbol ", $P4935)
  if_4926_end:
.annotate 'line', 1376
    find_dynamic_lex $P4939, "$*SCOPE"
    unless_null $P4939, vivify_2106
    get_hll_global $P4937, "GLOBAL"
    get_who $P4938, $P4937
    set $P4939, $P4938["$SCOPE"]
    unless_null $P4939, vivify_2107
    die "Contextual $*SCOPE not found"
  vivify_2107:
  vivify_2106:
    set $S4940, $P4939
    iseq $I4941, $S4940, "has"
    if $I4941, if_4936
.annotate 'line', 1401
    find_dynamic_lex $P5022, "$*SCOPE"
    unless_null $P5022, vivify_2108
    get_hll_global $P5020, "GLOBAL"
    get_who $P5021, $P5020
    set $P5022, $P5021["$SCOPE"]
    unless_null $P5022, vivify_2109
    die "Contextual $*SCOPE not found"
  vivify_2109:
  vivify_2108:
    set $S5023, $P5022
    iseq $I5024, $S5023, "our"
    if $I5024, if_5019
.annotate 'line', 1411
    find_lex $P5038, "$BLOCK"
    unless_null $P5038, vivify_2110
    $P5038 = root_new ['parrot';'ResizablePMCArray']
  vivify_2110:
    set $P5039, $P5038[0]
    unless_null $P5039, vivify_2111
    new $P5039, "Undef"
  vivify_2111:
    get_hll_global $P5040, "GLOBAL"
    nqp_get_package_through_who $P5041, $P5040, "PAST"
    get_who $P5042, $P5041
    set $P5043, $P5042["Var"]
    find_lex $P5044, "$name"
    unless_null $P5044, vivify_2112
    new $P5044, "Undef"
  vivify_2112:
.annotate 'line', 1413
    find_lex $P5045, "$sigil"
    unless_null $P5045, vivify_2113
    new $P5045, "Undef"
  vivify_2113:
    $P5046 = "vivitype"($P5045)
    find_lex $P5047, "$/"
    unless_null $P5047, vivify_2114
    new $P5047, "Undef"
  vivify_2114:
    $P5048 = $P5043."new"($P5044 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P5046 :named("viviself"), $P5047 :named("node"))
.annotate 'line', 1411
    $P5039."push"($P5048)
.annotate 'line', 1416
    find_lex $P5049, "$BLOCK"
    unless_null $P5049, vivify_2115
    new $P5049, "Undef"
  vivify_2115:
    find_lex $P5050, "$name"
    unless_null $P5050, vivify_2116
    new $P5050, "Undef"
  vivify_2116:
    $P5049."symbol"($P5050, "lexical" :named("scope"))
.annotate 'line', 1410
    goto if_5019_end
  if_5019:
.annotate 'line', 1405
    find_lex $P5025, "$/"
    unless_null $P5025, vivify_2117
    $P5025 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P5026, $P5025["variable"]
    unless_null $P5026, vivify_2118
    new $P5026, "Undef"
  vivify_2118:
    set $S5027, $P5026
    new $P5028, 'String'
    set $P5028, $S5027
    store_lex "$name", $P5028
.annotate 'line', 1406
    find_lex $P5029, "$name"
    unless_null $P5029, vivify_2119
    new $P5029, "Undef"
  vivify_2119:
    new $P5030, "ResizablePMCArray"
    push $P5030, $P5029
    find_lex $P5031, "$/"
    unless_null $P5031, vivify_2120
    new $P5031, "Undef"
  vivify_2120:
    $P5032 = "lexical_package_lookup"($P5030, $P5031)
    store_lex "$past", $P5032
.annotate 'line', 1407
    find_lex $P5033, "$past"
    unless_null $P5033, vivify_2121
    new $P5033, "Undef"
  vivify_2121:
    find_lex $P5034, "$sigil"
    unless_null $P5034, vivify_2122
    new $P5034, "Undef"
  vivify_2122:
    $P5035 = "vivitype"($P5034)
    $P5033."viviself"($P5035)
.annotate 'line', 1408
    find_lex $P5036, "$BLOCK"
    unless_null $P5036, vivify_2123
    new $P5036, "Undef"
  vivify_2123:
    find_lex $P5037, "$name"
    unless_null $P5037, vivify_2124
    new $P5037, "Undef"
  vivify_2124:
    $P5036."symbol"($P5037, "package" :named("scope"))
  if_5019_end:
.annotate 'line', 1401
    goto if_4936_end
  if_4936:
.annotate 'line', 1376
    .const 'Sub' $P4943 = "498_1303739803.72" 
    capture_lex $P4943
    $P4943()
  if_4936_end:
.annotate 'line', 1418
    find_lex $P5051, "$/"
    find_lex $P5052, "$past"
    unless_null $P5052, vivify_2146
    new $P5052, "Undef"
  vivify_2146:
    $P5053 = $P5051."!make"($P5052)
.annotate 'line', 1368
    .return ($P5053)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4942"  :anon :subid("498_1303739803.72") :outer("497_1303739803.72")
.annotate 'line', 1376
    .const 'Sub' $P5002 = "499_1303739803.72" 
    capture_lex $P5002
.annotate 'line', 1378
    new $P4944, "Undef"
    .lex "$meta-attr-type", $P4944
.annotate 'line', 1386
    new $P4945, "Undef"
    .lex "$meta_args", $P4945
.annotate 'line', 1378
    find_dynamic_lex $P4950, "$*PKGDECL"
    unless_null $P4950, vivify_2125
    get_hll_global $P4948, "GLOBAL"
    get_who $P4949, $P4948
    set $P4950, $P4949["$PKGDECL"]
    unless_null $P4950, vivify_2126
    die "Contextual $*PKGDECL not found"
  vivify_2126:
  vivify_2125:
    find_dynamic_lex $P4953, "%*HOW-METAATTR"
    unless_null $P4953, vivify_2127
    get_hll_global $P4951, "GLOBAL"
    get_who $P4952, $P4951
    set $P4953, $P4952["%HOW-METAATTR"]
    unless_null $P4953, vivify_2128
    die "Contextual %*HOW-METAATTR not found"
  vivify_2128:
  vivify_2127:
    set $P4954, $P4953[$P4950]
    unless_null $P4954, vivify_2129
    new $P4954, "Undef"
  vivify_2129:
    unless $P4954, unless_4947
    set $P4946, $P4954
    goto unless_4947_end
  unless_4947:
    find_dynamic_lex $P4957, "$*DEFAULT-METAATTR"
    unless_null $P4957, vivify_2130
    get_hll_global $P4955, "GLOBAL"
    get_who $P4956, $P4955
    set $P4957, $P4956["$DEFAULT-METAATTR"]
    unless_null $P4957, vivify_2131
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_2131:
  vivify_2130:
    set $P4946, $P4957
  unless_4947_end:
    store_lex "$meta-attr-type", $P4946
.annotate 'line', 1379
    find_dynamic_lex $P4960, "$*PACKAGE-SETUP"
    unless_null $P4960, vivify_2132
    get_hll_global $P4958, "GLOBAL"
    get_who $P4959, $P4958
    set $P4960, $P4959["$PACKAGE-SETUP"]
    unless_null $P4960, vivify_2133
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2133:
  vivify_2132:
    get_hll_global $P4961, "GLOBAL"
    nqp_get_package_through_who $P4962, $P4961, "PAST"
    get_who $P4963, $P4962
    set $P4964, $P4963["Op"]
.annotate 'line', 1381
    get_hll_global $P4965, "GLOBAL"
    nqp_get_package_through_who $P4966, $P4965, "PAST"
    get_who $P4967, $P4966
    set $P4968, $P4967["Op"]
.annotate 'line', 1383
    get_hll_global $P4969, "GLOBAL"
    nqp_get_package_through_who $P4970, $P4969, "PAST"
    get_who $P4971, $P4970
    set $P4972, $P4971["Var"]
    $P4973 = $P4972."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4974 = $P4968."new"($P4973, "get_how PP" :named("pirop"))
.annotate 'line', 1385
    get_hll_global $P4975, "GLOBAL"
    nqp_get_package_through_who $P4976, $P4975, "PAST"
    get_who $P4977, $P4976
    set $P4978, $P4977["Var"]
    $P4979 = $P4978."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1386
    get_hll_global $P4980, "GLOBAL"
    nqp_get_package_through_who $P4981, $P4980, "PAST"
    get_who $P4982, $P4981
    set $P4983, $P4982["Op"]
.annotate 'line', 1388
    get_hll_global $P4984, "GLOBAL"
    nqp_get_package_through_who $P4985, $P4984, "PAST"
    get_who $P4986, $P4985
    set $P4987, $P4986["Var"]
    find_lex $P4988, "$meta-attr-type"
    unless_null $P4988, vivify_2134
    new $P4988, "Undef"
  vivify_2134:
    $P4989 = $P4987."new"($P4988 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1389
    get_hll_global $P4990, "GLOBAL"
    nqp_get_package_through_who $P4991, $P4990, "PAST"
    get_who $P4992, $P4991
    set $P4993, $P4992["Val"]
    find_lex $P4994, "$name"
    unless_null $P4994, vivify_2135
    new $P4994, "Undef"
  vivify_2135:
    $P4995 = $P4993."new"($P4994 :named("value"), "name" :named("named"))
    $P4996 = $P4983."new"($P4989, $P4995, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1386
    store_lex "$meta_args", $P4996
    $P4997 = $P4964."new"($P4974, $P4979, $P4996, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1379
    $P4960."push"($P4997)
.annotate 'line', 1392
    find_lex $P4999, "$/"
    unless_null $P4999, vivify_2136
    $P4999 = root_new ['parrot';'Hash']
  vivify_2136:
    set $P5000, $P4999["typename"]
    unless_null $P5000, vivify_2137
    new $P5000, "Undef"
  vivify_2137:
    unless $P5000, if_4998_end
    .const 'Sub' $P5002 = "499_1303739803.72" 
    capture_lex $P5002
    $P5002()
  if_4998_end:
.annotate 'line', 1398
    find_lex $P5012, "$BLOCK"
    unless_null $P5012, vivify_2144
    new $P5012, "Undef"
  vivify_2144:
    find_lex $P5013, "$name"
    unless_null $P5013, vivify_2145
    new $P5013, "Undef"
  vivify_2145:
    $P5012."symbol"($P5013, "attribute" :named("scope"))
.annotate 'line', 1399
    get_hll_global $P5014, "GLOBAL"
    nqp_get_package_through_who $P5015, $P5014, "PAST"
    get_who $P5016, $P5015
    set $P5017, $P5016["Stmts"]
    $P5018 = $P5017."new"()
    store_lex "$past", $P5018
.annotate 'line', 1376
    .return ($P5018)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5001"  :anon :subid("499_1303739803.72") :outer("498_1303739803.72")
.annotate 'line', 1393
    new $P5003, "Undef"
    .lex "$type", $P5003
    find_lex $P5004, "$/"
    unless_null $P5004, vivify_2138
    $P5004 = root_new ['parrot';'Hash']
  vivify_2138:
    set $P5005, $P5004["typename"]
    unless_null $P5005, vivify_2139
    $P5005 = root_new ['parrot';'ResizablePMCArray']
  vivify_2139:
    set $P5006, $P5005[0]
    unless_null $P5006, vivify_2140
    new $P5006, "Undef"
  vivify_2140:
    $P5007 = $P5006."ast"()
    store_lex "$type", $P5007
.annotate 'line', 1394
    find_lex $P5008, "$type"
    unless_null $P5008, vivify_2141
    new $P5008, "Undef"
  vivify_2141:
    $P5008."named"("type")
.annotate 'line', 1395
    find_lex $P5009, "$meta_args"
    unless_null $P5009, vivify_2142
    new $P5009, "Undef"
  vivify_2142:
    find_lex $P5010, "$type"
    unless_null $P5010, vivify_2143
    new $P5010, "Undef"
  vivify_2143:
    $P5011 = $P5009."push"($P5010)
.annotate 'line', 1392
    .return ($P5011)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("500_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5055
    .param pmc param_5056
.annotate 'line', 1421
    .lex "self", param_5055
    .lex "$/", param_5056
    find_lex $P5057, "$/"
    find_lex $P5058, "$/"
    unless_null $P5058, vivify_2147
    $P5058 = root_new ['parrot';'Hash']
  vivify_2147:
    set $P5059, $P5058["routine_def"]
    unless_null $P5059, vivify_2148
    new $P5059, "Undef"
  vivify_2148:
    $P5060 = $P5059."ast"()
    $P5061 = $P5057."!make"($P5060)
    .return ($P5061)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("501_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5063
    .param pmc param_5064
.annotate 'line', 1422
    .lex "self", param_5063
    .lex "$/", param_5064
    find_lex $P5065, "$/"
    find_lex $P5066, "$/"
    unless_null $P5066, vivify_2149
    $P5066 = root_new ['parrot';'Hash']
  vivify_2149:
    set $P5067, $P5066["method_def"]
    unless_null $P5067, vivify_2150
    new $P5067, "Undef"
  vivify_2150:
    $P5068 = $P5067."ast"()
    $P5069 = $P5065."!make"($P5068)
    .return ($P5069)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("502_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5071
    .param pmc param_5072
.annotate 'line', 1424
    .const 'Sub' $P5429 = "508_1303739803.72" 
    capture_lex $P5429
    .const 'Sub' $P5094 = "503_1303739803.72" 
    capture_lex $P5094
    .lex "self", param_5071
    .lex "$/", param_5072
.annotate 'line', 1427
    new $P5073, "Undef"
    .lex "$past", $P5073
.annotate 'line', 1438
    new $P5074, "Undef"
    .lex "$block", $P5074
.annotate 'line', 1424
    find_lex $P5075, "$past"
    unless_null $P5075, vivify_2151
    new $P5075, "Undef"
  vivify_2151:
.annotate 'line', 1428
    find_lex $P5077, "$/"
    unless_null $P5077, vivify_2152
    $P5077 = root_new ['parrot';'Hash']
  vivify_2152:
    set $P5078, $P5077["onlystar"]
    unless_null $P5078, vivify_2153
    new $P5078, "Undef"
  vivify_2153:
    if $P5078, if_5076
.annotate 'line', 1432
    find_lex $P5080, "$/"
    unless_null $P5080, vivify_2154
    $P5080 = root_new ['parrot';'Hash']
  vivify_2154:
    set $P5081, $P5080["blockoid"]
    unless_null $P5081, vivify_2155
    new $P5081, "Undef"
  vivify_2155:
    $P5082 = $P5081."ast"()
    store_lex "$past", $P5082
.annotate 'line', 1433
    find_lex $P5083, "$past"
    unless_null $P5083, vivify_2156
    new $P5083, "Undef"
  vivify_2156:
    $P5083."blocktype"("declaration")
.annotate 'line', 1434
    find_dynamic_lex $P5087, "$*RETURN_USED"
    unless_null $P5087, vivify_2157
    get_hll_global $P5085, "GLOBAL"
    get_who $P5086, $P5085
    set $P5087, $P5086["$RETURN_USED"]
    unless_null $P5087, vivify_2158
    die "Contextual $*RETURN_USED not found"
  vivify_2158:
  vivify_2157:
    unless $P5087, if_5084_end
.annotate 'line', 1435
    find_lex $P5088, "$past"
    unless_null $P5088, vivify_2159
    new $P5088, "Undef"
  vivify_2159:
    $P5088."control"("return_pir")
  if_5084_end:
.annotate 'line', 1431
    goto if_5076_end
  if_5076:
.annotate 'line', 1429
    $P5079 = "only_star_block"()
    store_lex "$past", $P5079
  if_5076_end:
.annotate 'line', 1438
    find_lex $P5089, "$past"
    unless_null $P5089, vivify_2160
    new $P5089, "Undef"
  vivify_2160:
    store_lex "$block", $P5089
.annotate 'line', 1440
    find_lex $P5091, "$/"
    unless_null $P5091, vivify_2161
    $P5091 = root_new ['parrot';'Hash']
  vivify_2161:
    set $P5092, $P5091["deflongname"]
    unless_null $P5092, vivify_2162
    new $P5092, "Undef"
  vivify_2162:
    unless $P5092, if_5090_end
    .const 'Sub' $P5094 = "503_1303739803.72" 
    capture_lex $P5094
    $P5094()
  if_5090_end:
.annotate 'line', 1554
    find_lex $P5418, "$block"
    unless_null $P5418, vivify_2277
    new $P5418, "Undef"
  vivify_2277:
    find_lex $P5419, "$past"
    unless_null $P5419, vivify_2278
    $P5419 = root_new ['parrot';'Hash']
    store_lex "$past", $P5419
  vivify_2278:
    set $P5419["block_past"], $P5418
.annotate 'line', 1555
    find_lex $P5421, "$/"
    unless_null $P5421, vivify_2279
    $P5421 = root_new ['parrot';'Hash']
  vivify_2279:
    set $P5422, $P5421["trait"]
    unless_null $P5422, vivify_2280
    new $P5422, "Undef"
  vivify_2280:
    unless $P5422, if_5420_end
.annotate 'line', 1556
    find_lex $P5424, "$/"
    unless_null $P5424, vivify_2281
    $P5424 = root_new ['parrot';'Hash']
  vivify_2281:
    set $P5425, $P5424["trait"]
    unless_null $P5425, vivify_2282
    new $P5425, "Undef"
  vivify_2282:
    defined $I5426, $P5425
    unless $I5426, for_undef_2283
    iter $P5423, $P5425
    new $P5436, 'ExceptionHandler'
    set_label $P5436, loop5435_handler
    $P5436."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5436
  loop5435_test:
    unless $P5423, loop5435_done
    shift $P5427, $P5423
  loop5435_redo:
    .const 'Sub' $P5429 = "508_1303739803.72" 
    capture_lex $P5429
    $P5429($P5427)
  loop5435_next:
    goto loop5435_test
  loop5435_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5437, exception, 'type'
    eq $P5437, .CONTROL_LOOP_NEXT, loop5435_next
    eq $P5437, .CONTROL_LOOP_REDO, loop5435_redo
  loop5435_done:
    pop_eh 
  for_undef_2283:
  if_5420_end:
.annotate 'line', 1559
    find_lex $P5438, "$/"
    find_lex $P5439, "$past"
    unless_null $P5439, vivify_2286
    new $P5439, "Undef"
  vivify_2286:
    $P5440 = $P5438."!make"($P5439)
.annotate 'line', 1424
    .return ($P5440)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5093"  :anon :subid("503_1303739803.72") :outer("502_1303739803.72")
.annotate 'line', 1440
    .const 'Sub' $P5248 = "507_1303739803.72" 
    capture_lex $P5248
    .const 'Sub' $P5135 = "504_1303739803.72" 
    capture_lex $P5135
.annotate 'line', 1441
    new $P5095, "Undef"
    .lex "$name", $P5095
    find_lex $P5096, "$/"
    unless_null $P5096, vivify_2163
    $P5096 = root_new ['parrot';'Hash']
  vivify_2163:
    set $P5097, $P5096["sigil"]
    unless_null $P5097, vivify_2164
    $P5097 = root_new ['parrot';'ResizablePMCArray']
  vivify_2164:
    set $P5098, $P5097[0]
    unless_null $P5098, vivify_2165
    new $P5098, "Undef"
  vivify_2165:
    set $S5099, $P5098
    new $P5100, 'String'
    set $P5100, $S5099
    find_lex $P5101, "$/"
    unless_null $P5101, vivify_2166
    $P5101 = root_new ['parrot';'Hash']
  vivify_2166:
    set $P5102, $P5101["deflongname"]
    unless_null $P5102, vivify_2167
    $P5102 = root_new ['parrot';'ResizablePMCArray']
  vivify_2167:
    set $P5103, $P5102[0]
    unless_null $P5103, vivify_2168
    new $P5103, "Undef"
  vivify_2168:
    $S5104 = $P5103."ast"()
    concat $P5105, $P5100, $S5104
    store_lex "$name", $P5105
.annotate 'line', 1442
    find_lex $P5106, "$past"
    unless_null $P5106, vivify_2169
    new $P5106, "Undef"
  vivify_2169:
    find_lex $P5107, "$name"
    unless_null $P5107, vivify_2170
    new $P5107, "Undef"
  vivify_2170:
    $P5106."name"($P5107)
.annotate 'line', 1443
    find_dynamic_lex $P5115, "$*SCOPE"
    unless_null $P5115, vivify_2171
    get_hll_global $P5113, "GLOBAL"
    get_who $P5114, $P5113
    set $P5115, $P5114["$SCOPE"]
    unless_null $P5115, vivify_2172
    die "Contextual $*SCOPE not found"
  vivify_2172:
  vivify_2171:
    set $S5116, $P5115
    iseq $I5117, $S5116, ""
    unless $I5117, unless_5112
    new $P5111, 'Integer'
    set $P5111, $I5117
    goto unless_5112_end
  unless_5112:
    find_dynamic_lex $P5120, "$*SCOPE"
    unless_null $P5120, vivify_2173
    get_hll_global $P5118, "GLOBAL"
    get_who $P5119, $P5118
    set $P5120, $P5119["$SCOPE"]
    unless_null $P5120, vivify_2174
    die "Contextual $*SCOPE not found"
  vivify_2174:
  vivify_2173:
    set $S5121, $P5120
    iseq $I5122, $S5121, "my"
    new $P5111, 'Integer'
    set $P5111, $I5122
  unless_5112_end:
    unless $P5111, unless_5110
    set $P5109, $P5111
    goto unless_5110_end
  unless_5110:
    find_dynamic_lex $P5125, "$*SCOPE"
    unless_null $P5125, vivify_2175
    get_hll_global $P5123, "GLOBAL"
    get_who $P5124, $P5123
    set $P5125, $P5124["$SCOPE"]
    unless_null $P5125, vivify_2176
    die "Contextual $*SCOPE not found"
  vivify_2176:
  vivify_2175:
    set $S5126, $P5125
    iseq $I5127, $S5126, "our"
    new $P5109, 'Integer'
    set $P5109, $I5127
  unless_5110_end:
    if $P5109, if_5108
.annotate 'line', 1544
    find_lex $P5399, "$/"
    unless_null $P5399, vivify_2177
    new $P5399, "Undef"
  vivify_2177:
    $P5400 = $P5399."CURSOR"()
    find_dynamic_lex $P5403, "$*SCOPE"
    unless_null $P5403, vivify_2178
    get_hll_global $P5401, "GLOBAL"
    get_who $P5402, $P5401
    set $P5403, $P5402["$SCOPE"]
    unless_null $P5403, vivify_2179
    die "Contextual $*SCOPE not found"
  vivify_2179:
  vivify_2178:
    concat $P5404, $P5403, " scoped routines are not supported yet"
    $P5400."panic"($P5404)
.annotate 'line', 1543
    goto if_5108_end
  if_5108:
.annotate 'line', 1444
    find_dynamic_lex $P5131, "$*MULTINESS"
    unless_null $P5131, vivify_2180
    get_hll_global $P5129, "GLOBAL"
    get_who $P5130, $P5129
    set $P5131, $P5130["$MULTINESS"]
    unless_null $P5131, vivify_2181
    die "Contextual $*MULTINESS not found"
  vivify_2181:
  vivify_2180:
    set $S5132, $P5131
    iseq $I5133, $S5132, "multi"
    if $I5133, if_5128
.annotate 'line', 1495
    find_dynamic_lex $P5244, "$*MULTINESS"
    unless_null $P5244, vivify_2182
    get_hll_global $P5242, "GLOBAL"
    get_who $P5243, $P5242
    set $P5244, $P5243["$MULTINESS"]
    unless_null $P5244, vivify_2183
    die "Contextual $*MULTINESS not found"
  vivify_2183:
  vivify_2182:
    set $S5245, $P5244
    iseq $I5246, $S5245, "proto"
    if $I5246, if_5241
.annotate 'line', 1514
    find_lex $P5298, "$?PACKAGE"
    get_who $P5299, $P5298
    set $P5300, $P5299["@BLOCK"]
    unless_null $P5300, vivify_2184
    $P5300 = root_new ['parrot';'ResizablePMCArray']
  vivify_2184:
    set $P5301, $P5300[0]
    unless_null $P5301, vivify_2185
    $P5301 = root_new ['parrot';'ResizablePMCArray']
  vivify_2185:
    set $P5302, $P5301[0]
    unless_null $P5302, vivify_2186
    new $P5302, "Undef"
  vivify_2186:
    get_hll_global $P5303, "GLOBAL"
    nqp_get_package_through_who $P5304, $P5303, "PAST"
    get_who $P5305, $P5304
    set $P5306, $P5305["Var"]
    find_lex $P5307, "$name"
    unless_null $P5307, vivify_2187
    new $P5307, "Undef"
  vivify_2187:
    find_lex $P5308, "$past"
    unless_null $P5308, vivify_2188
    new $P5308, "Undef"
  vivify_2188:
    $P5309 = $P5306."new"($P5307 :named("name"), 1 :named("isdecl"), $P5308 :named("viviself"), "lexical" :named("scope"))
    $P5302."push"($P5309)
.annotate 'line', 1516
    find_lex $P5310, "$?PACKAGE"
    get_who $P5311, $P5310
    set $P5312, $P5311["@BLOCK"]
    unless_null $P5312, vivify_2189
    $P5312 = root_new ['parrot';'ResizablePMCArray']
  vivify_2189:
    set $P5313, $P5312[0]
    unless_null $P5313, vivify_2190
    new $P5313, "Undef"
  vivify_2190:
    find_lex $P5314, "$name"
    unless_null $P5314, vivify_2191
    new $P5314, "Undef"
  vivify_2191:
    $P5313."symbol"($P5314, "lexical" :named("scope"))
.annotate 'line', 1517
    find_dynamic_lex $P5318, "$*SCOPE"
    unless_null $P5318, vivify_2192
    get_hll_global $P5316, "GLOBAL"
    get_who $P5317, $P5316
    set $P5318, $P5317["$SCOPE"]
    unless_null $P5318, vivify_2193
    die "Contextual $*SCOPE not found"
  vivify_2193:
  vivify_2192:
    set $S5319, $P5318
    iseq $I5320, $S5319, "our"
    unless $I5320, if_5315_end
.annotate 'line', 1520
    find_dynamic_lex $P5323, "$*SC"
    unless_null $P5323, vivify_2194
    get_hll_global $P5321, "GLOBAL"
    get_who $P5322, $P5321
    set $P5323, $P5322["$SC"]
    unless_null $P5323, vivify_2195
    die "Contextual $*SC not found"
  vivify_2195:
  vivify_2194:
    find_dynamic_lex $P5326, "$*PACKAGE"
    unless_null $P5326, vivify_2196
    get_hll_global $P5324, "GLOBAL"
    get_who $P5325, $P5324
    set $P5326, $P5325["$PACKAGE"]
    unless_null $P5326, vivify_2197
    die "Contextual $*PACKAGE not found"
  vivify_2197:
  vivify_2196:
    find_lex $P5327, "$name"
    unless_null $P5327, vivify_2198
    new $P5327, "Undef"
  vivify_2198:
    find_lex $P5328, "$past"
    unless_null $P5328, vivify_2199
    new $P5328, "Undef"
  vivify_2199:
    $P5323."install_package_routine"($P5326, $P5327, $P5328)
.annotate 'line', 1521
    find_lex $P5329, "$?PACKAGE"
    get_who $P5330, $P5329
    set $P5331, $P5330["@BLOCK"]
    unless_null $P5331, vivify_2200
    $P5331 = root_new ['parrot';'ResizablePMCArray']
  vivify_2200:
    set $P5332, $P5331[0]
    unless_null $P5332, vivify_2201
    $P5332 = root_new ['parrot';'ResizablePMCArray']
  vivify_2201:
    set $P5333, $P5332[0]
    unless_null $P5333, vivify_2202
    new $P5333, "Undef"
  vivify_2202:
    get_hll_global $P5334, "GLOBAL"
    nqp_get_package_through_who $P5335, $P5334, "PAST"
    get_who $P5336, $P5335
    set $P5337, $P5336["Op"]
.annotate 'line', 1523
    find_lex $P5338, "$name"
    unless_null $P5338, vivify_2203
    new $P5338, "Undef"
  vivify_2203:
    new $P5339, "ResizablePMCArray"
    push $P5339, $P5338
    find_lex $P5340, "$/"
    unless_null $P5340, vivify_2204
    new $P5340, "Undef"
  vivify_2204:
    $P5341 = "lexical_package_lookup"($P5339, $P5340)
.annotate 'line', 1524
    get_hll_global $P5342, "GLOBAL"
    nqp_get_package_through_who $P5343, $P5342, "PAST"
    get_who $P5344, $P5343
    set $P5345, $P5344["Var"]
    find_lex $P5346, "$name"
    unless_null $P5346, vivify_2205
    new $P5346, "Undef"
  vivify_2205:
    $P5347 = $P5345."new"($P5346 :named("name"), "lexical" :named("scope"))
    $P5348 = $P5337."new"($P5341, $P5347, "bind" :named("pasttype"))
.annotate 'line', 1521
    $P5333."push"($P5348)
.annotate 'line', 1528
    find_lex $P5349, "$?PACKAGE"
    get_who $P5350, $P5349
    set $P5351, $P5350["@BLOCK"]
    unless_null $P5351, vivify_2206
    $P5351 = root_new ['parrot';'ResizablePMCArray']
  vivify_2206:
    set $P5352, $P5351[0]
    unless_null $P5352, vivify_2207
    $P5352 = root_new ['parrot';'ResizablePMCArray']
  vivify_2207:
    set $P5353, $P5352[0]
    unless_null $P5353, vivify_2208
    new $P5353, "Undef"
  vivify_2208:
    get_hll_global $P5354, "GLOBAL"
    nqp_get_package_through_who $P5355, $P5354, "PAST"
    get_who $P5356, $P5355
    set $P5357, $P5356["Op"]
.annotate 'line', 1530
    get_hll_global $P5358, "GLOBAL"
    nqp_get_package_through_who $P5359, $P5358, "PAST"
    get_who $P5360, $P5359
    set $P5361, $P5360["Var"]
    find_lex $P5362, "$name"
    unless_null $P5362, vivify_2209
    new $P5362, "Undef"
  vivify_2209:
    $P5363 = $P5361."new"($P5362 :named("name"), "package" :named("scope"))
.annotate 'line', 1531
    get_hll_global $P5364, "GLOBAL"
    nqp_get_package_through_who $P5365, $P5364, "PAST"
    get_who $P5366, $P5365
    set $P5367, $P5366["Var"]
    find_lex $P5368, "$name"
    unless_null $P5368, vivify_2210
    new $P5368, "Undef"
  vivify_2210:
    $P5369 = $P5367."new"($P5368 :named("name"), "lexical" :named("scope"))
    $P5370 = $P5357."new"($P5363, $P5369, "bind" :named("pasttype"))
.annotate 'line', 1528
    $P5353."push"($P5370)
.annotate 'line', 1533
    find_lex $P5371, "$?PACKAGE"
    get_who $P5372, $P5371
    set $P5373, $P5372["@BLOCK"]
    unless_null $P5373, vivify_2211
    $P5373 = root_new ['parrot';'ResizablePMCArray']
  vivify_2211:
    set $P5374, $P5373[0]
    unless_null $P5374, vivify_2212
    new $P5374, "Undef"
  vivify_2212:
    $P5375 = $P5374."loadinit"()
    get_hll_global $P5376, "GLOBAL"
    nqp_get_package_through_who $P5377, $P5376, "PAST"
    get_who $P5378, $P5377
    set $P5379, $P5378["Op"]
.annotate 'line', 1535
    get_hll_global $P5380, "GLOBAL"
    nqp_get_package_through_who $P5381, $P5380, "PAST"
    get_who $P5382, $P5381
    set $P5383, $P5382["Var"]
    find_lex $P5384, "$name"
    unless_null $P5384, vivify_2213
    new $P5384, "Undef"
  vivify_2213:
    $P5385 = $P5383."new"($P5384 :named("name"), "package" :named("scope"))
.annotate 'line', 1536
    get_hll_global $P5386, "GLOBAL"
    nqp_get_package_through_who $P5387, $P5386, "PAST"
    get_who $P5388, $P5387
    set $P5389, $P5388["Val"]
    find_lex $P5390, "$past"
    unless_null $P5390, vivify_2214
    new $P5390, "Undef"
  vivify_2214:
    $P5391 = $P5389."new"($P5390 :named("value"))
    $P5392 = $P5379."new"($P5385, $P5391, "bind" :named("pasttype"))
.annotate 'line', 1533
    $P5375."push"($P5392)
  if_5315_end:
.annotate 'line', 1513
    goto if_5241_end
  if_5241:
.annotate 'line', 1495
    .const 'Sub' $P5248 = "507_1303739803.72" 
    capture_lex $P5248
    $P5248()
  if_5241_end:
    goto if_5128_end
  if_5128:
.annotate 'line', 1444
    .const 'Sub' $P5135 = "504_1303739803.72" 
    capture_lex $P5135
    $P5135()
  if_5128_end:
.annotate 'line', 1541
    get_hll_global $P5393, "GLOBAL"
    nqp_get_package_through_who $P5394, $P5393, "PAST"
    get_who $P5395, $P5394
    set $P5396, $P5395["Var"]
    find_lex $P5397, "$name"
    unless_null $P5397, vivify_2272
    new $P5397, "Undef"
  vivify_2272:
    $P5398 = $P5396."new"($P5397 :named("name"))
    store_lex "$past", $P5398
  if_5108_end:
.annotate 'line', 1548
    find_lex $P5409, "$name"
    unless_null $P5409, vivify_2273
    new $P5409, "Undef"
  vivify_2273:
    set $S5410, $P5409
    iseq $I5411, $S5410, "MAIN"
    if $I5411, if_5408
    new $P5407, 'Integer'
    set $P5407, $I5411
    goto if_5408_end
  if_5408:
    find_dynamic_lex $P5414, "$*MULTINESS"
    unless_null $P5414, vivify_2274
    get_hll_global $P5412, "GLOBAL"
    get_who $P5413, $P5412
    set $P5414, $P5413["$MULTINESS"]
    unless_null $P5414, vivify_2275
    die "Contextual $*MULTINESS not found"
  vivify_2275:
  vivify_2274:
    set $S5415, $P5414
    isne $I5416, $S5415, "multi"
    new $P5407, 'Integer'
    set $P5407, $I5416
  if_5408_end:
    if $P5407, if_5406
    set $P5405, $P5407
    goto if_5406_end
  if_5406:
.annotate 'line', 1549
    find_lex $P5417, "$block"
    unless_null $P5417, vivify_2276
    new $P5417, "Undef"
  vivify_2276:
    store_dynamic_lex "$*MAIN_SUB", $P5417
.annotate 'line', 1548
    set $P5405, $P5417
  if_5406_end:
.annotate 'line', 1440
    .return ($P5405)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5247"  :anon :subid("507_1303739803.72") :outer("503_1303739803.72")
.annotate 'line', 1500
    new $P5249, "Undef"
    .lex "$cholder", $P5249
.annotate 'line', 1499
    find_dynamic_lex $P5253, "$*SCOPE"
    unless_null $P5253, vivify_2215
    get_hll_global $P5251, "GLOBAL"
    get_who $P5252, $P5251
    set $P5253, $P5252["$SCOPE"]
    unless_null $P5253, vivify_2216
    die "Contextual $*SCOPE not found"
  vivify_2216:
  vivify_2215:
    set $S5254, $P5253
    iseq $I5255, $S5254, "our"
    unless $I5255, if_5250_end
    die "our-scoped protos not yet implemented"
  if_5250_end:
.annotate 'line', 1500
    get_hll_global $P5256, "GLOBAL"
    nqp_get_package_through_who $P5257, $P5256, "PAST"
    get_who $P5258, $P5257
    set $P5259, $P5258["Op"]
    $P5260 = $P5259."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5260
.annotate 'line', 1501
    find_lex $P5261, "$?PACKAGE"
    get_who $P5262, $P5261
    set $P5263, $P5262["@BLOCK"]
    unless_null $P5263, vivify_2217
    $P5263 = root_new ['parrot';'ResizablePMCArray']
  vivify_2217:
    set $P5264, $P5263[0]
    unless_null $P5264, vivify_2218
    $P5264 = root_new ['parrot';'ResizablePMCArray']
  vivify_2218:
    set $P5265, $P5264[0]
    unless_null $P5265, vivify_2219
    new $P5265, "Undef"
  vivify_2219:
    get_hll_global $P5266, "GLOBAL"
    nqp_get_package_through_who $P5267, $P5266, "PAST"
    get_who $P5268, $P5267
    set $P5269, $P5268["Var"]
    find_lex $P5270, "$name"
    unless_null $P5270, vivify_2220
    new $P5270, "Undef"
  vivify_2220:
    find_lex $P5271, "$past"
    unless_null $P5271, vivify_2221
    new $P5271, "Undef"
  vivify_2221:
    $P5272 = $P5269."new"($P5270 :named("name"), 1 :named("isdecl"), $P5271 :named("viviself"), "lexical" :named("scope"))
    $P5265."push"($P5272)
.annotate 'line', 1503
    find_lex $P5273, "$?PACKAGE"
    get_who $P5274, $P5273
    set $P5275, $P5274["@BLOCK"]
    unless_null $P5275, vivify_2222
    $P5275 = root_new ['parrot';'ResizablePMCArray']
  vivify_2222:
    set $P5276, $P5275[0]
    unless_null $P5276, vivify_2223
    $P5276 = root_new ['parrot';'ResizablePMCArray']
  vivify_2223:
    set $P5277, $P5276[0]
    unless_null $P5277, vivify_2224
    new $P5277, "Undef"
  vivify_2224:
    get_hll_global $P5278, "GLOBAL"
    nqp_get_package_through_who $P5279, $P5278, "PAST"
    get_who $P5280, $P5279
    set $P5281, $P5280["Op"]
.annotate 'line', 1505
    get_hll_global $P5282, "GLOBAL"
    nqp_get_package_through_who $P5283, $P5282, "PAST"
    get_who $P5284, $P5283
    set $P5285, $P5284["Var"]
    find_lex $P5286, "$name"
    unless_null $P5286, vivify_2225
    new $P5286, "Undef"
  vivify_2225:
    $P5287 = $P5285."new"($P5286 :named("name"))
    find_lex $P5288, "$cholder"
    unless_null $P5288, vivify_2226
    new $P5288, "Undef"
  vivify_2226:
    $P5289 = $P5281."new"($P5287, $P5288, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1503
    $P5277."push"($P5289)
.annotate 'line', 1508
    find_lex $P5290, "$?PACKAGE"
    get_who $P5291, $P5290
    set $P5292, $P5291["@BLOCK"]
    unless_null $P5292, vivify_2227
    $P5292 = root_new ['parrot';'ResizablePMCArray']
  vivify_2227:
    set $P5293, $P5292[0]
    unless_null $P5293, vivify_2228
    new $P5293, "Undef"
  vivify_2228:
    find_lex $P5294, "$name"
    unless_null $P5294, vivify_2229
    new $P5294, "Undef"
  vivify_2229:
    find_lex $P5295, "$cholder"
    unless_null $P5295, vivify_2230
    new $P5295, "Undef"
  vivify_2230:
    $P5293."symbol"($P5294, "lexical" :named("scope"), 1 :named("proto"), $P5295 :named("cholder"))
.annotate 'line', 1511
    find_lex $P5296, "$past"
    unless_null $P5296, vivify_2231
    new $P5296, "Undef"
  vivify_2231:
    $P5297 = $P5296."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1495
    .return ($P5297)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5134"  :anon :subid("504_1303739803.72") :outer("503_1303739803.72")
.annotate 'line', 1444
    .const 'Sub' $P5157 = "505_1303739803.72" 
    capture_lex $P5157
.annotate 'line', 1447
    new $P5136, "Undef"
    .lex "$cholder", $P5136
.annotate 'line', 1448
    $P5137 = root_new ['parrot';'Hash']
    .lex "%sym", $P5137
.annotate 'line', 1446
    find_dynamic_lex $P5141, "$*SCOPE"
    unless_null $P5141, vivify_2232
    get_hll_global $P5139, "GLOBAL"
    get_who $P5140, $P5139
    set $P5141, $P5140["$SCOPE"]
    unless_null $P5141, vivify_2233
    die "Contextual $*SCOPE not found"
  vivify_2233:
  vivify_2232:
    set $S5142, $P5141
    iseq $I5143, $S5142, "our"
    unless $I5143, if_5138_end
    die "our-scoped multis not yet implemented"
  if_5138_end:
    find_lex $P5144, "$cholder"
    unless_null $P5144, vivify_2234
    new $P5144, "Undef"
  vivify_2234:
.annotate 'line', 1448
    find_lex $P5145, "$?PACKAGE"
    get_who $P5146, $P5145
    set $P5147, $P5146["@BLOCK"]
    unless_null $P5147, vivify_2235
    $P5147 = root_new ['parrot';'ResizablePMCArray']
  vivify_2235:
    set $P5148, $P5147[0]
    unless_null $P5148, vivify_2236
    new $P5148, "Undef"
  vivify_2236:
    find_lex $P5149, "$name"
    unless_null $P5149, vivify_2237
    new $P5149, "Undef"
  vivify_2237:
    $P5150 = $P5148."symbol"($P5149)
    store_lex "%sym", $P5150
.annotate 'line', 1449
    find_lex $P5152, "%sym"
    unless_null $P5152, vivify_2238
    $P5152 = root_new ['parrot';'Hash']
  vivify_2238:
    set $P5153, $P5152["cholder"]
    unless_null $P5153, vivify_2239
    new $P5153, "Undef"
  vivify_2239:
    if $P5153, if_5151
.annotate 'line', 1454
    .const 'Sub' $P5157 = "505_1303739803.72" 
    capture_lex $P5157
    $P5157()
    goto if_5151_end
  if_5151:
.annotate 'line', 1450
    find_lex $P5154, "%sym"
    unless_null $P5154, vivify_2267
    $P5154 = root_new ['parrot';'Hash']
  vivify_2267:
    set $P5155, $P5154["cholder"]
    unless_null $P5155, vivify_2268
    new $P5155, "Undef"
  vivify_2268:
    store_lex "$cholder", $P5155
  if_5151_end:
.annotate 'line', 1490
    find_lex $P5237, "$cholder"
    unless_null $P5237, vivify_2269
    new $P5237, "Undef"
  vivify_2269:
    find_lex $P5238, "$past"
    unless_null $P5238, vivify_2270
    new $P5238, "Undef"
  vivify_2270:
    $P5237."push"($P5238)
.annotate 'line', 1493
    find_lex $P5239, "$past"
    unless_null $P5239, vivify_2271
    new $P5239, "Undef"
  vivify_2271:
    $P5240 = "attach_multi_signature"($P5239)
.annotate 'line', 1444
    .return ($P5240)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5156"  :anon :subid("505_1303739803.72") :outer("504_1303739803.72")
.annotate 'line', 1454
    .const 'Sub' $P5173 = "506_1303739803.72" 
    capture_lex $P5173
.annotate 'line', 1461
    new $P5158, "Undef"
    .lex "$found_proto", $P5158
.annotate 'line', 1479
    new $P5159, "Undef"
    .lex "$dispatch_setup", $P5159
.annotate 'line', 1456
    find_lex $P5161, "%sym"
    unless_null $P5161, vivify_2240
    $P5161 = root_new ['parrot';'Hash']
  vivify_2240:
    set $P5162, $P5161["proto"]
    unless_null $P5162, vivify_2241
    new $P5162, "Undef"
  vivify_2241:
    unless $P5162, if_5160_end
.annotate 'line', 1459
    find_lex $P5163, "$/"
    unless_null $P5163, vivify_2242
    new $P5163, "Undef"
  vivify_2242:
    $P5164 = $P5163."CURSOR"()
    $P5164."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_5160_end:
.annotate 'line', 1456
    find_lex $P5165, "$found_proto"
    unless_null $P5165, vivify_2243
    new $P5165, "Undef"
  vivify_2243:
.annotate 'line', 1462
    find_lex $P5167, "$?PACKAGE"
    get_who $P5168, $P5167
    set $P5169, $P5168["@BLOCK"]
    unless_null $P5169, vivify_2244
    $P5169 = root_new ['parrot';'ResizablePMCArray']
  vivify_2244:
    defined $I5170, $P5169
    unless $I5170, for_undef_2245
    iter $P5166, $P5169
    new $P5195, 'ExceptionHandler'
    set_label $P5195, loop5194_handler
    $P5195."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5195
  loop5194_test:
    unless $P5166, loop5194_done
    shift $P5171, $P5166
  loop5194_redo:
    .const 'Sub' $P5173 = "506_1303739803.72" 
    capture_lex $P5173
    $P5173($P5171)
  loop5194_next:
    goto loop5194_test
  loop5194_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5196, exception, 'type'
    eq $P5196, .CONTROL_LOOP_NEXT, loop5194_next
    eq $P5196, .CONTROL_LOOP_REDO, loop5194_redo
  loop5194_done:
    pop_eh 
  for_undef_2245:
.annotate 'line', 1473
    find_lex $P5198, "$found_proto"
    unless_null $P5198, vivify_2254
    new $P5198, "Undef"
  vivify_2254:
    if $P5198, unless_5197_end
.annotate 'line', 1474
    find_lex $P5199, "$/"
    unless_null $P5199, vivify_2255
    new $P5199, "Undef"
  vivify_2255:
    $P5200 = $P5199."CURSOR"()
    $P5200."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_5197_end:
.annotate 'line', 1478
    get_hll_global $P5201, "GLOBAL"
    nqp_get_package_through_who $P5202, $P5201, "PAST"
    get_who $P5203, $P5202
    set $P5204, $P5203["Op"]
    $P5205 = $P5204."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5205
.annotate 'line', 1479
    get_hll_global $P5206, "GLOBAL"
    nqp_get_package_through_who $P5207, $P5206, "PAST"
    get_who $P5208, $P5207
    set $P5209, $P5208["Op"]
.annotate 'line', 1481
    get_hll_global $P5210, "GLOBAL"
    nqp_get_package_through_who $P5211, $P5210, "PAST"
    get_who $P5212, $P5211
    set $P5213, $P5212["Var"]
    find_lex $P5214, "$name"
    unless_null $P5214, vivify_2256
    new $P5214, "Undef"
  vivify_2256:
    $P5215 = $P5213."new"($P5214 :named("name"), "outer" :named("scope"))
    find_lex $P5216, "$cholder"
    unless_null $P5216, vivify_2257
    new $P5216, "Undef"
  vivify_2257:
    $P5217 = $P5209."new"($P5215, $P5216, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1479
    store_lex "$dispatch_setup", $P5217
.annotate 'line', 1484
    find_lex $P5218, "$?PACKAGE"
    get_who $P5219, $P5218
    set $P5220, $P5219["@BLOCK"]
    unless_null $P5220, vivify_2258
    $P5220 = root_new ['parrot';'ResizablePMCArray']
  vivify_2258:
    set $P5221, $P5220[0]
    unless_null $P5221, vivify_2259
    $P5221 = root_new ['parrot';'ResizablePMCArray']
  vivify_2259:
    set $P5222, $P5221[0]
    unless_null $P5222, vivify_2260
    new $P5222, "Undef"
  vivify_2260:
    get_hll_global $P5223, "GLOBAL"
    nqp_get_package_through_who $P5224, $P5223, "PAST"
    get_who $P5225, $P5224
    set $P5226, $P5225["Var"]
    find_lex $P5227, "$name"
    unless_null $P5227, vivify_2261
    new $P5227, "Undef"
  vivify_2261:
    find_lex $P5228, "$dispatch_setup"
    unless_null $P5228, vivify_2262
    new $P5228, "Undef"
  vivify_2262:
    $P5229 = $P5226."new"($P5227 :named("name"), 1 :named("isdecl"), $P5228 :named("viviself"), "lexical" :named("scope"))
    $P5222."push"($P5229)
.annotate 'line', 1486
    find_lex $P5230, "$?PACKAGE"
    get_who $P5231, $P5230
    set $P5232, $P5231["@BLOCK"]
    unless_null $P5232, vivify_2263
    $P5232 = root_new ['parrot';'ResizablePMCArray']
  vivify_2263:
    set $P5233, $P5232[0]
    unless_null $P5233, vivify_2264
    new $P5233, "Undef"
  vivify_2264:
    find_lex $P5234, "$name"
    unless_null $P5234, vivify_2265
    new $P5234, "Undef"
  vivify_2265:
    find_lex $P5235, "$cholder"
    unless_null $P5235, vivify_2266
    new $P5235, "Undef"
  vivify_2266:
    $P5236 = $P5233."symbol"($P5234, "lexical" :named("scope"), $P5235 :named("cholder"))
.annotate 'line', 1454
    .return ($P5236)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5172"  :anon :subid("506_1303739803.72") :outer("505_1303739803.72")
    .param pmc param_5175
.annotate 'line', 1463
    $P5174 = root_new ['parrot';'Hash']
    .lex "%sym", $P5174
    .lex "$_", param_5175
    find_lex $P5176, "$_"
    unless_null $P5176, vivify_2246
    new $P5176, "Undef"
  vivify_2246:
    find_lex $P5177, "$name"
    unless_null $P5177, vivify_2247
    new $P5177, "Undef"
  vivify_2247:
    $P5178 = $P5176."symbol"($P5177)
    store_lex "%sym", $P5178
.annotate 'line', 1464
    find_lex $P5183, "%sym"
    unless_null $P5183, vivify_2248
    $P5183 = root_new ['parrot';'Hash']
  vivify_2248:
    set $P5184, $P5183["proto"]
    unless_null $P5184, vivify_2249
    new $P5184, "Undef"
  vivify_2249:
    unless $P5184, unless_5182
    set $P5181, $P5184
    goto unless_5182_end
  unless_5182:
    find_lex $P5185, "%sym"
    unless_null $P5185, vivify_2250
    $P5185 = root_new ['parrot';'Hash']
  vivify_2250:
    set $P5186, $P5185["cholder"]
    unless_null $P5186, vivify_2251
    new $P5186, "Undef"
  vivify_2251:
    set $P5181, $P5186
  unless_5182_end:
    if $P5181, if_5180
.annotate 'line', 1467
    find_lex $P5190, "%sym"
    unless_null $P5190, vivify_2252
    $P5190 = root_new ['parrot';'Hash']
  vivify_2252:
    if $P5190, if_5189
    set $P5188, $P5190
    goto if_5189_end
  if_5189:
.annotate 'line', 1468
    find_lex $P5191, "$/"
    unless_null $P5191, vivify_2253
    new $P5191, "Undef"
  vivify_2253:
    $P5192 = $P5191."CURSOR"()
    $P5193 = $P5192."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1467
    set $P5188, $P5193
  if_5189_end:
    set $P5179, $P5188
.annotate 'line', 1464
    goto if_5180_end
  if_5180:
.annotate 'line', 1465
    new $P5187, "Integer"
    assign $P5187, 1
    store_lex "$found_proto", $P5187
.annotate 'line', 1464
    set $P5179, $P5187
  if_5180_end:
.annotate 'line', 1462
    .return ($P5179)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5428"  :anon :subid("508_1303739803.72") :outer("502_1303739803.72")
    .param pmc param_5430
.annotate 'line', 1556
    .lex "$_", param_5430
    find_lex $P5431, "$_"
    unless_null $P5431, vivify_2284
    new $P5431, "Undef"
  vivify_2284:
    $P5432 = $P5431."ast"()
    find_lex $P5433, "$/"
    unless_null $P5433, vivify_2285
    new $P5433, "Undef"
  vivify_2285:
    $P5434 = $P5432($P5433)
    .return ($P5434)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("509_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5442
    .param pmc param_5443
.annotate 'line', 1563
    .const 'Sub' $P5612 = "511_1303739803.72" 
    capture_lex $P5612
    .const 'Sub' $P5479 = "510_1303739803.72" 
    capture_lex $P5479
    .lex "self", param_5442
    .lex "$/", param_5443
.annotate 'line', 1566
    new $P5444, "Undef"
    .lex "$past", $P5444
.annotate 'line', 1563
    find_lex $P5445, "$past"
    unless_null $P5445, vivify_2287
    new $P5445, "Undef"
  vivify_2287:
.annotate 'line', 1567
    find_lex $P5447, "$/"
    unless_null $P5447, vivify_2288
    $P5447 = root_new ['parrot';'Hash']
  vivify_2288:
    set $P5448, $P5447["onlystar"]
    unless_null $P5448, vivify_2289
    new $P5448, "Undef"
  vivify_2289:
    if $P5448, if_5446
.annotate 'line', 1571
    find_lex $P5450, "$/"
    unless_null $P5450, vivify_2290
    $P5450 = root_new ['parrot';'Hash']
  vivify_2290:
    set $P5451, $P5450["blockoid"]
    unless_null $P5451, vivify_2291
    new $P5451, "Undef"
  vivify_2291:
    $P5452 = $P5451."ast"()
    store_lex "$past", $P5452
.annotate 'line', 1572
    find_lex $P5453, "$past"
    unless_null $P5453, vivify_2292
    new $P5453, "Undef"
  vivify_2292:
    $P5453."blocktype"("declaration")
.annotate 'line', 1573
    find_dynamic_lex $P5457, "$*RETURN_USED"
    unless_null $P5457, vivify_2293
    get_hll_global $P5455, "GLOBAL"
    get_who $P5456, $P5455
    set $P5457, $P5456["$RETURN_USED"]
    unless_null $P5457, vivify_2294
    die "Contextual $*RETURN_USED not found"
  vivify_2294:
  vivify_2293:
    unless $P5457, if_5454_end
.annotate 'line', 1574
    find_lex $P5458, "$past"
    unless_null $P5458, vivify_2295
    new $P5458, "Undef"
  vivify_2295:
    $P5458."control"("return_pir")
  if_5454_end:
.annotate 'line', 1570
    goto if_5446_end
  if_5446:
.annotate 'line', 1568
    $P5449 = "only_star_block"()
    store_lex "$past", $P5449
  if_5446_end:
.annotate 'line', 1579
    find_lex $P5460, "$past"
    unless_null $P5460, vivify_2296
    $P5460 = root_new ['parrot';'Hash']
  vivify_2296:
    set $P5461, $P5460["signature_has_invocant"]
    unless_null $P5461, vivify_2297
    new $P5461, "Undef"
  vivify_2297:
    if $P5461, unless_5459_end
.annotate 'line', 1580
    find_lex $P5462, "$past"
    unless_null $P5462, vivify_2298
    $P5462 = root_new ['parrot';'ResizablePMCArray']
  vivify_2298:
    set $P5463, $P5462[0]
    unless_null $P5463, vivify_2299
    new $P5463, "Undef"
  vivify_2299:
    get_hll_global $P5464, "GLOBAL"
    nqp_get_package_through_who $P5465, $P5464, "PAST"
    get_who $P5466, $P5465
    set $P5467, $P5466["Var"]
.annotate 'line', 1582
    get_hll_global $P5468, "GLOBAL"
    nqp_get_package_through_who $P5469, $P5468, "PAST"
    get_who $P5470, $P5469
    set $P5471, $P5470["Var"]
    $P5472 = $P5471."new"("$?CLASS" :named("name"))
    $P5473 = $P5467."new"("self" :named("name"), "parameter" :named("scope"), $P5472 :named("multitype"))
.annotate 'line', 1580
    $P5463."unshift"($P5473)
  unless_5459_end:
.annotate 'line', 1585
    find_lex $P5474, "$past"
    unless_null $P5474, vivify_2300
    new $P5474, "Undef"
  vivify_2300:
    $P5474."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1588
    find_lex $P5476, "$/"
    unless_null $P5476, vivify_2301
    $P5476 = root_new ['parrot';'Hash']
  vivify_2301:
    set $P5477, $P5476["deflongname"]
    unless_null $P5477, vivify_2302
    new $P5477, "Undef"
  vivify_2302:
    unless $P5477, if_5475_end
    .const 'Sub' $P5479 = "510_1303739803.72" 
    capture_lex $P5479
    $P5479()
  if_5475_end:
.annotate 'line', 1631
    find_lex $P5598, "$/"
    find_lex $P5599, "$past"
    unless_null $P5599, vivify_2337
    new $P5599, "Undef"
  vivify_2337:
    $P5598."!make"($P5599)
.annotate 'line', 1632
    find_lex $P5600, "$past"
    unless_null $P5600, vivify_2338
    new $P5600, "Undef"
  vivify_2338:
    find_lex $P5601, "$past"
    unless_null $P5601, vivify_2339
    $P5601 = root_new ['parrot';'Hash']
    store_lex "$past", $P5601
  vivify_2339:
    set $P5601["block_past"], $P5600
.annotate 'line', 1633
    find_lex $P5604, "$/"
    unless_null $P5604, vivify_2340
    $P5604 = root_new ['parrot';'Hash']
  vivify_2340:
    set $P5605, $P5604["trait"]
    unless_null $P5605, vivify_2341
    new $P5605, "Undef"
  vivify_2341:
    if $P5605, if_5603
    set $P5602, $P5605
    goto if_5603_end
  if_5603:
.annotate 'line', 1634
    find_lex $P5607, "$/"
    unless_null $P5607, vivify_2342
    $P5607 = root_new ['parrot';'Hash']
  vivify_2342:
    set $P5608, $P5607["trait"]
    unless_null $P5608, vivify_2343
    new $P5608, "Undef"
  vivify_2343:
    defined $I5609, $P5608
    unless $I5609, for_undef_2344
    iter $P5606, $P5608
    new $P5619, 'ExceptionHandler'
    set_label $P5619, loop5618_handler
    $P5619."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5619
  loop5618_test:
    unless $P5606, loop5618_done
    shift $P5610, $P5606
  loop5618_redo:
    .const 'Sub' $P5612 = "511_1303739803.72" 
    capture_lex $P5612
    $P5612($P5610)
  loop5618_next:
    goto loop5618_test
  loop5618_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5620, exception, 'type'
    eq $P5620, .CONTROL_LOOP_NEXT, loop5618_next
    eq $P5620, .CONTROL_LOOP_REDO, loop5618_redo
  loop5618_done:
    pop_eh 
  for_undef_2344:
.annotate 'line', 1633
    set $P5602, $P5606
  if_5603_end:
.annotate 'line', 1563
    .return ($P5602)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5478"  :anon :subid("510_1303739803.72") :outer("509_1303739803.72")
.annotate 'line', 1590
    new $P5480, "Undef"
    .lex "$name", $P5480
.annotate 'line', 1595
    new $P5481, "Undef"
    .lex "$to_add", $P5481
.annotate 'line', 1590
    find_lex $P5482, "$/"
    unless_null $P5482, vivify_2303
    $P5482 = root_new ['parrot';'Hash']
  vivify_2303:
    set $P5483, $P5482["private"]
    unless_null $P5483, vivify_2304
    new $P5483, "Undef"
  vivify_2304:
    set $S5484, $P5483
    new $P5485, 'String'
    set $P5485, $S5484
    find_lex $P5486, "$/"
    unless_null $P5486, vivify_2305
    $P5486 = root_new ['parrot';'Hash']
  vivify_2305:
    set $P5487, $P5486["deflongname"]
    unless_null $P5487, vivify_2306
    $P5487 = root_new ['parrot';'ResizablePMCArray']
  vivify_2306:
    set $P5488, $P5487[0]
    unless_null $P5488, vivify_2307
    new $P5488, "Undef"
  vivify_2307:
    $P5489 = $P5488."ast"()
    set $S5490, $P5489
    concat $P5491, $P5485, $S5490
    store_lex "$name", $P5491
.annotate 'line', 1591
    find_lex $P5492, "$past"
    unless_null $P5492, vivify_2308
    new $P5492, "Undef"
  vivify_2308:
    find_lex $P5493, "$name"
    unless_null $P5493, vivify_2309
    new $P5493, "Undef"
  vivify_2309:
    $P5492."name"($P5493)
.annotate 'line', 1595
    find_dynamic_lex $P5498, "$*MULTINESS"
    unless_null $P5498, vivify_2310
    get_hll_global $P5496, "GLOBAL"
    get_who $P5497, $P5496
    set $P5498, $P5497["$MULTINESS"]
    unless_null $P5498, vivify_2311
    die "Contextual $*MULTINESS not found"
  vivify_2311:
  vivify_2310:
    set $S5499, $P5498
    isne $I5500, $S5499, "proto"
    if $I5500, if_5495
.annotate 'line', 1597
    get_hll_global $P5507, "GLOBAL"
    nqp_get_package_through_who $P5508, $P5507, "PAST"
    get_who $P5509, $P5508
    set $P5510, $P5509["Op"]
.annotate 'line', 1599
    get_hll_global $P5511, "GLOBAL"
    nqp_get_package_through_who $P5512, $P5511, "PAST"
    get_who $P5513, $P5512
    set $P5514, $P5513["Val"]
    find_lex $P5515, "$past"
    unless_null $P5515, vivify_2312
    new $P5515, "Undef"
  vivify_2312:
    $P5516 = $P5514."new"($P5515 :named("value"))
.annotate 'line', 1600
    get_hll_global $P5517, "GLOBAL"
    nqp_get_package_through_who $P5518, $P5517, "PAST"
    get_who $P5519, $P5518
    set $P5520, $P5519["Op"]
    $P5521 = $P5520."new"("list" :named("pasttype"))
    $P5522 = $P5510."new"($P5516, $P5521, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1597
    set $P5494, $P5522
.annotate 'line', 1595
    goto if_5495_end
  if_5495:
.annotate 'line', 1596
    get_hll_global $P5501, "GLOBAL"
    nqp_get_package_through_who $P5502, $P5501, "PAST"
    get_who $P5503, $P5502
    set $P5504, $P5503["Val"]
    find_lex $P5505, "$past"
    unless_null $P5505, vivify_2313
    new $P5505, "Undef"
  vivify_2313:
    $P5506 = $P5504."new"($P5505 :named("value"))
    set $P5494, $P5506
  if_5495_end:
.annotate 'line', 1595
    store_lex "$to_add", $P5494
.annotate 'line', 1602
    find_dynamic_lex $P5526, "$*MULTINESS"
    unless_null $P5526, vivify_2314
    get_hll_global $P5524, "GLOBAL"
    get_who $P5525, $P5524
    set $P5526, $P5525["$MULTINESS"]
    unless_null $P5526, vivify_2315
    die "Contextual $*MULTINESS not found"
  vivify_2315:
  vivify_2314:
    set $S5527, $P5526
    iseq $I5528, $S5527, "proto"
    unless $I5528, if_5523_end
    find_lex $P5529, "$past"
    unless_null $P5529, vivify_2316
    new $P5529, "Undef"
  vivify_2316:
    $P5529."pirflags"(":instanceof(\"DispatcherSub\")")
  if_5523_end:
.annotate 'line', 1606
    find_dynamic_lex $P5533, "$*MULTINESS"
    unless_null $P5533, vivify_2317
    get_hll_global $P5531, "GLOBAL"
    get_who $P5532, $P5531
    set $P5533, $P5532["$MULTINESS"]
    unless_null $P5533, vivify_2318
    die "Contextual $*MULTINESS not found"
  vivify_2318:
  vivify_2317:
    set $S5534, $P5533
    iseq $I5535, $S5534, "multi"
    unless $I5535, if_5530_end
    find_lex $P5536, "$past"
    unless_null $P5536, vivify_2319
    new $P5536, "Undef"
  vivify_2319:
    "attach_multi_signature"($P5536)
  if_5530_end:
.annotate 'line', 1609
    find_dynamic_lex $P5540, "$*PACKAGE-SETUP"
    unless_null $P5540, vivify_2320
    get_hll_global $P5538, "GLOBAL"
    get_who $P5539, $P5538
    set $P5540, $P5539["$PACKAGE-SETUP"]
    unless_null $P5540, vivify_2321
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2321:
  vivify_2320:
    defined $I5541, $P5540
    unless $I5541, if_5537_end
.annotate 'line', 1610
    find_dynamic_lex $P5544, "$*PACKAGE-SETUP"
    unless_null $P5544, vivify_2322
    get_hll_global $P5542, "GLOBAL"
    get_who $P5543, $P5542
    set $P5544, $P5543["$PACKAGE-SETUP"]
    unless_null $P5544, vivify_2323
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2323:
  vivify_2322:
    get_hll_global $P5545, "GLOBAL"
    nqp_get_package_through_who $P5546, $P5545, "PAST"
    get_who $P5547, $P5546
    set $P5548, $P5547["Op"]
.annotate 'line', 1611
    find_dynamic_lex $P5553, "$*MULTINESS"
    unless_null $P5553, vivify_2324
    get_hll_global $P5551, "GLOBAL"
    get_who $P5552, $P5551
    set $P5553, $P5552["$MULTINESS"]
    unless_null $P5553, vivify_2325
    die "Contextual $*MULTINESS not found"
  vivify_2325:
  vivify_2324:
    set $S5554, $P5553
    iseq $I5555, $S5554, "multi"
    if $I5555, if_5550
    new $P5557, "String"
    assign $P5557, "add_method"
    set $P5549, $P5557
    goto if_5550_end
  if_5550:
    new $P5556, "String"
    assign $P5556, "add_multi_method"
    set $P5549, $P5556
  if_5550_end:
.annotate 'line', 1612
    get_hll_global $P5558, "GLOBAL"
    nqp_get_package_through_who $P5559, $P5558, "PAST"
    get_who $P5560, $P5559
    set $P5561, $P5560["Op"]
.annotate 'line', 1615
    get_hll_global $P5562, "GLOBAL"
    nqp_get_package_through_who $P5563, $P5562, "PAST"
    get_who $P5564, $P5563
    set $P5565, $P5564["Var"]
    $P5566 = $P5565."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5567 = $P5561."new"($P5566, "get_how PP" :named("pirop"))
.annotate 'line', 1617
    get_hll_global $P5568, "GLOBAL"
    nqp_get_package_through_who $P5569, $P5568, "PAST"
    get_who $P5570, $P5569
    set $P5571, $P5570["Var"]
    $P5572 = $P5571."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1618
    get_hll_global $P5573, "GLOBAL"
    nqp_get_package_through_who $P5574, $P5573, "PAST"
    get_who $P5575, $P5574
    set $P5576, $P5575["Val"]
    find_lex $P5577, "$name"
    unless_null $P5577, vivify_2326
    new $P5577, "Undef"
  vivify_2326:
    $P5578 = $P5576."new"($P5577 :named("value"))
    find_lex $P5579, "$to_add"
    unless_null $P5579, vivify_2327
    new $P5579, "Undef"
  vivify_2327:
    $P5580 = $P5548."new"($P5567, $P5572, $P5578, $P5579, "callmethod" :named("pasttype"), $P5549 :named("name"))
.annotate 'line', 1610
    $P5544."push"($P5580)
  if_5537_end:
.annotate 'line', 1623
    find_dynamic_lex $P5585, "$*SCOPE"
    unless_null $P5585, vivify_2328
    get_hll_global $P5583, "GLOBAL"
    get_who $P5584, $P5583
    set $P5585, $P5584["$SCOPE"]
    unless_null $P5585, vivify_2329
    die "Contextual $*SCOPE not found"
  vivify_2329:
  vivify_2328:
    set $S5586, $P5585
    iseq $I5587, $S5586, "our"
    if $I5587, if_5582
    new $P5581, 'Integer'
    set $P5581, $I5587
    goto if_5582_end
  if_5582:
.annotate 'line', 1624
    find_dynamic_lex $P5590, "$*SC"
    unless_null $P5590, vivify_2330
    get_hll_global $P5588, "GLOBAL"
    get_who $P5589, $P5588
    set $P5590, $P5589["$SC"]
    unless_null $P5590, vivify_2331
    die "Contextual $*SC not found"
  vivify_2331:
  vivify_2330:
    find_dynamic_lex $P5593, "$*PACKAGE"
    unless_null $P5593, vivify_2332
    get_hll_global $P5591, "GLOBAL"
    get_who $P5592, $P5591
    set $P5593, $P5592["$PACKAGE"]
    unless_null $P5593, vivify_2333
    die "Contextual $*PACKAGE not found"
  vivify_2333:
  vivify_2332:
    find_lex $P5594, "$name"
    unless_null $P5594, vivify_2334
    new $P5594, "Undef"
  vivify_2334:
    find_lex $P5595, "$past"
    unless_null $P5595, vivify_2335
    new $P5595, "Undef"
  vivify_2335:
    $P5590."install_package_routine"($P5593, $P5594, $P5595)
.annotate 'line', 1626
    find_lex $P5596, "$past"
    unless_null $P5596, vivify_2336
    new $P5596, "Undef"
  vivify_2336:
    $P5597 = $P5596."pirflags"(":nsentry")
.annotate 'line', 1623
    set $P5581, $P5597
  if_5582_end:
.annotate 'line', 1588
    .return ($P5581)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5611"  :anon :subid("511_1303739803.72") :outer("509_1303739803.72")
    .param pmc param_5613
.annotate 'line', 1634
    .lex "$_", param_5613
    find_lex $P5614, "$_"
    unless_null $P5614, vivify_2345
    new $P5614, "Undef"
  vivify_2345:
    $P5615 = $P5614."ast"()
    find_lex $P5616, "$/"
    unless_null $P5616, vivify_2346
    new $P5616, "Undef"
  vivify_2346:
    $P5617 = $P5615($P5616)
    .return ($P5617)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("512_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5624
    .param pmc param_5625
.annotate 'line', 1666
    .const 'Sub' $P5668 = "514_1303739803.72" 
    capture_lex $P5668
    .const 'Sub' $P5636 = "513_1303739803.72" 
    capture_lex $P5636
    .lex "self", param_5624
    .lex "$/", param_5625
.annotate 'line', 1667
    new $P5626, "Undef"
    .lex "$BLOCKINIT", $P5626
    find_lex $P5627, "$?PACKAGE"
    get_who $P5628, $P5627
    set $P5629, $P5628["@BLOCK"]
    unless_null $P5629, vivify_2347
    $P5629 = root_new ['parrot';'ResizablePMCArray']
  vivify_2347:
    set $P5630, $P5629[0]
    unless_null $P5630, vivify_2348
    $P5630 = root_new ['parrot';'ResizablePMCArray']
  vivify_2348:
    set $P5631, $P5630[0]
    unless_null $P5631, vivify_2349
    new $P5631, "Undef"
  vivify_2349:
    store_lex "$BLOCKINIT", $P5631
.annotate 'line', 1668
    find_lex $P5633, "$/"
    unless_null $P5633, vivify_2350
    $P5633 = root_new ['parrot';'Hash']
  vivify_2350:
    set $P5634, $P5633["invocant"]
    unless_null $P5634, vivify_2351
    new $P5634, "Undef"
  vivify_2351:
    unless $P5634, if_5632_end
    .const 'Sub' $P5636 = "513_1303739803.72" 
    capture_lex $P5636
    $P5636()
  if_5632_end:
.annotate 'line', 1677
    find_lex $P5663, "$/"
    unless_null $P5663, vivify_2361
    $P5663 = root_new ['parrot';'Hash']
  vivify_2361:
    set $P5664, $P5663["parameter"]
    unless_null $P5664, vivify_2362
    new $P5664, "Undef"
  vivify_2362:
    defined $I5665, $P5664
    unless $I5665, for_undef_2363
    iter $P5662, $P5664
    new $P5675, 'ExceptionHandler'
    set_label $P5675, loop5674_handler
    $P5675."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5675
  loop5674_test:
    unless $P5662, loop5674_done
    shift $P5666, $P5662
  loop5674_redo:
    .const 'Sub' $P5668 = "514_1303739803.72" 
    capture_lex $P5668
    $P5668($P5666)
  loop5674_next:
    goto loop5674_test
  loop5674_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5676, exception, 'type'
    eq $P5676, .CONTROL_LOOP_NEXT, loop5674_next
    eq $P5676, .CONTROL_LOOP_REDO, loop5674_redo
  loop5674_done:
    pop_eh 
  for_undef_2363:
.annotate 'line', 1666
    .return ($P5662)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5635"  :anon :subid("513_1303739803.72") :outer("512_1303739803.72")
.annotate 'line', 1669
    new $P5637, "Undef"
    .lex "$inv", $P5637
    find_lex $P5638, "$/"
    unless_null $P5638, vivify_2352
    $P5638 = root_new ['parrot';'Hash']
  vivify_2352:
    set $P5639, $P5638["invocant"]
    unless_null $P5639, vivify_2353
    $P5639 = root_new ['parrot';'ResizablePMCArray']
  vivify_2353:
    set $P5640, $P5639[0]
    unless_null $P5640, vivify_2354
    new $P5640, "Undef"
  vivify_2354:
    $P5641 = $P5640."ast"()
    store_lex "$inv", $P5641
.annotate 'line', 1670
    find_lex $P5642, "$BLOCKINIT"
    unless_null $P5642, vivify_2355
    new $P5642, "Undef"
  vivify_2355:
    find_lex $P5643, "$inv"
    unless_null $P5643, vivify_2356
    new $P5643, "Undef"
  vivify_2356:
    $P5642."push"($P5643)
.annotate 'line', 1671
    find_lex $P5644, "$BLOCKINIT"
    unless_null $P5644, vivify_2357
    new $P5644, "Undef"
  vivify_2357:
    get_hll_global $P5645, "GLOBAL"
    nqp_get_package_through_who $P5646, $P5645, "PAST"
    get_who $P5647, $P5646
    set $P5648, $P5647["Var"]
.annotate 'line', 1673
    get_hll_global $P5649, "GLOBAL"
    nqp_get_package_through_who $P5650, $P5649, "PAST"
    get_who $P5651, $P5650
    set $P5652, $P5651["Var"]
    find_lex $P5653, "$inv"
    unless_null $P5653, vivify_2358
    new $P5653, "Undef"
  vivify_2358:
    $P5654 = $P5653."name"()
    $P5655 = $P5652."new"("lexical" :named("scope"), $P5654 :named("name"))
    $P5656 = $P5648."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P5655 :named("viviself"))
.annotate 'line', 1671
    $P5644."push"($P5656)
.annotate 'line', 1675
    new $P5657, "Integer"
    assign $P5657, 1
    find_lex $P5658, "$?PACKAGE"
    get_who $P5659, $P5658
    set $P5660, $P5659["@BLOCK"]
    unless_null $P5660, vivify_2359
    $P5660 = root_new ['parrot';'ResizablePMCArray']
    set $P5659["@BLOCK"], $P5660
  vivify_2359:
    set $P5661, $P5660[0]
    unless_null $P5661, vivify_2360
    $P5661 = root_new ['parrot';'Hash']
    set $P5660[0], $P5661
  vivify_2360:
    set $P5661["signature_has_invocant"], $P5657
.annotate 'line', 1668
    .return ($P5657)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5667"  :anon :subid("514_1303739803.72") :outer("512_1303739803.72")
    .param pmc param_5669
.annotate 'line', 1677
    .lex "$_", param_5669
    find_lex $P5670, "$BLOCKINIT"
    unless_null $P5670, vivify_2364
    new $P5670, "Undef"
  vivify_2364:
    find_lex $P5671, "$_"
    unless_null $P5671, vivify_2365
    new $P5671, "Undef"
  vivify_2365:
    $P5672 = $P5671."ast"()
    $P5673 = $P5670."push"($P5672)
    .return ($P5673)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("515_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5678
    .param pmc param_5679
.annotate 'line', 1680
    .lex "self", param_5678
    .lex "$/", param_5679
.annotate 'line', 1681
    new $P5680, "Undef"
    .lex "$quant", $P5680
.annotate 'line', 1682
    new $P5681, "Undef"
    .lex "$past", $P5681
.annotate 'line', 1681
    find_lex $P5682, "$/"
    unless_null $P5682, vivify_2366
    $P5682 = root_new ['parrot';'Hash']
  vivify_2366:
    set $P5683, $P5682["quant"]
    unless_null $P5683, vivify_2367
    new $P5683, "Undef"
  vivify_2367:
    store_lex "$quant", $P5683
    find_lex $P5684, "$past"
    unless_null $P5684, vivify_2368
    new $P5684, "Undef"
  vivify_2368:
.annotate 'line', 1683
    find_lex $P5686, "$/"
    unless_null $P5686, vivify_2369
    $P5686 = root_new ['parrot';'Hash']
  vivify_2369:
    set $P5687, $P5686["named_param"]
    unless_null $P5687, vivify_2370
    new $P5687, "Undef"
  vivify_2370:
    if $P5687, if_5685
.annotate 'line', 1690
    find_lex $P5701, "$/"
    unless_null $P5701, vivify_2371
    $P5701 = root_new ['parrot';'Hash']
  vivify_2371:
    set $P5702, $P5701["param_var"]
    unless_null $P5702, vivify_2372
    new $P5702, "Undef"
  vivify_2372:
    $P5703 = $P5702."ast"()
    store_lex "$past", $P5703
.annotate 'line', 1691
    find_lex $P5705, "$quant"
    unless_null $P5705, vivify_2373
    new $P5705, "Undef"
  vivify_2373:
    set $S5706, $P5705
    iseq $I5707, $S5706, "*"
    if $I5707, if_5704
.annotate 'line', 1695
    find_lex $P5716, "$quant"
    unless_null $P5716, vivify_2374
    new $P5716, "Undef"
  vivify_2374:
    set $S5717, $P5716
    iseq $I5718, $S5717, "?"
    unless $I5718, if_5715_end
.annotate 'line', 1696
    find_lex $P5719, "$past"
    unless_null $P5719, vivify_2375
    new $P5719, "Undef"
  vivify_2375:
    find_lex $P5720, "$/"
    unless_null $P5720, vivify_2376
    $P5720 = root_new ['parrot';'Hash']
  vivify_2376:
    set $P5721, $P5720["param_var"]
    unless_null $P5721, vivify_2377
    $P5721 = root_new ['parrot';'Hash']
  vivify_2377:
    set $P5722, $P5721["sigil"]
    unless_null $P5722, vivify_2378
    new $P5722, "Undef"
  vivify_2378:
    $P5723 = "vivitype"($P5722)
    $P5719."viviself"($P5723)
  if_5715_end:
.annotate 'line', 1695
    goto if_5704_end
  if_5704:
.annotate 'line', 1692
    find_lex $P5708, "$past"
    unless_null $P5708, vivify_2379
    new $P5708, "Undef"
  vivify_2379:
    $P5708."slurpy"(1)
.annotate 'line', 1693
    find_lex $P5709, "$past"
    unless_null $P5709, vivify_2380
    new $P5709, "Undef"
  vivify_2380:
    find_lex $P5710, "$/"
    unless_null $P5710, vivify_2381
    $P5710 = root_new ['parrot';'Hash']
  vivify_2381:
    set $P5711, $P5710["param_var"]
    unless_null $P5711, vivify_2382
    $P5711 = root_new ['parrot';'Hash']
  vivify_2382:
    set $P5712, $P5711["sigil"]
    unless_null $P5712, vivify_2383
    new $P5712, "Undef"
  vivify_2383:
    set $S5713, $P5712
    iseq $I5714, $S5713, "%"
    $P5709."named"($I5714)
  if_5704_end:
.annotate 'line', 1689
    goto if_5685_end
  if_5685:
.annotate 'line', 1684
    find_lex $P5688, "$/"
    unless_null $P5688, vivify_2384
    $P5688 = root_new ['parrot';'Hash']
  vivify_2384:
    set $P5689, $P5688["named_param"]
    unless_null $P5689, vivify_2385
    new $P5689, "Undef"
  vivify_2385:
    $P5690 = $P5689."ast"()
    store_lex "$past", $P5690
.annotate 'line', 1685
    find_lex $P5692, "$quant"
    unless_null $P5692, vivify_2386
    new $P5692, "Undef"
  vivify_2386:
    set $S5693, $P5692
    isne $I5694, $S5693, "!"
    unless $I5694, if_5691_end
.annotate 'line', 1686
    find_lex $P5695, "$past"
    unless_null $P5695, vivify_2387
    new $P5695, "Undef"
  vivify_2387:
    find_lex $P5696, "$/"
    unless_null $P5696, vivify_2388
    $P5696 = root_new ['parrot';'Hash']
  vivify_2388:
    set $P5697, $P5696["named_param"]
    unless_null $P5697, vivify_2389
    $P5697 = root_new ['parrot';'Hash']
  vivify_2389:
    set $P5698, $P5697["param_var"]
    unless_null $P5698, vivify_2390
    $P5698 = root_new ['parrot';'Hash']
  vivify_2390:
    set $P5699, $P5698["sigil"]
    unless_null $P5699, vivify_2391
    new $P5699, "Undef"
  vivify_2391:
    $P5700 = "vivitype"($P5699)
    $P5695."viviself"($P5700)
  if_5691_end:
  if_5685_end:
.annotate 'line', 1699
    find_lex $P5725, "$/"
    unless_null $P5725, vivify_2392
    $P5725 = root_new ['parrot';'Hash']
  vivify_2392:
    set $P5726, $P5725["default_value"]
    unless_null $P5726, vivify_2393
    new $P5726, "Undef"
  vivify_2393:
    unless $P5726, if_5724_end
.annotate 'line', 1700
    find_lex $P5728, "$quant"
    unless_null $P5728, vivify_2394
    new $P5728, "Undef"
  vivify_2394:
    set $S5729, $P5728
    iseq $I5730, $S5729, "*"
    unless $I5730, if_5727_end
.annotate 'line', 1701
    find_lex $P5731, "$/"
    unless_null $P5731, vivify_2395
    new $P5731, "Undef"
  vivify_2395:
    $P5732 = $P5731."CURSOR"()
    $P5732."panic"("Can't put default on slurpy parameter")
  if_5727_end:
.annotate 'line', 1703
    find_lex $P5734, "$quant"
    unless_null $P5734, vivify_2396
    new $P5734, "Undef"
  vivify_2396:
    set $S5735, $P5734
    iseq $I5736, $S5735, "!"
    unless $I5736, if_5733_end
.annotate 'line', 1704
    find_lex $P5737, "$/"
    unless_null $P5737, vivify_2397
    new $P5737, "Undef"
  vivify_2397:
    $P5738 = $P5737."CURSOR"()
    $P5738."panic"("Can't put default on required parameter")
  if_5733_end:
.annotate 'line', 1706
    find_lex $P5739, "$past"
    unless_null $P5739, vivify_2398
    new $P5739, "Undef"
  vivify_2398:
    find_lex $P5740, "$/"
    unless_null $P5740, vivify_2399
    $P5740 = root_new ['parrot';'Hash']
  vivify_2399:
    set $P5741, $P5740["default_value"]
    unless_null $P5741, vivify_2400
    $P5741 = root_new ['parrot';'ResizablePMCArray']
  vivify_2400:
    set $P5742, $P5741[0]
    unless_null $P5742, vivify_2401
    $P5742 = root_new ['parrot';'Hash']
  vivify_2401:
    set $P5743, $P5742["EXPR"]
    unless_null $P5743, vivify_2402
    new $P5743, "Undef"
  vivify_2402:
    $P5744 = $P5743."ast"()
    $P5739."viviself"($P5744)
  if_5724_end:
.annotate 'line', 1708
    find_lex $P5746, "$past"
    unless_null $P5746, vivify_2403
    new $P5746, "Undef"
  vivify_2403:
    $P5747 = $P5746."viviself"()
    if $P5747, unless_5745_end
    find_lex $P5748, "$?PACKAGE"
    get_who $P5749, $P5748
    set $P5750, $P5749["@BLOCK"]
    unless_null $P5750, vivify_2404
    $P5750 = root_new ['parrot';'ResizablePMCArray']
  vivify_2404:
    set $P5751, $P5750[0]
    unless_null $P5751, vivify_2405
    new $P5751, "Undef"
  vivify_2405:
    find_lex $P5752, "$?PACKAGE"
    get_who $P5753, $P5752
    set $P5754, $P5753["@BLOCK"]
    unless_null $P5754, vivify_2406
    $P5754 = root_new ['parrot';'ResizablePMCArray']
  vivify_2406:
    set $P5755, $P5754[0]
    unless_null $P5755, vivify_2407
    new $P5755, "Undef"
  vivify_2407:
    $P5756 = $P5755."arity"()
    set $N5757, $P5756
    new $P5758, 'Float'
    set $P5758, $N5757
    add $P5759, $P5758, 1
    $P5751."arity"($P5759)
  unless_5745_end:
.annotate 'line', 1712
    find_lex $P5761, "$/"
    unless_null $P5761, vivify_2408
    $P5761 = root_new ['parrot';'Hash']
  vivify_2408:
    set $P5762, $P5761["typename"]
    unless_null $P5762, vivify_2409
    new $P5762, "Undef"
  vivify_2409:
    unless $P5762, if_5760_end
.annotate 'line', 1713
    find_lex $P5763, "$past"
    unless_null $P5763, vivify_2410
    new $P5763, "Undef"
  vivify_2410:
    find_lex $P5764, "$/"
    unless_null $P5764, vivify_2411
    $P5764 = root_new ['parrot';'Hash']
  vivify_2411:
    set $P5765, $P5764["typename"]
    unless_null $P5765, vivify_2412
    $P5765 = root_new ['parrot';'ResizablePMCArray']
  vivify_2412:
    set $P5766, $P5765[0]
    unless_null $P5766, vivify_2413
    new $P5766, "Undef"
  vivify_2413:
    $P5767 = $P5766."ast"()
    $P5763."multitype"($P5767)
  if_5760_end:
.annotate 'line', 1717
    find_lex $P5769, "$/"
    unless_null $P5769, vivify_2414
    $P5769 = root_new ['parrot';'Hash']
  vivify_2414:
    set $P5770, $P5769["definedness"]
    unless_null $P5770, vivify_2415
    new $P5770, "Undef"
  vivify_2415:
    unless $P5770, if_5768_end
.annotate 'line', 1718
    find_lex $P5771, "$/"
    unless_null $P5771, vivify_2416
    $P5771 = root_new ['parrot';'Hash']
  vivify_2416:
    set $P5772, $P5771["definedness"]
    unless_null $P5772, vivify_2417
    $P5772 = root_new ['parrot';'ResizablePMCArray']
  vivify_2417:
    set $P5773, $P5772[0]
    unless_null $P5773, vivify_2418
    new $P5773, "Undef"
  vivify_2418:
    set $S5774, $P5773
    new $P5775, 'String'
    set $P5775, $S5774
    find_lex $P5776, "$past"
    unless_null $P5776, vivify_2419
    $P5776 = root_new ['parrot';'Hash']
    store_lex "$past", $P5776
  vivify_2419:
    set $P5776["definedness"], $P5775
  if_5768_end:
.annotate 'line', 1721
    find_lex $P5777, "$/"
    find_lex $P5778, "$past"
    unless_null $P5778, vivify_2420
    new $P5778, "Undef"
  vivify_2420:
    $P5779 = $P5777."!make"($P5778)
.annotate 'line', 1680
    .return ($P5779)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("516_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5781
    .param pmc param_5782
.annotate 'line', 1724
    .lex "self", param_5781
    .lex "$/", param_5782
.annotate 'line', 1725
    new $P5783, "Undef"
    .lex "$name", $P5783
.annotate 'line', 1726
    new $P5784, "Undef"
    .lex "$past", $P5784
.annotate 'line', 1725
    find_lex $P5785, "$/"
    unless_null $P5785, vivify_2421
    new $P5785, "Undef"
  vivify_2421:
    set $S5786, $P5785
    new $P5787, 'String'
    set $P5787, $S5786
    store_lex "$name", $P5787
.annotate 'line', 1726
    get_hll_global $P5788, "GLOBAL"
    nqp_get_package_through_who $P5789, $P5788, "PAST"
    get_who $P5790, $P5789
    set $P5791, $P5790["Var"]
    find_lex $P5792, "$name"
    unless_null $P5792, vivify_2422
    new $P5792, "Undef"
  vivify_2422:
    find_lex $P5793, "$/"
    unless_null $P5793, vivify_2423
    new $P5793, "Undef"
  vivify_2423:
    $P5794 = $P5791."new"($P5792 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P5793 :named("node"))
    store_lex "$past", $P5794
.annotate 'line', 1728
    find_lex $P5795, "$?PACKAGE"
    get_who $P5796, $P5795
    set $P5797, $P5796["@BLOCK"]
    unless_null $P5797, vivify_2424
    $P5797 = root_new ['parrot';'ResizablePMCArray']
  vivify_2424:
    set $P5798, $P5797[0]
    unless_null $P5798, vivify_2425
    new $P5798, "Undef"
  vivify_2425:
    find_lex $P5799, "$name"
    unless_null $P5799, vivify_2426
    new $P5799, "Undef"
  vivify_2426:
    $P5798."symbol"($P5799, "lexical" :named("scope"))
.annotate 'line', 1729
    find_lex $P5800, "$/"
    find_lex $P5801, "$past"
    unless_null $P5801, vivify_2427
    new $P5801, "Undef"
  vivify_2427:
    $P5802 = $P5800."!make"($P5801)
.annotate 'line', 1724
    .return ($P5802)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("517_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5804
    .param pmc param_5805
.annotate 'line', 1732
    .lex "self", param_5804
    .lex "$/", param_5805
.annotate 'line', 1733
    new $P5806, "Undef"
    .lex "$past", $P5806
    find_lex $P5807, "$/"
    unless_null $P5807, vivify_2428
    $P5807 = root_new ['parrot';'Hash']
  vivify_2428:
    set $P5808, $P5807["param_var"]
    unless_null $P5808, vivify_2429
    new $P5808, "Undef"
  vivify_2429:
    $P5809 = $P5808."ast"()
    store_lex "$past", $P5809
.annotate 'line', 1734
    find_lex $P5810, "$past"
    unless_null $P5810, vivify_2430
    new $P5810, "Undef"
  vivify_2430:
    find_lex $P5811, "$/"
    unless_null $P5811, vivify_2431
    $P5811 = root_new ['parrot';'Hash']
  vivify_2431:
    set $P5812, $P5811["param_var"]
    unless_null $P5812, vivify_2432
    $P5812 = root_new ['parrot';'Hash']
  vivify_2432:
    set $P5813, $P5812["name"]
    unless_null $P5813, vivify_2433
    new $P5813, "Undef"
  vivify_2433:
    set $S5814, $P5813
    $P5810."named"($S5814)
.annotate 'line', 1735
    find_lex $P5815, "$/"
    find_lex $P5816, "$past"
    unless_null $P5816, vivify_2434
    new $P5816, "Undef"
  vivify_2434:
    $P5817 = $P5815."!make"($P5816)
.annotate 'line', 1732
    .return ($P5817)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("518_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5819
    .param pmc param_5820
.annotate 'line', 1738
    .lex "self", param_5819
    .lex "$/", param_5820
.annotate 'line', 1739
    $P5821 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P5821
    get_hll_global $P5822, "GLOBAL"
    nqp_get_package_through_who $P5823, $P5822, "HLL"
    get_who $P5824, $P5823
    set $P5825, $P5824["Compiler"]
    find_lex $P5826, "$/"
    unless_null $P5826, vivify_2435
    new $P5826, "Undef"
  vivify_2435:
    set $S5827, $P5826
    $P5828 = $P5825."parse_name"($S5827)
    store_lex "@name", $P5828
.annotate 'line', 1740
    find_lex $P5829, "$/"
    get_hll_global $P5830, "GLOBAL"
    nqp_get_package_through_who $P5831, $P5830, "PAST"
    get_who $P5832, $P5831
    set $P5833, $P5832["Var"]
.annotate 'line', 1741
    find_lex $P5834, "@name"
    unless_null $P5834, vivify_2436
    $P5834 = root_new ['parrot';'ResizablePMCArray']
  vivify_2436:
    $P5835 = $P5834."pop"()
    find_lex $P5836, "@name"
    unless_null $P5836, vivify_2437
    $P5836 = root_new ['parrot';'ResizablePMCArray']
  vivify_2437:
    $P5837 = $P5833."new"($P5835 :named("name"), $P5836 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1740
    $P5838 = $P5829."!make"($P5837)
.annotate 'line', 1738
    .return ($P5838)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("519_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5840
    .param pmc param_5841
.annotate 'line', 1747
    .lex "self", param_5840
    .lex "$/", param_5841
.annotate 'line', 1748
    find_lex $P5842, "$/"
    find_lex $P5843, "$/"
    unless_null $P5843, vivify_2438
    $P5843 = root_new ['parrot';'Hash']
  vivify_2438:
    set $P5844, $P5843["trait_mod"]
    unless_null $P5844, vivify_2439
    new $P5844, "Undef"
  vivify_2439:
    $P5845 = $P5844."ast"()
    $P5846 = $P5842."!make"($P5845)
.annotate 'line', 1747
    .return ($P5846)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("520_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5848
    .param pmc param_5849
.annotate 'line', 1751
    .const 'Sub' $P5872 = "521_1303739803.72" 
    capture_lex $P5872
    .lex "self", param_5848
    .lex "$/", param_5849
.annotate 'line', 1752
    new $P5850, "Undef"
    .lex "$cpast", $P5850
    find_lex $P5851, "$/"
    unless_null $P5851, vivify_2440
    $P5851 = root_new ['parrot';'Hash']
  vivify_2440:
    set $P5852, $P5851["circumfix"]
    unless_null $P5852, vivify_2441
    $P5852 = root_new ['parrot';'ResizablePMCArray']
  vivify_2441:
    set $P5853, $P5852[0]
    unless_null $P5853, vivify_2442
    new $P5853, "Undef"
  vivify_2442:
    $P5854 = $P5853."ast"()
    store_lex "$cpast", $P5854
.annotate 'line', 1753
    find_lex $P5857, "$/"
    unless_null $P5857, vivify_2443
    $P5857 = root_new ['parrot';'Hash']
  vivify_2443:
    set $P5858, $P5857["longname"]
    unless_null $P5858, vivify_2444
    new $P5858, "Undef"
  vivify_2444:
    set $S5859, $P5858
    iseq $I5860, $S5859, "parrot_vtable"
    if $I5860, if_5856
.annotate 'line', 1773
    find_lex $P5914, "$/"
    unless_null $P5914, vivify_2445
    $P5914 = root_new ['parrot';'Hash']
  vivify_2445:
    set $P5915, $P5914["longname"]
    unless_null $P5915, vivify_2446
    new $P5915, "Undef"
  vivify_2446:
    set $S5916, $P5915
    iseq $I5917, $S5916, "pirflags"
    if $I5917, if_5913
.annotate 'line', 1777
    find_lex $P5921, "$/"
    unless_null $P5921, vivify_2447
    new $P5921, "Undef"
  vivify_2447:
    $P5922 = $P5921."CURSOR"()
    new $P5923, 'String'
    set $P5923, "Trait '"
    find_lex $P5924, "$/"
    unless_null $P5924, vivify_2448
    $P5924 = root_new ['parrot';'Hash']
  vivify_2448:
    set $P5925, $P5924["longname"]
    unless_null $P5925, vivify_2449
    new $P5925, "Undef"
  vivify_2449:
    concat $P5926, $P5923, $P5925
    concat $P5927, $P5926, "' not implemented"
    $P5928 = $P5922."panic"($P5927)
.annotate 'line', 1776
    set $P5912, $P5928
.annotate 'line', 1773
    goto if_5913_end
  if_5913:
.annotate 'line', 1774
    find_lex $P5918, "$/"
    unless_null $P5918, vivify_2450
    new $P5918, "Undef"
  vivify_2450:
    $P5919 = $P5918."CURSOR"()
    $P5920 = $P5919."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1773
    set $P5912, $P5920
  if_5913_end:
    set $P5855, $P5912
.annotate 'line', 1753
    goto if_5856_end
  if_5856:
.annotate 'line', 1756
    get_hll_global $P5862, "GLOBAL"
    nqp_get_package_through_who $P5863, $P5862, "PAST"
    get_who $P5864, $P5863
    set $P5865, $P5864["Val"]
    find_lex $P5866, "$cpast"
    unless_null $P5866, vivify_2451
    new $P5866, "Undef"
  vivify_2451:
    $P5867 = $P5865."ACCEPTS"($P5866)
    if $P5867, unless_5861_end
.annotate 'line', 1755
    find_lex $P5868, "$/"
    unless_null $P5868, vivify_2452
    new $P5868, "Undef"
  vivify_2452:
    $P5869 = $P5868."CURSOR"()
    $P5869."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_5861_end:
.annotate 'line', 1757
    find_lex $P5870, "$/"
    .const 'Sub' $P5872 = "521_1303739803.72" 
    newclosure $P5910, $P5872
    $P5911 = $P5870."!make"($P5910)
.annotate 'line', 1753
    set $P5855, $P5911
  if_5856_end:
.annotate 'line', 1751
    .return ($P5855)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5871"  :anon :subid("521_1303739803.72") :outer("520_1303739803.72")
    .param pmc param_5873
.annotate 'line', 1757
    .lex "$match", param_5873
.annotate 'line', 1758
    new $P5874, "Undef"
    .lex "$meth", $P5874
    find_lex $P5875, "$match"
    unless_null $P5875, vivify_2453
    new $P5875, "Undef"
  vivify_2453:
    $P5876 = $P5875."ast"()
    set $P5877, $P5876["block_past"]
    unless_null $P5877, vivify_2454
    new $P5877, "Undef"
  vivify_2454:
    store_lex "$meth", $P5877
.annotate 'line', 1759
    find_dynamic_lex $P5882, "$*PACKAGE-SETUP"
    unless_null $P5882, vivify_2455
    get_hll_global $P5880, "GLOBAL"
    get_who $P5881, $P5880
    set $P5882, $P5881["$PACKAGE-SETUP"]
    unless_null $P5882, vivify_2456
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2456:
  vivify_2455:
    defined $I5883, $P5882
    if $I5883, if_5879
    new $P5878, 'Integer'
    set $P5878, $I5883
    goto if_5879_end
  if_5879:
.annotate 'line', 1760
    find_dynamic_lex $P5886, "$*PACKAGE-SETUP"
    unless_null $P5886, vivify_2457
    get_hll_global $P5884, "GLOBAL"
    get_who $P5885, $P5884
    set $P5886, $P5885["$PACKAGE-SETUP"]
    unless_null $P5886, vivify_2458
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2458:
  vivify_2457:
    get_hll_global $P5887, "GLOBAL"
    nqp_get_package_through_who $P5888, $P5887, "PAST"
    get_who $P5889, $P5888
    set $P5890, $P5889["Op"]
.annotate 'line', 1762
    get_hll_global $P5891, "GLOBAL"
    nqp_get_package_through_who $P5892, $P5891, "PAST"
    get_who $P5893, $P5892
    set $P5894, $P5893["Op"]
.annotate 'line', 1765
    get_hll_global $P5895, "GLOBAL"
    nqp_get_package_through_who $P5896, $P5895, "PAST"
    get_who $P5897, $P5896
    set $P5898, $P5897["Var"]
    $P5899 = $P5898."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5900 = $P5894."new"($P5899, "get_how PP" :named("pirop"))
.annotate 'line', 1767
    get_hll_global $P5901, "GLOBAL"
    nqp_get_package_through_who $P5902, $P5901, "PAST"
    get_who $P5903, $P5902
    set $P5904, $P5903["Var"]
    $P5905 = $P5904."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P5906, "$cpast"
    unless_null $P5906, vivify_2459
    new $P5906, "Undef"
  vivify_2459:
    find_lex $P5907, "$meth"
    unless_null $P5907, vivify_2460
    new $P5907, "Undef"
  vivify_2460:
    $P5908 = $P5890."new"($P5900, $P5905, $P5906, $P5907, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1760
    $P5909 = $P5886."push"($P5908)
.annotate 'line', 1759
    set $P5878, $P5909
  if_5879_end:
.annotate 'line', 1757
    .return ($P5878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("522_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_5932
    .param pmc param_5933
    .param pmc param_5934 :optional
    .param int has_param_5934 :opt_flag
.annotate 'line', 1781
    .const 'Sub' $P6088 = "525_1303739803.72" 
    capture_lex $P6088
    .const 'Sub' $P6050 = "524_1303739803.72" 
    capture_lex $P6050
    .const 'Sub' $P6003 = "523_1303739803.72" 
    capture_lex $P6003
    new $P5931, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5931, control_5930
    push_eh $P5931
    .lex "self", param_5932
    .lex "$/", param_5933
    if has_param_5934, optparam_2461
    new $P5935, "Undef"
    set param_5934, $P5935
  optparam_2461:
    .lex "$key", param_5934
.annotate 'line', 1782
    $P5936 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P5936
.annotate 'line', 1783
    new $P5937, "Undef"
    .lex "$name", $P5937
.annotate 'line', 1784
    new $P5938, "Undef"
    .lex "$past", $P5938
.annotate 'line', 1782
    get_hll_global $P5939, "GLOBAL"
    nqp_get_package_through_who $P5940, $P5939, "Regex"
    nqp_get_package_through_who $P5941, $P5940, "P6Regex"
    nqp_get_package_through_who $P5942, $P5941, "Actions"
    get_who $P5943, $P5942
    set $P5944, $P5943["@MODIFIERS"]
    unless_null $P5944, vivify_2462
    $P5944 = root_new ['parrot';'ResizablePMCArray']
  vivify_2462:
    store_lex "@MODIFIERS", $P5944
.annotate 'line', 1783
    find_lex $P5945, "$/"
    unless_null $P5945, vivify_2463
    $P5945 = root_new ['parrot';'Hash']
  vivify_2463:
    set $P5946, $P5945["deflongname"]
    unless_null $P5946, vivify_2464
    new $P5946, "Undef"
  vivify_2464:
    $P5947 = $P5946."ast"()
    set $S5948, $P5947
    new $P5949, 'String'
    set $P5949, $S5948
    store_lex "$name", $P5949
    find_lex $P5950, "$past"
    unless_null $P5950, vivify_2465
    new $P5950, "Undef"
  vivify_2465:
.annotate 'line', 1785
    find_lex $P5952, "$/"
    unless_null $P5952, vivify_2466
    $P5952 = root_new ['parrot';'Hash']
  vivify_2466:
    set $P5953, $P5952["proto"]
    unless_null $P5953, vivify_2467
    new $P5953, "Undef"
  vivify_2467:
    if $P5953, if_5951
.annotate 'line', 1824
    find_lex $P6046, "$key"
    unless_null $P6046, vivify_2468
    new $P6046, "Undef"
  vivify_2468:
    set $S6047, $P6046
    iseq $I6048, $S6047, "open"
    if $I6048, if_6045
.annotate 'line', 1834
    .const 'Sub' $P6088 = "525_1303739803.72" 
    capture_lex $P6088
    $P6088()
    goto if_6045_end
  if_6045:
.annotate 'line', 1824
    .const 'Sub' $P6050 = "524_1303739803.72" 
    capture_lex $P6050
    $P6050()
  if_6045_end:
    goto if_5951_end
  if_5951:
.annotate 'line', 1787
    get_hll_global $P5954, "GLOBAL"
    nqp_get_package_through_who $P5955, $P5954, "PAST"
    get_who $P5956, $P5955
    set $P5957, $P5956["Stmts"]
.annotate 'line', 1788
    get_hll_global $P5958, "GLOBAL"
    nqp_get_package_through_who $P5959, $P5958, "PAST"
    get_who $P5960, $P5959
    set $P5961, $P5960["Block"]
    find_lex $P5962, "$name"
    unless_null $P5962, vivify_2503
    new $P5962, "Undef"
  vivify_2503:
.annotate 'line', 1789
    get_hll_global $P5963, "GLOBAL"
    nqp_get_package_through_who $P5964, $P5963, "PAST"
    get_who $P5965, $P5964
    set $P5966, $P5965["Op"]
.annotate 'line', 1790
    get_hll_global $P5967, "GLOBAL"
    nqp_get_package_through_who $P5968, $P5967, "PAST"
    get_who $P5969, $P5968
    set $P5970, $P5969["Var"]
    $P5971 = $P5970."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5972, "$name"
    unless_null $P5972, vivify_2504
    new $P5972, "Undef"
  vivify_2504:
    $P5973 = $P5966."new"($P5971, $P5972, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1789
    find_lex $P5974, "$/"
    unless_null $P5974, vivify_2505
    new $P5974, "Undef"
  vivify_2505:
    $P5975 = $P5961."new"($P5973, $P5962 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5974 :named("node"))
.annotate 'line', 1799
    get_hll_global $P5976, "GLOBAL"
    nqp_get_package_through_who $P5977, $P5976, "PAST"
    get_who $P5978, $P5977
    set $P5979, $P5978["Block"]
    new $P5980, "String"
    assign $P5980, "!PREFIX__"
    find_lex $P5981, "$name"
    unless_null $P5981, vivify_2506
    new $P5981, "Undef"
  vivify_2506:
    concat $P5982, $P5980, $P5981
.annotate 'line', 1800
    get_hll_global $P5983, "GLOBAL"
    nqp_get_package_through_who $P5984, $P5983, "PAST"
    get_who $P5985, $P5984
    set $P5986, $P5985["Op"]
.annotate 'line', 1801
    get_hll_global $P5987, "GLOBAL"
    nqp_get_package_through_who $P5988, $P5987, "PAST"
    get_who $P5989, $P5988
    set $P5990, $P5989["Var"]
    $P5991 = $P5990."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5992, "$name"
    unless_null $P5992, vivify_2507
    new $P5992, "Undef"
  vivify_2507:
    $P5993 = $P5986."new"($P5991, $P5992, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1800
    find_lex $P5994, "$/"
    unless_null $P5994, vivify_2508
    new $P5994, "Undef"
  vivify_2508:
    $P5995 = $P5979."new"($P5993, $P5982 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5994 :named("node"))
.annotate 'line', 1799
    $P5996 = $P5957."new"($P5975, $P5995)
.annotate 'line', 1787
    store_lex "$past", $P5996
.annotate 'line', 1811
    find_lex $P5998, "$past"
    unless_null $P5998, vivify_2509
    new $P5998, "Undef"
  vivify_2509:
    $P5999 = $P5998."list"()
    defined $I6000, $P5999
    unless $I6000, for_undef_2510
    iter $P5997, $P5999
    new $P6043, 'ExceptionHandler'
    set_label $P6043, loop6042_handler
    $P6043."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6043
  loop6042_test:
    unless $P5997, loop6042_done
    shift $P6001, $P5997
  loop6042_redo:
    .const 'Sub' $P6003 = "523_1303739803.72" 
    capture_lex $P6003
    $P6003($P6001)
  loop6042_next:
    goto loop6042_test
  loop6042_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6044, exception, 'type'
    eq $P6044, .CONTROL_LOOP_NEXT, loop6042_next
    eq $P6044, .CONTROL_LOOP_REDO, loop6042_redo
  loop6042_done:
    pop_eh 
  for_undef_2510:
  if_5951_end:
.annotate 'line', 1870
    find_lex $P6201, "$/"
    find_lex $P6202, "$past"
    unless_null $P6202, vivify_2515
    new $P6202, "Undef"
  vivify_2515:
    $P6203 = $P6201."!make"($P6202)
.annotate 'line', 1781
    .return ($P6203)
  control_5930:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6204, exception, "payload"
    .return ($P6204)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6087"  :anon :subid("525_1303739803.72") :outer("522_1303739803.72")
.annotate 'line', 1835
    new $P6089, "Undef"
    .lex "$regex", $P6089
.annotate 'line', 1836
    get_hll_global $P6090, "GLOBAL"
    nqp_get_package_through_who $P6091, $P6090, "Regex"
    nqp_get_package_through_who $P6092, $P6091, "P6Regex"
    nqp_get_package_through_who $P6093, $P6092, "Actions"
    get_who $P6094, $P6093
    set $P6095, $P6094["buildsub"]
    find_lex $P6096, "$/"
    unless_null $P6096, vivify_2469
    $P6096 = root_new ['parrot';'Hash']
  vivify_2469:
    set $P6097, $P6096["p6regex"]
    unless_null $P6097, vivify_2470
    new $P6097, "Undef"
  vivify_2470:
    $P6098 = $P6097."ast"()
    find_lex $P6099, "$?PACKAGE"
    get_who $P6100, $P6099
    set $P6101, $P6100["@BLOCK"]
    unless_null $P6101, vivify_2471
    $P6101 = root_new ['parrot';'ResizablePMCArray']
  vivify_2471:
    $P6102 = $P6101."shift"()
    $P6103 = $P6095($P6098, $P6102)
    store_lex "$regex", $P6103
.annotate 'line', 1837
    find_lex $P6104, "$regex"
    unless_null $P6104, vivify_2472
    new $P6104, "Undef"
  vivify_2472:
    find_lex $P6105, "$name"
    unless_null $P6105, vivify_2473
    new $P6105, "Undef"
  vivify_2473:
    $P6104."name"($P6105)
.annotate 'line', 1839
    get_hll_global $P6106, "GLOBAL"
    nqp_get_package_through_who $P6107, $P6106, "PAST"
    get_who $P6108, $P6107
    set $P6109, $P6108["Op"]
.annotate 'line', 1841
    get_hll_global $P6110, "GLOBAL"
    nqp_get_package_through_who $P6111, $P6110, "PAST"
    get_who $P6112, $P6111
    set $P6113, $P6112["Var"]
    new $P6114, "ResizablePMCArray"
    push $P6114, "Regex"
    $P6115 = $P6113."new"("Method" :named("name"), $P6114 :named("namespace"), "package" :named("scope"))
    find_lex $P6116, "$regex"
    unless_null $P6116, vivify_2474
    new $P6116, "Undef"
  vivify_2474:
    $P6117 = $P6109."new"($P6115, $P6116, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1839
    store_lex "$past", $P6117
.annotate 'line', 1844
    find_dynamic_lex $P6121, "$*PACKAGE-SETUP"
    unless_null $P6121, vivify_2475
    get_hll_global $P6119, "GLOBAL"
    get_who $P6120, $P6119
    set $P6121, $P6120["$PACKAGE-SETUP"]
    unless_null $P6121, vivify_2476
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2476:
  vivify_2475:
    defined $I6122, $P6121
    unless $I6122, if_6118_end
.annotate 'line', 1845
    find_dynamic_lex $P6125, "$*PACKAGE-SETUP"
    unless_null $P6125, vivify_2477
    get_hll_global $P6123, "GLOBAL"
    get_who $P6124, $P6123
    set $P6125, $P6124["$PACKAGE-SETUP"]
    unless_null $P6125, vivify_2478
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2478:
  vivify_2477:
    get_hll_global $P6126, "GLOBAL"
    nqp_get_package_through_who $P6127, $P6126, "PAST"
    get_who $P6128, $P6127
    set $P6129, $P6128["Op"]
.annotate 'line', 1847
    get_hll_global $P6130, "GLOBAL"
    nqp_get_package_through_who $P6131, $P6130, "PAST"
    get_who $P6132, $P6131
    set $P6133, $P6132["Op"]
.annotate 'line', 1849
    get_hll_global $P6134, "GLOBAL"
    nqp_get_package_through_who $P6135, $P6134, "PAST"
    get_who $P6136, $P6135
    set $P6137, $P6136["Var"]
    $P6138 = $P6137."new"("type_obj" :named("name"), "register" :named("scope"))
    $P6139 = $P6133."new"($P6138, "get_how PP" :named("pirop"))
.annotate 'line', 1851
    get_hll_global $P6140, "GLOBAL"
    nqp_get_package_through_who $P6141, $P6140, "PAST"
    get_who $P6142, $P6141
    set $P6143, $P6142["Var"]
    $P6144 = $P6143."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1852
    get_hll_global $P6145, "GLOBAL"
    nqp_get_package_through_who $P6146, $P6145, "PAST"
    get_who $P6147, $P6146
    set $P6148, $P6147["Val"]
    find_lex $P6149, "$name"
    unless_null $P6149, vivify_2479
    new $P6149, "Undef"
  vivify_2479:
    $P6150 = $P6148."new"($P6149 :named("value"))
.annotate 'line', 1853
    get_hll_global $P6151, "GLOBAL"
    nqp_get_package_through_who $P6152, $P6151, "PAST"
    get_who $P6153, $P6152
    set $P6154, $P6153["Val"]
    find_lex $P6155, "$regex"
    unless_null $P6155, vivify_2480
    new $P6155, "Undef"
  vivify_2480:
    $P6156 = $P6154."new"($P6155 :named("value"))
    $P6157 = $P6129."new"($P6139, $P6144, $P6150, $P6156, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1845
    $P6125."push"($P6157)
.annotate 'line', 1855
    find_dynamic_lex $P6160, "$*PACKAGE-SETUP"
    unless_null $P6160, vivify_2481
    get_hll_global $P6158, "GLOBAL"
    get_who $P6159, $P6158
    set $P6160, $P6159["$PACKAGE-SETUP"]
    unless_null $P6160, vivify_2482
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2482:
  vivify_2481:
    get_hll_global $P6161, "GLOBAL"
    nqp_get_package_through_who $P6162, $P6161, "PAST"
    get_who $P6163, $P6162
    set $P6164, $P6163["Op"]
.annotate 'line', 1857
    get_hll_global $P6165, "GLOBAL"
    nqp_get_package_through_who $P6166, $P6165, "PAST"
    get_who $P6167, $P6166
    set $P6168, $P6167["Op"]
.annotate 'line', 1859
    get_hll_global $P6169, "GLOBAL"
    nqp_get_package_through_who $P6170, $P6169, "PAST"
    get_who $P6171, $P6170
    set $P6172, $P6171["Var"]
    $P6173 = $P6172."new"("type_obj" :named("name"), "register" :named("scope"))
    $P6174 = $P6168."new"($P6173, "get_how PP" :named("pirop"))
.annotate 'line', 1861
    get_hll_global $P6175, "GLOBAL"
    nqp_get_package_through_who $P6176, $P6175, "PAST"
    get_who $P6177, $P6176
    set $P6178, $P6177["Var"]
    $P6179 = $P6178."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1862
    get_hll_global $P6180, "GLOBAL"
    nqp_get_package_through_who $P6181, $P6180, "PAST"
    get_who $P6182, $P6181
    set $P6183, $P6182["Val"]
    new $P6184, "String"
    assign $P6184, "!PREFIX__"
    find_lex $P6185, "$name"
    unless_null $P6185, vivify_2483
    new $P6185, "Undef"
  vivify_2483:
    concat $P6186, $P6184, $P6185
    $P6187 = $P6183."new"($P6186 :named("value"))
.annotate 'line', 1863
    get_hll_global $P6188, "GLOBAL"
    nqp_get_package_through_who $P6189, $P6188, "PAST"
    get_who $P6190, $P6189
    set $P6191, $P6190["Var"]
    new $P6192, "String"
    assign $P6192, "!PREFIX__"
    find_lex $P6193, "$name"
    unless_null $P6193, vivify_2484
    new $P6193, "Undef"
  vivify_2484:
    concat $P6194, $P6192, $P6193
    $P6195 = $P6191."new"($P6194 :named("name"), "package" :named("scope"))
    $P6196 = $P6164."new"($P6174, $P6179, $P6187, $P6195, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1855
    $P6160."push"($P6196)
  if_6118_end:
.annotate 'line', 1867
    find_lex $P6197, "$regex"
    unless_null $P6197, vivify_2485
    new $P6197, "Undef"
  vivify_2485:
    find_lex $P6198, "$past"
    unless_null $P6198, vivify_2486
    $P6198 = root_new ['parrot';'Hash']
    store_lex "$past", $P6198
  vivify_2486:
    set $P6198["sink"], $P6197
.annotate 'line', 1868
    find_lex $P6199, "@MODIFIERS"
    unless_null $P6199, vivify_2487
    $P6199 = root_new ['parrot';'ResizablePMCArray']
  vivify_2487:
    $P6200 = $P6199."shift"()
.annotate 'line', 1834
    .return ($P6200)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6049"  :anon :subid("524_1303739803.72") :outer("522_1303739803.72")
.annotate 'line', 1825
    $P6051 = root_new ['parrot';'Hash']
    .lex "%h", $P6051
.annotate 'line', 1824
    find_lex $P6052, "%h"
    unless_null $P6052, vivify_2488
    $P6052 = root_new ['parrot';'Hash']
  vivify_2488:
.annotate 'line', 1826
    find_lex $P6054, "$/"
    unless_null $P6054, vivify_2489
    $P6054 = root_new ['parrot';'Hash']
  vivify_2489:
    set $P6055, $P6054["sym"]
    unless_null $P6055, vivify_2490
    new $P6055, "Undef"
  vivify_2490:
    set $S6056, $P6055
    iseq $I6057, $S6056, "token"
    unless $I6057, if_6053_end
    new $P6058, "Integer"
    assign $P6058, 1
    find_lex $P6059, "%h"
    unless_null $P6059, vivify_2491
    $P6059 = root_new ['parrot';'Hash']
    store_lex "%h", $P6059
  vivify_2491:
    set $P6059["r"], $P6058
  if_6053_end:
.annotate 'line', 1827
    find_lex $P6061, "$/"
    unless_null $P6061, vivify_2492
    $P6061 = root_new ['parrot';'Hash']
  vivify_2492:
    set $P6062, $P6061["sym"]
    unless_null $P6062, vivify_2493
    new $P6062, "Undef"
  vivify_2493:
    set $S6063, $P6062
    iseq $I6064, $S6063, "rule"
    unless $I6064, if_6060_end
    new $P6065, "Integer"
    assign $P6065, 1
    find_lex $P6066, "%h"
    unless_null $P6066, vivify_2494
    $P6066 = root_new ['parrot';'Hash']
    store_lex "%h", $P6066
  vivify_2494:
    set $P6066["r"], $P6065
    new $P6067, "Integer"
    assign $P6067, 1
    find_lex $P6068, "%h"
    unless_null $P6068, vivify_2495
    $P6068 = root_new ['parrot';'Hash']
    store_lex "%h", $P6068
  vivify_2495:
    set $P6068["s"], $P6067
  if_6060_end:
.annotate 'line', 1828
    find_lex $P6069, "@MODIFIERS"
    unless_null $P6069, vivify_2496
    $P6069 = root_new ['parrot';'ResizablePMCArray']
  vivify_2496:
    find_lex $P6070, "%h"
    unless_null $P6070, vivify_2497
    $P6070 = root_new ['parrot';'Hash']
  vivify_2497:
    $P6069."unshift"($P6070)
.annotate 'line', 1829
    find_lex $P6071, "$name"
    unless_null $P6071, vivify_2498
    new $P6071, "Undef"
  vivify_2498:
    get_hll_global $P6072, "GLOBAL"
    nqp_get_package_through_who $P6073, $P6072, "Regex"
    nqp_get_package_through_who $P6074, $P6073, "P6Regex"
    nqp_get_package_through_who $P6075, $P6074, "Actions"
    get_who $P6076, $P6075
    set $P6076["$REGEXNAME"], $P6071
.annotate 'line', 1830
    find_lex $P6077, "$?PACKAGE"
    get_who $P6078, $P6077
    set $P6079, $P6078["@BLOCK"]
    unless_null $P6079, vivify_2499
    $P6079 = root_new ['parrot';'ResizablePMCArray']
  vivify_2499:
    set $P6080, $P6079[0]
    unless_null $P6080, vivify_2500
    new $P6080, "Undef"
  vivify_2500:
    $P6080."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1831
    find_lex $P6081, "$?PACKAGE"
    get_who $P6082, $P6081
    set $P6083, $P6082["@BLOCK"]
    unless_null $P6083, vivify_2501
    $P6083 = root_new ['parrot';'ResizablePMCArray']
  vivify_2501:
    set $P6084, $P6083[0]
    unless_null $P6084, vivify_2502
    new $P6084, "Undef"
  vivify_2502:
    $P6084."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1832
    new $P6085, "Exception"
    set $P6085['type'], .CONTROL_RETURN
    new $P6086, "Integer"
    assign $P6086, 0
    setattribute $P6085, 'payload', $P6086
    throw $P6085
.annotate 'line', 1824
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6002"  :anon :subid("523_1303739803.72") :outer("522_1303739803.72")
    .param pmc param_6004
.annotate 'line', 1811
    .lex "$_", param_6004
.annotate 'line', 1812
    find_dynamic_lex $P6007, "$*PACKAGE-SETUP"
    unless_null $P6007, vivify_2511
    get_hll_global $P6005, "GLOBAL"
    get_who $P6006, $P6005
    set $P6007, $P6006["$PACKAGE-SETUP"]
    unless_null $P6007, vivify_2512
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2512:
  vivify_2511:
    get_hll_global $P6008, "GLOBAL"
    nqp_get_package_through_who $P6009, $P6008, "PAST"
    get_who $P6010, $P6009
    set $P6011, $P6010["Op"]
.annotate 'line', 1814
    get_hll_global $P6012, "GLOBAL"
    nqp_get_package_through_who $P6013, $P6012, "PAST"
    get_who $P6014, $P6013
    set $P6015, $P6014["Op"]
.annotate 'line', 1816
    get_hll_global $P6016, "GLOBAL"
    nqp_get_package_through_who $P6017, $P6016, "PAST"
    get_who $P6018, $P6017
    set $P6019, $P6018["Var"]
    $P6020 = $P6019."new"("type_obj" :named("name"), "register" :named("scope"))
    $P6021 = $P6015."new"($P6020, "get_how PP" :named("pirop"))
.annotate 'line', 1818
    get_hll_global $P6022, "GLOBAL"
    nqp_get_package_through_who $P6023, $P6022, "PAST"
    get_who $P6024, $P6023
    set $P6025, $P6024["Var"]
    $P6026 = $P6025."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1819
    get_hll_global $P6027, "GLOBAL"
    nqp_get_package_through_who $P6028, $P6027, "PAST"
    get_who $P6029, $P6028
    set $P6030, $P6029["Val"]
    find_lex $P6031, "$_"
    unless_null $P6031, vivify_2513
    new $P6031, "Undef"
  vivify_2513:
    $P6032 = $P6031."name"()
    $P6033 = $P6030."new"($P6032 :named("value"))
.annotate 'line', 1820
    get_hll_global $P6034, "GLOBAL"
    nqp_get_package_through_who $P6035, $P6034, "PAST"
    get_who $P6036, $P6035
    set $P6037, $P6036["Val"]
    find_lex $P6038, "$_"
    unless_null $P6038, vivify_2514
    new $P6038, "Undef"
  vivify_2514:
    $P6039 = $P6037."new"($P6038 :named("value"))
    $P6040 = $P6011."new"($P6021, $P6026, $P6033, $P6039, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1812
    $P6041 = $P6007."push"($P6040)
.annotate 'line', 1811
    .return ($P6041)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("526_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6206
    .param pmc param_6207
.annotate 'line', 1874
    .lex "self", param_6206
    .lex "$/", param_6207
.annotate 'line', 1875
    new $P6208, "Undef"
    .lex "$past", $P6208
    find_lex $P6211, "$/"
    unless_null $P6211, vivify_2516
    $P6211 = root_new ['parrot';'Hash']
  vivify_2516:
    set $P6212, $P6211["args"]
    unless_null $P6212, vivify_2517
    new $P6212, "Undef"
  vivify_2517:
    if $P6212, if_6210
    get_hll_global $P6217, "GLOBAL"
    nqp_get_package_through_who $P6218, $P6217, "PAST"
    get_who $P6219, $P6218
    set $P6220, $P6219["Op"]
    find_lex $P6221, "$/"
    unless_null $P6221, vivify_2518
    new $P6221, "Undef"
  vivify_2518:
    $P6222 = $P6220."new"($P6221 :named("node"))
    set $P6209, $P6222
    goto if_6210_end
  if_6210:
    find_lex $P6213, "$/"
    unless_null $P6213, vivify_2519
    $P6213 = root_new ['parrot';'Hash']
  vivify_2519:
    set $P6214, $P6213["args"]
    unless_null $P6214, vivify_2520
    $P6214 = root_new ['parrot';'ResizablePMCArray']
  vivify_2520:
    set $P6215, $P6214[0]
    unless_null $P6215, vivify_2521
    new $P6215, "Undef"
  vivify_2521:
    $P6216 = $P6215."ast"()
    set $P6209, $P6216
  if_6210_end:
    store_lex "$past", $P6209
.annotate 'line', 1876
    find_lex $P6224, "$/"
    unless_null $P6224, vivify_2522
    $P6224 = root_new ['parrot';'Hash']
  vivify_2522:
    set $P6225, $P6224["quote"]
    unless_null $P6225, vivify_2523
    new $P6225, "Undef"
  vivify_2523:
    if $P6225, if_6223
.annotate 'line', 1880
    find_lex $P6232, "$/"
    unless_null $P6232, vivify_2524
    $P6232 = root_new ['parrot';'Hash']
  vivify_2524:
    set $P6233, $P6232["longname"]
    unless_null $P6233, vivify_2525
    new $P6233, "Undef"
  vivify_2525:
    set $S6234, $P6233
    iseq $I6235, $S6234, "HOW"
    if $I6235, if_6231
.annotate 'line', 1883
    find_lex $P6238, "$/"
    unless_null $P6238, vivify_2526
    $P6238 = root_new ['parrot';'Hash']
  vivify_2526:
    set $P6239, $P6238["longname"]
    unless_null $P6239, vivify_2527
    new $P6239, "Undef"
  vivify_2527:
    set $S6240, $P6239
    iseq $I6241, $S6240, "WHAT"
    if $I6241, if_6237
.annotate 'line', 1886
    find_lex $P6244, "$/"
    unless_null $P6244, vivify_2528
    $P6244 = root_new ['parrot';'Hash']
  vivify_2528:
    set $P6245, $P6244["longname"]
    unless_null $P6245, vivify_2529
    new $P6245, "Undef"
  vivify_2529:
    set $S6246, $P6245
    iseq $I6247, $S6246, "WHO"
    if $I6247, if_6243
.annotate 'line', 1890
    find_lex $P6249, "$past"
    unless_null $P6249, vivify_2530
    new $P6249, "Undef"
  vivify_2530:
    find_lex $P6250, "$/"
    unless_null $P6250, vivify_2531
    $P6250 = root_new ['parrot';'Hash']
  vivify_2531:
    set $P6251, $P6250["longname"]
    unless_null $P6251, vivify_2532
    new $P6251, "Undef"
  vivify_2532:
    set $S6252, $P6251
    $P6249."name"($S6252)
.annotate 'line', 1891
    find_lex $P6253, "$past"
    unless_null $P6253, vivify_2533
    new $P6253, "Undef"
  vivify_2533:
    $P6253."pasttype"("callmethod")
.annotate 'line', 1889
    goto if_6243_end
  if_6243:
.annotate 'line', 1887
    find_lex $P6248, "$past"
    unless_null $P6248, vivify_2534
    new $P6248, "Undef"
  vivify_2534:
    $P6248."pirop"("get_who PP")
  if_6243_end:
.annotate 'line', 1886
    goto if_6237_end
  if_6237:
.annotate 'line', 1884
    find_lex $P6242, "$past"
    unless_null $P6242, vivify_2535
    new $P6242, "Undef"
  vivify_2535:
    $P6242."pirop"("get_what PP")
  if_6237_end:
.annotate 'line', 1883
    goto if_6231_end
  if_6231:
.annotate 'line', 1881
    find_lex $P6236, "$past"
    unless_null $P6236, vivify_2536
    new $P6236, "Undef"
  vivify_2536:
    $P6236."pirop"("get_how PP")
  if_6231_end:
.annotate 'line', 1880
    goto if_6223_end
  if_6223:
.annotate 'line', 1877
    find_lex $P6226, "$past"
    unless_null $P6226, vivify_2537
    new $P6226, "Undef"
  vivify_2537:
    find_lex $P6227, "$/"
    unless_null $P6227, vivify_2538
    $P6227 = root_new ['parrot';'Hash']
  vivify_2538:
    set $P6228, $P6227["quote"]
    unless_null $P6228, vivify_2539
    new $P6228, "Undef"
  vivify_2539:
    $P6229 = $P6228."ast"()
    $P6226."name"($P6229)
.annotate 'line', 1878
    find_lex $P6230, "$past"
    unless_null $P6230, vivify_2540
    new $P6230, "Undef"
  vivify_2540:
    $P6230."pasttype"("callmethod")
  if_6223_end:
.annotate 'line', 1893
    find_lex $P6254, "$/"
    find_lex $P6255, "$past"
    unless_null $P6255, vivify_2541
    new $P6255, "Undef"
  vivify_2541:
    $P6256 = $P6254."!make"($P6255)
.annotate 'line', 1874
    .return ($P6256)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("527_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6258
    .param pmc param_6259
.annotate 'line', 1898
    .lex "self", param_6258
    .lex "$/", param_6259
.annotate 'line', 1899
    find_lex $P6260, "$/"
    get_hll_global $P6261, "GLOBAL"
    nqp_get_package_through_who $P6262, $P6261, "PAST"
    get_who $P6263, $P6262
    set $P6264, $P6263["Var"]
    $P6265 = $P6264."new"("self" :named("name"))
    $P6266 = $P6260."!make"($P6265)
.annotate 'line', 1898
    .return ($P6266)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("528_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6268
    .param pmc param_6269
.annotate 'line', 1902
    .lex "self", param_6268
    .lex "$/", param_6269
.annotate 'line', 1903
    new $P6270, "Undef"
    .lex "$past", $P6270
    find_lex $P6271, "$/"
    unless_null $P6271, vivify_2542
    $P6271 = root_new ['parrot';'Hash']
  vivify_2542:
    set $P6272, $P6271["args"]
    unless_null $P6272, vivify_2543
    new $P6272, "Undef"
  vivify_2543:
    $P6273 = $P6272."ast"()
    store_lex "$past", $P6273
.annotate 'line', 1904
    find_lex $P6274, "$past"
    unless_null $P6274, vivify_2544
    new $P6274, "Undef"
  vivify_2544:
    find_lex $P6275, "$/"
    unless_null $P6275, vivify_2545
    $P6275 = root_new ['parrot';'Hash']
  vivify_2545:
    set $P6276, $P6275["deflongname"]
    unless_null $P6276, vivify_2546
    new $P6276, "Undef"
  vivify_2546:
    set $S6277, $P6276
    $P6274."name"($S6277)
.annotate 'line', 1905
    find_lex $P6278, "$/"
    find_lex $P6279, "$past"
    unless_null $P6279, vivify_2547
    new $P6279, "Undef"
  vivify_2547:
    $P6280 = $P6278."!make"($P6279)
.annotate 'line', 1902
    .return ($P6280)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("529_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6282
    .param pmc param_6283
.annotate 'line', 1908
    .const 'Sub' $P6301 = "530_1303739803.72" 
    capture_lex $P6301
    .lex "self", param_6282
    .lex "$/", param_6283
.annotate 'line', 1910
    new $P6284, "Undef"
    .lex "$var", $P6284
.annotate 'line', 1920
    new $P6285, "Undef"
    .lex "$past", $P6285
.annotate 'line', 1908
    find_lex $P6286, "$var"
    unless_null $P6286, vivify_2548
    new $P6286, "Undef"
  vivify_2548:
.annotate 'line', 1911
    find_lex $P6288, "$/"
    unless_null $P6288, vivify_2549
    $P6288 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P6289, $P6288["name"]
    unless_null $P6289, vivify_2550
    new $P6289, "Undef"
  vivify_2550:
    set $S6290, $P6289
    $P6291 = "is_lexical"($S6290)
    if $P6291, if_6287
.annotate 'line', 1914
    .const 'Sub' $P6301 = "530_1303739803.72" 
    capture_lex $P6301
    $P6301()
    goto if_6287_end
  if_6287:
.annotate 'line', 1912
    get_hll_global $P6292, "GLOBAL"
    nqp_get_package_through_who $P6293, $P6292, "PAST"
    get_who $P6294, $P6293
    set $P6295, $P6294["Var"]
    find_lex $P6296, "$/"
    unless_null $P6296, vivify_2556
    $P6296 = root_new ['parrot';'Hash']
  vivify_2556:
    set $P6297, $P6296["name"]
    unless_null $P6297, vivify_2557
    new $P6297, "Undef"
  vivify_2557:
    set $S6298, $P6297
    $P6299 = $P6295."new"($S6298 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P6299
  if_6287_end:
.annotate 'line', 1920
    find_lex $P6310, "$var"
    unless_null $P6310, vivify_2558
    new $P6310, "Undef"
  vivify_2558:
    store_lex "$past", $P6310
.annotate 'line', 1921
    find_lex $P6312, "$/"
    unless_null $P6312, vivify_2559
    $P6312 = root_new ['parrot';'Hash']
  vivify_2559:
    set $P6313, $P6312["args"]
    unless_null $P6313, vivify_2560
    new $P6313, "Undef"
  vivify_2560:
    unless $P6313, if_6311_end
.annotate 'line', 1922
    find_lex $P6314, "$/"
    unless_null $P6314, vivify_2561
    $P6314 = root_new ['parrot';'Hash']
  vivify_2561:
    set $P6315, $P6314["args"]
    unless_null $P6315, vivify_2562
    $P6315 = root_new ['parrot';'ResizablePMCArray']
  vivify_2562:
    set $P6316, $P6315[0]
    unless_null $P6316, vivify_2563
    new $P6316, "Undef"
  vivify_2563:
    $P6317 = $P6316."ast"()
    store_lex "$past", $P6317
.annotate 'line', 1923
    find_lex $P6318, "$past"
    unless_null $P6318, vivify_2564
    new $P6318, "Undef"
  vivify_2564:
    find_lex $P6319, "$var"
    unless_null $P6319, vivify_2565
    new $P6319, "Undef"
  vivify_2565:
    $P6318."unshift"($P6319)
  if_6311_end:
.annotate 'line', 1925
    find_lex $P6320, "$/"
    find_lex $P6321, "$past"
    unless_null $P6321, vivify_2566
    new $P6321, "Undef"
  vivify_2566:
    $P6322 = $P6320."!make"($P6321)
.annotate 'line', 1908
    .return ($P6322)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6300"  :anon :subid("530_1303739803.72") :outer("529_1303739803.72")
.annotate 'line', 1915
    $P6302 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P6302
    find_lex $P6303, "$/"
    unless_null $P6303, vivify_2551
    $P6303 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P6304, $P6303["name"]
    unless_null $P6304, vivify_2552
    $P6304 = root_new ['parrot';'Hash']
  vivify_2552:
    set $P6305, $P6304["identifier"]
    unless_null $P6305, vivify_2553
    new $P6305, "Undef"
  vivify_2553:
    clone $P6306, $P6305
    store_lex "@ns", $P6306
.annotate 'line', 1916
    find_lex $P6307, "@ns"
    unless_null $P6307, vivify_2554
    $P6307 = root_new ['parrot';'ResizablePMCArray']
  vivify_2554:
    find_lex $P6308, "$/"
    unless_null $P6308, vivify_2555
    new $P6308, "Undef"
  vivify_2555:
    $P6309 = "lexical_package_lookup"($P6307, $P6308)
    store_lex "$var", $P6309
.annotate 'line', 1914
    .return ($P6309)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("531_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6324
    .param pmc param_6325
.annotate 'line', 1928
    .lex "self", param_6324
    .lex "$/", param_6325
.annotate 'line', 1929
    new $P6326, "Undef"
    .lex "$past", $P6326
.annotate 'line', 1930
    new $P6327, "Undef"
    .lex "$pirop", $P6327
.annotate 'line', 1929
    find_lex $P6330, "$/"
    unless_null $P6330, vivify_2567
    $P6330 = root_new ['parrot';'Hash']
  vivify_2567:
    set $P6331, $P6330["args"]
    unless_null $P6331, vivify_2568
    new $P6331, "Undef"
  vivify_2568:
    if $P6331, if_6329
    get_hll_global $P6336, "GLOBAL"
    nqp_get_package_through_who $P6337, $P6336, "PAST"
    get_who $P6338, $P6337
    set $P6339, $P6338["Op"]
    find_lex $P6340, "$/"
    unless_null $P6340, vivify_2569
    new $P6340, "Undef"
  vivify_2569:
    $P6341 = $P6339."new"($P6340 :named("node"))
    set $P6328, $P6341
    goto if_6329_end
  if_6329:
    find_lex $P6332, "$/"
    unless_null $P6332, vivify_2570
    $P6332 = root_new ['parrot';'Hash']
  vivify_2570:
    set $P6333, $P6332["args"]
    unless_null $P6333, vivify_2571
    $P6333 = root_new ['parrot';'ResizablePMCArray']
  vivify_2571:
    set $P6334, $P6333[0]
    unless_null $P6334, vivify_2572
    new $P6334, "Undef"
  vivify_2572:
    $P6335 = $P6334."ast"()
    set $P6328, $P6335
  if_6329_end:
    store_lex "$past", $P6328
.annotate 'line', 1930
    find_lex $P6342, "$/"
    unless_null $P6342, vivify_2573
    $P6342 = root_new ['parrot';'Hash']
  vivify_2573:
    set $P6343, $P6342["op"]
    unless_null $P6343, vivify_2574
    new $P6343, "Undef"
  vivify_2574:
    set $S6344, $P6343
    new $P6345, 'String'
    set $P6345, $S6344
    store_lex "$pirop", $P6345
.annotate 'line', 1931
    find_lex $P6346, "$pirop"
    unless_null $P6346, vivify_2575
    new $P6346, "Undef"
  vivify_2575:
    set $S6347, $P6346
    split $P6348, "__", $S6347
    join $S6349, " ", $P6348
    new $P6350, 'String'
    set $P6350, $S6349
    store_lex "$pirop", $P6350
.annotate 'line', 1932
    find_lex $P6351, "$past"
    unless_null $P6351, vivify_2576
    new $P6351, "Undef"
  vivify_2576:
    find_lex $P6352, "$pirop"
    unless_null $P6352, vivify_2577
    new $P6352, "Undef"
  vivify_2577:
    $P6351."pirop"($P6352)
.annotate 'line', 1933
    find_lex $P6353, "$past"
    unless_null $P6353, vivify_2578
    new $P6353, "Undef"
  vivify_2578:
    $P6353."pasttype"("pirop")
.annotate 'line', 1934
    find_lex $P6354, "$/"
    find_lex $P6355, "$past"
    unless_null $P6355, vivify_2579
    new $P6355, "Undef"
  vivify_2579:
    $P6356 = $P6354."!make"($P6355)
.annotate 'line', 1928
    .return ($P6356)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("532_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6358
    .param pmc param_6359
.annotate 'line', 1937
    .lex "self", param_6358
    .lex "$/", param_6359
.annotate 'line', 1938
    find_lex $P6360, "$/"
    get_hll_global $P6361, "GLOBAL"
    nqp_get_package_through_who $P6362, $P6361, "PAST"
    get_who $P6363, $P6362
    set $P6364, $P6363["Op"]
    $P6365 = $P6364."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P6366 = $P6360."!make"($P6365)
.annotate 'line', 1937
    .return ($P6366)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("533_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6368
    .param pmc param_6369
.annotate 'line', 1943
    .lex "self", param_6368
    .lex "$/", param_6369
    find_lex $P6370, "$/"
    find_lex $P6371, "$/"
    unless_null $P6371, vivify_2580
    $P6371 = root_new ['parrot';'Hash']
  vivify_2580:
    set $P6372, $P6371["arglist"]
    unless_null $P6372, vivify_2581
    new $P6372, "Undef"
  vivify_2581:
    $P6373 = $P6372."ast"()
    $P6374 = $P6370."!make"($P6373)
    .return ($P6374)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("534_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6376
    .param pmc param_6377
.annotate 'line', 1945
    .const 'Sub' $P6391 = "535_1303739803.72" 
    capture_lex $P6391
    .lex "self", param_6376
    .lex "$/", param_6377
.annotate 'line', 1946
    new $P6378, "Undef"
    .lex "$past", $P6378
.annotate 'line', 1954
    new $P6379, "Undef"
    .lex "$i", $P6379
.annotate 'line', 1955
    new $P6380, "Undef"
    .lex "$n", $P6380
.annotate 'line', 1946
    get_hll_global $P6381, "GLOBAL"
    nqp_get_package_through_who $P6382, $P6381, "PAST"
    get_who $P6383, $P6382
    set $P6384, $P6383["Op"]
    find_lex $P6385, "$/"
    unless_null $P6385, vivify_2582
    new $P6385, "Undef"
  vivify_2582:
    $P6386 = $P6384."new"("call" :named("pasttype"), $P6385 :named("node"))
    store_lex "$past", $P6386
.annotate 'line', 1947
    find_lex $P6388, "$/"
    unless_null $P6388, vivify_2583
    $P6388 = root_new ['parrot';'Hash']
  vivify_2583:
    set $P6389, $P6388["EXPR"]
    unless_null $P6389, vivify_2584
    new $P6389, "Undef"
  vivify_2584:
    unless $P6389, if_6387_end
    .const 'Sub' $P6391 = "535_1303739803.72" 
    capture_lex $P6391
    $P6391()
  if_6387_end:
.annotate 'line', 1954
    new $P6423, "Integer"
    assign $P6423, 0
    store_lex "$i", $P6423
.annotate 'line', 1955
    find_lex $P6424, "$past"
    unless_null $P6424, vivify_2595
    new $P6424, "Undef"
  vivify_2595:
    $P6425 = $P6424."list"()
    set $N6426, $P6425
    new $P6427, 'Float'
    set $P6427, $N6426
    store_lex "$n", $P6427
.annotate 'line', 1956
    new $P6478, 'ExceptionHandler'
    set_label $P6478, loop6477_handler
    $P6478."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6478
  loop6477_test:
    find_lex $P6428, "$i"
    unless_null $P6428, vivify_2596
    new $P6428, "Undef"
  vivify_2596:
    set $N6429, $P6428
    find_lex $P6430, "$n"
    unless_null $P6430, vivify_2597
    new $P6430, "Undef"
  vivify_2597:
    set $N6431, $P6430
    islt $I6432, $N6429, $N6431
    unless $I6432, loop6477_done
  loop6477_redo:
.annotate 'line', 1957
    find_lex $P6434, "$i"
    unless_null $P6434, vivify_2598
    new $P6434, "Undef"
  vivify_2598:
    set $I6435, $P6434
    find_lex $P6436, "$past"
    unless_null $P6436, vivify_2599
    $P6436 = root_new ['parrot';'ResizablePMCArray']
  vivify_2599:
    set $P6437, $P6436[$I6435]
    unless_null $P6437, vivify_2600
    new $P6437, "Undef"
  vivify_2600:
    $S6438 = $P6437."name"()
    iseq $I6439, $S6438, "&prefix:<|>"
    unless $I6439, if_6433_end
.annotate 'line', 1958
    find_lex $P6440, "$i"
    unless_null $P6440, vivify_2601
    new $P6440, "Undef"
  vivify_2601:
    set $I6441, $P6440
    find_lex $P6442, "$past"
    unless_null $P6442, vivify_2602
    $P6442 = root_new ['parrot';'ResizablePMCArray']
  vivify_2602:
    set $P6443, $P6442[$I6441]
    unless_null $P6443, vivify_2603
    $P6443 = root_new ['parrot';'ResizablePMCArray']
  vivify_2603:
    set $P6444, $P6443[0]
    unless_null $P6444, vivify_2604
    new $P6444, "Undef"
  vivify_2604:
    find_lex $P6445, "$i"
    unless_null $P6445, vivify_2605
    new $P6445, "Undef"
  vivify_2605:
    set $I6446, $P6445
    find_lex $P6447, "$past"
    unless_null $P6447, vivify_2606
    $P6447 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P6447
  vivify_2606:
    set $P6447[$I6446], $P6444
.annotate 'line', 1959
    find_lex $P6448, "$i"
    unless_null $P6448, vivify_2607
    new $P6448, "Undef"
  vivify_2607:
    set $I6449, $P6448
    find_lex $P6450, "$past"
    unless_null $P6450, vivify_2608
    $P6450 = root_new ['parrot';'ResizablePMCArray']
  vivify_2608:
    set $P6451, $P6450[$I6449]
    unless_null $P6451, vivify_2609
    new $P6451, "Undef"
  vivify_2609:
    $P6451."flat"(1)
.annotate 'line', 1960
    find_lex $P6455, "$i"
    unless_null $P6455, vivify_2610
    new $P6455, "Undef"
  vivify_2610:
    set $I6456, $P6455
    find_lex $P6457, "$past"
    unless_null $P6457, vivify_2611
    $P6457 = root_new ['parrot';'ResizablePMCArray']
  vivify_2611:
    set $P6458, $P6457[$I6456]
    unless_null $P6458, vivify_2612
    new $P6458, "Undef"
  vivify_2612:
    get_hll_global $P6459, "GLOBAL"
    nqp_get_package_through_who $P6460, $P6459, "PAST"
    get_who $P6461, $P6460
    set $P6462, $P6461["Val"]
    $P6463 = $P6458."isa"($P6462)
    if $P6463, if_6454
    set $P6453, $P6463
    goto if_6454_end
  if_6454:
.annotate 'line', 1961
    find_lex $P6464, "$i"
    unless_null $P6464, vivify_2613
    new $P6464, "Undef"
  vivify_2613:
    set $I6465, $P6464
    find_lex $P6466, "$past"
    unless_null $P6466, vivify_2614
    $P6466 = root_new ['parrot';'ResizablePMCArray']
  vivify_2614:
    set $P6467, $P6466[$I6465]
    unless_null $P6467, vivify_2615
    new $P6467, "Undef"
  vivify_2615:
    $S6468 = $P6467."name"()
    substr $S6469, $S6468, 0, 1
    iseq $I6470, $S6469, "%"
    new $P6453, 'Integer'
    set $P6453, $I6470
  if_6454_end:
    unless $P6453, if_6452_end
.annotate 'line', 1962
    find_lex $P6471, "$i"
    unless_null $P6471, vivify_2616
    new $P6471, "Undef"
  vivify_2616:
    set $I6472, $P6471
    find_lex $P6473, "$past"
    unless_null $P6473, vivify_2617
    $P6473 = root_new ['parrot';'ResizablePMCArray']
  vivify_2617:
    set $P6474, $P6473[$I6472]
    unless_null $P6474, vivify_2618
    new $P6474, "Undef"
  vivify_2618:
    $P6474."named"(1)
  if_6452_end:
  if_6433_end:
.annotate 'line', 1957
    find_lex $P6475, "$i"
    unless_null $P6475, vivify_2619
    new $P6475, "Undef"
  vivify_2619:
    clone $P6476, $P6475
    inc $P6475
  loop6477_next:
.annotate 'line', 1956
    goto loop6477_test
  loop6477_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6479, exception, 'type'
    eq $P6479, .CONTROL_LOOP_NEXT, loop6477_next
    eq $P6479, .CONTROL_LOOP_REDO, loop6477_redo
  loop6477_done:
    pop_eh 
.annotate 'line', 1967
    find_lex $P6480, "$/"
    find_lex $P6481, "$past"
    unless_null $P6481, vivify_2620
    new $P6481, "Undef"
  vivify_2620:
    $P6482 = $P6480."!make"($P6481)
.annotate 'line', 1945
    .return ($P6482)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6390"  :anon :subid("535_1303739803.72") :outer("534_1303739803.72")
.annotate 'line', 1947
    .const 'Sub' $P6412 = "536_1303739803.72" 
    capture_lex $P6412
.annotate 'line', 1948
    new $P6392, "Undef"
    .lex "$expr", $P6392
    find_lex $P6393, "$/"
    unless_null $P6393, vivify_2585
    $P6393 = root_new ['parrot';'Hash']
  vivify_2585:
    set $P6394, $P6393["EXPR"]
    unless_null $P6394, vivify_2586
    new $P6394, "Undef"
  vivify_2586:
    $P6395 = $P6394."ast"()
    store_lex "$expr", $P6395
.annotate 'line', 1949
    find_lex $P6400, "$expr"
    unless_null $P6400, vivify_2587
    new $P6400, "Undef"
  vivify_2587:
    $S6401 = $P6400."name"()
    iseq $I6402, $S6401, "&infix:<,>"
    if $I6402, if_6399
    new $P6398, 'Integer'
    set $P6398, $I6402
    goto if_6399_end
  if_6399:
    find_lex $P6403, "$expr"
    unless_null $P6403, vivify_2588
    new $P6403, "Undef"
  vivify_2588:
    $P6404 = $P6403."named"()
    isfalse $I6405, $P6404
    new $P6398, 'Integer'
    set $P6398, $I6405
  if_6399_end:
    if $P6398, if_6397
.annotate 'line', 1952
    find_lex $P6420, "$past"
    unless_null $P6420, vivify_2589
    new $P6420, "Undef"
  vivify_2589:
    find_lex $P6421, "$expr"
    unless_null $P6421, vivify_2590
    new $P6421, "Undef"
  vivify_2590:
    $P6422 = $P6420."push"($P6421)
    set $P6396, $P6422
.annotate 'line', 1949
    goto if_6397_end
  if_6397:
.annotate 'line', 1950
    find_lex $P6407, "$expr"
    unless_null $P6407, vivify_2591
    new $P6407, "Undef"
  vivify_2591:
    $P6408 = $P6407."list"()
    defined $I6409, $P6408
    unless $I6409, for_undef_2592
    iter $P6406, $P6408
    new $P6418, 'ExceptionHandler'
    set_label $P6418, loop6417_handler
    $P6418."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6418
  loop6417_test:
    unless $P6406, loop6417_done
    shift $P6410, $P6406
  loop6417_redo:
    .const 'Sub' $P6412 = "536_1303739803.72" 
    capture_lex $P6412
    $P6412($P6410)
  loop6417_next:
    goto loop6417_test
  loop6417_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6419, exception, 'type'
    eq $P6419, .CONTROL_LOOP_NEXT, loop6417_next
    eq $P6419, .CONTROL_LOOP_REDO, loop6417_redo
  loop6417_done:
    pop_eh 
  for_undef_2592:
.annotate 'line', 1949
    set $P6396, $P6406
  if_6397_end:
.annotate 'line', 1947
    .return ($P6396)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6411"  :anon :subid("536_1303739803.72") :outer("535_1303739803.72")
    .param pmc param_6413
.annotate 'line', 1950
    .lex "$_", param_6413
    find_lex $P6414, "$past"
    unless_null $P6414, vivify_2593
    new $P6414, "Undef"
  vivify_2593:
    find_lex $P6415, "$_"
    unless_null $P6415, vivify_2594
    new $P6415, "Undef"
  vivify_2594:
    $P6416 = $P6414."push"($P6415)
    .return ($P6416)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("537_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6484
    .param pmc param_6485
.annotate 'line', 1970
    .lex "self", param_6484
    .lex "$/", param_6485
    find_lex $P6486, "$/"
    find_lex $P6487, "$/"
    unless_null $P6487, vivify_2621
    $P6487 = root_new ['parrot';'Hash']
  vivify_2621:
    set $P6488, $P6487["multi_declarator"]
    unless_null $P6488, vivify_2622
    new $P6488, "Undef"
  vivify_2622:
    $P6489 = $P6488."ast"()
    $P6490 = $P6486."!make"($P6489)
    .return ($P6490)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("538_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6492
    .param pmc param_6493
.annotate 'line', 1972
    .lex "self", param_6492
    .lex "$/", param_6493
    find_lex $P6494, "$/"
    find_lex $P6495, "$/"
    unless_null $P6495, vivify_2623
    $P6495 = root_new ['parrot';'Hash']
  vivify_2623:
    set $P6496, $P6495["value"]
    unless_null $P6496, vivify_2624
    new $P6496, "Undef"
  vivify_2624:
    $P6497 = $P6496."ast"()
    $P6498 = $P6494."!make"($P6497)
    .return ($P6498)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("539_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6500
    .param pmc param_6501
.annotate 'line', 1974
    .lex "self", param_6500
    .lex "$/", param_6501
.annotate 'line', 1975
    find_lex $P6502, "$/"
.annotate 'line', 1976
    find_lex $P6505, "$/"
    unless_null $P6505, vivify_2625
    $P6505 = root_new ['parrot';'Hash']
  vivify_2625:
    set $P6506, $P6505["EXPR"]
    unless_null $P6506, vivify_2626
    new $P6506, "Undef"
  vivify_2626:
    if $P6506, if_6504
.annotate 'line', 1977
    get_hll_global $P6511, "GLOBAL"
    nqp_get_package_through_who $P6512, $P6511, "PAST"
    get_who $P6513, $P6512
    set $P6514, $P6513["Op"]
    find_lex $P6515, "$/"
    unless_null $P6515, vivify_2627
    new $P6515, "Undef"
  vivify_2627:
    $P6516 = $P6514."new"("list" :named("pasttype"), $P6515 :named("node"))
    set $P6503, $P6516
.annotate 'line', 1976
    goto if_6504_end
  if_6504:
    find_lex $P6507, "$/"
    unless_null $P6507, vivify_2628
    $P6507 = root_new ['parrot';'Hash']
  vivify_2628:
    set $P6508, $P6507["EXPR"]
    unless_null $P6508, vivify_2629
    $P6508 = root_new ['parrot';'ResizablePMCArray']
  vivify_2629:
    set $P6509, $P6508[0]
    unless_null $P6509, vivify_2630
    new $P6509, "Undef"
  vivify_2630:
    $P6510 = $P6509."ast"()
    set $P6503, $P6510
  if_6504_end:
    $P6517 = $P6502."!make"($P6503)
.annotate 'line', 1974
    .return ($P6517)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("540_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6519
    .param pmc param_6520
.annotate 'line', 1980
    .lex "self", param_6519
    .lex "$/", param_6520
.annotate 'line', 1981
    new $P6521, "Undef"
    .lex "$past", $P6521
.annotate 'line', 1980
    find_lex $P6522, "$past"
    unless_null $P6522, vivify_2631
    new $P6522, "Undef"
  vivify_2631:
.annotate 'line', 1982
    find_lex $P6524, "$/"
    unless_null $P6524, vivify_2632
    $P6524 = root_new ['parrot';'Hash']
  vivify_2632:
    set $P6525, $P6524["EXPR"]
    unless_null $P6525, vivify_2633
    new $P6525, "Undef"
  vivify_2633:
    if $P6525, if_6523
.annotate 'line', 1989
    get_hll_global $P6540, "GLOBAL"
    nqp_get_package_through_who $P6541, $P6540, "PAST"
    get_who $P6542, $P6541
    set $P6543, $P6542["Op"]
    $P6544 = $P6543."new"("list" :named("pasttype"))
    store_lex "$past", $P6544
.annotate 'line', 1988
    goto if_6523_end
  if_6523:
.annotate 'line', 1983
    find_lex $P6526, "$/"
    unless_null $P6526, vivify_2634
    $P6526 = root_new ['parrot';'Hash']
  vivify_2634:
    set $P6527, $P6526["EXPR"]
    unless_null $P6527, vivify_2635
    $P6527 = root_new ['parrot';'ResizablePMCArray']
  vivify_2635:
    set $P6528, $P6527[0]
    unless_null $P6528, vivify_2636
    new $P6528, "Undef"
  vivify_2636:
    $P6529 = $P6528."ast"()
    store_lex "$past", $P6529
.annotate 'line', 1984
    find_lex $P6531, "$past"
    unless_null $P6531, vivify_2637
    new $P6531, "Undef"
  vivify_2637:
    $S6532 = $P6531."name"()
    isne $I6533, $S6532, "&infix:<,>"
    unless $I6533, if_6530_end
.annotate 'line', 1985
    get_hll_global $P6534, "GLOBAL"
    nqp_get_package_through_who $P6535, $P6534, "PAST"
    get_who $P6536, $P6535
    set $P6537, $P6536["Op"]
    find_lex $P6538, "$past"
    unless_null $P6538, vivify_2638
    new $P6538, "Undef"
  vivify_2638:
    $P6539 = $P6537."new"($P6538, "list" :named("pasttype"))
    store_lex "$past", $P6539
  if_6530_end:
  if_6523_end:
.annotate 'line', 1991
    find_lex $P6545, "$past"
    unless_null $P6545, vivify_2639
    new $P6545, "Undef"
  vivify_2639:
    $P6545."name"("&circumfix:<[ ]>")
.annotate 'line', 1992
    find_lex $P6546, "$/"
    find_lex $P6547, "$past"
    unless_null $P6547, vivify_2640
    new $P6547, "Undef"
  vivify_2640:
    $P6548 = $P6546."!make"($P6547)
.annotate 'line', 1980
    .return ($P6548)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("541_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6550
    .param pmc param_6551
.annotate 'line', 1995
    .lex "self", param_6550
    .lex "$/", param_6551
    find_lex $P6552, "$/"
    find_lex $P6553, "$/"
    unless_null $P6553, vivify_2641
    $P6553 = root_new ['parrot';'Hash']
  vivify_2641:
    set $P6554, $P6553["quote_EXPR"]
    unless_null $P6554, vivify_2642
    new $P6554, "Undef"
  vivify_2642:
    $P6555 = $P6554."ast"()
    $P6556 = $P6552."!make"($P6555)
    .return ($P6556)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("542_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6558
    .param pmc param_6559
.annotate 'line', 1996
    .lex "self", param_6558
    .lex "$/", param_6559
    find_lex $P6560, "$/"
    find_lex $P6561, "$/"
    unless_null $P6561, vivify_2643
    $P6561 = root_new ['parrot';'Hash']
  vivify_2643:
    set $P6562, $P6561["quote_EXPR"]
    unless_null $P6562, vivify_2644
    new $P6562, "Undef"
  vivify_2644:
    $P6563 = $P6562."ast"()
    $P6564 = $P6560."!make"($P6563)
    .return ($P6564)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("543_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6566
    .param pmc param_6567
.annotate 'line', 1998
    .const 'Sub' $P6578 = "544_1303739803.72" 
    capture_lex $P6578
    .lex "self", param_6566
    .lex "$/", param_6567
.annotate 'line', 1999
    find_lex $P6570, "$/"
    unless_null $P6570, vivify_2645
    $P6570 = root_new ['parrot';'Hash']
  vivify_2645:
    set $P6571, $P6570["pblock"]
    unless_null $P6571, vivify_2646
    $P6571 = root_new ['parrot';'Hash']
  vivify_2646:
    set $P6572, $P6571["blockoid"]
    unless_null $P6572, vivify_2647
    $P6572 = root_new ['parrot';'Hash']
  vivify_2647:
    set $P6573, $P6572["statementlist"]
    unless_null $P6573, vivify_2648
    $P6573 = root_new ['parrot';'Hash']
  vivify_2648:
    set $P6574, $P6573["statement"]
    unless_null $P6574, vivify_2649
    new $P6574, "Undef"
  vivify_2649:
    set $N6575, $P6574
    isgt $I6576, $N6575, 0.0
    if $I6576, if_6569
.annotate 'line', 2004
    find_lex $P6591, "$/"
    unless_null $P6591, vivify_2650
    $P6591 = root_new ['parrot';'Hash']
  vivify_2650:
    set $P6592, $P6591["pblock"]
    unless_null $P6592, vivify_2651
    $P6592 = root_new ['parrot';'Hash']
  vivify_2651:
    set $P6593, $P6592["blockoid"]
    unless_null $P6593, vivify_2652
    $P6593 = root_new ['parrot';'Hash']
  vivify_2652:
    set $P6594, $P6593["you_are_here"]
    unless_null $P6594, vivify_2653
    new $P6594, "Undef"
  vivify_2653:
    if $P6594, if_6590
.annotate 'line', 2008
    find_lex $P6600, "$/"
    $P6601 = "vivitype"("%")
    $P6602 = $P6600."!make"($P6601)
.annotate 'line', 2007
    set $P6589, $P6602
.annotate 'line', 2004
    goto if_6590_end
  if_6590:
.annotate 'line', 2005
    find_lex $P6595, "$/"
    find_lex $P6596, "$/"
    unless_null $P6596, vivify_2654
    $P6596 = root_new ['parrot';'Hash']
  vivify_2654:
    set $P6597, $P6596["pblock"]
    unless_null $P6597, vivify_2655
    new $P6597, "Undef"
  vivify_2655:
    $P6598 = $P6597."ast"()
    $P6599 = $P6595."!make"($P6598)
.annotate 'line', 2004
    set $P6589, $P6599
  if_6590_end:
    set $P6568, $P6589
.annotate 'line', 1999
    goto if_6569_end
  if_6569:
    .const 'Sub' $P6578 = "544_1303739803.72" 
    capture_lex $P6578
    $P6588 = $P6578()
    set $P6568, $P6588
  if_6569_end:
.annotate 'line', 1998
    .return ($P6568)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6577"  :anon :subid("544_1303739803.72") :outer("543_1303739803.72")
.annotate 'line', 2000
    new $P6579, "Undef"
    .lex "$past", $P6579
    find_lex $P6580, "$/"
    unless_null $P6580, vivify_2656
    $P6580 = root_new ['parrot';'Hash']
  vivify_2656:
    set $P6581, $P6580["pblock"]
    unless_null $P6581, vivify_2657
    new $P6581, "Undef"
  vivify_2657:
    $P6582 = $P6581."ast"()
    store_lex "$past", $P6582
.annotate 'line', 2001
    new $P6583, "Integer"
    assign $P6583, 1
    find_lex $P6584, "$past"
    unless_null $P6584, vivify_2658
    $P6584 = root_new ['parrot';'Hash']
    store_lex "$past", $P6584
  vivify_2658:
    set $P6584["bareblock"], $P6583
.annotate 'line', 2002
    find_dynamic_lex $P6585, "$/"
    find_lex $P6586, "$past"
    unless_null $P6586, vivify_2659
    new $P6586, "Undef"
  vivify_2659:
    $P6587 = $P6585."!make"($P6586)
.annotate 'line', 1999
    .return ($P6587)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("545_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6604
    .param pmc param_6605
.annotate 'line', 2012
    .lex "self", param_6604
    .lex "$/", param_6605
.annotate 'line', 2013
    new $P6606, "Undef"
    .lex "$name", $P6606
    find_lex $P6609, "$/"
    unless_null $P6609, vivify_2660
    $P6609 = root_new ['parrot';'Hash']
  vivify_2660:
    set $P6610, $P6609["sigil"]
    unless_null $P6610, vivify_2661
    new $P6610, "Undef"
  vivify_2661:
    set $S6611, $P6610
    iseq $I6612, $S6611, "@"
    if $I6612, if_6608
.annotate 'line', 2014
    find_lex $P6616, "$/"
    unless_null $P6616, vivify_2662
    $P6616 = root_new ['parrot';'Hash']
  vivify_2662:
    set $P6617, $P6616["sigil"]
    unless_null $P6617, vivify_2663
    new $P6617, "Undef"
  vivify_2663:
    set $S6618, $P6617
    iseq $I6619, $S6618, "%"
    if $I6619, if_6615
    new $P6621, "String"
    assign $P6621, "item"
    set $P6614, $P6621
    goto if_6615_end
  if_6615:
    new $P6620, "String"
    assign $P6620, "hash"
    set $P6614, $P6620
  if_6615_end:
    set $P6607, $P6614
.annotate 'line', 2013
    goto if_6608_end
  if_6608:
    new $P6613, "String"
    assign $P6613, "list"
    set $P6607, $P6613
  if_6608_end:
    store_lex "$name", $P6607
.annotate 'line', 2016
    find_lex $P6622, "$/"
    get_hll_global $P6623, "GLOBAL"
    nqp_get_package_through_who $P6624, $P6623, "PAST"
    get_who $P6625, $P6624
    set $P6626, $P6625["Op"]
    find_lex $P6627, "$name"
    unless_null $P6627, vivify_2664
    new $P6627, "Undef"
  vivify_2664:
    find_lex $P6628, "$/"
    unless_null $P6628, vivify_2665
    $P6628 = root_new ['parrot';'Hash']
  vivify_2665:
    set $P6629, $P6628["semilist"]
    unless_null $P6629, vivify_2666
    new $P6629, "Undef"
  vivify_2666:
    $P6630 = $P6629."ast"()
    $P6631 = $P6626."new"($P6630, "callmethod" :named("pasttype"), $P6627 :named("name"))
    $P6632 = $P6622."!make"($P6631)
.annotate 'line', 2012
    .return ($P6632)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("546_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6634
    .param pmc param_6635
.annotate 'line', 2019
    .lex "self", param_6634
    .lex "$/", param_6635
    find_lex $P6636, "$/"
    find_lex $P6637, "$/"
    unless_null $P6637, vivify_2667
    $P6637 = root_new ['parrot';'Hash']
  vivify_2667:
    set $P6638, $P6637["statement"]
    unless_null $P6638, vivify_2668
    new $P6638, "Undef"
  vivify_2668:
    $P6639 = $P6638."ast"()
    $P6640 = $P6636."!make"($P6639)
    .return ($P6640)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("547_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6642
    .param pmc param_6643
.annotate 'line', 2021
    .lex "self", param_6642
    .lex "$/", param_6643
.annotate 'line', 2022
    find_lex $P6644, "$/"
    get_hll_global $P6645, "GLOBAL"
    nqp_get_package_through_who $P6646, $P6645, "PAST"
    get_who $P6647, $P6646
    set $P6648, $P6647["Var"]
    find_lex $P6649, "$/"
    unless_null $P6649, vivify_2669
    $P6649 = root_new ['parrot';'Hash']
  vivify_2669:
    set $P6650, $P6649["EXPR"]
    unless_null $P6650, vivify_2670
    new $P6650, "Undef"
  vivify_2670:
    $P6651 = $P6650."ast"()
.annotate 'line', 2024
    $P6652 = "vivitype"("@")
    $P6653 = $P6648."new"($P6651, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P6652 :named("vivibase"))
.annotate 'line', 2022
    $P6654 = $P6644."!make"($P6653)
.annotate 'line', 2021
    .return ($P6654)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("548_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6656
    .param pmc param_6657
.annotate 'line', 2027
    .lex "self", param_6656
    .lex "$/", param_6657
.annotate 'line', 2028
    find_lex $P6658, "$/"
    get_hll_global $P6659, "GLOBAL"
    nqp_get_package_through_who $P6660, $P6659, "PAST"
    get_who $P6661, $P6660
    set $P6662, $P6661["Var"]
    find_lex $P6663, "$/"
    unless_null $P6663, vivify_2671
    $P6663 = root_new ['parrot';'Hash']
  vivify_2671:
    set $P6664, $P6663["EXPR"]
    unless_null $P6664, vivify_2672
    new $P6664, "Undef"
  vivify_2672:
    $P6665 = $P6664."ast"()
.annotate 'line', 2030
    $P6666 = "vivitype"("%")
    $P6667 = $P6662."new"($P6665, "keyed" :named("scope"), "Undef" :named("viviself"), $P6666 :named("vivibase"))
.annotate 'line', 2028
    $P6668 = $P6658."!make"($P6667)
.annotate 'line', 2027
    .return ($P6668)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("549_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6670
    .param pmc param_6671
.annotate 'line', 2033
    .lex "self", param_6670
    .lex "$/", param_6671
.annotate 'line', 2034
    find_lex $P6672, "$/"
    get_hll_global $P6673, "GLOBAL"
    nqp_get_package_through_who $P6674, $P6673, "PAST"
    get_who $P6675, $P6674
    set $P6676, $P6675["Var"]
    find_lex $P6677, "$/"
    unless_null $P6677, vivify_2673
    $P6677 = root_new ['parrot';'Hash']
  vivify_2673:
    set $P6678, $P6677["quote_EXPR"]
    unless_null $P6678, vivify_2674
    new $P6678, "Undef"
  vivify_2674:
    $P6679 = $P6678."ast"()
.annotate 'line', 2036
    $P6680 = "vivitype"("%")
    $P6681 = $P6676."new"($P6679, "keyed" :named("scope"), "Undef" :named("viviself"), $P6680 :named("vivibase"))
.annotate 'line', 2034
    $P6682 = $P6672."!make"($P6681)
.annotate 'line', 2033
    .return ($P6682)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("550_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6684
    .param pmc param_6685
.annotate 'line', 2039
    .lex "self", param_6684
    .lex "$/", param_6685
.annotate 'line', 2040
    find_lex $P6686, "$/"
    find_lex $P6687, "$/"
    unless_null $P6687, vivify_2675
    $P6687 = root_new ['parrot';'Hash']
  vivify_2675:
    set $P6688, $P6687["arglist"]
    unless_null $P6688, vivify_2676
    new $P6688, "Undef"
  vivify_2676:
    $P6689 = $P6688."ast"()
    $P6690 = $P6686."!make"($P6689)
.annotate 'line', 2039
    .return ($P6690)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("551_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6692
    .param pmc param_6693
.annotate 'line', 2043
    .lex "self", param_6692
    .lex "$/", param_6693
.annotate 'line', 2044
    find_lex $P6694, "$/"
    find_lex $P6697, "$/"
    unless_null $P6697, vivify_2677
    $P6697 = root_new ['parrot';'Hash']
  vivify_2677:
    set $P6698, $P6697["quote"]
    unless_null $P6698, vivify_2678
    new $P6698, "Undef"
  vivify_2678:
    if $P6698, if_6696
    find_lex $P6702, "$/"
    unless_null $P6702, vivify_2679
    $P6702 = root_new ['parrot';'Hash']
  vivify_2679:
    set $P6703, $P6702["number"]
    unless_null $P6703, vivify_2680
    new $P6703, "Undef"
  vivify_2680:
    $P6704 = $P6703."ast"()
    set $P6695, $P6704
    goto if_6696_end
  if_6696:
    find_lex $P6699, "$/"
    unless_null $P6699, vivify_2681
    $P6699 = root_new ['parrot';'Hash']
  vivify_2681:
    set $P6700, $P6699["quote"]
    unless_null $P6700, vivify_2682
    new $P6700, "Undef"
  vivify_2682:
    $P6701 = $P6700."ast"()
    set $P6695, $P6701
  if_6696_end:
    $P6705 = $P6694."!make"($P6695)
.annotate 'line', 2043
    .return ($P6705)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("552_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6707
    .param pmc param_6708
.annotate 'line', 2047
    .lex "self", param_6707
    .lex "$/", param_6708
.annotate 'line', 2048
    new $P6709, "Undef"
    .lex "$value", $P6709
    find_lex $P6712, "$/"
    unless_null $P6712, vivify_2683
    $P6712 = root_new ['parrot';'Hash']
  vivify_2683:
    set $P6713, $P6712["dec_number"]
    unless_null $P6713, vivify_2684
    new $P6713, "Undef"
  vivify_2684:
    if $P6713, if_6711
    find_lex $P6717, "$/"
    unless_null $P6717, vivify_2685
    $P6717 = root_new ['parrot';'Hash']
  vivify_2685:
    set $P6718, $P6717["integer"]
    unless_null $P6718, vivify_2686
    new $P6718, "Undef"
  vivify_2686:
    $P6719 = $P6718."ast"()
    set $P6710, $P6719
    goto if_6711_end
  if_6711:
    find_lex $P6714, "$/"
    unless_null $P6714, vivify_2687
    $P6714 = root_new ['parrot';'Hash']
  vivify_2687:
    set $P6715, $P6714["dec_number"]
    unless_null $P6715, vivify_2688
    new $P6715, "Undef"
  vivify_2688:
    $P6716 = $P6715."ast"()
    set $P6710, $P6716
  if_6711_end:
    store_lex "$value", $P6710
.annotate 'line', 2049
    find_lex $P6721, "$/"
    unless_null $P6721, vivify_2689
    $P6721 = root_new ['parrot';'Hash']
  vivify_2689:
    set $P6722, $P6721["sign"]
    unless_null $P6722, vivify_2690
    new $P6722, "Undef"
  vivify_2690:
    set $S6723, $P6722
    iseq $I6724, $S6723, "-"
    unless $I6724, if_6720_end
    find_lex $P6725, "$value"
    unless_null $P6725, vivify_2691
    new $P6725, "Undef"
  vivify_2691:
    neg $P6726, $P6725
    store_lex "$value", $P6726
  if_6720_end:
.annotate 'line', 2050
    find_lex $P6727, "$/"
    get_hll_global $P6728, "GLOBAL"
    nqp_get_package_through_who $P6729, $P6728, "PAST"
    get_who $P6730, $P6729
    set $P6731, $P6730["Val"]
    find_lex $P6732, "$value"
    unless_null $P6732, vivify_2692
    new $P6732, "Undef"
  vivify_2692:
    $P6733 = $P6731."new"($P6732 :named("value"))
    $P6734 = $P6727."!make"($P6733)
.annotate 'line', 2047
    .return ($P6734)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("553_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6736
    .param pmc param_6737
.annotate 'line', 2053
    .lex "self", param_6736
    .lex "$/", param_6737
    find_lex $P6738, "$/"
    find_lex $P6739, "$/"
    unless_null $P6739, vivify_2693
    $P6739 = root_new ['parrot';'Hash']
  vivify_2693:
    set $P6740, $P6739["quote_EXPR"]
    unless_null $P6740, vivify_2694
    new $P6740, "Undef"
  vivify_2694:
    $P6741 = $P6740."ast"()
    $P6742 = $P6738."!make"($P6741)
    .return ($P6742)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("554_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6744
    .param pmc param_6745
.annotate 'line', 2054
    .lex "self", param_6744
    .lex "$/", param_6745
    find_lex $P6746, "$/"
    find_lex $P6747, "$/"
    unless_null $P6747, vivify_2695
    $P6747 = root_new ['parrot';'Hash']
  vivify_2695:
    set $P6748, $P6747["quote_EXPR"]
    unless_null $P6748, vivify_2696
    new $P6748, "Undef"
  vivify_2696:
    $P6749 = $P6748."ast"()
    $P6750 = $P6746."!make"($P6749)
    .return ($P6750)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("555_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6752
    .param pmc param_6753
.annotate 'line', 2055
    .lex "self", param_6752
    .lex "$/", param_6753
    find_lex $P6754, "$/"
    find_lex $P6755, "$/"
    unless_null $P6755, vivify_2697
    $P6755 = root_new ['parrot';'Hash']
  vivify_2697:
    set $P6756, $P6755["quote_EXPR"]
    unless_null $P6756, vivify_2698
    new $P6756, "Undef"
  vivify_2698:
    $P6757 = $P6756."ast"()
    $P6758 = $P6754."!make"($P6757)
    .return ($P6758)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("556_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6760
    .param pmc param_6761
.annotate 'line', 2056
    .lex "self", param_6760
    .lex "$/", param_6761
    find_lex $P6762, "$/"
    find_lex $P6763, "$/"
    unless_null $P6763, vivify_2699
    $P6763 = root_new ['parrot';'Hash']
  vivify_2699:
    set $P6764, $P6763["quote_EXPR"]
    unless_null $P6764, vivify_2700
    new $P6764, "Undef"
  vivify_2700:
    $P6765 = $P6764."ast"()
    $P6766 = $P6762."!make"($P6765)
    .return ($P6766)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("557_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6768
    .param pmc param_6769
.annotate 'line', 2057
    .lex "self", param_6768
    .lex "$/", param_6769
    find_lex $P6770, "$/"
    find_lex $P6771, "$/"
    unless_null $P6771, vivify_2701
    $P6771 = root_new ['parrot';'Hash']
  vivify_2701:
    set $P6772, $P6771["quote_EXPR"]
    unless_null $P6772, vivify_2702
    new $P6772, "Undef"
  vivify_2702:
    $P6773 = $P6772."ast"()
    $P6774 = $P6770."!make"($P6773)
    .return ($P6774)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("558_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6776
    .param pmc param_6777
.annotate 'line', 2058
    .lex "self", param_6776
    .lex "$/", param_6777
.annotate 'line', 2059
    find_lex $P6778, "$/"
    get_hll_global $P6779, "GLOBAL"
    nqp_get_package_through_who $P6780, $P6779, "PAST"
    get_who $P6781, $P6780
    set $P6782, $P6781["Op"]
    find_lex $P6783, "$/"
    unless_null $P6783, vivify_2703
    $P6783 = root_new ['parrot';'Hash']
  vivify_2703:
    set $P6784, $P6783["quote_EXPR"]
    unless_null $P6784, vivify_2704
    new $P6784, "Undef"
  vivify_2704:
    $P6785 = $P6784."ast"()
    $P6786 = $P6785."value"()
    find_lex $P6787, "$/"
    unless_null $P6787, vivify_2705
    new $P6787, "Undef"
  vivify_2705:
    $P6788 = $P6782."new"($P6786 :named("inline"), "inline" :named("pasttype"), $P6787 :named("node"))
    $P6789 = $P6778."!make"($P6788)
.annotate 'line', 2058
    .return ($P6789)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("559_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6793
    .param pmc param_6794
    .param pmc param_6795 :optional
    .param int has_param_6795 :opt_flag
.annotate 'line', 2064
    new $P6792, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6792, control_6791
    push_eh $P6792
    .lex "self", param_6793
    .lex "$/", param_6794
    if has_param_6795, optparam_2706
    new $P6796, "Undef"
    set param_6795, $P6796
  optparam_2706:
    .lex "$key", param_6795
.annotate 'line', 2071
    new $P6797, "Undef"
    .lex "$regex", $P6797
.annotate 'line', 2073
    new $P6798, "Undef"
    .lex "$past", $P6798
.annotate 'line', 2065
    find_lex $P6800, "$key"
    unless_null $P6800, vivify_2707
    new $P6800, "Undef"
  vivify_2707:
    set $S6801, $P6800
    iseq $I6802, $S6801, "open"
    unless $I6802, if_6799_end
.annotate 'line', 2066
    null $P6803
    get_hll_global $P6804, "GLOBAL"
    nqp_get_package_through_who $P6805, $P6804, "Regex"
    nqp_get_package_through_who $P6806, $P6805, "P6Regex"
    nqp_get_package_through_who $P6807, $P6806, "Actions"
    get_who $P6808, $P6807
    set $P6808["$REGEXNAME"], $P6803
.annotate 'line', 2067
    find_lex $P6809, "$?PACKAGE"
    get_who $P6810, $P6809
    set $P6811, $P6810["@BLOCK"]
    unless_null $P6811, vivify_2708
    $P6811 = root_new ['parrot';'ResizablePMCArray']
  vivify_2708:
    set $P6812, $P6811[0]
    unless_null $P6812, vivify_2709
    new $P6812, "Undef"
  vivify_2709:
    $P6812."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2068
    find_lex $P6813, "$?PACKAGE"
    get_who $P6814, $P6813
    set $P6815, $P6814["@BLOCK"]
    unless_null $P6815, vivify_2710
    $P6815 = root_new ['parrot';'ResizablePMCArray']
  vivify_2710:
    set $P6816, $P6815[0]
    unless_null $P6816, vivify_2711
    new $P6816, "Undef"
  vivify_2711:
    $P6816."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2069
    new $P6817, "Exception"
    set $P6817['type'], .CONTROL_RETURN
    new $P6818, "Integer"
    assign $P6818, 0
    setattribute $P6817, 'payload', $P6818
    throw $P6817
  if_6799_end:
.annotate 'line', 2072
    get_hll_global $P6819, "GLOBAL"
    nqp_get_package_through_who $P6820, $P6819, "Regex"
    nqp_get_package_through_who $P6821, $P6820, "P6Regex"
    nqp_get_package_through_who $P6822, $P6821, "Actions"
    get_who $P6823, $P6822
    set $P6824, $P6823["buildsub"]
    find_lex $P6825, "$/"
    unless_null $P6825, vivify_2712
    $P6825 = root_new ['parrot';'Hash']
  vivify_2712:
    set $P6826, $P6825["p6regex"]
    unless_null $P6826, vivify_2713
    new $P6826, "Undef"
  vivify_2713:
    $P6827 = $P6826."ast"()
    find_lex $P6828, "$?PACKAGE"
    get_who $P6829, $P6828
    set $P6830, $P6829["@BLOCK"]
    unless_null $P6830, vivify_2714
    $P6830 = root_new ['parrot';'ResizablePMCArray']
  vivify_2714:
    $P6831 = $P6830."shift"()
    $P6832 = $P6824($P6827, $P6831)
    store_lex "$regex", $P6832
.annotate 'line', 2074
    get_hll_global $P6833, "GLOBAL"
    nqp_get_package_through_who $P6834, $P6833, "PAST"
    get_who $P6835, $P6834
    set $P6836, $P6835["Op"]
.annotate 'line', 2076
    get_hll_global $P6837, "GLOBAL"
    nqp_get_package_through_who $P6838, $P6837, "PAST"
    get_who $P6839, $P6838
    set $P6840, $P6839["Var"]
    new $P6841, "ResizablePMCArray"
    push $P6841, "Regex"
    $P6842 = $P6840."new"("Regex" :named("name"), $P6841 :named("namespace"), "package" :named("scope"))
    find_lex $P6843, "$regex"
    unless_null $P6843, vivify_2715
    new $P6843, "Undef"
  vivify_2715:
    $P6844 = $P6836."new"($P6842, $P6843, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2074
    store_lex "$past", $P6844
.annotate 'line', 2080
    find_lex $P6845, "$regex"
    unless_null $P6845, vivify_2716
    new $P6845, "Undef"
  vivify_2716:
    find_lex $P6846, "$past"
    unless_null $P6846, vivify_2717
    $P6846 = root_new ['parrot';'Hash']
    store_lex "$past", $P6846
  vivify_2717:
    set $P6846["sink"], $P6845
.annotate 'line', 2081
    find_lex $P6847, "$/"
    find_lex $P6848, "$past"
    unless_null $P6848, vivify_2718
    new $P6848, "Undef"
  vivify_2718:
    $P6849 = $P6847."!make"($P6848)
.annotate 'line', 2064
    .return ($P6849)
  control_6791:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6850, exception, "payload"
    .return ($P6850)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("560_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6852
    .param pmc param_6853
.annotate 'line', 2084
    .lex "self", param_6852
    .lex "$/", param_6853
    find_lex $P6854, "$/"
    find_lex $P6855, "$/"
    unless_null $P6855, vivify_2719
    $P6855 = root_new ['parrot';'Hash']
  vivify_2719:
    set $P6856, $P6855["variable"]
    unless_null $P6856, vivify_2720
    new $P6856, "Undef"
  vivify_2720:
    $P6857 = $P6856."ast"()
    $P6858 = $P6854."!make"($P6857)
    .return ($P6858)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("561_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6860
    .param pmc param_6861
.annotate 'line', 2085
    .lex "self", param_6860
    .lex "$/", param_6861
.annotate 'line', 2086
    find_lex $P6862, "$/"
    get_hll_global $P6863, "GLOBAL"
    nqp_get_package_through_who $P6864, $P6863, "PAST"
    get_who $P6865, $P6864
    set $P6866, $P6865["Op"]
.annotate 'line', 2087
    find_lex $P6867, "$/"
    unless_null $P6867, vivify_2721
    $P6867 = root_new ['parrot';'Hash']
  vivify_2721:
    set $P6868, $P6867["block"]
    unless_null $P6868, vivify_2722
    new $P6868, "Undef"
  vivify_2722:
    $P6869 = $P6868."ast"()
    $P6870 = "block_immediate"($P6869)
    find_lex $P6871, "$/"
    unless_null $P6871, vivify_2723
    new $P6871, "Undef"
  vivify_2723:
    $P6872 = $P6866."new"($P6870, "set S*" :named("pirop"), $P6871 :named("node"))
.annotate 'line', 2086
    $P6873 = $P6862."!make"($P6872)
.annotate 'line', 2085
    .return ($P6873)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("562_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6875
    .param pmc param_6876
.annotate 'line', 2090
    .lex "self", param_6875
    .lex "$/", param_6876
    find_lex $P6877, "$/"
    $P6878 = $P6877."!make"("\e")
    .return ($P6878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("563_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6880
    .param pmc param_6881
.annotate 'line', 2094
    .lex "self", param_6880
    .lex "$/", param_6881
    find_lex $P6882, "$/"
    find_lex $P6883, "$/"
    unless_null $P6883, vivify_2724
    $P6883 = root_new ['parrot';'Hash']
  vivify_2724:
    set $P6884, $P6883["dotty"]
    unless_null $P6884, vivify_2725
    new $P6884, "Undef"
  vivify_2725:
    $P6885 = $P6884."ast"()
    $P6886 = $P6882."!make"($P6885)
    .return ($P6886)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("564_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6888
    .param pmc param_6889
.annotate 'line', 2096
    .lex "self", param_6888
    .lex "$/", param_6889
.annotate 'line', 2097
    find_lex $P6890, "$/"
    get_hll_global $P6891, "GLOBAL"
    nqp_get_package_through_who $P6892, $P6891, "PAST"
    get_who $P6893, $P6892
    set $P6894, $P6893["Op"]
.annotate 'line', 2098
    new $P6895, "ResizablePMCArray"
    push $P6895, "    clone %r, %0"
    push $P6895, "    inc %0"
    $P6896 = $P6894."new"("postfix:<++>" :named("name"), $P6895 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2097
    $P6897 = $P6890."!make"($P6896)
.annotate 'line', 2096
    .return ($P6897)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("565_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6899
    .param pmc param_6900
.annotate 'line', 2102
    .lex "self", param_6899
    .lex "$/", param_6900
.annotate 'line', 2103
    find_lex $P6901, "$/"
    get_hll_global $P6902, "GLOBAL"
    nqp_get_package_through_who $P6903, $P6902, "PAST"
    get_who $P6904, $P6903
    set $P6905, $P6904["Op"]
.annotate 'line', 2104
    new $P6906, "ResizablePMCArray"
    push $P6906, "    clone %r, %0"
    push $P6906, "    dec %0"
    $P6907 = $P6905."new"("postfix:<-->" :named("name"), $P6906 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2103
    $P6908 = $P6901."!make"($P6907)
.annotate 'line', 2102
    .return ($P6908)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("566_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6910
    .param pmc param_6911
.annotate 'line', 2108
    .lex "self", param_6910
    .lex "$/", param_6911
.annotate 'line', 2109
    find_lex $P6912, "$/"
    get_hll_global $P6913, "GLOBAL"
    nqp_get_package_through_who $P6914, $P6913, "PAST"
    get_who $P6915, $P6914
    set $P6916, $P6915["Op"]
.annotate 'line', 2110
    get_hll_global $P6917, "GLOBAL"
    nqp_get_package_through_who $P6918, $P6917, "PAST"
    get_who $P6919, $P6918
    set $P6920, $P6919["Var"]
    $P6921 = $P6920."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P6922, "$/"
    unless_null $P6922, vivify_2726
    new $P6922, "Undef"
  vivify_2726:
    $P6923 = $P6916."new"($P6921, "callmethod" :named("pasttype"), "!make" :named("name"), $P6922 :named("node"))
.annotate 'line', 2109
    $P6924 = $P6912."!make"($P6923)
.annotate 'line', 2108
    .return ($P6924)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("567_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6927
    .param pmc param_6928
.annotate 'line', 2126
    .lex "self", param_6927
    .lex "$/", param_6928
    find_lex $P6929, "$/"
    unless_null $P6929, vivify_2727
    new $P6929, "Undef"
  vivify_2727:
    $P6930 = "control"($P6929, "CONTROL_LOOP_NEXT")
    .return ($P6930)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("568_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6932
    .param pmc param_6933
.annotate 'line', 2127
    .lex "self", param_6932
    .lex "$/", param_6933
    find_lex $P6934, "$/"
    unless_null $P6934, vivify_2728
    new $P6934, "Undef"
  vivify_2728:
    $P6935 = "control"($P6934, "CONTROL_LOOP_LAST")
    .return ($P6935)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("569_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6937
    .param pmc param_6938
.annotate 'line', 2128
    .lex "self", param_6937
    .lex "$/", param_6938
    find_lex $P6939, "$/"
    unless_null $P6939, vivify_2729
    new $P6939, "Undef"
  vivify_2729:
    $P6940 = "control"($P6939, "CONTROL_LOOP_REDO")
    .return ($P6940)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("570_1303739803.72") :outer("406_1303739803.72")
    .param pmc param_6942
    .param pmc param_6943
.annotate 'line', 2130
    .lex "self", param_6942
    .lex "$/", param_6943
.annotate 'line', 2131
    find_lex $P6944, "$/"
    get_hll_global $P6945, "GLOBAL"
    nqp_get_package_through_who $P6946, $P6945, "PAST"
    get_who $P6947, $P6946
    set $P6948, $P6947["Op"]
    find_lex $P6949, "$/"
    unless_null $P6949, vivify_2730
    new $P6949, "Undef"
  vivify_2730:
    $P6950 = $P6948."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P6949 :named("node"))
    $P6951 = $P6944."!make"($P6950)
.annotate 'line', 2130
    .return ($P6951)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7182"  :subid("572_1303739803.72") :outer("10_1303739803.72")
.annotate 'line', 2267
    .const 'Sub' $P7316 = "580_1303739803.72" 
    capture_lex $P7316
    .const 'Sub' $P7276 = "579_1303739803.72" 
    capture_lex $P7276
    .const 'Sub' $P7262 = "578_1303739803.72" 
    capture_lex $P7262
    .const 'Sub' $P7244 = "577_1303739803.72" 
    capture_lex $P7244
    .const 'Sub' $P7230 = "576_1303739803.72" 
    capture_lex $P7230
    .const 'Sub' $P7216 = "575_1303739803.72" 
    capture_lex $P7216
    .const 'Sub' $P7202 = "574_1303739803.72" 
    capture_lex $P7202
    .const 'Sub' $P7186 = "573_1303739803.72" 
    capture_lex $P7186
    .lex "$?PACKAGE", $P7184
    .lex "$?CLASS", $P7185
.annotate 'line', 2301
    .const 'Sub' $P7276 = "579_1303739803.72" 
    newclosure $P7314, $P7276
.annotate 'line', 2267
    .return ($P7314)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2731") :outer("572_1303739803.72")
.annotate 'line', 2267
    .const 'Sub' $P7183 = "572_1303739803.72" 
    .local pmc block
    set block, $P7183
    .const 'Sub' $P7316 = "580_1303739803.72" 
    capture_lex $P7316
    $P7316()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7315"  :anon :subid("580_1303739803.72") :outer("572_1303739803.72")
.annotate 'line', 2267
    nqp_get_sc_object $P7317, "1303739791.58", 4
    .local pmc type_obj
    set type_obj, $P7317
    get_how $P7318, type_obj
    .const 'Sub' $P7319 = "573_1303739803.72" 
    $P7318."add_method"(type_obj, "metachar:sym<:my>", $P7319)
    get_how $P7320, type_obj
    .const 'Sub' $P7321 = "574_1303739803.72" 
    $P7320."add_method"(type_obj, "metachar:sym<{ }>", $P7321)
    get_how $P7322, type_obj
    .const 'Sub' $P7323 = "575_1303739803.72" 
    $P7322."add_method"(type_obj, "metachar:sym<nqpvar>", $P7323)
    get_how $P7324, type_obj
    .const 'Sub' $P7325 = "576_1303739803.72" 
    $P7324."add_method"(type_obj, "assertion:sym<{ }>", $P7325)
    get_how $P7326, type_obj
    .const 'Sub' $P7327 = "577_1303739803.72" 
    $P7326."add_method"(type_obj, "assertion:sym<?{ }>", $P7327)
    get_how $P7328, type_obj
    .const 'Sub' $P7329 = "578_1303739803.72" 
    $P7328."add_method"(type_obj, "assertion:sym<var>", $P7329)
    get_how $P7330, type_obj
    .const 'Sub' $P7331 = "579_1303739803.72" 
    $P7330."add_method"(type_obj, "codeblock", $P7331)
    get_how $P7332, type_obj
    get_hll_global $P7333, ["Regex";"P6Regex"], "Actions"
    $P7332."add_parent"(type_obj, $P7333)
    get_how $P7334, type_obj
    $P7335 = $P7334."compose"(type_obj)
    .return ($P7335)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("573_1303739803.72") :outer("572_1303739803.72")
    .param pmc param_7187
    .param pmc param_7188
.annotate 'line', 2269
    .lex "self", param_7187
    .lex "$/", param_7188
.annotate 'line', 2270
    new $P7189, "Undef"
    .lex "$past", $P7189
    find_lex $P7190, "$/"
    unless_null $P7190, vivify_2732
    $P7190 = root_new ['parrot';'Hash']
  vivify_2732:
    set $P7191, $P7190["statement"]
    unless_null $P7191, vivify_2733
    new $P7191, "Undef"
  vivify_2733:
    $P7192 = $P7191."ast"()
    store_lex "$past", $P7192
.annotate 'line', 2271
    find_lex $P7193, "$/"
    get_hll_global $P7194, "GLOBAL"
    nqp_get_package_through_who $P7195, $P7194, "PAST"
    get_who $P7196, $P7195
    set $P7197, $P7196["Regex"]
    find_lex $P7198, "$past"
    unless_null $P7198, vivify_2734
    new $P7198, "Undef"
  vivify_2734:
    find_lex $P7199, "$/"
    unless_null $P7199, vivify_2735
    new $P7199, "Undef"
  vivify_2735:
    $P7200 = $P7197."new"($P7198, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P7199 :named("node"))
    $P7201 = $P7193."!make"($P7200)
.annotate 'line', 2269
    .return ($P7201)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("574_1303739803.72") :outer("572_1303739803.72")
    .param pmc param_7203
    .param pmc param_7204
.annotate 'line', 2275
    .lex "self", param_7203
    .lex "$/", param_7204
.annotate 'line', 2276
    find_lex $P7205, "$/"
    get_hll_global $P7206, "GLOBAL"
    nqp_get_package_through_who $P7207, $P7206, "PAST"
    get_who $P7208, $P7207
    set $P7209, $P7208["Regex"]
    find_lex $P7210, "$/"
    unless_null $P7210, vivify_2736
    $P7210 = root_new ['parrot';'Hash']
  vivify_2736:
    set $P7211, $P7210["codeblock"]
    unless_null $P7211, vivify_2737
    new $P7211, "Undef"
  vivify_2737:
    $P7212 = $P7211."ast"()
    find_lex $P7213, "$/"
    unless_null $P7213, vivify_2738
    new $P7213, "Undef"
  vivify_2738:
    $P7214 = $P7209."new"($P7212, "pastnode" :named("pasttype"), $P7213 :named("node"))
    $P7215 = $P7205."!make"($P7214)
.annotate 'line', 2275
    .return ($P7215)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("575_1303739803.72") :outer("572_1303739803.72")
    .param pmc param_7217
    .param pmc param_7218
.annotate 'line', 2280
    .lex "self", param_7217
    .lex "$/", param_7218
.annotate 'line', 2281
    find_lex $P7219, "$/"
    get_hll_global $P7220, "GLOBAL"
    nqp_get_package_through_who $P7221, $P7220, "PAST"
    get_who $P7222, $P7221
    set $P7223, $P7222["Regex"]
    find_lex $P7224, "$/"
    unless_null $P7224, vivify_2739
    $P7224 = root_new ['parrot';'Hash']
  vivify_2739:
    set $P7225, $P7224["var"]
    unless_null $P7225, vivify_2740
    new $P7225, "Undef"
  vivify_2740:
    $P7226 = $P7225."ast"()
    find_lex $P7227, "$/"
    unless_null $P7227, vivify_2741
    new $P7227, "Undef"
  vivify_2741:
    $P7228 = $P7223."new"("!INTERPOLATE", $P7226, "subrule" :named("pasttype"), "method" :named("subtype"), $P7227 :named("node"))
    $P7229 = $P7219."!make"($P7228)
.annotate 'line', 2280
    .return ($P7229)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("576_1303739803.72") :outer("572_1303739803.72")
    .param pmc param_7231
    .param pmc param_7232
.annotate 'line', 2285
    .lex "self", param_7231
    .lex "$/", param_7232
.annotate 'line', 2286
    find_lex $P7233, "$/"
    get_hll_global $P7234, "GLOBAL"
    nqp_get_package_through_who $P7235, $P7234, "PAST"
    get_who $P7236, $P7235
    set $P7237, $P7236["Regex"]
    find_lex $P7238, "$/"
    unless_null $P7238, vivify_2742
    $P7238 = root_new ['parrot';'Hash']
  vivify_2742:
    set $P7239, $P7238["codeblock"]
    unless_null $P7239, vivify_2743
    new $P7239, "Undef"
  vivify_2743:
    $P7240 = $P7239."ast"()
    find_lex $P7241, "$/"
    unless_null $P7241, vivify_2744
    new $P7241, "Undef"
  vivify_2744:
    $P7242 = $P7237."new"("!INTERPOLATE_REGEX", $P7240, "subrule" :named("pasttype"), "method" :named("subtype"), $P7241 :named("node"))
    $P7243 = $P7233."!make"($P7242)
.annotate 'line', 2285
    .return ($P7243)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("577_1303739803.72") :outer("572_1303739803.72")
    .param pmc param_7245
    .param pmc param_7246
.annotate 'line', 2290
    .lex "self", param_7245
    .lex "$/", param_7246
.annotate 'line', 2291
    find_lex $P7247, "$/"
    get_hll_global $P7248, "GLOBAL"
    nqp_get_package_through_who $P7249, $P7248, "PAST"
    get_who $P7250, $P7249
    set $P7251, $P7250["Regex"]
    find_lex $P7252, "$/"
    unless_null $P7252, vivify_2745
    $P7252 = root_new ['parrot';'Hash']
  vivify_2745:
    set $P7253, $P7252["codeblock"]
    unless_null $P7253, vivify_2746
    new $P7253, "Undef"
  vivify_2746:
    $P7254 = $P7253."ast"()
.annotate 'line', 2292
    find_lex $P7255, "$/"
    unless_null $P7255, vivify_2747
    $P7255 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P7256, $P7255["zw"]
    unless_null $P7256, vivify_2748
    new $P7256, "Undef"
  vivify_2748:
    set $S7257, $P7256
    iseq $I7258, $S7257, "!"
    find_lex $P7259, "$/"
    unless_null $P7259, vivify_2749
    new $P7259, "Undef"
  vivify_2749:
    $P7260 = $P7251."new"($P7254, "zerowidth" :named("subtype"), $I7258 :named("negate"), "pastnode" :named("pasttype"), $P7259 :named("node"))
.annotate 'line', 2291
    $P7261 = $P7247."!make"($P7260)
.annotate 'line', 2290
    .return ($P7261)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("578_1303739803.72") :outer("572_1303739803.72")
    .param pmc param_7263
    .param pmc param_7264
.annotate 'line', 2296
    .lex "self", param_7263
    .lex "$/", param_7264
.annotate 'line', 2297
    find_lex $P7265, "$/"
    get_hll_global $P7266, "GLOBAL"
    nqp_get_package_through_who $P7267, $P7266, "PAST"
    get_who $P7268, $P7267
    set $P7269, $P7268["Regex"]
    find_lex $P7270, "$/"
    unless_null $P7270, vivify_2750
    $P7270 = root_new ['parrot';'Hash']
  vivify_2750:
    set $P7271, $P7270["var"]
    unless_null $P7271, vivify_2751
    new $P7271, "Undef"
  vivify_2751:
    $P7272 = $P7271."ast"()
    find_lex $P7273, "$/"
    unless_null $P7273, vivify_2752
    new $P7273, "Undef"
  vivify_2752:
    $P7274 = $P7269."new"("!INTERPOLATE_REGEX", $P7272, "subrule" :named("pasttype"), "method" :named("subtype"), $P7273 :named("node"))
    $P7275 = $P7265."!make"($P7274)
.annotate 'line', 2296
    .return ($P7275)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("579_1303739803.72") :outer("572_1303739803.72")
    .param pmc param_7277
    .param pmc param_7278
.annotate 'line', 2301
    .lex "self", param_7277
    .lex "$/", param_7278
.annotate 'line', 2302
    new $P7279, "Undef"
    .lex "$block", $P7279
.annotate 'line', 2304
    new $P7280, "Undef"
    .lex "$past", $P7280
.annotate 'line', 2302
    find_lex $P7281, "$/"
    unless_null $P7281, vivify_2753
    $P7281 = root_new ['parrot';'Hash']
  vivify_2753:
    set $P7282, $P7281["block"]
    unless_null $P7282, vivify_2754
    new $P7282, "Undef"
  vivify_2754:
    $P7283 = $P7282."ast"()
    store_lex "$block", $P7283
.annotate 'line', 2303
    find_lex $P7284, "$block"
    unless_null $P7284, vivify_2755
    new $P7284, "Undef"
  vivify_2755:
    $P7284."blocktype"("immediate")
.annotate 'line', 2305
    get_hll_global $P7285, "GLOBAL"
    nqp_get_package_through_who $P7286, $P7285, "PAST"
    get_who $P7287, $P7286
    set $P7288, $P7287["Stmts"]
.annotate 'line', 2306
    get_hll_global $P7289, "GLOBAL"
    nqp_get_package_through_who $P7290, $P7289, "PAST"
    get_who $P7291, $P7290
    set $P7292, $P7291["Op"]
.annotate 'line', 2307
    get_hll_global $P7293, "GLOBAL"
    nqp_get_package_through_who $P7294, $P7293, "PAST"
    get_who $P7295, $P7294
    set $P7296, $P7295["Var"]
    $P7297 = $P7296."new"("$/" :named("name"))
.annotate 'line', 2308
    get_hll_global $P7298, "GLOBAL"
    nqp_get_package_through_who $P7299, $P7298, "PAST"
    get_who $P7300, $P7299
    set $P7301, $P7300["Op"]
.annotate 'line', 2309
    get_hll_global $P7302, "GLOBAL"
    nqp_get_package_through_who $P7303, $P7302, "PAST"
    get_who $P7304, $P7303
    set $P7305, $P7304["Var"]
    $P7306 = $P7305."new"(unicode:"$\x{a2}" :named("name"))
    $P7307 = $P7301."new"($P7306, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2308
    $P7308 = $P7292."new"($P7297, $P7307, "bind" :named("pasttype"))
.annotate 'line', 2306
    find_lex $P7309, "$block"
    unless_null $P7309, vivify_2756
    new $P7309, "Undef"
  vivify_2756:
    $P7310 = $P7288."new"($P7308, $P7309)
.annotate 'line', 2305
    store_lex "$past", $P7310
.annotate 'line', 2317
    find_lex $P7311, "$/"
    find_lex $P7312, "$past"
    unless_null $P7312, vivify_2757
    new $P7312, "Undef"
  vivify_2757:
    $P7313 = $P7311."!make"($P7312)
.annotate 'line', 2301
    .return ($P7313)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7336"  :subid("581_1303739803.72") :outer("10_1303739803.72")
.annotate 'line', 2322
    .const 'Sub' $P7341 = "582_1303739803.72" 
    capture_lex $P7341
    .lex "$?PACKAGE", $P7338
    .lex "$?CLASS", $P7339
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2758") :outer("581_1303739803.72")
.annotate 'line', 2322
    .const 'Sub' $P7337 = "581_1303739803.72" 
    .local pmc block
    set block, $P7337
    .const 'Sub' $P7341 = "582_1303739803.72" 
    capture_lex $P7341
    $P7341()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7340"  :anon :subid("582_1303739803.72") :outer("581_1303739803.72")
.annotate 'line', 2322
    nqp_get_sc_object $P7342, "1303739791.58", 5
    .local pmc type_obj
    set type_obj, $P7342
    get_how $P7343, type_obj
    get_hll_global $P7344, ["HLL"], "Compiler"
    $P7343."add_parent"(type_obj, $P7344)
    get_how $P7345, type_obj
    $P7346 = $P7345."compose"(type_obj)
    .return ($P7346)
.end


.HLL "nqp"

.namespace []
.sub "_block7354" :load :anon :subid("583_1303739803.72")
.annotate 'line', 1
    .const 'Sub' $P7356 = "10_1303739803.72" 
    $P7357 = $P7356()
    .return ($P7357)
.end

