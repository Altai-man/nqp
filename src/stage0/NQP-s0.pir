.include 'cclass.pasm'
.include 'except_severity.pasm'
.include 'except_types.pasm'
.include 'iglobals.pasm'
.include 'interpinfo.pasm'
.include 'iterator.pasm'
.include 'sysinfo.pasm'
.include 'stat.pasm'
.include 'datatypes.pasm'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.loadlib "nqp_bigint_ops"

.loadlib "trans_ops"

.loadlib "io_ops"

.namespace []
.sub "_block1000"  :anon :subid("10_1325892461.451")
    .param pmc param_1002 :slurpy
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 0
    .const 'Sub' $P3780 = "636_1325892461.451" 
    capture_lex $P3780
    .const 'Sub' $P3743 = "628_1325892461.451" 
    capture_lex $P3743
    .const 'Sub' $P2400 = "446_1325892461.451" 
    capture_lex $P2400
    .const 'Sub' $P2345 = "425_1325892461.451" 
    capture_lex $P2345
    .const 'Sub' $P1239 = "46_1325892461.451" 
    capture_lex $P1239
    .const 'Sub' $P1025 = "13_1325892461.451" 
    capture_lex $P1025
    .const 'Sub' $P1019 = "12_1325892461.451" 
    capture_lex $P1019
    .const 'Sub' $P1006 = "11_1325892461.451" 
    capture_lex $P1006
.annotate 'line', 1
    .lex "@ARGS", param_1002
    .lex "GLOBALish", $P1003
    .lex "$?PACKAGE", $P1004
.annotate 'line', 2821
    .const 'Sub' $P1006 = "11_1325892461.451" 
    newclosure $P1017, $P1006
    set $P1005, $P1017
    .lex "MAIN", $P1005
.annotate 'line', 2844
    .const 'Sub' $P1019 = "12_1325892461.451" 
    newclosure $P1023, $P1019
    set $P1018, $P1023
    .lex "hll-config", $P1018
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 7
    .const 'Sub' $P1025 = "13_1325892461.451" 
    capture_lex $P1025
    $P1025()
.annotate 'line', 462
    .const 'Sub' $P1239 = "46_1325892461.451" 
    capture_lex $P1239
    $P1239()
.annotate 'line', 1196
    .const 'Sub' $P2345 = "425_1325892461.451" 
    capture_lex $P2345
    $P2345()
.annotate 'line', 1239
    .const 'Sub' $P2400 = "446_1325892461.451" 
    capture_lex $P2400
    $P2400()
.annotate 'line', 2763
    .const 'Sub' $P3743 = "628_1325892461.451" 
    capture_lex $P3743
    $P3743()
.annotate 'line', 2818
    .const 'Sub' $P3780 = "636_1325892461.451" 
    capture_lex $P3780
    $P3780()
.annotate 'line', 1
    set $P103, $P1005
    set $P103, $P1018
    set $P104, param_1002
    if $P104, if_3783
    set $P103, $P104
    goto if_3783_end
  if_3783:
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P105, "ModuleLoader"
    getinterp $P106
    set $P107, $P106["context"]
    $P105."set_mainline_module"($P107)
    .const '' $P3784 = "11_1325892461.451" 
    set $P108, param_1002
    $P109 = $P3784($P108 :flat)
    set $P103, $P109
  if_3783_end:
    .return ($P103)
    .const 'Sub' $P3786 = "637_1325892461.451" 
    .return ($P3786)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post638") :outer("10_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 0
    .const 'Sub' $P1001 = "10_1325892461.451" 
    .local pmc block
    set block, $P1001
    nqp_get_sc $P111, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248"
    isnull $I100, $P111
    if $I100, if_3788
    goto if_3788_end
  if_3788:
    nqp_dynop_setup 
    nqp_bigint_setup 
    getinterp $P112
    get_class $P113, "LexPad"
    get_class $P114, "NQPLexPad"
    $P112."hll_map"($P113, $P114)
    nqp_create_sc $P115, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248"
    .local pmc cur_sc
    set cur_sc, $P115
    cur_sc."set_description"("src\\stage2\\gen\\NQP.pm")
    nqp_get_sc $P116, "__6MODEL_CORE__"
    isnull $I101, $P116
    unless $I101, if_3789_end
    set $S100, "Incorrect pre-compiled version of <unknown> loaded"
    die $S100
  if_3789_end:
    nqp_get_sc_object $P116, "__6MODEL_CORE__", 0
    $P117 = $P116."new_type"("GLOBALish" :named("name"))
    nqp_add_object_to_sc cur_sc, 0, $P117
    .const 'LexInfo' $P3790 = "10_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    $P3790."set_static_lexpad_value"("GLOBALish", $P116)
    .const 'LexInfo' $P3791 = "10_1325892461.451" 
    $P3791."finish_static_lexpad"()
    .const 'LexInfo' $P3792 = "10_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    $P3792."set_static_lexpad_value"("$?PACKAGE", $P116)
    .const 'LexInfo' $P3793 = "10_1325892461.451" 
    $P3793."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    $P117 = $P116."load_setting"("NQPCORE")
    block."set_outer_ctx"($P117)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    nqp_get_sc_object $P117, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    $P116."load_module"("NQPRegex", $P117)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P116, "ModuleLoader"
    nqp_get_sc_object $P117, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    $P116."load_module"("NQPP6Regex", $P117)
    nqp_get_sc $P116, "F3E24B0F152705B4B497A988620E1A8B7CA5D66B-1325892443.687"
    isnull $I101, $P116
    unless $I101, if_3794_end
    set $S100, "Incorrect pre-compiled version of src\\stage2\\gen\\nqp-mo.pm loaded"
    die $S100
  if_3794_end:
    nqp_get_sc_object $P116, "F3E24B0F152705B4B497A988620E1A8B7CA5D66B-1325892443.687", 55
    $P117 = $P116."new_type"("NQP::World" :named("name"))
    nqp_add_object_to_sc cur_sc, 1, $P117
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    nqp_get_sc_object $P117, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["World"], $P116
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3795 = "14_1325892461.451" 
    $P117."add_method"($P118, "load_setting", $P3795)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3796 = "16_1325892461.451" 
    $P117."add_method"($P118, "load_module", $P3796)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3797 = "17_1325892461.451" 
    $P117."add_method"($P118, "install_package_symbol", $P3797)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3798 = "21_1325892461.451" 
    $P117."add_method"($P118, "install_lexical_symbol", $P3798)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3799 = "22_1325892461.451" 
    $P117."add_method"($P118, "install_package_routine", $P3799)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3800 = "23_1325892461.451" 
    $P117."add_method"($P118, "pkg_create_mo", $P3800)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3801 = "25_1325892461.451" 
    $P117."add_method"($P118, "pkg_add_attribute", $P3801)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3802 = "29_1325892461.451" 
    $P117."add_method"($P118, "pkg_add_method", $P3802)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3803 = "32_1325892461.451" 
    $P117."add_method"($P118, "set_routine_signature", $P3803)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3804 = "33_1325892461.451" 
    $P117."add_method"($P118, "pkg_set_body_block", $P3804)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3805 = "38_1325892461.451" 
    $P117."add_method"($P118, "pkg_add_parent_or_role", $P3805)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3806 = "40_1325892461.451" 
    $P117."add_method"($P118, "pkg_add_parrot_vtable_handler_mapping", $P3806)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3807 = "42_1325892461.451" 
    $P117."add_method"($P118, "pkg_compose", $P3807)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    .const '' $P3808 = "44_1325892461.451" 
    $P117."add_method"($P118, "to_past", $P3808)
    .const 'LexInfo' $P3809 = "13_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    $P3809."set_static_lexpad_value"("$?PACKAGE", $P116)
    .const 'LexInfo' $P3810 = "13_1325892461.451" 
    $P3810."finish_static_lexpad"()
    .const 'LexInfo' $P3811 = "13_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    $P3811."set_static_lexpad_value"("$?CLASS", $P116)
    .const 'LexInfo' $P3812 = "13_1325892461.451" 
    $P3812."finish_static_lexpad"()
    nqp_get_sc $P116, "01AA8696BD92CF2ED32AF7809059A8B211BDAD44-1325892447.329"
    isnull $I101, $P116
    unless $I101, if_3813_end
    set $S100, "Incorrect pre-compiled version of src\\stage2\\gen\\NQPHLL.pm loaded"
    die $S100
  if_3813_end:
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    nqp_get_sc_object $P119, "01AA8696BD92CF2ED32AF7809059A8B211BDAD44-1325892447.329", 198
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 1
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "F3E24B0F152705B4B497A988620E1A8B7CA5D66B-1325892443.687", 55
    $P117 = $P116."new_type"("NQP::Grammar" :named("name"))
    nqp_add_object_to_sc cur_sc, 16, $P117
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    nqp_get_sc_object $P117, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Grammar"], $P116
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3814 = "47_1325892461.451" 
    $P117."add_method"($P118, "TOP", $P3814)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3815 = "48_1325892461.451" 
    $P117."add_method"($P118, "identifier", $P3815)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3816 = "49_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__identifier", $P3816)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3817 = "50_1325892461.451" 
    $P117."add_method"($P118, "name", $P3817)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3818 = "51_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__name", $P3818)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3819 = "52_1325892461.451" 
    $P117."add_method"($P118, "deflongname", $P3819)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3820 = "53_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__deflongname", $P3820)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3821 = "54_1325892461.451" 
    $P117."add_method"($P118, "ENDSTMT", $P3821)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3822 = "55_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__ENDSTMT", $P3822)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3823 = "56_1325892461.451" 
    $P117."add_method"($P118, "ws", $P3823)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3824 = "57_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__ws", $P3824)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3825 = "58_1325892461.451" 
    $P117."add_method"($P118, "unv", $P3825)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3826 = "60_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__unv", $P3826)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3827 = "61_1325892461.451" 
    $P117."add_method"($P118, "pod_comment", $P3827)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3828 = "63_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__pod_comment", $P3828)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3829 = "64_1325892461.451" 
    $P117."add_method"($P118, "comp_unit", $P3829)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3830 = "65_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__comp_unit", $P3830)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3831 = "66_1325892461.451" 
    $P117."add_method"($P118, "statementlist", $P3831)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3832 = "67_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statementlist", $P3832)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3833 = "68_1325892461.451" 
    $P117."add_method"($P118, "statement", $P3833)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3834 = "70_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement", $P3834)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3835 = "71_1325892461.451" 
    $P117."add_method"($P118, "eat_terminator", $P3835)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3836 = "72_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__eat_terminator", $P3836)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3837 = "73_1325892461.451" 
    $P117."add_method"($P118, "xblock", $P3837)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3838 = "74_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__xblock", $P3838)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3839 = "75_1325892461.451" 
    $P117."add_method"($P118, "pblock", $P3839)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3840 = "76_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__pblock", $P3840)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3841 = "77_1325892461.451" 
    $P117."add_method"($P118, "lambda", $P3841)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3842 = "78_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__lambda", $P3842)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3843 = "79_1325892461.451" 
    $P117."add_method"($P118, "block", $P3843)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3844 = "80_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__block", $P3844)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3845 = "81_1325892461.451" 
    $P117."add_method"($P118, "blockoid", $P3845)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3846 = "82_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__blockoid", $P3846)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3847 = "83_1325892461.451" 
    $P117."add_method"($P118, "newpad", $P3847)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3848 = "84_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__newpad", $P3848)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3849 = "85_1325892461.451" 
    $P117."add_method"($P118, "outerctx", $P3849)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3850 = "86_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__outerctx", $P3850)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3851 = "87_1325892461.451" 
    $P117."add_method"($P118, "GLOBALish", $P3851)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3852 = "88_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__GLOBALish", $P3852)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3853 = "89_1325892461.451" 
    $P117."add_method"($P118, "finishpad", $P3853)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3854 = "90_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__finishpad", $P3854)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3855 = "91_1325892461.451" 
    $P117."add_method"($P118, "you_are_here", $P3855)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3856 = "92_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__you_are_here", $P3856)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3857 = "93_1325892461.451" 
    $P117."add_method"($P118, "terminator", $P3857)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3858 = "94_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__terminator", $P3858)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3859 = "95_1325892461.451" 
    $P117."add_method"($P118, "terminator:sym<;>", $P3859)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3860 = "96_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__terminator:sym<;>", $P3860)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3861 = "97_1325892461.451" 
    $P117."add_method"($P118, "terminator:sym<}>", $P3861)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3862 = "98_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__terminator:sym<}>", $P3862)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3863 = "99_1325892461.451" 
    $P117."add_method"($P118, "statement_control", $P3863)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3864 = "100_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_control", $P3864)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3865 = "101_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<use>", $P3865)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3866 = "102_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<use>", $P3866)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3867 = "103_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<if>", $P3867)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3868 = "104_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<if>", $P3868)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3869 = "105_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<unless>", $P3869)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3870 = "107_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<unless>", $P3870)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3871 = "108_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<while>", $P3871)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3872 = "109_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<while>", $P3872)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3873 = "110_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<repeat>", $P3873)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3874 = "111_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<repeat>", $P3874)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3875 = "112_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<for>", $P3875)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3876 = "113_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<for>", $P3876)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3877 = "114_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<CATCH>", $P3877)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3878 = "115_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<CATCH>", $P3878)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3879 = "116_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<CONTROL>", $P3879)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3880 = "117_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_control:sym<CONTROL>", $P3880)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3881 = "118_1325892461.451" 
    $P117."add_method"($P118, "statement_prefix", $P3881)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3882 = "119_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix", $P3882)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3883 = "120_1325892461.451" 
    $P117."add_method"($P118, "statement_prefix:sym<INIT>", $P3883)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3884 = "121_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix:sym<INIT>", $P3884)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3885 = "122_1325892461.451" 
    $P117."add_method"($P118, "statement_prefix:sym<try>", $P3885)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3886 = "123_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_prefix:sym<try>", $P3886)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3887 = "124_1325892461.451" 
    $P117."add_method"($P118, "blorst", $P3887)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3888 = "125_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__blorst", $P3888)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3889 = "126_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_cond", $P3889)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3890 = "127_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond", $P3890)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3891 = "128_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_cond:sym<if>", $P3891)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3892 = "129_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond:sym<if>", $P3892)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3893 = "130_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_cond:sym<unless>", $P3893)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3894 = "131_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_cond:sym<unless>", $P3894)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3895 = "132_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_loop", $P3895)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3896 = "133_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop", $P3896)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3897 = "134_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_loop:sym<while>", $P3897)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3898 = "135_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<while>", $P3898)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3899 = "136_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_loop:sym<until>", $P3899)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3900 = "137_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<until>", $P3900)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3901 = "138_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_loop:sym<for>", $P3901)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3902 = "139_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__statement_mod_loop:sym<for>", $P3902)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3903 = "140_1325892461.451" 
    $P117."add_method"($P118, "term:sym<fatarrow>", $P3903)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3904 = "141_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<fatarrow>", $P3904)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3905 = "142_1325892461.451" 
    $P117."add_method"($P118, "term:sym<colonpair>", $P3905)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3906 = "143_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<colonpair>", $P3906)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3907 = "144_1325892461.451" 
    $P117."add_method"($P118, "term:sym<variable>", $P3907)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3908 = "145_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<variable>", $P3908)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3909 = "146_1325892461.451" 
    $P117."add_method"($P118, "term:sym<package_declarator>", $P3909)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3910 = "147_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<package_declarator>", $P3910)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3911 = "148_1325892461.451" 
    $P117."add_method"($P118, "term:sym<scope_declarator>", $P3911)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3912 = "149_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<scope_declarator>", $P3912)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3913 = "150_1325892461.451" 
    $P117."add_method"($P118, "term:sym<routine_declarator>", $P3913)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3914 = "151_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<routine_declarator>", $P3914)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3915 = "152_1325892461.451" 
    $P117."add_method"($P118, "term:sym<multi_declarator>", $P3915)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3916 = "155_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<multi_declarator>", $P3916)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3917 = "156_1325892461.451" 
    $P117."add_method"($P118, "term:sym<regex_declarator>", $P3917)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3918 = "157_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<regex_declarator>", $P3918)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3919 = "158_1325892461.451" 
    $P117."add_method"($P118, "term:sym<statement_prefix>", $P3919)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3920 = "159_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<statement_prefix>", $P3920)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3921 = "160_1325892461.451" 
    $P117."add_method"($P118, "term:sym<lambda>", $P3921)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3922 = "161_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<lambda>", $P3922)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3923 = "162_1325892461.451" 
    $P117."add_method"($P118, "fatarrow", $P3923)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3924 = "163_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__fatarrow", $P3924)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3925 = "164_1325892461.451" 
    $P117."add_method"($P118, "colonpair", $P3925)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3926 = "165_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__colonpair", $P3926)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3927 = "166_1325892461.451" 
    $P117."add_method"($P118, "variable", $P3927)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3928 = "167_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__variable", $P3928)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3929 = "168_1325892461.451" 
    $P117."add_method"($P118, "sigil", $P3929)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3930 = "169_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__sigil", $P3930)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3931 = "170_1325892461.451" 
    $P117."add_method"($P118, "twigil", $P3931)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3932 = "171_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__twigil", $P3932)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3933 = "172_1325892461.451" 
    $P117."add_method"($P118, "package_declarator", $P3933)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3934 = "173_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__package_declarator", $P3934)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3935 = "174_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<module>", $P3935)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3936 = "175_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<module>", $P3936)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3937 = "176_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<knowhow>", $P3937)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3938 = "177_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<knowhow>", $P3938)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3939 = "178_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<class>", $P3939)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3940 = "179_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<class>", $P3940)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3941 = "180_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<grammar>", $P3941)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3942 = "181_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<grammar>", $P3942)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3943 = "182_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<role>", $P3943)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3944 = "183_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<role>", $P3944)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3945 = "184_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<native>", $P3945)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3946 = "185_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<native>", $P3946)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3947 = "186_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<stub>", $P3947)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3948 = "187_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__package_declarator:sym<stub>", $P3948)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3949 = "188_1325892461.451" 
    $P117."add_method"($P118, "package_def", $P3949)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3950 = "190_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__package_def", $P3950)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3951 = "191_1325892461.451" 
    $P117."add_method"($P118, "scope_declarator", $P3951)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3952 = "192_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator", $P3952)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3953 = "193_1325892461.451" 
    $P117."add_method"($P118, "scope_declarator:sym<my>", $P3953)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3954 = "194_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<my>", $P3954)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3955 = "195_1325892461.451" 
    $P117."add_method"($P118, "scope_declarator:sym<our>", $P3955)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3956 = "196_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<our>", $P3956)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3957 = "197_1325892461.451" 
    $P117."add_method"($P118, "scope_declarator:sym<has>", $P3957)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3958 = "198_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__scope_declarator:sym<has>", $P3958)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3959 = "199_1325892461.451" 
    $P117."add_method"($P118, "scoped", $P3959)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3960 = "200_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__scoped", $P3960)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3961 = "201_1325892461.451" 
    $P117."add_method"($P118, "typename", $P3961)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3962 = "203_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__typename", $P3962)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3963 = "204_1325892461.451" 
    $P117."add_method"($P118, "declarator", $P3963)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3964 = "205_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__declarator", $P3964)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3965 = "206_1325892461.451" 
    $P117."add_method"($P118, "variable_declarator", $P3965)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3966 = "208_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__variable_declarator", $P3966)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3967 = "209_1325892461.451" 
    $P117."add_method"($P118, "routine_declarator", $P3967)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3968 = "210_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator", $P3968)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3969 = "211_1325892461.451" 
    $P117."add_method"($P118, "routine_declarator:sym<sub>", $P3969)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3970 = "212_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator:sym<sub>", $P3970)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3971 = "213_1325892461.451" 
    $P117."add_method"($P118, "routine_declarator:sym<method>", $P3971)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3972 = "214_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__routine_declarator:sym<method>", $P3972)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3973 = "215_1325892461.451" 
    $P117."add_method"($P118, "routine_def", $P3973)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3974 = "216_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__routine_def", $P3974)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3975 = "217_1325892461.451" 
    $P117."add_method"($P118, "method_def", $P3975)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3976 = "219_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__method_def", $P3976)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3977 = "220_1325892461.451" 
    $P117."add_method"($P118, "onlystar", $P3977)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3978 = "222_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__onlystar", $P3978)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3979 = "223_1325892461.451" 
    $P117."add_method"($P118, "multi_declarator", $P3979)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3980 = "224_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator", $P3980)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3981 = "225_1325892461.451" 
    $P117."add_method"($P118, "multi_declarator:sym<multi>", $P3981)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3982 = "226_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<multi>", $P3982)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3983 = "227_1325892461.451" 
    $P117."add_method"($P118, "multi_declarator:sym<proto>", $P3983)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3984 = "228_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<proto>", $P3984)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3985 = "229_1325892461.451" 
    $P117."add_method"($P118, "multi_declarator:sym<null>", $P3985)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3986 = "230_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__multi_declarator:sym<null>", $P3986)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3987 = "231_1325892461.451" 
    $P117."add_method"($P118, "signature", $P3987)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3988 = "233_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__signature", $P3988)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3989 = "234_1325892461.451" 
    $P117."add_method"($P118, "parameter", $P3989)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3990 = "235_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__parameter", $P3990)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3991 = "236_1325892461.451" 
    $P117."add_method"($P118, "param_var", $P3991)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3992 = "237_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__param_var", $P3992)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3993 = "238_1325892461.451" 
    $P117."add_method"($P118, "named_param", $P3993)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3994 = "239_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__named_param", $P3994)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3995 = "240_1325892461.451" 
    $P117."add_method"($P118, "default_value", $P3995)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3996 = "241_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__default_value", $P3996)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3997 = "242_1325892461.451" 
    $P117."add_method"($P118, "trait", $P3997)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3998 = "243_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__trait", $P3998)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P3999 = "244_1325892461.451" 
    $P117."add_method"($P118, "trait_mod", $P3999)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4000 = "245_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__trait_mod", $P4000)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4001 = "246_1325892461.451" 
    $P117."add_method"($P118, "trait_mod:sym<is>", $P4001)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4002 = "247_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__trait_mod:sym<is>", $P4002)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4003 = "248_1325892461.451" 
    $P117."add_method"($P118, "regex_declarator", $P4003)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4004 = "249_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__regex_declarator", $P4004)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4005 = "250_1325892461.451" 
    $P117."add_method"($P118, "dotty", $P4005)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4006 = "251_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__dotty", $P4006)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4007 = "252_1325892461.451" 
    $P117."add_method"($P118, "term", $P4007)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4008 = "253_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term", $P4008)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4009 = "254_1325892461.451" 
    $P117."add_method"($P118, "term:sym<self>", $P4009)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4010 = "255_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<self>", $P4010)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4011 = "256_1325892461.451" 
    $P117."add_method"($P118, "term:sym<identifier>", $P4011)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4012 = "257_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<identifier>", $P4012)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4013 = "258_1325892461.451" 
    $P117."add_method"($P118, "term:sym<name>", $P4013)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4014 = "259_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<name>", $P4014)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4015 = "260_1325892461.451" 
    $P117."add_method"($P118, "term:sym<pir::op>", $P4015)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4016 = "261_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<pir::op>", $P4016)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4017 = "262_1325892461.451" 
    $P117."add_method"($P118, "term:sym<pir::const>", $P4017)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4018 = "263_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<pir::const>", $P4018)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4019 = "264_1325892461.451" 
    $P117."add_method"($P118, "term:sym<nqp::op>", $P4019)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4020 = "265_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<nqp::op>", $P4020)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4021 = "266_1325892461.451" 
    $P117."add_method"($P118, "term:sym<onlystar>", $P4021)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4022 = "268_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<onlystar>", $P4022)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4023 = "269_1325892461.451" 
    $P117."add_method"($P118, "args", $P4023)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4024 = "270_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__args", $P4024)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4025 = "271_1325892461.451" 
    $P117."add_method"($P118, "arglist", $P4025)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4026 = "272_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__arglist", $P4026)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4027 = "273_1325892461.451" 
    $P117."add_method"($P118, "term:sym<value>", $P4027)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4028 = "274_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<value>", $P4028)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4029 = "275_1325892461.451" 
    $P117."add_method"($P118, "value", $P4029)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4030 = "276_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__value", $P4030)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4031 = "277_1325892461.451" 
    $P117."add_method"($P118, "number", $P4031)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4032 = "278_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__number", $P4032)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4033 = "279_1325892461.451" 
    $P117."add_method"($P118, "quote", $P4033)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4034 = "280_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote", $P4034)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4035 = "281_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<apos>", $P4035)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4036 = "282_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<apos>", $P4036)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4037 = "283_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<dblq>", $P4037)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4038 = "284_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<dblq>", $P4038)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4039 = "285_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<q>", $P4039)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4040 = "286_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<q>", $P4040)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4041 = "287_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<qq>", $P4041)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4042 = "288_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<qq>", $P4042)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4043 = "289_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<Q>", $P4043)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4044 = "290_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<Q>", $P4044)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4045 = "291_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<Q:PIR>", $P4045)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4046 = "292_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote:sym<Q:PIR>", $P4046)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4047 = "293_1325892461.451" 
    $P117."add_method"($P118, "quote:sym</ />", $P4047)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4048 = "294_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote:sym</ />", $P4048)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4049 = "295_1325892461.451" 
    $P117."add_method"($P118, "quote_escape:sym<$>", $P4049)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4050 = "296_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<$>", $P4050)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4051 = "297_1325892461.451" 
    $P117."add_method"($P118, "quote_escape:sym<{ }>", $P4051)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4052 = "298_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<{ }>", $P4052)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4053 = "299_1325892461.451" 
    $P117."add_method"($P118, "quote_escape:sym<esc>", $P4053)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4054 = "300_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__quote_escape:sym<esc>", $P4054)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4055 = "301_1325892461.451" 
    $P117."add_method"($P118, "circumfix:sym<( )>", $P4055)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4056 = "302_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<( )>", $P4056)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4057 = "303_1325892461.451" 
    $P117."add_method"($P118, "circumfix:sym<[ ]>", $P4057)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4058 = "304_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<[ ]>", $P4058)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4059 = "305_1325892461.451" 
    $P117."add_method"($P118, "circumfix:sym<ang>", $P4059)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4060 = "306_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<ang>", $P4060)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4061 = "307_1325892461.451" 
    $P117."add_method"($P118, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P4061)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4062 = "308_1325892461.451" 
    $P117."add_method"($P118, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P4062)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4063 = "309_1325892461.451" 
    $P117."add_method"($P118, "circumfix:sym<{ }>", $P4063)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4064 = "310_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<{ }>", $P4064)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4065 = "311_1325892461.451" 
    $P117."add_method"($P118, "circumfix:sym<sigil>", $P4065)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4066 = "312_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__circumfix:sym<sigil>", $P4066)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4067 = "313_1325892461.451" 
    $P117."add_method"($P118, "semilist", $P4067)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4068 = "314_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__semilist", $P4068)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4069 = "315_1325892461.451" 
    $P117."add_method"($P118, "infixish", $P4069)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4070 = "316_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infixish", $P4070)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4071 = "317_1325892461.451" 
    $P117."add_method"($P118, "infixstopper", $P4071)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4072 = "318_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infixstopper", $P4072)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4073 = "319_1325892461.451" 
    $P117."add_method"($P118, "postcircumfix:sym<[ ]>", $P4073)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4074 = "320_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<[ ]>", $P4074)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4075 = "321_1325892461.451" 
    $P117."add_method"($P118, "postcircumfix:sym<{ }>", $P4075)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4076 = "322_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<{ }>", $P4076)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4077 = "323_1325892461.451" 
    $P117."add_method"($P118, "postcircumfix:sym<ang>", $P4077)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4078 = "324_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<ang>", $P4078)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4079 = "325_1325892461.451" 
    $P117."add_method"($P118, "postcircumfix:sym<( )>", $P4079)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4080 = "326_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__postcircumfix:sym<( )>", $P4080)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4081 = "327_1325892461.451" 
    $P117."add_method"($P118, "postfix:sym<.>", $P4081)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4082 = "328_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<.>", $P4082)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4083 = "329_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<++>", $P4083)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4084 = "330_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<++>", $P4084)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4085 = "331_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<-->", $P4085)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4086 = "332_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<-->", $P4086)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4087 = "333_1325892461.451" 
    $P117."add_method"($P118, "postfix:sym<++>", $P4087)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4088 = "334_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<++>", $P4088)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4089 = "335_1325892461.451" 
    $P117."add_method"($P118, "postfix:sym<-->", $P4089)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4090 = "336_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__postfix:sym<-->", $P4090)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4091 = "337_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<**>", $P4091)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4092 = "338_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<**>", $P4092)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4093 = "339_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<+>", $P4093)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4094 = "340_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<+>", $P4094)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4095 = "341_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<~>", $P4095)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4096 = "342_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<~>", $P4096)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4097 = "343_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<->", $P4097)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4098 = "344_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<->", $P4098)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4099 = "345_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<?>", $P4099)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4100 = "346_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<?>", $P4100)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4101 = "347_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<!>", $P4101)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4102 = "348_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<!>", $P4102)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4103 = "349_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<|>", $P4103)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4104 = "350_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<|>", $P4104)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4105 = "351_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<*>", $P4105)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4106 = "352_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<*>", $P4106)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4107 = "353_1325892461.451" 
    $P117."add_method"($P118, "infix:sym</>", $P4107)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4108 = "354_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym</>", $P4108)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4109 = "355_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<%>", $P4109)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4110 = "356_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<%>", $P4110)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4111 = "357_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<+&>", $P4111)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4112 = "358_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+&>", $P4112)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4113 = "359_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<+>", $P4113)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4114 = "360_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+>", $P4114)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4115 = "361_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<->", $P4115)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4116 = "362_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<->", $P4116)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4117 = "363_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<+|>", $P4117)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4118 = "364_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+|>", $P4118)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4119 = "365_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<+^>", $P4119)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4120 = "366_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<+^>", $P4120)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4121 = "367_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<~>", $P4121)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4122 = "368_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<~>", $P4122)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4123 = "369_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<==>", $P4123)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4124 = "370_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<==>", $P4124)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4125 = "371_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<!=>", $P4125)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4126 = "372_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<!=>", $P4126)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4127 = "373_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<<=>", $P4127)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4128 = "374_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<<=>", $P4128)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4129 = "375_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<>=>", $P4129)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4130 = "376_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<>=>", $P4130)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4131 = "377_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<<>", $P4131)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4132 = "378_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<<>", $P4132)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4133 = "379_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<>>", $P4133)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4134 = "380_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<>>", $P4134)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4135 = "381_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<eq>", $P4135)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4136 = "382_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<eq>", $P4136)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4137 = "383_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<ne>", $P4137)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4138 = "384_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<ne>", $P4138)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4139 = "385_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<le>", $P4139)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4140 = "386_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<le>", $P4140)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4141 = "387_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<ge>", $P4141)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4142 = "388_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<ge>", $P4142)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4143 = "389_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<lt>", $P4143)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4144 = "390_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<lt>", $P4144)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4145 = "391_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<gt>", $P4145)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4146 = "392_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<gt>", $P4146)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4147 = "393_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<=:=>", $P4147)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4148 = "394_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<=:=>", $P4148)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4149 = "395_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<~~>", $P4149)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4150 = "396_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<~~>", $P4150)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4151 = "397_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<&&>", $P4151)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4152 = "398_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<&&>", $P4152)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4153 = "399_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<||>", $P4153)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4154 = "400_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<||>", $P4154)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4155 = "401_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<//>", $P4155)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4156 = "402_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<//>", $P4156)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4157 = "403_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<?? !!>", $P4157)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4158 = "404_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<?? !!>", $P4158)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4159 = "405_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<=>", $P4159)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4160 = "406_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<=>", $P4160)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4161 = "407_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<:=>", $P4161)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4162 = "408_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<:=>", $P4162)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4163 = "409_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<::=>", $P4163)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4164 = "410_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<::=>", $P4164)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4165 = "411_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<,>", $P4165)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4166 = "412_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__infix:sym<,>", $P4166)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4167 = "413_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<return>", $P4167)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4168 = "415_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<return>", $P4168)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4169 = "416_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<make>", $P4169)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4170 = "417_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__prefix:sym<make>", $P4170)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4171 = "418_1325892461.451" 
    $P117."add_method"($P118, "term:sym<last>", $P4171)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4172 = "419_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<last>", $P4172)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4173 = "420_1325892461.451" 
    $P117."add_method"($P118, "term:sym<next>", $P4173)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4174 = "421_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<next>", $P4174)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4175 = "422_1325892461.451" 
    $P117."add_method"($P118, "term:sym<redo>", $P4175)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4176 = "423_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__term:sym<redo>", $P4176)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    .const '' $P4177 = "424_1325892461.451" 
    $P117."add_method"($P118, "smartmatch", $P4177)
    .const 'LexInfo' $P4178 = "46_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    $P4178."set_static_lexpad_value"("$?PACKAGE", $P116)
    .const 'LexInfo' $P4179 = "46_1325892461.451" 
    $P4179."finish_static_lexpad"()
    .const 'LexInfo' $P4180 = "46_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    $P4180."set_static_lexpad_value"("$?CLASS", $P116)
    .const 'LexInfo' $P4181 = "46_1325892461.451" 
    $P4181."finish_static_lexpad"()
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    nqp_get_sc_object $P119, "01AA8696BD92CF2ED32AF7809059A8B211BDAD44-1325892447.329", 1
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 16
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "F3E24B0F152705B4B497A988620E1A8B7CA5D66B-1325892443.687", 55
    $P117 = $P116."new_type"("NQP::Regex" :named("name"))
    nqp_add_object_to_sc cur_sc, 381, $P117
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    nqp_get_sc_object $P117, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Regex"], $P116
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4182 = "426_1325892461.451" 
    $P117."add_method"($P118, "metachar:sym<:my>", $P4182)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4183 = "428_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<:my>", $P4183)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4184 = "429_1325892461.451" 
    $P117."add_method"($P118, "metachar:sym<{ }>", $P4184)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4185 = "430_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<{ }>", $P4185)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4186 = "431_1325892461.451" 
    $P117."add_method"($P118, "metachar:sym<nqpvar>", $P4186)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4187 = "433_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__metachar:sym<nqpvar>", $P4187)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4188 = "434_1325892461.451" 
    $P117."add_method"($P118, "assertion:sym<{ }>", $P4188)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4189 = "435_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<{ }>", $P4189)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4190 = "436_1325892461.451" 
    $P117."add_method"($P118, "assertion:sym<?{ }>", $P4190)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4191 = "438_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<?{ }>", $P4191)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4192 = "439_1325892461.451" 
    $P117."add_method"($P118, "assertion:sym<name>", $P4192)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4193 = "441_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<name>", $P4193)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4194 = "442_1325892461.451" 
    $P117."add_method"($P118, "assertion:sym<var>", $P4194)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4195 = "443_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__assertion:sym<var>", $P4195)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4196 = "444_1325892461.451" 
    $P117."add_method"($P118, "codeblock", $P4196)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    .const '' $P4197 = "445_1325892461.451" 
    $P117."add_method"($P118, "!PREFIX__codeblock", $P4197)
    .const 'LexInfo' $P4198 = "425_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    $P4198."set_static_lexpad_value"("$?PACKAGE", $P116)
    .const 'LexInfo' $P4199 = "425_1325892461.451" 
    $P4199."finish_static_lexpad"()
    .const 'LexInfo' $P4200 = "425_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    $P4200."set_static_lexpad_value"("$?CLASS", $P116)
    .const 'LexInfo' $P4201 = "425_1325892461.451" 
    $P4201."finish_static_lexpad"()
    nqp_get_sc $P116, "9C3392566B1FBE8D8EE209AF5C35DE0C9294CD76-1325892452.032"
    isnull $I101, $P116
    unless $I101, if_4202_end
    set $S100, "Incorrect pre-compiled version of src\\stage2\\gen\\NQPP6Regex.pm loaded"
    die $S100
  if_4202_end:
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    nqp_get_sc_object $P119, "9C3392566B1FBE8D8EE209AF5C35DE0C9294CD76-1325892452.032", 1
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 381
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "F3E24B0F152705B4B497A988620E1A8B7CA5D66B-1325892443.687", 55
    $P117 = $P116."new_type"("NQP::Actions" :named("name"))
    nqp_add_object_to_sc cur_sc, 398, $P117
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    nqp_get_sc_object $P117, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Actions"], $P116
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4203 = "473_1325892461.451" 
    $P117."add_method"($P118, "TOP", $P4203)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4204 = "474_1325892461.451" 
    $P117."add_method"($P118, "deflongname", $P4204)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4205 = "475_1325892461.451" 
    $P117."add_method"($P118, "comp_unit", $P4205)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4206 = "477_1325892461.451" 
    $P117."add_method"($P118, "statementlist", $P4206)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4207 = "479_1325892461.451" 
    $P117."add_method"($P118, "statement", $P4207)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4208 = "481_1325892461.451" 
    $P117."add_method"($P118, "xblock", $P4208)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4209 = "482_1325892461.451" 
    $P117."add_method"($P118, "pblock", $P4209)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4210 = "483_1325892461.451" 
    $P117."add_method"($P118, "block", $P4210)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4211 = "484_1325892461.451" 
    $P117."add_method"($P118, "blockoid", $P4211)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4212 = "486_1325892461.451" 
    $P117."add_method"($P118, "newpad", $P4212)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4213 = "487_1325892461.451" 
    $P117."add_method"($P118, "outerctx", $P4213)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4214 = "489_1325892461.451" 
    $P117."add_method"($P118, "GLOBALish", $P4214)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4215 = "490_1325892461.451" 
    $P117."add_method"($P118, "you_are_here", $P4215)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4216 = "491_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<use>", $P4216)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4217 = "492_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<if>", $P4217)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4218 = "494_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<unless>", $P4218)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4219 = "495_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<while>", $P4219)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4220 = "496_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<repeat>", $P4220)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4221 = "497_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<for>", $P4221)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4222 = "498_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<CATCH>", $P4222)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4223 = "499_1325892461.451" 
    $P117."add_method"($P118, "statement_control:sym<CONTROL>", $P4223)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4224 = "500_1325892461.451" 
    $P117."add_method"($P118, "statement_prefix:sym<INIT>", $P4224)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4225 = "501_1325892461.451" 
    $P117."add_method"($P118, "statement_prefix:sym<try>", $P4225)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4226 = "502_1325892461.451" 
    $P117."add_method"($P118, "blorst", $P4226)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4227 = "503_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_cond:sym<if>", $P4227)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4228 = "504_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_cond:sym<unless>", $P4228)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4229 = "505_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_loop:sym<while>", $P4229)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4230 = "506_1325892461.451" 
    $P117."add_method"($P118, "statement_mod_loop:sym<until>", $P4230)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4231 = "507_1325892461.451" 
    $P117."add_method"($P118, "term:sym<fatarrow>", $P4231)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4232 = "508_1325892461.451" 
    $P117."add_method"($P118, "term:sym<colonpair>", $P4232)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4233 = "509_1325892461.451" 
    $P117."add_method"($P118, "term:sym<variable>", $P4233)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4234 = "510_1325892461.451" 
    $P117."add_method"($P118, "term:sym<package_declarator>", $P4234)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4235 = "511_1325892461.451" 
    $P117."add_method"($P118, "term:sym<scope_declarator>", $P4235)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4236 = "512_1325892461.451" 
    $P117."add_method"($P118, "term:sym<routine_declarator>", $P4236)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4237 = "513_1325892461.451" 
    $P117."add_method"($P118, "term:sym<regex_declarator>", $P4237)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4238 = "514_1325892461.451" 
    $P117."add_method"($P118, "term:sym<statement_prefix>", $P4238)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4239 = "515_1325892461.451" 
    $P117."add_method"($P118, "term:sym<lambda>", $P4239)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4240 = "516_1325892461.451" 
    $P117."add_method"($P118, "fatarrow", $P4240)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4241 = "517_1325892461.451" 
    $P117."add_method"($P118, "colonpair", $P4241)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4242 = "518_1325892461.451" 
    $P117."add_method"($P118, "variable", $P4242)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4243 = "524_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<module>", $P4243)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4244 = "525_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<knowhow>", $P4244)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4245 = "526_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<class>", $P4245)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4246 = "527_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<grammar>", $P4246)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4247 = "528_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<role>", $P4247)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4248 = "529_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<native>", $P4248)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4249 = "530_1325892461.451" 
    $P117."add_method"($P118, "package_declarator:sym<stub>", $P4249)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4250 = "531_1325892461.451" 
    $P117."add_method"($P118, "package_def", $P4250)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4251 = "537_1325892461.451" 
    $P117."add_method"($P118, "scope_declarator:sym<my>", $P4251)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4252 = "538_1325892461.451" 
    $P117."add_method"($P118, "scope_declarator:sym<our>", $P4252)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4253 = "539_1325892461.451" 
    $P117."add_method"($P118, "scope_declarator:sym<has>", $P4253)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4254 = "540_1325892461.451" 
    $P117."add_method"($P118, "scoped", $P4254)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4255 = "541_1325892461.451" 
    $P117."add_method"($P118, "declarator", $P4255)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4256 = "542_1325892461.451" 
    $P117."add_method"($P118, "multi_declarator:sym<multi>", $P4256)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4257 = "543_1325892461.451" 
    $P117."add_method"($P118, "multi_declarator:sym<proto>", $P4257)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4258 = "544_1325892461.451" 
    $P117."add_method"($P118, "multi_declarator:sym<null>", $P4258)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4259 = "545_1325892461.451" 
    $P117."add_method"($P118, "variable_declarator", $P4259)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4260 = "548_1325892461.451" 
    $P117."add_method"($P118, "routine_declarator:sym<sub>", $P4260)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4261 = "549_1325892461.451" 
    $P117."add_method"($P118, "routine_declarator:sym<method>", $P4261)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4262 = "550_1325892461.451" 
    $P117."add_method"($P118, "routine_def", $P4262)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4263 = "557_1325892461.451" 
    $P117."add_method"($P118, "method_def", $P4263)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4264 = "560_1325892461.451" 
    $P117."add_method"($P118, "signature", $P4264)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4265 = "563_1325892461.451" 
    $P117."add_method"($P118, "parameter", $P4265)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4266 = "564_1325892461.451" 
    $P117."add_method"($P118, "param_var", $P4266)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4267 = "565_1325892461.451" 
    $P117."add_method"($P118, "named_param", $P4267)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4268 = "566_1325892461.451" 
    $P117."add_method"($P118, "typename", $P4268)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4269 = "568_1325892461.451" 
    $P117."add_method"($P118, "trait", $P4269)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4270 = "569_1325892461.451" 
    $P117."add_method"($P118, "trait_mod:sym<is>", $P4270)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4271 = "574_1325892461.451" 
    $P117."add_method"($P118, "regex_declarator", $P4271)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4272 = "579_1325892461.451" 
    $P117."add_method"($P118, "dotty", $P4272)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4273 = "580_1325892461.451" 
    $P117."add_method"($P118, "term:sym<self>", $P4273)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4274 = "581_1325892461.451" 
    $P117."add_method"($P118, "term:sym<identifier>", $P4274)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4275 = "582_1325892461.451" 
    $P117."add_method"($P118, "term:sym<name>", $P4275)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4276 = "584_1325892461.451" 
    $P117."add_method"($P118, "term:sym<pir::op>", $P4276)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4277 = "585_1325892461.451" 
    $P117."add_method"($P118, "term:sym<pir::const>", $P4277)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4278 = "586_1325892461.451" 
    $P117."add_method"($P118, "term:sym<nqp::op>", $P4278)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4279 = "587_1325892461.451" 
    $P117."add_method"($P118, "term:sym<onlystar>", $P4279)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4280 = "588_1325892461.451" 
    $P117."add_method"($P118, "args", $P4280)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4281 = "589_1325892461.451" 
    $P117."add_method"($P118, "arglist", $P4281)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4282 = "592_1325892461.451" 
    $P117."add_method"($P118, "term:sym<multi_declarator>", $P4282)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4283 = "593_1325892461.451" 
    $P117."add_method"($P118, "term:sym<value>", $P4283)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4284 = "594_1325892461.451" 
    $P117."add_method"($P118, "circumfix:sym<( )>", $P4284)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4285 = "595_1325892461.451" 
    $P117."add_method"($P118, "circumfix:sym<[ ]>", $P4285)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4286 = "596_1325892461.451" 
    $P117."add_method"($P118, "circumfix:sym<ang>", $P4286)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4287 = "597_1325892461.451" 
    $P117."add_method"($P118, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P4287)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4288 = "598_1325892461.451" 
    $P117."add_method"($P118, "circumfix:sym<{ }>", $P4288)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4289 = "600_1325892461.451" 
    $P117."add_method"($P118, "circumfix:sym<sigil>", $P4289)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4290 = "601_1325892461.451" 
    $P117."add_method"($P118, "semilist", $P4290)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4291 = "602_1325892461.451" 
    $P117."add_method"($P118, "postcircumfix:sym<[ ]>", $P4291)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4292 = "603_1325892461.451" 
    $P117."add_method"($P118, "postcircumfix:sym<{ }>", $P4292)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4293 = "604_1325892461.451" 
    $P117."add_method"($P118, "postcircumfix:sym<ang>", $P4293)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4294 = "605_1325892461.451" 
    $P117."add_method"($P118, "postcircumfix:sym<( )>", $P4294)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4295 = "606_1325892461.451" 
    $P117."add_method"($P118, "value", $P4295)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4296 = "607_1325892461.451" 
    $P117."add_method"($P118, "number", $P4296)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4297 = "608_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<apos>", $P4297)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4298 = "609_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<dblq>", $P4298)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4299 = "610_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<qq>", $P4299)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4300 = "611_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<q>", $P4300)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4301 = "612_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<Q>", $P4301)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4302 = "613_1325892461.451" 
    $P117."add_method"($P118, "quote:sym<Q:PIR>", $P4302)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4303 = "614_1325892461.451" 
    $P117."add_method"($P118, "quote:sym</ />", $P4303)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4304 = "615_1325892461.451" 
    $P117."add_method"($P118, "quote_escape:sym<$>", $P4304)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4305 = "616_1325892461.451" 
    $P117."add_method"($P118, "quote_escape:sym<{ }>", $P4305)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4306 = "617_1325892461.451" 
    $P117."add_method"($P118, "quote_escape:sym<esc>", $P4306)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4307 = "618_1325892461.451" 
    $P117."add_method"($P118, "postfix:sym<.>", $P4307)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4308 = "619_1325892461.451" 
    $P117."add_method"($P118, "postfix:sym<++>", $P4308)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4309 = "620_1325892461.451" 
    $P117."add_method"($P118, "postfix:sym<-->", $P4309)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4310 = "621_1325892461.451" 
    $P117."add_method"($P118, "prefix:sym<make>", $P4310)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4311 = "622_1325892461.451" 
    $P117."add_method"($P118, "term:sym<next>", $P4311)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4312 = "623_1325892461.451" 
    $P117."add_method"($P118, "term:sym<last>", $P4312)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4313 = "624_1325892461.451" 
    $P117."add_method"($P118, "term:sym<redo>", $P4313)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4314 = "625_1325892461.451" 
    $P117."add_method"($P118, "infix:sym<~~>", $P4314)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    .const '' $P4315 = "626_1325892461.451" 
    $P117."add_method"($P118, "known_sym", $P4315)
    .const 'LexInfo' $P4316 = "446_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    $P4316."set_static_lexpad_value"("$?PACKAGE", $P116)
    .const 'LexInfo' $P4317 = "446_1325892461.451" 
    $P4317."finish_static_lexpad"()
    .const 'LexInfo' $P4318 = "446_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    $P4318."set_static_lexpad_value"("$?CLASS", $P116)
    .const 'LexInfo' $P4319 = "446_1325892461.451" 
    $P4319."finish_static_lexpad"()
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    nqp_get_sc_object $P119, "01AA8696BD92CF2ED32AF7809059A8B211BDAD44-1325892447.329", 105
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 398
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "F3E24B0F152705B4B497A988620E1A8B7CA5D66B-1325892443.687", 55
    $P117 = $P116."new_type"("NQP::RegexActions" :named("name"))
    nqp_add_object_to_sc cur_sc, 512, $P117
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    nqp_get_sc_object $P117, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["RegexActions"], $P116
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    .const '' $P4320 = "629_1325892461.451" 
    $P117."add_method"($P118, "metachar:sym<:my>", $P4320)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    .const '' $P4321 = "630_1325892461.451" 
    $P117."add_method"($P118, "metachar:sym<{ }>", $P4321)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    .const '' $P4322 = "631_1325892461.451" 
    $P117."add_method"($P118, "metachar:sym<nqpvar>", $P4322)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    .const '' $P4323 = "632_1325892461.451" 
    $P117."add_method"($P118, "assertion:sym<{ }>", $P4323)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    .const '' $P4324 = "633_1325892461.451" 
    $P117."add_method"($P118, "assertion:sym<?{ }>", $P4324)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    .const '' $P4325 = "634_1325892461.451" 
    $P117."add_method"($P118, "assertion:sym<var>", $P4325)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    .const '' $P4326 = "635_1325892461.451" 
    $P117."add_method"($P118, "codeblock", $P4326)
    .const 'LexInfo' $P4327 = "628_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    $P4327."set_static_lexpad_value"("$?PACKAGE", $P116)
    .const 'LexInfo' $P4328 = "628_1325892461.451" 
    $P4328."finish_static_lexpad"()
    .const 'LexInfo' $P4329 = "628_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    $P4329."set_static_lexpad_value"("$?CLASS", $P116)
    .const 'LexInfo' $P4330 = "628_1325892461.451" 
    $P4330."finish_static_lexpad"()
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    nqp_get_sc_object $P119, "9C3392566B1FBE8D8EE209AF5C35DE0C9294CD76-1325892452.032", 145
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 512
    $P117."compose"($P118)
    nqp_get_sc_object $P116, "F3E24B0F152705B4B497A988620E1A8B7CA5D66B-1325892443.687", 55
    $P117 = $P116."new_type"("NQP::Compiler" :named("name"))
    nqp_add_object_to_sc cur_sc, 520, $P117
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 520
    nqp_get_sc_object $P117, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    nqp_get_package_through_who $P118, $P117, "NQP"
    get_who $P119, $P118
    set $P119["Compiler"], $P116
    .const 'LexInfo' $P4331 = "636_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 520
    $P4331."set_static_lexpad_value"("$?PACKAGE", $P116)
    .const 'LexInfo' $P4332 = "636_1325892461.451" 
    $P4332."finish_static_lexpad"()
    .const 'LexInfo' $P4333 = "636_1325892461.451" 
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 520
    $P4333."set_static_lexpad_value"("$?CLASS", $P116)
    .const 'LexInfo' $P4334 = "636_1325892461.451" 
    $P4334."finish_static_lexpad"()
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 520
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 520
    nqp_get_sc_object $P119, "01AA8696BD92CF2ED32AF7809059A8B211BDAD44-1325892447.329", 139
    $P117."add_parent"($P118, $P119)
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 520
    get_how $P117, $P116
    nqp_get_sc_object $P118, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 520
    $P117."compose"($P118)
  if_3788_end:
    nqp_get_sc_object $P116, "236F44AE8C4713468000F1DFBD3370023EADFD15-1325892455.248", 0
    set_hll_global "GLOBAL", $P116
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1325892461.451") :outer("10_1325892461.451")
    .param pmc param_1007
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2821
    .lex "@ARGS", param_1007
.annotate 'line', 2823
    new $P100, "Undef"
    set $P1008, $P100
    .lex "$nqpcomp", $P1008
.annotate 'line', 2830
    $P1010 = root_new ['parrot';'ResizablePMCArray']
    set $P1009, $P1010
    .lex "@clo", $P1009
.annotate 'line', 2823
    get_hll_global $P101, "GLOBAL"
    nqp_get_package_through_who $P102, $P101, "NQP"
    get_who $P103, $P102
    set $P104, $P103["Compiler"]
    $P105 = $P104."new"()
    set $P1008, $P105
.annotate 'line', 2824
    set $P101, $P1008
    unless_null $P101, vivify_639
    new $P101, "Undef"
  vivify_639:
    $P101."language"("nqp")
.annotate 'line', 2825
    set $P101, $P1008
    unless_null $P101, vivify_640
    new $P101, "Undef"
  vivify_640:
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P101."parsegrammar"($P105)
.annotate 'line', 2826
    set $P101, $P1008
    unless_null $P101, vivify_641
    new $P101, "Undef"
  vivify_641:
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Actions"]
    $P101."parseactions"($P105)
.annotate 'line', 2827
    set $P101, $P1008
    unless_null $P101, vivify_642
    new $P101, "Undef"
  vivify_642:
    $P102 = $P101."config"()
    "hll-config"($P102)
.annotate 'line', 2830
    set $P101, $P1008
    unless_null $P101, vivify_643
    new $P101, "Undef"
  vivify_643:
    $P102 = $P101."commandline_options"()
    set $P1009, $P102
.annotate 'line', 2831
    set $P1011, $P1009
    unless_null $P1011, vivify_644
    $P1011 = root_new ['parrot';'ResizablePMCArray']
  vivify_644:
    $P1011."push"("parsetrace")
.annotate 'line', 2832
    set $P1012, $P1009
    unless_null $P1012, vivify_645
    $P1012 = root_new ['parrot';'ResizablePMCArray']
  vivify_645:
    $P1012."push"("setting=s")
.annotate 'line', 2833
    set $P1013, $P1009
    unless_null $P1013, vivify_646
    $P1013 = root_new ['parrot';'ResizablePMCArray']
  vivify_646:
    $P1013."push"("setting-path=s")
.annotate 'line', 2834
    set $P1014, $P1009
    unless_null $P1014, vivify_647
    $P1014 = root_new ['parrot';'ResizablePMCArray']
  vivify_647:
    $P1014."push"("module-path=s")
.annotate 'line', 2835
    set $P1015, $P1009
    unless_null $P1015, vivify_648
    $P1015 = root_new ['parrot';'ResizablePMCArray']
  vivify_648:
    $P1015."push"("vmlibs=s")
.annotate 'line', 2838
    set $P101, $P1008
    unless_null $P101, vivify_649
    new $P101, "Undef"
  vivify_649:
    set $P1016, param_1007
    unless_null $P1016, vivify_650
    $P1016 = root_new ['parrot';'ResizablePMCArray']
  vivify_650:
    $P101."command_line"($P1016, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2840
    set $P101, $P1008
    unless_null $P101, vivify_651
    new $P101, "Undef"
  vivify_651:
    $P102 = $P101."nqpevent"()
.annotate 'line', 2821
    .return ($P102)
.end


.HLL "nqp"

.namespace []
.sub "hll-config"  :subid("12_1325892461.451") :outer("10_1325892461.451")
    .param pmc param_1020
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2844
    .lex "$config", param_1020
.annotate 'line', 2845
    new $P101, "String"
    assign $P101, "2011.12-7-g61ace16"
    set $P1021, param_1020
    unless_null $P1021, vivify_652
    $P1021 = root_new ['parrot';'Hash']
    set param_1020, $P1021
  vivify_652:
    set $P1021["version"], $P101
.annotate 'line', 2846
    new $P101, "String"
    assign $P101, "2012-01-06T23:27:35Z"
    set $P1022, param_1020
    unless_null $P1022, vivify_653
    $P1022 = root_new ['parrot';'Hash']
    set param_1020, $P1022
  vivify_653:
    set $P1022["build-date"], $P101
.annotate 'line', 2844
    .return ($P101)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1024"  :subid("13_1325892461.451") :outer("10_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 7
    .const 'Sub' $P1227 = "44_1325892461.451" 
    capture_lex $P1227
    .const 'Sub' $P1220 = "42_1325892461.451" 
    capture_lex $P1220
    .const 'Sub' $P1211 = "40_1325892461.451" 
    capture_lex $P1211
    .const 'Sub' $P1202 = "38_1325892461.451" 
    capture_lex $P1202
    .const 'Sub' $P1175 = "33_1325892461.451" 
    capture_lex $P1175
    .const 'Sub' $P1165 = "32_1325892461.451" 
    capture_lex $P1165
    .const 'Sub' $P1136 = "29_1325892461.451" 
    capture_lex $P1136
    .const 'Sub' $P1111 = "25_1325892461.451" 
    capture_lex $P1111
    .const 'Sub' $P1084 = "23_1325892461.451" 
    capture_lex $P1084
    .const 'Sub' $P1078 = "22_1325892461.451" 
    capture_lex $P1078
    .const 'Sub' $P1071 = "21_1325892461.451" 
    capture_lex $P1071
    .const 'Sub' $P1048 = "17_1325892461.451" 
    capture_lex $P1048
    .const 'Sub' $P1040 = "16_1325892461.451" 
    capture_lex $P1040
    .const 'Sub' $P1029 = "14_1325892461.451" 
    capture_lex $P1029
.annotate 'line', 12
    new $P103, "Undef"
    set $P1026, $P103
    .lex "$loader", $P1026
    .lex "$?PACKAGE", $P1027
    .lex "$?CLASS", $P1028
    get_hll_global $P104, "ModuleLoader"
    set $P1026, $P104
.annotate 'line', 422
    .const 'Sub' $P1227 = "44_1325892461.451" 
    newclosure $P1237, $P1227
.annotate 'line', 7
    .return ($P1237)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.include "except_types.pasm"
.sub "load_setting" :anon :subid("14_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1032
    .param pmc param_1033
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 15
    .const 'Sub' $P1036 = "15_1325892461.451" 
    capture_lex $P1036
    new $P1031, 'ExceptionHandler', [.CONTROL_RETURN]
    set_label $P1031, control_1030
    push_eh $P1031
    .lex "self", param_1032
    .lex "$setting_name", param_1033
.annotate 'line', 17
    set $P105, param_1033
    unless_null $P105, vivify_654
    new $P105, "Undef"
  vivify_654:
    set $S100, $P105
    isne $I100, $S100, "NULL"
    if $I100, if_1034
    new $P104, 'Integer'
    set $P104, $I100
    goto if_1034_end
  if_1034:
    .const 'Sub' $P1036 = "15_1325892461.451" 
    capture_lex $P1036
    $P107 = $P1036()
    set $P104, $P107
  if_1034_end:
.annotate 'line', 15
    .return ($P104)
  control_1030:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P105, exception, "payload"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.include "except_types.pasm"
.sub "_block1035"  :anon :subid("15_1325892461.451") :outer("14_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 21
    new $P106, "Undef"
    set $P1037, $P106
    .lex "$setting", $P1037
.annotate 'line', 22
    find_lex $P107, "$loader"
    unless_null $P107, vivify_655
    new $P107, "Undef"
  vivify_655:
    find_lex $P108, "$setting_name"
    unless_null $P108, vivify_656
    new $P108, "Undef"
  vivify_656:
    $P109 = $P107."load_setting"($P108)
    find_dynamic_lex $P112, "%*COMPILING"
    unless_null $P112, vivify_657
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["%COMPILING"]
    unless_null $P112, vivify_658
    die "Contextual %*COMPILING not found"
  vivify_658:
    store_dynamic_lex "%*COMPILING", $P112
  vivify_657:
    set $P1038, $P112["%?OPTIONS"]
    unless_null $P1038, vivify_659
    $P1038 = root_new ['parrot';'Hash']
    set $P112["%?OPTIONS"], $P1038
  vivify_659:
    set $P1038["outer_ctx"], $P109
    set $P1037, $P109
.annotate 'line', 25
    find_lex $P107, "self"
    nqp_decontainerize $P108, $P107
    $P109 = $P108."is_precompilation_mode"()
    if $P109, if_1039
.annotate 'line', 43
    find_lex $P110, "self"
    nqp_decontainerize $P111, $P110
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
.annotate 'line', 45
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P118, $P117
    set $P119, $P118["Var"]
    $P120 = $P119."new"("block" :named("name"), "register" :named("scope"))
.annotate 'line', 46
    get_hll_global $P121, "GLOBAL"
    nqp_get_package_through_who $P122, $P121, "PAST"
    get_who $P123, $P122
    set $P124, $P123["Op"]
.annotate 'line', 48
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P126, $P125, "PAST"
    get_who $P127, $P126
    set $P128, $P127["Var"]
    new $P129, "ResizablePMCArray"
    $P130 = $P128."new"("ModuleLoader" :named("name"), $P129 :named("namespace"), "package" :named("scope"))
    find_lex $P131, "$setting_name"
    unless_null $P131, vivify_660
    new $P131, "Undef"
  vivify_660:
    $P132 = $P124."new"($P130, $P131, "callmethod" :named("pasttype"), "load_setting" :named("name"))
.annotate 'line', 46
    $P133 = $P115."new"($P120, $P132, "callmethod" :named("pasttype"), "set_outer_ctx" :named("name"))
.annotate 'line', 43
    $P111."add_event"($P133 :named("fixup_past"))
.annotate 'line', 41
    goto if_1039_end
  if_1039:
.annotate 'line', 26
    find_lex $P110, "self"
    nqp_decontainerize $P111, $P110
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Stmts"]
.annotate 'line', 27
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P118, $P117
    set $P119, $P118["Op"]
    $P120 = $P119."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 30
    get_hll_global $P121, "GLOBAL"
    nqp_get_package_through_who $P122, $P121, "PAST"
    get_who $P123, $P122
    set $P124, $P123["Op"]
.annotate 'line', 32
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P126, $P125, "PAST"
    get_who $P127, $P126
    set $P128, $P127["Var"]
    $P129 = $P128."new"("block" :named("name"), "register" :named("scope"))
.annotate 'line', 33
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
.annotate 'line', 35
    get_hll_global $P134, "GLOBAL"
    nqp_get_package_through_who $P135, $P134, "PAST"
    get_who $P136, $P135
    set $P137, $P136["Var"]
    new $P138, "ResizablePMCArray"
    $P139 = $P137."new"("ModuleLoader" :named("name"), $P138 :named("namespace"), "package" :named("scope"))
    find_lex $P140, "$setting_name"
    unless_null $P140, vivify_661
    new $P140, "Undef"
  vivify_661:
    $P141 = $P133."new"($P139, $P140, "callmethod" :named("pasttype"), "load_setting" :named("name"))
.annotate 'line', 33
    $P142 = $P124."new"($P129, $P141, "callmethod" :named("pasttype"), "set_outer_ctx" :named("name"))
.annotate 'line', 30
    $P143 = $P115."new"($P120, $P142)
.annotate 'line', 26
    $P111."add_event"($P143 :named("deserialize_past"))
  if_1039_end:
.annotate 'line', 54
    new $P107, "Exception"
    set $P107['type'], .CONTROL_RETURN
    set $P108, $P1037
    unless_null $P108, vivify_662
    new $P108, "Undef"
  vivify_662:
    getattribute $P109, $P108, "lex_pad"
    setattribute $P107, 'payload', $P109
    throw $P107
.annotate 'line', 17
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.include "except_types.pasm"
.sub "load_module" :anon :subid("16_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1043
    .param pmc param_1044
    .param pmc param_1045
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 60
    new $P1042, 'ExceptionHandler', [.CONTROL_RETURN]
    set_label $P1042, control_1041
    push_eh $P1042
    .lex "self", param_1043
    .lex "$module_name", param_1044
    .lex "$cur_GLOBALish", param_1045
.annotate 'line', 62
    new $P104, "Undef"
    set $P1046, $P104
    .lex "$module", $P1046
    find_lex $P105, "$loader"
    unless_null $P105, vivify_663
    new $P105, "Undef"
  vivify_663:
    set $P106, param_1044
    unless_null $P106, vivify_664
    new $P106, "Undef"
  vivify_664:
    set $P107, param_1045
    unless_null $P107, vivify_665
    new $P107, "Undef"
  vivify_665:
    $P108 = $P105."load_module"($P106, $P107)
    set $P1046, $P108
.annotate 'line', 65
    set $P105, param_1043
    nqp_decontainerize $P106, $P105
    $P107 = $P106."is_precompilation_mode"()
    unless $P107, if_1047_end
.annotate 'line', 66
    set $P108, param_1043
    nqp_decontainerize $P109, $P108
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Stmts"]
.annotate 'line', 67
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Op"]
    $P118 = $P117."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 70
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Op"]
.annotate 'line', 72
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Var"]
    new $P127, "ResizablePMCArray"
    $P128 = $P126."new"("ModuleLoader" :named("name"), $P127 :named("namespace"), "package" :named("scope"))
    set $P129, param_1044
    unless_null $P129, vivify_666
    new $P129, "Undef"
  vivify_666:
.annotate 'line', 74
    set $P130, param_1043
    nqp_decontainerize $P131, $P130
    set $P132, param_1045
    unless_null $P132, vivify_667
    new $P132, "Undef"
  vivify_667:
    $P133 = $P131."get_slot_past_for_object"($P132)
    $P134 = $P122."new"($P128, $P129, $P133, "callmethod" :named("pasttype"), "load_module" :named("name"))
.annotate 'line', 70
    $P135 = $P113."new"($P118, $P134)
.annotate 'line', 66
    $P109."add_event"($P135 :named("deserialize_past"))
  if_1047_end:
.annotate 'line', 78
    new $P105, "Exception"
    set $P105['type'], .CONTROL_RETURN
    set $P106, $P1046
    unless_null $P106, vivify_668
    new $P106, "Undef"
  vivify_668:
    getattribute $P107, $P106, "lex_pad"
    setattribute $P105, 'payload', $P107
    throw $P105
.annotate 'line', 60
    .return ()
  control_1041:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P105, exception, "payload"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.include "except_types.pasm"
.sub "install_package_symbol" :anon :subid("17_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1049
    .param pmc param_1050
    .param pmc param_1051
    .param pmc param_1052
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 83
    .const 'Sub' $P1064 = "19_1325892461.451" 
    capture_lex $P1064
    .const 'Sub' $P1059 = "18_1325892461.451" 
    capture_lex $P1059
    .lex "self", param_1049
    .lex "$package", param_1050
    .lex "@sym", param_1051
    .lex "$obj", param_1052
.annotate 'line', 85
    new $P104, "Undef"
    set $P1053, $P104
    .lex "$name", $P1053
.annotate 'line', 88
    new $P105, "Undef"
    set $P1054, $P105
    .lex "$target", $P1054
.annotate 'line', 84
    set $P1055, param_1051
    unless_null $P1055, vivify_669
    $P1055 = root_new ['parrot';'ResizablePMCArray']
  vivify_669:
    clone $P106, $P1055
    set param_1051, $P106
.annotate 'line', 85
    set $P1056, param_1051
    unless_null $P1056, vivify_670
    $P1056 = root_new ['parrot';'ResizablePMCArray']
  vivify_670:
    $P106 = $P1056."pop"()
    set $S100, $P106
    new $P107, 'String'
    set $P107, $S100
    set $P1053, $P107
.annotate 'line', 88
    set $P106, param_1050
    unless_null $P106, vivify_671
    new $P106, "Undef"
  vivify_671:
    set $P1054, $P106
.annotate 'line', 89
    set $P1057, param_1051
    unless_null $P1057, vivify_672
    $P1057 = root_new ['parrot';'ResizablePMCArray']
  vivify_672:
    defined $I100, $P1057
    unless $I100, for_undef_673
    iter $P106, $P1057
    new $P108, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P108, loop1061_handler
    push_eh $P108
  loop1061_test:
    unless $P106, loop1061_done
    shift $P107, $P106
  loop1061_redo:
    .const 'Sub' $P1059 = "18_1325892461.451" 
    capture_lex $P1059
    $P1059($P107)
  loop1061_next:
    goto loop1061_test
  loop1061_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P109, exception, 'type'
    eq $P109, .CONTROL_LOOP_NEXT, loop1061_next
    eq $P109, .CONTROL_LOOP_REDO, loop1061_redo
  loop1061_done:
    pop_eh 
  for_undef_673:
.annotate 'line', 92
    set $P106, param_1052
    unless_null $P106, vivify_676
    new $P106, "Undef"
  vivify_676:
    set $P107, $P1053
    unless_null $P107, vivify_677
    new $P107, "Undef"
  vivify_677:
    set $P108, $P1054
    unless_null $P108, vivify_678
    new $P108, "Undef"
    set $P1054, $P108
  vivify_678:
    get_who $P109, $P108
    set $P109[$P107], $P106
.annotate 'line', 95
    set $P107, param_1049
    nqp_decontainerize $P108, $P107
    $P109 = $P108."is_precompilation_mode"()
    if $P109, if_1062
    set $P106, $P109
    goto if_1062_end
  if_1062:
    .const 'Sub' $P1064 = "19_1325892461.451" 
    capture_lex $P1064
    $P111 = $P1064()
    set $P106, $P111
  if_1062_end:
.annotate 'line', 83
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1058"  :anon :subid("18_1325892461.451") :outer("17_1325892461.451")
    .param pmc param_1060
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 89
    .lex "$_", param_1060
.annotate 'line', 90
    find_lex $P108, "$target"
    unless_null $P108, vivify_674
    new $P108, "Undef"
  vivify_674:
    find_lex $P109, "$_"
    unless_null $P109, vivify_675
    new $P109, "Undef"
  vivify_675:
    set $S100, $P109
    nqp_get_package_through_who $P110, $P108, $S100
    store_lex "$target", $P110
.annotate 'line', 89
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.include "except_types.pasm"
.sub "_block1063"  :anon :subid("19_1325892461.451") :outer("17_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 95
    .const 'Sub' $P1068 = "20_1325892461.451" 
    capture_lex $P1068
.annotate 'line', 96
    new $P110, "Undef"
    set $P1065, $P110
    .lex "$path", $P1065
    find_lex $P111, "self"
    nqp_decontainerize $P112, $P111
    find_lex $P113, "$package"
    unless_null $P113, vivify_679
    new $P113, "Undef"
  vivify_679:
    $P114 = $P112."get_slot_past_for_object"($P113)
    set $P1065, $P114
.annotate 'line', 97
    find_lex $P1066, "@sym"
    unless_null $P1066, vivify_680
    $P1066 = root_new ['parrot';'ResizablePMCArray']
  vivify_680:
    defined $I100, $P1066
    unless $I100, for_undef_681
    iter $P111, $P1066
    new $P113, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P113, loop1070_handler
    push_eh $P113
  loop1070_test:
    unless $P111, loop1070_done
    shift $P112, $P111
  loop1070_redo:
    .const 'Sub' $P1068 = "20_1325892461.451" 
    capture_lex $P1068
    $P1068($P112)
  loop1070_next:
    goto loop1070_test
  loop1070_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P114, exception, 'type'
    eq $P114, .CONTROL_LOOP_NEXT, loop1070_next
    eq $P114, .CONTROL_LOOP_REDO, loop1070_redo
  loop1070_done:
    pop_eh 
  for_undef_681:
.annotate 'line', 100
    find_lex $P111, "self"
    nqp_decontainerize $P112, $P111
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
.annotate 'line', 102
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "PAST"
    get_who $P119, $P118
    set $P120, $P119["Var"]
.annotate 'line', 104
    get_hll_global $P121, "GLOBAL"
    nqp_get_package_through_who $P122, $P121, "PAST"
    get_who $P123, $P122
    set $P124, $P123["Op"]
    set $P125, $P1065
    unless_null $P125, vivify_684
    new $P125, "Undef"
  vivify_684:
    $P126 = $P124."new"($P125, "get_who PP" :named("pirop"))
    find_lex $P127, "$name"
    unless_null $P127, vivify_685
    new $P127, "Undef"
  vivify_685:
    $P128 = $P120."new"($P126, $P127, "keyed" :named("scope"))
.annotate 'line', 107
    find_lex $P129, "self"
    nqp_decontainerize $P130, $P129
    find_lex $P131, "$obj"
    unless_null $P131, vivify_686
    new $P131, "Undef"
  vivify_686:
    $P132 = $P130."get_slot_past_for_object"($P131)
    $P133 = $P116."new"($P128, $P132, "bind_6model" :named("pasttype"))
.annotate 'line', 100
    $P134 = $P112."add_event"($P133 :named("deserialize_past"))
.annotate 'line', 95
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1067"  :anon :subid("20_1325892461.451") :outer("19_1325892461.451")
    .param pmc param_1069
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 97
    .lex "$_", param_1069
.annotate 'line', 98
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    find_lex $P117, "$path"
    unless_null $P117, vivify_682
    new $P117, "Undef"
  vivify_682:
    find_lex $P118, "$_"
    unless_null $P118, vivify_683
    new $P118, "Undef"
  vivify_683:
    set $S100, $P118
    $P119 = $P116."new"($P117, $S100, "nqp_get_package_through_who PPs" :named("pirop"))
    store_lex "$path", $P119
.annotate 'line', 97
    .return ($P119)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "install_lexical_symbol" :anon :subid("21_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1072
    .param pmc param_1073
    .param pmc param_1074
    .param pmc param_1075
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 116
    .lex "self", param_1072
    .lex "$block", param_1073
    .lex "$name", param_1074
    .lex "$obj", param_1075
.annotate 'line', 123
    new $P104, "Undef"
    set $P1076, $P104
    .lex "$fixup", $P1076
.annotate 'line', 118
    set $P105, param_1073
    unless_null $P105, vivify_687
    new $P105, "Undef"
  vivify_687:
    set $P106, param_1074
    unless_null $P106, vivify_688
    new $P106, "Undef"
  vivify_688:
    set $P107, param_1075
    unless_null $P107, vivify_689
    new $P107, "Undef"
  vivify_689:
    $P105."symbol"($P106, "lexical" :named("scope"), $P107 :named("value"))
.annotate 'line', 119
    new $P105, "Float"
    assign $P105, 0
    set $I100, $P105
    set $P1077, param_1073
    unless_null $P1077, vivify_690
    $P1077 = root_new ['parrot';'ResizablePMCArray']
  vivify_690:
    set $P106, $P1077[$I100]
    unless_null $P106, vivify_691
    new $P106, "Undef"
  vivify_691:
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Var"]
    set $P111, param_1074
    unless_null $P111, vivify_692
    new $P111, "Undef"
  vivify_692:
    $P112 = $P110."new"("lexical" :named("scope"), $P111 :named("name"), 1 :named("isdecl"), 1 :named("directaccess"))
    $P106."push"($P112)
.annotate 'line', 123
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Stmts"]
.annotate 'line', 124
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 126
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Val"]
    set $P117, param_1073
    unless_null $P117, vivify_693
    new $P117, "Undef"
  vivify_693:
    $P118 = $P116."new"($P117 :named("value"), "LexInfo" :named("returns"))
.annotate 'line', 127
    set $P119, param_1074
    unless_null $P119, vivify_694
    new $P119, "Undef"
  vivify_694:
    set $S100, $P119
    set $P120, param_1072
    nqp_decontainerize $P121, $P120
    set $P122, param_1075
    unless_null $P122, vivify_695
    new $P122, "Undef"
  vivify_695:
    $P123 = $P121."get_slot_past_for_object"($P122)
    $P124 = $P112."new"($P118, $S100, $P123, "callmethod" :named("pasttype"), "set_static_lexpad_value" :named("name"))
.annotate 'line', 131
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P126, $P125, "PAST"
    get_who $P127, $P126
    set $P128, $P127["Op"]
.annotate 'line', 133
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Val"]
    set $P133, param_1073
    unless_null $P133, vivify_696
    new $P133, "Undef"
  vivify_696:
    $P134 = $P132."new"($P133 :named("value"), "LexInfo" :named("returns"))
    $P135 = $P128."new"($P134, "callmethod" :named("pasttype"), "finish_static_lexpad" :named("name"))
.annotate 'line', 131
    $P136 = $P108."new"($P124, $P135)
.annotate 'line', 123
    set $P1076, $P136
.annotate 'line', 136
    set $P105, param_1072
    nqp_decontainerize $P106, $P105
    set $P107, $P1076
    unless_null $P107, vivify_697
    new $P107, "Undef"
  vivify_697:
    set $P108, $P1076
    unless_null $P108, vivify_698
    new $P108, "Undef"
  vivify_698:
    $P109 = $P106."add_event"($P107 :named("deserialize_past"), $P108 :named("fixup_past"))
.annotate 'line', 116
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "install_package_routine" :anon :subid("22_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1079
    .param pmc param_1080
    .param pmc param_1081
    .param pmc param_1082
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 141
    .lex "self", param_1079
    .lex "$package", param_1080
    .lex "$name", param_1081
    .lex "$past_block", param_1082
.annotate 'line', 142
    new $P104, "Undef"
    set $P1083, $P104
    .lex "$fixup", $P1083
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Op"]
.annotate 'line', 144
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Var"]
.annotate 'line', 146
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    set $P117, param_1079
    nqp_decontainerize $P118, $P117
    set $P119, param_1080
    unless_null $P119, vivify_699
    new $P119, "Undef"
  vivify_699:
    $P120 = $P118."get_slot_past_for_object"($P119)
    $P121 = $P116."new"($P120, "get_who PP" :named("pirop"))
.annotate 'line', 147
    set $P122, param_1081
    unless_null $P122, vivify_700
    new $P122, "Undef"
  vivify_700:
    set $S100, $P122
    $P123 = $P112."new"($P121, $S100, "keyed" :named("scope"))
.annotate 'line', 149
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P126, $P125
    set $P127, $P126["Val"]
    set $P128, param_1082
    unless_null $P128, vivify_701
    new $P128, "Undef"
  vivify_701:
    $P129 = $P127."new"($P128 :named("value"))
    $P130 = $P108."new"($P123, $P129, "bind_6model" :named("pasttype"))
.annotate 'line', 142
    set $P1083, $P130
.annotate 'line', 151
    set $P105, param_1079
    nqp_decontainerize $P106, $P105
    set $P107, $P1083
    unless_null $P107, vivify_702
    new $P107, "Undef"
  vivify_702:
    set $P108, $P1083
    unless_null $P108, vivify_703
    new $P108, "Undef"
  vivify_703:
    $P109 = $P106."add_event"($P107 :named("deserialize_past"), $P108 :named("fixup_past"))
.annotate 'line', 141
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.include "except_types.pasm"
.sub "pkg_create_mo" :anon :subid("23_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1087
    .param pmc param_1088
    .param pmc param_1089 :optional :named("name")
    .param int has_param_1089 :opt_flag
    .param pmc param_1090 :optional :named("repr")
    .param int has_param_1090 :opt_flag
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 156
    .const 'Sub' $P1103 = "24_1325892461.451" 
    capture_lex $P1103
    new $P1086, 'ExceptionHandler', [.CONTROL_RETURN]
    set_label $P1086, control_1085
    push_eh $P1086
    .lex "self", param_1087
    .lex "$how", param_1088
    if has_param_1089, optparam_704
    new $P104, "Undef"
    set param_1089, $P104
  optparam_704:
    .lex "$name", param_1089
    if has_param_1090, optparam_705
    new $P105, "Undef"
    set param_1090, $P105
  optparam_705:
    .lex "$repr", param_1090
.annotate 'line', 158
    $P1092 = root_new ['parrot';'Hash']
    set $P1091, $P1092
    .lex "%args", $P1091
.annotate 'line', 161
    new $P106, "Undef"
    set $P1093, $P106
    .lex "$mo", $P1093
.annotate 'line', 162
    new $P107, "Undef"
    set $P1094, $P107
    .lex "$slot", $P1094
.annotate 'line', 156
    set $P1095, $P1091
    unless_null $P1095, vivify_706
    $P1095 = root_new ['parrot';'Hash']
  vivify_706:
.annotate 'line', 159
    set $P108, param_1089
    unless_null $P108, vivify_707
    new $P108, "Undef"
  vivify_707:
    defined $I100, $P108
    unless $I100, if_1096_end
    set $P109, param_1089
    unless_null $P109, vivify_708
    new $P109, "Undef"
  vivify_708:
    set $P1097, $P1091
    unless_null $P1097, vivify_709
    $P1097 = root_new ['parrot';'Hash']
    set $P1091, $P1097
  vivify_709:
    set $P1097["name"], $P109
  if_1096_end:
.annotate 'line', 160
    set $P108, param_1090
    unless_null $P108, vivify_710
    new $P108, "Undef"
  vivify_710:
    defined $I100, $P108
    unless $I100, if_1098_end
    set $P109, param_1090
    unless_null $P109, vivify_711
    new $P109, "Undef"
  vivify_711:
    set $P1099, $P1091
    unless_null $P1099, vivify_712
    $P1099 = root_new ['parrot';'Hash']
    set $P1091, $P1099
  vivify_712:
    set $P1099["repr"], $P109
  if_1098_end:
.annotate 'line', 161
    set $P108, param_1088
    unless_null $P108, vivify_713
    new $P108, "Undef"
  vivify_713:
    set $P1100, $P1091
    unless_null $P1100, vivify_714
    $P1100 = root_new ['parrot';'Hash']
  vivify_714:
    $P109 = $P108."new_type"($P1100 :flat)
    set $P1093, $P109
.annotate 'line', 162
    set $P108, param_1087
    nqp_decontainerize $P109, $P108
    set $P110, $P1093
    unless_null $P110, vivify_715
    new $P110, "Undef"
  vivify_715:
    $P111 = $P109."add_object"($P110)
    set $P1094, $P111
.annotate 'line', 166
    set $P108, param_1087
    nqp_decontainerize $P109, $P108
    $P110 = $P109."is_precompilation_mode"()
    unless $P110, if_1101_end
    .const 'Sub' $P1103 = "24_1325892461.451" 
    capture_lex $P1103
    $P1103()
  if_1101_end:
.annotate 'line', 184
    new $P108, "Exception"
    set $P108['type'], .CONTROL_RETURN
    set $P109, $P1093
    unless_null $P109, vivify_728
    new $P109, "Undef"
  vivify_728:
    setattribute $P108, 'payload', $P109
    throw $P108
.annotate 'line', 156
    .return ()
  control_1085:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P108, exception, "payload"
    .return ($P108)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1102"  :anon :subid("24_1325892461.451") :outer("23_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 167
    $P1105 = root_new ['parrot';'ResizablePMCArray']
    set $P1104, $P1105
    .lex "@how_ns", $P1104
.annotate 'line', 168
    new $P111, "Undef"
    set $P1106, $P111
    .lex "$how_name", $P1106
.annotate 'line', 169
    new $P112, "Undef"
    set $P1107, $P112
    .lex "$setup_call", $P1107
.annotate 'line', 167
    find_lex $P113, "$how"
    unless_null $P113, vivify_716
    new $P113, "Undef"
  vivify_716:
    get_how $P114, $P113
    find_lex $P115, "$how"
    unless_null $P115, vivify_717
    new $P115, "Undef"
  vivify_717:
    $S100 = $P114."name"($P115)
    split $P116, "::", $S100
    set $P1104, $P116
.annotate 'line', 168
    set $P1108, $P1104
    unless_null $P1108, vivify_718
    $P1108 = root_new ['parrot';'ResizablePMCArray']
  vivify_718:
    $P113 = $P1108."pop"()
    set $P1106, $P113
.annotate 'line', 169
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
.annotate 'line', 171
    find_lex $P117, "self"
    nqp_decontainerize $P118, $P117
    find_lex $P119, "$how"
    unless_null $P119, vivify_719
    new $P119, "Undef"
  vivify_719:
    $P120 = $P118."get_ref"($P119)
    $P121 = $P116."new"($P120, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 169
    set $P1107, $P121
.annotate 'line', 173
    find_lex $P113, "$name"
    unless_null $P113, vivify_720
    new $P113, "Undef"
  vivify_720:
    defined $I100, $P113
    unless $I100, if_1109_end
.annotate 'line', 174
    set $P114, $P1107
    unless_null $P114, vivify_721
    new $P114, "Undef"
  vivify_721:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Val"]
    find_lex $P119, "$name"
    unless_null $P119, vivify_722
    new $P119, "Undef"
  vivify_722:
    $P120 = $P118."new"($P119 :named("value"), "name" :named("named"))
    $P114."push"($P120)
  if_1109_end:
.annotate 'line', 176
    find_lex $P113, "$repr"
    unless_null $P113, vivify_723
    new $P113, "Undef"
  vivify_723:
    defined $I100, $P113
    unless $I100, if_1110_end
.annotate 'line', 177
    set $P114, $P1107
    unless_null $P114, vivify_724
    new $P114, "Undef"
  vivify_724:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Val"]
    find_lex $P119, "$repr"
    unless_null $P119, vivify_725
    new $P119, "Undef"
  vivify_725:
    $P120 = $P118."new"($P119 :named("value"), "repr" :named("named"))
    $P114."push"($P120)
  if_1110_end:
.annotate 'line', 179
    find_lex $P113, "self"
    nqp_decontainerize $P114, $P113
.annotate 'line', 180
    find_lex $P115, "self"
    nqp_decontainerize $P116, $P115
    find_lex $P117, "$slot"
    unless_null $P117, vivify_726
    new $P117, "Undef"
  vivify_726:
    set $P118, $P1107
    unless_null $P118, vivify_727
    new $P118, "Undef"
  vivify_727:
    $P119 = $P116."add_object_to_cur_sc_past"($P117, $P118)
.annotate 'line', 179
    $P120 = $P114."add_event"($P119 :named("deserialize_past"))
.annotate 'line', 166
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "pkg_add_attribute" :anon :subid("25_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1112
    .param pmc param_1113
    .param pmc param_1114
    .param pmc param_1115
    .param pmc param_1116
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 192
    .const 'Sub' $P1122 = "26_1325892461.451" 
    capture_lex $P1122
    .lex "self", param_1112
    .lex "$obj", param_1113
    .lex "$meta_attr", param_1114
    .lex "%lit_args", param_1115
    .lex "%obj_args", param_1116
.annotate 'line', 194
    new $P104, "Undef"
    set $P1117, $P104
    .lex "$attr", $P1117
    set $P105, param_1114
    unless_null $P105, vivify_729
    new $P105, "Undef"
  vivify_729:
    set $P1118, param_1115
    unless_null $P1118, vivify_730
    $P1118 = root_new ['parrot';'Hash']
  vivify_730:
    set $P1119, param_1116
    unless_null $P1119, vivify_731
    $P1119 = root_new ['parrot';'Hash']
  vivify_731:
    $P106 = $P105."new"($P1118 :flat, $P1119 :flat)
    set $P1117, $P106
.annotate 'line', 195
    set $P105, param_1113
    unless_null $P105, vivify_732
    new $P105, "Undef"
  vivify_732:
    get_how $P106, $P105
    set $P107, param_1113
    unless_null $P107, vivify_733
    new $P107, "Undef"
  vivify_733:
    set $P108, $P1117
    unless_null $P108, vivify_734
    new $P108, "Undef"
  vivify_734:
    $P106."add_attribute"($P107, $P108)
.annotate 'line', 198
    set $P106, param_1112
    nqp_decontainerize $P107, $P106
    $P108 = $P107."is_precompilation_mode"()
    if $P108, if_1120
    set $P105, $P108
    goto if_1120_end
  if_1120:
    .const 'Sub' $P1122 = "26_1325892461.451" 
    capture_lex $P1122
    $P111 = $P1122()
    set $P105, $P111
  if_1120_end:
.annotate 'line', 192
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.include "except_types.pasm"
.sub "_block1121"  :anon :subid("26_1325892461.451") :outer("25_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 198
    .const 'Sub' $P1132 = "28_1325892461.451" 
    capture_lex $P1132
    .const 'Sub' $P1127 = "27_1325892461.451" 
    capture_lex $P1127
.annotate 'line', 199
    new $P109, "Undef"
    set $P1123, $P109
    .lex "$create_call", $P1123
.annotate 'line', 211
    new $P110, "Undef"
    set $P1124, $P110
    .lex "$obj_slot_past", $P1124
.annotate 'line', 199
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 201
    find_lex $P115, "self"
    nqp_decontainerize $P116, $P115
    find_lex $P117, "$meta_attr"
    unless_null $P117, vivify_735
    new $P117, "Undef"
  vivify_735:
    $P118 = $P116."get_ref"($P117)
    $P119 = $P114."new"($P118, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 199
    set $P1123, $P119
.annotate 'line', 203
    find_lex $P1125, "%lit_args"
    unless_null $P1125, vivify_736
    $P1125 = root_new ['parrot';'Hash']
  vivify_736:
    defined $I100, $P1125
    unless $I100, for_undef_737
    iter $P111, $P1125
    new $P113, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P113, loop1129_handler
    push_eh $P113
  loop1129_test:
    unless $P111, loop1129_done
    shift $P112, $P111
  loop1129_redo:
    .const 'Sub' $P1127 = "27_1325892461.451" 
    capture_lex $P1127
    $P1127($P112)
  loop1129_next:
    goto loop1129_test
  loop1129_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P114, exception, 'type'
    eq $P114, .CONTROL_LOOP_NEXT, loop1129_next
    eq $P114, .CONTROL_LOOP_REDO, loop1129_redo
  loop1129_done:
    pop_eh 
  for_undef_737:
.annotate 'line', 206
    find_lex $P1130, "%obj_args"
    unless_null $P1130, vivify_741
    $P1130 = root_new ['parrot';'Hash']
  vivify_741:
    defined $I100, $P1130
    unless $I100, for_undef_742
    iter $P111, $P1130
    new $P114, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P114, loop1135_handler
    push_eh $P114
  loop1135_test:
    unless $P111, loop1135_done
    shift $P112, $P111
  loop1135_redo:
    .const 'Sub' $P1132 = "28_1325892461.451" 
    capture_lex $P1132
    $P1132($P112)
  loop1135_next:
    goto loop1135_test
  loop1135_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P115, exception, 'type'
    eq $P115, .CONTROL_LOOP_NEXT, loop1135_next
    eq $P115, .CONTROL_LOOP_REDO, loop1135_redo
  loop1135_done:
    pop_eh 
  for_undef_742:
.annotate 'line', 211
    find_lex $P111, "self"
    nqp_decontainerize $P112, $P111
    find_lex $P113, "$obj"
    unless_null $P113, vivify_748
    new $P113, "Undef"
  vivify_748:
    $P114 = $P112."get_slot_past_for_object"($P113)
    set $P1124, $P114
.annotate 'line', 212
    find_lex $P111, "self"
    nqp_decontainerize $P112, $P111
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
.annotate 'line', 214
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "PAST"
    get_who $P119, $P118
    set $P120, $P119["Op"]
    set $P121, $P1124
    unless_null $P121, vivify_749
    new $P121, "Undef"
  vivify_749:
    $P122 = $P120."new"($P121, "get_how PP" :named("pirop"))
    set $P123, $P1124
    unless_null $P123, vivify_750
    new $P123, "Undef"
  vivify_750:
    set $P124, $P1123
    unless_null $P124, vivify_751
    new $P124, "Undef"
  vivify_751:
    $P125 = $P116."new"($P122, $P123, $P124, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 212
    $P126 = $P112."add_event"($P125 :named("deserialize_past"))
.annotate 'line', 198
    .return ($P126)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1126"  :anon :subid("27_1325892461.451") :outer("26_1325892461.451")
    .param pmc param_1128
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 203
    .lex "$_", param_1128
.annotate 'line', 204
    find_lex $P113, "$create_call"
    unless_null $P113, vivify_738
    new $P113, "Undef"
  vivify_738:
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Val"]
    find_lex $P118, "$_"
    unless_null $P118, vivify_739
    new $P118, "Undef"
  vivify_739:
    $P119 = $P118."value"()
    find_lex $P120, "$_"
    unless_null $P120, vivify_740
    new $P120, "Undef"
  vivify_740:
    $P121 = $P120."key"()
    $P122 = $P117."new"($P119 :named("value"), $P121 :named("named"))
    $P123 = $P113."push"($P122)
.annotate 'line', 203
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1131"  :anon :subid("28_1325892461.451") :outer("26_1325892461.451")
    .param pmc param_1134
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 207
    new $P113, "Undef"
    set $P1133, $P113
    .lex "$lookup", $P1133
    .lex "$_", param_1134
    find_lex $P114, "self"
    nqp_decontainerize $P115, $P114
    find_lex $P116, "$_"
    unless_null $P116, vivify_743
    new $P116, "Undef"
  vivify_743:
    $P117 = $P116."value"()
    $P118 = $P115."get_ref"($P117)
    set $P1133, $P118
.annotate 'line', 208
    set $P114, $P1133
    unless_null $P114, vivify_744
    new $P114, "Undef"
  vivify_744:
    find_lex $P115, "$_"
    unless_null $P115, vivify_745
    new $P115, "Undef"
  vivify_745:
    $P116 = $P115."key"()
    $P114."named"($P116)
.annotate 'line', 209
    find_lex $P114, "$create_call"
    unless_null $P114, vivify_746
    new $P114, "Undef"
  vivify_746:
    set $P115, $P1133
    unless_null $P115, vivify_747
    new $P115, "Undef"
  vivify_747:
    $P116 = $P114."push"($P115)
.annotate 'line', 206
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "pkg_add_method" :anon :subid("29_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1137
    .param pmc param_1138
    .param pmc param_1139
    .param pmc param_1140
    .param pmc param_1141
    .param pmc param_1142
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 224
    .const 'Sub' $P1160 = "31_1325892461.451" 
    capture_lex $P1160
    .const 'Sub' $P1148 = "30_1325892461.451" 
    capture_lex $P1148
    .lex "self", param_1137
    .lex "$obj", param_1138
    .lex "$meta_method_name", param_1139
    .lex "$name", param_1140
    .lex "$method_past", param_1141
    .lex "$is_dispatcher", param_1142
.annotate 'line', 230
    new $P104, "Undef"
    set $P1143, $P104
    .lex "$stub_code", $P1143
.annotate 'line', 236
    new $P105, "Undef"
    set $P1144, $P105
    .lex "$fixups", $P1144
.annotate 'line', 237
    new $P106, "Undef"
    set $P1145, $P106
    .lex "$dummy", $P1145
.annotate 'line', 282
    new $P107, "Undef"
    set $P1146, $P107
    .lex "$slot_past", $P1146
.annotate 'line', 230
    .const 'Sub' $P1148 = "30_1325892461.451" 
    newclosure $P1154, $P1148
    set $P1143, $P1154
.annotate 'line', 236
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
    $P112 = $P111."new"()
    set $P1144, $P112
.annotate 'line', 224
    set $P108, $P1145
    unless_null $P108, vivify_756
    new $P108, "Undef"
  vivify_756:
.annotate 'line', 238
    set $P1156, param_1141
    unless_null $P1156, vivify_757
    $P1156 = root_new ['parrot';'Hash']
  vivify_757:
    set $P108, $P1156["compile_time_dummy"]
    unless_null $P108, vivify_758
    new $P108, "Undef"
  vivify_758:
    defined $I100, $P108
    if $I100, if_1155
.annotate 'line', 245
    set $P109, param_1142
    unless_null $P109, vivify_759
    new $P109, "Undef"
  vivify_759:
    if $P109, if_1158
.annotate 'line', 261
    set $P110, $P1143
    unless_null $P110, vivify_760
    new $P110, "Undef"
  vivify_760:
    clone $P111, $P110
    set $P1145, $P111
.annotate 'line', 260
    goto if_1158_end
  if_1158:
.annotate 'line', 246
    set $P110, param_1141
    unless_null $P110, vivify_761
    new $P110, "Undef"
  vivify_761:
    $P110."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 247
    new $P110, "DispatcherSub"
    set $P111, $P1143
    unless_null $P111, vivify_762
    new $P111, "Undef"
  vivify_762:
    assign $P110, $P111
    set $P1145, $P110
.annotate 'line', 251
    set $P110, $P1145
    unless_null $P110, vivify_763
    new $P110, "Undef"
  vivify_763:
    .const 'Sub' $P1160 = "31_1325892461.451" 
    newclosure $P1163, $P1160
    setprop $P110, "CLONE_CALLBACK", $P1163
  if_1158_end:
.annotate 'line', 263
    set $P109, $P1145
    unless_null $P109, vivify_768
    new $P109, "Undef"
  vivify_768:
    set $P110, param_1140
    unless_null $P110, vivify_769
    new $P110, "Undef"
  vivify_769:
    set $S100, $P110
    assign $P109, $S100
.annotate 'line', 264
    set $P109, param_1137
    nqp_decontainerize $P110, $P109
    set $P111, $P1145
    unless_null $P111, vivify_770
    new $P111, "Undef"
  vivify_770:
    $P110."add_code"($P111)
.annotate 'line', 265
    set $P109, $P1145
    unless_null $P109, vivify_771
    new $P109, "Undef"
  vivify_771:
    set $P1164, param_1141
    unless_null $P1164, vivify_772
    $P1164 = root_new ['parrot';'Hash']
    set param_1141, $P1164
  vivify_772:
    set $P1164["compile_time_dummy"], $P109
.annotate 'line', 241
    goto if_1155_end
  if_1155:
.annotate 'line', 239
    set $P1157, param_1141
    unless_null $P1157, vivify_773
    $P1157 = root_new ['parrot';'Hash']
  vivify_773:
    set $P109, $P1157["compile_time_dummy"]
    unless_null $P109, vivify_774
    new $P109, "Undef"
  vivify_774:
    set $P1145, $P109
  if_1155_end:
.annotate 'line', 269
    set $P108, $P1145
    unless_null $P108, vivify_775
    new $P108, "Undef"
  vivify_775:
    set $P109, param_1141
    unless_null $P109, vivify_776
    new $P109, "Undef"
  vivify_776:
    setprop $P108, "PAST", $P109
.annotate 'line', 272
    set $P108, param_1138
    unless_null $P108, vivify_777
    new $P108, "Undef"
  vivify_777:
    get_how $P109, $P108
    set $P110, param_1138
    unless_null $P110, vivify_778
    new $P110, "Undef"
  vivify_778:
    set $P111, param_1140
    unless_null $P111, vivify_779
    new $P111, "Undef"
  vivify_779:
    set $P112, $P1145
    unless_null $P112, vivify_780
    new $P112, "Undef"
  vivify_780:
    set $P113, param_1139
    unless_null $P113, vivify_781
    new $P113, "Undef"
  vivify_781:
    set $S100, $P113
    $P109.$S100($P110, $P111, $P112)
.annotate 'line', 277
    set $P108, $P1144
    unless_null $P108, vivify_782
    new $P108, "Undef"
  vivify_782:
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 279
    set $P113, param_1137
    nqp_decontainerize $P114, $P113
    set $P115, $P1145
    unless_null $P115, vivify_783
    new $P115, "Undef"
  vivify_783:
    $P116 = $P114."get_slot_past_for_object"($P115)
.annotate 'line', 280
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P118, $P117, "PAST"
    get_who $P119, $P118
    set $P120, $P119["Val"]
    set $P121, param_1141
    unless_null $P121, vivify_784
    new $P121, "Undef"
  vivify_784:
    $P122 = $P120."new"($P121 :named("value"))
    $P123 = $P112."new"($P116, $P122, "assign vPP" :named("pirop"))
.annotate 'line', 277
    $P108."push"($P123)
.annotate 'line', 282
    set $P108, param_1137
    nqp_decontainerize $P109, $P108
    set $P110, param_1138
    unless_null $P110, vivify_785
    new $P110, "Undef"
  vivify_785:
    $P111 = $P109."get_slot_past_for_object"($P110)
    set $P1146, $P111
.annotate 'line', 283
    set $P108, param_1137
    nqp_decontainerize $P109, $P108
.annotate 'line', 284
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    set $P114, param_1139
    unless_null $P114, vivify_786
    new $P114, "Undef"
  vivify_786:
.annotate 'line', 286
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Op"]
    set $P119, $P1146
    unless_null $P119, vivify_787
    new $P119, "Undef"
  vivify_787:
    $P120 = $P118."new"($P119, "get_how PP" :named("pirop"))
    set $P121, $P1146
    unless_null $P121, vivify_788
    new $P121, "Undef"
  vivify_788:
    set $P122, param_1140
    unless_null $P122, vivify_789
    new $P122, "Undef"
  vivify_789:
.annotate 'line', 289
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P126, $P125["Val"]
    set $P127, param_1141
    unless_null $P127, vivify_790
    new $P127, "Undef"
  vivify_790:
    $P128 = $P126."new"($P127 :named("value"))
    $P129 = $P113."new"($P120, $P121, $P122, $P128, "callmethod" :named("pasttype"), $P114 :named("name"))
.annotate 'line', 283
    set $P130, $P1144
    unless_null $P130, vivify_791
    new $P130, "Undef"
  vivify_791:
    $P131 = $P109."add_event"($P129 :named("deserialize_past"), $P130 :named("fixup_past"))
.annotate 'line', 224
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1147"  :anon :subid("30_1325892461.451") :outer("29_1325892461.451")
    .param pmc param_1149 :slurpy
    .param pmc param_1150 :slurpy :named
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 230
    .lex "@args", param_1149
    .lex "%named", param_1150
.annotate 'line', 231
    new $P108, "Undef"
    set $P1151, $P108
    .lex "$compiled", $P1151
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Compiler"]
    find_lex $P113, "$method_past"
    unless_null $P113, vivify_752
    new $P113, "Undef"
  vivify_752:
    $P114 = $P112."compile"($P113)
    set $P1151, $P114
.annotate 'line', 232
    set $P109, $P1151
    unless_null $P109, vivify_753
    new $P109, "Undef"
  vivify_753:
    set $P1152, param_1149
    unless_null $P1152, vivify_754
    $P1152 = root_new ['parrot';'ResizablePMCArray']
  vivify_754:
    set $P1153, param_1150
    unless_null $P1153, vivify_755
    $P1153 = root_new ['parrot';'Hash']
  vivify_755:
    $P110 = $P109($P1152 :flat, $P1153 :flat)
.annotate 'line', 230
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1159"  :anon :subid("31_1325892461.451") :outer("29_1325892461.451")
    .param pmc param_1161
    .param pmc param_1162
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 251
    .lex "$orig", param_1161
    .lex "$clone", param_1162
.annotate 'line', 252
    find_lex $P111, "self"
    nqp_decontainerize $P112, $P111
    set $P113, param_1162
    unless_null $P113, vivify_764
    new $P113, "Undef"
  vivify_764:
    $P112."add_code"($P113)
.annotate 'line', 253
    find_lex $P111, "$fixups"
    unless_null $P111, vivify_765
    new $P111, "Undef"
  vivify_765:
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
.annotate 'line', 255
    find_lex $P116, "self"
    nqp_decontainerize $P117, $P116
    set $P118, param_1162
    unless_null $P118, vivify_766
    new $P118, "Undef"
  vivify_766:
    $P119 = $P117."get_slot_past_for_object"($P118)
.annotate 'line', 256
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Val"]
    set $P124, param_1161
    unless_null $P124, vivify_767
    new $P124, "Undef"
  vivify_767:
    getprop $P125, "PAST", $P124
    $P126 = $P123."new"($P125 :named("value"))
    $P127 = $P115."new"($P119, $P126, "assign vPP" :named("pirop"))
.annotate 'line', 253
    $P128 = $P111."push"($P127)
.annotate 'line', 251
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "set_routine_signature" :anon :subid("32_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1166
    .param pmc param_1167
    .param pmc param_1168
    .param pmc param_1169
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 295
    .lex "self", param_1166
    .lex "$routine", param_1167
    .lex "$types", param_1168
    .lex "$definednesses", param_1169
.annotate 'line', 298
    new $P104, "Undef"
    set $P1170, $P104
    .lex "$fixup", $P1170
.annotate 'line', 305
    new $P105, "Undef"
    set $P1171, $P105
    .lex "$des", $P1171
.annotate 'line', 298
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
    set $P110, param_1168
    unless_null $P110, vivify_792
    new $P110, "Undef"
  vivify_792:
    set $P111, param_1169
    unless_null $P111, vivify_793
    new $P111, "Undef"
  vivify_793:
    $P112 = $P109."new"($P110, $P111, "set_sub_multisig vPPP" :named("pirop"))
    set $P1170, $P112
.annotate 'line', 299
    set $P1173, param_1167
    unless_null $P1173, vivify_794
    $P1173 = root_new ['parrot';'Hash']
  vivify_794:
    set $P106, $P1173["compile_time_dummy"]
    unless_null $P106, vivify_795
    new $P106, "Undef"
  vivify_795:
    defined $I100, $P106
    if $I100, if_1172
.annotate 'line', 303
    set $P107, $P1170
    unless_null $P107, vivify_796
    new $P107, "Undef"
  vivify_796:
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Val"]
    set $P112, param_1167
    unless_null $P112, vivify_797
    new $P112, "Undef"
  vivify_797:
    $P113 = $P111."new"($P112 :named("value"))
    $P107."unshift"($P113)
.annotate 'line', 302
    goto if_1172_end
  if_1172:
.annotate 'line', 300
    set $P107, $P1170
    unless_null $P107, vivify_798
    new $P107, "Undef"
  vivify_798:
    set $P108, param_1166
    nqp_decontainerize $P109, $P108
    set $P1174, param_1167
    unless_null $P1174, vivify_799
    $P1174 = root_new ['parrot';'Hash']
  vivify_799:
    set $P110, $P1174["compile_time_dummy"]
    unless_null $P110, vivify_800
    new $P110, "Undef"
  vivify_800:
    $P111 = $P109."get_slot_past_for_object"($P110)
    $P107."unshift"($P111)
  if_1172_end:
.annotate 'line', 305
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Op"]
.annotate 'line', 306
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Val"]
    set $P114, param_1167
    unless_null $P114, vivify_801
    new $P114, "Undef"
  vivify_801:
    $P115 = $P113."new"($P114 :named("value"))
    set $P116, param_1168
    unless_null $P116, vivify_802
    new $P116, "Undef"
  vivify_802:
    set $P117, param_1169
    unless_null $P117, vivify_803
    new $P117, "Undef"
  vivify_803:
    $P118 = $P109."new"($P115, $P116, $P117, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 305
    set $P1171, $P118
.annotate 'line', 308
    set $P106, param_1166
    nqp_decontainerize $P107, $P106
    set $P108, $P1171
    unless_null $P108, vivify_804
    new $P108, "Undef"
  vivify_804:
    set $P109, $P1170
    unless_null $P109, vivify_805
    new $P109, "Undef"
  vivify_805:
    $P110 = $P107."add_event"($P108 :named("deserialize_past"), $P109 :named("fixup_past"))
.annotate 'line', 295
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "pkg_set_body_block" :anon :subid("33_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1176
    .param pmc param_1177
    .param pmc param_1178
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 312
    .const 'Sub' $P1184 = "34_1325892461.451" 
    capture_lex $P1184
    .lex "self", param_1176
    .lex "$obj", param_1177
    .lex "$body_past", param_1178
.annotate 'line', 323
    new $P104, "Undef"
    set $P1179, $P104
    .lex "$fixups", $P1179
.annotate 'line', 324
    new $P105, "Undef"
    set $P1180, $P105
    .lex "$dummy", $P1180
.annotate 'line', 359
    new $P106, "Undef"
    set $P1181, $P106
    .lex "$slot_past", $P1181
.annotate 'line', 360
    new $P107, "Undef"
    set $P1182, $P107
    .lex "$des", $P1182
.annotate 'line', 323
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Stmts"]
    $P112 = $P111."new"()
    set $P1179, $P112
.annotate 'line', 324
    .const 'Sub' $P1184 = "34_1325892461.451" 
    newclosure $P1201, $P1184
    set $P1180, $P1201
.annotate 'line', 356
    set $P108, param_1177
    unless_null $P108, vivify_823
    new $P108, "Undef"
  vivify_823:
    get_how $P109, $P108
    set $P110, param_1177
    unless_null $P110, vivify_824
    new $P110, "Undef"
  vivify_824:
    set $P111, $P1180
    unless_null $P111, vivify_825
    new $P111, "Undef"
  vivify_825:
    $P109."set_body_block"($P110, $P111)
.annotate 'line', 359
    set $P108, param_1176
    nqp_decontainerize $P109, $P108
    set $P110, param_1177
    unless_null $P110, vivify_826
    new $P110, "Undef"
  vivify_826:
    $P111 = $P109."get_slot_past_for_object"($P110)
    set $P1181, $P111
.annotate 'line', 360
    get_hll_global $P108, "GLOBAL"
    nqp_get_package_through_who $P109, $P108, "PAST"
    get_who $P110, $P109
    set $P111, $P110["Op"]
.annotate 'line', 362
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    set $P116, $P1181
    unless_null $P116, vivify_827
    new $P116, "Undef"
  vivify_827:
    $P117 = $P115."new"($P116, "get_how PP" :named("pirop"))
    set $P118, $P1181
    unless_null $P118, vivify_828
    new $P118, "Undef"
  vivify_828:
.annotate 'line', 364
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    set $P123, param_1178
    unless_null $P123, vivify_829
    new $P123, "Undef"
  vivify_829:
    $P124 = $P122."new"($P123 :named("value"))
    $P125 = $P111."new"($P117, $P118, $P124, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 360
    set $P1182, $P125
.annotate 'line', 367
    set $P108, param_1176
    nqp_decontainerize $P109, $P108
    set $P110, $P1182
    unless_null $P110, vivify_830
    new $P110, "Undef"
  vivify_830:
    set $P111, $P1179
    unless_null $P111, vivify_831
    new $P111, "Undef"
  vivify_831:
    $P112 = $P109."add_event"($P110 :named("deserialize_past"), $P111 :named("fixup_past"))
.annotate 'line', 312
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.include "except_types.pasm"
.sub "_block1183"  :anon :subid("34_1325892461.451") :outer("33_1325892461.451")
    .param pmc param_1185 :slurpy
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 324
    .const 'Sub' $P1193 = "36_1325892461.451" 
    capture_lex $P1193
    .const 'Sub' $P1189 = "35_1325892461.451" 
    capture_lex $P1189
    .lex "@type_args", param_1185
.annotate 'line', 326
    new $P108, "Undef"
    set $P1186, $P108
    .lex "$invoke_body", $P1186
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 328
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Val"]
    find_lex $P117, "$body_past"
    unless_null $P117, vivify_806
    new $P117, "Undef"
  vivify_806:
    $P118 = $P116."new"($P117 :named("value"))
    $P119 = $P112."new"($P118, "call" :named("pasttype"))
.annotate 'line', 326
    set $P1186, $P119
.annotate 'line', 330
    set $P1187, param_1185
    unless_null $P1187, vivify_807
    $P1187 = root_new ['parrot';'ResizablePMCArray']
  vivify_807:
    defined $I100, $P1187
    unless $I100, for_undef_808
    iter $P109, $P1187
    new $P111, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P111, loop1191_handler
    push_eh $P111
  loop1191_test:
    unless $P109, loop1191_done
    shift $P110, $P109
  loop1191_redo:
    .const 'Sub' $P1189 = "35_1325892461.451" 
    capture_lex $P1189
    $P1189($P110)
  loop1191_next:
    goto loop1191_test
  loop1191_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P112, exception, 'type'
    eq $P112, .CONTROL_LOOP_NEXT, loop1191_next
    eq $P112, .CONTROL_LOOP_REDO, loop1191_redo
  loop1191_done:
    pop_eh 
  for_undef_808:
.annotate 'line', 333
    find_lex $P109, "$fixups"
    unless_null $P109, vivify_811
    new $P109, "Undef"
  vivify_811:
    set $P110, $P1186
    unless_null $P110, vivify_812
    new $P110, "Undef"
  vivify_812:
    $P109."push"($P110)
.annotate 'line', 336
    find_lex $P110, "$obj"
    unless_null $P110, vivify_813
    new $P110, "Undef"
  vivify_813:
    get_how $P111, $P110
    find_lex $P112, "$obj"
    unless_null $P112, vivify_814
    new $P112, "Undef"
  vivify_814:
    $P113 = $P111."methods"($P112, 1 :named("local"))
    defined $I100, $P113
    unless $I100, for_undef_815
    iter $P109, $P113
    new $P115, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P115, loop1200_handler
    push_eh $P115
  loop1200_test:
    unless $P109, loop1200_done
    shift $P114, $P109
  loop1200_redo:
    .const 'Sub' $P1193 = "36_1325892461.451" 
    capture_lex $P1193
    $P1193($P114)
  loop1200_next:
    goto loop1200_test
  loop1200_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P116, exception, 'type'
    eq $P116, .CONTROL_LOOP_NEXT, loop1200_next
    eq $P116, .CONTROL_LOOP_REDO, loop1200_redo
  loop1200_done:
    pop_eh 
  for_undef_815:
.annotate 'line', 324
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1188"  :anon :subid("35_1325892461.451") :outer("34_1325892461.451")
    .param pmc param_1190
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 330
    .lex "$_", param_1190
.annotate 'line', 331
    find_lex $P111, "$invoke_body"
    unless_null $P111, vivify_809
    new $P111, "Undef"
  vivify_809:
    find_lex $P112, "self"
    nqp_decontainerize $P113, $P112
    find_lex $P114, "$_"
    unless_null $P114, vivify_810
    new $P114, "Undef"
  vivify_810:
    $P115 = $P113."get_slot_past_for_object"($P114)
    $P116 = $P111."push"($P115)
.annotate 'line', 330
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1192"  :anon :subid("36_1325892461.451") :outer("34_1325892461.451")
    .param pmc param_1194
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 336
    .const 'Sub' $P1196 = "37_1325892461.451" 
    capture_lex $P1196
    .lex "$_", param_1194
.annotate 'line', 337
    find_lex $P115, "$_"
    unless_null $P115, vivify_816
    new $P115, "Undef"
  vivify_816:
    .const 'Sub' $P1196 = "37_1325892461.451" 
    newclosure $P1199, $P1196
    setprop $P115, "REIFY_CALLBACK", $P1199
.annotate 'line', 336
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1195"  :anon :subid("37_1325892461.451") :outer("36_1325892461.451")
    .param pmc param_1197
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 337
    .lex "$meth", param_1197
.annotate 'line', 339
    new $P116, "Undef"
    set $P1198, $P116
    .lex "$clone", $P1198
    set $P117, param_1197
    unless_null $P117, vivify_817
    new $P117, "Undef"
  vivify_817:
    clone $P118, $P117
    set $P1198, $P118
.annotate 'line', 340
    find_lex $P117, "self"
    nqp_decontainerize $P118, $P117
    set $P119, $P1198
    unless_null $P119, vivify_818
    new $P119, "Undef"
  vivify_818:
    $P118."add_code"($P119)
.annotate 'line', 343
    find_lex $P117, "$fixups"
    unless_null $P117, vivify_819
    new $P117, "Undef"
  vivify_819:
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
.annotate 'line', 345
    find_lex $P122, "self"
    nqp_decontainerize $P123, $P122
    set $P124, $P1198
    unless_null $P124, vivify_820
    new $P124, "Undef"
  vivify_820:
    $P125 = $P123."get_slot_past_for_object"($P124)
.annotate 'line', 346
    get_hll_global $P126, "GLOBAL"
    nqp_get_package_through_who $P127, $P126, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Val"]
    set $P130, param_1197
    unless_null $P130, vivify_821
    new $P130, "Undef"
  vivify_821:
    getprop $P131, "PAST", $P130
    $P132 = $P129."new"($P131 :named("value"))
    $P133 = $P121."new"($P125, $P132, "assign vPP" :named("pirop"))
.annotate 'line', 343
    $P117."push"($P133)
.annotate 'line', 337
    set $P117, $P1198
    unless_null $P117, vivify_822
    new $P117, "Undef"
  vivify_822:
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "pkg_add_parent_or_role" :anon :subid("38_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1203
    .param pmc param_1204
    .param pmc param_1205
    .param pmc param_1206
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 372
    .const 'Sub' $P1209 = "39_1325892461.451" 
    capture_lex $P1209
    .lex "self", param_1203
    .lex "$obj", param_1204
    .lex "$meta_method_name", param_1205
    .lex "$to_add", param_1206
.annotate 'line', 374
    set $P104, param_1204
    unless_null $P104, vivify_832
    new $P104, "Undef"
  vivify_832:
    get_how $P105, $P104
    set $P106, param_1204
    unless_null $P106, vivify_833
    new $P106, "Undef"
  vivify_833:
    set $P107, param_1206
    unless_null $P107, vivify_834
    new $P107, "Undef"
  vivify_834:
    set $P108, param_1205
    unless_null $P108, vivify_835
    new $P108, "Undef"
  vivify_835:
    set $S100, $P108
    $P105.$S100($P106, $P107)
.annotate 'line', 377
    set $P105, param_1203
    nqp_decontainerize $P106, $P105
    $P107 = $P106."is_precompilation_mode"()
    if $P107, if_1207
    set $P104, $P107
    goto if_1207_end
  if_1207:
    .const 'Sub' $P1209 = "39_1325892461.451" 
    capture_lex $P1209
    $P109 = $P1209()
    set $P104, $P109
  if_1207_end:
.annotate 'line', 372
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1208"  :anon :subid("39_1325892461.451") :outer("38_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 378
    new $P108, "Undef"
    set $P1210, $P108
    .lex "$slot_past", $P1210
    find_lex $P109, "self"
    nqp_decontainerize $P110, $P109
    find_lex $P111, "$obj"
    unless_null $P111, vivify_836
    new $P111, "Undef"
  vivify_836:
    $P112 = $P110."get_slot_past_for_object"($P111)
    set $P1210, $P112
.annotate 'line', 379
    find_lex $P109, "self"
    nqp_decontainerize $P110, $P109
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
    find_lex $P115, "$meta_method_name"
    unless_null $P115, vivify_837
    new $P115, "Undef"
  vivify_837:
.annotate 'line', 381
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P118, $P117
    set $P119, $P118["Op"]
    set $P120, $P1210
    unless_null $P120, vivify_838
    new $P120, "Undef"
  vivify_838:
    $P121 = $P119."new"($P120, "get_how PP" :named("pirop"))
    set $P122, $P1210
    unless_null $P122, vivify_839
    new $P122, "Undef"
  vivify_839:
.annotate 'line', 383
    find_lex $P123, "self"
    nqp_decontainerize $P124, $P123
    find_lex $P125, "$to_add"
    unless_null $P125, vivify_840
    new $P125, "Undef"
  vivify_840:
    $P126 = $P124."get_ref"($P125)
    $P127 = $P114."new"($P121, $P122, $P126, "callmethod" :named("pasttype"), $P115 :named("name"))
.annotate 'line', 379
    $P128 = $P110."add_event"($P127 :named("deserialize_past"))
.annotate 'line', 377
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "pkg_add_parrot_vtable_handler_mapping" :anon :subid("40_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1212
    .param pmc param_1213
    .param pmc param_1214
    .param pmc param_1215
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 388
    .const 'Sub' $P1218 = "41_1325892461.451" 
    capture_lex $P1218
    .lex "self", param_1212
    .lex "$obj", param_1213
    .lex "$name", param_1214
    .lex "$att_name", param_1215
.annotate 'line', 390
    set $P104, param_1213
    unless_null $P104, vivify_841
    new $P104, "Undef"
  vivify_841:
    get_how $P105, $P104
    set $P106, param_1213
    unless_null $P106, vivify_842
    new $P106, "Undef"
  vivify_842:
    set $P107, param_1214
    unless_null $P107, vivify_843
    new $P107, "Undef"
  vivify_843:
    set $P108, param_1215
    unless_null $P108, vivify_844
    new $P108, "Undef"
  vivify_844:
    $P105."add_parrot_vtable_handler_mapping"($P106, $P107, $P108)
.annotate 'line', 393
    set $P105, param_1212
    nqp_decontainerize $P106, $P105
    $P107 = $P106."is_precompilation_mode"()
    if $P107, if_1216
    set $P104, $P107
    goto if_1216_end
  if_1216:
    .const 'Sub' $P1218 = "41_1325892461.451" 
    capture_lex $P1218
    $P109 = $P1218()
    set $P104, $P109
  if_1216_end:
.annotate 'line', 388
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1217"  :anon :subid("41_1325892461.451") :outer("40_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 394
    new $P108, "Undef"
    set $P1219, $P108
    .lex "$slot_past", $P1219
    find_lex $P109, "self"
    nqp_decontainerize $P110, $P109
    find_lex $P111, "$obj"
    unless_null $P111, vivify_845
    new $P111, "Undef"
  vivify_845:
    $P112 = $P110."get_slot_past_for_object"($P111)
    set $P1219, $P112
.annotate 'line', 395
    find_lex $P109, "self"
    nqp_decontainerize $P110, $P109
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 397
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Op"]
    set $P119, $P1219
    unless_null $P119, vivify_846
    new $P119, "Undef"
  vivify_846:
    $P120 = $P118."new"($P119, "get_how PP" :named("pirop"))
    set $P121, $P1219
    unless_null $P121, vivify_847
    new $P121, "Undef"
  vivify_847:
    find_lex $P122, "$name"
    unless_null $P122, vivify_848
    new $P122, "Undef"
  vivify_848:
    find_lex $P123, "$att_name"
    unless_null $P123, vivify_849
    new $P123, "Undef"
  vivify_849:
    $P124 = $P114."new"($P120, $P121, $P122, $P123, "callmethod" :named("pasttype"), "add_parrot_vtable_handler_mapping" :named("name"))
.annotate 'line', 395
    $P125 = $P110."add_event"($P124 :named("deserialize_past"))
.annotate 'line', 393
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "pkg_compose" :anon :subid("42_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1221
    .param pmc param_1222
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 405
    .const 'Sub' $P1225 = "43_1325892461.451" 
    capture_lex $P1225
    .lex "self", param_1221
    .lex "$obj", param_1222
.annotate 'line', 407
    set $P104, param_1222
    unless_null $P104, vivify_850
    new $P104, "Undef"
  vivify_850:
    get_how $P105, $P104
    set $P106, param_1222
    unless_null $P106, vivify_851
    new $P106, "Undef"
  vivify_851:
    $P105."compose"($P106)
.annotate 'line', 410
    set $P105, param_1221
    nqp_decontainerize $P106, $P105
    $P107 = $P106."is_precompilation_mode"()
    if $P107, if_1223
    set $P104, $P107
    goto if_1223_end
  if_1223:
    .const 'Sub' $P1225 = "43_1325892461.451" 
    capture_lex $P1225
    $P109 = $P1225()
    set $P104, $P109
  if_1223_end:
.annotate 'line', 405
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1224"  :anon :subid("43_1325892461.451") :outer("42_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 411
    new $P108, "Undef"
    set $P1226, $P108
    .lex "$slot_past", $P1226
    find_lex $P109, "self"
    nqp_decontainerize $P110, $P109
    find_lex $P111, "$obj"
    unless_null $P111, vivify_852
    new $P111, "Undef"
  vivify_852:
    $P112 = $P110."get_slot_past_for_object"($P111)
    set $P1226, $P112
.annotate 'line', 412
    find_lex $P109, "self"
    nqp_decontainerize $P110, $P109
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 414
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Op"]
    set $P119, $P1226
    unless_null $P119, vivify_853
    new $P119, "Undef"
  vivify_853:
    $P120 = $P118."new"($P119, "get_how PP" :named("pirop"))
    set $P121, $P1226
    unless_null $P121, vivify_854
    new $P121, "Undef"
  vivify_854:
    $P122 = $P114."new"($P120, $P121, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 412
    $P123 = $P110."add_event"($P122 :named("deserialize_past"))
.annotate 'line', 410
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.include "except_types.pasm"
.sub "to_past" :anon :subid("44_1325892461.451") :outer("13_1325892461.451")
    .param pmc param_1228
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 422
    .const 'Sub' $P1232 = "45_1325892461.451" 
    capture_lex $P1232
    .lex "self", param_1228
.annotate 'line', 423
    new $P104, "Undef"
    set $P1229, $P104
    .lex "$des", $P1229
.annotate 'line', 424
    new $P105, "Undef"
    set $P1230, $P105
    .lex "$fix", $P1230
.annotate 'line', 423
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Stmts"]
    $P110 = $P109."new"()
    set $P1229, $P110
.annotate 'line', 424
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "PAST"
    get_who $P108, $P107
    set $P109, $P108["Stmts"]
    $P110 = $P109."new"()
    set $P1230, $P110
.annotate 'line', 425
    set $P107, param_1228
    nqp_decontainerize $P108, $P107
    $P109 = $P108."event_stream"()
    defined $I100, $P109
    unless $I100, for_undef_855
    iter $P106, $P109
    new $P112, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P112, loop1236_handler
    push_eh $P112
  loop1236_test:
    unless $P106, loop1236_done
    shift $P110, $P106
  loop1236_redo:
    .const 'Sub' $P1232 = "45_1325892461.451" 
    capture_lex $P1232
    $P1232($P110)
  loop1236_next:
    goto loop1236_test
  loop1236_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P113, exception, 'type'
    eq $P113, .CONTROL_LOOP_NEXT, loop1236_next
    eq $P113, .CONTROL_LOOP_REDO, loop1236_redo
  loop1236_done:
    pop_eh 
  for_undef_855:
.annotate 'line', 429
    find_dynamic_lex $P106, "$/"
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
.annotate 'line', 431
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 433
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Op"]
    set $P119, param_1228
    nqp_decontainerize $P120, $P119
    $P121 = $P120."handle"()
    $P122 = $P118."new"($P121, "nqp_get_sc Ps" :named("pirop"))
    $P123 = $P114."new"($P122, "isnull IP" :named("pirop"))
.annotate 'line', 435
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P126, $P125
    set $P127, $P126["Stmts"]
.annotate 'line', 436
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Op"]
    $P132 = $P131."new"("nqp_dynop_setup v" :named("pirop"))
.annotate 'line', 437
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Op"]
    $P137 = $P136."new"("nqp_bigint_setup v" :named("pirop"))
.annotate 'line', 438
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Op"]
.annotate 'line', 440
    get_hll_global $P142, "GLOBAL"
    nqp_get_package_through_who $P143, $P142, "PAST"
    get_who $P144, $P143
    set $P145, $P144["Op"]
    $P146 = $P145."new"("getinterp P" :named("pirop"))
.annotate 'line', 441
    get_hll_global $P147, "GLOBAL"
    nqp_get_package_through_who $P148, $P147, "PAST"
    get_who $P149, $P148
    set $P150, $P149["Op"]
    $P151 = $P150."new"("LexPad", "get_class Ps" :named("pirop"))
.annotate 'line', 442
    get_hll_global $P152, "GLOBAL"
    nqp_get_package_through_who $P153, $P152, "PAST"
    get_who $P154, $P153
    set $P155, $P154["Op"]
    $P156 = $P155."new"("NQPLexPad", "get_class Ps" :named("pirop"))
    $P157 = $P141."new"($P146, $P151, $P156, "callmethod" :named("pasttype"), "hll_map" :named("name"))
.annotate 'line', 444
    get_hll_global $P158, "GLOBAL"
    nqp_get_package_through_who $P159, $P158, "PAST"
    get_who $P160, $P159
    set $P161, $P160["Op"]
.annotate 'line', 446
    get_hll_global $P162, "GLOBAL"
    nqp_get_package_through_who $P163, $P162, "PAST"
    get_who $P164, $P163
    set $P165, $P164["Var"]
    $P166 = $P165."new"("cur_sc" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 447
    get_hll_global $P167, "GLOBAL"
    nqp_get_package_through_who $P168, $P167, "PAST"
    get_who $P169, $P168
    set $P170, $P169["Op"]
    set $P171, param_1228
    nqp_decontainerize $P172, $P171
    $P173 = $P172."handle"()
    $P174 = $P170."new"($P173, "nqp_create_sc Ps" :named("pirop"))
    $P175 = $P161."new"($P166, $P174, "bind_6model" :named("pasttype"))
.annotate 'line', 449
    get_hll_global $P176, "GLOBAL"
    nqp_get_package_through_who $P177, $P176, "PAST"
    get_who $P178, $P177
    set $P179, $P178["Op"]
.annotate 'line', 451
    get_hll_global $P180, "GLOBAL"
    nqp_get_package_through_who $P181, $P180, "PAST"
    get_who $P182, $P181
    set $P183, $P182["Var"]
    $P184 = $P183."new"("cur_sc" :named("name"), "register" :named("scope"))
.annotate 'line', 452
    set $P185, param_1228
    nqp_decontainerize $P186, $P185
    $P187 = $P186."sc"()
    $P188 = $P187."description"()
    $P189 = $P179."new"($P184, $P188, "callmethod" :named("pasttype"), "set_description" :named("name"))
.annotate 'line', 449
    set $P190, $P1229
    unless_null $P190, vivify_862
    new $P190, "Undef"
  vivify_862:
    $P191 = $P127."new"($P132, $P137, $P157, $P175, $P189, $P190)
.annotate 'line', 435
    set $P192, $P1230
    unless_null $P192, vivify_863
    new $P192, "Undef"
  vivify_863:
    $P193 = $P110."new"($P123, $P191, $P192, "if" :named("pasttype"))
.annotate 'line', 429
    $P194 = $P106."!make"($P193)
.annotate 'line', 422
    .return ($P194)
.end


.HLL "nqp"

.namespace ["NQP";"World"]
.sub "_block1231"  :anon :subid("45_1325892461.451") :outer("44_1325892461.451")
    .param pmc param_1233
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 425
    .lex "$_", param_1233
.annotate 'line', 426
    find_lex $P111, "$_"
    unless_null $P111, vivify_856
    new $P111, "Undef"
  vivify_856:
    $P112 = $P111."deserialize_past"()
    defined $I101, $P112
    unless $I101, if_1234_end
    find_lex $P113, "$des"
    unless_null $P113, vivify_857
    new $P113, "Undef"
  vivify_857:
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Stmt"]
    find_lex $P118, "$_"
    unless_null $P118, vivify_858
    new $P118, "Undef"
  vivify_858:
    $P119 = $P118."deserialize_past"()
    $P120 = $P117."new"($P119)
    $P113."push"($P120)
  if_1234_end:
.annotate 'line', 427
    find_lex $P112, "$_"
    unless_null $P112, vivify_859
    new $P112, "Undef"
  vivify_859:
    $P113 = $P112."fixup_past"()
    defined $I101, $P113
    if $I101, if_1235
    new $P111, 'Integer'
    set $P111, $I101
    goto if_1235_end
  if_1235:
    find_lex $P114, "$fix"
    unless_null $P114, vivify_860
    new $P114, "Undef"
  vivify_860:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Stmt"]
    find_lex $P119, "$_"
    unless_null $P119, vivify_861
    new $P119, "Undef"
  vivify_861:
    $P120 = $P119."fixup_past"()
    $P121 = $P118."new"($P120)
    $P122 = $P114."push"($P121)
    set $P111, $P122
  if_1235_end:
.annotate 'line', 425
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1238"  :subid("46_1325892461.451") :outer("10_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P2335 = "424_1325892461.451" 
    capture_lex $P2335
    .const 'Sub' $P2334 = "423_1325892461.451" 
    capture_lex $P2334
    .const 'Sub' $P2330 = "422_1325892461.451" 
    capture_lex $P2330
    .const 'Sub' $P2329 = "421_1325892461.451" 
    capture_lex $P2329
    .const 'Sub' $P2325 = "420_1325892461.451" 
    capture_lex $P2325
    .const 'Sub' $P2324 = "419_1325892461.451" 
    capture_lex $P2324
    .const 'Sub' $P2320 = "418_1325892461.451" 
    capture_lex $P2320
    .const 'Sub' $P2319 = "417_1325892461.451" 
    capture_lex $P2319
    .const 'Sub' $P2315 = "416_1325892461.451" 
    capture_lex $P2315
    .const 'Sub' $P2314 = "415_1325892461.451" 
    capture_lex $P2314
    .const 'Sub' $P2308 = "413_1325892461.451" 
    capture_lex $P2308
    .const 'Sub' $P2307 = "412_1325892461.451" 
    capture_lex $P2307
    .const 'Sub' $P2303 = "411_1325892461.451" 
    capture_lex $P2303
    .const 'Sub' $P2302 = "410_1325892461.451" 
    capture_lex $P2302
    .const 'Sub' $P2298 = "409_1325892461.451" 
    capture_lex $P2298
    .const 'Sub' $P2297 = "408_1325892461.451" 
    capture_lex $P2297
    .const 'Sub' $P2293 = "407_1325892461.451" 
    capture_lex $P2293
    .const 'Sub' $P2292 = "406_1325892461.451" 
    capture_lex $P2292
    .const 'Sub' $P2288 = "405_1325892461.451" 
    capture_lex $P2288
    .const 'Sub' $P2287 = "404_1325892461.451" 
    capture_lex $P2287
    .const 'Sub' $P2284 = "403_1325892461.451" 
    capture_lex $P2284
    .const 'Sub' $P2283 = "402_1325892461.451" 
    capture_lex $P2283
    .const 'Sub' $P2279 = "401_1325892461.451" 
    capture_lex $P2279
    .const 'Sub' $P2278 = "400_1325892461.451" 
    capture_lex $P2278
    .const 'Sub' $P2274 = "399_1325892461.451" 
    capture_lex $P2274
    .const 'Sub' $P2273 = "398_1325892461.451" 
    capture_lex $P2273
    .const 'Sub' $P2269 = "397_1325892461.451" 
    capture_lex $P2269
    .const 'Sub' $P2268 = "396_1325892461.451" 
    capture_lex $P2268
    .const 'Sub' $P2264 = "395_1325892461.451" 
    capture_lex $P2264
    .const 'Sub' $P2263 = "394_1325892461.451" 
    capture_lex $P2263
    .const 'Sub' $P2259 = "393_1325892461.451" 
    capture_lex $P2259
    .const 'Sub' $P2258 = "392_1325892461.451" 
    capture_lex $P2258
    .const 'Sub' $P2254 = "391_1325892461.451" 
    capture_lex $P2254
    .const 'Sub' $P2253 = "390_1325892461.451" 
    capture_lex $P2253
    .const 'Sub' $P2249 = "389_1325892461.451" 
    capture_lex $P2249
    .const 'Sub' $P2248 = "388_1325892461.451" 
    capture_lex $P2248
    .const 'Sub' $P2244 = "387_1325892461.451" 
    capture_lex $P2244
    .const 'Sub' $P2243 = "386_1325892461.451" 
    capture_lex $P2243
    .const 'Sub' $P2239 = "385_1325892461.451" 
    capture_lex $P2239
    .const 'Sub' $P2238 = "384_1325892461.451" 
    capture_lex $P2238
    .const 'Sub' $P2234 = "383_1325892461.451" 
    capture_lex $P2234
    .const 'Sub' $P2233 = "382_1325892461.451" 
    capture_lex $P2233
    .const 'Sub' $P2229 = "381_1325892461.451" 
    capture_lex $P2229
    .const 'Sub' $P2228 = "380_1325892461.451" 
    capture_lex $P2228
    .const 'Sub' $P2224 = "379_1325892461.451" 
    capture_lex $P2224
    .const 'Sub' $P2223 = "378_1325892461.451" 
    capture_lex $P2223
    .const 'Sub' $P2219 = "377_1325892461.451" 
    capture_lex $P2219
    .const 'Sub' $P2218 = "376_1325892461.451" 
    capture_lex $P2218
    .const 'Sub' $P2214 = "375_1325892461.451" 
    capture_lex $P2214
    .const 'Sub' $P2213 = "374_1325892461.451" 
    capture_lex $P2213
    .const 'Sub' $P2209 = "373_1325892461.451" 
    capture_lex $P2209
    .const 'Sub' $P2208 = "372_1325892461.451" 
    capture_lex $P2208
    .const 'Sub' $P2204 = "371_1325892461.451" 
    capture_lex $P2204
    .const 'Sub' $P2203 = "370_1325892461.451" 
    capture_lex $P2203
    .const 'Sub' $P2199 = "369_1325892461.451" 
    capture_lex $P2199
    .const 'Sub' $P2198 = "368_1325892461.451" 
    capture_lex $P2198
    .const 'Sub' $P2194 = "367_1325892461.451" 
    capture_lex $P2194
    .const 'Sub' $P2193 = "366_1325892461.451" 
    capture_lex $P2193
    .const 'Sub' $P2189 = "365_1325892461.451" 
    capture_lex $P2189
    .const 'Sub' $P2188 = "364_1325892461.451" 
    capture_lex $P2188
    .const 'Sub' $P2184 = "363_1325892461.451" 
    capture_lex $P2184
    .const 'Sub' $P2183 = "362_1325892461.451" 
    capture_lex $P2183
    .const 'Sub' $P2179 = "361_1325892461.451" 
    capture_lex $P2179
    .const 'Sub' $P2178 = "360_1325892461.451" 
    capture_lex $P2178
    .const 'Sub' $P2174 = "359_1325892461.451" 
    capture_lex $P2174
    .const 'Sub' $P2173 = "358_1325892461.451" 
    capture_lex $P2173
    .const 'Sub' $P2169 = "357_1325892461.451" 
    capture_lex $P2169
    .const 'Sub' $P2168 = "356_1325892461.451" 
    capture_lex $P2168
    .const 'Sub' $P2164 = "355_1325892461.451" 
    capture_lex $P2164
    .const 'Sub' $P2163 = "354_1325892461.451" 
    capture_lex $P2163
    .const 'Sub' $P2159 = "353_1325892461.451" 
    capture_lex $P2159
    .const 'Sub' $P2158 = "352_1325892461.451" 
    capture_lex $P2158
    .const 'Sub' $P2154 = "351_1325892461.451" 
    capture_lex $P2154
    .const 'Sub' $P2153 = "350_1325892461.451" 
    capture_lex $P2153
    .const 'Sub' $P2149 = "349_1325892461.451" 
    capture_lex $P2149
    .const 'Sub' $P2148 = "348_1325892461.451" 
    capture_lex $P2148
    .const 'Sub' $P2144 = "347_1325892461.451" 
    capture_lex $P2144
    .const 'Sub' $P2143 = "346_1325892461.451" 
    capture_lex $P2143
    .const 'Sub' $P2139 = "345_1325892461.451" 
    capture_lex $P2139
    .const 'Sub' $P2138 = "344_1325892461.451" 
    capture_lex $P2138
    .const 'Sub' $P2134 = "343_1325892461.451" 
    capture_lex $P2134
    .const 'Sub' $P2133 = "342_1325892461.451" 
    capture_lex $P2133
    .const 'Sub' $P2129 = "341_1325892461.451" 
    capture_lex $P2129
    .const 'Sub' $P2128 = "340_1325892461.451" 
    capture_lex $P2128
    .const 'Sub' $P2124 = "339_1325892461.451" 
    capture_lex $P2124
    .const 'Sub' $P2123 = "338_1325892461.451" 
    capture_lex $P2123
    .const 'Sub' $P2119 = "337_1325892461.451" 
    capture_lex $P2119
    .const 'Sub' $P2118 = "336_1325892461.451" 
    capture_lex $P2118
    .const 'Sub' $P2114 = "335_1325892461.451" 
    capture_lex $P2114
    .const 'Sub' $P2113 = "334_1325892461.451" 
    capture_lex $P2113
    .const 'Sub' $P2109 = "333_1325892461.451" 
    capture_lex $P2109
    .const 'Sub' $P2108 = "332_1325892461.451" 
    capture_lex $P2108
    .const 'Sub' $P2104 = "331_1325892461.451" 
    capture_lex $P2104
    .const 'Sub' $P2103 = "330_1325892461.451" 
    capture_lex $P2103
    .const 'Sub' $P2099 = "329_1325892461.451" 
    capture_lex $P2099
    .const 'Sub' $P2098 = "328_1325892461.451" 
    capture_lex $P2098
    .const 'Sub' $P2095 = "327_1325892461.451" 
    capture_lex $P2095
    .const 'Sub' $P2094 = "326_1325892461.451" 
    capture_lex $P2094
    .const 'Sub' $P2091 = "325_1325892461.451" 
    capture_lex $P2091
    .const 'Sub' $P2090 = "324_1325892461.451" 
    capture_lex $P2090
    .const 'Sub' $P2087 = "323_1325892461.451" 
    capture_lex $P2087
    .const 'Sub' $P2086 = "322_1325892461.451" 
    capture_lex $P2086
    .const 'Sub' $P2083 = "321_1325892461.451" 
    capture_lex $P2083
    .const 'Sub' $P2082 = "320_1325892461.451" 
    capture_lex $P2082
    .const 'Sub' $P2079 = "319_1325892461.451" 
    capture_lex $P2079
    .const 'Sub' $P2078 = "318_1325892461.451" 
    capture_lex $P2078
    .const 'Sub' $P2075 = "317_1325892461.451" 
    capture_lex $P2075
    .const 'Sub' $P2074 = "316_1325892461.451" 
    capture_lex $P2074
    .const 'Sub' $P2071 = "315_1325892461.451" 
    capture_lex $P2071
    .const 'Sub' $P2070 = "314_1325892461.451" 
    capture_lex $P2070
    .const 'Sub' $P2067 = "313_1325892461.451" 
    capture_lex $P2067
    .const 'Sub' $P2066 = "312_1325892461.451" 
    capture_lex $P2066
    .const 'Sub' $P2061 = "311_1325892461.451" 
    capture_lex $P2061
    .const 'Sub' $P2060 = "310_1325892461.451" 
    capture_lex $P2060
    .const 'Sub' $P2057 = "309_1325892461.451" 
    capture_lex $P2057
    .const 'Sub' $P2056 = "308_1325892461.451" 
    capture_lex $P2056
    .const 'Sub' $P2053 = "307_1325892461.451" 
    capture_lex $P2053
    .const 'Sub' $P2052 = "306_1325892461.451" 
    capture_lex $P2052
    .const 'Sub' $P2049 = "305_1325892461.451" 
    capture_lex $P2049
    .const 'Sub' $P2048 = "304_1325892461.451" 
    capture_lex $P2048
    .const 'Sub' $P2043 = "303_1325892461.451" 
    capture_lex $P2043
    .const 'Sub' $P2042 = "302_1325892461.451" 
    capture_lex $P2042
    .const 'Sub' $P2037 = "301_1325892461.451" 
    capture_lex $P2037
    .const 'Sub' $P2036 = "300_1325892461.451" 
    capture_lex $P2036
    .const 'Sub' $P2033 = "299_1325892461.451" 
    capture_lex $P2033
    .const 'Sub' $P2032 = "298_1325892461.451" 
    capture_lex $P2032
    .const 'Sub' $P2029 = "297_1325892461.451" 
    capture_lex $P2029
    .const 'Sub' $P2028 = "296_1325892461.451" 
    capture_lex $P2028
    .const 'Sub' $P2025 = "295_1325892461.451" 
    capture_lex $P2025
    .const 'Sub' $P2024 = "294_1325892461.451" 
    capture_lex $P2024
    .const 'Sub' $P2021 = "293_1325892461.451" 
    capture_lex $P2021
    .const 'Sub' $P2020 = "292_1325892461.451" 
    capture_lex $P2020
    .const 'Sub' $P2016 = "291_1325892461.451" 
    capture_lex $P2016
    .const 'Sub' $P2015 = "290_1325892461.451" 
    capture_lex $P2015
    .const 'Sub' $P2011 = "289_1325892461.451" 
    capture_lex $P2011
    .const 'Sub' $P2010 = "288_1325892461.451" 
    capture_lex $P2010
    .const 'Sub' $P2006 = "287_1325892461.451" 
    capture_lex $P2006
    .const 'Sub' $P2005 = "286_1325892461.451" 
    capture_lex $P2005
    .const 'Sub' $P2001 = "285_1325892461.451" 
    capture_lex $P2001
    .const 'Sub' $P2000 = "284_1325892461.451" 
    capture_lex $P2000
    .const 'Sub' $P1997 = "283_1325892461.451" 
    capture_lex $P1997
    .const 'Sub' $P1996 = "282_1325892461.451" 
    capture_lex $P1996
    .const 'Sub' $P1993 = "281_1325892461.451" 
    capture_lex $P1993
    .const 'Sub' $P1988 = "278_1325892461.451" 
    capture_lex $P1988
    .const 'Sub' $P1982 = "277_1325892461.451" 
    capture_lex $P1982
    .const 'Sub' $P1981 = "276_1325892461.451" 
    capture_lex $P1981
    .const 'Sub' $P1977 = "275_1325892461.451" 
    capture_lex $P1977
    .const 'Sub' $P1976 = "274_1325892461.451" 
    capture_lex $P1976
    .const 'Sub' $P1973 = "273_1325892461.451" 
    capture_lex $P1973
    .const 'Sub' $P1972 = "272_1325892461.451" 
    capture_lex $P1972
    .const 'Sub' $P1968 = "271_1325892461.451" 
    capture_lex $P1968
    .const 'Sub' $P1967 = "270_1325892461.451" 
    capture_lex $P1967
    .const 'Sub' $P1964 = "269_1325892461.451" 
    capture_lex $P1964
    .const 'Sub' $P1963 = "268_1325892461.451" 
    capture_lex $P1963
    .const 'Sub' $P1957 = "266_1325892461.451" 
    capture_lex $P1957
    .const 'Sub' $P1956 = "265_1325892461.451" 
    capture_lex $P1956
    .const 'Sub' $P1950 = "264_1325892461.451" 
    capture_lex $P1950
    .const 'Sub' $P1949 = "263_1325892461.451" 
    capture_lex $P1949
    .const 'Sub' $P1945 = "262_1325892461.451" 
    capture_lex $P1945
    .const 'Sub' $P1944 = "261_1325892461.451" 
    capture_lex $P1944
    .const 'Sub' $P1938 = "260_1325892461.451" 
    capture_lex $P1938
    .const 'Sub' $P1937 = "259_1325892461.451" 
    capture_lex $P1937
    .const 'Sub' $P1932 = "258_1325892461.451" 
    capture_lex $P1932
    .const 'Sub' $P1931 = "257_1325892461.451" 
    capture_lex $P1931
    .const 'Sub' $P1928 = "256_1325892461.451" 
    capture_lex $P1928
    .const 'Sub' $P1927 = "255_1325892461.451" 
    capture_lex $P1927
    .const 'Sub' $P1923 = "254_1325892461.451" 
    capture_lex $P1923
    .const 'Sub' $P1918 = "251_1325892461.451" 
    capture_lex $P1918
    .const 'Sub' $P1911 = "250_1325892461.451" 
    capture_lex $P1911
    .const 'Sub' $P1910 = "249_1325892461.451" 
    capture_lex $P1910
    .const 'Sub' $P1900 = "248_1325892461.451" 
    capture_lex $P1900
    .const 'Sub' $P1899 = "247_1325892461.451" 
    capture_lex $P1899
    .const 'Sub' $P1893 = "246_1325892461.451" 
    capture_lex $P1893
    .const 'Sub' $P1888 = "243_1325892461.451" 
    capture_lex $P1888
    .const 'Sub' $P1885 = "242_1325892461.451" 
    capture_lex $P1885
    .const 'Sub' $P1884 = "241_1325892461.451" 
    capture_lex $P1884
    .const 'Sub' $P1881 = "240_1325892461.451" 
    capture_lex $P1881
    .const 'Sub' $P1880 = "239_1325892461.451" 
    capture_lex $P1880
    .const 'Sub' $P1877 = "238_1325892461.451" 
    capture_lex $P1877
    .const 'Sub' $P1876 = "237_1325892461.451" 
    capture_lex $P1876
    .const 'Sub' $P1869 = "236_1325892461.451" 
    capture_lex $P1869
    .const 'Sub' $P1868 = "235_1325892461.451" 
    capture_lex $P1868
    .const 'Sub' $P1855 = "234_1325892461.451" 
    capture_lex $P1855
    .const 'Sub' $P1854 = "233_1325892461.451" 
    capture_lex $P1854
    .const 'Sub' $P1846 = "231_1325892461.451" 
    capture_lex $P1846
    .const 'Sub' $P1845 = "230_1325892461.451" 
    capture_lex $P1845
    .const 'Sub' $P1841 = "229_1325892461.451" 
    capture_lex $P1841
    .const 'Sub' $P1840 = "228_1325892461.451" 
    capture_lex $P1840
    .const 'Sub' $P1834 = "227_1325892461.451" 
    capture_lex $P1834
    .const 'Sub' $P1833 = "226_1325892461.451" 
    capture_lex $P1833
    .const 'Sub' $P1827 = "225_1325892461.451" 
    capture_lex $P1827
    .const 'Sub' $P1822 = "222_1325892461.451" 
    capture_lex $P1822
    .const 'Sub' $P1817 = "220_1325892461.451" 
    capture_lex $P1817
    .const 'Sub' $P1816 = "219_1325892461.451" 
    capture_lex $P1816
    .const 'Sub' $P1801 = "217_1325892461.451" 
    capture_lex $P1801
    .const 'Sub' $P1800 = "216_1325892461.451" 
    capture_lex $P1800
    .const 'Sub' $P1789 = "215_1325892461.451" 
    capture_lex $P1789
    .const 'Sub' $P1788 = "214_1325892461.451" 
    capture_lex $P1788
    .const 'Sub' $P1784 = "213_1325892461.451" 
    capture_lex $P1784
    .const 'Sub' $P1783 = "212_1325892461.451" 
    capture_lex $P1783
    .const 'Sub' $P1779 = "211_1325892461.451" 
    capture_lex $P1779
    .const 'Sub' $P1774 = "208_1325892461.451" 
    capture_lex $P1774
    .const 'Sub' $P1764 = "206_1325892461.451" 
    capture_lex $P1764
    .const 'Sub' $P1763 = "205_1325892461.451" 
    capture_lex $P1763
    .const 'Sub' $P1759 = "204_1325892461.451" 
    capture_lex $P1759
    .const 'Sub' $P1758 = "203_1325892461.451" 
    capture_lex $P1758
    .const 'Sub' $P1751 = "201_1325892461.451" 
    capture_lex $P1751
    .const 'Sub' $P1750 = "200_1325892461.451" 
    capture_lex $P1750
    .const 'Sub' $P1745 = "199_1325892461.451" 
    capture_lex $P1745
    .const 'Sub' $P1744 = "198_1325892461.451" 
    capture_lex $P1744
    .const 'Sub' $P1740 = "197_1325892461.451" 
    capture_lex $P1740
    .const 'Sub' $P1739 = "196_1325892461.451" 
    capture_lex $P1739
    .const 'Sub' $P1735 = "195_1325892461.451" 
    capture_lex $P1735
    .const 'Sub' $P1734 = "194_1325892461.451" 
    capture_lex $P1734
    .const 'Sub' $P1730 = "193_1325892461.451" 
    capture_lex $P1730
    .const 'Sub' $P1725 = "190_1325892461.451" 
    capture_lex $P1725
    .const 'Sub' $P1681 = "188_1325892461.451" 
    capture_lex $P1681
    .const 'Sub' $P1680 = "187_1325892461.451" 
    capture_lex $P1680
    .const 'Sub' $P1674 = "186_1325892461.451" 
    capture_lex $P1674
    .const 'Sub' $P1673 = "185_1325892461.451" 
    capture_lex $P1673
    .const 'Sub' $P1667 = "184_1325892461.451" 
    capture_lex $P1667
    .const 'Sub' $P1666 = "183_1325892461.451" 
    capture_lex $P1666
    .const 'Sub' $P1660 = "182_1325892461.451" 
    capture_lex $P1660
    .const 'Sub' $P1659 = "181_1325892461.451" 
    capture_lex $P1659
    .const 'Sub' $P1653 = "180_1325892461.451" 
    capture_lex $P1653
    .const 'Sub' $P1652 = "179_1325892461.451" 
    capture_lex $P1652
    .const 'Sub' $P1646 = "178_1325892461.451" 
    capture_lex $P1646
    .const 'Sub' $P1645 = "177_1325892461.451" 
    capture_lex $P1645
    .const 'Sub' $P1639 = "176_1325892461.451" 
    capture_lex $P1639
    .const 'Sub' $P1638 = "175_1325892461.451" 
    capture_lex $P1638
    .const 'Sub' $P1632 = "174_1325892461.451" 
    capture_lex $P1632
    .const 'Sub' $P1627 = "171_1325892461.451" 
    capture_lex $P1627
    .const 'Sub' $P1624 = "170_1325892461.451" 
    capture_lex $P1624
    .const 'Sub' $P1623 = "169_1325892461.451" 
    capture_lex $P1623
    .const 'Sub' $P1620 = "168_1325892461.451" 
    capture_lex $P1620
    .const 'Sub' $P1619 = "167_1325892461.451" 
    capture_lex $P1619
    .const 'Sub' $P1611 = "166_1325892461.451" 
    capture_lex $P1611
    .const 'Sub' $P1610 = "165_1325892461.451" 
    capture_lex $P1610
    .const 'Sub' $P1603 = "164_1325892461.451" 
    capture_lex $P1603
    .const 'Sub' $P1602 = "163_1325892461.451" 
    capture_lex $P1602
    .const 'Sub' $P1598 = "162_1325892461.451" 
    capture_lex $P1598
    .const 'Sub' $P1597 = "161_1325892461.451" 
    capture_lex $P1597
    .const 'Sub' $P1594 = "160_1325892461.451" 
    capture_lex $P1594
    .const 'Sub' $P1593 = "159_1325892461.451" 
    capture_lex $P1593
    .const 'Sub' $P1590 = "158_1325892461.451" 
    capture_lex $P1590
    .const 'Sub' $P1589 = "157_1325892461.451" 
    capture_lex $P1589
    .const 'Sub' $P1586 = "156_1325892461.451" 
    capture_lex $P1586
    .const 'Sub' $P1585 = "155_1325892461.451" 
    capture_lex $P1585
    .const 'Sub' $P1572 = "152_1325892461.451" 
    capture_lex $P1572
    .const 'Sub' $P1571 = "151_1325892461.451" 
    capture_lex $P1571
    .const 'Sub' $P1568 = "150_1325892461.451" 
    capture_lex $P1568
    .const 'Sub' $P1567 = "149_1325892461.451" 
    capture_lex $P1567
    .const 'Sub' $P1564 = "148_1325892461.451" 
    capture_lex $P1564
    .const 'Sub' $P1563 = "147_1325892461.451" 
    capture_lex $P1563
    .const 'Sub' $P1560 = "146_1325892461.451" 
    capture_lex $P1560
    .const 'Sub' $P1559 = "145_1325892461.451" 
    capture_lex $P1559
    .const 'Sub' $P1556 = "144_1325892461.451" 
    capture_lex $P1556
    .const 'Sub' $P1555 = "143_1325892461.451" 
    capture_lex $P1555
    .const 'Sub' $P1552 = "142_1325892461.451" 
    capture_lex $P1552
    .const 'Sub' $P1551 = "141_1325892461.451" 
    capture_lex $P1551
    .const 'Sub' $P1548 = "140_1325892461.451" 
    capture_lex $P1548
    .const 'Sub' $P1547 = "139_1325892461.451" 
    capture_lex $P1547
    .const 'Sub' $P1543 = "138_1325892461.451" 
    capture_lex $P1543
    .const 'Sub' $P1542 = "137_1325892461.451" 
    capture_lex $P1542
    .const 'Sub' $P1538 = "136_1325892461.451" 
    capture_lex $P1538
    .const 'Sub' $P1537 = "135_1325892461.451" 
    capture_lex $P1537
    .const 'Sub' $P1533 = "134_1325892461.451" 
    capture_lex $P1533
    .const 'Sub' $P1528 = "131_1325892461.451" 
    capture_lex $P1528
    .const 'Sub' $P1524 = "130_1325892461.451" 
    capture_lex $P1524
    .const 'Sub' $P1523 = "129_1325892461.451" 
    capture_lex $P1523
    .const 'Sub' $P1519 = "128_1325892461.451" 
    capture_lex $P1519
    .const 'Sub' $P1514 = "125_1325892461.451" 
    capture_lex $P1514
    .const 'Sub' $P1510 = "124_1325892461.451" 
    capture_lex $P1510
    .const 'Sub' $P1509 = "123_1325892461.451" 
    capture_lex $P1509
    .const 'Sub' $P1505 = "122_1325892461.451" 
    capture_lex $P1505
    .const 'Sub' $P1504 = "121_1325892461.451" 
    capture_lex $P1504
    .const 'Sub' $P1500 = "120_1325892461.451" 
    capture_lex $P1500
    .const 'Sub' $P1495 = "117_1325892461.451" 
    capture_lex $P1495
    .const 'Sub' $P1491 = "116_1325892461.451" 
    capture_lex $P1491
    .const 'Sub' $P1490 = "115_1325892461.451" 
    capture_lex $P1490
    .const 'Sub' $P1486 = "114_1325892461.451" 
    capture_lex $P1486
    .const 'Sub' $P1485 = "113_1325892461.451" 
    capture_lex $P1485
    .const 'Sub' $P1481 = "112_1325892461.451" 
    capture_lex $P1481
    .const 'Sub' $P1480 = "111_1325892461.451" 
    capture_lex $P1480
    .const 'Sub' $P1471 = "110_1325892461.451" 
    capture_lex $P1471
    .const 'Sub' $P1470 = "109_1325892461.451" 
    capture_lex $P1470
    .const 'Sub' $P1465 = "108_1325892461.451" 
    capture_lex $P1465
    .const 'Sub' $P1464 = "107_1325892461.451" 
    capture_lex $P1464
    .const 'Sub' $P1455 = "105_1325892461.451" 
    capture_lex $P1455
    .const 'Sub' $P1454 = "104_1325892461.451" 
    capture_lex $P1454
    .const 'Sub' $P1448 = "103_1325892461.451" 
    capture_lex $P1448
    .const 'Sub' $P1447 = "102_1325892461.451" 
    capture_lex $P1447
    .const 'Sub' $P1443 = "101_1325892461.451" 
    capture_lex $P1443
    .const 'Sub' $P1438 = "98_1325892461.451" 
    capture_lex $P1438
    .const 'Sub' $P1435 = "97_1325892461.451" 
    capture_lex $P1435
    .const 'Sub' $P1434 = "96_1325892461.451" 
    capture_lex $P1434
    .const 'Sub' $P1431 = "95_1325892461.451" 
    capture_lex $P1431
    .const 'Sub' $P1426 = "92_1325892461.451" 
    capture_lex $P1426
    .const 'Sub' $P1423 = "91_1325892461.451" 
    capture_lex $P1423
    .const 'Sub' $P1422 = "90_1325892461.451" 
    capture_lex $P1422
    .const 'Sub' $P1419 = "89_1325892461.451" 
    capture_lex $P1419
    .const 'Sub' $P1418 = "88_1325892461.451" 
    capture_lex $P1418
    .const 'Sub' $P1415 = "87_1325892461.451" 
    capture_lex $P1415
    .const 'Sub' $P1414 = "86_1325892461.451" 
    capture_lex $P1414
    .const 'Sub' $P1411 = "85_1325892461.451" 
    capture_lex $P1411
    .const 'Sub' $P1410 = "84_1325892461.451" 
    capture_lex $P1410
    .const 'Sub' $P1407 = "83_1325892461.451" 
    capture_lex $P1407
    .const 'Sub' $P1406 = "82_1325892461.451" 
    capture_lex $P1406
    .const 'Sub' $P1400 = "81_1325892461.451" 
    capture_lex $P1400
    .const 'Sub' $P1399 = "80_1325892461.451" 
    capture_lex $P1399
    .const 'Sub' $P1395 = "79_1325892461.451" 
    capture_lex $P1395
    .const 'Sub' $P1394 = "78_1325892461.451" 
    capture_lex $P1394
    .const 'Sub' $P1390 = "77_1325892461.451" 
    capture_lex $P1390
    .const 'Sub' $P1389 = "76_1325892461.451" 
    capture_lex $P1389
    .const 'Sub' $P1385 = "75_1325892461.451" 
    capture_lex $P1385
    .const 'Sub' $P1384 = "74_1325892461.451" 
    capture_lex $P1384
    .const 'Sub' $P1381 = "73_1325892461.451" 
    capture_lex $P1381
    .const 'Sub' $P1380 = "72_1325892461.451" 
    capture_lex $P1380
    .const 'Sub' $P1376 = "71_1325892461.451" 
    capture_lex $P1376
    .const 'Sub' $P1375 = "70_1325892461.451" 
    capture_lex $P1375
    .const 'Sub' $P1362 = "68_1325892461.451" 
    capture_lex $P1362
    .const 'Sub' $P1361 = "67_1325892461.451" 
    capture_lex $P1361
    .const 'Sub' $P1356 = "66_1325892461.451" 
    capture_lex $P1356
    .const 'Sub' $P1355 = "65_1325892461.451" 
    capture_lex $P1355
    .const 'Sub' $P1346 = "64_1325892461.451" 
    capture_lex $P1346
    .const 'Sub' $P1345 = "63_1325892461.451" 
    capture_lex $P1345
    .const 'Sub' $P1309 = "61_1325892461.451" 
    capture_lex $P1309
    .const 'Sub' $P1308 = "60_1325892461.451" 
    capture_lex $P1308
    .const 'Sub' $P1295 = "58_1325892461.451" 
    capture_lex $P1295
    .const 'Sub' $P1294 = "57_1325892461.451" 
    capture_lex $P1294
    .const 'Sub' $P1285 = "56_1325892461.451" 
    capture_lex $P1285
    .const 'Sub' $P1284 = "55_1325892461.451" 
    capture_lex $P1284
    .const 'Sub' $P1274 = "54_1325892461.451" 
    capture_lex $P1274
    .const 'Sub' $P1273 = "53_1325892461.451" 
    capture_lex $P1273
    .const 'Sub' $P1268 = "52_1325892461.451" 
    capture_lex $P1268
    .const 'Sub' $P1267 = "51_1325892461.451" 
    capture_lex $P1267
    .const 'Sub' $P1262 = "50_1325892461.451" 
    capture_lex $P1262
    .const 'Sub' $P1261 = "49_1325892461.451" 
    capture_lex $P1261
    .const 'Sub' $P1257 = "48_1325892461.451" 
    capture_lex $P1257
    .const 'Sub' $P1242 = "47_1325892461.451" 
    capture_lex $P1242
    .lex "$?PACKAGE", $P1240
    .lex "$?CLASS", $P1241
.annotate 'line', 1077
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 1078
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 1079
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 1080
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 1081
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 1082
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 1083
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 1084
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 1085
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 1086
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 1087
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 1088
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 1089
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 1090
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 1091
    get_hll_global $P103, "GLOBAL"
    nqp_get_package_through_who $P104, $P103, "NQP"
    get_who $P105, $P104
    set $P106, $P105["Grammar"]
    $P106."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 1190
    .const 'Sub' $P2335 = "424_1325892461.451" 
    newclosure $P2343, $P2335
.annotate 'line', 462
    .return ($P2343)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP" :anon :subid("47_1325892461.451") :outer("46_1325892461.451")
    .param pmc param_1243
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 463
    .lex "self", param_1243
.annotate 'line', 465
    $P1245 = root_new ['parrot';'Hash']
    set $P1244, $P1245
    .lex "%*LANG", $P1244
.annotate 'line', 474
    $P1247 = root_new ['parrot';'Hash']
    set $P1246, $P1247
    .lex "%*HOW", $P1246
.annotate 'line', 481
    new $P103, "Undef"
    set $P1248, $P103
    .lex "$file", $P1248
.annotate 'line', 482
    new $P104, "Undef"
    set $P1249, $P104
    .lex "$source_id", $P1249
.annotate 'line', 484
    new $P105, "Undef"
    set $P1250, $P105
    .lex "$*W", $P1250
.annotate 'line', 488
    new $P106, "Undef"
    set $P1251, $P106
    .lex "$*SCOPE", $P1251
.annotate 'line', 489
    new $P107, "Undef"
    set $P1252, $P107
    .lex "$*MULTINESS", $P1252
.annotate 'line', 490
    new $P108, "Undef"
    set $P1253, $P108
    .lex "$*PKGDECL", $P1253
.annotate 'line', 491
    new $P109, "Undef"
    set $P1254, $P109
    .lex "$*INVOCANT_OK", $P1254
.annotate 'line', 492
    new $P110, "Undef"
    set $P1255, $P110
    .lex "$*RETURN_USED", $P1255
.annotate 'line', 463
    set $P113, $P1244
    unless_null $P113, vivify_864
    get_hll_global $P111, "GLOBAL"
    get_who $P112, $P111
    set $P113, $P112["%LANG"]
    unless_null $P113, vivify_865
    die "Contextual %*LANG not found"
  vivify_865:
  vivify_864:
.annotate 'line', 466
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "NQP"
    get_who $P113, $P112
    set $P114, $P113["Regex"]
    set $P117, $P1244
    unless_null $P117, vivify_866
    get_hll_global $P115, "GLOBAL"
    get_who $P116, $P115
    set $P117, $P116["%LANG"]
    unless_null $P117, vivify_867
    die "Contextual %*LANG not found"
  vivify_867:
    set $P1244, $P117
  vivify_866:
    set $P117["Regex"], $P114
.annotate 'line', 467
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "NQP"
    get_who $P113, $P112
    set $P114, $P113["RegexActions"]
    set $P117, $P1244
    unless_null $P117, vivify_868
    get_hll_global $P115, "GLOBAL"
    get_who $P116, $P115
    set $P117, $P116["%LANG"]
    unless_null $P117, vivify_869
    die "Contextual %*LANG not found"
  vivify_869:
    set $P1244, $P117
  vivify_868:
    set $P117["Regex-actions"], $P114
.annotate 'line', 468
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "NQP"
    get_who $P113, $P112
    set $P114, $P113["Grammar"]
    set $P117, $P1244
    unless_null $P117, vivify_870
    get_hll_global $P115, "GLOBAL"
    get_who $P116, $P115
    set $P117, $P116["%LANG"]
    unless_null $P117, vivify_871
    die "Contextual %*LANG not found"
  vivify_871:
    set $P1244, $P117
  vivify_870:
    set $P117["MAIN"], $P114
.annotate 'line', 469
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "NQP"
    get_who $P113, $P112
    set $P114, $P113["Actions"]
    set $P117, $P1244
    unless_null $P117, vivify_872
    get_hll_global $P115, "GLOBAL"
    get_who $P116, $P115
    set $P117, $P116["%LANG"]
    unless_null $P117, vivify_873
    die "Contextual %*LANG not found"
  vivify_873:
    set $P1244, $P117
  vivify_872:
    set $P117["MAIN-actions"], $P114
.annotate 'line', 463
    set $P113, $P1246
    unless_null $P113, vivify_874
    get_hll_global $P111, "GLOBAL"
    get_who $P112, $P111
    set $P113, $P112["%HOW"]
    unless_null $P113, vivify_875
    die "Contextual %*HOW not found"
  vivify_875:
  vivify_874:
.annotate 'line', 475
    get_knowhow $P111
    set $P114, $P1246
    unless_null $P114, vivify_876
    get_hll_global $P112, "GLOBAL"
    get_who $P113, $P112
    set $P114, $P113["%HOW"]
    unless_null $P114, vivify_877
    die "Contextual %*HOW not found"
  vivify_877:
    set $P1246, $P114
  vivify_876:
    set $P114["knowhow"], $P111
.annotate 'line', 476
    get_knowhow_attribute $P111
    set $P114, $P1246
    unless_null $P114, vivify_878
    get_hll_global $P112, "GLOBAL"
    get_who $P113, $P112
    set $P114, $P113["%HOW"]
    unless_null $P114, vivify_879
    die "Contextual %*HOW not found"
  vivify_879:
    set $P1246, $P114
  vivify_878:
    set $P114["knowhow-attr"], $P111
.annotate 'line', 481
    find_caller_lex $P111, "$?FILES"
    set $P1248, $P111
.annotate 'line', 482
    set $P111, param_1243
    nqp_decontainerize $P112, $P111
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "Regex"
    get_who $P115, $P114
    set $P116, $P115["Cursor"]
    getattribute $P117, $P112, $P116, "$!target"
    set $S100, $P117
    nqp_sha1 $S101, $S100
    new $P118, 'String'
    set $P118, $S101
    concat $P119, $P118, "-"
.annotate 'line', 483
    time $N100
    set $S102, $N100
    concat $P120, $P119, $S102
    set $P1249, $P120
.annotate 'line', 484
    set $P112, $P1248
    unless_null $P112, vivify_880
    new $P112, "Undef"
  vivify_880:
    isnull $I100, $P112
    if $I100, if_1256
.annotate 'line', 486
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "NQP"
    get_who $P121, $P120
    set $P122, $P121["World"]
    set $P123, $P1249
    unless_null $P123, vivify_881
    new $P123, "Undef"
  vivify_881:
    set $P124, $P1248
    unless_null $P124, vivify_882
    new $P124, "Undef"
  vivify_882:
    $P125 = $P122."new"($P123 :named("handle"), $P124 :named("description"))
    set $P111, $P125
.annotate 'line', 484
    goto if_1256_end
  if_1256:
.annotate 'line', 485
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "NQP"
    get_who $P115, $P114
    set $P116, $P115["World"]
    set $P117, $P1249
    unless_null $P117, vivify_883
    new $P117, "Undef"
  vivify_883:
    $P118 = $P116."new"($P117 :named("handle"))
    set $P111, $P118
  if_1256_end:
.annotate 'line', 484
    set $P1250, $P111
.annotate 'line', 488
    new $P111, "String"
    assign $P111, ""
    set $P1251, $P111
.annotate 'line', 489
    new $P111, "String"
    assign $P111, ""
    set $P1252, $P111
.annotate 'line', 490
    new $P111, "String"
    assign $P111, ""
    set $P1253, $P111
.annotate 'line', 491
    new $P111, "Float"
    assign $P111, 0
    set $P1254, $P111
.annotate 'line', 492
    new $P111, "Float"
    assign $P111, 0
    set $P1255, $P111
.annotate 'line', 493
    set $P111, param_1243
    nqp_decontainerize $P112, $P111
    $P113 = $P112."comp_unit"()
.annotate 'line', 463
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("48_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1258_tgt
    .local int rx1258_pos
    .local int rx1258_off
    .local int rx1258_eos
    .local int rx1258_rep
    .local pmc rx1258_cur
    .local pmc rx1258_debug
    (rx1258_cur, rx1258_pos, rx1258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1258_cur
    .local pmc match
    .lex "$/", match
    length rx1258_eos, rx1258_tgt
    gt rx1258_pos, rx1258_eos, rx1258_done
    set rx1258_off, 0
    lt rx1258_pos, 2, rx1258_start
    sub rx1258_off, rx1258_pos, 1
    substr rx1258_tgt, rx1258_tgt, rx1258_off
  rx1258_start:
    eq $I10, 1, rx1258_restart
    if_null rx1258_debug, debug_884
    rx1258_cur."!cursor_debug"("START", "identifier")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1259_done
    goto rxscan1259_scan
  rxscan1259_loop:
    (rx1258_pos) = rx1258_cur."from"()
    inc rx1258_pos
    rx1258_cur."!cursor_from"(rx1258_pos)
    ge rx1258_pos, rx1258_eos, rxscan1259_done
  rxscan1259_scan:
    set_addr $I10, rxscan1259_loop
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  rxscan1259_done:
.annotate 'line', 498
  # rx subrule "ident" subtype=method negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."ident"()
    unless $P10, rx1258_fail
    rx1258_pos = $P10."pos"()
  # rx rxquantr1260 ** 0..*
    set_addr $I10, rxquantr1260_done
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  rxquantr1260_loop:
  # rx enumcharlist negate=0 
    ge rx1258_pos, rx1258_eos, rx1258_fail
    sub $I10, rx1258_pos, rx1258_off
    substr $S10, rx1258_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx1258_fail
    inc rx1258_pos
  # rx subrule "ident" subtype=method negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."ident"()
    unless $P10, rx1258_fail
    rx1258_pos = $P10."pos"()
    set_addr $I10, rxquantr1260_done
    (rx1258_rep) = rx1258_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1260_done
    rx1258_cur."!mark_push"(rx1258_rep, rx1258_pos, $I10)
    goto rxquantr1260_loop
  rxquantr1260_done:
  # rx pass
    rx1258_cur."!cursor_pass"(rx1258_pos, "identifier")
    if_null rx1258_debug, debug_885
    rx1258_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx1258_pos)
  debug_885:
    .return (rx1258_cur)
  rx1258_restart:
.annotate 'line', 462
    if_null rx1258_debug, debug_886
    rx1258_cur."!cursor_debug"("NEXT", "identifier")
  debug_886:
  rx1258_fail:
    (rx1258_rep, rx1258_pos, $I10, $P10) = rx1258_cur."!mark_fail"(0)
    lt rx1258_pos, -1, rx1258_done
    eq rx1258_pos, -1, rx1258_fail
    jump $I10
  rx1258_done:
    rx1258_cur."!cursor_fail"()
    if_null rx1258_debug, debug_887
    rx1258_cur."!cursor_debug"("FAIL", "identifier")
  debug_887:
    .return (rx1258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("49_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ident", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("50_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1263_tgt
    .local int rx1263_pos
    .local int rx1263_off
    .local int rx1263_eos
    .local int rx1263_rep
    .local pmc rx1263_cur
    .local pmc rx1263_debug
    (rx1263_cur, rx1263_pos, rx1263_tgt, $I10) = self."!cursor_start"()
    rx1263_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx1263_cur
    .local pmc match
    .lex "$/", match
    length rx1263_eos, rx1263_tgt
    gt rx1263_pos, rx1263_eos, rx1263_done
    set rx1263_off, 0
    lt rx1263_pos, 2, rx1263_start
    sub rx1263_off, rx1263_pos, 1
    substr rx1263_tgt, rx1263_tgt, rx1263_off
  rx1263_start:
    eq $I10, 1, rx1263_restart
    if_null rx1263_debug, debug_888
    rx1263_cur."!cursor_debug"("START", "name")
  debug_888:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1264_done
    goto rxscan1264_scan
  rxscan1264_loop:
    (rx1263_pos) = rx1263_cur."from"()
    inc rx1263_pos
    rx1263_cur."!cursor_from"(rx1263_pos)
    ge rx1263_pos, rx1263_eos, rxscan1264_done
  rxscan1264_scan:
    set_addr $I10, rxscan1264_loop
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10)
  rxscan1264_done:
.annotate 'line', 500
  # rx rxquantr1265 ** 1..*
    set_addr $I10, rxquantr1265_done
    rx1263_cur."!mark_push"(0, -1, $I10)
  rxquantr1265_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx1263_cur."!cursor_pos"(rx1263_pos)
    $P10 = rx1263_cur."identifier"()
    unless $P10, rx1263_fail
    goto rxsubrule1266_pass
  rxsubrule1266_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1263_fail
  rxsubrule1266_pass:
    set_addr $I10, rxsubrule1266_back
    rx1263_cur."!mark_push"(0, rx1263_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx1263_pos = $P10."pos"()
    set_addr $I10, rxquantr1265_done
    (rx1263_rep) = rx1263_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1265_done
    rx1263_cur."!mark_push"(rx1263_rep, rx1263_pos, $I10)
  # rx literal  "::"
    add $I11, rx1263_pos, 2
    gt $I11, rx1263_eos, rx1263_fail
    sub $I11, rx1263_pos, rx1263_off
    substr $S10, rx1263_tgt, $I11, 2
    ne $S10, "::", rx1263_fail
    add rx1263_pos, 2
    goto rxquantr1265_loop
  rxquantr1265_done:
  # rx pass
    rx1263_cur."!cursor_pass"(rx1263_pos, "name")
    if_null rx1263_debug, debug_889
    rx1263_cur."!cursor_debug"("PASS", "name", " at pos=", rx1263_pos)
  debug_889:
    .return (rx1263_cur)
  rx1263_restart:
.annotate 'line', 462
    if_null rx1263_debug, debug_890
    rx1263_cur."!cursor_debug"("NEXT", "name")
  debug_890:
  rx1263_fail:
    (rx1263_rep, rx1263_pos, $I10, $P10) = rx1263_cur."!mark_fail"(0)
    lt rx1263_pos, -1, rx1263_done
    eq rx1263_pos, -1, rx1263_fail
    jump $I10
  rx1263_done:
    rx1263_cur."!cursor_fail"()
    if_null rx1263_debug, debug_891
    rx1263_cur."!cursor_debug"("FAIL", "name")
  debug_891:
    .return (rx1263_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("51_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("52_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1269_tgt
    .local int rx1269_pos
    .local int rx1269_off
    .local int rx1269_eos
    .local int rx1269_rep
    .local pmc rx1269_cur
    .local pmc rx1269_debug
    (rx1269_cur, rx1269_pos, rx1269_tgt, $I10) = self."!cursor_start"()
    rx1269_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx1269_cur
    .local pmc match
    .lex "$/", match
    length rx1269_eos, rx1269_tgt
    gt rx1269_pos, rx1269_eos, rx1269_done
    set rx1269_off, 0
    lt rx1269_pos, 2, rx1269_start
    sub rx1269_off, rx1269_pos, 1
    substr rx1269_tgt, rx1269_tgt, rx1269_off
  rx1269_start:
    eq $I10, 1, rx1269_restart
    if_null rx1269_debug, debug_892
    rx1269_cur."!cursor_debug"("START", "deflongname")
  debug_892:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1270_done
    goto rxscan1270_scan
  rxscan1270_loop:
    (rx1269_pos) = rx1269_cur."from"()
    inc rx1269_pos
    rx1269_cur."!cursor_from"(rx1269_pos)
    ge rx1269_pos, rx1269_eos, rxscan1270_done
  rxscan1270_scan:
    set_addr $I10, rxscan1270_loop
    rx1269_cur."!mark_push"(0, rx1269_pos, $I10)
  rxscan1270_done:
.annotate 'line', 503
  # rx subrule "identifier" subtype=capture negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."identifier"()
    unless $P10, rx1269_fail
    rx1269_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1269_pos = $P10."pos"()
  # rx rxquantr1271 ** 0..1
    set_addr $I10, rxquantr1271_done
    rx1269_cur."!mark_push"(0, rx1269_pos, $I10)
  rxquantr1271_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."colonpair"()
    unless $P10, rx1269_fail
    goto rxsubrule1272_pass
  rxsubrule1272_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1269_fail
  rxsubrule1272_pass:
    set_addr $I10, rxsubrule1272_back
    rx1269_cur."!mark_push"(0, rx1269_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx1269_pos = $P10."pos"()
    set_addr $I10, rxquantr1271_done
    (rx1269_rep) = rx1269_cur."!mark_commit"($I10)
  rxquantr1271_done:
.annotate 'line', 502
  # rx pass
    rx1269_cur."!cursor_pass"(rx1269_pos, "deflongname")
    if_null rx1269_debug, debug_893
    rx1269_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx1269_pos)
  debug_893:
    .return (rx1269_cur)
  rx1269_restart:
.annotate 'line', 462
    if_null rx1269_debug, debug_894
    rx1269_cur."!cursor_debug"("NEXT", "deflongname")
  debug_894:
  rx1269_fail:
    (rx1269_rep, rx1269_pos, $I10, $P10) = rx1269_cur."!mark_fail"(0)
    lt rx1269_pos, -1, rx1269_done
    eq rx1269_pos, -1, rx1269_fail
    jump $I10
  rx1269_done:
    rx1269_cur."!cursor_fail"()
    if_null rx1269_debug, debug_895
    rx1269_cur."!cursor_debug"("FAIL", "deflongname")
  debug_895:
    .return (rx1269_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("53_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("54_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1275_tgt
    .local int rx1275_pos
    .local int rx1275_off
    .local int rx1275_eos
    .local int rx1275_rep
    .local pmc rx1275_cur
    .local pmc rx1275_debug
    (rx1275_cur, rx1275_pos, rx1275_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1275_cur
    .local pmc match
    .lex "$/", match
    length rx1275_eos, rx1275_tgt
    gt rx1275_pos, rx1275_eos, rx1275_done
    set rx1275_off, 0
    lt rx1275_pos, 2, rx1275_start
    sub rx1275_off, rx1275_pos, 1
    substr rx1275_tgt, rx1275_tgt, rx1275_off
  rx1275_start:
    eq $I10, 1, rx1275_restart
    if_null rx1275_debug, debug_896
    rx1275_cur."!cursor_debug"("START", "ENDSTMT")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1276_done
    goto rxscan1276_scan
  rxscan1276_loop:
    (rx1275_pos) = rx1275_cur."from"()
    inc rx1275_pos
    rx1275_cur."!cursor_from"(rx1275_pos)
    ge rx1275_pos, rx1275_eos, rxscan1276_done
  rxscan1276_scan:
    set_addr $I10, rxscan1276_loop
    rx1275_cur."!mark_push"(0, rx1275_pos, $I10)
  rxscan1276_done:
.annotate 'line', 510
  # rx rxquantr1277 ** 0..1
    set_addr $I10, rxquantr1277_done
    rx1275_cur."!mark_push"(0, rx1275_pos, $I10)
  rxquantr1277_loop:
  alt1278_0:
.annotate 'line', 507
    set_addr $I10, alt1278_1
    rx1275_cur."!mark_push"(0, rx1275_pos, $I10)
.annotate 'line', 508
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1275_pos, rx1275_off
    set rx1275_rep, 0
    sub $I12, rx1275_eos, rx1275_pos
  rxenumcharlistq1279_loop:
    le $I12, 0, rxenumcharlistq1279_done
    substr $S10, rx1275_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1279_done
    inc rx1275_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1279_loop
  rxenumcharlistq1279_done:
    add rx1275_pos, rx1275_pos, rx1275_rep
  # rxanchor eol
    sub $I10, rx1275_pos, rx1275_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1275_tgt, $I10
    if $I11, rxanchor1280_done
    ne rx1275_pos, rx1275_eos, rx1275_fail
    eq rx1275_pos, 0, rxanchor1280_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1275_tgt, $I10
    if $I11, rx1275_fail
  rxanchor1280_done:
  # rx subrule "ws" subtype=method negate=
    rx1275_cur."!cursor_pos"(rx1275_pos)
    $P10 = rx1275_cur."ws"()
    unless $P10, rx1275_fail
    rx1275_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1275_cur."!cursor_pos"(rx1275_pos)
    $P10 = rx1275_cur."MARKER"("endstmt")
    unless $P10, rx1275_fail
    goto alt1278_end
  alt1278_1:
.annotate 'line', 509
  # rx rxquantr1281 ** 0..1
    set_addr $I10, rxquantr1281_done
    rx1275_cur."!mark_push"(0, rx1275_pos, $I10)
  rxquantr1281_loop:
  # rx subrule "unv" subtype=method negate=
    rx1275_cur."!cursor_pos"(rx1275_pos)
    $P10 = rx1275_cur."unv"()
    unless $P10, rx1275_fail
    goto rxsubrule1282_pass
  rxsubrule1282_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1275_fail
  rxsubrule1282_pass:
    set_addr $I10, rxsubrule1282_back
    rx1275_cur."!mark_push"(0, rx1275_pos, $I10, $P10)
    rx1275_pos = $P10."pos"()
    set_addr $I10, rxquantr1281_done
    (rx1275_rep) = rx1275_cur."!mark_commit"($I10)
  rxquantr1281_done:
  # rxanchor eol
    sub $I10, rx1275_pos, rx1275_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1275_tgt, $I10
    if $I11, rxanchor1283_done
    ne rx1275_pos, rx1275_eos, rx1275_fail
    eq rx1275_pos, 0, rxanchor1283_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1275_tgt, $I10
    if $I11, rx1275_fail
  rxanchor1283_done:
  # rx subrule "ws" subtype=method negate=
    rx1275_cur."!cursor_pos"(rx1275_pos)
    $P10 = rx1275_cur."ws"()
    unless $P10, rx1275_fail
    rx1275_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1275_cur."!cursor_pos"(rx1275_pos)
    $P10 = rx1275_cur."MARKER"("endstmt")
    unless $P10, rx1275_fail
  alt1278_end:
.annotate 'line', 510
    set_addr $I10, rxquantr1277_done
    (rx1275_rep) = rx1275_cur."!mark_commit"($I10)
  rxquantr1277_done:
.annotate 'line', 506
  # rx pass
    rx1275_cur."!cursor_pass"(rx1275_pos, "ENDSTMT")
    if_null rx1275_debug, debug_897
    rx1275_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx1275_pos)
  debug_897:
    .return (rx1275_cur)
  rx1275_restart:
.annotate 'line', 462
    if_null rx1275_debug, debug_898
    rx1275_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_898:
  rx1275_fail:
    (rx1275_rep, rx1275_pos, $I10, $P10) = rx1275_cur."!mark_fail"(0)
    lt rx1275_pos, -1, rx1275_done
    eq rx1275_pos, -1, rx1275_fail
    jump $I10
  rx1275_done:
    rx1275_cur."!cursor_fail"()
    if_null rx1275_debug, debug_899
    rx1275_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_899:
    .return (rx1275_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("55_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("56_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1286_tgt
    .local int rx1286_pos
    .local int rx1286_off
    .local int rx1286_eos
    .local int rx1286_rep
    .local pmc rx1286_cur
    .local pmc rx1286_debug
    (rx1286_cur, rx1286_pos, rx1286_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1286_cur
    .local pmc match
    .lex "$/", match
    length rx1286_eos, rx1286_tgt
    gt rx1286_pos, rx1286_eos, rx1286_done
    set rx1286_off, 0
    lt rx1286_pos, 2, rx1286_start
    sub rx1286_off, rx1286_pos, 1
    substr rx1286_tgt, rx1286_tgt, rx1286_off
  rx1286_start:
    eq $I10, 1, rx1286_restart
    if_null rx1286_debug, debug_900
    rx1286_cur."!cursor_debug"("START", "ws")
  debug_900:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1287_done
    goto rxscan1287_scan
  rxscan1287_loop:
    (rx1286_pos) = rx1286_cur."from"()
    inc rx1286_pos
    rx1286_cur."!cursor_from"(rx1286_pos)
    ge rx1286_pos, rx1286_eos, rxscan1287_done
  rxscan1287_scan:
    set_addr $I10, rxscan1287_loop
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  rxscan1287_done:
  alt1288_0:
.annotate 'line', 513
    set_addr $I10, alt1288_1
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
.annotate 'line', 514
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."MARKED"("ws")
    unless $P10, rx1286_fail
    goto alt1288_end
  alt1288_1:
.annotate 'line', 515
  # rx subrule "ww" subtype=zerowidth negate=1
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."ww"()
    if $P10, rx1286_fail
.annotate 'line', 520
  # rx rxquantr1289 ** 0..*
    set_addr $I10, rxquantr1289_done
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  rxquantr1289_loop:
  alt1290_0:
.annotate 'line', 516
    set_addr $I10, alt1290_1
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1286_pos, rx1286_off
    set rx1286_rep, 0
    sub $I12, rx1286_eos, rx1286_pos
  rxenumcharlistq1291_loop:
    le $I12, 0, rxenumcharlistq1291_done
    substr $S10, rx1286_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq1291_done
    inc rx1286_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1291_loop
  rxenumcharlistq1291_done:
    lt rx1286_rep, 1, rx1286_fail
    add rx1286_pos, rx1286_pos, rx1286_rep
    goto alt1290_end
  alt1290_1:
    set_addr $I10, alt1290_2
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
.annotate 'line', 517
  # rx literal  "#"
    add $I11, rx1286_pos, 1
    gt $I11, rx1286_eos, rx1286_fail
    sub $I11, rx1286_pos, rx1286_off
    ord $I11, rx1286_tgt, $I11
    ne $I11, 35, rx1286_fail
    add rx1286_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1286_pos, rx1286_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1286_tgt, $I10, rx1286_eos
    add rx1286_pos, rx1286_off, $I11
    goto alt1290_end
  alt1290_2:
    set_addr $I10, alt1290_3
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
.annotate 'line', 518
  # rxanchor bol
    eq rx1286_pos, 0, rxanchor1292_done
    ge rx1286_pos, rx1286_eos, rx1286_fail
    sub $I10, rx1286_pos, rx1286_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1286_tgt, $I10
    unless $I11, rx1286_fail
  rxanchor1292_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."pod_comment"()
    unless $P10, rx1286_fail
    rx1286_pos = $P10."pos"()
    goto alt1290_end
  alt1290_3:
.annotate 'line', 519
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1286_pos, rx1286_off
    set rx1286_rep, 0
    sub $I12, rx1286_eos, rx1286_pos
  rxenumcharlistq1293_loop:
    le $I12, 0, rxenumcharlistq1293_done
    substr $S10, rx1286_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1293_done
    inc rx1286_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1293_loop
  rxenumcharlistq1293_done:
    lt rx1286_rep, 1, rx1286_fail
    add rx1286_pos, rx1286_pos, rx1286_rep
  alt1290_end:
.annotate 'line', 520
    set_addr $I10, rxquantr1289_done
    (rx1286_rep) = rx1286_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1289_done
    rx1286_cur."!mark_push"(rx1286_rep, rx1286_pos, $I10)
    goto rxquantr1289_loop
  rxquantr1289_done:
.annotate 'line', 521
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."MARKER"("ws")
    unless $P10, rx1286_fail
  alt1288_end:
.annotate 'line', 513
  # rx pass
    rx1286_cur."!cursor_pass"(rx1286_pos, "ws")
    if_null rx1286_debug, debug_901
    rx1286_cur."!cursor_debug"("PASS", "ws", " at pos=", rx1286_pos)
  debug_901:
    .return (rx1286_cur)
  rx1286_restart:
.annotate 'line', 462
    if_null rx1286_debug, debug_902
    rx1286_cur."!cursor_debug"("NEXT", "ws")
  debug_902:
  rx1286_fail:
    (rx1286_rep, rx1286_pos, $I10, $P10) = rx1286_cur."!mark_fail"(0)
    lt rx1286_pos, -1, rx1286_done
    eq rx1286_pos, -1, rx1286_fail
    jump $I10
  rx1286_done:
    rx1286_cur."!cursor_fail"()
    if_null rx1286_debug, debug_903
    rx1286_cur."!cursor_debug"("FAIL", "ws")
  debug_903:
    .return (rx1286_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("57_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("58_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1301 = "59_1325892461.451" 
    capture_lex $P1301
    .local string rx1296_tgt
    .local int rx1296_pos
    .local int rx1296_off
    .local int rx1296_eos
    .local int rx1296_rep
    .local pmc rx1296_cur
    .local pmc rx1296_debug
    (rx1296_cur, rx1296_pos, rx1296_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1296_cur
    .local pmc match
    .lex "$/", match
    length rx1296_eos, rx1296_tgt
    gt rx1296_pos, rx1296_eos, rx1296_done
    set rx1296_off, 0
    lt rx1296_pos, 2, rx1296_start
    sub rx1296_off, rx1296_pos, 1
    substr rx1296_tgt, rx1296_tgt, rx1296_off
  rx1296_start:
    eq $I10, 1, rx1296_restart
    if_null rx1296_debug, debug_904
    rx1296_cur."!cursor_debug"("START", "unv")
  debug_904:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1297_done
    goto rxscan1297_scan
  rxscan1297_loop:
    (rx1296_pos) = rx1296_cur."from"()
    inc rx1296_pos
    rx1296_cur."!cursor_from"(rx1296_pos)
    ge rx1296_pos, rx1296_eos, rxscan1297_done
  rxscan1297_scan:
    set_addr $I10, rxscan1297_loop
    rx1296_cur."!mark_push"(0, rx1296_pos, $I10)
  rxscan1297_done:
  alt1298_0:
.annotate 'line', 526
    set_addr $I10, alt1298_1
    rx1296_cur."!mark_push"(0, rx1296_pos, $I10)
.annotate 'line', 527
  # rxanchor bol
    eq rx1296_pos, 0, rxanchor1299_done
    ge rx1296_pos, rx1296_eos, rx1296_fail
    sub $I10, rx1296_pos, rx1296_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1296_tgt, $I10
    unless $I11, rx1296_fail
  rxanchor1299_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1296_cur."!cursor_pos"(rx1296_pos)
    .const 'Sub' $P1301 = "59_1325892461.451" 
    capture_lex $P1301
    $P10 = rx1296_cur."before"($P1301)
    unless $P10, rx1296_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx1296_cur."!cursor_pos"(rx1296_pos)
    $P10 = rx1296_cur."pod_comment"()
    unless $P10, rx1296_fail
    rx1296_pos = $P10."pos"()
    goto alt1298_end
  alt1298_1:
    set_addr $I10, alt1298_2
    rx1296_cur."!mark_push"(0, rx1296_pos, $I10)
.annotate 'line', 528
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1296_pos, rx1296_off
    set rx1296_rep, 0
    sub $I12, rx1296_eos, rx1296_pos
  rxenumcharlistq1306_loop:
    le $I12, 0, rxenumcharlistq1306_done
    substr $S10, rx1296_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1306_done
    inc rx1296_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1306_loop
  rxenumcharlistq1306_done:
    add rx1296_pos, rx1296_pos, rx1296_rep
  # rx literal  "#"
    add $I11, rx1296_pos, 1
    gt $I11, rx1296_eos, rx1296_fail
    sub $I11, rx1296_pos, rx1296_off
    ord $I11, rx1296_tgt, $I11
    ne $I11, 35, rx1296_fail
    add rx1296_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx1296_pos, rx1296_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1296_tgt, $I10, rx1296_eos
    add rx1296_pos, rx1296_off, $I11
    goto alt1298_end
  alt1298_2:
.annotate 'line', 529
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1296_pos, rx1296_off
    set rx1296_rep, 0
    sub $I12, rx1296_eos, rx1296_pos
  rxenumcharlistq1307_loop:
    le $I12, 0, rxenumcharlistq1307_done
    substr $S10, rx1296_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1307_done
    inc rx1296_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1307_loop
  rxenumcharlistq1307_done:
    lt rx1296_rep, 1, rx1296_fail
    add rx1296_pos, rx1296_pos, rx1296_rep
  alt1298_end:
.annotate 'line', 524
  # rx pass
    rx1296_cur."!cursor_pass"(rx1296_pos, "unv")
    if_null rx1296_debug, debug_909
    rx1296_cur."!cursor_debug"("PASS", "unv", " at pos=", rx1296_pos)
  debug_909:
    .return (rx1296_cur)
  rx1296_restart:
.annotate 'line', 462
    if_null rx1296_debug, debug_910
    rx1296_cur."!cursor_debug"("NEXT", "unv")
  debug_910:
  rx1296_fail:
    (rx1296_rep, rx1296_pos, $I10, $P10) = rx1296_cur."!mark_fail"(0)
    lt rx1296_pos, -1, rx1296_done
    eq rx1296_pos, -1, rx1296_fail
    jump $I10
  rx1296_done:
    rx1296_cur."!cursor_fail"()
    if_null rx1296_debug, debug_911
    rx1296_cur."!cursor_debug"("FAIL", "unv")
  debug_911:
    .return (rx1296_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1300"  :anon :subid("59_1325892461.451") :method :outer("58_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 527
    .local string rx1302_tgt
    .local int rx1302_pos
    .local int rx1302_off
    .local int rx1302_eos
    .local int rx1302_rep
    .local pmc rx1302_cur
    .local pmc rx1302_debug
    (rx1302_cur, rx1302_pos, rx1302_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1302_cur
    .local pmc match
    .lex "$/", match
    length rx1302_eos, rx1302_tgt
    gt rx1302_pos, rx1302_eos, rx1302_done
    set rx1302_off, 0
    lt rx1302_pos, 2, rx1302_start
    sub rx1302_off, rx1302_pos, 1
    substr rx1302_tgt, rx1302_tgt, rx1302_off
  rx1302_start:
    eq $I10, 1, rx1302_restart
    if_null rx1302_debug, debug_905
    rx1302_cur."!cursor_debug"("START", "")
  debug_905:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1303_done
    goto rxscan1303_scan
  rxscan1303_loop:
    (rx1302_pos) = rx1302_cur."from"()
    inc rx1302_pos
    rx1302_cur."!cursor_from"(rx1302_pos)
    ge rx1302_pos, rx1302_eos, rxscan1303_done
  rxscan1303_scan:
    set_addr $I10, rxscan1303_loop
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxscan1303_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1302_pos, rx1302_off
    set rx1302_rep, 0
    sub $I12, rx1302_eos, rx1302_pos
  rxenumcharlistq1304_loop:
    le $I12, 0, rxenumcharlistq1304_done
    substr $S10, rx1302_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1304_done
    inc rx1302_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1304_loop
  rxenumcharlistq1304_done:
    add rx1302_pos, rx1302_pos, rx1302_rep
  # rx literal  "="
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 61, rx1302_fail
    add rx1302_pos, 1
  alt1305_0:
    set_addr $I10, alt1305_1
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx charclass w
    ge rx1302_pos, rx1302_eos, rx1302_fail
    sub $I10, rx1302_pos, rx1302_off
    is_cclass $I11, .CCLASS_WORD, rx1302_tgt, $I10
    unless $I11, rx1302_fail
    inc rx1302_pos
    goto alt1305_end
  alt1305_1:
  # rx literal  "\\"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 92, rx1302_fail
    add rx1302_pos, 1
  alt1305_end:
  # rx pass
    rx1302_cur."!cursor_pass"(rx1302_pos, "")
    if_null rx1302_debug, debug_906
    rx1302_cur."!cursor_debug"("PASS", "", " at pos=", rx1302_pos)
  debug_906:
    .return (rx1302_cur)
  rx1302_restart:
    if_null rx1302_debug, debug_907
    rx1302_cur."!cursor_debug"("NEXT", "")
  debug_907:
  rx1302_fail:
    (rx1302_rep, rx1302_pos, $I10, $P10) = rx1302_cur."!mark_fail"(0)
    lt rx1302_pos, -1, rx1302_done
    eq rx1302_pos, -1, rx1302_fail
    jump $I10
  rx1302_done:
    rx1302_cur."!cursor_fail"()
    if_null rx1302_debug, debug_908
    rx1302_cur."!cursor_debug"("FAIL", "")
  debug_908:
    .return (rx1302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("60_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("61_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1338 = "62_1325892461.451" 
    capture_lex $P1338
    .local string rx1310_tgt
    .local int rx1310_pos
    .local int rx1310_off
    .local int rx1310_eos
    .local int rx1310_rep
    .local pmc rx1310_cur
    .local pmc rx1310_debug
    (rx1310_cur, rx1310_pos, rx1310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1310_cur
    .local pmc match
    .lex "$/", match
    length rx1310_eos, rx1310_tgt
    gt rx1310_pos, rx1310_eos, rx1310_done
    set rx1310_off, 0
    lt rx1310_pos, 2, rx1310_start
    sub rx1310_off, rx1310_pos, 1
    substr rx1310_tgt, rx1310_tgt, rx1310_off
  rx1310_start:
    eq $I10, 1, rx1310_restart
    if_null rx1310_debug, debug_912
    rx1310_cur."!cursor_debug"("START", "pod_comment")
  debug_912:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1311_done
    goto rxscan1311_scan
  rxscan1311_loop:
    (rx1310_pos) = rx1310_cur."from"()
    inc rx1310_pos
    rx1310_cur."!cursor_from"(rx1310_pos)
    ge rx1310_pos, rx1310_eos, rxscan1311_done
  rxscan1311_scan:
    set_addr $I10, rxscan1311_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  rxscan1311_done:
.annotate 'line', 534
  # rxanchor bol
    eq rx1310_pos, 0, rxanchor1312_done
    ge rx1310_pos, rx1310_eos, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10
    unless $I11, rx1310_fail
  rxanchor1312_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1310_pos, rx1310_off
    set rx1310_rep, 0
    sub $I12, rx1310_eos, rx1310_pos
  rxenumcharlistq1313_loop:
    le $I12, 0, rxenumcharlistq1313_done
    substr $S10, rx1310_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1313_done
    inc rx1310_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1313_loop
  rxenumcharlistq1313_done:
    add rx1310_pos, rx1310_pos, rx1310_rep
  # rx literal  "="
    add $I11, rx1310_pos, 1
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    ord $I11, rx1310_tgt, $I11
    ne $I11, 61, rx1310_fail
    add rx1310_pos, 1
  alt1314_0:
.annotate 'line', 535
    set_addr $I10, alt1314_1
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
.annotate 'line', 536
  # rx literal  "begin"
    add $I11, rx1310_pos, 5
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    substr $S10, rx1310_tgt, $I11, 5
    ne $S10, "begin", rx1310_fail
    add rx1310_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1310_pos, rx1310_off
    set rx1310_rep, 0
    sub $I12, rx1310_eos, rx1310_pos
  rxenumcharlistq1315_loop:
    le $I12, 0, rxenumcharlistq1315_done
    substr $S10, rx1310_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1315_done
    inc rx1310_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1315_loop
  rxenumcharlistq1315_done:
    lt rx1310_rep, 1, rx1310_fail
    add rx1310_pos, rx1310_pos, rx1310_rep
  # rx literal  "END"
    add $I11, rx1310_pos, 3
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    substr $S10, rx1310_tgt, $I11, 3
    ne $S10, "END", rx1310_fail
    add rx1310_pos, 3
  # rxanchor rwb
    le rx1310_pos, 0, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, .CCLASS_WORD, rx1310_tgt, $I10
    if $I11, rx1310_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1310_tgt, $I10
    unless $I11, rx1310_fail
  alt1316_0:
.annotate 'line', 537
    set_addr $I10, alt1316_1
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  # rx rxquantf1317 ** 0..*
    set_addr $I10, rxquantf1317_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
    goto rxquantf1317_done
  rxquantf1317_loop:
  # rx charclass .
    ge rx1310_pos, rx1310_eos, rx1310_fail
    inc rx1310_pos
    set_addr $I10, rxquantf1317_loop
    rx1310_cur."!mark_push"(rx1310_rep, rx1310_pos, $I10)
  rxquantf1317_done:
  # rx charclass nl
    ge rx1310_pos, rx1310_eos, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10
    unless $I11, rx1310_fail
    substr $S10, rx1310_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1310_pos, $I11
    inc rx1310_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1310_pos, rx1310_off
    set rx1310_rep, 0
    sub $I12, rx1310_eos, rx1310_pos
  rxenumcharlistq1319_loop:
    le $I12, 0, rxenumcharlistq1319_done
    substr $S10, rx1310_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1319_done
    inc rx1310_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1319_loop
  rxenumcharlistq1319_done:
    add rx1310_pos, rx1310_pos, rx1310_rep
  # rx literal  "=end"
    add $I11, rx1310_pos, 4
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    substr $S10, rx1310_tgt, $I11, 4
    ne $S10, "=end", rx1310_fail
    add rx1310_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1310_pos, rx1310_off
    set rx1310_rep, 0
    sub $I12, rx1310_eos, rx1310_pos
  rxenumcharlistq1320_loop:
    le $I12, 0, rxenumcharlistq1320_done
    substr $S10, rx1310_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1320_done
    inc rx1310_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1320_loop
  rxenumcharlistq1320_done:
    lt rx1310_rep, 1, rx1310_fail
    add rx1310_pos, rx1310_pos, rx1310_rep
  # rx literal  "END"
    add $I11, rx1310_pos, 3
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    substr $S10, rx1310_tgt, $I11, 3
    ne $S10, "END", rx1310_fail
    add rx1310_pos, 3
  # rxanchor rwb
    le rx1310_pos, 0, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, .CCLASS_WORD, rx1310_tgt, $I10
    if $I11, rx1310_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1310_tgt, $I10
    unless $I11, rx1310_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1310_pos, rx1310_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10, rx1310_eos
    add rx1310_pos, rx1310_off, $I11
    goto alt1316_end
  alt1316_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx1310_pos, rx1310_off
    find_not_cclass $I11, .CCLASS_ANY, rx1310_tgt, $I10, rx1310_eos
    add rx1310_pos, rx1310_off, $I11
  alt1316_end:
.annotate 'line', 536
    goto alt1314_end
  alt1314_1:
    set_addr $I10, alt1314_2
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
.annotate 'line', 538
  # rx literal  "begin"
    add $I11, rx1310_pos, 5
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    substr $S10, rx1310_tgt, $I11, 5
    ne $S10, "begin", rx1310_fail
    add rx1310_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1310_pos, rx1310_off
    set rx1310_rep, 0
    sub $I12, rx1310_eos, rx1310_pos
  rxenumcharlistq1321_loop:
    le $I12, 0, rxenumcharlistq1321_done
    substr $S10, rx1310_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1321_done
    inc rx1310_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1321_loop
  rxenumcharlistq1321_done:
    lt rx1310_rep, 1, rx1310_fail
    add rx1310_pos, rx1310_pos, rx1310_rep
  # rx subrule "identifier" subtype=capture negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."identifier"()
    unless $P10, rx1310_fail
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1310_pos = $P10."pos"()
  alt1322_0:
.annotate 'line', 539
    set_addr $I10, alt1322_1
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
.annotate 'line', 540
  # rx rxquantf1323 ** 0..*
    set_addr $I10, rxquantf1323_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
    goto rxquantf1323_done
  rxquantf1323_loop:
  # rx charclass .
    ge rx1310_pos, rx1310_eos, rx1310_fail
    inc rx1310_pos
    set_addr $I10, rxquantf1323_loop
    rx1310_cur."!mark_push"(rx1310_rep, rx1310_pos, $I10)
  rxquantf1323_done:
  # rx charclass nl
    ge rx1310_pos, rx1310_eos, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10
    unless $I11, rx1310_fail
    substr $S10, rx1310_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1310_pos, $I11
    inc rx1310_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1310_pos, rx1310_off
    set rx1310_rep, 0
    sub $I12, rx1310_eos, rx1310_pos
  rxenumcharlistq1325_loop:
    le $I12, 0, rxenumcharlistq1325_done
    substr $S10, rx1310_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1325_done
    inc rx1310_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1325_loop
  rxenumcharlistq1325_done:
    add rx1310_pos, rx1310_pos, rx1310_rep
  # rx literal  "=end"
    add $I11, rx1310_pos, 4
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    substr $S10, rx1310_tgt, $I11, 4
    ne $S10, "=end", rx1310_fail
    add rx1310_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx1310_pos, rx1310_off
    set rx1310_rep, 0
    sub $I12, rx1310_eos, rx1310_pos
  rxenumcharlistq1326_loop:
    le $I12, 0, rxenumcharlistq1326_done
    substr $S10, rx1310_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1326_done
    inc rx1310_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1326_loop
  rxenumcharlistq1326_done:
    lt rx1310_rep, 1, rx1310_fail
    add rx1310_pos, rx1310_pos, rx1310_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."!BACKREF"("identifier")
    unless $P10, rx1310_fail
    rx1310_pos = $P10."pos"()
  # rxanchor rwb
    le rx1310_pos, 0, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, .CCLASS_WORD, rx1310_tgt, $I10
    if $I11, rx1310_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1310_tgt, $I10
    unless $I11, rx1310_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1310_pos, rx1310_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10, rx1310_eos
    add rx1310_pos, rx1310_off, $I11
    goto alt1322_end
  alt1322_1:
.annotate 'line', 541
  # rx subrule "panic" subtype=method negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."panic"("=begin without matching =end")
    unless $P10, rx1310_fail
    rx1310_pos = $P10."pos"()
  alt1322_end:
.annotate 'line', 538
    goto alt1314_end
  alt1314_2:
    set_addr $I10, alt1314_3
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
.annotate 'line', 543
  # rx literal  "begin"
    add $I11, rx1310_pos, 5
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    substr $S10, rx1310_tgt, $I11, 5
    ne $S10, "begin", rx1310_fail
    add rx1310_pos, 5
  # rxanchor rwb
    le rx1310_pos, 0, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, .CCLASS_WORD, rx1310_tgt, $I10
    if $I11, rx1310_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1310_tgt, $I10
    unless $I11, rx1310_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1310_pos, rx1310_off
    set rx1310_rep, 0
    sub $I12, rx1310_eos, rx1310_pos
  rxenumcharlistq1327_loop:
    le $I12, 0, rxenumcharlistq1327_done
    substr $S10, rx1310_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1327_done
    inc rx1310_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1327_loop
  rxenumcharlistq1327_done:
    add rx1310_pos, rx1310_pos, rx1310_rep
  alt1328_0:
.annotate 'line', 544
    set_addr $I10, alt1328_1
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  # rxanchor eol
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10
    if $I11, rxanchor1329_done
    ne rx1310_pos, rx1310_eos, rx1310_fail
    eq rx1310_pos, 0, rxanchor1329_done
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10
    if $I11, rx1310_fail
  rxanchor1329_done:
    goto alt1328_end
  alt1328_1:
    set_addr $I10, alt1328_2
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  # rx literal  "#"
    add $I11, rx1310_pos, 1
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    ord $I11, rx1310_tgt, $I11
    ne $I11, 35, rx1310_fail
    add rx1310_pos, 1
    goto alt1328_end
  alt1328_2:
  # rx subrule "panic" subtype=method negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx1310_fail
    rx1310_pos = $P10."pos"()
  alt1328_end:
  alt1330_0:
.annotate 'line', 545
    set_addr $I10, alt1330_1
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
.annotate 'line', 546
  # rx rxquantf1331 ** 0..*
    set_addr $I10, rxquantf1331_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
    goto rxquantf1331_done
  rxquantf1331_loop:
  # rx charclass .
    ge rx1310_pos, rx1310_eos, rx1310_fail
    inc rx1310_pos
    set_addr $I10, rxquantf1331_loop
    rx1310_cur."!mark_push"(rx1310_rep, rx1310_pos, $I10)
  rxquantf1331_done:
  # rx charclass nl
    ge rx1310_pos, rx1310_eos, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10
    unless $I11, rx1310_fail
    substr $S10, rx1310_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1310_pos, $I11
    inc rx1310_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1310_pos, rx1310_off
    set rx1310_rep, 0
    sub $I12, rx1310_eos, rx1310_pos
  rxenumcharlistq1333_loop:
    le $I12, 0, rxenumcharlistq1333_done
    substr $S10, rx1310_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1333_done
    inc rx1310_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1333_loop
  rxenumcharlistq1333_done:
    add rx1310_pos, rx1310_pos, rx1310_rep
  # rx literal  "=end"
    add $I11, rx1310_pos, 4
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    substr $S10, rx1310_tgt, $I11, 4
    ne $S10, "=end", rx1310_fail
    add rx1310_pos, 4
  # rxanchor rwb
    le rx1310_pos, 0, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, .CCLASS_WORD, rx1310_tgt, $I10
    if $I11, rx1310_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1310_tgt, $I10
    unless $I11, rx1310_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx1310_pos, rx1310_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10, rx1310_eos
    add rx1310_pos, rx1310_off, $I11
    goto alt1330_end
  alt1330_1:
.annotate 'line', 547
  # rx subrule "panic" subtype=method negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."panic"("=begin without matching =end")
    unless $P10, rx1310_fail
    rx1310_pos = $P10."pos"()
  alt1330_end:
.annotate 'line', 543
    goto alt1314_end
  alt1314_3:
    set_addr $I10, alt1314_4
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
.annotate 'line', 549
  # rx subrule "identifier" subtype=capture negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."identifier"()
    unless $P10, rx1310_fail
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1310_pos = $P10."pos"()
.annotate 'line', 550
  # rx rxquantf1334 ** 0..*
    set_addr $I10, rxquantf1334_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
    goto rxquantf1334_done
  rxquantf1334_loop:
  # rx charclass .
    ge rx1310_pos, rx1310_eos, rx1310_fail
    inc rx1310_pos
    set_addr $I10, rxquantf1334_loop
    rx1310_cur."!mark_push"(rx1310_rep, rx1310_pos, $I10)
  rxquantf1334_done:
  # rxanchor bol
    eq rx1310_pos, 0, rxanchor1336_done
    ge rx1310_pos, rx1310_eos, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    dec $I10
    is_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10
    unless $I11, rx1310_fail
  rxanchor1336_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    .const 'Sub' $P1338 = "62_1325892461.451" 
    capture_lex $P1338
    $P10 = rx1310_cur."before"($P1338)
    unless $P10, rx1310_fail
.annotate 'line', 549
    goto alt1314_end
  alt1314_4:
  alt1344_0:
.annotate 'line', 556
    set_addr $I10, alt1344_1
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  # rx charclass s
    ge rx1310_pos, rx1310_eos, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1310_tgt, $I10
    unless $I11, rx1310_fail
    inc rx1310_pos
    goto alt1344_end
  alt1344_1:
  # rx subrule "panic" subtype=method negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."panic"("Illegal pod directive")
    unless $P10, rx1310_fail
    rx1310_pos = $P10."pos"()
  alt1344_end:
.annotate 'line', 557
  # rx charclass_q N r 0..-1
    sub $I10, rx1310_pos, rx1310_off
    find_cclass $I11, .CCLASS_NEWLINE, rx1310_tgt, $I10, rx1310_eos
    add rx1310_pos, rx1310_off, $I11
  alt1314_end:
.annotate 'line', 533
  # rx pass
    rx1310_cur."!cursor_pass"(rx1310_pos, "pod_comment")
    if_null rx1310_debug, debug_917
    rx1310_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx1310_pos)
  debug_917:
    .return (rx1310_cur)
  rx1310_restart:
.annotate 'line', 462
    if_null rx1310_debug, debug_918
    rx1310_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_918:
  rx1310_fail:
    (rx1310_rep, rx1310_pos, $I10, $P10) = rx1310_cur."!mark_fail"(0)
    lt rx1310_pos, -1, rx1310_done
    eq rx1310_pos, -1, rx1310_fail
    jump $I10
  rx1310_done:
    rx1310_cur."!cursor_fail"()
    if_null rx1310_debug, debug_919
    rx1310_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_919:
    .return (rx1310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1337"  :anon :subid("62_1325892461.451") :method :outer("61_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 550
    .local string rx1339_tgt
    .local int rx1339_pos
    .local int rx1339_off
    .local int rx1339_eos
    .local int rx1339_rep
    .local pmc rx1339_cur
    .local pmc rx1339_debug
    (rx1339_cur, rx1339_pos, rx1339_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1339_cur
    .local pmc match
    .lex "$/", match
    length rx1339_eos, rx1339_tgt
    gt rx1339_pos, rx1339_eos, rx1339_done
    set rx1339_off, 0
    lt rx1339_pos, 2, rx1339_start
    sub rx1339_off, rx1339_pos, 1
    substr rx1339_tgt, rx1339_tgt, rx1339_off
  rx1339_start:
    eq $I10, 1, rx1339_restart
    if_null rx1339_debug, debug_913
    rx1339_cur."!cursor_debug"("START", "")
  debug_913:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1340_done
    goto rxscan1340_scan
  rxscan1340_loop:
    (rx1339_pos) = rx1339_cur."from"()
    inc rx1339_pos
    rx1339_cur."!cursor_from"(rx1339_pos)
    ge rx1339_pos, rx1339_eos, rxscan1340_done
  rxscan1340_scan:
    set_addr $I10, rxscan1340_loop
    rx1339_cur."!mark_push"(0, rx1339_pos, $I10)
  rxscan1340_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1339_pos, rx1339_off
    set rx1339_rep, 0
    sub $I12, rx1339_eos, rx1339_pos
  rxenumcharlistq1341_loop:
    le $I12, 0, rxenumcharlistq1341_done
    substr $S10, rx1339_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1341_done
    inc rx1339_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1341_loop
  rxenumcharlistq1341_done:
    add rx1339_pos, rx1339_pos, rx1339_rep
  alt1342_0:
    set_addr $I10, alt1342_1
    rx1339_cur."!mark_push"(0, rx1339_pos, $I10)
.annotate 'line', 551
  # rx literal  "="
    add $I11, rx1339_pos, 1
    gt $I11, rx1339_eos, rx1339_fail
    sub $I11, rx1339_pos, rx1339_off
    ord $I11, rx1339_tgt, $I11
    ne $I11, 61, rx1339_fail
    add rx1339_pos, 1
.annotate 'line', 553
  # rx rxquantr1343 ** 0..1
    set_addr $I10, rxquantr1343_done
    rx1339_cur."!mark_push"(0, rx1339_pos, $I10)
  rxquantr1343_loop:
.annotate 'line', 552
  # rx literal  "cut"
    add $I11, rx1339_pos, 3
    gt $I11, rx1339_eos, rx1339_fail
    sub $I11, rx1339_pos, rx1339_off
    substr $S10, rx1339_tgt, $I11, 3
    ne $S10, "cut", rx1339_fail
    add rx1339_pos, 3
  # rxanchor rwb
    le rx1339_pos, 0, rx1339_fail
    sub $I10, rx1339_pos, rx1339_off
    is_cclass $I11, .CCLASS_WORD, rx1339_tgt, $I10
    if $I11, rx1339_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1339_tgt, $I10
    unless $I11, rx1339_fail
.annotate 'line', 553
  # rx subrule "panic" subtype=method negate=
    rx1339_cur."!cursor_pos"(rx1339_pos)
    $P10 = rx1339_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx1339_fail
    rx1339_pos = $P10."pos"()
    set_addr $I10, rxquantr1343_done
    (rx1339_rep) = rx1339_cur."!mark_commit"($I10)
  rxquantr1343_done:
.annotate 'line', 550
    goto alt1342_end
  alt1342_1:
.annotate 'line', 554
  # rx charclass nl
    ge rx1339_pos, rx1339_eos, rx1339_fail
    sub $I10, rx1339_pos, rx1339_off
    is_cclass $I11, .CCLASS_NEWLINE, rx1339_tgt, $I10
    unless $I11, rx1339_fail
    substr $S10, rx1339_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx1339_pos, $I11
    inc rx1339_pos
  alt1342_end:
.annotate 'line', 550
  # rx pass
    rx1339_cur."!cursor_pass"(rx1339_pos, "")
    if_null rx1339_debug, debug_914
    rx1339_cur."!cursor_debug"("PASS", "", " at pos=", rx1339_pos)
  debug_914:
    .return (rx1339_cur)
  rx1339_restart:
    if_null rx1339_debug, debug_915
    rx1339_cur."!cursor_debug"("NEXT", "")
  debug_915:
  rx1339_fail:
    (rx1339_rep, rx1339_pos, $I10, $P10) = rx1339_cur."!mark_fail"(0)
    lt rx1339_pos, -1, rx1339_done
    eq rx1339_pos, -1, rx1339_fail
    jump $I10
  rx1339_done:
    rx1339_cur."!cursor_fail"()
    if_null rx1339_debug, debug_916
    rx1339_cur."!cursor_debug"("FAIL", "")
  debug_916:
    .return (rx1339_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("63_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P104, "ResizablePMCArray"
    push $P104, ""
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("64_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 565
    new $P103, "Undef"
    set $P1347, $P103
    .lex "$*IN_DECL", $P1347
.annotate 'line', 567
    new $P104, "Undef"
    set $P1348, $P104
    .lex "$*HAS_YOU_ARE_HERE", $P1348
.annotate 'line', 568
    new $P105, "Undef"
    set $P1349, $P105
    .lex "$*MAIN_SUB", $P1349
.annotate 'line', 571
    new $P106, "Undef"
    set $P1350, $P106
    .lex "$*PACKAGE", $P1350
.annotate 'line', 572
    new $P107, "Undef"
    set $P1351, $P107
    .lex "$*GLOBALish", $P1351
.annotate 'line', 462
    .local string rx1352_tgt
    .local int rx1352_pos
    .local int rx1352_off
    .local int rx1352_eos
    .local int rx1352_rep
    .local pmc rx1352_cur
    .local pmc rx1352_debug
    (rx1352_cur, rx1352_pos, rx1352_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1352_cur
    .local pmc match
    .lex "$/", match
    length rx1352_eos, rx1352_tgt
    gt rx1352_pos, rx1352_eos, rx1352_done
    set rx1352_off, 0
    lt rx1352_pos, 2, rx1352_start
    sub rx1352_off, rx1352_pos, 1
    substr rx1352_tgt, rx1352_tgt, rx1352_off
  rx1352_start:
    eq $I10, 1, rx1352_restart
    if_null rx1352_debug, debug_920
    rx1352_cur."!cursor_debug"("START", "comp_unit")
  debug_920:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1353_done
    goto rxscan1353_scan
  rxscan1353_loop:
    (rx1352_pos) = rx1352_cur."from"()
    inc rx1352_pos
    rx1352_cur."!cursor_from"(rx1352_pos)
    ge rx1352_pos, rx1352_eos, rxscan1353_done
  rxscan1353_scan:
    set_addr $I10, rxscan1353_loop
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxscan1353_done:
.annotate 'line', 565
    rx1352_cur."!cursor_pos"(rx1352_pos)
    new $P108, "String"
    assign $P108, ""
    set $P1347, $P108
.annotate 'line', 567
    rx1352_cur."!cursor_pos"(rx1352_pos)
    new $P109, "Float"
    assign $P109, 0
    set $P1348, $P109
.annotate 'line', 568
    rx1352_cur."!cursor_pos"(rx1352_pos)
    set $P112, $P1349
    unless_null $P112, vivify_921
    get_hll_global $P110, "GLOBAL"
    get_who $P111, $P110
    set $P112, $P111["$MAIN_SUB"]
    unless_null $P112, vivify_922
    die "Contextual $*MAIN_SUB not found"
  vivify_922:
  vivify_921:
.annotate 'line', 569
  # rx subrule "newpad" subtype=method negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."newpad"()
    unless $P10, rx1352_fail
    rx1352_pos = $P10."pos"()
.annotate 'line', 571
    rx1352_cur."!cursor_pos"(rx1352_pos)
    set $P115, $P1350
    unless_null $P115, vivify_923
    get_hll_global $P113, "GLOBAL"
    get_who $P114, $P113
    set $P115, $P114["$PACKAGE"]
    unless_null $P115, vivify_924
    die "Contextual $*PACKAGE not found"
  vivify_924:
  vivify_923:
.annotate 'line', 572
    rx1352_cur."!cursor_pos"(rx1352_pos)
    set $P118, $P1351
    unless_null $P118, vivify_925
    get_hll_global $P116, "GLOBAL"
    get_who $P117, $P116
    set $P118, $P117["$GLOBALish"]
    unless_null $P118, vivify_926
    die "Contextual $*GLOBALish not found"
  vivify_926:
  vivify_925:
.annotate 'line', 573
  # rx subrule "GLOBALish" subtype=method negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."GLOBALish"()
    unless $P10, rx1352_fail
    rx1352_pos = $P10."pos"()
.annotate 'line', 575
  # rx subrule "outerctx" subtype=method negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."outerctx"()
    unless $P10, rx1352_fail
    rx1352_pos = $P10."pos"()
.annotate 'line', 577
  # rx subrule "statementlist" subtype=capture negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."statementlist"()
    unless $P10, rx1352_fail
    rx1352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1352_pos = $P10."pos"()
  alt1354_0:
.annotate 'line', 578
    set_addr $I10, alt1354_1
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  # rxanchor eos
    ne rx1352_pos, rx1352_eos, rx1352_fail
    goto alt1354_end
  alt1354_1:
  # rx subrule "panic" subtype=method negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."panic"("Confused")
    unless $P10, rx1352_fail
    rx1352_pos = $P10."pos"()
  alt1354_end:
.annotate 'line', 564
  # rx pass
    rx1352_cur."!cursor_pass"(rx1352_pos, "comp_unit")
    if_null rx1352_debug, debug_927
    rx1352_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx1352_pos)
  debug_927:
    .return (rx1352_cur)
  rx1352_restart:
.annotate 'line', 462
    if_null rx1352_debug, debug_928
    rx1352_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_928:
  rx1352_fail:
    (rx1352_rep, rx1352_pos, $I10, $P10) = rx1352_cur."!mark_fail"(0)
    lt rx1352_pos, -1, rx1352_done
    eq rx1352_pos, -1, rx1352_fail
    jump $I10
  rx1352_done:
    rx1352_cur."!cursor_fail"()
    if_null rx1352_debug, debug_929
    rx1352_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_929:
    .return (rx1352_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("65_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P119 = self."!PREFIX__!subrule"("newpad", "")
    new $P120, "ResizablePMCArray"
    push $P120, $P119
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("66_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1357_tgt
    .local int rx1357_pos
    .local int rx1357_off
    .local int rx1357_eos
    .local int rx1357_rep
    .local pmc rx1357_cur
    .local pmc rx1357_debug
    (rx1357_cur, rx1357_pos, rx1357_tgt, $I10) = self."!cursor_start"()
    rx1357_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx1357_cur
    .local pmc match
    .lex "$/", match
    length rx1357_eos, rx1357_tgt
    gt rx1357_pos, rx1357_eos, rx1357_done
    set rx1357_off, 0
    lt rx1357_pos, 2, rx1357_start
    sub rx1357_off, rx1357_pos, 1
    substr rx1357_tgt, rx1357_tgt, rx1357_off
  rx1357_start:
    eq $I10, 1, rx1357_restart
    if_null rx1357_debug, debug_930
    rx1357_cur."!cursor_debug"("START", "statementlist")
  debug_930:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1358_done
    goto rxscan1358_scan
  rxscan1358_loop:
    (rx1357_pos) = rx1357_cur."from"()
    inc rx1357_pos
    rx1357_cur."!cursor_from"(rx1357_pos)
    ge rx1357_pos, rx1357_eos, rxscan1358_done
  rxscan1358_scan:
    set_addr $I10, rxscan1358_loop
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  rxscan1358_done:
  alt1359_0:
.annotate 'line', 581
    set_addr $I10, alt1359_1
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
.annotate 'line', 582
  # rx subrule "ws" subtype=method negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."ws"()
    unless $P10, rx1357_fail
    rx1357_pos = $P10."pos"()
  # rxanchor eos
    ne rx1357_pos, rx1357_eos, rx1357_fail
  # rx subrule "ws" subtype=method negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."ws"()
    unless $P10, rx1357_fail
    rx1357_pos = $P10."pos"()
    goto alt1359_end
  alt1359_1:
.annotate 'line', 583
  # rx subrule "ws" subtype=method negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."ws"()
    unless $P10, rx1357_fail
    rx1357_pos = $P10."pos"()
  # rx rxquantr1360 ** 0..*
    set_addr $I10, rxquantr1360_done
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  rxquantr1360_loop:
  # rx subrule "statement" subtype=capture negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."statement"()
    unless $P10, rx1357_fail
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1357_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."eat_terminator"()
    unless $P10, rx1357_fail
    rx1357_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."ws"()
    unless $P10, rx1357_fail
    rx1357_pos = $P10."pos"()
    set_addr $I10, rxquantr1360_done
    (rx1357_rep) = rx1357_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1360_done
    rx1357_cur."!mark_push"(rx1357_rep, rx1357_pos, $I10)
    goto rxquantr1360_loop
  rxquantr1360_done:
  # rx subrule "ws" subtype=method negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."ws"()
    unless $P10, rx1357_fail
    rx1357_pos = $P10."pos"()
  alt1359_end:
.annotate 'line', 581
  # rx pass
    rx1357_cur."!cursor_pass"(rx1357_pos, "statementlist")
    if_null rx1357_debug, debug_931
    rx1357_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx1357_pos)
  debug_931:
    .return (rx1357_cur)
  rx1357_restart:
.annotate 'line', 462
    if_null rx1357_debug, debug_932
    rx1357_cur."!cursor_debug"("NEXT", "statementlist")
  debug_932:
  rx1357_fail:
    (rx1357_rep, rx1357_pos, $I10, $P10) = rx1357_cur."!mark_fail"(0)
    lt rx1357_pos, -1, rx1357_done
    eq rx1357_pos, -1, rx1357_fail
    jump $I10
  rx1357_done:
    rx1357_cur."!cursor_fail"()
    if_null rx1357_debug, debug_933
    rx1357_cur."!cursor_debug"("FAIL", "statementlist")
  debug_933:
    .return (rx1357_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("67_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P108 = self."!PREFIX__!subrule"("ws", "")
    $P109 = self."!PREFIX__!subrule"("ws", "")
    new $P110, "ResizablePMCArray"
    push $P110, $P108
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("68_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1366 = "69_1325892461.451" 
    capture_lex $P1366
    .local string rx1363_tgt
    .local int rx1363_pos
    .local int rx1363_off
    .local int rx1363_eos
    .local int rx1363_rep
    .local pmc rx1363_cur
    .local pmc rx1363_debug
    (rx1363_cur, rx1363_pos, rx1363_tgt, $I10) = self."!cursor_start"()
    rx1363_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx1363_cur
    .local pmc match
    .lex "$/", match
    length rx1363_eos, rx1363_tgt
    gt rx1363_pos, rx1363_eos, rx1363_done
    set rx1363_off, 0
    lt rx1363_pos, 2, rx1363_start
    sub rx1363_off, rx1363_pos, 1
    substr rx1363_tgt, rx1363_tgt, rx1363_off
  rx1363_start:
    eq $I10, 1, rx1363_restart
    if_null rx1363_debug, debug_934
    rx1363_cur."!cursor_debug"("START", "statement")
  debug_934:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1364_done
    goto rxscan1364_scan
  rxscan1364_loop:
    (rx1363_pos) = rx1363_cur."from"()
    inc rx1363_pos
    rx1363_cur."!cursor_from"(rx1363_pos)
    ge rx1363_pos, rx1363_eos, rxscan1364_done
  rxscan1364_scan:
    set_addr $I10, rxscan1364_loop
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  rxscan1364_done:
.annotate 'line', 587
  # rx subrule "before" subtype=zerowidth negate=1
    rx1363_cur."!cursor_pos"(rx1363_pos)
    .const 'Sub' $P1366 = "69_1325892461.451" 
    capture_lex $P1366
    $P10 = rx1363_cur."before"($P1366)
    if $P10, rx1363_fail
  alt1370_0:
.annotate 'line', 588
    set_addr $I10, alt1370_1
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
.annotate 'line', 589
  # rx subrule "statement_control" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."statement_control"()
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx1363_pos = $P10."pos"()
    goto alt1370_end
  alt1370_1:
.annotate 'line', 590
  # rx subrule "EXPR" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."EXPR"()
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."ws"()
    unless $P10, rx1363_fail
    rx1363_pos = $P10."pos"()
.annotate 'line', 595
  # rx rxquantr1371 ** 0..1
    set_addr $I10, rxquantr1371_done
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  rxquantr1371_loop:
  alt1372_0:
.annotate 'line', 591
    set_addr $I10, alt1372_1
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
.annotate 'line', 592
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."MARKED"("endstmt")
    unless $P10, rx1363_fail
    goto alt1372_end
  alt1372_1:
    set_addr $I10, alt1372_2
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
.annotate 'line', 593
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."statement_mod_cond"()
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx1363_pos = $P10."pos"()
  # rx rxquantr1373 ** 0..1
    set_addr $I10, rxquantr1373_done
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  rxquantr1373_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."statement_mod_loop"()
    unless $P10, rx1363_fail
    goto rxsubrule1374_pass
  rxsubrule1374_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1363_fail
  rxsubrule1374_pass:
    set_addr $I10, rxsubrule1374_back
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1363_pos = $P10."pos"()
    set_addr $I10, rxquantr1373_done
    (rx1363_rep) = rx1363_cur."!mark_commit"($I10)
  rxquantr1373_done:
    goto alt1372_end
  alt1372_2:
.annotate 'line', 594
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."statement_mod_loop"()
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx1363_pos = $P10."pos"()
  alt1372_end:
.annotate 'line', 595
    set_addr $I10, rxquantr1371_done
    (rx1363_rep) = rx1363_cur."!mark_commit"($I10)
  rxquantr1371_done:
  alt1370_end:
.annotate 'line', 586
  # rx pass
    rx1363_cur."!cursor_pass"(rx1363_pos, "statement")
    if_null rx1363_debug, debug_939
    rx1363_cur."!cursor_debug"("PASS", "statement", " at pos=", rx1363_pos)
  debug_939:
    .return (rx1363_cur)
  rx1363_restart:
.annotate 'line', 462
    if_null rx1363_debug, debug_940
    rx1363_cur."!cursor_debug"("NEXT", "statement")
  debug_940:
  rx1363_fail:
    (rx1363_rep, rx1363_pos, $I10, $P10) = rx1363_cur."!mark_fail"(0)
    lt rx1363_pos, -1, rx1363_done
    eq rx1363_pos, -1, rx1363_fail
    jump $I10
  rx1363_done:
    rx1363_cur."!cursor_fail"()
    if_null rx1363_debug, debug_941
    rx1363_cur."!cursor_debug"("FAIL", "statement")
  debug_941:
    .return (rx1363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1365"  :anon :subid("69_1325892461.451") :method :outer("68_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 587
    .local string rx1367_tgt
    .local int rx1367_pos
    .local int rx1367_off
    .local int rx1367_eos
    .local int rx1367_rep
    .local pmc rx1367_cur
    .local pmc rx1367_debug
    (rx1367_cur, rx1367_pos, rx1367_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1367_cur
    .local pmc match
    .lex "$/", match
    length rx1367_eos, rx1367_tgt
    gt rx1367_pos, rx1367_eos, rx1367_done
    set rx1367_off, 0
    lt rx1367_pos, 2, rx1367_start
    sub rx1367_off, rx1367_pos, 1
    substr rx1367_tgt, rx1367_tgt, rx1367_off
  rx1367_start:
    eq $I10, 1, rx1367_restart
    if_null rx1367_debug, debug_935
    rx1367_cur."!cursor_debug"("START", "")
  debug_935:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1368_done
    goto rxscan1368_scan
  rxscan1368_loop:
    (rx1367_pos) = rx1367_cur."from"()
    inc rx1367_pos
    rx1367_cur."!cursor_from"(rx1367_pos)
    ge rx1367_pos, rx1367_eos, rxscan1368_done
  rxscan1368_scan:
    set_addr $I10, rxscan1368_loop
    rx1367_cur."!mark_push"(0, rx1367_pos, $I10)
  rxscan1368_done:
  alt1369_0:
    set_addr $I10, alt1369_1
    rx1367_cur."!mark_push"(0, rx1367_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1367_pos, rx1367_eos, rx1367_fail
    sub $I10, rx1367_pos, rx1367_off
    substr $S10, rx1367_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx1367_fail
    inc rx1367_pos
    goto alt1369_end
  alt1369_1:
  # rxanchor eos
    ne rx1367_pos, rx1367_eos, rx1367_fail
  alt1369_end:
  # rx pass
    rx1367_cur."!cursor_pass"(rx1367_pos, "")
    if_null rx1367_debug, debug_936
    rx1367_cur."!cursor_debug"("PASS", "", " at pos=", rx1367_pos)
  debug_936:
    .return (rx1367_cur)
  rx1367_restart:
    if_null rx1367_debug, debug_937
    rx1367_cur."!cursor_debug"("NEXT", "")
  debug_937:
  rx1367_fail:
    (rx1367_rep, rx1367_pos, $I10, $P10) = rx1367_cur."!mark_fail"(0)
    lt rx1367_pos, -1, rx1367_done
    eq rx1367_pos, -1, rx1367_fail
    jump $I10
  rx1367_done:
    rx1367_cur."!cursor_fail"()
    if_null rx1367_debug, debug_938
    rx1367_cur."!cursor_debug"("FAIL", "")
  debug_938:
    .return (rx1367_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("70_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("71_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1377_tgt
    .local int rx1377_pos
    .local int rx1377_off
    .local int rx1377_eos
    .local int rx1377_rep
    .local pmc rx1377_cur
    .local pmc rx1377_debug
    (rx1377_cur, rx1377_pos, rx1377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1377_cur
    .local pmc match
    .lex "$/", match
    length rx1377_eos, rx1377_tgt
    gt rx1377_pos, rx1377_eos, rx1377_done
    set rx1377_off, 0
    lt rx1377_pos, 2, rx1377_start
    sub rx1377_off, rx1377_pos, 1
    substr rx1377_tgt, rx1377_tgt, rx1377_off
  rx1377_start:
    eq $I10, 1, rx1377_restart
    if_null rx1377_debug, debug_942
    rx1377_cur."!cursor_debug"("START", "eat_terminator")
  debug_942:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1378_done
    goto rxscan1378_scan
  rxscan1378_loop:
    (rx1377_pos) = rx1377_cur."from"()
    inc rx1377_pos
    rx1377_cur."!cursor_from"(rx1377_pos)
    ge rx1377_pos, rx1377_eos, rxscan1378_done
  rxscan1378_scan:
    set_addr $I10, rxscan1378_loop
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  rxscan1378_done:
  alt1379_0:
.annotate 'line', 599
    set_addr $I10, alt1379_1
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
.annotate 'line', 600
  # rx literal  ";"
    add $I11, rx1377_pos, 1
    gt $I11, rx1377_eos, rx1377_fail
    sub $I11, rx1377_pos, rx1377_off
    ord $I11, rx1377_tgt, $I11
    ne $I11, 59, rx1377_fail
    add rx1377_pos, 1
    goto alt1379_end
  alt1379_1:
    set_addr $I10, alt1379_2
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
.annotate 'line', 601
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx1377_cur."!cursor_pos"(rx1377_pos)
    $P10 = rx1377_cur."MARKED"("endstmt")
    unless $P10, rx1377_fail
    goto alt1379_end
  alt1379_2:
    set_addr $I10, alt1379_3
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
.annotate 'line', 602
  # rx subrule "terminator" subtype=zerowidth negate=
    rx1377_cur."!cursor_pos"(rx1377_pos)
    $P10 = rx1377_cur."terminator"()
    unless $P10, rx1377_fail
    goto alt1379_end
  alt1379_3:
.annotate 'line', 603
  # rxanchor eos
    ne rx1377_pos, rx1377_eos, rx1377_fail
  alt1379_end:
.annotate 'line', 599
  # rx pass
    rx1377_cur."!cursor_pass"(rx1377_pos, "eat_terminator")
    if_null rx1377_debug, debug_943
    rx1377_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx1377_pos)
  debug_943:
    .return (rx1377_cur)
  rx1377_restart:
.annotate 'line', 462
    if_null rx1377_debug, debug_944
    rx1377_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_944:
  rx1377_fail:
    (rx1377_rep, rx1377_pos, $I10, $P10) = rx1377_cur."!mark_fail"(0)
    lt rx1377_pos, -1, rx1377_done
    eq rx1377_pos, -1, rx1377_fail
    jump $I10
  rx1377_done:
    rx1377_cur."!cursor_fail"()
    if_null rx1377_debug, debug_945
    rx1377_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_945:
    .return (rx1377_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("72_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    push $P103, ""
    push $P103, ";"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("73_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1382_tgt
    .local int rx1382_pos
    .local int rx1382_off
    .local int rx1382_eos
    .local int rx1382_rep
    .local pmc rx1382_cur
    .local pmc rx1382_debug
    (rx1382_cur, rx1382_pos, rx1382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1382_cur
    .local pmc match
    .lex "$/", match
    length rx1382_eos, rx1382_tgt
    gt rx1382_pos, rx1382_eos, rx1382_done
    set rx1382_off, 0
    lt rx1382_pos, 2, rx1382_start
    sub rx1382_off, rx1382_pos, 1
    substr rx1382_tgt, rx1382_tgt, rx1382_off
  rx1382_start:
    eq $I10, 1, rx1382_restart
    if_null rx1382_debug, debug_946
    rx1382_cur."!cursor_debug"("START", "xblock")
  debug_946:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1383_done
    goto rxscan1383_scan
  rxscan1383_loop:
    (rx1382_pos) = rx1382_cur."from"()
    inc rx1382_pos
    rx1382_cur."!cursor_from"(rx1382_pos)
    ge rx1382_pos, rx1382_eos, rxscan1383_done
  rxscan1383_scan:
    set_addr $I10, rxscan1383_loop
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  rxscan1383_done:
.annotate 'line', 607
  # rx subrule "EXPR" subtype=capture negate=
    rx1382_cur."!cursor_pos"(rx1382_pos)
    $P10 = rx1382_cur."EXPR"()
    unless $P10, rx1382_fail
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1382_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1382_cur."!cursor_pos"(rx1382_pos)
    $P10 = rx1382_cur."ws"()
    unless $P10, rx1382_fail
    rx1382_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1382_cur."!cursor_pos"(rx1382_pos)
    $P10 = rx1382_cur."pblock"()
    unless $P10, rx1382_fail
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1382_pos = $P10."pos"()
.annotate 'line', 606
  # rx pass
    rx1382_cur."!cursor_pass"(rx1382_pos, "xblock")
    if_null rx1382_debug, debug_947
    rx1382_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx1382_pos)
  debug_947:
    .return (rx1382_cur)
  rx1382_restart:
.annotate 'line', 462
    if_null rx1382_debug, debug_948
    rx1382_cur."!cursor_debug"("NEXT", "xblock")
  debug_948:
  rx1382_fail:
    (rx1382_rep, rx1382_pos, $I10, $P10) = rx1382_cur."!mark_fail"(0)
    lt rx1382_pos, -1, rx1382_done
    eq rx1382_pos, -1, rx1382_fail
    jump $I10
  rx1382_done:
    rx1382_cur."!cursor_fail"()
    if_null rx1382_debug, debug_949
    rx1382_cur."!cursor_debug"("FAIL", "xblock")
  debug_949:
    .return (rx1382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("74_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("EXPR", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("75_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1386_tgt
    .local int rx1386_pos
    .local int rx1386_off
    .local int rx1386_eos
    .local int rx1386_rep
    .local pmc rx1386_cur
    .local pmc rx1386_debug
    (rx1386_cur, rx1386_pos, rx1386_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1386_cur
    .local pmc match
    .lex "$/", match
    length rx1386_eos, rx1386_tgt
    gt rx1386_pos, rx1386_eos, rx1386_done
    set rx1386_off, 0
    lt rx1386_pos, 2, rx1386_start
    sub rx1386_off, rx1386_pos, 1
    substr rx1386_tgt, rx1386_tgt, rx1386_off
  rx1386_start:
    eq $I10, 1, rx1386_restart
    if_null rx1386_debug, debug_950
    rx1386_cur."!cursor_debug"("START", "pblock")
  debug_950:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1387_done
    goto rxscan1387_scan
  rxscan1387_loop:
    (rx1386_pos) = rx1386_cur."from"()
    inc rx1386_pos
    rx1386_cur."!cursor_from"(rx1386_pos)
    ge rx1386_pos, rx1386_eos, rxscan1387_done
  rxscan1387_scan:
    set_addr $I10, rxscan1387_loop
    rx1386_cur."!mark_push"(0, rx1386_pos, $I10)
  rxscan1387_done:
  alt1388_0:
.annotate 'line', 610
    set_addr $I10, alt1388_1
    rx1386_cur."!mark_push"(0, rx1386_pos, $I10)
.annotate 'line', 611
  # rx subrule "lambda" subtype=method negate=
    rx1386_cur."!cursor_pos"(rx1386_pos)
    $P10 = rx1386_cur."lambda"()
    unless $P10, rx1386_fail
    rx1386_pos = $P10."pos"()
.annotate 'line', 612
  # rx subrule "newpad" subtype=method negate=
    rx1386_cur."!cursor_pos"(rx1386_pos)
    $P10 = rx1386_cur."newpad"()
    unless $P10, rx1386_fail
    rx1386_pos = $P10."pos"()
.annotate 'line', 613
  # rx subrule "signature" subtype=capture negate=
    rx1386_cur."!cursor_pos"(rx1386_pos)
    $P10 = rx1386_cur."signature"()
    unless $P10, rx1386_fail
    rx1386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1386_pos = $P10."pos"()
.annotate 'line', 614
  # rx subrule "blockoid" subtype=capture negate=
    rx1386_cur."!cursor_pos"(rx1386_pos)
    $P10 = rx1386_cur."blockoid"()
    unless $P10, rx1386_fail
    rx1386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1386_pos = $P10."pos"()
.annotate 'line', 611
    goto alt1388_end
  alt1388_1:
    set_addr $I10, alt1388_2
    rx1386_cur."!mark_push"(0, rx1386_pos, $I10)
.annotate 'line', 615
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1386_pos, rx1386_off
    substr $S10, rx1386_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1386_fail
.annotate 'line', 616
  # rx subrule "newpad" subtype=method negate=
    rx1386_cur."!cursor_pos"(rx1386_pos)
    $P10 = rx1386_cur."newpad"()
    unless $P10, rx1386_fail
    rx1386_pos = $P10."pos"()
.annotate 'line', 617
  # rx subrule "blockoid" subtype=capture negate=
    rx1386_cur."!cursor_pos"(rx1386_pos)
    $P10 = rx1386_cur."blockoid"()
    unless $P10, rx1386_fail
    rx1386_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1386_pos = $P10."pos"()
.annotate 'line', 615
    goto alt1388_end
  alt1388_2:
.annotate 'line', 618
  # rx subrule "panic" subtype=method negate=
    rx1386_cur."!cursor_pos"(rx1386_pos)
    $P10 = rx1386_cur."panic"("Missing block")
    unless $P10, rx1386_fail
    rx1386_pos = $P10."pos"()
  alt1388_end:
.annotate 'line', 610
  # rx pass
    rx1386_cur."!cursor_pass"(rx1386_pos, "pblock")
    if_null rx1386_debug, debug_951
    rx1386_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx1386_pos)
  debug_951:
    .return (rx1386_cur)
  rx1386_restart:
.annotate 'line', 462
    if_null rx1386_debug, debug_952
    rx1386_cur."!cursor_debug"("NEXT", "pblock")
  debug_952:
  rx1386_fail:
    (rx1386_rep, rx1386_pos, $I10, $P10) = rx1386_cur."!mark_fail"(0)
    lt rx1386_pos, -1, rx1386_done
    eq rx1386_pos, -1, rx1386_fail
    jump $I10
  rx1386_done:
    rx1386_cur."!cursor_fail"()
    if_null rx1386_debug, debug_953
    rx1386_cur."!cursor_debug"("FAIL", "pblock")
  debug_953:
    .return (rx1386_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("76_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("panic", "")
    $P104 = self."!PREFIX__!subrule"("lambda", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, "{"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("77_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1391_tgt
    .local int rx1391_pos
    .local int rx1391_off
    .local int rx1391_eos
    .local int rx1391_rep
    .local pmc rx1391_cur
    .local pmc rx1391_debug
    (rx1391_cur, rx1391_pos, rx1391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1391_cur
    .local pmc match
    .lex "$/", match
    length rx1391_eos, rx1391_tgt
    gt rx1391_pos, rx1391_eos, rx1391_done
    set rx1391_off, 0
    lt rx1391_pos, 2, rx1391_start
    sub rx1391_off, rx1391_pos, 1
    substr rx1391_tgt, rx1391_tgt, rx1391_off
  rx1391_start:
    eq $I10, 1, rx1391_restart
    if_null rx1391_debug, debug_954
    rx1391_cur."!cursor_debug"("START", "lambda")
  debug_954:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1392_done
    goto rxscan1392_scan
  rxscan1392_loop:
    (rx1391_pos) = rx1391_cur."from"()
    inc rx1391_pos
    rx1391_cur."!cursor_from"(rx1391_pos)
    ge rx1391_pos, rx1391_eos, rxscan1392_done
  rxscan1392_scan:
    set_addr $I10, rxscan1392_loop
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  rxscan1392_done:
  alt1393_0:
.annotate 'line', 621
    set_addr $I10, alt1393_1
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  # rx literal  "->"
    add $I11, rx1391_pos, 2
    gt $I11, rx1391_eos, rx1391_fail
    sub $I11, rx1391_pos, rx1391_off
    substr $S10, rx1391_tgt, $I11, 2
    ne $S10, "->", rx1391_fail
    add rx1391_pos, 2
    goto alt1393_end
  alt1393_1:
  # rx literal  "<->"
    add $I11, rx1391_pos, 3
    gt $I11, rx1391_eos, rx1391_fail
    sub $I11, rx1391_pos, rx1391_off
    substr $S10, rx1391_tgt, $I11, 3
    ne $S10, "<->", rx1391_fail
    add rx1391_pos, 3
  alt1393_end:
  # rx pass
    rx1391_cur."!cursor_pass"(rx1391_pos, "lambda")
    if_null rx1391_debug, debug_955
    rx1391_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx1391_pos)
  debug_955:
    .return (rx1391_cur)
  rx1391_restart:
.annotate 'line', 462
    if_null rx1391_debug, debug_956
    rx1391_cur."!cursor_debug"("NEXT", "lambda")
  debug_956:
  rx1391_fail:
    (rx1391_rep, rx1391_pos, $I10, $P10) = rx1391_cur."!mark_fail"(0)
    lt rx1391_pos, -1, rx1391_done
    eq rx1391_pos, -1, rx1391_fail
    jump $I10
  rx1391_done:
    rx1391_cur."!cursor_fail"()
    if_null rx1391_debug, debug_957
    rx1391_cur."!cursor_debug"("FAIL", "lambda")
  debug_957:
    .return (rx1391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("78_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "<->"
    push $P103, "->"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("79_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1396_tgt
    .local int rx1396_pos
    .local int rx1396_off
    .local int rx1396_eos
    .local int rx1396_rep
    .local pmc rx1396_cur
    .local pmc rx1396_debug
    (rx1396_cur, rx1396_pos, rx1396_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1396_cur
    .local pmc match
    .lex "$/", match
    length rx1396_eos, rx1396_tgt
    gt rx1396_pos, rx1396_eos, rx1396_done
    set rx1396_off, 0
    lt rx1396_pos, 2, rx1396_start
    sub rx1396_off, rx1396_pos, 1
    substr rx1396_tgt, rx1396_tgt, rx1396_off
  rx1396_start:
    eq $I10, 1, rx1396_restart
    if_null rx1396_debug, debug_958
    rx1396_cur."!cursor_debug"("START", "block")
  debug_958:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1397_done
    goto rxscan1397_scan
  rxscan1397_loop:
    (rx1396_pos) = rx1396_cur."from"()
    inc rx1396_pos
    rx1396_cur."!cursor_from"(rx1396_pos)
    ge rx1396_pos, rx1396_eos, rxscan1397_done
  rxscan1397_scan:
    set_addr $I10, rxscan1397_loop
    rx1396_cur."!mark_push"(0, rx1396_pos, $I10)
  rxscan1397_done:
  alt1398_0:
.annotate 'line', 624
    set_addr $I10, alt1398_1
    rx1396_cur."!mark_push"(0, rx1396_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1396_pos, rx1396_off
    substr $S10, rx1396_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1396_fail
    goto alt1398_end
  alt1398_1:
  # rx subrule "panic" subtype=method negate=
    rx1396_cur."!cursor_pos"(rx1396_pos)
    $P10 = rx1396_cur."panic"("Missing block")
    unless $P10, rx1396_fail
    rx1396_pos = $P10."pos"()
  alt1398_end:
.annotate 'line', 625
  # rx subrule "newpad" subtype=method negate=
    rx1396_cur."!cursor_pos"(rx1396_pos)
    $P10 = rx1396_cur."newpad"()
    unless $P10, rx1396_fail
    rx1396_pos = $P10."pos"()
.annotate 'line', 626
  # rx subrule "blockoid" subtype=capture negate=
    rx1396_cur."!cursor_pos"(rx1396_pos)
    $P10 = rx1396_cur."blockoid"()
    unless $P10, rx1396_fail
    rx1396_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1396_pos = $P10."pos"()
.annotate 'line', 623
  # rx pass
    rx1396_cur."!cursor_pass"(rx1396_pos, "block")
    if_null rx1396_debug, debug_959
    rx1396_cur."!cursor_debug"("PASS", "block", " at pos=", rx1396_pos)
  debug_959:
    .return (rx1396_cur)
  rx1396_restart:
.annotate 'line', 462
    if_null rx1396_debug, debug_960
    rx1396_cur."!cursor_debug"("NEXT", "block")
  debug_960:
  rx1396_fail:
    (rx1396_rep, rx1396_pos, $I10, $P10) = rx1396_cur."!mark_fail"(0)
    lt rx1396_pos, -1, rx1396_done
    eq rx1396_pos, -1, rx1396_fail
    jump $I10
  rx1396_done:
    rx1396_cur."!cursor_fail"()
    if_null rx1396_debug, debug_961
    rx1396_cur."!cursor_debug"("FAIL", "block")
  debug_961:
    .return (rx1396_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("80_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("panic", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    push $P104, "{"
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("81_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1401_tgt
    .local int rx1401_pos
    .local int rx1401_off
    .local int rx1401_eos
    .local int rx1401_rep
    .local pmc rx1401_cur
    .local pmc rx1401_debug
    (rx1401_cur, rx1401_pos, rx1401_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1401_cur
    .local pmc match
    .lex "$/", match
    length rx1401_eos, rx1401_tgt
    gt rx1401_pos, rx1401_eos, rx1401_done
    set rx1401_off, 0
    lt rx1401_pos, 2, rx1401_start
    sub rx1401_off, rx1401_pos, 1
    substr rx1401_tgt, rx1401_tgt, rx1401_off
  rx1401_start:
    eq $I10, 1, rx1401_restart
    if_null rx1401_debug, debug_962
    rx1401_cur."!cursor_debug"("START", "blockoid")
  debug_962:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1402_done
    goto rxscan1402_scan
  rxscan1402_loop:
    (rx1401_pos) = rx1401_cur."from"()
    inc rx1401_pos
    rx1401_cur."!cursor_from"(rx1401_pos)
    ge rx1401_pos, rx1401_eos, rxscan1402_done
  rxscan1402_scan:
    set_addr $I10, rxscan1402_loop
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  rxscan1402_done:
.annotate 'line', 630
  # rx subrule "finishpad" subtype=method negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."finishpad"()
    unless $P10, rx1401_fail
    rx1401_pos = $P10."pos"()
  alt1403_0:
.annotate 'line', 631
    set_addr $I10, alt1403_1
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
.annotate 'line', 632
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx1401_pos, 14
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    substr $S10, rx1401_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx1401_fail
    add rx1401_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."you_are_here"()
    unless $P10, rx1401_fail
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx1401_pos = $P10."pos"()
    goto alt1403_end
  alt1403_1:
.annotate 'line', 633
  # rx literal  "{"
    add $I11, rx1401_pos, 1
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    ord $I11, rx1401_tgt, $I11
    ne $I11, 123, rx1401_fail
    add rx1401_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."statementlist"()
    unless $P10, rx1401_fail
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx1401_pos = $P10."pos"()
  alt1404_0:
    set_addr $I10, alt1404_1
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  # rx literal  "}"
    add $I11, rx1401_pos, 1
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    ord $I11, rx1401_tgt, $I11
    ne $I11, 125, rx1401_fail
    add rx1401_pos, 1
    goto alt1404_end
  alt1404_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."FAILGOAL"("'}'")
    unless $P10, rx1401_fail
    goto rxsubrule1405_pass
  rxsubrule1405_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1401_fail
  rxsubrule1405_pass:
    set_addr $I10, rxsubrule1405_back
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10, $P10)
    rx1401_pos = $P10."pos"()
  alt1404_end:
  alt1403_end:
.annotate 'line', 635
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."ENDSTMT"()
    unless $P10, rx1401_fail
.annotate 'line', 629
  # rx pass
    rx1401_cur."!cursor_pass"(rx1401_pos, "blockoid")
    if_null rx1401_debug, debug_963
    rx1401_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx1401_pos)
  debug_963:
    .return (rx1401_cur)
  rx1401_restart:
.annotate 'line', 462
    if_null rx1401_debug, debug_964
    rx1401_cur."!cursor_debug"("NEXT", "blockoid")
  debug_964:
  rx1401_fail:
    (rx1401_rep, rx1401_pos, $I10, $P10) = rx1401_cur."!mark_fail"(0)
    lt rx1401_pos, -1, rx1401_done
    eq rx1401_pos, -1, rx1401_fail
    jump $I10
  rx1401_done:
    rx1401_cur."!cursor_fail"()
    if_null rx1401_debug, debug_965
    rx1401_cur."!cursor_debug"("FAIL", "blockoid")
  debug_965:
    .return (rx1401_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("82_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P104 = self."!PREFIX__!subrule"("finishpad", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("83_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1408_tgt
    .local int rx1408_pos
    .local int rx1408_off
    .local int rx1408_eos
    .local int rx1408_rep
    .local pmc rx1408_cur
    .local pmc rx1408_debug
    (rx1408_cur, rx1408_pos, rx1408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1408_cur
    .local pmc match
    .lex "$/", match
    length rx1408_eos, rx1408_tgt
    gt rx1408_pos, rx1408_eos, rx1408_done
    set rx1408_off, 0
    lt rx1408_pos, 2, rx1408_start
    sub rx1408_off, rx1408_pos, 1
    substr rx1408_tgt, rx1408_tgt, rx1408_off
  rx1408_start:
    eq $I10, 1, rx1408_restart
    if_null rx1408_debug, debug_966
    rx1408_cur."!cursor_debug"("START", "newpad")
  debug_966:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1409_done
    goto rxscan1409_scan
  rxscan1409_loop:
    (rx1408_pos) = rx1408_cur."from"()
    inc rx1408_pos
    rx1408_cur."!cursor_from"(rx1408_pos)
    ge rx1408_pos, rx1408_eos, rxscan1409_done
  rxscan1409_scan:
    set_addr $I10, rxscan1409_loop
    rx1408_cur."!mark_push"(0, rx1408_pos, $I10)
  rxscan1409_done:
.annotate 'line', 638
  # rx pass
    rx1408_cur."!cursor_pass"(rx1408_pos, "newpad")
    if_null rx1408_debug, debug_967
    rx1408_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx1408_pos)
  debug_967:
    .return (rx1408_cur)
  rx1408_restart:
.annotate 'line', 462
    if_null rx1408_debug, debug_968
    rx1408_cur."!cursor_debug"("NEXT", "newpad")
  debug_968:
  rx1408_fail:
    (rx1408_rep, rx1408_pos, $I10, $P10) = rx1408_cur."!mark_fail"(0)
    lt rx1408_pos, -1, rx1408_done
    eq rx1408_pos, -1, rx1408_fail
    jump $I10
  rx1408_done:
    rx1408_cur."!cursor_fail"()
    if_null rx1408_debug, debug_969
    rx1408_cur."!cursor_debug"("FAIL", "newpad")
  debug_969:
    .return (rx1408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("84_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("85_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1412_tgt
    .local int rx1412_pos
    .local int rx1412_off
    .local int rx1412_eos
    .local int rx1412_rep
    .local pmc rx1412_cur
    .local pmc rx1412_debug
    (rx1412_cur, rx1412_pos, rx1412_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1412_cur
    .local pmc match
    .lex "$/", match
    length rx1412_eos, rx1412_tgt
    gt rx1412_pos, rx1412_eos, rx1412_done
    set rx1412_off, 0
    lt rx1412_pos, 2, rx1412_start
    sub rx1412_off, rx1412_pos, 1
    substr rx1412_tgt, rx1412_tgt, rx1412_off
  rx1412_start:
    eq $I10, 1, rx1412_restart
    if_null rx1412_debug, debug_970
    rx1412_cur."!cursor_debug"("START", "outerctx")
  debug_970:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1413_done
    goto rxscan1413_scan
  rxscan1413_loop:
    (rx1412_pos) = rx1412_cur."from"()
    inc rx1412_pos
    rx1412_cur."!cursor_from"(rx1412_pos)
    ge rx1412_pos, rx1412_eos, rxscan1413_done
  rxscan1413_scan:
    set_addr $I10, rxscan1413_loop
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  rxscan1413_done:
.annotate 'line', 639
  # rx pass
    rx1412_cur."!cursor_pass"(rx1412_pos, "outerctx")
    if_null rx1412_debug, debug_971
    rx1412_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx1412_pos)
  debug_971:
    .return (rx1412_cur)
  rx1412_restart:
.annotate 'line', 462
    if_null rx1412_debug, debug_972
    rx1412_cur."!cursor_debug"("NEXT", "outerctx")
  debug_972:
  rx1412_fail:
    (rx1412_rep, rx1412_pos, $I10, $P10) = rx1412_cur."!mark_fail"(0)
    lt rx1412_pos, -1, rx1412_done
    eq rx1412_pos, -1, rx1412_fail
    jump $I10
  rx1412_done:
    rx1412_cur."!cursor_fail"()
    if_null rx1412_debug, debug_973
    rx1412_cur."!cursor_debug"("FAIL", "outerctx")
  debug_973:
    .return (rx1412_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("86_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("87_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1416_tgt
    .local int rx1416_pos
    .local int rx1416_off
    .local int rx1416_eos
    .local int rx1416_rep
    .local pmc rx1416_cur
    .local pmc rx1416_debug
    (rx1416_cur, rx1416_pos, rx1416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1416_cur
    .local pmc match
    .lex "$/", match
    length rx1416_eos, rx1416_tgt
    gt rx1416_pos, rx1416_eos, rx1416_done
    set rx1416_off, 0
    lt rx1416_pos, 2, rx1416_start
    sub rx1416_off, rx1416_pos, 1
    substr rx1416_tgt, rx1416_tgt, rx1416_off
  rx1416_start:
    eq $I10, 1, rx1416_restart
    if_null rx1416_debug, debug_974
    rx1416_cur."!cursor_debug"("START", "GLOBALish")
  debug_974:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1417_done
    goto rxscan1417_scan
  rxscan1417_loop:
    (rx1416_pos) = rx1416_cur."from"()
    inc rx1416_pos
    rx1416_cur."!cursor_from"(rx1416_pos)
    ge rx1416_pos, rx1416_eos, rxscan1417_done
  rxscan1417_scan:
    set_addr $I10, rxscan1417_loop
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  rxscan1417_done:
.annotate 'line', 640
  # rx pass
    rx1416_cur."!cursor_pass"(rx1416_pos, "GLOBALish")
    if_null rx1416_debug, debug_975
    rx1416_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx1416_pos)
  debug_975:
    .return (rx1416_cur)
  rx1416_restart:
.annotate 'line', 462
    if_null rx1416_debug, debug_976
    rx1416_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_976:
  rx1416_fail:
    (rx1416_rep, rx1416_pos, $I10, $P10) = rx1416_cur."!mark_fail"(0)
    lt rx1416_pos, -1, rx1416_done
    eq rx1416_pos, -1, rx1416_fail
    jump $I10
  rx1416_done:
    rx1416_cur."!cursor_fail"()
    if_null rx1416_debug, debug_977
    rx1416_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_977:
    .return (rx1416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("88_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("89_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1420_tgt
    .local int rx1420_pos
    .local int rx1420_off
    .local int rx1420_eos
    .local int rx1420_rep
    .local pmc rx1420_cur
    .local pmc rx1420_debug
    (rx1420_cur, rx1420_pos, rx1420_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1420_cur
    .local pmc match
    .lex "$/", match
    length rx1420_eos, rx1420_tgt
    gt rx1420_pos, rx1420_eos, rx1420_done
    set rx1420_off, 0
    lt rx1420_pos, 2, rx1420_start
    sub rx1420_off, rx1420_pos, 1
    substr rx1420_tgt, rx1420_tgt, rx1420_off
  rx1420_start:
    eq $I10, 1, rx1420_restart
    if_null rx1420_debug, debug_978
    rx1420_cur."!cursor_debug"("START", "finishpad")
  debug_978:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1421_done
    goto rxscan1421_scan
  rxscan1421_loop:
    (rx1420_pos) = rx1420_cur."from"()
    inc rx1420_pos
    rx1420_cur."!cursor_from"(rx1420_pos)
    ge rx1420_pos, rx1420_eos, rxscan1421_done
  rxscan1421_scan:
    set_addr $I10, rxscan1421_loop
    rx1420_cur."!mark_push"(0, rx1420_pos, $I10)
  rxscan1421_done:
.annotate 'line', 641
  # rx pass
    rx1420_cur."!cursor_pass"(rx1420_pos, "finishpad")
    if_null rx1420_debug, debug_979
    rx1420_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx1420_pos)
  debug_979:
    .return (rx1420_cur)
  rx1420_restart:
.annotate 'line', 462
    if_null rx1420_debug, debug_980
    rx1420_cur."!cursor_debug"("NEXT", "finishpad")
  debug_980:
  rx1420_fail:
    (rx1420_rep, rx1420_pos, $I10, $P10) = rx1420_cur."!mark_fail"(0)
    lt rx1420_pos, -1, rx1420_done
    eq rx1420_pos, -1, rx1420_fail
    jump $I10
  rx1420_done:
    rx1420_cur."!cursor_fail"()
    if_null rx1420_debug, debug_981
    rx1420_cur."!cursor_debug"("FAIL", "finishpad")
  debug_981:
    .return (rx1420_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("90_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("91_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1424_tgt
    .local int rx1424_pos
    .local int rx1424_off
    .local int rx1424_eos
    .local int rx1424_rep
    .local pmc rx1424_cur
    .local pmc rx1424_debug
    (rx1424_cur, rx1424_pos, rx1424_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1424_cur
    .local pmc match
    .lex "$/", match
    length rx1424_eos, rx1424_tgt
    gt rx1424_pos, rx1424_eos, rx1424_done
    set rx1424_off, 0
    lt rx1424_pos, 2, rx1424_start
    sub rx1424_off, rx1424_pos, 1
    substr rx1424_tgt, rx1424_tgt, rx1424_off
  rx1424_start:
    eq $I10, 1, rx1424_restart
    if_null rx1424_debug, debug_982
    rx1424_cur."!cursor_debug"("START", "you_are_here")
  debug_982:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1425_done
    goto rxscan1425_scan
  rxscan1425_loop:
    (rx1424_pos) = rx1424_cur."from"()
    inc rx1424_pos
    rx1424_cur."!cursor_from"(rx1424_pos)
    ge rx1424_pos, rx1424_eos, rxscan1425_done
  rxscan1425_scan:
    set_addr $I10, rxscan1425_loop
    rx1424_cur."!mark_push"(0, rx1424_pos, $I10)
  rxscan1425_done:
.annotate 'line', 642
  # rx pass
    rx1424_cur."!cursor_pass"(rx1424_pos, "you_are_here")
    if_null rx1424_debug, debug_983
    rx1424_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx1424_pos)
  debug_983:
    .return (rx1424_cur)
  rx1424_restart:
.annotate 'line', 462
    if_null rx1424_debug, debug_984
    rx1424_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_984:
  rx1424_fail:
    (rx1424_rep, rx1424_pos, $I10, $P10) = rx1424_cur."!mark_fail"(0)
    lt rx1424_pos, -1, rx1424_done
    eq rx1424_pos, -1, rx1424_fail
    jump $I10
  rx1424_done:
    rx1424_cur."!cursor_fail"()
    if_null rx1424_debug, debug_985
    rx1424_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_985:
    .return (rx1424_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("92_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("93_1325892461.451")
    .param pmc param_1428
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 644
    .lex "self", param_1428
    $P103 = param_1428."!protoregex"("terminator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("94_1325892461.451")
    .param pmc param_1430
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 644
    .lex "self", param_1430
    $P104 = param_1430."!PREFIX__!protoregex"("terminator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("95_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1432_tgt
    .local int rx1432_pos
    .local int rx1432_off
    .local int rx1432_eos
    .local int rx1432_rep
    .local pmc rx1432_cur
    .local pmc rx1432_debug
    (rx1432_cur, rx1432_pos, rx1432_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1432_cur
    .local pmc match
    .lex "$/", match
    length rx1432_eos, rx1432_tgt
    gt rx1432_pos, rx1432_eos, rx1432_done
    set rx1432_off, 0
    lt rx1432_pos, 2, rx1432_start
    sub rx1432_off, rx1432_pos, 1
    substr rx1432_tgt, rx1432_tgt, rx1432_off
  rx1432_start:
    eq $I10, 1, rx1432_restart
    if_null rx1432_debug, debug_986
    rx1432_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_986:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1433_done
    goto rxscan1433_scan
  rxscan1433_loop:
    (rx1432_pos) = rx1432_cur."from"()
    inc rx1432_pos
    rx1432_cur."!cursor_from"(rx1432_pos)
    ge rx1432_pos, rx1432_eos, rxscan1433_done
  rxscan1433_scan:
    set_addr $I10, rxscan1433_loop
    rx1432_cur."!mark_push"(0, rx1432_pos, $I10)
  rxscan1433_done:
.annotate 'line', 646
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1432_pos, rx1432_off
    substr $S10, rx1432_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx1432_fail
  # rx pass
    rx1432_cur."!cursor_pass"(rx1432_pos, "terminator:sym<;>")
    if_null rx1432_debug, debug_987
    rx1432_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx1432_pos)
  debug_987:
    .return (rx1432_cur)
  rx1432_restart:
.annotate 'line', 462
    if_null rx1432_debug, debug_988
    rx1432_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_988:
  rx1432_fail:
    (rx1432_rep, rx1432_pos, $I10, $P10) = rx1432_cur."!mark_fail"(0)
    lt rx1432_pos, -1, rx1432_done
    eq rx1432_pos, -1, rx1432_fail
    jump $I10
  rx1432_done:
    rx1432_cur."!cursor_fail"()
    if_null rx1432_debug, debug_989
    rx1432_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_989:
    .return (rx1432_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("96_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ";"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("97_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1436_tgt
    .local int rx1436_pos
    .local int rx1436_off
    .local int rx1436_eos
    .local int rx1436_rep
    .local pmc rx1436_cur
    .local pmc rx1436_debug
    (rx1436_cur, rx1436_pos, rx1436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1436_cur
    .local pmc match
    .lex "$/", match
    length rx1436_eos, rx1436_tgt
    gt rx1436_pos, rx1436_eos, rx1436_done
    set rx1436_off, 0
    lt rx1436_pos, 2, rx1436_start
    sub rx1436_off, rx1436_pos, 1
    substr rx1436_tgt, rx1436_tgt, rx1436_off
  rx1436_start:
    eq $I10, 1, rx1436_restart
    if_null rx1436_debug, debug_990
    rx1436_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_990:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1437_done
    goto rxscan1437_scan
  rxscan1437_loop:
    (rx1436_pos) = rx1436_cur."from"()
    inc rx1436_pos
    rx1436_cur."!cursor_from"(rx1436_pos)
    ge rx1436_pos, rx1436_eos, rxscan1437_done
  rxscan1437_scan:
    set_addr $I10, rxscan1437_loop
    rx1436_cur."!mark_push"(0, rx1436_pos, $I10)
  rxscan1437_done:
.annotate 'line', 647
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1436_pos, rx1436_off
    substr $S10, rx1436_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx1436_fail
  # rx pass
    rx1436_cur."!cursor_pass"(rx1436_pos, "terminator:sym<}>")
    if_null rx1436_debug, debug_991
    rx1436_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx1436_pos)
  debug_991:
    .return (rx1436_cur)
  rx1436_restart:
.annotate 'line', 462
    if_null rx1436_debug, debug_992
    rx1436_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_992:
  rx1436_fail:
    (rx1436_rep, rx1436_pos, $I10, $P10) = rx1436_cur."!mark_fail"(0)
    lt rx1436_pos, -1, rx1436_done
    eq rx1436_pos, -1, rx1436_fail
    jump $I10
  rx1436_done:
    rx1436_cur."!cursor_fail"()
    if_null rx1436_debug, debug_993
    rx1436_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_993:
    .return (rx1436_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("98_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "}"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("99_1325892461.451")
    .param pmc param_1440
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 651
    .lex "self", param_1440
    $P103 = param_1440."!protoregex"("statement_control")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("100_1325892461.451")
    .param pmc param_1442
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 651
    .lex "self", param_1442
    $P104 = param_1442."!PREFIX__!protoregex"("statement_control")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("101_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1444_tgt
    .local int rx1444_pos
    .local int rx1444_off
    .local int rx1444_eos
    .local int rx1444_rep
    .local pmc rx1444_cur
    .local pmc rx1444_debug
    (rx1444_cur, rx1444_pos, rx1444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1444_cur
    .local pmc match
    .lex "$/", match
    length rx1444_eos, rx1444_tgt
    gt rx1444_pos, rx1444_eos, rx1444_done
    set rx1444_off, 0
    lt rx1444_pos, 2, rx1444_start
    sub rx1444_off, rx1444_pos, 1
    substr rx1444_tgt, rx1444_tgt, rx1444_off
  rx1444_start:
    eq $I10, 1, rx1444_restart
    if_null rx1444_debug, debug_994
    rx1444_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_994:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1445_done
    goto rxscan1445_scan
  rxscan1445_loop:
    (rx1444_pos) = rx1444_cur."from"()
    inc rx1444_pos
    rx1444_cur."!cursor_from"(rx1444_pos)
    ge rx1444_pos, rx1444_eos, rxscan1445_done
  rxscan1445_scan:
    set_addr $I10, rxscan1445_loop
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  rxscan1445_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1446_fail
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  # rx literal  "use"
    add $I11, rx1444_pos, 3
    gt $I11, rx1444_eos, rx1444_fail
    sub $I11, rx1444_pos, rx1444_off
    substr $S10, rx1444_tgt, $I11, 3
    ne $S10, "use", rx1444_fail
    add rx1444_pos, 3
    set_addr $I10, rxcap_1446_fail
    ($I12, $I11) = rx1444_cur."!mark_peek"($I10)
    rx1444_cur."!cursor_pos"($I11)
    ($P10) = rx1444_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1444_pos, "")
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1446_done
  rxcap_1446_fail:
    goto rx1444_fail
  rxcap_1446_done:
  # rx charclass s
    ge rx1444_pos, rx1444_eos, rx1444_fail
    sub $I10, rx1444_pos, rx1444_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1444_tgt, $I10
    unless $I11, rx1444_fail
    inc rx1444_pos
  # rx subrule "ws" subtype=method negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."ws"()
    unless $P10, rx1444_fail
    rx1444_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."name"()
    unless $P10, rx1444_fail
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1444_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."ws"()
    unless $P10, rx1444_fail
    rx1444_pos = $P10."pos"()
.annotate 'line', 653
  # rx pass
    rx1444_cur."!cursor_pass"(rx1444_pos, "statement_control:sym<use>")
    if_null rx1444_debug, debug_995
    rx1444_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx1444_pos)
  debug_995:
    .return (rx1444_cur)
  rx1444_restart:
.annotate 'line', 462
    if_null rx1444_debug, debug_996
    rx1444_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_996:
  rx1444_fail:
    (rx1444_rep, rx1444_pos, $I10, $P10) = rx1444_cur."!mark_fail"(0)
    lt rx1444_pos, -1, rx1444_done
    eq rx1444_pos, -1, rx1444_fail
    jump $I10
  rx1444_done:
    rx1444_cur."!cursor_fail"()
    if_null rx1444_debug, debug_997
    rx1444_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_997:
    .return (rx1444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("102_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P105, "ResizablePMCArray"
    push $P105, "use"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("103_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1449_tgt
    .local int rx1449_pos
    .local int rx1449_off
    .local int rx1449_eos
    .local int rx1449_rep
    .local pmc rx1449_cur
    .local pmc rx1449_debug
    (rx1449_cur, rx1449_pos, rx1449_tgt, $I10) = self."!cursor_start"()
    rx1449_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx1449_cur
    .local pmc match
    .lex "$/", match
    length rx1449_eos, rx1449_tgt
    gt rx1449_pos, rx1449_eos, rx1449_done
    set rx1449_off, 0
    lt rx1449_pos, 2, rx1449_start
    sub rx1449_off, rx1449_pos, 1
    substr rx1449_tgt, rx1449_tgt, rx1449_off
  rx1449_start:
    eq $I10, 1, rx1449_restart
    if_null rx1449_debug, debug_998
    rx1449_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_998:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1450_done
    goto rxscan1450_scan
  rxscan1450_loop:
    (rx1449_pos) = rx1449_cur."from"()
    inc rx1449_pos
    rx1449_cur."!cursor_from"(rx1449_pos)
    ge rx1449_pos, rx1449_eos, rxscan1450_done
  rxscan1450_scan:
    set_addr $I10, rxscan1450_loop
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxscan1450_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1451_fail
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  # rx literal  "if"
    add $I11, rx1449_pos, 2
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I11, 2
    ne $S10, "if", rx1449_fail
    add rx1449_pos, 2
    set_addr $I10, rxcap_1451_fail
    ($I12, $I11) = rx1449_cur."!mark_peek"($I10)
    rx1449_cur."!cursor_pos"($I11)
    ($P10) = rx1449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1449_pos, "")
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1451_done
  rxcap_1451_fail:
    goto rx1449_fail
  rxcap_1451_done:
  # rx charclass s
    ge rx1449_pos, rx1449_eos, rx1449_fail
    sub $I10, rx1449_pos, rx1449_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1449_tgt, $I10
    unless $I11, rx1449_fail
    inc rx1449_pos
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
.annotate 'line', 659
  # rx subrule "xblock" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."xblock"()
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1449_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
.annotate 'line', 660
  # rx rxquantr1452 ** 0..*
    set_addr $I10, rxquantr1452_done
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxquantr1452_loop:
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx1449_pos, 5
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I11, 5
    ne $S10, "elsif", rx1449_fail
    add rx1449_pos, 5
  # rx charclass s
    ge rx1449_pos, rx1449_eos, rx1449_fail
    sub $I10, rx1449_pos, rx1449_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1449_tgt, $I10
    unless $I11, rx1449_fail
    inc rx1449_pos
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."xblock"()
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1449_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
    set_addr $I10, rxquantr1452_done
    (rx1449_rep) = rx1449_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1452_done
    rx1449_cur."!mark_push"(rx1449_rep, rx1449_pos, $I10)
    goto rxquantr1452_loop
  rxquantr1452_done:
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
.annotate 'line', 661
  # rx rxquantr1453 ** 0..1
    set_addr $I10, rxquantr1453_done
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxquantr1453_loop:
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx1449_pos, 4
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I11, 4
    ne $S10, "else", rx1449_fail
    add rx1449_pos, 4
  # rx charclass s
    ge rx1449_pos, rx1449_eos, rx1449_fail
    sub $I10, rx1449_pos, rx1449_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1449_tgt, $I10
    unless $I11, rx1449_fail
    inc rx1449_pos
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."pblock"()
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx1449_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
    set_addr $I10, rxquantr1453_done
    (rx1449_rep) = rx1449_cur."!mark_commit"($I10)
  rxquantr1453_done:
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
.annotate 'line', 657
  # rx pass
    rx1449_cur."!cursor_pass"(rx1449_pos, "statement_control:sym<if>")
    if_null rx1449_debug, debug_999
    rx1449_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx1449_pos)
  debug_999:
    .return (rx1449_cur)
  rx1449_restart:
.annotate 'line', 462
    if_null rx1449_debug, debug_1000
    rx1449_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_1000:
  rx1449_fail:
    (rx1449_rep, rx1449_pos, $I10, $P10) = rx1449_cur."!mark_fail"(0)
    lt rx1449_pos, -1, rx1449_done
    eq rx1449_pos, -1, rx1449_fail
    jump $I10
  rx1449_done:
    rx1449_cur."!cursor_fail"()
    if_null rx1449_debug, debug_1001
    rx1449_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_1001:
    .return (rx1449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("104_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P113, "ResizablePMCArray"
    push $P113, "if"
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("105_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1461 = "106_1325892461.451" 
    capture_lex $P1461
    .local string rx1456_tgt
    .local int rx1456_pos
    .local int rx1456_off
    .local int rx1456_eos
    .local int rx1456_rep
    .local pmc rx1456_cur
    .local pmc rx1456_debug
    (rx1456_cur, rx1456_pos, rx1456_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1456_cur
    .local pmc match
    .lex "$/", match
    length rx1456_eos, rx1456_tgt
    gt rx1456_pos, rx1456_eos, rx1456_done
    set rx1456_off, 0
    lt rx1456_pos, 2, rx1456_start
    sub rx1456_off, rx1456_pos, 1
    substr rx1456_tgt, rx1456_tgt, rx1456_off
  rx1456_start:
    eq $I10, 1, rx1456_restart
    if_null rx1456_debug, debug_1002
    rx1456_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_1002:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1457_done
    goto rxscan1457_scan
  rxscan1457_loop:
    (rx1456_pos) = rx1456_cur."from"()
    inc rx1456_pos
    rx1456_cur."!cursor_from"(rx1456_pos)
    ge rx1456_pos, rx1456_eos, rxscan1457_done
  rxscan1457_scan:
    set_addr $I10, rxscan1457_loop
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  rxscan1457_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1458_fail
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1456_pos, 6
    gt $I11, rx1456_eos, rx1456_fail
    sub $I11, rx1456_pos, rx1456_off
    substr $S10, rx1456_tgt, $I11, 6
    ne $S10, "unless", rx1456_fail
    add rx1456_pos, 6
    set_addr $I10, rxcap_1458_fail
    ($I12, $I11) = rx1456_cur."!mark_peek"($I10)
    rx1456_cur."!cursor_pos"($I11)
    ($P10) = rx1456_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1456_pos, "")
    rx1456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1458_done
  rxcap_1458_fail:
    goto rx1456_fail
  rxcap_1458_done:
  # rx charclass s
    ge rx1456_pos, rx1456_eos, rx1456_fail
    sub $I10, rx1456_pos, rx1456_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1456_tgt, $I10
    unless $I11, rx1456_fail
    inc rx1456_pos
  # rx subrule "ws" subtype=method negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."ws"()
    unless $P10, rx1456_fail
    rx1456_pos = $P10."pos"()
.annotate 'line', 666
  # rx subrule "xblock" subtype=capture negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."xblock"()
    unless $P10, rx1456_fail
    rx1456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1456_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."ws"()
    unless $P10, rx1456_fail
    rx1456_pos = $P10."pos"()
  alt1459_0:
.annotate 'line', 667
    set_addr $I10, alt1459_1
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."ws"()
    unless $P10, rx1456_fail
    rx1456_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx1456_cur."!cursor_pos"(rx1456_pos)
    .const 'Sub' $P1461 = "106_1325892461.451" 
    capture_lex $P1461
    $P10 = rx1456_cur."before"($P1461)
    if $P10, rx1456_fail
  # rx subrule "ws" subtype=method negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."ws"()
    unless $P10, rx1456_fail
    rx1456_pos = $P10."pos"()
    goto alt1459_end
  alt1459_1:
  # rx subrule "ws" subtype=method negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."ws"()
    unless $P10, rx1456_fail
    rx1456_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx1456_fail
    rx1456_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."ws"()
    unless $P10, rx1456_fail
    rx1456_pos = $P10."pos"()
  alt1459_end:
  # rx subrule "ws" subtype=method negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."ws"()
    unless $P10, rx1456_fail
    rx1456_pos = $P10."pos"()
.annotate 'line', 664
  # rx pass
    rx1456_cur."!cursor_pass"(rx1456_pos, "statement_control:sym<unless>")
    if_null rx1456_debug, debug_1007
    rx1456_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx1456_pos)
  debug_1007:
    .return (rx1456_cur)
  rx1456_restart:
.annotate 'line', 462
    if_null rx1456_debug, debug_1008
    rx1456_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_1008:
  rx1456_fail:
    (rx1456_rep, rx1456_pos, $I10, $P10) = rx1456_cur."!mark_fail"(0)
    lt rx1456_pos, -1, rx1456_done
    eq rx1456_pos, -1, rx1456_fail
    jump $I10
  rx1456_done:
    rx1456_cur."!cursor_fail"()
    if_null rx1456_debug, debug_1009
    rx1456_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_1009:
    .return (rx1456_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1460"  :anon :subid("106_1325892461.451") :method :outer("105_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 667
    .local string rx1462_tgt
    .local int rx1462_pos
    .local int rx1462_off
    .local int rx1462_eos
    .local int rx1462_rep
    .local pmc rx1462_cur
    .local pmc rx1462_debug
    (rx1462_cur, rx1462_pos, rx1462_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1462_cur
    .local pmc match
    .lex "$/", match
    length rx1462_eos, rx1462_tgt
    gt rx1462_pos, rx1462_eos, rx1462_done
    set rx1462_off, 0
    lt rx1462_pos, 2, rx1462_start
    sub rx1462_off, rx1462_pos, 1
    substr rx1462_tgt, rx1462_tgt, rx1462_off
  rx1462_start:
    eq $I10, 1, rx1462_restart
    if_null rx1462_debug, debug_1003
    rx1462_cur."!cursor_debug"("START", "")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1463_done
    goto rxscan1463_scan
  rxscan1463_loop:
    (rx1462_pos) = rx1462_cur."from"()
    inc rx1462_pos
    rx1462_cur."!cursor_from"(rx1462_pos)
    ge rx1462_pos, rx1462_eos, rxscan1463_done
  rxscan1463_scan:
    set_addr $I10, rxscan1463_loop
    rx1462_cur."!mark_push"(0, rx1462_pos, $I10)
  rxscan1463_done:
  # rx literal  "else"
    add $I11, rx1462_pos, 4
    gt $I11, rx1462_eos, rx1462_fail
    sub $I11, rx1462_pos, rx1462_off
    substr $S10, rx1462_tgt, $I11, 4
    ne $S10, "else", rx1462_fail
    add rx1462_pos, 4
  # rx pass
    rx1462_cur."!cursor_pass"(rx1462_pos, "")
    if_null rx1462_debug, debug_1004
    rx1462_cur."!cursor_debug"("PASS", "", " at pos=", rx1462_pos)
  debug_1004:
    .return (rx1462_cur)
  rx1462_restart:
    if_null rx1462_debug, debug_1005
    rx1462_cur."!cursor_debug"("NEXT", "")
  debug_1005:
  rx1462_fail:
    (rx1462_rep, rx1462_pos, $I10, $P10) = rx1462_cur."!mark_fail"(0)
    lt rx1462_pos, -1, rx1462_done
    eq rx1462_pos, -1, rx1462_fail
    jump $I10
  rx1462_done:
    rx1462_cur."!cursor_fail"()
    if_null rx1462_debug, debug_1006
    rx1462_cur."!cursor_debug"("FAIL", "")
  debug_1006:
    .return (rx1462_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("107_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P110, "ResizablePMCArray"
    push $P110, "unless"
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("108_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1466_tgt
    .local int rx1466_pos
    .local int rx1466_off
    .local int rx1466_eos
    .local int rx1466_rep
    .local pmc rx1466_cur
    .local pmc rx1466_debug
    (rx1466_cur, rx1466_pos, rx1466_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1466_cur
    .local pmc match
    .lex "$/", match
    length rx1466_eos, rx1466_tgt
    gt rx1466_pos, rx1466_eos, rx1466_done
    set rx1466_off, 0
    lt rx1466_pos, 2, rx1466_start
    sub rx1466_off, rx1466_pos, 1
    substr rx1466_tgt, rx1466_tgt, rx1466_off
  rx1466_start:
    eq $I10, 1, rx1466_restart
    if_null rx1466_debug, debug_1010
    rx1466_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_1010:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1467_done
    goto rxscan1467_scan
  rxscan1467_loop:
    (rx1466_pos) = rx1466_cur."from"()
    inc rx1466_pos
    rx1466_cur."!cursor_from"(rx1466_pos)
    ge rx1466_pos, rx1466_eos, rxscan1467_done
  rxscan1467_scan:
    set_addr $I10, rxscan1467_loop
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  rxscan1467_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1469_fail
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  alt1468_0:
    set_addr $I10, alt1468_1
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  # rx literal  "while"
    add $I11, rx1466_pos, 5
    gt $I11, rx1466_eos, rx1466_fail
    sub $I11, rx1466_pos, rx1466_off
    substr $S10, rx1466_tgt, $I11, 5
    ne $S10, "while", rx1466_fail
    add rx1466_pos, 5
    goto alt1468_end
  alt1468_1:
  # rx literal  "until"
    add $I11, rx1466_pos, 5
    gt $I11, rx1466_eos, rx1466_fail
    sub $I11, rx1466_pos, rx1466_off
    substr $S10, rx1466_tgt, $I11, 5
    ne $S10, "until", rx1466_fail
    add rx1466_pos, 5
  alt1468_end:
    set_addr $I10, rxcap_1469_fail
    ($I12, $I11) = rx1466_cur."!mark_peek"($I10)
    rx1466_cur."!cursor_pos"($I11)
    ($P10) = rx1466_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1466_pos, "")
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1469_done
  rxcap_1469_fail:
    goto rx1466_fail
  rxcap_1469_done:
  # rx charclass s
    ge rx1466_pos, rx1466_eos, rx1466_fail
    sub $I10, rx1466_pos, rx1466_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1466_tgt, $I10
    unless $I11, rx1466_fail
    inc rx1466_pos
  # rx subrule "ws" subtype=method negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."ws"()
    unless $P10, rx1466_fail
    rx1466_pos = $P10."pos"()
.annotate 'line', 672
  # rx subrule "xblock" subtype=capture negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."xblock"()
    unless $P10, rx1466_fail
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1466_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."ws"()
    unless $P10, rx1466_fail
    rx1466_pos = $P10."pos"()
.annotate 'line', 670
  # rx pass
    rx1466_cur."!cursor_pass"(rx1466_pos, "statement_control:sym<while>")
    if_null rx1466_debug, debug_1011
    rx1466_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx1466_pos)
  debug_1011:
    .return (rx1466_cur)
  rx1466_restart:
.annotate 'line', 462
    if_null rx1466_debug, debug_1012
    rx1466_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_1012:
  rx1466_fail:
    (rx1466_rep, rx1466_pos, $I10, $P10) = rx1466_cur."!mark_fail"(0)
    lt rx1466_pos, -1, rx1466_done
    eq rx1466_pos, -1, rx1466_fail
    jump $I10
  rx1466_done:
    rx1466_cur."!cursor_fail"()
    if_null rx1466_debug, debug_1013
    rx1466_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_1013:
    .return (rx1466_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("109_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P105, "ResizablePMCArray"
    push $P105, "until"
    push $P105, "while"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("110_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1472_tgt
    .local int rx1472_pos
    .local int rx1472_off
    .local int rx1472_eos
    .local int rx1472_rep
    .local pmc rx1472_cur
    .local pmc rx1472_debug
    (rx1472_cur, rx1472_pos, rx1472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1472_cur
    .local pmc match
    .lex "$/", match
    length rx1472_eos, rx1472_tgt
    gt rx1472_pos, rx1472_eos, rx1472_done
    set rx1472_off, 0
    lt rx1472_pos, 2, rx1472_start
    sub rx1472_off, rx1472_pos, 1
    substr rx1472_tgt, rx1472_tgt, rx1472_off
  rx1472_start:
    eq $I10, 1, rx1472_restart
    if_null rx1472_debug, debug_1014
    rx1472_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_1014:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1473_done
    goto rxscan1473_scan
  rxscan1473_loop:
    (rx1472_pos) = rx1472_cur."from"()
    inc rx1472_pos
    rx1472_cur."!cursor_from"(rx1472_pos)
    ge rx1472_pos, rx1472_eos, rxscan1473_done
  rxscan1473_scan:
    set_addr $I10, rxscan1473_loop
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  rxscan1473_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_1474_fail
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx1472_pos, 6
    gt $I11, rx1472_eos, rx1472_fail
    sub $I11, rx1472_pos, rx1472_off
    substr $S10, rx1472_tgt, $I11, 6
    ne $S10, "repeat", rx1472_fail
    add rx1472_pos, 6
    set_addr $I10, rxcap_1474_fail
    ($I12, $I11) = rx1472_cur."!mark_peek"($I10)
    rx1472_cur."!cursor_pos"($I11)
    ($P10) = rx1472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1472_pos, "")
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1474_done
  rxcap_1474_fail:
    goto rx1472_fail
  rxcap_1474_done:
  # rx charclass s
    ge rx1472_pos, rx1472_eos, rx1472_fail
    sub $I10, rx1472_pos, rx1472_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1472_tgt, $I10
    unless $I11, rx1472_fail
    inc rx1472_pos
  # rx subrule "ws" subtype=method negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."ws"()
    unless $P10, rx1472_fail
    rx1472_pos = $P10."pos"()
  alt1475_0:
.annotate 'line', 677
    set_addr $I10, alt1475_1
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
.annotate 'line', 678
  # rx subrule "ws" subtype=method negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."ws"()
    unless $P10, rx1472_fail
    rx1472_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1477_fail
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  alt1476_0:
    set_addr $I10, alt1476_1
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  # rx literal  "while"
    add $I11, rx1472_pos, 5
    gt $I11, rx1472_eos, rx1472_fail
    sub $I11, rx1472_pos, rx1472_off
    substr $S10, rx1472_tgt, $I11, 5
    ne $S10, "while", rx1472_fail
    add rx1472_pos, 5
    goto alt1476_end
  alt1476_1:
  # rx literal  "until"
    add $I11, rx1472_pos, 5
    gt $I11, rx1472_eos, rx1472_fail
    sub $I11, rx1472_pos, rx1472_off
    substr $S10, rx1472_tgt, $I11, 5
    ne $S10, "until", rx1472_fail
    add rx1472_pos, 5
  alt1476_end:
    set_addr $I10, rxcap_1477_fail
    ($I12, $I11) = rx1472_cur."!mark_peek"($I10)
    rx1472_cur."!cursor_pos"($I11)
    ($P10) = rx1472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1472_pos, "")
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1477_done
  rxcap_1477_fail:
    goto rx1472_fail
  rxcap_1477_done:
  # rx charclass s
    ge rx1472_pos, rx1472_eos, rx1472_fail
    sub $I10, rx1472_pos, rx1472_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1472_tgt, $I10
    unless $I11, rx1472_fail
    inc rx1472_pos
  # rx subrule "ws" subtype=method negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."ws"()
    unless $P10, rx1472_fail
    rx1472_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."xblock"()
    unless $P10, rx1472_fail
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."ws"()
    unless $P10, rx1472_fail
    rx1472_pos = $P10."pos"()
    goto alt1475_end
  alt1475_1:
.annotate 'line', 679
  # rx subrule "ws" subtype=method negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."ws"()
    unless $P10, rx1472_fail
    rx1472_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."pblock"()
    unless $P10, rx1472_fail
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."ws"()
    unless $P10, rx1472_fail
    rx1472_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_1479_fail
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  alt1478_0:
    set_addr $I10, alt1478_1
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  # rx literal  "while"
    add $I11, rx1472_pos, 5
    gt $I11, rx1472_eos, rx1472_fail
    sub $I11, rx1472_pos, rx1472_off
    substr $S10, rx1472_tgt, $I11, 5
    ne $S10, "while", rx1472_fail
    add rx1472_pos, 5
    goto alt1478_end
  alt1478_1:
  # rx literal  "until"
    add $I11, rx1472_pos, 5
    gt $I11, rx1472_eos, rx1472_fail
    sub $I11, rx1472_pos, rx1472_off
    substr $S10, rx1472_tgt, $I11, 5
    ne $S10, "until", rx1472_fail
    add rx1472_pos, 5
  alt1478_end:
    set_addr $I10, rxcap_1479_fail
    ($I12, $I11) = rx1472_cur."!mark_peek"($I10)
    rx1472_cur."!cursor_pos"($I11)
    ($P10) = rx1472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1472_pos, "")
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_1479_done
  rxcap_1479_fail:
    goto rx1472_fail
  rxcap_1479_done:
  # rx charclass s
    ge rx1472_pos, rx1472_eos, rx1472_fail
    sub $I10, rx1472_pos, rx1472_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1472_tgt, $I10
    unless $I11, rx1472_fail
    inc rx1472_pos
  # rx subrule "ws" subtype=method negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."ws"()
    unless $P10, rx1472_fail
    rx1472_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."EXPR"()
    unless $P10, rx1472_fail
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."ws"()
    unless $P10, rx1472_fail
    rx1472_pos = $P10."pos"()
  alt1475_end:
.annotate 'line', 680
  # rx subrule "ws" subtype=method negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."ws"()
    unless $P10, rx1472_fail
    rx1472_pos = $P10."pos"()
.annotate 'line', 675
  # rx pass
    rx1472_cur."!cursor_pass"(rx1472_pos, "statement_control:sym<repeat>")
    if_null rx1472_debug, debug_1015
    rx1472_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx1472_pos)
  debug_1015:
    .return (rx1472_cur)
  rx1472_restart:
.annotate 'line', 462
    if_null rx1472_debug, debug_1016
    rx1472_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_1016:
  rx1472_fail:
    (rx1472_rep, rx1472_pos, $I10, $P10) = rx1472_cur."!mark_fail"(0)
    lt rx1472_pos, -1, rx1472_done
    eq rx1472_pos, -1, rx1472_fail
    jump $I10
  rx1472_done:
    rx1472_cur."!cursor_fail"()
    if_null rx1472_debug, debug_1017
    rx1472_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_1017:
    .return (rx1472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("111_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P112, "ResizablePMCArray"
    push $P112, "repeat"
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("112_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1482_tgt
    .local int rx1482_pos
    .local int rx1482_off
    .local int rx1482_eos
    .local int rx1482_rep
    .local pmc rx1482_cur
    .local pmc rx1482_debug
    (rx1482_cur, rx1482_pos, rx1482_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1482_cur
    .local pmc match
    .lex "$/", match
    length rx1482_eos, rx1482_tgt
    gt rx1482_pos, rx1482_eos, rx1482_done
    set rx1482_off, 0
    lt rx1482_pos, 2, rx1482_start
    sub rx1482_off, rx1482_pos, 1
    substr rx1482_tgt, rx1482_tgt, rx1482_off
  rx1482_start:
    eq $I10, 1, rx1482_restart
    if_null rx1482_debug, debug_1018
    rx1482_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_1018:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1483_done
    goto rxscan1483_scan
  rxscan1483_loop:
    (rx1482_pos) = rx1482_cur."from"()
    inc rx1482_pos
    rx1482_cur."!cursor_from"(rx1482_pos)
    ge rx1482_pos, rx1482_eos, rxscan1483_done
  rxscan1483_scan:
    set_addr $I10, rxscan1483_loop
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  rxscan1483_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1484_fail
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  # rx literal  "for"
    add $I11, rx1482_pos, 3
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    substr $S10, rx1482_tgt, $I11, 3
    ne $S10, "for", rx1482_fail
    add rx1482_pos, 3
    set_addr $I10, rxcap_1484_fail
    ($I12, $I11) = rx1482_cur."!mark_peek"($I10)
    rx1482_cur."!cursor_pos"($I11)
    ($P10) = rx1482_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1482_pos, "")
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1484_done
  rxcap_1484_fail:
    goto rx1482_fail
  rxcap_1484_done:
  # rx charclass s
    ge rx1482_pos, rx1482_eos, rx1482_fail
    sub $I10, rx1482_pos, rx1482_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1482_tgt, $I10
    unless $I11, rx1482_fail
    inc rx1482_pos
  # rx subrule "ws" subtype=method negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."ws"()
    unless $P10, rx1482_fail
    rx1482_pos = $P10."pos"()
.annotate 'line', 685
  # rx subrule "xblock" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."xblock"()
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx1482_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."ws"()
    unless $P10, rx1482_fail
    rx1482_pos = $P10."pos"()
.annotate 'line', 683
  # rx pass
    rx1482_cur."!cursor_pass"(rx1482_pos, "statement_control:sym<for>")
    if_null rx1482_debug, debug_1019
    rx1482_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx1482_pos)
  debug_1019:
    .return (rx1482_cur)
  rx1482_restart:
.annotate 'line', 462
    if_null rx1482_debug, debug_1020
    rx1482_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_1020:
  rx1482_fail:
    (rx1482_rep, rx1482_pos, $I10, $P10) = rx1482_cur."!mark_fail"(0)
    lt rx1482_pos, -1, rx1482_done
    eq rx1482_pos, -1, rx1482_fail
    jump $I10
  rx1482_done:
    rx1482_cur."!cursor_fail"()
    if_null rx1482_debug, debug_1021
    rx1482_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_1021:
    .return (rx1482_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("113_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P105, "ResizablePMCArray"
    push $P105, "for"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("114_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1487_tgt
    .local int rx1487_pos
    .local int rx1487_off
    .local int rx1487_eos
    .local int rx1487_rep
    .local pmc rx1487_cur
    .local pmc rx1487_debug
    (rx1487_cur, rx1487_pos, rx1487_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1487_cur
    .local pmc match
    .lex "$/", match
    length rx1487_eos, rx1487_tgt
    gt rx1487_pos, rx1487_eos, rx1487_done
    set rx1487_off, 0
    lt rx1487_pos, 2, rx1487_start
    sub rx1487_off, rx1487_pos, 1
    substr rx1487_tgt, rx1487_tgt, rx1487_off
  rx1487_start:
    eq $I10, 1, rx1487_restart
    if_null rx1487_debug, debug_1022
    rx1487_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_1022:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1488_done
    goto rxscan1488_scan
  rxscan1488_loop:
    (rx1487_pos) = rx1487_cur."from"()
    inc rx1487_pos
    rx1487_cur."!cursor_from"(rx1487_pos)
    ge rx1487_pos, rx1487_eos, rxscan1488_done
  rxscan1488_scan:
    set_addr $I10, rxscan1488_loop
    rx1487_cur."!mark_push"(0, rx1487_pos, $I10)
  rxscan1488_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1489_fail
    rx1487_cur."!mark_push"(0, rx1487_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx1487_pos, 5
    gt $I11, rx1487_eos, rx1487_fail
    sub $I11, rx1487_pos, rx1487_off
    substr $S10, rx1487_tgt, $I11, 5
    ne $S10, "CATCH", rx1487_fail
    add rx1487_pos, 5
    set_addr $I10, rxcap_1489_fail
    ($I12, $I11) = rx1487_cur."!mark_peek"($I10)
    rx1487_cur."!cursor_pos"($I11)
    ($P10) = rx1487_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1487_pos, "")
    rx1487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1489_done
  rxcap_1489_fail:
    goto rx1487_fail
  rxcap_1489_done:
  # rx charclass s
    ge rx1487_pos, rx1487_eos, rx1487_fail
    sub $I10, rx1487_pos, rx1487_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1487_tgt, $I10
    unless $I11, rx1487_fail
    inc rx1487_pos
  # rx subrule "ws" subtype=method negate=
    rx1487_cur."!cursor_pos"(rx1487_pos)
    $P10 = rx1487_cur."ws"()
    unless $P10, rx1487_fail
    rx1487_pos = $P10."pos"()
.annotate 'line', 690
  # rx subrule "block" subtype=capture negate=
    rx1487_cur."!cursor_pos"(rx1487_pos)
    $P10 = rx1487_cur."block"()
    unless $P10, rx1487_fail
    rx1487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1487_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1487_cur."!cursor_pos"(rx1487_pos)
    $P10 = rx1487_cur."ws"()
    unless $P10, rx1487_fail
    rx1487_pos = $P10."pos"()
.annotate 'line', 688
  # rx pass
    rx1487_cur."!cursor_pass"(rx1487_pos, "statement_control:sym<CATCH>")
    if_null rx1487_debug, debug_1023
    rx1487_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx1487_pos)
  debug_1023:
    .return (rx1487_cur)
  rx1487_restart:
.annotate 'line', 462
    if_null rx1487_debug, debug_1024
    rx1487_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_1024:
  rx1487_fail:
    (rx1487_rep, rx1487_pos, $I10, $P10) = rx1487_cur."!mark_fail"(0)
    lt rx1487_pos, -1, rx1487_done
    eq rx1487_pos, -1, rx1487_fail
    jump $I10
  rx1487_done:
    rx1487_cur."!cursor_fail"()
    if_null rx1487_debug, debug_1025
    rx1487_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_1025:
    .return (rx1487_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("115_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P105, "ResizablePMCArray"
    push $P105, "CATCH"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("116_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1492_tgt
    .local int rx1492_pos
    .local int rx1492_off
    .local int rx1492_eos
    .local int rx1492_rep
    .local pmc rx1492_cur
    .local pmc rx1492_debug
    (rx1492_cur, rx1492_pos, rx1492_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1492_cur
    .local pmc match
    .lex "$/", match
    length rx1492_eos, rx1492_tgt
    gt rx1492_pos, rx1492_eos, rx1492_done
    set rx1492_off, 0
    lt rx1492_pos, 2, rx1492_start
    sub rx1492_off, rx1492_pos, 1
    substr rx1492_tgt, rx1492_tgt, rx1492_off
  rx1492_start:
    eq $I10, 1, rx1492_restart
    if_null rx1492_debug, debug_1026
    rx1492_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_1026:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1493_done
    goto rxscan1493_scan
  rxscan1493_loop:
    (rx1492_pos) = rx1492_cur."from"()
    inc rx1492_pos
    rx1492_cur."!cursor_from"(rx1492_pos)
    ge rx1492_pos, rx1492_eos, rxscan1493_done
  rxscan1493_scan:
    set_addr $I10, rxscan1493_loop
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  rxscan1493_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1494_fail
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx1492_pos, 7
    gt $I11, rx1492_eos, rx1492_fail
    sub $I11, rx1492_pos, rx1492_off
    substr $S10, rx1492_tgt, $I11, 7
    ne $S10, "CONTROL", rx1492_fail
    add rx1492_pos, 7
    set_addr $I10, rxcap_1494_fail
    ($I12, $I11) = rx1492_cur."!mark_peek"($I10)
    rx1492_cur."!cursor_pos"($I11)
    ($P10) = rx1492_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1492_pos, "")
    rx1492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1494_done
  rxcap_1494_fail:
    goto rx1492_fail
  rxcap_1494_done:
  # rx charclass s
    ge rx1492_pos, rx1492_eos, rx1492_fail
    sub $I10, rx1492_pos, rx1492_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1492_tgt, $I10
    unless $I11, rx1492_fail
    inc rx1492_pos
  # rx subrule "ws" subtype=method negate=
    rx1492_cur."!cursor_pos"(rx1492_pos)
    $P10 = rx1492_cur."ws"()
    unless $P10, rx1492_fail
    rx1492_pos = $P10."pos"()
.annotate 'line', 695
  # rx subrule "block" subtype=capture negate=
    rx1492_cur."!cursor_pos"(rx1492_pos)
    $P10 = rx1492_cur."block"()
    unless $P10, rx1492_fail
    rx1492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1492_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1492_cur."!cursor_pos"(rx1492_pos)
    $P10 = rx1492_cur."ws"()
    unless $P10, rx1492_fail
    rx1492_pos = $P10."pos"()
.annotate 'line', 693
  # rx pass
    rx1492_cur."!cursor_pass"(rx1492_pos, "statement_control:sym<CONTROL>")
    if_null rx1492_debug, debug_1027
    rx1492_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx1492_pos)
  debug_1027:
    .return (rx1492_cur)
  rx1492_restart:
.annotate 'line', 462
    if_null rx1492_debug, debug_1028
    rx1492_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_1028:
  rx1492_fail:
    (rx1492_rep, rx1492_pos, $I10, $P10) = rx1492_cur."!mark_fail"(0)
    lt rx1492_pos, -1, rx1492_done
    eq rx1492_pos, -1, rx1492_fail
    jump $I10
  rx1492_done:
    rx1492_cur."!cursor_fail"()
    if_null rx1492_debug, debug_1029
    rx1492_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_1029:
    .return (rx1492_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("117_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P105, "ResizablePMCArray"
    push $P105, "CONTROL"
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("118_1325892461.451")
    .param pmc param_1497
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 698
    .lex "self", param_1497
    $P103 = param_1497."!protoregex"("statement_prefix")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("119_1325892461.451")
    .param pmc param_1499
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 698
    .lex "self", param_1499
    $P104 = param_1499."!PREFIX__!protoregex"("statement_prefix")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("120_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1501_tgt
    .local int rx1501_pos
    .local int rx1501_off
    .local int rx1501_eos
    .local int rx1501_rep
    .local pmc rx1501_cur
    .local pmc rx1501_debug
    (rx1501_cur, rx1501_pos, rx1501_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1501_cur
    .local pmc match
    .lex "$/", match
    length rx1501_eos, rx1501_tgt
    gt rx1501_pos, rx1501_eos, rx1501_done
    set rx1501_off, 0
    lt rx1501_pos, 2, rx1501_start
    sub rx1501_off, rx1501_pos, 1
    substr rx1501_tgt, rx1501_tgt, rx1501_off
  rx1501_start:
    eq $I10, 1, rx1501_restart
    if_null rx1501_debug, debug_1030
    rx1501_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_1030:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1502_done
    goto rxscan1502_scan
  rxscan1502_loop:
    (rx1501_pos) = rx1501_cur."from"()
    inc rx1501_pos
    rx1501_cur."!cursor_from"(rx1501_pos)
    ge rx1501_pos, rx1501_eos, rxscan1502_done
  rxscan1502_scan:
    set_addr $I10, rxscan1502_loop
    rx1501_cur."!mark_push"(0, rx1501_pos, $I10)
  rxscan1502_done:
.annotate 'line', 699
  # rx subcapture "sym"
    set_addr $I10, rxcap_1503_fail
    rx1501_cur."!mark_push"(0, rx1501_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx1501_pos, 4
    gt $I11, rx1501_eos, rx1501_fail
    sub $I11, rx1501_pos, rx1501_off
    substr $S10, rx1501_tgt, $I11, 4
    ne $S10, "INIT", rx1501_fail
    add rx1501_pos, 4
    set_addr $I10, rxcap_1503_fail
    ($I12, $I11) = rx1501_cur."!mark_peek"($I10)
    rx1501_cur."!cursor_pos"($I11)
    ($P10) = rx1501_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1501_pos, "")
    rx1501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1503_done
  rxcap_1503_fail:
    goto rx1501_fail
  rxcap_1503_done:
  # rx subrule "blorst" subtype=capture negate=
    rx1501_cur."!cursor_pos"(rx1501_pos)
    $P10 = rx1501_cur."blorst"()
    unless $P10, rx1501_fail
    rx1501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1501_pos = $P10."pos"()
  # rx pass
    rx1501_cur."!cursor_pass"(rx1501_pos, "statement_prefix:sym<INIT>")
    if_null rx1501_debug, debug_1031
    rx1501_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx1501_pos)
  debug_1031:
    .return (rx1501_cur)
  rx1501_restart:
.annotate 'line', 462
    if_null rx1501_debug, debug_1032
    rx1501_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_1032:
  rx1501_fail:
    (rx1501_rep, rx1501_pos, $I10, $P10) = rx1501_cur."!mark_fail"(0)
    lt rx1501_pos, -1, rx1501_done
    eq rx1501_pos, -1, rx1501_fail
    jump $I10
  rx1501_done:
    rx1501_cur."!cursor_fail"()
    if_null rx1501_debug, debug_1033
    rx1501_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_1033:
    .return (rx1501_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("121_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("122_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1506_tgt
    .local int rx1506_pos
    .local int rx1506_off
    .local int rx1506_eos
    .local int rx1506_rep
    .local pmc rx1506_cur
    .local pmc rx1506_debug
    (rx1506_cur, rx1506_pos, rx1506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1506_cur
    .local pmc match
    .lex "$/", match
    length rx1506_eos, rx1506_tgt
    gt rx1506_pos, rx1506_eos, rx1506_done
    set rx1506_off, 0
    lt rx1506_pos, 2, rx1506_start
    sub rx1506_off, rx1506_pos, 1
    substr rx1506_tgt, rx1506_tgt, rx1506_off
  rx1506_start:
    eq $I10, 1, rx1506_restart
    if_null rx1506_debug, debug_1034
    rx1506_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_1034:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1507_done
    goto rxscan1507_scan
  rxscan1507_loop:
    (rx1506_pos) = rx1506_cur."from"()
    inc rx1506_pos
    rx1506_cur."!cursor_from"(rx1506_pos)
    ge rx1506_pos, rx1506_eos, rxscan1507_done
  rxscan1507_scan:
    set_addr $I10, rxscan1507_loop
    rx1506_cur."!mark_push"(0, rx1506_pos, $I10)
  rxscan1507_done:
.annotate 'line', 702
  # rx subcapture "sym"
    set_addr $I10, rxcap_1508_fail
    rx1506_cur."!mark_push"(0, rx1506_pos, $I10)
  # rx literal  "try"
    add $I11, rx1506_pos, 3
    gt $I11, rx1506_eos, rx1506_fail
    sub $I11, rx1506_pos, rx1506_off
    substr $S10, rx1506_tgt, $I11, 3
    ne $S10, "try", rx1506_fail
    add rx1506_pos, 3
    set_addr $I10, rxcap_1508_fail
    ($I12, $I11) = rx1506_cur."!mark_peek"($I10)
    rx1506_cur."!cursor_pos"($I11)
    ($P10) = rx1506_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1506_pos, "")
    rx1506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1508_done
  rxcap_1508_fail:
    goto rx1506_fail
  rxcap_1508_done:
.annotate 'line', 703
  # rx subrule "blorst" subtype=capture negate=
    rx1506_cur."!cursor_pos"(rx1506_pos)
    $P10 = rx1506_cur."blorst"()
    unless $P10, rx1506_fail
    rx1506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx1506_pos = $P10."pos"()
.annotate 'line', 701
  # rx pass
    rx1506_cur."!cursor_pass"(rx1506_pos, "statement_prefix:sym<try>")
    if_null rx1506_debug, debug_1035
    rx1506_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx1506_pos)
  debug_1035:
    .return (rx1506_cur)
  rx1506_restart:
.annotate 'line', 462
    if_null rx1506_debug, debug_1036
    rx1506_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_1036:
  rx1506_fail:
    (rx1506_rep, rx1506_pos, $I10, $P10) = rx1506_cur."!mark_fail"(0)
    lt rx1506_pos, -1, rx1506_done
    eq rx1506_pos, -1, rx1506_fail
    jump $I10
  rx1506_done:
    rx1506_cur."!cursor_fail"()
    if_null rx1506_debug, debug_1037
    rx1506_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_1037:
    .return (rx1506_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("123_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("blorst", "try")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("124_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1511_tgt
    .local int rx1511_pos
    .local int rx1511_off
    .local int rx1511_eos
    .local int rx1511_rep
    .local pmc rx1511_cur
    .local pmc rx1511_debug
    (rx1511_cur, rx1511_pos, rx1511_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1511_cur
    .local pmc match
    .lex "$/", match
    length rx1511_eos, rx1511_tgt
    gt rx1511_pos, rx1511_eos, rx1511_done
    set rx1511_off, 0
    lt rx1511_pos, 2, rx1511_start
    sub rx1511_off, rx1511_pos, 1
    substr rx1511_tgt, rx1511_tgt, rx1511_off
  rx1511_start:
    eq $I10, 1, rx1511_restart
    if_null rx1511_debug, debug_1038
    rx1511_cur."!cursor_debug"("START", "blorst")
  debug_1038:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1512_done
    goto rxscan1512_scan
  rxscan1512_loop:
    (rx1511_pos) = rx1511_cur."from"()
    inc rx1511_pos
    rx1511_cur."!cursor_from"(rx1511_pos)
    ge rx1511_pos, rx1511_eos, rxscan1512_done
  rxscan1512_scan:
    set_addr $I10, rxscan1512_loop
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxscan1512_done:
.annotate 'line', 707
  # rx charclass s
    ge rx1511_pos, rx1511_eos, rx1511_fail
    sub $I10, rx1511_pos, rx1511_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1511_tgt, $I10
    unless $I11, rx1511_fail
    inc rx1511_pos
  # rx subrule "ws" subtype=method negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."ws"()
    unless $P10, rx1511_fail
    rx1511_pos = $P10."pos"()
  alt1513_0:
    set_addr $I10, alt1513_1
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1511_pos, rx1511_off
    substr $S10, rx1511_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1511_fail
  # rx subrule "block" subtype=capture negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."block"()
    unless $P10, rx1511_fail
    rx1511_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1511_pos = $P10."pos"()
    goto alt1513_end
  alt1513_1:
  # rx subrule "statement" subtype=capture negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."statement"()
    unless $P10, rx1511_fail
    rx1511_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1511_pos = $P10."pos"()
  alt1513_end:
.annotate 'line', 706
  # rx pass
    rx1511_cur."!cursor_pass"(rx1511_pos, "blorst")
    if_null rx1511_debug, debug_1039
    rx1511_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx1511_pos)
  debug_1039:
    .return (rx1511_cur)
  rx1511_restart:
.annotate 'line', 462
    if_null rx1511_debug, debug_1040
    rx1511_cur."!cursor_debug"("NEXT", "blorst")
  debug_1040:
  rx1511_fail:
    (rx1511_rep, rx1511_pos, $I10, $P10) = rx1511_cur."!mark_fail"(0)
    lt rx1511_pos, -1, rx1511_done
    eq rx1511_pos, -1, rx1511_fail
    jump $I10
  rx1511_done:
    rx1511_cur."!cursor_fail"()
    if_null rx1511_debug, debug_1041
    rx1511_cur."!cursor_debug"("FAIL", "blorst")
  debug_1041:
    .return (rx1511_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("125_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("126_1325892461.451")
    .param pmc param_1516
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 712
    .lex "self", param_1516
    $P103 = param_1516."!protoregex"("statement_mod_cond")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("127_1325892461.451")
    .param pmc param_1518
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 712
    .lex "self", param_1518
    $P104 = param_1518."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("128_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1520_tgt
    .local int rx1520_pos
    .local int rx1520_off
    .local int rx1520_eos
    .local int rx1520_rep
    .local pmc rx1520_cur
    .local pmc rx1520_debug
    (rx1520_cur, rx1520_pos, rx1520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1520_cur
    .local pmc match
    .lex "$/", match
    length rx1520_eos, rx1520_tgt
    gt rx1520_pos, rx1520_eos, rx1520_done
    set rx1520_off, 0
    lt rx1520_pos, 2, rx1520_start
    sub rx1520_off, rx1520_pos, 1
    substr rx1520_tgt, rx1520_tgt, rx1520_off
  rx1520_start:
    eq $I10, 1, rx1520_restart
    if_null rx1520_debug, debug_1042
    rx1520_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_1042:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1521_done
    goto rxscan1521_scan
  rxscan1521_loop:
    (rx1520_pos) = rx1520_cur."from"()
    inc rx1520_pos
    rx1520_cur."!cursor_from"(rx1520_pos)
    ge rx1520_pos, rx1520_eos, rxscan1521_done
  rxscan1521_scan:
    set_addr $I10, rxscan1521_loop
    rx1520_cur."!mark_push"(0, rx1520_pos, $I10)
  rxscan1521_done:
.annotate 'line', 714
  # rx subcapture "sym"
    set_addr $I10, rxcap_1522_fail
    rx1520_cur."!mark_push"(0, rx1520_pos, $I10)
  # rx literal  "if"
    add $I11, rx1520_pos, 2
    gt $I11, rx1520_eos, rx1520_fail
    sub $I11, rx1520_pos, rx1520_off
    substr $S10, rx1520_tgt, $I11, 2
    ne $S10, "if", rx1520_fail
    add rx1520_pos, 2
    set_addr $I10, rxcap_1522_fail
    ($I12, $I11) = rx1520_cur."!mark_peek"($I10)
    rx1520_cur."!cursor_pos"($I11)
    ($P10) = rx1520_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1520_pos, "")
    rx1520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1522_done
  rxcap_1522_fail:
    goto rx1520_fail
  rxcap_1522_done:
  # rx subrule "ws" subtype=method negate=
    rx1520_cur."!cursor_pos"(rx1520_pos)
    $P10 = rx1520_cur."ws"()
    unless $P10, rx1520_fail
    rx1520_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1520_cur."!cursor_pos"(rx1520_pos)
    $P10 = rx1520_cur."EXPR"()
    unless $P10, rx1520_fail
    rx1520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1520_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1520_cur."!cursor_pos"(rx1520_pos)
    $P10 = rx1520_cur."ws"()
    unless $P10, rx1520_fail
    rx1520_pos = $P10."pos"()
  # rx pass
    rx1520_cur."!cursor_pass"(rx1520_pos, "statement_mod_cond:sym<if>")
    if_null rx1520_debug, debug_1043
    rx1520_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx1520_pos)
  debug_1043:
    .return (rx1520_cur)
  rx1520_restart:
.annotate 'line', 462
    if_null rx1520_debug, debug_1044
    rx1520_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_1044:
  rx1520_fail:
    (rx1520_rep, rx1520_pos, $I10, $P10) = rx1520_cur."!mark_fail"(0)
    lt rx1520_pos, -1, rx1520_done
    eq rx1520_pos, -1, rx1520_fail
    jump $I10
  rx1520_done:
    rx1520_cur."!cursor_fail"()
    if_null rx1520_debug, debug_1045
    rx1520_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_1045:
    .return (rx1520_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("129_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("ws", "if")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("130_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1525_tgt
    .local int rx1525_pos
    .local int rx1525_off
    .local int rx1525_eos
    .local int rx1525_rep
    .local pmc rx1525_cur
    .local pmc rx1525_debug
    (rx1525_cur, rx1525_pos, rx1525_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1525_cur
    .local pmc match
    .lex "$/", match
    length rx1525_eos, rx1525_tgt
    gt rx1525_pos, rx1525_eos, rx1525_done
    set rx1525_off, 0
    lt rx1525_pos, 2, rx1525_start
    sub rx1525_off, rx1525_pos, 1
    substr rx1525_tgt, rx1525_tgt, rx1525_off
  rx1525_start:
    eq $I10, 1, rx1525_restart
    if_null rx1525_debug, debug_1046
    rx1525_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_1046:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1526_done
    goto rxscan1526_scan
  rxscan1526_loop:
    (rx1525_pos) = rx1525_cur."from"()
    inc rx1525_pos
    rx1525_cur."!cursor_from"(rx1525_pos)
    ge rx1525_pos, rx1525_eos, rxscan1526_done
  rxscan1526_scan:
    set_addr $I10, rxscan1526_loop
    rx1525_cur."!mark_push"(0, rx1525_pos, $I10)
  rxscan1526_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1527_fail
    rx1525_cur."!mark_push"(0, rx1525_pos, $I10)
  # rx literal  "unless"
    add $I11, rx1525_pos, 6
    gt $I11, rx1525_eos, rx1525_fail
    sub $I11, rx1525_pos, rx1525_off
    substr $S10, rx1525_tgt, $I11, 6
    ne $S10, "unless", rx1525_fail
    add rx1525_pos, 6
    set_addr $I10, rxcap_1527_fail
    ($I12, $I11) = rx1525_cur."!mark_peek"($I10)
    rx1525_cur."!cursor_pos"($I11)
    ($P10) = rx1525_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1525_pos, "")
    rx1525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1527_done
  rxcap_1527_fail:
    goto rx1525_fail
  rxcap_1527_done:
  # rx subrule "ws" subtype=method negate=
    rx1525_cur."!cursor_pos"(rx1525_pos)
    $P10 = rx1525_cur."ws"()
    unless $P10, rx1525_fail
    rx1525_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1525_cur."!cursor_pos"(rx1525_pos)
    $P10 = rx1525_cur."EXPR"()
    unless $P10, rx1525_fail
    rx1525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1525_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1525_cur."!cursor_pos"(rx1525_pos)
    $P10 = rx1525_cur."ws"()
    unless $P10, rx1525_fail
    rx1525_pos = $P10."pos"()
  # rx pass
    rx1525_cur."!cursor_pass"(rx1525_pos, "statement_mod_cond:sym<unless>")
    if_null rx1525_debug, debug_1047
    rx1525_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx1525_pos)
  debug_1047:
    .return (rx1525_cur)
  rx1525_restart:
.annotate 'line', 462
    if_null rx1525_debug, debug_1048
    rx1525_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_1048:
  rx1525_fail:
    (rx1525_rep, rx1525_pos, $I10, $P10) = rx1525_cur."!mark_fail"(0)
    lt rx1525_pos, -1, rx1525_done
    eq rx1525_pos, -1, rx1525_fail
    jump $I10
  rx1525_done:
    rx1525_cur."!cursor_fail"()
    if_null rx1525_debug, debug_1049
    rx1525_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_1049:
    .return (rx1525_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("131_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("ws", "unless")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("132_1325892461.451")
    .param pmc param_1530
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 717
    .lex "self", param_1530
    $P103 = param_1530."!protoregex"("statement_mod_loop")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("133_1325892461.451")
    .param pmc param_1532
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 717
    .lex "self", param_1532
    $P104 = param_1532."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("134_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1534_tgt
    .local int rx1534_pos
    .local int rx1534_off
    .local int rx1534_eos
    .local int rx1534_rep
    .local pmc rx1534_cur
    .local pmc rx1534_debug
    (rx1534_cur, rx1534_pos, rx1534_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1534_cur
    .local pmc match
    .lex "$/", match
    length rx1534_eos, rx1534_tgt
    gt rx1534_pos, rx1534_eos, rx1534_done
    set rx1534_off, 0
    lt rx1534_pos, 2, rx1534_start
    sub rx1534_off, rx1534_pos, 1
    substr rx1534_tgt, rx1534_tgt, rx1534_off
  rx1534_start:
    eq $I10, 1, rx1534_restart
    if_null rx1534_debug, debug_1050
    rx1534_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_1050:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1535_done
    goto rxscan1535_scan
  rxscan1535_loop:
    (rx1534_pos) = rx1534_cur."from"()
    inc rx1534_pos
    rx1534_cur."!cursor_from"(rx1534_pos)
    ge rx1534_pos, rx1534_eos, rxscan1535_done
  rxscan1535_scan:
    set_addr $I10, rxscan1535_loop
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  rxscan1535_done:
.annotate 'line', 719
  # rx subcapture "sym"
    set_addr $I10, rxcap_1536_fail
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  # rx literal  "while"
    add $I11, rx1534_pos, 5
    gt $I11, rx1534_eos, rx1534_fail
    sub $I11, rx1534_pos, rx1534_off
    substr $S10, rx1534_tgt, $I11, 5
    ne $S10, "while", rx1534_fail
    add rx1534_pos, 5
    set_addr $I10, rxcap_1536_fail
    ($I12, $I11) = rx1534_cur."!mark_peek"($I10)
    rx1534_cur."!cursor_pos"($I11)
    ($P10) = rx1534_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1534_pos, "")
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1536_done
  rxcap_1536_fail:
    goto rx1534_fail
  rxcap_1536_done:
  # rx subrule "ws" subtype=method negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."ws"()
    unless $P10, rx1534_fail
    rx1534_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."EXPR"()
    unless $P10, rx1534_fail
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1534_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1534_cur."!cursor_pos"(rx1534_pos)
    $P10 = rx1534_cur."ws"()
    unless $P10, rx1534_fail
    rx1534_pos = $P10."pos"()
  # rx pass
    rx1534_cur."!cursor_pass"(rx1534_pos, "statement_mod_loop:sym<while>")
    if_null rx1534_debug, debug_1051
    rx1534_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx1534_pos)
  debug_1051:
    .return (rx1534_cur)
  rx1534_restart:
.annotate 'line', 462
    if_null rx1534_debug, debug_1052
    rx1534_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_1052:
  rx1534_fail:
    (rx1534_rep, rx1534_pos, $I10, $P10) = rx1534_cur."!mark_fail"(0)
    lt rx1534_pos, -1, rx1534_done
    eq rx1534_pos, -1, rx1534_fail
    jump $I10
  rx1534_done:
    rx1534_cur."!cursor_fail"()
    if_null rx1534_debug, debug_1053
    rx1534_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_1053:
    .return (rx1534_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("135_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("ws", "while")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("136_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1539_tgt
    .local int rx1539_pos
    .local int rx1539_off
    .local int rx1539_eos
    .local int rx1539_rep
    .local pmc rx1539_cur
    .local pmc rx1539_debug
    (rx1539_cur, rx1539_pos, rx1539_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1539_cur
    .local pmc match
    .lex "$/", match
    length rx1539_eos, rx1539_tgt
    gt rx1539_pos, rx1539_eos, rx1539_done
    set rx1539_off, 0
    lt rx1539_pos, 2, rx1539_start
    sub rx1539_off, rx1539_pos, 1
    substr rx1539_tgt, rx1539_tgt, rx1539_off
  rx1539_start:
    eq $I10, 1, rx1539_restart
    if_null rx1539_debug, debug_1054
    rx1539_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_1054:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1540_done
    goto rxscan1540_scan
  rxscan1540_loop:
    (rx1539_pos) = rx1539_cur."from"()
    inc rx1539_pos
    rx1539_cur."!cursor_from"(rx1539_pos)
    ge rx1539_pos, rx1539_eos, rxscan1540_done
  rxscan1540_scan:
    set_addr $I10, rxscan1540_loop
    rx1539_cur."!mark_push"(0, rx1539_pos, $I10)
  rxscan1540_done:
.annotate 'line', 720
  # rx subcapture "sym"
    set_addr $I10, rxcap_1541_fail
    rx1539_cur."!mark_push"(0, rx1539_pos, $I10)
  # rx literal  "until"
    add $I11, rx1539_pos, 5
    gt $I11, rx1539_eos, rx1539_fail
    sub $I11, rx1539_pos, rx1539_off
    substr $S10, rx1539_tgt, $I11, 5
    ne $S10, "until", rx1539_fail
    add rx1539_pos, 5
    set_addr $I10, rxcap_1541_fail
    ($I12, $I11) = rx1539_cur."!mark_peek"($I10)
    rx1539_cur."!cursor_pos"($I11)
    ($P10) = rx1539_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1539_pos, "")
    rx1539_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1541_done
  rxcap_1541_fail:
    goto rx1539_fail
  rxcap_1541_done:
  # rx subrule "ws" subtype=method negate=
    rx1539_cur."!cursor_pos"(rx1539_pos)
    $P10 = rx1539_cur."ws"()
    unless $P10, rx1539_fail
    rx1539_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1539_cur."!cursor_pos"(rx1539_pos)
    $P10 = rx1539_cur."EXPR"()
    unless $P10, rx1539_fail
    rx1539_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1539_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1539_cur."!cursor_pos"(rx1539_pos)
    $P10 = rx1539_cur."ws"()
    unless $P10, rx1539_fail
    rx1539_pos = $P10."pos"()
  # rx pass
    rx1539_cur."!cursor_pass"(rx1539_pos, "statement_mod_loop:sym<until>")
    if_null rx1539_debug, debug_1055
    rx1539_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx1539_pos)
  debug_1055:
    .return (rx1539_cur)
  rx1539_restart:
.annotate 'line', 462
    if_null rx1539_debug, debug_1056
    rx1539_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_1056:
  rx1539_fail:
    (rx1539_rep, rx1539_pos, $I10, $P10) = rx1539_cur."!mark_fail"(0)
    lt rx1539_pos, -1, rx1539_done
    eq rx1539_pos, -1, rx1539_fail
    jump $I10
  rx1539_done:
    rx1539_cur."!cursor_fail"()
    if_null rx1539_debug, debug_1057
    rx1539_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_1057:
    .return (rx1539_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("137_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("ws", "until")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("138_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1544_tgt
    .local int rx1544_pos
    .local int rx1544_off
    .local int rx1544_eos
    .local int rx1544_rep
    .local pmc rx1544_cur
    .local pmc rx1544_debug
    (rx1544_cur, rx1544_pos, rx1544_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1544_cur
    .local pmc match
    .lex "$/", match
    length rx1544_eos, rx1544_tgt
    gt rx1544_pos, rx1544_eos, rx1544_done
    set rx1544_off, 0
    lt rx1544_pos, 2, rx1544_start
    sub rx1544_off, rx1544_pos, 1
    substr rx1544_tgt, rx1544_tgt, rx1544_off
  rx1544_start:
    eq $I10, 1, rx1544_restart
    if_null rx1544_debug, debug_1058
    rx1544_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_1058:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1545_done
    goto rxscan1545_scan
  rxscan1545_loop:
    (rx1544_pos) = rx1544_cur."from"()
    inc rx1544_pos
    rx1544_cur."!cursor_from"(rx1544_pos)
    ge rx1544_pos, rx1544_eos, rxscan1545_done
  rxscan1545_scan:
    set_addr $I10, rxscan1545_loop
    rx1544_cur."!mark_push"(0, rx1544_pos, $I10)
  rxscan1545_done:
.annotate 'line', 721
  # rx subcapture "sym"
    set_addr $I10, rxcap_1546_fail
    rx1544_cur."!mark_push"(0, rx1544_pos, $I10)
  # rx literal  "for"
    add $I11, rx1544_pos, 3
    gt $I11, rx1544_eos, rx1544_fail
    sub $I11, rx1544_pos, rx1544_off
    substr $S10, rx1544_tgt, $I11, 3
    ne $S10, "for", rx1544_fail
    add rx1544_pos, 3
    set_addr $I10, rxcap_1546_fail
    ($I12, $I11) = rx1544_cur."!mark_peek"($I10)
    rx1544_cur."!cursor_pos"($I11)
    ($P10) = rx1544_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1544_pos, "")
    rx1544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1546_done
  rxcap_1546_fail:
    goto rx1544_fail
  rxcap_1546_done:
  # rx subrule "ws" subtype=method negate=
    rx1544_cur."!cursor_pos"(rx1544_pos)
    $P10 = rx1544_cur."ws"()
    unless $P10, rx1544_fail
    rx1544_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1544_cur."!cursor_pos"(rx1544_pos)
    $P10 = rx1544_cur."EXPR"()
    unless $P10, rx1544_fail
    rx1544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx1544_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1544_cur."!cursor_pos"(rx1544_pos)
    $P10 = rx1544_cur."ws"()
    unless $P10, rx1544_fail
    rx1544_pos = $P10."pos"()
  # rx pass
    rx1544_cur."!cursor_pass"(rx1544_pos, "statement_mod_loop:sym<for>")
    if_null rx1544_debug, debug_1059
    rx1544_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx1544_pos)
  debug_1059:
    .return (rx1544_cur)
  rx1544_restart:
.annotate 'line', 462
    if_null rx1544_debug, debug_1060
    rx1544_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_1060:
  rx1544_fail:
    (rx1544_rep, rx1544_pos, $I10, $P10) = rx1544_cur."!mark_fail"(0)
    lt rx1544_pos, -1, rx1544_done
    eq rx1544_pos, -1, rx1544_fail
    jump $I10
  rx1544_done:
    rx1544_cur."!cursor_fail"()
    if_null rx1544_debug, debug_1061
    rx1544_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_1061:
    .return (rx1544_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("139_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("ws", "for")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("140_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1549_tgt
    .local int rx1549_pos
    .local int rx1549_off
    .local int rx1549_eos
    .local int rx1549_rep
    .local pmc rx1549_cur
    .local pmc rx1549_debug
    (rx1549_cur, rx1549_pos, rx1549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1549_cur
    .local pmc match
    .lex "$/", match
    length rx1549_eos, rx1549_tgt
    gt rx1549_pos, rx1549_eos, rx1549_done
    set rx1549_off, 0
    lt rx1549_pos, 2, rx1549_start
    sub rx1549_off, rx1549_pos, 1
    substr rx1549_tgt, rx1549_tgt, rx1549_off
  rx1549_start:
    eq $I10, 1, rx1549_restart
    if_null rx1549_debug, debug_1062
    rx1549_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_1062:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1550_done
    goto rxscan1550_scan
  rxscan1550_loop:
    (rx1549_pos) = rx1549_cur."from"()
    inc rx1549_pos
    rx1549_cur."!cursor_from"(rx1549_pos)
    ge rx1549_pos, rx1549_eos, rxscan1550_done
  rxscan1550_scan:
    set_addr $I10, rxscan1550_loop
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  rxscan1550_done:
.annotate 'line', 725
  # rx subrule "fatarrow" subtype=capture negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."fatarrow"()
    unless $P10, rx1549_fail
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx1549_pos = $P10."pos"()
  # rx pass
    rx1549_cur."!cursor_pass"(rx1549_pos, "term:sym<fatarrow>")
    if_null rx1549_debug, debug_1063
    rx1549_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx1549_pos)
  debug_1063:
    .return (rx1549_cur)
  rx1549_restart:
.annotate 'line', 462
    if_null rx1549_debug, debug_1064
    rx1549_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_1064:
  rx1549_fail:
    (rx1549_rep, rx1549_pos, $I10, $P10) = rx1549_cur."!mark_fail"(0)
    lt rx1549_pos, -1, rx1549_done
    eq rx1549_pos, -1, rx1549_fail
    jump $I10
  rx1549_done:
    rx1549_cur."!cursor_fail"()
    if_null rx1549_debug, debug_1065
    rx1549_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_1065:
    .return (rx1549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("141_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("142_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1553_tgt
    .local int rx1553_pos
    .local int rx1553_off
    .local int rx1553_eos
    .local int rx1553_rep
    .local pmc rx1553_cur
    .local pmc rx1553_debug
    (rx1553_cur, rx1553_pos, rx1553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1553_cur
    .local pmc match
    .lex "$/", match
    length rx1553_eos, rx1553_tgt
    gt rx1553_pos, rx1553_eos, rx1553_done
    set rx1553_off, 0
    lt rx1553_pos, 2, rx1553_start
    sub rx1553_off, rx1553_pos, 1
    substr rx1553_tgt, rx1553_tgt, rx1553_off
  rx1553_start:
    eq $I10, 1, rx1553_restart
    if_null rx1553_debug, debug_1066
    rx1553_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_1066:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1554_done
    goto rxscan1554_scan
  rxscan1554_loop:
    (rx1553_pos) = rx1553_cur."from"()
    inc rx1553_pos
    rx1553_cur."!cursor_from"(rx1553_pos)
    ge rx1553_pos, rx1553_eos, rxscan1554_done
  rxscan1554_scan:
    set_addr $I10, rxscan1554_loop
    rx1553_cur."!mark_push"(0, rx1553_pos, $I10)
  rxscan1554_done:
.annotate 'line', 726
  # rx subrule "colonpair" subtype=capture negate=
    rx1553_cur."!cursor_pos"(rx1553_pos)
    $P10 = rx1553_cur."colonpair"()
    unless $P10, rx1553_fail
    rx1553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx1553_pos = $P10."pos"()
  # rx pass
    rx1553_cur."!cursor_pass"(rx1553_pos, "term:sym<colonpair>")
    if_null rx1553_debug, debug_1067
    rx1553_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx1553_pos)
  debug_1067:
    .return (rx1553_cur)
  rx1553_restart:
.annotate 'line', 462
    if_null rx1553_debug, debug_1068
    rx1553_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_1068:
  rx1553_fail:
    (rx1553_rep, rx1553_pos, $I10, $P10) = rx1553_cur."!mark_fail"(0)
    lt rx1553_pos, -1, rx1553_done
    eq rx1553_pos, -1, rx1553_fail
    jump $I10
  rx1553_done:
    rx1553_cur."!cursor_fail"()
    if_null rx1553_debug, debug_1069
    rx1553_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_1069:
    .return (rx1553_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("143_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("colonpair", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("144_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1557_tgt
    .local int rx1557_pos
    .local int rx1557_off
    .local int rx1557_eos
    .local int rx1557_rep
    .local pmc rx1557_cur
    .local pmc rx1557_debug
    (rx1557_cur, rx1557_pos, rx1557_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1557_cur
    .local pmc match
    .lex "$/", match
    length rx1557_eos, rx1557_tgt
    gt rx1557_pos, rx1557_eos, rx1557_done
    set rx1557_off, 0
    lt rx1557_pos, 2, rx1557_start
    sub rx1557_off, rx1557_pos, 1
    substr rx1557_tgt, rx1557_tgt, rx1557_off
  rx1557_start:
    eq $I10, 1, rx1557_restart
    if_null rx1557_debug, debug_1070
    rx1557_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_1070:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1558_done
    goto rxscan1558_scan
  rxscan1558_loop:
    (rx1557_pos) = rx1557_cur."from"()
    inc rx1557_pos
    rx1557_cur."!cursor_from"(rx1557_pos)
    ge rx1557_pos, rx1557_eos, rxscan1558_done
  rxscan1558_scan:
    set_addr $I10, rxscan1558_loop
    rx1557_cur."!mark_push"(0, rx1557_pos, $I10)
  rxscan1558_done:
.annotate 'line', 727
  # rx subrule "variable" subtype=capture negate=
    rx1557_cur."!cursor_pos"(rx1557_pos)
    $P10 = rx1557_cur."variable"()
    unless $P10, rx1557_fail
    rx1557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1557_pos = $P10."pos"()
  # rx pass
    rx1557_cur."!cursor_pass"(rx1557_pos, "term:sym<variable>")
    if_null rx1557_debug, debug_1071
    rx1557_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx1557_pos)
  debug_1071:
    .return (rx1557_cur)
  rx1557_restart:
.annotate 'line', 462
    if_null rx1557_debug, debug_1072
    rx1557_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_1072:
  rx1557_fail:
    (rx1557_rep, rx1557_pos, $I10, $P10) = rx1557_cur."!mark_fail"(0)
    lt rx1557_pos, -1, rx1557_done
    eq rx1557_pos, -1, rx1557_fail
    jump $I10
  rx1557_done:
    rx1557_cur."!cursor_fail"()
    if_null rx1557_debug, debug_1073
    rx1557_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_1073:
    .return (rx1557_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("145_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("variable", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("146_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1561_tgt
    .local int rx1561_pos
    .local int rx1561_off
    .local int rx1561_eos
    .local int rx1561_rep
    .local pmc rx1561_cur
    .local pmc rx1561_debug
    (rx1561_cur, rx1561_pos, rx1561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1561_cur
    .local pmc match
    .lex "$/", match
    length rx1561_eos, rx1561_tgt
    gt rx1561_pos, rx1561_eos, rx1561_done
    set rx1561_off, 0
    lt rx1561_pos, 2, rx1561_start
    sub rx1561_off, rx1561_pos, 1
    substr rx1561_tgt, rx1561_tgt, rx1561_off
  rx1561_start:
    eq $I10, 1, rx1561_restart
    if_null rx1561_debug, debug_1074
    rx1561_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_1074:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1561_pos) = rx1561_cur."from"()
    inc rx1561_pos
    rx1561_cur."!cursor_from"(rx1561_pos)
    ge rx1561_pos, rx1561_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxscan1562_done:
.annotate 'line', 728
  # rx subrule "package_declarator" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."package_declarator"()
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1561_pos = $P10."pos"()
  # rx pass
    rx1561_cur."!cursor_pass"(rx1561_pos, "term:sym<package_declarator>")
    if_null rx1561_debug, debug_1075
    rx1561_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx1561_pos)
  debug_1075:
    .return (rx1561_cur)
  rx1561_restart:
.annotate 'line', 462
    if_null rx1561_debug, debug_1076
    rx1561_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_1076:
  rx1561_fail:
    (rx1561_rep, rx1561_pos, $I10, $P10) = rx1561_cur."!mark_fail"(0)
    lt rx1561_pos, -1, rx1561_done
    eq rx1561_pos, -1, rx1561_fail
    jump $I10
  rx1561_done:
    rx1561_cur."!cursor_fail"()
    if_null rx1561_debug, debug_1077
    rx1561_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_1077:
    .return (rx1561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("147_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("148_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1565_tgt
    .local int rx1565_pos
    .local int rx1565_off
    .local int rx1565_eos
    .local int rx1565_rep
    .local pmc rx1565_cur
    .local pmc rx1565_debug
    (rx1565_cur, rx1565_pos, rx1565_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1565_cur
    .local pmc match
    .lex "$/", match
    length rx1565_eos, rx1565_tgt
    gt rx1565_pos, rx1565_eos, rx1565_done
    set rx1565_off, 0
    lt rx1565_pos, 2, rx1565_start
    sub rx1565_off, rx1565_pos, 1
    substr rx1565_tgt, rx1565_tgt, rx1565_off
  rx1565_start:
    eq $I10, 1, rx1565_restart
    if_null rx1565_debug, debug_1078
    rx1565_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_1078:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1566_done
    goto rxscan1566_scan
  rxscan1566_loop:
    (rx1565_pos) = rx1565_cur."from"()
    inc rx1565_pos
    rx1565_cur."!cursor_from"(rx1565_pos)
    ge rx1565_pos, rx1565_eos, rxscan1566_done
  rxscan1566_scan:
    set_addr $I10, rxscan1566_loop
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  rxscan1566_done:
.annotate 'line', 729
  # rx subrule "scope_declarator" subtype=capture negate=
    rx1565_cur."!cursor_pos"(rx1565_pos)
    $P10 = rx1565_cur."scope_declarator"()
    unless $P10, rx1565_fail
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx1565_pos = $P10."pos"()
  # rx pass
    rx1565_cur."!cursor_pass"(rx1565_pos, "term:sym<scope_declarator>")
    if_null rx1565_debug, debug_1079
    rx1565_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx1565_pos)
  debug_1079:
    .return (rx1565_cur)
  rx1565_restart:
.annotate 'line', 462
    if_null rx1565_debug, debug_1080
    rx1565_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_1080:
  rx1565_fail:
    (rx1565_rep, rx1565_pos, $I10, $P10) = rx1565_cur."!mark_fail"(0)
    lt rx1565_pos, -1, rx1565_done
    eq rx1565_pos, -1, rx1565_fail
    jump $I10
  rx1565_done:
    rx1565_cur."!cursor_fail"()
    if_null rx1565_debug, debug_1081
    rx1565_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_1081:
    .return (rx1565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("149_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("150_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1569_tgt
    .local int rx1569_pos
    .local int rx1569_off
    .local int rx1569_eos
    .local int rx1569_rep
    .local pmc rx1569_cur
    .local pmc rx1569_debug
    (rx1569_cur, rx1569_pos, rx1569_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1569_cur
    .local pmc match
    .lex "$/", match
    length rx1569_eos, rx1569_tgt
    gt rx1569_pos, rx1569_eos, rx1569_done
    set rx1569_off, 0
    lt rx1569_pos, 2, rx1569_start
    sub rx1569_off, rx1569_pos, 1
    substr rx1569_tgt, rx1569_tgt, rx1569_off
  rx1569_start:
    eq $I10, 1, rx1569_restart
    if_null rx1569_debug, debug_1082
    rx1569_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_1082:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1570_done
    goto rxscan1570_scan
  rxscan1570_loop:
    (rx1569_pos) = rx1569_cur."from"()
    inc rx1569_pos
    rx1569_cur."!cursor_from"(rx1569_pos)
    ge rx1569_pos, rx1569_eos, rxscan1570_done
  rxscan1570_scan:
    set_addr $I10, rxscan1570_loop
    rx1569_cur."!mark_push"(0, rx1569_pos, $I10)
  rxscan1570_done:
.annotate 'line', 730
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1569_cur."!cursor_pos"(rx1569_pos)
    $P10 = rx1569_cur."routine_declarator"()
    unless $P10, rx1569_fail
    rx1569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1569_pos = $P10."pos"()
  # rx pass
    rx1569_cur."!cursor_pass"(rx1569_pos, "term:sym<routine_declarator>")
    if_null rx1569_debug, debug_1083
    rx1569_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx1569_pos)
  debug_1083:
    .return (rx1569_cur)
  rx1569_restart:
.annotate 'line', 462
    if_null rx1569_debug, debug_1084
    rx1569_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_1084:
  rx1569_fail:
    (rx1569_rep, rx1569_pos, $I10, $P10) = rx1569_cur."!mark_fail"(0)
    lt rx1569_pos, -1, rx1569_done
    eq rx1569_pos, -1, rx1569_fail
    jump $I10
  rx1569_done:
    rx1569_cur."!cursor_fail"()
    if_null rx1569_debug, debug_1085
    rx1569_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_1085:
    .return (rx1569_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("151_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("152_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1581 = "154_1325892461.451" 
    capture_lex $P1581
    .const 'Sub' $P1576 = "153_1325892461.451" 
    capture_lex $P1576
    .local string rx1573_tgt
    .local int rx1573_pos
    .local int rx1573_off
    .local int rx1573_eos
    .local int rx1573_rep
    .local pmc rx1573_cur
    .local pmc rx1573_debug
    (rx1573_cur, rx1573_pos, rx1573_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1573_cur
    .local pmc match
    .lex "$/", match
    length rx1573_eos, rx1573_tgt
    gt rx1573_pos, rx1573_eos, rx1573_done
    set rx1573_off, 0
    lt rx1573_pos, 2, rx1573_start
    sub rx1573_off, rx1573_pos, 1
    substr rx1573_tgt, rx1573_tgt, rx1573_off
  rx1573_start:
    eq $I10, 1, rx1573_restart
    if_null rx1573_debug, debug_1086
    rx1573_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_1086:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1573_pos) = rx1573_cur."from"()
    inc rx1573_pos
    rx1573_cur."!cursor_from"(rx1573_pos)
    ge rx1573_pos, rx1573_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  rxscan1574_done:
.annotate 'line', 732
  # rx subrule "before" subtype=zerowidth negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    .const 'Sub' $P1576 = "153_1325892461.451" 
    capture_lex $P1576
    $P10 = rx1573_cur."before"($P1576)
    unless $P10, rx1573_fail
.annotate 'line', 733
  # rx subrule "before" subtype=zerowidth negate=1
    rx1573_cur."!cursor_pos"(rx1573_pos)
    .const 'Sub' $P1581 = "154_1325892461.451" 
    capture_lex $P1581
    $P10 = rx1573_cur."before"($P1581)
    if $P10, rx1573_fail
.annotate 'line', 734
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."multi_declarator"()
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1573_pos = $P10."pos"()
.annotate 'line', 731
  # rx pass
    rx1573_cur."!cursor_pass"(rx1573_pos, "term:sym<multi_declarator>")
    if_null rx1573_debug, debug_1095
    rx1573_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx1573_pos)
  debug_1095:
    .return (rx1573_cur)
  rx1573_restart:
.annotate 'line', 462
    if_null rx1573_debug, debug_1096
    rx1573_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_1096:
  rx1573_fail:
    (rx1573_rep, rx1573_pos, $I10, $P10) = rx1573_cur."!mark_fail"(0)
    lt rx1573_pos, -1, rx1573_done
    eq rx1573_pos, -1, rx1573_fail
    jump $I10
  rx1573_done:
    rx1573_cur."!cursor_fail"()
    if_null rx1573_debug, debug_1097
    rx1573_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_1097:
    .return (rx1573_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1575"  :anon :subid("153_1325892461.451") :method :outer("152_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 732
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1087
    rx1577_cur."!cursor_debug"("START", "")
  debug_1087:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1578_done
    goto rxscan1578_scan
  rxscan1578_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1578_done
  rxscan1578_scan:
    set_addr $I10, rxscan1578_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1578_done:
  alt1579_0:
    set_addr $I10, alt1579_1
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1577_pos, 5
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 5
    ne $S10, "multi", rx1577_fail
    add rx1577_pos, 5
    goto alt1579_end
  alt1579_1:
    set_addr $I10, alt1579_2
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1577_pos, 5
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 5
    ne $S10, "proto", rx1577_fail
    add rx1577_pos, 5
    goto alt1579_end
  alt1579_2:
  # rx literal  "only"
    add $I11, rx1577_pos, 4
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 4
    ne $S10, "only", rx1577_fail
    add rx1577_pos, 4
  alt1579_end:
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "")
    if_null rx1577_debug, debug_1088
    rx1577_cur."!cursor_debug"("PASS", "", " at pos=", rx1577_pos)
  debug_1088:
    .return (rx1577_cur)
  rx1577_restart:
    if_null rx1577_debug, debug_1089
    rx1577_cur."!cursor_debug"("NEXT", "")
  debug_1089:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1090
    rx1577_cur."!cursor_debug"("FAIL", "")
  debug_1090:
    .return (rx1577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1580"  :anon :subid("154_1325892461.451") :method :outer("152_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 733
    .local string rx1582_tgt
    .local int rx1582_pos
    .local int rx1582_off
    .local int rx1582_eos
    .local int rx1582_rep
    .local pmc rx1582_cur
    .local pmc rx1582_debug
    (rx1582_cur, rx1582_pos, rx1582_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1582_cur
    .local pmc match
    .lex "$/", match
    length rx1582_eos, rx1582_tgt
    gt rx1582_pos, rx1582_eos, rx1582_done
    set rx1582_off, 0
    lt rx1582_pos, 2, rx1582_start
    sub rx1582_off, rx1582_pos, 1
    substr rx1582_tgt, rx1582_tgt, rx1582_off
  rx1582_start:
    eq $I10, 1, rx1582_restart
    if_null rx1582_debug, debug_1091
    rx1582_cur."!cursor_debug"("START", "")
  debug_1091:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1583_done
    goto rxscan1583_scan
  rxscan1583_loop:
    (rx1582_pos) = rx1582_cur."from"()
    inc rx1582_pos
    rx1582_cur."!cursor_from"(rx1582_pos)
    ge rx1582_pos, rx1582_eos, rxscan1583_done
  rxscan1583_scan:
    set_addr $I10, rxscan1583_loop
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  rxscan1583_done:
  # rx literal  "proto"
    add $I11, rx1582_pos, 5
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 5
    ne $S10, "proto", rx1582_fail
    add rx1582_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1582_cur."!cursor_pos"(rx1582_pos)
    $P10 = rx1582_cur."ws"()
    unless $P10, rx1582_fail
    rx1582_pos = $P10."pos"()
  alt1584_0:
    set_addr $I10, alt1584_1
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1582_pos, 5
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 5
    ne $S10, "regex", rx1582_fail
    add rx1582_pos, 5
    goto alt1584_end
  alt1584_1:
    set_addr $I10, alt1584_2
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  # rx literal  "token"
    add $I11, rx1582_pos, 5
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 5
    ne $S10, "token", rx1582_fail
    add rx1582_pos, 5
    goto alt1584_end
  alt1584_2:
  # rx literal  "rule"
    add $I11, rx1582_pos, 4
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 4
    ne $S10, "rule", rx1582_fail
    add rx1582_pos, 4
  alt1584_end:
  # rx pass
    rx1582_cur."!cursor_pass"(rx1582_pos, "")
    if_null rx1582_debug, debug_1092
    rx1582_cur."!cursor_debug"("PASS", "", " at pos=", rx1582_pos)
  debug_1092:
    .return (rx1582_cur)
  rx1582_restart:
    if_null rx1582_debug, debug_1093
    rx1582_cur."!cursor_debug"("NEXT", "")
  debug_1093:
  rx1582_fail:
    (rx1582_rep, rx1582_pos, $I10, $P10) = rx1582_cur."!mark_fail"(0)
    lt rx1582_pos, -1, rx1582_done
    eq rx1582_pos, -1, rx1582_fail
    jump $I10
  rx1582_done:
    rx1582_cur."!cursor_fail"()
    if_null rx1582_debug, debug_1094
    rx1582_cur."!cursor_debug"("FAIL", "")
  debug_1094:
    .return (rx1582_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("155_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("156_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1587_tgt
    .local int rx1587_pos
    .local int rx1587_off
    .local int rx1587_eos
    .local int rx1587_rep
    .local pmc rx1587_cur
    .local pmc rx1587_debug
    (rx1587_cur, rx1587_pos, rx1587_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1587_cur
    .local pmc match
    .lex "$/", match
    length rx1587_eos, rx1587_tgt
    gt rx1587_pos, rx1587_eos, rx1587_done
    set rx1587_off, 0
    lt rx1587_pos, 2, rx1587_start
    sub rx1587_off, rx1587_pos, 1
    substr rx1587_tgt, rx1587_tgt, rx1587_off
  rx1587_start:
    eq $I10, 1, rx1587_restart
    if_null rx1587_debug, debug_1098
    rx1587_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_1098:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1587_pos) = rx1587_cur."from"()
    inc rx1587_pos
    rx1587_cur."!cursor_from"(rx1587_pos)
    ge rx1587_pos, rx1587_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1587_cur."!mark_push"(0, rx1587_pos, $I10)
  rxscan1588_done:
.annotate 'line', 736
  # rx subrule "regex_declarator" subtype=capture negate=
    rx1587_cur."!cursor_pos"(rx1587_pos)
    $P10 = rx1587_cur."regex_declarator"()
    unless $P10, rx1587_fail
    rx1587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx1587_pos = $P10."pos"()
  # rx pass
    rx1587_cur."!cursor_pass"(rx1587_pos, "term:sym<regex_declarator>")
    if_null rx1587_debug, debug_1099
    rx1587_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx1587_pos)
  debug_1099:
    .return (rx1587_cur)
  rx1587_restart:
.annotate 'line', 462
    if_null rx1587_debug, debug_1100
    rx1587_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_1100:
  rx1587_fail:
    (rx1587_rep, rx1587_pos, $I10, $P10) = rx1587_cur."!mark_fail"(0)
    lt rx1587_pos, -1, rx1587_done
    eq rx1587_pos, -1, rx1587_fail
    jump $I10
  rx1587_done:
    rx1587_cur."!cursor_fail"()
    if_null rx1587_debug, debug_1101
    rx1587_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_1101:
    .return (rx1587_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("157_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("158_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1591_tgt
    .local int rx1591_pos
    .local int rx1591_off
    .local int rx1591_eos
    .local int rx1591_rep
    .local pmc rx1591_cur
    .local pmc rx1591_debug
    (rx1591_cur, rx1591_pos, rx1591_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1591_cur
    .local pmc match
    .lex "$/", match
    length rx1591_eos, rx1591_tgt
    gt rx1591_pos, rx1591_eos, rx1591_done
    set rx1591_off, 0
    lt rx1591_pos, 2, rx1591_start
    sub rx1591_off, rx1591_pos, 1
    substr rx1591_tgt, rx1591_tgt, rx1591_off
  rx1591_start:
    eq $I10, 1, rx1591_restart
    if_null rx1591_debug, debug_1102
    rx1591_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_1102:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1592_done
    goto rxscan1592_scan
  rxscan1592_loop:
    (rx1591_pos) = rx1591_cur."from"()
    inc rx1591_pos
    rx1591_cur."!cursor_from"(rx1591_pos)
    ge rx1591_pos, rx1591_eos, rxscan1592_done
  rxscan1592_scan:
    set_addr $I10, rxscan1592_loop
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxscan1592_done:
.annotate 'line', 737
  # rx subrule "statement_prefix" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."statement_prefix"()
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx1591_pos = $P10."pos"()
  # rx pass
    rx1591_cur."!cursor_pass"(rx1591_pos, "term:sym<statement_prefix>")
    if_null rx1591_debug, debug_1103
    rx1591_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx1591_pos)
  debug_1103:
    .return (rx1591_cur)
  rx1591_restart:
.annotate 'line', 462
    if_null rx1591_debug, debug_1104
    rx1591_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_1104:
  rx1591_fail:
    (rx1591_rep, rx1591_pos, $I10, $P10) = rx1591_cur."!mark_fail"(0)
    lt rx1591_pos, -1, rx1591_done
    eq rx1591_pos, -1, rx1591_fail
    jump $I10
  rx1591_done:
    rx1591_cur."!cursor_fail"()
    if_null rx1591_debug, debug_1105
    rx1591_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_1105:
    .return (rx1591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("159_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("160_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1595_tgt
    .local int rx1595_pos
    .local int rx1595_off
    .local int rx1595_eos
    .local int rx1595_rep
    .local pmc rx1595_cur
    .local pmc rx1595_debug
    (rx1595_cur, rx1595_pos, rx1595_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1595_cur
    .local pmc match
    .lex "$/", match
    length rx1595_eos, rx1595_tgt
    gt rx1595_pos, rx1595_eos, rx1595_done
    set rx1595_off, 0
    lt rx1595_pos, 2, rx1595_start
    sub rx1595_off, rx1595_pos, 1
    substr rx1595_tgt, rx1595_tgt, rx1595_off
  rx1595_start:
    eq $I10, 1, rx1595_restart
    if_null rx1595_debug, debug_1106
    rx1595_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_1106:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1596_done
    goto rxscan1596_scan
  rxscan1596_loop:
    (rx1595_pos) = rx1595_cur."from"()
    inc rx1595_pos
    rx1595_cur."!cursor_from"(rx1595_pos)
    ge rx1595_pos, rx1595_eos, rxscan1596_done
  rxscan1596_scan:
    set_addr $I10, rxscan1596_loop
    rx1595_cur."!mark_push"(0, rx1595_pos, $I10)
  rxscan1596_done:
.annotate 'line', 738
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1595_cur."!cursor_pos"(rx1595_pos)
    $P10 = rx1595_cur."lambda"()
    unless $P10, rx1595_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1595_cur."!cursor_pos"(rx1595_pos)
    $P10 = rx1595_cur."pblock"()
    unless $P10, rx1595_fail
    rx1595_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1595_pos = $P10."pos"()
  # rx pass
    rx1595_cur."!cursor_pass"(rx1595_pos, "term:sym<lambda>")
    if_null rx1595_debug, debug_1107
    rx1595_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx1595_pos)
  debug_1107:
    .return (rx1595_cur)
  rx1595_restart:
.annotate 'line', 462
    if_null rx1595_debug, debug_1108
    rx1595_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_1108:
  rx1595_fail:
    (rx1595_rep, rx1595_pos, $I10, $P10) = rx1595_cur."!mark_fail"(0)
    lt rx1595_pos, -1, rx1595_done
    eq rx1595_pos, -1, rx1595_fail
    jump $I10
  rx1595_done:
    rx1595_cur."!cursor_fail"()
    if_null rx1595_debug, debug_1109
    rx1595_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_1109:
    .return (rx1595_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("161_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("162_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1599_tgt
    .local int rx1599_pos
    .local int rx1599_off
    .local int rx1599_eos
    .local int rx1599_rep
    .local pmc rx1599_cur
    .local pmc rx1599_debug
    (rx1599_cur, rx1599_pos, rx1599_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1599_cur
    .local pmc match
    .lex "$/", match
    length rx1599_eos, rx1599_tgt
    gt rx1599_pos, rx1599_eos, rx1599_done
    set rx1599_off, 0
    lt rx1599_pos, 2, rx1599_start
    sub rx1599_off, rx1599_pos, 1
    substr rx1599_tgt, rx1599_tgt, rx1599_off
  rx1599_start:
    eq $I10, 1, rx1599_restart
    if_null rx1599_debug, debug_1110
    rx1599_cur."!cursor_debug"("START", "fatarrow")
  debug_1110:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1600_done
    goto rxscan1600_scan
  rxscan1600_loop:
    (rx1599_pos) = rx1599_cur."from"()
    inc rx1599_pos
    rx1599_cur."!cursor_from"(rx1599_pos)
    ge rx1599_pos, rx1599_eos, rxscan1600_done
  rxscan1600_scan:
    set_addr $I10, rxscan1600_loop
    rx1599_cur."!mark_push"(0, rx1599_pos, $I10)
  rxscan1600_done:
.annotate 'line', 741
  # rx subrule "identifier" subtype=capture negate=
    rx1599_cur."!cursor_pos"(rx1599_pos)
    $P10 = rx1599_cur."identifier"()
    unless $P10, rx1599_fail
    rx1599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx1599_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx1599_pos, rx1599_off
    set rx1599_rep, 0
    sub $I12, rx1599_eos, rx1599_pos
  rxenumcharlistq1601_loop:
    le $I12, 0, rxenumcharlistq1601_done
    substr $S10, rx1599_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq1601_done
    inc rx1599_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq1601_loop
  rxenumcharlistq1601_done:
    add rx1599_pos, rx1599_pos, rx1599_rep
  # rx literal  "=>"
    add $I11, rx1599_pos, 2
    gt $I11, rx1599_eos, rx1599_fail
    sub $I11, rx1599_pos, rx1599_off
    substr $S10, rx1599_tgt, $I11, 2
    ne $S10, "=>", rx1599_fail
    add rx1599_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1599_cur."!cursor_pos"(rx1599_pos)
    $P10 = rx1599_cur."ws"()
    unless $P10, rx1599_fail
    rx1599_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1599_cur."!cursor_pos"(rx1599_pos)
    $P10 = rx1599_cur."EXPR"("i=")
    unless $P10, rx1599_fail
    rx1599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx1599_pos = $P10."pos"()
.annotate 'line', 740
  # rx pass
    rx1599_cur."!cursor_pass"(rx1599_pos, "fatarrow")
    if_null rx1599_debug, debug_1111
    rx1599_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx1599_pos)
  debug_1111:
    .return (rx1599_cur)
  rx1599_restart:
.annotate 'line', 462
    if_null rx1599_debug, debug_1112
    rx1599_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_1112:
  rx1599_fail:
    (rx1599_rep, rx1599_pos, $I10, $P10) = rx1599_cur."!mark_fail"(0)
    lt rx1599_pos, -1, rx1599_done
    eq rx1599_pos, -1, rx1599_fail
    jump $I10
  rx1599_done:
    rx1599_cur."!cursor_fail"()
    if_null rx1599_debug, debug_1113
    rx1599_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_1113:
    .return (rx1599_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("163_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("164_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1604_tgt
    .local int rx1604_pos
    .local int rx1604_off
    .local int rx1604_eos
    .local int rx1604_rep
    .local pmc rx1604_cur
    .local pmc rx1604_debug
    (rx1604_cur, rx1604_pos, rx1604_tgt, $I10) = self."!cursor_start"()
    rx1604_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1604_cur
    .local pmc match
    .lex "$/", match
    length rx1604_eos, rx1604_tgt
    gt rx1604_pos, rx1604_eos, rx1604_done
    set rx1604_off, 0
    lt rx1604_pos, 2, rx1604_start
    sub rx1604_off, rx1604_pos, 1
    substr rx1604_tgt, rx1604_tgt, rx1604_off
  rx1604_start:
    eq $I10, 1, rx1604_restart
    if_null rx1604_debug, debug_1114
    rx1604_cur."!cursor_debug"("START", "colonpair")
  debug_1114:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1605_done
    goto rxscan1605_scan
  rxscan1605_loop:
    (rx1604_pos) = rx1604_cur."from"()
    inc rx1604_pos
    rx1604_cur."!cursor_from"(rx1604_pos)
    ge rx1604_pos, rx1604_eos, rxscan1605_done
  rxscan1605_scan:
    set_addr $I10, rxscan1605_loop
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxscan1605_done:
.annotate 'line', 745
  # rx literal  ":"
    add $I11, rx1604_pos, 1
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    ord $I11, rx1604_tgt, $I11
    ne $I11, 58, rx1604_fail
    add rx1604_pos, 1
  alt1606_0:
.annotate 'line', 746
    set_addr $I10, alt1606_1
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
.annotate 'line', 747
  # rx subcapture "not"
    set_addr $I10, rxcap_1607_fail
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  # rx literal  "!"
    add $I11, rx1604_pos, 1
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    ord $I11, rx1604_tgt, $I11
    ne $I11, 33, rx1604_fail
    add rx1604_pos, 1
    set_addr $I10, rxcap_1607_fail
    ($I12, $I11) = rx1604_cur."!mark_peek"($I10)
    rx1604_cur."!cursor_pos"($I11)
    ($P10) = rx1604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1604_pos, "")
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_1607_done
  rxcap_1607_fail:
    goto rx1604_fail
  rxcap_1607_done:
  # rx subrule "identifier" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."identifier"()
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1604_pos = $P10."pos"()
    goto alt1606_end
  alt1606_1:
    set_addr $I10, alt1606_2
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
.annotate 'line', 748
  # rx subrule "identifier" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."identifier"()
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx1604_pos = $P10."pos"()
  # rx rxquantr1608 ** 0..1
    set_addr $I10, rxquantr1608_done
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxquantr1608_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."circumfix"()
    unless $P10, rx1604_fail
    goto rxsubrule1609_pass
  rxsubrule1609_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1604_fail
  rxsubrule1609_pass:
    set_addr $I10, rxsubrule1609_back
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1604_pos = $P10."pos"()
    set_addr $I10, rxquantr1608_done
    (rx1604_rep) = rx1604_cur."!mark_commit"($I10)
  rxquantr1608_done:
    goto alt1606_end
  alt1606_2:
.annotate 'line', 749
  # rx subrule "circumfix" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."circumfix"()
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx1604_pos = $P10."pos"()
  alt1606_end:
.annotate 'line', 744
  # rx pass
    rx1604_cur."!cursor_pass"(rx1604_pos, "colonpair")
    if_null rx1604_debug, debug_1115
    rx1604_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx1604_pos)
  debug_1115:
    .return (rx1604_cur)
  rx1604_restart:
.annotate 'line', 462
    if_null rx1604_debug, debug_1116
    rx1604_cur."!cursor_debug"("NEXT", "colonpair")
  debug_1116:
  rx1604_fail:
    (rx1604_rep, rx1604_pos, $I10, $P10) = rx1604_cur."!mark_fail"(0)
    lt rx1604_pos, -1, rx1604_done
    eq rx1604_pos, -1, rx1604_fail
    jump $I10
  rx1604_done:
    rx1604_cur."!cursor_fail"()
    if_null rx1604_debug, debug_1117
    rx1604_cur."!cursor_debug"("FAIL", "colonpair")
  debug_1117:
    .return (rx1604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("165_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("circumfix", ":")
    $P104 = self."!PREFIX__!subrule"("identifier", ":")
    $P105 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P106, "ResizablePMCArray"
    push $P106, $P103
    push $P106, $P104
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("166_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1612_tgt
    .local int rx1612_pos
    .local int rx1612_off
    .local int rx1612_eos
    .local int rx1612_rep
    .local pmc rx1612_cur
    .local pmc rx1612_debug
    (rx1612_cur, rx1612_pos, rx1612_tgt, $I10) = self."!cursor_start"()
    rx1612_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1612_cur
    .local pmc match
    .lex "$/", match
    length rx1612_eos, rx1612_tgt
    gt rx1612_pos, rx1612_eos, rx1612_done
    set rx1612_off, 0
    lt rx1612_pos, 2, rx1612_start
    sub rx1612_off, rx1612_pos, 1
    substr rx1612_tgt, rx1612_tgt, rx1612_off
  rx1612_start:
    eq $I10, 1, rx1612_restart
    if_null rx1612_debug, debug_1118
    rx1612_cur."!cursor_debug"("START", "variable")
  debug_1118:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1613_done
    goto rxscan1613_scan
  rxscan1613_loop:
    (rx1612_pos) = rx1612_cur."from"()
    inc rx1612_pos
    rx1612_cur."!cursor_from"(rx1612_pos)
    ge rx1612_pos, rx1612_eos, rxscan1613_done
  rxscan1613_scan:
    set_addr $I10, rxscan1613_loop
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  rxscan1613_done:
  alt1614_0:
.annotate 'line', 753
    set_addr $I10, alt1614_1
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
.annotate 'line', 754
  # rx subrule "sigil" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."sigil"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1612_pos = $P10."pos"()
  # rx rxquantr1615 ** 0..1
    set_addr $I10, rxquantr1615_done
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  rxquantr1615_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."twigil"()
    unless $P10, rx1612_fail
    goto rxsubrule1616_pass
  rxsubrule1616_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1612_fail
  rxsubrule1616_pass:
    set_addr $I10, rxsubrule1616_back
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1612_pos = $P10."pos"()
    set_addr $I10, rxquantr1615_done
    (rx1612_rep) = rx1612_cur."!mark_commit"($I10)
  rxquantr1615_done:
  # rx subrule "name" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."name"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx1612_pos = $P10."pos"()
    goto alt1614_end
  alt1614_1:
    set_addr $I10, alt1614_2
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
.annotate 'line', 755
  # rx subrule "sigil" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."sigil"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1612_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1612_pos, rx1612_off
    substr $S10, rx1612_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx1612_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx1612_cur."!cursor_pos"(rx1612_pos)
    $P10 = rx1612_cur."postcircumfix"()
    unless $P10, rx1612_fail
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx1612_pos = $P10."pos"()
    goto alt1614_end
  alt1614_2:
.annotate 'line', 756
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1617_fail
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  # rx literal  "$"
    add $I11, rx1612_pos, 1
    gt $I11, rx1612_eos, rx1612_fail
    sub $I11, rx1612_pos, rx1612_off
    ord $I11, rx1612_tgt, $I11
    ne $I11, 36, rx1612_fail
    add rx1612_pos, 1
    set_addr $I10, rxcap_1617_fail
    ($I12, $I11) = rx1612_cur."!mark_peek"($I10)
    rx1612_cur."!cursor_pos"($I11)
    ($P10) = rx1612_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1612_pos, "")
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1617_done
  rxcap_1617_fail:
    goto rx1612_fail
  rxcap_1617_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_1618_fail
    rx1612_cur."!mark_push"(0, rx1612_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1612_pos, rx1612_eos, rx1612_fail
    sub $I10, rx1612_pos, rx1612_off
    substr $S10, rx1612_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx1612_fail
    inc rx1612_pos
    set_addr $I10, rxcap_1618_fail
    ($I12, $I11) = rx1612_cur."!mark_peek"($I10)
    rx1612_cur."!cursor_pos"($I11)
    ($P10) = rx1612_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1612_pos, "")
    rx1612_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_1618_done
  rxcap_1618_fail:
    goto rx1612_fail
  rxcap_1618_done:
  alt1614_end:
.annotate 'line', 753
  # rx pass
    rx1612_cur."!cursor_pass"(rx1612_pos, "variable")
    if_null rx1612_debug, debug_1119
    rx1612_cur."!cursor_debug"("PASS", "variable", " at pos=", rx1612_pos)
  debug_1119:
    .return (rx1612_cur)
  rx1612_restart:
.annotate 'line', 462
    if_null rx1612_debug, debug_1120
    rx1612_cur."!cursor_debug"("NEXT", "variable")
  debug_1120:
  rx1612_fail:
    (rx1612_rep, rx1612_pos, $I10, $P10) = rx1612_cur."!mark_fail"(0)
    lt rx1612_pos, -1, rx1612_done
    eq rx1612_pos, -1, rx1612_fail
    jump $I10
  rx1612_done:
    rx1612_cur."!cursor_fail"()
    if_null rx1612_debug, debug_1121
    rx1612_cur."!cursor_debug"("FAIL", "variable")
  debug_1121:
    .return (rx1612_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("167_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("sigil", "")
    $P104 = self."!PREFIX__!subrule"("sigil", "")
    new $P105, "ResizablePMCArray"
    push $P105, "/"
    push $P105, "_"
    push $P105, "!"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("168_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1621_tgt
    .local int rx1621_pos
    .local int rx1621_off
    .local int rx1621_eos
    .local int rx1621_rep
    .local pmc rx1621_cur
    .local pmc rx1621_debug
    (rx1621_cur, rx1621_pos, rx1621_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1621_cur
    .local pmc match
    .lex "$/", match
    length rx1621_eos, rx1621_tgt
    gt rx1621_pos, rx1621_eos, rx1621_done
    set rx1621_off, 0
    lt rx1621_pos, 2, rx1621_start
    sub rx1621_off, rx1621_pos, 1
    substr rx1621_tgt, rx1621_tgt, rx1621_off
  rx1621_start:
    eq $I10, 1, rx1621_restart
    if_null rx1621_debug, debug_1122
    rx1621_cur."!cursor_debug"("START", "sigil")
  debug_1122:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1621_pos) = rx1621_cur."from"()
    inc rx1621_pos
    rx1621_cur."!cursor_from"(rx1621_pos)
    ge rx1621_pos, rx1621_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1621_cur."!mark_push"(0, rx1621_pos, $I10)
  rxscan1622_done:
.annotate 'line', 759
  # rx enumcharlist negate=0 
    ge rx1621_pos, rx1621_eos, rx1621_fail
    sub $I10, rx1621_pos, rx1621_off
    substr $S10, rx1621_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx1621_fail
    inc rx1621_pos
  # rx pass
    rx1621_cur."!cursor_pass"(rx1621_pos, "sigil")
    if_null rx1621_debug, debug_1123
    rx1621_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx1621_pos)
  debug_1123:
    .return (rx1621_cur)
  rx1621_restart:
.annotate 'line', 462
    if_null rx1621_debug, debug_1124
    rx1621_cur."!cursor_debug"("NEXT", "sigil")
  debug_1124:
  rx1621_fail:
    (rx1621_rep, rx1621_pos, $I10, $P10) = rx1621_cur."!mark_fail"(0)
    lt rx1621_pos, -1, rx1621_done
    eq rx1621_pos, -1, rx1621_fail
    jump $I10
  rx1621_done:
    rx1621_cur."!cursor_fail"()
    if_null rx1621_debug, debug_1125
    rx1621_cur."!cursor_debug"("FAIL", "sigil")
  debug_1125:
    .return (rx1621_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("169_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    push $P103, "%"
    push $P103, "&"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("170_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1625_tgt
    .local int rx1625_pos
    .local int rx1625_off
    .local int rx1625_eos
    .local int rx1625_rep
    .local pmc rx1625_cur
    .local pmc rx1625_debug
    (rx1625_cur, rx1625_pos, rx1625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1625_cur
    .local pmc match
    .lex "$/", match
    length rx1625_eos, rx1625_tgt
    gt rx1625_pos, rx1625_eos, rx1625_done
    set rx1625_off, 0
    lt rx1625_pos, 2, rx1625_start
    sub rx1625_off, rx1625_pos, 1
    substr rx1625_tgt, rx1625_tgt, rx1625_off
  rx1625_start:
    eq $I10, 1, rx1625_restart
    if_null rx1625_debug, debug_1126
    rx1625_cur."!cursor_debug"("START", "twigil")
  debug_1126:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1626_done
    goto rxscan1626_scan
  rxscan1626_loop:
    (rx1625_pos) = rx1625_cur."from"()
    inc rx1625_pos
    rx1625_cur."!cursor_from"(rx1625_pos)
    ge rx1625_pos, rx1625_eos, rxscan1626_done
  rxscan1626_scan:
    set_addr $I10, rxscan1626_loop
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  rxscan1626_done:
.annotate 'line', 761
  # rx enumcharlist negate=0 
    ge rx1625_pos, rx1625_eos, rx1625_fail
    sub $I10, rx1625_pos, rx1625_off
    substr $S10, rx1625_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx1625_fail
    inc rx1625_pos
  # rx pass
    rx1625_cur."!cursor_pass"(rx1625_pos, "twigil")
    if_null rx1625_debug, debug_1127
    rx1625_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx1625_pos)
  debug_1127:
    .return (rx1625_cur)
  rx1625_restart:
.annotate 'line', 462
    if_null rx1625_debug, debug_1128
    rx1625_cur."!cursor_debug"("NEXT", "twigil")
  debug_1128:
  rx1625_fail:
    (rx1625_rep, rx1625_pos, $I10, $P10) = rx1625_cur."!mark_fail"(0)
    lt rx1625_pos, -1, rx1625_done
    eq rx1625_pos, -1, rx1625_fail
    jump $I10
  rx1625_done:
    rx1625_cur."!cursor_fail"()
    if_null rx1625_debug, debug_1129
    rx1625_cur."!cursor_debug"("FAIL", "twigil")
  debug_1129:
    .return (rx1625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("171_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "*"
    push $P103, "!"
    push $P103, "?"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("172_1325892461.451")
    .param pmc param_1629
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 763
    .lex "self", param_1629
    $P103 = param_1629."!protoregex"("package_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("173_1325892461.451")
    .param pmc param_1631
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 763
    .lex "self", param_1631
    $P104 = param_1631."!PREFIX__!protoregex"("package_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("174_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 765
    new $P103, "Undef"
    set $P1633, $P103
    .lex "$*OUTERPACKAGE", $P1633
.annotate 'line', 766
    new $P104, "Undef"
    set $P1634, $P104
    .lex "$*PKGDECL", $P1634
.annotate 'line', 462
    .local string rx1635_tgt
    .local int rx1635_pos
    .local int rx1635_off
    .local int rx1635_eos
    .local int rx1635_rep
    .local pmc rx1635_cur
    .local pmc rx1635_debug
    (rx1635_cur, rx1635_pos, rx1635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1635_cur
    .local pmc match
    .lex "$/", match
    length rx1635_eos, rx1635_tgt
    gt rx1635_pos, rx1635_eos, rx1635_done
    set rx1635_off, 0
    lt rx1635_pos, 2, rx1635_start
    sub rx1635_off, rx1635_pos, 1
    substr rx1635_tgt, rx1635_tgt, rx1635_off
  rx1635_start:
    eq $I10, 1, rx1635_restart
    if_null rx1635_debug, debug_1130
    rx1635_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1636_done
    goto rxscan1636_scan
  rxscan1636_loop:
    (rx1635_pos) = rx1635_cur."from"()
    inc rx1635_pos
    rx1635_cur."!cursor_from"(rx1635_pos)
    ge rx1635_pos, rx1635_eos, rxscan1636_done
  rxscan1636_scan:
    set_addr $I10, rxscan1636_loop
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  rxscan1636_done:
.annotate 'line', 765
    rx1635_cur."!cursor_pos"(rx1635_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1131
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1132
    die "Contextual $*PACKAGE not found"
  vivify_1132:
  vivify_1131:
    set $P1633, $P107
.annotate 'line', 766
    rx1635_cur."!cursor_pos"(rx1635_pos)
    new $P108, "String"
    assign $P108, "module"
    set $P1634, $P108
.annotate 'line', 767
  # rx subcapture "sym"
    set_addr $I10, rxcap_1637_fail
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  # rx literal  "module"
    add $I11, rx1635_pos, 6
    gt $I11, rx1635_eos, rx1635_fail
    sub $I11, rx1635_pos, rx1635_off
    substr $S10, rx1635_tgt, $I11, 6
    ne $S10, "module", rx1635_fail
    add rx1635_pos, 6
    set_addr $I10, rxcap_1637_fail
    ($I12, $I11) = rx1635_cur."!mark_peek"($I10)
    rx1635_cur."!cursor_pos"($I11)
    ($P10) = rx1635_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1635_pos, "")
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1637_done
  rxcap_1637_fail:
    goto rx1635_fail
  rxcap_1637_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    $P10 = rx1635_cur."package_def"()
    unless $P10, rx1635_fail
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1635_pos = $P10."pos"()
.annotate 'line', 764
  # rx pass
    rx1635_cur."!cursor_pass"(rx1635_pos, "package_declarator:sym<module>")
    if_null rx1635_debug, debug_1133
    rx1635_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx1635_pos)
  debug_1133:
    .return (rx1635_cur)
  rx1635_restart:
.annotate 'line', 462
    if_null rx1635_debug, debug_1134
    rx1635_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_1134:
  rx1635_fail:
    (rx1635_rep, rx1635_pos, $I10, $P10) = rx1635_cur."!mark_fail"(0)
    lt rx1635_pos, -1, rx1635_done
    eq rx1635_pos, -1, rx1635_fail
    jump $I10
  rx1635_done:
    rx1635_cur."!cursor_fail"()
    if_null rx1635_debug, debug_1135
    rx1635_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_1135:
    .return (rx1635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("175_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P109 = self."!PREFIX__!subrule"("package_def", "module")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("176_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 770
    new $P103, "Undef"
    set $P1640, $P103
    .lex "$*OUTERPACKAGE", $P1640
.annotate 'line', 771
    new $P104, "Undef"
    set $P1641, $P104
    .lex "$*PKGDECL", $P1641
.annotate 'line', 462
    .local string rx1642_tgt
    .local int rx1642_pos
    .local int rx1642_off
    .local int rx1642_eos
    .local int rx1642_rep
    .local pmc rx1642_cur
    .local pmc rx1642_debug
    (rx1642_cur, rx1642_pos, rx1642_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1642_cur
    .local pmc match
    .lex "$/", match
    length rx1642_eos, rx1642_tgt
    gt rx1642_pos, rx1642_eos, rx1642_done
    set rx1642_off, 0
    lt rx1642_pos, 2, rx1642_start
    sub rx1642_off, rx1642_pos, 1
    substr rx1642_tgt, rx1642_tgt, rx1642_off
  rx1642_start:
    eq $I10, 1, rx1642_restart
    if_null rx1642_debug, debug_1136
    rx1642_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1643_done
    goto rxscan1643_scan
  rxscan1643_loop:
    (rx1642_pos) = rx1642_cur."from"()
    inc rx1642_pos
    rx1642_cur."!cursor_from"(rx1642_pos)
    ge rx1642_pos, rx1642_eos, rxscan1643_done
  rxscan1643_scan:
    set_addr $I10, rxscan1643_loop
    rx1642_cur."!mark_push"(0, rx1642_pos, $I10)
  rxscan1643_done:
.annotate 'line', 770
    rx1642_cur."!cursor_pos"(rx1642_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1137
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1138
    die "Contextual $*PACKAGE not found"
  vivify_1138:
  vivify_1137:
    set $P1640, $P107
.annotate 'line', 771
    rx1642_cur."!cursor_pos"(rx1642_pos)
    new $P108, "String"
    assign $P108, "knowhow"
    set $P1641, $P108
.annotate 'line', 772
  # rx subcapture "sym"
    set_addr $I10, rxcap_1644_fail
    rx1642_cur."!mark_push"(0, rx1642_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx1642_pos, 7
    gt $I11, rx1642_eos, rx1642_fail
    sub $I11, rx1642_pos, rx1642_off
    substr $S10, rx1642_tgt, $I11, 7
    ne $S10, "knowhow", rx1642_fail
    add rx1642_pos, 7
    set_addr $I10, rxcap_1644_fail
    ($I12, $I11) = rx1642_cur."!mark_peek"($I10)
    rx1642_cur."!cursor_pos"($I11)
    ($P10) = rx1642_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1642_pos, "")
    rx1642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1644_done
  rxcap_1644_fail:
    goto rx1642_fail
  rxcap_1644_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1642_cur."!cursor_pos"(rx1642_pos)
    $P10 = rx1642_cur."package_def"()
    unless $P10, rx1642_fail
    rx1642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1642_pos = $P10."pos"()
.annotate 'line', 769
  # rx pass
    rx1642_cur."!cursor_pass"(rx1642_pos, "package_declarator:sym<knowhow>")
    if_null rx1642_debug, debug_1139
    rx1642_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx1642_pos)
  debug_1139:
    .return (rx1642_cur)
  rx1642_restart:
.annotate 'line', 462
    if_null rx1642_debug, debug_1140
    rx1642_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_1140:
  rx1642_fail:
    (rx1642_rep, rx1642_pos, $I10, $P10) = rx1642_cur."!mark_fail"(0)
    lt rx1642_pos, -1, rx1642_done
    eq rx1642_pos, -1, rx1642_fail
    jump $I10
  rx1642_done:
    rx1642_cur."!cursor_fail"()
    if_null rx1642_debug, debug_1141
    rx1642_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_1141:
    .return (rx1642_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("177_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P109 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("178_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 775
    new $P103, "Undef"
    set $P1647, $P103
    .lex "$*OUTERPACKAGE", $P1647
.annotate 'line', 776
    new $P104, "Undef"
    set $P1648, $P104
    .lex "$*PKGDECL", $P1648
.annotate 'line', 462
    .local string rx1649_tgt
    .local int rx1649_pos
    .local int rx1649_off
    .local int rx1649_eos
    .local int rx1649_rep
    .local pmc rx1649_cur
    .local pmc rx1649_debug
    (rx1649_cur, rx1649_pos, rx1649_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1649_cur
    .local pmc match
    .lex "$/", match
    length rx1649_eos, rx1649_tgt
    gt rx1649_pos, rx1649_eos, rx1649_done
    set rx1649_off, 0
    lt rx1649_pos, 2, rx1649_start
    sub rx1649_off, rx1649_pos, 1
    substr rx1649_tgt, rx1649_tgt, rx1649_off
  rx1649_start:
    eq $I10, 1, rx1649_restart
    if_null rx1649_debug, debug_1142
    rx1649_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1650_done
    goto rxscan1650_scan
  rxscan1650_loop:
    (rx1649_pos) = rx1649_cur."from"()
    inc rx1649_pos
    rx1649_cur."!cursor_from"(rx1649_pos)
    ge rx1649_pos, rx1649_eos, rxscan1650_done
  rxscan1650_scan:
    set_addr $I10, rxscan1650_loop
    rx1649_cur."!mark_push"(0, rx1649_pos, $I10)
  rxscan1650_done:
.annotate 'line', 775
    rx1649_cur."!cursor_pos"(rx1649_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1143
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1144
    die "Contextual $*PACKAGE not found"
  vivify_1144:
  vivify_1143:
    set $P1647, $P107
.annotate 'line', 776
    rx1649_cur."!cursor_pos"(rx1649_pos)
    new $P108, "String"
    assign $P108, "class"
    set $P1648, $P108
.annotate 'line', 777
  # rx subcapture "sym"
    set_addr $I10, rxcap_1651_fail
    rx1649_cur."!mark_push"(0, rx1649_pos, $I10)
  # rx literal  "class"
    add $I11, rx1649_pos, 5
    gt $I11, rx1649_eos, rx1649_fail
    sub $I11, rx1649_pos, rx1649_off
    substr $S10, rx1649_tgt, $I11, 5
    ne $S10, "class", rx1649_fail
    add rx1649_pos, 5
    set_addr $I10, rxcap_1651_fail
    ($I12, $I11) = rx1649_cur."!mark_peek"($I10)
    rx1649_cur."!cursor_pos"($I11)
    ($P10) = rx1649_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1649_pos, "")
    rx1649_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1651_done
  rxcap_1651_fail:
    goto rx1649_fail
  rxcap_1651_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1649_cur."!cursor_pos"(rx1649_pos)
    $P10 = rx1649_cur."package_def"()
    unless $P10, rx1649_fail
    rx1649_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1649_pos = $P10."pos"()
.annotate 'line', 774
  # rx pass
    rx1649_cur."!cursor_pass"(rx1649_pos, "package_declarator:sym<class>")
    if_null rx1649_debug, debug_1145
    rx1649_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx1649_pos)
  debug_1145:
    .return (rx1649_cur)
  rx1649_restart:
.annotate 'line', 462
    if_null rx1649_debug, debug_1146
    rx1649_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_1146:
  rx1649_fail:
    (rx1649_rep, rx1649_pos, $I10, $P10) = rx1649_cur."!mark_fail"(0)
    lt rx1649_pos, -1, rx1649_done
    eq rx1649_pos, -1, rx1649_fail
    jump $I10
  rx1649_done:
    rx1649_cur."!cursor_fail"()
    if_null rx1649_debug, debug_1147
    rx1649_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_1147:
    .return (rx1649_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("179_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P109 = self."!PREFIX__!subrule"("package_def", "class")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("180_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 780
    new $P103, "Undef"
    set $P1654, $P103
    .lex "$*OUTERPACKAGE", $P1654
.annotate 'line', 781
    new $P104, "Undef"
    set $P1655, $P104
    .lex "$*PKGDECL", $P1655
.annotate 'line', 462
    .local string rx1656_tgt
    .local int rx1656_pos
    .local int rx1656_off
    .local int rx1656_eos
    .local int rx1656_rep
    .local pmc rx1656_cur
    .local pmc rx1656_debug
    (rx1656_cur, rx1656_pos, rx1656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1656_cur
    .local pmc match
    .lex "$/", match
    length rx1656_eos, rx1656_tgt
    gt rx1656_pos, rx1656_eos, rx1656_done
    set rx1656_off, 0
    lt rx1656_pos, 2, rx1656_start
    sub rx1656_off, rx1656_pos, 1
    substr rx1656_tgt, rx1656_tgt, rx1656_off
  rx1656_start:
    eq $I10, 1, rx1656_restart
    if_null rx1656_debug, debug_1148
    rx1656_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1657_done
    goto rxscan1657_scan
  rxscan1657_loop:
    (rx1656_pos) = rx1656_cur."from"()
    inc rx1656_pos
    rx1656_cur."!cursor_from"(rx1656_pos)
    ge rx1656_pos, rx1656_eos, rxscan1657_done
  rxscan1657_scan:
    set_addr $I10, rxscan1657_loop
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  rxscan1657_done:
.annotate 'line', 780
    rx1656_cur."!cursor_pos"(rx1656_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1149
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1150
    die "Contextual $*PACKAGE not found"
  vivify_1150:
  vivify_1149:
    set $P1654, $P107
.annotate 'line', 781
    rx1656_cur."!cursor_pos"(rx1656_pos)
    new $P108, "String"
    assign $P108, "grammar"
    set $P1655, $P108
.annotate 'line', 782
  # rx subcapture "sym"
    set_addr $I10, rxcap_1658_fail
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx1656_pos, 7
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    substr $S10, rx1656_tgt, $I11, 7
    ne $S10, "grammar", rx1656_fail
    add rx1656_pos, 7
    set_addr $I10, rxcap_1658_fail
    ($I12, $I11) = rx1656_cur."!mark_peek"($I10)
    rx1656_cur."!cursor_pos"($I11)
    ($P10) = rx1656_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1656_pos, "")
    rx1656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1658_done
  rxcap_1658_fail:
    goto rx1656_fail
  rxcap_1658_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1656_cur."!cursor_pos"(rx1656_pos)
    $P10 = rx1656_cur."package_def"()
    unless $P10, rx1656_fail
    rx1656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1656_pos = $P10."pos"()
.annotate 'line', 779
  # rx pass
    rx1656_cur."!cursor_pass"(rx1656_pos, "package_declarator:sym<grammar>")
    if_null rx1656_debug, debug_1151
    rx1656_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx1656_pos)
  debug_1151:
    .return (rx1656_cur)
  rx1656_restart:
.annotate 'line', 462
    if_null rx1656_debug, debug_1152
    rx1656_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_1152:
  rx1656_fail:
    (rx1656_rep, rx1656_pos, $I10, $P10) = rx1656_cur."!mark_fail"(0)
    lt rx1656_pos, -1, rx1656_done
    eq rx1656_pos, -1, rx1656_fail
    jump $I10
  rx1656_done:
    rx1656_cur."!cursor_fail"()
    if_null rx1656_debug, debug_1153
    rx1656_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_1153:
    .return (rx1656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("181_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P109 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("182_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 785
    new $P103, "Undef"
    set $P1661, $P103
    .lex "$*OUTERPACKAGE", $P1661
.annotate 'line', 786
    new $P104, "Undef"
    set $P1662, $P104
    .lex "$*PKGDECL", $P1662
.annotate 'line', 462
    .local string rx1663_tgt
    .local int rx1663_pos
    .local int rx1663_off
    .local int rx1663_eos
    .local int rx1663_rep
    .local pmc rx1663_cur
    .local pmc rx1663_debug
    (rx1663_cur, rx1663_pos, rx1663_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1663_cur
    .local pmc match
    .lex "$/", match
    length rx1663_eos, rx1663_tgt
    gt rx1663_pos, rx1663_eos, rx1663_done
    set rx1663_off, 0
    lt rx1663_pos, 2, rx1663_start
    sub rx1663_off, rx1663_pos, 1
    substr rx1663_tgt, rx1663_tgt, rx1663_off
  rx1663_start:
    eq $I10, 1, rx1663_restart
    if_null rx1663_debug, debug_1154
    rx1663_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_1154:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1664_done
    goto rxscan1664_scan
  rxscan1664_loop:
    (rx1663_pos) = rx1663_cur."from"()
    inc rx1663_pos
    rx1663_cur."!cursor_from"(rx1663_pos)
    ge rx1663_pos, rx1663_eos, rxscan1664_done
  rxscan1664_scan:
    set_addr $I10, rxscan1664_loop
    rx1663_cur."!mark_push"(0, rx1663_pos, $I10)
  rxscan1664_done:
.annotate 'line', 785
    rx1663_cur."!cursor_pos"(rx1663_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1155
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1156
    die "Contextual $*PACKAGE not found"
  vivify_1156:
  vivify_1155:
    set $P1661, $P107
.annotate 'line', 786
    rx1663_cur."!cursor_pos"(rx1663_pos)
    new $P108, "String"
    assign $P108, "role"
    set $P1662, $P108
.annotate 'line', 787
  # rx subcapture "sym"
    set_addr $I10, rxcap_1665_fail
    rx1663_cur."!mark_push"(0, rx1663_pos, $I10)
  # rx literal  "role"
    add $I11, rx1663_pos, 4
    gt $I11, rx1663_eos, rx1663_fail
    sub $I11, rx1663_pos, rx1663_off
    substr $S10, rx1663_tgt, $I11, 4
    ne $S10, "role", rx1663_fail
    add rx1663_pos, 4
    set_addr $I10, rxcap_1665_fail
    ($I12, $I11) = rx1663_cur."!mark_peek"($I10)
    rx1663_cur."!cursor_pos"($I11)
    ($P10) = rx1663_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1663_pos, "")
    rx1663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1665_done
  rxcap_1665_fail:
    goto rx1663_fail
  rxcap_1665_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1663_cur."!cursor_pos"(rx1663_pos)
    $P10 = rx1663_cur."package_def"()
    unless $P10, rx1663_fail
    rx1663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1663_pos = $P10."pos"()
.annotate 'line', 784
  # rx pass
    rx1663_cur."!cursor_pass"(rx1663_pos, "package_declarator:sym<role>")
    if_null rx1663_debug, debug_1157
    rx1663_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx1663_pos)
  debug_1157:
    .return (rx1663_cur)
  rx1663_restart:
.annotate 'line', 462
    if_null rx1663_debug, debug_1158
    rx1663_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_1158:
  rx1663_fail:
    (rx1663_rep, rx1663_pos, $I10, $P10) = rx1663_cur."!mark_fail"(0)
    lt rx1663_pos, -1, rx1663_done
    eq rx1663_pos, -1, rx1663_fail
    jump $I10
  rx1663_done:
    rx1663_cur."!cursor_fail"()
    if_null rx1663_debug, debug_1159
    rx1663_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_1159:
    .return (rx1663_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("183_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P109 = self."!PREFIX__!subrule"("package_def", "role")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("184_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 790
    new $P103, "Undef"
    set $P1668, $P103
    .lex "$*OUTERPACKAGE", $P1668
.annotate 'line', 791
    new $P104, "Undef"
    set $P1669, $P104
    .lex "$*PKGDECL", $P1669
.annotate 'line', 462
    .local string rx1670_tgt
    .local int rx1670_pos
    .local int rx1670_off
    .local int rx1670_eos
    .local int rx1670_rep
    .local pmc rx1670_cur
    .local pmc rx1670_debug
    (rx1670_cur, rx1670_pos, rx1670_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1670_cur
    .local pmc match
    .lex "$/", match
    length rx1670_eos, rx1670_tgt
    gt rx1670_pos, rx1670_eos, rx1670_done
    set rx1670_off, 0
    lt rx1670_pos, 2, rx1670_start
    sub rx1670_off, rx1670_pos, 1
    substr rx1670_tgt, rx1670_tgt, rx1670_off
  rx1670_start:
    eq $I10, 1, rx1670_restart
    if_null rx1670_debug, debug_1160
    rx1670_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1671_done
    goto rxscan1671_scan
  rxscan1671_loop:
    (rx1670_pos) = rx1670_cur."from"()
    inc rx1670_pos
    rx1670_cur."!cursor_from"(rx1670_pos)
    ge rx1670_pos, rx1670_eos, rxscan1671_done
  rxscan1671_scan:
    set_addr $I10, rxscan1671_loop
    rx1670_cur."!mark_push"(0, rx1670_pos, $I10)
  rxscan1671_done:
.annotate 'line', 790
    rx1670_cur."!cursor_pos"(rx1670_pos)
    find_dynamic_lex $P107, "$*PACKAGE"
    unless_null $P107, vivify_1161
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1162
    die "Contextual $*PACKAGE not found"
  vivify_1162:
  vivify_1161:
    set $P1668, $P107
.annotate 'line', 791
    rx1670_cur."!cursor_pos"(rx1670_pos)
    new $P108, "String"
    assign $P108, "native"
    set $P1669, $P108
.annotate 'line', 792
  # rx subcapture "sym"
    set_addr $I10, rxcap_1672_fail
    rx1670_cur."!mark_push"(0, rx1670_pos, $I10)
  # rx literal  "native"
    add $I11, rx1670_pos, 6
    gt $I11, rx1670_eos, rx1670_fail
    sub $I11, rx1670_pos, rx1670_off
    substr $S10, rx1670_tgt, $I11, 6
    ne $S10, "native", rx1670_fail
    add rx1670_pos, 6
    set_addr $I10, rxcap_1672_fail
    ($I12, $I11) = rx1670_cur."!mark_peek"($I10)
    rx1670_cur."!cursor_pos"($I11)
    ($P10) = rx1670_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1670_pos, "")
    rx1670_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1672_done
  rxcap_1672_fail:
    goto rx1670_fail
  rxcap_1672_done:
  # rx subrule "package_def" subtype=capture negate=
    rx1670_cur."!cursor_pos"(rx1670_pos)
    $P10 = rx1670_cur."package_def"()
    unless $P10, rx1670_fail
    rx1670_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx1670_pos = $P10."pos"()
.annotate 'line', 789
  # rx pass
    rx1670_cur."!cursor_pass"(rx1670_pos, "package_declarator:sym<native>")
    if_null rx1670_debug, debug_1163
    rx1670_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx1670_pos)
  debug_1163:
    .return (rx1670_cur)
  rx1670_restart:
.annotate 'line', 462
    if_null rx1670_debug, debug_1164
    rx1670_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_1164:
  rx1670_fail:
    (rx1670_rep, rx1670_pos, $I10, $P10) = rx1670_cur."!mark_fail"(0)
    lt rx1670_pos, -1, rx1670_done
    eq rx1670_pos, -1, rx1670_fail
    jump $I10
  rx1670_done:
    rx1670_cur."!cursor_fail"()
    if_null rx1670_debug, debug_1165
    rx1670_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_1165:
    .return (rx1670_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("185_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P109 = self."!PREFIX__!subrule"("package_def", "native")
    new $P110, "ResizablePMCArray"
    push $P110, $P109
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<stub>"  :subid("186_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 795
    new $P103, "Undef"
    set $P1675, $P103
    .lex "$*OUTERPACKAGE", $P1675
.annotate 'line', 796
    new $P104, "Undef"
    set $P1676, $P104
    .lex "$*PKGDECL", $P1676
.annotate 'line', 462
    .local string rx1677_tgt
    .local int rx1677_pos
    .local int rx1677_off
    .local int rx1677_eos
    .local int rx1677_rep
    .local pmc rx1677_cur
    .local pmc rx1677_debug
    (rx1677_cur, rx1677_pos, rx1677_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1677_cur
    .local pmc match
    .lex "$/", match
    length rx1677_eos, rx1677_tgt
    gt rx1677_pos, rx1677_eos, rx1677_done
    set rx1677_off, 0
    lt rx1677_pos, 2, rx1677_start
    sub rx1677_off, rx1677_pos, 1
    substr rx1677_tgt, rx1677_tgt, rx1677_off
  rx1677_start:
    eq $I10, 1, rx1677_restart
    if_null rx1677_debug, debug_1166
    rx1677_cur."!cursor_debug"("START", "package_declarator:sym<stub>")
  debug_1166:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1678_done
    goto rxscan1678_scan
  rxscan1678_loop:
    (rx1677_pos) = rx1677_cur."from"()
    inc rx1677_pos
    rx1677_cur."!cursor_from"(rx1677_pos)
    ge rx1677_pos, rx1677_eos, rxscan1678_done
  rxscan1678_scan:
    set_addr $I10, rxscan1678_loop
    rx1677_cur."!mark_push"(0, rx1677_pos, $I10)
  rxscan1678_done:
.annotate 'line', 794
  # rx subrule "ws" subtype=method negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."ws"()
    unless $P10, rx1677_fail
    rx1677_pos = $P10."pos"()
.annotate 'line', 795
    rx1677_cur."!cursor_pos"(rx1677_pos)
    find_dynamic_lex $P108, "$*PACKAGE"
    unless_null $P108, vivify_1167
    get_hll_global $P106, "GLOBAL"
    get_who $P107, $P106
    set $P108, $P107["$PACKAGE"]
    unless_null $P108, vivify_1168
    die "Contextual $*PACKAGE not found"
  vivify_1168:
  vivify_1167:
    set $P1675, $P108
  # rx subrule "ws" subtype=method negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."ws"()
    unless $P10, rx1677_fail
    rx1677_pos = $P10."pos"()
.annotate 'line', 796
    rx1677_cur."!cursor_pos"(rx1677_pos)
    new $P110, "String"
    assign $P110, "stub"
    set $P1676, $P110
  # rx subrule "ws" subtype=method negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."ws"()
    unless $P10, rx1677_fail
    rx1677_pos = $P10."pos"()
.annotate 'line', 797
  # rx subcapture "sym"
    set_addr $I10, rxcap_1679_fail
    rx1677_cur."!mark_push"(0, rx1677_pos, $I10)
  # rx literal  "stub"
    add $I11, rx1677_pos, 4
    gt $I11, rx1677_eos, rx1677_fail
    sub $I11, rx1677_pos, rx1677_off
    substr $S10, rx1677_tgt, $I11, 4
    ne $S10, "stub", rx1677_fail
    add rx1677_pos, 4
    set_addr $I10, rxcap_1679_fail
    ($I12, $I11) = rx1677_cur."!mark_peek"($I10)
    rx1677_cur."!cursor_pos"($I11)
    ($P10) = rx1677_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1677_pos, "")
    rx1677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1679_done
  rxcap_1679_fail:
    goto rx1677_fail
  rxcap_1679_done:
  # rx subrule "ws" subtype=method negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."ws"()
    unless $P10, rx1677_fail
    rx1677_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."name"()
    unless $P10, rx1677_fail
    rx1677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1677_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."ws"()
    unless $P10, rx1677_fail
    rx1677_pos = $P10."pos"()
.annotate 'line', 798
  # rx literal  "metaclass"
    add $I11, rx1677_pos, 9
    gt $I11, rx1677_eos, rx1677_fail
    sub $I11, rx1677_pos, rx1677_off
    substr $S10, rx1677_tgt, $I11, 9
    ne $S10, "metaclass", rx1677_fail
    add rx1677_pos, 9
  # rx subrule "ws" subtype=method negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."ws"()
    unless $P10, rx1677_fail
    rx1677_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."name"()
    unless $P10, rx1677_fail
    rx1677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("metaclass")
    rx1677_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."ws"()
    unless $P10, rx1677_fail
    rx1677_pos = $P10."pos"()
.annotate 'line', 799
  # rx literal  "{"
    add $I11, rx1677_pos, 1
    gt $I11, rx1677_eos, rx1677_fail
    sub $I11, rx1677_pos, rx1677_off
    ord $I11, rx1677_tgt, $I11
    ne $I11, 123, rx1677_fail
    add rx1677_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."ws"()
    unless $P10, rx1677_fail
    rx1677_pos = $P10."pos"()
  # rx literal  "..."
    add $I11, rx1677_pos, 3
    gt $I11, rx1677_eos, rx1677_fail
    sub $I11, rx1677_pos, rx1677_off
    substr $S10, rx1677_tgt, $I11, 3
    ne $S10, "...", rx1677_fail
    add rx1677_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."ws"()
    unless $P10, rx1677_fail
    rx1677_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1677_pos, 1
    gt $I11, rx1677_eos, rx1677_fail
    sub $I11, rx1677_pos, rx1677_off
    ord $I11, rx1677_tgt, $I11
    ne $I11, 125, rx1677_fail
    add rx1677_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1677_cur."!cursor_pos"(rx1677_pos)
    $P10 = rx1677_cur."ws"()
    unless $P10, rx1677_fail
    rx1677_pos = $P10."pos"()
.annotate 'line', 794
  # rx pass
    rx1677_cur."!cursor_pass"(rx1677_pos, "package_declarator:sym<stub>")
    if_null rx1677_debug, debug_1169
    rx1677_cur."!cursor_debug"("PASS", "package_declarator:sym<stub>", " at pos=", rx1677_pos)
  debug_1169:
    .return (rx1677_cur)
  rx1677_restart:
.annotate 'line', 462
    if_null rx1677_debug, debug_1170
    rx1677_cur."!cursor_debug"("NEXT", "package_declarator:sym<stub>")
  debug_1170:
  rx1677_fail:
    (rx1677_rep, rx1677_pos, $I10, $P10) = rx1677_cur."!mark_fail"(0)
    lt rx1677_pos, -1, rx1677_done
    eq rx1677_pos, -1, rx1677_fail
    jump $I10
  rx1677_done:
    rx1677_cur."!cursor_fail"()
    if_null rx1677_debug, debug_1171
    rx1677_cur."!cursor_debug"("FAIL", "package_declarator:sym<stub>")
  debug_1171:
    .return (rx1677_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<stub>"  :subid("187_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P119 = self."!PREFIX__!subrule"("ws", "")
    new $P120, "ResizablePMCArray"
    push $P120, $P119
    .return ($P120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("188_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1687 = "189_1325892461.451" 
    capture_lex $P1687
.annotate 'line', 803
    new $P103, "Undef"
    set $P1682, $P103
    .lex "$*PACKAGE", $P1682
.annotate 'line', 462
    .local string rx1683_tgt
    .local int rx1683_pos
    .local int rx1683_off
    .local int rx1683_eos
    .local int rx1683_rep
    .local pmc rx1683_cur
    .local pmc rx1683_debug
    (rx1683_cur, rx1683_pos, rx1683_tgt, $I10) = self."!cursor_start"()
    rx1683_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx1683_cur
    .local pmc match
    .lex "$/", match
    length rx1683_eos, rx1683_tgt
    gt rx1683_pos, rx1683_eos, rx1683_done
    set rx1683_off, 0
    lt rx1683_pos, 2, rx1683_start
    sub rx1683_off, rx1683_pos, 1
    substr rx1683_tgt, rx1683_tgt, rx1683_off
  rx1683_start:
    eq $I10, 1, rx1683_restart
    if_null rx1683_debug, debug_1172
    rx1683_cur."!cursor_debug"("START", "package_def")
  debug_1172:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1684_done
    goto rxscan1684_scan
  rxscan1684_loop:
    (rx1683_pos) = rx1683_cur."from"()
    inc rx1683_pos
    rx1683_cur."!cursor_from"(rx1683_pos)
    ge rx1683_pos, rx1683_eos, rxscan1684_done
  rxscan1684_scan:
    set_addr $I10, rxscan1684_loop
    rx1683_cur."!mark_push"(0, rx1683_pos, $I10)
  rxscan1684_done:
.annotate 'line', 802
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
.annotate 'line', 803
    rx1683_cur."!cursor_pos"(rx1683_pos)
    set $P107, $P1682
    unless_null $P107, vivify_1173
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$PACKAGE"]
    unless_null $P107, vivify_1174
    die "Contextual $*PACKAGE not found"
  vivify_1174:
  vivify_1173:
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
.annotate 'line', 805
  # rx subrule "name" subtype=capture negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."name"()
    unless $P10, rx1683_fail
    rx1683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1683_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
.annotate 'line', 806
  # rx rxquantr1685 ** 0..1
    set_addr $I10, rxquantr1685_done
    rx1683_cur."!mark_push"(0, rx1683_pos, $I10)
  rxquantr1685_loop:
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1683_pos, 2
    gt $I11, rx1683_eos, rx1683_fail
    sub $I11, rx1683_pos, rx1683_off
    substr $S10, rx1683_tgt, $I11, 2
    ne $S10, "is", rx1683_fail
    add rx1683_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx1683_pos, 5
    gt $I11, rx1683_eos, rx1683_fail
    sub $I11, rx1683_pos, rx1683_off
    substr $S10, rx1683_tgt, $I11, 5
    ne $S10, "repr(", rx1683_fail
    add rx1683_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."quote_EXPR"()
    unless $P10, rx1683_fail
    rx1683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx1683_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1683_pos, 1
    gt $I11, rx1683_eos, rx1683_fail
    sub $I11, rx1683_pos, rx1683_off
    ord $I11, rx1683_tgt, $I11
    ne $I11, 41, rx1683_fail
    add rx1683_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
    set_addr $I10, rxquantr1685_done
    (rx1683_rep) = rx1683_cur."!mark_commit"($I10)
  rxquantr1685_done:
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
.annotate 'line', 808
    rx1683_cur."!cursor_pos"(rx1683_pos)
    find_lex $P116, unicode:"$\x{a2}"
    $P117 = $P116."MATCH"()
    store_lex "$/", $P117
    .const 'Sub' $P1687 = "189_1325892461.451" 
    capture_lex $P1687
    $P119 = $P1687()
.annotate 'line', 834
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
.annotate 'line', 836
  # rx rxquantr1722 ** 0..1
    set_addr $I10, rxquantr1722_done
    rx1683_cur."!mark_push"(0, rx1683_pos, $I10)
  rxquantr1722_loop:
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx1683_pos, 2
    gt $I11, rx1683_eos, rx1683_fail
    sub $I11, rx1683_pos, rx1683_off
    substr $S10, rx1683_tgt, $I11, 2
    ne $S10, "is", rx1683_fail
    add rx1683_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."name"()
    unless $P10, rx1683_fail
    rx1683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx1683_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
    set_addr $I10, rxquantr1722_done
    (rx1683_rep) = rx1683_cur."!mark_commit"($I10)
  rxquantr1722_done:
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
.annotate 'line', 837
  # rx rxquantr1723 ** 0..*
    set_addr $I10, rxquantr1723_done
    rx1683_cur."!mark_push"(0, rx1683_pos, $I10)
  rxquantr1723_loop:
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx1683_pos, 4
    gt $I11, rx1683_eos, rx1683_fail
    sub $I11, rx1683_pos, rx1683_off
    substr $S10, rx1683_tgt, $I11, 4
    ne $S10, "does", rx1683_fail
    add rx1683_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."name"()
    unless $P10, rx1683_fail
    rx1683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx1683_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
    set_addr $I10, rxquantr1723_done
    (rx1683_rep) = rx1683_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1723_done
    rx1683_cur."!mark_push"(rx1683_rep, rx1683_pos, $I10)
    goto rxquantr1723_loop
  rxquantr1723_done:
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  alt1724_0:
.annotate 'line', 838
    set_addr $I10, alt1724_1
    rx1683_cur."!mark_push"(0, rx1683_pos, $I10)
.annotate 'line', 839
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1683_pos, 1
    gt $I11, rx1683_eos, rx1683_fail
    sub $I11, rx1683_pos, rx1683_off
    ord $I11, rx1683_tgt, $I11
    ne $I11, 59, rx1683_fail
    add rx1683_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."comp_unit"()
    unless $P10, rx1683_fail
    rx1683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx1683_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
    goto alt1724_end
  alt1724_1:
    set_addr $I10, alt1724_2
    rx1683_cur."!mark_push"(0, rx1683_pos, $I10)
.annotate 'line', 840
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1683_pos, rx1683_off
    substr $S10, rx1683_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1683_fail
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."block"()
    unless $P10, rx1683_fail
    rx1683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1683_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
    goto alt1724_end
  alt1724_2:
.annotate 'line', 841
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."panic"("Malformed package declaration")
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
  alt1724_end:
.annotate 'line', 842
  # rx subrule "ws" subtype=method negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."ws"()
    unless $P10, rx1683_fail
    rx1683_pos = $P10."pos"()
.annotate 'line', 802
  # rx pass
    rx1683_cur."!cursor_pass"(rx1683_pos, "package_def")
    if_null rx1683_debug, debug_1242
    rx1683_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx1683_pos)
  debug_1242:
    .return (rx1683_cur)
  rx1683_restart:
.annotate 'line', 462
    if_null rx1683_debug, debug_1243
    rx1683_cur."!cursor_debug"("NEXT", "package_def")
  debug_1243:
  rx1683_fail:
    (rx1683_rep, rx1683_pos, $I10, $P10) = rx1683_cur."!mark_fail"(0)
    lt rx1683_pos, -1, rx1683_done
    eq rx1683_pos, -1, rx1683_fail
    jump $I10
  rx1683_done:
    rx1683_cur."!cursor_fail"()
    if_null rx1683_debug, debug_1244
    rx1683_cur."!cursor_debug"("FAIL", "package_def")
  debug_1244:
    .return (rx1683_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1686"  :anon :subid("189_1325892461.451") :outer("188_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 811
    $P1689 = root_new ['parrot';'Hash']
    set $P1688, $P1689
    .lex "%args", $P1688
.annotate 'line', 808
    set $P1690, $P1688
    unless_null $P1690, vivify_1175
    $P1690 = root_new ['parrot';'Hash']
  vivify_1175:
.annotate 'line', 812
    find_lex $P1691, "$/"
    unless_null $P1691, vivify_1176
    $P1691 = root_new ['parrot';'Hash']
  vivify_1176:
    set $P118, $P1691["name"]
    unless_null $P118, vivify_1177
    new $P118, "Undef"
  vivify_1177:
    set $S100, $P118
    new $P119, 'String'
    set $P119, $S100
    set $P1692, $P1688
    unless_null $P1692, vivify_1178
    $P1692 = root_new ['parrot';'Hash']
    set $P1688, $P1692
  vivify_1178:
    set $P1692["name"], $P119
.annotate 'line', 813
    find_lex $P1694, "$/"
    unless_null $P1694, vivify_1179
    $P1694 = root_new ['parrot';'Hash']
  vivify_1179:
    set $P118, $P1694["repr"]
    unless_null $P118, vivify_1180
    new $P118, "Undef"
  vivify_1180:
    unless $P118, if_1693_end
.annotate 'line', 814
    new $P119, "Float"
    assign $P119, 0
    set $I100, $P119
    new $P120, "Float"
    assign $P120, 0
    set $I101, $P120
    find_lex $P1695, "$/"
    unless_null $P1695, vivify_1181
    $P1695 = root_new ['parrot';'Hash']
  vivify_1181:
    set $P1696, $P1695["repr"]
    unless_null $P1696, vivify_1182
    $P1696 = root_new ['parrot';'ResizablePMCArray']
  vivify_1182:
    set $P1697, $P1696[$I101]
    unless_null $P1697, vivify_1183
    $P1697 = root_new ['parrot';'Hash']
  vivify_1183:
    set $P1698, $P1697["quote_delimited"]
    unless_null $P1698, vivify_1184
    $P1698 = root_new ['parrot';'Hash']
  vivify_1184:
    set $P1699, $P1698["quote_atom"]
    unless_null $P1699, vivify_1185
    $P1699 = root_new ['parrot';'ResizablePMCArray']
  vivify_1185:
    set $P121, $P1699[$I100]
    unless_null $P121, vivify_1186
    new $P121, "Undef"
  vivify_1186:
    set $S100, $P121
    new $P122, 'String'
    set $P122, $S100
    set $P1700, $P1688
    unless_null $P1700, vivify_1187
    $P1700 = root_new ['parrot';'Hash']
    set $P1688, $P1700
  vivify_1187:
    set $P1700["repr"], $P122
  if_1693_end:
.annotate 'line', 816
    find_dynamic_lex $P120, "$*W"
    unless_null $P120, vivify_1188
    get_hll_global $P118, "GLOBAL"
    get_who $P119, $P118
    set $P120, $P119["$W"]
    unless_null $P120, vivify_1189
    die "Contextual $*W not found"
  vivify_1189:
  vivify_1188:
    find_dynamic_lex $P123, "$*PKGDECL"
    unless_null $P123, vivify_1190
    get_hll_global $P121, "GLOBAL"
    get_who $P122, $P121
    set $P123, $P122["$PKGDECL"]
    unless_null $P123, vivify_1191
    die "Contextual $*PKGDECL not found"
  vivify_1191:
  vivify_1190:
    find_dynamic_lex $P126, "%*HOW"
    unless_null $P126, vivify_1192
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P126, $P125["%HOW"]
    unless_null $P126, vivify_1193
    die "Contextual %*HOW not found"
  vivify_1193:
  vivify_1192:
    set $P127, $P126[$P123]
    unless_null $P127, vivify_1194
    new $P127, "Undef"
  vivify_1194:
    set $P1701, $P1688
    unless_null $P1701, vivify_1195
    $P1701 = root_new ['parrot';'Hash']
  vivify_1195:
    $P128 = $P120."pkg_create_mo"($P127, $P1701 :flat)
    store_dynamic_lex "$*PACKAGE", $P128
.annotate 'line', 819
    find_dynamic_lex $P122, "$*SCOPE"
    unless_null $P122, vivify_1196
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["$SCOPE"]
    unless_null $P122, vivify_1197
    die "Contextual $*SCOPE not found"
  vivify_1197:
  vivify_1196:
    set $S100, $P122
    iseq $I100, $S100, "our"
    unless $I100, unless_1703
    new $P119, 'Integer'
    set $P119, $I100
    goto unless_1703_end
  unless_1703:
    find_dynamic_lex $P125, "$*SCOPE"
    unless_null $P125, vivify_1198
    get_hll_global $P123, "GLOBAL"
    get_who $P124, $P123
    set $P125, $P124["$SCOPE"]
    unless_null $P125, vivify_1199
    die "Contextual $*SCOPE not found"
  vivify_1199:
  vivify_1198:
    set $S101, $P125
    iseq $I101, $S101, ""
    new $P119, 'Integer'
    set $P119, $I101
  unless_1703_end:
    if $P119, if_1702
.annotate 'line', 825
    find_dynamic_lex $P130, "$*SCOPE"
    unless_null $P130, vivify_1200
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$SCOPE"]
    unless_null $P130, vivify_1201
    die "Contextual $*SCOPE not found"
  vivify_1201:
  vivify_1200:
    set $S102, $P130
    iseq $I102, $S102, "my"
    if $I102, if_1713
.annotate 'line', 832
    find_lex $P131, "$/"
    unless_null $P131, vivify_1202
    new $P131, "Undef"
  vivify_1202:
    $P132 = $P131."CURSOR"()
    find_dynamic_lex $P135, "$*SCOPE"
    unless_null $P135, vivify_1203
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$SCOPE"]
    unless_null $P135, vivify_1204
    die "Contextual $*SCOPE not found"
  vivify_1204:
  vivify_1203:
    concat $P136, $P135, " scoped packages are not supported"
    $P137 = $P132."panic"($P136)
.annotate 'line', 831
    set $P127, $P137
.annotate 'line', 825
    goto if_1713_end
  if_1713:
.annotate 'line', 826
    find_lex $P1715, "$/"
    unless_null $P1715, vivify_1205
    $P1715 = root_new ['parrot';'Hash']
  vivify_1205:
    set $P1716, $P1715["name"]
    unless_null $P1716, vivify_1206
    $P1716 = root_new ['parrot';'Hash']
  vivify_1206:
    set $P131, $P1716["identifier"]
    unless_null $P131, vivify_1207
    new $P131, "Undef"
  vivify_1207:
    set $N100, $P131
    set $N101, 1
    isne $I103, $N100, $N101
    unless $I103, if_1714_end
.annotate 'line', 827
    find_lex $P1717, "$/"
    unless_null $P1717, vivify_1208
    $P1717 = root_new ['parrot';'Hash']
  vivify_1208:
    set $P132, $P1717["name"]
    unless_null $P132, vivify_1209
    new $P132, "Undef"
  vivify_1209:
    $P133 = $P132."CURSOR"()
    $P133."panic"("A my scoped package cannot have a multi-part name yet")
  if_1714_end:
.annotate 'line', 829
    find_dynamic_lex $P133, "$*W"
    unless_null $P133, vivify_1210
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$W"]
    unless_null $P133, vivify_1211
    die "Contextual $*W not found"
  vivify_1211:
  vivify_1210:
    new $P134, "Float"
    assign $P134, 0
    set $I103, $P134
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "NQP"
    nqp_get_package_through_who $P137, $P136, "Actions"
    get_who $P138, $P137
    set $P1718, $P138["@BLOCK"]
    unless_null $P1718, vivify_1212
    $P1718 = root_new ['parrot';'ResizablePMCArray']
  vivify_1212:
    set $P139, $P1718[$I103]
    unless_null $P139, vivify_1213
    new $P139, "Undef"
  vivify_1213:
    new $P140, "Float"
    assign $P140, 0
    set $I104, $P140
    find_lex $P1719, "$/"
    unless_null $P1719, vivify_1214
    $P1719 = root_new ['parrot';'Hash']
  vivify_1214:
    set $P1720, $P1719["name"]
    unless_null $P1720, vivify_1215
    $P1720 = root_new ['parrot';'Hash']
  vivify_1215:
    set $P1721, $P1720["identifier"]
    unless_null $P1721, vivify_1216
    $P1721 = root_new ['parrot';'ResizablePMCArray']
  vivify_1216:
    set $P141, $P1721[$I104]
    unless_null $P141, vivify_1217
    new $P141, "Undef"
  vivify_1217:
    find_dynamic_lex $P144, "$*PACKAGE"
    unless_null $P144, vivify_1218
    get_hll_global $P142, "GLOBAL"
    get_who $P143, $P142
    set $P144, $P143["$PACKAGE"]
    unless_null $P144, vivify_1219
    die "Contextual $*PACKAGE not found"
  vivify_1219:
  vivify_1218:
    $P145 = $P133."install_lexical_symbol"($P139, $P141, $P144)
.annotate 'line', 825
    set $P127, $P145
  if_1713_end:
    set $P118, $P127
.annotate 'line', 819
    goto if_1702_end
  if_1702:
.annotate 'line', 820
    find_dynamic_lex $P128, "$*W"
    unless_null $P128, vivify_1220
    get_hll_global $P126, "GLOBAL"
    get_who $P127, $P126
    set $P128, $P127["$W"]
    unless_null $P128, vivify_1221
    die "Contextual $*W not found"
  vivify_1221:
  vivify_1220:
    find_dynamic_lex $P131, "$*OUTERPACKAGE"
    unless_null $P131, vivify_1222
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$OUTERPACKAGE"]
    unless_null $P131, vivify_1223
    die "Contextual $*OUTERPACKAGE not found"
  vivify_1223:
  vivify_1222:
    find_lex $P1704, "$/"
    unless_null $P1704, vivify_1224
    $P1704 = root_new ['parrot';'Hash']
  vivify_1224:
    set $P1705, $P1704["name"]
    unless_null $P1705, vivify_1225
    $P1705 = root_new ['parrot';'Hash']
  vivify_1225:
    set $P132, $P1705["identifier"]
    unless_null $P132, vivify_1226
    new $P132, "Undef"
  vivify_1226:
    find_dynamic_lex $P135, "$*PACKAGE"
    unless_null $P135, vivify_1227
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PACKAGE"]
    unless_null $P135, vivify_1228
    die "Contextual $*PACKAGE not found"
  vivify_1228:
  vivify_1227:
    $P128."install_package_symbol"($P131, $P132, $P135)
.annotate 'line', 821
    find_lex $P1707, "$/"
    unless_null $P1707, vivify_1229
    $P1707 = root_new ['parrot';'Hash']
  vivify_1229:
    set $P1708, $P1707["name"]
    unless_null $P1708, vivify_1230
    $P1708 = root_new ['parrot';'Hash']
  vivify_1230:
    set $P127, $P1708["identifier"]
    unless_null $P127, vivify_1231
    new $P127, "Undef"
  vivify_1231:
    set $N100, $P127
    set $N101, 1
    iseq $I102, $N100, $N101
    if $I102, if_1706
    new $P126, 'Integer'
    set $P126, $I102
    goto if_1706_end
  if_1706:
.annotate 'line', 822
    find_dynamic_lex $P130, "$*W"
    unless_null $P130, vivify_1232
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$W"]
    unless_null $P130, vivify_1233
    die "Contextual $*W not found"
  vivify_1233:
  vivify_1232:
    new $P131, "Float"
    assign $P131, 0
    set $I103, $P131
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "NQP"
    nqp_get_package_through_who $P134, $P133, "Actions"
    get_who $P135, $P134
    set $P1709, $P135["@BLOCK"]
    unless_null $P1709, vivify_1234
    $P1709 = root_new ['parrot';'ResizablePMCArray']
  vivify_1234:
    set $P136, $P1709[$I103]
    unless_null $P136, vivify_1235
    new $P136, "Undef"
  vivify_1235:
    new $P137, "Float"
    assign $P137, 0
    set $I104, $P137
    find_lex $P1710, "$/"
    unless_null $P1710, vivify_1236
    $P1710 = root_new ['parrot';'Hash']
  vivify_1236:
    set $P1711, $P1710["name"]
    unless_null $P1711, vivify_1237
    $P1711 = root_new ['parrot';'Hash']
  vivify_1237:
    set $P1712, $P1711["identifier"]
    unless_null $P1712, vivify_1238
    $P1712 = root_new ['parrot';'ResizablePMCArray']
  vivify_1238:
    set $P138, $P1712[$I104]
    unless_null $P138, vivify_1239
    new $P138, "Undef"
  vivify_1239:
    find_dynamic_lex $P141, "$*PACKAGE"
    unless_null $P141, vivify_1240
    get_hll_global $P139, "GLOBAL"
    get_who $P140, $P139
    set $P141, $P140["$PACKAGE"]
    unless_null $P141, vivify_1241
    die "Contextual $*PACKAGE not found"
  vivify_1241:
  vivify_1240:
    $P142 = $P130."install_lexical_symbol"($P136, $P138, $P141)
.annotate 'line', 821
    set $P126, $P142
  if_1706_end:
.annotate 'line', 819
    set $P118, $P126
  if_1702_end:
.annotate 'line', 808
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("190_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P138 = self."!PREFIX__!subrule"("ws", "")
    new $P139, "ResizablePMCArray"
    push $P139, $P138
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("191_1325892461.451")
    .param pmc param_1727
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 845
    .lex "self", param_1727
    $P103 = param_1727."!protoregex"("scope_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("192_1325892461.451")
    .param pmc param_1729
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 845
    .lex "self", param_1729
    $P104 = param_1729."!PREFIX__!protoregex"("scope_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("193_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1731_tgt
    .local int rx1731_pos
    .local int rx1731_off
    .local int rx1731_eos
    .local int rx1731_rep
    .local pmc rx1731_cur
    .local pmc rx1731_debug
    (rx1731_cur, rx1731_pos, rx1731_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1731_cur
    .local pmc match
    .lex "$/", match
    length rx1731_eos, rx1731_tgt
    gt rx1731_pos, rx1731_eos, rx1731_done
    set rx1731_off, 0
    lt rx1731_pos, 2, rx1731_start
    sub rx1731_off, rx1731_pos, 1
    substr rx1731_tgt, rx1731_tgt, rx1731_off
  rx1731_start:
    eq $I10, 1, rx1731_restart
    if_null rx1731_debug, debug_1245
    rx1731_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_1245:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1732_done
    goto rxscan1732_scan
  rxscan1732_loop:
    (rx1731_pos) = rx1731_cur."from"()
    inc rx1731_pos
    rx1731_cur."!cursor_from"(rx1731_pos)
    ge rx1731_pos, rx1731_eos, rxscan1732_done
  rxscan1732_scan:
    set_addr $I10, rxscan1732_loop
    rx1731_cur."!mark_push"(0, rx1731_pos, $I10)
  rxscan1732_done:
.annotate 'line', 846
  # rx subcapture "sym"
    set_addr $I10, rxcap_1733_fail
    rx1731_cur."!mark_push"(0, rx1731_pos, $I10)
  # rx literal  "my"
    add $I11, rx1731_pos, 2
    gt $I11, rx1731_eos, rx1731_fail
    sub $I11, rx1731_pos, rx1731_off
    substr $S10, rx1731_tgt, $I11, 2
    ne $S10, "my", rx1731_fail
    add rx1731_pos, 2
    set_addr $I10, rxcap_1733_fail
    ($I12, $I11) = rx1731_cur."!mark_peek"($I10)
    rx1731_cur."!cursor_pos"($I11)
    ($P10) = rx1731_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1731_pos, "")
    rx1731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1733_done
  rxcap_1733_fail:
    goto rx1731_fail
  rxcap_1733_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1731_cur."!cursor_pos"(rx1731_pos)
    $P10 = rx1731_cur."scoped"("my")
    unless $P10, rx1731_fail
    rx1731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1731_pos = $P10."pos"()
  # rx pass
    rx1731_cur."!cursor_pass"(rx1731_pos, "scope_declarator:sym<my>")
    if_null rx1731_debug, debug_1246
    rx1731_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1731_pos)
  debug_1246:
    .return (rx1731_cur)
  rx1731_restart:
.annotate 'line', 462
    if_null rx1731_debug, debug_1247
    rx1731_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_1247:
  rx1731_fail:
    (rx1731_rep, rx1731_pos, $I10, $P10) = rx1731_cur."!mark_fail"(0)
    lt rx1731_pos, -1, rx1731_done
    eq rx1731_pos, -1, rx1731_fail
    jump $I10
  rx1731_done:
    rx1731_cur."!cursor_fail"()
    if_null rx1731_debug, debug_1248
    rx1731_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_1248:
    .return (rx1731_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("194_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("scoped", "my")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("195_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1736_tgt
    .local int rx1736_pos
    .local int rx1736_off
    .local int rx1736_eos
    .local int rx1736_rep
    .local pmc rx1736_cur
    .local pmc rx1736_debug
    (rx1736_cur, rx1736_pos, rx1736_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1736_cur
    .local pmc match
    .lex "$/", match
    length rx1736_eos, rx1736_tgt
    gt rx1736_pos, rx1736_eos, rx1736_done
    set rx1736_off, 0
    lt rx1736_pos, 2, rx1736_start
    sub rx1736_off, rx1736_pos, 1
    substr rx1736_tgt, rx1736_tgt, rx1736_off
  rx1736_start:
    eq $I10, 1, rx1736_restart
    if_null rx1736_debug, debug_1249
    rx1736_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_1249:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1737_done
    goto rxscan1737_scan
  rxscan1737_loop:
    (rx1736_pos) = rx1736_cur."from"()
    inc rx1736_pos
    rx1736_cur."!cursor_from"(rx1736_pos)
    ge rx1736_pos, rx1736_eos, rxscan1737_done
  rxscan1737_scan:
    set_addr $I10, rxscan1737_loop
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  rxscan1737_done:
.annotate 'line', 847
  # rx subcapture "sym"
    set_addr $I10, rxcap_1738_fail
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  # rx literal  "our"
    add $I11, rx1736_pos, 3
    gt $I11, rx1736_eos, rx1736_fail
    sub $I11, rx1736_pos, rx1736_off
    substr $S10, rx1736_tgt, $I11, 3
    ne $S10, "our", rx1736_fail
    add rx1736_pos, 3
    set_addr $I10, rxcap_1738_fail
    ($I12, $I11) = rx1736_cur."!mark_peek"($I10)
    rx1736_cur."!cursor_pos"($I11)
    ($P10) = rx1736_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1736_pos, "")
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1738_done
  rxcap_1738_fail:
    goto rx1736_fail
  rxcap_1738_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1736_cur."!cursor_pos"(rx1736_pos)
    $P10 = rx1736_cur."scoped"("our")
    unless $P10, rx1736_fail
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1736_pos = $P10."pos"()
  # rx pass
    rx1736_cur."!cursor_pass"(rx1736_pos, "scope_declarator:sym<our>")
    if_null rx1736_debug, debug_1250
    rx1736_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1736_pos)
  debug_1250:
    .return (rx1736_cur)
  rx1736_restart:
.annotate 'line', 462
    if_null rx1736_debug, debug_1251
    rx1736_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_1251:
  rx1736_fail:
    (rx1736_rep, rx1736_pos, $I10, $P10) = rx1736_cur."!mark_fail"(0)
    lt rx1736_pos, -1, rx1736_done
    eq rx1736_pos, -1, rx1736_fail
    jump $I10
  rx1736_done:
    rx1736_cur."!cursor_fail"()
    if_null rx1736_debug, debug_1252
    rx1736_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_1252:
    .return (rx1736_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("196_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("scoped", "our")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("197_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1741_tgt
    .local int rx1741_pos
    .local int rx1741_off
    .local int rx1741_eos
    .local int rx1741_rep
    .local pmc rx1741_cur
    .local pmc rx1741_debug
    (rx1741_cur, rx1741_pos, rx1741_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1741_cur
    .local pmc match
    .lex "$/", match
    length rx1741_eos, rx1741_tgt
    gt rx1741_pos, rx1741_eos, rx1741_done
    set rx1741_off, 0
    lt rx1741_pos, 2, rx1741_start
    sub rx1741_off, rx1741_pos, 1
    substr rx1741_tgt, rx1741_tgt, rx1741_off
  rx1741_start:
    eq $I10, 1, rx1741_restart
    if_null rx1741_debug, debug_1253
    rx1741_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_1253:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1742_done
    goto rxscan1742_scan
  rxscan1742_loop:
    (rx1741_pos) = rx1741_cur."from"()
    inc rx1741_pos
    rx1741_cur."!cursor_from"(rx1741_pos)
    ge rx1741_pos, rx1741_eos, rxscan1742_done
  rxscan1742_scan:
    set_addr $I10, rxscan1742_loop
    rx1741_cur."!mark_push"(0, rx1741_pos, $I10)
  rxscan1742_done:
.annotate 'line', 848
  # rx subcapture "sym"
    set_addr $I10, rxcap_1743_fail
    rx1741_cur."!mark_push"(0, rx1741_pos, $I10)
  # rx literal  "has"
    add $I11, rx1741_pos, 3
    gt $I11, rx1741_eos, rx1741_fail
    sub $I11, rx1741_pos, rx1741_off
    substr $S10, rx1741_tgt, $I11, 3
    ne $S10, "has", rx1741_fail
    add rx1741_pos, 3
    set_addr $I10, rxcap_1743_fail
    ($I12, $I11) = rx1741_cur."!mark_peek"($I10)
    rx1741_cur."!cursor_pos"($I11)
    ($P10) = rx1741_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1741_pos, "")
    rx1741_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1743_done
  rxcap_1743_fail:
    goto rx1741_fail
  rxcap_1743_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1741_cur."!cursor_pos"(rx1741_pos)
    $P10 = rx1741_cur."scoped"("has")
    unless $P10, rx1741_fail
    rx1741_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1741_pos = $P10."pos"()
  # rx pass
    rx1741_cur."!cursor_pass"(rx1741_pos, "scope_declarator:sym<has>")
    if_null rx1741_debug, debug_1254
    rx1741_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1741_pos)
  debug_1254:
    .return (rx1741_cur)
  rx1741_restart:
.annotate 'line', 462
    if_null rx1741_debug, debug_1255
    rx1741_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_1255:
  rx1741_fail:
    (rx1741_rep, rx1741_pos, $I10, $P10) = rx1741_cur."!mark_fail"(0)
    lt rx1741_pos, -1, rx1741_done
    eq rx1741_pos, -1, rx1741_fail
    jump $I10
  rx1741_done:
    rx1741_cur."!cursor_fail"()
    if_null rx1741_debug, debug_1256
    rx1741_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_1256:
    .return (rx1741_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("198_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("scoped", "has")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("199_1325892461.451") :method :outer("46_1325892461.451")
    .param pmc param_1746
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 850
    .lex "$*SCOPE", param_1746
.annotate 'line', 462
    .local string rx1747_tgt
    .local int rx1747_pos
    .local int rx1747_off
    .local int rx1747_eos
    .local int rx1747_rep
    .local pmc rx1747_cur
    .local pmc rx1747_debug
    (rx1747_cur, rx1747_pos, rx1747_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1747_cur
    .local pmc match
    .lex "$/", match
    length rx1747_eos, rx1747_tgt
    gt rx1747_pos, rx1747_eos, rx1747_done
    set rx1747_off, 0
    lt rx1747_pos, 2, rx1747_start
    sub rx1747_off, rx1747_pos, 1
    substr rx1747_tgt, rx1747_tgt, rx1747_off
  rx1747_start:
    eq $I10, 1, rx1747_restart
    if_null rx1747_debug, debug_1257
    rx1747_cur."!cursor_debug"("START", "scoped")
  debug_1257:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1748_done
    goto rxscan1748_scan
  rxscan1748_loop:
    (rx1747_pos) = rx1747_cur."from"()
    inc rx1747_pos
    rx1747_cur."!cursor_from"(rx1747_pos)
    ge rx1747_pos, rx1747_eos, rxscan1748_done
  rxscan1748_scan:
    set_addr $I10, rxscan1748_loop
    rx1747_cur."!mark_push"(0, rx1747_pos, $I10)
  rxscan1748_done:
  alt1749_0:
.annotate 'line', 850
    set_addr $I10, alt1749_1
    rx1747_cur."!mark_push"(0, rx1747_pos, $I10)
.annotate 'line', 851
  # rx subrule "ws" subtype=method negate=
    rx1747_cur."!cursor_pos"(rx1747_pos)
    $P10 = rx1747_cur."ws"()
    unless $P10, rx1747_fail
    rx1747_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1747_cur."!cursor_pos"(rx1747_pos)
    $P10 = rx1747_cur."declarator"()
    unless $P10, rx1747_fail
    rx1747_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1747_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1747_cur."!cursor_pos"(rx1747_pos)
    $P10 = rx1747_cur."ws"()
    unless $P10, rx1747_fail
    rx1747_pos = $P10."pos"()
    goto alt1749_end
  alt1749_1:
    set_addr $I10, alt1749_2
    rx1747_cur."!mark_push"(0, rx1747_pos, $I10)
.annotate 'line', 852
  # rx subrule "ws" subtype=method negate=
    rx1747_cur."!cursor_pos"(rx1747_pos)
    $P10 = rx1747_cur."ws"()
    unless $P10, rx1747_fail
    rx1747_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1747_cur."!cursor_pos"(rx1747_pos)
    $P10 = rx1747_cur."multi_declarator"()
    unless $P10, rx1747_fail
    rx1747_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1747_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1747_cur."!cursor_pos"(rx1747_pos)
    $P10 = rx1747_cur."ws"()
    unless $P10, rx1747_fail
    rx1747_pos = $P10."pos"()
    goto alt1749_end
  alt1749_2:
.annotate 'line', 853
  # rx subrule "ws" subtype=method negate=
    rx1747_cur."!cursor_pos"(rx1747_pos)
    $P10 = rx1747_cur."ws"()
    unless $P10, rx1747_fail
    rx1747_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1747_cur."!cursor_pos"(rx1747_pos)
    $P10 = rx1747_cur."package_declarator"()
    unless $P10, rx1747_fail
    rx1747_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1747_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1747_cur."!cursor_pos"(rx1747_pos)
    $P10 = rx1747_cur."ws"()
    unless $P10, rx1747_fail
    rx1747_pos = $P10."pos"()
  alt1749_end:
.annotate 'line', 850
  # rx pass
    rx1747_cur."!cursor_pass"(rx1747_pos, "scoped")
    if_null rx1747_debug, debug_1258
    rx1747_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1747_pos)
  debug_1258:
    .return (rx1747_cur)
  rx1747_restart:
.annotate 'line', 462
    if_null rx1747_debug, debug_1259
    rx1747_cur."!cursor_debug"("NEXT", "scoped")
  debug_1259:
  rx1747_fail:
    (rx1747_rep, rx1747_pos, $I10, $P10) = rx1747_cur."!mark_fail"(0)
    lt rx1747_pos, -1, rx1747_done
    eq rx1747_pos, -1, rx1747_fail
    jump $I10
  rx1747_done:
    rx1747_cur."!cursor_fail"()
    if_null rx1747_debug, debug_1260
    rx1747_cur."!cursor_debug"("FAIL", "scoped")
  debug_1260:
    .return (rx1747_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("200_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P109 = self."!PREFIX__!subrule"("ws", "")
    $P110 = self."!PREFIX__!subrule"("ws", "")
    $P111 = self."!PREFIX__!subrule"("ws", "")
    new $P112, "ResizablePMCArray"
    push $P112, $P109
    push $P112, $P110
    push $P112, $P111
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("201_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1755 = "202_1325892461.451" 
    capture_lex $P1755
    .local string rx1752_tgt
    .local int rx1752_pos
    .local int rx1752_off
    .local int rx1752_eos
    .local int rx1752_rep
    .local pmc rx1752_cur
    .local pmc rx1752_debug
    (rx1752_cur, rx1752_pos, rx1752_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1752_cur
    .local pmc match
    .lex "$/", match
    length rx1752_eos, rx1752_tgt
    gt rx1752_pos, rx1752_eos, rx1752_done
    set rx1752_off, 0
    lt rx1752_pos, 2, rx1752_start
    sub rx1752_off, rx1752_pos, 1
    substr rx1752_tgt, rx1752_tgt, rx1752_off
  rx1752_start:
    eq $I10, 1, rx1752_restart
    if_null rx1752_debug, debug_1261
    rx1752_cur."!cursor_debug"("START", "typename")
  debug_1261:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1753_done
    goto rxscan1753_scan
  rxscan1753_loop:
    (rx1752_pos) = rx1752_cur."from"()
    inc rx1752_pos
    rx1752_cur."!cursor_from"(rx1752_pos)
    ge rx1752_pos, rx1752_eos, rxscan1753_done
  rxscan1753_scan:
    set_addr $I10, rxscan1753_loop
    rx1752_cur."!mark_push"(0, rx1752_pos, $I10)
  rxscan1753_done:
.annotate 'line', 857
  # rx subrule "name" subtype=capture negate=
    rx1752_cur."!cursor_pos"(rx1752_pos)
    $P10 = rx1752_cur."name"()
    unless $P10, rx1752_fail
    rx1752_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1752_pos = $P10."pos"()
.annotate 'line', 858
    rx1752_cur."!cursor_pos"(rx1752_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1755 = "202_1325892461.451" 
    capture_lex $P1755
    $P105 = $P1755()
    unless $P105, rx1752_fail
.annotate 'line', 856
  # rx pass
    rx1752_cur."!cursor_pass"(rx1752_pos, "typename")
    if_null rx1752_debug, debug_1268
    rx1752_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1752_pos)
  debug_1268:
    .return (rx1752_cur)
  rx1752_restart:
.annotate 'line', 462
    if_null rx1752_debug, debug_1269
    rx1752_cur."!cursor_debug"("NEXT", "typename")
  debug_1269:
  rx1752_fail:
    (rx1752_rep, rx1752_pos, $I10, $P10) = rx1752_cur."!mark_fail"(0)
    lt rx1752_pos, -1, rx1752_done
    eq rx1752_pos, -1, rx1752_fail
    jump $I10
  rx1752_done:
    rx1752_cur."!cursor_fail"()
    if_null rx1752_debug, debug_1270
    rx1752_cur."!cursor_debug"("FAIL", "typename")
  debug_1270:
    .return (rx1752_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1754"  :anon :subid("202_1325892461.451") :outer("201_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 858
    find_dynamic_lex $P107, "$*ACTIONS"
    unless_null $P107, vivify_1262
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$ACTIONS"]
    unless_null $P107, vivify_1263
    die "Contextual $*ACTIONS not found"
  vivify_1263:
  vivify_1262:
    find_lex $P108, "$/"
    unless_null $P108, vivify_1264
    new $P108, "Undef"
  vivify_1264:
    find_lex $P1756, "$/"
    unless_null $P1756, vivify_1265
    $P1756 = root_new ['parrot';'Hash']
  vivify_1265:
    set $P1757, $P1756["name"]
    unless_null $P1757, vivify_1266
    $P1757 = root_new ['parrot';'Hash']
  vivify_1266:
    set $P109, $P1757["identifier"]
    unless_null $P109, vivify_1267
    new $P109, "Undef"
  vivify_1267:
    $P110 = $P107."known_sym"($P108, $P109)
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("203_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P106 = self."!PREFIX__!subrule"("name", "")
    new $P107, "ResizablePMCArray"
    push $P107, $P106
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("204_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1760_tgt
    .local int rx1760_pos
    .local int rx1760_off
    .local int rx1760_eos
    .local int rx1760_rep
    .local pmc rx1760_cur
    .local pmc rx1760_debug
    (rx1760_cur, rx1760_pos, rx1760_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1760_cur
    .local pmc match
    .lex "$/", match
    length rx1760_eos, rx1760_tgt
    gt rx1760_pos, rx1760_eos, rx1760_done
    set rx1760_off, 0
    lt rx1760_pos, 2, rx1760_start
    sub rx1760_off, rx1760_pos, 1
    substr rx1760_tgt, rx1760_tgt, rx1760_off
  rx1760_start:
    eq $I10, 1, rx1760_restart
    if_null rx1760_debug, debug_1271
    rx1760_cur."!cursor_debug"("START", "declarator")
  debug_1271:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1761_done
    goto rxscan1761_scan
  rxscan1761_loop:
    (rx1760_pos) = rx1760_cur."from"()
    inc rx1760_pos
    rx1760_cur."!cursor_from"(rx1760_pos)
    ge rx1760_pos, rx1760_eos, rxscan1761_done
  rxscan1761_scan:
    set_addr $I10, rxscan1761_loop
    rx1760_cur."!mark_push"(0, rx1760_pos, $I10)
  rxscan1761_done:
  alt1762_0:
.annotate 'line', 861
    set_addr $I10, alt1762_1
    rx1760_cur."!mark_push"(0, rx1760_pos, $I10)
.annotate 'line', 862
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1760_cur."!cursor_pos"(rx1760_pos)
    $P10 = rx1760_cur."variable_declarator"()
    unless $P10, rx1760_fail
    rx1760_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1760_pos = $P10."pos"()
    goto alt1762_end
  alt1762_1:
.annotate 'line', 863
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1760_cur."!cursor_pos"(rx1760_pos)
    $P10 = rx1760_cur."routine_declarator"()
    unless $P10, rx1760_fail
    rx1760_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1760_pos = $P10."pos"()
  alt1762_end:
.annotate 'line', 861
  # rx pass
    rx1760_cur."!cursor_pass"(rx1760_pos, "declarator")
    if_null rx1760_debug, debug_1272
    rx1760_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1760_pos)
  debug_1272:
    .return (rx1760_cur)
  rx1760_restart:
.annotate 'line', 462
    if_null rx1760_debug, debug_1273
    rx1760_cur."!cursor_debug"("NEXT", "declarator")
  debug_1273:
  rx1760_fail:
    (rx1760_rep, rx1760_pos, $I10, $P10) = rx1760_cur."!mark_fail"(0)
    lt rx1760_pos, -1, rx1760_done
    eq rx1760_pos, -1, rx1760_fail
    jump $I10
  rx1760_done:
    rx1760_cur."!cursor_fail"()
    if_null rx1760_debug, debug_1274
    rx1760_cur."!cursor_debug"("FAIL", "declarator")
  debug_1274:
    .return (rx1760_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("205_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P104 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("206_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1771 = "207_1325892461.451" 
    capture_lex $P1771
.annotate 'line', 868
    new $P103, "Undef"
    set $P1765, $P103
    .lex "$*IN_DECL", $P1765
.annotate 'line', 462
    .local string rx1766_tgt
    .local int rx1766_pos
    .local int rx1766_off
    .local int rx1766_eos
    .local int rx1766_rep
    .local pmc rx1766_cur
    .local pmc rx1766_debug
    (rx1766_cur, rx1766_pos, rx1766_tgt, $I10) = self."!cursor_start"()
    rx1766_cur."!cursor_caparray"("typename", "trait")
    .lex unicode:"$\x{a2}", rx1766_cur
    .local pmc match
    .lex "$/", match
    length rx1766_eos, rx1766_tgt
    gt rx1766_pos, rx1766_eos, rx1766_done
    set rx1766_off, 0
    lt rx1766_pos, 2, rx1766_start
    sub rx1766_off, rx1766_pos, 1
    substr rx1766_tgt, rx1766_tgt, rx1766_off
  rx1766_start:
    eq $I10, 1, rx1766_restart
    if_null rx1766_debug, debug_1275
    rx1766_cur."!cursor_debug"("START", "variable_declarator")
  debug_1275:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1767_done
    goto rxscan1767_scan
  rxscan1767_loop:
    (rx1766_pos) = rx1766_cur."from"()
    inc rx1766_pos
    rx1766_cur."!cursor_from"(rx1766_pos)
    ge rx1766_pos, rx1766_eos, rxscan1767_done
  rxscan1767_scan:
    set_addr $I10, rxscan1767_loop
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10)
  rxscan1767_done:
.annotate 'line', 866
  # rx subrule "ws" subtype=method negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."ws"()
    unless $P10, rx1766_fail
    rx1766_pos = $P10."pos"()
.annotate 'line', 867
  # rx rxquantr1768 ** 0..1
    set_addr $I10, rxquantr1768_done
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10)
  rxquantr1768_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."typename"()
    unless $P10, rx1766_fail
    goto rxsubrule1769_pass
  rxsubrule1769_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1766_fail
  rxsubrule1769_pass:
    set_addr $I10, rxsubrule1769_back
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1766_pos = $P10."pos"()
    set_addr $I10, rxquantr1768_done
    (rx1766_rep) = rx1766_cur."!mark_commit"($I10)
  rxquantr1768_done:
  # rx subrule "ws" subtype=method negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."ws"()
    unless $P10, rx1766_fail
    rx1766_pos = $P10."pos"()
.annotate 'line', 868
    rx1766_cur."!cursor_pos"(rx1766_pos)
    new $P106, "String"
    assign $P106, "variable"
    set $P1765, $P106
  # rx subrule "ws" subtype=method negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."ws"()
    unless $P10, rx1766_fail
    rx1766_pos = $P10."pos"()
.annotate 'line', 869
  # rx subrule "variable" subtype=capture negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."variable"()
    unless $P10, rx1766_fail
    rx1766_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1766_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."ws"()
    unless $P10, rx1766_fail
    rx1766_pos = $P10."pos"()
.annotate 'line', 870
    rx1766_cur."!cursor_pos"(rx1766_pos)
    find_lex $P109, unicode:"$\x{a2}"
    $P110 = $P109."MATCH"()
    store_lex "$/", $P110
    .const 'Sub' $P1771 = "207_1325892461.451" 
    capture_lex $P1771
    $P112 = $P1771()
  # rx subrule "ws" subtype=method negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."ws"()
    unless $P10, rx1766_fail
    rx1766_pos = $P10."pos"()
.annotate 'line', 871
  # rx rxquantr1772 ** 0..*
    set_addr $I10, rxquantr1772_done
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10)
  rxquantr1772_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."trait"()
    unless $P10, rx1766_fail
    goto rxsubrule1773_pass
  rxsubrule1773_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1766_fail
  rxsubrule1773_pass:
    set_addr $I10, rxsubrule1773_back
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1766_pos = $P10."pos"()
    set_addr $I10, rxquantr1772_done
    (rx1766_rep) = rx1766_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1772_done
    rx1766_cur."!mark_push"(rx1766_rep, rx1766_pos, $I10)
    goto rxquantr1772_loop
  rxquantr1772_done:
  # rx subrule "ws" subtype=method negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."ws"()
    unless $P10, rx1766_fail
    rx1766_pos = $P10."pos"()
.annotate 'line', 866
  # rx pass
    rx1766_cur."!cursor_pass"(rx1766_pos, "variable_declarator")
    if_null rx1766_debug, debug_1276
    rx1766_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1766_pos)
  debug_1276:
    .return (rx1766_cur)
  rx1766_restart:
.annotate 'line', 462
    if_null rx1766_debug, debug_1277
    rx1766_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1277:
  rx1766_fail:
    (rx1766_rep, rx1766_pos, $I10, $P10) = rx1766_cur."!mark_fail"(0)
    lt rx1766_pos, -1, rx1766_done
    eq rx1766_pos, -1, rx1766_fail
    jump $I10
  rx1766_done:
    rx1766_cur."!cursor_fail"()
    if_null rx1766_debug, debug_1278
    rx1766_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1278:
    .return (rx1766_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1770"  :anon :subid("207_1325892461.451") :outer("206_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 870
    new $P111, "Float"
    assign $P111, 0
    store_dynamic_lex "$*IN_DECL", $P111
    .return ($P111)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("208_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P115 = self."!PREFIX__!subrule"("ws", "")
    new $P116, "ResizablePMCArray"
    push $P116, $P115
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("209_1325892461.451")
    .param pmc param_1776
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 874
    .lex "self", param_1776
    $P103 = param_1776."!protoregex"("routine_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("210_1325892461.451")
    .param pmc param_1778
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 874
    .lex "self", param_1778
    $P104 = param_1778."!PREFIX__!protoregex"("routine_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("211_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1780_tgt
    .local int rx1780_pos
    .local int rx1780_off
    .local int rx1780_eos
    .local int rx1780_rep
    .local pmc rx1780_cur
    .local pmc rx1780_debug
    (rx1780_cur, rx1780_pos, rx1780_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1780_cur
    .local pmc match
    .lex "$/", match
    length rx1780_eos, rx1780_tgt
    gt rx1780_pos, rx1780_eos, rx1780_done
    set rx1780_off, 0
    lt rx1780_pos, 2, rx1780_start
    sub rx1780_off, rx1780_pos, 1
    substr rx1780_tgt, rx1780_tgt, rx1780_off
  rx1780_start:
    eq $I10, 1, rx1780_restart
    if_null rx1780_debug, debug_1279
    rx1780_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1279:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1781_done
    goto rxscan1781_scan
  rxscan1781_loop:
    (rx1780_pos) = rx1780_cur."from"()
    inc rx1780_pos
    rx1780_cur."!cursor_from"(rx1780_pos)
    ge rx1780_pos, rx1780_eos, rxscan1781_done
  rxscan1781_scan:
    set_addr $I10, rxscan1781_loop
    rx1780_cur."!mark_push"(0, rx1780_pos, $I10)
  rxscan1781_done:
.annotate 'line', 875
  # rx subcapture "sym"
    set_addr $I10, rxcap_1782_fail
    rx1780_cur."!mark_push"(0, rx1780_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1780_pos, 3
    gt $I11, rx1780_eos, rx1780_fail
    sub $I11, rx1780_pos, rx1780_off
    substr $S10, rx1780_tgt, $I11, 3
    ne $S10, "sub", rx1780_fail
    add rx1780_pos, 3
    set_addr $I10, rxcap_1782_fail
    ($I12, $I11) = rx1780_cur."!mark_peek"($I10)
    rx1780_cur."!cursor_pos"($I11)
    ($P10) = rx1780_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1780_pos, "")
    rx1780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1782_done
  rxcap_1782_fail:
    goto rx1780_fail
  rxcap_1782_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1780_cur."!cursor_pos"(rx1780_pos)
    $P10 = rx1780_cur."routine_def"()
    unless $P10, rx1780_fail
    rx1780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1780_pos = $P10."pos"()
  # rx pass
    rx1780_cur."!cursor_pass"(rx1780_pos, "routine_declarator:sym<sub>")
    if_null rx1780_debug, debug_1280
    rx1780_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1780_pos)
  debug_1280:
    .return (rx1780_cur)
  rx1780_restart:
.annotate 'line', 462
    if_null rx1780_debug, debug_1281
    rx1780_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1281:
  rx1780_fail:
    (rx1780_rep, rx1780_pos, $I10, $P10) = rx1780_cur."!mark_fail"(0)
    lt rx1780_pos, -1, rx1780_done
    eq rx1780_pos, -1, rx1780_fail
    jump $I10
  rx1780_done:
    rx1780_cur."!cursor_fail"()
    if_null rx1780_debug, debug_1282
    rx1780_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1282:
    .return (rx1780_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("212_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("213_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1785_tgt
    .local int rx1785_pos
    .local int rx1785_off
    .local int rx1785_eos
    .local int rx1785_rep
    .local pmc rx1785_cur
    .local pmc rx1785_debug
    (rx1785_cur, rx1785_pos, rx1785_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1785_cur
    .local pmc match
    .lex "$/", match
    length rx1785_eos, rx1785_tgt
    gt rx1785_pos, rx1785_eos, rx1785_done
    set rx1785_off, 0
    lt rx1785_pos, 2, rx1785_start
    sub rx1785_off, rx1785_pos, 1
    substr rx1785_tgt, rx1785_tgt, rx1785_off
  rx1785_start:
    eq $I10, 1, rx1785_restart
    if_null rx1785_debug, debug_1283
    rx1785_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1283:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1786_done
    goto rxscan1786_scan
  rxscan1786_loop:
    (rx1785_pos) = rx1785_cur."from"()
    inc rx1785_pos
    rx1785_cur."!cursor_from"(rx1785_pos)
    ge rx1785_pos, rx1785_eos, rxscan1786_done
  rxscan1786_scan:
    set_addr $I10, rxscan1786_loop
    rx1785_cur."!mark_push"(0, rx1785_pos, $I10)
  rxscan1786_done:
.annotate 'line', 876
  # rx subcapture "sym"
    set_addr $I10, rxcap_1787_fail
    rx1785_cur."!mark_push"(0, rx1785_pos, $I10)
  # rx literal  "method"
    add $I11, rx1785_pos, 6
    gt $I11, rx1785_eos, rx1785_fail
    sub $I11, rx1785_pos, rx1785_off
    substr $S10, rx1785_tgt, $I11, 6
    ne $S10, "method", rx1785_fail
    add rx1785_pos, 6
    set_addr $I10, rxcap_1787_fail
    ($I12, $I11) = rx1785_cur."!mark_peek"($I10)
    rx1785_cur."!cursor_pos"($I11)
    ($P10) = rx1785_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1785_pos, "")
    rx1785_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1787_done
  rxcap_1787_fail:
    goto rx1785_fail
  rxcap_1787_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1785_cur."!cursor_pos"(rx1785_pos)
    $P10 = rx1785_cur."method_def"()
    unless $P10, rx1785_fail
    rx1785_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1785_pos = $P10."pos"()
  # rx pass
    rx1785_cur."!cursor_pass"(rx1785_pos, "routine_declarator:sym<method>")
    if_null rx1785_debug, debug_1284
    rx1785_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1785_pos)
  debug_1284:
    .return (rx1785_cur)
  rx1785_restart:
.annotate 'line', 462
    if_null rx1785_debug, debug_1285
    rx1785_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1285:
  rx1785_fail:
    (rx1785_rep, rx1785_pos, $I10, $P10) = rx1785_cur."!mark_fail"(0)
    lt rx1785_pos, -1, rx1785_done
    eq rx1785_pos, -1, rx1785_fail
    jump $I10
  rx1785_done:
    rx1785_cur."!cursor_fail"()
    if_null rx1785_debug, debug_1286
    rx1785_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1286:
    .return (rx1785_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("214_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("method_def", "method")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("215_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 879
    new $P103, "Undef"
    set $P1790, $P103
    .lex "$*RETURN_USED", $P1790
.annotate 'line', 462
    .local string rx1791_tgt
    .local int rx1791_pos
    .local int rx1791_off
    .local int rx1791_eos
    .local int rx1791_rep
    .local pmc rx1791_cur
    .local pmc rx1791_debug
    (rx1791_cur, rx1791_pos, rx1791_tgt, $I10) = self."!cursor_start"()
    rx1791_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1791_cur
    .local pmc match
    .lex "$/", match
    length rx1791_eos, rx1791_tgt
    gt rx1791_pos, rx1791_eos, rx1791_done
    set rx1791_off, 0
    lt rx1791_pos, 2, rx1791_start
    sub rx1791_off, rx1791_pos, 1
    substr rx1791_tgt, rx1791_tgt, rx1791_off
  rx1791_start:
    eq $I10, 1, rx1791_restart
    if_null rx1791_debug, debug_1287
    rx1791_cur."!cursor_debug"("START", "routine_def")
  debug_1287:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1792_done
    goto rxscan1792_scan
  rxscan1792_loop:
    (rx1791_pos) = rx1791_cur."from"()
    inc rx1791_pos
    rx1791_cur."!cursor_from"(rx1791_pos)
    ge rx1791_pos, rx1791_eos, rxscan1792_done
  rxscan1792_scan:
    set_addr $I10, rxscan1792_loop
    rx1791_cur."!mark_push"(0, rx1791_pos, $I10)
  rxscan1792_done:
.annotate 'line', 878
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
.annotate 'line', 879
    rx1791_cur."!cursor_pos"(rx1791_pos)
    new $P105, "Float"
    assign $P105, 0
    set $P1790, $P105
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
.annotate 'line', 880
  # rx rxquantr1793 ** 0..1
    set_addr $I10, rxquantr1793_done
    rx1791_cur."!mark_push"(0, rx1791_pos, $I10)
  rxquantr1793_loop:
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1795_fail
    rx1791_cur."!mark_push"(0, rx1791_pos, $I10)
  # rx rxquantr1794 ** 0..1
    set_addr $I10, rxquantr1794_done
    rx1791_cur."!mark_push"(0, rx1791_pos, $I10)
  rxquantr1794_loop:
  # rx literal  "&"
    add $I11, rx1791_pos, 1
    gt $I11, rx1791_eos, rx1791_fail
    sub $I11, rx1791_pos, rx1791_off
    ord $I11, rx1791_tgt, $I11
    ne $I11, 38, rx1791_fail
    add rx1791_pos, 1
    set_addr $I10, rxquantr1794_done
    (rx1791_rep) = rx1791_cur."!mark_commit"($I10)
  rxquantr1794_done:
    set_addr $I10, rxcap_1795_fail
    ($I12, $I11) = rx1791_cur."!mark_peek"($I10)
    rx1791_cur."!cursor_pos"($I11)
    ($P10) = rx1791_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1791_pos, "")
    rx1791_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1795_done
  rxcap_1795_fail:
    goto rx1791_fail
  rxcap_1795_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."deflongname"()
    unless $P10, rx1791_fail
    rx1791_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1791_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
    set_addr $I10, rxquantr1793_done
    (rx1791_rep) = rx1791_cur."!mark_commit"($I10)
  rxquantr1793_done:
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
.annotate 'line', 881
  # rx subrule "newpad" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."newpad"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  alt1796_0:
.annotate 'line', 882
    set_addr $I10, alt1796_1
    rx1791_cur."!mark_push"(0, rx1791_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1791_pos, 1
    gt $I11, rx1791_eos, rx1791_fail
    sub $I11, rx1791_pos, rx1791_off
    ord $I11, rx1791_tgt, $I11
    ne $I11, 40, rx1791_fail
    add rx1791_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."signature"()
    unless $P10, rx1791_fail
    rx1791_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1791_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1791_pos, 1
    gt $I11, rx1791_eos, rx1791_fail
    sub $I11, rx1791_pos, rx1791_off
    ord $I11, rx1791_tgt, $I11
    ne $I11, 41, rx1791_fail
    add rx1791_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
    goto alt1796_end
  alt1796_1:
.annotate 'line', 883
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  alt1796_end:
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
.annotate 'line', 884
  # rx rxquantr1797 ** 0..*
    set_addr $I10, rxquantr1797_done
    rx1791_cur."!mark_push"(0, rx1791_pos, $I10)
  rxquantr1797_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."trait"()
    unless $P10, rx1791_fail
    goto rxsubrule1798_pass
  rxsubrule1798_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1791_fail
  rxsubrule1798_pass:
    set_addr $I10, rxsubrule1798_back
    rx1791_cur."!mark_push"(0, rx1791_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1791_pos = $P10."pos"()
    set_addr $I10, rxquantr1797_done
    (rx1791_rep) = rx1791_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1797_done
    rx1791_cur."!mark_push"(rx1791_rep, rx1791_pos, $I10)
    goto rxquantr1797_loop
  rxquantr1797_done:
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  alt1799_0:
.annotate 'line', 885
    set_addr $I10, alt1799_1
    rx1791_cur."!mark_push"(0, rx1791_pos, $I10)
.annotate 'line', 886
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."onlystar"()
    unless $P10, rx1791_fail
    rx1791_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1791_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
    goto alt1799_end
  alt1799_1:
.annotate 'line', 887
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."blockoid"()
    unless $P10, rx1791_fail
    rx1791_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1791_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
  alt1799_end:
.annotate 'line', 888
  # rx subrule "ws" subtype=method negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."ws"()
    unless $P10, rx1791_fail
    rx1791_pos = $P10."pos"()
.annotate 'line', 878
  # rx pass
    rx1791_cur."!cursor_pass"(rx1791_pos, "routine_def")
    if_null rx1791_debug, debug_1288
    rx1791_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1791_pos)
  debug_1288:
    .return (rx1791_cur)
  rx1791_restart:
.annotate 'line', 462
    if_null rx1791_debug, debug_1289
    rx1791_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1289:
  rx1791_fail:
    (rx1791_rep, rx1791_pos, $I10, $P10) = rx1791_cur."!mark_fail"(0)
    lt rx1791_pos, -1, rx1791_done
    eq rx1791_pos, -1, rx1791_fail
    jump $I10
  rx1791_done:
    rx1791_cur."!cursor_fail"()
    if_null rx1791_debug, debug_1290
    rx1791_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1290:
    .return (rx1791_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("216_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P124 = self."!PREFIX__!subrule"("ws", "")
    new $P125, "ResizablePMCArray"
    push $P125, $P124
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("217_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1812 = "218_1325892461.451" 
    capture_lex $P1812
.annotate 'line', 892
    new $P103, "Undef"
    set $P1802, $P103
    .lex "$*RETURN_USED", $P1802
.annotate 'line', 893
    new $P104, "Undef"
    set $P1803, $P104
    .lex "$*INVOCANT_OK", $P1803
.annotate 'line', 462
    .local string rx1804_tgt
    .local int rx1804_pos
    .local int rx1804_off
    .local int rx1804_eos
    .local int rx1804_rep
    .local pmc rx1804_cur
    .local pmc rx1804_debug
    (rx1804_cur, rx1804_pos, rx1804_tgt, $I10) = self."!cursor_start"()
    rx1804_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1804_cur
    .local pmc match
    .lex "$/", match
    length rx1804_eos, rx1804_tgt
    gt rx1804_pos, rx1804_eos, rx1804_done
    set rx1804_off, 0
    lt rx1804_pos, 2, rx1804_start
    sub rx1804_off, rx1804_pos, 1
    substr rx1804_tgt, rx1804_tgt, rx1804_off
  rx1804_start:
    eq $I10, 1, rx1804_restart
    if_null rx1804_debug, debug_1291
    rx1804_cur."!cursor_debug"("START", "method_def")
  debug_1291:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1805_done
    goto rxscan1805_scan
  rxscan1805_loop:
    (rx1804_pos) = rx1804_cur."from"()
    inc rx1804_pos
    rx1804_cur."!cursor_from"(rx1804_pos)
    ge rx1804_pos, rx1804_eos, rxscan1805_done
  rxscan1805_scan:
    set_addr $I10, rxscan1805_loop
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10)
  rxscan1805_done:
.annotate 'line', 891
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
.annotate 'line', 892
    rx1804_cur."!cursor_pos"(rx1804_pos)
    new $P106, "Float"
    assign $P106, 0
    set $P1802, $P106
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
.annotate 'line', 893
    rx1804_cur."!cursor_pos"(rx1804_pos)
    new $P108, "Float"
    assign $P108, 1
    set $P1803, $P108
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
.annotate 'line', 894
  # rx subcapture "private"
    set_addr $I10, rxcap_1807_fail
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10)
  # rx rxquantr1806 ** 0..1
    set_addr $I10, rxquantr1806_done
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10)
  rxquantr1806_loop:
  # rx literal  "!"
    add $I11, rx1804_pos, 1
    gt $I11, rx1804_eos, rx1804_fail
    sub $I11, rx1804_pos, rx1804_off
    ord $I11, rx1804_tgt, $I11
    ne $I11, 33, rx1804_fail
    add rx1804_pos, 1
    set_addr $I10, rxquantr1806_done
    (rx1804_rep) = rx1804_cur."!mark_commit"($I10)
  rxquantr1806_done:
    set_addr $I10, rxcap_1807_fail
    ($I12, $I11) = rx1804_cur."!mark_peek"($I10)
    rx1804_cur."!cursor_pos"($I11)
    ($P10) = rx1804_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1804_pos, "")
    rx1804_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1807_done
  rxcap_1807_fail:
    goto rx1804_fail
  rxcap_1807_done:
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
.annotate 'line', 895
  # rx rxquantr1808 ** 0..1
    set_addr $I10, rxquantr1808_done
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10)
  rxquantr1808_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."deflongname"()
    unless $P10, rx1804_fail
    goto rxsubrule1809_pass
  rxsubrule1809_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1804_fail
  rxsubrule1809_pass:
    set_addr $I10, rxsubrule1809_back
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1804_pos = $P10."pos"()
    set_addr $I10, rxquantr1808_done
    (rx1804_rep) = rx1804_cur."!mark_commit"($I10)
  rxquantr1808_done:
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
.annotate 'line', 896
  # rx subrule "newpad" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."newpad"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  alt1810_0:
.annotate 'line', 897
    set_addr $I10, alt1810_1
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1804_pos, 1
    gt $I11, rx1804_eos, rx1804_fail
    sub $I11, rx1804_pos, rx1804_off
    ord $I11, rx1804_tgt, $I11
    ne $I11, 40, rx1804_fail
    add rx1804_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."signature"()
    unless $P10, rx1804_fail
    rx1804_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1804_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1804_pos, 1
    gt $I11, rx1804_eos, rx1804_fail
    sub $I11, rx1804_pos, rx1804_off
    ord $I11, rx1804_tgt, $I11
    ne $I11, 41, rx1804_fail
    add rx1804_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
    goto alt1810_end
  alt1810_1:
.annotate 'line', 898
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  alt1810_end:
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
.annotate 'line', 899
    rx1804_cur."!cursor_pos"(rx1804_pos)
    find_lex $P120, unicode:"$\x{a2}"
    $P121 = $P120."MATCH"()
    store_lex "$/", $P121
    .const 'Sub' $P1812 = "218_1325892461.451" 
    capture_lex $P1812
    $P123 = $P1812()
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
.annotate 'line', 900
  # rx rxquantr1813 ** 0..*
    set_addr $I10, rxquantr1813_done
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10)
  rxquantr1813_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."trait"()
    unless $P10, rx1804_fail
    goto rxsubrule1814_pass
  rxsubrule1814_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1804_fail
  rxsubrule1814_pass:
    set_addr $I10, rxsubrule1814_back
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1804_pos = $P10."pos"()
    set_addr $I10, rxquantr1813_done
    (rx1804_rep) = rx1804_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1813_done
    rx1804_cur."!mark_push"(rx1804_rep, rx1804_pos, $I10)
    goto rxquantr1813_loop
  rxquantr1813_done:
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  alt1815_0:
.annotate 'line', 901
    set_addr $I10, alt1815_1
    rx1804_cur."!mark_push"(0, rx1804_pos, $I10)
.annotate 'line', 902
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."onlystar"()
    unless $P10, rx1804_fail
    rx1804_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1804_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
    goto alt1815_end
  alt1815_1:
.annotate 'line', 903
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."blockoid"()
    unless $P10, rx1804_fail
    rx1804_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1804_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
  alt1815_end:
.annotate 'line', 904
  # rx subrule "ws" subtype=method negate=
    rx1804_cur."!cursor_pos"(rx1804_pos)
    $P10 = rx1804_cur."ws"()
    unless $P10, rx1804_fail
    rx1804_pos = $P10."pos"()
.annotate 'line', 891
  # rx pass
    rx1804_cur."!cursor_pass"(rx1804_pos, "method_def")
    if_null rx1804_debug, debug_1292
    rx1804_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1804_pos)
  debug_1292:
    .return (rx1804_cur)
  rx1804_restart:
.annotate 'line', 462
    if_null rx1804_debug, debug_1293
    rx1804_cur."!cursor_debug"("NEXT", "method_def")
  debug_1293:
  rx1804_fail:
    (rx1804_rep, rx1804_pos, $I10, $P10) = rx1804_cur."!mark_fail"(0)
    lt rx1804_pos, -1, rx1804_done
    eq rx1804_pos, -1, rx1804_fail
    jump $I10
  rx1804_done:
    rx1804_cur."!cursor_fail"()
    if_null rx1804_debug, debug_1294
    rx1804_cur."!cursor_debug"("FAIL", "method_def")
  debug_1294:
    .return (rx1804_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1811"  :anon :subid("218_1325892461.451") :outer("217_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 899
    new $P122, "Float"
    assign $P122, 0
    store_dynamic_lex "$*INVOCANT_OK", $P122
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("219_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P131 = self."!PREFIX__!subrule"("ws", "")
    new $P132, "ResizablePMCArray"
    push $P132, $P131
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("220_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1821 = "221_1325892461.451" 
    capture_lex $P1821
    .local string rx1818_tgt
    .local int rx1818_pos
    .local int rx1818_off
    .local int rx1818_eos
    .local int rx1818_rep
    .local pmc rx1818_cur
    .local pmc rx1818_debug
    (rx1818_cur, rx1818_pos, rx1818_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1818_cur
    .local pmc match
    .lex "$/", match
    length rx1818_eos, rx1818_tgt
    gt rx1818_pos, rx1818_eos, rx1818_done
    set rx1818_off, 0
    lt rx1818_pos, 2, rx1818_start
    sub rx1818_off, rx1818_pos, 1
    substr rx1818_tgt, rx1818_tgt, rx1818_off
  rx1818_start:
    eq $I10, 1, rx1818_restart
    if_null rx1818_debug, debug_1295
    rx1818_cur."!cursor_debug"("START", "onlystar")
  debug_1295:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1819_done
    goto rxscan1819_scan
  rxscan1819_loop:
    (rx1818_pos) = rx1818_cur."from"()
    inc rx1818_pos
    rx1818_cur."!cursor_from"(rx1818_pos)
    ge rx1818_pos, rx1818_eos, rxscan1819_done
  rxscan1819_scan:
    set_addr $I10, rxscan1819_loop
    rx1818_cur."!mark_push"(0, rx1818_pos, $I10)
  rxscan1819_done:
.annotate 'line', 908
    rx1818_cur."!cursor_pos"(rx1818_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1821 = "221_1325892461.451" 
    capture_lex $P1821
    $P105 = $P1821()
    unless $P105, rx1818_fail
.annotate 'line', 909
  # rx literal  "{"
    add $I11, rx1818_pos, 1
    gt $I11, rx1818_eos, rx1818_fail
    sub $I11, rx1818_pos, rx1818_off
    ord $I11, rx1818_tgt, $I11
    ne $I11, 123, rx1818_fail
    add rx1818_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1818_cur."!cursor_pos"(rx1818_pos)
    $P10 = rx1818_cur."ws"()
    unless $P10, rx1818_fail
    rx1818_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1818_pos, 1
    gt $I11, rx1818_eos, rx1818_fail
    sub $I11, rx1818_pos, rx1818_off
    ord $I11, rx1818_tgt, $I11
    ne $I11, 42, rx1818_fail
    add rx1818_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1818_cur."!cursor_pos"(rx1818_pos)
    $P10 = rx1818_cur."ws"()
    unless $P10, rx1818_fail
    rx1818_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1818_pos, 1
    gt $I11, rx1818_eos, rx1818_fail
    sub $I11, rx1818_pos, rx1818_off
    ord $I11, rx1818_tgt, $I11
    ne $I11, 125, rx1818_fail
    add rx1818_pos, 1
.annotate 'line', 910
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1818_cur."!cursor_pos"(rx1818_pos)
    $P10 = rx1818_cur."ENDSTMT"()
    unless $P10, rx1818_fail
.annotate 'line', 911
  # rx subrule "finishpad" subtype=method negate=
    rx1818_cur."!cursor_pos"(rx1818_pos)
    $P10 = rx1818_cur."finishpad"()
    unless $P10, rx1818_fail
    rx1818_pos = $P10."pos"()
.annotate 'line', 907
  # rx pass
    rx1818_cur."!cursor_pass"(rx1818_pos, "onlystar")
    if_null rx1818_debug, debug_1298
    rx1818_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1818_pos)
  debug_1298:
    .return (rx1818_cur)
  rx1818_restart:
.annotate 'line', 462
    if_null rx1818_debug, debug_1299
    rx1818_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1299:
  rx1818_fail:
    (rx1818_rep, rx1818_pos, $I10, $P10) = rx1818_cur."!mark_fail"(0)
    lt rx1818_pos, -1, rx1818_done
    eq rx1818_pos, -1, rx1818_fail
    jump $I10
  rx1818_done:
    rx1818_cur."!cursor_fail"()
    if_null rx1818_debug, debug_1300
    rx1818_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1300:
    .return (rx1818_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1820"  :anon :subid("221_1325892461.451") :outer("220_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 908
    find_dynamic_lex $P107, "$*MULTINESS"
    unless_null $P107, vivify_1296
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$MULTINESS"]
    unless_null $P107, vivify_1297
    die "Contextual $*MULTINESS not found"
  vivify_1297:
  vivify_1296:
    set $S100, $P107
    iseq $I100, $S100, "proto"
    .return ($I100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("222_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P106, "ResizablePMCArray"
    push $P106, ""
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("223_1325892461.451")
    .param pmc param_1824
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 914
    .lex "self", param_1824
    $P103 = param_1824."!protoregex"("multi_declarator")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("224_1325892461.451")
    .param pmc param_1826
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 914
    .lex "self", param_1826
    $P104 = param_1826."!PREFIX__!protoregex"("multi_declarator")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("225_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 916
    new $P103, "Undef"
    set $P1828, $P103
    .lex "$*MULTINESS", $P1828
.annotate 'line', 462
    .local string rx1829_tgt
    .local int rx1829_pos
    .local int rx1829_off
    .local int rx1829_eos
    .local int rx1829_rep
    .local pmc rx1829_cur
    .local pmc rx1829_debug
    (rx1829_cur, rx1829_pos, rx1829_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1829_cur
    .local pmc match
    .lex "$/", match
    length rx1829_eos, rx1829_tgt
    gt rx1829_pos, rx1829_eos, rx1829_done
    set rx1829_off, 0
    lt rx1829_pos, 2, rx1829_start
    sub rx1829_off, rx1829_pos, 1
    substr rx1829_tgt, rx1829_tgt, rx1829_off
  rx1829_start:
    eq $I10, 1, rx1829_restart
    if_null rx1829_debug, debug_1301
    rx1829_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1301:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1830_done
    goto rxscan1830_scan
  rxscan1830_loop:
    (rx1829_pos) = rx1829_cur."from"()
    inc rx1829_pos
    rx1829_cur."!cursor_from"(rx1829_pos)
    ge rx1829_pos, rx1829_eos, rxscan1830_done
  rxscan1830_scan:
    set_addr $I10, rxscan1830_loop
    rx1829_cur."!mark_push"(0, rx1829_pos, $I10)
  rxscan1830_done:
.annotate 'line', 916
    rx1829_cur."!cursor_pos"(rx1829_pos)
    new $P104, "String"
    assign $P104, "multi"
    set $P1828, $P104
.annotate 'line', 917
  # rx subcapture "sym"
    set_addr $I10, rxcap_1831_fail
    rx1829_cur."!mark_push"(0, rx1829_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1829_pos, 5
    gt $I11, rx1829_eos, rx1829_fail
    sub $I11, rx1829_pos, rx1829_off
    substr $S10, rx1829_tgt, $I11, 5
    ne $S10, "multi", rx1829_fail
    add rx1829_pos, 5
    set_addr $I10, rxcap_1831_fail
    ($I12, $I11) = rx1829_cur."!mark_peek"($I10)
    rx1829_cur."!cursor_pos"($I11)
    ($P10) = rx1829_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1829_pos, "")
    rx1829_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1831_done
  rxcap_1831_fail:
    goto rx1829_fail
  rxcap_1831_done:
.annotate 'line', 918
  # rx subrule "ws" subtype=method negate=
    rx1829_cur."!cursor_pos"(rx1829_pos)
    $P10 = rx1829_cur."ws"()
    unless $P10, rx1829_fail
    rx1829_pos = $P10."pos"()
  alt1832_0:
    set_addr $I10, alt1832_1
    rx1829_cur."!mark_push"(0, rx1829_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1829_cur."!cursor_pos"(rx1829_pos)
    $P10 = rx1829_cur."declarator"()
    unless $P10, rx1829_fail
    rx1829_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1829_pos = $P10."pos"()
    goto alt1832_end
  alt1832_1:
    set_addr $I10, alt1832_2
    rx1829_cur."!mark_push"(0, rx1829_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1829_cur."!cursor_pos"(rx1829_pos)
    $P10 = rx1829_cur."routine_def"()
    unless $P10, rx1829_fail
    rx1829_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1829_pos = $P10."pos"()
    goto alt1832_end
  alt1832_2:
  # rx subrule "panic" subtype=method negate=
    rx1829_cur."!cursor_pos"(rx1829_pos)
    $P10 = rx1829_cur."panic"("Malformed multi")
    unless $P10, rx1829_fail
    rx1829_pos = $P10."pos"()
  alt1832_end:
.annotate 'line', 915
  # rx pass
    rx1829_cur."!cursor_pass"(rx1829_pos, "multi_declarator:sym<multi>")
    if_null rx1829_debug, debug_1302
    rx1829_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1829_pos)
  debug_1302:
    .return (rx1829_cur)
  rx1829_restart:
.annotate 'line', 462
    if_null rx1829_debug, debug_1303
    rx1829_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1303:
  rx1829_fail:
    (rx1829_rep, rx1829_pos, $I10, $P10) = rx1829_cur."!mark_fail"(0)
    lt rx1829_pos, -1, rx1829_done
    eq rx1829_pos, -1, rx1829_fail
    jump $I10
  rx1829_done:
    rx1829_cur."!cursor_fail"()
    if_null rx1829_debug, debug_1304
    rx1829_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1304:
    .return (rx1829_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("226_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("ws", "multi")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("227_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 921
    new $P103, "Undef"
    set $P1835, $P103
    .lex "$*MULTINESS", $P1835
.annotate 'line', 462
    .local string rx1836_tgt
    .local int rx1836_pos
    .local int rx1836_off
    .local int rx1836_eos
    .local int rx1836_rep
    .local pmc rx1836_cur
    .local pmc rx1836_debug
    (rx1836_cur, rx1836_pos, rx1836_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1836_cur
    .local pmc match
    .lex "$/", match
    length rx1836_eos, rx1836_tgt
    gt rx1836_pos, rx1836_eos, rx1836_done
    set rx1836_off, 0
    lt rx1836_pos, 2, rx1836_start
    sub rx1836_off, rx1836_pos, 1
    substr rx1836_tgt, rx1836_tgt, rx1836_off
  rx1836_start:
    eq $I10, 1, rx1836_restart
    if_null rx1836_debug, debug_1305
    rx1836_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1305:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1837_done
    goto rxscan1837_scan
  rxscan1837_loop:
    (rx1836_pos) = rx1836_cur."from"()
    inc rx1836_pos
    rx1836_cur."!cursor_from"(rx1836_pos)
    ge rx1836_pos, rx1836_eos, rxscan1837_done
  rxscan1837_scan:
    set_addr $I10, rxscan1837_loop
    rx1836_cur."!mark_push"(0, rx1836_pos, $I10)
  rxscan1837_done:
.annotate 'line', 921
    rx1836_cur."!cursor_pos"(rx1836_pos)
    new $P104, "String"
    assign $P104, "proto"
    set $P1835, $P104
.annotate 'line', 922
  # rx subcapture "sym"
    set_addr $I10, rxcap_1838_fail
    rx1836_cur."!mark_push"(0, rx1836_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1836_pos, 5
    gt $I11, rx1836_eos, rx1836_fail
    sub $I11, rx1836_pos, rx1836_off
    substr $S10, rx1836_tgt, $I11, 5
    ne $S10, "proto", rx1836_fail
    add rx1836_pos, 5
    set_addr $I10, rxcap_1838_fail
    ($I12, $I11) = rx1836_cur."!mark_peek"($I10)
    rx1836_cur."!cursor_pos"($I11)
    ($P10) = rx1836_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1836_pos, "")
    rx1836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1838_done
  rxcap_1838_fail:
    goto rx1836_fail
  rxcap_1838_done:
.annotate 'line', 923
  # rx subrule "ws" subtype=method negate=
    rx1836_cur."!cursor_pos"(rx1836_pos)
    $P10 = rx1836_cur."ws"()
    unless $P10, rx1836_fail
    rx1836_pos = $P10."pos"()
  alt1839_0:
    set_addr $I10, alt1839_1
    rx1836_cur."!mark_push"(0, rx1836_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1836_cur."!cursor_pos"(rx1836_pos)
    $P10 = rx1836_cur."declarator"()
    unless $P10, rx1836_fail
    rx1836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1836_pos = $P10."pos"()
    goto alt1839_end
  alt1839_1:
    set_addr $I10, alt1839_2
    rx1836_cur."!mark_push"(0, rx1836_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1836_cur."!cursor_pos"(rx1836_pos)
    $P10 = rx1836_cur."routine_def"()
    unless $P10, rx1836_fail
    rx1836_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1836_pos = $P10."pos"()
    goto alt1839_end
  alt1839_2:
  # rx subrule "panic" subtype=method negate=
    rx1836_cur."!cursor_pos"(rx1836_pos)
    $P10 = rx1836_cur."panic"("Malformed proto")
    unless $P10, rx1836_fail
    rx1836_pos = $P10."pos"()
  alt1839_end:
.annotate 'line', 920
  # rx pass
    rx1836_cur."!cursor_pass"(rx1836_pos, "multi_declarator:sym<proto>")
    if_null rx1836_debug, debug_1306
    rx1836_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1836_pos)
  debug_1306:
    .return (rx1836_cur)
  rx1836_restart:
.annotate 'line', 462
    if_null rx1836_debug, debug_1307
    rx1836_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1307:
  rx1836_fail:
    (rx1836_rep, rx1836_pos, $I10, $P10) = rx1836_cur."!mark_fail"(0)
    lt rx1836_pos, -1, rx1836_done
    eq rx1836_pos, -1, rx1836_fail
    jump $I10
  rx1836_done:
    rx1836_cur."!cursor_fail"()
    if_null rx1836_debug, debug_1308
    rx1836_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1308:
    .return (rx1836_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("228_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("ws", "proto")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("229_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 926
    new $P103, "Undef"
    set $P1842, $P103
    .lex "$*MULTINESS", $P1842
.annotate 'line', 462
    .local string rx1843_tgt
    .local int rx1843_pos
    .local int rx1843_off
    .local int rx1843_eos
    .local int rx1843_rep
    .local pmc rx1843_cur
    .local pmc rx1843_debug
    (rx1843_cur, rx1843_pos, rx1843_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1843_cur
    .local pmc match
    .lex "$/", match
    length rx1843_eos, rx1843_tgt
    gt rx1843_pos, rx1843_eos, rx1843_done
    set rx1843_off, 0
    lt rx1843_pos, 2, rx1843_start
    sub rx1843_off, rx1843_pos, 1
    substr rx1843_tgt, rx1843_tgt, rx1843_off
  rx1843_start:
    eq $I10, 1, rx1843_restart
    if_null rx1843_debug, debug_1309
    rx1843_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1309:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1844_done
    goto rxscan1844_scan
  rxscan1844_loop:
    (rx1843_pos) = rx1843_cur."from"()
    inc rx1843_pos
    rx1843_cur."!cursor_from"(rx1843_pos)
    ge rx1843_pos, rx1843_eos, rxscan1844_done
  rxscan1844_scan:
    set_addr $I10, rxscan1844_loop
    rx1843_cur."!mark_push"(0, rx1843_pos, $I10)
  rxscan1844_done:
.annotate 'line', 926
    rx1843_cur."!cursor_pos"(rx1843_pos)
    new $P104, "String"
    assign $P104, ""
    set $P1842, $P104
.annotate 'line', 927
  # rx subrule "declarator" subtype=capture negate=
    rx1843_cur."!cursor_pos"(rx1843_pos)
    $P10 = rx1843_cur."declarator"()
    unless $P10, rx1843_fail
    rx1843_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1843_pos = $P10."pos"()
.annotate 'line', 925
  # rx pass
    rx1843_cur."!cursor_pass"(rx1843_pos, "multi_declarator:sym<null>")
    if_null rx1843_debug, debug_1310
    rx1843_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1843_pos)
  debug_1310:
    .return (rx1843_cur)
  rx1843_restart:
.annotate 'line', 462
    if_null rx1843_debug, debug_1311
    rx1843_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1311:
  rx1843_fail:
    (rx1843_rep, rx1843_pos, $I10, $P10) = rx1843_cur."!mark_fail"(0)
    lt rx1843_pos, -1, rx1843_done
    eq rx1843_pos, -1, rx1843_fail
    jump $I10
  rx1843_done:
    rx1843_cur."!cursor_fail"()
    if_null rx1843_debug, debug_1312
    rx1843_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1312:
    .return (rx1843_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("230_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("declarator", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("231_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1851 = "232_1325892461.451" 
    capture_lex $P1851
    .local string rx1847_tgt
    .local int rx1847_pos
    .local int rx1847_off
    .local int rx1847_eos
    .local int rx1847_rep
    .local pmc rx1847_cur
    .local pmc rx1847_debug
    (rx1847_cur, rx1847_pos, rx1847_tgt, $I10) = self."!cursor_start"()
    rx1847_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1847_cur
    .local pmc match
    .lex "$/", match
    length rx1847_eos, rx1847_tgt
    gt rx1847_pos, rx1847_eos, rx1847_done
    set rx1847_off, 0
    lt rx1847_pos, 2, rx1847_start
    sub rx1847_off, rx1847_pos, 1
    substr rx1847_tgt, rx1847_tgt, rx1847_off
  rx1847_start:
    eq $I10, 1, rx1847_restart
    if_null rx1847_debug, debug_1313
    rx1847_cur."!cursor_debug"("START", "signature")
  debug_1313:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1848_done
    goto rxscan1848_scan
  rxscan1848_loop:
    (rx1847_pos) = rx1847_cur."from"()
    inc rx1847_pos
    rx1847_cur."!cursor_from"(rx1847_pos)
    ge rx1847_pos, rx1847_eos, rxscan1848_done
  rxscan1848_scan:
    set_addr $I10, rxscan1848_loop
    rx1847_cur."!mark_push"(0, rx1847_pos, $I10)
  rxscan1848_done:
.annotate 'line', 931
  # rx rxquantr1849 ** 0..1
    set_addr $I10, rxquantr1849_done
    rx1847_cur."!mark_push"(0, rx1847_pos, $I10)
  rxquantr1849_loop:
    rx1847_cur."!cursor_pos"(rx1847_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1851 = "232_1325892461.451" 
    capture_lex $P1851
    $P105 = $P1851()
    unless $P105, rx1847_fail
  # rx subrule "ws" subtype=method negate=
    rx1847_cur."!cursor_pos"(rx1847_pos)
    $P10 = rx1847_cur."ws"()
    unless $P10, rx1847_fail
    rx1847_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1847_cur."!cursor_pos"(rx1847_pos)
    $P10 = rx1847_cur."parameter"()
    unless $P10, rx1847_fail
    rx1847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1847_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1847_cur."!cursor_pos"(rx1847_pos)
    $P10 = rx1847_cur."ws"()
    unless $P10, rx1847_fail
    rx1847_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1847_pos, 1
    gt $I11, rx1847_eos, rx1847_fail
    sub $I11, rx1847_pos, rx1847_off
    ord $I11, rx1847_tgt, $I11
    ne $I11, 58, rx1847_fail
    add rx1847_pos, 1
    set_addr $I10, rxquantr1849_done
    (rx1847_rep) = rx1847_cur."!mark_commit"($I10)
  rxquantr1849_done:
.annotate 'line', 932
  # rx rxquantr1852 ** 0..1
    set_addr $I10, rxquantr1852_done
    rx1847_cur."!mark_push"(0, rx1847_pos, $I10)
  rxquantr1852_loop:
  # rx rxquantr1853 ** 1..*
    set_addr $I10, rxquantr1853_done
    rx1847_cur."!mark_push"(0, -1, $I10)
  rxquantr1853_loop:
  # rx subrule "ws" subtype=method negate=
    rx1847_cur."!cursor_pos"(rx1847_pos)
    $P10 = rx1847_cur."ws"()
    unless $P10, rx1847_fail
    rx1847_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1847_cur."!cursor_pos"(rx1847_pos)
    $P10 = rx1847_cur."parameter"()
    unless $P10, rx1847_fail
    rx1847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1847_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1847_cur."!cursor_pos"(rx1847_pos)
    $P10 = rx1847_cur."ws"()
    unless $P10, rx1847_fail
    rx1847_pos = $P10."pos"()
    set_addr $I10, rxquantr1853_done
    (rx1847_rep) = rx1847_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1853_done
    rx1847_cur."!mark_push"(rx1847_rep, rx1847_pos, $I10)
  # rx literal  ","
    add $I11, rx1847_pos, 1
    gt $I11, rx1847_eos, rx1847_fail
    sub $I11, rx1847_pos, rx1847_off
    ord $I11, rx1847_tgt, $I11
    ne $I11, 44, rx1847_fail
    add rx1847_pos, 1
    goto rxquantr1853_loop
  rxquantr1853_done:
    set_addr $I10, rxquantr1852_done
    (rx1847_rep) = rx1847_cur."!mark_commit"($I10)
  rxquantr1852_done:
.annotate 'line', 930
  # rx pass
    rx1847_cur."!cursor_pass"(rx1847_pos, "signature")
    if_null rx1847_debug, debug_1316
    rx1847_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1847_pos)
  debug_1316:
    .return (rx1847_cur)
  rx1847_restart:
.annotate 'line', 462
    if_null rx1847_debug, debug_1317
    rx1847_cur."!cursor_debug"("NEXT", "signature")
  debug_1317:
  rx1847_fail:
    (rx1847_rep, rx1847_pos, $I10, $P10) = rx1847_cur."!mark_fail"(0)
    lt rx1847_pos, -1, rx1847_done
    eq rx1847_pos, -1, rx1847_fail
    jump $I10
  rx1847_done:
    rx1847_cur."!cursor_fail"()
    if_null rx1847_debug, debug_1318
    rx1847_cur."!cursor_debug"("FAIL", "signature")
  debug_1318:
    .return (rx1847_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1850"  :anon :subid("232_1325892461.451") :outer("231_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 931
    find_dynamic_lex $P107, "$*INVOCANT_OK"
    unless_null $P107, vivify_1314
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$INVOCANT_OK"]
    unless_null $P107, vivify_1315
    die "Contextual $*INVOCANT_OK not found"
  vivify_1315:
  vivify_1314:
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("233_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P106, "ResizablePMCArray"
    push $P106, ""
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("234_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1856_tgt
    .local int rx1856_pos
    .local int rx1856_off
    .local int rx1856_eos
    .local int rx1856_rep
    .local pmc rx1856_cur
    .local pmc rx1856_debug
    (rx1856_cur, rx1856_pos, rx1856_tgt, $I10) = self."!cursor_start"()
    rx1856_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1856_cur
    .local pmc match
    .lex "$/", match
    length rx1856_eos, rx1856_tgt
    gt rx1856_pos, rx1856_eos, rx1856_done
    set rx1856_off, 0
    lt rx1856_pos, 2, rx1856_start
    sub rx1856_off, rx1856_pos, 1
    substr rx1856_tgt, rx1856_tgt, rx1856_off
  rx1856_start:
    eq $I10, 1, rx1856_restart
    if_null rx1856_debug, debug_1319
    rx1856_cur."!cursor_debug"("START", "parameter")
  debug_1319:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1857_done
    goto rxscan1857_scan
  rxscan1857_loop:
    (rx1856_pos) = rx1856_cur."from"()
    inc rx1856_pos
    rx1856_cur."!cursor_from"(rx1856_pos)
    ge rx1856_pos, rx1856_eos, rxscan1857_done
  rxscan1857_scan:
    set_addr $I10, rxscan1857_loop
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  rxscan1857_done:
.annotate 'line', 936
  # rx rxquantr1858 ** 0..*
    set_addr $I10, rxquantr1858_done
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  rxquantr1858_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1856_cur."!cursor_pos"(rx1856_pos)
    $P10 = rx1856_cur."typename"()
    unless $P10, rx1856_fail
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1856_pos = $P10."pos"()
  # rx rxquantr1859 ** 0..1
    set_addr $I10, rxquantr1859_done
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  rxquantr1859_loop:
  # rx literal  ":"
    add $I11, rx1856_pos, 1
    gt $I11, rx1856_eos, rx1856_fail
    sub $I11, rx1856_pos, rx1856_off
    ord $I11, rx1856_tgt, $I11
    ne $I11, 58, rx1856_fail
    add rx1856_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1860_fail
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1856_pos, rx1856_eos, rx1856_fail
    sub $I10, rx1856_pos, rx1856_off
    substr $S10, rx1856_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1856_fail
    inc rx1856_pos
    set_addr $I10, rxcap_1860_fail
    ($I12, $I11) = rx1856_cur."!mark_peek"($I10)
    rx1856_cur."!cursor_pos"($I11)
    ($P10) = rx1856_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1856_pos, "")
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1860_done
  rxcap_1860_fail:
    goto rx1856_fail
  rxcap_1860_done:
    set_addr $I10, rxquantr1859_done
    (rx1856_rep) = rx1856_cur."!mark_commit"($I10)
  rxquantr1859_done:
  # rx subrule "ws" subtype=method negate=
    rx1856_cur."!cursor_pos"(rx1856_pos)
    $P10 = rx1856_cur."ws"()
    unless $P10, rx1856_fail
    rx1856_pos = $P10."pos"()
    set_addr $I10, rxquantr1858_done
    (rx1856_rep) = rx1856_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1858_done
    rx1856_cur."!mark_push"(rx1856_rep, rx1856_pos, $I10)
    goto rxquantr1858_loop
  rxquantr1858_done:
  alt1861_0:
.annotate 'line', 937
    set_addr $I10, alt1861_1
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
.annotate 'line', 938
  # rx subcapture "quant"
    set_addr $I10, rxcap_1862_fail
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  # rx literal  "*"
    add $I11, rx1856_pos, 1
    gt $I11, rx1856_eos, rx1856_fail
    sub $I11, rx1856_pos, rx1856_off
    ord $I11, rx1856_tgt, $I11
    ne $I11, 42, rx1856_fail
    add rx1856_pos, 1
    set_addr $I10, rxcap_1862_fail
    ($I12, $I11) = rx1856_cur."!mark_peek"($I10)
    rx1856_cur."!cursor_pos"($I11)
    ($P10) = rx1856_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1856_pos, "")
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1862_done
  rxcap_1862_fail:
    goto rx1856_fail
  rxcap_1862_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1856_cur."!cursor_pos"(rx1856_pos)
    $P10 = rx1856_cur."param_var"()
    unless $P10, rx1856_fail
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1856_pos = $P10."pos"()
    goto alt1861_end
  alt1861_1:
  alt1863_0:
.annotate 'line', 939
    set_addr $I10, alt1863_1
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1856_cur."!cursor_pos"(rx1856_pos)
    $P10 = rx1856_cur."param_var"()
    unless $P10, rx1856_fail
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1856_pos = $P10."pos"()
    goto alt1863_end
  alt1863_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1856_cur."!cursor_pos"(rx1856_pos)
    $P10 = rx1856_cur."named_param"()
    unless $P10, rx1856_fail
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1856_pos = $P10."pos"()
  alt1863_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1865_fail
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  alt1864_0:
    set_addr $I10, alt1864_1
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  # rx literal  "?"
    add $I11, rx1856_pos, 1
    gt $I11, rx1856_eos, rx1856_fail
    sub $I11, rx1856_pos, rx1856_off
    ord $I11, rx1856_tgt, $I11
    ne $I11, 63, rx1856_fail
    add rx1856_pos, 1
    goto alt1864_end
  alt1864_1:
    set_addr $I10, alt1864_2
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  # rx literal  "!"
    add $I11, rx1856_pos, 1
    gt $I11, rx1856_eos, rx1856_fail
    sub $I11, rx1856_pos, rx1856_off
    ord $I11, rx1856_tgt, $I11
    ne $I11, 33, rx1856_fail
    add rx1856_pos, 1
    goto alt1864_end
  alt1864_2:
  alt1864_end:
    set_addr $I10, rxcap_1865_fail
    ($I12, $I11) = rx1856_cur."!mark_peek"($I10)
    rx1856_cur."!cursor_pos"($I11)
    ($P10) = rx1856_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1856_pos, "")
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1865_done
  rxcap_1865_fail:
    goto rx1856_fail
  rxcap_1865_done:
  alt1861_end:
.annotate 'line', 941
  # rx rxquantr1866 ** 0..1
    set_addr $I10, rxquantr1866_done
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  rxquantr1866_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1856_cur."!cursor_pos"(rx1856_pos)
    $P10 = rx1856_cur."default_value"()
    unless $P10, rx1856_fail
    goto rxsubrule1867_pass
  rxsubrule1867_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1856_fail
  rxsubrule1867_pass:
    set_addr $I10, rxsubrule1867_back
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1856_pos = $P10."pos"()
    set_addr $I10, rxquantr1866_done
    (rx1856_rep) = rx1856_cur."!mark_commit"($I10)
  rxquantr1866_done:
.annotate 'line', 935
  # rx pass
    rx1856_cur."!cursor_pass"(rx1856_pos, "parameter")
    if_null rx1856_debug, debug_1320
    rx1856_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1856_pos)
  debug_1320:
    .return (rx1856_cur)
  rx1856_restart:
.annotate 'line', 462
    if_null rx1856_debug, debug_1321
    rx1856_cur."!cursor_debug"("NEXT", "parameter")
  debug_1321:
  rx1856_fail:
    (rx1856_rep, rx1856_pos, $I10, $P10) = rx1856_cur."!mark_fail"(0)
    lt rx1856_pos, -1, rx1856_done
    eq rx1856_pos, -1, rx1856_fail
    jump $I10
  rx1856_done:
    rx1856_cur."!cursor_fail"()
    if_null rx1856_debug, debug_1322
    rx1856_cur."!cursor_debug"("FAIL", "parameter")
  debug_1322:
    .return (rx1856_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("235_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("236_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1870_tgt
    .local int rx1870_pos
    .local int rx1870_off
    .local int rx1870_eos
    .local int rx1870_rep
    .local pmc rx1870_cur
    .local pmc rx1870_debug
    (rx1870_cur, rx1870_pos, rx1870_tgt, $I10) = self."!cursor_start"()
    rx1870_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1870_cur
    .local pmc match
    .lex "$/", match
    length rx1870_eos, rx1870_tgt
    gt rx1870_pos, rx1870_eos, rx1870_done
    set rx1870_off, 0
    lt rx1870_pos, 2, rx1870_start
    sub rx1870_off, rx1870_pos, 1
    substr rx1870_tgt, rx1870_tgt, rx1870_off
  rx1870_start:
    eq $I10, 1, rx1870_restart
    if_null rx1870_debug, debug_1323
    rx1870_cur."!cursor_debug"("START", "param_var")
  debug_1323:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1871_done
    goto rxscan1871_scan
  rxscan1871_loop:
    (rx1870_pos) = rx1870_cur."from"()
    inc rx1870_pos
    rx1870_cur."!cursor_from"(rx1870_pos)
    ge rx1870_pos, rx1870_eos, rxscan1871_done
  rxscan1871_scan:
    set_addr $I10, rxscan1871_loop
    rx1870_cur."!mark_push"(0, rx1870_pos, $I10)
  rxscan1871_done:
.annotate 'line', 945
  # rx subrule "sigil" subtype=capture negate=
    rx1870_cur."!cursor_pos"(rx1870_pos)
    $P10 = rx1870_cur."sigil"()
    unless $P10, rx1870_fail
    rx1870_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1870_pos = $P10."pos"()
  # rx rxquantr1872 ** 0..1
    set_addr $I10, rxquantr1872_done
    rx1870_cur."!mark_push"(0, rx1870_pos, $I10)
  rxquantr1872_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1870_cur."!cursor_pos"(rx1870_pos)
    $P10 = rx1870_cur."twigil"()
    unless $P10, rx1870_fail
    goto rxsubrule1873_pass
  rxsubrule1873_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1870_fail
  rxsubrule1873_pass:
    set_addr $I10, rxsubrule1873_back
    rx1870_cur."!mark_push"(0, rx1870_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1870_pos = $P10."pos"()
    set_addr $I10, rxquantr1872_done
    (rx1870_rep) = rx1870_cur."!mark_commit"($I10)
  rxquantr1872_done:
  alt1874_0:
.annotate 'line', 946
    set_addr $I10, alt1874_1
    rx1870_cur."!mark_push"(0, rx1870_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1870_cur."!cursor_pos"(rx1870_pos)
    $P10 = rx1870_cur."ident"()
    unless $P10, rx1870_fail
    rx1870_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1870_pos = $P10."pos"()
    goto alt1874_end
  alt1874_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1875_fail
    rx1870_cur."!mark_push"(0, rx1870_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1870_pos, rx1870_eos, rx1870_fail
    sub $I10, rx1870_pos, rx1870_off
    substr $S10, rx1870_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1870_fail
    inc rx1870_pos
    set_addr $I10, rxcap_1875_fail
    ($I12, $I11) = rx1870_cur."!mark_peek"($I10)
    rx1870_cur."!cursor_pos"($I11)
    ($P10) = rx1870_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1870_pos, "")
    rx1870_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1875_done
  rxcap_1875_fail:
    goto rx1870_fail
  rxcap_1875_done:
  alt1874_end:
.annotate 'line', 944
  # rx pass
    rx1870_cur."!cursor_pass"(rx1870_pos, "param_var")
    if_null rx1870_debug, debug_1324
    rx1870_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1870_pos)
  debug_1324:
    .return (rx1870_cur)
  rx1870_restart:
.annotate 'line', 462
    if_null rx1870_debug, debug_1325
    rx1870_cur."!cursor_debug"("NEXT", "param_var")
  debug_1325:
  rx1870_fail:
    (rx1870_rep, rx1870_pos, $I10, $P10) = rx1870_cur."!mark_fail"(0)
    lt rx1870_pos, -1, rx1870_done
    eq rx1870_pos, -1, rx1870_fail
    jump $I10
  rx1870_done:
    rx1870_cur."!cursor_fail"()
    if_null rx1870_debug, debug_1326
    rx1870_cur."!cursor_debug"("FAIL", "param_var")
  debug_1326:
    .return (rx1870_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("237_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("sigil", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("238_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1878_tgt
    .local int rx1878_pos
    .local int rx1878_off
    .local int rx1878_eos
    .local int rx1878_rep
    .local pmc rx1878_cur
    .local pmc rx1878_debug
    (rx1878_cur, rx1878_pos, rx1878_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1878_cur
    .local pmc match
    .lex "$/", match
    length rx1878_eos, rx1878_tgt
    gt rx1878_pos, rx1878_eos, rx1878_done
    set rx1878_off, 0
    lt rx1878_pos, 2, rx1878_start
    sub rx1878_off, rx1878_pos, 1
    substr rx1878_tgt, rx1878_tgt, rx1878_off
  rx1878_start:
    eq $I10, 1, rx1878_restart
    if_null rx1878_debug, debug_1327
    rx1878_cur."!cursor_debug"("START", "named_param")
  debug_1327:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1879_done
    goto rxscan1879_scan
  rxscan1879_loop:
    (rx1878_pos) = rx1878_cur."from"()
    inc rx1878_pos
    rx1878_cur."!cursor_from"(rx1878_pos)
    ge rx1878_pos, rx1878_eos, rxscan1879_done
  rxscan1879_scan:
    set_addr $I10, rxscan1879_loop
    rx1878_cur."!mark_push"(0, rx1878_pos, $I10)
  rxscan1879_done:
.annotate 'line', 950
  # rx literal  ":"
    add $I11, rx1878_pos, 1
    gt $I11, rx1878_eos, rx1878_fail
    sub $I11, rx1878_pos, rx1878_off
    ord $I11, rx1878_tgt, $I11
    ne $I11, 58, rx1878_fail
    add rx1878_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1878_cur."!cursor_pos"(rx1878_pos)
    $P10 = rx1878_cur."param_var"()
    unless $P10, rx1878_fail
    rx1878_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1878_pos = $P10."pos"()
.annotate 'line', 949
  # rx pass
    rx1878_cur."!cursor_pass"(rx1878_pos, "named_param")
    if_null rx1878_debug, debug_1328
    rx1878_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1878_pos)
  debug_1328:
    .return (rx1878_cur)
  rx1878_restart:
.annotate 'line', 462
    if_null rx1878_debug, debug_1329
    rx1878_cur."!cursor_debug"("NEXT", "named_param")
  debug_1329:
  rx1878_fail:
    (rx1878_rep, rx1878_pos, $I10, $P10) = rx1878_cur."!mark_fail"(0)
    lt rx1878_pos, -1, rx1878_done
    eq rx1878_pos, -1, rx1878_fail
    jump $I10
  rx1878_done:
    rx1878_cur."!cursor_fail"()
    if_null rx1878_debug, debug_1330
    rx1878_cur."!cursor_debug"("FAIL", "named_param")
  debug_1330:
    .return (rx1878_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("239_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("param_var", ":")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("240_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1882_tgt
    .local int rx1882_pos
    .local int rx1882_off
    .local int rx1882_eos
    .local int rx1882_rep
    .local pmc rx1882_cur
    .local pmc rx1882_debug
    (rx1882_cur, rx1882_pos, rx1882_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1882_cur
    .local pmc match
    .lex "$/", match
    length rx1882_eos, rx1882_tgt
    gt rx1882_pos, rx1882_eos, rx1882_done
    set rx1882_off, 0
    lt rx1882_pos, 2, rx1882_start
    sub rx1882_off, rx1882_pos, 1
    substr rx1882_tgt, rx1882_tgt, rx1882_off
  rx1882_start:
    eq $I10, 1, rx1882_restart
    if_null rx1882_debug, debug_1331
    rx1882_cur."!cursor_debug"("START", "default_value")
  debug_1331:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1883_done
    goto rxscan1883_scan
  rxscan1883_loop:
    (rx1882_pos) = rx1882_cur."from"()
    inc rx1882_pos
    rx1882_cur."!cursor_from"(rx1882_pos)
    ge rx1882_pos, rx1882_eos, rxscan1883_done
  rxscan1883_scan:
    set_addr $I10, rxscan1883_loop
    rx1882_cur."!mark_push"(0, rx1882_pos, $I10)
  rxscan1883_done:
.annotate 'line', 953
  # rx subrule "ws" subtype=method negate=
    rx1882_cur."!cursor_pos"(rx1882_pos)
    $P10 = rx1882_cur."ws"()
    unless $P10, rx1882_fail
    rx1882_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1882_pos, 1
    gt $I11, rx1882_eos, rx1882_fail
    sub $I11, rx1882_pos, rx1882_off
    ord $I11, rx1882_tgt, $I11
    ne $I11, 61, rx1882_fail
    add rx1882_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1882_cur."!cursor_pos"(rx1882_pos)
    $P10 = rx1882_cur."ws"()
    unless $P10, rx1882_fail
    rx1882_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1882_cur."!cursor_pos"(rx1882_pos)
    $P10 = rx1882_cur."EXPR"("i=")
    unless $P10, rx1882_fail
    rx1882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1882_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1882_cur."!cursor_pos"(rx1882_pos)
    $P10 = rx1882_cur."ws"()
    unless $P10, rx1882_fail
    rx1882_pos = $P10."pos"()
  # rx pass
    rx1882_cur."!cursor_pass"(rx1882_pos, "default_value")
    if_null rx1882_debug, debug_1332
    rx1882_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1882_pos)
  debug_1332:
    .return (rx1882_cur)
  rx1882_restart:
.annotate 'line', 462
    if_null rx1882_debug, debug_1333
    rx1882_cur."!cursor_debug"("NEXT", "default_value")
  debug_1333:
  rx1882_fail:
    (rx1882_rep, rx1882_pos, $I10, $P10) = rx1882_cur."!mark_fail"(0)
    lt rx1882_pos, -1, rx1882_done
    eq rx1882_pos, -1, rx1882_fail
    jump $I10
  rx1882_done:
    rx1882_cur."!cursor_fail"()
    if_null rx1882_debug, debug_1334
    rx1882_cur."!cursor_debug"("FAIL", "default_value")
  debug_1334:
    .return (rx1882_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("241_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P106 = self."!PREFIX__!subrule"("ws", "")
    new $P107, "ResizablePMCArray"
    push $P107, $P106
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("242_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1886_tgt
    .local int rx1886_pos
    .local int rx1886_off
    .local int rx1886_eos
    .local int rx1886_rep
    .local pmc rx1886_cur
    .local pmc rx1886_debug
    (rx1886_cur, rx1886_pos, rx1886_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1886_cur
    .local pmc match
    .lex "$/", match
    length rx1886_eos, rx1886_tgt
    gt rx1886_pos, rx1886_eos, rx1886_done
    set rx1886_off, 0
    lt rx1886_pos, 2, rx1886_start
    sub rx1886_off, rx1886_pos, 1
    substr rx1886_tgt, rx1886_tgt, rx1886_off
  rx1886_start:
    eq $I10, 1, rx1886_restart
    if_null rx1886_debug, debug_1335
    rx1886_cur."!cursor_debug"("START", "trait")
  debug_1335:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1887_done
    goto rxscan1887_scan
  rxscan1887_loop:
    (rx1886_pos) = rx1886_cur."from"()
    inc rx1886_pos
    rx1886_cur."!cursor_from"(rx1886_pos)
    ge rx1886_pos, rx1886_eos, rxscan1887_done
  rxscan1887_scan:
    set_addr $I10, rxscan1887_loop
    rx1886_cur."!mark_push"(0, rx1886_pos, $I10)
  rxscan1887_done:
.annotate 'line', 955
  # rx subrule "ws" subtype=method negate=
    rx1886_cur."!cursor_pos"(rx1886_pos)
    $P10 = rx1886_cur."ws"()
    unless $P10, rx1886_fail
    rx1886_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1886_cur."!cursor_pos"(rx1886_pos)
    $P10 = rx1886_cur."trait_mod"()
    unless $P10, rx1886_fail
    rx1886_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1886_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1886_cur."!cursor_pos"(rx1886_pos)
    $P10 = rx1886_cur."ws"()
    unless $P10, rx1886_fail
    rx1886_pos = $P10."pos"()
  # rx pass
    rx1886_cur."!cursor_pass"(rx1886_pos, "trait")
    if_null rx1886_debug, debug_1336
    rx1886_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1886_pos)
  debug_1336:
    .return (rx1886_cur)
  rx1886_restart:
.annotate 'line', 462
    if_null rx1886_debug, debug_1337
    rx1886_cur."!cursor_debug"("NEXT", "trait")
  debug_1337:
  rx1886_fail:
    (rx1886_rep, rx1886_pos, $I10, $P10) = rx1886_cur."!mark_fail"(0)
    lt rx1886_pos, -1, rx1886_done
    eq rx1886_pos, -1, rx1886_fail
    jump $I10
  rx1886_done:
    rx1886_cur."!cursor_fail"()
    if_null rx1886_debug, debug_1338
    rx1886_cur."!cursor_debug"("FAIL", "trait")
  debug_1338:
    .return (rx1886_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("243_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("ws", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("244_1325892461.451")
    .param pmc param_1890
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 957
    .lex "self", param_1890
    $P103 = param_1890."!protoregex"("trait_mod")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("245_1325892461.451")
    .param pmc param_1892
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 957
    .lex "self", param_1892
    $P104 = param_1892."!PREFIX__!protoregex"("trait_mod")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("246_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1894_tgt
    .local int rx1894_pos
    .local int rx1894_off
    .local int rx1894_eos
    .local int rx1894_rep
    .local pmc rx1894_cur
    .local pmc rx1894_debug
    (rx1894_cur, rx1894_pos, rx1894_tgt, $I10) = self."!cursor_start"()
    rx1894_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1894_cur
    .local pmc match
    .lex "$/", match
    length rx1894_eos, rx1894_tgt
    gt rx1894_pos, rx1894_eos, rx1894_done
    set rx1894_off, 0
    lt rx1894_pos, 2, rx1894_start
    sub rx1894_off, rx1894_pos, 1
    substr rx1894_tgt, rx1894_tgt, rx1894_off
  rx1894_start:
    eq $I10, 1, rx1894_restart
    if_null rx1894_debug, debug_1339
    rx1894_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1339:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1895_done
    goto rxscan1895_scan
  rxscan1895_loop:
    (rx1894_pos) = rx1894_cur."from"()
    inc rx1894_pos
    rx1894_cur."!cursor_from"(rx1894_pos)
    ge rx1894_pos, rx1894_eos, rxscan1895_done
  rxscan1895_scan:
    set_addr $I10, rxscan1895_loop
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  rxscan1895_done:
.annotate 'line', 958
  # rx subcapture "sym"
    set_addr $I10, rxcap_1896_fail
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  # rx literal  "is"
    add $I11, rx1894_pos, 2
    gt $I11, rx1894_eos, rx1894_fail
    sub $I11, rx1894_pos, rx1894_off
    substr $S10, rx1894_tgt, $I11, 2
    ne $S10, "is", rx1894_fail
    add rx1894_pos, 2
    set_addr $I10, rxcap_1896_fail
    ($I12, $I11) = rx1894_cur."!mark_peek"($I10)
    rx1894_cur."!cursor_pos"($I11)
    ($P10) = rx1894_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1894_pos, "")
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1896_done
  rxcap_1896_fail:
    goto rx1894_fail
  rxcap_1896_done:
  # rx subrule "ws" subtype=method negate=
    rx1894_cur."!cursor_pos"(rx1894_pos)
    $P10 = rx1894_cur."ws"()
    unless $P10, rx1894_fail
    rx1894_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1894_cur."!cursor_pos"(rx1894_pos)
    $P10 = rx1894_cur."deflongname"()
    unless $P10, rx1894_fail
    rx1894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1894_pos = $P10."pos"()
  # rx rxquantr1897 ** 0..1
    set_addr $I10, rxquantr1897_done
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10)
  rxquantr1897_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1894_cur."!cursor_pos"(rx1894_pos)
    $P10 = rx1894_cur."circumfix"()
    unless $P10, rx1894_fail
    goto rxsubrule1898_pass
  rxsubrule1898_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1894_fail
  rxsubrule1898_pass:
    set_addr $I10, rxsubrule1898_back
    rx1894_cur."!mark_push"(0, rx1894_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1894_pos = $P10."pos"()
    set_addr $I10, rxquantr1897_done
    (rx1894_rep) = rx1894_cur."!mark_commit"($I10)
  rxquantr1897_done:
  # rx subrule "ws" subtype=method negate=
    rx1894_cur."!cursor_pos"(rx1894_pos)
    $P10 = rx1894_cur."ws"()
    unless $P10, rx1894_fail
    rx1894_pos = $P10."pos"()
  # rx pass
    rx1894_cur."!cursor_pass"(rx1894_pos, "trait_mod:sym<is>")
    if_null rx1894_debug, debug_1340
    rx1894_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1894_pos)
  debug_1340:
    .return (rx1894_cur)
  rx1894_restart:
.annotate 'line', 462
    if_null rx1894_debug, debug_1341
    rx1894_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1341:
  rx1894_fail:
    (rx1894_rep, rx1894_pos, $I10, $P10) = rx1894_cur."!mark_fail"(0)
    lt rx1894_pos, -1, rx1894_done
    eq rx1894_pos, -1, rx1894_fail
    jump $I10
  rx1894_done:
    rx1894_cur."!cursor_fail"()
    if_null rx1894_debug, debug_1342
    rx1894_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1342:
    .return (rx1894_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("247_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("ws", "is")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("248_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1901_tgt
    .local int rx1901_pos
    .local int rx1901_off
    .local int rx1901_eos
    .local int rx1901_rep
    .local pmc rx1901_cur
    .local pmc rx1901_debug
    (rx1901_cur, rx1901_pos, rx1901_tgt, $I10) = self."!cursor_start"()
    rx1901_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1901_cur
    .local pmc match
    .lex "$/", match
    length rx1901_eos, rx1901_tgt
    gt rx1901_pos, rx1901_eos, rx1901_done
    set rx1901_off, 0
    lt rx1901_pos, 2, rx1901_start
    sub rx1901_off, rx1901_pos, 1
    substr rx1901_tgt, rx1901_tgt, rx1901_off
  rx1901_start:
    eq $I10, 1, rx1901_restart
    if_null rx1901_debug, debug_1343
    rx1901_cur."!cursor_debug"("START", "regex_declarator")
  debug_1343:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1902_done
    goto rxscan1902_scan
  rxscan1902_loop:
    (rx1901_pos) = rx1901_cur."from"()
    inc rx1901_pos
    rx1901_cur."!cursor_from"(rx1901_pos)
    ge rx1901_pos, rx1901_eos, rxscan1902_done
  rxscan1902_scan:
    set_addr $I10, rxscan1902_loop
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  rxscan1902_done:
.annotate 'line', 960
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  alt1903_0:
.annotate 'line', 961
    set_addr $I10, alt1903_1
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
.annotate 'line', 962
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1904_fail
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1901_pos, 5
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 5
    ne $S10, "proto", rx1901_fail
    add rx1901_pos, 5
    set_addr $I10, rxcap_1904_fail
    ($I12, $I11) = rx1901_cur."!mark_peek"($I10)
    rx1901_cur."!cursor_pos"($I11)
    ($P10) = rx1901_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1901_pos, "")
    rx1901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1904_done
  rxcap_1904_fail:
    goto rx1901_fail
  rxcap_1904_done:
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  alt1905_0:
    set_addr $I10, alt1905_1
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1901_pos, 5
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 5
    ne $S10, "regex", rx1901_fail
    add rx1901_pos, 5
    goto alt1905_end
  alt1905_1:
    set_addr $I10, alt1905_2
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  # rx literal  "token"
    add $I11, rx1901_pos, 5
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 5
    ne $S10, "token", rx1901_fail
    add rx1901_pos, 5
    goto alt1905_end
  alt1905_2:
  # rx literal  "rule"
    add $I11, rx1901_pos, 4
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 4
    ne $S10, "rule", rx1901_fail
    add rx1901_pos, 4
  alt1905_end:
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
.annotate 'line', 963
  # rx subrule "deflongname" subtype=capture negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."deflongname"()
    unless $P10, rx1901_fail
    rx1901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1901_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  alt1906_0:
.annotate 'line', 964
    set_addr $I10, alt1906_1
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
.annotate 'line', 965
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1901_pos, 1
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    ord $I11, rx1901_tgt, $I11
    ne $I11, 123, rx1901_fail
    add rx1901_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1901_pos, 5
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 5
    ne $S10, "<...>", rx1901_fail
    add rx1901_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1901_pos, 1
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    ord $I11, rx1901_tgt, $I11
    ne $I11, 125, rx1901_fail
    add rx1901_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ENDSTMT"()
    unless $P10, rx1901_fail
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
    goto alt1906_end
  alt1906_1:
    set_addr $I10, alt1906_2
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
.annotate 'line', 966
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1901_pos, 1
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    ord $I11, rx1901_tgt, $I11
    ne $I11, 123, rx1901_fail
    add rx1901_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1901_pos, 3
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 3
    ne $S10, "<*>", rx1901_fail
    add rx1901_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1901_pos, 1
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    ord $I11, rx1901_tgt, $I11
    ne $I11, 125, rx1901_fail
    add rx1901_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ENDSTMT"()
    unless $P10, rx1901_fail
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
    goto alt1906_end
  alt1906_2:
.annotate 'line', 967
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  alt1906_end:
.annotate 'line', 968
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
.annotate 'line', 962
    goto alt1903_end
  alt1903_1:
.annotate 'line', 969
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1908_fail
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  alt1907_0:
    set_addr $I10, alt1907_1
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1901_pos, 5
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 5
    ne $S10, "regex", rx1901_fail
    add rx1901_pos, 5
    goto alt1907_end
  alt1907_1:
    set_addr $I10, alt1907_2
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  # rx literal  "token"
    add $I11, rx1901_pos, 5
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 5
    ne $S10, "token", rx1901_fail
    add rx1901_pos, 5
    goto alt1907_end
  alt1907_2:
  # rx literal  "rule"
    add $I11, rx1901_pos, 4
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    substr $S10, rx1901_tgt, $I11, 4
    ne $S10, "rule", rx1901_fail
    add rx1901_pos, 4
  alt1907_end:
    set_addr $I10, rxcap_1908_fail
    ($I12, $I11) = rx1901_cur."!mark_peek"($I10)
    rx1901_cur."!cursor_pos"($I11)
    ($P10) = rx1901_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1901_pos, "")
    rx1901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1908_done
  rxcap_1908_fail:
    goto rx1901_fail
  rxcap_1908_done:
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
.annotate 'line', 970
  # rx subrule "deflongname" subtype=capture negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."deflongname"()
    unless $P10, rx1901_fail
    rx1901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1901_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
.annotate 'line', 971
  # rx subrule "newpad" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."newpad"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
.annotate 'line', 972
  # rx rxquantr1909 ** 0..1
    set_addr $I10, rxquantr1909_done
    rx1901_cur."!mark_push"(0, rx1901_pos, $I10)
  rxquantr1909_loop:
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1901_pos, 1
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    ord $I11, rx1901_tgt, $I11
    ne $I11, 40, rx1901_fail
    add rx1901_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."signature"()
    unless $P10, rx1901_fail
    rx1901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1901_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1901_pos, 1
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    ord $I11, rx1901_tgt, $I11
    ne $I11, 41, rx1901_fail
    add rx1901_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
    set_addr $I10, rxquantr1909_done
    (rx1901_rep) = rx1901_cur."!mark_commit"($I10)
  rxquantr1909_done:
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
.annotate 'line', 973
  # rx reduce name="regex_declarator" key="open"
    rx1901_cur."!cursor_pos"(rx1901_pos)
    rx1901_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
.annotate 'line', 974
  # rx literal  "{"
    add $I11, rx1901_pos, 1
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    ord $I11, rx1901_tgt, $I11
    ne $I11, 123, rx1901_fail
    add rx1901_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1901_fail
    rx1901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1901_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1901_pos, 1
    gt $I11, rx1901_eos, rx1901_fail
    sub $I11, rx1901_pos, rx1901_off
    ord $I11, rx1901_tgt, $I11
    ne $I11, 125, rx1901_fail
    add rx1901_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ENDSTMT"()
    unless $P10, rx1901_fail
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
  alt1903_end:
.annotate 'line', 975
  # rx subrule "ws" subtype=method negate=
    rx1901_cur."!cursor_pos"(rx1901_pos)
    $P10 = rx1901_cur."ws"()
    unless $P10, rx1901_fail
    rx1901_pos = $P10."pos"()
.annotate 'line', 960
  # rx pass
    rx1901_cur."!cursor_pass"(rx1901_pos, "regex_declarator")
    if_null rx1901_debug, debug_1344
    rx1901_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1901_pos)
  debug_1344:
    .return (rx1901_cur)
  rx1901_restart:
.annotate 'line', 462
    if_null rx1901_debug, debug_1345
    rx1901_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1345:
  rx1901_fail:
    (rx1901_rep, rx1901_pos, $I10, $P10) = rx1901_cur."!mark_fail"(0)
    lt rx1901_pos, -1, rx1901_done
    eq rx1901_pos, -1, rx1901_fail
    jump $I10
  rx1901_done:
    rx1901_cur."!cursor_fail"()
    if_null rx1901_debug, debug_1346
    rx1901_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1346:
    .return (rx1901_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("249_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P131 = self."!PREFIX__!subrule"("ws", "")
    new $P132, "ResizablePMCArray"
    push $P132, $P131
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("250_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1912_tgt
    .local int rx1912_pos
    .local int rx1912_off
    .local int rx1912_eos
    .local int rx1912_rep
    .local pmc rx1912_cur
    .local pmc rx1912_debug
    (rx1912_cur, rx1912_pos, rx1912_tgt, $I10) = self."!cursor_start"()
    rx1912_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1912_cur
    .local pmc match
    .lex "$/", match
    length rx1912_eos, rx1912_tgt
    gt rx1912_pos, rx1912_eos, rx1912_done
    set rx1912_off, 0
    lt rx1912_pos, 2, rx1912_start
    sub rx1912_off, rx1912_pos, 1
    substr rx1912_tgt, rx1912_tgt, rx1912_off
  rx1912_start:
    eq $I10, 1, rx1912_restart
    if_null rx1912_debug, debug_1347
    rx1912_cur."!cursor_debug"("START", "dotty")
  debug_1347:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1913_done
    goto rxscan1913_scan
  rxscan1913_loop:
    (rx1912_pos) = rx1912_cur."from"()
    inc rx1912_pos
    rx1912_cur."!cursor_from"(rx1912_pos)
    ge rx1912_pos, rx1912_eos, rxscan1913_done
  rxscan1913_scan:
    set_addr $I10, rxscan1913_loop
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  rxscan1913_done:
.annotate 'line', 979
  # rx literal  "."
    add $I11, rx1912_pos, 1
    gt $I11, rx1912_eos, rx1912_fail
    sub $I11, rx1912_pos, rx1912_off
    ord $I11, rx1912_tgt, $I11
    ne $I11, 46, rx1912_fail
    add rx1912_pos, 1
  alt1914_0:
.annotate 'line', 980
    set_addr $I10, alt1914_1
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1912_cur."!cursor_pos"(rx1912_pos)
    $P10 = rx1912_cur."deflongname"()
    unless $P10, rx1912_fail
    rx1912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1912_pos = $P10."pos"()
    goto alt1914_end
  alt1914_1:
.annotate 'line', 981
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1912_pos, rx1912_off
    substr $S10, rx1912_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1912_fail
  # rx subrule "quote" subtype=capture negate=
    rx1912_cur."!cursor_pos"(rx1912_pos)
    $P10 = rx1912_cur."quote"()
    unless $P10, rx1912_fail
    rx1912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1912_pos = $P10."pos"()
  alt1915_0:
.annotate 'line', 982
    set_addr $I10, alt1915_1
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1912_pos, rx1912_off
    substr $S10, rx1912_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1912_fail
    goto alt1915_end
  alt1915_1:
  # rx subrule "panic" subtype=method negate=
    rx1912_cur."!cursor_pos"(rx1912_pos)
    $P10 = rx1912_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1912_fail
    rx1912_pos = $P10."pos"()
  alt1915_end:
  alt1914_end:
.annotate 'line', 988
  # rx rxquantr1916 ** 0..1
    set_addr $I10, rxquantr1916_done
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  rxquantr1916_loop:
  alt1917_0:
.annotate 'line', 985
    set_addr $I10, alt1917_1
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
.annotate 'line', 986
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1912_pos, rx1912_off
    substr $S10, rx1912_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1912_fail
  # rx subrule "args" subtype=capture negate=
    rx1912_cur."!cursor_pos"(rx1912_pos)
    $P10 = rx1912_cur."args"()
    unless $P10, rx1912_fail
    rx1912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1912_pos = $P10."pos"()
    goto alt1917_end
  alt1917_1:
.annotate 'line', 987
  # rx literal  ":"
    add $I11, rx1912_pos, 1
    gt $I11, rx1912_eos, rx1912_fail
    sub $I11, rx1912_pos, rx1912_off
    ord $I11, rx1912_tgt, $I11
    ne $I11, 58, rx1912_fail
    add rx1912_pos, 1
  # rx charclass s
    ge rx1912_pos, rx1912_eos, rx1912_fail
    sub $I10, rx1912_pos, rx1912_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx1912_tgt, $I10
    unless $I11, rx1912_fail
    inc rx1912_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1912_cur."!cursor_pos"(rx1912_pos)
    $P10 = rx1912_cur."arglist"()
    unless $P10, rx1912_fail
    rx1912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1912_pos = $P10."pos"()
  alt1917_end:
.annotate 'line', 988
    set_addr $I10, rxquantr1916_done
    (rx1912_rep) = rx1912_cur."!mark_commit"($I10)
  rxquantr1916_done:
.annotate 'line', 978
  # rx pass
    rx1912_cur."!cursor_pass"(rx1912_pos, "dotty")
    if_null rx1912_debug, debug_1348
    rx1912_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1912_pos)
  debug_1348:
    .return (rx1912_cur)
  rx1912_restart:
.annotate 'line', 462
    if_null rx1912_debug, debug_1349
    rx1912_cur."!cursor_debug"("NEXT", "dotty")
  debug_1349:
  rx1912_fail:
    (rx1912_rep, rx1912_pos, $I10, $P10) = rx1912_cur."!mark_fail"(0)
    lt rx1912_pos, -1, rx1912_done
    eq rx1912_pos, -1, rx1912_fail
    jump $I10
  rx1912_done:
    rx1912_cur."!cursor_fail"()
    if_null rx1912_debug, debug_1350
    rx1912_cur."!cursor_debug"("FAIL", "dotty")
  debug_1350:
    .return (rx1912_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("251_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P104, "ResizablePMCArray"
    push $P104, "'"
    push $P104, "\""
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("252_1325892461.451")
    .param pmc param_1920
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 992
    .lex "self", param_1920
    $P103 = param_1920."!protoregex"("term")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("253_1325892461.451")
    .param pmc param_1922
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 992
    .lex "self", param_1922
    $P104 = param_1922."!PREFIX__!protoregex"("term")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("254_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1924_tgt
    .local int rx1924_pos
    .local int rx1924_off
    .local int rx1924_eos
    .local int rx1924_rep
    .local pmc rx1924_cur
    .local pmc rx1924_debug
    (rx1924_cur, rx1924_pos, rx1924_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1924_cur
    .local pmc match
    .lex "$/", match
    length rx1924_eos, rx1924_tgt
    gt rx1924_pos, rx1924_eos, rx1924_done
    set rx1924_off, 0
    lt rx1924_pos, 2, rx1924_start
    sub rx1924_off, rx1924_pos, 1
    substr rx1924_tgt, rx1924_tgt, rx1924_off
  rx1924_start:
    eq $I10, 1, rx1924_restart
    if_null rx1924_debug, debug_1351
    rx1924_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1351:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1925_done
    goto rxscan1925_scan
  rxscan1925_loop:
    (rx1924_pos) = rx1924_cur."from"()
    inc rx1924_pos
    rx1924_cur."!cursor_from"(rx1924_pos)
    ge rx1924_pos, rx1924_eos, rxscan1925_done
  rxscan1925_scan:
    set_addr $I10, rxscan1925_loop
    rx1924_cur."!mark_push"(0, rx1924_pos, $I10)
  rxscan1925_done:
.annotate 'line', 994
  # rx subcapture "sym"
    set_addr $I10, rxcap_1926_fail
    rx1924_cur."!mark_push"(0, rx1924_pos, $I10)
  # rx literal  "self"
    add $I11, rx1924_pos, 4
    gt $I11, rx1924_eos, rx1924_fail
    sub $I11, rx1924_pos, rx1924_off
    substr $S10, rx1924_tgt, $I11, 4
    ne $S10, "self", rx1924_fail
    add rx1924_pos, 4
    set_addr $I10, rxcap_1926_fail
    ($I12, $I11) = rx1924_cur."!mark_peek"($I10)
    rx1924_cur."!cursor_pos"($I11)
    ($P10) = rx1924_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1924_pos, "")
    rx1924_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1926_done
  rxcap_1926_fail:
    goto rx1924_fail
  rxcap_1926_done:
  # rxanchor rwb
    le rx1924_pos, 0, rx1924_fail
    sub $I10, rx1924_pos, rx1924_off
    is_cclass $I11, .CCLASS_WORD, rx1924_tgt, $I10
    if $I11, rx1924_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx1924_tgt, $I10
    unless $I11, rx1924_fail
  # rx pass
    rx1924_cur."!cursor_pass"(rx1924_pos, "term:sym<self>")
    if_null rx1924_debug, debug_1352
    rx1924_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1924_pos)
  debug_1352:
    .return (rx1924_cur)
  rx1924_restart:
.annotate 'line', 462
    if_null rx1924_debug, debug_1353
    rx1924_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1353:
  rx1924_fail:
    (rx1924_rep, rx1924_pos, $I10, $P10) = rx1924_cur."!mark_fail"(0)
    lt rx1924_pos, -1, rx1924_done
    eq rx1924_pos, -1, rx1924_fail
    jump $I10
  rx1924_done:
    rx1924_cur."!cursor_fail"()
    if_null rx1924_debug, debug_1354
    rx1924_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1354:
    .return (rx1924_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("255_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "self"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("256_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1929_tgt
    .local int rx1929_pos
    .local int rx1929_off
    .local int rx1929_eos
    .local int rx1929_rep
    .local pmc rx1929_cur
    .local pmc rx1929_debug
    (rx1929_cur, rx1929_pos, rx1929_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1929_cur
    .local pmc match
    .lex "$/", match
    length rx1929_eos, rx1929_tgt
    gt rx1929_pos, rx1929_eos, rx1929_done
    set rx1929_off, 0
    lt rx1929_pos, 2, rx1929_start
    sub rx1929_off, rx1929_pos, 1
    substr rx1929_tgt, rx1929_tgt, rx1929_off
  rx1929_start:
    eq $I10, 1, rx1929_restart
    if_null rx1929_debug, debug_1355
    rx1929_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1355:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1930_done
    goto rxscan1930_scan
  rxscan1930_loop:
    (rx1929_pos) = rx1929_cur."from"()
    inc rx1929_pos
    rx1929_cur."!cursor_from"(rx1929_pos)
    ge rx1929_pos, rx1929_eos, rxscan1930_done
  rxscan1930_scan:
    set_addr $I10, rxscan1930_loop
    rx1929_cur."!mark_push"(0, rx1929_pos, $I10)
  rxscan1930_done:
.annotate 'line', 997
  # rx subrule "deflongname" subtype=capture negate=
    rx1929_cur."!cursor_pos"(rx1929_pos)
    $P10 = rx1929_cur."deflongname"()
    unless $P10, rx1929_fail
    rx1929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1929_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1929_pos, rx1929_off
    substr $S10, rx1929_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1929_fail
  # rx subrule "args" subtype=capture negate=
    rx1929_cur."!cursor_pos"(rx1929_pos)
    $P10 = rx1929_cur."args"()
    unless $P10, rx1929_fail
    rx1929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1929_pos = $P10."pos"()
.annotate 'line', 996
  # rx pass
    rx1929_cur."!cursor_pass"(rx1929_pos, "term:sym<identifier>")
    if_null rx1929_debug, debug_1356
    rx1929_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1929_pos)
  debug_1356:
    .return (rx1929_cur)
  rx1929_restart:
.annotate 'line', 462
    if_null rx1929_debug, debug_1357
    rx1929_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1357:
  rx1929_fail:
    (rx1929_rep, rx1929_pos, $I10, $P10) = rx1929_cur."!mark_fail"(0)
    lt rx1929_pos, -1, rx1929_done
    eq rx1929_pos, -1, rx1929_fail
    jump $I10
  rx1929_done:
    rx1929_cur."!cursor_fail"()
    if_null rx1929_debug, debug_1358
    rx1929_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1358:
    .return (rx1929_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("257_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("deflongname", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("258_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1933_tgt
    .local int rx1933_pos
    .local int rx1933_off
    .local int rx1933_eos
    .local int rx1933_rep
    .local pmc rx1933_cur
    .local pmc rx1933_debug
    (rx1933_cur, rx1933_pos, rx1933_tgt, $I10) = self."!cursor_start"()
    rx1933_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1933_cur
    .local pmc match
    .lex "$/", match
    length rx1933_eos, rx1933_tgt
    gt rx1933_pos, rx1933_eos, rx1933_done
    set rx1933_off, 0
    lt rx1933_pos, 2, rx1933_start
    sub rx1933_off, rx1933_pos, 1
    substr rx1933_tgt, rx1933_tgt, rx1933_off
  rx1933_start:
    eq $I10, 1, rx1933_restart
    if_null rx1933_debug, debug_1359
    rx1933_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1359:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1934_done
    goto rxscan1934_scan
  rxscan1934_loop:
    (rx1933_pos) = rx1933_cur."from"()
    inc rx1933_pos
    rx1933_cur."!cursor_from"(rx1933_pos)
    ge rx1933_pos, rx1933_eos, rxscan1934_done
  rxscan1934_scan:
    set_addr $I10, rxscan1934_loop
    rx1933_cur."!mark_push"(0, rx1933_pos, $I10)
  rxscan1934_done:
.annotate 'line', 1001
  # rx subrule "name" subtype=capture negate=
    rx1933_cur."!cursor_pos"(rx1933_pos)
    $P10 = rx1933_cur."name"()
    unless $P10, rx1933_fail
    rx1933_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1933_pos = $P10."pos"()
  # rx rxquantr1935 ** 0..1
    set_addr $I10, rxquantr1935_done
    rx1933_cur."!mark_push"(0, rx1933_pos, $I10)
  rxquantr1935_loop:
  # rx subrule "args" subtype=capture negate=
    rx1933_cur."!cursor_pos"(rx1933_pos)
    $P10 = rx1933_cur."args"()
    unless $P10, rx1933_fail
    goto rxsubrule1936_pass
  rxsubrule1936_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1933_fail
  rxsubrule1936_pass:
    set_addr $I10, rxsubrule1936_back
    rx1933_cur."!mark_push"(0, rx1933_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1933_pos = $P10."pos"()
    set_addr $I10, rxquantr1935_done
    (rx1933_rep) = rx1933_cur."!mark_commit"($I10)
  rxquantr1935_done:
.annotate 'line', 1000
  # rx pass
    rx1933_cur."!cursor_pass"(rx1933_pos, "term:sym<name>")
    if_null rx1933_debug, debug_1360
    rx1933_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1933_pos)
  debug_1360:
    .return (rx1933_cur)
  rx1933_restart:
.annotate 'line', 462
    if_null rx1933_debug, debug_1361
    rx1933_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1361:
  rx1933_fail:
    (rx1933_rep, rx1933_pos, $I10, $P10) = rx1933_cur."!mark_fail"(0)
    lt rx1933_pos, -1, rx1933_done
    eq rx1933_pos, -1, rx1933_fail
    jump $I10
  rx1933_done:
    rx1933_cur."!cursor_fail"()
    if_null rx1933_debug, debug_1362
    rx1933_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1362:
    .return (rx1933_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("259_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("name", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("260_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1939_tgt
    .local int rx1939_pos
    .local int rx1939_off
    .local int rx1939_eos
    .local int rx1939_rep
    .local pmc rx1939_cur
    .local pmc rx1939_debug
    (rx1939_cur, rx1939_pos, rx1939_tgt, $I10) = self."!cursor_start"()
    rx1939_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1939_cur
    .local pmc match
    .lex "$/", match
    length rx1939_eos, rx1939_tgt
    gt rx1939_pos, rx1939_eos, rx1939_done
    set rx1939_off, 0
    lt rx1939_pos, 2, rx1939_start
    sub rx1939_off, rx1939_pos, 1
    substr rx1939_tgt, rx1939_tgt, rx1939_off
  rx1939_start:
    eq $I10, 1, rx1939_restart
    if_null rx1939_debug, debug_1363
    rx1939_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1363:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1940_done
    goto rxscan1940_scan
  rxscan1940_loop:
    (rx1939_pos) = rx1939_cur."from"()
    inc rx1939_pos
    rx1939_cur."!cursor_from"(rx1939_pos)
    ge rx1939_pos, rx1939_eos, rxscan1940_done
  rxscan1940_scan:
    set_addr $I10, rxscan1940_loop
    rx1939_cur."!mark_push"(0, rx1939_pos, $I10)
  rxscan1940_done:
.annotate 'line', 1005
  # rx literal  "pir::"
    add $I11, rx1939_pos, 5
    gt $I11, rx1939_eos, rx1939_fail
    sub $I11, rx1939_pos, rx1939_off
    substr $S10, rx1939_tgt, $I11, 5
    ne $S10, "pir::", rx1939_fail
    add rx1939_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1941_fail
    rx1939_cur."!mark_push"(0, rx1939_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1939_pos, rx1939_off
    find_not_cclass $I11, .CCLASS_WORD, rx1939_tgt, $I10, rx1939_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1939_fail
    add rx1939_pos, rx1939_off, $I11
    set_addr $I10, rxcap_1941_fail
    ($I12, $I11) = rx1939_cur."!mark_peek"($I10)
    rx1939_cur."!cursor_pos"($I11)
    ($P10) = rx1939_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1939_pos, "")
    rx1939_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1941_done
  rxcap_1941_fail:
    goto rx1939_fail
  rxcap_1941_done:
  # rx rxquantr1942 ** 0..1
    set_addr $I10, rxquantr1942_done
    rx1939_cur."!mark_push"(0, rx1939_pos, $I10)
  rxquantr1942_loop:
  # rx subrule "args" subtype=capture negate=
    rx1939_cur."!cursor_pos"(rx1939_pos)
    $P10 = rx1939_cur."args"()
    unless $P10, rx1939_fail
    goto rxsubrule1943_pass
  rxsubrule1943_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1939_fail
  rxsubrule1943_pass:
    set_addr $I10, rxsubrule1943_back
    rx1939_cur."!mark_push"(0, rx1939_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1939_pos = $P10."pos"()
    set_addr $I10, rxquantr1942_done
    (rx1939_rep) = rx1939_cur."!mark_commit"($I10)
  rxquantr1942_done:
.annotate 'line', 1004
  # rx pass
    rx1939_cur."!cursor_pass"(rx1939_pos, "term:sym<pir::op>")
    if_null rx1939_debug, debug_1364
    rx1939_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1939_pos)
  debug_1364:
    .return (rx1939_cur)
  rx1939_restart:
.annotate 'line', 462
    if_null rx1939_debug, debug_1365
    rx1939_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1365:
  rx1939_fail:
    (rx1939_rep, rx1939_pos, $I10, $P10) = rx1939_cur."!mark_fail"(0)
    lt rx1939_pos, -1, rx1939_done
    eq rx1939_pos, -1, rx1939_fail
    jump $I10
  rx1939_done:
    rx1939_cur."!cursor_fail"()
    if_null rx1939_debug, debug_1366
    rx1939_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1366:
    .return (rx1939_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("261_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "pir::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::const>"  :subid("262_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1946_tgt
    .local int rx1946_pos
    .local int rx1946_off
    .local int rx1946_eos
    .local int rx1946_rep
    .local pmc rx1946_cur
    .local pmc rx1946_debug
    (rx1946_cur, rx1946_pos, rx1946_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1946_cur
    .local pmc match
    .lex "$/", match
    length rx1946_eos, rx1946_tgt
    gt rx1946_pos, rx1946_eos, rx1946_done
    set rx1946_off, 0
    lt rx1946_pos, 2, rx1946_start
    sub rx1946_off, rx1946_pos, 1
    substr rx1946_tgt, rx1946_tgt, rx1946_off
  rx1946_start:
    eq $I10, 1, rx1946_restart
    if_null rx1946_debug, debug_1367
    rx1946_cur."!cursor_debug"("START", "term:sym<pir::const>")
  debug_1367:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1947_done
    goto rxscan1947_scan
  rxscan1947_loop:
    (rx1946_pos) = rx1946_cur."from"()
    inc rx1946_pos
    rx1946_cur."!cursor_from"(rx1946_pos)
    ge rx1946_pos, rx1946_eos, rxscan1947_done
  rxscan1947_scan:
    set_addr $I10, rxscan1947_loop
    rx1946_cur."!mark_push"(0, rx1946_pos, $I10)
  rxscan1947_done:
.annotate 'line', 1009
  # rx literal  "pir::const::"
    add $I11, rx1946_pos, 12
    gt $I11, rx1946_eos, rx1946_fail
    sub $I11, rx1946_pos, rx1946_off
    substr $S10, rx1946_tgt, $I11, 12
    ne $S10, "pir::const::", rx1946_fail
    add rx1946_pos, 12
  # rx subcapture "const"
    set_addr $I10, rxcap_1948_fail
    rx1946_cur."!mark_push"(0, rx1946_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1946_pos, rx1946_off
    find_not_cclass $I11, .CCLASS_WORD, rx1946_tgt, $I10, rx1946_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1946_fail
    add rx1946_pos, rx1946_off, $I11
    set_addr $I10, rxcap_1948_fail
    ($I12, $I11) = rx1946_cur."!mark_peek"($I10)
    rx1946_cur."!cursor_pos"($I11)
    ($P10) = rx1946_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1946_pos, "")
    rx1946_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("const")
    goto rxcap_1948_done
  rxcap_1948_fail:
    goto rx1946_fail
  rxcap_1948_done:
.annotate 'line', 1008
  # rx pass
    rx1946_cur."!cursor_pass"(rx1946_pos, "term:sym<pir::const>")
    if_null rx1946_debug, debug_1368
    rx1946_cur."!cursor_debug"("PASS", "term:sym<pir::const>", " at pos=", rx1946_pos)
  debug_1368:
    .return (rx1946_cur)
  rx1946_restart:
.annotate 'line', 462
    if_null rx1946_debug, debug_1369
    rx1946_cur."!cursor_debug"("NEXT", "term:sym<pir::const>")
  debug_1369:
  rx1946_fail:
    (rx1946_rep, rx1946_pos, $I10, $P10) = rx1946_cur."!mark_fail"(0)
    lt rx1946_pos, -1, rx1946_done
    eq rx1946_pos, -1, rx1946_fail
    jump $I10
  rx1946_done:
    rx1946_cur."!cursor_fail"()
    if_null rx1946_debug, debug_1370
    rx1946_cur."!cursor_debug"("FAIL", "term:sym<pir::const>")
  debug_1370:
    .return (rx1946_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::const>"  :subid("263_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "pir::const::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<nqp::op>"  :subid("264_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1951_tgt
    .local int rx1951_pos
    .local int rx1951_off
    .local int rx1951_eos
    .local int rx1951_rep
    .local pmc rx1951_cur
    .local pmc rx1951_debug
    (rx1951_cur, rx1951_pos, rx1951_tgt, $I10) = self."!cursor_start"()
    rx1951_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1951_cur
    .local pmc match
    .lex "$/", match
    length rx1951_eos, rx1951_tgt
    gt rx1951_pos, rx1951_eos, rx1951_done
    set rx1951_off, 0
    lt rx1951_pos, 2, rx1951_start
    sub rx1951_off, rx1951_pos, 1
    substr rx1951_tgt, rx1951_tgt, rx1951_off
  rx1951_start:
    eq $I10, 1, rx1951_restart
    if_null rx1951_debug, debug_1371
    rx1951_cur."!cursor_debug"("START", "term:sym<nqp::op>")
  debug_1371:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1952_done
    goto rxscan1952_scan
  rxscan1952_loop:
    (rx1951_pos) = rx1951_cur."from"()
    inc rx1951_pos
    rx1951_cur."!cursor_from"(rx1951_pos)
    ge rx1951_pos, rx1951_eos, rxscan1952_done
  rxscan1952_scan:
    set_addr $I10, rxscan1952_loop
    rx1951_cur."!mark_push"(0, rx1951_pos, $I10)
  rxscan1952_done:
.annotate 'line', 1013
  # rx literal  "nqp::"
    add $I11, rx1951_pos, 5
    gt $I11, rx1951_eos, rx1951_fail
    sub $I11, rx1951_pos, rx1951_off
    substr $S10, rx1951_tgt, $I11, 5
    ne $S10, "nqp::", rx1951_fail
    add rx1951_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1953_fail
    rx1951_cur."!mark_push"(0, rx1951_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1951_pos, rx1951_off
    find_not_cclass $I11, .CCLASS_WORD, rx1951_tgt, $I10, rx1951_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1951_fail
    add rx1951_pos, rx1951_off, $I11
    set_addr $I10, rxcap_1953_fail
    ($I12, $I11) = rx1951_cur."!mark_peek"($I10)
    rx1951_cur."!cursor_pos"($I11)
    ($P10) = rx1951_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1951_pos, "")
    rx1951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1953_done
  rxcap_1953_fail:
    goto rx1951_fail
  rxcap_1953_done:
  # rx rxquantr1954 ** 0..1
    set_addr $I10, rxquantr1954_done
    rx1951_cur."!mark_push"(0, rx1951_pos, $I10)
  rxquantr1954_loop:
  # rx subrule "args" subtype=capture negate=
    rx1951_cur."!cursor_pos"(rx1951_pos)
    $P10 = rx1951_cur."args"()
    unless $P10, rx1951_fail
    goto rxsubrule1955_pass
  rxsubrule1955_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1951_fail
  rxsubrule1955_pass:
    set_addr $I10, rxsubrule1955_back
    rx1951_cur."!mark_push"(0, rx1951_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1951_pos = $P10."pos"()
    set_addr $I10, rxquantr1954_done
    (rx1951_rep) = rx1951_cur."!mark_commit"($I10)
  rxquantr1954_done:
.annotate 'line', 1012
  # rx pass
    rx1951_cur."!cursor_pass"(rx1951_pos, "term:sym<nqp::op>")
    if_null rx1951_debug, debug_1372
    rx1951_cur."!cursor_debug"("PASS", "term:sym<nqp::op>", " at pos=", rx1951_pos)
  debug_1372:
    .return (rx1951_cur)
  rx1951_restart:
.annotate 'line', 462
    if_null rx1951_debug, debug_1373
    rx1951_cur."!cursor_debug"("NEXT", "term:sym<nqp::op>")
  debug_1373:
  rx1951_fail:
    (rx1951_rep, rx1951_pos, $I10, $P10) = rx1951_cur."!mark_fail"(0)
    lt rx1951_pos, -1, rx1951_done
    eq rx1951_pos, -1, rx1951_fail
    jump $I10
  rx1951_done:
    rx1951_cur."!cursor_fail"()
    if_null rx1951_debug, debug_1374
    rx1951_cur."!cursor_debug"("FAIL", "term:sym<nqp::op>")
  debug_1374:
    .return (rx1951_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<nqp::op>"  :subid("265_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "nqp::"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("266_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P1962 = "267_1325892461.451" 
    capture_lex $P1962
    .local string rx1958_tgt
    .local int rx1958_pos
    .local int rx1958_off
    .local int rx1958_eos
    .local int rx1958_rep
    .local pmc rx1958_cur
    .local pmc rx1958_debug
    (rx1958_cur, rx1958_pos, rx1958_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1958_cur
    .local pmc match
    .lex "$/", match
    length rx1958_eos, rx1958_tgt
    gt rx1958_pos, rx1958_eos, rx1958_done
    set rx1958_off, 0
    lt rx1958_pos, 2, rx1958_start
    sub rx1958_off, rx1958_pos, 1
    substr rx1958_tgt, rx1958_tgt, rx1958_off
  rx1958_start:
    eq $I10, 1, rx1958_restart
    if_null rx1958_debug, debug_1375
    rx1958_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1375:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1959_done
    goto rxscan1959_scan
  rxscan1959_loop:
    (rx1958_pos) = rx1958_cur."from"()
    inc rx1958_pos
    rx1958_cur."!cursor_from"(rx1958_pos)
    ge rx1958_pos, rx1958_eos, rxscan1959_done
  rxscan1959_scan:
    set_addr $I10, rxscan1959_loop
    rx1958_cur."!mark_push"(0, rx1958_pos, $I10)
  rxscan1959_done:
.annotate 'line', 1017
  # rx literal  "{*}"
    add $I11, rx1958_pos, 3
    gt $I11, rx1958_eos, rx1958_fail
    sub $I11, rx1958_pos, rx1958_off
    substr $S10, rx1958_tgt, $I11, 3
    ne $S10, "{*}", rx1958_fail
    add rx1958_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1958_cur."!cursor_pos"(rx1958_pos)
    $P10 = rx1958_cur."ENDSTMT"()
    unless $P10, rx1958_fail
  alt1960_0:
.annotate 'line', 1018
    set_addr $I10, alt1960_1
    rx1958_cur."!mark_push"(0, rx1958_pos, $I10)
    rx1958_cur."!cursor_pos"(rx1958_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P1962 = "267_1325892461.451" 
    capture_lex $P1962
    $P105 = $P1962()
    unless $P105, rx1958_fail
    goto alt1960_end
  alt1960_1:
  # rx subrule "panic" subtype=method negate=
    rx1958_cur."!cursor_pos"(rx1958_pos)
    $P10 = rx1958_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1958_fail
    rx1958_pos = $P10."pos"()
  alt1960_end:
.annotate 'line', 1016
  # rx pass
    rx1958_cur."!cursor_pass"(rx1958_pos, "term:sym<onlystar>")
    if_null rx1958_debug, debug_1378
    rx1958_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1958_pos)
  debug_1378:
    .return (rx1958_cur)
  rx1958_restart:
.annotate 'line', 462
    if_null rx1958_debug, debug_1379
    rx1958_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1379:
  rx1958_fail:
    (rx1958_rep, rx1958_pos, $I10, $P10) = rx1958_cur."!mark_fail"(0)
    lt rx1958_pos, -1, rx1958_done
    eq rx1958_pos, -1, rx1958_fail
    jump $I10
  rx1958_done:
    rx1958_cur."!cursor_fail"()
    if_null rx1958_debug, debug_1380
    rx1958_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1380:
    .return (rx1958_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1961"  :anon :subid("267_1325892461.451") :outer("266_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1018
    find_dynamic_lex $P107, "$*MULTINESS"
    unless_null $P107, vivify_1376
    get_hll_global $P105, "GLOBAL"
    get_who $P106, $P105
    set $P107, $P106["$MULTINESS"]
    unless_null $P107, vivify_1377
    die "Contextual $*MULTINESS not found"
  vivify_1377:
  vivify_1376:
    set $S100, $P107
    iseq $I100, $S100, "proto"
    .return ($I100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("268_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P106, "ResizablePMCArray"
    push $P106, "{*}"
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("269_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1965_tgt
    .local int rx1965_pos
    .local int rx1965_off
    .local int rx1965_eos
    .local int rx1965_rep
    .local pmc rx1965_cur
    .local pmc rx1965_debug
    (rx1965_cur, rx1965_pos, rx1965_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1965_cur
    .local pmc match
    .lex "$/", match
    length rx1965_eos, rx1965_tgt
    gt rx1965_pos, rx1965_eos, rx1965_done
    set rx1965_off, 0
    lt rx1965_pos, 2, rx1965_start
    sub rx1965_off, rx1965_pos, 1
    substr rx1965_tgt, rx1965_tgt, rx1965_off
  rx1965_start:
    eq $I10, 1, rx1965_restart
    if_null rx1965_debug, debug_1381
    rx1965_cur."!cursor_debug"("START", "args")
  debug_1381:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1966_done
    goto rxscan1966_scan
  rxscan1966_loop:
    (rx1965_pos) = rx1965_cur."from"()
    inc rx1965_pos
    rx1965_cur."!cursor_from"(rx1965_pos)
    ge rx1965_pos, rx1965_eos, rxscan1966_done
  rxscan1966_scan:
    set_addr $I10, rxscan1966_loop
    rx1965_cur."!mark_push"(0, rx1965_pos, $I10)
  rxscan1966_done:
.annotate 'line', 1022
  # rx literal  "("
    add $I11, rx1965_pos, 1
    gt $I11, rx1965_eos, rx1965_fail
    sub $I11, rx1965_pos, rx1965_off
    ord $I11, rx1965_tgt, $I11
    ne $I11, 40, rx1965_fail
    add rx1965_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1965_cur."!cursor_pos"(rx1965_pos)
    $P10 = rx1965_cur."arglist"()
    unless $P10, rx1965_fail
    rx1965_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1965_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1965_pos, 1
    gt $I11, rx1965_eos, rx1965_fail
    sub $I11, rx1965_pos, rx1965_off
    ord $I11, rx1965_tgt, $I11
    ne $I11, 41, rx1965_fail
    add rx1965_pos, 1
  # rx pass
    rx1965_cur."!cursor_pass"(rx1965_pos, "args")
    if_null rx1965_debug, debug_1382
    rx1965_cur."!cursor_debug"("PASS", "args", " at pos=", rx1965_pos)
  debug_1382:
    .return (rx1965_cur)
  rx1965_restart:
.annotate 'line', 462
    if_null rx1965_debug, debug_1383
    rx1965_cur."!cursor_debug"("NEXT", "args")
  debug_1383:
  rx1965_fail:
    (rx1965_rep, rx1965_pos, $I10, $P10) = rx1965_cur."!mark_fail"(0)
    lt rx1965_pos, -1, rx1965_done
    eq rx1965_pos, -1, rx1965_fail
    jump $I10
  rx1965_done:
    rx1965_cur."!cursor_fail"()
    if_null rx1965_debug, debug_1384
    rx1965_cur."!cursor_debug"("FAIL", "args")
  debug_1384:
    .return (rx1965_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("270_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("arglist", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("271_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1969_tgt
    .local int rx1969_pos
    .local int rx1969_off
    .local int rx1969_eos
    .local int rx1969_rep
    .local pmc rx1969_cur
    .local pmc rx1969_debug
    (rx1969_cur, rx1969_pos, rx1969_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1969_cur
    .local pmc match
    .lex "$/", match
    length rx1969_eos, rx1969_tgt
    gt rx1969_pos, rx1969_eos, rx1969_done
    set rx1969_off, 0
    lt rx1969_pos, 2, rx1969_start
    sub rx1969_off, rx1969_pos, 1
    substr rx1969_tgt, rx1969_tgt, rx1969_off
  rx1969_start:
    eq $I10, 1, rx1969_restart
    if_null rx1969_debug, debug_1385
    rx1969_cur."!cursor_debug"("START", "arglist")
  debug_1385:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1970_done
    goto rxscan1970_scan
  rxscan1970_loop:
    (rx1969_pos) = rx1969_cur."from"()
    inc rx1969_pos
    rx1969_cur."!cursor_from"(rx1969_pos)
    ge rx1969_pos, rx1969_eos, rxscan1970_done
  rxscan1970_scan:
    set_addr $I10, rxscan1970_loop
    rx1969_cur."!mark_push"(0, rx1969_pos, $I10)
  rxscan1970_done:
.annotate 'line', 1026
  # rx subrule "ws" subtype=method negate=
    rx1969_cur."!cursor_pos"(rx1969_pos)
    $P10 = rx1969_cur."ws"()
    unless $P10, rx1969_fail
    rx1969_pos = $P10."pos"()
  alt1971_0:
.annotate 'line', 1027
    set_addr $I10, alt1971_1
    rx1969_cur."!mark_push"(0, rx1969_pos, $I10)
.annotate 'line', 1028
  # rx subrule "EXPR" subtype=capture negate=
    rx1969_cur."!cursor_pos"(rx1969_pos)
    $P10 = rx1969_cur."EXPR"("f=")
    unless $P10, rx1969_fail
    rx1969_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1969_pos = $P10."pos"()
    goto alt1971_end
  alt1971_1:
  alt1971_end:
.annotate 'line', 1025
  # rx pass
    rx1969_cur."!cursor_pass"(rx1969_pos, "arglist")
    if_null rx1969_debug, debug_1386
    rx1969_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1969_pos)
  debug_1386:
    .return (rx1969_cur)
  rx1969_restart:
.annotate 'line', 462
    if_null rx1969_debug, debug_1387
    rx1969_cur."!cursor_debug"("NEXT", "arglist")
  debug_1387:
  rx1969_fail:
    (rx1969_rep, rx1969_pos, $I10, $P10) = rx1969_cur."!mark_fail"(0)
    lt rx1969_pos, -1, rx1969_done
    eq rx1969_pos, -1, rx1969_fail
    jump $I10
  rx1969_done:
    rx1969_cur."!cursor_fail"()
    if_null rx1969_debug, debug_1388
    rx1969_cur."!cursor_debug"("FAIL", "arglist")
  debug_1388:
    .return (rx1969_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("272_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("273_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1974_tgt
    .local int rx1974_pos
    .local int rx1974_off
    .local int rx1974_eos
    .local int rx1974_rep
    .local pmc rx1974_cur
    .local pmc rx1974_debug
    (rx1974_cur, rx1974_pos, rx1974_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1974_cur
    .local pmc match
    .lex "$/", match
    length rx1974_eos, rx1974_tgt
    gt rx1974_pos, rx1974_eos, rx1974_done
    set rx1974_off, 0
    lt rx1974_pos, 2, rx1974_start
    sub rx1974_off, rx1974_pos, 1
    substr rx1974_tgt, rx1974_tgt, rx1974_off
  rx1974_start:
    eq $I10, 1, rx1974_restart
    if_null rx1974_debug, debug_1389
    rx1974_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1389:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1975_done
    goto rxscan1975_scan
  rxscan1975_loop:
    (rx1974_pos) = rx1974_cur."from"()
    inc rx1974_pos
    rx1974_cur."!cursor_from"(rx1974_pos)
    ge rx1974_pos, rx1974_eos, rxscan1975_done
  rxscan1975_scan:
    set_addr $I10, rxscan1975_loop
    rx1974_cur."!mark_push"(0, rx1974_pos, $I10)
  rxscan1975_done:
.annotate 'line', 1034
  # rx subrule "value" subtype=capture negate=
    rx1974_cur."!cursor_pos"(rx1974_pos)
    $P10 = rx1974_cur."value"()
    unless $P10, rx1974_fail
    rx1974_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1974_pos = $P10."pos"()
  # rx pass
    rx1974_cur."!cursor_pass"(rx1974_pos, "term:sym<value>")
    if_null rx1974_debug, debug_1390
    rx1974_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1974_pos)
  debug_1390:
    .return (rx1974_cur)
  rx1974_restart:
.annotate 'line', 462
    if_null rx1974_debug, debug_1391
    rx1974_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1391:
  rx1974_fail:
    (rx1974_rep, rx1974_pos, $I10, $P10) = rx1974_cur."!mark_fail"(0)
    lt rx1974_pos, -1, rx1974_done
    eq rx1974_pos, -1, rx1974_fail
    jump $I10
  rx1974_done:
    rx1974_cur."!cursor_fail"()
    if_null rx1974_debug, debug_1392
    rx1974_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1392:
    .return (rx1974_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("274_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("value", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("275_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1978_tgt
    .local int rx1978_pos
    .local int rx1978_off
    .local int rx1978_eos
    .local int rx1978_rep
    .local pmc rx1978_cur
    .local pmc rx1978_debug
    (rx1978_cur, rx1978_pos, rx1978_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1978_cur
    .local pmc match
    .lex "$/", match
    length rx1978_eos, rx1978_tgt
    gt rx1978_pos, rx1978_eos, rx1978_done
    set rx1978_off, 0
    lt rx1978_pos, 2, rx1978_start
    sub rx1978_off, rx1978_pos, 1
    substr rx1978_tgt, rx1978_tgt, rx1978_off
  rx1978_start:
    eq $I10, 1, rx1978_restart
    if_null rx1978_debug, debug_1393
    rx1978_cur."!cursor_debug"("START", "value")
  debug_1393:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1979_done
    goto rxscan1979_scan
  rxscan1979_loop:
    (rx1978_pos) = rx1978_cur."from"()
    inc rx1978_pos
    rx1978_cur."!cursor_from"(rx1978_pos)
    ge rx1978_pos, rx1978_eos, rxscan1979_done
  rxscan1979_scan:
    set_addr $I10, rxscan1979_loop
    rx1978_cur."!mark_push"(0, rx1978_pos, $I10)
  rxscan1979_done:
  alt1980_0:
.annotate 'line', 1036
    set_addr $I10, alt1980_1
    rx1978_cur."!mark_push"(0, rx1978_pos, $I10)
.annotate 'line', 1037
  # rx subrule "quote" subtype=capture negate=
    rx1978_cur."!cursor_pos"(rx1978_pos)
    $P10 = rx1978_cur."quote"()
    unless $P10, rx1978_fail
    rx1978_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1978_pos = $P10."pos"()
    goto alt1980_end
  alt1980_1:
.annotate 'line', 1038
  # rx subrule "number" subtype=capture negate=
    rx1978_cur."!cursor_pos"(rx1978_pos)
    $P10 = rx1978_cur."number"()
    unless $P10, rx1978_fail
    rx1978_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1978_pos = $P10."pos"()
  alt1980_end:
.annotate 'line', 1036
  # rx pass
    rx1978_cur."!cursor_pass"(rx1978_pos, "value")
    if_null rx1978_debug, debug_1394
    rx1978_cur."!cursor_debug"("PASS", "value", " at pos=", rx1978_pos)
  debug_1394:
    .return (rx1978_cur)
  rx1978_restart:
.annotate 'line', 462
    if_null rx1978_debug, debug_1395
    rx1978_cur."!cursor_debug"("NEXT", "value")
  debug_1395:
  rx1978_fail:
    (rx1978_rep, rx1978_pos, $I10, $P10) = rx1978_cur."!mark_fail"(0)
    lt rx1978_pos, -1, rx1978_done
    eq rx1978_pos, -1, rx1978_fail
    jump $I10
  rx1978_done:
    rx1978_cur."!cursor_fail"()
    if_null rx1978_debug, debug_1396
    rx1978_cur."!cursor_debug"("FAIL", "value")
  debug_1396:
    .return (rx1978_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("276_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("number", "")
    $P104 = self."!PREFIX__!subrule"("quote", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P103
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("277_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1983_tgt
    .local int rx1983_pos
    .local int rx1983_off
    .local int rx1983_eos
    .local int rx1983_rep
    .local pmc rx1983_cur
    .local pmc rx1983_debug
    (rx1983_cur, rx1983_pos, rx1983_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1983_cur
    .local pmc match
    .lex "$/", match
    length rx1983_eos, rx1983_tgt
    gt rx1983_pos, rx1983_eos, rx1983_done
    set rx1983_off, 0
    lt rx1983_pos, 2, rx1983_start
    sub rx1983_off, rx1983_pos, 1
    substr rx1983_tgt, rx1983_tgt, rx1983_off
  rx1983_start:
    eq $I10, 1, rx1983_restart
    if_null rx1983_debug, debug_1397
    rx1983_cur."!cursor_debug"("START", "number")
  debug_1397:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1984_done
    goto rxscan1984_scan
  rxscan1984_loop:
    (rx1983_pos) = rx1983_cur."from"()
    inc rx1983_pos
    rx1983_cur."!cursor_from"(rx1983_pos)
    ge rx1983_pos, rx1983_eos, rxscan1984_done
  rxscan1984_scan:
    set_addr $I10, rxscan1984_loop
    rx1983_cur."!mark_push"(0, rx1983_pos, $I10)
  rxscan1984_done:
.annotate 'line', 1042
  # rx subcapture "sign"
    set_addr $I10, rxcap_1986_fail
    rx1983_cur."!mark_push"(0, rx1983_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1983_pos, rx1983_off
    set rx1983_rep, 0
    sub $I12, rx1983_eos, rx1983_pos
    le $I12, 1, rxenumcharlistq1985_loop
    set $I12, 1
  rxenumcharlistq1985_loop:
    le $I12, 0, rxenumcharlistq1985_done
    substr $S10, rx1983_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1985_done
    inc rx1983_rep
  rxenumcharlistq1985_done:
    add rx1983_pos, rx1983_pos, rx1983_rep
    set_addr $I10, rxcap_1986_fail
    ($I12, $I11) = rx1983_cur."!mark_peek"($I10)
    rx1983_cur."!cursor_pos"($I11)
    ($P10) = rx1983_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1983_pos, "")
    rx1983_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1986_done
  rxcap_1986_fail:
    goto rx1983_fail
  rxcap_1986_done:
  alt1987_0:
.annotate 'line', 1043
    set_addr $I10, alt1987_1
    rx1983_cur."!mark_push"(0, rx1983_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1983_cur."!cursor_pos"(rx1983_pos)
    $P10 = rx1983_cur."dec_number"()
    unless $P10, rx1983_fail
    rx1983_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1983_pos = $P10."pos"()
    goto alt1987_end
  alt1987_1:
  # rx subrule "integer" subtype=capture negate=
    rx1983_cur."!cursor_pos"(rx1983_pos)
    $P10 = rx1983_cur."integer"()
    unless $P10, rx1983_fail
    rx1983_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1983_pos = $P10."pos"()
  alt1987_end:
.annotate 'line', 1041
  # rx pass
    rx1983_cur."!cursor_pass"(rx1983_pos, "number")
    if_null rx1983_debug, debug_1398
    rx1983_cur."!cursor_debug"("PASS", "number", " at pos=", rx1983_pos)
  debug_1398:
    .return (rx1983_cur)
  rx1983_restart:
.annotate 'line', 462
    if_null rx1983_debug, debug_1399
    rx1983_cur."!cursor_debug"("NEXT", "number")
  debug_1399:
  rx1983_fail:
    (rx1983_rep, rx1983_pos, $I10, $P10) = rx1983_cur."!mark_fail"(0)
    lt rx1983_pos, -1, rx1983_done
    eq rx1983_pos, -1, rx1983_fail
    jump $I10
  rx1983_done:
    rx1983_cur."!cursor_fail"()
    if_null rx1983_debug, debug_1400
    rx1983_cur."!cursor_debug"("FAIL", "number")
  debug_1400:
    .return (rx1983_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("278_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("279_1325892461.451")
    .param pmc param_1990
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1046
    .lex "self", param_1990
    $P103 = param_1990."!protoregex"("quote")
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("280_1325892461.451")
    .param pmc param_1992
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1046
    .lex "self", param_1992
    $P104 = param_1992."!PREFIX__!protoregex"("quote")
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("281_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1994_tgt
    .local int rx1994_pos
    .local int rx1994_off
    .local int rx1994_eos
    .local int rx1994_rep
    .local pmc rx1994_cur
    .local pmc rx1994_debug
    (rx1994_cur, rx1994_pos, rx1994_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1994_cur
    .local pmc match
    .lex "$/", match
    length rx1994_eos, rx1994_tgt
    gt rx1994_pos, rx1994_eos, rx1994_done
    set rx1994_off, 0
    lt rx1994_pos, 2, rx1994_start
    sub rx1994_off, rx1994_pos, 1
    substr rx1994_tgt, rx1994_tgt, rx1994_off
  rx1994_start:
    eq $I10, 1, rx1994_restart
    if_null rx1994_debug, debug_1401
    rx1994_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1401:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1995_done
    goto rxscan1995_scan
  rxscan1995_loop:
    (rx1994_pos) = rx1994_cur."from"()
    inc rx1994_pos
    rx1994_cur."!cursor_from"(rx1994_pos)
    ge rx1994_pos, rx1994_eos, rxscan1995_done
  rxscan1995_scan:
    set_addr $I10, rxscan1995_loop
    rx1994_cur."!mark_push"(0, rx1994_pos, $I10)
  rxscan1995_done:
.annotate 'line', 1047
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1994_pos, rx1994_off
    substr $S10, rx1994_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1994_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1994_cur."!cursor_pos"(rx1994_pos)
    $P10 = rx1994_cur."quote_EXPR"(":q")
    unless $P10, rx1994_fail
    rx1994_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1994_pos = $P10."pos"()
  # rx pass
    rx1994_cur."!cursor_pass"(rx1994_pos, "quote:sym<apos>")
    if_null rx1994_debug, debug_1402
    rx1994_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1994_pos)
  debug_1402:
    .return (rx1994_cur)
  rx1994_restart:
.annotate 'line', 462
    if_null rx1994_debug, debug_1403
    rx1994_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1403:
  rx1994_fail:
    (rx1994_rep, rx1994_pos, $I10, $P10) = rx1994_cur."!mark_fail"(0)
    lt rx1994_pos, -1, rx1994_done
    eq rx1994_pos, -1, rx1994_fail
    jump $I10
  rx1994_done:
    rx1994_cur."!cursor_fail"()
    if_null rx1994_debug, debug_1404
    rx1994_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1404:
    .return (rx1994_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("282_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "'"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("283_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx1998_tgt
    .local int rx1998_pos
    .local int rx1998_off
    .local int rx1998_eos
    .local int rx1998_rep
    .local pmc rx1998_cur
    .local pmc rx1998_debug
    (rx1998_cur, rx1998_pos, rx1998_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1998_cur
    .local pmc match
    .lex "$/", match
    length rx1998_eos, rx1998_tgt
    gt rx1998_pos, rx1998_eos, rx1998_done
    set rx1998_off, 0
    lt rx1998_pos, 2, rx1998_start
    sub rx1998_off, rx1998_pos, 1
    substr rx1998_tgt, rx1998_tgt, rx1998_off
  rx1998_start:
    eq $I10, 1, rx1998_restart
    if_null rx1998_debug, debug_1405
    rx1998_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1405:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1999_done
    goto rxscan1999_scan
  rxscan1999_loop:
    (rx1998_pos) = rx1998_cur."from"()
    inc rx1998_pos
    rx1998_cur."!cursor_from"(rx1998_pos)
    ge rx1998_pos, rx1998_eos, rxscan1999_done
  rxscan1999_scan:
    set_addr $I10, rxscan1999_loop
    rx1998_cur."!mark_push"(0, rx1998_pos, $I10)
  rxscan1999_done:
.annotate 'line', 1048
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1998_pos, rx1998_off
    substr $S10, rx1998_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1998_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1998_cur."!cursor_pos"(rx1998_pos)
    $P10 = rx1998_cur."quote_EXPR"(":qq")
    unless $P10, rx1998_fail
    rx1998_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1998_pos = $P10."pos"()
  # rx pass
    rx1998_cur."!cursor_pass"(rx1998_pos, "quote:sym<dblq>")
    if_null rx1998_debug, debug_1406
    rx1998_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1998_pos)
  debug_1406:
    .return (rx1998_cur)
  rx1998_restart:
.annotate 'line', 462
    if_null rx1998_debug, debug_1407
    rx1998_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1407:
  rx1998_fail:
    (rx1998_rep, rx1998_pos, $I10, $P10) = rx1998_cur."!mark_fail"(0)
    lt rx1998_pos, -1, rx1998_done
    eq rx1998_pos, -1, rx1998_fail
    jump $I10
  rx1998_done:
    rx1998_cur."!cursor_fail"()
    if_null rx1998_debug, debug_1408
    rx1998_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1408:
    .return (rx1998_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("284_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "\""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("285_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2002_tgt
    .local int rx2002_pos
    .local int rx2002_off
    .local int rx2002_eos
    .local int rx2002_rep
    .local pmc rx2002_cur
    .local pmc rx2002_debug
    (rx2002_cur, rx2002_pos, rx2002_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2002_cur
    .local pmc match
    .lex "$/", match
    length rx2002_eos, rx2002_tgt
    gt rx2002_pos, rx2002_eos, rx2002_done
    set rx2002_off, 0
    lt rx2002_pos, 2, rx2002_start
    sub rx2002_off, rx2002_pos, 1
    substr rx2002_tgt, rx2002_tgt, rx2002_off
  rx2002_start:
    eq $I10, 1, rx2002_restart
    if_null rx2002_debug, debug_1409
    rx2002_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1409:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2003_done
    goto rxscan2003_scan
  rxscan2003_loop:
    (rx2002_pos) = rx2002_cur."from"()
    inc rx2002_pos
    rx2002_cur."!cursor_from"(rx2002_pos)
    ge rx2002_pos, rx2002_eos, rxscan2003_done
  rxscan2003_scan:
    set_addr $I10, rxscan2003_loop
    rx2002_cur."!mark_push"(0, rx2002_pos, $I10)
  rxscan2003_done:
.annotate 'line', 1049
  # rx subcapture "sym"
    set_addr $I10, rxcap_2004_fail
    rx2002_cur."!mark_push"(0, rx2002_pos, $I10)
  # rx literal  "q"
    add $I11, rx2002_pos, 1
    gt $I11, rx2002_eos, rx2002_fail
    sub $I11, rx2002_pos, rx2002_off
    ord $I11, rx2002_tgt, $I11
    ne $I11, 113, rx2002_fail
    add rx2002_pos, 1
    set_addr $I10, rxcap_2004_fail
    ($I12, $I11) = rx2002_cur."!mark_peek"($I10)
    rx2002_cur."!cursor_pos"($I11)
    ($P10) = rx2002_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2002_pos, "")
    rx2002_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2004_done
  rxcap_2004_fail:
    goto rx2002_fail
  rxcap_2004_done:
  # rxanchor rwb
    le rx2002_pos, 0, rx2002_fail
    sub $I10, rx2002_pos, rx2002_off
    is_cclass $I11, .CCLASS_WORD, rx2002_tgt, $I10
    if $I11, rx2002_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx2002_tgt, $I10
    unless $I11, rx2002_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2002_pos, rx2002_off
    substr $S10, rx2002_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2002_fail
  # rx subrule "ws" subtype=method negate=
    rx2002_cur."!cursor_pos"(rx2002_pos)
    $P10 = rx2002_cur."ws"()
    unless $P10, rx2002_fail
    rx2002_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2002_cur."!cursor_pos"(rx2002_pos)
    $P10 = rx2002_cur."quote_EXPR"(":q")
    unless $P10, rx2002_fail
    rx2002_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2002_pos = $P10."pos"()
  # rx pass
    rx2002_cur."!cursor_pass"(rx2002_pos, "quote:sym<q>")
    if_null rx2002_debug, debug_1410
    rx2002_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx2002_pos)
  debug_1410:
    .return (rx2002_cur)
  rx2002_restart:
.annotate 'line', 462
    if_null rx2002_debug, debug_1411
    rx2002_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1411:
  rx2002_fail:
    (rx2002_rep, rx2002_pos, $I10, $P10) = rx2002_cur."!mark_fail"(0)
    lt rx2002_pos, -1, rx2002_done
    eq rx2002_pos, -1, rx2002_fail
    jump $I10
  rx2002_done:
    rx2002_cur."!cursor_fail"()
    if_null rx2002_debug, debug_1412
    rx2002_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1412:
    .return (rx2002_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("286_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "q")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("287_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2007_tgt
    .local int rx2007_pos
    .local int rx2007_off
    .local int rx2007_eos
    .local int rx2007_rep
    .local pmc rx2007_cur
    .local pmc rx2007_debug
    (rx2007_cur, rx2007_pos, rx2007_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2007_cur
    .local pmc match
    .lex "$/", match
    length rx2007_eos, rx2007_tgt
    gt rx2007_pos, rx2007_eos, rx2007_done
    set rx2007_off, 0
    lt rx2007_pos, 2, rx2007_start
    sub rx2007_off, rx2007_pos, 1
    substr rx2007_tgt, rx2007_tgt, rx2007_off
  rx2007_start:
    eq $I10, 1, rx2007_restart
    if_null rx2007_debug, debug_1413
    rx2007_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1413:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2008_done
    goto rxscan2008_scan
  rxscan2008_loop:
    (rx2007_pos) = rx2007_cur."from"()
    inc rx2007_pos
    rx2007_cur."!cursor_from"(rx2007_pos)
    ge rx2007_pos, rx2007_eos, rxscan2008_done
  rxscan2008_scan:
    set_addr $I10, rxscan2008_loop
    rx2007_cur."!mark_push"(0, rx2007_pos, $I10)
  rxscan2008_done:
.annotate 'line', 1050
  # rx subcapture "sym"
    set_addr $I10, rxcap_2009_fail
    rx2007_cur."!mark_push"(0, rx2007_pos, $I10)
  # rx literal  "qq"
    add $I11, rx2007_pos, 2
    gt $I11, rx2007_eos, rx2007_fail
    sub $I11, rx2007_pos, rx2007_off
    substr $S10, rx2007_tgt, $I11, 2
    ne $S10, "qq", rx2007_fail
    add rx2007_pos, 2
    set_addr $I10, rxcap_2009_fail
    ($I12, $I11) = rx2007_cur."!mark_peek"($I10)
    rx2007_cur."!cursor_pos"($I11)
    ($P10) = rx2007_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2007_pos, "")
    rx2007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2009_done
  rxcap_2009_fail:
    goto rx2007_fail
  rxcap_2009_done:
  # rxanchor rwb
    le rx2007_pos, 0, rx2007_fail
    sub $I10, rx2007_pos, rx2007_off
    is_cclass $I11, .CCLASS_WORD, rx2007_tgt, $I10
    if $I11, rx2007_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx2007_tgt, $I10
    unless $I11, rx2007_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2007_pos, rx2007_off
    substr $S10, rx2007_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2007_fail
  # rx subrule "ws" subtype=method negate=
    rx2007_cur."!cursor_pos"(rx2007_pos)
    $P10 = rx2007_cur."ws"()
    unless $P10, rx2007_fail
    rx2007_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2007_cur."!cursor_pos"(rx2007_pos)
    $P10 = rx2007_cur."quote_EXPR"(":qq")
    unless $P10, rx2007_fail
    rx2007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2007_pos = $P10."pos"()
  # rx pass
    rx2007_cur."!cursor_pass"(rx2007_pos, "quote:sym<qq>")
    if_null rx2007_debug, debug_1414
    rx2007_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx2007_pos)
  debug_1414:
    .return (rx2007_cur)
  rx2007_restart:
.annotate 'line', 462
    if_null rx2007_debug, debug_1415
    rx2007_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1415:
  rx2007_fail:
    (rx2007_rep, rx2007_pos, $I10, $P10) = rx2007_cur."!mark_fail"(0)
    lt rx2007_pos, -1, rx2007_done
    eq rx2007_pos, -1, rx2007_fail
    jump $I10
  rx2007_done:
    rx2007_cur."!cursor_fail"()
    if_null rx2007_debug, debug_1416
    rx2007_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1416:
    .return (rx2007_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("288_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "qq")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("289_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2012_tgt
    .local int rx2012_pos
    .local int rx2012_off
    .local int rx2012_eos
    .local int rx2012_rep
    .local pmc rx2012_cur
    .local pmc rx2012_debug
    (rx2012_cur, rx2012_pos, rx2012_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2012_cur
    .local pmc match
    .lex "$/", match
    length rx2012_eos, rx2012_tgt
    gt rx2012_pos, rx2012_eos, rx2012_done
    set rx2012_off, 0
    lt rx2012_pos, 2, rx2012_start
    sub rx2012_off, rx2012_pos, 1
    substr rx2012_tgt, rx2012_tgt, rx2012_off
  rx2012_start:
    eq $I10, 1, rx2012_restart
    if_null rx2012_debug, debug_1417
    rx2012_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1417:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2013_done
    goto rxscan2013_scan
  rxscan2013_loop:
    (rx2012_pos) = rx2012_cur."from"()
    inc rx2012_pos
    rx2012_cur."!cursor_from"(rx2012_pos)
    ge rx2012_pos, rx2012_eos, rxscan2013_done
  rxscan2013_scan:
    set_addr $I10, rxscan2013_loop
    rx2012_cur."!mark_push"(0, rx2012_pos, $I10)
  rxscan2013_done:
.annotate 'line', 1051
  # rx subcapture "sym"
    set_addr $I10, rxcap_2014_fail
    rx2012_cur."!mark_push"(0, rx2012_pos, $I10)
  # rx literal  "Q"
    add $I11, rx2012_pos, 1
    gt $I11, rx2012_eos, rx2012_fail
    sub $I11, rx2012_pos, rx2012_off
    ord $I11, rx2012_tgt, $I11
    ne $I11, 81, rx2012_fail
    add rx2012_pos, 1
    set_addr $I10, rxcap_2014_fail
    ($I12, $I11) = rx2012_cur."!mark_peek"($I10)
    rx2012_cur."!cursor_pos"($I11)
    ($P10) = rx2012_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2012_pos, "")
    rx2012_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2014_done
  rxcap_2014_fail:
    goto rx2012_fail
  rxcap_2014_done:
  # rxanchor rwb
    le rx2012_pos, 0, rx2012_fail
    sub $I10, rx2012_pos, rx2012_off
    is_cclass $I11, .CCLASS_WORD, rx2012_tgt, $I10
    if $I11, rx2012_fail
    dec $I10
    is_cclass $I11, .CCLASS_WORD, rx2012_tgt, $I10
    unless $I11, rx2012_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2012_pos, rx2012_off
    substr $S10, rx2012_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx2012_fail
  # rx subrule "ws" subtype=method negate=
    rx2012_cur."!cursor_pos"(rx2012_pos)
    $P10 = rx2012_cur."ws"()
    unless $P10, rx2012_fail
    rx2012_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2012_cur."!cursor_pos"(rx2012_pos)
    $P10 = rx2012_cur."quote_EXPR"()
    unless $P10, rx2012_fail
    rx2012_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2012_pos = $P10."pos"()
  # rx pass
    rx2012_cur."!cursor_pass"(rx2012_pos, "quote:sym<Q>")
    if_null rx2012_debug, debug_1418
    rx2012_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx2012_pos)
  debug_1418:
    .return (rx2012_cur)
  rx2012_restart:
.annotate 'line', 462
    if_null rx2012_debug, debug_1419
    rx2012_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1419:
  rx2012_fail:
    (rx2012_rep, rx2012_pos, $I10, $P10) = rx2012_cur."!mark_fail"(0)
    lt rx2012_pos, -1, rx2012_done
    eq rx2012_pos, -1, rx2012_fail
    jump $I10
  rx2012_done:
    rx2012_cur."!cursor_fail"()
    if_null rx2012_debug, debug_1420
    rx2012_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1420:
    .return (rx2012_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("290_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "Q")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("291_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2017_tgt
    .local int rx2017_pos
    .local int rx2017_off
    .local int rx2017_eos
    .local int rx2017_rep
    .local pmc rx2017_cur
    .local pmc rx2017_debug
    (rx2017_cur, rx2017_pos, rx2017_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2017_cur
    .local pmc match
    .lex "$/", match
    length rx2017_eos, rx2017_tgt
    gt rx2017_pos, rx2017_eos, rx2017_done
    set rx2017_off, 0
    lt rx2017_pos, 2, rx2017_start
    sub rx2017_off, rx2017_pos, 1
    substr rx2017_tgt, rx2017_tgt, rx2017_off
  rx2017_start:
    eq $I10, 1, rx2017_restart
    if_null rx2017_debug, debug_1421
    rx2017_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1421:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2018_done
    goto rxscan2018_scan
  rxscan2018_loop:
    (rx2017_pos) = rx2017_cur."from"()
    inc rx2017_pos
    rx2017_cur."!cursor_from"(rx2017_pos)
    ge rx2017_pos, rx2017_eos, rxscan2018_done
  rxscan2018_scan:
    set_addr $I10, rxscan2018_loop
    rx2017_cur."!mark_push"(0, rx2017_pos, $I10)
  rxscan2018_done:
.annotate 'line', 1052
  # rx subcapture "sym"
    set_addr $I10, rxcap_2019_fail
    rx2017_cur."!mark_push"(0, rx2017_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx2017_pos, 5
    gt $I11, rx2017_eos, rx2017_fail
    sub $I11, rx2017_pos, rx2017_off
    substr $S10, rx2017_tgt, $I11, 5
    ne $S10, "Q:PIR", rx2017_fail
    add rx2017_pos, 5
    set_addr $I10, rxcap_2019_fail
    ($I12, $I11) = rx2017_cur."!mark_peek"($I10)
    rx2017_cur."!cursor_pos"($I11)
    ($P10) = rx2017_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2017_pos, "")
    rx2017_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2019_done
  rxcap_2019_fail:
    goto rx2017_fail
  rxcap_2019_done:
  # rx subrule "ws" subtype=method negate=
    rx2017_cur."!cursor_pos"(rx2017_pos)
    $P10 = rx2017_cur."ws"()
    unless $P10, rx2017_fail
    rx2017_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2017_cur."!cursor_pos"(rx2017_pos)
    $P10 = rx2017_cur."quote_EXPR"()
    unless $P10, rx2017_fail
    rx2017_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2017_pos = $P10."pos"()
  # rx pass
    rx2017_cur."!cursor_pass"(rx2017_pos, "quote:sym<Q:PIR>")
    if_null rx2017_debug, debug_1422
    rx2017_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx2017_pos)
  debug_1422:
    .return (rx2017_cur)
  rx2017_restart:
.annotate 'line', 462
    if_null rx2017_debug, debug_1423
    rx2017_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1423:
  rx2017_fail:
    (rx2017_rep, rx2017_pos, $I10, $P10) = rx2017_cur."!mark_fail"(0)
    lt rx2017_pos, -1, rx2017_done
    eq rx2017_pos, -1, rx2017_fail
    jump $I10
  rx2017_done:
    rx2017_cur."!cursor_fail"()
    if_null rx2017_debug, debug_1424
    rx2017_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1424:
    .return (rx2017_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("292_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("293_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2022_tgt
    .local int rx2022_pos
    .local int rx2022_off
    .local int rx2022_eos
    .local int rx2022_rep
    .local pmc rx2022_cur
    .local pmc rx2022_debug
    (rx2022_cur, rx2022_pos, rx2022_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2022_cur
    .local pmc match
    .lex "$/", match
    length rx2022_eos, rx2022_tgt
    gt rx2022_pos, rx2022_eos, rx2022_done
    set rx2022_off, 0
    lt rx2022_pos, 2, rx2022_start
    sub rx2022_off, rx2022_pos, 1
    substr rx2022_tgt, rx2022_tgt, rx2022_off
  rx2022_start:
    eq $I10, 1, rx2022_restart
    if_null rx2022_debug, debug_1425
    rx2022_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1425:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2023_done
    goto rxscan2023_scan
  rxscan2023_loop:
    (rx2022_pos) = rx2022_cur."from"()
    inc rx2022_pos
    rx2022_cur."!cursor_from"(rx2022_pos)
    ge rx2022_pos, rx2022_eos, rxscan2023_done
  rxscan2023_scan:
    set_addr $I10, rxscan2023_loop
    rx2022_cur."!mark_push"(0, rx2022_pos, $I10)
  rxscan2023_done:
.annotate 'line', 1054
  # rx literal  "/"
    add $I11, rx2022_pos, 1
    gt $I11, rx2022_eos, rx2022_fail
    sub $I11, rx2022_pos, rx2022_off
    ord $I11, rx2022_tgt, $I11
    ne $I11, 47, rx2022_fail
    add rx2022_pos, 1
.annotate 'line', 1055
  # rx subrule "newpad" subtype=method negate=
    rx2022_cur."!cursor_pos"(rx2022_pos)
    $P10 = rx2022_cur."newpad"()
    unless $P10, rx2022_fail
    rx2022_pos = $P10."pos"()
.annotate 'line', 1056
  # rx reduce name="quote:sym</ />" key="open"
    rx2022_cur."!cursor_pos"(rx2022_pos)
    rx2022_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 1057
  # rx subrule "LANG" subtype=capture negate=
    rx2022_cur."!cursor_pos"(rx2022_pos)
    $P10 = rx2022_cur."LANG"("Regex", "nibbler")
    unless $P10, rx2022_fail
    rx2022_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx2022_pos = $P10."pos"()
.annotate 'line', 1058
  # rx literal  "/"
    add $I11, rx2022_pos, 1
    gt $I11, rx2022_eos, rx2022_fail
    sub $I11, rx2022_pos, rx2022_off
    ord $I11, rx2022_tgt, $I11
    ne $I11, 47, rx2022_fail
    add rx2022_pos, 1
.annotate 'line', 1053
  # rx pass
    rx2022_cur."!cursor_pass"(rx2022_pos, "quote:sym</ />")
    if_null rx2022_debug, debug_1426
    rx2022_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx2022_pos)
  debug_1426:
    .return (rx2022_cur)
  rx2022_restart:
.annotate 'line', 462
    if_null rx2022_debug, debug_1427
    rx2022_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1427:
  rx2022_fail:
    (rx2022_rep, rx2022_pos, $I10, $P10) = rx2022_cur."!mark_fail"(0)
    lt rx2022_pos, -1, rx2022_done
    eq rx2022_pos, -1, rx2022_fail
    jump $I10
  rx2022_done:
    rx2022_cur."!cursor_fail"()
    if_null rx2022_debug, debug_1428
    rx2022_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1428:
    .return (rx2022_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("294_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("newpad", "/")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("295_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2026_tgt
    .local int rx2026_pos
    .local int rx2026_off
    .local int rx2026_eos
    .local int rx2026_rep
    .local pmc rx2026_cur
    .local pmc rx2026_debug
    (rx2026_cur, rx2026_pos, rx2026_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2026_cur
    .local pmc match
    .lex "$/", match
    length rx2026_eos, rx2026_tgt
    gt rx2026_pos, rx2026_eos, rx2026_done
    set rx2026_off, 0
    lt rx2026_pos, 2, rx2026_start
    sub rx2026_off, rx2026_pos, 1
    substr rx2026_tgt, rx2026_tgt, rx2026_off
  rx2026_start:
    eq $I10, 1, rx2026_restart
    if_null rx2026_debug, debug_1429
    rx2026_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1429:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2027_done
    goto rxscan2027_scan
  rxscan2027_loop:
    (rx2026_pos) = rx2026_cur."from"()
    inc rx2026_pos
    rx2026_cur."!cursor_from"(rx2026_pos)
    ge rx2026_pos, rx2026_eos, rxscan2027_done
  rxscan2027_scan:
    set_addr $I10, rxscan2027_loop
    rx2026_cur."!mark_push"(0, rx2026_pos, $I10)
  rxscan2027_done:
.annotate 'line', 1061
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2026_pos, rx2026_off
    substr $S10, rx2026_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx2026_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2026_cur."!cursor_pos"(rx2026_pos)
    $P10 = rx2026_cur."quotemod_check"("s")
    unless $P10, rx2026_fail
  # rx subrule "variable" subtype=capture negate=
    rx2026_cur."!cursor_pos"(rx2026_pos)
    $P10 = rx2026_cur."variable"()
    unless $P10, rx2026_fail
    rx2026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx2026_pos = $P10."pos"()
  # rx pass
    rx2026_cur."!cursor_pass"(rx2026_pos, "quote_escape:sym<$>")
    if_null rx2026_debug, debug_1430
    rx2026_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx2026_pos)
  debug_1430:
    .return (rx2026_cur)
  rx2026_restart:
.annotate 'line', 462
    if_null rx2026_debug, debug_1431
    rx2026_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1431:
  rx2026_fail:
    (rx2026_rep, rx2026_pos, $I10, $P10) = rx2026_cur."!mark_fail"(0)
    lt rx2026_pos, -1, rx2026_done
    eq rx2026_pos, -1, rx2026_fail
    jump $I10
  rx2026_done:
    rx2026_cur."!cursor_fail"()
    if_null rx2026_debug, debug_1432
    rx2026_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1432:
    .return (rx2026_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("296_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("297_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2030_tgt
    .local int rx2030_pos
    .local int rx2030_off
    .local int rx2030_eos
    .local int rx2030_rep
    .local pmc rx2030_cur
    .local pmc rx2030_debug
    (rx2030_cur, rx2030_pos, rx2030_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2030_cur
    .local pmc match
    .lex "$/", match
    length rx2030_eos, rx2030_tgt
    gt rx2030_pos, rx2030_eos, rx2030_done
    set rx2030_off, 0
    lt rx2030_pos, 2, rx2030_start
    sub rx2030_off, rx2030_pos, 1
    substr rx2030_tgt, rx2030_tgt, rx2030_off
  rx2030_start:
    eq $I10, 1, rx2030_restart
    if_null rx2030_debug, debug_1433
    rx2030_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1433:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2031_done
    goto rxscan2031_scan
  rxscan2031_loop:
    (rx2030_pos) = rx2030_cur."from"()
    inc rx2030_pos
    rx2030_cur."!cursor_from"(rx2030_pos)
    ge rx2030_pos, rx2030_eos, rxscan2031_done
  rxscan2031_scan:
    set_addr $I10, rxscan2031_loop
    rx2030_cur."!mark_push"(0, rx2030_pos, $I10)
  rxscan2031_done:
.annotate 'line', 1062
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2030_pos, rx2030_off
    substr $S10, rx2030_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2030_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2030_cur."!cursor_pos"(rx2030_pos)
    $P10 = rx2030_cur."quotemod_check"("c")
    unless $P10, rx2030_fail
  # rx subrule "block" subtype=capture negate=
    rx2030_cur."!cursor_pos"(rx2030_pos)
    $P10 = rx2030_cur."block"()
    unless $P10, rx2030_fail
    rx2030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2030_pos = $P10."pos"()
  # rx pass
    rx2030_cur."!cursor_pass"(rx2030_pos, "quote_escape:sym<{ }>")
    if_null rx2030_debug, debug_1434
    rx2030_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx2030_pos)
  debug_1434:
    .return (rx2030_cur)
  rx2030_restart:
.annotate 'line', 462
    if_null rx2030_debug, debug_1435
    rx2030_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1435:
  rx2030_fail:
    (rx2030_rep, rx2030_pos, $I10, $P10) = rx2030_cur."!mark_fail"(0)
    lt rx2030_pos, -1, rx2030_done
    eq rx2030_pos, -1, rx2030_fail
    jump $I10
  rx2030_done:
    rx2030_cur."!cursor_fail"()
    if_null rx2030_debug, debug_1436
    rx2030_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1436:
    .return (rx2030_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("298_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("299_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2034_tgt
    .local int rx2034_pos
    .local int rx2034_off
    .local int rx2034_eos
    .local int rx2034_rep
    .local pmc rx2034_cur
    .local pmc rx2034_debug
    (rx2034_cur, rx2034_pos, rx2034_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2034_cur
    .local pmc match
    .lex "$/", match
    length rx2034_eos, rx2034_tgt
    gt rx2034_pos, rx2034_eos, rx2034_done
    set rx2034_off, 0
    lt rx2034_pos, 2, rx2034_start
    sub rx2034_off, rx2034_pos, 1
    substr rx2034_tgt, rx2034_tgt, rx2034_off
  rx2034_start:
    eq $I10, 1, rx2034_restart
    if_null rx2034_debug, debug_1437
    rx2034_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1437:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2035_done
    goto rxscan2035_scan
  rxscan2035_loop:
    (rx2034_pos) = rx2034_cur."from"()
    inc rx2034_pos
    rx2034_cur."!cursor_from"(rx2034_pos)
    ge rx2034_pos, rx2034_eos, rxscan2035_done
  rxscan2035_scan:
    set_addr $I10, rxscan2035_loop
    rx2034_cur."!mark_push"(0, rx2034_pos, $I10)
  rxscan2035_done:
.annotate 'line', 1063
  # rx literal  "\\e"
    add $I11, rx2034_pos, 2
    gt $I11, rx2034_eos, rx2034_fail
    sub $I11, rx2034_pos, rx2034_off
    substr $S10, rx2034_tgt, $I11, 2
    ne $S10, "\\e", rx2034_fail
    add rx2034_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx2034_cur."!cursor_pos"(rx2034_pos)
    $P10 = rx2034_cur."quotemod_check"("b")
    unless $P10, rx2034_fail
  # rx pass
    rx2034_cur."!cursor_pass"(rx2034_pos, "quote_escape:sym<esc>")
    if_null rx2034_debug, debug_1438
    rx2034_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx2034_pos)
  debug_1438:
    .return (rx2034_cur)
  rx2034_restart:
.annotate 'line', 462
    if_null rx2034_debug, debug_1439
    rx2034_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1439:
  rx2034_fail:
    (rx2034_rep, rx2034_pos, $I10, $P10) = rx2034_cur."!mark_fail"(0)
    lt rx2034_pos, -1, rx2034_done
    eq rx2034_pos, -1, rx2034_fail
    jump $I10
  rx2034_done:
    rx2034_cur."!cursor_fail"()
    if_null rx2034_debug, debug_1440
    rx2034_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1440:
    .return (rx2034_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("300_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "\\e"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("301_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2038_tgt
    .local int rx2038_pos
    .local int rx2038_off
    .local int rx2038_eos
    .local int rx2038_rep
    .local pmc rx2038_cur
    .local pmc rx2038_debug
    (rx2038_cur, rx2038_pos, rx2038_tgt, $I10) = self."!cursor_start"()
    rx2038_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2038_cur
    .local pmc match
    .lex "$/", match
    length rx2038_eos, rx2038_tgt
    gt rx2038_pos, rx2038_eos, rx2038_done
    set rx2038_off, 0
    lt rx2038_pos, 2, rx2038_start
    sub rx2038_off, rx2038_pos, 1
    substr rx2038_tgt, rx2038_tgt, rx2038_off
  rx2038_start:
    eq $I10, 1, rx2038_restart
    if_null rx2038_debug, debug_1441
    rx2038_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1441:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2039_done
    goto rxscan2039_scan
  rxscan2039_loop:
    (rx2038_pos) = rx2038_cur."from"()
    inc rx2038_pos
    rx2038_cur."!cursor_from"(rx2038_pos)
    ge rx2038_pos, rx2038_eos, rxscan2039_done
  rxscan2039_scan:
    set_addr $I10, rxscan2039_loop
    rx2038_cur."!mark_push"(0, rx2038_pos, $I10)
  rxscan2039_done:
.annotate 'line', 1065
  # rx literal  "("
    add $I11, rx2038_pos, 1
    gt $I11, rx2038_eos, rx2038_fail
    sub $I11, rx2038_pos, rx2038_off
    ord $I11, rx2038_tgt, $I11
    ne $I11, 40, rx2038_fail
    add rx2038_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2038_cur."!cursor_pos"(rx2038_pos)
    $P10 = rx2038_cur."ws"()
    unless $P10, rx2038_fail
    rx2038_pos = $P10."pos"()
  # rx rxquantr2040 ** 0..1
    set_addr $I10, rxquantr2040_done
    rx2038_cur."!mark_push"(0, rx2038_pos, $I10)
  rxquantr2040_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2038_cur."!cursor_pos"(rx2038_pos)
    $P10 = rx2038_cur."EXPR"()
    unless $P10, rx2038_fail
    goto rxsubrule2041_pass
  rxsubrule2041_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2038_fail
  rxsubrule2041_pass:
    set_addr $I10, rxsubrule2041_back
    rx2038_cur."!mark_push"(0, rx2038_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2038_pos = $P10."pos"()
    set_addr $I10, rxquantr2040_done
    (rx2038_rep) = rx2038_cur."!mark_commit"($I10)
  rxquantr2040_done:
  # rx literal  ")"
    add $I11, rx2038_pos, 1
    gt $I11, rx2038_eos, rx2038_fail
    sub $I11, rx2038_pos, rx2038_off
    ord $I11, rx2038_tgt, $I11
    ne $I11, 41, rx2038_fail
    add rx2038_pos, 1
  # rx pass
    rx2038_cur."!cursor_pass"(rx2038_pos, "circumfix:sym<( )>")
    if_null rx2038_debug, debug_1442
    rx2038_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx2038_pos)
  debug_1442:
    .return (rx2038_cur)
  rx2038_restart:
.annotate 'line', 462
    if_null rx2038_debug, debug_1443
    rx2038_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1443:
  rx2038_fail:
    (rx2038_rep, rx2038_pos, $I10, $P10) = rx2038_cur."!mark_fail"(0)
    lt rx2038_pos, -1, rx2038_done
    eq rx2038_pos, -1, rx2038_fail
    jump $I10
  rx2038_done:
    rx2038_cur."!cursor_fail"()
    if_null rx2038_debug, debug_1444
    rx2038_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1444:
    .return (rx2038_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("302_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("303_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2044_tgt
    .local int rx2044_pos
    .local int rx2044_off
    .local int rx2044_eos
    .local int rx2044_rep
    .local pmc rx2044_cur
    .local pmc rx2044_debug
    (rx2044_cur, rx2044_pos, rx2044_tgt, $I10) = self."!cursor_start"()
    rx2044_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx2044_cur
    .local pmc match
    .lex "$/", match
    length rx2044_eos, rx2044_tgt
    gt rx2044_pos, rx2044_eos, rx2044_done
    set rx2044_off, 0
    lt rx2044_pos, 2, rx2044_start
    sub rx2044_off, rx2044_pos, 1
    substr rx2044_tgt, rx2044_tgt, rx2044_off
  rx2044_start:
    eq $I10, 1, rx2044_restart
    if_null rx2044_debug, debug_1445
    rx2044_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1445:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2045_done
    goto rxscan2045_scan
  rxscan2045_loop:
    (rx2044_pos) = rx2044_cur."from"()
    inc rx2044_pos
    rx2044_cur."!cursor_from"(rx2044_pos)
    ge rx2044_pos, rx2044_eos, rxscan2045_done
  rxscan2045_scan:
    set_addr $I10, rxscan2045_loop
    rx2044_cur."!mark_push"(0, rx2044_pos, $I10)
  rxscan2045_done:
.annotate 'line', 1066
  # rx literal  "["
    add $I11, rx2044_pos, 1
    gt $I11, rx2044_eos, rx2044_fail
    sub $I11, rx2044_pos, rx2044_off
    ord $I11, rx2044_tgt, $I11
    ne $I11, 91, rx2044_fail
    add rx2044_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2044_cur."!cursor_pos"(rx2044_pos)
    $P10 = rx2044_cur."ws"()
    unless $P10, rx2044_fail
    rx2044_pos = $P10."pos"()
  # rx rxquantr2046 ** 0..1
    set_addr $I10, rxquantr2046_done
    rx2044_cur."!mark_push"(0, rx2044_pos, $I10)
  rxquantr2046_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx2044_cur."!cursor_pos"(rx2044_pos)
    $P10 = rx2044_cur."EXPR"()
    unless $P10, rx2044_fail
    goto rxsubrule2047_pass
  rxsubrule2047_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2044_fail
  rxsubrule2047_pass:
    set_addr $I10, rxsubrule2047_back
    rx2044_cur."!mark_push"(0, rx2044_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx2044_pos = $P10."pos"()
    set_addr $I10, rxquantr2046_done
    (rx2044_rep) = rx2044_cur."!mark_commit"($I10)
  rxquantr2046_done:
  # rx literal  "]"
    add $I11, rx2044_pos, 1
    gt $I11, rx2044_eos, rx2044_fail
    sub $I11, rx2044_pos, rx2044_off
    ord $I11, rx2044_tgt, $I11
    ne $I11, 93, rx2044_fail
    add rx2044_pos, 1
  # rx pass
    rx2044_cur."!cursor_pass"(rx2044_pos, "circumfix:sym<[ ]>")
    if_null rx2044_debug, debug_1446
    rx2044_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx2044_pos)
  debug_1446:
    .return (rx2044_cur)
  rx2044_restart:
.annotate 'line', 462
    if_null rx2044_debug, debug_1447
    rx2044_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1447:
  rx2044_fail:
    (rx2044_rep, rx2044_pos, $I10, $P10) = rx2044_cur."!mark_fail"(0)
    lt rx2044_pos, -1, rx2044_done
    eq rx2044_pos, -1, rx2044_fail
    jump $I10
  rx2044_done:
    rx2044_cur."!cursor_fail"()
    if_null rx2044_debug, debug_1448
    rx2044_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1448:
    .return (rx2044_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("304_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "[")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("305_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2050_tgt
    .local int rx2050_pos
    .local int rx2050_off
    .local int rx2050_eos
    .local int rx2050_rep
    .local pmc rx2050_cur
    .local pmc rx2050_debug
    (rx2050_cur, rx2050_pos, rx2050_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2050_cur
    .local pmc match
    .lex "$/", match
    length rx2050_eos, rx2050_tgt
    gt rx2050_pos, rx2050_eos, rx2050_done
    set rx2050_off, 0
    lt rx2050_pos, 2, rx2050_start
    sub rx2050_off, rx2050_pos, 1
    substr rx2050_tgt, rx2050_tgt, rx2050_off
  rx2050_start:
    eq $I10, 1, rx2050_restart
    if_null rx2050_debug, debug_1449
    rx2050_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1449:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2051_done
    goto rxscan2051_scan
  rxscan2051_loop:
    (rx2050_pos) = rx2050_cur."from"()
    inc rx2050_pos
    rx2050_cur."!cursor_from"(rx2050_pos)
    ge rx2050_pos, rx2050_eos, rxscan2051_done
  rxscan2051_scan:
    set_addr $I10, rxscan2051_loop
    rx2050_cur."!mark_push"(0, rx2050_pos, $I10)
  rxscan2051_done:
.annotate 'line', 1067
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2050_pos, rx2050_off
    substr $S10, rx2050_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2050_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2050_cur."!cursor_pos"(rx2050_pos)
    $P10 = rx2050_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx2050_fail
    rx2050_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2050_pos = $P10."pos"()
  # rx pass
    rx2050_cur."!cursor_pass"(rx2050_pos, "circumfix:sym<ang>")
    if_null rx2050_debug, debug_1450
    rx2050_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx2050_pos)
  debug_1450:
    .return (rx2050_cur)
  rx2050_restart:
.annotate 'line', 462
    if_null rx2050_debug, debug_1451
    rx2050_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1451:
  rx2050_fail:
    (rx2050_rep, rx2050_pos, $I10, $P10) = rx2050_cur."!mark_fail"(0)
    lt rx2050_pos, -1, rx2050_done
    eq rx2050_pos, -1, rx2050_fail
    jump $I10
  rx2050_done:
    rx2050_cur."!cursor_fail"()
    if_null rx2050_debug, debug_1452
    rx2050_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1452:
    .return (rx2050_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("306_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "<"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("307_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2054_tgt
    .local int rx2054_pos
    .local int rx2054_off
    .local int rx2054_eos
    .local int rx2054_rep
    .local pmc rx2054_cur
    .local pmc rx2054_debug
    (rx2054_cur, rx2054_pos, rx2054_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2054_cur
    .local pmc match
    .lex "$/", match
    length rx2054_eos, rx2054_tgt
    gt rx2054_pos, rx2054_eos, rx2054_done
    set rx2054_off, 0
    lt rx2054_pos, 2, rx2054_start
    sub rx2054_off, rx2054_pos, 1
    substr rx2054_tgt, rx2054_tgt, rx2054_off
  rx2054_start:
    eq $I10, 1, rx2054_restart
    if_null rx2054_debug, debug_1453
    rx2054_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1453:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2055_done
    goto rxscan2055_scan
  rxscan2055_loop:
    (rx2054_pos) = rx2054_cur."from"()
    inc rx2054_pos
    rx2054_cur."!cursor_from"(rx2054_pos)
    ge rx2054_pos, rx2054_eos, rxscan2055_done
  rxscan2055_scan:
    set_addr $I10, rxscan2055_loop
    rx2054_cur."!mark_push"(0, rx2054_pos, $I10)
  rxscan2055_done:
.annotate 'line', 1068
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2054_pos, rx2054_off
    substr $S10, rx2054_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx2054_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2054_cur."!cursor_pos"(rx2054_pos)
    $P10 = rx2054_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx2054_fail
    rx2054_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2054_pos = $P10."pos"()
  # rx pass
    rx2054_cur."!cursor_pass"(rx2054_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx2054_debug, debug_1454
    rx2054_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx2054_pos)
  debug_1454:
    .return (rx2054_cur)
  rx2054_restart:
.annotate 'line', 462
    if_null rx2054_debug, debug_1455
    rx2054_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1455:
  rx2054_fail:
    (rx2054_rep, rx2054_pos, $I10, $P10) = rx2054_cur."!mark_fail"(0)
    lt rx2054_pos, -1, rx2054_done
    eq rx2054_pos, -1, rx2054_fail
    jump $I10
  rx2054_done:
    rx2054_cur."!cursor_fail"()
    if_null rx2054_debug, debug_1456
    rx2054_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1456:
    .return (rx2054_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("308_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, unicode:"\x{ab}"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("309_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2058_tgt
    .local int rx2058_pos
    .local int rx2058_off
    .local int rx2058_eos
    .local int rx2058_rep
    .local pmc rx2058_cur
    .local pmc rx2058_debug
    (rx2058_cur, rx2058_pos, rx2058_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2058_cur
    .local pmc match
    .lex "$/", match
    length rx2058_eos, rx2058_tgt
    gt rx2058_pos, rx2058_eos, rx2058_done
    set rx2058_off, 0
    lt rx2058_pos, 2, rx2058_start
    sub rx2058_off, rx2058_pos, 1
    substr rx2058_tgt, rx2058_tgt, rx2058_off
  rx2058_start:
    eq $I10, 1, rx2058_restart
    if_null rx2058_debug, debug_1457
    rx2058_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1457:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2059_done
    goto rxscan2059_scan
  rxscan2059_loop:
    (rx2058_pos) = rx2058_cur."from"()
    inc rx2058_pos
    rx2058_cur."!cursor_from"(rx2058_pos)
    ge rx2058_pos, rx2058_eos, rxscan2059_done
  rxscan2059_scan:
    set_addr $I10, rxscan2059_loop
    rx2058_cur."!mark_push"(0, rx2058_pos, $I10)
  rxscan2059_done:
.annotate 'line', 1069
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2058_pos, rx2058_off
    substr $S10, rx2058_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2058_fail
  # rx subrule "pblock" subtype=capture negate=
    rx2058_cur."!cursor_pos"(rx2058_pos)
    $P10 = rx2058_cur."pblock"()
    unless $P10, rx2058_fail
    rx2058_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx2058_pos = $P10."pos"()
  # rx pass
    rx2058_cur."!cursor_pass"(rx2058_pos, "circumfix:sym<{ }>")
    if_null rx2058_debug, debug_1458
    rx2058_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx2058_pos)
  debug_1458:
    .return (rx2058_cur)
  rx2058_restart:
.annotate 'line', 462
    if_null rx2058_debug, debug_1459
    rx2058_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1459:
  rx2058_fail:
    (rx2058_rep, rx2058_pos, $I10, $P10) = rx2058_cur."!mark_fail"(0)
    lt rx2058_pos, -1, rx2058_done
    eq rx2058_pos, -1, rx2058_fail
    jump $I10
  rx2058_done:
    rx2058_cur."!cursor_fail"()
    if_null rx2058_debug, debug_1460
    rx2058_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1460:
    .return (rx2058_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("310_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("311_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2062_tgt
    .local int rx2062_pos
    .local int rx2062_off
    .local int rx2062_eos
    .local int rx2062_rep
    .local pmc rx2062_cur
    .local pmc rx2062_debug
    (rx2062_cur, rx2062_pos, rx2062_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2062_cur
    .local pmc match
    .lex "$/", match
    length rx2062_eos, rx2062_tgt
    gt rx2062_pos, rx2062_eos, rx2062_done
    set rx2062_off, 0
    lt rx2062_pos, 2, rx2062_start
    sub rx2062_off, rx2062_pos, 1
    substr rx2062_tgt, rx2062_tgt, rx2062_off
  rx2062_start:
    eq $I10, 1, rx2062_restart
    if_null rx2062_debug, debug_1461
    rx2062_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1461:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2063_done
    goto rxscan2063_scan
  rxscan2063_loop:
    (rx2062_pos) = rx2062_cur."from"()
    inc rx2062_pos
    rx2062_cur."!cursor_from"(rx2062_pos)
    ge rx2062_pos, rx2062_eos, rxscan2063_done
  rxscan2063_scan:
    set_addr $I10, rxscan2063_loop
    rx2062_cur."!mark_push"(0, rx2062_pos, $I10)
  rxscan2063_done:
.annotate 'line', 1070
  # rx subrule "sigil" subtype=capture negate=
    rx2062_cur."!cursor_pos"(rx2062_pos)
    $P10 = rx2062_cur."sigil"()
    unless $P10, rx2062_fail
    rx2062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx2062_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx2062_pos, 1
    gt $I11, rx2062_eos, rx2062_fail
    sub $I11, rx2062_pos, rx2062_off
    ord $I11, rx2062_tgt, $I11
    ne $I11, 40, rx2062_fail
    add rx2062_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx2062_cur."!cursor_pos"(rx2062_pos)
    $P10 = rx2062_cur."semilist"()
    unless $P10, rx2062_fail
    rx2062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx2062_pos = $P10."pos"()
  alt2064_0:
    set_addr $I10, alt2064_1
    rx2062_cur."!mark_push"(0, rx2062_pos, $I10)
  # rx literal  ")"
    add $I11, rx2062_pos, 1
    gt $I11, rx2062_eos, rx2062_fail
    sub $I11, rx2062_pos, rx2062_off
    ord $I11, rx2062_tgt, $I11
    ne $I11, 41, rx2062_fail
    add rx2062_pos, 1
    goto alt2064_end
  alt2064_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx2062_cur."!cursor_pos"(rx2062_pos)
    $P10 = rx2062_cur."FAILGOAL"("')'")
    unless $P10, rx2062_fail
    goto rxsubrule2065_pass
  rxsubrule2065_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx2062_fail
  rxsubrule2065_pass:
    set_addr $I10, rxsubrule2065_back
    rx2062_cur."!mark_push"(0, rx2062_pos, $I10, $P10)
    rx2062_pos = $P10."pos"()
  alt2064_end:
  # rx pass
    rx2062_cur."!cursor_pass"(rx2062_pos, "circumfix:sym<sigil>")
    if_null rx2062_debug, debug_1462
    rx2062_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx2062_pos)
  debug_1462:
    .return (rx2062_cur)
  rx2062_restart:
.annotate 'line', 462
    if_null rx2062_debug, debug_1463
    rx2062_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1463:
  rx2062_fail:
    (rx2062_rep, rx2062_pos, $I10, $P10) = rx2062_cur."!mark_fail"(0)
    lt rx2062_pos, -1, rx2062_done
    eq rx2062_pos, -1, rx2062_fail
    jump $I10
  rx2062_done:
    rx2062_cur."!cursor_fail"()
    if_null rx2062_debug, debug_1464
    rx2062_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1464:
    .return (rx2062_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("312_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P104 = self."!PREFIX__!subrule"("sigil", "")
    new $P105, "ResizablePMCArray"
    push $P105, $P104
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("313_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2068_tgt
    .local int rx2068_pos
    .local int rx2068_off
    .local int rx2068_eos
    .local int rx2068_rep
    .local pmc rx2068_cur
    .local pmc rx2068_debug
    (rx2068_cur, rx2068_pos, rx2068_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2068_cur
    .local pmc match
    .lex "$/", match
    length rx2068_eos, rx2068_tgt
    gt rx2068_pos, rx2068_eos, rx2068_done
    set rx2068_off, 0
    lt rx2068_pos, 2, rx2068_start
    sub rx2068_off, rx2068_pos, 1
    substr rx2068_tgt, rx2068_tgt, rx2068_off
  rx2068_start:
    eq $I10, 1, rx2068_restart
    if_null rx2068_debug, debug_1465
    rx2068_cur."!cursor_debug"("START", "semilist")
  debug_1465:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2069_done
    goto rxscan2069_scan
  rxscan2069_loop:
    (rx2068_pos) = rx2068_cur."from"()
    inc rx2068_pos
    rx2068_cur."!cursor_from"(rx2068_pos)
    ge rx2068_pos, rx2068_eos, rxscan2069_done
  rxscan2069_scan:
    set_addr $I10, rxscan2069_loop
    rx2068_cur."!mark_push"(0, rx2068_pos, $I10)
  rxscan2069_done:
.annotate 'line', 1072
  # rx subrule "ws" subtype=method negate=
    rx2068_cur."!cursor_pos"(rx2068_pos)
    $P10 = rx2068_cur."ws"()
    unless $P10, rx2068_fail
    rx2068_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx2068_cur."!cursor_pos"(rx2068_pos)
    $P10 = rx2068_cur."statement"()
    unless $P10, rx2068_fail
    rx2068_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2068_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2068_cur."!cursor_pos"(rx2068_pos)
    $P10 = rx2068_cur."ws"()
    unless $P10, rx2068_fail
    rx2068_pos = $P10."pos"()
  # rx pass
    rx2068_cur."!cursor_pass"(rx2068_pos, "semilist")
    if_null rx2068_debug, debug_1466
    rx2068_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx2068_pos)
  debug_1466:
    .return (rx2068_cur)
  rx2068_restart:
.annotate 'line', 462
    if_null rx2068_debug, debug_1467
    rx2068_cur."!cursor_debug"("NEXT", "semilist")
  debug_1467:
  rx2068_fail:
    (rx2068_rep, rx2068_pos, $I10, $P10) = rx2068_cur."!mark_fail"(0)
    lt rx2068_pos, -1, rx2068_done
    eq rx2068_pos, -1, rx2068_fail
    jump $I10
  rx2068_done:
    rx2068_cur."!cursor_fail"()
    if_null rx2068_debug, debug_1468
    rx2068_cur."!cursor_debug"("FAIL", "semilist")
  debug_1468:
    .return (rx2068_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("314_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P105 = self."!PREFIX__!subrule"("ws", "")
    new $P106, "ResizablePMCArray"
    push $P106, $P105
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("315_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2072_tgt
    .local int rx2072_pos
    .local int rx2072_off
    .local int rx2072_eos
    .local int rx2072_rep
    .local pmc rx2072_cur
    .local pmc rx2072_debug
    (rx2072_cur, rx2072_pos, rx2072_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2072_cur
    .local pmc match
    .lex "$/", match
    length rx2072_eos, rx2072_tgt
    gt rx2072_pos, rx2072_eos, rx2072_done
    set rx2072_off, 0
    lt rx2072_pos, 2, rx2072_start
    sub rx2072_off, rx2072_pos, 1
    substr rx2072_tgt, rx2072_tgt, rx2072_off
  rx2072_start:
    eq $I10, 1, rx2072_restart
    if_null rx2072_debug, debug_1469
    rx2072_cur."!cursor_debug"("START", "infixish")
  debug_1469:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2073_done
    goto rxscan2073_scan
  rxscan2073_loop:
    (rx2072_pos) = rx2072_cur."from"()
    inc rx2072_pos
    rx2072_cur."!cursor_from"(rx2072_pos)
    ge rx2072_pos, rx2072_eos, rxscan2073_done
  rxscan2073_scan:
    set_addr $I10, rxscan2073_loop
    rx2072_cur."!mark_push"(0, rx2072_pos, $I10)
  rxscan2073_done:
.annotate 'line', 1095
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx2072_cur."!cursor_pos"(rx2072_pos)
    $P10 = rx2072_cur."infixstopper"()
    if $P10, rx2072_fail
  # rx subrule "infix" subtype=capture negate=
    rx2072_cur."!cursor_pos"(rx2072_pos)
    $P10 = rx2072_cur."infix"()
    unless $P10, rx2072_fail
    rx2072_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx2072_pos = $P10."pos"()
  # rx pass
    rx2072_cur."!cursor_pass"(rx2072_pos, "infixish")
    if_null rx2072_debug, debug_1470
    rx2072_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx2072_pos)
  debug_1470:
    .return (rx2072_cur)
  rx2072_restart:
.annotate 'line', 462
    if_null rx2072_debug, debug_1471
    rx2072_cur."!cursor_debug"("NEXT", "infixish")
  debug_1471:
  rx2072_fail:
    (rx2072_rep, rx2072_pos, $I10, $P10) = rx2072_cur."!mark_fail"(0)
    lt rx2072_pos, -1, rx2072_done
    eq rx2072_pos, -1, rx2072_fail
    jump $I10
  rx2072_done:
    rx2072_cur."!cursor_fail"()
    if_null rx2072_debug, debug_1472
    rx2072_cur."!cursor_debug"("FAIL", "infixish")
  debug_1472:
    .return (rx2072_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("316_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("317_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2076_tgt
    .local int rx2076_pos
    .local int rx2076_off
    .local int rx2076_eos
    .local int rx2076_rep
    .local pmc rx2076_cur
    .local pmc rx2076_debug
    (rx2076_cur, rx2076_pos, rx2076_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2076_cur
    .local pmc match
    .lex "$/", match
    length rx2076_eos, rx2076_tgt
    gt rx2076_pos, rx2076_eos, rx2076_done
    set rx2076_off, 0
    lt rx2076_pos, 2, rx2076_start
    sub rx2076_off, rx2076_pos, 1
    substr rx2076_tgt, rx2076_tgt, rx2076_off
  rx2076_start:
    eq $I10, 1, rx2076_restart
    if_null rx2076_debug, debug_1473
    rx2076_cur."!cursor_debug"("START", "infixstopper")
  debug_1473:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2077_done
    goto rxscan2077_scan
  rxscan2077_loop:
    (rx2076_pos) = rx2076_cur."from"()
    inc rx2076_pos
    rx2076_cur."!cursor_from"(rx2076_pos)
    ge rx2076_pos, rx2076_eos, rxscan2077_done
  rxscan2077_scan:
    set_addr $I10, rxscan2077_loop
    rx2076_cur."!mark_push"(0, rx2076_pos, $I10)
  rxscan2077_done:
.annotate 'line', 1096
  # rx subrule "lambda" subtype=zerowidth negate=
    rx2076_cur."!cursor_pos"(rx2076_pos)
    $P10 = rx2076_cur."lambda"()
    unless $P10, rx2076_fail
  # rx pass
    rx2076_cur."!cursor_pass"(rx2076_pos, "infixstopper")
    if_null rx2076_debug, debug_1474
    rx2076_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx2076_pos)
  debug_1474:
    .return (rx2076_cur)
  rx2076_restart:
.annotate 'line', 462
    if_null rx2076_debug, debug_1475
    rx2076_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1475:
  rx2076_fail:
    (rx2076_rep, rx2076_pos, $I10, $P10) = rx2076_cur."!mark_fail"(0)
    lt rx2076_pos, -1, rx2076_done
    eq rx2076_pos, -1, rx2076_fail
    jump $I10
  rx2076_done:
    rx2076_cur."!cursor_fail"()
    if_null rx2076_debug, debug_1476
    rx2076_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1476:
    .return (rx2076_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("318_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, ""
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("319_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2080_tgt
    .local int rx2080_pos
    .local int rx2080_off
    .local int rx2080_eos
    .local int rx2080_rep
    .local pmc rx2080_cur
    .local pmc rx2080_debug
    (rx2080_cur, rx2080_pos, rx2080_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2080_cur
    .local pmc match
    .lex "$/", match
    length rx2080_eos, rx2080_tgt
    gt rx2080_pos, rx2080_eos, rx2080_done
    set rx2080_off, 0
    lt rx2080_pos, 2, rx2080_start
    sub rx2080_off, rx2080_pos, 1
    substr rx2080_tgt, rx2080_tgt, rx2080_off
  rx2080_start:
    eq $I10, 1, rx2080_restart
    if_null rx2080_debug, debug_1477
    rx2080_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1477:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2081_done
    goto rxscan2081_scan
  rxscan2081_loop:
    (rx2080_pos) = rx2080_cur."from"()
    inc rx2080_pos
    rx2080_cur."!cursor_from"(rx2080_pos)
    ge rx2080_pos, rx2080_eos, rxscan2081_done
  rxscan2081_scan:
    set_addr $I10, rxscan2081_loop
    rx2080_cur."!mark_push"(0, rx2080_pos, $I10)
  rxscan2081_done:
.annotate 'line', 1099
  # rx literal  "["
    add $I11, rx2080_pos, 1
    gt $I11, rx2080_eos, rx2080_fail
    sub $I11, rx2080_pos, rx2080_off
    ord $I11, rx2080_tgt, $I11
    ne $I11, 91, rx2080_fail
    add rx2080_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2080_cur."!cursor_pos"(rx2080_pos)
    $P10 = rx2080_cur."ws"()
    unless $P10, rx2080_fail
    rx2080_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2080_cur."!cursor_pos"(rx2080_pos)
    $P10 = rx2080_cur."EXPR"()
    unless $P10, rx2080_fail
    rx2080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2080_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx2080_pos, 1
    gt $I11, rx2080_eos, rx2080_fail
    sub $I11, rx2080_pos, rx2080_off
    ord $I11, rx2080_tgt, $I11
    ne $I11, 93, rx2080_fail
    add rx2080_pos, 1
.annotate 'line', 1100
  # rx subrule "O" subtype=capture negate=
    rx2080_cur."!cursor_pos"(rx2080_pos)
    $P10 = rx2080_cur."O"("%methodop")
    unless $P10, rx2080_fail
    rx2080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2080_pos = $P10."pos"()
.annotate 'line', 1098
  # rx pass
    rx2080_cur."!cursor_pass"(rx2080_pos, "postcircumfix:sym<[ ]>")
    if_null rx2080_debug, debug_1478
    rx2080_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx2080_pos)
  debug_1478:
    .return (rx2080_cur)
  rx2080_restart:
.annotate 'line', 462
    if_null rx2080_debug, debug_1479
    rx2080_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1479:
  rx2080_fail:
    (rx2080_rep, rx2080_pos, $I10, $P10) = rx2080_cur."!mark_fail"(0)
    lt rx2080_pos, -1, rx2080_done
    eq rx2080_pos, -1, rx2080_fail
    jump $I10
  rx2080_done:
    rx2080_cur."!cursor_fail"()
    if_null rx2080_debug, debug_1480
    rx2080_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1480:
    .return (rx2080_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("320_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "[")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("321_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2084_tgt
    .local int rx2084_pos
    .local int rx2084_off
    .local int rx2084_eos
    .local int rx2084_rep
    .local pmc rx2084_cur
    .local pmc rx2084_debug
    (rx2084_cur, rx2084_pos, rx2084_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2084_cur
    .local pmc match
    .lex "$/", match
    length rx2084_eos, rx2084_tgt
    gt rx2084_pos, rx2084_eos, rx2084_done
    set rx2084_off, 0
    lt rx2084_pos, 2, rx2084_start
    sub rx2084_off, rx2084_pos, 1
    substr rx2084_tgt, rx2084_tgt, rx2084_off
  rx2084_start:
    eq $I10, 1, rx2084_restart
    if_null rx2084_debug, debug_1481
    rx2084_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1481:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2085_done
    goto rxscan2085_scan
  rxscan2085_loop:
    (rx2084_pos) = rx2084_cur."from"()
    inc rx2084_pos
    rx2084_cur."!cursor_from"(rx2084_pos)
    ge rx2084_pos, rx2084_eos, rxscan2085_done
  rxscan2085_scan:
    set_addr $I10, rxscan2085_loop
    rx2084_cur."!mark_push"(0, rx2084_pos, $I10)
  rxscan2085_done:
.annotate 'line', 1104
  # rx literal  "{"
    add $I11, rx2084_pos, 1
    gt $I11, rx2084_eos, rx2084_fail
    sub $I11, rx2084_pos, rx2084_off
    ord $I11, rx2084_tgt, $I11
    ne $I11, 123, rx2084_fail
    add rx2084_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2084_cur."!cursor_pos"(rx2084_pos)
    $P10 = rx2084_cur."ws"()
    unless $P10, rx2084_fail
    rx2084_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx2084_cur."!cursor_pos"(rx2084_pos)
    $P10 = rx2084_cur."EXPR"()
    unless $P10, rx2084_fail
    rx2084_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2084_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx2084_pos, 1
    gt $I11, rx2084_eos, rx2084_fail
    sub $I11, rx2084_pos, rx2084_off
    ord $I11, rx2084_tgt, $I11
    ne $I11, 125, rx2084_fail
    add rx2084_pos, 1
.annotate 'line', 1105
  # rx subrule "O" subtype=capture negate=
    rx2084_cur."!cursor_pos"(rx2084_pos)
    $P10 = rx2084_cur."O"("%methodop")
    unless $P10, rx2084_fail
    rx2084_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2084_pos = $P10."pos"()
.annotate 'line', 1103
  # rx pass
    rx2084_cur."!cursor_pass"(rx2084_pos, "postcircumfix:sym<{ }>")
    if_null rx2084_debug, debug_1482
    rx2084_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx2084_pos)
  debug_1482:
    .return (rx2084_cur)
  rx2084_restart:
.annotate 'line', 462
    if_null rx2084_debug, debug_1483
    rx2084_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1483:
  rx2084_fail:
    (rx2084_rep, rx2084_pos, $I10, $P10) = rx2084_cur."!mark_fail"(0)
    lt rx2084_pos, -1, rx2084_done
    eq rx2084_pos, -1, rx2084_fail
    jump $I10
  rx2084_done:
    rx2084_cur."!cursor_fail"()
    if_null rx2084_debug, debug_1484
    rx2084_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1484:
    .return (rx2084_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("322_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "{")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("323_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2088_tgt
    .local int rx2088_pos
    .local int rx2088_off
    .local int rx2088_eos
    .local int rx2088_rep
    .local pmc rx2088_cur
    .local pmc rx2088_debug
    (rx2088_cur, rx2088_pos, rx2088_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2088_cur
    .local pmc match
    .lex "$/", match
    length rx2088_eos, rx2088_tgt
    gt rx2088_pos, rx2088_eos, rx2088_done
    set rx2088_off, 0
    lt rx2088_pos, 2, rx2088_start
    sub rx2088_off, rx2088_pos, 1
    substr rx2088_tgt, rx2088_tgt, rx2088_off
  rx2088_start:
    eq $I10, 1, rx2088_restart
    if_null rx2088_debug, debug_1485
    rx2088_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1485:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2089_done
    goto rxscan2089_scan
  rxscan2089_loop:
    (rx2088_pos) = rx2088_cur."from"()
    inc rx2088_pos
    rx2088_cur."!cursor_from"(rx2088_pos)
    ge rx2088_pos, rx2088_eos, rxscan2089_done
  rxscan2089_scan:
    set_addr $I10, rxscan2089_loop
    rx2088_cur."!mark_push"(0, rx2088_pos, $I10)
  rxscan2089_done:
.annotate 'line', 1109
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2088_pos, rx2088_off
    substr $S10, rx2088_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx2088_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx2088_cur."!cursor_pos"(rx2088_pos)
    $P10 = rx2088_cur."quote_EXPR"(":q")
    unless $P10, rx2088_fail
    rx2088_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx2088_pos = $P10."pos"()
.annotate 'line', 1110
  # rx subrule "O" subtype=capture negate=
    rx2088_cur."!cursor_pos"(rx2088_pos)
    $P10 = rx2088_cur."O"("%methodop")
    unless $P10, rx2088_fail
    rx2088_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2088_pos = $P10."pos"()
.annotate 'line', 1108
  # rx pass
    rx2088_cur."!cursor_pass"(rx2088_pos, "postcircumfix:sym<ang>")
    if_null rx2088_debug, debug_1486
    rx2088_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx2088_pos)
  debug_1486:
    .return (rx2088_cur)
  rx2088_restart:
.annotate 'line', 462
    if_null rx2088_debug, debug_1487
    rx2088_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1487:
  rx2088_fail:
    (rx2088_rep, rx2088_pos, $I10, $P10) = rx2088_cur."!mark_fail"(0)
    lt rx2088_pos, -1, rx2088_done
    eq rx2088_pos, -1, rx2088_fail
    jump $I10
  rx2088_done:
    rx2088_cur."!cursor_fail"()
    if_null rx2088_debug, debug_1488
    rx2088_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1488:
    .return (rx2088_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("324_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "<"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("325_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2092_tgt
    .local int rx2092_pos
    .local int rx2092_off
    .local int rx2092_eos
    .local int rx2092_rep
    .local pmc rx2092_cur
    .local pmc rx2092_debug
    (rx2092_cur, rx2092_pos, rx2092_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2092_cur
    .local pmc match
    .lex "$/", match
    length rx2092_eos, rx2092_tgt
    gt rx2092_pos, rx2092_eos, rx2092_done
    set rx2092_off, 0
    lt rx2092_pos, 2, rx2092_start
    sub rx2092_off, rx2092_pos, 1
    substr rx2092_tgt, rx2092_tgt, rx2092_off
  rx2092_start:
    eq $I10, 1, rx2092_restart
    if_null rx2092_debug, debug_1489
    rx2092_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1489:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2093_done
    goto rxscan2093_scan
  rxscan2093_loop:
    (rx2092_pos) = rx2092_cur."from"()
    inc rx2092_pos
    rx2092_cur."!cursor_from"(rx2092_pos)
    ge rx2092_pos, rx2092_eos, rxscan2093_done
  rxscan2093_scan:
    set_addr $I10, rxscan2093_loop
    rx2092_cur."!mark_push"(0, rx2092_pos, $I10)
  rxscan2093_done:
.annotate 'line', 1114
  # rx literal  "("
    add $I11, rx2092_pos, 1
    gt $I11, rx2092_eos, rx2092_fail
    sub $I11, rx2092_pos, rx2092_off
    ord $I11, rx2092_tgt, $I11
    ne $I11, 40, rx2092_fail
    add rx2092_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx2092_cur."!cursor_pos"(rx2092_pos)
    $P10 = rx2092_cur."ws"()
    unless $P10, rx2092_fail
    rx2092_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx2092_cur."!cursor_pos"(rx2092_pos)
    $P10 = rx2092_cur."arglist"()
    unless $P10, rx2092_fail
    rx2092_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2092_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2092_pos, 1
    gt $I11, rx2092_eos, rx2092_fail
    sub $I11, rx2092_pos, rx2092_off
    ord $I11, rx2092_tgt, $I11
    ne $I11, 41, rx2092_fail
    add rx2092_pos, 1
.annotate 'line', 1115
  # rx subrule "O" subtype=capture negate=
    rx2092_cur."!cursor_pos"(rx2092_pos)
    $P10 = rx2092_cur."O"("%methodop")
    unless $P10, rx2092_fail
    rx2092_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2092_pos = $P10."pos"()
.annotate 'line', 1113
  # rx pass
    rx2092_cur."!cursor_pass"(rx2092_pos, "postcircumfix:sym<( )>")
    if_null rx2092_debug, debug_1490
    rx2092_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx2092_pos)
  debug_1490:
    .return (rx2092_cur)
  rx2092_restart:
.annotate 'line', 462
    if_null rx2092_debug, debug_1491
    rx2092_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1491:
  rx2092_fail:
    (rx2092_rep, rx2092_pos, $I10, $P10) = rx2092_cur."!mark_fail"(0)
    lt rx2092_pos, -1, rx2092_done
    eq rx2092_pos, -1, rx2092_fail
    jump $I10
  rx2092_done:
    rx2092_cur."!cursor_fail"()
    if_null rx2092_debug, debug_1492
    rx2092_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1492:
    .return (rx2092_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("326_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "(")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("327_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2096_tgt
    .local int rx2096_pos
    .local int rx2096_off
    .local int rx2096_eos
    .local int rx2096_rep
    .local pmc rx2096_cur
    .local pmc rx2096_debug
    (rx2096_cur, rx2096_pos, rx2096_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2096_cur
    .local pmc match
    .lex "$/", match
    length rx2096_eos, rx2096_tgt
    gt rx2096_pos, rx2096_eos, rx2096_done
    set rx2096_off, 0
    lt rx2096_pos, 2, rx2096_start
    sub rx2096_off, rx2096_pos, 1
    substr rx2096_tgt, rx2096_tgt, rx2096_off
  rx2096_start:
    eq $I10, 1, rx2096_restart
    if_null rx2096_debug, debug_1493
    rx2096_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1493:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2097_done
    goto rxscan2097_scan
  rxscan2097_loop:
    (rx2096_pos) = rx2096_cur."from"()
    inc rx2096_pos
    rx2096_cur."!cursor_from"(rx2096_pos)
    ge rx2096_pos, rx2096_eos, rxscan2097_done
  rxscan2097_scan:
    set_addr $I10, rxscan2097_loop
    rx2096_cur."!mark_push"(0, rx2096_pos, $I10)
  rxscan2097_done:
.annotate 'line', 1118
  # rx subrule "dotty" subtype=capture negate=
    rx2096_cur."!cursor_pos"(rx2096_pos)
    $P10 = rx2096_cur."dotty"()
    unless $P10, rx2096_fail
    rx2096_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx2096_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx2096_cur."!cursor_pos"(rx2096_pos)
    $P10 = rx2096_cur."O"("%methodop")
    unless $P10, rx2096_fail
    rx2096_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2096_pos = $P10."pos"()
  # rx pass
    rx2096_cur."!cursor_pass"(rx2096_pos, "postfix:sym<.>")
    if_null rx2096_debug, debug_1494
    rx2096_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx2096_pos)
  debug_1494:
    .return (rx2096_cur)
  rx2096_restart:
.annotate 'line', 462
    if_null rx2096_debug, debug_1495
    rx2096_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1495:
  rx2096_fail:
    (rx2096_rep, rx2096_pos, $I10, $P10) = rx2096_cur."!mark_fail"(0)
    lt rx2096_pos, -1, rx2096_done
    eq rx2096_pos, -1, rx2096_fail
    jump $I10
  rx2096_done:
    rx2096_cur."!cursor_fail"()
    if_null rx2096_debug, debug_1496
    rx2096_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1496:
    .return (rx2096_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("328_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("dotty", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("329_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2100_tgt
    .local int rx2100_pos
    .local int rx2100_off
    .local int rx2100_eos
    .local int rx2100_rep
    .local pmc rx2100_cur
    .local pmc rx2100_debug
    (rx2100_cur, rx2100_pos, rx2100_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2100_cur
    .local pmc match
    .lex "$/", match
    length rx2100_eos, rx2100_tgt
    gt rx2100_pos, rx2100_eos, rx2100_done
    set rx2100_off, 0
    lt rx2100_pos, 2, rx2100_start
    sub rx2100_off, rx2100_pos, 1
    substr rx2100_tgt, rx2100_tgt, rx2100_off
  rx2100_start:
    eq $I10, 1, rx2100_restart
    if_null rx2100_debug, debug_1497
    rx2100_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1497:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2101_done
    goto rxscan2101_scan
  rxscan2101_loop:
    (rx2100_pos) = rx2100_cur."from"()
    inc rx2100_pos
    rx2100_cur."!cursor_from"(rx2100_pos)
    ge rx2100_pos, rx2100_eos, rxscan2101_done
  rxscan2101_scan:
    set_addr $I10, rxscan2101_loop
    rx2100_cur."!mark_push"(0, rx2100_pos, $I10)
  rxscan2101_done:
.annotate 'line', 1120
  # rx subcapture "sym"
    set_addr $I10, rxcap_2102_fail
    rx2100_cur."!mark_push"(0, rx2100_pos, $I10)
  # rx literal  "++"
    add $I11, rx2100_pos, 2
    gt $I11, rx2100_eos, rx2100_fail
    sub $I11, rx2100_pos, rx2100_off
    substr $S10, rx2100_tgt, $I11, 2
    ne $S10, "++", rx2100_fail
    add rx2100_pos, 2
    set_addr $I10, rxcap_2102_fail
    ($I12, $I11) = rx2100_cur."!mark_peek"($I10)
    rx2100_cur."!cursor_pos"($I11)
    ($P10) = rx2100_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2100_pos, "")
    rx2100_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2102_done
  rxcap_2102_fail:
    goto rx2100_fail
  rxcap_2102_done:
  # rx subrule "O" subtype=capture negate=
    rx2100_cur."!cursor_pos"(rx2100_pos)
    $P10 = rx2100_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx2100_fail
    rx2100_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2100_pos = $P10."pos"()
  # rx pass
    rx2100_cur."!cursor_pass"(rx2100_pos, "prefix:sym<++>")
    if_null rx2100_debug, debug_1498
    rx2100_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx2100_pos)
  debug_1498:
    .return (rx2100_cur)
  rx2100_restart:
.annotate 'line', 462
    if_null rx2100_debug, debug_1499
    rx2100_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1499:
  rx2100_fail:
    (rx2100_rep, rx2100_pos, $I10, $P10) = rx2100_cur."!mark_fail"(0)
    lt rx2100_pos, -1, rx2100_done
    eq rx2100_pos, -1, rx2100_fail
    jump $I10
  rx2100_done:
    rx2100_cur."!cursor_fail"()
    if_null rx2100_debug, debug_1500
    rx2100_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1500:
    .return (rx2100_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("330_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "++")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("331_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2105_tgt
    .local int rx2105_pos
    .local int rx2105_off
    .local int rx2105_eos
    .local int rx2105_rep
    .local pmc rx2105_cur
    .local pmc rx2105_debug
    (rx2105_cur, rx2105_pos, rx2105_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2105_cur
    .local pmc match
    .lex "$/", match
    length rx2105_eos, rx2105_tgt
    gt rx2105_pos, rx2105_eos, rx2105_done
    set rx2105_off, 0
    lt rx2105_pos, 2, rx2105_start
    sub rx2105_off, rx2105_pos, 1
    substr rx2105_tgt, rx2105_tgt, rx2105_off
  rx2105_start:
    eq $I10, 1, rx2105_restart
    if_null rx2105_debug, debug_1501
    rx2105_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1501:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2106_done
    goto rxscan2106_scan
  rxscan2106_loop:
    (rx2105_pos) = rx2105_cur."from"()
    inc rx2105_pos
    rx2105_cur."!cursor_from"(rx2105_pos)
    ge rx2105_pos, rx2105_eos, rxscan2106_done
  rxscan2106_scan:
    set_addr $I10, rxscan2106_loop
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  rxscan2106_done:
.annotate 'line', 1121
  # rx subcapture "sym"
    set_addr $I10, rxcap_2107_fail
    rx2105_cur."!mark_push"(0, rx2105_pos, $I10)
  # rx literal  "--"
    add $I11, rx2105_pos, 2
    gt $I11, rx2105_eos, rx2105_fail
    sub $I11, rx2105_pos, rx2105_off
    substr $S10, rx2105_tgt, $I11, 2
    ne $S10, "--", rx2105_fail
    add rx2105_pos, 2
    set_addr $I10, rxcap_2107_fail
    ($I12, $I11) = rx2105_cur."!mark_peek"($I10)
    rx2105_cur."!cursor_pos"($I11)
    ($P10) = rx2105_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2105_pos, "")
    rx2105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2107_done
  rxcap_2107_fail:
    goto rx2105_fail
  rxcap_2107_done:
  # rx subrule "O" subtype=capture negate=
    rx2105_cur."!cursor_pos"(rx2105_pos)
    $P10 = rx2105_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx2105_fail
    rx2105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2105_pos = $P10."pos"()
  # rx pass
    rx2105_cur."!cursor_pass"(rx2105_pos, "prefix:sym<-->")
    if_null rx2105_debug, debug_1502
    rx2105_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx2105_pos)
  debug_1502:
    .return (rx2105_cur)
  rx2105_restart:
.annotate 'line', 462
    if_null rx2105_debug, debug_1503
    rx2105_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1503:
  rx2105_fail:
    (rx2105_rep, rx2105_pos, $I10, $P10) = rx2105_cur."!mark_fail"(0)
    lt rx2105_pos, -1, rx2105_done
    eq rx2105_pos, -1, rx2105_fail
    jump $I10
  rx2105_done:
    rx2105_cur."!cursor_fail"()
    if_null rx2105_debug, debug_1504
    rx2105_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1504:
    .return (rx2105_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("332_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "--")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("333_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2110_tgt
    .local int rx2110_pos
    .local int rx2110_off
    .local int rx2110_eos
    .local int rx2110_rep
    .local pmc rx2110_cur
    .local pmc rx2110_debug
    (rx2110_cur, rx2110_pos, rx2110_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2110_cur
    .local pmc match
    .lex "$/", match
    length rx2110_eos, rx2110_tgt
    gt rx2110_pos, rx2110_eos, rx2110_done
    set rx2110_off, 0
    lt rx2110_pos, 2, rx2110_start
    sub rx2110_off, rx2110_pos, 1
    substr rx2110_tgt, rx2110_tgt, rx2110_off
  rx2110_start:
    eq $I10, 1, rx2110_restart
    if_null rx2110_debug, debug_1505
    rx2110_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1505:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2111_done
    goto rxscan2111_scan
  rxscan2111_loop:
    (rx2110_pos) = rx2110_cur."from"()
    inc rx2110_pos
    rx2110_cur."!cursor_from"(rx2110_pos)
    ge rx2110_pos, rx2110_eos, rxscan2111_done
  rxscan2111_scan:
    set_addr $I10, rxscan2111_loop
    rx2110_cur."!mark_push"(0, rx2110_pos, $I10)
  rxscan2111_done:
.annotate 'line', 1124
  # rx subcapture "sym"
    set_addr $I10, rxcap_2112_fail
    rx2110_cur."!mark_push"(0, rx2110_pos, $I10)
  # rx literal  "++"
    add $I11, rx2110_pos, 2
    gt $I11, rx2110_eos, rx2110_fail
    sub $I11, rx2110_pos, rx2110_off
    substr $S10, rx2110_tgt, $I11, 2
    ne $S10, "++", rx2110_fail
    add rx2110_pos, 2
    set_addr $I10, rxcap_2112_fail
    ($I12, $I11) = rx2110_cur."!mark_peek"($I10)
    rx2110_cur."!cursor_pos"($I11)
    ($P10) = rx2110_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2110_pos, "")
    rx2110_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2112_done
  rxcap_2112_fail:
    goto rx2110_fail
  rxcap_2112_done:
  # rx subrule "O" subtype=capture negate=
    rx2110_cur."!cursor_pos"(rx2110_pos)
    $P10 = rx2110_cur."O"("%autoincrement")
    unless $P10, rx2110_fail
    rx2110_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2110_pos = $P10."pos"()
  # rx pass
    rx2110_cur."!cursor_pass"(rx2110_pos, "postfix:sym<++>")
    if_null rx2110_debug, debug_1506
    rx2110_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx2110_pos)
  debug_1506:
    .return (rx2110_cur)
  rx2110_restart:
.annotate 'line', 462
    if_null rx2110_debug, debug_1507
    rx2110_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1507:
  rx2110_fail:
    (rx2110_rep, rx2110_pos, $I10, $P10) = rx2110_cur."!mark_fail"(0)
    lt rx2110_pos, -1, rx2110_done
    eq rx2110_pos, -1, rx2110_fail
    jump $I10
  rx2110_done:
    rx2110_cur."!cursor_fail"()
    if_null rx2110_debug, debug_1508
    rx2110_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1508:
    .return (rx2110_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("334_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "++")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("335_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2115_tgt
    .local int rx2115_pos
    .local int rx2115_off
    .local int rx2115_eos
    .local int rx2115_rep
    .local pmc rx2115_cur
    .local pmc rx2115_debug
    (rx2115_cur, rx2115_pos, rx2115_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2115_cur
    .local pmc match
    .lex "$/", match
    length rx2115_eos, rx2115_tgt
    gt rx2115_pos, rx2115_eos, rx2115_done
    set rx2115_off, 0
    lt rx2115_pos, 2, rx2115_start
    sub rx2115_off, rx2115_pos, 1
    substr rx2115_tgt, rx2115_tgt, rx2115_off
  rx2115_start:
    eq $I10, 1, rx2115_restart
    if_null rx2115_debug, debug_1509
    rx2115_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1509:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2116_done
    goto rxscan2116_scan
  rxscan2116_loop:
    (rx2115_pos) = rx2115_cur."from"()
    inc rx2115_pos
    rx2115_cur."!cursor_from"(rx2115_pos)
    ge rx2115_pos, rx2115_eos, rxscan2116_done
  rxscan2116_scan:
    set_addr $I10, rxscan2116_loop
    rx2115_cur."!mark_push"(0, rx2115_pos, $I10)
  rxscan2116_done:
.annotate 'line', 1125
  # rx subcapture "sym"
    set_addr $I10, rxcap_2117_fail
    rx2115_cur."!mark_push"(0, rx2115_pos, $I10)
  # rx literal  "--"
    add $I11, rx2115_pos, 2
    gt $I11, rx2115_eos, rx2115_fail
    sub $I11, rx2115_pos, rx2115_off
    substr $S10, rx2115_tgt, $I11, 2
    ne $S10, "--", rx2115_fail
    add rx2115_pos, 2
    set_addr $I10, rxcap_2117_fail
    ($I12, $I11) = rx2115_cur."!mark_peek"($I10)
    rx2115_cur."!cursor_pos"($I11)
    ($P10) = rx2115_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2115_pos, "")
    rx2115_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2117_done
  rxcap_2117_fail:
    goto rx2115_fail
  rxcap_2117_done:
  # rx subrule "O" subtype=capture negate=
    rx2115_cur."!cursor_pos"(rx2115_pos)
    $P10 = rx2115_cur."O"("%autoincrement")
    unless $P10, rx2115_fail
    rx2115_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2115_pos = $P10."pos"()
  # rx pass
    rx2115_cur."!cursor_pass"(rx2115_pos, "postfix:sym<-->")
    if_null rx2115_debug, debug_1510
    rx2115_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx2115_pos)
  debug_1510:
    .return (rx2115_cur)
  rx2115_restart:
.annotate 'line', 462
    if_null rx2115_debug, debug_1511
    rx2115_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1511:
  rx2115_fail:
    (rx2115_rep, rx2115_pos, $I10, $P10) = rx2115_cur."!mark_fail"(0)
    lt rx2115_pos, -1, rx2115_done
    eq rx2115_pos, -1, rx2115_fail
    jump $I10
  rx2115_done:
    rx2115_cur."!cursor_fail"()
    if_null rx2115_debug, debug_1512
    rx2115_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1512:
    .return (rx2115_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("336_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "--")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("337_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2120_tgt
    .local int rx2120_pos
    .local int rx2120_off
    .local int rx2120_eos
    .local int rx2120_rep
    .local pmc rx2120_cur
    .local pmc rx2120_debug
    (rx2120_cur, rx2120_pos, rx2120_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2120_cur
    .local pmc match
    .lex "$/", match
    length rx2120_eos, rx2120_tgt
    gt rx2120_pos, rx2120_eos, rx2120_done
    set rx2120_off, 0
    lt rx2120_pos, 2, rx2120_start
    sub rx2120_off, rx2120_pos, 1
    substr rx2120_tgt, rx2120_tgt, rx2120_off
  rx2120_start:
    eq $I10, 1, rx2120_restart
    if_null rx2120_debug, debug_1513
    rx2120_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1513:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2121_done
    goto rxscan2121_scan
  rxscan2121_loop:
    (rx2120_pos) = rx2120_cur."from"()
    inc rx2120_pos
    rx2120_cur."!cursor_from"(rx2120_pos)
    ge rx2120_pos, rx2120_eos, rxscan2121_done
  rxscan2121_scan:
    set_addr $I10, rxscan2121_loop
    rx2120_cur."!mark_push"(0, rx2120_pos, $I10)
  rxscan2121_done:
.annotate 'line', 1127
  # rx subcapture "sym"
    set_addr $I10, rxcap_2122_fail
    rx2120_cur."!mark_push"(0, rx2120_pos, $I10)
  # rx literal  "**"
    add $I11, rx2120_pos, 2
    gt $I11, rx2120_eos, rx2120_fail
    sub $I11, rx2120_pos, rx2120_off
    substr $S10, rx2120_tgt, $I11, 2
    ne $S10, "**", rx2120_fail
    add rx2120_pos, 2
    set_addr $I10, rxcap_2122_fail
    ($I12, $I11) = rx2120_cur."!mark_peek"($I10)
    rx2120_cur."!cursor_pos"($I11)
    ($P10) = rx2120_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2120_pos, "")
    rx2120_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2122_done
  rxcap_2122_fail:
    goto rx2120_fail
  rxcap_2122_done:
  # rx subrule "O" subtype=capture negate=
    rx2120_cur."!cursor_pos"(rx2120_pos)
    $P10 = rx2120_cur."O"("%exponentiation, :pirop<pow__NNN>")
    unless $P10, rx2120_fail
    rx2120_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2120_pos = $P10."pos"()
  # rx pass
    rx2120_cur."!cursor_pass"(rx2120_pos, "infix:sym<**>")
    if_null rx2120_debug, debug_1514
    rx2120_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx2120_pos)
  debug_1514:
    .return (rx2120_cur)
  rx2120_restart:
.annotate 'line', 462
    if_null rx2120_debug, debug_1515
    rx2120_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1515:
  rx2120_fail:
    (rx2120_rep, rx2120_pos, $I10, $P10) = rx2120_cur."!mark_fail"(0)
    lt rx2120_pos, -1, rx2120_done
    eq rx2120_pos, -1, rx2120_fail
    jump $I10
  rx2120_done:
    rx2120_cur."!cursor_fail"()
    if_null rx2120_debug, debug_1516
    rx2120_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1516:
    .return (rx2120_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("338_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "**")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("339_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2125_tgt
    .local int rx2125_pos
    .local int rx2125_off
    .local int rx2125_eos
    .local int rx2125_rep
    .local pmc rx2125_cur
    .local pmc rx2125_debug
    (rx2125_cur, rx2125_pos, rx2125_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2125_cur
    .local pmc match
    .lex "$/", match
    length rx2125_eos, rx2125_tgt
    gt rx2125_pos, rx2125_eos, rx2125_done
    set rx2125_off, 0
    lt rx2125_pos, 2, rx2125_start
    sub rx2125_off, rx2125_pos, 1
    substr rx2125_tgt, rx2125_tgt, rx2125_off
  rx2125_start:
    eq $I10, 1, rx2125_restart
    if_null rx2125_debug, debug_1517
    rx2125_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1517:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2126_done
    goto rxscan2126_scan
  rxscan2126_loop:
    (rx2125_pos) = rx2125_cur."from"()
    inc rx2125_pos
    rx2125_cur."!cursor_from"(rx2125_pos)
    ge rx2125_pos, rx2125_eos, rxscan2126_done
  rxscan2126_scan:
    set_addr $I10, rxscan2126_loop
    rx2125_cur."!mark_push"(0, rx2125_pos, $I10)
  rxscan2126_done:
.annotate 'line', 1129
  # rx subcapture "sym"
    set_addr $I10, rxcap_2127_fail
    rx2125_cur."!mark_push"(0, rx2125_pos, $I10)
  # rx literal  "+"
    add $I11, rx2125_pos, 1
    gt $I11, rx2125_eos, rx2125_fail
    sub $I11, rx2125_pos, rx2125_off
    ord $I11, rx2125_tgt, $I11
    ne $I11, 43, rx2125_fail
    add rx2125_pos, 1
    set_addr $I10, rxcap_2127_fail
    ($I12, $I11) = rx2125_cur."!mark_peek"($I10)
    rx2125_cur."!cursor_pos"($I11)
    ($P10) = rx2125_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2125_pos, "")
    rx2125_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2127_done
  rxcap_2127_fail:
    goto rx2125_fail
  rxcap_2127_done:
  # rx subrule "O" subtype=capture negate=
    rx2125_cur."!cursor_pos"(rx2125_pos)
    $P10 = rx2125_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx2125_fail
    rx2125_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2125_pos = $P10."pos"()
  # rx pass
    rx2125_cur."!cursor_pass"(rx2125_pos, "prefix:sym<+>")
    if_null rx2125_debug, debug_1518
    rx2125_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx2125_pos)
  debug_1518:
    .return (rx2125_cur)
  rx2125_restart:
.annotate 'line', 462
    if_null rx2125_debug, debug_1519
    rx2125_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1519:
  rx2125_fail:
    (rx2125_rep, rx2125_pos, $I10, $P10) = rx2125_cur."!mark_fail"(0)
    lt rx2125_pos, -1, rx2125_done
    eq rx2125_pos, -1, rx2125_fail
    jump $I10
  rx2125_done:
    rx2125_cur."!cursor_fail"()
    if_null rx2125_debug, debug_1520
    rx2125_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1520:
    .return (rx2125_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("340_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "+")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("341_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2130_tgt
    .local int rx2130_pos
    .local int rx2130_off
    .local int rx2130_eos
    .local int rx2130_rep
    .local pmc rx2130_cur
    .local pmc rx2130_debug
    (rx2130_cur, rx2130_pos, rx2130_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2130_cur
    .local pmc match
    .lex "$/", match
    length rx2130_eos, rx2130_tgt
    gt rx2130_pos, rx2130_eos, rx2130_done
    set rx2130_off, 0
    lt rx2130_pos, 2, rx2130_start
    sub rx2130_off, rx2130_pos, 1
    substr rx2130_tgt, rx2130_tgt, rx2130_off
  rx2130_start:
    eq $I10, 1, rx2130_restart
    if_null rx2130_debug, debug_1521
    rx2130_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1521:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2131_done
    goto rxscan2131_scan
  rxscan2131_loop:
    (rx2130_pos) = rx2130_cur."from"()
    inc rx2130_pos
    rx2130_cur."!cursor_from"(rx2130_pos)
    ge rx2130_pos, rx2130_eos, rxscan2131_done
  rxscan2131_scan:
    set_addr $I10, rxscan2131_loop
    rx2130_cur."!mark_push"(0, rx2130_pos, $I10)
  rxscan2131_done:
.annotate 'line', 1130
  # rx subcapture "sym"
    set_addr $I10, rxcap_2132_fail
    rx2130_cur."!mark_push"(0, rx2130_pos, $I10)
  # rx literal  "~"
    add $I11, rx2130_pos, 1
    gt $I11, rx2130_eos, rx2130_fail
    sub $I11, rx2130_pos, rx2130_off
    ord $I11, rx2130_tgt, $I11
    ne $I11, 126, rx2130_fail
    add rx2130_pos, 1
    set_addr $I10, rxcap_2132_fail
    ($I12, $I11) = rx2130_cur."!mark_peek"($I10)
    rx2130_cur."!cursor_pos"($I11)
    ($P10) = rx2130_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2130_pos, "")
    rx2130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2132_done
  rxcap_2132_fail:
    goto rx2130_fail
  rxcap_2132_done:
  # rx subrule "O" subtype=capture negate=
    rx2130_cur."!cursor_pos"(rx2130_pos)
    $P10 = rx2130_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx2130_fail
    rx2130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2130_pos = $P10."pos"()
  # rx pass
    rx2130_cur."!cursor_pass"(rx2130_pos, "prefix:sym<~>")
    if_null rx2130_debug, debug_1522
    rx2130_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx2130_pos)
  debug_1522:
    .return (rx2130_cur)
  rx2130_restart:
.annotate 'line', 462
    if_null rx2130_debug, debug_1523
    rx2130_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1523:
  rx2130_fail:
    (rx2130_rep, rx2130_pos, $I10, $P10) = rx2130_cur."!mark_fail"(0)
    lt rx2130_pos, -1, rx2130_done
    eq rx2130_pos, -1, rx2130_fail
    jump $I10
  rx2130_done:
    rx2130_cur."!cursor_fail"()
    if_null rx2130_debug, debug_1524
    rx2130_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1524:
    .return (rx2130_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("342_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("343_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2135_tgt
    .local int rx2135_pos
    .local int rx2135_off
    .local int rx2135_eos
    .local int rx2135_rep
    .local pmc rx2135_cur
    .local pmc rx2135_debug
    (rx2135_cur, rx2135_pos, rx2135_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2135_cur
    .local pmc match
    .lex "$/", match
    length rx2135_eos, rx2135_tgt
    gt rx2135_pos, rx2135_eos, rx2135_done
    set rx2135_off, 0
    lt rx2135_pos, 2, rx2135_start
    sub rx2135_off, rx2135_pos, 1
    substr rx2135_tgt, rx2135_tgt, rx2135_off
  rx2135_start:
    eq $I10, 1, rx2135_restart
    if_null rx2135_debug, debug_1525
    rx2135_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1525:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2136_done
    goto rxscan2136_scan
  rxscan2136_loop:
    (rx2135_pos) = rx2135_cur."from"()
    inc rx2135_pos
    rx2135_cur."!cursor_from"(rx2135_pos)
    ge rx2135_pos, rx2135_eos, rxscan2136_done
  rxscan2136_scan:
    set_addr $I10, rxscan2136_loop
    rx2135_cur."!mark_push"(0, rx2135_pos, $I10)
  rxscan2136_done:
.annotate 'line', 1131
  # rx subcapture "sym"
    set_addr $I10, rxcap_2137_fail
    rx2135_cur."!mark_push"(0, rx2135_pos, $I10)
  # rx literal  "-"
    add $I11, rx2135_pos, 1
    gt $I11, rx2135_eos, rx2135_fail
    sub $I11, rx2135_pos, rx2135_off
    ord $I11, rx2135_tgt, $I11
    ne $I11, 45, rx2135_fail
    add rx2135_pos, 1
    set_addr $I10, rxcap_2137_fail
    ($I12, $I11) = rx2135_cur."!mark_peek"($I10)
    rx2135_cur."!cursor_pos"($I11)
    ($P10) = rx2135_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2135_pos, "")
    rx2135_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2137_done
  rxcap_2137_fail:
    goto rx2135_fail
  rxcap_2137_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx2135_pos, rx2135_off
    substr $S10, rx2135_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx2135_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx2135_cur."!cursor_pos"(rx2135_pos)
    $P10 = rx2135_cur."number"()
    if $P10, rx2135_fail
  # rx subrule "O" subtype=capture negate=
    rx2135_cur."!cursor_pos"(rx2135_pos)
    $P10 = rx2135_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx2135_fail
    rx2135_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2135_pos = $P10."pos"()
  # rx pass
    rx2135_cur."!cursor_pass"(rx2135_pos, "prefix:sym<->")
    if_null rx2135_debug, debug_1526
    rx2135_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx2135_pos)
  debug_1526:
    .return (rx2135_cur)
  rx2135_restart:
.annotate 'line', 462
    if_null rx2135_debug, debug_1527
    rx2135_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1527:
  rx2135_fail:
    (rx2135_rep, rx2135_pos, $I10, $P10) = rx2135_cur."!mark_fail"(0)
    lt rx2135_pos, -1, rx2135_done
    eq rx2135_pos, -1, rx2135_fail
    jump $I10
  rx2135_done:
    rx2135_cur."!cursor_fail"()
    if_null rx2135_debug, debug_1528
    rx2135_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1528:
    .return (rx2135_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("344_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "-"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("345_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2140_tgt
    .local int rx2140_pos
    .local int rx2140_off
    .local int rx2140_eos
    .local int rx2140_rep
    .local pmc rx2140_cur
    .local pmc rx2140_debug
    (rx2140_cur, rx2140_pos, rx2140_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2140_cur
    .local pmc match
    .lex "$/", match
    length rx2140_eos, rx2140_tgt
    gt rx2140_pos, rx2140_eos, rx2140_done
    set rx2140_off, 0
    lt rx2140_pos, 2, rx2140_start
    sub rx2140_off, rx2140_pos, 1
    substr rx2140_tgt, rx2140_tgt, rx2140_off
  rx2140_start:
    eq $I10, 1, rx2140_restart
    if_null rx2140_debug, debug_1529
    rx2140_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1529:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2141_done
    goto rxscan2141_scan
  rxscan2141_loop:
    (rx2140_pos) = rx2140_cur."from"()
    inc rx2140_pos
    rx2140_cur."!cursor_from"(rx2140_pos)
    ge rx2140_pos, rx2140_eos, rxscan2141_done
  rxscan2141_scan:
    set_addr $I10, rxscan2141_loop
    rx2140_cur."!mark_push"(0, rx2140_pos, $I10)
  rxscan2141_done:
.annotate 'line', 1132
  # rx subcapture "sym"
    set_addr $I10, rxcap_2142_fail
    rx2140_cur."!mark_push"(0, rx2140_pos, $I10)
  # rx literal  "?"
    add $I11, rx2140_pos, 1
    gt $I11, rx2140_eos, rx2140_fail
    sub $I11, rx2140_pos, rx2140_off
    ord $I11, rx2140_tgt, $I11
    ne $I11, 63, rx2140_fail
    add rx2140_pos, 1
    set_addr $I10, rxcap_2142_fail
    ($I12, $I11) = rx2140_cur."!mark_peek"($I10)
    rx2140_cur."!cursor_pos"($I11)
    ($P10) = rx2140_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2140_pos, "")
    rx2140_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2142_done
  rxcap_2142_fail:
    goto rx2140_fail
  rxcap_2142_done:
  # rx subrule "O" subtype=capture negate=
    rx2140_cur."!cursor_pos"(rx2140_pos)
    $P10 = rx2140_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx2140_fail
    rx2140_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2140_pos = $P10."pos"()
  # rx pass
    rx2140_cur."!cursor_pass"(rx2140_pos, "prefix:sym<?>")
    if_null rx2140_debug, debug_1530
    rx2140_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx2140_pos)
  debug_1530:
    .return (rx2140_cur)
  rx2140_restart:
.annotate 'line', 462
    if_null rx2140_debug, debug_1531
    rx2140_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1531:
  rx2140_fail:
    (rx2140_rep, rx2140_pos, $I10, $P10) = rx2140_cur."!mark_fail"(0)
    lt rx2140_pos, -1, rx2140_done
    eq rx2140_pos, -1, rx2140_fail
    jump $I10
  rx2140_done:
    rx2140_cur."!cursor_fail"()
    if_null rx2140_debug, debug_1532
    rx2140_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1532:
    .return (rx2140_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("346_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "?")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("347_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2145_tgt
    .local int rx2145_pos
    .local int rx2145_off
    .local int rx2145_eos
    .local int rx2145_rep
    .local pmc rx2145_cur
    .local pmc rx2145_debug
    (rx2145_cur, rx2145_pos, rx2145_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2145_cur
    .local pmc match
    .lex "$/", match
    length rx2145_eos, rx2145_tgt
    gt rx2145_pos, rx2145_eos, rx2145_done
    set rx2145_off, 0
    lt rx2145_pos, 2, rx2145_start
    sub rx2145_off, rx2145_pos, 1
    substr rx2145_tgt, rx2145_tgt, rx2145_off
  rx2145_start:
    eq $I10, 1, rx2145_restart
    if_null rx2145_debug, debug_1533
    rx2145_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1533:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2146_done
    goto rxscan2146_scan
  rxscan2146_loop:
    (rx2145_pos) = rx2145_cur."from"()
    inc rx2145_pos
    rx2145_cur."!cursor_from"(rx2145_pos)
    ge rx2145_pos, rx2145_eos, rxscan2146_done
  rxscan2146_scan:
    set_addr $I10, rxscan2146_loop
    rx2145_cur."!mark_push"(0, rx2145_pos, $I10)
  rxscan2146_done:
.annotate 'line', 1133
  # rx subcapture "sym"
    set_addr $I10, rxcap_2147_fail
    rx2145_cur."!mark_push"(0, rx2145_pos, $I10)
  # rx literal  "!"
    add $I11, rx2145_pos, 1
    gt $I11, rx2145_eos, rx2145_fail
    sub $I11, rx2145_pos, rx2145_off
    ord $I11, rx2145_tgt, $I11
    ne $I11, 33, rx2145_fail
    add rx2145_pos, 1
    set_addr $I10, rxcap_2147_fail
    ($I12, $I11) = rx2145_cur."!mark_peek"($I10)
    rx2145_cur."!cursor_pos"($I11)
    ($P10) = rx2145_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2145_pos, "")
    rx2145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2147_done
  rxcap_2147_fail:
    goto rx2145_fail
  rxcap_2147_done:
  # rx subrule "O" subtype=capture negate=
    rx2145_cur."!cursor_pos"(rx2145_pos)
    $P10 = rx2145_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx2145_fail
    rx2145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2145_pos = $P10."pos"()
  # rx pass
    rx2145_cur."!cursor_pass"(rx2145_pos, "prefix:sym<!>")
    if_null rx2145_debug, debug_1534
    rx2145_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx2145_pos)
  debug_1534:
    .return (rx2145_cur)
  rx2145_restart:
.annotate 'line', 462
    if_null rx2145_debug, debug_1535
    rx2145_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1535:
  rx2145_fail:
    (rx2145_rep, rx2145_pos, $I10, $P10) = rx2145_cur."!mark_fail"(0)
    lt rx2145_pos, -1, rx2145_done
    eq rx2145_pos, -1, rx2145_fail
    jump $I10
  rx2145_done:
    rx2145_cur."!cursor_fail"()
    if_null rx2145_debug, debug_1536
    rx2145_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1536:
    .return (rx2145_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("348_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "!")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("349_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2150_tgt
    .local int rx2150_pos
    .local int rx2150_off
    .local int rx2150_eos
    .local int rx2150_rep
    .local pmc rx2150_cur
    .local pmc rx2150_debug
    (rx2150_cur, rx2150_pos, rx2150_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2150_cur
    .local pmc match
    .lex "$/", match
    length rx2150_eos, rx2150_tgt
    gt rx2150_pos, rx2150_eos, rx2150_done
    set rx2150_off, 0
    lt rx2150_pos, 2, rx2150_start
    sub rx2150_off, rx2150_pos, 1
    substr rx2150_tgt, rx2150_tgt, rx2150_off
  rx2150_start:
    eq $I10, 1, rx2150_restart
    if_null rx2150_debug, debug_1537
    rx2150_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1537:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2151_done
    goto rxscan2151_scan
  rxscan2151_loop:
    (rx2150_pos) = rx2150_cur."from"()
    inc rx2150_pos
    rx2150_cur."!cursor_from"(rx2150_pos)
    ge rx2150_pos, rx2150_eos, rxscan2151_done
  rxscan2151_scan:
    set_addr $I10, rxscan2151_loop
    rx2150_cur."!mark_push"(0, rx2150_pos, $I10)
  rxscan2151_done:
.annotate 'line', 1134
  # rx subcapture "sym"
    set_addr $I10, rxcap_2152_fail
    rx2150_cur."!mark_push"(0, rx2150_pos, $I10)
  # rx literal  "|"
    add $I11, rx2150_pos, 1
    gt $I11, rx2150_eos, rx2150_fail
    sub $I11, rx2150_pos, rx2150_off
    ord $I11, rx2150_tgt, $I11
    ne $I11, 124, rx2150_fail
    add rx2150_pos, 1
    set_addr $I10, rxcap_2152_fail
    ($I12, $I11) = rx2150_cur."!mark_peek"($I10)
    rx2150_cur."!cursor_pos"($I11)
    ($P10) = rx2150_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2150_pos, "")
    rx2150_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2152_done
  rxcap_2152_fail:
    goto rx2150_fail
  rxcap_2152_done:
  # rx subrule "O" subtype=capture negate=
    rx2150_cur."!cursor_pos"(rx2150_pos)
    $P10 = rx2150_cur."O"("%symbolic_unary")
    unless $P10, rx2150_fail
    rx2150_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2150_pos = $P10."pos"()
  # rx pass
    rx2150_cur."!cursor_pass"(rx2150_pos, "prefix:sym<|>")
    if_null rx2150_debug, debug_1538
    rx2150_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx2150_pos)
  debug_1538:
    .return (rx2150_cur)
  rx2150_restart:
.annotate 'line', 462
    if_null rx2150_debug, debug_1539
    rx2150_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1539:
  rx2150_fail:
    (rx2150_rep, rx2150_pos, $I10, $P10) = rx2150_cur."!mark_fail"(0)
    lt rx2150_pos, -1, rx2150_done
    eq rx2150_pos, -1, rx2150_fail
    jump $I10
  rx2150_done:
    rx2150_cur."!cursor_fail"()
    if_null rx2150_debug, debug_1540
    rx2150_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1540:
    .return (rx2150_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("350_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "|")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("351_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2155_tgt
    .local int rx2155_pos
    .local int rx2155_off
    .local int rx2155_eos
    .local int rx2155_rep
    .local pmc rx2155_cur
    .local pmc rx2155_debug
    (rx2155_cur, rx2155_pos, rx2155_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2155_cur
    .local pmc match
    .lex "$/", match
    length rx2155_eos, rx2155_tgt
    gt rx2155_pos, rx2155_eos, rx2155_done
    set rx2155_off, 0
    lt rx2155_pos, 2, rx2155_start
    sub rx2155_off, rx2155_pos, 1
    substr rx2155_tgt, rx2155_tgt, rx2155_off
  rx2155_start:
    eq $I10, 1, rx2155_restart
    if_null rx2155_debug, debug_1541
    rx2155_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1541:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2156_done
    goto rxscan2156_scan
  rxscan2156_loop:
    (rx2155_pos) = rx2155_cur."from"()
    inc rx2155_pos
    rx2155_cur."!cursor_from"(rx2155_pos)
    ge rx2155_pos, rx2155_eos, rxscan2156_done
  rxscan2156_scan:
    set_addr $I10, rxscan2156_loop
    rx2155_cur."!mark_push"(0, rx2155_pos, $I10)
  rxscan2156_done:
.annotate 'line', 1136
  # rx subcapture "sym"
    set_addr $I10, rxcap_2157_fail
    rx2155_cur."!mark_push"(0, rx2155_pos, $I10)
  # rx literal  "*"
    add $I11, rx2155_pos, 1
    gt $I11, rx2155_eos, rx2155_fail
    sub $I11, rx2155_pos, rx2155_off
    ord $I11, rx2155_tgt, $I11
    ne $I11, 42, rx2155_fail
    add rx2155_pos, 1
    set_addr $I10, rxcap_2157_fail
    ($I12, $I11) = rx2155_cur."!mark_peek"($I10)
    rx2155_cur."!cursor_pos"($I11)
    ($P10) = rx2155_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2155_pos, "")
    rx2155_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2157_done
  rxcap_2157_fail:
    goto rx2155_fail
  rxcap_2157_done:
  # rx subrule "O" subtype=capture negate=
    rx2155_cur."!cursor_pos"(rx2155_pos)
    $P10 = rx2155_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx2155_fail
    rx2155_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2155_pos = $P10."pos"()
  # rx pass
    rx2155_cur."!cursor_pass"(rx2155_pos, "infix:sym<*>")
    if_null rx2155_debug, debug_1542
    rx2155_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx2155_pos)
  debug_1542:
    .return (rx2155_cur)
  rx2155_restart:
.annotate 'line', 462
    if_null rx2155_debug, debug_1543
    rx2155_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1543:
  rx2155_fail:
    (rx2155_rep, rx2155_pos, $I10, $P10) = rx2155_cur."!mark_fail"(0)
    lt rx2155_pos, -1, rx2155_done
    eq rx2155_pos, -1, rx2155_fail
    jump $I10
  rx2155_done:
    rx2155_cur."!cursor_fail"()
    if_null rx2155_debug, debug_1544
    rx2155_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1544:
    .return (rx2155_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("352_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "*")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("353_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2160_tgt
    .local int rx2160_pos
    .local int rx2160_off
    .local int rx2160_eos
    .local int rx2160_rep
    .local pmc rx2160_cur
    .local pmc rx2160_debug
    (rx2160_cur, rx2160_pos, rx2160_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2160_cur
    .local pmc match
    .lex "$/", match
    length rx2160_eos, rx2160_tgt
    gt rx2160_pos, rx2160_eos, rx2160_done
    set rx2160_off, 0
    lt rx2160_pos, 2, rx2160_start
    sub rx2160_off, rx2160_pos, 1
    substr rx2160_tgt, rx2160_tgt, rx2160_off
  rx2160_start:
    eq $I10, 1, rx2160_restart
    if_null rx2160_debug, debug_1545
    rx2160_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1545:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2161_done
    goto rxscan2161_scan
  rxscan2161_loop:
    (rx2160_pos) = rx2160_cur."from"()
    inc rx2160_pos
    rx2160_cur."!cursor_from"(rx2160_pos)
    ge rx2160_pos, rx2160_eos, rxscan2161_done
  rxscan2161_scan:
    set_addr $I10, rxscan2161_loop
    rx2160_cur."!mark_push"(0, rx2160_pos, $I10)
  rxscan2161_done:
.annotate 'line', 1137
  # rx subcapture "sym"
    set_addr $I10, rxcap_2162_fail
    rx2160_cur."!mark_push"(0, rx2160_pos, $I10)
  # rx literal  "/"
    add $I11, rx2160_pos, 1
    gt $I11, rx2160_eos, rx2160_fail
    sub $I11, rx2160_pos, rx2160_off
    ord $I11, rx2160_tgt, $I11
    ne $I11, 47, rx2160_fail
    add rx2160_pos, 1
    set_addr $I10, rxcap_2162_fail
    ($I12, $I11) = rx2160_cur."!mark_peek"($I10)
    rx2160_cur."!cursor_pos"($I11)
    ($P10) = rx2160_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2160_pos, "")
    rx2160_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2162_done
  rxcap_2162_fail:
    goto rx2160_fail
  rxcap_2162_done:
  # rx subrule "O" subtype=capture negate=
    rx2160_cur."!cursor_pos"(rx2160_pos)
    $P10 = rx2160_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx2160_fail
    rx2160_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2160_pos = $P10."pos"()
  # rx pass
    rx2160_cur."!cursor_pass"(rx2160_pos, "infix:sym</>")
    if_null rx2160_debug, debug_1546
    rx2160_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx2160_pos)
  debug_1546:
    .return (rx2160_cur)
  rx2160_restart:
.annotate 'line', 462
    if_null rx2160_debug, debug_1547
    rx2160_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1547:
  rx2160_fail:
    (rx2160_rep, rx2160_pos, $I10, $P10) = rx2160_cur."!mark_fail"(0)
    lt rx2160_pos, -1, rx2160_done
    eq rx2160_pos, -1, rx2160_fail
    jump $I10
  rx2160_done:
    rx2160_cur."!cursor_fail"()
    if_null rx2160_debug, debug_1548
    rx2160_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1548:
    .return (rx2160_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("354_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "/")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("355_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2165_tgt
    .local int rx2165_pos
    .local int rx2165_off
    .local int rx2165_eos
    .local int rx2165_rep
    .local pmc rx2165_cur
    .local pmc rx2165_debug
    (rx2165_cur, rx2165_pos, rx2165_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2165_cur
    .local pmc match
    .lex "$/", match
    length rx2165_eos, rx2165_tgt
    gt rx2165_pos, rx2165_eos, rx2165_done
    set rx2165_off, 0
    lt rx2165_pos, 2, rx2165_start
    sub rx2165_off, rx2165_pos, 1
    substr rx2165_tgt, rx2165_tgt, rx2165_off
  rx2165_start:
    eq $I10, 1, rx2165_restart
    if_null rx2165_debug, debug_1549
    rx2165_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1549:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2166_done
    goto rxscan2166_scan
  rxscan2166_loop:
    (rx2165_pos) = rx2165_cur."from"()
    inc rx2165_pos
    rx2165_cur."!cursor_from"(rx2165_pos)
    ge rx2165_pos, rx2165_eos, rxscan2166_done
  rxscan2166_scan:
    set_addr $I10, rxscan2166_loop
    rx2165_cur."!mark_push"(0, rx2165_pos, $I10)
  rxscan2166_done:
.annotate 'line', 1138
  # rx subcapture "sym"
    set_addr $I10, rxcap_2167_fail
    rx2165_cur."!mark_push"(0, rx2165_pos, $I10)
  # rx literal  "%"
    add $I11, rx2165_pos, 1
    gt $I11, rx2165_eos, rx2165_fail
    sub $I11, rx2165_pos, rx2165_off
    ord $I11, rx2165_tgt, $I11
    ne $I11, 37, rx2165_fail
    add rx2165_pos, 1
    set_addr $I10, rxcap_2167_fail
    ($I12, $I11) = rx2165_cur."!mark_peek"($I10)
    rx2165_cur."!cursor_pos"($I11)
    ($P10) = rx2165_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2165_pos, "")
    rx2165_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2167_done
  rxcap_2167_fail:
    goto rx2165_fail
  rxcap_2167_done:
  # rx subrule "O" subtype=capture negate=
    rx2165_cur."!cursor_pos"(rx2165_pos)
    $P10 = rx2165_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx2165_fail
    rx2165_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2165_pos = $P10."pos"()
  # rx pass
    rx2165_cur."!cursor_pass"(rx2165_pos, "infix:sym<%>")
    if_null rx2165_debug, debug_1550
    rx2165_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx2165_pos)
  debug_1550:
    .return (rx2165_cur)
  rx2165_restart:
.annotate 'line', 462
    if_null rx2165_debug, debug_1551
    rx2165_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1551:
  rx2165_fail:
    (rx2165_rep, rx2165_pos, $I10, $P10) = rx2165_cur."!mark_fail"(0)
    lt rx2165_pos, -1, rx2165_done
    eq rx2165_pos, -1, rx2165_fail
    jump $I10
  rx2165_done:
    rx2165_cur."!cursor_fail"()
    if_null rx2165_debug, debug_1552
    rx2165_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1552:
    .return (rx2165_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("356_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "%")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("357_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2170_tgt
    .local int rx2170_pos
    .local int rx2170_off
    .local int rx2170_eos
    .local int rx2170_rep
    .local pmc rx2170_cur
    .local pmc rx2170_debug
    (rx2170_cur, rx2170_pos, rx2170_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2170_cur
    .local pmc match
    .lex "$/", match
    length rx2170_eos, rx2170_tgt
    gt rx2170_pos, rx2170_eos, rx2170_done
    set rx2170_off, 0
    lt rx2170_pos, 2, rx2170_start
    sub rx2170_off, rx2170_pos, 1
    substr rx2170_tgt, rx2170_tgt, rx2170_off
  rx2170_start:
    eq $I10, 1, rx2170_restart
    if_null rx2170_debug, debug_1553
    rx2170_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1553:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2171_done
    goto rxscan2171_scan
  rxscan2171_loop:
    (rx2170_pos) = rx2170_cur."from"()
    inc rx2170_pos
    rx2170_cur."!cursor_from"(rx2170_pos)
    ge rx2170_pos, rx2170_eos, rxscan2171_done
  rxscan2171_scan:
    set_addr $I10, rxscan2171_loop
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
  rxscan2171_done:
.annotate 'line', 1139
  # rx subcapture "sym"
    set_addr $I10, rxcap_2172_fail
    rx2170_cur."!mark_push"(0, rx2170_pos, $I10)
  # rx literal  "+&"
    add $I11, rx2170_pos, 2
    gt $I11, rx2170_eos, rx2170_fail
    sub $I11, rx2170_pos, rx2170_off
    substr $S10, rx2170_tgt, $I11, 2
    ne $S10, "+&", rx2170_fail
    add rx2170_pos, 2
    set_addr $I10, rxcap_2172_fail
    ($I12, $I11) = rx2170_cur."!mark_peek"($I10)
    rx2170_cur."!cursor_pos"($I11)
    ($P10) = rx2170_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2170_pos, "")
    rx2170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2172_done
  rxcap_2172_fail:
    goto rx2170_fail
  rxcap_2172_done:
  # rx subrule "O" subtype=capture negate=
    rx2170_cur."!cursor_pos"(rx2170_pos)
    $P10 = rx2170_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx2170_fail
    rx2170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2170_pos = $P10."pos"()
  # rx pass
    rx2170_cur."!cursor_pass"(rx2170_pos, "infix:sym<+&>")
    if_null rx2170_debug, debug_1554
    rx2170_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx2170_pos)
  debug_1554:
    .return (rx2170_cur)
  rx2170_restart:
.annotate 'line', 462
    if_null rx2170_debug, debug_1555
    rx2170_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1555:
  rx2170_fail:
    (rx2170_rep, rx2170_pos, $I10, $P10) = rx2170_cur."!mark_fail"(0)
    lt rx2170_pos, -1, rx2170_done
    eq rx2170_pos, -1, rx2170_fail
    jump $I10
  rx2170_done:
    rx2170_cur."!cursor_fail"()
    if_null rx2170_debug, debug_1556
    rx2170_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1556:
    .return (rx2170_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("358_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "+&")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("359_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2175_tgt
    .local int rx2175_pos
    .local int rx2175_off
    .local int rx2175_eos
    .local int rx2175_rep
    .local pmc rx2175_cur
    .local pmc rx2175_debug
    (rx2175_cur, rx2175_pos, rx2175_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2175_cur
    .local pmc match
    .lex "$/", match
    length rx2175_eos, rx2175_tgt
    gt rx2175_pos, rx2175_eos, rx2175_done
    set rx2175_off, 0
    lt rx2175_pos, 2, rx2175_start
    sub rx2175_off, rx2175_pos, 1
    substr rx2175_tgt, rx2175_tgt, rx2175_off
  rx2175_start:
    eq $I10, 1, rx2175_restart
    if_null rx2175_debug, debug_1557
    rx2175_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1557:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2176_done
    goto rxscan2176_scan
  rxscan2176_loop:
    (rx2175_pos) = rx2175_cur."from"()
    inc rx2175_pos
    rx2175_cur."!cursor_from"(rx2175_pos)
    ge rx2175_pos, rx2175_eos, rxscan2176_done
  rxscan2176_scan:
    set_addr $I10, rxscan2176_loop
    rx2175_cur."!mark_push"(0, rx2175_pos, $I10)
  rxscan2176_done:
.annotate 'line', 1141
  # rx subcapture "sym"
    set_addr $I10, rxcap_2177_fail
    rx2175_cur."!mark_push"(0, rx2175_pos, $I10)
  # rx literal  "+"
    add $I11, rx2175_pos, 1
    gt $I11, rx2175_eos, rx2175_fail
    sub $I11, rx2175_pos, rx2175_off
    ord $I11, rx2175_tgt, $I11
    ne $I11, 43, rx2175_fail
    add rx2175_pos, 1
    set_addr $I10, rxcap_2177_fail
    ($I12, $I11) = rx2175_cur."!mark_peek"($I10)
    rx2175_cur."!cursor_pos"($I11)
    ($P10) = rx2175_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2175_pos, "")
    rx2175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2177_done
  rxcap_2177_fail:
    goto rx2175_fail
  rxcap_2177_done:
  # rx subrule "O" subtype=capture negate=
    rx2175_cur."!cursor_pos"(rx2175_pos)
    $P10 = rx2175_cur."O"("%additive, :pirop<add>")
    unless $P10, rx2175_fail
    rx2175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2175_pos = $P10."pos"()
  # rx pass
    rx2175_cur."!cursor_pass"(rx2175_pos, "infix:sym<+>")
    if_null rx2175_debug, debug_1558
    rx2175_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx2175_pos)
  debug_1558:
    .return (rx2175_cur)
  rx2175_restart:
.annotate 'line', 462
    if_null rx2175_debug, debug_1559
    rx2175_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1559:
  rx2175_fail:
    (rx2175_rep, rx2175_pos, $I10, $P10) = rx2175_cur."!mark_fail"(0)
    lt rx2175_pos, -1, rx2175_done
    eq rx2175_pos, -1, rx2175_fail
    jump $I10
  rx2175_done:
    rx2175_cur."!cursor_fail"()
    if_null rx2175_debug, debug_1560
    rx2175_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1560:
    .return (rx2175_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("360_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "+")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("361_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2180_tgt
    .local int rx2180_pos
    .local int rx2180_off
    .local int rx2180_eos
    .local int rx2180_rep
    .local pmc rx2180_cur
    .local pmc rx2180_debug
    (rx2180_cur, rx2180_pos, rx2180_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2180_cur
    .local pmc match
    .lex "$/", match
    length rx2180_eos, rx2180_tgt
    gt rx2180_pos, rx2180_eos, rx2180_done
    set rx2180_off, 0
    lt rx2180_pos, 2, rx2180_start
    sub rx2180_off, rx2180_pos, 1
    substr rx2180_tgt, rx2180_tgt, rx2180_off
  rx2180_start:
    eq $I10, 1, rx2180_restart
    if_null rx2180_debug, debug_1561
    rx2180_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1561:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2181_done
    goto rxscan2181_scan
  rxscan2181_loop:
    (rx2180_pos) = rx2180_cur."from"()
    inc rx2180_pos
    rx2180_cur."!cursor_from"(rx2180_pos)
    ge rx2180_pos, rx2180_eos, rxscan2181_done
  rxscan2181_scan:
    set_addr $I10, rxscan2181_loop
    rx2180_cur."!mark_push"(0, rx2180_pos, $I10)
  rxscan2181_done:
.annotate 'line', 1142
  # rx subcapture "sym"
    set_addr $I10, rxcap_2182_fail
    rx2180_cur."!mark_push"(0, rx2180_pos, $I10)
  # rx literal  "-"
    add $I11, rx2180_pos, 1
    gt $I11, rx2180_eos, rx2180_fail
    sub $I11, rx2180_pos, rx2180_off
    ord $I11, rx2180_tgt, $I11
    ne $I11, 45, rx2180_fail
    add rx2180_pos, 1
    set_addr $I10, rxcap_2182_fail
    ($I12, $I11) = rx2180_cur."!mark_peek"($I10)
    rx2180_cur."!cursor_pos"($I11)
    ($P10) = rx2180_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2180_pos, "")
    rx2180_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2182_done
  rxcap_2182_fail:
    goto rx2180_fail
  rxcap_2182_done:
  # rx subrule "O" subtype=capture negate=
    rx2180_cur."!cursor_pos"(rx2180_pos)
    $P10 = rx2180_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx2180_fail
    rx2180_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2180_pos = $P10."pos"()
  # rx pass
    rx2180_cur."!cursor_pass"(rx2180_pos, "infix:sym<->")
    if_null rx2180_debug, debug_1562
    rx2180_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx2180_pos)
  debug_1562:
    .return (rx2180_cur)
  rx2180_restart:
.annotate 'line', 462
    if_null rx2180_debug, debug_1563
    rx2180_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1563:
  rx2180_fail:
    (rx2180_rep, rx2180_pos, $I10, $P10) = rx2180_cur."!mark_fail"(0)
    lt rx2180_pos, -1, rx2180_done
    eq rx2180_pos, -1, rx2180_fail
    jump $I10
  rx2180_done:
    rx2180_cur."!cursor_fail"()
    if_null rx2180_debug, debug_1564
    rx2180_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1564:
    .return (rx2180_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("362_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "-")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("363_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2185_tgt
    .local int rx2185_pos
    .local int rx2185_off
    .local int rx2185_eos
    .local int rx2185_rep
    .local pmc rx2185_cur
    .local pmc rx2185_debug
    (rx2185_cur, rx2185_pos, rx2185_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2185_cur
    .local pmc match
    .lex "$/", match
    length rx2185_eos, rx2185_tgt
    gt rx2185_pos, rx2185_eos, rx2185_done
    set rx2185_off, 0
    lt rx2185_pos, 2, rx2185_start
    sub rx2185_off, rx2185_pos, 1
    substr rx2185_tgt, rx2185_tgt, rx2185_off
  rx2185_start:
    eq $I10, 1, rx2185_restart
    if_null rx2185_debug, debug_1565
    rx2185_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1565:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2186_done
    goto rxscan2186_scan
  rxscan2186_loop:
    (rx2185_pos) = rx2185_cur."from"()
    inc rx2185_pos
    rx2185_cur."!cursor_from"(rx2185_pos)
    ge rx2185_pos, rx2185_eos, rxscan2186_done
  rxscan2186_scan:
    set_addr $I10, rxscan2186_loop
    rx2185_cur."!mark_push"(0, rx2185_pos, $I10)
  rxscan2186_done:
.annotate 'line', 1143
  # rx subcapture "sym"
    set_addr $I10, rxcap_2187_fail
    rx2185_cur."!mark_push"(0, rx2185_pos, $I10)
  # rx literal  "+|"
    add $I11, rx2185_pos, 2
    gt $I11, rx2185_eos, rx2185_fail
    sub $I11, rx2185_pos, rx2185_off
    substr $S10, rx2185_tgt, $I11, 2
    ne $S10, "+|", rx2185_fail
    add rx2185_pos, 2
    set_addr $I10, rxcap_2187_fail
    ($I12, $I11) = rx2185_cur."!mark_peek"($I10)
    rx2185_cur."!cursor_pos"($I11)
    ($P10) = rx2185_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2185_pos, "")
    rx2185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2187_done
  rxcap_2187_fail:
    goto rx2185_fail
  rxcap_2187_done:
  # rx subrule "O" subtype=capture negate=
    rx2185_cur."!cursor_pos"(rx2185_pos)
    $P10 = rx2185_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx2185_fail
    rx2185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2185_pos = $P10."pos"()
  # rx pass
    rx2185_cur."!cursor_pass"(rx2185_pos, "infix:sym<+|>")
    if_null rx2185_debug, debug_1566
    rx2185_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx2185_pos)
  debug_1566:
    .return (rx2185_cur)
  rx2185_restart:
.annotate 'line', 462
    if_null rx2185_debug, debug_1567
    rx2185_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1567:
  rx2185_fail:
    (rx2185_rep, rx2185_pos, $I10, $P10) = rx2185_cur."!mark_fail"(0)
    lt rx2185_pos, -1, rx2185_done
    eq rx2185_pos, -1, rx2185_fail
    jump $I10
  rx2185_done:
    rx2185_cur."!cursor_fail"()
    if_null rx2185_debug, debug_1568
    rx2185_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1568:
    .return (rx2185_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("364_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "+|")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("365_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2190_tgt
    .local int rx2190_pos
    .local int rx2190_off
    .local int rx2190_eos
    .local int rx2190_rep
    .local pmc rx2190_cur
    .local pmc rx2190_debug
    (rx2190_cur, rx2190_pos, rx2190_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2190_cur
    .local pmc match
    .lex "$/", match
    length rx2190_eos, rx2190_tgt
    gt rx2190_pos, rx2190_eos, rx2190_done
    set rx2190_off, 0
    lt rx2190_pos, 2, rx2190_start
    sub rx2190_off, rx2190_pos, 1
    substr rx2190_tgt, rx2190_tgt, rx2190_off
  rx2190_start:
    eq $I10, 1, rx2190_restart
    if_null rx2190_debug, debug_1569
    rx2190_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1569:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2191_done
    goto rxscan2191_scan
  rxscan2191_loop:
    (rx2190_pos) = rx2190_cur."from"()
    inc rx2190_pos
    rx2190_cur."!cursor_from"(rx2190_pos)
    ge rx2190_pos, rx2190_eos, rxscan2191_done
  rxscan2191_scan:
    set_addr $I10, rxscan2191_loop
    rx2190_cur."!mark_push"(0, rx2190_pos, $I10)
  rxscan2191_done:
.annotate 'line', 1144
  # rx subcapture "sym"
    set_addr $I10, rxcap_2192_fail
    rx2190_cur."!mark_push"(0, rx2190_pos, $I10)
  # rx literal  "+^"
    add $I11, rx2190_pos, 2
    gt $I11, rx2190_eos, rx2190_fail
    sub $I11, rx2190_pos, rx2190_off
    substr $S10, rx2190_tgt, $I11, 2
    ne $S10, "+^", rx2190_fail
    add rx2190_pos, 2
    set_addr $I10, rxcap_2192_fail
    ($I12, $I11) = rx2190_cur."!mark_peek"($I10)
    rx2190_cur."!cursor_pos"($I11)
    ($P10) = rx2190_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2190_pos, "")
    rx2190_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2192_done
  rxcap_2192_fail:
    goto rx2190_fail
  rxcap_2192_done:
  # rx subrule "O" subtype=capture negate=
    rx2190_cur."!cursor_pos"(rx2190_pos)
    $P10 = rx2190_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx2190_fail
    rx2190_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2190_pos = $P10."pos"()
  # rx pass
    rx2190_cur."!cursor_pass"(rx2190_pos, "infix:sym<+^>")
    if_null rx2190_debug, debug_1570
    rx2190_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx2190_pos)
  debug_1570:
    .return (rx2190_cur)
  rx2190_restart:
.annotate 'line', 462
    if_null rx2190_debug, debug_1571
    rx2190_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1571:
  rx2190_fail:
    (rx2190_rep, rx2190_pos, $I10, $P10) = rx2190_cur."!mark_fail"(0)
    lt rx2190_pos, -1, rx2190_done
    eq rx2190_pos, -1, rx2190_fail
    jump $I10
  rx2190_done:
    rx2190_cur."!cursor_fail"()
    if_null rx2190_debug, debug_1572
    rx2190_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1572:
    .return (rx2190_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("366_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "+^")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("367_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2195_tgt
    .local int rx2195_pos
    .local int rx2195_off
    .local int rx2195_eos
    .local int rx2195_rep
    .local pmc rx2195_cur
    .local pmc rx2195_debug
    (rx2195_cur, rx2195_pos, rx2195_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2195_cur
    .local pmc match
    .lex "$/", match
    length rx2195_eos, rx2195_tgt
    gt rx2195_pos, rx2195_eos, rx2195_done
    set rx2195_off, 0
    lt rx2195_pos, 2, rx2195_start
    sub rx2195_off, rx2195_pos, 1
    substr rx2195_tgt, rx2195_tgt, rx2195_off
  rx2195_start:
    eq $I10, 1, rx2195_restart
    if_null rx2195_debug, debug_1573
    rx2195_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1573:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2196_done
    goto rxscan2196_scan
  rxscan2196_loop:
    (rx2195_pos) = rx2195_cur."from"()
    inc rx2195_pos
    rx2195_cur."!cursor_from"(rx2195_pos)
    ge rx2195_pos, rx2195_eos, rxscan2196_done
  rxscan2196_scan:
    set_addr $I10, rxscan2196_loop
    rx2195_cur."!mark_push"(0, rx2195_pos, $I10)
  rxscan2196_done:
.annotate 'line', 1146
  # rx subcapture "sym"
    set_addr $I10, rxcap_2197_fail
    rx2195_cur."!mark_push"(0, rx2195_pos, $I10)
  # rx literal  "~"
    add $I11, rx2195_pos, 1
    gt $I11, rx2195_eos, rx2195_fail
    sub $I11, rx2195_pos, rx2195_off
    ord $I11, rx2195_tgt, $I11
    ne $I11, 126, rx2195_fail
    add rx2195_pos, 1
    set_addr $I10, rxcap_2197_fail
    ($I12, $I11) = rx2195_cur."!mark_peek"($I10)
    rx2195_cur."!cursor_pos"($I11)
    ($P10) = rx2195_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2195_pos, "")
    rx2195_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2197_done
  rxcap_2197_fail:
    goto rx2195_fail
  rxcap_2197_done:
  # rx subrule "O" subtype=capture negate=
    rx2195_cur."!cursor_pos"(rx2195_pos)
    $P10 = rx2195_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx2195_fail
    rx2195_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2195_pos = $P10."pos"()
  # rx pass
    rx2195_cur."!cursor_pass"(rx2195_pos, "infix:sym<~>")
    if_null rx2195_debug, debug_1574
    rx2195_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx2195_pos)
  debug_1574:
    .return (rx2195_cur)
  rx2195_restart:
.annotate 'line', 462
    if_null rx2195_debug, debug_1575
    rx2195_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1575:
  rx2195_fail:
    (rx2195_rep, rx2195_pos, $I10, $P10) = rx2195_cur."!mark_fail"(0)
    lt rx2195_pos, -1, rx2195_done
    eq rx2195_pos, -1, rx2195_fail
    jump $I10
  rx2195_done:
    rx2195_cur."!cursor_fail"()
    if_null rx2195_debug, debug_1576
    rx2195_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1576:
    .return (rx2195_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("368_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("369_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2200_tgt
    .local int rx2200_pos
    .local int rx2200_off
    .local int rx2200_eos
    .local int rx2200_rep
    .local pmc rx2200_cur
    .local pmc rx2200_debug
    (rx2200_cur, rx2200_pos, rx2200_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2200_cur
    .local pmc match
    .lex "$/", match
    length rx2200_eos, rx2200_tgt
    gt rx2200_pos, rx2200_eos, rx2200_done
    set rx2200_off, 0
    lt rx2200_pos, 2, rx2200_start
    sub rx2200_off, rx2200_pos, 1
    substr rx2200_tgt, rx2200_tgt, rx2200_off
  rx2200_start:
    eq $I10, 1, rx2200_restart
    if_null rx2200_debug, debug_1577
    rx2200_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1577:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2201_done
    goto rxscan2201_scan
  rxscan2201_loop:
    (rx2200_pos) = rx2200_cur."from"()
    inc rx2200_pos
    rx2200_cur."!cursor_from"(rx2200_pos)
    ge rx2200_pos, rx2200_eos, rxscan2201_done
  rxscan2201_scan:
    set_addr $I10, rxscan2201_loop
    rx2200_cur."!mark_push"(0, rx2200_pos, $I10)
  rxscan2201_done:
.annotate 'line', 1148
  # rx subcapture "sym"
    set_addr $I10, rxcap_2202_fail
    rx2200_cur."!mark_push"(0, rx2200_pos, $I10)
  # rx literal  "=="
    add $I11, rx2200_pos, 2
    gt $I11, rx2200_eos, rx2200_fail
    sub $I11, rx2200_pos, rx2200_off
    substr $S10, rx2200_tgt, $I11, 2
    ne $S10, "==", rx2200_fail
    add rx2200_pos, 2
    set_addr $I10, rxcap_2202_fail
    ($I12, $I11) = rx2200_cur."!mark_peek"($I10)
    rx2200_cur."!cursor_pos"($I11)
    ($P10) = rx2200_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2200_pos, "")
    rx2200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2202_done
  rxcap_2202_fail:
    goto rx2200_fail
  rxcap_2202_done:
  # rx subrule "O" subtype=capture negate=
    rx2200_cur."!cursor_pos"(rx2200_pos)
    $P10 = rx2200_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx2200_fail
    rx2200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2200_pos = $P10."pos"()
  # rx pass
    rx2200_cur."!cursor_pass"(rx2200_pos, "infix:sym<==>")
    if_null rx2200_debug, debug_1578
    rx2200_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx2200_pos)
  debug_1578:
    .return (rx2200_cur)
  rx2200_restart:
.annotate 'line', 462
    if_null rx2200_debug, debug_1579
    rx2200_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1579:
  rx2200_fail:
    (rx2200_rep, rx2200_pos, $I10, $P10) = rx2200_cur."!mark_fail"(0)
    lt rx2200_pos, -1, rx2200_done
    eq rx2200_pos, -1, rx2200_fail
    jump $I10
  rx2200_done:
    rx2200_cur."!cursor_fail"()
    if_null rx2200_debug, debug_1580
    rx2200_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1580:
    .return (rx2200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("370_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "==")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("371_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2205_tgt
    .local int rx2205_pos
    .local int rx2205_off
    .local int rx2205_eos
    .local int rx2205_rep
    .local pmc rx2205_cur
    .local pmc rx2205_debug
    (rx2205_cur, rx2205_pos, rx2205_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2205_cur
    .local pmc match
    .lex "$/", match
    length rx2205_eos, rx2205_tgt
    gt rx2205_pos, rx2205_eos, rx2205_done
    set rx2205_off, 0
    lt rx2205_pos, 2, rx2205_start
    sub rx2205_off, rx2205_pos, 1
    substr rx2205_tgt, rx2205_tgt, rx2205_off
  rx2205_start:
    eq $I10, 1, rx2205_restart
    if_null rx2205_debug, debug_1581
    rx2205_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1581:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2206_done
    goto rxscan2206_scan
  rxscan2206_loop:
    (rx2205_pos) = rx2205_cur."from"()
    inc rx2205_pos
    rx2205_cur."!cursor_from"(rx2205_pos)
    ge rx2205_pos, rx2205_eos, rxscan2206_done
  rxscan2206_scan:
    set_addr $I10, rxscan2206_loop
    rx2205_cur."!mark_push"(0, rx2205_pos, $I10)
  rxscan2206_done:
.annotate 'line', 1149
  # rx subcapture "sym"
    set_addr $I10, rxcap_2207_fail
    rx2205_cur."!mark_push"(0, rx2205_pos, $I10)
  # rx literal  "!="
    add $I11, rx2205_pos, 2
    gt $I11, rx2205_eos, rx2205_fail
    sub $I11, rx2205_pos, rx2205_off
    substr $S10, rx2205_tgt, $I11, 2
    ne $S10, "!=", rx2205_fail
    add rx2205_pos, 2
    set_addr $I10, rxcap_2207_fail
    ($I12, $I11) = rx2205_cur."!mark_peek"($I10)
    rx2205_cur."!cursor_pos"($I11)
    ($P10) = rx2205_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2205_pos, "")
    rx2205_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2207_done
  rxcap_2207_fail:
    goto rx2205_fail
  rxcap_2207_done:
  # rx subrule "O" subtype=capture negate=
    rx2205_cur."!cursor_pos"(rx2205_pos)
    $P10 = rx2205_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx2205_fail
    rx2205_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2205_pos = $P10."pos"()
  # rx pass
    rx2205_cur."!cursor_pass"(rx2205_pos, "infix:sym<!=>")
    if_null rx2205_debug, debug_1582
    rx2205_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx2205_pos)
  debug_1582:
    .return (rx2205_cur)
  rx2205_restart:
.annotate 'line', 462
    if_null rx2205_debug, debug_1583
    rx2205_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1583:
  rx2205_fail:
    (rx2205_rep, rx2205_pos, $I10, $P10) = rx2205_cur."!mark_fail"(0)
    lt rx2205_pos, -1, rx2205_done
    eq rx2205_pos, -1, rx2205_fail
    jump $I10
  rx2205_done:
    rx2205_cur."!cursor_fail"()
    if_null rx2205_debug, debug_1584
    rx2205_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1584:
    .return (rx2205_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("372_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "!=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("373_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2210_tgt
    .local int rx2210_pos
    .local int rx2210_off
    .local int rx2210_eos
    .local int rx2210_rep
    .local pmc rx2210_cur
    .local pmc rx2210_debug
    (rx2210_cur, rx2210_pos, rx2210_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2210_cur
    .local pmc match
    .lex "$/", match
    length rx2210_eos, rx2210_tgt
    gt rx2210_pos, rx2210_eos, rx2210_done
    set rx2210_off, 0
    lt rx2210_pos, 2, rx2210_start
    sub rx2210_off, rx2210_pos, 1
    substr rx2210_tgt, rx2210_tgt, rx2210_off
  rx2210_start:
    eq $I10, 1, rx2210_restart
    if_null rx2210_debug, debug_1585
    rx2210_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1585:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2211_done
    goto rxscan2211_scan
  rxscan2211_loop:
    (rx2210_pos) = rx2210_cur."from"()
    inc rx2210_pos
    rx2210_cur."!cursor_from"(rx2210_pos)
    ge rx2210_pos, rx2210_eos, rxscan2211_done
  rxscan2211_scan:
    set_addr $I10, rxscan2211_loop
    rx2210_cur."!mark_push"(0, rx2210_pos, $I10)
  rxscan2211_done:
.annotate 'line', 1150
  # rx subcapture "sym"
    set_addr $I10, rxcap_2212_fail
    rx2210_cur."!mark_push"(0, rx2210_pos, $I10)
  # rx literal  "<="
    add $I11, rx2210_pos, 2
    gt $I11, rx2210_eos, rx2210_fail
    sub $I11, rx2210_pos, rx2210_off
    substr $S10, rx2210_tgt, $I11, 2
    ne $S10, "<=", rx2210_fail
    add rx2210_pos, 2
    set_addr $I10, rxcap_2212_fail
    ($I12, $I11) = rx2210_cur."!mark_peek"($I10)
    rx2210_cur."!cursor_pos"($I11)
    ($P10) = rx2210_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2210_pos, "")
    rx2210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2212_done
  rxcap_2212_fail:
    goto rx2210_fail
  rxcap_2212_done:
  # rx subrule "O" subtype=capture negate=
    rx2210_cur."!cursor_pos"(rx2210_pos)
    $P10 = rx2210_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx2210_fail
    rx2210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2210_pos = $P10."pos"()
  # rx pass
    rx2210_cur."!cursor_pass"(rx2210_pos, "infix:sym<<=>")
    if_null rx2210_debug, debug_1586
    rx2210_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx2210_pos)
  debug_1586:
    .return (rx2210_cur)
  rx2210_restart:
.annotate 'line', 462
    if_null rx2210_debug, debug_1587
    rx2210_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1587:
  rx2210_fail:
    (rx2210_rep, rx2210_pos, $I10, $P10) = rx2210_cur."!mark_fail"(0)
    lt rx2210_pos, -1, rx2210_done
    eq rx2210_pos, -1, rx2210_fail
    jump $I10
  rx2210_done:
    rx2210_cur."!cursor_fail"()
    if_null rx2210_debug, debug_1588
    rx2210_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1588:
    .return (rx2210_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("374_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "<=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("375_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2215_tgt
    .local int rx2215_pos
    .local int rx2215_off
    .local int rx2215_eos
    .local int rx2215_rep
    .local pmc rx2215_cur
    .local pmc rx2215_debug
    (rx2215_cur, rx2215_pos, rx2215_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2215_cur
    .local pmc match
    .lex "$/", match
    length rx2215_eos, rx2215_tgt
    gt rx2215_pos, rx2215_eos, rx2215_done
    set rx2215_off, 0
    lt rx2215_pos, 2, rx2215_start
    sub rx2215_off, rx2215_pos, 1
    substr rx2215_tgt, rx2215_tgt, rx2215_off
  rx2215_start:
    eq $I10, 1, rx2215_restart
    if_null rx2215_debug, debug_1589
    rx2215_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1589:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2216_done
    goto rxscan2216_scan
  rxscan2216_loop:
    (rx2215_pos) = rx2215_cur."from"()
    inc rx2215_pos
    rx2215_cur."!cursor_from"(rx2215_pos)
    ge rx2215_pos, rx2215_eos, rxscan2216_done
  rxscan2216_scan:
    set_addr $I10, rxscan2216_loop
    rx2215_cur."!mark_push"(0, rx2215_pos, $I10)
  rxscan2216_done:
.annotate 'line', 1151
  # rx subcapture "sym"
    set_addr $I10, rxcap_2217_fail
    rx2215_cur."!mark_push"(0, rx2215_pos, $I10)
  # rx literal  ">="
    add $I11, rx2215_pos, 2
    gt $I11, rx2215_eos, rx2215_fail
    sub $I11, rx2215_pos, rx2215_off
    substr $S10, rx2215_tgt, $I11, 2
    ne $S10, ">=", rx2215_fail
    add rx2215_pos, 2
    set_addr $I10, rxcap_2217_fail
    ($I12, $I11) = rx2215_cur."!mark_peek"($I10)
    rx2215_cur."!cursor_pos"($I11)
    ($P10) = rx2215_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2215_pos, "")
    rx2215_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2217_done
  rxcap_2217_fail:
    goto rx2215_fail
  rxcap_2217_done:
  # rx subrule "O" subtype=capture negate=
    rx2215_cur."!cursor_pos"(rx2215_pos)
    $P10 = rx2215_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx2215_fail
    rx2215_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2215_pos = $P10."pos"()
  # rx pass
    rx2215_cur."!cursor_pass"(rx2215_pos, "infix:sym<>=>")
    if_null rx2215_debug, debug_1590
    rx2215_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx2215_pos)
  debug_1590:
    .return (rx2215_cur)
  rx2215_restart:
.annotate 'line', 462
    if_null rx2215_debug, debug_1591
    rx2215_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1591:
  rx2215_fail:
    (rx2215_rep, rx2215_pos, $I10, $P10) = rx2215_cur."!mark_fail"(0)
    lt rx2215_pos, -1, rx2215_done
    eq rx2215_pos, -1, rx2215_fail
    jump $I10
  rx2215_done:
    rx2215_cur."!cursor_fail"()
    if_null rx2215_debug, debug_1592
    rx2215_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1592:
    .return (rx2215_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("376_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", ">=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("377_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2220_tgt
    .local int rx2220_pos
    .local int rx2220_off
    .local int rx2220_eos
    .local int rx2220_rep
    .local pmc rx2220_cur
    .local pmc rx2220_debug
    (rx2220_cur, rx2220_pos, rx2220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2220_cur
    .local pmc match
    .lex "$/", match
    length rx2220_eos, rx2220_tgt
    gt rx2220_pos, rx2220_eos, rx2220_done
    set rx2220_off, 0
    lt rx2220_pos, 2, rx2220_start
    sub rx2220_off, rx2220_pos, 1
    substr rx2220_tgt, rx2220_tgt, rx2220_off
  rx2220_start:
    eq $I10, 1, rx2220_restart
    if_null rx2220_debug, debug_1593
    rx2220_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1593:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2221_done
    goto rxscan2221_scan
  rxscan2221_loop:
    (rx2220_pos) = rx2220_cur."from"()
    inc rx2220_pos
    rx2220_cur."!cursor_from"(rx2220_pos)
    ge rx2220_pos, rx2220_eos, rxscan2221_done
  rxscan2221_scan:
    set_addr $I10, rxscan2221_loop
    rx2220_cur."!mark_push"(0, rx2220_pos, $I10)
  rxscan2221_done:
.annotate 'line', 1152
  # rx subcapture "sym"
    set_addr $I10, rxcap_2222_fail
    rx2220_cur."!mark_push"(0, rx2220_pos, $I10)
  # rx literal  "<"
    add $I11, rx2220_pos, 1
    gt $I11, rx2220_eos, rx2220_fail
    sub $I11, rx2220_pos, rx2220_off
    ord $I11, rx2220_tgt, $I11
    ne $I11, 60, rx2220_fail
    add rx2220_pos, 1
    set_addr $I10, rxcap_2222_fail
    ($I12, $I11) = rx2220_cur."!mark_peek"($I10)
    rx2220_cur."!cursor_pos"($I11)
    ($P10) = rx2220_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2220_pos, "")
    rx2220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2222_done
  rxcap_2222_fail:
    goto rx2220_fail
  rxcap_2222_done:
  # rx subrule "O" subtype=capture negate=
    rx2220_cur."!cursor_pos"(rx2220_pos)
    $P10 = rx2220_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx2220_fail
    rx2220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2220_pos = $P10."pos"()
  # rx pass
    rx2220_cur."!cursor_pass"(rx2220_pos, "infix:sym<<>")
    if_null rx2220_debug, debug_1594
    rx2220_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx2220_pos)
  debug_1594:
    .return (rx2220_cur)
  rx2220_restart:
.annotate 'line', 462
    if_null rx2220_debug, debug_1595
    rx2220_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1595:
  rx2220_fail:
    (rx2220_rep, rx2220_pos, $I10, $P10) = rx2220_cur."!mark_fail"(0)
    lt rx2220_pos, -1, rx2220_done
    eq rx2220_pos, -1, rx2220_fail
    jump $I10
  rx2220_done:
    rx2220_cur."!cursor_fail"()
    if_null rx2220_debug, debug_1596
    rx2220_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1596:
    .return (rx2220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("378_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "<")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("379_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2225_tgt
    .local int rx2225_pos
    .local int rx2225_off
    .local int rx2225_eos
    .local int rx2225_rep
    .local pmc rx2225_cur
    .local pmc rx2225_debug
    (rx2225_cur, rx2225_pos, rx2225_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2225_cur
    .local pmc match
    .lex "$/", match
    length rx2225_eos, rx2225_tgt
    gt rx2225_pos, rx2225_eos, rx2225_done
    set rx2225_off, 0
    lt rx2225_pos, 2, rx2225_start
    sub rx2225_off, rx2225_pos, 1
    substr rx2225_tgt, rx2225_tgt, rx2225_off
  rx2225_start:
    eq $I10, 1, rx2225_restart
    if_null rx2225_debug, debug_1597
    rx2225_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1597:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2226_done
    goto rxscan2226_scan
  rxscan2226_loop:
    (rx2225_pos) = rx2225_cur."from"()
    inc rx2225_pos
    rx2225_cur."!cursor_from"(rx2225_pos)
    ge rx2225_pos, rx2225_eos, rxscan2226_done
  rxscan2226_scan:
    set_addr $I10, rxscan2226_loop
    rx2225_cur."!mark_push"(0, rx2225_pos, $I10)
  rxscan2226_done:
.annotate 'line', 1153
  # rx subcapture "sym"
    set_addr $I10, rxcap_2227_fail
    rx2225_cur."!mark_push"(0, rx2225_pos, $I10)
  # rx literal  ">"
    add $I11, rx2225_pos, 1
    gt $I11, rx2225_eos, rx2225_fail
    sub $I11, rx2225_pos, rx2225_off
    ord $I11, rx2225_tgt, $I11
    ne $I11, 62, rx2225_fail
    add rx2225_pos, 1
    set_addr $I10, rxcap_2227_fail
    ($I12, $I11) = rx2225_cur."!mark_peek"($I10)
    rx2225_cur."!cursor_pos"($I11)
    ($P10) = rx2225_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2225_pos, "")
    rx2225_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2227_done
  rxcap_2227_fail:
    goto rx2225_fail
  rxcap_2227_done:
  # rx subrule "O" subtype=capture negate=
    rx2225_cur."!cursor_pos"(rx2225_pos)
    $P10 = rx2225_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx2225_fail
    rx2225_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2225_pos = $P10."pos"()
  # rx pass
    rx2225_cur."!cursor_pass"(rx2225_pos, "infix:sym<>>")
    if_null rx2225_debug, debug_1598
    rx2225_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx2225_pos)
  debug_1598:
    .return (rx2225_cur)
  rx2225_restart:
.annotate 'line', 462
    if_null rx2225_debug, debug_1599
    rx2225_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1599:
  rx2225_fail:
    (rx2225_rep, rx2225_pos, $I10, $P10) = rx2225_cur."!mark_fail"(0)
    lt rx2225_pos, -1, rx2225_done
    eq rx2225_pos, -1, rx2225_fail
    jump $I10
  rx2225_done:
    rx2225_cur."!cursor_fail"()
    if_null rx2225_debug, debug_1600
    rx2225_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1600:
    .return (rx2225_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("380_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", ">")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("381_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2230_tgt
    .local int rx2230_pos
    .local int rx2230_off
    .local int rx2230_eos
    .local int rx2230_rep
    .local pmc rx2230_cur
    .local pmc rx2230_debug
    (rx2230_cur, rx2230_pos, rx2230_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2230_cur
    .local pmc match
    .lex "$/", match
    length rx2230_eos, rx2230_tgt
    gt rx2230_pos, rx2230_eos, rx2230_done
    set rx2230_off, 0
    lt rx2230_pos, 2, rx2230_start
    sub rx2230_off, rx2230_pos, 1
    substr rx2230_tgt, rx2230_tgt, rx2230_off
  rx2230_start:
    eq $I10, 1, rx2230_restart
    if_null rx2230_debug, debug_1601
    rx2230_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1601:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2231_done
    goto rxscan2231_scan
  rxscan2231_loop:
    (rx2230_pos) = rx2230_cur."from"()
    inc rx2230_pos
    rx2230_cur."!cursor_from"(rx2230_pos)
    ge rx2230_pos, rx2230_eos, rxscan2231_done
  rxscan2231_scan:
    set_addr $I10, rxscan2231_loop
    rx2230_cur."!mark_push"(0, rx2230_pos, $I10)
  rxscan2231_done:
.annotate 'line', 1154
  # rx subcapture "sym"
    set_addr $I10, rxcap_2232_fail
    rx2230_cur."!mark_push"(0, rx2230_pos, $I10)
  # rx literal  "eq"
    add $I11, rx2230_pos, 2
    gt $I11, rx2230_eos, rx2230_fail
    sub $I11, rx2230_pos, rx2230_off
    substr $S10, rx2230_tgt, $I11, 2
    ne $S10, "eq", rx2230_fail
    add rx2230_pos, 2
    set_addr $I10, rxcap_2232_fail
    ($I12, $I11) = rx2230_cur."!mark_peek"($I10)
    rx2230_cur."!cursor_pos"($I11)
    ($P10) = rx2230_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2230_pos, "")
    rx2230_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2232_done
  rxcap_2232_fail:
    goto rx2230_fail
  rxcap_2232_done:
  # rx subrule "O" subtype=capture negate=
    rx2230_cur."!cursor_pos"(rx2230_pos)
    $P10 = rx2230_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx2230_fail
    rx2230_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2230_pos = $P10."pos"()
  # rx pass
    rx2230_cur."!cursor_pass"(rx2230_pos, "infix:sym<eq>")
    if_null rx2230_debug, debug_1602
    rx2230_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx2230_pos)
  debug_1602:
    .return (rx2230_cur)
  rx2230_restart:
.annotate 'line', 462
    if_null rx2230_debug, debug_1603
    rx2230_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1603:
  rx2230_fail:
    (rx2230_rep, rx2230_pos, $I10, $P10) = rx2230_cur."!mark_fail"(0)
    lt rx2230_pos, -1, rx2230_done
    eq rx2230_pos, -1, rx2230_fail
    jump $I10
  rx2230_done:
    rx2230_cur."!cursor_fail"()
    if_null rx2230_debug, debug_1604
    rx2230_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1604:
    .return (rx2230_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("382_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "eq")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("383_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2235_tgt
    .local int rx2235_pos
    .local int rx2235_off
    .local int rx2235_eos
    .local int rx2235_rep
    .local pmc rx2235_cur
    .local pmc rx2235_debug
    (rx2235_cur, rx2235_pos, rx2235_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2235_cur
    .local pmc match
    .lex "$/", match
    length rx2235_eos, rx2235_tgt
    gt rx2235_pos, rx2235_eos, rx2235_done
    set rx2235_off, 0
    lt rx2235_pos, 2, rx2235_start
    sub rx2235_off, rx2235_pos, 1
    substr rx2235_tgt, rx2235_tgt, rx2235_off
  rx2235_start:
    eq $I10, 1, rx2235_restart
    if_null rx2235_debug, debug_1605
    rx2235_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1605:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2236_done
    goto rxscan2236_scan
  rxscan2236_loop:
    (rx2235_pos) = rx2235_cur."from"()
    inc rx2235_pos
    rx2235_cur."!cursor_from"(rx2235_pos)
    ge rx2235_pos, rx2235_eos, rxscan2236_done
  rxscan2236_scan:
    set_addr $I10, rxscan2236_loop
    rx2235_cur."!mark_push"(0, rx2235_pos, $I10)
  rxscan2236_done:
.annotate 'line', 1155
  # rx subcapture "sym"
    set_addr $I10, rxcap_2237_fail
    rx2235_cur."!mark_push"(0, rx2235_pos, $I10)
  # rx literal  "ne"
    add $I11, rx2235_pos, 2
    gt $I11, rx2235_eos, rx2235_fail
    sub $I11, rx2235_pos, rx2235_off
    substr $S10, rx2235_tgt, $I11, 2
    ne $S10, "ne", rx2235_fail
    add rx2235_pos, 2
    set_addr $I10, rxcap_2237_fail
    ($I12, $I11) = rx2235_cur."!mark_peek"($I10)
    rx2235_cur."!cursor_pos"($I11)
    ($P10) = rx2235_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2235_pos, "")
    rx2235_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2237_done
  rxcap_2237_fail:
    goto rx2235_fail
  rxcap_2237_done:
  # rx subrule "O" subtype=capture negate=
    rx2235_cur."!cursor_pos"(rx2235_pos)
    $P10 = rx2235_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx2235_fail
    rx2235_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2235_pos = $P10."pos"()
  # rx pass
    rx2235_cur."!cursor_pass"(rx2235_pos, "infix:sym<ne>")
    if_null rx2235_debug, debug_1606
    rx2235_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx2235_pos)
  debug_1606:
    .return (rx2235_cur)
  rx2235_restart:
.annotate 'line', 462
    if_null rx2235_debug, debug_1607
    rx2235_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1607:
  rx2235_fail:
    (rx2235_rep, rx2235_pos, $I10, $P10) = rx2235_cur."!mark_fail"(0)
    lt rx2235_pos, -1, rx2235_done
    eq rx2235_pos, -1, rx2235_fail
    jump $I10
  rx2235_done:
    rx2235_cur."!cursor_fail"()
    if_null rx2235_debug, debug_1608
    rx2235_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1608:
    .return (rx2235_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("384_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "ne")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("385_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2240_tgt
    .local int rx2240_pos
    .local int rx2240_off
    .local int rx2240_eos
    .local int rx2240_rep
    .local pmc rx2240_cur
    .local pmc rx2240_debug
    (rx2240_cur, rx2240_pos, rx2240_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2240_cur
    .local pmc match
    .lex "$/", match
    length rx2240_eos, rx2240_tgt
    gt rx2240_pos, rx2240_eos, rx2240_done
    set rx2240_off, 0
    lt rx2240_pos, 2, rx2240_start
    sub rx2240_off, rx2240_pos, 1
    substr rx2240_tgt, rx2240_tgt, rx2240_off
  rx2240_start:
    eq $I10, 1, rx2240_restart
    if_null rx2240_debug, debug_1609
    rx2240_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1609:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2241_done
    goto rxscan2241_scan
  rxscan2241_loop:
    (rx2240_pos) = rx2240_cur."from"()
    inc rx2240_pos
    rx2240_cur."!cursor_from"(rx2240_pos)
    ge rx2240_pos, rx2240_eos, rxscan2241_done
  rxscan2241_scan:
    set_addr $I10, rxscan2241_loop
    rx2240_cur."!mark_push"(0, rx2240_pos, $I10)
  rxscan2241_done:
.annotate 'line', 1156
  # rx subcapture "sym"
    set_addr $I10, rxcap_2242_fail
    rx2240_cur."!mark_push"(0, rx2240_pos, $I10)
  # rx literal  "le"
    add $I11, rx2240_pos, 2
    gt $I11, rx2240_eos, rx2240_fail
    sub $I11, rx2240_pos, rx2240_off
    substr $S10, rx2240_tgt, $I11, 2
    ne $S10, "le", rx2240_fail
    add rx2240_pos, 2
    set_addr $I10, rxcap_2242_fail
    ($I12, $I11) = rx2240_cur."!mark_peek"($I10)
    rx2240_cur."!cursor_pos"($I11)
    ($P10) = rx2240_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2240_pos, "")
    rx2240_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2242_done
  rxcap_2242_fail:
    goto rx2240_fail
  rxcap_2242_done:
  # rx subrule "O" subtype=capture negate=
    rx2240_cur."!cursor_pos"(rx2240_pos)
    $P10 = rx2240_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx2240_fail
    rx2240_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2240_pos = $P10."pos"()
  # rx pass
    rx2240_cur."!cursor_pass"(rx2240_pos, "infix:sym<le>")
    if_null rx2240_debug, debug_1610
    rx2240_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx2240_pos)
  debug_1610:
    .return (rx2240_cur)
  rx2240_restart:
.annotate 'line', 462
    if_null rx2240_debug, debug_1611
    rx2240_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1611:
  rx2240_fail:
    (rx2240_rep, rx2240_pos, $I10, $P10) = rx2240_cur."!mark_fail"(0)
    lt rx2240_pos, -1, rx2240_done
    eq rx2240_pos, -1, rx2240_fail
    jump $I10
  rx2240_done:
    rx2240_cur."!cursor_fail"()
    if_null rx2240_debug, debug_1612
    rx2240_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1612:
    .return (rx2240_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("386_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "le")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("387_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2245_tgt
    .local int rx2245_pos
    .local int rx2245_off
    .local int rx2245_eos
    .local int rx2245_rep
    .local pmc rx2245_cur
    .local pmc rx2245_debug
    (rx2245_cur, rx2245_pos, rx2245_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2245_cur
    .local pmc match
    .lex "$/", match
    length rx2245_eos, rx2245_tgt
    gt rx2245_pos, rx2245_eos, rx2245_done
    set rx2245_off, 0
    lt rx2245_pos, 2, rx2245_start
    sub rx2245_off, rx2245_pos, 1
    substr rx2245_tgt, rx2245_tgt, rx2245_off
  rx2245_start:
    eq $I10, 1, rx2245_restart
    if_null rx2245_debug, debug_1613
    rx2245_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1613:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2246_done
    goto rxscan2246_scan
  rxscan2246_loop:
    (rx2245_pos) = rx2245_cur."from"()
    inc rx2245_pos
    rx2245_cur."!cursor_from"(rx2245_pos)
    ge rx2245_pos, rx2245_eos, rxscan2246_done
  rxscan2246_scan:
    set_addr $I10, rxscan2246_loop
    rx2245_cur."!mark_push"(0, rx2245_pos, $I10)
  rxscan2246_done:
.annotate 'line', 1157
  # rx subcapture "sym"
    set_addr $I10, rxcap_2247_fail
    rx2245_cur."!mark_push"(0, rx2245_pos, $I10)
  # rx literal  "ge"
    add $I11, rx2245_pos, 2
    gt $I11, rx2245_eos, rx2245_fail
    sub $I11, rx2245_pos, rx2245_off
    substr $S10, rx2245_tgt, $I11, 2
    ne $S10, "ge", rx2245_fail
    add rx2245_pos, 2
    set_addr $I10, rxcap_2247_fail
    ($I12, $I11) = rx2245_cur."!mark_peek"($I10)
    rx2245_cur."!cursor_pos"($I11)
    ($P10) = rx2245_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2245_pos, "")
    rx2245_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2247_done
  rxcap_2247_fail:
    goto rx2245_fail
  rxcap_2247_done:
  # rx subrule "O" subtype=capture negate=
    rx2245_cur."!cursor_pos"(rx2245_pos)
    $P10 = rx2245_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx2245_fail
    rx2245_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2245_pos = $P10."pos"()
  # rx pass
    rx2245_cur."!cursor_pass"(rx2245_pos, "infix:sym<ge>")
    if_null rx2245_debug, debug_1614
    rx2245_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx2245_pos)
  debug_1614:
    .return (rx2245_cur)
  rx2245_restart:
.annotate 'line', 462
    if_null rx2245_debug, debug_1615
    rx2245_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1615:
  rx2245_fail:
    (rx2245_rep, rx2245_pos, $I10, $P10) = rx2245_cur."!mark_fail"(0)
    lt rx2245_pos, -1, rx2245_done
    eq rx2245_pos, -1, rx2245_fail
    jump $I10
  rx2245_done:
    rx2245_cur."!cursor_fail"()
    if_null rx2245_debug, debug_1616
    rx2245_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1616:
    .return (rx2245_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("388_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "ge")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("389_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2250_tgt
    .local int rx2250_pos
    .local int rx2250_off
    .local int rx2250_eos
    .local int rx2250_rep
    .local pmc rx2250_cur
    .local pmc rx2250_debug
    (rx2250_cur, rx2250_pos, rx2250_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2250_cur
    .local pmc match
    .lex "$/", match
    length rx2250_eos, rx2250_tgt
    gt rx2250_pos, rx2250_eos, rx2250_done
    set rx2250_off, 0
    lt rx2250_pos, 2, rx2250_start
    sub rx2250_off, rx2250_pos, 1
    substr rx2250_tgt, rx2250_tgt, rx2250_off
  rx2250_start:
    eq $I10, 1, rx2250_restart
    if_null rx2250_debug, debug_1617
    rx2250_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1617:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2251_done
    goto rxscan2251_scan
  rxscan2251_loop:
    (rx2250_pos) = rx2250_cur."from"()
    inc rx2250_pos
    rx2250_cur."!cursor_from"(rx2250_pos)
    ge rx2250_pos, rx2250_eos, rxscan2251_done
  rxscan2251_scan:
    set_addr $I10, rxscan2251_loop
    rx2250_cur."!mark_push"(0, rx2250_pos, $I10)
  rxscan2251_done:
.annotate 'line', 1158
  # rx subcapture "sym"
    set_addr $I10, rxcap_2252_fail
    rx2250_cur."!mark_push"(0, rx2250_pos, $I10)
  # rx literal  "lt"
    add $I11, rx2250_pos, 2
    gt $I11, rx2250_eos, rx2250_fail
    sub $I11, rx2250_pos, rx2250_off
    substr $S10, rx2250_tgt, $I11, 2
    ne $S10, "lt", rx2250_fail
    add rx2250_pos, 2
    set_addr $I10, rxcap_2252_fail
    ($I12, $I11) = rx2250_cur."!mark_peek"($I10)
    rx2250_cur."!cursor_pos"($I11)
    ($P10) = rx2250_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2250_pos, "")
    rx2250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2252_done
  rxcap_2252_fail:
    goto rx2250_fail
  rxcap_2252_done:
  # rx subrule "O" subtype=capture negate=
    rx2250_cur."!cursor_pos"(rx2250_pos)
    $P10 = rx2250_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx2250_fail
    rx2250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2250_pos = $P10."pos"()
  # rx pass
    rx2250_cur."!cursor_pass"(rx2250_pos, "infix:sym<lt>")
    if_null rx2250_debug, debug_1618
    rx2250_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx2250_pos)
  debug_1618:
    .return (rx2250_cur)
  rx2250_restart:
.annotate 'line', 462
    if_null rx2250_debug, debug_1619
    rx2250_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1619:
  rx2250_fail:
    (rx2250_rep, rx2250_pos, $I10, $P10) = rx2250_cur."!mark_fail"(0)
    lt rx2250_pos, -1, rx2250_done
    eq rx2250_pos, -1, rx2250_fail
    jump $I10
  rx2250_done:
    rx2250_cur."!cursor_fail"()
    if_null rx2250_debug, debug_1620
    rx2250_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1620:
    .return (rx2250_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("390_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "lt")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("391_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2255_tgt
    .local int rx2255_pos
    .local int rx2255_off
    .local int rx2255_eos
    .local int rx2255_rep
    .local pmc rx2255_cur
    .local pmc rx2255_debug
    (rx2255_cur, rx2255_pos, rx2255_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2255_cur
    .local pmc match
    .lex "$/", match
    length rx2255_eos, rx2255_tgt
    gt rx2255_pos, rx2255_eos, rx2255_done
    set rx2255_off, 0
    lt rx2255_pos, 2, rx2255_start
    sub rx2255_off, rx2255_pos, 1
    substr rx2255_tgt, rx2255_tgt, rx2255_off
  rx2255_start:
    eq $I10, 1, rx2255_restart
    if_null rx2255_debug, debug_1621
    rx2255_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1621:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2256_done
    goto rxscan2256_scan
  rxscan2256_loop:
    (rx2255_pos) = rx2255_cur."from"()
    inc rx2255_pos
    rx2255_cur."!cursor_from"(rx2255_pos)
    ge rx2255_pos, rx2255_eos, rxscan2256_done
  rxscan2256_scan:
    set_addr $I10, rxscan2256_loop
    rx2255_cur."!mark_push"(0, rx2255_pos, $I10)
  rxscan2256_done:
.annotate 'line', 1159
  # rx subcapture "sym"
    set_addr $I10, rxcap_2257_fail
    rx2255_cur."!mark_push"(0, rx2255_pos, $I10)
  # rx literal  "gt"
    add $I11, rx2255_pos, 2
    gt $I11, rx2255_eos, rx2255_fail
    sub $I11, rx2255_pos, rx2255_off
    substr $S10, rx2255_tgt, $I11, 2
    ne $S10, "gt", rx2255_fail
    add rx2255_pos, 2
    set_addr $I10, rxcap_2257_fail
    ($I12, $I11) = rx2255_cur."!mark_peek"($I10)
    rx2255_cur."!cursor_pos"($I11)
    ($P10) = rx2255_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2255_pos, "")
    rx2255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2257_done
  rxcap_2257_fail:
    goto rx2255_fail
  rxcap_2257_done:
  # rx subrule "O" subtype=capture negate=
    rx2255_cur."!cursor_pos"(rx2255_pos)
    $P10 = rx2255_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx2255_fail
    rx2255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2255_pos = $P10."pos"()
  # rx pass
    rx2255_cur."!cursor_pass"(rx2255_pos, "infix:sym<gt>")
    if_null rx2255_debug, debug_1622
    rx2255_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx2255_pos)
  debug_1622:
    .return (rx2255_cur)
  rx2255_restart:
.annotate 'line', 462
    if_null rx2255_debug, debug_1623
    rx2255_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1623:
  rx2255_fail:
    (rx2255_rep, rx2255_pos, $I10, $P10) = rx2255_cur."!mark_fail"(0)
    lt rx2255_pos, -1, rx2255_done
    eq rx2255_pos, -1, rx2255_fail
    jump $I10
  rx2255_done:
    rx2255_cur."!cursor_fail"()
    if_null rx2255_debug, debug_1624
    rx2255_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1624:
    .return (rx2255_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("392_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "gt")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("393_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2260_tgt
    .local int rx2260_pos
    .local int rx2260_off
    .local int rx2260_eos
    .local int rx2260_rep
    .local pmc rx2260_cur
    .local pmc rx2260_debug
    (rx2260_cur, rx2260_pos, rx2260_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2260_cur
    .local pmc match
    .lex "$/", match
    length rx2260_eos, rx2260_tgt
    gt rx2260_pos, rx2260_eos, rx2260_done
    set rx2260_off, 0
    lt rx2260_pos, 2, rx2260_start
    sub rx2260_off, rx2260_pos, 1
    substr rx2260_tgt, rx2260_tgt, rx2260_off
  rx2260_start:
    eq $I10, 1, rx2260_restart
    if_null rx2260_debug, debug_1625
    rx2260_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1625:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2261_done
    goto rxscan2261_scan
  rxscan2261_loop:
    (rx2260_pos) = rx2260_cur."from"()
    inc rx2260_pos
    rx2260_cur."!cursor_from"(rx2260_pos)
    ge rx2260_pos, rx2260_eos, rxscan2261_done
  rxscan2261_scan:
    set_addr $I10, rxscan2261_loop
    rx2260_cur."!mark_push"(0, rx2260_pos, $I10)
  rxscan2261_done:
.annotate 'line', 1160
  # rx subcapture "sym"
    set_addr $I10, rxcap_2262_fail
    rx2260_cur."!mark_push"(0, rx2260_pos, $I10)
  # rx literal  "=:="
    add $I11, rx2260_pos, 3
    gt $I11, rx2260_eos, rx2260_fail
    sub $I11, rx2260_pos, rx2260_off
    substr $S10, rx2260_tgt, $I11, 3
    ne $S10, "=:=", rx2260_fail
    add rx2260_pos, 3
    set_addr $I10, rxcap_2262_fail
    ($I12, $I11) = rx2260_cur."!mark_peek"($I10)
    rx2260_cur."!cursor_pos"($I11)
    ($P10) = rx2260_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2260_pos, "")
    rx2260_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2262_done
  rxcap_2262_fail:
    goto rx2260_fail
  rxcap_2262_done:
  # rx subrule "O" subtype=capture negate=
    rx2260_cur."!cursor_pos"(rx2260_pos)
    $P10 = rx2260_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx2260_fail
    rx2260_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2260_pos = $P10."pos"()
  # rx pass
    rx2260_cur."!cursor_pass"(rx2260_pos, "infix:sym<=:=>")
    if_null rx2260_debug, debug_1626
    rx2260_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx2260_pos)
  debug_1626:
    .return (rx2260_cur)
  rx2260_restart:
.annotate 'line', 462
    if_null rx2260_debug, debug_1627
    rx2260_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1627:
  rx2260_fail:
    (rx2260_rep, rx2260_pos, $I10, $P10) = rx2260_cur."!mark_fail"(0)
    lt rx2260_pos, -1, rx2260_done
    eq rx2260_pos, -1, rx2260_fail
    jump $I10
  rx2260_done:
    rx2260_cur."!cursor_fail"()
    if_null rx2260_debug, debug_1628
    rx2260_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1628:
    .return (rx2260_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("394_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "=:=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("395_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2265_tgt
    .local int rx2265_pos
    .local int rx2265_off
    .local int rx2265_eos
    .local int rx2265_rep
    .local pmc rx2265_cur
    .local pmc rx2265_debug
    (rx2265_cur, rx2265_pos, rx2265_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2265_cur
    .local pmc match
    .lex "$/", match
    length rx2265_eos, rx2265_tgt
    gt rx2265_pos, rx2265_eos, rx2265_done
    set rx2265_off, 0
    lt rx2265_pos, 2, rx2265_start
    sub rx2265_off, rx2265_pos, 1
    substr rx2265_tgt, rx2265_tgt, rx2265_off
  rx2265_start:
    eq $I10, 1, rx2265_restart
    if_null rx2265_debug, debug_1629
    rx2265_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1629:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2266_done
    goto rxscan2266_scan
  rxscan2266_loop:
    (rx2265_pos) = rx2265_cur."from"()
    inc rx2265_pos
    rx2265_cur."!cursor_from"(rx2265_pos)
    ge rx2265_pos, rx2265_eos, rxscan2266_done
  rxscan2266_scan:
    set_addr $I10, rxscan2266_loop
    rx2265_cur."!mark_push"(0, rx2265_pos, $I10)
  rxscan2266_done:
.annotate 'line', 1161
  # rx subcapture "sym"
    set_addr $I10, rxcap_2267_fail
    rx2265_cur."!mark_push"(0, rx2265_pos, $I10)
  # rx literal  "~~"
    add $I11, rx2265_pos, 2
    gt $I11, rx2265_eos, rx2265_fail
    sub $I11, rx2265_pos, rx2265_off
    substr $S10, rx2265_tgt, $I11, 2
    ne $S10, "~~", rx2265_fail
    add rx2265_pos, 2
    set_addr $I10, rxcap_2267_fail
    ($I12, $I11) = rx2265_cur."!mark_peek"($I10)
    rx2265_cur."!cursor_pos"($I11)
    ($P10) = rx2265_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2265_pos, "")
    rx2265_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2267_done
  rxcap_2267_fail:
    goto rx2265_fail
  rxcap_2267_done:
  # rx subrule "O" subtype=capture negate=
    rx2265_cur."!cursor_pos"(rx2265_pos)
    $P10 = rx2265_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx2265_fail
    rx2265_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2265_pos = $P10."pos"()
  # rx pass
    rx2265_cur."!cursor_pass"(rx2265_pos, "infix:sym<~~>")
    if_null rx2265_debug, debug_1630
    rx2265_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx2265_pos)
  debug_1630:
    .return (rx2265_cur)
  rx2265_restart:
.annotate 'line', 462
    if_null rx2265_debug, debug_1631
    rx2265_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1631:
  rx2265_fail:
    (rx2265_rep, rx2265_pos, $I10, $P10) = rx2265_cur."!mark_fail"(0)
    lt rx2265_pos, -1, rx2265_done
    eq rx2265_pos, -1, rx2265_fail
    jump $I10
  rx2265_done:
    rx2265_cur."!cursor_fail"()
    if_null rx2265_debug, debug_1632
    rx2265_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1632:
    .return (rx2265_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("396_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "~~")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("397_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2270_tgt
    .local int rx2270_pos
    .local int rx2270_off
    .local int rx2270_eos
    .local int rx2270_rep
    .local pmc rx2270_cur
    .local pmc rx2270_debug
    (rx2270_cur, rx2270_pos, rx2270_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2270_cur
    .local pmc match
    .lex "$/", match
    length rx2270_eos, rx2270_tgt
    gt rx2270_pos, rx2270_eos, rx2270_done
    set rx2270_off, 0
    lt rx2270_pos, 2, rx2270_start
    sub rx2270_off, rx2270_pos, 1
    substr rx2270_tgt, rx2270_tgt, rx2270_off
  rx2270_start:
    eq $I10, 1, rx2270_restart
    if_null rx2270_debug, debug_1633
    rx2270_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1633:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2271_done
    goto rxscan2271_scan
  rxscan2271_loop:
    (rx2270_pos) = rx2270_cur."from"()
    inc rx2270_pos
    rx2270_cur."!cursor_from"(rx2270_pos)
    ge rx2270_pos, rx2270_eos, rxscan2271_done
  rxscan2271_scan:
    set_addr $I10, rxscan2271_loop
    rx2270_cur."!mark_push"(0, rx2270_pos, $I10)
  rxscan2271_done:
.annotate 'line', 1163
  # rx subcapture "sym"
    set_addr $I10, rxcap_2272_fail
    rx2270_cur."!mark_push"(0, rx2270_pos, $I10)
  # rx literal  "&&"
    add $I11, rx2270_pos, 2
    gt $I11, rx2270_eos, rx2270_fail
    sub $I11, rx2270_pos, rx2270_off
    substr $S10, rx2270_tgt, $I11, 2
    ne $S10, "&&", rx2270_fail
    add rx2270_pos, 2
    set_addr $I10, rxcap_2272_fail
    ($I12, $I11) = rx2270_cur."!mark_peek"($I10)
    rx2270_cur."!cursor_pos"($I11)
    ($P10) = rx2270_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2270_pos, "")
    rx2270_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2272_done
  rxcap_2272_fail:
    goto rx2270_fail
  rxcap_2272_done:
  # rx subrule "O" subtype=capture negate=
    rx2270_cur."!cursor_pos"(rx2270_pos)
    $P10 = rx2270_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx2270_fail
    rx2270_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2270_pos = $P10."pos"()
  # rx pass
    rx2270_cur."!cursor_pass"(rx2270_pos, "infix:sym<&&>")
    if_null rx2270_debug, debug_1634
    rx2270_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx2270_pos)
  debug_1634:
    .return (rx2270_cur)
  rx2270_restart:
.annotate 'line', 462
    if_null rx2270_debug, debug_1635
    rx2270_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1635:
  rx2270_fail:
    (rx2270_rep, rx2270_pos, $I10, $P10) = rx2270_cur."!mark_fail"(0)
    lt rx2270_pos, -1, rx2270_done
    eq rx2270_pos, -1, rx2270_fail
    jump $I10
  rx2270_done:
    rx2270_cur."!cursor_fail"()
    if_null rx2270_debug, debug_1636
    rx2270_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1636:
    .return (rx2270_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("398_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "&&")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("399_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2275_tgt
    .local int rx2275_pos
    .local int rx2275_off
    .local int rx2275_eos
    .local int rx2275_rep
    .local pmc rx2275_cur
    .local pmc rx2275_debug
    (rx2275_cur, rx2275_pos, rx2275_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2275_cur
    .local pmc match
    .lex "$/", match
    length rx2275_eos, rx2275_tgt
    gt rx2275_pos, rx2275_eos, rx2275_done
    set rx2275_off, 0
    lt rx2275_pos, 2, rx2275_start
    sub rx2275_off, rx2275_pos, 1
    substr rx2275_tgt, rx2275_tgt, rx2275_off
  rx2275_start:
    eq $I10, 1, rx2275_restart
    if_null rx2275_debug, debug_1637
    rx2275_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1637:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2276_done
    goto rxscan2276_scan
  rxscan2276_loop:
    (rx2275_pos) = rx2275_cur."from"()
    inc rx2275_pos
    rx2275_cur."!cursor_from"(rx2275_pos)
    ge rx2275_pos, rx2275_eos, rxscan2276_done
  rxscan2276_scan:
    set_addr $I10, rxscan2276_loop
    rx2275_cur."!mark_push"(0, rx2275_pos, $I10)
  rxscan2276_done:
.annotate 'line', 1165
  # rx subcapture "sym"
    set_addr $I10, rxcap_2277_fail
    rx2275_cur."!mark_push"(0, rx2275_pos, $I10)
  # rx literal  "||"
    add $I11, rx2275_pos, 2
    gt $I11, rx2275_eos, rx2275_fail
    sub $I11, rx2275_pos, rx2275_off
    substr $S10, rx2275_tgt, $I11, 2
    ne $S10, "||", rx2275_fail
    add rx2275_pos, 2
    set_addr $I10, rxcap_2277_fail
    ($I12, $I11) = rx2275_cur."!mark_peek"($I10)
    rx2275_cur."!cursor_pos"($I11)
    ($P10) = rx2275_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2275_pos, "")
    rx2275_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2277_done
  rxcap_2277_fail:
    goto rx2275_fail
  rxcap_2277_done:
  # rx subrule "O" subtype=capture negate=
    rx2275_cur."!cursor_pos"(rx2275_pos)
    $P10 = rx2275_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx2275_fail
    rx2275_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2275_pos = $P10."pos"()
  # rx pass
    rx2275_cur."!cursor_pass"(rx2275_pos, "infix:sym<||>")
    if_null rx2275_debug, debug_1638
    rx2275_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx2275_pos)
  debug_1638:
    .return (rx2275_cur)
  rx2275_restart:
.annotate 'line', 462
    if_null rx2275_debug, debug_1639
    rx2275_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1639:
  rx2275_fail:
    (rx2275_rep, rx2275_pos, $I10, $P10) = rx2275_cur."!mark_fail"(0)
    lt rx2275_pos, -1, rx2275_done
    eq rx2275_pos, -1, rx2275_fail
    jump $I10
  rx2275_done:
    rx2275_cur."!cursor_fail"()
    if_null rx2275_debug, debug_1640
    rx2275_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1640:
    .return (rx2275_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("400_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "||")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("401_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2280_tgt
    .local int rx2280_pos
    .local int rx2280_off
    .local int rx2280_eos
    .local int rx2280_rep
    .local pmc rx2280_cur
    .local pmc rx2280_debug
    (rx2280_cur, rx2280_pos, rx2280_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2280_cur
    .local pmc match
    .lex "$/", match
    length rx2280_eos, rx2280_tgt
    gt rx2280_pos, rx2280_eos, rx2280_done
    set rx2280_off, 0
    lt rx2280_pos, 2, rx2280_start
    sub rx2280_off, rx2280_pos, 1
    substr rx2280_tgt, rx2280_tgt, rx2280_off
  rx2280_start:
    eq $I10, 1, rx2280_restart
    if_null rx2280_debug, debug_1641
    rx2280_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1641:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2281_done
    goto rxscan2281_scan
  rxscan2281_loop:
    (rx2280_pos) = rx2280_cur."from"()
    inc rx2280_pos
    rx2280_cur."!cursor_from"(rx2280_pos)
    ge rx2280_pos, rx2280_eos, rxscan2281_done
  rxscan2281_scan:
    set_addr $I10, rxscan2281_loop
    rx2280_cur."!mark_push"(0, rx2280_pos, $I10)
  rxscan2281_done:
.annotate 'line', 1166
  # rx subcapture "sym"
    set_addr $I10, rxcap_2282_fail
    rx2280_cur."!mark_push"(0, rx2280_pos, $I10)
  # rx literal  "//"
    add $I11, rx2280_pos, 2
    gt $I11, rx2280_eos, rx2280_fail
    sub $I11, rx2280_pos, rx2280_off
    substr $S10, rx2280_tgt, $I11, 2
    ne $S10, "//", rx2280_fail
    add rx2280_pos, 2
    set_addr $I10, rxcap_2282_fail
    ($I12, $I11) = rx2280_cur."!mark_peek"($I10)
    rx2280_cur."!cursor_pos"($I11)
    ($P10) = rx2280_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2280_pos, "")
    rx2280_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2282_done
  rxcap_2282_fail:
    goto rx2280_fail
  rxcap_2282_done:
  # rx subrule "O" subtype=capture negate=
    rx2280_cur."!cursor_pos"(rx2280_pos)
    $P10 = rx2280_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx2280_fail
    rx2280_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2280_pos = $P10."pos"()
  # rx pass
    rx2280_cur."!cursor_pass"(rx2280_pos, "infix:sym<//>")
    if_null rx2280_debug, debug_1642
    rx2280_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx2280_pos)
  debug_1642:
    .return (rx2280_cur)
  rx2280_restart:
.annotate 'line', 462
    if_null rx2280_debug, debug_1643
    rx2280_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1643:
  rx2280_fail:
    (rx2280_rep, rx2280_pos, $I10, $P10) = rx2280_cur."!mark_fail"(0)
    lt rx2280_pos, -1, rx2280_done
    eq rx2280_pos, -1, rx2280_fail
    jump $I10
  rx2280_done:
    rx2280_cur."!cursor_fail"()
    if_null rx2280_debug, debug_1644
    rx2280_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1644:
    .return (rx2280_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("402_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "//")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("403_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2285_tgt
    .local int rx2285_pos
    .local int rx2285_off
    .local int rx2285_eos
    .local int rx2285_rep
    .local pmc rx2285_cur
    .local pmc rx2285_debug
    (rx2285_cur, rx2285_pos, rx2285_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2285_cur
    .local pmc match
    .lex "$/", match
    length rx2285_eos, rx2285_tgt
    gt rx2285_pos, rx2285_eos, rx2285_done
    set rx2285_off, 0
    lt rx2285_pos, 2, rx2285_start
    sub rx2285_off, rx2285_pos, 1
    substr rx2285_tgt, rx2285_tgt, rx2285_off
  rx2285_start:
    eq $I10, 1, rx2285_restart
    if_null rx2285_debug, debug_1645
    rx2285_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1645:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2286_done
    goto rxscan2286_scan
  rxscan2286_loop:
    (rx2285_pos) = rx2285_cur."from"()
    inc rx2285_pos
    rx2285_cur."!cursor_from"(rx2285_pos)
    ge rx2285_pos, rx2285_eos, rxscan2286_done
  rxscan2286_scan:
    set_addr $I10, rxscan2286_loop
    rx2285_cur."!mark_push"(0, rx2285_pos, $I10)
  rxscan2286_done:
.annotate 'line', 1169
  # rx literal  "??"
    add $I11, rx2285_pos, 2
    gt $I11, rx2285_eos, rx2285_fail
    sub $I11, rx2285_pos, rx2285_off
    substr $S10, rx2285_tgt, $I11, 2
    ne $S10, "??", rx2285_fail
    add rx2285_pos, 2
.annotate 'line', 1170
  # rx subrule "ws" subtype=method negate=
    rx2285_cur."!cursor_pos"(rx2285_pos)
    $P10 = rx2285_cur."ws"()
    unless $P10, rx2285_fail
    rx2285_pos = $P10."pos"()
.annotate 'line', 1171
  # rx subrule "EXPR" subtype=capture negate=
    rx2285_cur."!cursor_pos"(rx2285_pos)
    $P10 = rx2285_cur."EXPR"("i=")
    unless $P10, rx2285_fail
    rx2285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx2285_pos = $P10."pos"()
.annotate 'line', 1172
  # rx literal  "!!"
    add $I11, rx2285_pos, 2
    gt $I11, rx2285_eos, rx2285_fail
    sub $I11, rx2285_pos, rx2285_off
    substr $S10, rx2285_tgt, $I11, 2
    ne $S10, "!!", rx2285_fail
    add rx2285_pos, 2
.annotate 'line', 1173
  # rx subrule "O" subtype=capture negate=
    rx2285_cur."!cursor_pos"(rx2285_pos)
    $P10 = rx2285_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx2285_fail
    rx2285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2285_pos = $P10."pos"()
.annotate 'line', 1168
  # rx pass
    rx2285_cur."!cursor_pass"(rx2285_pos, "infix:sym<?? !!>")
    if_null rx2285_debug, debug_1646
    rx2285_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx2285_pos)
  debug_1646:
    .return (rx2285_cur)
  rx2285_restart:
.annotate 'line', 462
    if_null rx2285_debug, debug_1647
    rx2285_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1647:
  rx2285_fail:
    (rx2285_rep, rx2285_pos, $I10, $P10) = rx2285_cur."!mark_fail"(0)
    lt rx2285_pos, -1, rx2285_done
    eq rx2285_pos, -1, rx2285_fail
    jump $I10
  rx2285_done:
    rx2285_cur."!cursor_fail"()
    if_null rx2285_debug, debug_1648
    rx2285_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1648:
    .return (rx2285_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("404_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("ws", "??")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("405_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2289_tgt
    .local int rx2289_pos
    .local int rx2289_off
    .local int rx2289_eos
    .local int rx2289_rep
    .local pmc rx2289_cur
    .local pmc rx2289_debug
    (rx2289_cur, rx2289_pos, rx2289_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2289_cur
    .local pmc match
    .lex "$/", match
    length rx2289_eos, rx2289_tgt
    gt rx2289_pos, rx2289_eos, rx2289_done
    set rx2289_off, 0
    lt rx2289_pos, 2, rx2289_start
    sub rx2289_off, rx2289_pos, 1
    substr rx2289_tgt, rx2289_tgt, rx2289_off
  rx2289_start:
    eq $I10, 1, rx2289_restart
    if_null rx2289_debug, debug_1649
    rx2289_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1649:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2290_done
    goto rxscan2290_scan
  rxscan2290_loop:
    (rx2289_pos) = rx2289_cur."from"()
    inc rx2289_pos
    rx2289_cur."!cursor_from"(rx2289_pos)
    ge rx2289_pos, rx2289_eos, rxscan2290_done
  rxscan2290_scan:
    set_addr $I10, rxscan2290_loop
    rx2289_cur."!mark_push"(0, rx2289_pos, $I10)
  rxscan2290_done:
.annotate 'line', 1177
  # rx subcapture "sym"
    set_addr $I10, rxcap_2291_fail
    rx2289_cur."!mark_push"(0, rx2289_pos, $I10)
  # rx literal  "="
    add $I11, rx2289_pos, 1
    gt $I11, rx2289_eos, rx2289_fail
    sub $I11, rx2289_pos, rx2289_off
    ord $I11, rx2289_tgt, $I11
    ne $I11, 61, rx2289_fail
    add rx2289_pos, 1
    set_addr $I10, rxcap_2291_fail
    ($I12, $I11) = rx2289_cur."!mark_peek"($I10)
    rx2289_cur."!cursor_pos"($I11)
    ($P10) = rx2289_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2289_pos, "")
    rx2289_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2291_done
  rxcap_2291_fail:
    goto rx2289_fail
  rxcap_2291_done:
  # rx subrule "panic" subtype=method negate=
    rx2289_cur."!cursor_pos"(rx2289_pos)
    $P10 = rx2289_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx2289_fail
    rx2289_pos = $P10."pos"()
.annotate 'line', 1176
  # rx pass
    rx2289_cur."!cursor_pass"(rx2289_pos, "infix:sym<=>")
    if_null rx2289_debug, debug_1650
    rx2289_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx2289_pos)
  debug_1650:
    .return (rx2289_cur)
  rx2289_restart:
.annotate 'line', 462
    if_null rx2289_debug, debug_1651
    rx2289_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1651:
  rx2289_fail:
    (rx2289_rep, rx2289_pos, $I10, $P10) = rx2289_cur."!mark_fail"(0)
    lt rx2289_pos, -1, rx2289_done
    eq rx2289_pos, -1, rx2289_fail
    jump $I10
  rx2289_done:
    rx2289_cur."!cursor_fail"()
    if_null rx2289_debug, debug_1652
    rx2289_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1652:
    .return (rx2289_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("406_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("panic", "=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("407_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2294_tgt
    .local int rx2294_pos
    .local int rx2294_off
    .local int rx2294_eos
    .local int rx2294_rep
    .local pmc rx2294_cur
    .local pmc rx2294_debug
    (rx2294_cur, rx2294_pos, rx2294_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2294_cur
    .local pmc match
    .lex "$/", match
    length rx2294_eos, rx2294_tgt
    gt rx2294_pos, rx2294_eos, rx2294_done
    set rx2294_off, 0
    lt rx2294_pos, 2, rx2294_start
    sub rx2294_off, rx2294_pos, 1
    substr rx2294_tgt, rx2294_tgt, rx2294_off
  rx2294_start:
    eq $I10, 1, rx2294_restart
    if_null rx2294_debug, debug_1653
    rx2294_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1653:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2295_done
    goto rxscan2295_scan
  rxscan2295_loop:
    (rx2294_pos) = rx2294_cur."from"()
    inc rx2294_pos
    rx2294_cur."!cursor_from"(rx2294_pos)
    ge rx2294_pos, rx2294_eos, rxscan2295_done
  rxscan2295_scan:
    set_addr $I10, rxscan2295_loop
    rx2294_cur."!mark_push"(0, rx2294_pos, $I10)
  rxscan2295_done:
.annotate 'line', 1179
  # rx subcapture "sym"
    set_addr $I10, rxcap_2296_fail
    rx2294_cur."!mark_push"(0, rx2294_pos, $I10)
  # rx literal  ":="
    add $I11, rx2294_pos, 2
    gt $I11, rx2294_eos, rx2294_fail
    sub $I11, rx2294_pos, rx2294_off
    substr $S10, rx2294_tgt, $I11, 2
    ne $S10, ":=", rx2294_fail
    add rx2294_pos, 2
    set_addr $I10, rxcap_2296_fail
    ($I12, $I11) = rx2294_cur."!mark_peek"($I10)
    rx2294_cur."!cursor_pos"($I11)
    ($P10) = rx2294_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2294_pos, "")
    rx2294_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2296_done
  rxcap_2296_fail:
    goto rx2294_fail
  rxcap_2296_done:
  # rx subrule "O" subtype=capture negate=
    rx2294_cur."!cursor_pos"(rx2294_pos)
    $P10 = rx2294_cur."O"("%assignment, :pasttype<bind_6model>")
    unless $P10, rx2294_fail
    rx2294_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2294_pos = $P10."pos"()
  # rx pass
    rx2294_cur."!cursor_pass"(rx2294_pos, "infix:sym<:=>")
    if_null rx2294_debug, debug_1654
    rx2294_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx2294_pos)
  debug_1654:
    .return (rx2294_cur)
  rx2294_restart:
.annotate 'line', 462
    if_null rx2294_debug, debug_1655
    rx2294_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1655:
  rx2294_fail:
    (rx2294_rep, rx2294_pos, $I10, $P10) = rx2294_cur."!mark_fail"(0)
    lt rx2294_pos, -1, rx2294_done
    eq rx2294_pos, -1, rx2294_fail
    jump $I10
  rx2294_done:
    rx2294_cur."!cursor_fail"()
    if_null rx2294_debug, debug_1656
    rx2294_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1656:
    .return (rx2294_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("408_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", ":=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("409_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2299_tgt
    .local int rx2299_pos
    .local int rx2299_off
    .local int rx2299_eos
    .local int rx2299_rep
    .local pmc rx2299_cur
    .local pmc rx2299_debug
    (rx2299_cur, rx2299_pos, rx2299_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2299_cur
    .local pmc match
    .lex "$/", match
    length rx2299_eos, rx2299_tgt
    gt rx2299_pos, rx2299_eos, rx2299_done
    set rx2299_off, 0
    lt rx2299_pos, 2, rx2299_start
    sub rx2299_off, rx2299_pos, 1
    substr rx2299_tgt, rx2299_tgt, rx2299_off
  rx2299_start:
    eq $I10, 1, rx2299_restart
    if_null rx2299_debug, debug_1657
    rx2299_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1657:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2300_done
    goto rxscan2300_scan
  rxscan2300_loop:
    (rx2299_pos) = rx2299_cur."from"()
    inc rx2299_pos
    rx2299_cur."!cursor_from"(rx2299_pos)
    ge rx2299_pos, rx2299_eos, rxscan2300_done
  rxscan2300_scan:
    set_addr $I10, rxscan2300_loop
    rx2299_cur."!mark_push"(0, rx2299_pos, $I10)
  rxscan2300_done:
.annotate 'line', 1180
  # rx subcapture "sym"
    set_addr $I10, rxcap_2301_fail
    rx2299_cur."!mark_push"(0, rx2299_pos, $I10)
  # rx literal  "::="
    add $I11, rx2299_pos, 3
    gt $I11, rx2299_eos, rx2299_fail
    sub $I11, rx2299_pos, rx2299_off
    substr $S10, rx2299_tgt, $I11, 3
    ne $S10, "::=", rx2299_fail
    add rx2299_pos, 3
    set_addr $I10, rxcap_2301_fail
    ($I12, $I11) = rx2299_cur."!mark_peek"($I10)
    rx2299_cur."!cursor_pos"($I11)
    ($P10) = rx2299_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2299_pos, "")
    rx2299_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2301_done
  rxcap_2301_fail:
    goto rx2299_fail
  rxcap_2301_done:
  # rx subrule "O" subtype=capture negate=
    rx2299_cur."!cursor_pos"(rx2299_pos)
    $P10 = rx2299_cur."O"("%assignment, :pasttype<bind_6model>")
    unless $P10, rx2299_fail
    rx2299_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2299_pos = $P10."pos"()
  # rx pass
    rx2299_cur."!cursor_pass"(rx2299_pos, "infix:sym<::=>")
    if_null rx2299_debug, debug_1658
    rx2299_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx2299_pos)
  debug_1658:
    .return (rx2299_cur)
  rx2299_restart:
.annotate 'line', 462
    if_null rx2299_debug, debug_1659
    rx2299_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1659:
  rx2299_fail:
    (rx2299_rep, rx2299_pos, $I10, $P10) = rx2299_cur."!mark_fail"(0)
    lt rx2299_pos, -1, rx2299_done
    eq rx2299_pos, -1, rx2299_fail
    jump $I10
  rx2299_done:
    rx2299_cur."!cursor_fail"()
    if_null rx2299_debug, debug_1660
    rx2299_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1660:
    .return (rx2299_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("410_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", "::=")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("411_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2304_tgt
    .local int rx2304_pos
    .local int rx2304_off
    .local int rx2304_eos
    .local int rx2304_rep
    .local pmc rx2304_cur
    .local pmc rx2304_debug
    (rx2304_cur, rx2304_pos, rx2304_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2304_cur
    .local pmc match
    .lex "$/", match
    length rx2304_eos, rx2304_tgt
    gt rx2304_pos, rx2304_eos, rx2304_done
    set rx2304_off, 0
    lt rx2304_pos, 2, rx2304_start
    sub rx2304_off, rx2304_pos, 1
    substr rx2304_tgt, rx2304_tgt, rx2304_off
  rx2304_start:
    eq $I10, 1, rx2304_restart
    if_null rx2304_debug, debug_1661
    rx2304_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1661:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2305_done
    goto rxscan2305_scan
  rxscan2305_loop:
    (rx2304_pos) = rx2304_cur."from"()
    inc rx2304_pos
    rx2304_cur."!cursor_from"(rx2304_pos)
    ge rx2304_pos, rx2304_eos, rxscan2305_done
  rxscan2305_scan:
    set_addr $I10, rxscan2305_loop
    rx2304_cur."!mark_push"(0, rx2304_pos, $I10)
  rxscan2305_done:
.annotate 'line', 1182
  # rx subcapture "sym"
    set_addr $I10, rxcap_2306_fail
    rx2304_cur."!mark_push"(0, rx2304_pos, $I10)
  # rx literal  ","
    add $I11, rx2304_pos, 1
    gt $I11, rx2304_eos, rx2304_fail
    sub $I11, rx2304_pos, rx2304_off
    ord $I11, rx2304_tgt, $I11
    ne $I11, 44, rx2304_fail
    add rx2304_pos, 1
    set_addr $I10, rxcap_2306_fail
    ($I12, $I11) = rx2304_cur."!mark_peek"($I10)
    rx2304_cur."!cursor_pos"($I11)
    ($P10) = rx2304_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2304_pos, "")
    rx2304_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2306_done
  rxcap_2306_fail:
    goto rx2304_fail
  rxcap_2306_done:
  # rx subrule "O" subtype=capture negate=
    rx2304_cur."!cursor_pos"(rx2304_pos)
    $P10 = rx2304_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx2304_fail
    rx2304_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2304_pos = $P10."pos"()
  # rx pass
    rx2304_cur."!cursor_pass"(rx2304_pos, "infix:sym<,>")
    if_null rx2304_debug, debug_1662
    rx2304_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx2304_pos)
  debug_1662:
    .return (rx2304_cur)
  rx2304_restart:
.annotate 'line', 462
    if_null rx2304_debug, debug_1663
    rx2304_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1663:
  rx2304_fail:
    (rx2304_rep, rx2304_pos, $I10, $P10) = rx2304_cur."!mark_fail"(0)
    lt rx2304_pos, -1, rx2304_done
    eq rx2304_pos, -1, rx2304_fail
    jump $I10
  rx2304_done:
    rx2304_cur."!cursor_fail"()
    if_null rx2304_debug, debug_1664
    rx2304_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1664:
    .return (rx2304_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("412_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    $P103 = self."!PREFIX__!subrule"("O", ",")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("413_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .const 'Sub' $P2313 = "414_1325892461.451" 
    capture_lex $P2313
    .local string rx2309_tgt
    .local int rx2309_pos
    .local int rx2309_off
    .local int rx2309_eos
    .local int rx2309_rep
    .local pmc rx2309_cur
    .local pmc rx2309_debug
    (rx2309_cur, rx2309_pos, rx2309_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2309_cur
    .local pmc match
    .lex "$/", match
    length rx2309_eos, rx2309_tgt
    gt rx2309_pos, rx2309_eos, rx2309_done
    set rx2309_off, 0
    lt rx2309_pos, 2, rx2309_start
    sub rx2309_off, rx2309_pos, 1
    substr rx2309_tgt, rx2309_tgt, rx2309_off
  rx2309_start:
    eq $I10, 1, rx2309_restart
    if_null rx2309_debug, debug_1665
    rx2309_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1665:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2310_done
    goto rxscan2310_scan
  rxscan2310_loop:
    (rx2309_pos) = rx2309_cur."from"()
    inc rx2309_pos
    rx2309_cur."!cursor_from"(rx2309_pos)
    ge rx2309_pos, rx2309_eos, rxscan2310_done
  rxscan2310_scan:
    set_addr $I10, rxscan2310_loop
    rx2309_cur."!mark_push"(0, rx2309_pos, $I10)
  rxscan2310_done:
.annotate 'line', 1184
  # rx subcapture "sym"
    set_addr $I10, rxcap_2311_fail
    rx2309_cur."!mark_push"(0, rx2309_pos, $I10)
  # rx literal  "return"
    add $I11, rx2309_pos, 6
    gt $I11, rx2309_eos, rx2309_fail
    sub $I11, rx2309_pos, rx2309_off
    substr $S10, rx2309_tgt, $I11, 6
    ne $S10, "return", rx2309_fail
    add rx2309_pos, 6
    set_addr $I10, rxcap_2311_fail
    ($I12, $I11) = rx2309_cur."!mark_peek"($I10)
    rx2309_cur."!cursor_pos"($I11)
    ($P10) = rx2309_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2309_pos, "")
    rx2309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2311_done
  rxcap_2311_fail:
    goto rx2309_fail
  rxcap_2311_done:
  # rx charclass s
    ge rx2309_pos, rx2309_eos, rx2309_fail
    sub $I10, rx2309_pos, rx2309_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2309_tgt, $I10
    unless $I11, rx2309_fail
    inc rx2309_pos
  # rx subrule "O" subtype=capture negate=
    rx2309_cur."!cursor_pos"(rx2309_pos)
    $P10 = rx2309_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx2309_fail
    rx2309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2309_pos = $P10."pos"()
    rx2309_cur."!cursor_pos"(rx2309_pos)
    find_lex $P103, unicode:"$\x{a2}"
    $P104 = $P103."MATCH"()
    store_lex "$/", $P104
    .const 'Sub' $P2313 = "414_1325892461.451" 
    capture_lex $P2313
    $P106 = $P2313()
  # rx pass
    rx2309_cur."!cursor_pass"(rx2309_pos, "prefix:sym<return>")
    if_null rx2309_debug, debug_1666
    rx2309_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx2309_pos)
  debug_1666:
    .return (rx2309_cur)
  rx2309_restart:
.annotate 'line', 462
    if_null rx2309_debug, debug_1667
    rx2309_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1667:
  rx2309_fail:
    (rx2309_rep, rx2309_pos, $I10, $P10) = rx2309_cur."!mark_fail"(0)
    lt rx2309_pos, -1, rx2309_done
    eq rx2309_pos, -1, rx2309_fail
    jump $I10
  rx2309_done:
    rx2309_cur."!cursor_fail"()
    if_null rx2309_debug, debug_1668
    rx2309_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1668:
    .return (rx2309_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block2312"  :anon :subid("414_1325892461.451") :outer("413_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1184
    new $P105, "Float"
    assign $P105, 1
    store_dynamic_lex "$*RETURN_USED", $P105
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("415_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P107, "ResizablePMCArray"
    push $P107, "return"
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("416_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2316_tgt
    .local int rx2316_pos
    .local int rx2316_off
    .local int rx2316_eos
    .local int rx2316_rep
    .local pmc rx2316_cur
    .local pmc rx2316_debug
    (rx2316_cur, rx2316_pos, rx2316_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2316_cur
    .local pmc match
    .lex "$/", match
    length rx2316_eos, rx2316_tgt
    gt rx2316_pos, rx2316_eos, rx2316_done
    set rx2316_off, 0
    lt rx2316_pos, 2, rx2316_start
    sub rx2316_off, rx2316_pos, 1
    substr rx2316_tgt, rx2316_tgt, rx2316_off
  rx2316_start:
    eq $I10, 1, rx2316_restart
    if_null rx2316_debug, debug_1669
    rx2316_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1669:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2317_done
    goto rxscan2317_scan
  rxscan2317_loop:
    (rx2316_pos) = rx2316_cur."from"()
    inc rx2316_pos
    rx2316_cur."!cursor_from"(rx2316_pos)
    ge rx2316_pos, rx2316_eos, rxscan2317_done
  rxscan2317_scan:
    set_addr $I10, rxscan2317_loop
    rx2316_cur."!mark_push"(0, rx2316_pos, $I10)
  rxscan2317_done:
.annotate 'line', 1185
  # rx subcapture "sym"
    set_addr $I10, rxcap_2318_fail
    rx2316_cur."!mark_push"(0, rx2316_pos, $I10)
  # rx literal  "make"
    add $I11, rx2316_pos, 4
    gt $I11, rx2316_eos, rx2316_fail
    sub $I11, rx2316_pos, rx2316_off
    substr $S10, rx2316_tgt, $I11, 4
    ne $S10, "make", rx2316_fail
    add rx2316_pos, 4
    set_addr $I10, rxcap_2318_fail
    ($I12, $I11) = rx2316_cur."!mark_peek"($I10)
    rx2316_cur."!cursor_pos"($I11)
    ($P10) = rx2316_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2316_pos, "")
    rx2316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2318_done
  rxcap_2318_fail:
    goto rx2316_fail
  rxcap_2318_done:
  # rx charclass s
    ge rx2316_pos, rx2316_eos, rx2316_fail
    sub $I10, rx2316_pos, rx2316_off
    is_cclass $I11, .CCLASS_WHITESPACE, rx2316_tgt, $I10
    unless $I11, rx2316_fail
    inc rx2316_pos
  # rx subrule "O" subtype=capture negate=
    rx2316_cur."!cursor_pos"(rx2316_pos)
    $P10 = rx2316_cur."O"("%list_prefix")
    unless $P10, rx2316_fail
    rx2316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx2316_pos = $P10."pos"()
  # rx pass
    rx2316_cur."!cursor_pass"(rx2316_pos, "prefix:sym<make>")
    if_null rx2316_debug, debug_1670
    rx2316_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx2316_pos)
  debug_1670:
    .return (rx2316_cur)
  rx2316_restart:
.annotate 'line', 462
    if_null rx2316_debug, debug_1671
    rx2316_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1671:
  rx2316_fail:
    (rx2316_rep, rx2316_pos, $I10, $P10) = rx2316_cur."!mark_fail"(0)
    lt rx2316_pos, -1, rx2316_done
    eq rx2316_pos, -1, rx2316_fail
    jump $I10
  rx2316_done:
    rx2316_cur."!cursor_fail"()
    if_null rx2316_debug, debug_1672
    rx2316_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1672:
    .return (rx2316_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("417_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "make"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("418_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2321_tgt
    .local int rx2321_pos
    .local int rx2321_off
    .local int rx2321_eos
    .local int rx2321_rep
    .local pmc rx2321_cur
    .local pmc rx2321_debug
    (rx2321_cur, rx2321_pos, rx2321_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2321_cur
    .local pmc match
    .lex "$/", match
    length rx2321_eos, rx2321_tgt
    gt rx2321_pos, rx2321_eos, rx2321_done
    set rx2321_off, 0
    lt rx2321_pos, 2, rx2321_start
    sub rx2321_off, rx2321_pos, 1
    substr rx2321_tgt, rx2321_tgt, rx2321_off
  rx2321_start:
    eq $I10, 1, rx2321_restart
    if_null rx2321_debug, debug_1673
    rx2321_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1673:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2322_done
    goto rxscan2322_scan
  rxscan2322_loop:
    (rx2321_pos) = rx2321_cur."from"()
    inc rx2321_pos
    rx2321_cur."!cursor_from"(rx2321_pos)
    ge rx2321_pos, rx2321_eos, rxscan2322_done
  rxscan2322_scan:
    set_addr $I10, rxscan2322_loop
    rx2321_cur."!mark_push"(0, rx2321_pos, $I10)
  rxscan2322_done:
.annotate 'line', 1186
  # rx subcapture "sym"
    set_addr $I10, rxcap_2323_fail
    rx2321_cur."!mark_push"(0, rx2321_pos, $I10)
  # rx literal  "last"
    add $I11, rx2321_pos, 4
    gt $I11, rx2321_eos, rx2321_fail
    sub $I11, rx2321_pos, rx2321_off
    substr $S10, rx2321_tgt, $I11, 4
    ne $S10, "last", rx2321_fail
    add rx2321_pos, 4
    set_addr $I10, rxcap_2323_fail
    ($I12, $I11) = rx2321_cur."!mark_peek"($I10)
    rx2321_cur."!cursor_pos"($I11)
    ($P10) = rx2321_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2321_pos, "")
    rx2321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2323_done
  rxcap_2323_fail:
    goto rx2321_fail
  rxcap_2323_done:
  # rx pass
    rx2321_cur."!cursor_pass"(rx2321_pos, "term:sym<last>")
    if_null rx2321_debug, debug_1674
    rx2321_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx2321_pos)
  debug_1674:
    .return (rx2321_cur)
  rx2321_restart:
.annotate 'line', 462
    if_null rx2321_debug, debug_1675
    rx2321_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1675:
  rx2321_fail:
    (rx2321_rep, rx2321_pos, $I10, $P10) = rx2321_cur."!mark_fail"(0)
    lt rx2321_pos, -1, rx2321_done
    eq rx2321_pos, -1, rx2321_fail
    jump $I10
  rx2321_done:
    rx2321_cur."!cursor_fail"()
    if_null rx2321_debug, debug_1676
    rx2321_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1676:
    .return (rx2321_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("419_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "last"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("420_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2326_tgt
    .local int rx2326_pos
    .local int rx2326_off
    .local int rx2326_eos
    .local int rx2326_rep
    .local pmc rx2326_cur
    .local pmc rx2326_debug
    (rx2326_cur, rx2326_pos, rx2326_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2326_cur
    .local pmc match
    .lex "$/", match
    length rx2326_eos, rx2326_tgt
    gt rx2326_pos, rx2326_eos, rx2326_done
    set rx2326_off, 0
    lt rx2326_pos, 2, rx2326_start
    sub rx2326_off, rx2326_pos, 1
    substr rx2326_tgt, rx2326_tgt, rx2326_off
  rx2326_start:
    eq $I10, 1, rx2326_restart
    if_null rx2326_debug, debug_1677
    rx2326_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1677:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2327_done
    goto rxscan2327_scan
  rxscan2327_loop:
    (rx2326_pos) = rx2326_cur."from"()
    inc rx2326_pos
    rx2326_cur."!cursor_from"(rx2326_pos)
    ge rx2326_pos, rx2326_eos, rxscan2327_done
  rxscan2327_scan:
    set_addr $I10, rxscan2327_loop
    rx2326_cur."!mark_push"(0, rx2326_pos, $I10)
  rxscan2327_done:
.annotate 'line', 1187
  # rx subcapture "sym"
    set_addr $I10, rxcap_2328_fail
    rx2326_cur."!mark_push"(0, rx2326_pos, $I10)
  # rx literal  "next"
    add $I11, rx2326_pos, 4
    gt $I11, rx2326_eos, rx2326_fail
    sub $I11, rx2326_pos, rx2326_off
    substr $S10, rx2326_tgt, $I11, 4
    ne $S10, "next", rx2326_fail
    add rx2326_pos, 4
    set_addr $I10, rxcap_2328_fail
    ($I12, $I11) = rx2326_cur."!mark_peek"($I10)
    rx2326_cur."!cursor_pos"($I11)
    ($P10) = rx2326_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2326_pos, "")
    rx2326_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2328_done
  rxcap_2328_fail:
    goto rx2326_fail
  rxcap_2328_done:
  # rx pass
    rx2326_cur."!cursor_pass"(rx2326_pos, "term:sym<next>")
    if_null rx2326_debug, debug_1678
    rx2326_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx2326_pos)
  debug_1678:
    .return (rx2326_cur)
  rx2326_restart:
.annotate 'line', 462
    if_null rx2326_debug, debug_1679
    rx2326_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1679:
  rx2326_fail:
    (rx2326_rep, rx2326_pos, $I10, $P10) = rx2326_cur."!mark_fail"(0)
    lt rx2326_pos, -1, rx2326_done
    eq rx2326_pos, -1, rx2326_fail
    jump $I10
  rx2326_done:
    rx2326_cur."!cursor_fail"()
    if_null rx2326_debug, debug_1680
    rx2326_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1680:
    .return (rx2326_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("421_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "next"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("422_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    .local string rx2331_tgt
    .local int rx2331_pos
    .local int rx2331_off
    .local int rx2331_eos
    .local int rx2331_rep
    .local pmc rx2331_cur
    .local pmc rx2331_debug
    (rx2331_cur, rx2331_pos, rx2331_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2331_cur
    .local pmc match
    .lex "$/", match
    length rx2331_eos, rx2331_tgt
    gt rx2331_pos, rx2331_eos, rx2331_done
    set rx2331_off, 0
    lt rx2331_pos, 2, rx2331_start
    sub rx2331_off, rx2331_pos, 1
    substr rx2331_tgt, rx2331_tgt, rx2331_off
  rx2331_start:
    eq $I10, 1, rx2331_restart
    if_null rx2331_debug, debug_1681
    rx2331_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1681:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2332_done
    goto rxscan2332_scan
  rxscan2332_loop:
    (rx2331_pos) = rx2331_cur."from"()
    inc rx2331_pos
    rx2331_cur."!cursor_from"(rx2331_pos)
    ge rx2331_pos, rx2331_eos, rxscan2332_done
  rxscan2332_scan:
    set_addr $I10, rxscan2332_loop
    rx2331_cur."!mark_push"(0, rx2331_pos, $I10)
  rxscan2332_done:
.annotate 'line', 1188
  # rx subcapture "sym"
    set_addr $I10, rxcap_2333_fail
    rx2331_cur."!mark_push"(0, rx2331_pos, $I10)
  # rx literal  "redo"
    add $I11, rx2331_pos, 4
    gt $I11, rx2331_eos, rx2331_fail
    sub $I11, rx2331_pos, rx2331_off
    substr $S10, rx2331_tgt, $I11, 4
    ne $S10, "redo", rx2331_fail
    add rx2331_pos, 4
    set_addr $I10, rxcap_2333_fail
    ($I12, $I11) = rx2331_cur."!mark_peek"($I10)
    rx2331_cur."!cursor_pos"($I11)
    ($P10) = rx2331_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2331_pos, "")
    rx2331_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_2333_done
  rxcap_2333_fail:
    goto rx2331_fail
  rxcap_2333_done:
  # rx pass
    rx2331_cur."!cursor_pass"(rx2331_pos, "term:sym<redo>")
    if_null rx2331_debug, debug_1682
    rx2331_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx2331_pos)
  debug_1682:
    .return (rx2331_cur)
  rx2331_restart:
.annotate 'line', 462
    if_null rx2331_debug, debug_1683
    rx2331_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1683:
  rx2331_fail:
    (rx2331_rep, rx2331_pos, $I10, $P10) = rx2331_cur."!mark_fail"(0)
    lt rx2331_pos, -1, rx2331_done
    eq rx2331_pos, -1, rx2331_fail
    jump $I10
  rx2331_done:
    rx2331_cur."!cursor_fail"()
    if_null rx2331_debug, debug_1684
    rx2331_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1684:
    .return (rx2331_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("423_1325892461.451") :method :outer("46_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 462
    new $P103, "ResizablePMCArray"
    push $P103, "redo"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch" :anon :subid("424_1325892461.451") :outer("46_1325892461.451")
    .param pmc param_2336
    .param pmc param_2337
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1190
    .lex "self", param_2336
    .lex "$/", param_2337
.annotate 'line', 1192
    new $P103, "Undef"
    set $P2338, $P103
    .lex "$t", $P2338
    new $P104, "Float"
    assign $P104, 0
    set $I100, $P104
    set $P2339, param_2337
    unless_null $P2339, vivify_1685
    $P2339 = root_new ['parrot';'ResizablePMCArray']
  vivify_1685:
    set $P105, $P2339[$I100]
    unless_null $P105, vivify_1686
    new $P105, "Undef"
  vivify_1686:
    set $P2338, $P105
    new $P104, "Float"
    assign $P104, 1
    set $I100, $P104
    set $P2340, param_2337
    unless_null $P2340, vivify_1687
    $P2340 = root_new ['parrot';'ResizablePMCArray']
  vivify_1687:
    set $P105, $P2340[$I100]
    unless_null $P105, vivify_1688
    new $P105, "Undef"
  vivify_1688:
    new $P106, "Float"
    assign $P106, 0
    set $I101, $P106
    set $P2341, param_2337
    unless_null $P2341, vivify_1689
    $P2341 = root_new ['parrot';'ResizablePMCArray']
    set param_2337, $P2341
  vivify_1689:
    set $P2341[$I101], $P105
    set $P104, $P2338
    unless_null $P104, vivify_1690
    new $P104, "Undef"
  vivify_1690:
    new $P105, "Float"
    assign $P105, 1
    set $I100, $P105
    set $P2342, param_2337
    unless_null $P2342, vivify_1691
    $P2342 = root_new ['parrot';'ResizablePMCArray']
    set param_2337, $P2342
  vivify_1691:
    set $P2342[$I100], $P104
.annotate 'line', 1190
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2344"  :subid("425_1325892461.451") :outer("10_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    .const 'Sub' $P2398 = "445_1325892461.451" 
    capture_lex $P2398
    .const 'Sub' $P2395 = "444_1325892461.451" 
    capture_lex $P2395
    .const 'Sub' $P2394 = "443_1325892461.451" 
    capture_lex $P2394
    .const 'Sub' $P2391 = "442_1325892461.451" 
    capture_lex $P2391
    .const 'Sub' $P2390 = "441_1325892461.451" 
    capture_lex $P2390
    .const 'Sub' $P2381 = "439_1325892461.451" 
    capture_lex $P2381
    .const 'Sub' $P2380 = "438_1325892461.451" 
    capture_lex $P2380
    .const 'Sub' $P2372 = "436_1325892461.451" 
    capture_lex $P2372
    .const 'Sub' $P2371 = "435_1325892461.451" 
    capture_lex $P2371
    .const 'Sub' $P2368 = "434_1325892461.451" 
    capture_lex $P2368
    .const 'Sub' $P2367 = "433_1325892461.451" 
    capture_lex $P2367
    .const 'Sub' $P2360 = "431_1325892461.451" 
    capture_lex $P2360
    .const 'Sub' $P2359 = "430_1325892461.451" 
    capture_lex $P2359
    .const 'Sub' $P2356 = "429_1325892461.451" 
    capture_lex $P2356
    .const 'Sub' $P2355 = "428_1325892461.451" 
    capture_lex $P2355
    .const 'Sub' $P2348 = "426_1325892461.451" 
    capture_lex $P2348
    .lex "$?PACKAGE", $P2346
    .lex "$?CLASS", $P2347
    .const 'Sub' $P2398 = "445_1325892461.451" 
    capture_lex $P2398
    .return ($P2398)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("426_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    .const 'Sub' $P2352 = "427_1325892461.451" 
    capture_lex $P2352
    .local string rx2349_tgt
    .local int rx2349_pos
    .local int rx2349_off
    .local int rx2349_eos
    .local int rx2349_rep
    .local pmc rx2349_cur
    .local pmc rx2349_debug
    (rx2349_cur, rx2349_pos, rx2349_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2349_cur
    .local pmc match
    .lex "$/", match
    length rx2349_eos, rx2349_tgt
    gt rx2349_pos, rx2349_eos, rx2349_done
    set rx2349_off, 0
    lt rx2349_pos, 2, rx2349_start
    sub rx2349_off, rx2349_pos, 1
    substr rx2349_tgt, rx2349_tgt, rx2349_off
  rx2349_start:
    eq $I10, 1, rx2349_restart
    if_null rx2349_debug, debug_1692
    rx2349_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2350_done
    goto rxscan2350_scan
  rxscan2350_loop:
    (rx2349_pos) = rx2349_cur."from"()
    inc rx2349_pos
    rx2349_cur."!cursor_from"(rx2349_pos)
    ge rx2349_pos, rx2349_eos, rxscan2350_done
  rxscan2350_scan:
    set_addr $I10, rxscan2350_loop
    rx2349_cur."!mark_push"(0, rx2349_pos, $I10)
  rxscan2350_done:
.annotate 'line', 1198
  # rx literal  ":"
    add $I11, rx2349_pos, 1
    gt $I11, rx2349_eos, rx2349_fail
    sub $I11, rx2349_pos, rx2349_off
    ord $I11, rx2349_tgt, $I11
    ne $I11, 58, rx2349_fail
    add rx2349_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2349_cur."!cursor_pos"(rx2349_pos)
    .const 'Sub' $P2352 = "427_1325892461.451" 
    capture_lex $P2352
    $P10 = rx2349_cur."before"($P2352)
    unless $P10, rx2349_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2349_cur."!cursor_pos"(rx2349_pos)
    $P10 = rx2349_cur."LANG"("MAIN", "statement")
    unless $P10, rx2349_fail
    rx2349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2349_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2349_cur."!cursor_pos"(rx2349_pos)
    $P10 = rx2349_cur."ws"()
    unless $P10, rx2349_fail
    rx2349_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2349_pos, 1
    gt $I11, rx2349_eos, rx2349_fail
    sub $I11, rx2349_pos, rx2349_off
    ord $I11, rx2349_tgt, $I11
    ne $I11, 59, rx2349_fail
    add rx2349_pos, 1
.annotate 'line', 1197
  # rx pass
    rx2349_cur."!cursor_pass"(rx2349_pos, "metachar:sym<:my>")
    if_null rx2349_debug, debug_1697
    rx2349_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2349_pos)
  debug_1697:
    .return (rx2349_cur)
  rx2349_restart:
.annotate 'line', 1196
    if_null rx2349_debug, debug_1698
    rx2349_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1698:
  rx2349_fail:
    (rx2349_rep, rx2349_pos, $I10, $P10) = rx2349_cur."!mark_fail"(0)
    lt rx2349_pos, -1, rx2349_done
    eq rx2349_pos, -1, rx2349_fail
    jump $I10
  rx2349_done:
    rx2349_cur."!cursor_fail"()
    if_null rx2349_debug, debug_1699
    rx2349_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1699:
    .return (rx2349_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2351"  :anon :subid("427_1325892461.451") :method :outer("426_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1198
    .local string rx2353_tgt
    .local int rx2353_pos
    .local int rx2353_off
    .local int rx2353_eos
    .local int rx2353_rep
    .local pmc rx2353_cur
    .local pmc rx2353_debug
    (rx2353_cur, rx2353_pos, rx2353_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2353_cur
    .local pmc match
    .lex "$/", match
    length rx2353_eos, rx2353_tgt
    gt rx2353_pos, rx2353_eos, rx2353_done
    set rx2353_off, 0
    lt rx2353_pos, 2, rx2353_start
    sub rx2353_off, rx2353_pos, 1
    substr rx2353_tgt, rx2353_tgt, rx2353_off
  rx2353_start:
    eq $I10, 1, rx2353_restart
    if_null rx2353_debug, debug_1693
    rx2353_cur."!cursor_debug"("START", "")
  debug_1693:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2354_done
    goto rxscan2354_scan
  rxscan2354_loop:
    (rx2353_pos) = rx2353_cur."from"()
    inc rx2353_pos
    rx2353_cur."!cursor_from"(rx2353_pos)
    ge rx2353_pos, rx2353_eos, rxscan2354_done
  rxscan2354_scan:
    set_addr $I10, rxscan2354_loop
    rx2353_cur."!mark_push"(0, rx2353_pos, $I10)
  rxscan2354_done:
  # rx literal  "my"
    add $I11, rx2353_pos, 2
    gt $I11, rx2353_eos, rx2353_fail
    sub $I11, rx2353_pos, rx2353_off
    substr $S10, rx2353_tgt, $I11, 2
    ne $S10, "my", rx2353_fail
    add rx2353_pos, 2
  # rx pass
    rx2353_cur."!cursor_pass"(rx2353_pos, "")
    if_null rx2353_debug, debug_1694
    rx2353_cur."!cursor_debug"("PASS", "", " at pos=", rx2353_pos)
  debug_1694:
    .return (rx2353_cur)
  rx2353_restart:
    if_null rx2353_debug, debug_1695
    rx2353_cur."!cursor_debug"("NEXT", "")
  debug_1695:
  rx2353_fail:
    (rx2353_rep, rx2353_pos, $I10, $P10) = rx2353_cur."!mark_fail"(0)
    lt rx2353_pos, -1, rx2353_done
    eq rx2353_pos, -1, rx2353_fail
    jump $I10
  rx2353_done:
    rx2353_cur."!cursor_fail"()
    if_null rx2353_debug, debug_1696
    rx2353_cur."!cursor_debug"("FAIL", "")
  debug_1696:
    .return (rx2353_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("428_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    new $P103, "ResizablePMCArray"
    push $P103, ":"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("429_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    .local string rx2357_tgt
    .local int rx2357_pos
    .local int rx2357_off
    .local int rx2357_eos
    .local int rx2357_rep
    .local pmc rx2357_cur
    .local pmc rx2357_debug
    (rx2357_cur, rx2357_pos, rx2357_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2357_cur
    .local pmc match
    .lex "$/", match
    length rx2357_eos, rx2357_tgt
    gt rx2357_pos, rx2357_eos, rx2357_done
    set rx2357_off, 0
    lt rx2357_pos, 2, rx2357_start
    sub rx2357_off, rx2357_pos, 1
    substr rx2357_tgt, rx2357_tgt, rx2357_off
  rx2357_start:
    eq $I10, 1, rx2357_restart
    if_null rx2357_debug, debug_1700
    rx2357_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2358_done
    goto rxscan2358_scan
  rxscan2358_loop:
    (rx2357_pos) = rx2357_cur."from"()
    inc rx2357_pos
    rx2357_cur."!cursor_from"(rx2357_pos)
    ge rx2357_pos, rx2357_eos, rxscan2358_done
  rxscan2358_scan:
    set_addr $I10, rxscan2358_loop
    rx2357_cur."!mark_push"(0, rx2357_pos, $I10)
  rxscan2358_done:
.annotate 'line', 1202
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2357_pos, rx2357_off
    substr $S10, rx2357_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2357_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2357_cur."!cursor_pos"(rx2357_pos)
    $P10 = rx2357_cur."codeblock"()
    unless $P10, rx2357_fail
    rx2357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2357_pos = $P10."pos"()
.annotate 'line', 1201
  # rx pass
    rx2357_cur."!cursor_pass"(rx2357_pos, "metachar:sym<{ }>")
    if_null rx2357_debug, debug_1701
    rx2357_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2357_pos)
  debug_1701:
    .return (rx2357_cur)
  rx2357_restart:
.annotate 'line', 1196
    if_null rx2357_debug, debug_1702
    rx2357_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1702:
  rx2357_fail:
    (rx2357_rep, rx2357_pos, $I10, $P10) = rx2357_cur."!mark_fail"(0)
    lt rx2357_pos, -1, rx2357_done
    eq rx2357_pos, -1, rx2357_fail
    jump $I10
  rx2357_done:
    rx2357_cur."!cursor_fail"()
    if_null rx2357_debug, debug_1703
    rx2357_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1703:
    .return (rx2357_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("430_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("431_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    .const 'Sub' $P2364 = "432_1325892461.451" 
    capture_lex $P2364
    .local string rx2361_tgt
    .local int rx2361_pos
    .local int rx2361_off
    .local int rx2361_eos
    .local int rx2361_rep
    .local pmc rx2361_cur
    .local pmc rx2361_debug
    (rx2361_cur, rx2361_pos, rx2361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2361_cur
    .local pmc match
    .lex "$/", match
    length rx2361_eos, rx2361_tgt
    gt rx2361_pos, rx2361_eos, rx2361_done
    set rx2361_off, 0
    lt rx2361_pos, 2, rx2361_start
    sub rx2361_off, rx2361_pos, 1
    substr rx2361_tgt, rx2361_tgt, rx2361_off
  rx2361_start:
    eq $I10, 1, rx2361_restart
    if_null rx2361_debug, debug_1704
    rx2361_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2362_done
    goto rxscan2362_scan
  rxscan2362_loop:
    (rx2361_pos) = rx2361_cur."from"()
    inc rx2361_pos
    rx2361_cur."!cursor_from"(rx2361_pos)
    ge rx2361_pos, rx2361_eos, rxscan2362_done
  rxscan2362_scan:
    set_addr $I10, rxscan2362_loop
    rx2361_cur."!mark_push"(0, rx2361_pos, $I10)
  rxscan2362_done:
.annotate 'line', 1206
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2361_pos, rx2361_off
    substr $S10, rx2361_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2361_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    .const 'Sub' $P2364 = "432_1325892461.451" 
    capture_lex $P2364
    $P10 = rx2361_cur."before"($P2364)
    unless $P10, rx2361_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2361_cur."!cursor_pos"(rx2361_pos)
    $P10 = rx2361_cur."LANG"("MAIN", "variable")
    unless $P10, rx2361_fail
    rx2361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2361_pos = $P10."pos"()
.annotate 'line', 1205
  # rx pass
    rx2361_cur."!cursor_pass"(rx2361_pos, "metachar:sym<nqpvar>")
    if_null rx2361_debug, debug_1709
    rx2361_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2361_pos)
  debug_1709:
    .return (rx2361_cur)
  rx2361_restart:
.annotate 'line', 1196
    if_null rx2361_debug, debug_1710
    rx2361_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1710:
  rx2361_fail:
    (rx2361_rep, rx2361_pos, $I10, $P10) = rx2361_cur."!mark_fail"(0)
    lt rx2361_pos, -1, rx2361_done
    eq rx2361_pos, -1, rx2361_fail
    jump $I10
  rx2361_done:
    rx2361_cur."!cursor_fail"()
    if_null rx2361_debug, debug_1711
    rx2361_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1711:
    .return (rx2361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2363"  :anon :subid("432_1325892461.451") :method :outer("431_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1206
    .local string rx2365_tgt
    .local int rx2365_pos
    .local int rx2365_off
    .local int rx2365_eos
    .local int rx2365_rep
    .local pmc rx2365_cur
    .local pmc rx2365_debug
    (rx2365_cur, rx2365_pos, rx2365_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2365_cur
    .local pmc match
    .lex "$/", match
    length rx2365_eos, rx2365_tgt
    gt rx2365_pos, rx2365_eos, rx2365_done
    set rx2365_off, 0
    lt rx2365_pos, 2, rx2365_start
    sub rx2365_off, rx2365_pos, 1
    substr rx2365_tgt, rx2365_tgt, rx2365_off
  rx2365_start:
    eq $I10, 1, rx2365_restart
    if_null rx2365_debug, debug_1705
    rx2365_cur."!cursor_debug"("START", "")
  debug_1705:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2366_done
    goto rxscan2366_scan
  rxscan2366_loop:
    (rx2365_pos) = rx2365_cur."from"()
    inc rx2365_pos
    rx2365_cur."!cursor_from"(rx2365_pos)
    ge rx2365_pos, rx2365_eos, rxscan2366_done
  rxscan2366_scan:
    set_addr $I10, rxscan2366_loop
    rx2365_cur."!mark_push"(0, rx2365_pos, $I10)
  rxscan2366_done:
  # rx charclass .
    ge rx2365_pos, rx2365_eos, rx2365_fail
    inc rx2365_pos
  # rx charclass w
    ge rx2365_pos, rx2365_eos, rx2365_fail
    sub $I10, rx2365_pos, rx2365_off
    is_cclass $I11, .CCLASS_WORD, rx2365_tgt, $I10
    unless $I11, rx2365_fail
    inc rx2365_pos
  # rx pass
    rx2365_cur."!cursor_pass"(rx2365_pos, "")
    if_null rx2365_debug, debug_1706
    rx2365_cur."!cursor_debug"("PASS", "", " at pos=", rx2365_pos)
  debug_1706:
    .return (rx2365_cur)
  rx2365_restart:
    if_null rx2365_debug, debug_1707
    rx2365_cur."!cursor_debug"("NEXT", "")
  debug_1707:
  rx2365_fail:
    (rx2365_rep, rx2365_pos, $I10, $P10) = rx2365_cur."!mark_fail"(0)
    lt rx2365_pos, -1, rx2365_done
    eq rx2365_pos, -1, rx2365_fail
    jump $I10
  rx2365_done:
    rx2365_cur."!cursor_fail"()
    if_null rx2365_debug, debug_1708
    rx2365_cur."!cursor_debug"("FAIL", "")
  debug_1708:
    .return (rx2365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("433_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("434_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    .local string rx2369_tgt
    .local int rx2369_pos
    .local int rx2369_off
    .local int rx2369_eos
    .local int rx2369_rep
    .local pmc rx2369_cur
    .local pmc rx2369_debug
    (rx2369_cur, rx2369_pos, rx2369_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2369_cur
    .local pmc match
    .lex "$/", match
    length rx2369_eos, rx2369_tgt
    gt rx2369_pos, rx2369_eos, rx2369_done
    set rx2369_off, 0
    lt rx2369_pos, 2, rx2369_start
    sub rx2369_off, rx2369_pos, 1
    substr rx2369_tgt, rx2369_tgt, rx2369_off
  rx2369_start:
    eq $I10, 1, rx2369_restart
    if_null rx2369_debug, debug_1712
    rx2369_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2370_done
    goto rxscan2370_scan
  rxscan2370_loop:
    (rx2369_pos) = rx2369_cur."from"()
    inc rx2369_pos
    rx2369_cur."!cursor_from"(rx2369_pos)
    ge rx2369_pos, rx2369_eos, rxscan2370_done
  rxscan2370_scan:
    set_addr $I10, rxscan2370_loop
    rx2369_cur."!mark_push"(0, rx2369_pos, $I10)
  rxscan2370_done:
.annotate 'line', 1210
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2369_pos, rx2369_off
    substr $S10, rx2369_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2369_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2369_cur."!cursor_pos"(rx2369_pos)
    $P10 = rx2369_cur."codeblock"()
    unless $P10, rx2369_fail
    rx2369_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2369_pos = $P10."pos"()
.annotate 'line', 1209
  # rx pass
    rx2369_cur."!cursor_pass"(rx2369_pos, "assertion:sym<{ }>")
    if_null rx2369_debug, debug_1713
    rx2369_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2369_pos)
  debug_1713:
    .return (rx2369_cur)
  rx2369_restart:
.annotate 'line', 1196
    if_null rx2369_debug, debug_1714
    rx2369_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1714:
  rx2369_fail:
    (rx2369_rep, rx2369_pos, $I10, $P10) = rx2369_cur."!mark_fail"(0)
    lt rx2369_pos, -1, rx2369_done
    eq rx2369_pos, -1, rx2369_fail
    jump $I10
  rx2369_done:
    rx2369_cur."!cursor_fail"()
    if_null rx2369_debug, debug_1715
    rx2369_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1715:
    .return (rx2369_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("435_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    new $P103, "ResizablePMCArray"
    push $P103, "{"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("436_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    .const 'Sub' $P2376 = "437_1325892461.451" 
    capture_lex $P2376
    .local string rx2373_tgt
    .local int rx2373_pos
    .local int rx2373_off
    .local int rx2373_eos
    .local int rx2373_rep
    .local pmc rx2373_cur
    .local pmc rx2373_debug
    (rx2373_cur, rx2373_pos, rx2373_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2373_cur
    .local pmc match
    .lex "$/", match
    length rx2373_eos, rx2373_tgt
    gt rx2373_pos, rx2373_eos, rx2373_done
    set rx2373_off, 0
    lt rx2373_pos, 2, rx2373_start
    sub rx2373_off, rx2373_pos, 1
    substr rx2373_tgt, rx2373_tgt, rx2373_off
  rx2373_start:
    eq $I10, 1, rx2373_restart
    if_null rx2373_debug, debug_1716
    rx2373_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1716:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2374_done
    goto rxscan2374_scan
  rxscan2374_loop:
    (rx2373_pos) = rx2373_cur."from"()
    inc rx2373_pos
    rx2373_cur."!cursor_from"(rx2373_pos)
    ge rx2373_pos, rx2373_eos, rxscan2374_done
  rxscan2374_scan:
    set_addr $I10, rxscan2374_loop
    rx2373_cur."!mark_push"(0, rx2373_pos, $I10)
  rxscan2374_done:
.annotate 'line', 1214
  # rx subcapture "zw"
    set_addr $I10, rxcap_2379_fail
    rx2373_cur."!mark_push"(0, rx2373_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2373_pos, rx2373_eos, rx2373_fail
    sub $I10, rx2373_pos, rx2373_off
    substr $S10, rx2373_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2373_fail
    inc rx2373_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2373_cur."!cursor_pos"(rx2373_pos)
    .const 'Sub' $P2376 = "437_1325892461.451" 
    capture_lex $P2376
    $P10 = rx2373_cur."before"($P2376)
    unless $P10, rx2373_fail
    set_addr $I10, rxcap_2379_fail
    ($I12, $I11) = rx2373_cur."!mark_peek"($I10)
    rx2373_cur."!cursor_pos"($I11)
    ($P10) = rx2373_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2373_pos, "")
    rx2373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2379_done
  rxcap_2379_fail:
    goto rx2373_fail
  rxcap_2379_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2373_cur."!cursor_pos"(rx2373_pos)
    $P10 = rx2373_cur."codeblock"()
    unless $P10, rx2373_fail
    rx2373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2373_pos = $P10."pos"()
.annotate 'line', 1213
  # rx pass
    rx2373_cur."!cursor_pass"(rx2373_pos, "assertion:sym<?{ }>")
    if_null rx2373_debug, debug_1721
    rx2373_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2373_pos)
  debug_1721:
    .return (rx2373_cur)
  rx2373_restart:
.annotate 'line', 1196
    if_null rx2373_debug, debug_1722
    rx2373_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1722:
  rx2373_fail:
    (rx2373_rep, rx2373_pos, $I10, $P10) = rx2373_cur."!mark_fail"(0)
    lt rx2373_pos, -1, rx2373_done
    eq rx2373_pos, -1, rx2373_fail
    jump $I10
  rx2373_done:
    rx2373_cur."!cursor_fail"()
    if_null rx2373_debug, debug_1723
    rx2373_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1723:
    .return (rx2373_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2375"  :anon :subid("437_1325892461.451") :method :outer("436_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1214
    .local string rx2377_tgt
    .local int rx2377_pos
    .local int rx2377_off
    .local int rx2377_eos
    .local int rx2377_rep
    .local pmc rx2377_cur
    .local pmc rx2377_debug
    (rx2377_cur, rx2377_pos, rx2377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2377_cur
    .local pmc match
    .lex "$/", match
    length rx2377_eos, rx2377_tgt
    gt rx2377_pos, rx2377_eos, rx2377_done
    set rx2377_off, 0
    lt rx2377_pos, 2, rx2377_start
    sub rx2377_off, rx2377_pos, 1
    substr rx2377_tgt, rx2377_tgt, rx2377_off
  rx2377_start:
    eq $I10, 1, rx2377_restart
    if_null rx2377_debug, debug_1717
    rx2377_cur."!cursor_debug"("START", "")
  debug_1717:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2378_done
    goto rxscan2378_scan
  rxscan2378_loop:
    (rx2377_pos) = rx2377_cur."from"()
    inc rx2377_pos
    rx2377_cur."!cursor_from"(rx2377_pos)
    ge rx2377_pos, rx2377_eos, rxscan2378_done
  rxscan2378_scan:
    set_addr $I10, rxscan2378_loop
    rx2377_cur."!mark_push"(0, rx2377_pos, $I10)
  rxscan2378_done:
  # rx literal  "{"
    add $I11, rx2377_pos, 1
    gt $I11, rx2377_eos, rx2377_fail
    sub $I11, rx2377_pos, rx2377_off
    ord $I11, rx2377_tgt, $I11
    ne $I11, 123, rx2377_fail
    add rx2377_pos, 1
  # rx pass
    rx2377_cur."!cursor_pass"(rx2377_pos, "")
    if_null rx2377_debug, debug_1718
    rx2377_cur."!cursor_debug"("PASS", "", " at pos=", rx2377_pos)
  debug_1718:
    .return (rx2377_cur)
  rx2377_restart:
    if_null rx2377_debug, debug_1719
    rx2377_cur."!cursor_debug"("NEXT", "")
  debug_1719:
  rx2377_fail:
    (rx2377_rep, rx2377_pos, $I10, $P10) = rx2377_cur."!mark_fail"(0)
    lt rx2377_pos, -1, rx2377_done
    eq rx2377_pos, -1, rx2377_fail
    jump $I10
  rx2377_done:
    rx2377_cur."!cursor_fail"()
    if_null rx2377_debug, debug_1720
    rx2377_cur."!cursor_debug"("FAIL", "")
  debug_1720:
    .return (rx2377_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("438_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    new $P103, "ResizablePMCArray"
    push $P103, "!"
    push $P103, "?"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("439_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    .const 'Sub' $P2387 = "440_1325892461.451" 
    capture_lex $P2387
    .local string rx2382_tgt
    .local int rx2382_pos
    .local int rx2382_off
    .local int rx2382_eos
    .local int rx2382_rep
    .local pmc rx2382_cur
    .local pmc rx2382_debug
    (rx2382_cur, rx2382_pos, rx2382_tgt, $I10) = self."!cursor_start"()
    rx2382_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2382_cur
    .local pmc match
    .lex "$/", match
    length rx2382_eos, rx2382_tgt
    gt rx2382_pos, rx2382_eos, rx2382_done
    set rx2382_off, 0
    lt rx2382_pos, 2, rx2382_start
    sub rx2382_off, rx2382_pos, 1
    substr rx2382_tgt, rx2382_tgt, rx2382_off
  rx2382_start:
    eq $I10, 1, rx2382_restart
    if_null rx2382_debug, debug_1724
    rx2382_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2383_done
    goto rxscan2383_scan
  rxscan2383_loop:
    (rx2382_pos) = rx2382_cur."from"()
    inc rx2382_pos
    rx2382_cur."!cursor_from"(rx2382_pos)
    ge rx2382_pos, rx2382_eos, rxscan2383_done
  rxscan2383_scan:
    set_addr $I10, rxscan2383_loop
    rx2382_cur."!mark_push"(0, rx2382_pos, $I10)
  rxscan2383_done:
.annotate 'line', 1218
  # rx subrule "identifier" subtype=capture negate=
    rx2382_cur."!cursor_pos"(rx2382_pos)
    $P10 = rx2382_cur."identifier"()
    unless $P10, rx2382_fail
    rx2382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2382_pos = $P10."pos"()
.annotate 'line', 1225
  # rx rxquantr2384 ** 0..1
    set_addr $I10, rxquantr2384_done
    rx2382_cur."!mark_push"(0, rx2382_pos, $I10)
  rxquantr2384_loop:
  alt2385_0:
.annotate 'line', 1219
    set_addr $I10, alt2385_1
    rx2382_cur."!mark_push"(0, rx2382_pos, $I10)
.annotate 'line', 1220
  # rx subrule "before" subtype=zerowidth negate=
    rx2382_cur."!cursor_pos"(rx2382_pos)
    .const 'Sub' $P2387 = "440_1325892461.451" 
    capture_lex $P2387
    $P10 = rx2382_cur."before"($P2387)
    unless $P10, rx2382_fail
    goto alt2385_end
  alt2385_1:
    set_addr $I10, alt2385_2
    rx2382_cur."!mark_push"(0, rx2382_pos, $I10)
.annotate 'line', 1221
  # rx literal  "="
    add $I11, rx2382_pos, 1
    gt $I11, rx2382_eos, rx2382_fail
    sub $I11, rx2382_pos, rx2382_off
    ord $I11, rx2382_tgt, $I11
    ne $I11, 61, rx2382_fail
    add rx2382_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2382_cur."!cursor_pos"(rx2382_pos)
    $P10 = rx2382_cur."assertion"()
    unless $P10, rx2382_fail
    rx2382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2382_pos = $P10."pos"()
    goto alt2385_end
  alt2385_2:
    set_addr $I10, alt2385_3
    rx2382_cur."!mark_push"(0, rx2382_pos, $I10)
.annotate 'line', 1222
  # rx literal  ":"
    add $I11, rx2382_pos, 1
    gt $I11, rx2382_eos, rx2382_fail
    sub $I11, rx2382_pos, rx2382_off
    ord $I11, rx2382_tgt, $I11
    ne $I11, 58, rx2382_fail
    add rx2382_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2382_cur."!cursor_pos"(rx2382_pos)
    $P10 = rx2382_cur."arglist"()
    unless $P10, rx2382_fail
    rx2382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2382_pos = $P10."pos"()
    goto alt2385_end
  alt2385_3:
    set_addr $I10, alt2385_4
    rx2382_cur."!mark_push"(0, rx2382_pos, $I10)
.annotate 'line', 1223
  # rx literal  "("
    add $I11, rx2382_pos, 1
    gt $I11, rx2382_eos, rx2382_fail
    sub $I11, rx2382_pos, rx2382_off
    ord $I11, rx2382_tgt, $I11
    ne $I11, 40, rx2382_fail
    add rx2382_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2382_cur."!cursor_pos"(rx2382_pos)
    $P10 = rx2382_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2382_fail
    rx2382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2382_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2382_pos, 1
    gt $I11, rx2382_eos, rx2382_fail
    sub $I11, rx2382_pos, rx2382_off
    ord $I11, rx2382_tgt, $I11
    ne $I11, 41, rx2382_fail
    add rx2382_pos, 1
    goto alt2385_end
  alt2385_4:
.annotate 'line', 1224
  # rx subrule "normspace" subtype=method negate=
    rx2382_cur."!cursor_pos"(rx2382_pos)
    $P10 = rx2382_cur."normspace"()
    unless $P10, rx2382_fail
    rx2382_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2382_cur."!cursor_pos"(rx2382_pos)
    $P10 = rx2382_cur."nibbler"()
    unless $P10, rx2382_fail
    rx2382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2382_pos = $P10."pos"()
  alt2385_end:
.annotate 'line', 1225
    set_addr $I10, rxquantr2384_done
    (rx2382_rep) = rx2382_cur."!mark_commit"($I10)
  rxquantr2384_done:
.annotate 'line', 1217
  # rx pass
    rx2382_cur."!cursor_pass"(rx2382_pos, "assertion:sym<name>")
    if_null rx2382_debug, debug_1729
    rx2382_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2382_pos)
  debug_1729:
    .return (rx2382_cur)
  rx2382_restart:
.annotate 'line', 1196
    if_null rx2382_debug, debug_1730
    rx2382_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1730:
  rx2382_fail:
    (rx2382_rep, rx2382_pos, $I10, $P10) = rx2382_cur."!mark_fail"(0)
    lt rx2382_pos, -1, rx2382_done
    eq rx2382_pos, -1, rx2382_fail
    jump $I10
  rx2382_done:
    rx2382_cur."!cursor_fail"()
    if_null rx2382_debug, debug_1731
    rx2382_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1731:
    .return (rx2382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2386"  :anon :subid("440_1325892461.451") :method :outer("439_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1220
    .local string rx2388_tgt
    .local int rx2388_pos
    .local int rx2388_off
    .local int rx2388_eos
    .local int rx2388_rep
    .local pmc rx2388_cur
    .local pmc rx2388_debug
    (rx2388_cur, rx2388_pos, rx2388_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2388_cur
    .local pmc match
    .lex "$/", match
    length rx2388_eos, rx2388_tgt
    gt rx2388_pos, rx2388_eos, rx2388_done
    set rx2388_off, 0
    lt rx2388_pos, 2, rx2388_start
    sub rx2388_off, rx2388_pos, 1
    substr rx2388_tgt, rx2388_tgt, rx2388_off
  rx2388_start:
    eq $I10, 1, rx2388_restart
    if_null rx2388_debug, debug_1725
    rx2388_cur."!cursor_debug"("START", "")
  debug_1725:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2389_done
    goto rxscan2389_scan
  rxscan2389_loop:
    (rx2388_pos) = rx2388_cur."from"()
    inc rx2388_pos
    rx2388_cur."!cursor_from"(rx2388_pos)
    ge rx2388_pos, rx2388_eos, rxscan2389_done
  rxscan2389_scan:
    set_addr $I10, rxscan2389_loop
    rx2388_cur."!mark_push"(0, rx2388_pos, $I10)
  rxscan2389_done:
  # rx literal  ">"
    add $I11, rx2388_pos, 1
    gt $I11, rx2388_eos, rx2388_fail
    sub $I11, rx2388_pos, rx2388_off
    ord $I11, rx2388_tgt, $I11
    ne $I11, 62, rx2388_fail
    add rx2388_pos, 1
  # rx pass
    rx2388_cur."!cursor_pass"(rx2388_pos, "")
    if_null rx2388_debug, debug_1726
    rx2388_cur."!cursor_debug"("PASS", "", " at pos=", rx2388_pos)
  debug_1726:
    .return (rx2388_cur)
  rx2388_restart:
    if_null rx2388_debug, debug_1727
    rx2388_cur."!cursor_debug"("NEXT", "")
  debug_1727:
  rx2388_fail:
    (rx2388_rep, rx2388_pos, $I10, $P10) = rx2388_cur."!mark_fail"(0)
    lt rx2388_pos, -1, rx2388_done
    eq rx2388_pos, -1, rx2388_fail
    jump $I10
  rx2388_done:
    rx2388_cur."!cursor_fail"()
    if_null rx2388_debug, debug_1728
    rx2388_cur."!cursor_debug"("FAIL", "")
  debug_1728:
    .return (rx2388_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("441_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    $P103 = self."!PREFIX__!subrule"("identifier", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("442_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    .local string rx2392_tgt
    .local int rx2392_pos
    .local int rx2392_off
    .local int rx2392_eos
    .local int rx2392_rep
    .local pmc rx2392_cur
    .local pmc rx2392_debug
    (rx2392_cur, rx2392_pos, rx2392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2392_cur
    .local pmc match
    .lex "$/", match
    length rx2392_eos, rx2392_tgt
    gt rx2392_pos, rx2392_eos, rx2392_done
    set rx2392_off, 0
    lt rx2392_pos, 2, rx2392_start
    sub rx2392_off, rx2392_pos, 1
    substr rx2392_tgt, rx2392_tgt, rx2392_off
  rx2392_start:
    eq $I10, 1, rx2392_restart
    if_null rx2392_debug, debug_1732
    rx2392_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2393_done
    goto rxscan2393_scan
  rxscan2393_loop:
    (rx2392_pos) = rx2392_cur."from"()
    inc rx2392_pos
    rx2392_cur."!cursor_from"(rx2392_pos)
    ge rx2392_pos, rx2392_eos, rxscan2393_done
  rxscan2393_scan:
    set_addr $I10, rxscan2393_loop
    rx2392_cur."!mark_push"(0, rx2392_pos, $I10)
  rxscan2393_done:
.annotate 'line', 1229
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2392_pos, rx2392_off
    substr $S10, rx2392_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2392_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2392_cur."!cursor_pos"(rx2392_pos)
    $P10 = rx2392_cur."LANG"("MAIN", "variable")
    unless $P10, rx2392_fail
    rx2392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2392_pos = $P10."pos"()
.annotate 'line', 1228
  # rx pass
    rx2392_cur."!cursor_pass"(rx2392_pos, "assertion:sym<var>")
    if_null rx2392_debug, debug_1733
    rx2392_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2392_pos)
  debug_1733:
    .return (rx2392_cur)
  rx2392_restart:
.annotate 'line', 1196
    if_null rx2392_debug, debug_1734
    rx2392_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1734:
  rx2392_fail:
    (rx2392_rep, rx2392_pos, $I10, $P10) = rx2392_cur."!mark_fail"(0)
    lt rx2392_pos, -1, rx2392_done
    eq rx2392_pos, -1, rx2392_fail
    jump $I10
  rx2392_done:
    rx2392_cur."!cursor_fail"()
    if_null rx2392_debug, debug_1735
    rx2392_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1735:
    .return (rx2392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("443_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    new $P103, "ResizablePMCArray"
    push $P103, "$"
    push $P103, "@"
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("444_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    .local string rx2396_tgt
    .local int rx2396_pos
    .local int rx2396_off
    .local int rx2396_eos
    .local int rx2396_rep
    .local pmc rx2396_cur
    .local pmc rx2396_debug
    (rx2396_cur, rx2396_pos, rx2396_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2396_cur
    .local pmc match
    .lex "$/", match
    length rx2396_eos, rx2396_tgt
    gt rx2396_pos, rx2396_eos, rx2396_done
    set rx2396_off, 0
    lt rx2396_pos, 2, rx2396_start
    sub rx2396_off, rx2396_pos, 1
    substr rx2396_tgt, rx2396_tgt, rx2396_off
  rx2396_start:
    eq $I10, 1, rx2396_restart
    if_null rx2396_debug, debug_1736
    rx2396_cur."!cursor_debug"("START", "codeblock")
  debug_1736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2397_done
    goto rxscan2397_scan
  rxscan2397_loop:
    (rx2396_pos) = rx2396_cur."from"()
    inc rx2396_pos
    rx2396_cur."!cursor_from"(rx2396_pos)
    ge rx2396_pos, rx2396_eos, rxscan2397_done
  rxscan2397_scan:
    set_addr $I10, rxscan2397_loop
    rx2396_cur."!mark_push"(0, rx2396_pos, $I10)
  rxscan2397_done:
.annotate 'line', 1233
  # rx subrule "LANG" subtype=capture negate=
    rx2396_cur."!cursor_pos"(rx2396_pos)
    $P10 = rx2396_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2396_fail
    rx2396_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2396_pos = $P10."pos"()
.annotate 'line', 1232
  # rx pass
    rx2396_cur."!cursor_pass"(rx2396_pos, "codeblock")
    if_null rx2396_debug, debug_1737
    rx2396_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2396_pos)
  debug_1737:
    .return (rx2396_cur)
  rx2396_restart:
.annotate 'line', 1196
    if_null rx2396_debug, debug_1738
    rx2396_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1738:
  rx2396_fail:
    (rx2396_rep, rx2396_pos, $I10, $P10) = rx2396_cur."!mark_fail"(0)
    lt rx2396_pos, -1, rx2396_done
    eq rx2396_pos, -1, rx2396_fail
    jump $I10
  rx2396_done:
    rx2396_cur."!cursor_fail"()
    if_null rx2396_debug, debug_1739
    rx2396_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1739:
    .return (rx2396_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("445_1325892461.451") :method :outer("425_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1196
    $P103 = self."!PREFIX__!subrule"("LANG", "")
    new $P104, "ResizablePMCArray"
    push $P104, $P103
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2399"  :subid("446_1325892461.451") :outer("10_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1239
    .const 'Sub' $P3727 = "626_1325892461.451" 
    capture_lex $P3727
    .const 'Sub' $P3724 = "625_1325892461.451" 
    capture_lex $P3724
    .const 'Sub' $P3721 = "624_1325892461.451" 
    capture_lex $P3721
    .const 'Sub' $P3718 = "623_1325892461.451" 
    capture_lex $P3718
    .const 'Sub' $P3715 = "622_1325892461.451" 
    capture_lex $P3715
    .const 'Sub' $P3712 = "621_1325892461.451" 
    capture_lex $P3712
    .const 'Sub' $P3709 = "620_1325892461.451" 
    capture_lex $P3709
    .const 'Sub' $P3706 = "619_1325892461.451" 
    capture_lex $P3706
    .const 'Sub' $P3702 = "618_1325892461.451" 
    capture_lex $P3702
    .const 'Sub' $P3699 = "617_1325892461.451" 
    capture_lex $P3699
    .const 'Sub' $P3695 = "616_1325892461.451" 
    capture_lex $P3695
    .const 'Sub' $P3691 = "615_1325892461.451" 
    capture_lex $P3691
    .const 'Sub' $P3677 = "614_1325892461.451" 
    capture_lex $P3677
    .const 'Sub' $P3673 = "613_1325892461.451" 
    capture_lex $P3673
    .const 'Sub' $P3669 = "612_1325892461.451" 
    capture_lex $P3669
    .const 'Sub' $P3665 = "611_1325892461.451" 
    capture_lex $P3665
    .const 'Sub' $P3661 = "610_1325892461.451" 
    capture_lex $P3661
    .const 'Sub' $P3657 = "609_1325892461.451" 
    capture_lex $P3657
    .const 'Sub' $P3653 = "608_1325892461.451" 
    capture_lex $P3653
    .const 'Sub' $P3643 = "607_1325892461.451" 
    capture_lex $P3643
    .const 'Sub' $P3636 = "606_1325892461.451" 
    capture_lex $P3636
    .const 'Sub' $P3632 = "605_1325892461.451" 
    capture_lex $P3632
    .const 'Sub' $P3628 = "604_1325892461.451" 
    capture_lex $P3628
    .const 'Sub' $P3624 = "603_1325892461.451" 
    capture_lex $P3624
    .const 'Sub' $P3620 = "602_1325892461.451" 
    capture_lex $P3620
    .const 'Sub' $P3616 = "601_1325892461.451" 
    capture_lex $P3616
    .const 'Sub' $P3607 = "600_1325892461.451" 
    capture_lex $P3607
    .const 'Sub' $P3589 = "598_1325892461.451" 
    capture_lex $P3589
    .const 'Sub' $P3585 = "597_1325892461.451" 
    capture_lex $P3585
    .const 'Sub' $P3581 = "596_1325892461.451" 
    capture_lex $P3581
    .const 'Sub' $P3572 = "595_1325892461.451" 
    capture_lex $P3572
    .const 'Sub' $P3565 = "594_1325892461.451" 
    capture_lex $P3565
    .const 'Sub' $P3561 = "593_1325892461.451" 
    capture_lex $P3561
    .const 'Sub' $P3557 = "592_1325892461.451" 
    capture_lex $P3557
    .const 'Sub' $P3526 = "589_1325892461.451" 
    capture_lex $P3526
    .const 'Sub' $P3522 = "588_1325892461.451" 
    capture_lex $P3522
    .const 'Sub' $P3519 = "587_1325892461.451" 
    capture_lex $P3519
    .const 'Sub' $P3507 = "586_1325892461.451" 
    capture_lex $P3507
    .const 'Sub' $P3503 = "585_1325892461.451" 
    capture_lex $P3503
    .const 'Sub' $P3493 = "584_1325892461.451" 
    capture_lex $P3493
    .const 'Sub' $P3474 = "582_1325892461.451" 
    capture_lex $P3474
    .const 'Sub' $P3468 = "581_1325892461.451" 
    capture_lex $P3468
    .const 'Sub' $P3465 = "580_1325892461.451" 
    capture_lex $P3465
    .const 'Sub' $P3445 = "579_1325892461.451" 
    capture_lex $P3445
    .const 'Sub' $P3393 = "574_1325892461.451" 
    capture_lex $P3393
    .const 'Sub' $P3357 = "569_1325892461.451" 
    capture_lex $P3357
    .const 'Sub' $P3353 = "568_1325892461.451" 
    capture_lex $P3353
    .const 'Sub' $P3335 = "566_1325892461.451" 
    capture_lex $P3335
    .const 'Sub' $P3328 = "565_1325892461.451" 
    capture_lex $P3328
    .const 'Sub' $P3322 = "564_1325892461.451" 
    capture_lex $P3322
    .const 'Sub' $P3283 = "563_1325892461.451" 
    capture_lex $P3283
    .const 'Sub' $P3263 = "560_1325892461.451" 
    capture_lex $P3263
    .const 'Sub' $P3230 = "557_1325892461.451" 
    capture_lex $P3230
    .const 'Sub' $P3149 = "550_1325892461.451" 
    capture_lex $P3149
    .const 'Sub' $P3145 = "549_1325892461.451" 
    capture_lex $P3145
    .const 'Sub' $P3141 = "548_1325892461.451" 
    capture_lex $P3141
    .const 'Sub' $P3100 = "545_1325892461.451" 
    capture_lex $P3100
    .const 'Sub' $P3096 = "544_1325892461.451" 
    capture_lex $P3096
    .const 'Sub' $P3089 = "543_1325892461.451" 
    capture_lex $P3089
    .const 'Sub' $P3082 = "542_1325892461.451" 
    capture_lex $P3082
    .const 'Sub' $P3075 = "541_1325892461.451" 
    capture_lex $P3075
    .const 'Sub' $P3065 = "540_1325892461.451" 
    capture_lex $P3065
    .const 'Sub' $P3061 = "539_1325892461.451" 
    capture_lex $P3061
    .const 'Sub' $P3057 = "538_1325892461.451" 
    capture_lex $P3057
    .const 'Sub' $P3053 = "537_1325892461.451" 
    capture_lex $P3053
    .const 'Sub' $P2986 = "531_1325892461.451" 
    capture_lex $P2986
    .const 'Sub' $P2958 = "530_1325892461.451" 
    capture_lex $P2958
    .const 'Sub' $P2954 = "529_1325892461.451" 
    capture_lex $P2954
    .const 'Sub' $P2950 = "528_1325892461.451" 
    capture_lex $P2950
    .const 'Sub' $P2946 = "527_1325892461.451" 
    capture_lex $P2946
    .const 'Sub' $P2942 = "526_1325892461.451" 
    capture_lex $P2942
    .const 'Sub' $P2938 = "525_1325892461.451" 
    capture_lex $P2938
    .const 'Sub' $P2934 = "524_1325892461.451" 
    capture_lex $P2934
    .const 'Sub' $P2880 = "518_1325892461.451" 
    capture_lex $P2880
    .const 'Sub' $P2870 = "517_1325892461.451" 
    capture_lex $P2870
    .const 'Sub' $P2864 = "516_1325892461.451" 
    capture_lex $P2864
    .const 'Sub' $P2860 = "515_1325892461.451" 
    capture_lex $P2860
    .const 'Sub' $P2856 = "514_1325892461.451" 
    capture_lex $P2856
    .const 'Sub' $P2852 = "513_1325892461.451" 
    capture_lex $P2852
    .const 'Sub' $P2848 = "512_1325892461.451" 
    capture_lex $P2848
    .const 'Sub' $P2844 = "511_1325892461.451" 
    capture_lex $P2844
    .const 'Sub' $P2840 = "510_1325892461.451" 
    capture_lex $P2840
    .const 'Sub' $P2836 = "509_1325892461.451" 
    capture_lex $P2836
    .const 'Sub' $P2832 = "508_1325892461.451" 
    capture_lex $P2832
    .const 'Sub' $P2828 = "507_1325892461.451" 
    capture_lex $P2828
    .const 'Sub' $P2824 = "506_1325892461.451" 
    capture_lex $P2824
    .const 'Sub' $P2820 = "505_1325892461.451" 
    capture_lex $P2820
    .const 'Sub' $P2816 = "504_1325892461.451" 
    capture_lex $P2816
    .const 'Sub' $P2812 = "503_1325892461.451" 
    capture_lex $P2812
    .const 'Sub' $P2805 = "502_1325892461.451" 
    capture_lex $P2805
    .const 'Sub' $P2798 = "501_1325892461.451" 
    capture_lex $P2798
    .const 'Sub' $P2793 = "500_1325892461.451" 
    capture_lex $P2793
    .const 'Sub' $P2787 = "499_1325892461.451" 
    capture_lex $P2787
    .const 'Sub' $P2781 = "498_1325892461.451" 
    capture_lex $P2781
    .const 'Sub' $P2772 = "497_1325892461.451" 
    capture_lex $P2772
    .const 'Sub' $P2761 = "496_1325892461.451" 
    capture_lex $P2761
    .const 'Sub' $P2755 = "495_1325892461.451" 
    capture_lex $P2755
    .const 'Sub' $P2750 = "494_1325892461.451" 
    capture_lex $P2750
    .const 'Sub' $P2731 = "492_1325892461.451" 
    capture_lex $P2731
    .const 'Sub' $P2725 = "491_1325892461.451" 
    capture_lex $P2725
    .const 'Sub' $P2722 = "490_1325892461.451" 
    capture_lex $P2722
    .const 'Sub' $P2717 = "489_1325892461.451" 
    capture_lex $P2717
    .const 'Sub' $P2702 = "487_1325892461.451" 
    capture_lex $P2702
    .const 'Sub' $P2698 = "486_1325892461.451" 
    capture_lex $P2698
    .const 'Sub' $P2685 = "484_1325892461.451" 
    capture_lex $P2685
    .const 'Sub' $P2681 = "483_1325892461.451" 
    capture_lex $P2681
    .const 'Sub' $P2677 = "482_1325892461.451" 
    capture_lex $P2677
    .const 'Sub' $P2672 = "481_1325892461.451" 
    capture_lex $P2672
    .const 'Sub' $P2643 = "479_1325892461.451" 
    capture_lex $P2643
    .const 'Sub' $P2625 = "477_1325892461.451" 
    capture_lex $P2625
    .const 'Sub' $P2604 = "475_1325892461.451" 
    capture_lex $P2604
    .const 'Sub' $P2594 = "474_1325892461.451" 
    capture_lex $P2594
    .const 'Sub' $P2590 = "473_1325892461.451" 
    capture_lex $P2590
    .const 'Sub' $P2535 = "467_1325892461.451" 
    capture_lex $P2535
    .const 'Sub' $P2518 = "465_1325892461.451" 
    capture_lex $P2518
    .const 'Sub' $P2514 = "464_1325892461.451" 
    capture_lex $P2514
    .const 'Sub' $P2510 = "463_1325892461.451" 
    capture_lex $P2510
    .const 'Sub' $P2482 = "460_1325892461.451" 
    capture_lex $P2482
    .const 'Sub' $P2477 = "459_1325892461.451" 
    capture_lex $P2477
    .const 'Sub' $P2457 = "457_1325892461.451" 
    capture_lex $P2457
    .const 'Sub' $P2452 = "456_1325892461.451" 
    capture_lex $P2452
    .const 'Sub' $P2442 = "455_1325892461.451" 
    capture_lex $P2442
    .const 'Sub' $P2432 = "453_1325892461.451" 
    capture_lex $P2432
    .const 'Sub' $P2427 = "452_1325892461.451" 
    capture_lex $P2427
    .const 'Sub' $P2421 = "451_1325892461.451" 
    capture_lex $P2421
    .const 'Sub' $P2408 = "448_1325892461.451" 
    capture_lex $P2408
    .const 'Sub' $P2402 = "447_1325892461.451" 
    capture_lex $P2402
.annotate 'line', 1243
    .const 'Sub' $P2402 = "447_1325892461.451" 
    newclosure $P2406, $P2402
    set $P2401, $P2406
    .lex "xblock_immediate", $P2401
.annotate 'line', 1248
    .const 'Sub' $P2408 = "448_1325892461.451" 
    newclosure $P2419, $P2408
    set $P2407, $P2419
    .lex "block_immediate", $P2407
.annotate 'line', 1258
    .const 'Sub' $P2421 = "451_1325892461.451" 
    newclosure $P2425, $P2421
    set $P2420, $P2425
    .lex "vivitype", $P2420
.annotate 'line', 1277
    .const 'Sub' $P2427 = "452_1325892461.451" 
    newclosure $P2430, $P2427
    set $P2426, $P2430
    .lex "colonpair_str", $P2426
.annotate 'line', 1458
    .const 'Sub' $P2432 = "453_1325892461.451" 
    newclosure $P2440, $P2432
    set $P2431, $P2440
    .lex "import_HOW_exports", $P2431
.annotate 'line', 1563
    .const 'Sub' $P2442 = "455_1325892461.451" 
    newclosure $P2450, $P2442
    set $P2441, $P2450
    .lex "push_block_handler", $P2441
.annotate 'line', 2112
    .const 'Sub' $P2452 = "456_1325892461.451" 
    newclosure $P2455, $P2452
    set $P2451, $P2455
    .lex "only_star_block", $P2451
.annotate 'line', 2121
    .const 'Sub' $P2457 = "457_1325892461.451" 
    newclosure $P2475, $P2457
    set $P2456, $P2475
    .lex "attach_multi_signature", $P2456
.annotate 'line', 2603
    .const 'Sub' $P2477 = "459_1325892461.451" 
    newclosure $P2480, $P2477
    set $P2476, $P2480
    .lex "control", $P2476
.annotate 'line', 2622
    .const 'Sub' $P2482 = "460_1325892461.451" 
    newclosure $P2508, $P2482
    set $P2481, $P2508
    .lex "lexical_package_lookup", $P2481
.annotate 'line', 2671
    .const 'Sub' $P2510 = "463_1325892461.451" 
    newclosure $P2512, $P2510
    set $P2509, $P2512
    .lex "is_lexical", $P2509
.annotate 'line', 2677
    .const 'Sub' $P2514 = "464_1325892461.451" 
    newclosure $P2516, $P2514
    set $P2513, $P2516
    .lex "is_package", $P2513
.annotate 'line', 2683
    .const 'Sub' $P2518 = "465_1325892461.451" 
    newclosure $P2533, $P2518
    set $P2517, $P2533
    .lex "is_scope", $P2517
.annotate 'line', 2706
    .const 'Sub' $P2535 = "467_1325892461.451" 
    newclosure $P2587, $P2535
    set $P2534, $P2587
    .lex "find_sym", $P2534
.annotate 'line', 1239
    .lex "$?PACKAGE", $P2588
    .lex "$?CLASS", $P2589
.annotate 'line', 1241
    new $P122, "ResizablePMCArray"
    set $P123, $P2588
    get_who $P124, $P123
    set $P124["@BLOCK"], $P122
.annotate 'line', 1239
    set $P122, $P2401
    set $P122, $P2407
    set $P122, $P2420
    set $P122, $P2426
    set $P122, $P2431
    set $P122, $P2441
    set $P122, $P2451
    set $P122, $P2456
    set $P122, $P2476
    set $P122, $P2481
    set $P122, $P2509
    set $P122, $P2513
    set $P122, $P2517
    set $P122, $P2534
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("447_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2403
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1243
    .lex "$xblock", param_2403
.annotate 'line', 1244
    new $P103, "Float"
    assign $P103, 1
    set $I100, $P103
    set $P2404, param_2403
    unless_null $P2404, vivify_1740
    $P2404 = root_new ['parrot';'ResizablePMCArray']
  vivify_1740:
    set $P104, $P2404[$I100]
    unless_null $P104, vivify_1741
    new $P104, "Undef"
  vivify_1741:
    $P105 = "block_immediate"($P104)
    new $P106, "Float"
    assign $P106, 1
    set $I101, $P106
    set $P2405, param_2403
    unless_null $P2405, vivify_1742
    $P2405 = root_new ['parrot';'ResizablePMCArray']
    set param_2403, $P2405
  vivify_1742:
    set $P2405[$I101], $P105
.annotate 'line', 1243
    set $P103, param_2403
    unless_null $P103, vivify_1743
    new $P103, "Undef"
  vivify_1743:
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("448_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2409
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1248
    .const 'Sub' $P2413 = "449_1325892461.451" 
    capture_lex $P2413
    .lex "$block", param_2409
.annotate 'line', 1249
    set $P104, param_2409
    unless_null $P104, vivify_1744
    new $P104, "Undef"
  vivify_1744:
    $P104."blocktype"("immediate")
.annotate 'line', 1250
    set $P105, param_2409
    unless_null $P105, vivify_1745
    new $P105, "Undef"
  vivify_1745:
    $P106 = $P105."symtable"()
    unless $P106, unless_2411
    set $P104, $P106
    goto unless_2411_end
  unless_2411:
    set $P107, param_2409
    unless_null $P107, vivify_1746
    new $P107, "Undef"
  vivify_1746:
    $P108 = $P107."handlers"()
    set $P104, $P108
  unless_2411_end:
    if $P104, unless_2410_end
    .const 'Sub' $P2413 = "449_1325892461.451" 
    capture_lex $P2413
    $P2413()
  unless_2410_end:
.annotate 'line', 1248
    set $P104, param_2409
    unless_null $P104, vivify_1753
    new $P104, "Undef"
  vivify_1753:
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2412"  :anon :subid("449_1325892461.451") :outer("448_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1250
    .const 'Sub' $P2416 = "450_1325892461.451" 
    capture_lex $P2416
.annotate 'line', 1251
    new $P109, "Undef"
    set $P2414, $P109
    .lex "$stmts", $P2414
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Stmts"]
    find_lex $P114, "$block"
    unless_null $P114, vivify_1747
    new $P114, "Undef"
  vivify_1747:
    $P115 = $P113."new"($P114 :named("node"))
    set $P2414, $P115
.annotate 'line', 1252
    find_lex $P111, "$block"
    unless_null $P111, vivify_1748
    new $P111, "Undef"
  vivify_1748:
    $P112 = $P111."list"()
    defined $I100, $P112
    unless $I100, for_undef_1749
    iter $P110, $P112
    new $P114, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P114, loop2418_handler
    push_eh $P114
  loop2418_test:
    unless $P110, loop2418_done
    shift $P113, $P110
  loop2418_redo:
    .const 'Sub' $P2416 = "450_1325892461.451" 
    capture_lex $P2416
    $P2416($P113)
  loop2418_next:
    goto loop2418_test
  loop2418_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P115, exception, 'type'
    eq $P115, .CONTROL_LOOP_NEXT, loop2418_next
    eq $P115, .CONTROL_LOOP_REDO, loop2418_redo
  loop2418_done:
    pop_eh 
  for_undef_1749:
.annotate 'line', 1253
    set $P110, $P2414
    unless_null $P110, vivify_1752
    new $P110, "Undef"
  vivify_1752:
    store_lex "$block", $P110
.annotate 'line', 1250
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2415"  :anon :subid("450_1325892461.451") :outer("449_1325892461.451")
    .param pmc param_2417
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1252
    .lex "$_", param_2417
    find_lex $P114, "$stmts"
    unless_null $P114, vivify_1750
    new $P114, "Undef"
  vivify_1750:
    find_lex $P115, "$_"
    unless_null $P115, vivify_1751
    new $P115, "Undef"
  vivify_1751:
    $P116 = $P114."push"($P115)
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("451_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2422
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1258
    .lex "$sigil", param_2422
.annotate 'line', 1259
    set $P106, param_2422
    unless_null $P106, vivify_1754
    new $P106, "Undef"
  vivify_1754:
    set $S100, $P106
    iseq $I100, $S100, "%"
    if $I100, if_2423
.annotate 'line', 1261
    set $P113, param_2422
    unless_null $P113, vivify_1755
    new $P113, "Undef"
  vivify_1755:
    set $S101, $P113
    iseq $I101, $S101, "@"
    if $I101, if_2424
    new $P119, "String"
    assign $P119, "Undef"
    set $P112, $P119
    goto if_2424_end
  if_2424:
.annotate 'line', 1262
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Op"]
    $P118 = $P117."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P112, $P118
  if_2424_end:
    set $P105, $P112
.annotate 'line', 1259
    goto if_2423_end
  if_2423:
.annotate 'line', 1260
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
    $P111 = $P110."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P105, $P111
  if_2423_end:
.annotate 'line', 1258
    .return ($P105)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("452_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2428
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1277
    .lex "$ast", param_2428
.annotate 'line', 1278
    get_hll_global $P107, "GLOBAL"
    nqp_get_package_through_who $P108, $P107, "PAST"
    get_who $P109, $P108
    set $P110, $P109["Op"]
    set $P111, param_2428
    unless_null $P111, vivify_1756
    new $P111, "Undef"
  vivify_1756:
    $P112 = $P110."ACCEPTS"($P111)
    if $P112, if_2429
.annotate 'line', 1280
    set $P115, param_2428
    unless_null $P115, vivify_1757
    new $P115, "Undef"
  vivify_1757:
    $P116 = $P115."value"()
    set $P106, $P116
.annotate 'line', 1278
    goto if_2429_end
  if_2429:
.annotate 'line', 1279
    set $P113, param_2428
    unless_null $P113, vivify_1758
    new $P113, "Undef"
  vivify_1758:
    $P114 = $P113."list"()
    join $S100, " ", $P114
    new $P106, 'String'
    set $P106, $S100
  if_2429_end:
.annotate 'line', 1277
    .return ($P106)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("453_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2433
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1458
    .const 'Sub' $P2437 = "454_1325892461.451" 
    capture_lex $P2437
    .lex "$UNIT", param_2433
.annotate 'line', 1460
    set $P108, param_2433
    unless_null $P108, vivify_1759
    new $P108, "Undef"
  vivify_1759:
    exists $I100, $P108["EXPORTHOW"]
    if $I100, if_2434
    new $P107, 'Integer'
    set $P107, $I100
    goto if_2434_end
  if_2434:
.annotate 'line', 1461
    set $P2435, param_2433
    unless_null $P2435, vivify_1760
    $P2435 = root_new ['parrot';'Hash']
  vivify_1760:
    set $P110, $P2435["EXPORTHOW"]
    unless_null $P110, vivify_1761
    new $P110, "Undef"
  vivify_1761:
    get_who $P111, $P110
    defined $I101, $P111
    unless $I101, for_undef_1762
    iter $P109, $P111
    new $P113, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P113, loop2439_handler
    push_eh $P113
  loop2439_test:
    unless $P109, loop2439_done
    shift $P112, $P109
  loop2439_redo:
    .const 'Sub' $P2437 = "454_1325892461.451" 
    capture_lex $P2437
    $P2437($P112)
  loop2439_next:
    goto loop2439_test
  loop2439_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P115, exception, 'type'
    eq $P115, .CONTROL_LOOP_NEXT, loop2439_next
    eq $P115, .CONTROL_LOOP_REDO, loop2439_redo
  loop2439_done:
    pop_eh 
  for_undef_1762:
.annotate 'line', 1460
    set $P107, $P109
  if_2434_end:
.annotate 'line', 1458
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2436"  :anon :subid("454_1325892461.451") :outer("453_1325892461.451")
    .param pmc param_2438
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1461
    .lex "$_", param_2438
.annotate 'line', 1462
    find_lex $P113, "$_"
    unless_null $P113, vivify_1763
    new $P113, "Undef"
  vivify_1763:
    $P114 = $P113."value"()
    find_lex $P115, "$_"
    unless_null $P115, vivify_1764
    new $P115, "Undef"
  vivify_1764:
    $P116 = $P115."key"()
    find_dynamic_lex $P119, "%*HOW"
    unless_null $P119, vivify_1765
    get_hll_global $P117, "GLOBAL"
    get_who $P118, $P117
    set $P119, $P118["%HOW"]
    unless_null $P119, vivify_1766
    die "Contextual %*HOW not found"
  vivify_1766:
    store_dynamic_lex "%*HOW", $P119
  vivify_1765:
    set $P119[$P116], $P114
.annotate 'line', 1461
    .return ($P114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("455_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2443
    .param pmc param_2444
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1563
    .lex "$/", param_2443
    .lex "$block", param_2444
.annotate 'line', 1564
    new $P108, "Float"
    assign $P108, 0
    set $I100, $P108
    find_lex $P109, "$?PACKAGE"
    get_who $P110, $P109
    set $P2446, $P110["@BLOCK"]
    unless_null $P2446, vivify_1767
    $P2446 = root_new ['parrot';'ResizablePMCArray']
  vivify_1767:
    set $P111, $P2446[$I100]
    unless_null $P111, vivify_1768
    new $P111, "Undef"
  vivify_1768:
    $P112 = $P111."handlers"()
    if $P112, unless_2445_end
.annotate 'line', 1565
    new $P113, "Float"
    assign $P113, 0
    set $I101, $P113
    find_lex $P114, "$?PACKAGE"
    get_who $P115, $P114
    set $P2447, $P115["@BLOCK"]
    unless_null $P2447, vivify_1769
    $P2447 = root_new ['parrot';'ResizablePMCArray']
  vivify_1769:
    set $P116, $P2447[$I101]
    unless_null $P116, vivify_1770
    new $P116, "Undef"
  vivify_1770:
    new $P117, "ResizablePMCArray"
    $P116."handlers"($P117)
  unless_2445_end:
.annotate 'line', 1567
    set $P108, param_2444
    unless_null $P108, vivify_1771
    new $P108, "Undef"
  vivify_1771:
    $P109 = $P108."arity"()
    if $P109, unless_2448_end
.annotate 'line', 1568
    set $P110, param_2444
    unless_null $P110, vivify_1772
    new $P110, "Undef"
  vivify_1772:
.annotate 'line', 1569
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Op"]
.annotate 'line', 1570
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P118, $P117["Var"]
    $P119 = $P118."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1571
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    $P124 = $P123."new"("lexical" :named("scope"), "$_" :named("name"))
    $P125 = $P114."new"($P119, $P124, "bind_6model" :named("pasttype"))
.annotate 'line', 1569
    $P110."unshift"($P125)
.annotate 'line', 1574
    set $P110, param_2444
    unless_null $P110, vivify_1773
    new $P110, "Undef"
  vivify_1773:
    get_hll_global $P111, "GLOBAL"
    nqp_get_package_through_who $P112, $P111, "PAST"
    get_who $P113, $P112
    set $P114, $P113["Var"]
    $P115 = $P114."new"("$_" :named("name"), "parameter" :named("scope"))
    $P110."unshift"($P115)
.annotate 'line', 1575
    set $P110, param_2444
    unless_null $P110, vivify_1774
    new $P110, "Undef"
  vivify_1774:
    $P110."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1576
    set $P110, param_2444
    unless_null $P110, vivify_1775
    new $P110, "Undef"
  vivify_1775:
    $P110."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1577
    set $P110, param_2444
    unless_null $P110, vivify_1776
    new $P110, "Undef"
  vivify_1776:
    $P110."arity"(1)
  unless_2448_end:
.annotate 'line', 1579
    set $P108, param_2444
    unless_null $P108, vivify_1777
    new $P108, "Undef"
  vivify_1777:
    $P108."blocktype"("declaration")
.annotate 'line', 1580
    new $P108, "Float"
    assign $P108, 0
    set $I100, $P108
    find_lex $P109, "$?PACKAGE"
    get_who $P110, $P109
    set $P2449, $P110["@BLOCK"]
    unless_null $P2449, vivify_1778
    $P2449 = root_new ['parrot';'ResizablePMCArray']
  vivify_1778:
    set $P111, $P2449[$I100]
    unless_null $P111, vivify_1779
    new $P111, "Undef"
  vivify_1779:
    $P112 = $P111."handlers"()
.annotate 'line', 1581
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Control"]
    set $P117, param_2443
    unless_null $P117, vivify_1780
    new $P117, "Undef"
  vivify_1780:
.annotate 'line', 1583
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Stmts"]
.annotate 'line', 1584
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Op"]
    set $P126, param_2444
    unless_null $P126, vivify_1781
    new $P126, "Undef"
  vivify_1781:
.annotate 'line', 1586
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    $P131 = $P130."new"("register" :named("scope"), "exception" :named("name"))
    $P132 = $P125."new"($P126, $P131, "call" :named("pasttype"))
.annotate 'line', 1588
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Op"]
.annotate 'line', 1589
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "PAST"
    get_who $P139, $P138
    set $P140, $P139["Var"]
.annotate 'line', 1590
    get_hll_global $P141, "GLOBAL"
    nqp_get_package_through_who $P142, $P141, "PAST"
    get_who $P143, $P142
    set $P144, $P143["Var"]
    $P145 = $P144."new"("register" :named("scope"), "exception" :named("name"))
    $P146 = $P140."new"($P145, "handled", "keyed" :named("scope"))
.annotate 'line', 1589
    $P147 = $P136."new"($P146, 1, "bind_6model" :named("pasttype"))
.annotate 'line', 1588
    $P148 = $P121."new"($P132, $P147)
.annotate 'line', 1583
    $P149 = $P116."new"($P148, $P117 :named("node"))
.annotate 'line', 1581
    $P150 = $P112."unshift"($P149)
.annotate 'line', 1563
    .return ($P150)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("456_1325892461.451") :outer("446_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2113
    new $P108, "Undef"
    set $P2453, $P108
    .lex "$past", $P2453
    find_lex $P109, "$?PACKAGE"
    get_who $P110, $P109
    set $P2454, $P110["@BLOCK"]
    unless_null $P2454, vivify_1782
    $P2454 = root_new ['parrot';'ResizablePMCArray']
  vivify_1782:
    $P111 = $P2454."shift"()
    set $P2453, $P111
.annotate 'line', 2114
    set $P109, $P2453
    unless_null $P109, vivify_1783
    new $P109, "Undef"
  vivify_1783:
    $P109."closure"(1)
.annotate 'line', 2115
    set $P109, $P2453
    unless_null $P109, vivify_1784
    new $P109, "Undef"
  vivify_1784:
    get_hll_global $P110, "GLOBAL"
    nqp_get_package_through_who $P111, $P110, "PAST"
    get_who $P112, $P111
    set $P113, $P112["Op"]
    $P114 = $P113."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P109."push"($P114)
.annotate 'line', 2112
    set $P109, $P2453
    unless_null $P109, vivify_1785
    new $P109, "Undef"
  vivify_1785:
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("457_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2458
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2121
    .const 'Sub' $P2463 = "458_1325892461.451" 
    capture_lex $P2463
    .lex "$routine", param_2458
.annotate 'line', 2125
    new $P110, "Undef"
    set $P2459, $P110
    .lex "$types", $P2459
.annotate 'line', 2126
    new $P111, "Undef"
    set $P2460, $P111
    .lex "$definednesses", $P2460
.annotate 'line', 2125
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("list" :named("pasttype"))
    set $P2459, $P116
.annotate 'line', 2126
    get_hll_global $P112, "GLOBAL"
    nqp_get_package_through_who $P113, $P112, "PAST"
    get_who $P114, $P113
    set $P115, $P114["Op"]
    $P116 = $P115."new"("list" :named("pasttype"))
    set $P2460, $P116
.annotate 'line', 2127
    new $P113, "Float"
    assign $P113, 0
    set $I100, $P113
    set $P2461, param_2458
    unless_null $P2461, vivify_1786
    $P2461 = root_new ['parrot';'ResizablePMCArray']
  vivify_1786:
    set $P114, $P2461[$I100]
    unless_null $P114, vivify_1787
    new $P114, "Undef"
  vivify_1787:
    $P115 = $P114."list"()
    defined $I101, $P115
    unless $I101, for_undef_1788
    iter $P112, $P115
    new $P118, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P118, loop2474_handler
    push_eh $P118
  loop2474_test:
    unless $P112, loop2474_done
    shift $P116, $P112
  loop2474_redo:
    .const 'Sub' $P2463 = "458_1325892461.451" 
    capture_lex $P2463
    $P2463($P116)
  loop2474_next:
    goto loop2474_test
  loop2474_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P119, exception, 'type'
    eq $P119, .CONTROL_LOOP_NEXT, loop2474_next
    eq $P119, .CONTROL_LOOP_REDO, loop2474_redo
  loop2474_done:
    pop_eh 
  for_undef_1788:
.annotate 'line', 2134
    find_dynamic_lex $P114, "$*W"
    unless_null $P114, vivify_1798
    get_hll_global $P112, "GLOBAL"
    get_who $P113, $P112
    set $P114, $P113["$W"]
    unless_null $P114, vivify_1799
    die "Contextual $*W not found"
  vivify_1799:
  vivify_1798:
    set $P115, param_2458
    unless_null $P115, vivify_1800
    new $P115, "Undef"
  vivify_1800:
    set $P116, $P2459
    unless_null $P116, vivify_1801
    new $P116, "Undef"
  vivify_1801:
    set $P117, $P2460
    unless_null $P117, vivify_1802
    new $P117, "Undef"
  vivify_1802:
    $P118 = $P114."set_routine_signature"($P115, $P116, $P117)
.annotate 'line', 2121
    .return ($P118)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2462"  :anon :subid("458_1325892461.451") :outer("457_1325892461.451")
    .param pmc param_2464
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2127
    .lex "$_", param_2464
.annotate 'line', 2128
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Var"]
    find_lex $P123, "$_"
    unless_null $P123, vivify_1789
    new $P123, "Undef"
  vivify_1789:
    $P124 = $P122."ACCEPTS"($P123)
    if $P124, if_2466
    set $P118, $P124
    goto if_2466_end
  if_2466:
    find_lex $P125, "$_"
    unless_null $P125, vivify_1790
    new $P125, "Undef"
  vivify_1790:
    $S100 = $P125."scope"()
    iseq $I102, $S100, "parameter"
    new $P118, 'Integer'
    set $P118, $I102
  if_2466_end:
    if $P118, if_2465
    set $P117, $P118
    goto if_2465_end
  if_2465:
.annotate 'line', 2129
    find_lex $P126, "$types"
    unless_null $P126, vivify_1791
    new $P126, "Undef"
  vivify_1791:
    find_lex $P127, "$_"
    unless_null $P127, vivify_1792
    new $P127, "Undef"
  vivify_1792:
    $P128 = $P127."multitype"()
    set $P2467, $P128
    defined $I2469, $P2467
    if $I2469, default_2468
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    $P133 = $P132."new"("null P" :named("pirop"))
    set $P2467, $P133
  default_2468:
    $P126."push"($P2467)
.annotate 'line', 2130
    find_lex $P126, "$definednesses"
    unless_null $P126, vivify_1793
    new $P126, "Undef"
  vivify_1793:
    find_lex $P2471, "$_"
    unless_null $P2471, vivify_1794
    $P2471 = root_new ['parrot';'Hash']
  vivify_1794:
    set $P128, $P2471["definedness"]
    unless_null $P128, vivify_1795
    new $P128, "Undef"
  vivify_1795:
    set $S101, $P128
    iseq $I103, $S101, "D"
    if $I103, if_2470
.annotate 'line', 2131
    find_lex $P2473, "$_"
    unless_null $P2473, vivify_1796
    $P2473 = root_new ['parrot';'Hash']
  vivify_1796:
    set $P131, $P2473["definedness"]
    unless_null $P131, vivify_1797
    new $P131, "Undef"
  vivify_1797:
    set $S102, $P131
    iseq $I104, $S102, "U"
    if $I104, if_2472
    new $P133, "Float"
    assign $P133, 0
    set $P130, $P133
    goto if_2472_end
  if_2472:
    new $P132, "Float"
    assign $P132, 2
    set $P130, $P132
  if_2472_end:
    set $P127, $P130
.annotate 'line', 2130
    goto if_2470_end
  if_2470:
    new $P129, "Float"
    assign $P129, 1
    set $P127, $P129
  if_2470_end:
    $P134 = $P126."push"($P127)
.annotate 'line', 2128
    set $P117, $P134
  if_2465_end:
.annotate 'line', 2127
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("459_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2478
    .param pmc param_2479
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2603
    .lex "$/", param_2478
    .lex "$type", param_2479
.annotate 'line', 2604
    set $P112, param_2478
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Op"]
    set $P117, param_2478
    unless_null $P117, vivify_1803
    new $P117, "Undef"
  vivify_1803:
.annotate 'line', 2608
    get_hll_global $P119, "GLOBAL"
    nqp_get_package_through_who $P120, $P119, "PAST"
    get_who $P121, $P120
    set $P122, $P121["Val"]
    set $P123, param_2479
    unless_null $P123, vivify_1804
    new $P123, "Undef"
  vivify_1804:
    $P124 = $P122."new"($P123 :named("value"), "!macro_const" :named("returns"))
    $P125 = $P116."new"(0, $P124, $P117 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2604
    $P126 = $P112."!make"($P125)
.annotate 'line', 2603
    .return ($P126)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("460_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2485
    .param pmc param_2486
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2622
    .const 'Sub' $P2495 = "461_1325892461.451" 
    capture_lex $P2495
    new $P2484, 'ExceptionHandler', [.CONTROL_RETURN]
    set_label $P2484, control_2483
    push_eh $P2484
    .lex "@name", param_2485
    .lex "$/", param_2486
.annotate 'line', 2628
    new $P112, "Undef"
    set $P2487, $P112
    .lex "$final_name", $P2487
.annotate 'line', 2629
    new $P113, "Undef"
    set $P2488, $P113
    .lex "$lookup", $P2488
.annotate 'line', 2624
    set $P2490, param_2485
    unless_null $P2490, vivify_1805
    $P2490 = root_new ['parrot';'ResizablePMCArray']
  vivify_1805:
    set $N100, $P2490
    set $N101, 0
    iseq $I100, $N100, $N101
    unless $I100, if_2489_end
    set $P114, param_2486
    unless_null $P114, vivify_1806
    new $P114, "Undef"
  vivify_1806:
    $P115 = $P114."CURSOR"()
    $P115."panic"("Cannot compile empty name")
  if_2489_end:
.annotate 'line', 2628
    set $P2491, param_2485
    unless_null $P2491, vivify_1807
    $P2491 = root_new ['parrot';'ResizablePMCArray']
  vivify_1807:
    $P114 = $P2491."pop"()
    set $P2487, $P114
.annotate 'line', 2629
    get_hll_global $P114, "GLOBAL"
    nqp_get_package_through_who $P115, $P114, "PAST"
    get_who $P116, $P115
    set $P117, $P116["Var"]
    set $P119, $P2487
    unless_null $P119, vivify_1808
    new $P119, "Undef"
  vivify_1808:
    set $S100, $P119
    $P120 = $P117."new"($S100, "keyed" :named("scope"))
    set $P2488, $P120
.annotate 'line', 2633
    set $P2493, param_2485
    unless_null $P2493, vivify_1809
    $P2493 = root_new ['parrot';'ResizablePMCArray']
  vivify_1809:
    set $N100, $P2493
    set $N101, 0
    iseq $I100, $N100, $N101
    if $I100, if_2492
.annotate 'line', 2651
    .const 'Sub' $P2495 = "461_1325892461.451" 
    capture_lex $P2495
    $P2495()
    goto if_2492_end
  if_2492:
.annotate 'line', 2634
    set $P114, $P2488
    unless_null $P114, vivify_1822
    new $P114, "Undef"
  vivify_1822:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P119, $P117["Op"]
.annotate 'line', 2636
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    $P124 = $P123."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P125 = $P119."new"($P124, "get_who PP" :named("pirop"))
.annotate 'line', 2634
    $P114."unshift"($P125)
.annotate 'line', 2638
    set $P114, $P2488
    unless_null $P114, vivify_1823
    new $P114, "Undef"
  vivify_1823:
    get_hll_global $P115, "GLOBAL"
    nqp_get_package_through_who $P116, $P115, "PAST"
    get_who $P117, $P116
    set $P119, $P117["Var"]
.annotate 'line', 2640
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Op"]
.annotate 'line', 2642
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Var"]
    new $P129, "ResizablePMCArray"
    $P130 = $P128."new"("GLOBAL" :named("name"), $P129 :named("namespace"), "package" :named("scope"))
    $P131 = $P123."new"($P130, "get_who PP" :named("pirop"))
.annotate 'line', 2644
    set $P132, $P2487
    unless_null $P132, vivify_1824
    new $P132, "Undef"
  vivify_1824:
    set $S100, $P132
    $P133 = $P119."new"($P131, $S100, "keyed" :named("scope"))
.annotate 'line', 2638
    $P114."viviself"($P133)
  if_2492_end:
.annotate 'line', 2666
    new $P114, "Exception"
    set $P114['type'], .CONTROL_RETURN
    set $P115, $P2488
    unless_null $P115, vivify_1825
    new $P115, "Undef"
  vivify_1825:
    setattribute $P114, 'payload', $P115
    throw $P114
.annotate 'line', 2622
    .return ()
  control_2483:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P114, exception, "payload"
    .return ($P114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2494"  :anon :subid("461_1325892461.451") :outer("460_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2651
    .const 'Sub' $P2505 = "462_1325892461.451" 
    capture_lex $P2505
.annotate 'line', 2652
    new $P114, "Undef"
    set $P2496, $P114
    .lex "$path", $P2496
    new $P116, "Float"
    assign $P116, 0
    set $I101, $P116
    find_lex $P2498, "@name"
    unless_null $P2498, vivify_1810
    $P2498 = root_new ['parrot';'ResizablePMCArray']
  vivify_1810:
    set $P117, $P2498[$I101]
    unless_null $P117, vivify_1811
    new $P117, "Undef"
  vivify_1811:
    $P119 = "is_lexical"($P117)
    if $P119, if_2497
.annotate 'line', 2654
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    new $P131, "ResizablePMCArray"
    $P132 = $P130."new"("GLOBAL" :named("name"), $P131 :named("namespace"), "package" :named("scope"))
    set $P115, $P132
.annotate 'line', 2652
    goto if_2497_end
  if_2497:
.annotate 'line', 2653
    get_hll_global $P120, "GLOBAL"
    nqp_get_package_through_who $P121, $P120, "PAST"
    get_who $P122, $P121
    set $P123, $P122["Var"]
    find_lex $P2499, "@name"
    unless_null $P2499, vivify_1812
    $P2499 = root_new ['parrot';'ResizablePMCArray']
  vivify_1812:
    $P124 = $P2499."shift"()
    $P125 = $P123."new"($P124 :named("name"), "lexical" :named("scope"))
    set $P115, $P125
  if_2497_end:
.annotate 'line', 2652
    set $P2496, $P115
.annotate 'line', 2655
    new $P115, "Float"
    assign $P115, 0
    set $I101, $P115
    find_lex $P2501, "@name"
    unless_null $P2501, vivify_1813
    $P2501 = root_new ['parrot';'ResizablePMCArray']
  vivify_1813:
    set $P116, $P2501[$I101]
    unless_null $P116, vivify_1814
    new $P116, "Undef"
  vivify_1814:
    set $S100, $P116
    iseq $I102, $S100, "GLOBAL"
    unless $I102, if_2500_end
.annotate 'line', 2656
    find_lex $P2502, "@name"
    unless_null $P2502, vivify_1815
    $P2502 = root_new ['parrot';'ResizablePMCArray']
  vivify_1815:
    $P2502."shift"()
  if_2500_end:
.annotate 'line', 2658
    find_lex $P2503, "@name"
    unless_null $P2503, vivify_1816
    $P2503 = root_new ['parrot';'ResizablePMCArray']
  vivify_1816:
    defined $I101, $P2503
    unless $I101, for_undef_1817
    iter $P115, $P2503
    new $P117, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P117, loop2507_handler
    push_eh $P117
  loop2507_test:
    unless $P115, loop2507_done
    shift $P116, $P115
  loop2507_redo:
    .const 'Sub' $P2505 = "462_1325892461.451" 
    capture_lex $P2505
    $P2505($P116)
  loop2507_next:
    goto loop2507_test
  loop2507_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P119, exception, 'type'
    eq $P119, .CONTROL_LOOP_NEXT, loop2507_next
    eq $P119, .CONTROL_LOOP_REDO, loop2507_redo
  loop2507_done:
    pop_eh 
  for_undef_1817:
.annotate 'line', 2663
    find_lex $P115, "$lookup"
    unless_null $P115, vivify_1820
    new $P115, "Undef"
  vivify_1820:
    get_hll_global $P116, "GLOBAL"
    nqp_get_package_through_who $P117, $P116, "PAST"
    get_who $P119, $P117
    set $P120, $P119["Op"]
    set $P121, $P2496
    unless_null $P121, vivify_1821
    new $P121, "Undef"
  vivify_1821:
    $P122 = $P120."new"($P121, "get_who PP" :named("pirop"))
    $P123 = $P115."unshift"($P122)
.annotate 'line', 2651
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2504"  :anon :subid("462_1325892461.451") :outer("461_1325892461.451")
    .param pmc param_2506
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2658
    .lex "$_", param_2506
.annotate 'line', 2659
    get_hll_global $P117, "GLOBAL"
    nqp_get_package_through_who $P119, $P117, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
    find_lex $P122, "$path"
    unless_null $P122, vivify_1818
    new $P122, "Undef"
  vivify_1818:
.annotate 'line', 2661
    find_lex $P123, "$_"
    unless_null $P123, vivify_1819
    new $P123, "Undef"
  vivify_1819:
    set $S100, $P123
    $P124 = $P121."new"($P122, $S100, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2659
    store_lex "$path", $P124
.annotate 'line', 2658
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("463_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2511
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2671
    .lex "$name", param_2511
.annotate 'line', 2672
    set $P115, param_2511
    unless_null $P115, vivify_1826
    new $P115, "Undef"
  vivify_1826:
    $P116 = "is_scope"($P115, "lexical")
.annotate 'line', 2671
    .return ($P116)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("464_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2515
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2677
    .lex "$name", param_2515
.annotate 'line', 2678
    set $P115, param_2515
    unless_null $P115, vivify_1827
    new $P115, "Undef"
  vivify_1827:
    $P117 = "is_scope"($P115, "package")
.annotate 'line', 2677
    .return ($P117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("465_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2521
    .param pmc param_2522
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2683
    .const 'Sub' $P2525 = "466_1325892461.451" 
    capture_lex $P2525
    new $P2520, 'ExceptionHandler', [.CONTROL_RETURN]
    set_label $P2520, control_2519
    push_eh $P2520
    .lex "$name", param_2521
    .lex "$wanted_scope", param_2522
.annotate 'line', 2684
    find_lex $P119, "$?PACKAGE"
    get_who $P120, $P119
    set $P2523, $P120["@BLOCK"]
    unless_null $P2523, vivify_1828
    $P2523 = root_new ['parrot';'ResizablePMCArray']
  vivify_1828:
    defined $I100, $P2523
    unless $I100, for_undef_1829
    iter $P115, $P2523
    new $P123, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P123, loop2532_handler
    push_eh $P123
  loop2532_test:
    unless $P115, loop2532_done
    shift $P121, $P115
  loop2532_redo:
    .const 'Sub' $P2525 = "466_1325892461.451" 
    capture_lex $P2525
    $P2525($P121)
  loop2532_next:
    goto loop2532_test
  loop2532_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P124, exception, 'type'
    eq $P124, .CONTROL_LOOP_NEXT, loop2532_next
    eq $P124, .CONTROL_LOOP_REDO, loop2532_redo
  loop2532_done:
    pop_eh 
  for_undef_1829:
.annotate 'line', 2683
    .return (0)
  control_2519:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P115, exception, "payload"
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2524"  :anon :subid("466_1325892461.451") :outer("465_1325892461.451")
    .param pmc param_2528
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2685
    $P2527 = root_new ['parrot';'Hash']
    set $P2526, $P2527
    .lex "%sym", $P2526
    .lex "$_", param_2528
    find_lex $P122, "$_"
    unless_null $P122, vivify_1830
    new $P122, "Undef"
  vivify_1830:
    find_lex $P123, "$name"
    unless_null $P123, vivify_1831
    new $P123, "Undef"
  vivify_1831:
    $P124 = $P122."symbol"($P123)
    set $P2526, $P124
.annotate 'line', 2686
    set $P2530, $P2526
    unless_null $P2530, vivify_1832
    $P2530 = root_new ['parrot';'Hash']
  vivify_1832:
    set $N100, $P2530
    if $N100, if_2529
    new $P122, 'Float'
    set $P122, $N100
    goto if_2529_end
  if_2529:
.annotate 'line', 2687
    new $P123, "Exception"
    set $P123['type'], .CONTROL_RETURN
    set $P2531, $P2526
    unless_null $P2531, vivify_1833
    $P2531 = root_new ['parrot';'Hash']
  vivify_1833:
    set $P124, $P2531["scope"]
    unless_null $P124, vivify_1834
    new $P124, "Undef"
  vivify_1834:
    set $S100, $P124
    find_lex $P125, "$wanted_scope"
    unless_null $P125, vivify_1835
    new $P125, "Undef"
  vivify_1835:
    set $S101, $P125
    iseq $I101, $S100, $S101
    new $P127, 'Integer'
    set $P127, $I101
    setattribute $P123, 'payload', $P127
    throw $P123
  if_2529_end:
.annotate 'line', 2684
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("467_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2538
    .param pmc param_2539
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2706
    .const 'Sub' $P2582 = "472_1325892461.451" 
    capture_lex $P2582
    .const 'Sub' $P2564 = "470_1325892461.451" 
    capture_lex $P2564
    .const 'Sub' $P2546 = "468_1325892461.451" 
    capture_lex $P2546
    new $P2537, 'ExceptionHandler', [.CONTROL_RETURN]
    set_label $P2537, control_2536
    push_eh $P2537
    .lex "@name", param_2538
    .lex "$/", param_2539
.annotate 'line', 2730
    new $P119, "Undef"
    set $P2540, $P119
    .lex "$result", $P2540
.annotate 'line', 2708
    set $P2542, param_2538
    unless_null $P2542, vivify_1836
    $P2542 = root_new ['parrot';'ResizablePMCArray']
  vivify_1836:
    set $N100, $P2542
    if $N100, unless_2541_end
    set $P120, param_2539
    unless_null $P120, vivify_1837
    new $P120, "Undef"
  vivify_1837:
    $P121 = $P120."CURSOR"()
    $P121."panic"("Cannot look up empty name")
  unless_2541_end:
.annotate 'line', 2712
    set $P2544, param_2538
    unless_null $P2544, vivify_1838
    $P2544 = root_new ['parrot';'ResizablePMCArray']
  vivify_1838:
    set $N100, $P2544
    set $N101, 1
    iseq $I100, $N100, $N101
    unless $I100, if_2543_end
    .const 'Sub' $P2546 = "468_1325892461.451" 
    capture_lex $P2546
    $P2546()
  if_2543_end:
.annotate 'line', 2730
    find_dynamic_lex $P122, "$*GLOBALish"
    unless_null $P122, vivify_1850
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["$GLOBALish"]
    unless_null $P122, vivify_1851
    die "Contextual $*GLOBALish not found"
  vivify_1851:
  vivify_1850:
    set $P2540, $P122
.annotate 'line', 2731
    set $P2562, param_2538
    unless_null $P2562, vivify_1852
    $P2562 = root_new ['parrot';'ResizablePMCArray']
  vivify_1852:
    set $N100, $P2562
    set $N101, 2
    isge $I100, $N100, $N101
    unless $I100, if_2561_end
    .const 'Sub' $P2564 = "470_1325892461.451" 
    capture_lex $P2564
    $P2564()
  if_2561_end:
.annotate 'line', 2749
    set $P2580, param_2538
    unless_null $P2580, vivify_1865
    $P2580 = root_new ['parrot';'ResizablePMCArray']
  vivify_1865:
    defined $I100, $P2580
    unless $I100, for_undef_1866
    iter $P120, $P2580
    new $P123, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P123, loop2586_handler
    push_eh $P123
  loop2586_test:
    unless $P120, loop2586_done
    shift $P121, $P120
  loop2586_redo:
    .const 'Sub' $P2582 = "472_1325892461.451" 
    capture_lex $P2582
    $P2582($P121)
  loop2586_next:
    goto loop2586_test
  loop2586_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P124, exception, 'type'
    eq $P124, .CONTROL_LOOP_NEXT, loop2586_next
    eq $P124, .CONTROL_LOOP_REDO, loop2586_redo
  loop2586_done:
    pop_eh 
  for_undef_1866:
.annotate 'line', 2706
    set $P120, $P2540
    unless_null $P120, vivify_1873
    new $P120, "Undef"
  vivify_1873:
    .return ($P120)
  control_2536:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P121, exception, "payload"
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2545"  :anon :subid("468_1325892461.451") :outer("467_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2712
    .const 'Sub' $P2551 = "469_1325892461.451" 
    capture_lex $P2551
.annotate 'line', 2713
    new $P120, "Undef"
    set $P2547, $P120
    .lex "$final_name", $P2547
    new $P121, "Float"
    assign $P121, 0
    set $I101, $P121
    find_lex $P2548, "@name"
    unless_null $P2548, vivify_1839
    $P2548 = root_new ['parrot';'ResizablePMCArray']
  vivify_1839:
    set $P122, $P2548[$I101]
    unless_null $P122, vivify_1840
    new $P122, "Undef"
  vivify_1840:
    set $P2547, $P122
.annotate 'line', 2714
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2549, $P123["@BLOCK"]
    unless_null $P2549, vivify_1841
    $P2549 = root_new ['parrot';'ResizablePMCArray']
  vivify_1841:
    defined $I101, $P2549
    unless $I101, for_undef_1842
    iter $P121, $P2549
    new $P127, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P127, loop2560_handler
    push_eh $P127
  loop2560_test:
    unless $P121, loop2560_done
    shift $P124, $P121
  loop2560_redo:
    .const 'Sub' $P2551 = "469_1325892461.451" 
    capture_lex $P2551
    $P2551($P124)
  loop2560_next:
    goto loop2560_test
  loop2560_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2560_next
    eq $P128, .CONTROL_LOOP_REDO, loop2560_redo
  loop2560_done:
    pop_eh 
  for_undef_1842:
.annotate 'line', 2712
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2550"  :anon :subid("469_1325892461.451") :outer("468_1325892461.451")
    .param pmc param_2554
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2715
    $P2553 = root_new ['parrot';'Hash']
    set $P2552, $P2553
    .lex "%sym", $P2552
    .lex "$_", param_2554
    find_lex $P125, "$_"
    unless_null $P125, vivify_1843
    new $P125, "Undef"
  vivify_1843:
    find_lex $P127, "$final_name"
    unless_null $P127, vivify_1844
    new $P127, "Undef"
  vivify_1844:
    $P128 = $P125."symbol"($P127)
    set $P2552, $P128
.annotate 'line', 2716
    set $P2556, $P2552
    unless_null $P2556, vivify_1845
    $P2556 = root_new ['parrot';'Hash']
  vivify_1845:
    set $N102, $P2556
    if $N102, if_2555
    new $P125, 'Float'
    set $P125, $N102
    goto if_2555_end
  if_2555:
.annotate 'line', 2717
    set $P2558, $P2552
    unless_null $P2558, vivify_1846
    $P2558 = root_new ['parrot';'Hash']
  vivify_1846:
    exists $I102, $P2558["value"]
    if $I102, if_2557
.annotate 'line', 2721
    new $P128, 'String'
    set $P128, "No compile-time value for "
    find_lex $P129, "$final_name"
    unless_null $P129, vivify_1847
    new $P129, "Undef"
  vivify_1847:
    concat $P130, $P128, $P129
    die $P130
.annotate 'line', 2720
    goto if_2557_end
  if_2557:
.annotate 'line', 2718
    new $P128, "Exception"
    set $P128['type'], .CONTROL_RETURN
    set $P2559, $P2552
    unless_null $P2559, vivify_1848
    $P2559 = root_new ['parrot';'Hash']
  vivify_1848:
    set $P129, $P2559["value"]
    unless_null $P129, vivify_1849
    new $P129, "Undef"
  vivify_1849:
    setattribute $P128, 'payload', $P129
    throw $P128
  if_2557_end:
.annotate 'line', 2716
    set $P125, $P127
  if_2555_end:
.annotate 'line', 2714
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2563"  :anon :subid("470_1325892461.451") :outer("467_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2731
    .const 'Sub' $P2569 = "471_1325892461.451" 
    capture_lex $P2569
.annotate 'line', 2732
    new $P120, "Undef"
    set $P2565, $P120
    .lex "$first", $P2565
    new $P121, "Float"
    assign $P121, 0
    set $I101, $P121
    find_lex $P2566, "@name"
    unless_null $P2566, vivify_1853
    $P2566 = root_new ['parrot';'ResizablePMCArray']
  vivify_1853:
    set $P122, $P2566[$I101]
    unless_null $P122, vivify_1854
    new $P122, "Undef"
  vivify_1854:
    set $P2565, $P122
.annotate 'line', 2733
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2567, $P123["@BLOCK"]
    unless_null $P2567, vivify_1855
    $P2567 = root_new ['parrot';'ResizablePMCArray']
  vivify_1855:
    defined $I101, $P2567
    unless $I101, for_undef_1856
    iter $P121, $P2567
    new $P127, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P127, loop2579_handler
    push_eh $P127
  loop2579_test:
    unless $P121, loop2579_done
    shift $P124, $P121
  loop2579_redo:
    .const 'Sub' $P2569 = "471_1325892461.451" 
    capture_lex $P2569
    $P2569($P124)
  loop2579_next:
    goto loop2579_test
  loop2579_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2579_next
    eq $P128, .CONTROL_LOOP_REDO, loop2579_redo
  loop2579_done:
    pop_eh 
  for_undef_1856:
.annotate 'line', 2731
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2568"  :anon :subid("471_1325892461.451") :outer("470_1325892461.451")
    .param pmc param_2572
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2734
    $P2571 = root_new ['parrot';'Hash']
    set $P2570, $P2571
    .lex "%sym", $P2570
    .lex "$_", param_2572
    find_lex $P125, "$_"
    unless_null $P125, vivify_1857
    new $P125, "Undef"
  vivify_1857:
    find_lex $P127, "$first"
    unless_null $P127, vivify_1858
    new $P127, "Undef"
  vivify_1858:
    $P128 = $P125."symbol"($P127)
    set $P2570, $P128
.annotate 'line', 2735
    set $P2574, $P2570
    unless_null $P2574, vivify_1859
    $P2574 = root_new ['parrot';'Hash']
  vivify_1859:
    set $N102, $P2574
    if $N102, if_2573
    new $P125, 'Float'
    set $P125, $N102
    goto if_2573_end
  if_2573:
.annotate 'line', 2736
    set $P2576, $P2570
    unless_null $P2576, vivify_1860
    $P2576 = root_new ['parrot';'Hash']
  vivify_1860:
    exists $I102, $P2576["value"]
    if $I102, if_2575
.annotate 'line', 2742
    new $P128, 'String'
    set $P128, "No compile-time value for "
    find_lex $P129, "$first"
    unless_null $P129, vivify_1861
    new $P129, "Undef"
  vivify_1861:
    concat $P130, $P128, $P129
    die $P130
.annotate 'line', 2741
    goto if_2575_end
  if_2575:
.annotate 'line', 2737
    set $P2577, $P2570
    unless_null $P2577, vivify_1862
    $P2577 = root_new ['parrot';'Hash']
  vivify_1862:
    set $P128, $P2577["value"]
    unless_null $P128, vivify_1863
    new $P128, "Undef"
  vivify_1863:
    store_lex "$result", $P128
.annotate 'line', 2738
    find_lex $P2578, "@name"
    unless_null $P2578, vivify_1864
    $P2578 = root_new ['parrot';'ResizablePMCArray']
  vivify_1864:
    $P2578."shift"()
.annotate 'line', 2739
    die 0, .CONTROL_LOOP_LAST
  if_2575_end:
.annotate 'line', 2735
    set $P125, $P127
  if_2573_end:
.annotate 'line', 2733
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2581"  :anon :subid("472_1325892461.451") :outer("467_1325892461.451")
    .param pmc param_2583
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2749
    .lex "$_", param_2583
.annotate 'line', 2750
    find_lex $P125, "$_"
    unless_null $P125, vivify_1867
    new $P125, "Undef"
  vivify_1867:
    set $S100, $P125
    find_lex $P123, "$result"
    unless_null $P123, vivify_1868
    new $P123, "Undef"
  vivify_1868:
    get_who $P124, $P123
    exists $I101, $P124[$S100]
    if $I101, if_2584
.annotate 'line', 2754
    new $P127, "String"
    assign $P127, "Could not locate compile-time value for symbol "
.annotate 'line', 2755
    find_lex $P2585, "@name"
    unless_null $P2585, vivify_1869
    $P2585 = root_new ['parrot';'ResizablePMCArray']
  vivify_1869:
    join $S101, "::", $P2585
    concat $P128, $P127, $S101
.annotate 'line', 2754
    die $P128
.annotate 'line', 2753
    goto if_2584_end
  if_2584:
.annotate 'line', 2751
    find_lex $P127, "$_"
    unless_null $P127, vivify_1870
    new $P127, "Undef"
  vivify_1870:
    find_lex $P128, "$result"
    unless_null $P128, vivify_1871
    new $P128, "Undef"
  vivify_1871:
    get_who $P129, $P128
    set $P130, $P129[$P127]
    unless_null $P130, vivify_1872
    new $P130, "Undef"
  vivify_1872:
    store_lex "$result", $P130
.annotate 'line', 2750
    set $P122, $P130
  if_2584_end:
.annotate 'line', 2749
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP" :anon :subid("473_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2591
    .param pmc param_2592
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1267
    .lex "self", param_2591
    .lex "$/", param_2592
    set $P122, param_2592
    set $P2593, param_2592
    unless_null $P2593, vivify_1874
    $P2593 = root_new ['parrot';'Hash']
  vivify_1874:
    set $P123, $P2593["comp_unit"]
    unless_null $P123, vivify_1875
    new $P123, "Undef"
  vivify_1875:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname" :anon :subid("474_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2595
    .param pmc param_2596
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1269
    .lex "self", param_2595
    .lex "$/", param_2596
.annotate 'line', 1270
    set $P122, param_2596
.annotate 'line', 1271
    set $P2598, param_2596
    unless_null $P2598, vivify_1876
    $P2598 = root_new ['parrot';'Hash']
  vivify_1876:
    set $P124, $P2598["colonpair"]
    unless_null $P124, vivify_1877
    new $P124, "Undef"
  vivify_1877:
    if $P124, if_2597
.annotate 'line', 1273
    set $P139, param_2596
    unless_null $P139, vivify_1878
    new $P139, "Undef"
  vivify_1878:
    set $S103, $P139
    new $P123, 'String'
    set $P123, $S103
.annotate 'line', 1271
    goto if_2597_end
  if_2597:
    set $P2599, param_2596
    unless_null $P2599, vivify_1879
    $P2599 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P125, $P2599["identifier"]
    unless_null $P125, vivify_1880
    new $P125, "Undef"
  vivify_1880:
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    concat $P128, $P127, ":"
    new $P129, "Float"
    assign $P129, 0
    set $I100, $P129
    set $P2600, param_2596
    unless_null $P2600, vivify_1881
    $P2600 = root_new ['parrot';'Hash']
  vivify_1881:
    set $P2601, $P2600["colonpair"]
    unless_null $P2601, vivify_1882
    $P2601 = root_new ['parrot';'ResizablePMCArray']
  vivify_1882:
    set $P130, $P2601[$I100]
    unless_null $P130, vivify_1883
    new $P130, "Undef"
  vivify_1883:
    $P131 = $P130."ast"()
    $S101 = $P131."named"()
    concat $P132, $P128, $S101
    concat $P133, $P132, "<"
.annotate 'line', 1272
    new $P134, "Float"
    assign $P134, 0
    set $I101, $P134
    set $P2602, param_2596
    unless_null $P2602, vivify_1884
    $P2602 = root_new ['parrot';'Hash']
  vivify_1884:
    set $P2603, $P2602["colonpair"]
    unless_null $P2603, vivify_1885
    $P2603 = root_new ['parrot';'ResizablePMCArray']
  vivify_1885:
    set $P135, $P2603[$I101]
    unless_null $P135, vivify_1886
    new $P135, "Undef"
  vivify_1886:
    $P136 = $P135."ast"()
    $S102 = "colonpair_str"($P136)
    concat $P137, $P133, $S102
    concat $P138, $P137, ">"
    set $P123, $P138
  if_2597_end:
.annotate 'line', 1271
    $P140 = $P122."!make"($P123)
.annotate 'line', 1269
    .return ($P140)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "comp_unit" :anon :subid("475_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2605
    .param pmc param_2606
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1283
    .const 'Sub' $P2619 = "476_1325892461.451" 
    capture_lex $P2619
    .lex "self", param_2605
    .lex "$/", param_2606
.annotate 'line', 1284
    new $P122, "Undef"
    set $P2607, $P122
    .lex "$mainline", $P2607
.annotate 'line', 1285
    new $P123, "Undef"
    set $P2608, $P123
    .lex "$unit", $P2608
.annotate 'line', 1308
    $P2610 = root_new ['parrot';'ResizablePMCArray']
    set $P2609, $P2610
    .lex "@loadlibs", $P2609
.annotate 'line', 1322
    new $P124, "Undef"
    set $P2611, $P124
    .lex "$main_tasks", $P2611
.annotate 'line', 1284
    set $P2612, param_2606
    unless_null $P2612, vivify_1887
    $P2612 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P125, $P2612["statementlist"]
    unless_null $P125, vivify_1888
    new $P125, "Undef"
  vivify_1888:
    $P127 = $P125."ast"()
    set $P2607, $P127
.annotate 'line', 1285
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2613, $P127["@BLOCK"]
    unless_null $P2613, vivify_1889
    $P2613 = root_new ['parrot';'ResizablePMCArray']
  vivify_1889:
    $P128 = $P2613."shift"()
    set $P2608, $P128
.annotate 'line', 1289
    set $P125, $P2608
    unless_null $P125, vivify_1890
    new $P125, "Undef"
  vivify_1890:
    $P127 = $P125."loadinit"()
    find_dynamic_lex $P130, "$*W"
    unless_null $P130, vivify_1891
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$W"]
    unless_null $P130, vivify_1892
    die "Contextual $*W not found"
  vivify_1892:
  vivify_1891:
    $P131 = $P130."to_past"()
    $P127."push"($P131)
.annotate 'line', 1294
    set $P125, $P2608
    unless_null $P125, vivify_1893
    new $P125, "Undef"
  vivify_1893:
    $P127 = $P125."loadinit"()
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Op"]
.annotate 'line', 1296
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Var"]
    new $P136, "ResizablePMCArray"
    $P137 = $P135."new"("GLOBAL" :named("name"), $P136 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1297
    find_dynamic_lex $P140, "$*W"
    unless_null $P140, vivify_1894
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$W"]
    unless_null $P140, vivify_1895
    die "Contextual $*W not found"
  vivify_1895:
  vivify_1894:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_1896
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_1897
    die "Contextual $*PACKAGE not found"
  vivify_1897:
  vivify_1896:
    $P144 = $P140."get_slot_past_for_object"($P143)
    $P145 = $P131."new"($P137, $P144, "bind_6model" :named("pasttype"))
.annotate 'line', 1294
    $P127."push"($P145)
.annotate 'line', 1303
    find_dynamic_lex $P128, "$*HAS_YOU_ARE_HERE"
    unless_null $P128, vivify_1898
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$HAS_YOU_ARE_HERE"]
    unless_null $P128, vivify_1899
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1899:
  vivify_1898:
    if $P128, unless_2614_end
.annotate 'line', 1304
    set $P129, $P2608
    unless_null $P129, vivify_1900
    new $P129, "Undef"
  vivify_1900:
    set $P130, param_2605
    nqp_decontainerize $P131, $P130
    $P132 = $P131."CTXSAVE"()
    $P129."push"($P132)
  unless_2614_end:
.annotate 'line', 1308
    new $P125, "ResizablePMCArray"
    push $P125, "nqp_group"
    push $P125, "nqp_ops"
    push $P125, "nqp_bigint_ops"
    push $P125, "trans_ops"
    push $P125, "io_ops"
    set $P2609, $P125
.annotate 'line', 1309
    find_dynamic_lex $P128, "%*COMPILING"
    unless_null $P128, vivify_1901
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["%COMPILING"]
    unless_null $P128, vivify_1902
    die "Contextual %*COMPILING not found"
  vivify_1902:
  vivify_1901:
    set $P2616, $P128["%?OPTIONS"]
    unless_null $P2616, vivify_1903
    $P2616 = root_new ['parrot';'Hash']
  vivify_1903:
    set $P129, $P2616["vmlibs"]
    unless_null $P129, vivify_1904
    new $P129, "Undef"
  vivify_1904:
    unless $P129, if_2615_end
.annotate 'line', 1310
    find_dynamic_lex $P133, "%*COMPILING"
    unless_null $P133, vivify_1905
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["%COMPILING"]
    unless_null $P133, vivify_1906
    die "Contextual %*COMPILING not found"
  vivify_1906:
  vivify_1905:
    set $P2617, $P133["%?OPTIONS"]
    unless_null $P2617, vivify_1907
    $P2617 = root_new ['parrot';'Hash']
  vivify_1907:
    set $P134, $P2617["vmlibs"]
    unless_null $P134, vivify_1908
    new $P134, "Undef"
  vivify_1908:
    set $S100, $P134
    split $P135, ",", $S100
    defined $I100, $P135
    unless $I100, for_undef_1909
    iter $P130, $P135
    new $P137, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P137, loop2622_handler
    push_eh $P137
  loop2622_test:
    unless $P130, loop2622_done
    shift $P136, $P130
  loop2622_redo:
    .const 'Sub' $P2619 = "476_1325892461.451" 
    capture_lex $P2619
    $P2619($P136)
  loop2622_next:
    goto loop2622_test
  loop2622_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P139, exception, 'type'
    eq $P139, .CONTROL_LOOP_NEXT, loop2622_next
    eq $P139, .CONTROL_LOOP_REDO, loop2622_redo
  loop2622_done:
    pop_eh 
  for_undef_1909:
  if_2615_end:
.annotate 'line', 1314
    set $P125, $P2608
    unless_null $P125, vivify_1912
    new $P125, "Undef"
  vivify_1912:
    set $P2623, $P2609
    unless_null $P2623, vivify_1913
    $P2623 = root_new ['parrot';'ResizablePMCArray']
  vivify_1913:
    $P125."loadlibs"($P2623 :flat)
.annotate 'line', 1320
    set $P125, $P2608
    unless_null $P125, vivify_1914
    new $P125, "Undef"
  vivify_1914:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    $P131 = $P130."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"), 1 :named("directaccess"))
    $P125."unshift"($P131)
.annotate 'line', 1322
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Stmts"]
.annotate 'line', 1323
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
    $P134 = $P133."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 1324
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Op"]
.annotate 'line', 1326
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "PAST"
    get_who $P141, $P140
    set $P142, $P141["Var"]
    new $P143, "ResizablePMCArray"
    $P144 = $P142."new"("ModuleLoader" :named("name"), $P143 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1327
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Var"]
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Op"]
    $P154 = $P153."new"("getinterp P" :named("pirop"))
    $P155 = $P148."new"($P154, "context", "keyed" :named("scope"))
    $P156 = $P138."new"($P144, $P155, "callmethod" :named("pasttype"), "set_mainline_module" :named("name"))
.annotate 'line', 1324
    $P157 = $P129."new"($P134, $P156)
.annotate 'line', 1322
    set $P2611, $P157
.annotate 'line', 1330
    find_dynamic_lex $P128, "$*MAIN_SUB"
    unless_null $P128, vivify_1915
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$MAIN_SUB"]
    unless_null $P128, vivify_1916
    die "Contextual $*MAIN_SUB not found"
  vivify_1916:
  vivify_1915:
    unless $P128, if_2624_end
.annotate 'line', 1331
    set $P129, $P2611
    unless_null $P129, vivify_1917
    new $P129, "Undef"
  vivify_1917:
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
.annotate 'line', 1332
    get_hll_global $P134, "GLOBAL"
    nqp_get_package_through_who $P135, $P134, "PAST"
    get_who $P136, $P135
    set $P137, $P136["Val"]
    find_dynamic_lex $P140, "$*MAIN_SUB"
    unless_null $P140, vivify_1918
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$MAIN_SUB"]
    unless_null $P140, vivify_1919
    die "Contextual $*MAIN_SUB not found"
  vivify_1919:
  vivify_1918:
    $P141 = $P137."new"($P140 :named("value"))
.annotate 'line', 1333
    get_hll_global $P142, "GLOBAL"
    nqp_get_package_through_who $P143, $P142, "PAST"
    get_who $P144, $P143
    set $P145, $P144["Var"]
    $P146 = $P145."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P147 = $P133."new"($P141, $P146, "call" :named("pasttype"))
.annotate 'line', 1331
    $P129."push"($P147)
  if_2624_end:
.annotate 'line', 1336
    set $P125, $P2607
    unless_null $P125, vivify_1920
    new $P125, "Undef"
  vivify_1920:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
.annotate 'line', 1338
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
    $P135 = $P134."new"("lexical" :named("scope"), "@ARGS" :named("name"))
    set $P136, $P2611
    unless_null $P136, vivify_1921
    new $P136, "Undef"
  vivify_1921:
    $P137 = $P130."new"($P135, $P136, "if" :named("pasttype"))
.annotate 'line', 1336
    $P125."push"($P137)
.annotate 'line', 1345
    set $P125, $P2608
    unless_null $P125, vivify_1922
    new $P125, "Undef"
  vivify_1922:
.annotate 'line', 1346
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Op"]
    set $P131, $P2607
    unless_null $P131, vivify_1923
    new $P131, "Undef"
  vivify_1923:
    $P132 = $P130."new"($P131, "return" :named("pirop"))
    $P125."push"($P132)
.annotate 'line', 1351
    set $P125, $P2608
    unless_null $P125, vivify_1924
    new $P125, "Undef"
  vivify_1924:
.annotate 'line', 1352
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Block"]
.annotate 'line', 1354
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Op"]
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Val"]
    set $P139, $P2608
    unless_null $P139, vivify_1925
    new $P139, "Undef"
  vivify_1925:
    $P140 = $P138."new"($P139 :named("value"))
    $P141 = $P134."new"($P140, "call" :named("pasttype"))
    $P142 = $P130."new"($P141, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 1352
    $P125."push"($P142)
.annotate 'line', 1357
    set $P125, $P2608
    unless_null $P125, vivify_1926
    new $P125, "Undef"
  vivify_1926:
    set $P127, param_2606
    unless_null $P127, vivify_1927
    new $P127, "Undef"
  vivify_1927:
    $P125."node"($P127)
.annotate 'line', 1360
    set $P125, $P2608
    unless_null $P125, vivify_1928
    new $P125, "Undef"
  vivify_1928:
    $P125."hll"("nqp")
.annotate 'line', 1362
    set $P125, param_2606
    set $P127, $P2608
    unless_null $P127, vivify_1929
    new $P127, "Undef"
  vivify_1929:
    $P128 = $P125."!make"($P127)
.annotate 'line', 1283
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2618"  :anon :subid("476_1325892461.451") :outer("475_1325892461.451")
    .param pmc param_2620
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1310
    .lex "$_", param_2620
.annotate 'line', 1311
    find_lex $P2621, "@loadlibs"
    unless_null $P2621, vivify_1910
    $P2621 = root_new ['parrot';'ResizablePMCArray']
  vivify_1910:
    find_lex $P137, "$_"
    unless_null $P137, vivify_1911
    new $P137, "Undef"
  vivify_1911:
    $P138 = $P2621."push"($P137)
.annotate 'line', 1310
    .return ($P138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist" :anon :subid("477_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2626
    .param pmc param_2627
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1365
    .const 'Sub' $P2633 = "478_1325892461.451" 
    capture_lex $P2633
    .lex "self", param_2626
    .lex "$/", param_2627
.annotate 'line', 1366
    new $P122, "Undef"
    set $P2628, $P122
    .lex "$past", $P2628
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Stmts"]
    set $P128, param_2627
    unless_null $P128, vivify_1930
    new $P128, "Undef"
  vivify_1930:
    $P129 = $P127."new"($P128 :named("node"))
    set $P2628, $P129
.annotate 'line', 1367
    set $P2630, param_2627
    unless_null $P2630, vivify_1931
    $P2630 = root_new ['parrot';'Hash']
  vivify_1931:
    set $P123, $P2630["statement"]
    unless_null $P123, vivify_1932
    new $P123, "Undef"
  vivify_1932:
    unless $P123, if_2629_end
.annotate 'line', 1368
    set $P2631, param_2627
    unless_null $P2631, vivify_1933
    $P2631 = root_new ['parrot';'Hash']
  vivify_1933:
    set $P125, $P2631["statement"]
    unless_null $P125, vivify_1934
    new $P125, "Undef"
  vivify_1934:
    defined $I100, $P125
    unless $I100, for_undef_1935
    iter $P124, $P125
    new $P129, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P129, loop2642_handler
    push_eh $P129
  loop2642_test:
    unless $P124, loop2642_done
    shift $P127, $P124
  loop2642_redo:
    .const 'Sub' $P2633 = "478_1325892461.451" 
    capture_lex $P2633
    $P2633($P127)
  loop2642_next:
    goto loop2642_test
  loop2642_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop2642_next
    eq $P130, .CONTROL_LOOP_REDO, loop2642_redo
  loop2642_done:
    pop_eh 
  for_undef_1935:
  if_2629_end:
.annotate 'line', 1376
    set $P123, param_2627
    set $P124, $P2628
    unless_null $P124, vivify_1948
    new $P124, "Undef"
  vivify_1948:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1365
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2632"  :anon :subid("478_1325892461.451") :outer("477_1325892461.451")
    .param pmc param_2635
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1369
    new $P128, "Undef"
    set $P2634, $P128
    .lex "$ast", $P2634
    .lex "$_", param_2635
    find_lex $P129, "$_"
    unless_null $P129, vivify_1936
    new $P129, "Undef"
  vivify_1936:
    $P130 = $P129."ast"()
    set $P2634, $P130
.annotate 'line', 1370
    set $P2637, $P2634
    unless_null $P2637, vivify_1937
    $P2637 = root_new ['parrot';'Hash']
  vivify_1937:
    set $P129, $P2637["sink"]
    unless_null $P129, vivify_1938
    new $P129, "Undef"
  vivify_1938:
    defined $I101, $P129
    unless $I101, if_2636_end
    set $P2638, $P2634
    unless_null $P2638, vivify_1939
    $P2638 = root_new ['parrot';'Hash']
  vivify_1939:
    set $P130, $P2638["sink"]
    unless_null $P130, vivify_1940
    new $P130, "Undef"
  vivify_1940:
    set $P2634, $P130
  if_2636_end:
.annotate 'line', 1371
    set $P2640, $P2634
    unless_null $P2640, vivify_1941
    $P2640 = root_new ['parrot';'Hash']
  vivify_1941:
    set $P129, $P2640["bareblock"]
    unless_null $P129, vivify_1942
    new $P129, "Undef"
  vivify_1942:
    unless $P129, if_2639_end
    set $P130, $P2634
    unless_null $P130, vivify_1943
    new $P130, "Undef"
  vivify_1943:
    $P131 = "block_immediate"($P130)
    set $P2634, $P131
  if_2639_end:
.annotate 'line', 1372
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Node"]
    set $P133, $P2634
    unless_null $P133, vivify_1944
    new $P133, "Undef"
  vivify_1944:
    $P134 = $P132."ACCEPTS"($P133)
    unless $P134, if_2641_end
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Stmt"]
    set $P139, $P2634
    unless_null $P139, vivify_1945
    new $P139, "Undef"
  vivify_1945:
    $P140 = $P138."new"($P139)
    set $P2634, $P140
  if_2641_end:
.annotate 'line', 1373
    find_lex $P129, "$past"
    unless_null $P129, vivify_1946
    new $P129, "Undef"
  vivify_1946:
    set $P130, $P2634
    unless_null $P130, vivify_1947
    new $P130, "Undef"
  vivify_1947:
    $P131 = $P129."push"($P130)
.annotate 'line', 1368
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement" :anon :subid("479_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2644
    .param pmc param_2645
    .param pmc param_2646 :optional
    .param int has_param_2646 :opt_flag
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1379
    .const 'Sub' $P2651 = "480_1325892461.451" 
    capture_lex $P2651
    .lex "self", param_2644
    .lex "$/", param_2645
    if has_param_2646, optparam_1949
    new $P122, "Undef"
    set param_2646, $P122
  optparam_1949:
    .lex "$key", param_2646
.annotate 'line', 1380
    new $P123, "Undef"
    set $P2647, $P123
    .lex "$past", $P2647
.annotate 'line', 1379
    set $P124, $P2647
    unless_null $P124, vivify_1950
    new $P124, "Undef"
  vivify_1950:
.annotate 'line', 1381
    set $P2649, param_2645
    unless_null $P2649, vivify_1951
    $P2649 = root_new ['parrot';'Hash']
  vivify_1951:
    set $P124, $P2649["EXPR"]
    unless_null $P124, vivify_1952
    new $P124, "Undef"
  vivify_1952:
    if $P124, if_2648
.annotate 'line', 1402
    set $P2670, param_2645
    unless_null $P2670, vivify_1953
    $P2670 = root_new ['parrot';'Hash']
  vivify_1953:
    set $P129, $P2670["statement_control"]
    unless_null $P129, vivify_1954
    new $P129, "Undef"
  vivify_1954:
    if $P129, if_2669
.annotate 'line', 1403
    new $P130, "Float"
    assign $P130, 0
    set $P2647, $P130
    goto if_2669_end
  if_2669:
.annotate 'line', 1402
    set $P2671, param_2645
    unless_null $P2671, vivify_1955
    $P2671 = root_new ['parrot';'Hash']
  vivify_1955:
    set $P130, $P2671["statement_control"]
    unless_null $P130, vivify_1956
    new $P130, "Undef"
  vivify_1956:
    $P131 = $P130."ast"()
    set $P2647, $P131
  if_2669_end:
    goto if_2648_end
  if_2648:
.annotate 'line', 1381
    .const 'Sub' $P2651 = "480_1325892461.451" 
    capture_lex $P2651
    $P2651()
  if_2648_end:
.annotate 'line', 1404
    set $P124, param_2645
    set $P125, $P2647
    unless_null $P125, vivify_1990
    new $P125, "Undef"
  vivify_1990:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1379
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2650"  :anon :subid("480_1325892461.451") :outer("479_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1382
    new $P125, "Undef"
    set $P2652, $P125
    .lex "$mc", $P2652
.annotate 'line', 1383
    new $P127, "Undef"
    set $P2653, $P127
    .lex "$ml", $P2653
.annotate 'line', 1382
    new $P128, "Float"
    assign $P128, 0
    set $I100, $P128
    find_lex $P2654, "$/"
    unless_null $P2654, vivify_1957
    $P2654 = root_new ['parrot';'Hash']
  vivify_1957:
    set $P2655, $P2654["statement_mod_cond"]
    unless_null $P2655, vivify_1958
    $P2655 = root_new ['parrot';'ResizablePMCArray']
  vivify_1958:
    set $P129, $P2655[$I100]
    unless_null $P129, vivify_1959
    new $P129, "Undef"
  vivify_1959:
    set $P2652, $P129
.annotate 'line', 1383
    new $P128, "Float"
    assign $P128, 0
    set $I100, $P128
    find_lex $P2656, "$/"
    unless_null $P2656, vivify_1960
    $P2656 = root_new ['parrot';'Hash']
  vivify_1960:
    set $P2657, $P2656["statement_mod_loop"]
    unless_null $P2657, vivify_1961
    $P2657 = root_new ['parrot';'ResizablePMCArray']
  vivify_1961:
    set $P129, $P2657[$I100]
    unless_null $P129, vivify_1962
    new $P129, "Undef"
  vivify_1962:
    set $P2653, $P129
.annotate 'line', 1384
    find_lex $P2658, "$/"
    unless_null $P2658, vivify_1963
    $P2658 = root_new ['parrot';'Hash']
  vivify_1963:
    set $P128, $P2658["EXPR"]
    unless_null $P128, vivify_1964
    new $P128, "Undef"
  vivify_1964:
    $P129 = $P128."ast"()
    store_lex "$past", $P129
.annotate 'line', 1385
    set $P128, $P2652
    unless_null $P128, vivify_1965
    new $P128, "Undef"
  vivify_1965:
    unless $P128, if_2659_end
.annotate 'line', 1386
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    set $P2660, $P2652
    unless_null $P2660, vivify_1966
    $P2660 = root_new ['parrot';'Hash']
  vivify_1966:
    set $P133, $P2660["cond"]
    unless_null $P133, vivify_1967
    new $P133, "Undef"
  vivify_1967:
    $P134 = $P133."ast"()
    find_lex $P135, "$past"
    unless_null $P135, vivify_1968
    new $P135, "Undef"
  vivify_1968:
    set $P2661, $P2652
    unless_null $P2661, vivify_1969
    $P2661 = root_new ['parrot';'Hash']
  vivify_1969:
    set $P136, $P2661["sym"]
    unless_null $P136, vivify_1970
    new $P136, "Undef"
  vivify_1970:
    set $S100, $P136
    find_lex $P137, "$/"
    unless_null $P137, vivify_1971
    new $P137, "Undef"
  vivify_1971:
    $P138 = $P132."new"($P134, $P135, $S100 :named("pasttype"), $P137 :named("node"))
    store_lex "$past", $P138
  if_2659_end:
.annotate 'line', 1388
    set $P129, $P2653
    unless_null $P129, vivify_1972
    new $P129, "Undef"
  vivify_1972:
    if $P129, if_2662
    set $P128, $P129
    goto if_2662_end
  if_2662:
.annotate 'line', 1389
    set $P2664, $P2653
    unless_null $P2664, vivify_1973
    $P2664 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P131, $P2664["sym"]
    unless_null $P131, vivify_1974
    new $P131, "Undef"
  vivify_1974:
    set $S100, $P131
    iseq $I100, $S100, "for"
    if $I100, if_2663
.annotate 'line', 1398
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
    set $P2667, $P2653
    unless_null $P2667, vivify_1975
    $P2667 = root_new ['parrot';'Hash']
  vivify_1975:
    set $P136, $P2667["cond"]
    unless_null $P136, vivify_1976
    new $P136, "Undef"
  vivify_1976:
    $P137 = $P136."ast"()
    find_lex $P138, "$past"
    unless_null $P138, vivify_1977
    new $P138, "Undef"
  vivify_1977:
    set $P2668, $P2653
    unless_null $P2668, vivify_1978
    $P2668 = root_new ['parrot';'Hash']
  vivify_1978:
    set $P139, $P2668["sym"]
    unless_null $P139, vivify_1979
    new $P139, "Undef"
  vivify_1979:
    set $S101, $P139
    find_lex $P140, "$/"
    unless_null $P140, vivify_1980
    new $P140, "Undef"
  vivify_1980:
    $P142 = $P135."new"($P137, $P138, $S101 :named("pasttype"), $P140 :named("node"))
    store_lex "$past", $P142
.annotate 'line', 1397
    set $P130, $P142
.annotate 'line', 1389
    goto if_2663_end
  if_2663:
.annotate 'line', 1390
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Block"]
.annotate 'line', 1391
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Var"]
    $P140 = $P139."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P141, "$past"
    unless_null $P141, vivify_1981
    new $P141, "Undef"
  vivify_1981:
    $P142 = $P135."new"($P140, $P141, "immediate" :named("blocktype"))
.annotate 'line', 1390
    store_lex "$past", $P142
.annotate 'line', 1393
    find_lex $P132, "$past"
    unless_null $P132, vivify_1982
    new $P132, "Undef"
  vivify_1982:
    $P132."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1394
    find_lex $P132, "$past"
    unless_null $P132, vivify_1983
    new $P132, "Undef"
  vivify_1983:
    $P132."arity"(1)
.annotate 'line', 1395
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
    set $P2665, $P2653
    unless_null $P2665, vivify_1984
    $P2665 = root_new ['parrot';'Hash']
  vivify_1984:
    set $P136, $P2665["cond"]
    unless_null $P136, vivify_1985
    new $P136, "Undef"
  vivify_1985:
    $P137 = $P136."ast"()
    find_lex $P138, "$past"
    unless_null $P138, vivify_1986
    new $P138, "Undef"
  vivify_1986:
    set $P2666, $P2653
    unless_null $P2666, vivify_1987
    $P2666 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P139, $P2666["sym"]
    unless_null $P139, vivify_1988
    new $P139, "Undef"
  vivify_1988:
    set $S101, $P139
    find_lex $P140, "$/"
    unless_null $P140, vivify_1989
    new $P140, "Undef"
  vivify_1989:
    $P141 = $P135."new"($P137, $P138, $S101 :named("pasttype"), $P140 :named("node"))
    store_lex "$past", $P141
.annotate 'line', 1389
    set $P130, $P141
  if_2663_end:
.annotate 'line', 1388
    set $P128, $P130
  if_2662_end:
.annotate 'line', 1381
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock" :anon :subid("481_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2673
    .param pmc param_2674
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1407
    .lex "self", param_2673
    .lex "$/", param_2674
.annotate 'line', 1408
    set $P122, param_2674
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    set $P2675, param_2674
    unless_null $P2675, vivify_1991
    $P2675 = root_new ['parrot';'Hash']
  vivify_1991:
    set $P128, $P2675["EXPR"]
    unless_null $P128, vivify_1992
    new $P128, "Undef"
  vivify_1992:
    $P129 = $P128."ast"()
    set $P2676, param_2674
    unless_null $P2676, vivify_1993
    $P2676 = root_new ['parrot';'Hash']
  vivify_1993:
    set $P130, $P2676["pblock"]
    unless_null $P130, vivify_1994
    new $P130, "Undef"
  vivify_1994:
    $P131 = $P130."ast"()
    set $P132, param_2674
    unless_null $P132, vivify_1995
    new $P132, "Undef"
  vivify_1995:
    $P133 = $P127."new"($P129, $P131, "if" :named("pasttype"), $P132 :named("node"))
    $P134 = $P122."!make"($P133)
.annotate 'line', 1407
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock" :anon :subid("482_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2678
    .param pmc param_2679
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1411
    .lex "self", param_2678
    .lex "$/", param_2679
.annotate 'line', 1412
    set $P122, param_2679
    set $P2680, param_2679
    unless_null $P2680, vivify_1996
    $P2680 = root_new ['parrot';'Hash']
  vivify_1996:
    set $P123, $P2680["blockoid"]
    unless_null $P123, vivify_1997
    new $P123, "Undef"
  vivify_1997:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1411
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block" :anon :subid("483_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2682
    .param pmc param_2683
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1415
    .lex "self", param_2682
    .lex "$/", param_2683
.annotate 'line', 1416
    set $P122, param_2683
    set $P2684, param_2683
    unless_null $P2684, vivify_1998
    $P2684 = root_new ['parrot';'Hash']
  vivify_1998:
    set $P123, $P2684["blockoid"]
    unless_null $P123, vivify_1999
    new $P123, "Undef"
  vivify_1999:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 1415
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid" :anon :subid("484_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2686
    .param pmc param_2687
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1419
    .const 'Sub' $P2693 = "485_1325892461.451" 
    capture_lex $P2693
    .lex "self", param_2686
    .lex "$/", param_2687
.annotate 'line', 1420
    new $P122, "Undef"
    set $P2688, $P122
    .lex "$BLOCK", $P2688
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P2689, $P124["@BLOCK"]
    unless_null $P2689, vivify_2000
    $P2689 = root_new ['parrot';'ResizablePMCArray']
  vivify_2000:
    $P125 = $P2689."shift"()
    set $P2688, $P125
.annotate 'line', 1421
    set $P2691, param_2687
    unless_null $P2691, vivify_2001
    $P2691 = root_new ['parrot';'Hash']
  vivify_2001:
    set $P124, $P2691["statementlist"]
    unless_null $P124, vivify_2002
    new $P124, "Undef"
  vivify_2002:
    if $P124, if_2690
.annotate 'line', 1429
    find_dynamic_lex $P131, "$*HAS_YOU_ARE_HERE"
    unless_null $P131, vivify_2003
    get_hll_global $P128, "GLOBAL"
    get_who $P130, $P128
    set $P131, $P130["$HAS_YOU_ARE_HERE"]
    unless_null $P131, vivify_2004
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_2004:
  vivify_2003:
    unless $P131, if_2696_end
.annotate 'line', 1430
    set $P132, param_2687
    unless_null $P132, vivify_2005
    new $P132, "Undef"
  vivify_2005:
    $P133 = $P132."CURSOR"()
    $P133."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_2696_end:
.annotate 'line', 1432
    new $P128, "Float"
    assign $P128, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P128
.annotate 'line', 1433
    set $P128, param_2687
    set $P2697, param_2687
    unless_null $P2697, vivify_2006
    $P2697 = root_new ['parrot';'Hash']
  vivify_2006:
    set $P130, $P2697["you_are_here"]
    unless_null $P130, vivify_2007
    new $P130, "Undef"
  vivify_2007:
    $P131 = $P130."ast"()
    $P132 = $P128."!make"($P131)
.annotate 'line', 1428
    set $P123, $P132
.annotate 'line', 1421
    goto if_2690_end
  if_2690:
    .const 'Sub' $P2693 = "485_1325892461.451" 
    capture_lex $P2693
    $P127 = $P2693()
    set $P123, $P127
  if_2690_end:
.annotate 'line', 1419
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2692"  :anon :subid("485_1325892461.451") :outer("484_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1422
    new $P125, "Undef"
    set $P2694, $P125
    .lex "$past", $P2694
    find_lex $P2695, "$/"
    unless_null $P2695, vivify_2008
    $P2695 = root_new ['parrot';'Hash']
  vivify_2008:
    set $P127, $P2695["statementlist"]
    unless_null $P127, vivify_2009
    new $P127, "Undef"
  vivify_2009:
    $P128 = $P127."ast"()
    set $P2694, $P128
.annotate 'line', 1423
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2010
    new $P127, "Undef"
  vivify_2010:
    set $P128, $P2694
    unless_null $P128, vivify_2011
    new $P128, "Undef"
  vivify_2011:
    $P127."push"($P128)
.annotate 'line', 1424
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2012
    new $P127, "Undef"
  vivify_2012:
    find_lex $P128, "$/"
    unless_null $P128, vivify_2013
    new $P128, "Undef"
  vivify_2013:
    $P127."node"($P128)
.annotate 'line', 1425
    find_lex $P127, "$BLOCK"
    unless_null $P127, vivify_2014
    new $P127, "Undef"
  vivify_2014:
    $P127."closure"(1)
.annotate 'line', 1426
    find_dynamic_lex $P127, "$/"
    find_lex $P128, "$BLOCK"
    unless_null $P128, vivify_2015
    new $P128, "Undef"
  vivify_2015:
    $P129 = $P127."!make"($P128)
.annotate 'line', 1421
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad" :anon :subid("486_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2699
    .param pmc param_2700
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1437
    .lex "self", param_2699
    .lex "$/", param_2700
.annotate 'line', 1438
    find_lex $P122, "$?PACKAGE"
    get_who $P123, $P122
    set $P2701, $P123["@BLOCK"]
    unless_null $P2701, vivify_2016
    $P2701 = root_new ['parrot';'ResizablePMCArray']
  vivify_2016:
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Block"]
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Stmts"]
    $P133 = $P132."new"()
    $P134 = $P128."new"($P133)
    $P135 = $P2701."unshift"($P134)
.annotate 'line', 1437
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx" :anon :subid("487_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2703
    .param pmc param_2704
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1441
    .const 'Sub' $P2708 = "488_1325892461.451" 
    capture_lex $P2708
    .lex "self", param_2703
    .lex "$/", param_2704
.annotate 'line', 1442
    find_dynamic_lex $P124, "%*COMPILING"
    unless_null $P124, vivify_2017
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["%COMPILING"]
    unless_null $P124, vivify_2018
    die "Contextual %*COMPILING not found"
  vivify_2018:
  vivify_2017:
    set $P2706, $P124["%?OPTIONS"]
    unless_null $P2706, vivify_2019
    $P2706 = root_new ['parrot';'Hash']
  vivify_2019:
    set $P125, $P2706["outer_ctx"]
    unless_null $P125, vivify_2020
    new $P125, "Undef"
  vivify_2020:
    defined $I100, $P125
    if $I100, unless_2705_end
    .const 'Sub' $P2708 = "488_1325892461.451" 
    capture_lex $P2708
    $P2708()
  unless_2705_end:
.annotate 'line', 1455
    set $P122, param_2703
    nqp_decontainerize $P123, $P122
    new $P124, "Float"
    assign $P124, 0
    set $I100, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2716, $P127["@BLOCK"]
    unless_null $P2716, vivify_2036
    $P2716 = root_new ['parrot';'ResizablePMCArray']
  vivify_2036:
    set $P128, $P2716[$I100]
    unless_null $P128, vivify_2037
    new $P128, "Undef"
  vivify_2037:
    $P129 = $P123."SET_BLOCK_OUTER_CTX"($P128)
.annotate 'line', 1441
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2707"  :anon :subid("488_1325892461.451") :outer("487_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1445
    new $P127, "Undef"
    set $P2709, $P127
    .lex "$SETTING", $P2709
    find_dynamic_lex $P130, "$*W"
    unless_null $P130, vivify_2021
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$W"]
    unless_null $P130, vivify_2022
    die "Contextual $*W not found"
  vivify_2022:
  vivify_2021:
    find_dynamic_lex $P133, "%*COMPILING"
    unless_null $P133, vivify_2023
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["%COMPILING"]
    unless_null $P133, vivify_2024
    die "Contextual %*COMPILING not found"
  vivify_2024:
  vivify_2023:
    set $P2711, $P133["%?OPTIONS"]
    unless_null $P2711, vivify_2025
    $P2711 = root_new ['parrot';'Hash']
  vivify_2025:
    set $P134, $P2711["setting"]
    unless_null $P134, vivify_2026
    new $P134, "Undef"
  vivify_2026:
    set $P2710, $P134
    defined $I2713, $P2710
    if $I2713, default_2712
    new $P135, "String"
    assign $P135, "NQPCORE"
    set $P2710, $P135
  default_2712:
    $P136 = $P130."load_setting"($P2710)
    set $P2709, $P136
.annotate 'line', 1450
    find_dynamic_lex $P131, "%*COMPILING"
    unless_null $P131, vivify_2027
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%COMPILING"]
    unless_null $P131, vivify_2028
    die "Contextual %*COMPILING not found"
  vivify_2028:
  vivify_2027:
    set $P2715, $P131["%?OPTIONS"]
    unless_null $P2715, vivify_2029
    $P2715 = root_new ['parrot';'Hash']
  vivify_2029:
    set $P132, $P2715["setting"]
    unless_null $P132, vivify_2030
    new $P132, "Undef"
  vivify_2030:
    set $S100, $P132
    iseq $I101, $S100, "NULL"
    unless $I101, unless_2714
    new $P128, 'Integer'
    set $P128, $I101
    goto unless_2714_end
  unless_2714:
.annotate 'line', 1451
    set $P133, $P2709
    unless_null $P133, vivify_2031
    new $P133, "Undef"
  vivify_2031:
    "import_HOW_exports"($P133)
.annotate 'line', 1452
    find_dynamic_lex $P135, "$*W"
    unless_null $P135, vivify_2032
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$W"]
    unless_null $P135, vivify_2033
    die "Contextual $*W not found"
  vivify_2033:
  vivify_2032:
    find_dynamic_lex $P138, "$*GLOBALish"
    unless_null $P138, vivify_2034
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$GLOBALish"]
    unless_null $P138, vivify_2035
    die "Contextual $*GLOBALish not found"
  vivify_2035:
  vivify_2034:
    $P139 = $P135."load_module"("NQPRegex", $P138)
.annotate 'line', 1450
    set $P128, $P139
  unless_2714_end:
.annotate 'line', 1442
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish" :anon :subid("489_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2718
    .param pmc param_2719
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1467
    .lex "self", param_2718
    .lex "$/", param_2719
.annotate 'line', 1471
    find_dynamic_lex $P124, "$*W"
    unless_null $P124, vivify_2038
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$W"]
    unless_null $P124, vivify_2039
    die "Contextual $*W not found"
  vivify_2039:
  vivify_2038:
    find_dynamic_lex $P128, "%*HOW"
    unless_null $P128, vivify_2040
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["%HOW"]
    unless_null $P128, vivify_2041
    die "Contextual %*HOW not found"
  vivify_2041:
  vivify_2040:
    set $P129, $P128["knowhow"]
    unless_null $P129, vivify_2042
    new $P129, "Undef"
  vivify_2042:
    $P130 = $P124."pkg_create_mo"($P129, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P130
.annotate 'line', 1472
    find_dynamic_lex $P124, "$*GLOBALish"
    unless_null $P124, vivify_2043
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$GLOBALish"]
    unless_null $P124, vivify_2044
    die "Contextual $*GLOBALish not found"
  vivify_2044:
  vivify_2043:
    get_how $P125, $P124
    find_dynamic_lex $P129, "$*GLOBALish"
    unless_null $P129, vivify_2045
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$GLOBALish"]
    unless_null $P129, vivify_2046
    die "Contextual $*GLOBALish not found"
  vivify_2046:
  vivify_2045:
    $P125."compose"($P129)
.annotate 'line', 1473
    find_dynamic_lex $P124, "$*W"
    unless_null $P124, vivify_2047
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$W"]
    unless_null $P124, vivify_2048
    die "Contextual $*W not found"
  vivify_2048:
  vivify_2047:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P2720, $P128["@BLOCK"]
    unless_null $P2720, vivify_2049
    $P2720 = root_new ['parrot';'ResizablePMCArray']
  vivify_2049:
    set $P129, $P2720[$I100]
    unless_null $P129, vivify_2050
    new $P129, "Undef"
  vivify_2050:
    find_dynamic_lex $P132, "$*GLOBALish"
    unless_null $P132, vivify_2051
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$GLOBALish"]
    unless_null $P132, vivify_2052
    die "Contextual $*GLOBALish not found"
  vivify_2052:
  vivify_2051:
    $P124."install_lexical_symbol"($P129, "GLOBALish", $P132)
.annotate 'line', 1476
    find_dynamic_lex $P124, "$*GLOBALish"
    unless_null $P124, vivify_2053
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$GLOBALish"]
    unless_null $P124, vivify_2054
    die "Contextual $*GLOBALish not found"
  vivify_2054:
  vivify_2053:
    store_dynamic_lex "$*PACKAGE", $P124
.annotate 'line', 1477
    find_dynamic_lex $P124, "$*W"
    unless_null $P124, vivify_2055
    get_hll_global $P122, "GLOBAL"
    get_who $P123, $P122
    set $P124, $P123["$W"]
    unless_null $P124, vivify_2056
    die "Contextual $*W not found"
  vivify_2056:
  vivify_2055:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P127, "$?PACKAGE"
    get_who $P128, $P127
    set $P2721, $P128["@BLOCK"]
    unless_null $P2721, vivify_2057
    $P2721 = root_new ['parrot';'ResizablePMCArray']
  vivify_2057:
    set $P129, $P2721[$I100]
    unless_null $P129, vivify_2058
    new $P129, "Undef"
  vivify_2058:
    find_dynamic_lex $P132, "$*PACKAGE"
    unless_null $P132, vivify_2059
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$PACKAGE"]
    unless_null $P132, vivify_2060
    die "Contextual $*PACKAGE not found"
  vivify_2060:
  vivify_2059:
    $P133 = $P124."install_lexical_symbol"($P129, "$?PACKAGE", $P132)
.annotate 'line', 1467
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here" :anon :subid("490_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2723
    .param pmc param_2724
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1480
    .lex "self", param_2723
    .lex "$/", param_2724
.annotate 'line', 1481
    set $P122, param_2724
    set $P123, param_2723
    nqp_decontainerize $P124, $P123
    $P125 = $P124."CTXSAVE"()
    $P127 = $P122."!make"($P125)
.annotate 'line', 1480
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>" :anon :subid("491_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2726
    .param pmc param_2727
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1486
    .lex "self", param_2726
    .lex "$/", param_2727
.annotate 'line', 1487
    new $P122, "Undef"
    set $P2728, $P122
    .lex "$module", $P2728
    find_dynamic_lex $P125, "$*W"
    unless_null $P125, vivify_2061
    get_hll_global $P123, "GLOBAL"
    get_who $P124, $P123
    set $P125, $P124["$W"]
    unless_null $P125, vivify_2062
    die "Contextual $*W not found"
  vivify_2062:
  vivify_2061:
    set $P2729, param_2727
    unless_null $P2729, vivify_2063
    $P2729 = root_new ['parrot';'Hash']
  vivify_2063:
    set $P127, $P2729["name"]
    unless_null $P127, vivify_2064
    new $P127, "Undef"
  vivify_2064:
    set $S100, $P127
    find_dynamic_lex $P130, "$*GLOBALish"
    unless_null $P130, vivify_2065
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$GLOBALish"]
    unless_null $P130, vivify_2066
    die "Contextual $*GLOBALish not found"
  vivify_2066:
  vivify_2065:
    $P131 = $P125."load_module"($S100, $P130)
    set $P2728, $P131
.annotate 'line', 1488
    set $P123, $P2728
    unless_null $P123, vivify_2067
    new $P123, "Undef"
  vivify_2067:
    defined $I100, $P123
    unless $I100, if_2730_end
.annotate 'line', 1489
    set $P124, $P2728
    unless_null $P124, vivify_2068
    new $P124, "Undef"
  vivify_2068:
    "import_HOW_exports"($P124)
  if_2730_end:
.annotate 'line', 1491
    set $P123, param_2727
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    $P129 = $P128."new"()
    $P130 = $P123."!make"($P129)
.annotate 'line', 1486
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>" :anon :subid("492_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2732
    .param pmc param_2733
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1494
    .const 'Sub' $P2744 = "493_1325892461.451" 
    capture_lex $P2744
    .lex "self", param_2732
    .lex "$/", param_2733
.annotate 'line', 1495
    new $P122, "Undef"
    set $P2734, $P122
    .lex "$count", $P2734
.annotate 'line', 1496
    new $P123, "Undef"
    set $P2735, $P123
    .lex "$past", $P2735
.annotate 'line', 1495
    set $P2736, param_2733
    unless_null $P2736, vivify_2069
    $P2736 = root_new ['parrot';'Hash']
  vivify_2069:
    set $P124, $P2736["xblock"]
    unless_null $P124, vivify_2070
    new $P124, "Undef"
  vivify_2070:
    set $N100, $P124
    new $P125, 'Float'
    set $P125, $N100
    sub $P127, $P125, 1
    set $P2734, $P127
.annotate 'line', 1496
    set $P124, $P2734
    unless_null $P124, vivify_2071
    new $P124, "Undef"
  vivify_2071:
    set $I100, $P124
    set $P2737, param_2733
    unless_null $P2737, vivify_2072
    $P2737 = root_new ['parrot';'Hash']
  vivify_2072:
    set $P2738, $P2737["xblock"]
    unless_null $P2738, vivify_2073
    $P2738 = root_new ['parrot';'ResizablePMCArray']
  vivify_2073:
    set $P125, $P2738[$I100]
    unless_null $P125, vivify_2074
    new $P125, "Undef"
  vivify_2074:
    $P127 = $P125."ast"()
    $P128 = "xblock_immediate"($P127)
    set $P2735, $P128
.annotate 'line', 1497
    set $P2740, param_2733
    unless_null $P2740, vivify_2075
    $P2740 = root_new ['parrot';'Hash']
  vivify_2075:
    set $P124, $P2740["else"]
    unless_null $P124, vivify_2076
    new $P124, "Undef"
  vivify_2076:
    unless $P124, if_2739_end
.annotate 'line', 1498
    set $P125, $P2735
    unless_null $P125, vivify_2077
    new $P125, "Undef"
  vivify_2077:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    set $P2741, param_2733
    unless_null $P2741, vivify_2078
    $P2741 = root_new ['parrot';'Hash']
  vivify_2078:
    set $P2742, $P2741["else"]
    unless_null $P2742, vivify_2079
    $P2742 = root_new ['parrot';'ResizablePMCArray']
  vivify_2079:
    set $P128, $P2742[$I100]
    unless_null $P128, vivify_2080
    new $P128, "Undef"
  vivify_2080:
    $P129 = $P128."ast"()
    $P130 = "block_immediate"($P129)
    $P125."push"($P130)
  if_2739_end:
.annotate 'line', 1501
    new $P127, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P127, loop2749_handler
    push_eh $P127
  loop2749_test:
    set $P124, $P2734
    unless_null $P124, vivify_2081
    new $P124, "Undef"
  vivify_2081:
    set $N100, $P124
    set $N101, 0
    isgt $I100, $N100, $N101
    unless $I100, loop2749_done
  loop2749_redo:
    .const 'Sub' $P2744 = "493_1325892461.451" 
    capture_lex $P2744
    $P2744()
  loop2749_next:
    goto loop2749_test
  loop2749_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop2749_next
    eq $P128, .CONTROL_LOOP_REDO, loop2749_redo
  loop2749_done:
    pop_eh 
.annotate 'line', 1507
    set $P124, param_2733
    set $P125, $P2735
    unless_null $P125, vivify_2090
    new $P125, "Undef"
  vivify_2090:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1494
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2743"  :anon :subid("493_1325892461.451") :outer("492_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1503
    new $P125, "Undef"
    set $P2745, $P125
    .lex "$else", $P2745
.annotate 'line', 1501
    find_lex $P127, "$count"
    unless_null $P127, vivify_2082
    new $P127, "Undef"
  vivify_2082:
    clone $P2746, $P127
    dec $P127
.annotate 'line', 1503
    find_lex $P127, "$past"
    unless_null $P127, vivify_2083
    new $P127, "Undef"
  vivify_2083:
    set $P2745, $P127
.annotate 'line', 1504
    find_lex $P127, "$count"
    unless_null $P127, vivify_2084
    new $P127, "Undef"
  vivify_2084:
    set $I101, $P127
    find_lex $P2747, "$/"
    unless_null $P2747, vivify_2085
    $P2747 = root_new ['parrot';'Hash']
  vivify_2085:
    set $P2748, $P2747["xblock"]
    unless_null $P2748, vivify_2086
    $P2748 = root_new ['parrot';'ResizablePMCArray']
  vivify_2086:
    set $P128, $P2748[$I101]
    unless_null $P128, vivify_2087
    new $P128, "Undef"
  vivify_2087:
    $P129 = $P128."ast"()
    $P130 = "xblock_immediate"($P129)
    store_lex "$past", $P130
.annotate 'line', 1505
    find_lex $P127, "$past"
    unless_null $P127, vivify_2088
    new $P127, "Undef"
  vivify_2088:
    set $P128, $P2745
    unless_null $P128, vivify_2089
    new $P128, "Undef"
  vivify_2089:
    $P129 = $P127."push"($P128)
.annotate 'line', 1501
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>" :anon :subid("494_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2751
    .param pmc param_2752
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1510
    .lex "self", param_2751
    .lex "$/", param_2752
.annotate 'line', 1511
    new $P122, "Undef"
    set $P2753, $P122
    .lex "$past", $P2753
    set $P2754, param_2752
    unless_null $P2754, vivify_2091
    $P2754 = root_new ['parrot';'Hash']
  vivify_2091:
    set $P123, $P2754["xblock"]
    unless_null $P123, vivify_2092
    new $P123, "Undef"
  vivify_2092:
    $P124 = $P123."ast"()
    $P125 = "xblock_immediate"($P124)
    set $P2753, $P125
.annotate 'line', 1512
    set $P123, $P2753
    unless_null $P123, vivify_2093
    new $P123, "Undef"
  vivify_2093:
    $P123."pasttype"("unless")
.annotate 'line', 1513
    set $P123, param_2752
    set $P124, $P2753
    unless_null $P124, vivify_2094
    new $P124, "Undef"
  vivify_2094:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1510
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>" :anon :subid("495_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2756
    .param pmc param_2757
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1516
    .lex "self", param_2756
    .lex "$/", param_2757
.annotate 'line', 1517
    new $P122, "Undef"
    set $P2758, $P122
    .lex "$past", $P2758
    set $P2759, param_2757
    unless_null $P2759, vivify_2095
    $P2759 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P123, $P2759["xblock"]
    unless_null $P123, vivify_2096
    new $P123, "Undef"
  vivify_2096:
    $P124 = $P123."ast"()
    $P125 = "xblock_immediate"($P124)
    set $P2758, $P125
.annotate 'line', 1518
    set $P123, $P2758
    unless_null $P123, vivify_2097
    new $P123, "Undef"
  vivify_2097:
    set $P2760, param_2757
    unless_null $P2760, vivify_2098
    $P2760 = root_new ['parrot';'Hash']
  vivify_2098:
    set $P124, $P2760["sym"]
    unless_null $P124, vivify_2099
    new $P124, "Undef"
  vivify_2099:
    set $S100, $P124
    $P123."pasttype"($S100)
.annotate 'line', 1519
    set $P123, param_2757
    set $P124, $P2758
    unless_null $P124, vivify_2100
    new $P124, "Undef"
  vivify_2100:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1516
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>" :anon :subid("496_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2762
    .param pmc param_2763
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1522
    .lex "self", param_2762
    .lex "$/", param_2763
.annotate 'line', 1523
    new $P122, "Undef"
    set $P2764, $P122
    .lex "$pasttype", $P2764
.annotate 'line', 1524
    new $P123, "Undef"
    set $P2765, $P123
    .lex "$past", $P2765
.annotate 'line', 1523
    new $P124, "String"
    assign $P124, "repeat_"
    set $P2766, param_2763
    unless_null $P2766, vivify_2101
    $P2766 = root_new ['parrot';'Hash']
  vivify_2101:
    set $P125, $P2766["wu"]
    unless_null $P125, vivify_2102
    new $P125, "Undef"
  vivify_2102:
    set $S100, $P125
    concat $P127, $P124, $S100
    set $P2764, $P127
.annotate 'line', 1522
    set $P124, $P2765
    unless_null $P124, vivify_2103
    new $P124, "Undef"
  vivify_2103:
.annotate 'line', 1525
    set $P2768, param_2763
    unless_null $P2768, vivify_2104
    $P2768 = root_new ['parrot';'Hash']
  vivify_2104:
    set $P124, $P2768["xblock"]
    unless_null $P124, vivify_2105
    new $P124, "Undef"
  vivify_2105:
    if $P124, if_2767
.annotate 'line', 1530
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    set $P2770, param_2763
    unless_null $P2770, vivify_2106
    $P2770 = root_new ['parrot';'Hash']
  vivify_2106:
    set $P130, $P2770["EXPR"]
    unless_null $P130, vivify_2107
    new $P130, "Undef"
  vivify_2107:
    $P131 = $P130."ast"()
    set $P2771, param_2763
    unless_null $P2771, vivify_2108
    $P2771 = root_new ['parrot';'Hash']
  vivify_2108:
    set $P132, $P2771["pblock"]
    unless_null $P132, vivify_2109
    new $P132, "Undef"
  vivify_2109:
    $P133 = $P132."ast"()
    $P134 = "block_immediate"($P133)
    set $P135, $P2764
    unless_null $P135, vivify_2110
    new $P135, "Undef"
  vivify_2110:
    set $P136, param_2763
    unless_null $P136, vivify_2111
    new $P136, "Undef"
  vivify_2111:
    $P137 = $P129."new"($P131, $P134, $P135 :named("pasttype"), $P136 :named("node"))
    set $P2765, $P137
.annotate 'line', 1529
    goto if_2767_end
  if_2767:
.annotate 'line', 1526
    set $P2769, param_2763
    unless_null $P2769, vivify_2112
    $P2769 = root_new ['parrot';'Hash']
  vivify_2112:
    set $P125, $P2769["xblock"]
    unless_null $P125, vivify_2113
    new $P125, "Undef"
  vivify_2113:
    $P127 = $P125."ast"()
    $P128 = "xblock_immediate"($P127)
    set $P2765, $P128
.annotate 'line', 1527
    set $P125, $P2765
    unless_null $P125, vivify_2114
    new $P125, "Undef"
  vivify_2114:
    set $P127, $P2764
    unless_null $P127, vivify_2115
    new $P127, "Undef"
  vivify_2115:
    $P125."pasttype"($P127)
  if_2767_end:
.annotate 'line', 1533
    set $P124, param_2763
    set $P125, $P2765
    unless_null $P125, vivify_2116
    new $P125, "Undef"
  vivify_2116:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1522
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>" :anon :subid("497_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2773
    .param pmc param_2774
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1536
    .lex "self", param_2773
    .lex "$/", param_2774
.annotate 'line', 1537
    new $P122, "Undef"
    set $P2775, $P122
    .lex "$past", $P2775
.annotate 'line', 1539
    new $P123, "Undef"
    set $P2776, $P123
    .lex "$block", $P2776
.annotate 'line', 1537
    set $P2777, param_2774
    unless_null $P2777, vivify_2117
    $P2777 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P124, $P2777["xblock"]
    unless_null $P124, vivify_2118
    new $P124, "Undef"
  vivify_2118:
    $P125 = $P124."ast"()
    set $P2775, $P125
.annotate 'line', 1538
    set $P124, $P2775
    unless_null $P124, vivify_2119
    new $P124, "Undef"
  vivify_2119:
    $P124."pasttype"("for")
.annotate 'line', 1539
    new $P124, "Float"
    assign $P124, 1
    set $I100, $P124
    set $P2778, $P2775
    unless_null $P2778, vivify_2120
    $P2778 = root_new ['parrot';'ResizablePMCArray']
  vivify_2120:
    set $P125, $P2778[$I100]
    unless_null $P125, vivify_2121
    new $P125, "Undef"
  vivify_2121:
    set $P2776, $P125
.annotate 'line', 1540
    set $P124, $P2776
    unless_null $P124, vivify_2122
    new $P124, "Undef"
  vivify_2122:
    $P125 = $P124."arity"()
    if $P125, unless_2779_end
.annotate 'line', 1541
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    set $P2780, $P2776
    unless_null $P2780, vivify_2123
    $P2780 = root_new ['parrot';'ResizablePMCArray']
  vivify_2123:
    set $P128, $P2780[$I100]
    unless_null $P128, vivify_2124
    new $P128, "Undef"
  vivify_2124:
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Var"]
    $P133 = $P132."new"("$_" :named("name"), "parameter" :named("scope"))
    $P128."push"($P133)
.annotate 'line', 1542
    set $P127, $P2776
    unless_null $P127, vivify_2125
    new $P127, "Undef"
  vivify_2125:
    $P127."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1543
    set $P127, $P2776
    unless_null $P127, vivify_2126
    new $P127, "Undef"
  vivify_2126:
    $P127."arity"(1)
  unless_2779_end:
.annotate 'line', 1545
    set $P124, $P2776
    unless_null $P124, vivify_2127
    new $P124, "Undef"
  vivify_2127:
    $P124."blocktype"("immediate")
.annotate 'line', 1546
    set $P124, param_2774
    set $P125, $P2775
    unless_null $P125, vivify_2128
    new $P125, "Undef"
  vivify_2128:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1536
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>" :anon :subid("498_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2782
    .param pmc param_2783
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1549
    .lex "self", param_2782
    .lex "$/", param_2783
.annotate 'line', 1550
    new $P122, "Undef"
    set $P2784, $P122
    .lex "$block", $P2784
    set $P2785, param_2783
    unless_null $P2785, vivify_2129
    $P2785 = root_new ['parrot';'Hash']
  vivify_2129:
    set $P123, $P2785["block"]
    unless_null $P123, vivify_2130
    new $P123, "Undef"
  vivify_2130:
    $P124 = $P123."ast"()
    set $P2784, $P124
.annotate 'line', 1551
    set $P123, param_2783
    unless_null $P123, vivify_2131
    new $P123, "Undef"
  vivify_2131:
    set $P124, $P2784
    unless_null $P124, vivify_2132
    new $P124, "Undef"
  vivify_2132:
    "push_block_handler"($P123, $P124)
.annotate 'line', 1552
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    new $P124, "Float"
    assign $P124, 0
    set $I101, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2786, $P127["@BLOCK"]
    unless_null $P2786, vivify_2133
    $P2786 = root_new ['parrot';'ResizablePMCArray']
  vivify_2133:
    set $P128, $P2786[$I101]
    unless_null $P128, vivify_2134
    new $P128, "Undef"
  vivify_2134:
    $P129 = $P128."handlers"()
    set $P130, $P129[$I100]
    unless_null $P130, vivify_2135
    new $P130, "Undef"
  vivify_2135:
    $P130."handle_types_except"("CONTROL")
.annotate 'line', 1553
    set $P123, param_2783
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    set $P129, param_2783
    unless_null $P129, vivify_2136
    new $P129, "Undef"
  vivify_2136:
    $P130 = $P128."new"($P129 :named("node"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 1549
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>" :anon :subid("499_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2788
    .param pmc param_2789
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1556
    .lex "self", param_2788
    .lex "$/", param_2789
.annotate 'line', 1557
    new $P122, "Undef"
    set $P2790, $P122
    .lex "$block", $P2790
    set $P2791, param_2789
    unless_null $P2791, vivify_2137
    $P2791 = root_new ['parrot';'Hash']
  vivify_2137:
    set $P123, $P2791["block"]
    unless_null $P123, vivify_2138
    new $P123, "Undef"
  vivify_2138:
    $P124 = $P123."ast"()
    set $P2790, $P124
.annotate 'line', 1558
    set $P123, param_2789
    unless_null $P123, vivify_2139
    new $P123, "Undef"
  vivify_2139:
    set $P124, $P2790
    unless_null $P124, vivify_2140
    new $P124, "Undef"
  vivify_2140:
    "push_block_handler"($P123, $P124)
.annotate 'line', 1559
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    new $P124, "Float"
    assign $P124, 0
    set $I101, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P2792, $P127["@BLOCK"]
    unless_null $P2792, vivify_2141
    $P2792 = root_new ['parrot';'ResizablePMCArray']
  vivify_2141:
    set $P128, $P2792[$I101]
    unless_null $P128, vivify_2142
    new $P128, "Undef"
  vivify_2142:
    $P129 = $P128."handlers"()
    set $P130, $P129[$I100]
    unless_null $P130, vivify_2143
    new $P130, "Undef"
  vivify_2143:
    $P130."handle_types"("CONTROL")
.annotate 'line', 1560
    set $P123, param_2789
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Stmts"]
    set $P129, param_2789
    unless_null $P129, vivify_2144
    new $P129, "Undef"
  vivify_2144:
    $P130 = $P128."new"($P129 :named("node"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 1556
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>" :anon :subid("500_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2794
    .param pmc param_2795
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1600
    .lex "self", param_2794
    .lex "$/", param_2795
.annotate 'line', 1601
    new $P122, "Float"
    assign $P122, 0
    set $I100, $P122
    find_lex $P123, "$?PACKAGE"
    get_who $P124, $P123
    set $P2796, $P124["@BLOCK"]
    unless_null $P2796, vivify_2145
    $P2796 = root_new ['parrot';'ResizablePMCArray']
  vivify_2145:
    set $P125, $P2796[$I100]
    unless_null $P125, vivify_2146
    new $P125, "Undef"
  vivify_2146:
    set $P2797, param_2795
    unless_null $P2797, vivify_2147
    $P2797 = root_new ['parrot';'Hash']
  vivify_2147:
    set $P127, $P2797["blorst"]
    unless_null $P127, vivify_2148
    new $P127, "Undef"
  vivify_2148:
    $P128 = $P127."ast"()
    $P125."push"($P128)
.annotate 'line', 1602
    set $P122, param_2795
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Stmts"]
    $P128 = $P127."new"()
    $P129 = $P122."!make"($P128)
.annotate 'line', 1600
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>" :anon :subid("501_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2799
    .param pmc param_2800
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1605
    .lex "self", param_2799
    .lex "$/", param_2800
.annotate 'line', 1606
    new $P122, "Undef"
    set $P2801, $P122
    .lex "$past", $P2801
    set $P2802, param_2800
    unless_null $P2802, vivify_2149
    $P2802 = root_new ['parrot';'Hash']
  vivify_2149:
    set $P123, $P2802["blorst"]
    unless_null $P123, vivify_2150
    new $P123, "Undef"
  vivify_2150:
    $P124 = $P123."ast"()
    set $P2801, $P124
.annotate 'line', 1607
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Block"]
    set $P128, $P2801
    unless_null $P128, vivify_2151
    new $P128, "Undef"
  vivify_2151:
    $P129 = $P127."ACCEPTS"($P128)
    if $P129, unless_2803_end
.annotate 'line', 1608
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Block"]
    set $P134, $P2801
    unless_null $P134, vivify_2152
    new $P134, "Undef"
  vivify_2152:
    set $P135, param_2800
    unless_null $P135, vivify_2153
    new $P135, "Undef"
  vivify_2153:
    $P136 = $P133."new"($P134, "immediate" :named("blocktype"), $P135 :named("node"))
    set $P2801, $P136
  unless_2803_end:
.annotate 'line', 1610
    set $P123, $P2801
    unless_null $P123, vivify_2154
    new $P123, "Undef"
  vivify_2154:
    $P124 = $P123."handlers"()
    if $P124, unless_2804_end
.annotate 'line', 1611
    set $P125, $P2801
    unless_null $P125, vivify_2155
    new $P125, "Undef"
  vivify_2155:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Control"]
.annotate 'line', 1613
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Stmts"]
.annotate 'line', 1614
    get_hll_global $P135, "GLOBAL"
    nqp_get_package_through_who $P136, $P135, "PAST"
    get_who $P137, $P136
    set $P138, $P137["Op"]
.annotate 'line', 1615
    get_hll_global $P139, "GLOBAL"
    nqp_get_package_through_who $P140, $P139, "PAST"
    get_who $P141, $P140
    set $P142, $P141["Var"]
.annotate 'line', 1616
    get_hll_global $P143, "GLOBAL"
    nqp_get_package_through_who $P144, $P143, "PAST"
    get_who $P145, $P144
    set $P146, $P145["Var"]
    $P147 = $P146."new"("register" :named("scope"), "exception" :named("name"))
    $P148 = $P142."new"($P147, "handled", "keyed" :named("scope"))
.annotate 'line', 1615
    $P149 = $P138."new"($P148, 1, "bind_6model" :named("pasttype"))
.annotate 'line', 1614
    $P151 = $P134."new"($P149)
.annotate 'line', 1613
    $P152 = $P130."new"($P151, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1611
    new $P153, "ResizablePMCArray"
    push $P153, $P152
    $P125."handlers"($P153)
  unless_2804_end:
.annotate 'line', 1625
    set $P123, param_2800
    set $P124, $P2801
    unless_null $P124, vivify_2156
    new $P124, "Undef"
  vivify_2156:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1605
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst" :anon :subid("502_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2806
    .param pmc param_2807
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1628
    .lex "self", param_2806
    .lex "$/", param_2807
.annotate 'line', 1629
    set $P122, param_2807
.annotate 'line', 1630
    set $P2809, param_2807
    unless_null $P2809, vivify_2157
    $P2809 = root_new ['parrot';'Hash']
  vivify_2157:
    set $P124, $P2809["block"]
    unless_null $P124, vivify_2158
    new $P124, "Undef"
  vivify_2158:
    if $P124, if_2808
.annotate 'line', 1631
    set $P2811, param_2807
    unless_null $P2811, vivify_2159
    $P2811 = root_new ['parrot';'Hash']
  vivify_2159:
    set $P129, $P2811["statement"]
    unless_null $P129, vivify_2160
    new $P129, "Undef"
  vivify_2160:
    $P130 = $P129."ast"()
    set $P123, $P130
.annotate 'line', 1630
    goto if_2808_end
  if_2808:
    set $P2810, param_2807
    unless_null $P2810, vivify_2161
    $P2810 = root_new ['parrot';'Hash']
  vivify_2161:
    set $P125, $P2810["block"]
    unless_null $P125, vivify_2162
    new $P125, "Undef"
  vivify_2162:
    $P127 = $P125."ast"()
    $P128 = "block_immediate"($P127)
    set $P123, $P128
  if_2808_end:
    $P131 = $P122."!make"($P123)
.annotate 'line', 1628
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>" :anon :subid("503_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2813
    .param pmc param_2814
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1636
    .lex "self", param_2813
    .lex "$/", param_2814
    set $P122, param_2814
    set $P2815, param_2814
    unless_null $P2815, vivify_2163
    $P2815 = root_new ['parrot';'Hash']
  vivify_2163:
    set $P123, $P2815["cond"]
    unless_null $P123, vivify_2164
    new $P123, "Undef"
  vivify_2164:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>" :anon :subid("504_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2817
    .param pmc param_2818
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1637
    .lex "self", param_2817
    .lex "$/", param_2818
    set $P122, param_2818
    set $P2819, param_2818
    unless_null $P2819, vivify_2165
    $P2819 = root_new ['parrot';'Hash']
  vivify_2165:
    set $P123, $P2819["cond"]
    unless_null $P123, vivify_2166
    new $P123, "Undef"
  vivify_2166:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>" :anon :subid("505_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2821
    .param pmc param_2822
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1639
    .lex "self", param_2821
    .lex "$/", param_2822
    set $P122, param_2822
    set $P2823, param_2822
    unless_null $P2823, vivify_2167
    $P2823 = root_new ['parrot';'Hash']
  vivify_2167:
    set $P123, $P2823["cond"]
    unless_null $P123, vivify_2168
    new $P123, "Undef"
  vivify_2168:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>" :anon :subid("506_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2825
    .param pmc param_2826
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1640
    .lex "self", param_2825
    .lex "$/", param_2826
    set $P122, param_2826
    set $P2827, param_2826
    unless_null $P2827, vivify_2169
    $P2827 = root_new ['parrot';'Hash']
  vivify_2169:
    set $P123, $P2827["cond"]
    unless_null $P123, vivify_2170
    new $P123, "Undef"
  vivify_2170:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>" :anon :subid("507_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2829
    .param pmc param_2830
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1644
    .lex "self", param_2829
    .lex "$/", param_2830
    set $P122, param_2830
    set $P2831, param_2830
    unless_null $P2831, vivify_2171
    $P2831 = root_new ['parrot';'Hash']
  vivify_2171:
    set $P123, $P2831["fatarrow"]
    unless_null $P123, vivify_2172
    new $P123, "Undef"
  vivify_2172:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>" :anon :subid("508_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2833
    .param pmc param_2834
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1645
    .lex "self", param_2833
    .lex "$/", param_2834
    set $P122, param_2834
    set $P2835, param_2834
    unless_null $P2835, vivify_2173
    $P2835 = root_new ['parrot';'Hash']
  vivify_2173:
    set $P123, $P2835["colonpair"]
    unless_null $P123, vivify_2174
    new $P123, "Undef"
  vivify_2174:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>" :anon :subid("509_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2837
    .param pmc param_2838
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1646
    .lex "self", param_2837
    .lex "$/", param_2838
    set $P122, param_2838
    set $P2839, param_2838
    unless_null $P2839, vivify_2175
    $P2839 = root_new ['parrot';'Hash']
  vivify_2175:
    set $P123, $P2839["variable"]
    unless_null $P123, vivify_2176
    new $P123, "Undef"
  vivify_2176:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>" :anon :subid("510_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2841
    .param pmc param_2842
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1647
    .lex "self", param_2841
    .lex "$/", param_2842
    set $P122, param_2842
    set $P2843, param_2842
    unless_null $P2843, vivify_2177
    $P2843 = root_new ['parrot';'Hash']
  vivify_2177:
    set $P123, $P2843["package_declarator"]
    unless_null $P123, vivify_2178
    new $P123, "Undef"
  vivify_2178:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>" :anon :subid("511_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2845
    .param pmc param_2846
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1648
    .lex "self", param_2845
    .lex "$/", param_2846
    set $P122, param_2846
    set $P2847, param_2846
    unless_null $P2847, vivify_2179
    $P2847 = root_new ['parrot';'Hash']
  vivify_2179:
    set $P123, $P2847["scope_declarator"]
    unless_null $P123, vivify_2180
    new $P123, "Undef"
  vivify_2180:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>" :anon :subid("512_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2849
    .param pmc param_2850
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1649
    .lex "self", param_2849
    .lex "$/", param_2850
    set $P122, param_2850
    set $P2851, param_2850
    unless_null $P2851, vivify_2181
    $P2851 = root_new ['parrot';'Hash']
  vivify_2181:
    set $P123, $P2851["routine_declarator"]
    unless_null $P123, vivify_2182
    new $P123, "Undef"
  vivify_2182:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>" :anon :subid("513_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2853
    .param pmc param_2854
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1650
    .lex "self", param_2853
    .lex "$/", param_2854
    set $P122, param_2854
    set $P2855, param_2854
    unless_null $P2855, vivify_2183
    $P2855 = root_new ['parrot';'Hash']
  vivify_2183:
    set $P123, $P2855["regex_declarator"]
    unless_null $P123, vivify_2184
    new $P123, "Undef"
  vivify_2184:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>" :anon :subid("514_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2857
    .param pmc param_2858
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1651
    .lex "self", param_2857
    .lex "$/", param_2858
    set $P122, param_2858
    set $P2859, param_2858
    unless_null $P2859, vivify_2185
    $P2859 = root_new ['parrot';'Hash']
  vivify_2185:
    set $P123, $P2859["statement_prefix"]
    unless_null $P123, vivify_2186
    new $P123, "Undef"
  vivify_2186:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>" :anon :subid("515_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2861
    .param pmc param_2862
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1652
    .lex "self", param_2861
    .lex "$/", param_2862
    set $P122, param_2862
    set $P2863, param_2862
    unless_null $P2863, vivify_2187
    $P2863 = root_new ['parrot';'Hash']
  vivify_2187:
    set $P123, $P2863["pblock"]
    unless_null $P123, vivify_2188
    new $P123, "Undef"
  vivify_2188:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow" :anon :subid("516_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2865
    .param pmc param_2866
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1654
    .lex "self", param_2865
    .lex "$/", param_2866
.annotate 'line', 1655
    new $P122, "Undef"
    set $P2867, $P122
    .lex "$past", $P2867
    set $P2868, param_2866
    unless_null $P2868, vivify_2189
    $P2868 = root_new ['parrot';'Hash']
  vivify_2189:
    set $P123, $P2868["val"]
    unless_null $P123, vivify_2190
    new $P123, "Undef"
  vivify_2190:
    $P124 = $P123."ast"()
    set $P2867, $P124
.annotate 'line', 1656
    set $P123, $P2867
    unless_null $P123, vivify_2191
    new $P123, "Undef"
  vivify_2191:
    set $P2869, param_2866
    unless_null $P2869, vivify_2192
    $P2869 = root_new ['parrot';'Hash']
  vivify_2192:
    set $P124, $P2869["key"]
    unless_null $P124, vivify_2193
    new $P124, "Undef"
  vivify_2193:
    $P125 = $P124."Str"()
    $P123."named"($P125)
.annotate 'line', 1657
    set $P123, param_2866
    set $P124, $P2867
    unless_null $P124, vivify_2194
    new $P124, "Undef"
  vivify_2194:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1654
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair" :anon :subid("517_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2871
    .param pmc param_2872
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1660
    .lex "self", param_2871
    .lex "$/", param_2872
.annotate 'line', 1661
    new $P122, "Undef"
    set $P2873, $P122
    .lex "$past", $P2873
.annotate 'line', 1662
    set $P2875, param_2872
    unless_null $P2875, vivify_2195
    $P2875 = root_new ['parrot';'Hash']
  vivify_2195:
    set $P124, $P2875["circumfix"]
    unless_null $P124, vivify_2196
    new $P124, "Undef"
  vivify_2196:
    if $P124, if_2874
.annotate 'line', 1663
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Val"]
    set $P2878, param_2872
    unless_null $P2878, vivify_2197
    $P2878 = root_new ['parrot';'Hash']
  vivify_2197:
    set $P133, $P2878["not"]
    unless_null $P133, vivify_2198
    new $P133, "Undef"
  vivify_2198:
    isfalse $I101, $P133
    $P134 = $P132."new"($I101 :named("value"))
    set $P123, $P134
.annotate 'line', 1662
    goto if_2874_end
  if_2874:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    set $P2876, param_2872
    unless_null $P2876, vivify_2199
    $P2876 = root_new ['parrot';'Hash']
  vivify_2199:
    set $P2877, $P2876["circumfix"]
    unless_null $P2877, vivify_2200
    $P2877 = root_new ['parrot';'ResizablePMCArray']
  vivify_2200:
    set $P127, $P2877[$I100]
    unless_null $P127, vivify_2201
    new $P127, "Undef"
  vivify_2201:
    $P128 = $P127."ast"()
    set $P123, $P128
  if_2874_end:
    set $P2873, $P123
.annotate 'line', 1664
    set $P123, $P2873
    unless_null $P123, vivify_2202
    new $P123, "Undef"
  vivify_2202:
    set $P2879, param_2872
    unless_null $P2879, vivify_2203
    $P2879 = root_new ['parrot';'Hash']
  vivify_2203:
    set $P124, $P2879["identifier"]
    unless_null $P124, vivify_2204
    new $P124, "Undef"
  vivify_2204:
    set $S100, $P124
    $P123."named"($S100)
.annotate 'line', 1665
    set $P123, param_2872
    set $P124, $P2873
    unless_null $P124, vivify_2205
    new $P124, "Undef"
  vivify_2205:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1660
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable" :anon :subid("518_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2881
    .param pmc param_2882
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1668
    .const 'Sub' $P2888 = "519_1325892461.451" 
    capture_lex $P2888
    .lex "self", param_2881
    .lex "$/", param_2882
.annotate 'line', 1669
    new $P122, "Undef"
    set $P2883, $P122
    .lex "$past", $P2883
.annotate 'line', 1668
    set $P123, $P2883
    unless_null $P123, vivify_2206
    new $P123, "Undef"
  vivify_2206:
.annotate 'line', 1670
    set $P2885, param_2882
    unless_null $P2885, vivify_2207
    $P2885 = root_new ['parrot';'Hash']
  vivify_2207:
    set $P123, $P2885["postcircumfix"]
    unless_null $P123, vivify_2208
    new $P123, "Undef"
  vivify_2208:
    if $P123, if_2884
.annotate 'line', 1674
    .const 'Sub' $P2888 = "519_1325892461.451" 
    capture_lex $P2888
    $P2888()
    goto if_2884_end
  if_2884:
.annotate 'line', 1671
    set $P2886, param_2882
    unless_null $P2886, vivify_2270
    $P2886 = root_new ['parrot';'Hash']
  vivify_2270:
    set $P124, $P2886["postcircumfix"]
    unless_null $P124, vivify_2271
    new $P124, "Undef"
  vivify_2271:
    $P125 = $P124."ast"()
    set $P2883, $P125
.annotate 'line', 1672
    set $P124, $P2883
    unless_null $P124, vivify_2272
    new $P124, "Undef"
  vivify_2272:
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Var"]
    $P130 = $P129."new"("$/" :named("name"))
    $P124."unshift"($P130)
  if_2884_end:
.annotate 'line', 1736
    set $P123, param_2882
    set $P124, $P2883
    unless_null $P124, vivify_2273
    new $P124, "Undef"
  vivify_2273:
    $P125 = $P123."!make"($P124)
.annotate 'line', 1668
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2887"  :anon :subid("519_1325892461.451") :outer("518_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1674
    .const 'Sub' $P2910 = "521_1325892461.451" 
    capture_lex $P2910
    .const 'Sub' $P2901 = "520_1325892461.451" 
    capture_lex $P2901
.annotate 'line', 1675
    $P2890 = root_new ['parrot';'ResizablePMCArray']
    set $P2889, $P2890
    .lex "@name", $P2889
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "NQP"
    get_who $P127, $P125
    set $P128, $P127["Compiler"]
    find_lex $P129, "$/"
    unless_null $P129, vivify_2209
    new $P129, "Undef"
  vivify_2209:
    set $S100, $P129
    $P130 = $P128."parse_name"($S100)
    set $P2889, $P130
.annotate 'line', 1676
    set $P2892, $P2889
    unless_null $P2892, vivify_2210
    $P2892 = root_new ['parrot';'ResizablePMCArray']
  vivify_2210:
    set $N100, $P2892
    set $N101, 1
    isgt $I100, $N100, $N101
    if $I100, if_2891
.annotate 'line', 1683
    new $P127, "Float"
    assign $P127, 0
    set $I101, $P127
    find_lex $P2898, "$/"
    unless_null $P2898, vivify_2211
    $P2898 = root_new ['parrot';'Hash']
  vivify_2211:
    set $P2899, $P2898["twigil"]
    unless_null $P2899, vivify_2212
    $P2899 = root_new ['parrot';'ResizablePMCArray']
  vivify_2212:
    set $P128, $P2899[$I101]
    unless_null $P128, vivify_2213
    new $P128, "Undef"
  vivify_2213:
    set $S100, $P128
    iseq $I102, $S100, "*"
    if $I102, if_2897
.annotate 'line', 1694
    new $P133, "Float"
    assign $P133, 0
    set $I103, $P133
    find_lex $P2907, "$/"
    unless_null $P2907, vivify_2214
    $P2907 = root_new ['parrot';'Hash']
  vivify_2214:
    set $P2908, $P2907["twigil"]
    unless_null $P2908, vivify_2215
    $P2908 = root_new ['parrot';'ResizablePMCArray']
  vivify_2215:
    set $P134, $P2908[$I103]
    unless_null $P134, vivify_2216
    new $P134, "Undef"
  vivify_2216:
    set $S101, $P134
    iseq $I104, $S101, "!"
    if $I104, if_2906
.annotate 'line', 1726
    new $P141, "Float"
    assign $P141, 0
    set $I105, $P141
    set $P2929, $P2889
    unless_null $P2929, vivify_2217
    $P2929 = root_new ['parrot';'ResizablePMCArray']
  vivify_2217:
    set $P142, $P2929[$I105]
    unless_null $P142, vivify_2218
    new $P142, "Undef"
  vivify_2218:
    set $S102, $P142
    $P143 = "is_package"($S102)
    if $P143, if_2928
.annotate 'line', 1731
    get_hll_global $P144, "GLOBAL"
    nqp_get_package_through_who $P145, $P144, "PAST"
    get_who $P146, $P145
    set $P148, $P146["Var"]
.annotate 'line', 1732
    set $P2932, $P2889
    unless_null $P2932, vivify_2219
    $P2932 = root_new ['parrot';'ResizablePMCArray']
  vivify_2219:
    $P149 = $P2932."pop"()
    set $S103, $P149
    find_lex $P2933, "$/"
    unless_null $P2933, vivify_2220
    $P2933 = root_new ['parrot';'Hash']
  vivify_2220:
    set $P151, $P2933["sigil"]
    unless_null $P151, vivify_2221
    new $P151, "Undef"
  vivify_2221:
    $P152 = "vivitype"($P151)
.annotate 'line', 1731
    $P153 = $P148."new"($S103 :named("name"), $P152 :named("viviself"))
    store_lex "$past", $P153
.annotate 'line', 1730
    set $P140, $P153
.annotate 'line', 1726
    goto if_2928_end
  if_2928:
.annotate 'line', 1727
    set $P2930, $P2889
    unless_null $P2930, vivify_2222
    $P2930 = root_new ['parrot';'ResizablePMCArray']
  vivify_2222:
    find_lex $P144, "$/"
    unless_null $P144, vivify_2223
    new $P144, "Undef"
  vivify_2223:
    $P145 = "lexical_package_lookup"($P2930, $P144)
    store_lex "$past", $P145
.annotate 'line', 1728
    find_lex $P144, "$past"
    unless_null $P144, vivify_2224
    new $P144, "Undef"
  vivify_2224:
    find_lex $P2931, "$/"
    unless_null $P2931, vivify_2225
    $P2931 = root_new ['parrot';'Hash']
  vivify_2225:
    set $P145, $P2931["sigil"]
    unless_null $P145, vivify_2226
    new $P145, "Undef"
  vivify_2226:
    $P146 = "vivitype"($P145)
    $P147 = $P144."viviself"($P146)
.annotate 'line', 1726
    set $P140, $P147
  if_2928_end:
    set $P132, $P140
.annotate 'line', 1694
    goto if_2906_end
  if_2906:
    .const 'Sub' $P2910 = "521_1325892461.451" 
    capture_lex $P2910
    $P139 = $P2910()
    set $P132, $P139
  if_2906_end:
    set $P125, $P132
.annotate 'line', 1683
    goto if_2897_end
  if_2897:
    .const 'Sub' $P2901 = "520_1325892461.451" 
    capture_lex $P2901
    $P131 = $P2901()
    set $P125, $P131
  if_2897_end:
    set $P124, $P125
.annotate 'line', 1676
    goto if_2891_end
  if_2891:
.annotate 'line', 1677
    find_lex $P2894, "$/"
    unless_null $P2894, vivify_2262
    $P2894 = root_new ['parrot';'Hash']
  vivify_2262:
    set $P125, $P2894["twigil"]
    unless_null $P125, vivify_2263
    new $P125, "Undef"
  vivify_2263:
    unless $P125, if_2893_end
.annotate 'line', 1678
    find_lex $P127, "$/"
    unless_null $P127, vivify_2264
    new $P127, "Undef"
  vivify_2264:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Twigil not allowed on multi-part name")
  if_2893_end:
.annotate 'line', 1680
    set $P2895, $P2889
    unless_null $P2895, vivify_2265
    $P2895 = root_new ['parrot';'ResizablePMCArray']
  vivify_2265:
    find_lex $P125, "$/"
    unless_null $P125, vivify_2266
    new $P125, "Undef"
  vivify_2266:
    $P127 = "lexical_package_lookup"($P2895, $P125)
    store_lex "$past", $P127
.annotate 'line', 1681
    find_lex $P125, "$past"
    unless_null $P125, vivify_2267
    new $P125, "Undef"
  vivify_2267:
    find_lex $P2896, "$/"
    unless_null $P2896, vivify_2268
    $P2896 = root_new ['parrot';'Hash']
  vivify_2268:
    set $P127, $P2896["sigil"]
    unless_null $P127, vivify_2269
    new $P127, "Undef"
  vivify_2269:
    $P128 = "vivitype"($P127)
    $P129 = $P125."viviself"($P128)
.annotate 'line', 1676
    set $P124, $P129
  if_2891_end:
.annotate 'line', 1674
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2909"  :anon :subid("521_1325892461.451") :outer("519_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1694
    .const 'Sub' $P2919 = "522_1325892461.451" 
    capture_lex $P2919
.annotate 'line', 1696
    new $P135, "Undef"
    set $P2911, $P135
    .lex "$name", $P2911
.annotate 'line', 1697
    new $P136, "Undef"
    set $P2912, $P136
    .lex "$ch", $P2912
.annotate 'line', 1696
    find_lex $P2913, "@name"
    unless_null $P2913, vivify_2227
    $P2913 = root_new ['parrot';'ResizablePMCArray']
  vivify_2227:
    $P138 = $P2913."pop"()
    set $S102, $P138
    new $P139, 'String'
    set $P139, $S102
    set $P2911, $P139
.annotate 'line', 1697
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Var"]
    $P142 = $P141."new"("$?CLASS" :named("name"))
    set $P2912, $P142
.annotate 'line', 1698
    new $P138, "Float"
    assign $P138, 1
    set $P2914, $P2912
    unless_null $P2914, vivify_2228
    $P2914 = root_new ['parrot';'Hash']
    set $P2912, $P2914
  vivify_2228:
    set $P2914["has_compile_time_value"], $P138
.annotate 'line', 1699
    find_dynamic_lex $P140, "$*PACKAGE"
    unless_null $P140, vivify_2229
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$PACKAGE"]
    unless_null $P140, vivify_2230
    die "Contextual $*PACKAGE not found"
  vivify_2230:
  vivify_2229:
    set $P2915, $P2912
    unless_null $P2915, vivify_2231
    $P2915 = root_new ['parrot';'Hash']
    set $P2912, $P2915
  vivify_2231:
    set $P2915["compile_time_value"], $P140
.annotate 'line', 1700
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Var"]
    set $P142, $P2911
    unless_null $P142, vivify_2232
    new $P142, "Undef"
  vivify_2232:
.annotate 'line', 1702
    find_lex $P2916, "$/"
    unless_null $P2916, vivify_2233
    $P2916 = root_new ['parrot';'Hash']
  vivify_2233:
    set $P143, $P2916["sigil"]
    unless_null $P143, vivify_2234
    new $P143, "Undef"
  vivify_2234:
    $P144 = "vivitype"($P143)
.annotate 'line', 1703
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Var"]
    $P154 = $P153."new"("self" :named("name"))
    $P155 = $P148."new"($P154, "nqp_decontainerize PP" :named("pirop"))
    set $P156, $P2912
    unless_null $P156, vivify_2235
    new $P156, "Undef"
  vivify_2235:
    $P157 = $P141."new"($P155, $P156, $P142 :named("name"), "attribute_6model" :named("scope"), $P144 :named("viviself"))
.annotate 'line', 1700
    store_lex "$past", $P157
.annotate 'line', 1708
    find_dynamic_lex $P141, "$*IN_DECL"
    unless_null $P141, vivify_2236
    get_hll_global $P139, "GLOBAL"
    get_who $P140, $P139
    set $P141, $P140["$IN_DECL"]
    unless_null $P141, vivify_2237
    die "Contextual $*IN_DECL not found"
  vivify_2237:
  vivify_2236:
    unless $P141, unless_2917
    set $P138, $P141
    goto unless_2917_end
  unless_2917:
    .const 'Sub' $P2919 = "522_1325892461.451" 
    capture_lex $P2919
    $P144 = $P2919()
    set $P138, $P144
  unless_2917_end:
.annotate 'line', 1694
    .return ($P138)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2918"  :anon :subid("522_1325892461.451") :outer("521_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1708
    .const 'Sub' $P2922 = "523_1325892461.451" 
    capture_lex $P2922
.annotate 'line', 1709
    new $P142, "Undef"
    set $P2920, $P142
    .lex "$attr", $P2920
.annotate 'line', 1708
    set $P143, $P2920
    unless_null $P143, vivify_2238
    new $P143, "Undef"
  vivify_2238:
.annotate 'line', 1710
    find_dynamic_lex $P146, "$*PACKAGE"
    unless_null $P146, vivify_2239
    get_hll_global $P144, "GLOBAL"
    get_who $P145, $P144
    set $P146, $P145["$PACKAGE"]
    unless_null $P146, vivify_2240
    die "Contextual $*PACKAGE not found"
  vivify_2240:
  vivify_2239:
    get_how $P147, $P146
    find_dynamic_lex $P151, "$*PACKAGE"
    unless_null $P151, vivify_2241
    get_hll_global $P148, "GLOBAL"
    get_who $P149, $P148
    set $P151, $P149["$PACKAGE"]
    unless_null $P151, vivify_2242
    die "Contextual $*PACKAGE not found"
  vivify_2242:
  vivify_2241:
    $P152 = $P147."attributes"($P151, 1 :named("local"))
    defined $I105, $P152
    unless $I105, for_undef_2243
    iter $P143, $P152
    new $P155, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P155, loop2925_handler
    push_eh $P155
  loop2925_test:
    unless $P143, loop2925_done
    shift $P153, $P143
  loop2925_redo:
    .const 'Sub' $P2922 = "523_1325892461.451" 
    capture_lex $P2922
    $P2922($P153)
  loop2925_next:
    goto loop2925_test
  loop2925_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P156, exception, 'type'
    eq $P156, .CONTROL_LOOP_NEXT, loop2925_next
    eq $P156, .CONTROL_LOOP_REDO, loop2925_redo
  loop2925_done:
    pop_eh 
  for_undef_2243:
.annotate 'line', 1716
    set $P144, $P2920
    unless_null $P144, vivify_2247
    new $P144, "Undef"
  vivify_2247:
    defined $I105, $P144
    if $I105, if_2926
.annotate 'line', 1722
    find_lex $P146, "$/"
    unless_null $P146, vivify_2248
    new $P146, "Undef"
  vivify_2248:
    $P147 = $P146."CURSOR"()
    new $P148, 'String'
    set $P148, "Attribute '"
    find_lex $P149, "$name"
    unless_null $P149, vivify_2249
    new $P149, "Undef"
  vivify_2249:
    concat $P151, $P148, $P149
    concat $P152, $P151, "' not declared"
    $P153 = $P147."panic"($P152)
.annotate 'line', 1721
    set $P143, $P153
.annotate 'line', 1716
    goto if_2926_end
  if_2926:
.annotate 'line', 1717
    set $P146, $P2920
    unless_null $P146, vivify_2250
    new $P146, "Undef"
  vivify_2250:
    can $I106, $P146, "type"
    if $I106, if_2927
    new $P145, 'Integer'
    set $P145, $I106
    goto if_2927_end
  if_2927:
.annotate 'line', 1718
    find_lex $P147, "$past"
    unless_null $P147, vivify_2251
    new $P147, "Undef"
  vivify_2251:
    set $P148, $P2920
    unless_null $P148, vivify_2252
    new $P148, "Undef"
  vivify_2252:
    $P149 = $P148."type"()
    $P151 = $P147."type"($P149)
.annotate 'line', 1717
    set $P145, $P151
  if_2927_end:
.annotate 'line', 1716
    set $P143, $P145
  if_2926_end:
.annotate 'line', 1708
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2921"  :anon :subid("523_1325892461.451") :outer("522_1325892461.451")
    .param pmc param_2923
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1710
    .lex "$_", param_2923
.annotate 'line', 1711
    find_lex $P155, "$_"
    unless_null $P155, vivify_2244
    new $P155, "Undef"
  vivify_2244:
    $S102 = $P155."name"()
    find_lex $P156, "$name"
    unless_null $P156, vivify_2245
    new $P156, "Undef"
  vivify_2245:
    set $S103, $P156
    iseq $I106, $S102, $S103
    if $I106, if_2924
    new $P154, 'Integer'
    set $P154, $I106
    goto if_2924_end
  if_2924:
.annotate 'line', 1712
    find_lex $P157, "$_"
    unless_null $P157, vivify_2246
    new $P157, "Undef"
  vivify_2246:
    store_lex "$attr", $P157
.annotate 'line', 1713
    die 0, .CONTROL_LOOP_LAST
  if_2924_end:
.annotate 'line', 1710
    .return ($P154)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2900"  :anon :subid("520_1325892461.451") :outer("519_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1684
    new $P130, "Undef"
    set $P2902, $P130
    .lex "$global_fallback", $P2902
    find_lex $P2903, "$/"
    unless_null $P2903, vivify_2253
    $P2903 = root_new ['parrot';'Hash']
  vivify_2253:
    set $P131, $P2903["sigil"]
    unless_null $P131, vivify_2254
    new $P131, "Undef"
  vivify_2254:
    set $S101, $P131
    new $P132, 'String'
    set $P132, $S101
    find_lex $P2904, "$/"
    unless_null $P2904, vivify_2255
    $P2904 = root_new ['parrot';'Hash']
  vivify_2255:
    set $P133, $P2904["desigilname"]
    unless_null $P133, vivify_2256
    new $P133, "Undef"
  vivify_2256:
    concat $P134, $P132, $P133
    new $P135, "ResizablePMCArray"
    push $P135, "GLOBAL"
    push $P135, $P134
    find_lex $P136, "$/"
    unless_null $P136, vivify_2257
    new $P136, "Undef"
  vivify_2257:
    $P137 = "lexical_package_lookup"($P135, $P136)
    set $P2902, $P137
.annotate 'line', 1685
    set $P131, $P2902
    unless_null $P131, vivify_2258
    new $P131, "Undef"
  vivify_2258:
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Op"]
.annotate 'line', 1686
    new $P136, "String"
    assign $P136, "Contextual "
    find_lex $P137, "$/"
    unless_null $P137, vivify_2259
    new $P137, "Undef"
  vivify_2259:
    set $S101, $P137
    concat $P138, $P136, $S101
    concat $P139, $P138, " not found"
    $P140 = $P135."new"($P139, "die" :named("pirop"))
.annotate 'line', 1685
    $P131."viviself"($P140)
.annotate 'line', 1689
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
.annotate 'line', 1690
    find_lex $P2905, "@name"
    unless_null $P2905, vivify_2260
    $P2905 = root_new ['parrot';'ResizablePMCArray']
  vivify_2260:
    $P135 = $P2905."pop"()
    set $S101, $P135
.annotate 'line', 1689
    set $P136, $P2902
    unless_null $P136, vivify_2261
    new $P136, "Undef"
  vivify_2261:
    $P137 = $P134."new"($S101 :named("name"), "contextual" :named("scope"), $P136 :named("viviself"))
    store_lex "$past", $P137
.annotate 'line', 1683
    .return ($P137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>" :anon :subid("524_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2935
    .param pmc param_2936
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1739
    .lex "self", param_2935
    .lex "$/", param_2936
    set $P122, param_2936
    set $P2937, param_2936
    unless_null $P2937, vivify_2274
    $P2937 = root_new ['parrot';'Hash']
  vivify_2274:
    set $P123, $P2937["package_def"]
    unless_null $P123, vivify_2275
    new $P123, "Undef"
  vivify_2275:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>" :anon :subid("525_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2939
    .param pmc param_2940
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1740
    .lex "self", param_2939
    .lex "$/", param_2940
    set $P122, param_2940
    set $P2941, param_2940
    unless_null $P2941, vivify_2276
    $P2941 = root_new ['parrot';'Hash']
  vivify_2276:
    set $P123, $P2941["package_def"]
    unless_null $P123, vivify_2277
    new $P123, "Undef"
  vivify_2277:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>" :anon :subid("526_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2943
    .param pmc param_2944
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1741
    .lex "self", param_2943
    .lex "$/", param_2944
    set $P122, param_2944
    set $P2945, param_2944
    unless_null $P2945, vivify_2278
    $P2945 = root_new ['parrot';'Hash']
  vivify_2278:
    set $P123, $P2945["package_def"]
    unless_null $P123, vivify_2279
    new $P123, "Undef"
  vivify_2279:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>" :anon :subid("527_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2947
    .param pmc param_2948
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1742
    .lex "self", param_2947
    .lex "$/", param_2948
    set $P122, param_2948
    set $P2949, param_2948
    unless_null $P2949, vivify_2280
    $P2949 = root_new ['parrot';'Hash']
  vivify_2280:
    set $P123, $P2949["package_def"]
    unless_null $P123, vivify_2281
    new $P123, "Undef"
  vivify_2281:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>" :anon :subid("528_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2951
    .param pmc param_2952
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1743
    .lex "self", param_2951
    .lex "$/", param_2952
    set $P122, param_2952
    set $P2953, param_2952
    unless_null $P2953, vivify_2282
    $P2953 = root_new ['parrot';'Hash']
  vivify_2282:
    set $P123, $P2953["package_def"]
    unless_null $P123, vivify_2283
    new $P123, "Undef"
  vivify_2283:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>" :anon :subid("529_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2955
    .param pmc param_2956
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1744
    .lex "self", param_2955
    .lex "$/", param_2956
    set $P122, param_2956
    set $P2957, param_2956
    unless_null $P2957, vivify_2284
    $P2957 = root_new ['parrot';'Hash']
  vivify_2284:
    set $P123, $P2957["package_def"]
    unless_null $P123, vivify_2285
    new $P123, "Undef"
  vivify_2285:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<stub>" :anon :subid("530_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2959
    .param pmc param_2960
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1746
    .lex "self", param_2959
    .lex "$/", param_2960
.annotate 'line', 1749
    new $P122, "Undef"
    set $P2961, $P122
    .lex "$HOW", $P2961
.annotate 'line', 1750
    new $P123, "Undef"
    set $P2962, $P123
    .lex "$PACKAGE", $P2962
.annotate 'line', 1749
    set $P2963, param_2960
    unless_null $P2963, vivify_2286
    $P2963 = root_new ['parrot';'Hash']
  vivify_2286:
    set $P2964, $P2963["metaclass"]
    unless_null $P2964, vivify_2287
    $P2964 = root_new ['parrot';'Hash']
  vivify_2287:
    set $P124, $P2964["identifier"]
    unless_null $P124, vivify_2288
    new $P124, "Undef"
  vivify_2288:
    set $P125, param_2960
    unless_null $P125, vivify_2289
    new $P125, "Undef"
  vivify_2289:
    $P127 = "find_sym"($P124, $P125)
    set $P2961, $P127
.annotate 'line', 1750
    find_dynamic_lex $P127, "$*W"
    unless_null $P127, vivify_2290
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P127, $P125["$W"]
    unless_null $P127, vivify_2291
    die "Contextual $*W not found"
  vivify_2291:
  vivify_2290:
    set $P128, $P2961
    unless_null $P128, vivify_2292
    new $P128, "Undef"
  vivify_2292:
    set $P2965, param_2960
    unless_null $P2965, vivify_2293
    $P2965 = root_new ['parrot';'Hash']
  vivify_2293:
    set $P129, $P2965["name"]
    unless_null $P129, vivify_2294
    new $P129, "Undef"
  vivify_2294:
    set $S100, $P129
    $P130 = $P127."pkg_create_mo"($P128, $S100 :named("name"))
    set $P2962, $P130
.annotate 'line', 1753
    find_dynamic_lex $P128, "$*SCOPE"
    unless_null $P128, vivify_2295
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$SCOPE"]
    unless_null $P128, vivify_2296
    die "Contextual $*SCOPE not found"
  vivify_2296:
  vivify_2295:
    set $S100, $P128
    iseq $I100, $S100, "our"
    unless $I100, unless_2967
    new $P124, 'Integer'
    set $P124, $I100
    goto unless_2967_end
  unless_2967:
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2297
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2298
    die "Contextual $*SCOPE not found"
  vivify_2298:
  vivify_2297:
    set $S101, $P131
    iseq $I101, $S101, ""
    new $P124, 'Integer'
    set $P124, $I101
  unless_2967_end:
    if $P124, if_2966
.annotate 'line', 1759
    find_dynamic_lex $P134, "$*SCOPE"
    unless_null $P134, vivify_2299
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SCOPE"]
    unless_null $P134, vivify_2300
    die "Contextual $*SCOPE not found"
  vivify_2300:
  vivify_2299:
    set $S102, $P134
    iseq $I102, $S102, "my"
    if $I102, if_2977
.annotate 'line', 1766
    set $P135, param_2960
    unless_null $P135, vivify_2301
    new $P135, "Undef"
  vivify_2301:
    $P136 = $P135."CURSOR"()
    find_dynamic_lex $P139, "$*SCOPE"
    unless_null $P139, vivify_2302
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$SCOPE"]
    unless_null $P139, vivify_2303
    die "Contextual $*SCOPE not found"
  vivify_2303:
  vivify_2302:
    concat $P140, $P139, " scoped packages are not supported"
    $P136."panic"($P140)
.annotate 'line', 1765
    goto if_2977_end
  if_2977:
.annotate 'line', 1760
    set $P2979, param_2960
    unless_null $P2979, vivify_2304
    $P2979 = root_new ['parrot';'Hash']
  vivify_2304:
    set $P2980, $P2979["name"]
    unless_null $P2980, vivify_2305
    $P2980 = root_new ['parrot';'Hash']
  vivify_2305:
    set $P135, $P2980["identifier"]
    unless_null $P135, vivify_2306
    new $P135, "Undef"
  vivify_2306:
    set $N100, $P135
    set $N101, 1
    isne $I103, $N100, $N101
    unless $I103, if_2978_end
.annotate 'line', 1761
    set $P2981, param_2960
    unless_null $P2981, vivify_2307
    $P2981 = root_new ['parrot';'Hash']
  vivify_2307:
    set $P136, $P2981["name"]
    unless_null $P136, vivify_2308
    new $P136, "Undef"
  vivify_2308:
    $P137 = $P136."CURSOR"()
    $P137."panic"("A my scoped package cannot have a multi-part name yet")
  if_2978_end:
.annotate 'line', 1763
    find_dynamic_lex $P137, "$*W"
    unless_null $P137, vivify_2309
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$W"]
    unless_null $P137, vivify_2310
    die "Contextual $*W not found"
  vivify_2310:
  vivify_2309:
    new $P138, "Float"
    assign $P138, 0
    set $I103, $P138
    find_lex $P139, "$?PACKAGE"
    get_who $P140, $P139
    set $P2982, $P140["@BLOCK"]
    unless_null $P2982, vivify_2311
    $P2982 = root_new ['parrot';'ResizablePMCArray']
  vivify_2311:
    set $P141, $P2982[$I103]
    unless_null $P141, vivify_2312
    new $P141, "Undef"
  vivify_2312:
    new $P142, "Float"
    assign $P142, 0
    set $I104, $P142
    set $P2983, param_2960
    unless_null $P2983, vivify_2313
    $P2983 = root_new ['parrot';'Hash']
  vivify_2313:
    set $P2984, $P2983["name"]
    unless_null $P2984, vivify_2314
    $P2984 = root_new ['parrot';'Hash']
  vivify_2314:
    set $P2985, $P2984["identifier"]
    unless_null $P2985, vivify_2315
    $P2985 = root_new ['parrot';'ResizablePMCArray']
  vivify_2315:
    set $P143, $P2985[$I104]
    unless_null $P143, vivify_2316
    new $P143, "Undef"
  vivify_2316:
    set $P144, $P2962
    unless_null $P144, vivify_2317
    new $P144, "Undef"
  vivify_2317:
    $P137."install_lexical_symbol"($P141, $P143, $P144)
  if_2977_end:
.annotate 'line', 1759
    goto if_2966_end
  if_2966:
.annotate 'line', 1754
    find_dynamic_lex $P134, "$*W"
    unless_null $P134, vivify_2318
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$W"]
    unless_null $P134, vivify_2319
    die "Contextual $*W not found"
  vivify_2319:
  vivify_2318:
    find_dynamic_lex $P137, "$*OUTERPACKAGE"
    unless_null $P137, vivify_2320
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$OUTERPACKAGE"]
    unless_null $P137, vivify_2321
    die "Contextual $*OUTERPACKAGE not found"
  vivify_2321:
  vivify_2320:
    set $P2968, param_2960
    unless_null $P2968, vivify_2322
    $P2968 = root_new ['parrot';'Hash']
  vivify_2322:
    set $P2969, $P2968["name"]
    unless_null $P2969, vivify_2323
    $P2969 = root_new ['parrot';'Hash']
  vivify_2323:
    set $P138, $P2969["identifier"]
    unless_null $P138, vivify_2324
    new $P138, "Undef"
  vivify_2324:
    set $P139, $P2962
    unless_null $P139, vivify_2325
    new $P139, "Undef"
  vivify_2325:
    $P134."install_package_symbol"($P137, $P138, $P139)
.annotate 'line', 1755
    set $P2971, param_2960
    unless_null $P2971, vivify_2326
    $P2971 = root_new ['parrot';'Hash']
  vivify_2326:
    set $P2972, $P2971["name"]
    unless_null $P2972, vivify_2327
    $P2972 = root_new ['parrot';'Hash']
  vivify_2327:
    set $P132, $P2972["identifier"]
    unless_null $P132, vivify_2328
    new $P132, "Undef"
  vivify_2328:
    set $N100, $P132
    set $N101, 1
    iseq $I102, $N100, $N101
    unless $I102, if_2970_end
.annotate 'line', 1756
    find_dynamic_lex $P135, "$*W"
    unless_null $P135, vivify_2329
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$W"]
    unless_null $P135, vivify_2330
    die "Contextual $*W not found"
  vivify_2330:
  vivify_2329:
    new $P136, "Float"
    assign $P136, 0
    set $I103, $P136
    find_lex $P137, "$?PACKAGE"
    get_who $P138, $P137
    set $P2973, $P138["@BLOCK"]
    unless_null $P2973, vivify_2331
    $P2973 = root_new ['parrot';'ResizablePMCArray']
  vivify_2331:
    set $P139, $P2973[$I103]
    unless_null $P139, vivify_2332
    new $P139, "Undef"
  vivify_2332:
    new $P140, "Float"
    assign $P140, 0
    set $I104, $P140
    set $P2974, param_2960
    unless_null $P2974, vivify_2333
    $P2974 = root_new ['parrot';'Hash']
  vivify_2333:
    set $P2975, $P2974["name"]
    unless_null $P2975, vivify_2334
    $P2975 = root_new ['parrot';'Hash']
  vivify_2334:
    set $P2976, $P2975["identifier"]
    unless_null $P2976, vivify_2335
    $P2976 = root_new ['parrot';'ResizablePMCArray']
  vivify_2335:
    set $P141, $P2976[$I104]
    unless_null $P141, vivify_2336
    new $P141, "Undef"
  vivify_2336:
    set $P142, $P2962
    unless_null $P142, vivify_2337
    new $P142, "Undef"
  vivify_2337:
    $P135."install_lexical_symbol"($P139, $P141, $P142)
  if_2970_end:
  if_2966_end:
.annotate 'line', 1769
    set $P124, param_2960
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Stmts"]
    $P130 = $P129."new"()
    $P131 = $P124."!make"($P130)
.annotate 'line', 1746
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def" :anon :subid("531_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_2987
    .param pmc param_2988
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1772
    .const 'Sub' $P3037 = "535_1325892461.451" 
    capture_lex $P3037
    .const 'Sub' $P3030 = "534_1325892461.451" 
    capture_lex $P3030
    .const 'Sub' $P3010 = "532_1325892461.451" 
    capture_lex $P3010
    .lex "self", param_2987
    .lex "$/", param_2988
.annotate 'line', 1774
    $P2990 = root_new ['parrot';'ResizablePMCArray']
    set $P2989, $P2990
    .lex "@ns", $P2989
.annotate 'line', 1775
    new $P122, "Undef"
    set $P2991, $P122
    .lex "$name", $P2991
.annotate 'line', 1776
    new $P123, "Undef"
    set $P2992, $P123
    .lex "$how", $P2992
.annotate 'line', 1779
    new $P124, "Undef"
    set $P2993, $P124
    .lex "$past", $P2993
.annotate 'line', 1774
    set $P2994, param_2988
    unless_null $P2994, vivify_2338
    $P2994 = root_new ['parrot';'Hash']
  vivify_2338:
    set $P2995, $P2994["name"]
    unless_null $P2995, vivify_2339
    $P2995 = root_new ['parrot';'Hash']
  vivify_2339:
    set $P125, $P2995["identifier"]
    unless_null $P125, vivify_2340
    new $P125, "Undef"
  vivify_2340:
    clone $P127, $P125
    set $P2989, $P127
.annotate 'line', 1775
    set $P2996, $P2989
    unless_null $P2996, vivify_2341
    $P2996 = root_new ['parrot';'ResizablePMCArray']
  vivify_2341:
    $P125 = $P2996."pop"()
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    set $P2991, $P127
.annotate 'line', 1776
    find_dynamic_lex $P128, "$*PKGDECL"
    unless_null $P128, vivify_2342
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$PKGDECL"]
    unless_null $P128, vivify_2343
    die "Contextual $*PKGDECL not found"
  vivify_2343:
  vivify_2342:
    find_dynamic_lex $P131, "%*HOW"
    unless_null $P131, vivify_2344
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["%HOW"]
    unless_null $P131, vivify_2345
    die "Contextual %*HOW not found"
  vivify_2345:
  vivify_2344:
    set $P132, $P131[$P128]
    unless_null $P132, vivify_2346
    new $P132, "Undef"
  vivify_2346:
    set $P2992, $P132
.annotate 'line', 1779
    set $P2998, param_2988
    unless_null $P2998, vivify_2347
    $P2998 = root_new ['parrot';'Hash']
  vivify_2347:
    set $P127, $P2998["block"]
    unless_null $P127, vivify_2348
    new $P127, "Undef"
  vivify_2348:
    if $P127, if_2997
    set $P3000, param_2988
    unless_null $P3000, vivify_2349
    $P3000 = root_new ['parrot';'Hash']
  vivify_2349:
    set $P130, $P3000["comp_unit"]
    unless_null $P130, vivify_2350
    new $P130, "Undef"
  vivify_2350:
    $P131 = $P130."ast"()
    set $P125, $P131
    goto if_2997_end
  if_2997:
    set $P2999, param_2988
    unless_null $P2999, vivify_2351
    $P2999 = root_new ['parrot';'Hash']
  vivify_2351:
    set $P128, $P2999["block"]
    unless_null $P128, vivify_2352
    new $P128, "Undef"
  vivify_2352:
    $P129 = $P128."ast"()
    set $P125, $P129
  if_2997_end:
    set $P2993, $P125
.annotate 'line', 1780
    find_dynamic_lex $P129, "$*SCOPE"
    unless_null $P129, vivify_2353
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$SCOPE"]
    unless_null $P129, vivify_2354
    die "Contextual $*SCOPE not found"
  vivify_2354:
  vivify_2353:
    set $S100, $P129
    iseq $I100, $S100, "our"
    unless $I100, unless_3002
    new $P125, 'Integer'
    set $P125, $I100
    goto unless_3002_end
  unless_3002:
    find_dynamic_lex $P132, "$*SCOPE"
    unless_null $P132, vivify_2355
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SCOPE"]
    unless_null $P132, vivify_2356
    die "Contextual $*SCOPE not found"
  vivify_2356:
  vivify_2355:
    set $S101, $P132
    iseq $I101, $S101, ""
    new $P125, 'Integer'
    set $P125, $I101
  unless_3002_end:
    unless $P125, if_3001_end
.annotate 'line', 1781
    set $P133, $P2993
    unless_null $P133, vivify_2357
    new $P133, "Undef"
  vivify_2357:
    set $P3003, param_2988
    unless_null $P3003, vivify_2358
    $P3003 = root_new ['parrot';'Hash']
  vivify_2358:
    set $P3004, $P3003["name"]
    unless_null $P3004, vivify_2359
    $P3004 = root_new ['parrot';'Hash']
  vivify_2359:
    set $P134, $P3004["identifier"]
    unless_null $P134, vivify_2360
    new $P134, "Undef"
  vivify_2360:
    $P133."namespace"($P134)
  if_3001_end:
.annotate 'line', 1788
    set $P127, $P2992
    unless_null $P127, vivify_2361
    new $P127, "Undef"
  vivify_2361:
    can $I100, $P127, "parametric"
    if $I100, if_3006
    new $P125, 'Integer'
    set $P125, $I100
    goto if_3006_end
  if_3006:
    set $P128, $P2992
    unless_null $P128, vivify_2362
    new $P128, "Undef"
  vivify_2362:
    set $P129, $P2992
    unless_null $P129, vivify_2363
    new $P129, "Undef"
  vivify_2363:
    $P130 = $P128."parametric"($P129)
    set $P125, $P130
  if_3006_end:
    if $P125, if_3005
.annotate 'line', 1798
    set $P131, $P2993
    unless_null $P131, vivify_2364
    new $P131, "Undef"
  vivify_2364:
    $P131."blocktype"("immediate")
.annotate 'line', 1799
    find_dynamic_lex $P133, "$*W"
    unless_null $P133, vivify_2365
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$W"]
    unless_null $P133, vivify_2366
    die "Contextual $*W not found"
  vivify_2366:
  vivify_2365:
    set $P134, $P2993
    unless_null $P134, vivify_2367
    new $P134, "Undef"
  vivify_2367:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2368
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2369
    die "Contextual $*PACKAGE not found"
  vivify_2369:
  vivify_2368:
    $P133."install_lexical_symbol"($P134, "$?PACKAGE", $P137)
.annotate 'line', 1800
    find_dynamic_lex $P133, "$*W"
    unless_null $P133, vivify_2370
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$W"]
    unless_null $P133, vivify_2371
    die "Contextual $*W not found"
  vivify_2371:
  vivify_2370:
    set $P134, $P2993
    unless_null $P134, vivify_2372
    new $P134, "Undef"
  vivify_2372:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2373
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2374
    die "Contextual $*PACKAGE not found"
  vivify_2374:
  vivify_2373:
    $P133."install_lexical_symbol"($P134, "$?CLASS", $P137)
.annotate 'line', 1797
    goto if_3005_end
  if_3005:
.annotate 'line', 1789
    set $P131, $P2993
    unless_null $P131, vivify_2375
    new $P131, "Undef"
  vivify_2375:
    $P131."blocktype"("declaration")
.annotate 'line', 1790
    set $P131, $P2993
    unless_null $P131, vivify_2376
    new $P131, "Undef"
  vivify_2376:
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Var"]
    $P136 = $P135."new"("$?CLASS" :named("name"), "parameter" :named("scope"), 1 :named("directaccess"))
    $P131."unshift"($P136)
.annotate 'line', 1792
    set $P131, $P2993
    unless_null $P131, vivify_2377
    new $P131, "Undef"
  vivify_2377:
    $P131."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1793
    find_dynamic_lex $P133, "$*W"
    unless_null $P133, vivify_2378
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$W"]
    unless_null $P133, vivify_2379
    die "Contextual $*W not found"
  vivify_2379:
  vivify_2378:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2380
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2381
    die "Contextual $*PACKAGE not found"
  vivify_2381:
  vivify_2380:
    set $P137, $P2993
    unless_null $P137, vivify_2382
    new $P137, "Undef"
  vivify_2382:
    $P133."pkg_set_body_block"($P136, $P137)
.annotate 'line', 1794
    find_dynamic_lex $P133, "$*W"
    unless_null $P133, vivify_2383
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$W"]
    unless_null $P133, vivify_2384
    die "Contextual $*W not found"
  vivify_2384:
  vivify_2383:
    set $P134, $P2993
    unless_null $P134, vivify_2385
    new $P134, "Undef"
  vivify_2385:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2386
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2387
    die "Contextual $*PACKAGE not found"
  vivify_2387:
  vivify_2386:
    $P133."install_lexical_symbol"($P134, "$?PACKAGE", $P137)
.annotate 'line', 1795
    find_dynamic_lex $P133, "$*W"
    unless_null $P133, vivify_2388
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$W"]
    unless_null $P133, vivify_2389
    die "Contextual $*W not found"
  vivify_2389:
  vivify_2388:
    set $P134, $P2993
    unless_null $P134, vivify_2390
    new $P134, "Undef"
  vivify_2390:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2391
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2392
    die "Contextual $*PACKAGE not found"
  vivify_2392:
  vivify_2391:
    $P133."install_lexical_symbol"($P134, "$?ROLE", $P137)
  if_3005_end:
.annotate 'line', 1804
    set $P3008, param_2988
    unless_null $P3008, vivify_2393
    $P3008 = root_new ['parrot';'Hash']
  vivify_2393:
    set $P125, $P3008["parent"]
    unless_null $P125, vivify_2394
    new $P125, "Undef"
  vivify_2394:
    if $P125, if_3007
.annotate 'line', 1818
    set $P130, $P2992
    unless_null $P130, vivify_2395
    new $P130, "Undef"
  vivify_2395:
    can $I100, $P130, "set_default_parent"
    unless $I100, if_3028_end
    .const 'Sub' $P3030 = "534_1325892461.451" 
    capture_lex $P3030
    $P3030()
  if_3028_end:
    goto if_3007_end
  if_3007:
.annotate 'line', 1804
    .const 'Sub' $P3010 = "532_1325892461.451" 
    capture_lex $P3010
    $P3010()
  if_3007_end:
.annotate 'line', 1825
    set $P3034, param_2988
    unless_null $P3034, vivify_2421
    $P3034 = root_new ['parrot';'Hash']
  vivify_2421:
    set $P125, $P3034["role"]
    unless_null $P125, vivify_2422
    new $P125, "Undef"
  vivify_2422:
    unless $P125, if_3033_end
.annotate 'line', 1826
    set $P3035, param_2988
    unless_null $P3035, vivify_2423
    $P3035 = root_new ['parrot';'Hash']
  vivify_2423:
    set $P128, $P3035["role"]
    unless_null $P128, vivify_2424
    new $P128, "Undef"
  vivify_2424:
    defined $I100, $P128
    unless $I100, for_undef_2425
    iter $P127, $P128
    new $P133, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P133, loop3052_handler
    push_eh $P133
  loop3052_test:
    unless $P127, loop3052_done
    shift $P129, $P127
  loop3052_redo:
    .const 'Sub' $P3037 = "535_1325892461.451" 
    capture_lex $P3037
    $P3037($P129)
  loop3052_next:
    goto loop3052_test
  loop3052_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P134, exception, 'type'
    eq $P134, .CONTROL_LOOP_NEXT, loop3052_next
    eq $P134, .CONTROL_LOOP_REDO, loop3052_redo
  loop3052_done:
    pop_eh 
  for_undef_2425:
  if_3033_end:
.annotate 'line', 1843
    find_dynamic_lex $P128, "$*W"
    unless_null $P128, vivify_2439
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$W"]
    unless_null $P128, vivify_2440
    die "Contextual $*W not found"
  vivify_2440:
  vivify_2439:
    find_dynamic_lex $P131, "$*PACKAGE"
    unless_null $P131, vivify_2441
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$PACKAGE"]
    unless_null $P131, vivify_2442
    die "Contextual $*PACKAGE not found"
  vivify_2442:
  vivify_2441:
    $P128."pkg_compose"($P131)
.annotate 'line', 1845
    set $P125, param_2988
    set $P127, $P2993
    unless_null $P127, vivify_2443
    new $P127, "Undef"
  vivify_2443:
    $P128 = $P125."!make"($P127)
.annotate 'line', 1772
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3029"  :anon :subid("534_1325892461.451") :outer("531_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1819
    new $P131, "Undef"
    set $P3031, $P131
    .lex "$default", $P3031
    find_dynamic_lex $P135, "$*PKGDECL"
    unless_null $P135, vivify_2396
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PKGDECL"]
    unless_null $P135, vivify_2397
    die "Contextual $*PKGDECL not found"
  vivify_2397:
  vivify_2396:
    set $S100, $P135
    iseq $I101, $S100, "grammar"
    if $I101, if_3032
    new $P137, "ResizablePMCArray"
    push $P137, "NQPMu"
    set $P132, $P137
    goto if_3032_end
  if_3032:
    new $P136, "ResizablePMCArray"
    push $P136, "Regex"
    push $P136, "Cursor"
    set $P132, $P136
  if_3032_end:
    set $P3031, $P132
.annotate 'line', 1820
    find_dynamic_lex $P134, "$*W"
    unless_null $P134, vivify_2398
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$W"]
    unless_null $P134, vivify_2399
    die "Contextual $*W not found"
  vivify_2399:
  vivify_2398:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2400
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2401
    die "Contextual $*PACKAGE not found"
  vivify_2401:
  vivify_2400:
.annotate 'line', 1821
    set $P138, $P3031
    unless_null $P138, vivify_2402
    new $P138, "Undef"
  vivify_2402:
    find_lex $P139, "$/"
    unless_null $P139, vivify_2403
    new $P139, "Undef"
  vivify_2403:
    $P140 = "find_sym"($P138, $P139)
    $P141 = $P134."pkg_add_parent_or_role"($P137, "set_default_parent", $P140)
.annotate 'line', 1818
    .return ($P141)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3009"  :anon :subid("532_1325892461.451") :outer("531_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1804
    .const 'Sub' $P3014 = "533_1325892461.451" 
    capture_lex $P3014
.annotate 'line', 1805
    new $P127, "Undef"
    set $P3011, $P127
    .lex "$parent", $P3011
.annotate 'line', 1806
    new $P128, "Undef"
    set $P3012, $P128
    .lex "$parent_found", $P3012
.annotate 'line', 1804
    set $P129, $P3011
    unless_null $P129, vivify_2404
    new $P129, "Undef"
  vivify_2404:
    set $P129, $P3012
    unless_null $P129, vivify_2405
    new $P129, "Undef"
  vivify_2405:
.annotate 'line', 1807
    .const 'Sub' $P3014 = "533_1325892461.451" 
    capture_lex $P3014
    $P3014()
.annotate 'line', 1811
    set $P130, $P3012
    unless_null $P130, vivify_2411
    new $P130, "Undef"
  vivify_2411:
    if $P130, if_3025
.annotate 'line', 1815
    find_lex $P131, "$/"
    unless_null $P131, vivify_2412
    new $P131, "Undef"
  vivify_2412:
    $P132 = $P131."CURSOR"()
    new $P133, "String"
    assign $P133, "Could not find parent class '"
    new $P134, "Float"
    assign $P134, 0
    set $I100, $P134
    find_lex $P3026, "$/"
    unless_null $P3026, vivify_2413
    $P3026 = root_new ['parrot';'Hash']
  vivify_2413:
    set $P3027, $P3026["parent"]
    unless_null $P3027, vivify_2414
    $P3027 = root_new ['parrot';'ResizablePMCArray']
  vivify_2414:
    set $P135, $P3027[$I100]
    unless_null $P135, vivify_2415
    new $P135, "Undef"
  vivify_2415:
    set $S100, $P135
    concat $P136, $P133, $S100
    concat $P137, $P136, "'"
    $P139 = $P132."panic"($P137)
.annotate 'line', 1814
    set $P129, $P139
.annotate 'line', 1811
    goto if_3025_end
  if_3025:
.annotate 'line', 1812
    find_dynamic_lex $P133, "$*W"
    unless_null $P133, vivify_2416
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$W"]
    unless_null $P133, vivify_2417
    die "Contextual $*W not found"
  vivify_2417:
  vivify_2416:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2418
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2419
    die "Contextual $*PACKAGE not found"
  vivify_2419:
  vivify_2418:
    set $P137, $P3011
    unless_null $P137, vivify_2420
    new $P137, "Undef"
  vivify_2420:
    $P138 = $P133."pkg_add_parent_or_role"($P136, "add_parent", $P137)
.annotate 'line', 1811
    set $P129, $P138
  if_3025_end:
.annotate 'line', 1804
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3013"  :anon :subid("533_1325892461.451") :outer("532_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1807
    new $P3020, 'ExceptionHandler'
    set_label $P3020, control_3019
    $P3020."handle_types_except"(.CONTROL_ALL)
    push_eh $P3020
.annotate 'line', 1808
    new $P129, "Float"
    assign $P129, 0
    set $I100, $P129
    find_lex $P3015, "$/"
    unless_null $P3015, vivify_2406
    $P3015 = root_new ['parrot';'Hash']
  vivify_2406:
    set $P3016, $P3015["parent"]
    unless_null $P3016, vivify_2407
    $P3016 = root_new ['parrot';'ResizablePMCArray']
  vivify_2407:
    set $P3017, $P3016[$I100]
    unless_null $P3017, vivify_2408
    $P3017 = root_new ['parrot';'Hash']
  vivify_2408:
    set $P130, $P3017["identifier"]
    unless_null $P130, vivify_2409
    new $P130, "Undef"
  vivify_2409:
    clone $P131, $P130
    find_lex $P132, "$/"
    unless_null $P132, vivify_2410
    new $P132, "Undef"
  vivify_2410:
    $P133 = "find_sym"($P131, $P132)
    store_lex "$parent", $P133
.annotate 'line', 1809
    new $P129, "Float"
    assign $P129, 1
    store_lex "$parent_found", $P129
.annotate 'line', 1807
    pop_eh 
    goto skip_handler_3018
  control_3019:
    peek_exception $P3021
    .local pmc exception 
    .get_results (exception) 
    new $P3023, 'Integer'
    set $P3023, 1
    set exception["handled"], $P3023
    set $I3024, exception["handled"]
    eq $I3024, 1, handled_3022
    rethrow exception
  handled_3022:
    finalize $P3021
    .return (exception)
  skip_handler_3018:
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3036"  :anon :subid("535_1325892461.451") :outer("531_1325892461.451")
    .param pmc param_3040
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1826
    .const 'Sub' $P3042 = "536_1325892461.451" 
    capture_lex $P3042
.annotate 'line', 1827
    new $P130, "Undef"
    set $P3038, $P130
    .lex "$role", $P3038
.annotate 'line', 1828
    new $P131, "Undef"
    set $P3039, $P131
    .lex "$role_found", $P3039
    .lex "$_", param_3040
.annotate 'line', 1826
    set $P132, $P3038
    unless_null $P132, vivify_2426
    new $P132, "Undef"
  vivify_2426:
    set $P132, $P3039
    unless_null $P132, vivify_2427
    new $P132, "Undef"
  vivify_2427:
.annotate 'line', 1829
    .const 'Sub' $P3042 = "536_1325892461.451" 
    capture_lex $P3042
    $P3042()
.annotate 'line', 1833
    set $P133, $P3039
    unless_null $P133, vivify_2431
    new $P133, "Undef"
  vivify_2431:
    if $P133, if_3051
.annotate 'line', 1837
    find_lex $P134, "$/"
    unless_null $P134, vivify_2432
    new $P134, "Undef"
  vivify_2432:
    $P135 = $P134."CURSOR"()
    new $P136, "String"
    assign $P136, "Could not find role '"
    find_lex $P137, "$_"
    unless_null $P137, vivify_2433
    new $P137, "Undef"
  vivify_2433:
    set $S100, $P137
    concat $P138, $P136, $S100
    concat $P139, $P138, "'"
    $P140 = $P135."panic"($P139)
.annotate 'line', 1836
    set $P132, $P140
.annotate 'line', 1833
    goto if_3051_end
  if_3051:
.annotate 'line', 1834
    find_dynamic_lex $P136, "$*W"
    unless_null $P136, vivify_2434
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$W"]
    unless_null $P136, vivify_2435
    die "Contextual $*W not found"
  vivify_2435:
  vivify_2434:
    find_dynamic_lex $P139, "$*PACKAGE"
    unless_null $P139, vivify_2436
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$PACKAGE"]
    unless_null $P139, vivify_2437
    die "Contextual $*PACKAGE not found"
  vivify_2437:
  vivify_2436:
    set $P140, $P3038
    unless_null $P140, vivify_2438
    new $P140, "Undef"
  vivify_2438:
    $P141 = $P136."pkg_add_parent_or_role"($P139, "add_role", $P140)
.annotate 'line', 1833
    set $P132, $P141
  if_3051_end:
.annotate 'line', 1826
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3041"  :anon :subid("536_1325892461.451") :outer("535_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1829
    new $P3046, 'ExceptionHandler'
    set_label $P3046, control_3045
    $P3046."handle_types_except"(.CONTROL_ALL)
    push_eh $P3046
.annotate 'line', 1830
    find_lex $P3043, "$_"
    unless_null $P3043, vivify_2428
    $P3043 = root_new ['parrot';'Hash']
  vivify_2428:
    set $P132, $P3043["identifier"]
    unless_null $P132, vivify_2429
    new $P132, "Undef"
  vivify_2429:
    clone $P133, $P132
    find_lex $P134, "$/"
    unless_null $P134, vivify_2430
    new $P134, "Undef"
  vivify_2430:
    $P135 = "find_sym"($P133, $P134)
    store_lex "$role", $P135
.annotate 'line', 1831
    new $P132, "Float"
    assign $P132, 1
    store_lex "$role_found", $P132
.annotate 'line', 1829
    pop_eh 
    goto skip_handler_3044
  control_3045:
    peek_exception $P3047
    .local pmc exception 
    .get_results (exception) 
    new $P3049, 'Integer'
    set $P3049, 1
    set exception["handled"], $P3049
    set $I3050, exception["handled"]
    eq $I3050, 1, handled_3048
    rethrow exception
  handled_3048:
    finalize $P3047
    .return (exception)
  skip_handler_3044:
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>" :anon :subid("537_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3054
    .param pmc param_3055
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1848
    .lex "self", param_3054
    .lex "$/", param_3055
    set $P122, param_3055
    set $P3056, param_3055
    unless_null $P3056, vivify_2444
    $P3056 = root_new ['parrot';'Hash']
  vivify_2444:
    set $P123, $P3056["scoped"]
    unless_null $P123, vivify_2445
    new $P123, "Undef"
  vivify_2445:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>" :anon :subid("538_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3058
    .param pmc param_3059
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1849
    .lex "self", param_3058
    .lex "$/", param_3059
    set $P122, param_3059
    set $P3060, param_3059
    unless_null $P3060, vivify_2446
    $P3060 = root_new ['parrot';'Hash']
  vivify_2446:
    set $P123, $P3060["scoped"]
    unless_null $P123, vivify_2447
    new $P123, "Undef"
  vivify_2447:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>" :anon :subid("539_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3062
    .param pmc param_3063
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1850
    .lex "self", param_3062
    .lex "$/", param_3063
    set $P122, param_3063
    set $P3064, param_3063
    unless_null $P3064, vivify_2448
    $P3064 = root_new ['parrot';'Hash']
  vivify_2448:
    set $P123, $P3064["scoped"]
    unless_null $P123, vivify_2449
    new $P123, "Undef"
  vivify_2449:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped" :anon :subid("540_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3066
    .param pmc param_3067
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1852
    .lex "self", param_3066
    .lex "$/", param_3067
.annotate 'line', 1853
    set $P122, param_3067
    set $P3069, param_3067
    unless_null $P3069, vivify_2450
    $P3069 = root_new ['parrot';'Hash']
  vivify_2450:
    set $P124, $P3069["declarator"]
    unless_null $P124, vivify_2451
    new $P124, "Undef"
  vivify_2451:
    if $P124, if_3068
.annotate 'line', 1854
    set $P3072, param_3067
    unless_null $P3072, vivify_2452
    $P3072 = root_new ['parrot';'Hash']
  vivify_2452:
    set $P129, $P3072["multi_declarator"]
    unless_null $P129, vivify_2453
    new $P129, "Undef"
  vivify_2453:
    if $P129, if_3071
.annotate 'line', 1855
    set $P3074, param_3067
    unless_null $P3074, vivify_2454
    $P3074 = root_new ['parrot';'Hash']
  vivify_2454:
    set $P132, $P3074["package_declarator"]
    unless_null $P132, vivify_2455
    new $P132, "Undef"
  vivify_2455:
    $P133 = $P132."ast"()
    set $P128, $P133
.annotate 'line', 1854
    goto if_3071_end
  if_3071:
    set $P3073, param_3067
    unless_null $P3073, vivify_2456
    $P3073 = root_new ['parrot';'Hash']
  vivify_2456:
    set $P130, $P3073["multi_declarator"]
    unless_null $P130, vivify_2457
    new $P130, "Undef"
  vivify_2457:
    $P131 = $P130."ast"()
    set $P128, $P131
  if_3071_end:
    set $P123, $P128
.annotate 'line', 1853
    goto if_3068_end
  if_3068:
    set $P3070, param_3067
    unless_null $P3070, vivify_2458
    $P3070 = root_new ['parrot';'Hash']
  vivify_2458:
    set $P125, $P3070["declarator"]
    unless_null $P125, vivify_2459
    new $P125, "Undef"
  vivify_2459:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3068_end:
    $P134 = $P122."!make"($P123)
.annotate 'line', 1852
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator" :anon :subid("541_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3076
    .param pmc param_3077
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1858
    .lex "self", param_3076
    .lex "$/", param_3077
.annotate 'line', 1859
    set $P122, param_3077
.annotate 'line', 1860
    set $P3079, param_3077
    unless_null $P3079, vivify_2460
    $P3079 = root_new ['parrot';'Hash']
  vivify_2460:
    set $P124, $P3079["routine_declarator"]
    unless_null $P124, vivify_2461
    new $P124, "Undef"
  vivify_2461:
    if $P124, if_3078
.annotate 'line', 1861
    set $P3081, param_3077
    unless_null $P3081, vivify_2462
    $P3081 = root_new ['parrot';'Hash']
  vivify_2462:
    set $P128, $P3081["variable_declarator"]
    unless_null $P128, vivify_2463
    new $P128, "Undef"
  vivify_2463:
    $P129 = $P128."ast"()
    set $P123, $P129
.annotate 'line', 1860
    goto if_3078_end
  if_3078:
    set $P3080, param_3077
    unless_null $P3080, vivify_2464
    $P3080 = root_new ['parrot';'Hash']
  vivify_2464:
    set $P125, $P3080["routine_declarator"]
    unless_null $P125, vivify_2465
    new $P125, "Undef"
  vivify_2465:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3078_end:
    $P130 = $P122."!make"($P123)
.annotate 'line', 1858
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>" :anon :subid("542_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3083
    .param pmc param_3084
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1864
    .lex "self", param_3083
    .lex "$/", param_3084
    set $P122, param_3084
    set $P3086, param_3084
    unless_null $P3086, vivify_2466
    $P3086 = root_new ['parrot';'Hash']
  vivify_2466:
    set $P124, $P3086["declarator"]
    unless_null $P124, vivify_2467
    new $P124, "Undef"
  vivify_2467:
    if $P124, if_3085
    set $P3088, param_3084
    unless_null $P3088, vivify_2468
    $P3088 = root_new ['parrot';'Hash']
  vivify_2468:
    set $P128, $P3088["routine_def"]
    unless_null $P128, vivify_2469
    new $P128, "Undef"
  vivify_2469:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3085_end
  if_3085:
    set $P3087, param_3084
    unless_null $P3087, vivify_2470
    $P3087 = root_new ['parrot';'Hash']
  vivify_2470:
    set $P125, $P3087["declarator"]
    unless_null $P125, vivify_2471
    new $P125, "Undef"
  vivify_2471:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3085_end:
    $P130 = $P122."!make"($P123)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>" :anon :subid("543_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3090
    .param pmc param_3091
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1865
    .lex "self", param_3090
    .lex "$/", param_3091
    set $P122, param_3091
    set $P3093, param_3091
    unless_null $P3093, vivify_2472
    $P3093 = root_new ['parrot';'Hash']
  vivify_2472:
    set $P124, $P3093["declarator"]
    unless_null $P124, vivify_2473
    new $P124, "Undef"
  vivify_2473:
    if $P124, if_3092
    set $P3095, param_3091
    unless_null $P3095, vivify_2474
    $P3095 = root_new ['parrot';'Hash']
  vivify_2474:
    set $P128, $P3095["routine_def"]
    unless_null $P128, vivify_2475
    new $P128, "Undef"
  vivify_2475:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3092_end
  if_3092:
    set $P3094, param_3091
    unless_null $P3094, vivify_2476
    $P3094 = root_new ['parrot';'Hash']
  vivify_2476:
    set $P125, $P3094["declarator"]
    unless_null $P125, vivify_2477
    new $P125, "Undef"
  vivify_2477:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3092_end:
    $P130 = $P122."!make"($P123)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>" :anon :subid("544_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3097
    .param pmc param_3098
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1866
    .lex "self", param_3097
    .lex "$/", param_3098
    set $P122, param_3098
    set $P3099, param_3098
    unless_null $P3099, vivify_2478
    $P3099 = root_new ['parrot';'Hash']
  vivify_2478:
    set $P123, $P3099["declarator"]
    unless_null $P123, vivify_2479
    new $P123, "Undef"
  vivify_2479:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "variable_declarator" :anon :subid("545_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3101
    .param pmc param_3102
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1869
    .const 'Sub' $P3138 = "547_1325892461.451" 
    capture_lex $P3138
    .const 'Sub' $P3115 = "546_1325892461.451" 
    capture_lex $P3115
    .lex "self", param_3101
    .lex "$/", param_3102
.annotate 'line', 1870
    new $P122, "Undef"
    set $P3103, $P122
    .lex "$past", $P3103
.annotate 'line', 1871
    new $P123, "Undef"
    set $P3104, $P123
    .lex "$sigil", $P3104
.annotate 'line', 1872
    new $P124, "Undef"
    set $P3105, $P124
    .lex "$name", $P3105
.annotate 'line', 1873
    new $P125, "Undef"
    set $P3106, $P125
    .lex "$BLOCK", $P3106
.annotate 'line', 1870
    set $P3107, param_3102
    unless_null $P3107, vivify_2480
    $P3107 = root_new ['parrot';'Hash']
  vivify_2480:
    set $P127, $P3107["variable"]
    unless_null $P127, vivify_2481
    new $P127, "Undef"
  vivify_2481:
    $P128 = $P127."ast"()
    set $P3103, $P128
.annotate 'line', 1871
    set $P3108, param_3102
    unless_null $P3108, vivify_2482
    $P3108 = root_new ['parrot';'Hash']
  vivify_2482:
    set $P3109, $P3108["variable"]
    unless_null $P3109, vivify_2483
    $P3109 = root_new ['parrot';'Hash']
  vivify_2483:
    set $P127, $P3109["sigil"]
    unless_null $P127, vivify_2484
    new $P127, "Undef"
  vivify_2484:
    set $P3104, $P127
.annotate 'line', 1872
    set $P127, $P3103
    unless_null $P127, vivify_2485
    new $P127, "Undef"
  vivify_2485:
    $P128 = $P127."name"()
    set $P3105, $P128
.annotate 'line', 1873
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3110, $P129["@BLOCK"]
    unless_null $P3110, vivify_2486
    $P3110 = root_new ['parrot';'ResizablePMCArray']
  vivify_2486:
    set $P130, $P3110[$I100]
    unless_null $P130, vivify_2487
    new $P130, "Undef"
  vivify_2487:
    set $P3106, $P130
.annotate 'line', 1874
    set $P128, $P3105
    unless_null $P128, vivify_2488
    new $P128, "Undef"
  vivify_2488:
    if $P128, if_3112
    set $P127, $P128
    goto if_3112_end
  if_3112:
    set $P129, $P3106
    unless_null $P129, vivify_2489
    new $P129, "Undef"
  vivify_2489:
    set $P130, $P3105
    unless_null $P130, vivify_2490
    new $P130, "Undef"
  vivify_2490:
    $P131 = $P129."symbol"($P130)
    set $P127, $P131
  if_3112_end:
    unless $P127, if_3111_end
.annotate 'line', 1875
    set $P132, param_3102
    unless_null $P132, vivify_2491
    new $P132, "Undef"
  vivify_2491:
    $P133 = $P132."CURSOR"()
    set $P134, $P3105
    unless_null $P134, vivify_2492
    new $P134, "Undef"
  vivify_2492:
    $P133."panic"("Redeclaration of symbol ", $P134)
  if_3111_end:
.annotate 'line', 1877
    find_dynamic_lex $P129, "$*SCOPE"
    unless_null $P129, vivify_2493
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["$SCOPE"]
    unless_null $P129, vivify_2494
    die "Contextual $*SCOPE not found"
  vivify_2494:
  vivify_2493:
    set $S100, $P129
    iseq $I100, $S100, "has"
    if $I100, if_3113
.annotate 'line', 1897
    find_dynamic_lex $P132, "$*SCOPE"
    unless_null $P132, vivify_2495
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$SCOPE"]
    unless_null $P132, vivify_2496
    die "Contextual $*SCOPE not found"
  vivify_2496:
  vivify_2495:
    set $S101, $P132
    iseq $I101, $S101, "our"
    if $I101, if_3131
.annotate 'line', 1907
    new $P133, "Float"
    assign $P133, 0
    set $I102, $P133
    set $P3133, $P3106
    unless_null $P3133, vivify_2497
    $P3133 = root_new ['parrot';'ResizablePMCArray']
  vivify_2497:
    set $P135, $P3133[$I102]
    unless_null $P135, vivify_2498
    new $P135, "Undef"
  vivify_2498:
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Var"]
    set $P140, $P3105
    unless_null $P140, vivify_2499
    new $P140, "Undef"
  vivify_2499:
.annotate 'line', 1909
    set $P141, $P3104
    unless_null $P141, vivify_2500
    new $P141, "Undef"
  vivify_2500:
    $P142 = "vivitype"($P141)
.annotate 'line', 1907
    set $P143, param_3102
    unless_null $P143, vivify_2501
    new $P143, "Undef"
  vivify_2501:
    $P144 = $P139."new"($P140 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("directaccess"), 1 :named("lvalue"), $P142 :named("viviself"), $P143 :named("node"))
    $P135."push"($P144)
.annotate 'line', 1912
    set $P133, $P3106
    unless_null $P133, vivify_2502
    new $P133, "Undef"
  vivify_2502:
    set $P135, $P3105
    unless_null $P135, vivify_2503
    new $P135, "Undef"
  vivify_2503:
    $P133."symbol"($P135, "lexical" :named("scope"))
.annotate 'line', 1906
    goto if_3131_end
  if_3131:
.annotate 'line', 1901
    set $P3132, param_3102
    unless_null $P3132, vivify_2504
    $P3132 = root_new ['parrot';'Hash']
  vivify_2504:
    set $P133, $P3132["variable"]
    unless_null $P133, vivify_2505
    new $P133, "Undef"
  vivify_2505:
    set $S102, $P133
    new $P135, 'String'
    set $P135, $S102
    set $P3105, $P135
.annotate 'line', 1902
    set $P133, $P3105
    unless_null $P133, vivify_2506
    new $P133, "Undef"
  vivify_2506:
    new $P135, "ResizablePMCArray"
    push $P135, $P133
    set $P136, param_3102
    unless_null $P136, vivify_2507
    new $P136, "Undef"
  vivify_2507:
    $P137 = "lexical_package_lookup"($P135, $P136)
    set $P3103, $P137
.annotate 'line', 1903
    set $P133, $P3103
    unless_null $P133, vivify_2508
    new $P133, "Undef"
  vivify_2508:
    set $P135, $P3104
    unless_null $P135, vivify_2509
    new $P135, "Undef"
  vivify_2509:
    $P136 = "vivitype"($P135)
    $P133."viviself"($P136)
.annotate 'line', 1904
    set $P133, $P3106
    unless_null $P133, vivify_2510
    new $P133, "Undef"
  vivify_2510:
    set $P135, $P3105
    unless_null $P135, vivify_2511
    new $P135, "Undef"
  vivify_2511:
    $P133."symbol"($P135, "package" :named("scope"))
  if_3131_end:
.annotate 'line', 1897
    goto if_3113_end
  if_3113:
.annotate 'line', 1877
    .const 'Sub' $P3115 = "546_1325892461.451" 
    capture_lex $P3115
    $P3115()
  if_3113_end:
.annotate 'line', 1916
    set $P127, param_3102
    set $P128, $P3103
    unless_null $P128, vivify_2541
    new $P128, "Undef"
  vivify_2541:
    $P127."!make"($P128)
.annotate 'line', 1918
    set $P3135, param_3102
    unless_null $P3135, vivify_2542
    $P3135 = root_new ['parrot';'Hash']
  vivify_2542:
    set $P128, $P3135["trait"]
    unless_null $P128, vivify_2543
    new $P128, "Undef"
  vivify_2543:
    if $P128, if_3134
    set $P127, $P128
    goto if_3134_end
  if_3134:
.annotate 'line', 1919
    set $P3136, param_3102
    unless_null $P3136, vivify_2544
    $P3136 = root_new ['parrot';'Hash']
  vivify_2544:
    set $P130, $P3136["trait"]
    unless_null $P130, vivify_2545
    new $P130, "Undef"
  vivify_2545:
    defined $I100, $P130
    unless $I100, for_undef_2546
    iter $P129, $P130
    new $P132, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P132, loop3140_handler
    push_eh $P132
  loop3140_test:
    unless $P129, loop3140_done
    shift $P131, $P129
  loop3140_redo:
    .const 'Sub' $P3138 = "547_1325892461.451" 
    capture_lex $P3138
    $P3138($P131)
  loop3140_next:
    goto loop3140_test
  loop3140_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P133, exception, 'type'
    eq $P133, .CONTROL_LOOP_NEXT, loop3140_next
    eq $P133, .CONTROL_LOOP_REDO, loop3140_redo
  loop3140_done:
    pop_eh 
  for_undef_2546:
.annotate 'line', 1918
    set $P127, $P129
  if_3134_end:
.annotate 'line', 1869
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3114"  :anon :subid("546_1325892461.451") :outer("545_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1884
    $P3117 = root_new ['parrot';'Hash']
    set $P3116, $P3117
    .lex "%lit_args", $P3116
.annotate 'line', 1885
    $P3119 = root_new ['parrot';'Hash']
    set $P3118, $P3119
    .lex "%obj_args", $P3118
.annotate 'line', 1879
    find_dynamic_lex $P135, "$*PKGDECL"
    unless_null $P135, vivify_2512
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PKGDECL"]
    unless_null $P135, vivify_2513
    die "Contextual $*PKGDECL not found"
  vivify_2513:
  vivify_2512:
    concat $P136, $P135, "-attr"
    find_dynamic_lex $P132, "%*HOW"
    unless_null $P132, vivify_2514
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["%HOW"]
    unless_null $P132, vivify_2515
    die "Contextual %*HOW not found"
  vivify_2515:
  vivify_2514:
    exists $I101, $P132[$P136]
    if $I101, unless_3120_end
.annotate 'line', 1880
    find_lex $P137, "$/"
    unless_null $P137, vivify_2516
    new $P137, "Undef"
  vivify_2516:
    $P138 = $P137."CURSOR"()
    find_dynamic_lex $P141, "$*PKGDECL"
    unless_null $P141, vivify_2517
    get_hll_global $P139, "GLOBAL"
    get_who $P140, $P139
    set $P141, $P140["$PKGDECL"]
    unless_null $P141, vivify_2518
    die "Contextual $*PKGDECL not found"
  vivify_2518:
  vivify_2517:
    concat $P142, $P141, " packages do not support attributes"
    $P138."panic"($P142)
  unless_3120_end:
.annotate 'line', 1877
    set $P3121, $P3116
    unless_null $P3121, vivify_2519
    $P3121 = root_new ['parrot';'Hash']
  vivify_2519:
    set $P3122, $P3118
    unless_null $P3122, vivify_2520
    $P3122 = root_new ['parrot';'Hash']
  vivify_2520:
.annotate 'line', 1886
    find_lex $P130, "$name"
    unless_null $P130, vivify_2521
    new $P130, "Undef"
  vivify_2521:
    set $P3123, $P3116
    unless_null $P3123, vivify_2522
    $P3123 = root_new ['parrot';'Hash']
    set $P3116, $P3123
  vivify_2522:
    set $P3123["name"], $P130
.annotate 'line', 1887
    find_lex $P3125, "$/"
    unless_null $P3125, vivify_2523
    $P3125 = root_new ['parrot';'Hash']
  vivify_2523:
    set $P130, $P3125["typename"]
    unless_null $P130, vivify_2524
    new $P130, "Undef"
  vivify_2524:
    unless $P130, if_3124_end
.annotate 'line', 1888
    new $P131, "Float"
    assign $P131, 0
    set $I101, $P131
    find_lex $P3126, "$/"
    unless_null $P3126, vivify_2525
    $P3126 = root_new ['parrot';'Hash']
  vivify_2525:
    set $P3127, $P3126["typename"]
    unless_null $P3127, vivify_2526
    $P3127 = root_new ['parrot';'ResizablePMCArray']
  vivify_2526:
    set $P132, $P3127[$I101]
    unless_null $P132, vivify_2527
    new $P132, "Undef"
  vivify_2527:
    set $S101, $P132
    new $P133, "ResizablePMCArray"
    push $P133, $S101
    find_lex $P134, "$/"
    unless_null $P134, vivify_2528
    new $P134, "Undef"
  vivify_2528:
    $P135 = "find_sym"($P133, $P134)
    set $P3128, $P3118
    unless_null $P3128, vivify_2529
    $P3128 = root_new ['parrot';'Hash']
    set $P3118, $P3128
  vivify_2529:
    set $P3128["type"], $P135
  if_3124_end:
.annotate 'line', 1892
    find_dynamic_lex $P132, "$*W"
    unless_null $P132, vivify_2530
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$W"]
    unless_null $P132, vivify_2531
    die "Contextual $*W not found"
  vivify_2531:
  vivify_2530:
    find_dynamic_lex $P135, "$*PACKAGE"
    unless_null $P135, vivify_2532
    get_hll_global $P133, "GLOBAL"
    get_who $P134, $P133
    set $P135, $P134["$PACKAGE"]
    unless_null $P135, vivify_2533
    die "Contextual $*PACKAGE not found"
  vivify_2533:
  vivify_2532:
    find_dynamic_lex $P138, "$*PKGDECL"
    unless_null $P138, vivify_2534
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$PKGDECL"]
    unless_null $P138, vivify_2535
    die "Contextual $*PKGDECL not found"
  vivify_2535:
  vivify_2534:
    concat $P139, $P138, "-attr"
    find_dynamic_lex $P142, "%*HOW"
    unless_null $P142, vivify_2536
    get_hll_global $P140, "GLOBAL"
    get_who $P141, $P140
    set $P142, $P141["%HOW"]
    unless_null $P142, vivify_2537
    die "Contextual %*HOW not found"
  vivify_2537:
  vivify_2536:
    set $P143, $P142[$P139]
    unless_null $P143, vivify_2538
    new $P143, "Undef"
  vivify_2538:
    set $P3129, $P3116
    unless_null $P3129, vivify_2539
    $P3129 = root_new ['parrot';'Hash']
  vivify_2539:
    set $P3130, $P3118
    unless_null $P3130, vivify_2540
    $P3130 = root_new ['parrot';'Hash']
  vivify_2540:
    $P132."pkg_add_attribute"($P135, $P143, $P3129, $P3130)
.annotate 'line', 1895
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Stmts"]
    $P134 = $P133."new"()
    store_lex "$past", $P134
.annotate 'line', 1877
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3137"  :anon :subid("547_1325892461.451") :outer("545_1325892461.451")
    .param pmc param_3139
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1919
    .lex "$_", param_3139
    find_lex $P132, "$_"
    unless_null $P132, vivify_2547
    new $P132, "Undef"
  vivify_2547:
    $P133 = $P132."ast"()
    find_lex $P134, "$/"
    unless_null $P134, vivify_2548
    new $P134, "Undef"
  vivify_2548:
    $P135 = $P133($P134)
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>" :anon :subid("548_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3142
    .param pmc param_3143
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1924
    .lex "self", param_3142
    .lex "$/", param_3143
    set $P122, param_3143
    set $P3144, param_3143
    unless_null $P3144, vivify_2549
    $P3144 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P123, $P3144["routine_def"]
    unless_null $P123, vivify_2550
    new $P123, "Undef"
  vivify_2550:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>" :anon :subid("549_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3146
    .param pmc param_3147
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1925
    .lex "self", param_3146
    .lex "$/", param_3147
    set $P122, param_3147
    set $P3148, param_3147
    unless_null $P3148, vivify_2551
    $P3148 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P123, $P3148["method_def"]
    unless_null $P123, vivify_2552
    new $P123, "Undef"
  vivify_2552:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def" :anon :subid("550_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3150
    .param pmc param_3151
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1927
    .const 'Sub' $P3227 = "556_1325892461.451" 
    capture_lex $P3227
    .const 'Sub' $P3161 = "551_1325892461.451" 
    capture_lex $P3161
    .lex "self", param_3150
    .lex "$/", param_3151
.annotate 'line', 1930
    new $P122, "Undef"
    set $P3152, $P122
    .lex "$past", $P3152
.annotate 'line', 1941
    new $P123, "Undef"
    set $P3153, $P123
    .lex "$block", $P3153
.annotate 'line', 1927
    set $P124, $P3152
    unless_null $P124, vivify_2553
    new $P124, "Undef"
  vivify_2553:
.annotate 'line', 1931
    set $P3155, param_3151
    unless_null $P3155, vivify_2554
    $P3155 = root_new ['parrot';'Hash']
  vivify_2554:
    set $P124, $P3155["onlystar"]
    unless_null $P124, vivify_2555
    new $P124, "Undef"
  vivify_2555:
    if $P124, if_3154
.annotate 'line', 1935
    set $P3156, param_3151
    unless_null $P3156, vivify_2556
    $P3156 = root_new ['parrot';'Hash']
  vivify_2556:
    set $P125, $P3156["blockoid"]
    unless_null $P125, vivify_2557
    new $P125, "Undef"
  vivify_2557:
    $P127 = $P125."ast"()
    set $P3152, $P127
.annotate 'line', 1936
    set $P125, $P3152
    unless_null $P125, vivify_2558
    new $P125, "Undef"
  vivify_2558:
    $P125."blocktype"("declaration")
.annotate 'line', 1937
    find_dynamic_lex $P128, "$*RETURN_USED"
    unless_null $P128, vivify_2559
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$RETURN_USED"]
    unless_null $P128, vivify_2560
    die "Contextual $*RETURN_USED not found"
  vivify_2560:
  vivify_2559:
    unless $P128, if_3157_end
.annotate 'line', 1938
    set $P129, $P3152
    unless_null $P129, vivify_2561
    new $P129, "Undef"
  vivify_2561:
    $P129."control"("return_pir")
  if_3157_end:
.annotate 'line', 1934
    goto if_3154_end
  if_3154:
.annotate 'line', 1932
    $P125 = "only_star_block"()
    set $P3152, $P125
  if_3154_end:
.annotate 'line', 1941
    set $P124, $P3152
    unless_null $P124, vivify_2562
    new $P124, "Undef"
  vivify_2562:
    set $P3153, $P124
.annotate 'line', 1943
    set $P3159, param_3151
    unless_null $P3159, vivify_2563
    $P3159 = root_new ['parrot';'Hash']
  vivify_2563:
    set $P124, $P3159["deflongname"]
    unless_null $P124, vivify_2564
    new $P124, "Undef"
  vivify_2564:
    unless $P124, if_3158_end
    .const 'Sub' $P3161 = "551_1325892461.451" 
    capture_lex $P3161
    $P3161()
  if_3158_end:
.annotate 'line', 2044
    set $P124, $P3153
    unless_null $P124, vivify_2670
    new $P124, "Undef"
  vivify_2670:
    set $P3222, $P3152
    unless_null $P3222, vivify_2671
    $P3222 = root_new ['parrot';'Hash']
    set $P3152, $P3222
  vivify_2671:
    set $P3222["block_past"], $P124
.annotate 'line', 2045
    set $P3224, param_3151
    unless_null $P3224, vivify_2672
    $P3224 = root_new ['parrot';'Hash']
  vivify_2672:
    set $P124, $P3224["trait"]
    unless_null $P124, vivify_2673
    new $P124, "Undef"
  vivify_2673:
    unless $P124, if_3223_end
.annotate 'line', 2046
    set $P3225, param_3151
    unless_null $P3225, vivify_2674
    $P3225 = root_new ['parrot';'Hash']
  vivify_2674:
    set $P127, $P3225["trait"]
    unless_null $P127, vivify_2675
    new $P127, "Undef"
  vivify_2675:
    defined $I100, $P127
    unless $I100, for_undef_2676
    iter $P125, $P127
    new $P129, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P129, loop3229_handler
    push_eh $P129
  loop3229_test:
    unless $P125, loop3229_done
    shift $P128, $P125
  loop3229_redo:
    .const 'Sub' $P3227 = "556_1325892461.451" 
    capture_lex $P3227
    $P3227($P128)
  loop3229_next:
    goto loop3229_test
  loop3229_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop3229_next
    eq $P130, .CONTROL_LOOP_REDO, loop3229_redo
  loop3229_done:
    pop_eh 
  for_undef_2676:
  if_3223_end:
.annotate 'line', 2049
    set $P124, param_3151
    set $P125, $P3152
    unless_null $P125, vivify_2679
    new $P125, "Undef"
  vivify_2679:
    $P127 = $P124."!make"($P125)
.annotate 'line', 1927
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3160"  :anon :subid("551_1325892461.451") :outer("550_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1943
    .const 'Sub' $P3206 = "555_1325892461.451" 
    capture_lex $P3206
    .const 'Sub' $P3172 = "552_1325892461.451" 
    capture_lex $P3172
.annotate 'line', 1944
    new $P125, "Undef"
    set $P3162, $P125
    .lex "$name", $P3162
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P3163, "$/"
    unless_null $P3163, vivify_2565
    $P3163 = root_new ['parrot';'Hash']
  vivify_2565:
    set $P3164, $P3163["sigil"]
    unless_null $P3164, vivify_2566
    $P3164 = root_new ['parrot';'ResizablePMCArray']
  vivify_2566:
    set $P128, $P3164[$I100]
    unless_null $P128, vivify_2567
    new $P128, "Undef"
  vivify_2567:
    set $S100, $P128
    new $P129, 'String'
    set $P129, $S100
    new $P130, "Float"
    assign $P130, 0
    set $I101, $P130
    find_lex $P3165, "$/"
    unless_null $P3165, vivify_2568
    $P3165 = root_new ['parrot';'Hash']
  vivify_2568:
    set $P3166, $P3165["deflongname"]
    unless_null $P3166, vivify_2569
    $P3166 = root_new ['parrot';'ResizablePMCArray']
  vivify_2569:
    set $P131, $P3166[$I101]
    unless_null $P131, vivify_2570
    new $P131, "Undef"
  vivify_2570:
    $S101 = $P131."ast"()
    concat $P132, $P129, $S101
    set $P3162, $P132
.annotate 'line', 1945
    find_lex $P127, "$past"
    unless_null $P127, vivify_2571
    new $P127, "Undef"
  vivify_2571:
    set $P128, $P3162
    unless_null $P128, vivify_2572
    new $P128, "Undef"
  vivify_2572:
    $P127."name"($P128)
.annotate 'line', 1946
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2573
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2574
    die "Contextual $*SCOPE not found"
  vivify_2574:
  vivify_2573:
    set $S100, $P131
    iseq $I100, $S100, ""
    unless $I100, unless_3169
    new $P128, 'Integer'
    set $P128, $I100
    goto unless_3169_end
  unless_3169:
    find_dynamic_lex $P134, "$*SCOPE"
    unless_null $P134, vivify_2575
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$SCOPE"]
    unless_null $P134, vivify_2576
    die "Contextual $*SCOPE not found"
  vivify_2576:
  vivify_2575:
    set $S101, $P134
    iseq $I101, $S101, "my"
    new $P128, 'Integer'
    set $P128, $I101
  unless_3169_end:
    unless $P128, unless_3168
    set $P127, $P128
    goto unless_3168_end
  unless_3168:
    find_dynamic_lex $P137, "$*SCOPE"
    unless_null $P137, vivify_2577
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$SCOPE"]
    unless_null $P137, vivify_2578
    die "Contextual $*SCOPE not found"
  vivify_2578:
  vivify_2577:
    set $S102, $P137
    iseq $I102, $S102, "our"
    new $P127, 'Integer'
    set $P127, $I102
  unless_3168_end:
    if $P127, if_3167
.annotate 'line', 2034
    find_lex $P138, "$/"
    unless_null $P138, vivify_2579
    new $P138, "Undef"
  vivify_2579:
    $P139 = $P138."CURSOR"()
    find_dynamic_lex $P142, "$*SCOPE"
    unless_null $P142, vivify_2580
    get_hll_global $P140, "GLOBAL"
    get_who $P141, $P140
    set $P142, $P141["$SCOPE"]
    unless_null $P142, vivify_2581
    die "Contextual $*SCOPE not found"
  vivify_2581:
  vivify_2580:
    concat $P143, $P142, " scoped routines are not supported yet"
    $P139."panic"($P143)
.annotate 'line', 2033
    goto if_3167_end
  if_3167:
.annotate 'line', 1947
    find_dynamic_lex $P140, "$*MULTINESS"
    unless_null $P140, vivify_2582
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$MULTINESS"]
    unless_null $P140, vivify_2583
    die "Contextual $*MULTINESS not found"
  vivify_2583:
  vivify_2582:
    set $S103, $P140
    iseq $I103, $S103, "multi"
    if $I103, if_3170
.annotate 'line', 1998
    find_dynamic_lex $P145, "$*MULTINESS"
    unless_null $P145, vivify_2584
    get_hll_global $P142, "GLOBAL"
    get_who $P144, $P142
    set $P145, $P144["$MULTINESS"]
    unless_null $P145, vivify_2585
    die "Contextual $*MULTINESS not found"
  vivify_2585:
  vivify_2584:
    set $S104, $P145
    iseq $I104, $S104, "proto"
    if $I104, if_3204
.annotate 'line', 2017
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    new $P149, "Float"
    assign $P149, 0
    set $I106, $P149
    find_lex $P151, "$?PACKAGE"
    get_who $P152, $P151
    set $P3214, $P152["@BLOCK"]
    unless_null $P3214, vivify_2586
    $P3214 = root_new ['parrot';'ResizablePMCArray']
  vivify_2586:
    set $P3215, $P3214[$I106]
    unless_null $P3215, vivify_2587
    $P3215 = root_new ['parrot';'ResizablePMCArray']
  vivify_2587:
    set $P153, $P3215[$I105]
    unless_null $P153, vivify_2588
    new $P153, "Undef"
  vivify_2588:
    get_hll_global $P154, "GLOBAL"
    nqp_get_package_through_who $P155, $P154, "PAST"
    get_who $P156, $P155
    set $P157, $P156["Var"]
    set $P158, $P3162
    unless_null $P158, vivify_2589
    new $P158, "Undef"
  vivify_2589:
    find_lex $P159, "$past"
    unless_null $P159, vivify_2590
    new $P159, "Undef"
  vivify_2590:
    $P160 = $P157."new"($P158 :named("name"), 1 :named("isdecl"), 1 :named("directaccess"), $P159 :named("viviself"), "lexical" :named("scope"))
    $P153."push"($P160)
.annotate 'line', 2019
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    find_lex $P149, "$?PACKAGE"
    get_who $P151, $P149
    set $P3216, $P151["@BLOCK"]
    unless_null $P3216, vivify_2591
    $P3216 = root_new ['parrot';'ResizablePMCArray']
  vivify_2591:
    set $P152, $P3216[$I105]
    unless_null $P152, vivify_2592
    new $P152, "Undef"
  vivify_2592:
    set $P153, $P3162
    unless_null $P153, vivify_2593
    new $P153, "Undef"
  vivify_2593:
    $P152."symbol"($P153, "lexical" :named("scope"))
.annotate 'line', 2020
    find_dynamic_lex $P151, "$*SCOPE"
    unless_null $P151, vivify_2594
    get_hll_global $P147, "GLOBAL"
    get_who $P149, $P147
    set $P151, $P149["$SCOPE"]
    unless_null $P151, vivify_2595
    die "Contextual $*SCOPE not found"
  vivify_2595:
  vivify_2594:
    set $S105, $P151
    iseq $I105, $S105, "our"
    unless $I105, if_3217_end
.annotate 'line', 2023
    find_dynamic_lex $P154, "$*W"
    unless_null $P154, vivify_2596
    get_hll_global $P152, "GLOBAL"
    get_who $P153, $P152
    set $P154, $P153["$W"]
    unless_null $P154, vivify_2597
    die "Contextual $*W not found"
  vivify_2597:
  vivify_2596:
    find_dynamic_lex $P157, "$*PACKAGE"
    unless_null $P157, vivify_2598
    get_hll_global $P155, "GLOBAL"
    get_who $P156, $P155
    set $P157, $P156["$PACKAGE"]
    unless_null $P157, vivify_2599
    die "Contextual $*PACKAGE not found"
  vivify_2599:
  vivify_2598:
    set $P158, $P3162
    unless_null $P158, vivify_2600
    new $P158, "Undef"
  vivify_2600:
    find_lex $P159, "$past"
    unless_null $P159, vivify_2601
    new $P159, "Undef"
  vivify_2601:
    $P154."install_package_routine"($P157, $P158, $P159)
.annotate 'line', 2024
    new $P152, "Float"
    assign $P152, 0
    set $I106, $P152
    new $P153, "Float"
    assign $P153, 0
    set $I107, $P153
    find_lex $P154, "$?PACKAGE"
    get_who $P155, $P154
    set $P3218, $P155["@BLOCK"]
    unless_null $P3218, vivify_2602
    $P3218 = root_new ['parrot';'ResizablePMCArray']
  vivify_2602:
    set $P3219, $P3218[$I107]
    unless_null $P3219, vivify_2603
    $P3219 = root_new ['parrot';'ResizablePMCArray']
  vivify_2603:
    set $P156, $P3219[$I106]
    unless_null $P156, vivify_2604
    new $P156, "Undef"
  vivify_2604:
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Op"]
.annotate 'line', 2026
    set $P161, $P3162
    unless_null $P161, vivify_2605
    new $P161, "Undef"
  vivify_2605:
    new $P162, "ResizablePMCArray"
    push $P162, $P161
    find_lex $P163, "$/"
    unless_null $P163, vivify_2606
    new $P163, "Undef"
  vivify_2606:
    $P164 = "lexical_package_lookup"($P162, $P163)
.annotate 'line', 2027
    get_hll_global $P165, "GLOBAL"
    nqp_get_package_through_who $P166, $P165, "PAST"
    get_who $P167, $P166
    set $P168, $P167["Var"]
    set $P169, $P3162
    unless_null $P169, vivify_2607
    new $P169, "Undef"
  vivify_2607:
    $P170 = $P168."new"($P169 :named("name"), "lexical" :named("scope"))
    $P171 = $P160."new"($P164, $P170, "bind_6model" :named("pasttype"))
.annotate 'line', 2024
    $P156."push"($P171)
  if_3217_end:
.annotate 'line', 2016
    goto if_3204_end
  if_3204:
.annotate 'line', 1998
    .const 'Sub' $P3206 = "555_1325892461.451" 
    capture_lex $P3206
    $P3206()
  if_3204_end:
    goto if_3170_end
  if_3170:
.annotate 'line', 1947
    .const 'Sub' $P3172 = "552_1325892461.451" 
    capture_lex $P3172
    $P3172()
  if_3170_end:
.annotate 'line', 2031
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Var"]
    set $P142, $P3162
    unless_null $P142, vivify_2665
    new $P142, "Undef"
  vivify_2665:
    $P143 = $P141."new"($P142 :named("name"))
    store_lex "$past", $P143
  if_3167_end:
.annotate 'line', 2038
    set $P129, $P3162
    unless_null $P129, vivify_2666
    new $P129, "Undef"
  vivify_2666:
    set $S100, $P129
    iseq $I100, $S100, "MAIN"
    if $I100, if_3221
    new $P128, 'Integer'
    set $P128, $I100
    goto if_3221_end
  if_3221:
    find_dynamic_lex $P132, "$*MULTINESS"
    unless_null $P132, vivify_2667
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$MULTINESS"]
    unless_null $P132, vivify_2668
    die "Contextual $*MULTINESS not found"
  vivify_2668:
  vivify_2667:
    set $S101, $P132
    isne $I101, $S101, "multi"
    new $P128, 'Integer'
    set $P128, $I101
  if_3221_end:
    if $P128, if_3220
    set $P127, $P128
    goto if_3220_end
  if_3220:
.annotate 'line', 2039
    find_lex $P133, "$block"
    unless_null $P133, vivify_2669
    new $P133, "Undef"
  vivify_2669:
    store_dynamic_lex "$*MAIN_SUB", $P133
.annotate 'line', 2038
    set $P127, $P133
  if_3220_end:
.annotate 'line', 1943
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3205"  :anon :subid("555_1325892461.451") :outer("551_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2003
    new $P146, "Undef"
    set $P3207, $P146
    .lex "$cholder", $P3207
.annotate 'line', 2002
    find_dynamic_lex $P149, "$*SCOPE"
    unless_null $P149, vivify_2608
    get_hll_global $P147, "GLOBAL"
    get_who $P148, $P147
    set $P149, $P148["$SCOPE"]
    unless_null $P149, vivify_2609
    die "Contextual $*SCOPE not found"
  vivify_2609:
  vivify_2608:
    set $S105, $P149
    iseq $I105, $S105, "our"
    unless $I105, if_3208_end
    die "our-scoped protos not yet implemented"
  if_3208_end:
.annotate 'line', 2003
    get_hll_global $P147, "GLOBAL"
    nqp_get_package_through_who $P148, $P147, "PAST"
    get_who $P149, $P148
    set $P151, $P149["Op"]
    $P152 = $P151."new"("list" :named("pasttype"))
    set $P3207, $P152
.annotate 'line', 2004
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    new $P148, "Float"
    assign $P148, 0
    set $I106, $P148
    find_lex $P149, "$?PACKAGE"
    get_who $P151, $P149
    set $P3209, $P151["@BLOCK"]
    unless_null $P3209, vivify_2610
    $P3209 = root_new ['parrot';'ResizablePMCArray']
  vivify_2610:
    set $P3210, $P3209[$I106]
    unless_null $P3210, vivify_2611
    $P3210 = root_new ['parrot';'ResizablePMCArray']
  vivify_2611:
    set $P152, $P3210[$I105]
    unless_null $P152, vivify_2612
    new $P152, "Undef"
  vivify_2612:
    get_hll_global $P153, "GLOBAL"
    nqp_get_package_through_who $P154, $P153, "PAST"
    get_who $P155, $P154
    set $P156, $P155["Var"]
    find_lex $P157, "$name"
    unless_null $P157, vivify_2613
    new $P157, "Undef"
  vivify_2613:
    find_lex $P158, "$past"
    unless_null $P158, vivify_2614
    new $P158, "Undef"
  vivify_2614:
    $P159 = $P156."new"($P157 :named("name"), 1 :named("isdecl"), 1 :named("directaccess"), $P158 :named("viviself"), "lexical" :named("scope"))
    $P152."push"($P159)
.annotate 'line', 2006
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    new $P148, "Float"
    assign $P148, 0
    set $I106, $P148
    find_lex $P149, "$?PACKAGE"
    get_who $P151, $P149
    set $P3211, $P151["@BLOCK"]
    unless_null $P3211, vivify_2615
    $P3211 = root_new ['parrot';'ResizablePMCArray']
  vivify_2615:
    set $P3212, $P3211[$I106]
    unless_null $P3212, vivify_2616
    $P3212 = root_new ['parrot';'ResizablePMCArray']
  vivify_2616:
    set $P152, $P3212[$I105]
    unless_null $P152, vivify_2617
    new $P152, "Undef"
  vivify_2617:
    get_hll_global $P153, "GLOBAL"
    nqp_get_package_through_who $P154, $P153, "PAST"
    get_who $P155, $P154
    set $P156, $P155["Op"]
.annotate 'line', 2008
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Var"]
    find_lex $P161, "$name"
    unless_null $P161, vivify_2618
    new $P161, "Undef"
  vivify_2618:
    $P162 = $P160."new"($P161 :named("name"))
    set $P163, $P3207
    unless_null $P163, vivify_2619
    new $P163, "Undef"
  vivify_2619:
    $P164 = $P156."new"($P162, $P163, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 2006
    $P152."push"($P164)
.annotate 'line', 2011
    new $P147, "Float"
    assign $P147, 0
    set $I105, $P147
    find_lex $P148, "$?PACKAGE"
    get_who $P149, $P148
    set $P3213, $P149["@BLOCK"]
    unless_null $P3213, vivify_2620
    $P3213 = root_new ['parrot';'ResizablePMCArray']
  vivify_2620:
    set $P151, $P3213[$I105]
    unless_null $P151, vivify_2621
    new $P151, "Undef"
  vivify_2621:
    find_lex $P152, "$name"
    unless_null $P152, vivify_2622
    new $P152, "Undef"
  vivify_2622:
    set $P153, $P3207
    unless_null $P153, vivify_2623
    new $P153, "Undef"
  vivify_2623:
    $P151."symbol"($P152, "lexical" :named("scope"), 1 :named("proto"), $P153 :named("cholder"))
.annotate 'line', 2014
    find_lex $P147, "$past"
    unless_null $P147, vivify_2624
    new $P147, "Undef"
  vivify_2624:
    $P148 = $P147."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1998
    .return ($P148)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3171"  :anon :subid("552_1325892461.451") :outer("551_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1947
    .const 'Sub' $P3182 = "553_1325892461.451" 
    capture_lex $P3182
.annotate 'line', 1950
    new $P141, "Undef"
    set $P3173, $P141
    .lex "$cholder", $P3173
.annotate 'line', 1951
    $P3175 = root_new ['parrot';'Hash']
    set $P3174, $P3175
    .lex "%sym", $P3174
.annotate 'line', 1949
    find_dynamic_lex $P144, "$*SCOPE"
    unless_null $P144, vivify_2625
    get_hll_global $P142, "GLOBAL"
    get_who $P143, $P142
    set $P144, $P143["$SCOPE"]
    unless_null $P144, vivify_2626
    die "Contextual $*SCOPE not found"
  vivify_2626:
  vivify_2625:
    set $S104, $P144
    iseq $I104, $S104, "our"
    unless $I104, if_3176_end
    die "our-scoped multis not yet implemented"
  if_3176_end:
.annotate 'line', 1947
    set $P142, $P3173
    unless_null $P142, vivify_2627
    new $P142, "Undef"
  vivify_2627:
.annotate 'line', 1951
    new $P142, "Float"
    assign $P142, 0
    set $I104, $P142
    find_lex $P143, "$?PACKAGE"
    get_who $P144, $P143
    set $P3177, $P144["@BLOCK"]
    unless_null $P3177, vivify_2628
    $P3177 = root_new ['parrot';'ResizablePMCArray']
  vivify_2628:
    set $P145, $P3177[$I104]
    unless_null $P145, vivify_2629
    new $P145, "Undef"
  vivify_2629:
    find_lex $P146, "$name"
    unless_null $P146, vivify_2630
    new $P146, "Undef"
  vivify_2630:
    $P147 = $P145."symbol"($P146)
    set $P3174, $P147
.annotate 'line', 1952
    set $P3179, $P3174
    unless_null $P3179, vivify_2631
    $P3179 = root_new ['parrot';'Hash']
  vivify_2631:
    set $P142, $P3179["cholder"]
    unless_null $P142, vivify_2632
    new $P142, "Undef"
  vivify_2632:
    if $P142, if_3178
.annotate 'line', 1957
    .const 'Sub' $P3182 = "553_1325892461.451" 
    capture_lex $P3182
    $P3182()
    goto if_3178_end
  if_3178:
.annotate 'line', 1953
    set $P3180, $P3174
    unless_null $P3180, vivify_2660
    $P3180 = root_new ['parrot';'Hash']
  vivify_2660:
    set $P143, $P3180["cholder"]
    unless_null $P143, vivify_2661
    new $P143, "Undef"
  vivify_2661:
    set $P3173, $P143
  if_3178_end:
.annotate 'line', 1993
    set $P142, $P3173
    unless_null $P142, vivify_2662
    new $P142, "Undef"
  vivify_2662:
    find_lex $P143, "$past"
    unless_null $P143, vivify_2663
    new $P143, "Undef"
  vivify_2663:
    $P142."push"($P143)
.annotate 'line', 1996
    find_lex $P142, "$past"
    unless_null $P142, vivify_2664
    new $P142, "Undef"
  vivify_2664:
    $P143 = "attach_multi_signature"($P142)
.annotate 'line', 1947
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3181"  :anon :subid("553_1325892461.451") :outer("552_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1957
    .const 'Sub' $P3189 = "554_1325892461.451" 
    capture_lex $P3189
.annotate 'line', 1964
    new $P143, "Undef"
    set $P3183, $P143
    .lex "$found_proto", $P3183
.annotate 'line', 1982
    new $P144, "Undef"
    set $P3184, $P144
    .lex "$dispatch_setup", $P3184
.annotate 'line', 1959
    find_lex $P3186, "%sym"
    unless_null $P3186, vivify_2633
    $P3186 = root_new ['parrot';'Hash']
  vivify_2633:
    set $P145, $P3186["proto"]
    unless_null $P145, vivify_2634
    new $P145, "Undef"
  vivify_2634:
    unless $P145, if_3185_end
.annotate 'line', 1962
    find_lex $P146, "$/"
    unless_null $P146, vivify_2635
    new $P146, "Undef"
  vivify_2635:
    $P147 = $P146."CURSOR"()
    $P147."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_3185_end:
.annotate 'line', 1957
    set $P145, $P3183
    unless_null $P145, vivify_2636
    new $P145, "Undef"
  vivify_2636:
.annotate 'line', 1965
    find_lex $P146, "$?PACKAGE"
    get_who $P147, $P146
    set $P3187, $P147["@BLOCK"]
    unless_null $P3187, vivify_2637
    $P3187 = root_new ['parrot';'ResizablePMCArray']
  vivify_2637:
    defined $I104, $P3187
    unless $I104, for_undef_2638
    iter $P145, $P3187
    new $P151, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P151, loop3199_handler
    push_eh $P151
  loop3199_test:
    unless $P145, loop3199_done
    shift $P148, $P145
  loop3199_redo:
    .const 'Sub' $P3189 = "554_1325892461.451" 
    capture_lex $P3189
    $P3189($P148)
  loop3199_next:
    goto loop3199_test
  loop3199_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P152, exception, 'type'
    eq $P152, .CONTROL_LOOP_NEXT, loop3199_next
    eq $P152, .CONTROL_LOOP_REDO, loop3199_redo
  loop3199_done:
    pop_eh 
  for_undef_2638:
.annotate 'line', 1976
    set $P145, $P3183
    unless_null $P145, vivify_2647
    new $P145, "Undef"
  vivify_2647:
    if $P145, unless_3200_end
.annotate 'line', 1977
    find_lex $P146, "$/"
    unless_null $P146, vivify_2648
    new $P146, "Undef"
  vivify_2648:
    $P147 = $P146."CURSOR"()
    $P147."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_3200_end:
.annotate 'line', 1981
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
    $P149 = $P148."new"("list" :named("pasttype"))
    store_lex "$cholder", $P149
.annotate 'line', 1982
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
.annotate 'line', 1984
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Var"]
    find_lex $P154, "$name"
    unless_null $P154, vivify_2649
    new $P154, "Undef"
  vivify_2649:
    $P155 = $P153."new"($P154 :named("name"), "outer" :named("scope"))
    find_lex $P156, "$cholder"
    unless_null $P156, vivify_2650
    new $P156, "Undef"
  vivify_2650:
    $P157 = $P148."new"($P155, $P156, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1982
    set $P3184, $P157
.annotate 'line', 1987
    new $P145, "Float"
    assign $P145, 0
    set $I104, $P145
    new $P146, "Float"
    assign $P146, 0
    set $I105, $P146
    find_lex $P147, "$?PACKAGE"
    get_who $P148, $P147
    set $P3201, $P148["@BLOCK"]
    unless_null $P3201, vivify_2651
    $P3201 = root_new ['parrot';'ResizablePMCArray']
  vivify_2651:
    set $P3202, $P3201[$I105]
    unless_null $P3202, vivify_2652
    $P3202 = root_new ['parrot';'ResizablePMCArray']
  vivify_2652:
    set $P149, $P3202[$I104]
    unless_null $P149, vivify_2653
    new $P149, "Undef"
  vivify_2653:
    get_hll_global $P151, "GLOBAL"
    nqp_get_package_through_who $P152, $P151, "PAST"
    get_who $P153, $P152
    set $P154, $P153["Var"]
    find_lex $P155, "$name"
    unless_null $P155, vivify_2654
    new $P155, "Undef"
  vivify_2654:
    set $P156, $P3184
    unless_null $P156, vivify_2655
    new $P156, "Undef"
  vivify_2655:
    $P157 = $P154."new"($P155 :named("name"), 1 :named("isdecl"), 1 :named("directaccess"), $P156 :named("viviself"), "lexical" :named("scope"))
    $P149."push"($P157)
.annotate 'line', 1989
    new $P145, "Float"
    assign $P145, 0
    set $I104, $P145
    find_lex $P146, "$?PACKAGE"
    get_who $P147, $P146
    set $P3203, $P147["@BLOCK"]
    unless_null $P3203, vivify_2656
    $P3203 = root_new ['parrot';'ResizablePMCArray']
  vivify_2656:
    set $P148, $P3203[$I104]
    unless_null $P148, vivify_2657
    new $P148, "Undef"
  vivify_2657:
    find_lex $P149, "$name"
    unless_null $P149, vivify_2658
    new $P149, "Undef"
  vivify_2658:
    find_lex $P151, "$cholder"
    unless_null $P151, vivify_2659
    new $P151, "Undef"
  vivify_2659:
    $P152 = $P148."symbol"($P149, "lexical" :named("scope"), $P151 :named("cholder"))
.annotate 'line', 1957
    .return ($P152)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3188"  :anon :subid("554_1325892461.451") :outer("553_1325892461.451")
    .param pmc param_3192
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1966
    $P3191 = root_new ['parrot';'Hash']
    set $P3190, $P3191
    .lex "%sym", $P3190
    .lex "$_", param_3192
    find_lex $P149, "$_"
    unless_null $P149, vivify_2639
    new $P149, "Undef"
  vivify_2639:
    find_lex $P151, "$name"
    unless_null $P151, vivify_2640
    new $P151, "Undef"
  vivify_2640:
    $P152 = $P149."symbol"($P151)
    set $P3190, $P152
.annotate 'line', 1967
    set $P3195, $P3190
    unless_null $P3195, vivify_2641
    $P3195 = root_new ['parrot';'Hash']
  vivify_2641:
    set $P152, $P3195["proto"]
    unless_null $P152, vivify_2642
    new $P152, "Undef"
  vivify_2642:
    unless $P152, unless_3194
    set $P151, $P152
    goto unless_3194_end
  unless_3194:
    set $P3196, $P3190
    unless_null $P3196, vivify_2643
    $P3196 = root_new ['parrot';'Hash']
  vivify_2643:
    set $P153, $P3196["cholder"]
    unless_null $P153, vivify_2644
    new $P153, "Undef"
  vivify_2644:
    set $P151, $P153
  unless_3194_end:
    if $P151, if_3193
.annotate 'line', 1970
    set $P3198, $P3190
    unless_null $P3198, vivify_2645
    $P3198 = root_new ['parrot';'Hash']
  vivify_2645:
    if $P3198, if_3197
    set $P155, $P3198
    goto if_3197_end
  if_3197:
.annotate 'line', 1971
    find_lex $P156, "$/"
    unless_null $P156, vivify_2646
    new $P156, "Undef"
  vivify_2646:
    $P157 = $P156."CURSOR"()
    $P158 = $P157."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1970
    set $P155, $P158
  if_3197_end:
    set $P149, $P155
.annotate 'line', 1967
    goto if_3193_end
  if_3193:
.annotate 'line', 1968
    new $P154, "Float"
    assign $P154, 1
    store_lex "$found_proto", $P154
.annotate 'line', 1967
    set $P149, $P154
  if_3193_end:
.annotate 'line', 1965
    .return ($P149)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3226"  :anon :subid("556_1325892461.451") :outer("550_1325892461.451")
    .param pmc param_3228
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2046
    .lex "$_", param_3228
    find_lex $P129, "$_"
    unless_null $P129, vivify_2677
    new $P129, "Undef"
  vivify_2677:
    $P130 = $P129."ast"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_2678
    new $P131, "Undef"
  vivify_2678:
    $P132 = $P130($P131)
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def" :anon :subid("557_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3231
    .param pmc param_3232
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2053
    .const 'Sub' $P3260 = "559_1325892461.451" 
    capture_lex $P3260
    .const 'Sub' $P3244 = "558_1325892461.451" 
    capture_lex $P3244
    .lex "self", param_3231
    .lex "$/", param_3232
.annotate 'line', 2056
    new $P122, "Undef"
    set $P3233, $P122
    .lex "$past", $P3233
.annotate 'line', 2053
    set $P123, $P3233
    unless_null $P123, vivify_2680
    new $P123, "Undef"
  vivify_2680:
.annotate 'line', 2057
    set $P3235, param_3232
    unless_null $P3235, vivify_2681
    $P3235 = root_new ['parrot';'Hash']
  vivify_2681:
    set $P123, $P3235["onlystar"]
    unless_null $P123, vivify_2682
    new $P123, "Undef"
  vivify_2682:
    if $P123, if_3234
.annotate 'line', 2061
    set $P3236, param_3232
    unless_null $P3236, vivify_2683
    $P3236 = root_new ['parrot';'Hash']
  vivify_2683:
    set $P124, $P3236["blockoid"]
    unless_null $P124, vivify_2684
    new $P124, "Undef"
  vivify_2684:
    $P125 = $P124."ast"()
    set $P3233, $P125
.annotate 'line', 2062
    set $P124, $P3233
    unless_null $P124, vivify_2685
    new $P124, "Undef"
  vivify_2685:
    $P124."blocktype"("declaration")
.annotate 'line', 2063
    find_dynamic_lex $P127, "$*RETURN_USED"
    unless_null $P127, vivify_2686
    get_hll_global $P124, "GLOBAL"
    get_who $P125, $P124
    set $P127, $P125["$RETURN_USED"]
    unless_null $P127, vivify_2687
    die "Contextual $*RETURN_USED not found"
  vivify_2687:
  vivify_2686:
    unless $P127, if_3237_end
.annotate 'line', 2064
    set $P128, $P3233
    unless_null $P128, vivify_2688
    new $P128, "Undef"
  vivify_2688:
    $P128."control"("return_pir")
  if_3237_end:
.annotate 'line', 2060
    goto if_3234_end
  if_3234:
.annotate 'line', 2058
    $P124 = "only_star_block"()
    set $P3233, $P124
  if_3234_end:
.annotate 'line', 2069
    set $P3239, $P3233
    unless_null $P3239, vivify_2689
    $P3239 = root_new ['parrot';'Hash']
  vivify_2689:
    set $P123, $P3239["signature_has_invocant"]
    unless_null $P123, vivify_2690
    new $P123, "Undef"
  vivify_2690:
    if $P123, unless_3238_end
.annotate 'line', 2070
    new $P124, "Float"
    assign $P124, 0
    set $I100, $P124
    set $P3240, $P3233
    unless_null $P3240, vivify_2691
    $P3240 = root_new ['parrot';'ResizablePMCArray']
  vivify_2691:
    set $P125, $P3240[$I100]
    unless_null $P125, vivify_2692
    new $P125, "Undef"
  vivify_2692:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
.annotate 'line', 2072
    find_dynamic_lex $P133, "$*W"
    unless_null $P133, vivify_2693
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$W"]
    unless_null $P133, vivify_2694
    die "Contextual $*W not found"
  vivify_2694:
  vivify_2693:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2695
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2696
    die "Contextual $*PACKAGE not found"
  vivify_2696:
  vivify_2695:
    $P137 = $P133."get_ref"($P136)
.annotate 'line', 2070
    $P138 = $P130."new"("self" :named("name"), "parameter" :named("scope"), 1 :named("directaccess"), $P137 :named("multitype"))
    $P125."unshift"($P138)
  unless_3238_end:
.annotate 'line', 2075
    set $P123, $P3233
    unless_null $P123, vivify_2697
    new $P123, "Undef"
  vivify_2697:
    $P123."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 2078
    set $P3242, param_3232
    unless_null $P3242, vivify_2698
    $P3242 = root_new ['parrot';'Hash']
  vivify_2698:
    set $P123, $P3242["deflongname"]
    unless_null $P123, vivify_2699
    new $P123, "Undef"
  vivify_2699:
    unless $P123, if_3241_end
    .const 'Sub' $P3244 = "558_1325892461.451" 
    capture_lex $P3244
    $P3244()
  if_3241_end:
.annotate 'line', 2105
    set $P123, param_3232
    set $P124, $P3233
    unless_null $P124, vivify_2734
    new $P124, "Undef"
  vivify_2734:
    $P123."!make"($P124)
.annotate 'line', 2106
    set $P123, $P3233
    unless_null $P123, vivify_2735
    new $P123, "Undef"
  vivify_2735:
    set $P3255, $P3233
    unless_null $P3255, vivify_2736
    $P3255 = root_new ['parrot';'Hash']
    set $P3233, $P3255
  vivify_2736:
    set $P3255["block_past"], $P123
.annotate 'line', 2107
    set $P3257, param_3232
    unless_null $P3257, vivify_2737
    $P3257 = root_new ['parrot';'Hash']
  vivify_2737:
    set $P124, $P3257["trait"]
    unless_null $P124, vivify_2738
    new $P124, "Undef"
  vivify_2738:
    if $P124, if_3256
    set $P123, $P124
    goto if_3256_end
  if_3256:
.annotate 'line', 2108
    set $P3258, param_3232
    unless_null $P3258, vivify_2739
    $P3258 = root_new ['parrot';'Hash']
  vivify_2739:
    set $P127, $P3258["trait"]
    unless_null $P127, vivify_2740
    new $P127, "Undef"
  vivify_2740:
    defined $I100, $P127
    unless $I100, for_undef_2741
    iter $P125, $P127
    new $P129, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P129, loop3262_handler
    push_eh $P129
  loop3262_test:
    unless $P125, loop3262_done
    shift $P128, $P125
  loop3262_redo:
    .const 'Sub' $P3260 = "559_1325892461.451" 
    capture_lex $P3260
    $P3260($P128)
  loop3262_next:
    goto loop3262_test
  loop3262_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P130, exception, 'type'
    eq $P130, .CONTROL_LOOP_NEXT, loop3262_next
    eq $P130, .CONTROL_LOOP_REDO, loop3262_redo
  loop3262_done:
    pop_eh 
  for_undef_2741:
.annotate 'line', 2107
    set $P123, $P125
  if_3256_end:
.annotate 'line', 2053
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3243"  :anon :subid("558_1325892461.451") :outer("557_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2080
    new $P124, "Undef"
    set $P3245, $P124
    .lex "$name", $P3245
.annotate 'line', 2088
    new $P125, "Undef"
    set $P3246, $P125
    .lex "$meta_meth", $P3246
.annotate 'line', 2089
    new $P127, "Undef"
    set $P3247, $P127
    .lex "$is_dispatcher", $P3247
.annotate 'line', 2080
    find_lex $P3248, "$/"
    unless_null $P3248, vivify_2700
    $P3248 = root_new ['parrot';'Hash']
  vivify_2700:
    set $P128, $P3248["private"]
    unless_null $P128, vivify_2701
    new $P128, "Undef"
  vivify_2701:
    set $S100, $P128
    new $P129, 'String'
    set $P129, $S100
    new $P130, "Float"
    assign $P130, 0
    set $I100, $P130
    find_lex $P3249, "$/"
    unless_null $P3249, vivify_2702
    $P3249 = root_new ['parrot';'Hash']
  vivify_2702:
    set $P3250, $P3249["deflongname"]
    unless_null $P3250, vivify_2703
    $P3250 = root_new ['parrot';'ResizablePMCArray']
  vivify_2703:
    set $P131, $P3250[$I100]
    unless_null $P131, vivify_2704
    new $P131, "Undef"
  vivify_2704:
    $P132 = $P131."ast"()
    set $S101, $P132
    concat $P133, $P129, $S101
    set $P3245, $P133
.annotate 'line', 2081
    find_lex $P128, "$past"
    unless_null $P128, vivify_2705
    new $P128, "Undef"
  vivify_2705:
    set $P129, $P3245
    unless_null $P129, vivify_2706
    new $P129, "Undef"
  vivify_2706:
    $P128."name"($P129)
.annotate 'line', 2085
    find_dynamic_lex $P130, "$*MULTINESS"
    unless_null $P130, vivify_2707
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$MULTINESS"]
    unless_null $P130, vivify_2708
    die "Contextual $*MULTINESS not found"
  vivify_2708:
  vivify_2707:
    set $S100, $P130
    iseq $I100, $S100, "multi"
    unless $I100, if_3251_end
    find_lex $P131, "$past"
    unless_null $P131, vivify_2709
    new $P131, "Undef"
  vivify_2709:
    "attach_multi_signature"($P131)
  if_3251_end:
.annotate 'line', 2088
    find_dynamic_lex $P131, "$*MULTINESS"
    unless_null $P131, vivify_2710
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$MULTINESS"]
    unless_null $P131, vivify_2711
    die "Contextual $*MULTINESS not found"
  vivify_2711:
  vivify_2710:
    set $S100, $P131
    iseq $I100, $S100, "multi"
    if $I100, if_3252
    new $P133, "String"
    assign $P133, "add_method"
    set $P128, $P133
    goto if_3252_end
  if_3252:
    new $P132, "String"
    assign $P132, "add_multi_method"
    set $P128, $P132
  if_3252_end:
    set $P3246, $P128
.annotate 'line', 2089
    find_dynamic_lex $P130, "$*MULTINESS"
    unless_null $P130, vivify_2712
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$MULTINESS"]
    unless_null $P130, vivify_2713
    die "Contextual $*MULTINESS not found"
  vivify_2713:
  vivify_2712:
    set $S100, $P130
    iseq $I100, $S100, "proto"
    new $P131, 'Integer'
    set $P131, $I100
    set $P3247, $P131
.annotate 'line', 2090
    find_dynamic_lex $P130, "$*W"
    unless_null $P130, vivify_2714
    get_hll_global $P128, "GLOBAL"
    get_who $P129, $P128
    set $P130, $P129["$W"]
    unless_null $P130, vivify_2715
    die "Contextual $*W not found"
  vivify_2715:
  vivify_2714:
    find_dynamic_lex $P133, "$*PACKAGE"
    unless_null $P133, vivify_2716
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$PACKAGE"]
    unless_null $P133, vivify_2717
    die "Contextual $*PACKAGE not found"
  vivify_2717:
  vivify_2716:
    set $P134, $P3246
    unless_null $P134, vivify_2718
    new $P134, "Undef"
  vivify_2718:
    set $P135, $P3245
    unless_null $P135, vivify_2719
    new $P135, "Undef"
  vivify_2719:
    find_lex $P136, "$past"
    unless_null $P136, vivify_2720
    new $P136, "Undef"
  vivify_2720:
    set $P137, $P3247
    unless_null $P137, vivify_2721
    new $P137, "Undef"
  vivify_2721:
    $P130."pkg_add_method"($P133, $P134, $P135, $P136, $P137)
.annotate 'line', 2093
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2722
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2723
    die "Contextual $*SCOPE not found"
  vivify_2723:
  vivify_2722:
    set $S100, $P131
    iseq $I100, $S100, "our"
    if $I100, if_3253
.annotate 'line', 2096
    find_lex $P133, "$past"
    unless_null $P133, vivify_2724
    new $P133, "Undef"
  vivify_2724:
    $P134 = $P133."pirflags"()
    if $P134, if_3254
.annotate 'line', 2099
    find_lex $P135, "$past"
    unless_null $P135, vivify_2725
    new $P135, "Undef"
  vivify_2725:
    $P136 = $P135."pirflags"(":anon")
.annotate 'line', 2098
    set $P132, $P136
.annotate 'line', 2096
    goto if_3254_end
  if_3254:
.annotate 'line', 2097
    find_lex $P135, "$past"
    unless_null $P135, vivify_2726
    new $P135, "Undef"
  vivify_2726:
    find_lex $P136, "$past"
    unless_null $P136, vivify_2727
    new $P136, "Undef"
  vivify_2727:
    $P137 = $P136."pirflags"()
    set $S101, $P137
    new $P138, 'String'
    set $P138, $S101
    concat $P139, $P138, ":anon"
    $P141 = $P135."pirflags"($P139)
.annotate 'line', 2096
    set $P132, $P141
  if_3254_end:
.annotate 'line', 2095
    set $P128, $P132
.annotate 'line', 2093
    goto if_3253_end
  if_3253:
.annotate 'line', 2094
    find_dynamic_lex $P134, "$*W"
    unless_null $P134, vivify_2728
    get_hll_global $P132, "GLOBAL"
    get_who $P133, $P132
    set $P134, $P133["$W"]
    unless_null $P134, vivify_2729
    die "Contextual $*W not found"
  vivify_2729:
  vivify_2728:
    find_dynamic_lex $P137, "$*PACKAGE"
    unless_null $P137, vivify_2730
    get_hll_global $P135, "GLOBAL"
    get_who $P136, $P135
    set $P137, $P136["$PACKAGE"]
    unless_null $P137, vivify_2731
    die "Contextual $*PACKAGE not found"
  vivify_2731:
  vivify_2730:
    set $P138, $P3245
    unless_null $P138, vivify_2732
    new $P138, "Undef"
  vivify_2732:
    find_lex $P139, "$past"
    unless_null $P139, vivify_2733
    new $P139, "Undef"
  vivify_2733:
    $P140 = $P134."install_package_routine"($P137, $P138, $P139)
.annotate 'line', 2093
    set $P128, $P140
  if_3253_end:
.annotate 'line', 2078
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3259"  :anon :subid("559_1325892461.451") :outer("557_1325892461.451")
    .param pmc param_3261
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2108
    .lex "$_", param_3261
    find_lex $P129, "$_"
    unless_null $P129, vivify_2742
    new $P129, "Undef"
  vivify_2742:
    $P130 = $P129."ast"()
    find_lex $P131, "$/"
    unless_null $P131, vivify_2743
    new $P131, "Undef"
  vivify_2743:
    $P132 = $P130($P131)
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature" :anon :subid("560_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3264
    .param pmc param_3265
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2137
    .const 'Sub' $P3280 = "562_1325892461.451" 
    capture_lex $P3280
    .const 'Sub' $P3272 = "561_1325892461.451" 
    capture_lex $P3272
    .lex "self", param_3264
    .lex "$/", param_3265
.annotate 'line', 2138
    new $P122, "Undef"
    set $P3266, $P122
    .lex "$BLOCKINIT", $P3266
    new $P123, "Float"
    assign $P123, 0
    set $I100, $P123
    new $P124, "Float"
    assign $P124, 0
    set $I101, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P3267, $P127["@BLOCK"]
    unless_null $P3267, vivify_2744
    $P3267 = root_new ['parrot';'ResizablePMCArray']
  vivify_2744:
    set $P3268, $P3267[$I101]
    unless_null $P3268, vivify_2745
    $P3268 = root_new ['parrot';'ResizablePMCArray']
  vivify_2745:
    set $P128, $P3268[$I100]
    unless_null $P128, vivify_2746
    new $P128, "Undef"
  vivify_2746:
    set $P3266, $P128
.annotate 'line', 2139
    set $P3270, param_3265
    unless_null $P3270, vivify_2747
    $P3270 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P123, $P3270["invocant"]
    unless_null $P123, vivify_2748
    new $P123, "Undef"
  vivify_2748:
    unless $P123, if_3269_end
    .const 'Sub' $P3272 = "561_1325892461.451" 
    capture_lex $P3272
    $P3272()
  if_3269_end:
.annotate 'line', 2148
    set $P3278, param_3265
    unless_null $P3278, vivify_2758
    $P3278 = root_new ['parrot';'Hash']
  vivify_2758:
    set $P124, $P3278["parameter"]
    unless_null $P124, vivify_2759
    new $P124, "Undef"
  vivify_2759:
    defined $I100, $P124
    unless $I100, for_undef_2760
    iter $P123, $P124
    new $P127, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P127, loop3282_handler
    push_eh $P127
  loop3282_test:
    unless $P123, loop3282_done
    shift $P125, $P123
  loop3282_redo:
    .const 'Sub' $P3280 = "562_1325892461.451" 
    capture_lex $P3280
    $P3280($P125)
  loop3282_next:
    goto loop3282_test
  loop3282_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P128, exception, 'type'
    eq $P128, .CONTROL_LOOP_NEXT, loop3282_next
    eq $P128, .CONTROL_LOOP_REDO, loop3282_redo
  loop3282_done:
    pop_eh 
  for_undef_2760:
.annotate 'line', 2137
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3271"  :anon :subid("561_1325892461.451") :outer("560_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2140
    new $P124, "Undef"
    set $P3273, $P124
    .lex "$inv", $P3273
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    find_lex $P3274, "$/"
    unless_null $P3274, vivify_2749
    $P3274 = root_new ['parrot';'Hash']
  vivify_2749:
    set $P3275, $P3274["invocant"]
    unless_null $P3275, vivify_2750
    $P3275 = root_new ['parrot';'ResizablePMCArray']
  vivify_2750:
    set $P127, $P3275[$I100]
    unless_null $P127, vivify_2751
    new $P127, "Undef"
  vivify_2751:
    $P128 = $P127."ast"()
    set $P3273, $P128
.annotate 'line', 2141
    find_lex $P125, "$BLOCKINIT"
    unless_null $P125, vivify_2752
    new $P125, "Undef"
  vivify_2752:
    set $P127, $P3273
    unless_null $P127, vivify_2753
    new $P127, "Undef"
  vivify_2753:
    $P125."push"($P127)
.annotate 'line', 2142
    find_lex $P125, "$BLOCKINIT"
    unless_null $P125, vivify_2754
    new $P125, "Undef"
  vivify_2754:
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
.annotate 'line', 2144
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Var"]
    set $P135, $P3273
    unless_null $P135, vivify_2755
    new $P135, "Undef"
  vivify_2755:
    $P136 = $P135."name"()
    $P137 = $P134."new"("lexical" :named("scope"), $P136 :named("name"))
.annotate 'line', 2142
    $P138 = $P130."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("directaccess"), $P137 :named("viviself"))
    $P125."push"($P138)
.annotate 'line', 2146
    new $P125, "Float"
    assign $P125, 1
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3276, $P129["@BLOCK"]
    unless_null $P3276, vivify_2756
    $P3276 = root_new ['parrot';'ResizablePMCArray']
    set $P129["@BLOCK"], $P3276
  vivify_2756:
    set $P3277, $P3276[$I100]
    unless_null $P3277, vivify_2757
    $P3277 = root_new ['parrot';'Hash']
    set $P3276[$I100], $P3277
  vivify_2757:
    set $P3277["signature_has_invocant"], $P125
.annotate 'line', 2139
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3279"  :anon :subid("562_1325892461.451") :outer("560_1325892461.451")
    .param pmc param_3281
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2148
    .lex "$_", param_3281
    find_lex $P127, "$BLOCKINIT"
    unless_null $P127, vivify_2761
    new $P127, "Undef"
  vivify_2761:
    find_lex $P128, "$_"
    unless_null $P128, vivify_2762
    new $P128, "Undef"
  vivify_2762:
    $P129 = $P128."ast"()
    $P130 = $P127."push"($P129)
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter" :anon :subid("563_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3284
    .param pmc param_3285
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2151
    .lex "self", param_3284
    .lex "$/", param_3285
.annotate 'line', 2152
    new $P122, "Undef"
    set $P3286, $P122
    .lex "$quant", $P3286
.annotate 'line', 2153
    new $P123, "Undef"
    set $P3287, $P123
    .lex "$past", $P3287
.annotate 'line', 2152
    set $P3288, param_3285
    unless_null $P3288, vivify_2763
    $P3288 = root_new ['parrot';'Hash']
  vivify_2763:
    set $P124, $P3288["quant"]
    unless_null $P124, vivify_2764
    new $P124, "Undef"
  vivify_2764:
    set $P3286, $P124
.annotate 'line', 2151
    set $P124, $P3287
    unless_null $P124, vivify_2765
    new $P124, "Undef"
  vivify_2765:
.annotate 'line', 2154
    set $P3290, param_3285
    unless_null $P3290, vivify_2766
    $P3290 = root_new ['parrot';'Hash']
  vivify_2766:
    set $P124, $P3290["named_param"]
    unless_null $P124, vivify_2767
    new $P124, "Undef"
  vivify_2767:
    if $P124, if_3289
.annotate 'line', 2161
    set $P3296, param_3285
    unless_null $P3296, vivify_2768
    $P3296 = root_new ['parrot';'Hash']
  vivify_2768:
    set $P125, $P3296["param_var"]
    unless_null $P125, vivify_2769
    new $P125, "Undef"
  vivify_2769:
    $P127 = $P125."ast"()
    set $P3287, $P127
.annotate 'line', 2162
    set $P125, $P3286
    unless_null $P125, vivify_2770
    new $P125, "Undef"
  vivify_2770:
    set $S100, $P125
    iseq $I100, $S100, "*"
    if $I100, if_3297
.annotate 'line', 2166
    set $P127, $P3286
    unless_null $P127, vivify_2771
    new $P127, "Undef"
  vivify_2771:
    set $S101, $P127
    iseq $I101, $S101, "?"
    unless $I101, if_3300_end
.annotate 'line', 2167
    set $P128, $P3287
    unless_null $P128, vivify_2772
    new $P128, "Undef"
  vivify_2772:
    set $P3301, param_3285
    unless_null $P3301, vivify_2773
    $P3301 = root_new ['parrot';'Hash']
  vivify_2773:
    set $P3302, $P3301["param_var"]
    unless_null $P3302, vivify_2774
    $P3302 = root_new ['parrot';'Hash']
  vivify_2774:
    set $P129, $P3302["sigil"]
    unless_null $P129, vivify_2775
    new $P129, "Undef"
  vivify_2775:
    $P130 = "vivitype"($P129)
    $P128."viviself"($P130)
  if_3300_end:
.annotate 'line', 2166
    goto if_3297_end
  if_3297:
.annotate 'line', 2163
    set $P127, $P3287
    unless_null $P127, vivify_2776
    new $P127, "Undef"
  vivify_2776:
    $P127."slurpy"(1)
.annotate 'line', 2164
    set $P127, $P3287
    unless_null $P127, vivify_2777
    new $P127, "Undef"
  vivify_2777:
    set $P3298, param_3285
    unless_null $P3298, vivify_2778
    $P3298 = root_new ['parrot';'Hash']
  vivify_2778:
    set $P3299, $P3298["param_var"]
    unless_null $P3299, vivify_2779
    $P3299 = root_new ['parrot';'Hash']
  vivify_2779:
    set $P128, $P3299["sigil"]
    unless_null $P128, vivify_2780
    new $P128, "Undef"
  vivify_2780:
    set $S101, $P128
    iseq $I101, $S101, "%"
    $P127."named"($I101)
  if_3297_end:
.annotate 'line', 2160
    goto if_3289_end
  if_3289:
.annotate 'line', 2155
    set $P3291, param_3285
    unless_null $P3291, vivify_2781
    $P3291 = root_new ['parrot';'Hash']
  vivify_2781:
    set $P125, $P3291["named_param"]
    unless_null $P125, vivify_2782
    new $P125, "Undef"
  vivify_2782:
    $P127 = $P125."ast"()
    set $P3287, $P127
.annotate 'line', 2156
    set $P125, $P3286
    unless_null $P125, vivify_2783
    new $P125, "Undef"
  vivify_2783:
    set $S100, $P125
    isne $I100, $S100, "!"
    unless $I100, if_3292_end
.annotate 'line', 2157
    set $P127, $P3287
    unless_null $P127, vivify_2784
    new $P127, "Undef"
  vivify_2784:
    set $P3293, param_3285
    unless_null $P3293, vivify_2785
    $P3293 = root_new ['parrot';'Hash']
  vivify_2785:
    set $P3294, $P3293["named_param"]
    unless_null $P3294, vivify_2786
    $P3294 = root_new ['parrot';'Hash']
  vivify_2786:
    set $P3295, $P3294["param_var"]
    unless_null $P3295, vivify_2787
    $P3295 = root_new ['parrot';'Hash']
  vivify_2787:
    set $P128, $P3295["sigil"]
    unless_null $P128, vivify_2788
    new $P128, "Undef"
  vivify_2788:
    $P129 = "vivitype"($P128)
    $P127."viviself"($P129)
  if_3292_end:
  if_3289_end:
.annotate 'line', 2170
    set $P3304, param_3285
    unless_null $P3304, vivify_2789
    $P3304 = root_new ['parrot';'Hash']
  vivify_2789:
    set $P124, $P3304["default_value"]
    unless_null $P124, vivify_2790
    new $P124, "Undef"
  vivify_2790:
    unless $P124, if_3303_end
.annotate 'line', 2171
    set $P125, $P3286
    unless_null $P125, vivify_2791
    new $P125, "Undef"
  vivify_2791:
    set $S100, $P125
    iseq $I100, $S100, "*"
    unless $I100, if_3305_end
.annotate 'line', 2172
    set $P127, param_3285
    unless_null $P127, vivify_2792
    new $P127, "Undef"
  vivify_2792:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Can't put default on slurpy parameter")
  if_3305_end:
.annotate 'line', 2174
    set $P125, $P3286
    unless_null $P125, vivify_2793
    new $P125, "Undef"
  vivify_2793:
    set $S100, $P125
    iseq $I100, $S100, "!"
    unless $I100, if_3306_end
.annotate 'line', 2175
    set $P127, param_3285
    unless_null $P127, vivify_2794
    new $P127, "Undef"
  vivify_2794:
    $P128 = $P127."CURSOR"()
    $P128."panic"("Can't put default on required parameter")
  if_3306_end:
.annotate 'line', 2177
    set $P125, $P3287
    unless_null $P125, vivify_2795
    new $P125, "Undef"
  vivify_2795:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    set $P3307, param_3285
    unless_null $P3307, vivify_2796
    $P3307 = root_new ['parrot';'Hash']
  vivify_2796:
    set $P3308, $P3307["default_value"]
    unless_null $P3308, vivify_2797
    $P3308 = root_new ['parrot';'ResizablePMCArray']
  vivify_2797:
    set $P3309, $P3308[$I100]
    unless_null $P3309, vivify_2798
    $P3309 = root_new ['parrot';'Hash']
  vivify_2798:
    set $P128, $P3309["EXPR"]
    unless_null $P128, vivify_2799
    new $P128, "Undef"
  vivify_2799:
    $P129 = $P128."ast"()
    $P125."viviself"($P129)
  if_3303_end:
.annotate 'line', 2179
    set $P124, $P3287
    unless_null $P124, vivify_2800
    new $P124, "Undef"
  vivify_2800:
    $P125 = $P124."viviself"()
    if $P125, unless_3310_end
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3311, $P129["@BLOCK"]
    unless_null $P3311, vivify_2801
    $P3311 = root_new ['parrot';'ResizablePMCArray']
  vivify_2801:
    set $P130, $P3311[$I100]
    unless_null $P130, vivify_2802
    new $P130, "Undef"
  vivify_2802:
    new $P131, "Float"
    assign $P131, 0
    set $I101, $P131
    find_lex $P132, "$?PACKAGE"
    get_who $P133, $P132
    set $P3312, $P133["@BLOCK"]
    unless_null $P3312, vivify_2803
    $P3312 = root_new ['parrot';'ResizablePMCArray']
  vivify_2803:
    set $P134, $P3312[$I101]
    unless_null $P134, vivify_2804
    new $P134, "Undef"
  vivify_2804:
    $P135 = $P134."arity"()
    set $N100, $P135
    new $P136, 'Float'
    set $P136, $N100
    add $P137, $P136, 1
    $P130."arity"($P137)
  unless_3310_end:
.annotate 'line', 2183
    set $P3314, param_3285
    unless_null $P3314, vivify_2805
    $P3314 = root_new ['parrot';'Hash']
  vivify_2805:
    set $P124, $P3314["typename"]
    unless_null $P124, vivify_2806
    new $P124, "Undef"
  vivify_2806:
    unless $P124, if_3313_end
.annotate 'line', 2184
    set $P125, $P3287
    unless_null $P125, vivify_2807
    new $P125, "Undef"
  vivify_2807:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    set $P3315, param_3285
    unless_null $P3315, vivify_2808
    $P3315 = root_new ['parrot';'Hash']
  vivify_2808:
    set $P3316, $P3315["typename"]
    unless_null $P3316, vivify_2809
    $P3316 = root_new ['parrot';'ResizablePMCArray']
  vivify_2809:
    set $P128, $P3316[$I100]
    unless_null $P128, vivify_2810
    new $P128, "Undef"
  vivify_2810:
    $P129 = $P128."ast"()
    $P125."multitype"($P129)
  if_3313_end:
.annotate 'line', 2188
    set $P3318, param_3285
    unless_null $P3318, vivify_2811
    $P3318 = root_new ['parrot';'Hash']
  vivify_2811:
    set $P124, $P3318["definedness"]
    unless_null $P124, vivify_2812
    new $P124, "Undef"
  vivify_2812:
    unless $P124, if_3317_end
.annotate 'line', 2189
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    set $P3319, param_3285
    unless_null $P3319, vivify_2813
    $P3319 = root_new ['parrot';'Hash']
  vivify_2813:
    set $P3320, $P3319["definedness"]
    unless_null $P3320, vivify_2814
    $P3320 = root_new ['parrot';'ResizablePMCArray']
  vivify_2814:
    set $P127, $P3320[$I100]
    unless_null $P127, vivify_2815
    new $P127, "Undef"
  vivify_2815:
    set $S100, $P127
    new $P128, 'String'
    set $P128, $S100
    set $P3321, $P3287
    unless_null $P3321, vivify_2816
    $P3321 = root_new ['parrot';'Hash']
    set $P3287, $P3321
  vivify_2816:
    set $P3321["definedness"], $P128
  if_3317_end:
.annotate 'line', 2192
    set $P124, param_3285
    set $P125, $P3287
    unless_null $P125, vivify_2817
    new $P125, "Undef"
  vivify_2817:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2151
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var" :anon :subid("564_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3323
    .param pmc param_3324
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2195
    .lex "self", param_3323
    .lex "$/", param_3324
.annotate 'line', 2196
    new $P122, "Undef"
    set $P3325, $P122
    .lex "$name", $P3325
.annotate 'line', 2197
    new $P123, "Undef"
    set $P3326, $P123
    .lex "$past", $P3326
.annotate 'line', 2196
    set $P124, param_3324
    unless_null $P124, vivify_2818
    new $P124, "Undef"
  vivify_2818:
    set $S100, $P124
    new $P125, 'String'
    set $P125, $S100
    set $P3325, $P125
.annotate 'line', 2197
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Var"]
    set $P129, $P3325
    unless_null $P129, vivify_2819
    new $P129, "Undef"
  vivify_2819:
    set $P130, param_3324
    unless_null $P130, vivify_2820
    new $P130, "Undef"
  vivify_2820:
    $P131 = $P128."new"($P129 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), 1 :named("directaccess"), $P130 :named("node"))
    set $P3326, $P131
.annotate 'line', 2199
    new $P124, "Float"
    assign $P124, 0
    set $I100, $P124
    find_lex $P125, "$?PACKAGE"
    get_who $P127, $P125
    set $P3327, $P127["@BLOCK"]
    unless_null $P3327, vivify_2821
    $P3327 = root_new ['parrot';'ResizablePMCArray']
  vivify_2821:
    set $P128, $P3327[$I100]
    unless_null $P128, vivify_2822
    new $P128, "Undef"
  vivify_2822:
    set $P129, $P3325
    unless_null $P129, vivify_2823
    new $P129, "Undef"
  vivify_2823:
    $P128."symbol"($P129, "lexical" :named("scope"))
.annotate 'line', 2200
    set $P124, param_3324
    set $P125, $P3326
    unless_null $P125, vivify_2824
    new $P125, "Undef"
  vivify_2824:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2195
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param" :anon :subid("565_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3329
    .param pmc param_3330
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2203
    .lex "self", param_3329
    .lex "$/", param_3330
.annotate 'line', 2204
    new $P122, "Undef"
    set $P3331, $P122
    .lex "$past", $P3331
    set $P3332, param_3330
    unless_null $P3332, vivify_2825
    $P3332 = root_new ['parrot';'Hash']
  vivify_2825:
    set $P123, $P3332["param_var"]
    unless_null $P123, vivify_2826
    new $P123, "Undef"
  vivify_2826:
    $P124 = $P123."ast"()
    set $P3331, $P124
.annotate 'line', 2205
    set $P123, $P3331
    unless_null $P123, vivify_2827
    new $P123, "Undef"
  vivify_2827:
    set $P3333, param_3330
    unless_null $P3333, vivify_2828
    $P3333 = root_new ['parrot';'Hash']
  vivify_2828:
    set $P3334, $P3333["param_var"]
    unless_null $P3334, vivify_2829
    $P3334 = root_new ['parrot';'Hash']
  vivify_2829:
    set $P124, $P3334["name"]
    unless_null $P124, vivify_2830
    new $P124, "Undef"
  vivify_2830:
    set $S100, $P124
    $P123."named"($S100)
.annotate 'line', 2206
    set $P123, param_3330
    set $P124, $P3331
    unless_null $P124, vivify_2831
    new $P124, "Undef"
  vivify_2831:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2203
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename" :anon :subid("566_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3336
    .param pmc param_3337
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2209
    .const 'Sub' $P3342 = "567_1325892461.451" 
    capture_lex $P3342
    .lex "self", param_3336
    .lex "$/", param_3337
.annotate 'line', 2213
    $P3339 = root_new ['parrot';'ResizablePMCArray']
    set $P3338, $P3339
    .lex "@name", $P3338
.annotate 'line', 2214
    new $P122, "Undef"
    set $P3340, $P122
    .lex "$found", $P3340
.annotate 'line', 2213
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "HLL"
    get_who $P125, $P124
    set $P127, $P125["Compiler"]
    set $P128, param_3337
    unless_null $P128, vivify_2832
    new $P128, "Undef"
  vivify_2832:
    set $S100, $P128
    $P129 = $P127."parse_name"($S100)
    set $P3338, $P129
.annotate 'line', 2214
    new $P123, "Float"
    assign $P123, 0
    set $P3340, $P123
.annotate 'line', 2215
    .const 'Sub' $P3342 = "567_1325892461.451" 
    capture_lex $P3342
    $P3342()
.annotate 'line', 2220
    set $P124, $P3340
    unless_null $P124, vivify_2838
    new $P124, "Undef"
  vivify_2838:
    unless $P124, unless_3352
    set $P123, $P124
    goto unless_3352_end
  unless_3352:
.annotate 'line', 2221
    set $P125, param_3337
    unless_null $P125, vivify_2839
    new $P125, "Undef"
  vivify_2839:
    $P127 = $P125."CURSOR"()
    new $P128, "String"
    assign $P128, "Use of undeclared type '"
    set $P129, param_3337
    unless_null $P129, vivify_2840
    new $P129, "Undef"
  vivify_2840:
    set $S100, $P129
    concat $P130, $P128, $S100
    concat $P131, $P130, "'"
    $P132 = $P127."panic"($P131)
.annotate 'line', 2220
    set $P123, $P132
  unless_3352_end:
.annotate 'line', 2209
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3341"  :anon :subid("567_1325892461.451") :outer("566_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2215
    new $P3347, 'ExceptionHandler'
    set_label $P3347, control_3346
    $P3347."handle_types_except"(.CONTROL_ALL)
    push_eh $P3347
.annotate 'line', 2216
    new $P123, "Undef"
    set $P3343, $P123
    .lex "$sym", $P3343
    find_lex $P3344, "@name"
    unless_null $P3344, vivify_2833
    $P3344 = root_new ['parrot';'ResizablePMCArray']
  vivify_2833:
    find_lex $P124, "$/"
    unless_null $P124, vivify_2834
    new $P124, "Undef"
  vivify_2834:
    $P125 = "find_sym"($P3344, $P124)
    set $P3343, $P125
.annotate 'line', 2217
    find_dynamic_lex $P124, "$/"
    find_dynamic_lex $P128, "$*W"
    unless_null $P128, vivify_2835
    get_hll_global $P125, "GLOBAL"
    get_who $P127, $P125
    set $P128, $P127["$W"]
    unless_null $P128, vivify_2836
    die "Contextual $*W not found"
  vivify_2836:
  vivify_2835:
    set $P129, $P3343
    unless_null $P129, vivify_2837
    new $P129, "Undef"
  vivify_2837:
    $P130 = $P128."get_ref"($P129)
    $P124."!make"($P130)
.annotate 'line', 2218
    new $P124, "Float"
    assign $P124, 1
    store_lex "$found", $P124
.annotate 'line', 2215
    pop_eh 
    goto skip_handler_3345
  control_3346:
    peek_exception $P3348
    .local pmc exception 
    .get_results (exception) 
    new $P3350, 'Integer'
    set $P3350, 1
    set exception["handled"], $P3350
    set $I3351, exception["handled"]
    eq $I3351, 1, handled_3349
    rethrow exception
  handled_3349:
    finalize $P3348
    .return (exception)
  skip_handler_3345:
    .return ($P124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait" :anon :subid("568_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3354
    .param pmc param_3355
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2225
    .lex "self", param_3354
    .lex "$/", param_3355
.annotate 'line', 2226
    set $P122, param_3355
    set $P3356, param_3355
    unless_null $P3356, vivify_2841
    $P3356 = root_new ['parrot';'Hash']
  vivify_2841:
    set $P123, $P3356["trait_mod"]
    unless_null $P123, vivify_2842
    new $P123, "Undef"
  vivify_2842:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 2225
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>" :anon :subid("569_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3358
    .param pmc param_3359
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2229
    .const 'Sub' $P3378 = "572_1325892461.451" 
    capture_lex $P3378
    .const 'Sub' $P3363 = "570_1325892461.451" 
    capture_lex $P3363
    .lex "self", param_3358
    .lex "$/", param_3359
.annotate 'line', 2230
    set $P3361, param_3359
    unless_null $P3361, vivify_2843
    $P3361 = root_new ['parrot';'Hash']
  vivify_2843:
    set $P123, $P3361["longname"]
    unless_null $P123, vivify_2844
    new $P123, "Undef"
  vivify_2844:
    set $S100, $P123
    iseq $I100, $S100, "parrot_vtable"
    if $I100, if_3360
.annotate 'line', 2243
    set $P3376, param_3359
    unless_null $P3376, vivify_2845
    $P3376 = root_new ['parrot';'Hash']
  vivify_2845:
    set $P132, $P3376["longname"]
    unless_null $P132, vivify_2846
    new $P132, "Undef"
  vivify_2846:
    set $S101, $P132
    iseq $I101, $S101, "parrot_vtable_handler"
    if $I101, if_3375
.annotate 'line', 2254
    set $P3391, param_3359
    unless_null $P3391, vivify_2847
    $P3391 = root_new ['parrot';'Hash']
  vivify_2847:
    set $P139, $P3391["longname"]
    unless_null $P139, vivify_2848
    new $P139, "Undef"
  vivify_2848:
    set $S102, $P139
    iseq $I102, $S102, "pirflags"
    if $I102, if_3390
.annotate 'line', 2258
    set $P140, param_3359
    unless_null $P140, vivify_2849
    new $P140, "Undef"
  vivify_2849:
    $P141 = $P140."CURSOR"()
    new $P143, 'String'
    set $P143, "Trait '"
    set $P3392, param_3359
    unless_null $P3392, vivify_2850
    $P3392 = root_new ['parrot';'Hash']
  vivify_2850:
    set $P144, $P3392["longname"]
    unless_null $P144, vivify_2851
    new $P144, "Undef"
  vivify_2851:
    concat $P145, $P143, $P144
    concat $P146, $P145, "' not implemented"
    $P147 = $P141."panic"($P146)
.annotate 'line', 2257
    set $P138, $P147
.annotate 'line', 2254
    goto if_3390_end
  if_3390:
.annotate 'line', 2255
    set $P140, param_3359
    unless_null $P140, vivify_2852
    new $P140, "Undef"
  vivify_2852:
    $P141 = $P140."CURSOR"()
    $P142 = $P141."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 2254
    set $P138, $P142
  if_3390_end:
    set $P131, $P138
.annotate 'line', 2243
    goto if_3375_end
  if_3375:
    .const 'Sub' $P3378 = "572_1325892461.451" 
    capture_lex $P3378
    $P136 = $P3378()
    set $P131, $P136
  if_3375_end:
    set $P122, $P131
.annotate 'line', 2230
    goto if_3360_end
  if_3360:
    .const 'Sub' $P3363 = "570_1325892461.451" 
    capture_lex $P3363
    $P129 = $P3363()
    set $P122, $P129
  if_3360_end:
.annotate 'line', 2229
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3377"  :anon :subid("572_1325892461.451") :outer("569_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2243
    .const 'Sub' $P3386 = "573_1325892461.451" 
    capture_lex $P3386
.annotate 'line', 2245
    new $P133, "Undef"
    set $P3379, $P133
    .lex "$cpast", $P3379
.annotate 'line', 2248
    new $P134, "Undef"
    set $P3380, $P134
    .lex "$name", $P3380
.annotate 'line', 2249
    new $P135, "Undef"
    set $P3381, $P135
    .lex "$package", $P3381
.annotate 'line', 2245
    new $P136, "Float"
    assign $P136, 0
    set $I102, $P136
    find_lex $P3382, "$/"
    unless_null $P3382, vivify_2853
    $P3382 = root_new ['parrot';'Hash']
  vivify_2853:
    set $P3383, $P3382["circumfix"]
    unless_null $P3383, vivify_2854
    $P3383 = root_new ['parrot';'ResizablePMCArray']
  vivify_2854:
    set $P137, $P3383[$I102]
    unless_null $P137, vivify_2855
    new $P137, "Undef"
  vivify_2855:
    $P138 = $P137."ast"()
    set $P3379, $P138
.annotate 'line', 2247
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Val"]
    set $P140, $P3379
    unless_null $P140, vivify_2856
    new $P140, "Undef"
  vivify_2856:
    $P141 = $P139."ACCEPTS"($P140)
    if $P141, unless_3384_end
.annotate 'line', 2246
    find_lex $P142, "$/"
    unless_null $P142, vivify_2857
    new $P142, "Undef"
  vivify_2857:
    $P143 = $P142."CURSOR"()
    $P143."panic"("Trait 'parrot_vtable_handler' requires constant scalar argument")
  unless_3384_end:
.annotate 'line', 2248
    set $P136, $P3379
    unless_null $P136, vivify_2858
    new $P136, "Undef"
  vivify_2858:
    $P137 = $P136."value"()
    set $P3380, $P137
.annotate 'line', 2249
    find_dynamic_lex $P138, "$*PACKAGE"
    unless_null $P138, vivify_2859
    get_hll_global $P136, "GLOBAL"
    get_who $P137, $P136
    set $P138, $P137["$PACKAGE"]
    unless_null $P138, vivify_2860
    die "Contextual $*PACKAGE not found"
  vivify_2860:
  vivify_2859:
    set $P3381, $P138
.annotate 'line', 2250
    find_dynamic_lex $P136, "$/"
    .const 'Sub' $P3386 = "573_1325892461.451" 
    newclosure $P3389, $P3386
    $P137 = $P136."!make"($P3389)
.annotate 'line', 2243
    .return ($P137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3385"  :anon :subid("573_1325892461.451") :outer("572_1325892461.451")
    .param pmc param_3387
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2250
    .lex "$match", param_3387
.annotate 'line', 2251
    find_dynamic_lex $P139, "$*W"
    unless_null $P139, vivify_2861
    get_hll_global $P137, "GLOBAL"
    get_who $P138, $P137
    set $P139, $P138["$W"]
    unless_null $P139, vivify_2862
    die "Contextual $*W not found"
  vivify_2862:
  vivify_2861:
    find_lex $P140, "$package"
    unless_null $P140, vivify_2863
    new $P140, "Undef"
  vivify_2863:
    find_lex $P141, "$name"
    unless_null $P141, vivify_2864
    new $P141, "Undef"
  vivify_2864:
    set $P3388, param_3387
    unless_null $P3388, vivify_2865
    $P3388 = root_new ['parrot';'Hash']
  vivify_2865:
    set $P142, $P3388["variable"]
    unless_null $P142, vivify_2866
    new $P142, "Undef"
  vivify_2866:
    set $S102, $P142
    $P143 = $P139."pkg_add_parrot_vtable_handler_mapping"($P140, $P141, $S102)
.annotate 'line', 2250
    .return ($P143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3362"  :anon :subid("570_1325892461.451") :outer("569_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2230
    .const 'Sub' $P3372 = "571_1325892461.451" 
    capture_lex $P3372
.annotate 'line', 2232
    new $P124, "Undef"
    set $P3364, $P124
    .lex "$cpast", $P3364
.annotate 'line', 2235
    new $P125, "Undef"
    set $P3365, $P125
    .lex "$name", $P3365
.annotate 'line', 2236
    new $P127, "Undef"
    set $P3366, $P127
    .lex "$package", $P3366
.annotate 'line', 2237
    new $P128, "Undef"
    set $P3367, $P128
    .lex "$is_dispatcher", $P3367
.annotate 'line', 2232
    new $P129, "Float"
    assign $P129, 0
    set $I101, $P129
    find_lex $P3368, "$/"
    unless_null $P3368, vivify_2867
    $P3368 = root_new ['parrot';'Hash']
  vivify_2867:
    set $P3369, $P3368["circumfix"]
    unless_null $P3369, vivify_2868
    $P3369 = root_new ['parrot';'ResizablePMCArray']
  vivify_2868:
    set $P130, $P3369[$I101]
    unless_null $P130, vivify_2869
    new $P130, "Undef"
  vivify_2869:
    $P131 = $P130."ast"()
    set $P3364, $P131
.annotate 'line', 2234
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Val"]
    set $P133, $P3364
    unless_null $P133, vivify_2870
    new $P133, "Undef"
  vivify_2870:
    $P134 = $P132."ACCEPTS"($P133)
    if $P134, unless_3370_end
.annotate 'line', 2233
    find_lex $P135, "$/"
    unless_null $P135, vivify_2871
    new $P135, "Undef"
  vivify_2871:
    $P136 = $P135."CURSOR"()
    $P136."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_3370_end:
.annotate 'line', 2235
    set $P129, $P3364
    unless_null $P129, vivify_2872
    new $P129, "Undef"
  vivify_2872:
    $P130 = $P129."value"()
    set $P3365, $P130
.annotate 'line', 2236
    find_dynamic_lex $P131, "$*PACKAGE"
    unless_null $P131, vivify_2873
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$PACKAGE"]
    unless_null $P131, vivify_2874
    die "Contextual $*PACKAGE not found"
  vivify_2874:
  vivify_2873:
    set $P3366, $P131
.annotate 'line', 2237
    find_dynamic_lex $P131, "$*SCOPE"
    unless_null $P131, vivify_2875
    get_hll_global $P129, "GLOBAL"
    get_who $P130, $P129
    set $P131, $P130["$SCOPE"]
    unless_null $P131, vivify_2876
    die "Contextual $*SCOPE not found"
  vivify_2876:
  vivify_2875:
    set $S101, $P131
    iseq $I101, $S101, "proto"
    new $P132, 'Integer'
    set $P132, $I101
    set $P3367, $P132
.annotate 'line', 2238
    find_dynamic_lex $P129, "$/"
    .const 'Sub' $P3372 = "571_1325892461.451" 
    newclosure $P3374, $P3372
    $P130 = $P129."!make"($P3374)
.annotate 'line', 2230
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3371"  :anon :subid("571_1325892461.451") :outer("570_1325892461.451")
    .param pmc param_3373
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2238
    .lex "$match", param_3373
.annotate 'line', 2239
    find_dynamic_lex $P132, "$*W"
    unless_null $P132, vivify_2877
    get_hll_global $P130, "GLOBAL"
    get_who $P131, $P130
    set $P132, $P131["$W"]
    unless_null $P132, vivify_2878
    die "Contextual $*W not found"
  vivify_2878:
  vivify_2877:
    find_lex $P133, "$package"
    unless_null $P133, vivify_2879
    new $P133, "Undef"
  vivify_2879:
    find_lex $P134, "$name"
    unless_null $P134, vivify_2880
    new $P134, "Undef"
  vivify_2880:
.annotate 'line', 2240
    set $P135, param_3373
    unless_null $P135, vivify_2881
    new $P135, "Undef"
  vivify_2881:
    $P136 = $P135."ast"()
    set $P137, $P136["block_past"]
    unless_null $P137, vivify_2882
    new $P137, "Undef"
  vivify_2882:
.annotate 'line', 2239
    find_lex $P138, "$is_dispatcher"
    unless_null $P138, vivify_2883
    new $P138, "Undef"
  vivify_2883:
    $P139 = $P132."pkg_add_method"($P133, "add_parrot_vtable_mapping", $P134, $P137, $P138)
.annotate 'line', 2238
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator" :anon :subid("574_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3396
    .param pmc param_3397
    .param pmc param_3398 :optional
    .param int has_param_3398 :opt_flag
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2262
    .const 'Sub' $P3429 = "577_1325892461.451" 
    capture_lex $P3429
    .const 'Sub' $P3413 = "576_1325892461.451" 
    capture_lex $P3413
    .const 'Sub' $P3408 = "575_1325892461.451" 
    capture_lex $P3408
    new $P3395, 'ExceptionHandler', [.CONTROL_RETURN]
    set_label $P3395, control_3394
    push_eh $P3395
    .lex "self", param_3396
    .lex "$/", param_3397
    if has_param_3398, optparam_2884
    new $P122, "Undef"
    set param_3398, $P122
  optparam_2884:
    .lex "$key", param_3398
.annotate 'line', 2263
    $P3400 = root_new ['parrot';'ResizablePMCArray']
    set $P3399, $P3400
    .lex "@MODIFIERS", $P3399
.annotate 'line', 2264
    new $P123, "Undef"
    set $P3401, $P123
    .lex "$name", $P3401
.annotate 'line', 2265
    new $P124, "Undef"
    set $P3402, $P124
    .lex "$past", $P3402
.annotate 'line', 2263
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "Regex"
    nqp_get_package_through_who $P128, $P127, "P6Regex"
    nqp_get_package_through_who $P129, $P128, "Actions"
    get_who $P130, $P129
    set $P3403, $P130["@MODIFIERS"]
    unless_null $P3403, vivify_2885
    $P3403 = root_new ['parrot';'ResizablePMCArray']
  vivify_2885:
    set $P3399, $P3403
.annotate 'line', 2264
    set $P3404, param_3397
    unless_null $P3404, vivify_2886
    $P3404 = root_new ['parrot';'Hash']
  vivify_2886:
    set $P125, $P3404["deflongname"]
    unless_null $P125, vivify_2887
    new $P125, "Undef"
  vivify_2887:
    $P127 = $P125."ast"()
    set $S100, $P127
    new $P128, 'String'
    set $P128, $S100
    set $P3401, $P128
.annotate 'line', 2262
    set $P125, $P3402
    unless_null $P125, vivify_2888
    new $P125, "Undef"
  vivify_2888:
.annotate 'line', 2266
    set $P3406, param_3397
    unless_null $P3406, vivify_2889
    $P3406 = root_new ['parrot';'Hash']
  vivify_2889:
    set $P125, $P3406["proto"]
    unless_null $P125, vivify_2890
    new $P125, "Undef"
  vivify_2890:
    if $P125, if_3405
.annotate 'line', 2296
    set $P127, param_3398
    unless_null $P127, vivify_2891
    new $P127, "Undef"
  vivify_2891:
    set $S100, $P127
    iseq $I100, $S100, "open"
    if $I100, if_3411
.annotate 'line', 2306
    .const 'Sub' $P3429 = "577_1325892461.451" 
    capture_lex $P3429
    $P3429()
    goto if_3411_end
  if_3411:
.annotate 'line', 2296
    .const 'Sub' $P3413 = "576_1325892461.451" 
    capture_lex $P3413
    $P3413()
  if_3411_end:
    goto if_3405_end
  if_3405:
.annotate 'line', 2268
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Stmts"]
.annotate 'line', 2269
    get_hll_global $P131, "GLOBAL"
    nqp_get_package_through_who $P132, $P131, "PAST"
    get_who $P133, $P132
    set $P134, $P133["Block"]
    set $P135, $P3401
    unless_null $P135, vivify_2941
    new $P135, "Undef"
  vivify_2941:
.annotate 'line', 2270
    get_hll_global $P136, "GLOBAL"
    nqp_get_package_through_who $P137, $P136, "PAST"
    get_who $P138, $P137
    set $P139, $P138["Op"]
.annotate 'line', 2271
    get_hll_global $P140, "GLOBAL"
    nqp_get_package_through_who $P141, $P140, "PAST"
    get_who $P142, $P141
    set $P143, $P142["Var"]
    $P144 = $P143."new"("self" :named("name"), "parameter" :named("scope"))
    set $P145, $P3401
    unless_null $P145, vivify_2942
    new $P145, "Undef"
  vivify_2942:
    $P146 = $P139."new"($P144, $P145, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2270
    set $P147, param_3397
    unless_null $P147, vivify_2943
    new $P147, "Undef"
  vivify_2943:
    $P148 = $P134."new"($P146, $P135 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P147 :named("node"))
.annotate 'line', 2280
    get_hll_global $P149, "GLOBAL"
    nqp_get_package_through_who $P151, $P149, "PAST"
    get_who $P152, $P151
    set $P153, $P152["Block"]
    new $P154, "String"
    assign $P154, "!PREFIX__"
    set $P155, $P3401
    unless_null $P155, vivify_2944
    new $P155, "Undef"
  vivify_2944:
    concat $P156, $P154, $P155
.annotate 'line', 2281
    get_hll_global $P157, "GLOBAL"
    nqp_get_package_through_who $P158, $P157, "PAST"
    get_who $P159, $P158
    set $P160, $P159["Op"]
.annotate 'line', 2282
    get_hll_global $P161, "GLOBAL"
    nqp_get_package_through_who $P162, $P161, "PAST"
    get_who $P163, $P162
    set $P164, $P163["Var"]
    $P165 = $P164."new"("self" :named("name"), "parameter" :named("scope"))
    set $P166, $P3401
    unless_null $P166, vivify_2945
    new $P166, "Undef"
  vivify_2945:
    $P167 = $P160."new"($P165, $P166, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2281
    set $P168, param_3397
    unless_null $P168, vivify_2946
    new $P168, "Undef"
  vivify_2946:
    $P169 = $P153."new"($P167, $P156 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P168 :named("node"))
.annotate 'line', 2280
    $P170 = $P130."new"($P148, $P169)
.annotate 'line', 2268
    set $P3402, $P170
.annotate 'line', 2292
    set $P128, $P3402
    unless_null $P128, vivify_2947
    new $P128, "Undef"
  vivify_2947:
    $P129 = $P128."list"()
    defined $I100, $P129
    unless $I100, for_undef_2948
    iter $P127, $P129
    new $P131, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P131, loop3410_handler
    push_eh $P131
  loop3410_test:
    unless $P127, loop3410_done
    shift $P130, $P127
  loop3410_redo:
    .const 'Sub' $P3408 = "575_1325892461.451" 
    capture_lex $P3408
    $P3408($P130)
  loop3410_next:
    goto loop3410_test
  loop3410_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P132, exception, 'type'
    eq $P132, .CONTROL_LOOP_NEXT, loop3410_next
    eq $P132, .CONTROL_LOOP_REDO, loop3410_redo
  loop3410_done:
    pop_eh 
  for_undef_2948:
  if_3405_end:
.annotate 'line', 2337
    set $P125, param_3397
    set $P127, $P3402
    unless_null $P127, vivify_2955
    new $P127, "Undef"
  vivify_2955:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2262
    .return ($P128)
  control_3394:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P125, exception, "payload"
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3428"  :anon :subid("577_1325892461.451") :outer("574_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2306
    .const 'Sub' $P3437 = "578_1325892461.451" 
    capture_lex $P3437
.annotate 'line', 2307
    new $P128, "Undef"
    set $P3430, $P128
    .lex "$regex", $P3430
.annotate 'line', 2310
    new $P129, "Undef"
    set $P3431, $P129
    .lex "$prefix_meth", $P3431
.annotate 'line', 2308
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "Regex"
    nqp_get_package_through_who $P132, $P131, "P6Regex"
    nqp_get_package_through_who $P133, $P132, "Actions"
    get_who $P134, $P133
    set $P135, $P134["buildsub"]
    find_lex $P3432, "$/"
    unless_null $P3432, vivify_2892
    $P3432 = root_new ['parrot';'Hash']
  vivify_2892:
    set $P136, $P3432["p6regex"]
    unless_null $P136, vivify_2893
    new $P136, "Undef"
  vivify_2893:
    $P137 = $P136."ast"()
    find_lex $P138, "$?PACKAGE"
    get_who $P139, $P138
    set $P3433, $P139["@BLOCK"]
    unless_null $P3433, vivify_2894
    $P3433 = root_new ['parrot';'ResizablePMCArray']
  vivify_2894:
    $P140 = $P3433."shift"()
    $P141 = $P135($P137, $P140)
    set $P3430, $P141
.annotate 'line', 2309
    set $P130, $P3430
    unless_null $P130, vivify_2895
    new $P130, "Undef"
  vivify_2895:
    find_lex $P131, "$name"
    unless_null $P131, vivify_2896
    new $P131, "Undef"
  vivify_2896:
    $P130."name"($P131)
.annotate 'line', 2306
    set $P130, $P3431
    unless_null $P130, vivify_2897
    new $P130, "Undef"
  vivify_2897:
.annotate 'line', 2312
    find_dynamic_lex $P133, "$*PKGDECL"
    unless_null $P133, vivify_2898
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$PKGDECL"]
    unless_null $P133, vivify_2899
    die "Contextual $*PKGDECL not found"
  vivify_2899:
  vivify_2898:
    if $P133, if_3435
    set $P130, $P133
    goto if_3435_end
  if_3435:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2900
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2901
    die "Contextual $*PACKAGE not found"
  vivify_2901:
  vivify_2900:
    get_how $P137, $P136
    can $I101, $P137, "add_method"
    new $P130, 'Integer'
    set $P130, $I101
  if_3435_end:
    unless $P130, if_3434_end
    .const 'Sub' $P3437 = "578_1325892461.451" 
    capture_lex $P3437
    $P3437()
  if_3434_end:
.annotate 'line', 2327
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
.annotate 'line', 2329
    new $P134, "ResizablePMCArray"
    push $P134, "Regex"
    push $P134, "Method"
    find_lex $P135, "$/"
    unless_null $P135, vivify_2918
    new $P135, "Undef"
  vivify_2918:
    $P136 = "lexical_package_lookup"($P134, $P135)
    set $P137, $P3430
    unless_null $P137, vivify_2919
    new $P137, "Undef"
  vivify_2919:
    $P138 = $P133."new"($P136, $P137, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2327
    store_lex "$past", $P138
.annotate 'line', 2332
    set $P131, $P3431
    unless_null $P131, vivify_2920
    new $P131, "Undef"
  vivify_2920:
    if $P131, if_3442
    set $P139, $P3430
    unless_null $P139, vivify_2921
    new $P139, "Undef"
  vivify_2921:
    set $P130, $P139
    goto if_3442_end
  if_3442:
.annotate 'line', 2333
    get_hll_global $P132, "GLOBAL"
    nqp_get_package_through_who $P133, $P132, "PAST"
    get_who $P134, $P133
    set $P135, $P134["Stmts"]
    set $P136, $P3430
    unless_null $P136, vivify_2922
    new $P136, "Undef"
  vivify_2922:
    set $P137, $P3431
    unless_null $P137, vivify_2923
    new $P137, "Undef"
  vivify_2923:
    $P138 = $P135."new"($P136, $P137)
    set $P130, $P138
  if_3442_end:
.annotate 'line', 2332
    find_lex $P3443, "$past"
    unless_null $P3443, vivify_2924
    $P3443 = root_new ['parrot';'Hash']
    store_lex "$past", $P3443
  vivify_2924:
    set $P3443["sink"], $P130
.annotate 'line', 2335
    find_lex $P3444, "@MODIFIERS"
    unless_null $P3444, vivify_2925
    $P3444 = root_new ['parrot';'ResizablePMCArray']
  vivify_2925:
    $P130 = $P3444."shift"()
.annotate 'line', 2306
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3436"  :anon :subid("578_1325892461.451") :outer("577_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2317
    $P3439 = root_new ['parrot';'ResizablePMCArray']
    set $P3438, $P3439
    .lex "@prefixes", $P3438
.annotate 'line', 2314
    find_dynamic_lex $P140, "$*W"
    unless_null $P140, vivify_2902
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$W"]
    unless_null $P140, vivify_2903
    die "Contextual $*W not found"
  vivify_2903:
  vivify_2902:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_2904
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_2905
    die "Contextual $*PACKAGE not found"
  vivify_2905:
  vivify_2904:
    find_lex $P144, "$name"
    unless_null $P144, vivify_2906
    new $P144, "Undef"
  vivify_2906:
    find_lex $P145, "$regex"
    unless_null $P145, vivify_2907
    new $P145, "Undef"
  vivify_2907:
    $P140."pkg_add_method"($P143, "add_method", $P144, $P145, 0)
.annotate 'line', 2317
    find_lex $P3440, "$/"
    unless_null $P3440, vivify_2908
    $P3440 = root_new ['parrot';'Hash']
  vivify_2908:
    set $P138, $P3440["p6regex"]
    unless_null $P138, vivify_2909
    new $P138, "Undef"
  vivify_2909:
    $P139 = $P138."ast"()
    $P140 = $P139."prefix_list"()
    set $P3438, $P140
.annotate 'line', 2318
    get_hll_global $P138, "GLOBAL"
    nqp_get_package_through_who $P139, $P138, "PAST"
    get_who $P140, $P139
    set $P141, $P140["Block"]
.annotate 'line', 2319
    new $P142, "String"
    assign $P142, "!PREFIX__"
    find_lex $P143, "$name"
    unless_null $P143, vivify_2910
    new $P143, "Undef"
  vivify_2910:
    concat $P144, $P142, $P143
.annotate 'line', 2320
    get_hll_global $P145, "GLOBAL"
    nqp_get_package_through_who $P146, $P145, "PAST"
    get_who $P147, $P146
    set $P148, $P147["Op"]
    set $P3441, $P3438
    unless_null $P3441, vivify_2911
    $P3441 = root_new ['parrot';'ResizablePMCArray']
  vivify_2911:
    $P149 = $P148."new"($P3441 :flat, "list" :named("pasttype"))
    $P151 = $P141."new"($P149, $P144 :named("name"), "method" :named("blocktype"))
.annotate 'line', 2318
    store_lex "$prefix_meth", $P151
.annotate 'line', 2322
    find_dynamic_lex $P140, "$*W"
    unless_null $P140, vivify_2912
    get_hll_global $P138, "GLOBAL"
    get_who $P139, $P138
    set $P140, $P139["$W"]
    unless_null $P140, vivify_2913
    die "Contextual $*W not found"
  vivify_2913:
  vivify_2912:
    find_dynamic_lex $P143, "$*PACKAGE"
    unless_null $P143, vivify_2914
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["$PACKAGE"]
    unless_null $P143, vivify_2915
    die "Contextual $*PACKAGE not found"
  vivify_2915:
  vivify_2914:
    find_lex $P144, "$prefix_meth"
    unless_null $P144, vivify_2916
    new $P144, "Undef"
  vivify_2916:
    $P145 = $P144."name"()
    find_lex $P146, "$prefix_meth"
    unless_null $P146, vivify_2917
    new $P146, "Undef"
  vivify_2917:
    $P147 = $P140."pkg_add_method"($P143, "add_method", $P145, $P146, 0)
.annotate 'line', 2312
    .return ($P147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3412"  :anon :subid("576_1325892461.451") :outer("574_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2297
    $P3415 = root_new ['parrot';'Hash']
    set $P3414, $P3415
    .lex "%h", $P3414
.annotate 'line', 2296
    set $P3416, $P3414
    unless_null $P3416, vivify_2926
    $P3416 = root_new ['parrot';'Hash']
  vivify_2926:
.annotate 'line', 2298
    find_lex $P3418, "$/"
    unless_null $P3418, vivify_2927
    $P3418 = root_new ['parrot';'Hash']
  vivify_2927:
    set $P128, $P3418["sym"]
    unless_null $P128, vivify_2928
    new $P128, "Undef"
  vivify_2928:
    set $S101, $P128
    iseq $I101, $S101, "token"
    unless $I101, if_3417_end
    new $P129, "Float"
    assign $P129, 1
    set $P3419, $P3414
    unless_null $P3419, vivify_2929
    $P3419 = root_new ['parrot';'Hash']
    set $P3414, $P3419
  vivify_2929:
    set $P3419["r"], $P129
  if_3417_end:
.annotate 'line', 2299
    find_lex $P3421, "$/"
    unless_null $P3421, vivify_2930
    $P3421 = root_new ['parrot';'Hash']
  vivify_2930:
    set $P128, $P3421["sym"]
    unless_null $P128, vivify_2931
    new $P128, "Undef"
  vivify_2931:
    set $S101, $P128
    iseq $I101, $S101, "rule"
    unless $I101, if_3420_end
    new $P129, "Float"
    assign $P129, 1
    set $P3422, $P3414
    unless_null $P3422, vivify_2932
    $P3422 = root_new ['parrot';'Hash']
    set $P3414, $P3422
  vivify_2932:
    set $P3422["r"], $P129
    new $P129, "Float"
    assign $P129, 1
    set $P3423, $P3414
    unless_null $P3423, vivify_2933
    $P3423 = root_new ['parrot';'Hash']
    set $P3414, $P3423
  vivify_2933:
    set $P3423["s"], $P129
  if_3420_end:
.annotate 'line', 2300
    find_lex $P3424, "@MODIFIERS"
    unless_null $P3424, vivify_2934
    $P3424 = root_new ['parrot';'ResizablePMCArray']
  vivify_2934:
    set $P3425, $P3414
    unless_null $P3425, vivify_2935
    $P3425 = root_new ['parrot';'Hash']
  vivify_2935:
    $P3424."unshift"($P3425)
.annotate 'line', 2301
    find_lex $P128, "$name"
    unless_null $P128, vivify_2936
    new $P128, "Undef"
  vivify_2936:
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "Regex"
    nqp_get_package_through_who $P131, $P130, "P6Regex"
    nqp_get_package_through_who $P132, $P131, "Actions"
    get_who $P133, $P132
    set $P133["$REGEXNAME"], $P128
.annotate 'line', 2302
    new $P128, "Float"
    assign $P128, 0
    set $I101, $P128
    find_lex $P129, "$?PACKAGE"
    get_who $P130, $P129
    set $P3426, $P130["@BLOCK"]
    unless_null $P3426, vivify_2937
    $P3426 = root_new ['parrot';'ResizablePMCArray']
  vivify_2937:
    set $P131, $P3426[$I101]
    unless_null $P131, vivify_2938
    new $P131, "Undef"
  vivify_2938:
    $P131."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2303
    new $P128, "Float"
    assign $P128, 0
    set $I101, $P128
    find_lex $P129, "$?PACKAGE"
    get_who $P130, $P129
    set $P3427, $P130["@BLOCK"]
    unless_null $P3427, vivify_2939
    $P3427 = root_new ['parrot';'ResizablePMCArray']
  vivify_2939:
    set $P131, $P3427[$I101]
    unless_null $P131, vivify_2940
    new $P131, "Undef"
  vivify_2940:
    $P131."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2304
    new $P128, "Exception"
    set $P128['type'], .CONTROL_RETURN
    new $P129, "Float"
    assign $P129, 0
    setattribute $P128, 'payload', $P129
    throw $P128
.annotate 'line', 2296
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3407"  :anon :subid("575_1325892461.451") :outer("574_1325892461.451")
    .param pmc param_3409
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2292
    .lex "$_", param_3409
.annotate 'line', 2293
    find_dynamic_lex $P133, "$*W"
    unless_null $P133, vivify_2949
    get_hll_global $P131, "GLOBAL"
    get_who $P132, $P131
    set $P133, $P132["$W"]
    unless_null $P133, vivify_2950
    die "Contextual $*W not found"
  vivify_2950:
  vivify_2949:
    find_dynamic_lex $P136, "$*PACKAGE"
    unless_null $P136, vivify_2951
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["$PACKAGE"]
    unless_null $P136, vivify_2952
    die "Contextual $*PACKAGE not found"
  vivify_2952:
  vivify_2951:
    find_lex $P137, "$_"
    unless_null $P137, vivify_2953
    new $P137, "Undef"
  vivify_2953:
    $P138 = $P137."name"()
    find_lex $P139, "$_"
    unless_null $P139, vivify_2954
    new $P139, "Undef"
  vivify_2954:
    $P140 = $P133."pkg_add_method"($P136, "add_method", $P138, $P139, 0)
.annotate 'line', 2292
    .return ($P140)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty" :anon :subid("579_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3446
    .param pmc param_3447
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2341
    .lex "self", param_3446
    .lex "$/", param_3447
.annotate 'line', 2342
    new $P122, "Undef"
    set $P3448, $P122
    .lex "$past", $P3448
    set $P3450, param_3447
    unless_null $P3450, vivify_2956
    $P3450 = root_new ['parrot';'Hash']
  vivify_2956:
    set $P124, $P3450["args"]
    unless_null $P124, vivify_2957
    new $P124, "Undef"
  vivify_2957:
    if $P124, if_3449
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    set $P133, param_3447
    unless_null $P133, vivify_2958
    new $P133, "Undef"
  vivify_2958:
    $P134 = $P132."new"($P133 :named("node"))
    set $P123, $P134
    goto if_3449_end
  if_3449:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    set $P3451, param_3447
    unless_null $P3451, vivify_2959
    $P3451 = root_new ['parrot';'Hash']
  vivify_2959:
    set $P3452, $P3451["args"]
    unless_null $P3452, vivify_2960
    $P3452 = root_new ['parrot';'ResizablePMCArray']
  vivify_2960:
    set $P127, $P3452[$I100]
    unless_null $P127, vivify_2961
    new $P127, "Undef"
  vivify_2961:
    $P128 = $P127."ast"()
    set $P123, $P128
  if_3449_end:
    set $P3448, $P123
.annotate 'line', 2343
    set $P3454, param_3447
    unless_null $P3454, vivify_2962
    $P3454 = root_new ['parrot';'Hash']
  vivify_2962:
    set $P123, $P3454["quote"]
    unless_null $P123, vivify_2963
    new $P123, "Undef"
  vivify_2963:
    if $P123, if_3453
.annotate 'line', 2347
    set $P3457, param_3447
    unless_null $P3457, vivify_2964
    $P3457 = root_new ['parrot';'Hash']
  vivify_2964:
    set $P124, $P3457["longname"]
    unless_null $P124, vivify_2965
    new $P124, "Undef"
  vivify_2965:
    set $S100, $P124
    iseq $I100, $S100, "HOW"
    if $I100, if_3456
.annotate 'line', 2350
    set $P3459, param_3447
    unless_null $P3459, vivify_2966
    $P3459 = root_new ['parrot';'Hash']
  vivify_2966:
    set $P125, $P3459["longname"]
    unless_null $P125, vivify_2967
    new $P125, "Undef"
  vivify_2967:
    set $S101, $P125
    iseq $I101, $S101, "WHAT"
    if $I101, if_3458
.annotate 'line', 2353
    set $P3461, param_3447
    unless_null $P3461, vivify_2968
    $P3461 = root_new ['parrot';'Hash']
  vivify_2968:
    set $P127, $P3461["longname"]
    unless_null $P127, vivify_2969
    new $P127, "Undef"
  vivify_2969:
    set $S102, $P127
    iseq $I102, $S102, "WHO"
    if $I102, if_3460
.annotate 'line', 2356
    set $P3463, param_3447
    unless_null $P3463, vivify_2970
    $P3463 = root_new ['parrot';'Hash']
  vivify_2970:
    set $P128, $P3463["longname"]
    unless_null $P128, vivify_2971
    new $P128, "Undef"
  vivify_2971:
    set $S103, $P128
    iseq $I103, $S103, "REPR"
    if $I103, if_3462
.annotate 'line', 2360
    set $P129, $P3448
    unless_null $P129, vivify_2972
    new $P129, "Undef"
  vivify_2972:
    set $P3464, param_3447
    unless_null $P3464, vivify_2973
    $P3464 = root_new ['parrot';'Hash']
  vivify_2973:
    set $P130, $P3464["longname"]
    unless_null $P130, vivify_2974
    new $P130, "Undef"
  vivify_2974:
    set $S104, $P130
    $P129."name"($S104)
.annotate 'line', 2361
    set $P129, $P3448
    unless_null $P129, vivify_2975
    new $P129, "Undef"
  vivify_2975:
    $P129."pasttype"("callmethod")
.annotate 'line', 2359
    goto if_3462_end
  if_3462:
.annotate 'line', 2357
    set $P129, $P3448
    unless_null $P129, vivify_2976
    new $P129, "Undef"
  vivify_2976:
    $P129."pirop"("repr_name SP")
  if_3462_end:
.annotate 'line', 2356
    goto if_3460_end
  if_3460:
.annotate 'line', 2354
    set $P128, $P3448
    unless_null $P128, vivify_2977
    new $P128, "Undef"
  vivify_2977:
    $P128."pirop"("get_who PP")
  if_3460_end:
.annotate 'line', 2353
    goto if_3458_end
  if_3458:
.annotate 'line', 2351
    set $P127, $P3448
    unless_null $P127, vivify_2978
    new $P127, "Undef"
  vivify_2978:
    $P127."pirop"("get_what PP")
  if_3458_end:
.annotate 'line', 2350
    goto if_3456_end
  if_3456:
.annotate 'line', 2348
    set $P125, $P3448
    unless_null $P125, vivify_2979
    new $P125, "Undef"
  vivify_2979:
    $P125."pirop"("get_how PP")
  if_3456_end:
.annotate 'line', 2347
    goto if_3453_end
  if_3453:
.annotate 'line', 2344
    set $P124, $P3448
    unless_null $P124, vivify_2980
    new $P124, "Undef"
  vivify_2980:
    set $P3455, param_3447
    unless_null $P3455, vivify_2981
    $P3455 = root_new ['parrot';'Hash']
  vivify_2981:
    set $P125, $P3455["quote"]
    unless_null $P125, vivify_2982
    new $P125, "Undef"
  vivify_2982:
    $P127 = $P125."ast"()
    $P124."name"($P127)
.annotate 'line', 2345
    set $P124, $P3448
    unless_null $P124, vivify_2983
    new $P124, "Undef"
  vivify_2983:
    $P124."pasttype"("callmethod")
  if_3453_end:
.annotate 'line', 2363
    set $P123, param_3447
    set $P124, $P3448
    unless_null $P124, vivify_2984
    new $P124, "Undef"
  vivify_2984:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2341
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>" :anon :subid("580_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3466
    .param pmc param_3467
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2368
    .lex "self", param_3466
    .lex "$/", param_3467
.annotate 'line', 2369
    set $P122, param_3467
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2370
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Var"]
    $P132 = $P131."new"("self" :named("name"))
    $P133 = $P127."new"($P132, "nqp_decontainerize PP" :named("pirop"))
.annotate 'line', 2369
    $P134 = $P122."!make"($P133)
.annotate 'line', 2368
    .return ($P134)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>" :anon :subid("581_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3469
    .param pmc param_3470
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2373
    .lex "self", param_3469
    .lex "$/", param_3470
.annotate 'line', 2374
    new $P122, "Undef"
    set $P3471, $P122
    .lex "$past", $P3471
    set $P3472, param_3470
    unless_null $P3472, vivify_2985
    $P3472 = root_new ['parrot';'Hash']
  vivify_2985:
    set $P123, $P3472["args"]
    unless_null $P123, vivify_2986
    new $P123, "Undef"
  vivify_2986:
    $P124 = $P123."ast"()
    set $P3471, $P124
.annotate 'line', 2375
    set $P123, $P3471
    unless_null $P123, vivify_2987
    new $P123, "Undef"
  vivify_2987:
    set $P3473, param_3470
    unless_null $P3473, vivify_2988
    $P3473 = root_new ['parrot';'Hash']
  vivify_2988:
    set $P124, $P3473["deflongname"]
    unless_null $P124, vivify_2989
    new $P124, "Undef"
  vivify_2989:
    set $S100, $P124
    $P123."name"($S100)
.annotate 'line', 2376
    set $P123, param_3470
    set $P124, $P3471
    unless_null $P124, vivify_2990
    new $P124, "Undef"
  vivify_2990:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2373
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>" :anon :subid("582_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3475
    .param pmc param_3476
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2379
    .const 'Sub' $P3483 = "583_1325892461.451" 
    capture_lex $P3483
    .lex "self", param_3475
    .lex "$/", param_3476
.annotate 'line', 2381
    new $P122, "Undef"
    set $P3477, $P122
    .lex "$var", $P3477
.annotate 'line', 2391
    new $P123, "Undef"
    set $P3478, $P123
    .lex "$past", $P3478
.annotate 'line', 2379
    set $P124, $P3477
    unless_null $P124, vivify_2991
    new $P124, "Undef"
  vivify_2991:
.annotate 'line', 2382
    set $P3480, param_3476
    unless_null $P3480, vivify_2992
    $P3480 = root_new ['parrot';'Hash']
  vivify_2992:
    set $P124, $P3480["name"]
    unless_null $P124, vivify_2993
    new $P124, "Undef"
  vivify_2993:
    set $S100, $P124
    $P125 = "is_lexical"($S100)
    if $P125, if_3479
.annotate 'line', 2385
    .const 'Sub' $P3483 = "583_1325892461.451" 
    capture_lex $P3483
    $P3483()
    goto if_3479_end
  if_3479:
.annotate 'line', 2383
    get_hll_global $P127, "GLOBAL"
    nqp_get_package_through_who $P128, $P127, "PAST"
    get_who $P129, $P128
    set $P130, $P129["Var"]
    set $P3481, param_3476
    unless_null $P3481, vivify_2999
    $P3481 = root_new ['parrot';'Hash']
  vivify_2999:
    set $P131, $P3481["name"]
    unless_null $P131, vivify_3000
    new $P131, "Undef"
  vivify_3000:
    set $S101, $P131
    $P132 = $P130."new"($S101 :named("name"), "lexical" :named("scope"))
    set $P3477, $P132
  if_3479_end:
.annotate 'line', 2391
    set $P124, $P3477
    unless_null $P124, vivify_3001
    new $P124, "Undef"
  vivify_3001:
    set $P3478, $P124
.annotate 'line', 2392
    set $P3490, param_3476
    unless_null $P3490, vivify_3002
    $P3490 = root_new ['parrot';'Hash']
  vivify_3002:
    set $P124, $P3490["args"]
    unless_null $P124, vivify_3003
    new $P124, "Undef"
  vivify_3003:
    unless $P124, if_3489_end
.annotate 'line', 2393
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    set $P3491, param_3476
    unless_null $P3491, vivify_3004
    $P3491 = root_new ['parrot';'Hash']
  vivify_3004:
    set $P3492, $P3491["args"]
    unless_null $P3492, vivify_3005
    $P3492 = root_new ['parrot';'ResizablePMCArray']
  vivify_3005:
    set $P127, $P3492[$I100]
    unless_null $P127, vivify_3006
    new $P127, "Undef"
  vivify_3006:
    $P128 = $P127."ast"()
    set $P3478, $P128
.annotate 'line', 2394
    set $P125, $P3478
    unless_null $P125, vivify_3007
    new $P125, "Undef"
  vivify_3007:
    set $P127, $P3477
    unless_null $P127, vivify_3008
    new $P127, "Undef"
  vivify_3008:
    $P125."unshift"($P127)
  if_3489_end:
.annotate 'line', 2396
    set $P124, param_3476
    set $P125, $P3478
    unless_null $P125, vivify_3009
    new $P125, "Undef"
  vivify_3009:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2379
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3482"  :anon :subid("583_1325892461.451") :outer("582_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2386
    $P3485 = root_new ['parrot';'ResizablePMCArray']
    set $P3484, $P3485
    .lex "@ns", $P3484
    find_lex $P3486, "$/"
    unless_null $P3486, vivify_2994
    $P3486 = root_new ['parrot';'Hash']
  vivify_2994:
    set $P3487, $P3486["name"]
    unless_null $P3487, vivify_2995
    $P3487 = root_new ['parrot';'Hash']
  vivify_2995:
    set $P127, $P3487["identifier"]
    unless_null $P127, vivify_2996
    new $P127, "Undef"
  vivify_2996:
    clone $P128, $P127
    set $P3484, $P128
.annotate 'line', 2387
    set $P3488, $P3484
    unless_null $P3488, vivify_2997
    $P3488 = root_new ['parrot';'ResizablePMCArray']
  vivify_2997:
    find_lex $P127, "$/"
    unless_null $P127, vivify_2998
    new $P127, "Undef"
  vivify_2998:
    $P128 = "lexical_package_lookup"($P3488, $P127)
    store_lex "$var", $P128
.annotate 'line', 2385
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>" :anon :subid("584_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3494
    .param pmc param_3495
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2399
    .lex "self", param_3494
    .lex "$/", param_3495
.annotate 'line', 2400
    new $P122, "Undef"
    set $P3496, $P122
    .lex "$past", $P3496
.annotate 'line', 2401
    new $P123, "Undef"
    set $P3497, $P123
    .lex "$pirop", $P3497
.annotate 'line', 2400
    set $P3499, param_3495
    unless_null $P3499, vivify_3010
    $P3499 = root_new ['parrot';'Hash']
  vivify_3010:
    set $P125, $P3499["args"]
    unless_null $P125, vivify_3011
    new $P125, "Undef"
  vivify_3011:
    if $P125, if_3498
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "PAST"
    get_who $P132, $P131
    set $P133, $P132["Op"]
    set $P134, param_3495
    unless_null $P134, vivify_3012
    new $P134, "Undef"
  vivify_3012:
    $P135 = $P133."new"($P134 :named("node"))
    set $P124, $P135
    goto if_3498_end
  if_3498:
    new $P127, "Float"
    assign $P127, 0
    set $I100, $P127
    set $P3500, param_3495
    unless_null $P3500, vivify_3013
    $P3500 = root_new ['parrot';'Hash']
  vivify_3013:
    set $P3501, $P3500["args"]
    unless_null $P3501, vivify_3014
    $P3501 = root_new ['parrot';'ResizablePMCArray']
  vivify_3014:
    set $P128, $P3501[$I100]
    unless_null $P128, vivify_3015
    new $P128, "Undef"
  vivify_3015:
    $P129 = $P128."ast"()
    set $P124, $P129
  if_3498_end:
    set $P3496, $P124
.annotate 'line', 2401
    set $P3502, param_3495
    unless_null $P3502, vivify_3016
    $P3502 = root_new ['parrot';'Hash']
  vivify_3016:
    set $P124, $P3502["op"]
    unless_null $P124, vivify_3017
    new $P124, "Undef"
  vivify_3017:
    set $S100, $P124
    new $P125, 'String'
    set $P125, $S100
    set $P3497, $P125
.annotate 'line', 2402
    set $P124, $P3497
    unless_null $P124, vivify_3018
    new $P124, "Undef"
  vivify_3018:
    set $S100, $P124
    split $P125, "__", $S100
    join $S101, " ", $P125
    new $P127, 'String'
    set $P127, $S101
    set $P3497, $P127
.annotate 'line', 2403
    set $P124, $P3496
    unless_null $P124, vivify_3019
    new $P124, "Undef"
  vivify_3019:
    set $P125, $P3497
    unless_null $P125, vivify_3020
    new $P125, "Undef"
  vivify_3020:
    $P124."pirop"($P125)
.annotate 'line', 2404
    set $P124, $P3496
    unless_null $P124, vivify_3021
    new $P124, "Undef"
  vivify_3021:
    $P124."pasttype"("pirop")
.annotate 'line', 2405
    set $P124, param_3495
    set $P125, $P3496
    unless_null $P125, vivify_3022
    new $P125, "Undef"
  vivify_3022:
    $P127 = $P124."!make"($P125)
.annotate 'line', 2399
    .return ($P127)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::const>" :anon :subid("585_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3504
    .param pmc param_3505
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2408
    .lex "self", param_3504
    .lex "$/", param_3505
.annotate 'line', 2409
    set $P122, param_3505
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Val"]
    set $P3506, param_3505
    unless_null $P3506, vivify_3023
    $P3506 = root_new ['parrot';'Hash']
  vivify_3023:
    set $P128, $P3506["const"]
    unless_null $P128, vivify_3024
    new $P128, "Undef"
  vivify_3024:
    set $S100, $P128
    set $P129, param_3505
    unless_null $P129, vivify_3025
    new $P129, "Undef"
  vivify_3025:
    $P130 = $P127."new"($S100 :named("value"), "!macro_const" :named("returns"), $P129 :named("node"))
    $P131 = $P122."!make"($P130)
.annotate 'line', 2408
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<nqp::op>" :anon :subid("586_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3508
    .param pmc param_3509
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2412
    .lex "self", param_3508
    .lex "$/", param_3509
.annotate 'line', 2413
    new $P122, "Undef"
    set $P3510, $P122
    .lex "$op", $P3510
.annotate 'line', 2414
    new $P123, "Undef"
    set $P3511, $P123
    .lex "$args", $P3511
.annotate 'line', 2415
    new $P124, "Undef"
    set $P3512, $P124
    .lex "$past", $P3512
.annotate 'line', 2413
    set $P3513, param_3509
    unless_null $P3513, vivify_3026
    $P3513 = root_new ['parrot';'Hash']
  vivify_3026:
    set $P125, $P3513["op"]
    unless_null $P125, vivify_3027
    new $P125, "Undef"
  vivify_3027:
    set $S100, $P125
    new $P127, 'String'
    set $P127, $S100
    set $P3510, $P127
.annotate 'line', 2414
    set $P3515, param_3509
    unless_null $P3515, vivify_3028
    $P3515 = root_new ['parrot';'Hash']
  vivify_3028:
    set $P127, $P3515["args"]
    unless_null $P127, vivify_3029
    new $P127, "Undef"
  vivify_3029:
    if $P127, if_3514
    new $P132, "ResizablePMCArray"
    set $P125, $P132
    goto if_3514_end
  if_3514:
    new $P128, "Float"
    assign $P128, 0
    set $I100, $P128
    set $P3516, param_3509
    unless_null $P3516, vivify_3030
    $P3516 = root_new ['parrot';'Hash']
  vivify_3030:
    set $P3517, $P3516["args"]
    unless_null $P3517, vivify_3031
    $P3517 = root_new ['parrot';'ResizablePMCArray']
  vivify_3031:
    set $P129, $P3517[$I100]
    unless_null $P129, vivify_3032
    new $P129, "Undef"
  vivify_3032:
    $P130 = $P129."ast"()
    $P131 = $P130."list"()
    set $P125, $P131
  if_3514_end:
    set $P3511, $P125
.annotate 'line', 2415
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Node"]
    set $P130, $P3511
    unless_null $P130, vivify_3033
    new $P130, "Undef"
  vivify_3033:
    set $P131, $P3510
    unless_null $P131, vivify_3034
    new $P131, "Undef"
  vivify_3034:
    set $P132, param_3509
    unless_null $P132, vivify_3035
    new $P132, "Undef"
  vivify_3035:
    $P133 = $P129."map_node"($P130 :flat, "nqp" :named("map"), $P131 :named("op"), $P132 :named("node"))
    set $P3512, $P133
.annotate 'line', 2418
    set $P125, $P3512
    unless_null $P125, vivify_3036
    new $P125, "Undef"
  vivify_3036:
    defined $I100, $P125
    if $I100, unless_3518_end
.annotate 'line', 2419
    set $P127, param_3509
    unless_null $P127, vivify_3037
    new $P127, "Undef"
  vivify_3037:
    $P128 = $P127."CURSOR"()
    new $P129, 'String'
    set $P129, "Unrecognized nqp:: opcode 'nqp::"
    set $P130, $P3510
    unless_null $P130, vivify_3038
    new $P130, "Undef"
  vivify_3038:
    concat $P131, $P129, $P130
    concat $P132, $P131, "'"
    $P128."panic"($P132)
  unless_3518_end:
.annotate 'line', 2420
    set $P125, param_3509
    set $P127, $P3512
    unless_null $P127, vivify_3039
    new $P127, "Undef"
  vivify_3039:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2412
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>" :anon :subid("587_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3520
    .param pmc param_3521
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2423
    .lex "self", param_3520
    .lex "$/", param_3521
.annotate 'line', 2424
    set $P122, param_3521
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    $P128 = $P127."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P129 = $P122."!make"($P128)
.annotate 'line', 2423
    .return ($P129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args" :anon :subid("588_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3523
    .param pmc param_3524
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2429
    .lex "self", param_3523
    .lex "$/", param_3524
    set $P122, param_3524
    set $P3525, param_3524
    unless_null $P3525, vivify_3040
    $P3525 = root_new ['parrot';'Hash']
  vivify_3040:
    set $P123, $P3525["arglist"]
    unless_null $P123, vivify_3041
    new $P123, "Undef"
  vivify_3041:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist" :anon :subid("589_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3527
    .param pmc param_3528
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2431
    .const 'Sub' $P3535 = "590_1325892461.451" 
    capture_lex $P3535
    .lex "self", param_3527
    .lex "$/", param_3528
.annotate 'line', 2432
    new $P122, "Undef"
    set $P3529, $P122
    .lex "$past", $P3529
.annotate 'line', 2440
    new $P123, "Undef"
    set $P3530, $P123
    .lex "$i", $P3530
.annotate 'line', 2441
    new $P124, "Undef"
    set $P3531, $P124
    .lex "$n", $P3531
.annotate 'line', 2432
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    set $P130, param_3528
    unless_null $P130, vivify_3042
    new $P130, "Undef"
  vivify_3042:
    $P131 = $P129."new"("call" :named("pasttype"), $P130 :named("node"))
    set $P3529, $P131
.annotate 'line', 2433
    set $P3533, param_3528
    unless_null $P3533, vivify_3043
    $P3533 = root_new ['parrot';'Hash']
  vivify_3043:
    set $P125, $P3533["EXPR"]
    unless_null $P125, vivify_3044
    new $P125, "Undef"
  vivify_3044:
    unless $P125, if_3532_end
    .const 'Sub' $P3535 = "590_1325892461.451" 
    capture_lex $P3535
    $P3535()
  if_3532_end:
.annotate 'line', 2440
    new $P125, "Float"
    assign $P125, 0
    set $P3530, $P125
.annotate 'line', 2441
    set $P125, $P3529
    unless_null $P125, vivify_3055
    new $P125, "Undef"
  vivify_3055:
    $P127 = $P125."list"()
    set $N100, $P127
    new $P128, 'Float'
    set $P128, $N100
    set $P3531, $P128
.annotate 'line', 2442
    new $P128, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P128, loop3556_handler
    push_eh $P128
  loop3556_test:
    set $P125, $P3530
    unless_null $P125, vivify_3056
    new $P125, "Undef"
  vivify_3056:
    set $N100, $P125
    set $P127, $P3531
    unless_null $P127, vivify_3057
    new $P127, "Undef"
  vivify_3057:
    set $N101, $P127
    islt $I100, $N100, $N101
    unless $I100, loop3556_done
  loop3556_redo:
.annotate 'line', 2443
    set $P128, $P3530
    unless_null $P128, vivify_3058
    new $P128, "Undef"
  vivify_3058:
    set $I101, $P128
    set $P3545, $P3529
    unless_null $P3545, vivify_3059
    $P3545 = root_new ['parrot';'ResizablePMCArray']
  vivify_3059:
    set $P129, $P3545[$I101]
    unless_null $P129, vivify_3060
    new $P129, "Undef"
  vivify_3060:
    $S100 = $P129."name"()
    iseq $I102, $S100, "&prefix:<|>"
    unless $I102, if_3544_end
.annotate 'line', 2444
    new $P130, "Float"
    assign $P130, 0
    set $I103, $P130
    set $P131, $P3530
    unless_null $P131, vivify_3061
    new $P131, "Undef"
  vivify_3061:
    set $I104, $P131
    set $P3546, $P3529
    unless_null $P3546, vivify_3062
    $P3546 = root_new ['parrot';'ResizablePMCArray']
  vivify_3062:
    set $P3547, $P3546[$I104]
    unless_null $P3547, vivify_3063
    $P3547 = root_new ['parrot';'ResizablePMCArray']
  vivify_3063:
    set $P132, $P3547[$I103]
    unless_null $P132, vivify_3064
    new $P132, "Undef"
  vivify_3064:
    set $P133, $P3530
    unless_null $P133, vivify_3065
    new $P133, "Undef"
  vivify_3065:
    set $I105, $P133
    set $P3548, $P3529
    unless_null $P3548, vivify_3066
    $P3548 = root_new ['parrot';'ResizablePMCArray']
    set $P3529, $P3548
  vivify_3066:
    set $P3548[$I105], $P132
.annotate 'line', 2445
    set $P130, $P3530
    unless_null $P130, vivify_3067
    new $P130, "Undef"
  vivify_3067:
    set $I103, $P130
    set $P3549, $P3529
    unless_null $P3549, vivify_3068
    $P3549 = root_new ['parrot';'ResizablePMCArray']
  vivify_3068:
    set $P131, $P3549[$I103]
    unless_null $P131, vivify_3069
    new $P131, "Undef"
  vivify_3069:
    $P131."flat"(1)
.annotate 'line', 2446
    set $P131, $P3530
    unless_null $P131, vivify_3070
    new $P131, "Undef"
  vivify_3070:
    set $I103, $P131
    set $P3552, $P3529
    unless_null $P3552, vivify_3071
    $P3552 = root_new ['parrot';'ResizablePMCArray']
  vivify_3071:
    set $P132, $P3552[$I103]
    unless_null $P132, vivify_3072
    new $P132, "Undef"
  vivify_3072:
    get_hll_global $P133, "GLOBAL"
    nqp_get_package_through_who $P134, $P133, "PAST"
    get_who $P135, $P134
    set $P136, $P135["Val"]
    $P137 = $P132."isa"($P136)
    if $P137, if_3551
    set $P130, $P137
    goto if_3551_end
  if_3551:
.annotate 'line', 2447
    set $P138, $P3530
    unless_null $P138, vivify_3073
    new $P138, "Undef"
  vivify_3073:
    set $I104, $P138
    set $P3553, $P3529
    unless_null $P3553, vivify_3074
    $P3553 = root_new ['parrot';'ResizablePMCArray']
  vivify_3074:
    set $P139, $P3553[$I104]
    unless_null $P139, vivify_3075
    new $P139, "Undef"
  vivify_3075:
    $S101 = $P139."name"()
    new $P140, "Float"
    assign $P140, 0
    set $I105, $P140
    new $P141, "Float"
    assign $P141, 1
    set $I106, $P141
    substr $S102, $S101, $I105, $I106
    iseq $I107, $S102, "%"
    new $P130, 'Integer'
    set $P130, $I107
  if_3551_end:
    unless $P130, if_3550_end
.annotate 'line', 2448
    set $P142, $P3530
    unless_null $P142, vivify_3076
    new $P142, "Undef"
  vivify_3076:
    set $I108, $P142
    set $P3554, $P3529
    unless_null $P3554, vivify_3077
    $P3554 = root_new ['parrot';'ResizablePMCArray']
  vivify_3077:
    set $P143, $P3554[$I108]
    unless_null $P143, vivify_3078
    new $P143, "Undef"
  vivify_3078:
    $P143."named"(1)
  if_3550_end:
  if_3544_end:
.annotate 'line', 2442
    set $P128, $P3530
    unless_null $P128, vivify_3079
    new $P128, "Undef"
  vivify_3079:
    clone $P3555, $P128
    inc $P128
  loop3556_next:
    goto loop3556_test
  loop3556_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P129, exception, 'type'
    eq $P129, .CONTROL_LOOP_NEXT, loop3556_next
    eq $P129, .CONTROL_LOOP_REDO, loop3556_redo
  loop3556_done:
    pop_eh 
.annotate 'line', 2453
    set $P125, param_3528
    set $P127, $P3529
    unless_null $P127, vivify_3080
    new $P127, "Undef"
  vivify_3080:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2431
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3534"  :anon :subid("590_1325892461.451") :outer("589_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2433
    .const 'Sub' $P3541 = "591_1325892461.451" 
    capture_lex $P3541
.annotate 'line', 2434
    new $P127, "Undef"
    set $P3536, $P127
    .lex "$expr", $P3536
    find_lex $P3537, "$/"
    unless_null $P3537, vivify_3045
    $P3537 = root_new ['parrot';'Hash']
  vivify_3045:
    set $P128, $P3537["EXPR"]
    unless_null $P128, vivify_3046
    new $P128, "Undef"
  vivify_3046:
    $P129 = $P128."ast"()
    set $P3536, $P129
.annotate 'line', 2435
    set $P130, $P3536
    unless_null $P130, vivify_3047
    new $P130, "Undef"
  vivify_3047:
    $S100 = $P130."name"()
    iseq $I100, $S100, "&infix:<,>"
    if $I100, if_3539
    new $P129, 'Integer'
    set $P129, $I100
    goto if_3539_end
  if_3539:
    set $P131, $P3536
    unless_null $P131, vivify_3048
    new $P131, "Undef"
  vivify_3048:
    $P132 = $P131."named"()
    isfalse $I101, $P132
    new $P129, 'Integer'
    set $P129, $I101
  if_3539_end:
    if $P129, if_3538
.annotate 'line', 2438
    find_lex $P134, "$past"
    unless_null $P134, vivify_3049
    new $P134, "Undef"
  vivify_3049:
    set $P135, $P3536
    unless_null $P135, vivify_3050
    new $P135, "Undef"
  vivify_3050:
    $P136 = $P134."push"($P135)
    set $P128, $P136
.annotate 'line', 2435
    goto if_3538_end
  if_3538:
.annotate 'line', 2436
    set $P134, $P3536
    unless_null $P134, vivify_3051
    new $P134, "Undef"
  vivify_3051:
    $P135 = $P134."list"()
    defined $I102, $P135
    unless $I102, for_undef_3052
    iter $P133, $P135
    new $P137, 'ExceptionHandler', [.CONTROL_LOOP_NEXT;.CONTROL_LOOP_REDO;.CONTROL_LOOP_LAST]
    set_label $P137, loop3543_handler
    push_eh $P137
  loop3543_test:
    unless $P133, loop3543_done
    shift $P136, $P133
  loop3543_redo:
    .const 'Sub' $P3541 = "591_1325892461.451" 
    capture_lex $P3541
    $P3541($P136)
  loop3543_next:
    goto loop3543_test
  loop3543_handler:
    .local pmc exception 
    .get_results (exception) 
    pop_upto_eh exception
    getattribute $P138, exception, 'type'
    eq $P138, .CONTROL_LOOP_NEXT, loop3543_next
    eq $P138, .CONTROL_LOOP_REDO, loop3543_redo
  loop3543_done:
    pop_eh 
  for_undef_3052:
.annotate 'line', 2435
    set $P128, $P133
  if_3538_end:
.annotate 'line', 2433
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3540"  :anon :subid("591_1325892461.451") :outer("590_1325892461.451")
    .param pmc param_3542
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2436
    .lex "$_", param_3542
    find_lex $P137, "$past"
    unless_null $P137, vivify_3053
    new $P137, "Undef"
  vivify_3053:
    find_lex $P138, "$_"
    unless_null $P138, vivify_3054
    new $P138, "Undef"
  vivify_3054:
    $P139 = $P137."push"($P138)
    .return ($P139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>" :anon :subid("592_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3558
    .param pmc param_3559
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2456
    .lex "self", param_3558
    .lex "$/", param_3559
    set $P122, param_3559
    set $P3560, param_3559
    unless_null $P3560, vivify_3081
    $P3560 = root_new ['parrot';'Hash']
  vivify_3081:
    set $P123, $P3560["multi_declarator"]
    unless_null $P123, vivify_3082
    new $P123, "Undef"
  vivify_3082:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>" :anon :subid("593_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3562
    .param pmc param_3563
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2458
    .lex "self", param_3562
    .lex "$/", param_3563
    set $P122, param_3563
    set $P3564, param_3563
    unless_null $P3564, vivify_3083
    $P3564 = root_new ['parrot';'Hash']
  vivify_3083:
    set $P123, $P3564["value"]
    unless_null $P123, vivify_3084
    new $P123, "Undef"
  vivify_3084:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>" :anon :subid("594_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3566
    .param pmc param_3567
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2460
    .lex "self", param_3566
    .lex "$/", param_3567
.annotate 'line', 2461
    set $P122, param_3567
.annotate 'line', 2462
    set $P3569, param_3567
    unless_null $P3569, vivify_3085
    $P3569 = root_new ['parrot';'Hash']
  vivify_3085:
    set $P124, $P3569["EXPR"]
    unless_null $P124, vivify_3086
    new $P124, "Undef"
  vivify_3086:
    if $P124, if_3568
.annotate 'line', 2463
    get_hll_global $P129, "GLOBAL"
    nqp_get_package_through_who $P130, $P129, "PAST"
    get_who $P131, $P130
    set $P132, $P131["Op"]
    set $P133, param_3567
    unless_null $P133, vivify_3087
    new $P133, "Undef"
  vivify_3087:
    $P134 = $P132."new"("list" :named("pasttype"), $P133 :named("node"))
    set $P123, $P134
.annotate 'line', 2462
    goto if_3568_end
  if_3568:
    new $P125, "Float"
    assign $P125, 0
    set $I100, $P125
    set $P3570, param_3567
    unless_null $P3570, vivify_3088
    $P3570 = root_new ['parrot';'Hash']
  vivify_3088:
    set $P3571, $P3570["EXPR"]
    unless_null $P3571, vivify_3089
    $P3571 = root_new ['parrot';'ResizablePMCArray']
  vivify_3089:
    set $P127, $P3571[$I100]
    unless_null $P127, vivify_3090
    new $P127, "Undef"
  vivify_3090:
    $P128 = $P127."ast"()
    set $P123, $P128
  if_3568_end:
    $P135 = $P122."!make"($P123)
.annotate 'line', 2460
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>" :anon :subid("595_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3573
    .param pmc param_3574
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2466
    .lex "self", param_3573
    .lex "$/", param_3574
.annotate 'line', 2467
    new $P122, "Undef"
    set $P3575, $P122
    .lex "$past", $P3575
.annotate 'line', 2466
    set $P123, $P3575
    unless_null $P123, vivify_3091
    new $P123, "Undef"
  vivify_3091:
.annotate 'line', 2468
    set $P3577, param_3574
    unless_null $P3577, vivify_3092
    $P3577 = root_new ['parrot';'Hash']
  vivify_3092:
    set $P123, $P3577["EXPR"]
    unless_null $P123, vivify_3093
    new $P123, "Undef"
  vivify_3093:
    if $P123, if_3576
.annotate 'line', 2475
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Op"]
    $P129 = $P128."new"("list" :named("pasttype"))
    set $P3575, $P129
.annotate 'line', 2474
    goto if_3576_end
  if_3576:
.annotate 'line', 2469
    new $P124, "Float"
    assign $P124, 0
    set $I100, $P124
    set $P3578, param_3574
    unless_null $P3578, vivify_3094
    $P3578 = root_new ['parrot';'Hash']
  vivify_3094:
    set $P3579, $P3578["EXPR"]
    unless_null $P3579, vivify_3095
    $P3579 = root_new ['parrot';'ResizablePMCArray']
  vivify_3095:
    set $P125, $P3579[$I100]
    unless_null $P125, vivify_3096
    new $P125, "Undef"
  vivify_3096:
    $P127 = $P125."ast"()
    set $P3575, $P127
.annotate 'line', 2470
    set $P124, $P3575
    unless_null $P124, vivify_3097
    new $P124, "Undef"
  vivify_3097:
    $S100 = $P124."name"()
    isne $I100, $S100, "&infix:<,>"
    unless $I100, if_3580_end
.annotate 'line', 2471
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
    set $P130, $P3575
    unless_null $P130, vivify_3098
    new $P130, "Undef"
  vivify_3098:
    $P131 = $P129."new"($P130, "list" :named("pasttype"))
    set $P3575, $P131
  if_3580_end:
  if_3576_end:
.annotate 'line', 2477
    set $P123, $P3575
    unless_null $P123, vivify_3099
    new $P123, "Undef"
  vivify_3099:
    $P123."name"("&circumfix:<[ ]>")
.annotate 'line', 2478
    set $P123, param_3574
    set $P124, $P3575
    unless_null $P124, vivify_3100
    new $P124, "Undef"
  vivify_3100:
    $P125 = $P123."!make"($P124)
.annotate 'line', 2466
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>" :anon :subid("596_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3582
    .param pmc param_3583
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2481
    .lex "self", param_3582
    .lex "$/", param_3583
    set $P122, param_3583
    set $P3584, param_3583
    unless_null $P3584, vivify_3101
    $P3584 = root_new ['parrot';'Hash']
  vivify_3101:
    set $P123, $P3584["quote_EXPR"]
    unless_null $P123, vivify_3102
    new $P123, "Undef"
  vivify_3102:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>" :anon :subid("597_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3586
    .param pmc param_3587
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2482
    .lex "self", param_3586
    .lex "$/", param_3587
    set $P122, param_3587
    set $P3588, param_3587
    unless_null $P3588, vivify_3103
    $P3588 = root_new ['parrot';'Hash']
  vivify_3103:
    set $P123, $P3588["quote_EXPR"]
    unless_null $P123, vivify_3104
    new $P123, "Undef"
  vivify_3104:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>" :anon :subid("598_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3590
    .param pmc param_3591
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2484
    .const 'Sub' $P3598 = "599_1325892461.451" 
    capture_lex $P3598
    .lex "self", param_3590
    .lex "$/", param_3591
.annotate 'line', 2485
    set $P3593, param_3591
    unless_null $P3593, vivify_3105
    $P3593 = root_new ['parrot';'Hash']
  vivify_3105:
    set $P3594, $P3593["pblock"]
    unless_null $P3594, vivify_3106
    $P3594 = root_new ['parrot';'Hash']
  vivify_3106:
    set $P3595, $P3594["blockoid"]
    unless_null $P3595, vivify_3107
    $P3595 = root_new ['parrot';'Hash']
  vivify_3107:
    set $P3596, $P3595["statementlist"]
    unless_null $P3596, vivify_3108
    $P3596 = root_new ['parrot';'Hash']
  vivify_3108:
    set $P123, $P3596["statement"]
    unless_null $P123, vivify_3109
    new $P123, "Undef"
  vivify_3109:
    set $N100, $P123
    set $N101, 0
    isgt $I100, $N100, $N101
    if $I100, if_3592
.annotate 'line', 2490
    set $P3603, param_3591
    unless_null $P3603, vivify_3110
    $P3603 = root_new ['parrot';'Hash']
  vivify_3110:
    set $P3604, $P3603["pblock"]
    unless_null $P3604, vivify_3111
    $P3604 = root_new ['parrot';'Hash']
  vivify_3111:
    set $P3605, $P3604["blockoid"]
    unless_null $P3605, vivify_3112
    $P3605 = root_new ['parrot';'Hash']
  vivify_3112:
    set $P129, $P3605["you_are_here"]
    unless_null $P129, vivify_3113
    new $P129, "Undef"
  vivify_3113:
    if $P129, if_3602
.annotate 'line', 2494
    set $P130, param_3591
    $P131 = "vivitype"("%")
    $P132 = $P130."!make"($P131)
.annotate 'line', 2493
    set $P127, $P132
.annotate 'line', 2490
    goto if_3602_end
  if_3602:
.annotate 'line', 2491
    set $P130, param_3591
    set $P3606, param_3591
    unless_null $P3606, vivify_3114
    $P3606 = root_new ['parrot';'Hash']
  vivify_3114:
    set $P131, $P3606["pblock"]
    unless_null $P131, vivify_3115
    new $P131, "Undef"
  vivify_3115:
    $P132 = $P131."ast"()
    $P133 = $P130."!make"($P132)
.annotate 'line', 2490
    set $P127, $P133
  if_3602_end:
    set $P122, $P127
.annotate 'line', 2485
    goto if_3592_end
  if_3592:
    .const 'Sub' $P3598 = "599_1325892461.451" 
    capture_lex $P3598
    $P125 = $P3598()
    set $P122, $P125
  if_3592_end:
.annotate 'line', 2484
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3597"  :anon :subid("599_1325892461.451") :outer("598_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2486
    new $P124, "Undef"
    set $P3599, $P124
    .lex "$past", $P3599
    find_lex $P3600, "$/"
    unless_null $P3600, vivify_3116
    $P3600 = root_new ['parrot';'Hash']
  vivify_3116:
    set $P125, $P3600["pblock"]
    unless_null $P125, vivify_3117
    new $P125, "Undef"
  vivify_3117:
    $P127 = $P125."ast"()
    set $P3599, $P127
.annotate 'line', 2487
    new $P125, "Float"
    assign $P125, 1
    set $P3601, $P3599
    unless_null $P3601, vivify_3118
    $P3601 = root_new ['parrot';'Hash']
    set $P3599, $P3601
  vivify_3118:
    set $P3601["bareblock"], $P125
.annotate 'line', 2488
    find_dynamic_lex $P125, "$/"
    set $P127, $P3599
    unless_null $P127, vivify_3119
    new $P127, "Undef"
  vivify_3119:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2485
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>" :anon :subid("600_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3608
    .param pmc param_3609
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2498
    .lex "self", param_3608
    .lex "$/", param_3609
.annotate 'line', 2499
    new $P122, "Undef"
    set $P3610, $P122
    .lex "$name", $P3610
    set $P3612, param_3609
    unless_null $P3612, vivify_3120
    $P3612 = root_new ['parrot';'Hash']
  vivify_3120:
    set $P124, $P3612["sigil"]
    unless_null $P124, vivify_3121
    new $P124, "Undef"
  vivify_3121:
    set $S100, $P124
    iseq $I100, $S100, "@"
    if $I100, if_3611
.annotate 'line', 2500
    set $P3614, param_3609
    unless_null $P3614, vivify_3122
    $P3614 = root_new ['parrot';'Hash']
  vivify_3122:
    set $P128, $P3614["sigil"]
    unless_null $P128, vivify_3123
    new $P128, "Undef"
  vivify_3123:
    set $S101, $P128
    iseq $I101, $S101, "%"
    if $I101, if_3613
    new $P130, "String"
    assign $P130, "item"
    set $P127, $P130
    goto if_3613_end
  if_3613:
    new $P129, "String"
    assign $P129, "hash"
    set $P127, $P129
  if_3613_end:
    set $P123, $P127
.annotate 'line', 2499
    goto if_3611_end
  if_3611:
    new $P125, "String"
    assign $P125, "list"
    set $P123, $P125
  if_3611_end:
    set $P3610, $P123
.annotate 'line', 2502
    set $P123, param_3609
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Op"]
    set $P129, $P3610
    unless_null $P129, vivify_3124
    new $P129, "Undef"
  vivify_3124:
    set $P3615, param_3609
    unless_null $P3615, vivify_3125
    $P3615 = root_new ['parrot';'Hash']
  vivify_3125:
    set $P130, $P3615["semilist"]
    unless_null $P130, vivify_3126
    new $P130, "Undef"
  vivify_3126:
    $P131 = $P130."ast"()
    $P132 = $P128."new"($P131, "callmethod" :named("pasttype"), $P129 :named("name"))
    $P133 = $P123."!make"($P132)
.annotate 'line', 2498
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist" :anon :subid("601_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3617
    .param pmc param_3618
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2505
    .lex "self", param_3617
    .lex "$/", param_3618
    set $P122, param_3618
    set $P3619, param_3618
    unless_null $P3619, vivify_3127
    $P3619 = root_new ['parrot';'Hash']
  vivify_3127:
    set $P123, $P3619["statement"]
    unless_null $P123, vivify_3128
    new $P123, "Undef"
  vivify_3128:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>" :anon :subid("602_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3621
    .param pmc param_3622
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2507
    .lex "self", param_3621
    .lex "$/", param_3622
.annotate 'line', 2508
    set $P122, param_3622
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    set $P3623, param_3622
    unless_null $P3623, vivify_3129
    $P3623 = root_new ['parrot';'Hash']
  vivify_3129:
    set $P128, $P3623["EXPR"]
    unless_null $P128, vivify_3130
    new $P128, "Undef"
  vivify_3130:
    $P129 = $P128."ast"()
.annotate 'line', 2510
    $P130 = "vivitype"("@")
.annotate 'line', 2508
    $P131 = $P127."new"($P129, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2507
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>" :anon :subid("603_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3625
    .param pmc param_3626
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2513
    .lex "self", param_3625
    .lex "$/", param_3626
.annotate 'line', 2514
    set $P122, param_3626
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    set $P3627, param_3626
    unless_null $P3627, vivify_3131
    $P3627 = root_new ['parrot';'Hash']
  vivify_3131:
    set $P128, $P3627["EXPR"]
    unless_null $P128, vivify_3132
    new $P128, "Undef"
  vivify_3132:
    $P129 = $P128."ast"()
.annotate 'line', 2516
    $P130 = "vivitype"("%")
.annotate 'line', 2514
    $P131 = $P127."new"($P129, "keyed" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2513
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>" :anon :subid("604_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3629
    .param pmc param_3630
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2519
    .lex "self", param_3629
    .lex "$/", param_3630
.annotate 'line', 2520
    set $P122, param_3630
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Var"]
    set $P3631, param_3630
    unless_null $P3631, vivify_3133
    $P3631 = root_new ['parrot';'Hash']
  vivify_3133:
    set $P128, $P3631["quote_EXPR"]
    unless_null $P128, vivify_3134
    new $P128, "Undef"
  vivify_3134:
    $P129 = $P128."ast"()
.annotate 'line', 2522
    $P130 = "vivitype"("%")
.annotate 'line', 2520
    $P131 = $P127."new"($P129, "keyed" :named("scope"), "Undef" :named("viviself"), $P130 :named("vivibase"))
    $P132 = $P122."!make"($P131)
.annotate 'line', 2519
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>" :anon :subid("605_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3633
    .param pmc param_3634
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2525
    .lex "self", param_3633
    .lex "$/", param_3634
.annotate 'line', 2526
    set $P122, param_3634
    set $P3635, param_3634
    unless_null $P3635, vivify_3135
    $P3635 = root_new ['parrot';'Hash']
  vivify_3135:
    set $P123, $P3635["arglist"]
    unless_null $P123, vivify_3136
    new $P123, "Undef"
  vivify_3136:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
.annotate 'line', 2525
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value" :anon :subid("606_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3637
    .param pmc param_3638
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2529
    .lex "self", param_3637
    .lex "$/", param_3638
.annotate 'line', 2530
    set $P122, param_3638
    set $P3640, param_3638
    unless_null $P3640, vivify_3137
    $P3640 = root_new ['parrot';'Hash']
  vivify_3137:
    set $P124, $P3640["quote"]
    unless_null $P124, vivify_3138
    new $P124, "Undef"
  vivify_3138:
    if $P124, if_3639
    set $P3642, param_3638
    unless_null $P3642, vivify_3139
    $P3642 = root_new ['parrot';'Hash']
  vivify_3139:
    set $P128, $P3642["number"]
    unless_null $P128, vivify_3140
    new $P128, "Undef"
  vivify_3140:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3639_end
  if_3639:
    set $P3641, param_3638
    unless_null $P3641, vivify_3141
    $P3641 = root_new ['parrot';'Hash']
  vivify_3141:
    set $P125, $P3641["quote"]
    unless_null $P125, vivify_3142
    new $P125, "Undef"
  vivify_3142:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3639_end:
    $P130 = $P122."!make"($P123)
.annotate 'line', 2529
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number" :anon :subid("607_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3644
    .param pmc param_3645
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2533
    .lex "self", param_3644
    .lex "$/", param_3645
.annotate 'line', 2534
    new $P122, "Undef"
    set $P3646, $P122
    .lex "$value", $P3646
    set $P3648, param_3645
    unless_null $P3648, vivify_3143
    $P3648 = root_new ['parrot';'Hash']
  vivify_3143:
    set $P124, $P3648["dec_number"]
    unless_null $P124, vivify_3144
    new $P124, "Undef"
  vivify_3144:
    if $P124, if_3647
    set $P3650, param_3645
    unless_null $P3650, vivify_3145
    $P3650 = root_new ['parrot';'Hash']
  vivify_3145:
    set $P128, $P3650["integer"]
    unless_null $P128, vivify_3146
    new $P128, "Undef"
  vivify_3146:
    $P129 = $P128."ast"()
    set $P123, $P129
    goto if_3647_end
  if_3647:
    set $P3649, param_3645
    unless_null $P3649, vivify_3147
    $P3649 = root_new ['parrot';'Hash']
  vivify_3147:
    set $P125, $P3649["dec_number"]
    unless_null $P125, vivify_3148
    new $P125, "Undef"
  vivify_3148:
    $P127 = $P125."ast"()
    set $P123, $P127
  if_3647_end:
    set $P3646, $P123
.annotate 'line', 2535
    set $P3652, param_3645
    unless_null $P3652, vivify_3149
    $P3652 = root_new ['parrot';'Hash']
  vivify_3149:
    set $P123, $P3652["sign"]
    unless_null $P123, vivify_3150
    new $P123, "Undef"
  vivify_3150:
    set $S100, $P123
    iseq $I100, $S100, "-"
    unless $I100, if_3651_end
    set $P124, $P3646
    unless_null $P124, vivify_3151
    new $P124, "Undef"
  vivify_3151:
    neg $P125, $P124
    set $P3646, $P125
  if_3651_end:
.annotate 'line', 2536
    set $P123, param_3645
    get_hll_global $P124, "GLOBAL"
    nqp_get_package_through_who $P125, $P124, "PAST"
    get_who $P127, $P125
    set $P128, $P127["Val"]
    set $P129, $P3646
    unless_null $P129, vivify_3152
    new $P129, "Undef"
  vivify_3152:
    $P130 = $P128."new"($P129 :named("value"))
    $P131 = $P123."!make"($P130)
.annotate 'line', 2533
    .return ($P131)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>" :anon :subid("608_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3654
    .param pmc param_3655
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2539
    .lex "self", param_3654
    .lex "$/", param_3655
    set $P122, param_3655
    set $P3656, param_3655
    unless_null $P3656, vivify_3153
    $P3656 = root_new ['parrot';'Hash']
  vivify_3153:
    set $P123, $P3656["quote_EXPR"]
    unless_null $P123, vivify_3154
    new $P123, "Undef"
  vivify_3154:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>" :anon :subid("609_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3658
    .param pmc param_3659
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2540
    .lex "self", param_3658
    .lex "$/", param_3659
    set $P122, param_3659
    set $P3660, param_3659
    unless_null $P3660, vivify_3155
    $P3660 = root_new ['parrot';'Hash']
  vivify_3155:
    set $P123, $P3660["quote_EXPR"]
    unless_null $P123, vivify_3156
    new $P123, "Undef"
  vivify_3156:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>" :anon :subid("610_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3662
    .param pmc param_3663
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2541
    .lex "self", param_3662
    .lex "$/", param_3663
    set $P122, param_3663
    set $P3664, param_3663
    unless_null $P3664, vivify_3157
    $P3664 = root_new ['parrot';'Hash']
  vivify_3157:
    set $P123, $P3664["quote_EXPR"]
    unless_null $P123, vivify_3158
    new $P123, "Undef"
  vivify_3158:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>" :anon :subid("611_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3666
    .param pmc param_3667
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2542
    .lex "self", param_3666
    .lex "$/", param_3667
    set $P122, param_3667
    set $P3668, param_3667
    unless_null $P3668, vivify_3159
    $P3668 = root_new ['parrot';'Hash']
  vivify_3159:
    set $P123, $P3668["quote_EXPR"]
    unless_null $P123, vivify_3160
    new $P123, "Undef"
  vivify_3160:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>" :anon :subid("612_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3670
    .param pmc param_3671
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2543
    .lex "self", param_3670
    .lex "$/", param_3671
    set $P122, param_3671
    set $P3672, param_3671
    unless_null $P3672, vivify_3161
    $P3672 = root_new ['parrot';'Hash']
  vivify_3161:
    set $P123, $P3672["quote_EXPR"]
    unless_null $P123, vivify_3162
    new $P123, "Undef"
  vivify_3162:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>" :anon :subid("613_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3674
    .param pmc param_3675
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2544
    .lex "self", param_3674
    .lex "$/", param_3675
.annotate 'line', 2545
    set $P122, param_3675
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    set $P3676, param_3675
    unless_null $P3676, vivify_3163
    $P3676 = root_new ['parrot';'Hash']
  vivify_3163:
    set $P128, $P3676["quote_EXPR"]
    unless_null $P128, vivify_3164
    new $P128, "Undef"
  vivify_3164:
    $P129 = $P128."ast"()
    $P130 = $P129."value"()
    set $P131, param_3675
    unless_null $P131, vivify_3165
    new $P131, "Undef"
  vivify_3165:
    $P132 = $P127."new"($P130 :named("inline"), "inline" :named("pasttype"), $P131 :named("node"))
    $P133 = $P122."!make"($P132)
.annotate 'line', 2544
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />" :anon :subid("614_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3680
    .param pmc param_3681
    .param pmc param_3682 :optional
    .param int has_param_3682 :opt_flag
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2550
    new $P3679, 'ExceptionHandler', [.CONTROL_RETURN]
    set_label $P3679, control_3678
    push_eh $P3679
    .lex "self", param_3680
    .lex "$/", param_3681
    if has_param_3682, optparam_3166
    new $P122, "Undef"
    set param_3682, $P122
  optparam_3166:
    .lex "$key", param_3682
.annotate 'line', 2557
    new $P123, "Undef"
    set $P3683, $P123
    .lex "$regex", $P3683
.annotate 'line', 2559
    new $P124, "Undef"
    set $P3684, $P124
    .lex "$past", $P3684
.annotate 'line', 2551
    set $P125, param_3682
    unless_null $P125, vivify_3167
    new $P125, "Undef"
  vivify_3167:
    set $S100, $P125
    iseq $I100, $S100, "open"
    unless $I100, if_3685_end
.annotate 'line', 2552
    null $P127
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "Regex"
    nqp_get_package_through_who $P130, $P129, "P6Regex"
    nqp_get_package_through_who $P131, $P130, "Actions"
    get_who $P132, $P131
    set $P132["$REGEXNAME"], $P127
.annotate 'line', 2553
    new $P127, "Float"
    assign $P127, 0
    set $I101, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3686, $P129["@BLOCK"]
    unless_null $P3686, vivify_3168
    $P3686 = root_new ['parrot';'ResizablePMCArray']
  vivify_3168:
    set $P130, $P3686[$I101]
    unless_null $P130, vivify_3169
    new $P130, "Undef"
  vivify_3169:
    $P130."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2554
    new $P127, "Float"
    assign $P127, 0
    set $I101, $P127
    find_lex $P128, "$?PACKAGE"
    get_who $P129, $P128
    set $P3687, $P129["@BLOCK"]
    unless_null $P3687, vivify_3170
    $P3687 = root_new ['parrot';'ResizablePMCArray']
  vivify_3170:
    set $P130, $P3687[$I101]
    unless_null $P130, vivify_3171
    new $P130, "Undef"
  vivify_3171:
    $P130."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2555
    new $P127, "Exception"
    set $P127['type'], .CONTROL_RETURN
    new $P128, "Float"
    assign $P128, 0
    setattribute $P127, 'payload', $P128
    throw $P127
  if_3685_end:
.annotate 'line', 2558
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "Regex"
    nqp_get_package_through_who $P128, $P127, "P6Regex"
    nqp_get_package_through_who $P129, $P128, "Actions"
    get_who $P130, $P129
    set $P131, $P130["buildsub"]
    set $P3688, param_3681
    unless_null $P3688, vivify_3172
    $P3688 = root_new ['parrot';'Hash']
  vivify_3172:
    set $P132, $P3688["p6regex"]
    unless_null $P132, vivify_3173
    new $P132, "Undef"
  vivify_3173:
    $P133 = $P132."ast"()
    find_lex $P134, "$?PACKAGE"
    get_who $P135, $P134
    set $P3689, $P135["@BLOCK"]
    unless_null $P3689, vivify_3174
    $P3689 = root_new ['parrot';'ResizablePMCArray']
  vivify_3174:
    $P136 = $P3689."shift"()
    $P137 = $P131($P133, $P136)
    set $P3683, $P137
.annotate 'line', 2560
    get_hll_global $P125, "GLOBAL"
    nqp_get_package_through_who $P127, $P125, "PAST"
    get_who $P128, $P127
    set $P129, $P128["Op"]
.annotate 'line', 2562
    new $P130, "ResizablePMCArray"
    push $P130, "Regex"
    push $P130, "Regex"
    set $P131, param_3681
    unless_null $P131, vivify_3175
    new $P131, "Undef"
  vivify_3175:
    $P132 = "lexical_package_lookup"($P130, $P131)
    set $P133, $P3683
    unless_null $P133, vivify_3176
    new $P133, "Undef"
  vivify_3176:
    $P134 = $P129."new"($P132, $P133, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2560
    set $P3684, $P134
.annotate 'line', 2566
    set $P125, $P3683
    unless_null $P125, vivify_3177
    new $P125, "Undef"
  vivify_3177:
    set $P3690, $P3684
    unless_null $P3690, vivify_3178
    $P3690 = root_new ['parrot';'Hash']
    set $P3684, $P3690
  vivify_3178:
    set $P3690["sink"], $P125
.annotate 'line', 2567
    set $P125, param_3681
    set $P127, $P3684
    unless_null $P127, vivify_3179
    new $P127, "Undef"
  vivify_3179:
    $P128 = $P125."!make"($P127)
.annotate 'line', 2550
    .return ($P128)
  control_3678:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P125, exception, "payload"
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>" :anon :subid("615_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3692
    .param pmc param_3693
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2570
    .lex "self", param_3692
    .lex "$/", param_3693
    set $P122, param_3693
    set $P3694, param_3693
    unless_null $P3694, vivify_3180
    $P3694 = root_new ['parrot';'Hash']
  vivify_3180:
    set $P123, $P3694["variable"]
    unless_null $P123, vivify_3181
    new $P123, "Undef"
  vivify_3181:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>" :anon :subid("616_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3696
    .param pmc param_3697
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2571
    .lex "self", param_3696
    .lex "$/", param_3697
.annotate 'line', 2572
    set $P122, param_3697
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2573
    set $P3698, param_3697
    unless_null $P3698, vivify_3182
    $P3698 = root_new ['parrot';'Hash']
  vivify_3182:
    set $P128, $P3698["block"]
    unless_null $P128, vivify_3183
    new $P128, "Undef"
  vivify_3183:
    $P129 = $P128."ast"()
    $P130 = "block_immediate"($P129)
    set $P131, param_3697
    unless_null $P131, vivify_3184
    new $P131, "Undef"
  vivify_3184:
    $P132 = $P127."new"($P130, "set S*" :named("pirop"), $P131 :named("node"))
.annotate 'line', 2572
    $P133 = $P122."!make"($P132)
.annotate 'line', 2571
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>" :anon :subid("617_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3700
    .param pmc param_3701
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2576
    .lex "self", param_3700
    .lex "$/", param_3701
    set $P122, param_3701
    $P123 = $P122."!make"("\e")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>" :anon :subid("618_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3703
    .param pmc param_3704
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2580
    .lex "self", param_3703
    .lex "$/", param_3704
    set $P122, param_3704
    set $P3705, param_3704
    unless_null $P3705, vivify_3185
    $P3705 = root_new ['parrot';'Hash']
  vivify_3185:
    set $P123, $P3705["dotty"]
    unless_null $P123, vivify_3186
    new $P123, "Undef"
  vivify_3186:
    $P124 = $P123."ast"()
    $P125 = $P122."!make"($P124)
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>" :anon :subid("619_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3707
    .param pmc param_3708
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2582
    .lex "self", param_3707
    .lex "$/", param_3708
.annotate 'line', 2583
    set $P122, param_3708
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2584
    new $P128, "ResizablePMCArray"
    push $P128, "    clone %r, %0"
    push $P128, "    inc %0"
.annotate 'line', 2583
    $P129 = $P127."new"("postfix:<++>" :named("name"), $P128 :named("inline"), "inline" :named("pasttype"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2582
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->" :anon :subid("620_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3710
    .param pmc param_3711
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2588
    .lex "self", param_3710
    .lex "$/", param_3711
.annotate 'line', 2589
    set $P122, param_3711
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2590
    new $P128, "ResizablePMCArray"
    push $P128, "    clone %r, %0"
    push $P128, "    dec %0"
.annotate 'line', 2589
    $P129 = $P127."new"("postfix:<-->" :named("name"), $P128 :named("inline"), "inline" :named("pasttype"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2588
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>" :anon :subid("621_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3713
    .param pmc param_3714
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2594
    .lex "self", param_3713
    .lex "$/", param_3714
.annotate 'line', 2595
    set $P122, param_3714
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
.annotate 'line', 2596
    get_hll_global $P128, "GLOBAL"
    nqp_get_package_through_who $P129, $P128, "PAST"
    get_who $P130, $P129
    set $P131, $P130["Var"]
    $P132 = $P131."new"("$/" :named("name"), "contextual" :named("scope"))
    set $P133, param_3714
    unless_null $P133, vivify_3187
    new $P133, "Undef"
  vivify_3187:
    $P134 = $P127."new"($P132, "callmethod" :named("pasttype"), "!make" :named("name"), $P133 :named("node"))
.annotate 'line', 2595
    $P135 = $P122."!make"($P134)
.annotate 'line', 2594
    .return ($P135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>" :anon :subid("622_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3716
    .param pmc param_3717
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2612
    .lex "self", param_3716
    .lex "$/", param_3717
    set $P122, param_3717
    unless_null $P122, vivify_3188
    new $P122, "Undef"
  vivify_3188:
    $P123 = "control"($P122, "CONTROL_LOOP_NEXT")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>" :anon :subid("623_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3719
    .param pmc param_3720
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2613
    .lex "self", param_3719
    .lex "$/", param_3720
    set $P122, param_3720
    unless_null $P122, vivify_3189
    new $P122, "Undef"
  vivify_3189:
    $P123 = "control"($P122, "CONTROL_LOOP_LAST")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>" :anon :subid("624_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3722
    .param pmc param_3723
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2614
    .lex "self", param_3722
    .lex "$/", param_3723
    set $P122, param_3723
    unless_null $P122, vivify_3190
    new $P122, "Undef"
  vivify_3190:
    $P123 = "control"($P122, "CONTROL_LOOP_REDO")
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>" :anon :subid("625_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3725
    .param pmc param_3726
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2616
    .lex "self", param_3725
    .lex "$/", param_3726
.annotate 'line', 2617
    set $P122, param_3726
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "PAST"
    get_who $P125, $P124
    set $P127, $P125["Op"]
    set $P128, param_3726
    unless_null $P128, vivify_3191
    new $P128, "Undef"
  vivify_3191:
    $P129 = $P127."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P128 :named("node"))
    $P130 = $P122."!make"($P129)
.annotate 'line', 2616
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym" :anon :subid("626_1325892461.451") :outer("446_1325892461.451")
    .param pmc param_3728
    .param pmc param_3729
    .param pmc param_3730
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2694
    .const 'Sub' $P3733 = "627_1325892461.451" 
    capture_lex $P3733
    .lex "self", param_3728
    .lex "$/", param_3729
    .lex "@name", param_3730
.annotate 'line', 2695
    new $P122, "Undef"
    set $P3731, $P122
    .lex "$known", $P3731
    new $P123, "Float"
    assign $P123, 0
    set $P3731, $P123
.annotate 'line', 2696
    .const 'Sub' $P3733 = "627_1325892461.451" 
    capture_lex $P3733
    $P3733()
.annotate 'line', 2694
    set $P123, $P3731
    unless_null $P123, vivify_3194
    new $P123, "Undef"
  vivify_3194:
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3732"  :anon :subid("627_1325892461.451") :outer("626_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2696
    new $P3737, 'ExceptionHandler'
    set_label $P3737, control_3736
    $P3737."handle_types_except"(.CONTROL_ALL)
    push_eh $P3737
.annotate 'line', 2697
    find_lex $P3734, "@name"
    unless_null $P3734, vivify_3192
    $P3734 = root_new ['parrot';'ResizablePMCArray']
  vivify_3192:
    find_lex $P123, "$/"
    unless_null $P123, vivify_3193
    new $P123, "Undef"
  vivify_3193:
    "find_sym"($P3734, $P123)
.annotate 'line', 2698
    new $P123, "Float"
    assign $P123, 1
    store_lex "$known", $P123
.annotate 'line', 2696
    pop_eh 
    goto skip_handler_3735
  control_3736:
    peek_exception $P3738
    .local pmc exception 
    .get_results (exception) 
    new $P3740, 'Integer'
    set $P3740, 1
    set exception["handled"], $P3740
    set $I3741, exception["handled"]
    eq $I3741, 1, handled_3739
    rethrow exception
  handled_3739:
    finalize $P3738
    .return (exception)
  skip_handler_3735:
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block3742"  :subid("628_1325892461.451") :outer("10_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2763
    .const 'Sub' $P3772 = "635_1325892461.451" 
    capture_lex $P3772
    .const 'Sub' $P3768 = "634_1325892461.451" 
    capture_lex $P3768
    .const 'Sub' $P3763 = "633_1325892461.451" 
    capture_lex $P3763
    .const 'Sub' $P3759 = "632_1325892461.451" 
    capture_lex $P3759
    .const 'Sub' $P3755 = "631_1325892461.451" 
    capture_lex $P3755
    .const 'Sub' $P3751 = "630_1325892461.451" 
    capture_lex $P3751
    .const 'Sub' $P3746 = "629_1325892461.451" 
    capture_lex $P3746
    .lex "$?PACKAGE", $P3744
    .lex "$?CLASS", $P3745
.annotate 'line', 2797
    .const 'Sub' $P3772 = "635_1325892461.451" 
    newclosure $P3778, $P3772
.annotate 'line', 2763
    .return ($P3778)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>" :anon :subid("629_1325892461.451") :outer("628_1325892461.451")
    .param pmc param_3747
    .param pmc param_3748
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2765
    .lex "self", param_3747
    .lex "$/", param_3748
.annotate 'line', 2766
    new $P103, "Undef"
    set $P3749, $P103
    .lex "$past", $P3749
    set $P3750, param_3748
    unless_null $P3750, vivify_3195
    $P3750 = root_new ['parrot';'Hash']
  vivify_3195:
    set $P104, $P3750["statement"]
    unless_null $P104, vivify_3196
    new $P104, "Undef"
  vivify_3196:
    $P105 = $P104."ast"()
    set $P3749, $P105
.annotate 'line', 2767
    set $P104, param_3748
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Regex"]
    set $P109, $P3749
    unless_null $P109, vivify_3197
    new $P109, "Undef"
  vivify_3197:
    set $P110, param_3748
    unless_null $P110, vivify_3198
    new $P110, "Undef"
  vivify_3198:
    $P111 = $P108."new"($P109, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P110 :named("node"))
    $P112 = $P104."!make"($P111)
.annotate 'line', 2765
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>" :anon :subid("630_1325892461.451") :outer("628_1325892461.451")
    .param pmc param_3752
    .param pmc param_3753
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2771
    .lex "self", param_3752
    .lex "$/", param_3753
.annotate 'line', 2772
    set $P103, param_3753
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    set $P3754, param_3753
    unless_null $P3754, vivify_3199
    $P3754 = root_new ['parrot';'Hash']
  vivify_3199:
    set $P108, $P3754["codeblock"]
    unless_null $P108, vivify_3200
    new $P108, "Undef"
  vivify_3200:
    $P109 = $P108."ast"()
    set $P110, param_3753
    unless_null $P110, vivify_3201
    new $P110, "Undef"
  vivify_3201:
    $P111 = $P107."new"($P109, "pastnode" :named("pasttype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2771
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>" :anon :subid("631_1325892461.451") :outer("628_1325892461.451")
    .param pmc param_3756
    .param pmc param_3757
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2776
    .lex "self", param_3756
    .lex "$/", param_3757
.annotate 'line', 2777
    set $P103, param_3757
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    set $P3758, param_3757
    unless_null $P3758, vivify_3202
    $P3758 = root_new ['parrot';'Hash']
  vivify_3202:
    set $P108, $P3758["var"]
    unless_null $P108, vivify_3203
    new $P108, "Undef"
  vivify_3203:
    $P109 = $P108."ast"()
    set $P110, param_3757
    unless_null $P110, vivify_3204
    new $P110, "Undef"
  vivify_3204:
    $P111 = $P107."new"("!INTERPOLATE", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2776
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>" :anon :subid("632_1325892461.451") :outer("628_1325892461.451")
    .param pmc param_3760
    .param pmc param_3761
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2781
    .lex "self", param_3760
    .lex "$/", param_3761
.annotate 'line', 2782
    set $P103, param_3761
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    set $P3762, param_3761
    unless_null $P3762, vivify_3205
    $P3762 = root_new ['parrot';'Hash']
  vivify_3205:
    set $P108, $P3762["codeblock"]
    unless_null $P108, vivify_3206
    new $P108, "Undef"
  vivify_3206:
    $P109 = $P108."ast"()
    set $P110, param_3761
    unless_null $P110, vivify_3207
    new $P110, "Undef"
  vivify_3207:
    $P111 = $P107."new"("!INTERPOLATE_REGEX", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2781
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>" :anon :subid("633_1325892461.451") :outer("628_1325892461.451")
    .param pmc param_3764
    .param pmc param_3765
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2786
    .lex "self", param_3764
    .lex "$/", param_3765
.annotate 'line', 2787
    set $P103, param_3765
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    set $P3766, param_3765
    unless_null $P3766, vivify_3208
    $P3766 = root_new ['parrot';'Hash']
  vivify_3208:
    set $P108, $P3766["codeblock"]
    unless_null $P108, vivify_3209
    new $P108, "Undef"
  vivify_3209:
    $P109 = $P108."ast"()
.annotate 'line', 2788
    set $P3767, param_3765
    unless_null $P3767, vivify_3210
    $P3767 = root_new ['parrot';'Hash']
  vivify_3210:
    set $P110, $P3767["zw"]
    unless_null $P110, vivify_3211
    new $P110, "Undef"
  vivify_3211:
    set $S100, $P110
    iseq $I100, $S100, "!"
.annotate 'line', 2787
    set $P111, param_3765
    unless_null $P111, vivify_3212
    new $P111, "Undef"
  vivify_3212:
    $P112 = $P107."new"($P109, "zerowidth" :named("subtype"), $I100 :named("negate"), "pastnode" :named("pasttype"), $P111 :named("node"))
    $P113 = $P103."!make"($P112)
.annotate 'line', 2786
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>" :anon :subid("634_1325892461.451") :outer("628_1325892461.451")
    .param pmc param_3769
    .param pmc param_3770
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2792
    .lex "self", param_3769
    .lex "$/", param_3770
.annotate 'line', 2793
    set $P103, param_3770
    get_hll_global $P104, "GLOBAL"
    nqp_get_package_through_who $P105, $P104, "PAST"
    get_who $P106, $P105
    set $P107, $P106["Regex"]
    set $P3771, param_3770
    unless_null $P3771, vivify_3213
    $P3771 = root_new ['parrot';'Hash']
  vivify_3213:
    set $P108, $P3771["var"]
    unless_null $P108, vivify_3214
    new $P108, "Undef"
  vivify_3214:
    $P109 = $P108."ast"()
    set $P110, param_3770
    unless_null $P110, vivify_3215
    new $P110, "Undef"
  vivify_3215:
    $P111 = $P107."new"("!INTERPOLATE_REGEX", $P109, "subrule" :named("pasttype"), "method" :named("subtype"), $P110 :named("node"))
    $P112 = $P103."!make"($P111)
.annotate 'line', 2792
    .return ($P112)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock" :anon :subid("635_1325892461.451") :outer("628_1325892461.451")
    .param pmc param_3773
    .param pmc param_3774
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2797
    .lex "self", param_3773
    .lex "$/", param_3774
.annotate 'line', 2798
    new $P103, "Undef"
    set $P3775, $P103
    .lex "$block", $P3775
.annotate 'line', 2800
    new $P104, "Undef"
    set $P3776, $P104
    .lex "$past", $P3776
.annotate 'line', 2798
    set $P3777, param_3774
    unless_null $P3777, vivify_3216
    $P3777 = root_new ['parrot';'Hash']
  vivify_3216:
    set $P105, $P3777["block"]
    unless_null $P105, vivify_3217
    new $P105, "Undef"
  vivify_3217:
    $P106 = $P105."ast"()
    set $P3775, $P106
.annotate 'line', 2799
    set $P105, $P3775
    unless_null $P105, vivify_3218
    new $P105, "Undef"
  vivify_3218:
    $P105."blocktype"("immediate")
.annotate 'line', 2801
    get_hll_global $P105, "GLOBAL"
    nqp_get_package_through_who $P106, $P105, "PAST"
    get_who $P107, $P106
    set $P108, $P107["Stmts"]
.annotate 'line', 2802
    get_hll_global $P109, "GLOBAL"
    nqp_get_package_through_who $P110, $P109, "PAST"
    get_who $P111, $P110
    set $P112, $P111["Op"]
.annotate 'line', 2803
    get_hll_global $P113, "GLOBAL"
    nqp_get_package_through_who $P114, $P113, "PAST"
    get_who $P115, $P114
    set $P116, $P115["Var"]
    $P117 = $P116."new"("$/" :named("name"))
.annotate 'line', 2804
    get_hll_global $P118, "GLOBAL"
    nqp_get_package_through_who $P119, $P118, "PAST"
    get_who $P120, $P119
    set $P121, $P120["Op"]
.annotate 'line', 2805
    get_hll_global $P122, "GLOBAL"
    nqp_get_package_through_who $P123, $P122, "PAST"
    get_who $P124, $P123
    set $P125, $P124["Var"]
    $P126 = $P125."new"(unicode:"$\x{a2}" :named("name"))
    $P127 = $P121."new"($P126, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2804
    $P128 = $P112."new"($P117, $P127, "bind_6model" :named("pasttype"))
.annotate 'line', 2802
    set $P129, $P3775
    unless_null $P129, vivify_3219
    new $P129, "Undef"
  vivify_3219:
    $P130 = $P108."new"($P128, $P129)
.annotate 'line', 2801
    set $P3776, $P130
.annotate 'line', 2813
    set $P105, param_3774
    set $P106, $P3776
    unless_null $P106, vivify_3220
    new $P106, "Undef"
  vivify_3220:
    $P107 = $P105."!make"($P106)
.annotate 'line', 2797
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block3779"  :subid("636_1325892461.451") :outer("10_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 2818
    .lex "$?PACKAGE", $P3781
    .lex "$?CLASS", $P3782
    .return ()
.end


.HLL "nqp"

.namespace []
.sub "_block3785" :load :anon :subid("637_1325892461.451")
.annotate 'file', "src\\stage2\\gen\\NQP.pm"
.annotate 'line', 1
    .const '' $P3787 = "10_1325892461.451" 
    $P110 = $P3787()
    .return ($P110)
.end

