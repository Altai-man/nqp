# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup
.end
### .include 'gen/nqp-how.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1296306514.38863")
.annotate 'line', 0
    get_hll_global $P1115, ["str"], "_block1114" 
    capture_lex $P1115
    get_hll_global $P1106, ["num"], "_block1105" 
    capture_lex $P1106
    get_hll_global $P1097, ["int"], "_block1096" 
    capture_lex $P1097
    get_hll_global $P1054, ["NQPMu"], "_block1053" 
    capture_lex $P1054
    get_hll_global $P970, ["NQPAttribute"], "_block969" 
    capture_lex $P970
    get_hll_global $P882, ["NQPNativeHOW"], "_block881" 
    capture_lex $P882
    get_hll_global $P48, ["NQPClassHOW"], "_block47" 
    capture_lex $P48
    get_hll_global $P22, ["KnowHOWAttribute"], "_block21" 
    capture_lex $P22
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, "str"
    get_hll_global $P14, "num"
    get_hll_global $P15, "int"
    get_hll_global $P16, "NQPMu"
    get_hll_global $P17, "NQPAttribute"
    get_hll_global $P18, "NQPNativeHOW"
    get_hll_global $P19, "NQPClassHOW"
    get_hll_global $P20, "KnowHOWAttribute"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 10
    get_hll_global $P22, ["KnowHOWAttribute"], "_block21" 
    capture_lex $P22
    $P22()
.annotate 'line', 26
    get_hll_global $P48, ["NQPClassHOW"], "_block47" 
    capture_lex $P48
    $P48()
.annotate 'line', 394
    get_hll_global $P882, ["NQPNativeHOW"], "_block881" 
    capture_lex $P882
    $P882()
.annotate 'line', 438
    get_hll_global $P970, ["NQPAttribute"], "_block969" 
    capture_lex $P970
    $P970()
.annotate 'line', 469
    get_hll_global $P1054, ["NQPMu"], "_block1053" 
    capture_lex $P1054
    $P1054()
.annotate 'line', 485
    get_hll_global $P1097, ["int"], "_block1096" 
    capture_lex $P1097
    $P1097()
.annotate 'line', 487
    get_hll_global $P1106, ["num"], "_block1105" 
    capture_lex $P1106
    $P1106()
.annotate 'line', 489
    get_hll_global $P1115, ["str"], "_block1114" 
    capture_lex $P1115
    $P1123 = $P1115()
.annotate 'line', 1
    .return ($P1123)
    .const 'Sub' $P1125 = "88_1296306514.38863" 
    .return ($P1125)
.end


.namespace ["KnowHOWAttribute"]
.sub "_block21"  :subid("11_1296306514.38863") :outer("10_1296306514.38863")
.annotate 'line', 10
    .const 'Sub' $P38 = "14_1296306514.38863" 
    capture_lex $P38
    .const 'Sub' $P32 = "13_1296306514.38863" 
    capture_lex $P32
    .const 'Sub' $P24 = "12_1296306514.38863" 
    capture_lex $P24
    get_global $P23, "$?CLASS"
.annotate 'line', 14
    .const 'Sub' $P32 = "13_1296306514.38863" 
    newclosure $P36, $P32
.annotate 'line', 10
    .return ($P36)
.end


.namespace ["KnowHOWAttribute"]
.sub "" :load :init :subid("post89") :outer("11_1296306514.38863")
.annotate 'line', 10
    get_hll_global $P22, ["KnowHOWAttribute"], "_block21" 
    .local pmc block
    set block, $P22
    .const 'Sub' $P38 = "14_1296306514.38863" 
    capture_lex $P38
    $P38()
.end


.namespace ["KnowHOWAttribute"]
.sub "_block37"  :anon :subid("14_1296306514.38863") :outer("11_1296306514.38863")
.annotate 'line', 10
    get_hll_global $P39, "KnowHOW"
    $P40 = $P39."new_type"("KnowHOWAttribute" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P40
    set_hll_global "KnowHOWAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P41, type_obj
    .const 'Sub' $P42 = "12_1296306514.38863" 
    $P41."add_method"(type_obj, "new", $P42)
    get_how $P43, type_obj
    .const 'Sub' $P44 = "13_1296306514.38863" 
    $P43."add_method"(type_obj, "name", $P44)
    get_how $P45, type_obj
    $P46 = $P45."compose"(type_obj)
    .return ($P46)
.end


.namespace ["KnowHOWAttribute"]
.sub "new"  :subid("12_1296306514.38863") :outer("11_1296306514.38863")
    .param pmc param_25
    .param pmc param_26 :optional :named("name")
    .param int has_param_26 :opt_flag
.annotate 'line', 11
    .lex "self", param_25
    if has_param_26, optparam_90
    new $P27, "Undef"
    set param_26, $P27
  optparam_90:
    .lex "$name", param_26
.annotate 'line', 12
    find_lex $P28, "$name"
    set $S29, $P28
    get_hll_global $P30, "KnowHOWAttribute"
    repr_box_str $P31, $S29, $P30
.annotate 'line', 11
    .return ($P31)
.end


.namespace ["KnowHOWAttribute"]
.sub "name"  :subid("13_1296306514.38863") :outer("11_1296306514.38863")
    .param pmc param_33
.annotate 'line', 14
    .lex "self", param_33
.annotate 'line', 15
    find_lex $P34, "self"
    repr_unbox_str $S35, $P34
.annotate 'line', 14
    .return ($S35)
.end


.namespace ["NQPClassHOW"]
.sub "_block47"  :subid("15_1296306514.38863") :outer("10_1296306514.38863")
.annotate 'line', 26
    .const 'Sub' $P801 = "58_1296306514.38863" 
    capture_lex $P801
    .const 'Sub' $P764 = "56_1296306514.38863" 
    capture_lex $P764
    .const 'Sub' $P728 = "54_1296306514.38863" 
    capture_lex $P728
    .const 'Sub' $P694 = "53_1296306514.38863" 
    capture_lex $P694
    .const 'Sub' $P657 = "52_1296306514.38863" 
    capture_lex $P657
    .const 'Sub' $P634 = "50_1296306514.38863" 
    capture_lex $P634
    .const 'Sub' $P628 = "49_1296306514.38863" 
    capture_lex $P628
    .const 'Sub' $P622 = "48_1296306514.38863" 
    capture_lex $P622
    .const 'Sub' $P599 = "46_1296306514.38863" 
    capture_lex $P599
    .const 'Sub' $P592 = "45_1296306514.38863" 
    capture_lex $P592
    .const 'Sub' $P578 = "44_1296306514.38863" 
    capture_lex $P578
    .const 'Sub' $P533 = "41_1296306514.38863" 
    capture_lex $P533
    .const 'Sub' $P526 = "40_1296306514.38863" 
    capture_lex $P526
    .const 'Sub' $P396 = "35_1296306514.38863" 
    capture_lex $P396
    .const 'Sub' $P359 = "34_1296306514.38863" 
    capture_lex $P359
    .const 'Sub' $P321 = "32_1296306514.38863" 
    capture_lex $P321
    .const 'Sub' $P300 = "31_1296306514.38863" 
    capture_lex $P300
    .const 'Sub' $P279 = "30_1296306514.38863" 
    capture_lex $P279
    .const 'Sub' $P260 = "29_1296306514.38863" 
    capture_lex $P260
    .const 'Sub' $P246 = "28_1296306514.38863" 
    capture_lex $P246
    .const 'Sub' $P239 = "27_1296306514.38863" 
    capture_lex $P239
    .const 'Sub' $P229 = "26_1296306514.38863" 
    capture_lex $P229
    .const 'Sub' $P92 = "19_1296306514.38863" 
    capture_lex $P92
    .const 'Sub' $P50 = "16_1296306514.38863" 
    capture_lex $P50
    get_global $P49, "$?CLASS"
.annotate 'line', 196
    .const 'Sub' $P50 = "16_1296306514.38863" 
    newclosure $P91, $P50
    .lex "compute_c3_mro", $P91
.annotate 'line', 218
    .const 'Sub' $P92 = "19_1296306514.38863" 
    newclosure $P228, $P92
    .lex "c3_merge", $P228
.annotate 'line', 142
    find_lex $P524, "compute_c3_mro"
    find_lex $P525, "c3_merge"
.annotate 'line', 381
    .const 'Sub' $P764 = "56_1296306514.38863" 
    newclosure $P799, $P764
.annotate 'line', 26
    .return ($P799)
.end


.namespace ["NQPClassHOW"]
.sub "" :load :init :subid("post91") :outer("15_1296306514.38863")
.annotate 'line', 26
    get_hll_global $P48, ["NQPClassHOW"], "_block47" 
    .local pmc block
    set block, $P48
    .const 'Sub' $P801 = "58_1296306514.38863" 
    capture_lex $P801
    $P801()
.end


.namespace ["NQPClassHOW"]
.sub "_block800"  :anon :subid("58_1296306514.38863") :outer("15_1296306514.38863")
.annotate 'line', 26
    get_hll_global $P802, "KnowHOW"
    $P803 = $P802."new_type"("NQPClassHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P803
    set_hll_global "NQPClassHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P804, type_obj
    get_hll_global $P805, "KnowHOWAttribute"
    $P806 = $P805."new"("$!name" :named("name"))
    $P804."add_attribute"(type_obj, $P806)
    get_how $P807, type_obj
    get_hll_global $P808, "KnowHOWAttribute"
    $P809 = $P808."new"("%!attributes" :named("name"))
    $P807."add_attribute"(type_obj, $P809)
    get_how $P810, type_obj
    get_hll_global $P811, "KnowHOWAttribute"
    $P812 = $P811."new"("%!methods" :named("name"))
    $P810."add_attribute"(type_obj, $P812)
    get_how $P813, type_obj
    get_hll_global $P814, "KnowHOWAttribute"
    $P815 = $P814."new"("@!multi_methods_to_incorporate" :named("name"))
    $P813."add_attribute"(type_obj, $P815)
    get_how $P816, type_obj
    get_hll_global $P817, "KnowHOWAttribute"
    $P818 = $P817."new"("@!parents" :named("name"))
    $P816."add_attribute"(type_obj, $P818)
    get_how $P819, type_obj
    get_hll_global $P820, "KnowHOWAttribute"
    $P821 = $P820."new"("@!roles" :named("name"))
    $P819."add_attribute"(type_obj, $P821)
    get_how $P822, type_obj
    get_hll_global $P823, "KnowHOWAttribute"
    $P824 = $P823."new"("@!vtable" :named("name"))
    $P822."add_attribute"(type_obj, $P824)
    get_how $P825, type_obj
    get_hll_global $P826, "KnowHOWAttribute"
    $P827 = $P826."new"("%!method-vtable-slots" :named("name"))
    $P825."add_attribute"(type_obj, $P827)
    get_how $P828, type_obj
    get_hll_global $P829, "KnowHOWAttribute"
    $P830 = $P829."new"("$!composed" :named("name"))
    $P828."add_attribute"(type_obj, $P830)
    get_how $P831, type_obj
    get_hll_global $P832, "KnowHOWAttribute"
    $P833 = $P832."new"("@!mro" :named("name"))
    $P831."add_attribute"(type_obj, $P833)
    get_how $P834, type_obj
    get_hll_global $P835, "KnowHOWAttribute"
    $P836 = $P835."new"("@!done" :named("name"))
    $P834."add_attribute"(type_obj, $P836)
    get_how $P837, type_obj
    .const 'Sub' $P838 = "26_1296306514.38863" 
    $P837."add_method"(type_obj, "new", $P838)
    get_how $P839, type_obj
    .const 'Sub' $P840 = "27_1296306514.38863" 
    $P839."add_method"(type_obj, "BUILD", $P840)
    get_how $P841, type_obj
    .const 'Sub' $P842 = "28_1296306514.38863" 
    $P841."add_method"(type_obj, "new_type", $P842)
    get_how $P843, type_obj
    .const 'Sub' $P844 = "29_1296306514.38863" 
    $P843."add_method"(type_obj, "add_method", $P844)
    get_how $P845, type_obj
    .const 'Sub' $P846 = "30_1296306514.38863" 
    $P845."add_method"(type_obj, "add_multi_method", $P846)
    get_how $P847, type_obj
    .const 'Sub' $P848 = "31_1296306514.38863" 
    $P847."add_method"(type_obj, "add_attribute", $P848)
    get_how $P849, type_obj
    .const 'Sub' $P850 = "32_1296306514.38863" 
    $P849."add_method"(type_obj, "add_parent", $P850)
    get_how $P851, type_obj
    .const 'Sub' $P852 = "34_1296306514.38863" 
    $P851."add_method"(type_obj, "compose", $P852)
    get_how $P853, type_obj
    .const 'Sub' $P854 = "35_1296306514.38863" 
    $P853."add_method"(type_obj, "incorporate_multi_candidates", $P854)
    get_how $P855, type_obj
    .const 'Sub' $P856 = "40_1296306514.38863" 
    $P855."add_method"(type_obj, "publish_type_cache", $P856)
    get_how $P857, type_obj
    .const 'Sub' $P858 = "41_1296306514.38863" 
    $P857."add_method"(type_obj, "publish_method_cache", $P858)
    get_how $P859, type_obj
    .const 'Sub' $P860 = "44_1296306514.38863" 
    $P859."add_method"(type_obj, "parents", $P860)
    get_how $P861, type_obj
    .const 'Sub' $P862 = "45_1296306514.38863" 
    $P861."add_method"(type_obj, "roles", $P862)
    get_how $P863, type_obj
    .const 'Sub' $P864 = "46_1296306514.38863" 
    $P863."add_method"(type_obj, "methods", $P864)
    get_how $P865, type_obj
    .const 'Sub' $P866 = "48_1296306514.38863" 
    $P865."add_method"(type_obj, "method_table", $P866)
    get_how $P867, type_obj
    .const 'Sub' $P868 = "49_1296306514.38863" 
    $P867."add_method"(type_obj, "name", $P868)
    get_how $P869, type_obj
    .const 'Sub' $P870 = "50_1296306514.38863" 
    $P869."add_method"(type_obj, "attributes", $P870)
    get_how $P871, type_obj
    .const 'Sub' $P872 = "52_1296306514.38863" 
    $P871."add_method"(type_obj, "isa", $P872)
    get_how $P873, type_obj
    .const 'Sub' $P874 = "53_1296306514.38863" 
    $P873."add_method"(type_obj, "does", $P874)
    get_how $P875, type_obj
    .const 'Sub' $P876 = "54_1296306514.38863" 
    $P875."add_method"(type_obj, "can", $P876)
    get_how $P877, type_obj
    .const 'Sub' $P878 = "56_1296306514.38863" 
    $P877."add_method"(type_obj, "find_method", $P878)
    get_how $P879, type_obj
    $P880 = $P879."compose"(type_obj)
    .return ($P880)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compute_c3_mro"  :subid("16_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_53
.annotate 'line', 196
    .const 'Sub' $P65 = "17_1296306514.38863" 
    capture_lex $P65
    new $P52, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P52, control_51
    push_eh $P52
    .lex "$class", param_53
.annotate 'line', 197
    $P54 = root_new ['parrot';'ResizablePMCArray']
    .lex "@immediate_parents", $P54
.annotate 'line', 200
    $P55 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P55
.annotate 'line', 197
    find_lex $P56, "$class"
    get_how $P57, $P56
    find_lex $P58, "$class"
    $P59 = $P57."parents"($P58, 1 :named("local"))
    store_lex "@immediate_parents", $P59
    find_lex $P60, "@result"
.annotate 'line', 201
    find_lex $P62, "@immediate_parents"
    set $N63, $P62
    unless $N63, if_61_end
    .const 'Sub' $P65 = "17_1296306514.38863" 
    capture_lex $P65
    $P65()
  if_61_end:
.annotate 'line', 213
    find_lex $P86, "@result"
    find_lex $P87, "$class"
    $P86."unshift"($P87)
.annotate 'line', 214
    new $P88, "Exception"
    set $P88['type'], .CONTROL_RETURN
    find_lex $P89, "@result"
    setattribute $P88, 'payload', $P89
    throw $P88
.annotate 'line', 196
    .return ()
  control_51:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P90, exception, "payload"
    .return ($P90)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block64"  :anon :subid("17_1296306514.38863") :outer("16_1296306514.38863")
.annotate 'line', 201
    .const 'Sub' $P73 = "18_1296306514.38863" 
    capture_lex $P73
.annotate 'line', 204
    $P66 = root_new ['parrot';'ResizablePMCArray']
    .lex "@merge_list", $P66
.annotate 'line', 201
    find_lex $P67, "@merge_list"
.annotate 'line', 205
    find_lex $P69, "@immediate_parents"
    defined $I70, $P69
    unless $I70, for_undef_92
    iter $P68, $P69
    new $P80, 'ExceptionHandler'
    set_addr $P80, loop79_handler
    $P80."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P80
  loop79_test:
    unless $P68, loop79_done
    shift $P71, $P68
  loop79_redo:
    .const 'Sub' $P73 = "18_1296306514.38863" 
    capture_lex $P73
    $P73($P71)
  loop79_next:
    goto loop79_test
  loop79_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P81, exception, 'type'
    eq $P81, .CONTROL_LOOP_NEXT, loop79_next
    eq $P81, .CONTROL_LOOP_REDO, loop79_redo
  loop79_done:
    pop_eh 
  for_undef_92:
.annotate 'line', 208
    find_lex $P82, "@merge_list"
    find_lex $P83, "@immediate_parents"
    $P82."push"($P83)
.annotate 'line', 209
    find_lex $P84, "@merge_list"
    $P85 = "c3_merge"($P84)
    store_lex "@result", $P85
.annotate 'line', 201
    .return ($P85)
.end


.namespace ["NQPClassHOW"]
.sub "_block72"  :anon :subid("18_1296306514.38863") :outer("17_1296306514.38863")
    .param pmc param_74
.annotate 'line', 205
    .lex "$_", param_74
.annotate 'line', 206
    find_lex $P75, "@merge_list"
    find_lex $P76, "$_"
    $P77 = "compute_c3_mro"($P76)
    $P78 = $P75."push"($P77)
.annotate 'line', 205
    .return ($P78)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "c3_merge"  :subid("19_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_95
.annotate 'line', 218
    .const 'Sub' $P188 = "24_1296306514.38863" 
    capture_lex $P188
    .const 'Sub' $P110 = "20_1296306514.38863" 
    capture_lex $P110
    new $P94, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P94, control_93
    push_eh $P94
    .lex "@merge_list", param_95
.annotate 'line', 219
    $P96 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P96
.annotate 'line', 220
    new $P97, "Undef"
    .lex "$accepted", $P97
.annotate 'line', 221
    new $P98, "Undef"
    .lex "$something_accepted", $P98
.annotate 'line', 222
    new $P99, "Undef"
    .lex "$cand_count", $P99
.annotate 'line', 265
    new $P100, "Undef"
    .lex "$i", $P100
.annotate 'line', 218
    find_lex $P101, "@result"
    find_lex $P102, "$accepted"
.annotate 'line', 221
    new $P103, "Integer"
    assign $P103, 0
    store_lex "$something_accepted", $P103
.annotate 'line', 222
    new $P104, "Integer"
    assign $P104, 0
    store_lex "$cand_count", $P104
.annotate 'line', 225
    find_lex $P106, "@merge_list"
    defined $I107, $P106
    unless $I107, for_undef_93
    iter $P105, $P106
    new $P171, 'ExceptionHandler'
    set_addr $P171, loop170_handler
    $P171."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P171
  loop170_test:
    unless $P105, loop170_done
    shift $P108, $P105
  loop170_redo:
    .const 'Sub' $P110 = "20_1296306514.38863" 
    capture_lex $P110
    $P110($P108)
  loop170_next:
    goto loop170_test
  loop170_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P172, exception, 'type'
    eq $P172, .CONTROL_LOOP_NEXT, loop170_next
    eq $P172, .CONTROL_LOOP_REDO, loop170_redo
  loop170_done:
    pop_eh 
  for_undef_93:
.annotate 'line', 255
    find_lex $P174, "$cand_count"
    set $N175, $P174
    iseq $I176, $N175, 0.0
    unless $I176, if_173_end
.annotate 'line', 256
    new $P177, "Exception"
    set $P177['type'], .CONTROL_RETURN
    find_lex $P178, "@result"
    setattribute $P177, 'payload', $P178
    throw $P177
  if_173_end:
.annotate 'line', 260
    find_lex $P180, "$something_accepted"
    if $P180, unless_179_end
.annotate 'line', 261
    die "Could not build C3 linearization: ambiguous hierarchy"
  unless_179_end:
.annotate 'line', 265
    new $P181, "Integer"
    assign $P181, 0
    store_lex "$i", $P181
.annotate 'line', 266
    new $P219, 'ExceptionHandler'
    set_addr $P219, loop218_handler
    $P219."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P219
  loop218_test:
    find_lex $P182, "$i"
    set $N183, $P182
    find_lex $P184, "@merge_list"
    set $N185, $P184
    islt $I186, $N183, $N185
    unless $I186, loop218_done
  loop218_redo:
    .const 'Sub' $P188 = "24_1296306514.38863" 
    capture_lex $P188
    $P188()
  loop218_next:
    goto loop218_test
  loop218_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P220, exception, 'type'
    eq $P220, .CONTROL_LOOP_NEXT, loop218_next
    eq $P220, .CONTROL_LOOP_REDO, loop218_redo
  loop218_done:
    pop_eh 
.annotate 'line', 279
    find_lex $P221, "@merge_list"
    $P222 = "c3_merge"($P221)
    store_lex "@result", $P222
.annotate 'line', 280
    find_lex $P223, "@result"
    find_lex $P224, "$accepted"
    $P223."unshift"($P224)
.annotate 'line', 281
    new $P225, "Exception"
    set $P225['type'], .CONTROL_RETURN
    find_lex $P226, "@result"
    setattribute $P225, 'payload', $P226
    throw $P225
.annotate 'line', 218
    .return ()
  control_93:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P227, exception, "payload"
    .return ($P227)
.end


.namespace ["NQPClassHOW"]
.sub "_block109"  :anon :subid("20_1296306514.38863") :outer("19_1296306514.38863")
    .param pmc param_112
.annotate 'line', 225
    .const 'Sub' $P119 = "21_1296306514.38863" 
    capture_lex $P119
.annotate 'line', 226
    $P111 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cand_list", $P111
    .lex "$_", param_112
    find_lex $P113, "$_"
    store_lex "@cand_list", $P113
.annotate 'line', 227
    find_lex $P116, "@cand_list"
    set $N117, $P116
    if $N117, if_115
    new $P114, 'Float'
    set $P114, $N117
    goto if_115_end
  if_115:
    .const 'Sub' $P119 = "21_1296306514.38863" 
    capture_lex $P119
    $P169 = $P119()
    set $P114, $P169
  if_115_end:
.annotate 'line', 225
    .return ($P114)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block118"  :anon :subid("21_1296306514.38863") :outer("20_1296306514.38863")
.annotate 'line', 227
    .const 'Sub' $P132 = "22_1296306514.38863" 
    capture_lex $P132
.annotate 'line', 228
    new $P120, "Undef"
    .lex "$rejected", $P120
.annotate 'line', 229
    new $P121, "Undef"
    .lex "$cand_class", $P121
.annotate 'line', 228
    new $P122, "Integer"
    assign $P122, 0
    store_lex "$rejected", $P122
.annotate 'line', 229
    find_lex $P123, "@cand_list"
    unless_null $P123, vivify_94
    $P123 = root_new ['parrot';'ResizablePMCArray']
  vivify_94:
    set $P124, $P123[0]
    unless_null $P124, vivify_95
    new $P124, "Undef"
  vivify_95:
    store_lex "$cand_class", $P124
.annotate 'line', 230
    find_lex $P125, "$cand_count"
    add $P126, $P125, 1
    store_lex "$cand_count", $P126
.annotate 'line', 231
    find_lex $P128, "@merge_list"
    defined $I129, $P128
    unless $I129, for_undef_96
    iter $P127, $P128
    new $P167, 'ExceptionHandler'
    set_addr $P167, loop166_handler
    $P167."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P167
  loop166_test:
    unless $P127, loop166_done
    shift $P130, $P127
  loop166_redo:
    .const 'Sub' $P132 = "22_1296306514.38863" 
    capture_lex $P132
    $P132($P130)
  loop166_next:
    goto loop166_test
  loop166_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P168, exception, 'type'
    eq $P168, .CONTROL_LOOP_NEXT, loop166_next
    eq $P168, .CONTROL_LOOP_REDO, loop166_redo
  loop166_done:
    pop_eh 
  for_undef_96:
.annotate 'line', 227
    .return ($P127)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block131"  :anon :subid("22_1296306514.38863") :outer("21_1296306514.38863")
    .param pmc param_133
.annotate 'line', 231
    .const 'Sub' $P139 = "23_1296306514.38863" 
    capture_lex $P139
    .lex "$_", param_133
.annotate 'line', 233
    find_lex $P135, "$_"
    find_lex $P136, "@cand_list"
    issame $I137, $P135, $P136
    if $I137, unless_134_end
    .const 'Sub' $P139 = "23_1296306514.38863" 
    capture_lex $P139
    $P139()
  unless_134_end:
.annotate 'line', 245
    find_lex $P162, "$rejected"
    unless $P162, unless_161
    set $P160, $P162
    goto unless_161_end
  unless_161:
.annotate 'line', 246
    find_lex $P163, "$cand_class"
    store_lex "$accepted", $P163
.annotate 'line', 247
    new $P164, "Integer"
    assign $P164, 1
    store_lex "$something_accepted", $P164
.annotate 'line', 248
    set $I165, .CONTROL_LOOP_LAST
    die 0, $I165
  unless_161_end:
.annotate 'line', 231
    .return ($P160)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block138"  :anon :subid("23_1296306514.38863") :outer("22_1296306514.38863")
.annotate 'line', 235
    new $P140, "Undef"
    .lex "$cur_pos", $P140
    new $P141, "Integer"
    assign $P141, 1
    store_lex "$cur_pos", $P141
.annotate 'line', 236
    new $P158, 'ExceptionHandler'
    set_addr $P158, loop157_handler
    $P158."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P158
  loop157_test:
    find_lex $P142, "$cur_pos"
    set $N143, $P142
    find_lex $P144, "$_"
    set $N145, $P144
    isle $I146, $N143, $N145
    unless $I146, loop157_done
  loop157_redo:
.annotate 'line', 237
    find_lex $P148, "$cur_pos"
    set $I149, $P148
    find_lex $P150, "$_"
    unless_null $P150, vivify_97
    $P150 = root_new ['parrot';'ResizablePMCArray']
  vivify_97:
    set $P151, $P150[$I149]
    unless_null $P151, vivify_98
    new $P151, "Undef"
  vivify_98:
    find_lex $P152, "$cand_class"
    issame $I153, $P151, $P152
    unless $I153, if_147_end
.annotate 'line', 238
    new $P154, "Integer"
    assign $P154, 1
    store_lex "$rejected", $P154
  if_147_end:
.annotate 'line', 240
    find_lex $P155, "$cur_pos"
    add $P156, $P155, 1
    store_lex "$cur_pos", $P156
  loop157_next:
.annotate 'line', 236
    goto loop157_test
  loop157_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P159, exception, 'type'
    eq $P159, .CONTROL_LOOP_NEXT, loop157_next
    eq $P159, .CONTROL_LOOP_REDO, loop157_redo
  loop157_done:
    pop_eh 
.annotate 'line', 233
    .return ($I146)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block187"  :anon :subid("24_1296306514.38863") :outer("19_1296306514.38863")
.annotate 'line', 266
    .const 'Sub' $P199 = "25_1296306514.38863" 
    capture_lex $P199
.annotate 'line', 267
    $P189 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_list", $P189
.annotate 'line', 266
    find_lex $P190, "@new_list"
.annotate 'line', 268
    find_lex $P192, "$i"
    set $I193, $P192
    find_lex $P194, "@merge_list"
    unless_null $P194, vivify_99
    $P194 = root_new ['parrot';'ResizablePMCArray']
  vivify_99:
    set $P195, $P194[$I193]
    unless_null $P195, vivify_100
    new $P195, "Undef"
  vivify_100:
    defined $I196, $P195
    unless $I196, for_undef_101
    iter $P191, $P195
    new $P210, 'ExceptionHandler'
    set_addr $P210, loop209_handler
    $P210."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P210
  loop209_test:
    unless $P191, loop209_done
    shift $P197, $P191
  loop209_redo:
    .const 'Sub' $P199 = "25_1296306514.38863" 
    capture_lex $P199
    $P199($P197)
  loop209_next:
    goto loop209_test
  loop209_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P211, exception, 'type'
    eq $P211, .CONTROL_LOOP_NEXT, loop209_next
    eq $P211, .CONTROL_LOOP_REDO, loop209_redo
  loop209_done:
    pop_eh 
  for_undef_101:
.annotate 'line', 273
    find_lex $P212, "@new_list"
    find_lex $P213, "$i"
    set $I214, $P213
    find_lex $P215, "@merge_list"
    unless_null $P215, vivify_102
    $P215 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@merge_list", $P215
  vivify_102:
    set $P215[$I214], $P212
.annotate 'line', 274
    find_lex $P216, "$i"
    add $P217, $P216, 1
    store_lex "$i", $P217
.annotate 'line', 266
    .return ($P217)
.end


.namespace ["NQPClassHOW"]
.sub "_block198"  :anon :subid("25_1296306514.38863") :outer("24_1296306514.38863")
    .param pmc param_200
.annotate 'line', 268
    .lex "$_", param_200
.annotate 'line', 269
    find_lex $P203, "$_"
    find_lex $P204, "$accepted"
    issame $I205, $P203, $P204
    unless $I205, unless_202
    new $P201, 'Integer'
    set $P201, $I205
    goto unless_202_end
  unless_202:
.annotate 'line', 270
    find_lex $P206, "@new_list"
    find_lex $P207, "$_"
    $P208 = $P206."push"($P207)
.annotate 'line', 269
    set $P201, $P208
  unless_202_end:
.annotate 'line', 268
    .return ($P201)
.end


.namespace ["NQPClassHOW"]
.sub "new"  :subid("26_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_230
    .param pmc param_231 :optional :named("name")
    .param int has_param_231 :opt_flag
.annotate 'line', 59
    .lex "self", param_230
    if has_param_231, optparam_103
    new $P232, "Undef"
    set param_231, $P232
  optparam_103:
    .lex "$name", param_231
.annotate 'line', 60
    new $P233, "Undef"
    .lex "$obj", $P233
    find_lex $P234, "self"
    repr_instance_of $P235, $P234
    store_lex "$obj", $P235
.annotate 'line', 61
    find_lex $P236, "$obj"
    find_lex $P237, "$name"
    $P236."BUILD"($P237 :named("name"))
    find_lex $P238, "$obj"
.annotate 'line', 59
    .return ($P238)
.end


.namespace ["NQPClassHOW"]
.sub "BUILD"  :subid("27_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_240
    .param pmc param_241 :optional :named("name")
    .param int has_param_241 :opt_flag
.annotate 'line', 65
    .lex "self", param_240
    if has_param_241, optparam_104
    new $P242, "Undef"
    set param_241, $P242
  optparam_104:
    .lex "$name", param_241
.annotate 'line', 66
    find_lex $P243, "$name"
    find_lex $P244, "self"
    get_global $P245, "$?CLASS"
    setattribute $P244, $P245, "$!name", $P243
.annotate 'line', 65
    .return ($P243)
.end


.namespace ["NQPClassHOW"]
.sub "new_type"  :subid("28_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_247
    .param pmc param_248 :optional :named("name")
    .param int has_param_248 :opt_flag
    .param pmc param_250 :optional :named("repr")
    .param int has_param_250 :opt_flag
.annotate 'line', 71
    .lex "self", param_247
    if has_param_248, optparam_105
    new $P249, "String"
    assign $P249, "<anon>"
    set param_248, $P249
  optparam_105:
    .lex "$name", param_248
    if has_param_250, optparam_106
    new $P251, "String"
    assign $P251, "P6opaque"
    set param_250, $P251
  optparam_106:
    .lex "$repr", param_250
.annotate 'line', 72
    new $P252, "Undef"
    .lex "$metaclass", $P252
    find_lex $P253, "self"
    find_lex $P254, "$name"
    $P255 = $P253."new"($P254 :named("name"))
    store_lex "$metaclass", $P255
.annotate 'line', 73
    find_lex $P256, "$metaclass"
    find_lex $P257, "$repr"
    set $S258, $P257
    repr_type_object_for $P259, $P256, $S258
.annotate 'line', 71
    .return ($P259)
.end


.namespace ["NQPClassHOW"]
.sub "add_method"  :subid("29_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_261
    .param pmc param_262
    .param pmc param_263
    .param pmc param_264
.annotate 'line', 76
    .lex "self", param_261
    .lex "$obj", param_262
    .lex "$name", param_263
    .lex "$code_obj", param_264
.annotate 'line', 77
    find_lex $P266, "$name"
    find_lex $P267, "self"
    get_global $P268, "$?CLASS"
    getattribute $P269, $P267, $P268, "%!methods"
    unless_null $P269, vivify_107
    $P269 = root_new ['parrot';'Hash']
  vivify_107:
    set $P270, $P269[$P266]
    unless_null $P270, vivify_108
    new $P270, "Undef"
  vivify_108:
    unless $P270, if_265_end
.annotate 'line', 78
    new $P271, "String"
    assign $P271, "This class already has a method named "
    find_lex $P272, "$name"
    concat $P273, $P271, $P272
    die $P273
  if_265_end:
.annotate 'line', 80
    find_lex $P274, "$code_obj"
    find_lex $P275, "$name"
    find_lex $P276, "self"
    get_global $P277, "$?CLASS"
    getattribute $P278, $P276, $P277, "%!methods"
    unless_null $P278, vivify_109
    $P278 = root_new ['parrot';'Hash']
    setattribute $P276, $P277, "%!methods", $P278
  vivify_109:
    set $P278[$P275], $P274
.annotate 'line', 76
    .return ($P274)
.end


.namespace ["NQPClassHOW"]
.sub "add_multi_method"  :subid("30_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_280
    .param pmc param_281
    .param pmc param_282
    .param pmc param_283
.annotate 'line', 83
    .lex "self", param_280
    .lex "$obj", param_281
    .lex "$name", param_282
    .lex "$code_obj", param_283
.annotate 'line', 89
    $P284 = root_new ['parrot';'Hash']
    .lex "%todo", $P284
.annotate 'line', 83
    find_lex $P285, "%todo"
.annotate 'line', 90
    find_lex $P286, "$name"
    find_lex $P287, "%todo"
    unless_null $P287, vivify_110
    $P287 = root_new ['parrot';'Hash']
    store_lex "%todo", $P287
  vivify_110:
    set $P287["name"], $P286
.annotate 'line', 91
    find_lex $P288, "$code_obj"
    find_lex $P289, "%todo"
    unless_null $P289, vivify_111
    $P289 = root_new ['parrot';'Hash']
    store_lex "%todo", $P289
  vivify_111:
    set $P289["code"], $P288
.annotate 'line', 92
    find_lex $P290, "%todo"
    find_lex $P291, "self"
    get_global $P292, "$?CLASS"
    getattribute $P293, $P291, $P292, "@!multi_methods_to_incorporate"
    unless_null $P293, vivify_112
    $P293 = root_new ['parrot';'ResizablePMCArray']
  vivify_112:
    set $N294, $P293
    set $I295, $N294
    find_lex $P296, "self"
    get_global $P297, "$?CLASS"
    getattribute $P298, $P296, $P297, "@!multi_methods_to_incorporate"
    unless_null $P298, vivify_113
    $P298 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P296, $P297, "@!multi_methods_to_incorporate", $P298
  vivify_113:
    set $P298[$I295], $P290
    find_lex $P299, "$code_obj"
.annotate 'line', 83
    .return ($P299)
.end


.namespace ["NQPClassHOW"]
.sub "add_attribute"  :subid("31_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_301
    .param pmc param_302
    .param pmc param_303
.annotate 'line', 96
    .lex "self", param_301
    .lex "$obj", param_302
    .lex "$meta_attr", param_303
.annotate 'line', 97
    new $P304, "Undef"
    .lex "$name", $P304
    find_lex $P305, "$meta_attr"
    $P306 = $P305."name"()
    store_lex "$name", $P306
.annotate 'line', 98
    find_lex $P308, "$name"
    find_lex $P309, "self"
    get_global $P310, "$?CLASS"
    getattribute $P311, $P309, $P310, "%!attributes"
    unless_null $P311, vivify_114
    $P311 = root_new ['parrot';'Hash']
  vivify_114:
    set $P312, $P311[$P308]
    unless_null $P312, vivify_115
    new $P312, "Undef"
  vivify_115:
    unless $P312, if_307_end
.annotate 'line', 99
    new $P313, "String"
    assign $P313, "This class already has an attribute named "
    find_lex $P314, "$name"
    concat $P315, $P313, $P314
    die $P315
  if_307_end:
.annotate 'line', 101
    find_lex $P316, "$meta_attr"
    find_lex $P317, "$name"
    find_lex $P318, "self"
    get_global $P319, "$?CLASS"
    getattribute $P320, $P318, $P319, "%!attributes"
    unless_null $P320, vivify_116
    $P320 = root_new ['parrot';'Hash']
    setattribute $P318, $P319, "%!attributes", $P320
  vivify_116:
    set $P320[$P317], $P316
.annotate 'line', 96
    .return ($P316)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_parent"  :subid("32_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_322
    .param pmc param_323
    .param pmc param_324
.annotate 'line', 104
    .const 'Sub' $P336 = "33_1296306514.38863" 
    capture_lex $P336
    .lex "self", param_322
    .lex "$obj", param_323
    .lex "$parent", param_324
.annotate 'line', 105
    find_lex $P326, "self"
    get_global $P327, "$?CLASS"
    getattribute $P328, $P326, $P327, "$!composed"
    unless_null $P328, vivify_117
    new $P328, "Undef"
  vivify_117:
    unless $P328, if_325_end
.annotate 'line', 106
    die "NQPClassHOW does not support adding parents after being composed."
  if_325_end:
.annotate 'line', 108
    find_lex $P330, "self"
    get_global $P331, "$?CLASS"
    getattribute $P332, $P330, $P331, "@!parents"
    unless_null $P332, vivify_118
    $P332 = root_new ['parrot';'ResizablePMCArray']
  vivify_118:
    defined $I333, $P332
    unless $I333, for_undef_119
    iter $P329, $P332
    new $P348, 'ExceptionHandler'
    set_addr $P348, loop347_handler
    $P348."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P348
  loop347_test:
    unless $P329, loop347_done
    shift $P334, $P329
  loop347_redo:
    .const 'Sub' $P336 = "33_1296306514.38863" 
    capture_lex $P336
    $P336($P334)
  loop347_next:
    goto loop347_test
  loop347_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P349, exception, 'type'
    eq $P349, .CONTROL_LOOP_NEXT, loop347_next
    eq $P349, .CONTROL_LOOP_REDO, loop347_redo
  loop347_done:
    pop_eh 
  for_undef_119:
.annotate 'line', 113
    find_lex $P350, "$parent"
    find_lex $P351, "self"
    get_global $P352, "$?CLASS"
    getattribute $P353, $P351, $P352, "@!parents"
    unless_null $P353, vivify_120
    $P353 = root_new ['parrot';'ResizablePMCArray']
  vivify_120:
    set $N354, $P353
    set $I355, $N354
    find_lex $P356, "self"
    get_global $P357, "$?CLASS"
    getattribute $P358, $P356, $P357, "@!parents"
    unless_null $P358, vivify_121
    $P358 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P356, $P357, "@!parents", $P358
  vivify_121:
    set $P358[$I355], $P350
.annotate 'line', 104
    .return ($P350)
.end


.namespace ["NQPClassHOW"]
.sub "_block335"  :anon :subid("33_1296306514.38863") :outer("32_1296306514.38863")
    .param pmc param_337
.annotate 'line', 108
    .lex "$_", param_337
.annotate 'line', 109
    find_lex $P340, "$_"
    find_lex $P341, "$parent"
    issame $I342, $P340, $P341
    if $I342, if_339
    new $P338, 'Integer'
    set $P338, $I342
    goto if_339_end
  if_339:
.annotate 'line', 110
    new $P343, "String"
    assign $P343, "Already have "
    find_lex $P344, "$parent"
    concat $P345, $P343, $P344
    concat $P346, $P345, " as a parent class."
    die $P346
  if_339_end:
.annotate 'line', 108
    .return ($P338)
.end


.namespace ["NQPClassHOW"]
.sub "compose"  :subid("34_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_360
    .param pmc param_361
.annotate 'line', 116
    .lex "self", param_360
    .lex "$obj", param_361
.annotate 'line', 121
    find_lex $P365, "self"
    get_global $P366, "$?CLASS"
    getattribute $P367, $P365, $P366, "@!parents"
    unless_null $P367, vivify_122
    $P367 = root_new ['parrot';'ResizablePMCArray']
  vivify_122:
    set $N368, $P367
    iseq $I369, $N368, 0.0
    if $I369, if_364
    new $P363, 'Integer'
    set $P363, $I369
    goto if_364_end
  if_364:
    find_lex $P370, "self"
    get_global $P371, "$?CLASS"
    getattribute $P372, $P370, $P371, "$!name"
    unless_null $P372, vivify_123
    new $P372, "Undef"
  vivify_123:
    set $S373, $P372
    isne $I374, $S373, "NQPMu"
    new $P363, 'Integer'
    set $P363, $I374
  if_364_end:
    unless $P363, if_362_end
.annotate 'line', 122
    find_lex $P375, "self"
    find_lex $P376, "$obj"
    get_hll_global $P377, "NQPMu"
    $P375."add_parent"($P376, $P377)
  if_362_end:
.annotate 'line', 127
    find_lex $P379, "self"
    get_global $P380, "$?CLASS"
    getattribute $P381, $P379, $P380, "$!composed"
    unless_null $P381, vivify_124
    new $P381, "Undef"
  vivify_124:
    if $P381, unless_378_end
.annotate 'line', 128
    find_lex $P382, "$obj"
    $P383 = "compute_c3_mro"($P382)
    find_lex $P384, "self"
    get_global $P385, "$?CLASS"
    setattribute $P384, $P385, "@!mro", $P383
.annotate 'line', 129
    new $P386, "Integer"
    assign $P386, 1
    find_lex $P387, "self"
    get_global $P388, "$?CLASS"
    setattribute $P387, $P388, "$!composed", $P386
  unless_378_end:
.annotate 'line', 133
    find_lex $P389, "self"
    find_lex $P390, "$obj"
    $P389."incorporate_multi_candidates"($P390)
.annotate 'line', 136
    find_lex $P391, "self"
    find_lex $P392, "$obj"
    $P391."publish_type_cache"($P392)
.annotate 'line', 137
    find_lex $P393, "self"
    find_lex $P394, "$obj"
    $P393."publish_method_cache"($P394)
    find_lex $P395, "$obj"
.annotate 'line', 116
    .return ($P395)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "incorporate_multi_candidates"  :subid("35_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_397
    .param pmc param_398
.annotate 'line', 142
    .const 'Sub' $P413 = "36_1296306514.38863" 
    capture_lex $P413
    .lex "self", param_397
    .lex "$obj", param_398
.annotate 'line', 143
    new $P399, "Undef"
    .lex "$num_todo", $P399
.annotate 'line', 144
    new $P400, "Undef"
    .lex "$i", $P400
.annotate 'line', 143
    find_lex $P401, "self"
    get_global $P402, "$?CLASS"
    getattribute $P403, $P401, $P402, "@!multi_methods_to_incorporate"
    unless_null $P403, vivify_125
    $P403 = root_new ['parrot';'ResizablePMCArray']
  vivify_125:
    set $N404, $P403
    new $P405, 'Float'
    set $P405, $N404
    store_lex "$num_todo", $P405
.annotate 'line', 144
    new $P406, "Integer"
    assign $P406, 0
    store_lex "$i", $P406
.annotate 'line', 145
    new $P522, 'ExceptionHandler'
    set_addr $P522, loop521_handler
    $P522."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P522
  loop521_test:
    find_lex $P407, "$i"
    set $N408, $P407
    find_lex $P409, "$num_todo"
    set $N410, $P409
    isne $I411, $N408, $N410
    unless $I411, loop521_done
  loop521_redo:
    .const 'Sub' $P413 = "36_1296306514.38863" 
    capture_lex $P413
    $P413()
  loop521_next:
    goto loop521_test
  loop521_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P523, exception, 'type'
    eq $P523, .CONTROL_LOOP_NEXT, loop521_next
    eq $P523, .CONTROL_LOOP_REDO, loop521_redo
  loop521_done:
    pop_eh 
.annotate 'line', 142
    .return ($I411)
.end


.namespace ["NQPClassHOW"]
.sub "_block412"  :anon :subid("36_1296306514.38863") :outer("35_1296306514.38863")
.annotate 'line', 145
    .const 'Sub' $P449 = "37_1296306514.38863" 
    capture_lex $P449
.annotate 'line', 147
    new $P414, "Undef"
    .lex "$name", $P414
.annotate 'line', 148
    new $P415, "Undef"
    .lex "$code", $P415
.annotate 'line', 152
    new $P416, "Undef"
    .lex "$dispatcher", $P416
.annotate 'line', 147
    find_lex $P417, "$i"
    set $I418, $P417
    find_lex $P419, "self"
    get_global $P420, "$?CLASS"
    getattribute $P421, $P419, $P420, "@!multi_methods_to_incorporate"
    unless_null $P421, vivify_126
    $P421 = root_new ['parrot';'ResizablePMCArray']
  vivify_126:
    set $P422, $P421[$I418]
    unless_null $P422, vivify_127
    $P422 = root_new ['parrot';'Hash']
  vivify_127:
    set $P423, $P422["name"]
    unless_null $P423, vivify_128
    new $P423, "Undef"
  vivify_128:
    store_lex "$name", $P423
.annotate 'line', 148
    find_lex $P424, "$i"
    set $I425, $P424
    find_lex $P426, "self"
    get_global $P427, "$?CLASS"
    getattribute $P428, $P426, $P427, "@!multi_methods_to_incorporate"
    unless_null $P428, vivify_129
    $P428 = root_new ['parrot';'ResizablePMCArray']
  vivify_129:
    set $P429, $P428[$I425]
    unless_null $P429, vivify_130
    $P429 = root_new ['parrot';'Hash']
  vivify_130:
    set $P430, $P429["code"]
    unless_null $P430, vivify_131
    new $P430, "Undef"
  vivify_131:
    store_lex "$code", $P430
.annotate 'line', 152
    find_lex $P431, "$name"
    find_lex $P432, "self"
    get_global $P433, "$?CLASS"
    getattribute $P434, $P432, $P433, "%!methods"
    unless_null $P434, vivify_132
    $P434 = root_new ['parrot';'Hash']
  vivify_132:
    set $P435, $P434[$P431]
    unless_null $P435, vivify_133
    new $P435, "Undef"
  vivify_133:
    store_lex "$dispatcher", $P435
.annotate 'line', 153
    find_lex $P437, "$dispatcher"
    defined $I438, $P437
    if $I438, if_436
.annotate 'line', 163
    .const 'Sub' $P449 = "37_1296306514.38863" 
    capture_lex $P449
    $P449()
    goto if_436_end
  if_436:
.annotate 'line', 156
    find_lex $P440, "$dispatcher"
    is_dispatcher $I441, $P440
    if $I441, if_439
.annotate 'line', 160
    new $P444, 'String'
    set $P444, "Cannot have a multi candidate for "
    find_lex $P445, "$name"
    concat $P446, $P444, $P445
    concat $P447, $P446, " when an only method is also in the class"
    die $P447
.annotate 'line', 159
    goto if_439_end
  if_439:
.annotate 'line', 157
    find_lex $P442, "$dispatcher"
    find_lex $P443, "$code"
    push_dispatchee $P442, $P443
  if_439_end:
  if_436_end:
.annotate 'line', 191
    find_lex $P519, "$i"
    add $P520, $P519, 1
    store_lex "$i", $P520
.annotate 'line', 145
    .return ($P520)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block448"  :anon :subid("37_1296306514.38863") :outer("36_1296306514.38863")
.annotate 'line', 163
    .const 'Sub' $P466 = "38_1296306514.38863" 
    capture_lex $P466
.annotate 'line', 165
    new $P450, "Undef"
    .lex "$j", $P450
.annotate 'line', 166
    new $P451, "Undef"
    .lex "$found", $P451
.annotate 'line', 165
    new $P452, "Integer"
    assign $P452, 1
    store_lex "$j", $P452
.annotate 'line', 166
    new $P453, "Integer"
    assign $P453, 0
    store_lex "$found", $P453
.annotate 'line', 167
    new $P510, 'ExceptionHandler'
    set_addr $P510, loop509_handler
    $P510."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P510
  loop509_test:
    find_lex $P456, "$j"
    set $N457, $P456
    find_lex $P458, "self"
    get_global $P459, "$?CLASS"
    getattribute $P460, $P458, $P459, "@!mro"
    unless_null $P460, vivify_134
    $P460 = root_new ['parrot';'ResizablePMCArray']
  vivify_134:
    set $N461, $P460
    isne $I462, $N457, $N461
    if $I462, if_455
    new $P454, 'Integer'
    set $P454, $I462
    goto if_455_end
  if_455:
    find_lex $P463, "$found"
    isfalse $I464, $P463
    new $P454, 'Integer'
    set $P454, $I464
  if_455_end:
    unless $P454, loop509_done
  loop509_redo:
    .const 'Sub' $P466 = "38_1296306514.38863" 
    capture_lex $P466
    $P466()
  loop509_next:
    goto loop509_test
  loop509_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P511, exception, 'type'
    eq $P511, .CONTROL_LOOP_NEXT, loop509_next
    eq $P511, .CONTROL_LOOP_REDO, loop509_redo
  loop509_done:
    pop_eh 
.annotate 'line', 187
    find_lex $P514, "$found"
    unless $P514, unless_513
    set $P512, $P514
    goto unless_513_end
  unless_513:
.annotate 'line', 188
    new $P515, 'String'
    set $P515, "Could not find a proto for multi "
    find_lex $P516, "$name"
    concat $P517, $P515, $P516
    concat $P518, $P517, ", and proto generation is NYI"
    die $P518
  unless_513_end:
.annotate 'line', 163
    .return ($P512)
.end


.namespace ["NQPClassHOW"]
.sub "_block465"  :anon :subid("38_1296306514.38863") :outer("37_1296306514.38863")
.annotate 'line', 167
    .const 'Sub' $P490 = "39_1296306514.38863" 
    capture_lex $P490
.annotate 'line', 168
    new $P467, "Undef"
    .lex "$parent", $P467
.annotate 'line', 169
    $P468 = root_new ['parrot';'Hash']
    .lex "%meths", $P468
.annotate 'line', 170
    new $P469, "Undef"
    .lex "$dispatcher", $P469
.annotate 'line', 168
    find_lex $P470, "$j"
    set $I471, $P470
    find_lex $P472, "self"
    get_global $P473, "$?CLASS"
    getattribute $P474, $P472, $P473, "@!mro"
    unless_null $P474, vivify_135
    $P474 = root_new ['parrot';'ResizablePMCArray']
  vivify_135:
    set $P475, $P474[$I471]
    unless_null $P475, vivify_136
    new $P475, "Undef"
  vivify_136:
    store_lex "$parent", $P475
.annotate 'line', 169
    find_lex $P476, "$parent"
    get_how $P477, $P476
    find_lex $P478, "$parent"
    $P479 = $P477."method_table"($P478)
    store_lex "%meths", $P479
.annotate 'line', 170
    find_lex $P480, "$name"
    find_lex $P481, "%meths"
    unless_null $P481, vivify_137
    $P481 = root_new ['parrot';'Hash']
  vivify_137:
    set $P482, $P481[$P480]
    unless_null $P482, vivify_138
    new $P482, "Undef"
  vivify_138:
    store_lex "$dispatcher", $P482
.annotate 'line', 171
    find_lex $P484, "$dispatcher"
    defined $I485, $P484
    unless $I485, if_483_end
.annotate 'line', 174
    find_lex $P487, "$dispatcher"
    is_dispatcher $I488, $P487
    if $I488, if_486
.annotate 'line', 182
    new $P503, 'String'
    set $P503, "Could not find a proto for multi "
    find_lex $P504, "$name"
    concat $P505, $P503, $P504
    concat $P506, $P505, " (it may exist, but an only is hiding it if so)"
    die $P506
.annotate 'line', 181
    goto if_486_end
  if_486:
.annotate 'line', 174
    .const 'Sub' $P490 = "39_1296306514.38863" 
    capture_lex $P490
    $P490()
  if_486_end:
  if_483_end:
.annotate 'line', 185
    find_lex $P507, "$j"
    add $P508, $P507, 1
    store_lex "$j", $P508
.annotate 'line', 167
    .return ($P508)
.end


.namespace ["NQPClassHOW"]
.sub "_block489"  :anon :subid("39_1296306514.38863") :outer("38_1296306514.38863")
.annotate 'line', 176
    $P491 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_dispatchees", $P491
.annotate 'line', 174
    find_lex $P492, "@new_dispatchees"
.annotate 'line', 177
    find_lex $P493, "$code"
    find_lex $P494, "@new_dispatchees"
    unless_null $P494, vivify_139
    $P494 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@new_dispatchees", $P494
  vivify_139:
    set $P494[0], $P493
.annotate 'line', 178
    find_lex $P495, "$dispatcher"
    find_lex $P496, "@new_dispatchees"
    create_dispatch_and_add_candidates $P497, $P495, $P496
    find_lex $P498, "$name"
    find_lex $P499, "self"
    get_global $P500, "$?CLASS"
    getattribute $P501, $P499, $P500, "%!methods"
    unless_null $P501, vivify_140
    $P501 = root_new ['parrot';'Hash']
    setattribute $P499, $P500, "%!methods", $P501
  vivify_140:
    set $P501[$P498], $P497
.annotate 'line', 179
    new $P502, "Integer"
    assign $P502, 1
    store_lex "$found", $P502
.annotate 'line', 174
    .return ($P502)
.end


.namespace ["NQPClassHOW"]
.sub "publish_type_cache"  :subid("40_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_527
    .param pmc param_528
.annotate 'line', 284
    .lex "self", param_527
    .lex "$obj", param_528
.annotate 'line', 286
    find_lex $P529, "$obj"
    find_lex $P530, "self"
    get_global $P531, "$?CLASS"
    getattribute $P532, $P530, $P531, "@!mro"
    unless_null $P532, vivify_141
    $P532 = root_new ['parrot';'ResizablePMCArray']
  vivify_141:
    publish_type_check_cache $P529, $P532
.annotate 'line', 284
    .return ()
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_method_cache"  :subid("41_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_534
    .param pmc param_535
.annotate 'line', 289
    .const 'Sub' $P545 = "42_1296306514.38863" 
    capture_lex $P545
    .lex "self", param_534
    .lex "$obj", param_535
.annotate 'line', 292
    $P536 = root_new ['parrot';'Hash']
    .lex "%cache", $P536
.annotate 'line', 289
    find_lex $P537, "%cache"
.annotate 'line', 293
    find_lex $P539, "self"
    get_global $P540, "$?CLASS"
    getattribute $P541, $P539, $P540, "@!mro"
    unless_null $P541, vivify_142
    $P541 = root_new ['parrot';'ResizablePMCArray']
  vivify_142:
    defined $I542, $P541
    unless $I542, for_undef_143
    iter $P538, $P541
    new $P574, 'ExceptionHandler'
    set_addr $P574, loop573_handler
    $P574."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P574
  loop573_test:
    unless $P538, loop573_done
    shift $P543, $P538
  loop573_redo:
    .const 'Sub' $P545 = "42_1296306514.38863" 
    capture_lex $P545
    $P545($P543)
  loop573_next:
    goto loop573_test
  loop573_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P575, exception, 'type'
    eq $P575, .CONTROL_LOOP_NEXT, loop573_next
    eq $P575, .CONTROL_LOOP_REDO, loop573_redo
  loop573_done:
    pop_eh 
  for_undef_143:
.annotate 'line', 301
    find_lex $P576, "$obj"
    find_lex $P577, "%cache"
    publish_method_cache $P576, $P577
.annotate 'line', 289
    .return ()
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block544"  :anon :subid("42_1296306514.38863") :outer("41_1296306514.38863")
    .param pmc param_547
.annotate 'line', 293
    .const 'Sub' $P557 = "43_1296306514.38863" 
    capture_lex $P557
.annotate 'line', 294
    $P546 = root_new ['parrot';'Hash']
    .lex "%methods", $P546
    .lex "$_", param_547
    find_lex $P548, "$_"
    get_how $P549, $P548
    find_lex $P550, "$_"
    $P551 = $P549."method_table"($P550)
    store_lex "%methods", $P551
.annotate 'line', 295
    find_lex $P553, "%methods"
    defined $I554, $P553
    unless $I554, for_undef_144
    iter $P552, $P553
    new $P571, 'ExceptionHandler'
    set_addr $P571, loop570_handler
    $P571."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P571
  loop570_test:
    unless $P552, loop570_done
    shift $P555, $P552
  loop570_redo:
    .const 'Sub' $P557 = "43_1296306514.38863" 
    capture_lex $P557
    $P557($P555)
  loop570_next:
    goto loop570_test
  loop570_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P572, exception, 'type'
    eq $P572, .CONTROL_LOOP_NEXT, loop570_next
    eq $P572, .CONTROL_LOOP_REDO, loop570_redo
  loop570_done:
    pop_eh 
  for_undef_144:
.annotate 'line', 293
    .return ($P552)
.end


.namespace ["NQPClassHOW"]
.sub "_block556"  :anon :subid("43_1296306514.38863") :outer("42_1296306514.38863")
    .param pmc param_558
.annotate 'line', 295
    .lex "$_", param_558
.annotate 'line', 296
    find_lex $P561, "$_"
    $P562 = $P561."key"()
    find_lex $P563, "%cache"
    unless_null $P563, vivify_145
    $P563 = root_new ['parrot';'Hash']
  vivify_145:
    set $P564, $P563[$P562]
    unless_null $P564, vivify_146
    new $P564, "Undef"
  vivify_146:
    unless $P564, unless_560
    set $P559, $P564
    goto unless_560_end
  unless_560:
.annotate 'line', 297
    find_lex $P565, "$_"
    $P566 = $P565."value"()
    find_lex $P567, "$_"
    $P568 = $P567."key"()
    find_lex $P569, "%cache"
    unless_null $P569, vivify_147
    $P569 = root_new ['parrot';'Hash']
    store_lex "%cache", $P569
  vivify_147:
    set $P569[$P568], $P566
.annotate 'line', 296
    set $P559, $P566
  unless_560_end:
.annotate 'line', 295
    .return ($P559)
.end


.namespace ["NQPClassHOW"]
.sub "parents"  :subid("44_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_579
    .param pmc param_580
    .param pmc param_581 :optional :named("local")
    .param int has_param_581 :opt_flag
.annotate 'line', 308
    .lex "self", param_579
    .lex "$obj", param_580
    if has_param_581, optparam_148
    new $P582, "Undef"
    set param_581, $P582
  optparam_148:
    .lex "$local", param_581
.annotate 'line', 309
    find_lex $P585, "$local"
    if $P585, if_584
    find_lex $P589, "self"
    get_global $P590, "$?CLASS"
    getattribute $P591, $P589, $P590, "@!mro"
    unless_null $P591, vivify_149
    $P591 = root_new ['parrot';'ResizablePMCArray']
  vivify_149:
    set $P583, $P591
    goto if_584_end
  if_584:
    find_lex $P586, "self"
    get_global $P587, "$?CLASS"
    getattribute $P588, $P586, $P587, "@!parents"
    unless_null $P588, vivify_150
    $P588 = root_new ['parrot';'ResizablePMCArray']
  vivify_150:
    set $P583, $P588
  if_584_end:
.annotate 'line', 308
    .return ($P583)
.end


.namespace ["NQPClassHOW"]
.sub "roles"  :subid("45_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_593
    .param pmc param_594
    .param pmc param_595 :named("local")
.annotate 'line', 312
    .lex "self", param_593
    .lex "$obj", param_594
    .lex "$local", param_595
    find_lex $P596, "self"
    get_global $P597, "$?CLASS"
    getattribute $P598, $P596, $P597, "@!roles"
    unless_null $P598, vivify_151
    $P598 = root_new ['parrot';'ResizablePMCArray']
  vivify_151:
    .return ($P598)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("46_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_600
    .param pmc param_601
    .param pmc param_602 :named("local")
.annotate 'line', 316
    .const 'Sub' $P612 = "47_1296306514.38863" 
    capture_lex $P612
    .lex "self", param_600
    .lex "$obj", param_601
    .lex "$local", param_602
.annotate 'line', 317
    $P603 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P603
.annotate 'line', 316
    find_lex $P604, "@meths"
.annotate 'line', 318
    find_lex $P606, "self"
    get_global $P607, "$?CLASS"
    getattribute $P608, $P606, $P607, "%!methods"
    unless_null $P608, vivify_152
    $P608 = root_new ['parrot';'Hash']
  vivify_152:
    defined $I609, $P608
    unless $I609, for_undef_153
    iter $P605, $P608
    new $P619, 'ExceptionHandler'
    set_addr $P619, loop618_handler
    $P619."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P619
  loop618_test:
    unless $P605, loop618_done
    shift $P610, $P605
  loop618_redo:
    .const 'Sub' $P612 = "47_1296306514.38863" 
    capture_lex $P612
    $P612($P610)
  loop618_next:
    goto loop618_test
  loop618_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P620, exception, 'type'
    eq $P620, .CONTROL_LOOP_NEXT, loop618_next
    eq $P620, .CONTROL_LOOP_REDO, loop618_redo
  loop618_done:
    pop_eh 
  for_undef_153:
    find_lex $P621, "@meths"
.annotate 'line', 316
    .return ($P621)
.end


.namespace ["NQPClassHOW"]
.sub "_block611"  :anon :subid("47_1296306514.38863") :outer("46_1296306514.38863")
    .param pmc param_613
.annotate 'line', 318
    .lex "$_", param_613
.annotate 'line', 319
    find_lex $P614, "@meths"
    find_lex $P615, "$_"
    $P616 = $P615."value"()
    $P617 = $P614."push"($P616)
.annotate 'line', 318
    .return ($P617)
.end


.namespace ["NQPClassHOW"]
.sub "method_table"  :subid("48_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_623
    .param pmc param_624
.annotate 'line', 324
    .lex "self", param_623
    .lex "$obj", param_624
    find_lex $P625, "self"
    get_global $P626, "$?CLASS"
    getattribute $P627, $P625, $P626, "%!methods"
    unless_null $P627, vivify_154
    $P627 = root_new ['parrot';'Hash']
  vivify_154:
    .return ($P627)
.end


.namespace ["NQPClassHOW"]
.sub "name"  :subid("49_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_629
    .param pmc param_630
.annotate 'line', 328
    .lex "self", param_629
    .lex "$obj", param_630
    find_lex $P631, "self"
    get_global $P632, "$?CLASS"
    getattribute $P633, $P631, $P632, "$!name"
    unless_null $P633, vivify_155
    new $P633, "Undef"
  vivify_155:
    .return ($P633)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("50_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_635
    .param pmc param_636
    .param pmc param_637 :named("local")
.annotate 'line', 332
    .const 'Sub' $P647 = "51_1296306514.38863" 
    capture_lex $P647
    .lex "self", param_635
    .lex "$obj", param_636
    .lex "$local", param_637
.annotate 'line', 333
    $P638 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P638
.annotate 'line', 332
    find_lex $P639, "@attrs"
.annotate 'line', 334
    find_lex $P641, "self"
    get_global $P642, "$?CLASS"
    getattribute $P643, $P641, $P642, "%!attributes"
    unless_null $P643, vivify_156
    $P643 = root_new ['parrot';'Hash']
  vivify_156:
    defined $I644, $P643
    unless $I644, for_undef_157
    iter $P640, $P643
    new $P654, 'ExceptionHandler'
    set_addr $P654, loop653_handler
    $P654."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P654
  loop653_test:
    unless $P640, loop653_done
    shift $P645, $P640
  loop653_redo:
    .const 'Sub' $P647 = "51_1296306514.38863" 
    capture_lex $P647
    $P647($P645)
  loop653_next:
    goto loop653_test
  loop653_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P655, exception, 'type'
    eq $P655, .CONTROL_LOOP_NEXT, loop653_next
    eq $P655, .CONTROL_LOOP_REDO, loop653_redo
  loop653_done:
    pop_eh 
  for_undef_157:
    find_lex $P656, "@attrs"
.annotate 'line', 332
    .return ($P656)
.end


.namespace ["NQPClassHOW"]
.sub "_block646"  :anon :subid("51_1296306514.38863") :outer("50_1296306514.38863")
    .param pmc param_648
.annotate 'line', 334
    .lex "$_", param_648
.annotate 'line', 335
    find_lex $P649, "@attrs"
    find_lex $P650, "$_"
    $P651 = $P650."value"()
    $P652 = $P649."push"($P651)
.annotate 'line', 334
    .return ($P652)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "isa"  :subid("52_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_660
    .param pmc param_661
    .param pmc param_662
.annotate 'line', 344
    new $P659, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P659, control_658
    push_eh $P659
    .lex "self", param_660
    .lex "$obj", param_661
    .lex "$check", param_662
.annotate 'line', 345
    new $P663, "Undef"
    .lex "$check-class", $P663
.annotate 'line', 346
    new $P664, "Undef"
    .lex "$i", $P664
.annotate 'line', 345
    find_lex $P665, "$check"
    get_what $P666, $P665
    store_lex "$check-class", $P666
.annotate 'line', 346
    find_lex $P667, "self"
    get_global $P668, "$?CLASS"
    getattribute $P669, $P667, $P668, "@!mro"
    unless_null $P669, vivify_158
    $P669 = root_new ['parrot';'ResizablePMCArray']
  vivify_158:
    set $N670, $P669
    new $P671, 'Float'
    set $P671, $N670
    store_lex "$i", $P671
.annotate 'line', 347
    new $P689, 'ExceptionHandler'
    set_addr $P689, loop688_handler
    $P689."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P689
  loop688_test:
    find_lex $P672, "$i"
    set $N673, $P672
    isgt $I674, $N673, 0.0
    unless $I674, loop688_done
  loop688_redo:
.annotate 'line', 348
    find_lex $P675, "$i"
    sub $P676, $P675, 1
    store_lex "$i", $P676
.annotate 'line', 349
    find_lex $P678, "$i"
    set $I679, $P678
    find_lex $P680, "self"
    get_global $P681, "$?CLASS"
    getattribute $P682, $P680, $P681, "@!mro"
    unless_null $P682, vivify_159
    $P682 = root_new ['parrot';'ResizablePMCArray']
  vivify_159:
    set $P683, $P682[$I679]
    unless_null $P683, vivify_160
    new $P683, "Undef"
  vivify_160:
    find_lex $P684, "$check-class"
    issame $I685, $P683, $P684
    unless $I685, if_677_end
.annotate 'line', 350
    new $P686, "Exception"
    set $P686['type'], .CONTROL_RETURN
    new $P687, "Integer"
    assign $P687, 1
    setattribute $P686, 'payload', $P687
    throw $P686
  if_677_end:
  loop688_next:
.annotate 'line', 347
    goto loop688_test
  loop688_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P690, exception, 'type'
    eq $P690, .CONTROL_LOOP_NEXT, loop688_next
    eq $P690, .CONTROL_LOOP_REDO, loop688_redo
  loop688_done:
    pop_eh 
.annotate 'line', 353
    new $P691, "Exception"
    set $P691['type'], .CONTROL_RETURN
    new $P692, "Integer"
    assign $P692, 0
    setattribute $P691, 'payload', $P692
    throw $P691
.annotate 'line', 344
    .return ()
  control_658:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P693, exception, "payload"
    .return ($P693)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "does"  :subid("53_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_697
    .param pmc param_698
    .param pmc param_699
.annotate 'line', 356
    new $P696, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P696, control_695
    push_eh $P696
    .lex "self", param_697
    .lex "$obj", param_698
    .lex "$check", param_699
.annotate 'line', 357
    new $P700, "Undef"
    .lex "$i", $P700
    find_lex $P701, "self"
    get_global $P702, "$?CLASS"
    getattribute $P703, $P701, $P702, "@!done"
    unless_null $P703, vivify_161
    $P703 = root_new ['parrot';'ResizablePMCArray']
  vivify_161:
    set $N704, $P703
    new $P705, 'Float'
    set $P705, $N704
    store_lex "$i", $P705
.annotate 'line', 358
    new $P723, 'ExceptionHandler'
    set_addr $P723, loop722_handler
    $P723."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P723
  loop722_test:
    find_lex $P706, "$i"
    set $N707, $P706
    isgt $I708, $N707, 0.0
    unless $I708, loop722_done
  loop722_redo:
.annotate 'line', 359
    find_lex $P709, "$i"
    sub $P710, $P709, 1
    store_lex "$i", $P710
.annotate 'line', 360
    find_lex $P712, "$i"
    set $I713, $P712
    find_lex $P714, "self"
    get_global $P715, "$?CLASS"
    getattribute $P716, $P714, $P715, "@!done"
    unless_null $P716, vivify_162
    $P716 = root_new ['parrot';'ResizablePMCArray']
  vivify_162:
    set $P717, $P716[$I713]
    unless_null $P717, vivify_163
    new $P717, "Undef"
  vivify_163:
    find_lex $P718, "$check"
    issame $I719, $P717, $P718
    unless $I719, if_711_end
.annotate 'line', 361
    new $P720, "Exception"
    set $P720['type'], .CONTROL_RETURN
    new $P721, "Integer"
    assign $P721, 1
    setattribute $P720, 'payload', $P721
    throw $P720
  if_711_end:
  loop722_next:
.annotate 'line', 358
    goto loop722_test
  loop722_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P724, exception, 'type'
    eq $P724, .CONTROL_LOOP_NEXT, loop722_next
    eq $P724, .CONTROL_LOOP_REDO, loop722_redo
  loop722_done:
    pop_eh 
.annotate 'line', 364
    new $P725, "Exception"
    set $P725['type'], .CONTROL_RETURN
    new $P726, "Integer"
    assign $P726, 0
    setattribute $P725, 'payload', $P726
    throw $P725
.annotate 'line', 356
    .return ()
  control_695:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P727, exception, "payload"
    .return ($P727)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "can"  :subid("54_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_731
    .param pmc param_732
    .param pmc param_733
.annotate 'line', 367
    .const 'Sub' $P741 = "55_1296306514.38863" 
    capture_lex $P741
    new $P730, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P730, control_729
    push_eh $P730
    .lex "self", param_731
    .lex "$obj", param_732
    .lex "$name", param_733
.annotate 'line', 368
    find_lex $P735, "self"
    get_global $P736, "$?CLASS"
    getattribute $P737, $P735, $P736, "@!mro"
    unless_null $P737, vivify_164
    $P737 = root_new ['parrot';'ResizablePMCArray']
  vivify_164:
    defined $I738, $P737
    unless $I738, for_undef_165
    iter $P734, $P737
    new $P759, 'ExceptionHandler'
    set_addr $P759, loop758_handler
    $P759."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P759
  loop758_test:
    unless $P734, loop758_done
    shift $P739, $P734
  loop758_redo:
    .const 'Sub' $P741 = "55_1296306514.38863" 
    capture_lex $P741
    $P741($P739)
  loop758_next:
    goto loop758_test
  loop758_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P760, exception, 'type'
    eq $P760, .CONTROL_LOOP_NEXT, loop758_next
    eq $P760, .CONTROL_LOOP_REDO, loop758_redo
  loop758_done:
    pop_eh 
  for_undef_165:
.annotate 'line', 375
    new $P761, "Exception"
    set $P761['type'], .CONTROL_RETURN
    new $P762, "Integer"
    assign $P762, 0
    setattribute $P761, 'payload', $P762
    throw $P761
.annotate 'line', 367
    .return ()
  control_729:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P763, exception, "payload"
    .return ($P763)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block740"  :anon :subid("55_1296306514.38863") :outer("54_1296306514.38863")
    .param pmc param_744
.annotate 'line', 369
    $P742 = root_new ['parrot';'Hash']
    .lex "%meths", $P742
.annotate 'line', 370
    new $P743, "Undef"
    .lex "$can", $P743
    .lex "$_", param_744
.annotate 'line', 369
    find_lex $P745, "$_"
    get_how $P746, $P745
    find_lex $P747, "$obj"
    $P748 = $P746."method_table"($P747)
    store_lex "%meths", $P748
.annotate 'line', 370
    find_lex $P749, "$name"
    find_lex $P750, "%meths"
    unless_null $P750, vivify_166
    $P750 = root_new ['parrot';'Hash']
  vivify_166:
    set $P751, $P750[$P749]
    unless_null $P751, vivify_167
    new $P751, "Undef"
  vivify_167:
    store_lex "$can", $P751
.annotate 'line', 371
    find_lex $P754, "$can"
    defined $I755, $P754
    if $I755, if_753
    new $P752, 'Integer'
    set $P752, $I755
    goto if_753_end
  if_753:
.annotate 'line', 372
    new $P756, "Exception"
    set $P756['type'], .CONTROL_RETURN
    find_lex $P757, "$can"
    setattribute $P756, 'payload', $P757
    throw $P756
  if_753_end:
.annotate 'line', 368
    .return ($P752)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "find_method"  :subid("56_1296306514.38863") :outer("15_1296306514.38863")
    .param pmc param_767
    .param pmc param_768
    .param pmc param_769
.annotate 'line', 381
    .const 'Sub' $P777 = "57_1296306514.38863" 
    capture_lex $P777
    new $P766, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P766, control_765
    push_eh $P766
    .lex "self", param_767
    .lex "$obj", param_768
    .lex "$name", param_769
.annotate 'line', 382
    find_lex $P771, "self"
    get_global $P772, "$?CLASS"
    getattribute $P773, $P771, $P772, "@!mro"
    unless_null $P773, vivify_168
    $P773 = root_new ['parrot';'ResizablePMCArray']
  vivify_168:
    defined $I774, $P773
    unless $I774, for_undef_169
    iter $P770, $P773
    new $P795, 'ExceptionHandler'
    set_addr $P795, loop794_handler
    $P795."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P795
  loop794_test:
    unless $P770, loop794_done
    shift $P775, $P770
  loop794_redo:
    .const 'Sub' $P777 = "57_1296306514.38863" 
    capture_lex $P777
    $P777($P775)
  loop794_next:
    goto loop794_test
  loop794_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P796, exception, 'type'
    eq $P796, .CONTROL_LOOP_NEXT, loop794_next
    eq $P796, .CONTROL_LOOP_REDO, loop794_redo
  loop794_done:
    pop_eh 
  for_undef_169:
.annotate 'line', 389
    null $P797
.annotate 'line', 381
    .return ($P797)
  control_765:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P798, exception, "payload"
    .return ($P798)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block776"  :anon :subid("57_1296306514.38863") :outer("56_1296306514.38863")
    .param pmc param_780
.annotate 'line', 383
    $P778 = root_new ['parrot';'Hash']
    .lex "%meths", $P778
.annotate 'line', 384
    new $P779, "Undef"
    .lex "$found", $P779
    .lex "$_", param_780
.annotate 'line', 383
    find_lex $P781, "$_"
    get_how $P782, $P781
    find_lex $P783, "$obj"
    $P784 = $P782."method_table"($P783)
    store_lex "%meths", $P784
.annotate 'line', 384
    find_lex $P785, "$name"
    find_lex $P786, "%meths"
    unless_null $P786, vivify_170
    $P786 = root_new ['parrot';'Hash']
  vivify_170:
    set $P787, $P786[$P785]
    unless_null $P787, vivify_171
    new $P787, "Undef"
  vivify_171:
    store_lex "$found", $P787
.annotate 'line', 385
    find_lex $P790, "$found"
    defined $I791, $P790
    if $I791, if_789
    new $P788, 'Integer'
    set $P788, $I791
    goto if_789_end
  if_789:
.annotate 'line', 386
    new $P792, "Exception"
    set $P792['type'], .CONTROL_RETURN
    find_lex $P793, "$found"
    setattribute $P792, 'payload', $P793
    throw $P792
  if_789_end:
.annotate 'line', 382
    .return ($P788)
.end


.namespace ["NQPNativeHOW"]
.sub "_block881"  :subid("59_1296306514.38863") :outer("10_1296306514.38863")
.annotate 'line', 394
    .const 'Sub' $P942 = "68_1296306514.38863" 
    capture_lex $P942
    .const 'Sub' $P934 = "67_1296306514.38863" 
    capture_lex $P934
    .const 'Sub' $P928 = "66_1296306514.38863" 
    capture_lex $P928
    .const 'Sub' $P924 = "65_1296306514.38863" 
    capture_lex $P924
    .const 'Sub' $P919 = "64_1296306514.38863" 
    capture_lex $P919
    .const 'Sub' $P914 = "63_1296306514.38863" 
    capture_lex $P914
    .const 'Sub' $P901 = "62_1296306514.38863" 
    capture_lex $P901
    .const 'Sub' $P894 = "61_1296306514.38863" 
    capture_lex $P894
    .const 'Sub' $P884 = "60_1296306514.38863" 
    capture_lex $P884
    get_global $P883, "$?CLASS"
.annotate 'line', 432
    .const 'Sub' $P934 = "67_1296306514.38863" 
    newclosure $P940, $P934
.annotate 'line', 394
    .return ($P940)
.end


.namespace ["NQPNativeHOW"]
.sub "" :load :init :subid("post172") :outer("59_1296306514.38863")
.annotate 'line', 394
    get_hll_global $P882, ["NQPNativeHOW"], "_block881" 
    .local pmc block
    set block, $P882
    .const 'Sub' $P942 = "68_1296306514.38863" 
    capture_lex $P942
    $P942()
.end


.namespace ["NQPNativeHOW"]
.sub "_block941"  :anon :subid("68_1296306514.38863") :outer("59_1296306514.38863")
.annotate 'line', 394
    get_hll_global $P943, "KnowHOW"
    $P944 = $P943."new_type"("NQPNativeHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P944
    set_hll_global "NQPNativeHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P945, type_obj
    get_hll_global $P946, "KnowHOWAttribute"
    $P947 = $P946."new"("$!name" :named("name"))
    $P945."add_attribute"(type_obj, $P947)
    get_how $P948, type_obj
    get_hll_global $P949, "KnowHOWAttribute"
    $P950 = $P949."new"("$!composed" :named("name"))
    $P948."add_attribute"(type_obj, $P950)
    get_how $P951, type_obj
    .const 'Sub' $P952 = "60_1296306514.38863" 
    $P951."add_method"(type_obj, "new", $P952)
    get_how $P953, type_obj
    .const 'Sub' $P954 = "61_1296306514.38863" 
    $P953."add_method"(type_obj, "BUILD", $P954)
    get_how $P955, type_obj
    .const 'Sub' $P956 = "62_1296306514.38863" 
    $P955."add_method"(type_obj, "new_type", $P956)
    get_how $P957, type_obj
    .const 'Sub' $P958 = "63_1296306514.38863" 
    $P957."add_method"(type_obj, "add_method", $P958)
    get_how $P959, type_obj
    .const 'Sub' $P960 = "64_1296306514.38863" 
    $P959."add_method"(type_obj, "add_multi_method", $P960)
    get_how $P961, type_obj
    .const 'Sub' $P962 = "65_1296306514.38863" 
    $P961."add_method"(type_obj, "add_attribute", $P962)
    get_how $P963, type_obj
    .const 'Sub' $P964 = "66_1296306514.38863" 
    $P963."add_method"(type_obj, "compose", $P964)
    get_how $P965, type_obj
    .const 'Sub' $P966 = "67_1296306514.38863" 
    $P965."add_method"(type_obj, "name", $P966)
    get_how $P967, type_obj
    $P968 = $P967."compose"(type_obj)
    .return ($P968)
.end


.namespace ["NQPNativeHOW"]
.sub "new"  :subid("60_1296306514.38863") :outer("59_1296306514.38863")
    .param pmc param_885
    .param pmc param_886 :optional :named("name")
    .param int has_param_886 :opt_flag
.annotate 'line', 398
    .lex "self", param_885
    if has_param_886, optparam_173
    new $P887, "Undef"
    set param_886, $P887
  optparam_173:
    .lex "$name", param_886
.annotate 'line', 399
    new $P888, "Undef"
    .lex "$obj", $P888
    find_lex $P889, "self"
    repr_instance_of $P890, $P889
    store_lex "$obj", $P890
.annotate 'line', 400
    find_lex $P891, "$obj"
    find_lex $P892, "$name"
    $P891."BUILD"($P892 :named("name"))
    find_lex $P893, "$obj"
.annotate 'line', 398
    .return ($P893)
.end


.namespace ["NQPNativeHOW"]
.sub "BUILD"  :subid("61_1296306514.38863") :outer("59_1296306514.38863")
    .param pmc param_895
    .param pmc param_896 :optional :named("name")
    .param int has_param_896 :opt_flag
.annotate 'line', 404
    .lex "self", param_895
    if has_param_896, optparam_174
    new $P897, "Undef"
    set param_896, $P897
  optparam_174:
    .lex "$name", param_896
.annotate 'line', 405
    find_lex $P898, "$name"
    find_lex $P899, "self"
    get_global $P900, "$?CLASS"
    setattribute $P899, $P900, "$!name", $P898
.annotate 'line', 404
    .return ($P898)
.end


.namespace ["NQPNativeHOW"]
.sub "new_type"  :subid("62_1296306514.38863") :outer("59_1296306514.38863")
    .param pmc param_902
    .param pmc param_905 :named("repr")
    .param pmc param_903 :optional :named("name")
    .param int has_param_903 :opt_flag
.annotate 'line', 411
    .lex "self", param_902
    if has_param_903, optparam_175
    new $P904, "String"
    assign $P904, "<anon>"
    set param_903, $P904
  optparam_175:
    .lex "$name", param_903
    .lex "$repr", param_905
.annotate 'line', 412
    new $P906, "Undef"
    .lex "$metaclass", $P906
    find_lex $P907, "self"
    find_lex $P908, "$name"
    $P909 = $P907."new"($P908 :named("name"))
    store_lex "$metaclass", $P909
.annotate 'line', 413
    find_lex $P910, "$metaclass"
    find_lex $P911, "$repr"
    set $S912, $P911
    repr_type_object_for $P913, $P910, $S912
.annotate 'line', 411
    .return ($P913)
.end


.namespace ["NQPNativeHOW"]
.sub "add_method"  :subid("63_1296306514.38863") :outer("59_1296306514.38863")
    .param pmc param_915
    .param pmc param_916
    .param pmc param_917
    .param pmc param_918
.annotate 'line', 416
    .lex "self", param_915
    .lex "$obj", param_916
    .lex "$name", param_917
    .lex "$code_obj", param_918
.annotate 'line', 417
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 416
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "add_multi_method"  :subid("64_1296306514.38863") :outer("59_1296306514.38863")
    .param pmc param_920
    .param pmc param_921
    .param pmc param_922
    .param pmc param_923
.annotate 'line', 420
    .lex "self", param_920
    .lex "$obj", param_921
    .lex "$name", param_922
    .lex "$code_obj", param_923
.annotate 'line', 421
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 420
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "add_attribute"  :subid("65_1296306514.38863") :outer("59_1296306514.38863")
    .param pmc param_925
    .param pmc param_926
    .param pmc param_927
.annotate 'line', 424
    .lex "self", param_925
    .lex "$obj", param_926
    .lex "$meta_attr", param_927
.annotate 'line', 425
    die "Native types may not have attributes"
.annotate 'line', 424
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "compose"  :subid("66_1296306514.38863") :outer("59_1296306514.38863")
    .param pmc param_929
    .param pmc param_930
.annotate 'line', 428
    .lex "self", param_929
    .lex "$obj", param_930
.annotate 'line', 429
    new $P931, "Integer"
    assign $P931, 1
    find_lex $P932, "self"
    get_global $P933, "$?CLASS"
    setattribute $P932, $P933, "$!composed", $P931
.annotate 'line', 428
    .return ($P931)
.end


.namespace ["NQPNativeHOW"]
.sub "name"  :subid("67_1296306514.38863") :outer("59_1296306514.38863")
    .param pmc param_935
    .param pmc param_936
.annotate 'line', 432
    .lex "self", param_935
    .lex "$obj", param_936
    find_lex $P937, "self"
    get_global $P938, "$?CLASS"
    getattribute $P939, $P937, $P938, "$!name"
    unless_null $P939, vivify_176
    new $P939, "Undef"
  vivify_176:
    .return ($P939)
.end


.namespace ["NQPAttribute"]
.sub "_block969"  :subid("69_1296306514.38863") :outer("10_1296306514.38863")
.annotate 'line', 438
    .const 'Sub' $P1029 = "75_1296306514.38863" 
    capture_lex $P1029
    .const 'Sub' $P1018 = "74_1296306514.38863" 
    capture_lex $P1018
    .const 'Sub' $P1009 = "73_1296306514.38863" 
    capture_lex $P1009
    .const 'Sub' $P1004 = "72_1296306514.38863" 
    capture_lex $P1004
    .const 'Sub' $P987 = "71_1296306514.38863" 
    capture_lex $P987
    .const 'Sub' $P972 = "70_1296306514.38863" 
    capture_lex $P972
    get_global $P971, "$?CLASS"
.annotate 'line', 463
    .const 'Sub' $P1018 = "74_1296306514.38863" 
    newclosure $P1027, $P1018
.annotate 'line', 438
    .return ($P1027)
.end


.namespace ["NQPAttribute"]
.sub "" :load :init :subid("post177") :outer("69_1296306514.38863")
.annotate 'line', 438
    get_hll_global $P970, ["NQPAttribute"], "_block969" 
    .local pmc block
    set block, $P970
    .const 'Sub' $P1029 = "75_1296306514.38863" 
    capture_lex $P1029
    $P1029()
.end


.namespace ["NQPAttribute"]
.sub "_block1028"  :anon :subid("75_1296306514.38863") :outer("69_1296306514.38863")
.annotate 'line', 438
    get_hll_global $P1030, "KnowHOW"
    $P1031 = $P1030."new_type"("NQPAttribute" :named("name"))
    .local pmc type_obj
    set type_obj, $P1031
    set_hll_global "NQPAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1032, type_obj
    get_hll_global $P1033, "KnowHOWAttribute"
    $P1034 = $P1033."new"("$!name" :named("name"))
    $P1032."add_attribute"(type_obj, $P1034)
    get_how $P1035, type_obj
    get_hll_global $P1036, "KnowHOWAttribute"
    $P1037 = $P1036."new"("$!type" :named("name"))
    $P1035."add_attribute"(type_obj, $P1037)
    get_how $P1038, type_obj
    get_hll_global $P1039, "KnowHOWAttribute"
    $P1040 = $P1039."new"("$!box_target" :named("name"))
    $P1038."add_attribute"(type_obj, $P1040)
    get_how $P1041, type_obj
    .const 'Sub' $P1042 = "70_1296306514.38863" 
    $P1041."add_method"(type_obj, "new", $P1042)
    get_how $P1043, type_obj
    .const 'Sub' $P1044 = "71_1296306514.38863" 
    $P1043."add_method"(type_obj, "BUILD", $P1044)
    get_how $P1045, type_obj
    .const 'Sub' $P1046 = "72_1296306514.38863" 
    $P1045."add_method"(type_obj, "name", $P1046)
    get_how $P1047, type_obj
    .const 'Sub' $P1048 = "73_1296306514.38863" 
    $P1047."add_method"(type_obj, "type", $P1048)
    get_how $P1049, type_obj
    .const 'Sub' $P1050 = "74_1296306514.38863" 
    $P1049."add_method"(type_obj, "box_target", $P1050)
    get_how $P1051, type_obj
    $P1052 = $P1051."compose"(type_obj)
    .return ($P1052)
.end


.namespace ["NQPAttribute"]
.sub "new"  :subid("70_1296306514.38863") :outer("69_1296306514.38863")
    .param pmc param_973
    .param pmc param_974 :named("name")
    .param pmc param_975 :optional :named("type")
    .param int has_param_975 :opt_flag
    .param pmc param_977 :optional :named("box_target")
    .param int has_param_977 :opt_flag
.annotate 'line', 443
    .lex "self", param_973
    .lex "$name", param_974
    if has_param_975, optparam_178
    new $P976, "Undef"
    set param_975, $P976
  optparam_178:
    .lex "$type", param_975
    if has_param_977, optparam_179
    new $P978, "Undef"
    set param_977, $P978
  optparam_179:
    .lex "$box_target", param_977
.annotate 'line', 444
    new $P979, "Undef"
    .lex "$attr", $P979
    find_lex $P980, "self"
    repr_instance_of $P981, $P980
    store_lex "$attr", $P981
.annotate 'line', 445
    find_lex $P982, "$attr"
    find_lex $P983, "$name"
    find_lex $P984, "$type"
    find_lex $P985, "$box_target"
    $P982."BUILD"($P983 :named("name"), $P984 :named("type"), $P985 :named("box_target"))
    find_lex $P986, "$attr"
.annotate 'line', 443
    .return ($P986)
.end


.namespace ["NQPAttribute"]
.sub "BUILD"  :subid("71_1296306514.38863") :outer("69_1296306514.38863")
    .param pmc param_988
    .param pmc param_989 :optional :named("name")
    .param int has_param_989 :opt_flag
    .param pmc param_991 :optional :named("type")
    .param int has_param_991 :opt_flag
    .param pmc param_993 :optional :named("box_target")
    .param int has_param_993 :opt_flag
.annotate 'line', 449
    .lex "self", param_988
    if has_param_989, optparam_180
    new $P990, "Undef"
    set param_989, $P990
  optparam_180:
    .lex "$name", param_989
    if has_param_991, optparam_181
    new $P992, "Undef"
    set param_991, $P992
  optparam_181:
    .lex "$type", param_991
    if has_param_993, optparam_182
    new $P994, "Undef"
    set param_993, $P994
  optparam_182:
    .lex "$box_target", param_993
.annotate 'line', 450
    find_lex $P995, "$name"
    find_lex $P996, "self"
    get_global $P997, "$?CLASS"
    setattribute $P996, $P997, "$!name", $P995
.annotate 'line', 451
    find_lex $P998, "$type"
    find_lex $P999, "self"
    get_global $P1000, "$?CLASS"
    setattribute $P999, $P1000, "$!type", $P998
.annotate 'line', 452
    find_lex $P1001, "$box_target"
    find_lex $P1002, "self"
    get_global $P1003, "$?CLASS"
    setattribute $P1002, $P1003, "$!box_target", $P1001
.annotate 'line', 449
    .return ($P1001)
.end


.namespace ["NQPAttribute"]
.sub "name"  :subid("72_1296306514.38863") :outer("69_1296306514.38863")
    .param pmc param_1005
.annotate 'line', 455
    .lex "self", param_1005
    find_lex $P1006, "self"
    get_global $P1007, "$?CLASS"
    getattribute $P1008, $P1006, $P1007, "$!name"
    unless_null $P1008, vivify_183
    new $P1008, "Undef"
  vivify_183:
    .return ($P1008)
.end


.namespace ["NQPAttribute"]
.sub "type"  :subid("73_1296306514.38863") :outer("69_1296306514.38863")
    .param pmc param_1010
.annotate 'line', 459
    .lex "self", param_1010
.annotate 'line', 460
    find_lex $P1012, "self"
    get_global $P1013, "$?CLASS"
    getattribute $P1014, $P1012, $P1013, "$!type"
    unless_null $P1014, vivify_184
    new $P1014, "Undef"
  vivify_184:
    set $P1011, $P1014
    defined $I1016, $P1011
    if $I1016, default_1015
    null $P1017
    set $P1011, $P1017
  default_1015:
.annotate 'line', 459
    .return ($P1011)
.end


.namespace ["NQPAttribute"]
.sub "box_target"  :subid("74_1296306514.38863") :outer("69_1296306514.38863")
    .param pmc param_1019
.annotate 'line', 463
    .lex "self", param_1019
.annotate 'line', 464
    find_lex $P1022, "self"
    get_global $P1023, "$?CLASS"
    getattribute $P1024, $P1022, $P1023, "$!box_target"
    unless_null $P1024, vivify_185
    new $P1024, "Undef"
  vivify_185:
    if $P1024, if_1021
    new $P1026, "Integer"
    assign $P1026, 0
    set $P1020, $P1026
    goto if_1021_end
  if_1021:
    new $P1025, "Integer"
    assign $P1025, 1
    set $P1020, $P1025
  if_1021_end:
.annotate 'line', 463
    .return ($P1020)
.end


.namespace ["NQPMu"]
.sub "_block1053"  :subid("76_1296306514.38863") :outer("10_1296306514.38863")
.annotate 'line', 469
    .const 'Sub' $P1082 = "81_1296306514.38863" 
    capture_lex $P1082
    .const 'Sub' $P1068 = "80_1296306514.38863" 
    capture_lex $P1068
    .const 'Sub' $P1064 = "79_1296306514.38863" 
    capture_lex $P1064
    .const 'Sub' $P1060 = "78_1296306514.38863" 
    capture_lex $P1060
    .const 'Sub' $P1056 = "77_1296306514.38863" 
    capture_lex $P1056
    get_global $P1055, "$?CLASS"
.annotate 'line', 479
    .const 'Sub' $P1068 = "80_1296306514.38863" 
    newclosure $P1080, $P1068
.annotate 'line', 469
    .return ($P1080)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post186") :outer("76_1296306514.38863")
.annotate 'line', 469
    get_hll_global $P1054, ["NQPMu"], "_block1053" 
    .local pmc block
    set block, $P1054
    .const 'Sub' $P1082 = "81_1296306514.38863" 
    capture_lex $P1082
    $P1082()
.end


.namespace ["NQPMu"]
.sub "_block1081"  :anon :subid("81_1296306514.38863") :outer("76_1296306514.38863")
.annotate 'line', 469
    get_hll_global $P1083, "NQPClassHOW"
    $P1084 = $P1083."new_type"("NQPMu" :named("name"))
    .local pmc type_obj
    set type_obj, $P1084
    set_hll_global "NQPMu", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1085, type_obj
    .const 'Sub' $P1086 = "77_1296306514.38863" 
    $P1085."add_method"(type_obj, "CREATE", $P1086)
    get_how $P1087, type_obj
    .const 'Sub' $P1088 = "78_1296306514.38863" 
    $P1087."add_method"(type_obj, "new", $P1088)
    get_how $P1089, type_obj
    .const 'Sub' $P1090 = "79_1296306514.38863" 
    new $P1091, "ResizablePMCArray"
    set_dispatchees $P1090, $P1091
    $P1089."add_method"(type_obj, "ACCEPTS", $P1090)
    get_how $P1092, type_obj
    .const 'Sub' $P1093 = "80_1296306514.38863" 
    $P1092."add_multi_method"(type_obj, "ACCEPTS", $P1093)
    get_how $P1094, type_obj
    $P1095 = $P1094."compose"(type_obj)
    .return ($P1095)
.end


.namespace ["NQPMu"]
.sub "CREATE"  :subid("77_1296306514.38863") :outer("76_1296306514.38863")
    .param pmc param_1057
.annotate 'line', 470
    .lex "self", param_1057
.annotate 'line', 471
    find_lex $P1058, "self"
    repr_instance_of $P1059, $P1058
.annotate 'line', 470
    .return ($P1059)
.end


.namespace ["NQPMu"]
.sub "new"  :subid("78_1296306514.38863") :outer("76_1296306514.38863")
    .param pmc param_1061
.annotate 'line', 474
    .lex "self", param_1061
.annotate 'line', 475
    find_lex $P1062, "self"
    $P1063 = $P1062."CREATE"()
.annotate 'line', 474
    .return ($P1063)
.end


.namespace ["NQPMu"]
.sub "ACCEPTS" :instanceof("DispatcherSub") :subid("79_1296306514.38863") :outer("76_1296306514.38863")
    .param pmc param_1065
    .param pmc param_1066
.annotate 'line', 474
    .lex "self", param_1065
.annotate 'line', 478
    .lex "$topic", param_1066
.annotate 'line', 474
    multi_dispatch_over_lexical_candidates $P1067
    .return ($P1067)
.end


.namespace ["NQPMu"]
.sub "ACCEPTS"  :subid("80_1296306514.38863") :outer("76_1296306514.38863")
    .param pmc param_1069
    .param pmc param_1071
.annotate 'line', 479
    .lex "$self", param_1069
    find_lex $P1070, "$self"
    .lex "self", $P1070
    .lex "$topic", param_1071
.annotate 'line', 480
    find_lex $P1072, "$topic"
    find_lex $P1073, "self"
    get_what $P1074, $P1073
    type_check $I1075, $P1072, $P1074
.annotate 'line', 479
    .return ($I1075)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post187") :outer("80_1296306514.38863")
.annotate 'line', 479
    .const 'Sub' $P1068 = "80_1296306514.38863" 
    .local pmc block
    set block, $P1068
    get_hll_global $P1076, "NQPMu"
    null $P1077
    new $P1078, "ResizablePMCArray"
    push $P1078, $P1076
    push $P1078, $P1077
    new $P1079, "ResizablePMCArray"
    push $P1079, 2
    push $P1079, 0
    set_sub_multisig block, $P1078, $P1079
.end


.namespace ["int"]
.sub "_block1096"  :subid("82_1296306514.38863") :outer("10_1296306514.38863")
.annotate 'line', 485
    .const 'Sub' $P1100 = "83_1296306514.38863" 
    capture_lex $P1100
    get_global $P1098, "$?CLASS"
    .return ()
.end


.namespace ["int"]
.sub "" :load :init :subid("post188") :outer("82_1296306514.38863")
.annotate 'line', 485
    get_hll_global $P1097, ["int"], "_block1096" 
    .local pmc block
    set block, $P1097
    .const 'Sub' $P1100 = "83_1296306514.38863" 
    capture_lex $P1100
    $P1100()
.end


.namespace ["int"]
.sub "_block1099"  :anon :subid("83_1296306514.38863") :outer("82_1296306514.38863")
.annotate 'line', 485
    get_hll_global $P1101, "NQPNativeHOW"
    $P1102 = $P1101."new_type"("int" :named("name"), "P6int" :named("repr"))
    .local pmc type_obj
    set type_obj, $P1102
    set_hll_global "int", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1103, type_obj
    $P1104 = $P1103."compose"(type_obj)
    .return ($P1104)
.end


.namespace ["num"]
.sub "_block1105"  :subid("84_1296306514.38863") :outer("10_1296306514.38863")
.annotate 'line', 487
    .const 'Sub' $P1109 = "85_1296306514.38863" 
    capture_lex $P1109
    get_global $P1107, "$?CLASS"
    .return ()
.end


.namespace ["num"]
.sub "" :load :init :subid("post189") :outer("84_1296306514.38863")
.annotate 'line', 487
    get_hll_global $P1106, ["num"], "_block1105" 
    .local pmc block
    set block, $P1106
    .const 'Sub' $P1109 = "85_1296306514.38863" 
    capture_lex $P1109
    $P1109()
.end


.namespace ["num"]
.sub "_block1108"  :anon :subid("85_1296306514.38863") :outer("84_1296306514.38863")
.annotate 'line', 487
    get_hll_global $P1110, "NQPNativeHOW"
    $P1111 = $P1110."new_type"("num" :named("name"), "P6num" :named("repr"))
    .local pmc type_obj
    set type_obj, $P1111
    set_hll_global "num", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1112, type_obj
    $P1113 = $P1112."compose"(type_obj)
    .return ($P1113)
.end


.namespace ["str"]
.sub "_block1114"  :subid("86_1296306514.38863") :outer("10_1296306514.38863")
.annotate 'line', 489
    .const 'Sub' $P1118 = "87_1296306514.38863" 
    capture_lex $P1118
    get_global $P1116, "$?CLASS"
    .return ()
.end


.namespace ["str"]
.sub "" :load :init :subid("post190") :outer("86_1296306514.38863")
.annotate 'line', 489
    get_hll_global $P1115, ["str"], "_block1114" 
    .local pmc block
    set block, $P1115
    .const 'Sub' $P1118 = "87_1296306514.38863" 
    capture_lex $P1118
    $P1118()
.end


.namespace ["str"]
.sub "_block1117"  :anon :subid("87_1296306514.38863") :outer("86_1296306514.38863")
.annotate 'line', 489
    get_hll_global $P1119, "NQPNativeHOW"
    $P1120 = $P1119."new_type"("str" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P1120
    set_hll_global "str", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1121, type_obj
    $P1122 = $P1121."compose"(type_obj)
    .return ($P1122)
.end


.namespace []
.sub "_block1124" :load :anon :subid("88_1296306514.38863")
.annotate 'line', 1
    .const 'Sub' $P1126 = "10_1296306514.38863" 
    $P1127 = $P1126()
    .return ($P1127)
.end


.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
.end

### .include 'gen/nqp-grammar.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1296306519.49046")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Grammar"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
    $P2402 = $P15()
.annotate 'line', 1
    .return ($P2402)
    .const 'Sub' $P2404 = "400_1296306519.49046" 
    .return ($P2404)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block14"  :subid("11_1296306519.49046") :outer("10_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P1691 = "399_1296306519.49046" 
    capture_lex $P1691
    get_hll_global $P1582, ["NQP";"Regex"], "_block1581" 
    capture_lex $P1582
    .const 'Sub' $P1570 = "375_1296306519.49046" 
    capture_lex $P1570
    .const 'Sub' $P1564 = "373_1296306519.49046" 
    capture_lex $P1564
    .const 'Sub' $P1558 = "371_1296306519.49046" 
    capture_lex $P1558
    .const 'Sub' $P1552 = "369_1296306519.49046" 
    capture_lex $P1552
    .const 'Sub' $P1546 = "367_1296306519.49046" 
    capture_lex $P1546
    .const 'Sub' $P1534 = "364_1296306519.49046" 
    capture_lex $P1534
    .const 'Sub' $P1527 = "362_1296306519.49046" 
    capture_lex $P1527
    .const 'Sub' $P1520 = "360_1296306519.49046" 
    capture_lex $P1520
    .const 'Sub' $P1513 = "358_1296306519.49046" 
    capture_lex $P1513
    .const 'Sub' $P1506 = "356_1296306519.49046" 
    capture_lex $P1506
    .const 'Sub' $P1500 = "354_1296306519.49046" 
    capture_lex $P1500
    .const 'Sub' $P1493 = "352_1296306519.49046" 
    capture_lex $P1493
    .const 'Sub' $P1486 = "350_1296306519.49046" 
    capture_lex $P1486
    .const 'Sub' $P1479 = "348_1296306519.49046" 
    capture_lex $P1479
    .const 'Sub' $P1472 = "346_1296306519.49046" 
    capture_lex $P1472
    .const 'Sub' $P1465 = "344_1296306519.49046" 
    capture_lex $P1465
    .const 'Sub' $P1458 = "342_1296306519.49046" 
    capture_lex $P1458
    .const 'Sub' $P1451 = "340_1296306519.49046" 
    capture_lex $P1451
    .const 'Sub' $P1444 = "338_1296306519.49046" 
    capture_lex $P1444
    .const 'Sub' $P1437 = "336_1296306519.49046" 
    capture_lex $P1437
    .const 'Sub' $P1430 = "334_1296306519.49046" 
    capture_lex $P1430
    .const 'Sub' $P1423 = "332_1296306519.49046" 
    capture_lex $P1423
    .const 'Sub' $P1416 = "330_1296306519.49046" 
    capture_lex $P1416
    .const 'Sub' $P1409 = "328_1296306519.49046" 
    capture_lex $P1409
    .const 'Sub' $P1402 = "326_1296306519.49046" 
    capture_lex $P1402
    .const 'Sub' $P1395 = "324_1296306519.49046" 
    capture_lex $P1395
    .const 'Sub' $P1388 = "322_1296306519.49046" 
    capture_lex $P1388
    .const 'Sub' $P1381 = "320_1296306519.49046" 
    capture_lex $P1381
    .const 'Sub' $P1374 = "318_1296306519.49046" 
    capture_lex $P1374
    .const 'Sub' $P1367 = "316_1296306519.49046" 
    capture_lex $P1367
    .const 'Sub' $P1360 = "314_1296306519.49046" 
    capture_lex $P1360
    .const 'Sub' $P1353 = "312_1296306519.49046" 
    capture_lex $P1353
    .const 'Sub' $P1346 = "310_1296306519.49046" 
    capture_lex $P1346
    .const 'Sub' $P1339 = "308_1296306519.49046" 
    capture_lex $P1339
    .const 'Sub' $P1332 = "306_1296306519.49046" 
    capture_lex $P1332
    .const 'Sub' $P1325 = "304_1296306519.49046" 
    capture_lex $P1325
    .const 'Sub' $P1318 = "302_1296306519.49046" 
    capture_lex $P1318
    .const 'Sub' $P1311 = "300_1296306519.49046" 
    capture_lex $P1311
    .const 'Sub' $P1304 = "298_1296306519.49046" 
    capture_lex $P1304
    .const 'Sub' $P1297 = "296_1296306519.49046" 
    capture_lex $P1297
    .const 'Sub' $P1291 = "294_1296306519.49046" 
    capture_lex $P1291
    .const 'Sub' $P1284 = "292_1296306519.49046" 
    capture_lex $P1284
    .const 'Sub' $P1277 = "290_1296306519.49046" 
    capture_lex $P1277
    .const 'Sub' $P1270 = "288_1296306519.49046" 
    capture_lex $P1270
    .const 'Sub' $P1263 = "286_1296306519.49046" 
    capture_lex $P1263
    .const 'Sub' $P1256 = "284_1296306519.49046" 
    capture_lex $P1256
    .const 'Sub' $P1249 = "282_1296306519.49046" 
    capture_lex $P1249
    .const 'Sub' $P1242 = "280_1296306519.49046" 
    capture_lex $P1242
    .const 'Sub' $P1236 = "278_1296306519.49046" 
    capture_lex $P1236
    .const 'Sub' $P1230 = "276_1296306519.49046" 
    capture_lex $P1230
    .const 'Sub' $P1225 = "274_1296306519.49046" 
    capture_lex $P1225
    .const 'Sub' $P1219 = "272_1296306519.49046" 
    capture_lex $P1219
    .const 'Sub' $P1213 = "270_1296306519.49046" 
    capture_lex $P1213
    .const 'Sub' $P1208 = "268_1296306519.49046" 
    capture_lex $P1208
    .const 'Sub' $P1203 = "266_1296306519.49046" 
    capture_lex $P1203
    .const 'Sub' $P1187 = "265_1296306519.49046" 
    capture_lex $P1187
    .const 'Sub' $P1178 = "263_1296306519.49046" 
    capture_lex $P1178
    .const 'Sub' $P1169 = "261_1296306519.49046" 
    capture_lex $P1169
    .const 'Sub' $P1164 = "259_1296306519.49046" 
    capture_lex $P1164
    .const 'Sub' $P1159 = "257_1296306519.49046" 
    capture_lex $P1159
    .const 'Sub' $P1154 = "255_1296306519.49046" 
    capture_lex $P1154
    .const 'Sub' $P1146 = "253_1296306519.49046" 
    capture_lex $P1146
    .const 'Sub' $P1138 = "251_1296306519.49046" 
    capture_lex $P1138
    .const 'Sub' $P1133 = "249_1296306519.49046" 
    capture_lex $P1133
    .const 'Sub' $P1128 = "247_1296306519.49046" 
    capture_lex $P1128
    .const 'Sub' $P1123 = "245_1296306519.49046" 
    capture_lex $P1123
    .const 'Sub' $P1117 = "243_1296306519.49046" 
    capture_lex $P1117
    .const 'Sub' $P1111 = "241_1296306519.49046" 
    capture_lex $P1111
    .const 'Sub' $P1105 = "239_1296306519.49046" 
    capture_lex $P1105
    .const 'Sub' $P1099 = "237_1296306519.49046" 
    capture_lex $P1099
    .const 'Sub' $P1093 = "235_1296306519.49046" 
    capture_lex $P1093
    .const 'Sub' $P1088 = "233_1296306519.49046" 
    capture_lex $P1088
    .const 'Sub' $P1083 = "231_1296306519.49046" 
    capture_lex $P1083
    .const 'Sub' $P1069 = "227_1296306519.49046" 
    capture_lex $P1069
    .const 'Sub' $P1061 = "225_1296306519.49046" 
    capture_lex $P1061
    .const 'Sub' $P1055 = "223_1296306519.49046" 
    capture_lex $P1055
    .const 'Sub' $P1048 = "221_1296306519.49046" 
    capture_lex $P1048
    .const 'Sub' $P1042 = "219_1296306519.49046" 
    capture_lex $P1042
    .const 'Sub' $P1028 = "216_1296306519.49046" 
    capture_lex $P1028
    .const 'Sub' $P1020 = "214_1296306519.49046" 
    capture_lex $P1020
    .const 'Sub' $P1012 = "212_1296306519.49046" 
    capture_lex $P1012
    .const 'Sub' $P1006 = "210_1296306519.49046" 
    capture_lex $P1006
    .const 'Sub' $P1000 = "208_1296306519.49046" 
    capture_lex $P1000
    .const 'Sub' $P984 = "204_1296306519.49046" 
    capture_lex $P984
    .const 'Sub' $P947 = "202_1296306519.49046" 
    capture_lex $P947
    .const 'Sub' $P936 = "200_1296306519.49046" 
    capture_lex $P936
    .const 'Sub' $P922 = "196_1296306519.49046" 
    capture_lex $P922
    .const 'Sub' $P913 = "194_1296306519.49046" 
    capture_lex $P913
    .const 'Sub' $P907 = "192_1296306519.49046" 
    capture_lex $P907
    .const 'Sub' $P897 = "190_1296306519.49046" 
    capture_lex $P897
    .const 'Sub' $P882 = "188_1296306519.49046" 
    capture_lex $P882
    .const 'Sub' $P868 = "185_1296306519.49046" 
    capture_lex $P868
    .const 'Sub' $P860 = "183_1296306519.49046" 
    capture_lex $P860
    .const 'Sub' $P850 = "181_1296306519.49046" 
    capture_lex $P850
    .const 'Sub' $P840 = "179_1296306519.49046" 
    capture_lex $P840
    .const 'Sub' $P821 = "174_1296306519.49046" 
    capture_lex $P821
    .const 'Sub' $P777 = "171_1296306519.49046" 
    capture_lex $P777
    .const 'Sub' $P743 = "169_1296306519.49046" 
    capture_lex $P743
    .const 'Sub' $P736 = "167_1296306519.49046" 
    capture_lex $P736
    .const 'Sub' $P729 = "165_1296306519.49046" 
    capture_lex $P729
    .const 'Sub' $P712 = "161_1296306519.49046" 
    capture_lex $P712
    .const 'Sub' $P704 = "159_1296306519.49046" 
    capture_lex $P704
    .const 'Sub' $P698 = "157_1296306519.49046" 
    capture_lex $P698
    .const 'Sub' $P685 = "155_1296306519.49046" 
    capture_lex $P685
    .const 'Sub' $P678 = "153_1296306519.49046" 
    capture_lex $P678
    .const 'Sub' $P671 = "151_1296306519.49046" 
    capture_lex $P671
    .const 'Sub' $P664 = "149_1296306519.49046" 
    capture_lex $P664
    .const 'Sub' $P628 = "145_1296306519.49046" 
    capture_lex $P628
    .const 'Sub' $P616 = "143_1296306519.49046" 
    capture_lex $P616
    .const 'Sub' $P604 = "141_1296306519.49046" 
    capture_lex $P604
    .const 'Sub' $P592 = "139_1296306519.49046" 
    capture_lex $P592
    .const 'Sub' $P580 = "137_1296306519.49046" 
    capture_lex $P580
    .const 'Sub' $P568 = "135_1296306519.49046" 
    capture_lex $P568
    .const 'Sub' $P561 = "133_1296306519.49046" 
    capture_lex $P561
    .const 'Sub' $P550 = "129_1296306519.49046" 
    capture_lex $P550
    .const 'Sub' $P545 = "127_1296306519.49046" 
    capture_lex $P545
    .const 'Sub' $P533 = "125_1296306519.49046" 
    capture_lex $P533
    .const 'Sub' $P521 = "123_1296306519.49046" 
    capture_lex $P521
    .const 'Sub' $P514 = "121_1296306519.49046" 
    capture_lex $P514
    .const 'Sub' $P509 = "119_1296306519.49046" 
    capture_lex $P509
    .const 'Sub' $P503 = "117_1296306519.49046" 
    capture_lex $P503
    .const 'Sub' $P497 = "115_1296306519.49046" 
    capture_lex $P497
    .const 'Sub' $P482 = "111_1296306519.49046" 
    capture_lex $P482
    .const 'Sub' $P476 = "109_1296306519.49046" 
    capture_lex $P476
    .const 'Sub' $P470 = "107_1296306519.49046" 
    capture_lex $P470
    .const 'Sub' $P464 = "105_1296306519.49046" 
    capture_lex $P464
    .const 'Sub' $P458 = "103_1296306519.49046" 
    capture_lex $P458
    .const 'Sub' $P452 = "101_1296306519.49046" 
    capture_lex $P452
    .const 'Sub' $P446 = "99_1296306519.49046" 
    capture_lex $P446
    .const 'Sub' $P437 = "97_1296306519.49046" 
    capture_lex $P437
    .const 'Sub' $P428 = "95_1296306519.49046" 
    capture_lex $P428
    .const 'Sub' $P419 = "93_1296306519.49046" 
    capture_lex $P419
    .const 'Sub' $P404 = "89_1296306519.49046" 
    capture_lex $P404
    .const 'Sub' $P395 = "87_1296306519.49046" 
    capture_lex $P395
    .const 'Sub' $P383 = "83_1296306519.49046" 
    capture_lex $P383
    .const 'Sub' $P376 = "81_1296306519.49046" 
    capture_lex $P376
    .const 'Sub' $P369 = "79_1296306519.49046" 
    capture_lex $P369
    .const 'Sub' $P355 = "75_1296306519.49046" 
    capture_lex $P355
    .const 'Sub' $P347 = "73_1296306519.49046" 
    capture_lex $P347
    .const 'Sub' $P339 = "71_1296306519.49046" 
    capture_lex $P339
    .const 'Sub' $P319 = "69_1296306519.49046" 
    capture_lex $P319
    .const 'Sub' $P310 = "67_1296306519.49046" 
    capture_lex $P310
    .const 'Sub' $P292 = "64_1296306519.49046" 
    capture_lex $P292
    .const 'Sub' $P274 = "62_1296306519.49046" 
    capture_lex $P274
    .const 'Sub' $P263 = "58_1296306519.49046" 
    capture_lex $P263
    .const 'Sub' $P258 = "56_1296306519.49046" 
    capture_lex $P258
    .const 'Sub' $P247 = "52_1296306519.49046" 
    capture_lex $P247
    .const 'Sub' $P242 = "50_1296306519.49046" 
    capture_lex $P242
    .const 'Sub' $P237 = "48_1296306519.49046" 
    capture_lex $P237
    .const 'Sub' $P228 = "46_1296306519.49046" 
    capture_lex $P228
    .const 'Sub' $P221 = "44_1296306519.49046" 
    capture_lex $P221
    .const 'Sub' $P215 = "42_1296306519.49046" 
    capture_lex $P215
    .const 'Sub' $P207 = "40_1296306519.49046" 
    capture_lex $P207
    .const 'Sub' $P201 = "38_1296306519.49046" 
    capture_lex $P201
    .const 'Sub' $P195 = "36_1296306519.49046" 
    capture_lex $P195
    .const 'Sub' $P180 = "33_1296306519.49046" 
    capture_lex $P180
    .const 'Sub' $P166 = "31_1296306519.49046" 
    capture_lex $P166
    .const 'Sub' $P159 = "29_1296306519.49046" 
    capture_lex $P159
    .const 'Sub' $P120 = "26_1296306519.49046" 
    capture_lex $P120
    .const 'Sub' $P105 = "23_1296306519.49046" 
    capture_lex $P105
    .const 'Sub' $P94 = "21_1296306519.49046" 
    capture_lex $P94
    .const 'Sub' $P82 = "19_1296306519.49046" 
    capture_lex $P82
    .const 'Sub' $P74 = "17_1296306519.49046" 
    capture_lex $P74
    .const 'Sub' $P67 = "15_1296306519.49046" 
    capture_lex $P67
    .const 'Sub' $P60 = "13_1296306519.49046" 
    capture_lex $P60
    .const 'Sub' $P18 = "12_1296306519.49046" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "Regex"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    .const 'Sub' $P1187 = "265_1296306519.49046" 
    capture_lex $P1187
    $P1187()
.annotate 'line', 651
    get_hll_global $P1582, ["NQP";"Regex"], "_block1581" 
    capture_lex $P1582
    $P1685 = $P1582()
.annotate 'line', 4
    .return ($P1685)
    .const 'Sub' $P1687 = "398_1296306519.49046" 
    .return ($P1687)
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post401") :outer("11_1296306519.49046")
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P1691 = "399_1296306519.49046" 
    capture_lex $P1691
    $P1691()
.end


.namespace ["NQP";"Grammar"]
.sub "_block1690"  :anon :subid("399_1296306519.49046") :outer("11_1296306519.49046")
.annotate 'line', 4
    get_hll_global $P1692, "NQPClassHOW"
    $P1693 = $P1692."new_type"("Grammar" :named("name"))
    .local pmc type_obj
    set type_obj, $P1693
    set_hll_global ["NQP"], "Grammar", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1694, type_obj
    .const 'Sub' $P1695 = "12_1296306519.49046" 
    $P1694."add_method"(type_obj, "TOP", $P1695)
    get_how $P1696, type_obj
    .const 'Sub' $P1697 = "13_1296306519.49046" 
    $P1696."add_method"(type_obj, "identifier", $P1697)
    get_how $P1698, type_obj
    get_global $P1699, "!PREFIX__identifier"
    $P1698."add_method"(type_obj, "!PREFIX__identifier", $P1699)
    get_how $P1700, type_obj
    .const 'Sub' $P1701 = "15_1296306519.49046" 
    $P1700."add_method"(type_obj, "name", $P1701)
    get_how $P1702, type_obj
    get_global $P1703, "!PREFIX__name"
    $P1702."add_method"(type_obj, "!PREFIX__name", $P1703)
    get_how $P1704, type_obj
    .const 'Sub' $P1705 = "17_1296306519.49046" 
    $P1704."add_method"(type_obj, "deflongname", $P1705)
    get_how $P1706, type_obj
    get_global $P1707, "!PREFIX__deflongname"
    $P1706."add_method"(type_obj, "!PREFIX__deflongname", $P1707)
    get_how $P1708, type_obj
    .const 'Sub' $P1709 = "19_1296306519.49046" 
    $P1708."add_method"(type_obj, "ENDSTMT", $P1709)
    get_how $P1710, type_obj
    get_global $P1711, "!PREFIX__ENDSTMT"
    $P1710."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1711)
    get_how $P1712, type_obj
    .const 'Sub' $P1713 = "21_1296306519.49046" 
    $P1712."add_method"(type_obj, "ws", $P1713)
    get_how $P1714, type_obj
    get_global $P1715, "!PREFIX__ws"
    $P1714."add_method"(type_obj, "!PREFIX__ws", $P1715)
    get_how $P1716, type_obj
    .const 'Sub' $P1717 = "23_1296306519.49046" 
    $P1716."add_method"(type_obj, "unv", $P1717)
    get_how $P1718, type_obj
    get_global $P1719, "!PREFIX__unv"
    $P1718."add_method"(type_obj, "!PREFIX__unv", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "26_1296306519.49046" 
    $P1720."add_method"(type_obj, "pod_comment", $P1721)
    get_how $P1722, type_obj
    get_global $P1723, "!PREFIX__pod_comment"
    $P1722."add_method"(type_obj, "!PREFIX__pod_comment", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "29_1296306519.49046" 
    $P1724."add_method"(type_obj, "comp_unit", $P1725)
    get_how $P1726, type_obj
    get_global $P1727, "!PREFIX__comp_unit"
    $P1726."add_method"(type_obj, "!PREFIX__comp_unit", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "31_1296306519.49046" 
    $P1728."add_method"(type_obj, "statementlist", $P1729)
    get_how $P1730, type_obj
    get_global $P1731, "!PREFIX__statementlist"
    $P1730."add_method"(type_obj, "!PREFIX__statementlist", $P1731)
    get_how $P1732, type_obj
    .const 'Sub' $P1733 = "33_1296306519.49046" 
    $P1732."add_method"(type_obj, "statement", $P1733)
    get_how $P1734, type_obj
    get_global $P1735, "!PREFIX__statement"
    $P1734."add_method"(type_obj, "!PREFIX__statement", $P1735)
    get_how $P1736, type_obj
    .const 'Sub' $P1737 = "36_1296306519.49046" 
    $P1736."add_method"(type_obj, "eat_terminator", $P1737)
    get_how $P1738, type_obj
    get_global $P1739, "!PREFIX__eat_terminator"
    $P1738."add_method"(type_obj, "!PREFIX__eat_terminator", $P1739)
    get_how $P1740, type_obj
    .const 'Sub' $P1741 = "38_1296306519.49046" 
    $P1740."add_method"(type_obj, "xblock", $P1741)
    get_how $P1742, type_obj
    get_global $P1743, "!PREFIX__xblock"
    $P1742."add_method"(type_obj, "!PREFIX__xblock", $P1743)
    get_how $P1744, type_obj
    .const 'Sub' $P1745 = "40_1296306519.49046" 
    $P1744."add_method"(type_obj, "pblock", $P1745)
    get_how $P1746, type_obj
    get_global $P1747, "!PREFIX__pblock"
    $P1746."add_method"(type_obj, "!PREFIX__pblock", $P1747)
    get_how $P1748, type_obj
    .const 'Sub' $P1749 = "42_1296306519.49046" 
    $P1748."add_method"(type_obj, "lambda", $P1749)
    get_how $P1750, type_obj
    get_global $P1751, "!PREFIX__lambda"
    $P1750."add_method"(type_obj, "!PREFIX__lambda", $P1751)
    get_how $P1752, type_obj
    .const 'Sub' $P1753 = "44_1296306519.49046" 
    $P1752."add_method"(type_obj, "block", $P1753)
    get_how $P1754, type_obj
    get_global $P1755, "!PREFIX__block"
    $P1754."add_method"(type_obj, "!PREFIX__block", $P1755)
    get_how $P1756, type_obj
    .const 'Sub' $P1757 = "46_1296306519.49046" 
    $P1756."add_method"(type_obj, "blockoid", $P1757)
    get_how $P1758, type_obj
    get_global $P1759, "!PREFIX__blockoid"
    $P1758."add_method"(type_obj, "!PREFIX__blockoid", $P1759)
    get_how $P1760, type_obj
    .const 'Sub' $P1761 = "48_1296306519.49046" 
    $P1760."add_method"(type_obj, "newpad", $P1761)
    get_how $P1762, type_obj
    get_global $P1763, "!PREFIX__newpad"
    $P1762."add_method"(type_obj, "!PREFIX__newpad", $P1763)
    get_how $P1764, type_obj
    .const 'Sub' $P1765 = "50_1296306519.49046" 
    $P1764."add_method"(type_obj, "outerctx", $P1765)
    get_how $P1766, type_obj
    get_global $P1767, "!PREFIX__outerctx"
    $P1766."add_method"(type_obj, "!PREFIX__outerctx", $P1767)
    get_how $P1768, type_obj
    .const 'Sub' $P1769 = "52_1296306519.49046" 
    $P1768."add_method"(type_obj, "finishpad", $P1769)
    get_how $P1770, type_obj
    get_global $P1771, "!PREFIX__finishpad"
    $P1770."add_method"(type_obj, "!PREFIX__finishpad", $P1771)
    get_how $P1772, type_obj
    .const 'Sub' $P1773 = "54_1296306519.49046" 
    $P1772."add_method"(type_obj, "terminator", $P1773)
    get_how $P1774, type_obj
    .const 'Sub' $P1775 = "55_1296306519.49046" 
    $P1774."add_method"(type_obj, "!PREFIX__terminator", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "56_1296306519.49046" 
    $P1776."add_method"(type_obj, "terminator:sym<;>", $P1777)
    get_how $P1778, type_obj
    get_global $P1779, "!PREFIX__terminator:sym<;>"
    $P1778."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "58_1296306519.49046" 
    $P1780."add_method"(type_obj, "terminator:sym<}>", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__terminator:sym<}>"
    $P1782."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "60_1296306519.49046" 
    $P1784."add_method"(type_obj, "statement_control", $P1785)
    get_how $P1786, type_obj
    .const 'Sub' $P1787 = "61_1296306519.49046" 
    $P1786."add_method"(type_obj, "!PREFIX__statement_control", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "62_1296306519.49046" 
    $P1788."add_method"(type_obj, "statement_control:sym<if>", $P1789)
    get_how $P1790, type_obj
    get_global $P1791, "!PREFIX__statement_control:sym<if>"
    $P1790."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "64_1296306519.49046" 
    $P1792."add_method"(type_obj, "statement_control:sym<unless>", $P1793)
    get_how $P1794, type_obj
    get_global $P1795, "!PREFIX__statement_control:sym<unless>"
    $P1794."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "67_1296306519.49046" 
    $P1796."add_method"(type_obj, "statement_control:sym<while>", $P1797)
    get_how $P1798, type_obj
    get_global $P1799, "!PREFIX__statement_control:sym<while>"
    $P1798."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "69_1296306519.49046" 
    $P1800."add_method"(type_obj, "statement_control:sym<repeat>", $P1801)
    get_how $P1802, type_obj
    get_global $P1803, "!PREFIX__statement_control:sym<repeat>"
    $P1802."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "71_1296306519.49046" 
    $P1804."add_method"(type_obj, "statement_control:sym<for>", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__statement_control:sym<for>"
    $P1806."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "73_1296306519.49046" 
    $P1808."add_method"(type_obj, "statement_control:sym<CATCH>", $P1809)
    get_how $P1810, type_obj
    get_global $P1811, "!PREFIX__statement_control:sym<CATCH>"
    $P1810."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "75_1296306519.49046" 
    $P1812."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1813)
    get_how $P1814, type_obj
    get_global $P1815, "!PREFIX__statement_control:sym<CONTROL>"
    $P1814."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "77_1296306519.49046" 
    $P1816."add_method"(type_obj, "statement_prefix", $P1817)
    get_how $P1818, type_obj
    .const 'Sub' $P1819 = "78_1296306519.49046" 
    $P1818."add_method"(type_obj, "!PREFIX__statement_prefix", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "79_1296306519.49046" 
    $P1820."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1821)
    get_how $P1822, type_obj
    get_global $P1823, "!PREFIX__statement_prefix:sym<INIT>"
    $P1822."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "81_1296306519.49046" 
    $P1824."add_method"(type_obj, "statement_prefix:sym<try>", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__statement_prefix:sym<try>"
    $P1826."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "83_1296306519.49046" 
    $P1828."add_method"(type_obj, "blorst", $P1829)
    get_how $P1830, type_obj
    get_global $P1831, "!PREFIX__blorst"
    $P1830."add_method"(type_obj, "!PREFIX__blorst", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "85_1296306519.49046" 
    $P1832."add_method"(type_obj, "statement_mod_cond", $P1833)
    get_how $P1834, type_obj
    .const 'Sub' $P1835 = "86_1296306519.49046" 
    $P1834."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "87_1296306519.49046" 
    $P1836."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__statement_mod_cond:sym<if>"
    $P1838."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "89_1296306519.49046" 
    $P1840."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1841)
    get_how $P1842, type_obj
    get_global $P1843, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1842."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "91_1296306519.49046" 
    $P1844."add_method"(type_obj, "statement_mod_loop", $P1845)
    get_how $P1846, type_obj
    .const 'Sub' $P1847 = "92_1296306519.49046" 
    $P1846."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "93_1296306519.49046" 
    $P1848."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1849)
    get_how $P1850, type_obj
    get_global $P1851, "!PREFIX__statement_mod_loop:sym<while>"
    $P1850."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "95_1296306519.49046" 
    $P1852."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__statement_mod_loop:sym<until>"
    $P1854."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "97_1296306519.49046" 
    $P1856."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1857)
    get_how $P1858, type_obj
    get_global $P1859, "!PREFIX__statement_mod_loop:sym<for>"
    $P1858."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "99_1296306519.49046" 
    $P1860."add_method"(type_obj, "term:sym<fatarrow>", $P1861)
    get_how $P1862, type_obj
    get_global $P1863, "!PREFIX__term:sym<fatarrow>"
    $P1862."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "101_1296306519.49046" 
    $P1864."add_method"(type_obj, "term:sym<colonpair>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__term:sym<colonpair>"
    $P1866."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "103_1296306519.49046" 
    $P1868."add_method"(type_obj, "term:sym<variable>", $P1869)
    get_how $P1870, type_obj
    get_global $P1871, "!PREFIX__term:sym<variable>"
    $P1870."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "105_1296306519.49046" 
    $P1872."add_method"(type_obj, "term:sym<package_declarator>", $P1873)
    get_how $P1874, type_obj
    get_global $P1875, "!PREFIX__term:sym<package_declarator>"
    $P1874."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "107_1296306519.49046" 
    $P1876."add_method"(type_obj, "term:sym<scope_declarator>", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__term:sym<scope_declarator>"
    $P1878."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "109_1296306519.49046" 
    $P1880."add_method"(type_obj, "term:sym<routine_declarator>", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__term:sym<routine_declarator>"
    $P1882."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "111_1296306519.49046" 
    $P1884."add_method"(type_obj, "term:sym<multi_declarator>", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__term:sym<multi_declarator>"
    $P1886."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "115_1296306519.49046" 
    $P1888."add_method"(type_obj, "term:sym<regex_declarator>", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__term:sym<regex_declarator>"
    $P1890."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "117_1296306519.49046" 
    $P1892."add_method"(type_obj, "term:sym<statement_prefix>", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__term:sym<statement_prefix>"
    $P1894."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "119_1296306519.49046" 
    $P1896."add_method"(type_obj, "term:sym<lambda>", $P1897)
    get_how $P1898, type_obj
    get_global $P1899, "!PREFIX__term:sym<lambda>"
    $P1898."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "121_1296306519.49046" 
    $P1900."add_method"(type_obj, "fatarrow", $P1901)
    get_how $P1902, type_obj
    get_global $P1903, "!PREFIX__fatarrow"
    $P1902."add_method"(type_obj, "!PREFIX__fatarrow", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "123_1296306519.49046" 
    $P1904."add_method"(type_obj, "colonpair", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__colonpair"
    $P1906."add_method"(type_obj, "!PREFIX__colonpair", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "125_1296306519.49046" 
    $P1908."add_method"(type_obj, "variable", $P1909)
    get_how $P1910, type_obj
    get_global $P1911, "!PREFIX__variable"
    $P1910."add_method"(type_obj, "!PREFIX__variable", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "127_1296306519.49046" 
    $P1912."add_method"(type_obj, "sigil", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__sigil"
    $P1914."add_method"(type_obj, "!PREFIX__sigil", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "129_1296306519.49046" 
    $P1916."add_method"(type_obj, "twigil", $P1917)
    get_how $P1918, type_obj
    get_global $P1919, "!PREFIX__twigil"
    $P1918."add_method"(type_obj, "!PREFIX__twigil", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "131_1296306519.49046" 
    $P1920."add_method"(type_obj, "package_declarator", $P1921)
    get_how $P1922, type_obj
    .const 'Sub' $P1923 = "132_1296306519.49046" 
    $P1922."add_method"(type_obj, "!PREFIX__package_declarator", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "133_1296306519.49046" 
    $P1924."add_method"(type_obj, "package_declarator:sym<module>", $P1925)
    get_how $P1926, type_obj
    get_global $P1927, "!PREFIX__package_declarator:sym<module>"
    $P1926."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "135_1296306519.49046" 
    $P1928."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1929)
    get_how $P1930, type_obj
    get_global $P1931, "!PREFIX__package_declarator:sym<knowhow>"
    $P1930."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "137_1296306519.49046" 
    $P1932."add_method"(type_obj, "package_declarator:sym<class>", $P1933)
    get_how $P1934, type_obj
    get_global $P1935, "!PREFIX__package_declarator:sym<class>"
    $P1934."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "139_1296306519.49046" 
    $P1936."add_method"(type_obj, "package_declarator:sym<grammar>", $P1937)
    get_how $P1938, type_obj
    get_global $P1939, "!PREFIX__package_declarator:sym<grammar>"
    $P1938."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "141_1296306519.49046" 
    $P1940."add_method"(type_obj, "package_declarator:sym<role>", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__package_declarator:sym<role>"
    $P1942."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "143_1296306519.49046" 
    $P1944."add_method"(type_obj, "package_declarator:sym<native>", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__package_declarator:sym<native>"
    $P1946."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "145_1296306519.49046" 
    $P1948."add_method"(type_obj, "package_def", $P1949)
    get_how $P1950, type_obj
    get_global $P1951, "!PREFIX__package_def"
    $P1950."add_method"(type_obj, "!PREFIX__package_def", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "147_1296306519.49046" 
    $P1952."add_method"(type_obj, "scope_declarator", $P1953)
    get_how $P1954, type_obj
    .const 'Sub' $P1955 = "148_1296306519.49046" 
    $P1954."add_method"(type_obj, "!PREFIX__scope_declarator", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "149_1296306519.49046" 
    $P1956."add_method"(type_obj, "scope_declarator:sym<my>", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__scope_declarator:sym<my>"
    $P1958."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "151_1296306519.49046" 
    $P1960."add_method"(type_obj, "scope_declarator:sym<our>", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__scope_declarator:sym<our>"
    $P1962."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "153_1296306519.49046" 
    $P1964."add_method"(type_obj, "scope_declarator:sym<has>", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__scope_declarator:sym<has>"
    $P1966."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "155_1296306519.49046" 
    $P1968."add_method"(type_obj, "scoped", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__scoped"
    $P1970."add_method"(type_obj, "!PREFIX__scoped", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "157_1296306519.49046" 
    $P1972."add_method"(type_obj, "typename", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__typename"
    $P1974."add_method"(type_obj, "!PREFIX__typename", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "159_1296306519.49046" 
    $P1976."add_method"(type_obj, "declarator", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__declarator"
    $P1978."add_method"(type_obj, "!PREFIX__declarator", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "161_1296306519.49046" 
    $P1980."add_method"(type_obj, "variable_declarator", $P1981)
    get_how $P1982, type_obj
    get_global $P1983, "!PREFIX__variable_declarator"
    $P1982."add_method"(type_obj, "!PREFIX__variable_declarator", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "163_1296306519.49046" 
    $P1984."add_method"(type_obj, "routine_declarator", $P1985)
    get_how $P1986, type_obj
    .const 'Sub' $P1987 = "164_1296306519.49046" 
    $P1986."add_method"(type_obj, "!PREFIX__routine_declarator", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "165_1296306519.49046" 
    $P1988."add_method"(type_obj, "routine_declarator:sym<sub>", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__routine_declarator:sym<sub>"
    $P1990."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "167_1296306519.49046" 
    $P1992."add_method"(type_obj, "routine_declarator:sym<method>", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__routine_declarator:sym<method>"
    $P1994."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "169_1296306519.49046" 
    $P1996."add_method"(type_obj, "routine_def", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__routine_def"
    $P1998."add_method"(type_obj, "!PREFIX__routine_def", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "171_1296306519.49046" 
    $P2000."add_method"(type_obj, "method_def", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__method_def"
    $P2002."add_method"(type_obj, "!PREFIX__method_def", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "174_1296306519.49046" 
    $P2004."add_method"(type_obj, "onlystar", $P2005)
    get_how $P2006, type_obj
    get_global $P2007, "!PREFIX__onlystar"
    $P2006."add_method"(type_obj, "!PREFIX__onlystar", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "177_1296306519.49046" 
    $P2008."add_method"(type_obj, "multi_declarator", $P2009)
    get_how $P2010, type_obj
    .const 'Sub' $P2011 = "178_1296306519.49046" 
    $P2010."add_method"(type_obj, "!PREFIX__multi_declarator", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "179_1296306519.49046" 
    $P2012."add_method"(type_obj, "multi_declarator:sym<multi>", $P2013)
    get_how $P2014, type_obj
    get_global $P2015, "!PREFIX__multi_declarator:sym<multi>"
    $P2014."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "181_1296306519.49046" 
    $P2016."add_method"(type_obj, "multi_declarator:sym<proto>", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__multi_declarator:sym<proto>"
    $P2018."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "183_1296306519.49046" 
    $P2020."add_method"(type_obj, "multi_declarator:sym<null>", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__multi_declarator:sym<null>"
    $P2022."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "185_1296306519.49046" 
    $P2024."add_method"(type_obj, "signature", $P2025)
    get_how $P2026, type_obj
    get_global $P2027, "!PREFIX__signature"
    $P2026."add_method"(type_obj, "!PREFIX__signature", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "188_1296306519.49046" 
    $P2028."add_method"(type_obj, "parameter", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__parameter"
    $P2030."add_method"(type_obj, "!PREFIX__parameter", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "190_1296306519.49046" 
    $P2032."add_method"(type_obj, "param_var", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__param_var"
    $P2034."add_method"(type_obj, "!PREFIX__param_var", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "192_1296306519.49046" 
    $P2036."add_method"(type_obj, "named_param", $P2037)
    get_how $P2038, type_obj
    get_global $P2039, "!PREFIX__named_param"
    $P2038."add_method"(type_obj, "!PREFIX__named_param", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "194_1296306519.49046" 
    $P2040."add_method"(type_obj, "default_value", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__default_value"
    $P2042."add_method"(type_obj, "!PREFIX__default_value", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "196_1296306519.49046" 
    $P2044."add_method"(type_obj, "trait", $P2045)
    get_how $P2046, type_obj
    get_global $P2047, "!PREFIX__trait"
    $P2046."add_method"(type_obj, "!PREFIX__trait", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "198_1296306519.49046" 
    $P2048."add_method"(type_obj, "trait_mod", $P2049)
    get_how $P2050, type_obj
    .const 'Sub' $P2051 = "199_1296306519.49046" 
    $P2050."add_method"(type_obj, "!PREFIX__trait_mod", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "200_1296306519.49046" 
    $P2052."add_method"(type_obj, "trait_mod:sym<is>", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__trait_mod:sym<is>"
    $P2054."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "202_1296306519.49046" 
    $P2056."add_method"(type_obj, "regex_declarator", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__regex_declarator"
    $P2058."add_method"(type_obj, "!PREFIX__regex_declarator", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "204_1296306519.49046" 
    $P2060."add_method"(type_obj, "dotty", $P2061)
    get_how $P2062, type_obj
    get_global $P2063, "!PREFIX__dotty"
    $P2062."add_method"(type_obj, "!PREFIX__dotty", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "206_1296306519.49046" 
    $P2064."add_method"(type_obj, "term", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "207_1296306519.49046" 
    $P2066."add_method"(type_obj, "!PREFIX__term", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "208_1296306519.49046" 
    $P2068."add_method"(type_obj, "term:sym<self>", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__term:sym<self>"
    $P2070."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "210_1296306519.49046" 
    $P2072."add_method"(type_obj, "term:sym<identifier>", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__term:sym<identifier>"
    $P2074."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "212_1296306519.49046" 
    $P2076."add_method"(type_obj, "term:sym<name>", $P2077)
    get_how $P2078, type_obj
    get_global $P2079, "!PREFIX__term:sym<name>"
    $P2078."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "214_1296306519.49046" 
    $P2080."add_method"(type_obj, "term:sym<pir::op>", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__term:sym<pir::op>"
    $P2082."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "216_1296306519.49046" 
    $P2084."add_method"(type_obj, "term:sym<onlystar>", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__term:sym<onlystar>"
    $P2086."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "219_1296306519.49046" 
    $P2088."add_method"(type_obj, "args", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__args"
    $P2090."add_method"(type_obj, "!PREFIX__args", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "221_1296306519.49046" 
    $P2092."add_method"(type_obj, "arglist", $P2093)
    get_how $P2094, type_obj
    get_global $P2095, "!PREFIX__arglist"
    $P2094."add_method"(type_obj, "!PREFIX__arglist", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "223_1296306519.49046" 
    $P2096."add_method"(type_obj, "term:sym<value>", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__term:sym<value>"
    $P2098."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "225_1296306519.49046" 
    $P2100."add_method"(type_obj, "value", $P2101)
    get_how $P2102, type_obj
    get_global $P2103, "!PREFIX__value"
    $P2102."add_method"(type_obj, "!PREFIX__value", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "227_1296306519.49046" 
    $P2104."add_method"(type_obj, "number", $P2105)
    get_how $P2106, type_obj
    get_global $P2107, "!PREFIX__number"
    $P2106."add_method"(type_obj, "!PREFIX__number", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "229_1296306519.49046" 
    $P2108."add_method"(type_obj, "quote", $P2109)
    get_how $P2110, type_obj
    .const 'Sub' $P2111 = "230_1296306519.49046" 
    $P2110."add_method"(type_obj, "!PREFIX__quote", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "231_1296306519.49046" 
    $P2112."add_method"(type_obj, "quote:sym<apos>", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__quote:sym<apos>"
    $P2114."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "233_1296306519.49046" 
    $P2116."add_method"(type_obj, "quote:sym<dblq>", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__quote:sym<dblq>"
    $P2118."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "235_1296306519.49046" 
    $P2120."add_method"(type_obj, "quote:sym<q>", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__quote:sym<q>"
    $P2122."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "237_1296306519.49046" 
    $P2124."add_method"(type_obj, "quote:sym<qq>", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__quote:sym<qq>"
    $P2126."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "239_1296306519.49046" 
    $P2128."add_method"(type_obj, "quote:sym<Q>", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__quote:sym<Q>"
    $P2130."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "241_1296306519.49046" 
    $P2132."add_method"(type_obj, "quote:sym<Q:PIR>", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__quote:sym<Q:PIR>"
    $P2134."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "243_1296306519.49046" 
    $P2136."add_method"(type_obj, "quote:sym</ />", $P2137)
    get_how $P2138, type_obj
    get_global $P2139, "!PREFIX__quote:sym</ />"
    $P2138."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "245_1296306519.49046" 
    $P2140."add_method"(type_obj, "quote_escape:sym<$>", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, "!PREFIX__quote_escape:sym<$>"
    $P2142."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "247_1296306519.49046" 
    $P2144."add_method"(type_obj, "quote_escape:sym<{ }>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__quote_escape:sym<{ }>"
    $P2146."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "249_1296306519.49046" 
    $P2148."add_method"(type_obj, "quote_escape:sym<esc>", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__quote_escape:sym<esc>"
    $P2150."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "251_1296306519.49046" 
    $P2152."add_method"(type_obj, "circumfix:sym<( )>", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__circumfix:sym<( )>"
    $P2154."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "253_1296306519.49046" 
    $P2156."add_method"(type_obj, "circumfix:sym<[ ]>", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__circumfix:sym<[ ]>"
    $P2158."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "255_1296306519.49046" 
    $P2160."add_method"(type_obj, "circumfix:sym<ang>", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, "!PREFIX__circumfix:sym<ang>"
    $P2162."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "257_1296306519.49046" 
    $P2164."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2166."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "259_1296306519.49046" 
    $P2168."add_method"(type_obj, "circumfix:sym<{ }>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__circumfix:sym<{ }>"
    $P2170."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "261_1296306519.49046" 
    $P2172."add_method"(type_obj, "circumfix:sym<sigil>", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__circumfix:sym<sigil>"
    $P2174."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "263_1296306519.49046" 
    $P2176."add_method"(type_obj, "semilist", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, "!PREFIX__semilist"
    $P2178."add_method"(type_obj, "!PREFIX__semilist", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "266_1296306519.49046" 
    $P2180."add_method"(type_obj, "infixish", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__infixish"
    $P2182."add_method"(type_obj, "!PREFIX__infixish", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "268_1296306519.49046" 
    $P2184."add_method"(type_obj, "infixstopper", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__infixstopper"
    $P2186."add_method"(type_obj, "!PREFIX__infixstopper", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "270_1296306519.49046" 
    $P2188."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2190."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "272_1296306519.49046" 
    $P2192."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, "!PREFIX__postcircumfix:sym<{ }>"
    $P2194."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "274_1296306519.49046" 
    $P2196."add_method"(type_obj, "postcircumfix:sym<ang>", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__postcircumfix:sym<ang>"
    $P2198."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "276_1296306519.49046" 
    $P2200."add_method"(type_obj, "postcircumfix:sym<( )>", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__postcircumfix:sym<( )>"
    $P2202."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "278_1296306519.49046" 
    $P2204."add_method"(type_obj, "postfix:sym<.>", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__postfix:sym<.>"
    $P2206."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "280_1296306519.49046" 
    $P2208."add_method"(type_obj, "prefix:sym<++>", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__prefix:sym<++>"
    $P2210."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "282_1296306519.49046" 
    $P2212."add_method"(type_obj, "prefix:sym<-->", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__prefix:sym<-->"
    $P2214."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "284_1296306519.49046" 
    $P2216."add_method"(type_obj, "postfix:sym<++>", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__postfix:sym<++>"
    $P2218."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "286_1296306519.49046" 
    $P2220."add_method"(type_obj, "postfix:sym<-->", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__postfix:sym<-->"
    $P2222."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "288_1296306519.49046" 
    $P2224."add_method"(type_obj, "infix:sym<**>", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__infix:sym<**>"
    $P2226."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "290_1296306519.49046" 
    $P2228."add_method"(type_obj, "prefix:sym<+>", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__prefix:sym<+>"
    $P2230."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "292_1296306519.49046" 
    $P2232."add_method"(type_obj, "prefix:sym<~>", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__prefix:sym<~>"
    $P2234."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "294_1296306519.49046" 
    $P2236."add_method"(type_obj, "prefix:sym<->", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__prefix:sym<->"
    $P2238."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "296_1296306519.49046" 
    $P2240."add_method"(type_obj, "prefix:sym<?>", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__prefix:sym<?>"
    $P2242."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "298_1296306519.49046" 
    $P2244."add_method"(type_obj, "prefix:sym<!>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__prefix:sym<!>"
    $P2246."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "300_1296306519.49046" 
    $P2248."add_method"(type_obj, "prefix:sym<|>", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__prefix:sym<|>"
    $P2250."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "302_1296306519.49046" 
    $P2252."add_method"(type_obj, "infix:sym<*>", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__infix:sym<*>"
    $P2254."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "304_1296306519.49046" 
    $P2256."add_method"(type_obj, "infix:sym</>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__infix:sym</>"
    $P2258."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "306_1296306519.49046" 
    $P2260."add_method"(type_obj, "infix:sym<%>", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__infix:sym<%>"
    $P2262."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "308_1296306519.49046" 
    $P2264."add_method"(type_obj, "infix:sym<+&>", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__infix:sym<+&>"
    $P2266."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "310_1296306519.49046" 
    $P2268."add_method"(type_obj, "infix:sym<+>", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__infix:sym<+>"
    $P2270."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "312_1296306519.49046" 
    $P2272."add_method"(type_obj, "infix:sym<->", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__infix:sym<->"
    $P2274."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "314_1296306519.49046" 
    $P2276."add_method"(type_obj, "infix:sym<+|>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__infix:sym<+|>"
    $P2278."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "316_1296306519.49046" 
    $P2280."add_method"(type_obj, "infix:sym<+^>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__infix:sym<+^>"
    $P2282."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "318_1296306519.49046" 
    $P2284."add_method"(type_obj, "infix:sym<~>", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__infix:sym<~>"
    $P2286."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "320_1296306519.49046" 
    $P2288."add_method"(type_obj, "infix:sym<==>", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__infix:sym<==>"
    $P2290."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "322_1296306519.49046" 
    $P2292."add_method"(type_obj, "infix:sym<!=>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__infix:sym<!=>"
    $P2294."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "324_1296306519.49046" 
    $P2296."add_method"(type_obj, "infix:sym<<=>", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__infix:sym<<=>"
    $P2298."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "326_1296306519.49046" 
    $P2300."add_method"(type_obj, "infix:sym<>=>", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__infix:sym<>=>"
    $P2302."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "328_1296306519.49046" 
    $P2304."add_method"(type_obj, "infix:sym<<>", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__infix:sym<<>"
    $P2306."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "330_1296306519.49046" 
    $P2308."add_method"(type_obj, "infix:sym<>>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__infix:sym<>>"
    $P2310."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "332_1296306519.49046" 
    $P2312."add_method"(type_obj, "infix:sym<eq>", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__infix:sym<eq>"
    $P2314."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "334_1296306519.49046" 
    $P2316."add_method"(type_obj, "infix:sym<ne>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__infix:sym<ne>"
    $P2318."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "336_1296306519.49046" 
    $P2320."add_method"(type_obj, "infix:sym<le>", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__infix:sym<le>"
    $P2322."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "338_1296306519.49046" 
    $P2324."add_method"(type_obj, "infix:sym<ge>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__infix:sym<ge>"
    $P2326."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "340_1296306519.49046" 
    $P2328."add_method"(type_obj, "infix:sym<lt>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__infix:sym<lt>"
    $P2330."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "342_1296306519.49046" 
    $P2332."add_method"(type_obj, "infix:sym<gt>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__infix:sym<gt>"
    $P2334."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "344_1296306519.49046" 
    $P2336."add_method"(type_obj, "infix:sym<=:=>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__infix:sym<=:=>"
    $P2338."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "346_1296306519.49046" 
    $P2340."add_method"(type_obj, "infix:sym<~~>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__infix:sym<~~>"
    $P2342."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "348_1296306519.49046" 
    $P2344."add_method"(type_obj, "infix:sym<&&>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<&&>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "350_1296306519.49046" 
    $P2348."add_method"(type_obj, "infix:sym<||>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym<||>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "352_1296306519.49046" 
    $P2352."add_method"(type_obj, "infix:sym<//>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__infix:sym<//>"
    $P2354."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "354_1296306519.49046" 
    $P2356."add_method"(type_obj, "infix:sym<?? !!>", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__infix:sym<?? !!>"
    $P2358."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "356_1296306519.49046" 
    $P2360."add_method"(type_obj, "infix:sym<=>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__infix:sym<=>"
    $P2362."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "358_1296306519.49046" 
    $P2364."add_method"(type_obj, "infix:sym<:=>", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__infix:sym<:=>"
    $P2366."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "360_1296306519.49046" 
    $P2368."add_method"(type_obj, "infix:sym<::=>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__infix:sym<::=>"
    $P2370."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "362_1296306519.49046" 
    $P2372."add_method"(type_obj, "infix:sym<,>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__infix:sym<,>"
    $P2374."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "364_1296306519.49046" 
    $P2376."add_method"(type_obj, "prefix:sym<return>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__prefix:sym<return>"
    $P2378."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "367_1296306519.49046" 
    $P2380."add_method"(type_obj, "prefix:sym<make>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__prefix:sym<make>"
    $P2382."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "369_1296306519.49046" 
    $P2384."add_method"(type_obj, "term:sym<last>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__term:sym<last>"
    $P2386."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "371_1296306519.49046" 
    $P2388."add_method"(type_obj, "term:sym<next>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__term:sym<next>"
    $P2390."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "373_1296306519.49046" 
    $P2392."add_method"(type_obj, "term:sym<redo>", $P2393)
    get_how $P2394, type_obj
    get_global $P2395, "!PREFIX__term:sym<redo>"
    $P2394."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2395)
    get_how $P2396, type_obj
    .const 'Sub' $P2397 = "375_1296306519.49046" 
    $P2396."add_method"(type_obj, "smartmatch", $P2397)
    get_how $P2398, type_obj
    get_hll_global $P2399, ["HLL"], "Grammar"
    $P2398."add_parent"(type_obj, $P2399)
    get_how $P2400, type_obj
    $P2401 = $P2400."compose"(type_obj)
    .return ($P2401)
.end


.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1296306519.49046") :outer("11_1296306519.49046")
    .param pmc param_19
.annotate 'line', 4
    .lex "self", param_19
.annotate 'line', 5
    $P20 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P20
.annotate 'line', 12
    $P21 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P21
.annotate 'line', 20
    new $P22, "Undef"
    .lex "$*DEFAULT-METAATTR", $P22
.annotate 'line', 21
    $P23 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P23
.annotate 'line', 24
    new $P24, "Undef"
    .lex "$*SCOPE", $P24
.annotate 'line', 25
    new $P25, "Undef"
    .lex "$*MULTINESS", $P25
.annotate 'line', 26
    new $P26, "Undef"
    .lex "$*INVOCANT_OK", $P26
.annotate 'line', 27
    new $P27, "Undef"
    .lex "$*RETURN_USED", $P27
.annotate 'line', 28
    new $P28, "Undef"
    .lex "$*PACKAGE-SETUP", $P28
.annotate 'line', 4
    find_lex $P29, "%*LANG"
    unless_null $P29, vivify_402
    get_hll_global $P29, "%LANG"
    unless_null $P29, vivify_403
    die "Contextual %*LANG not found"
  vivify_403:
  vivify_402:
.annotate 'line', 6
    get_hll_global $P30, ["NQP"], "Regex"
    find_lex $P31, "%*LANG"
    unless_null $P31, vivify_404
    get_hll_global $P31, "%LANG"
    unless_null $P31, vivify_405
    die "Contextual %*LANG not found"
  vivify_405:
    store_lex "%*LANG", $P31
  vivify_404:
    set $P31["Regex"], $P30
.annotate 'line', 7
    get_hll_global $P32, ["NQP"], "RegexActions"
    find_lex $P33, "%*LANG"
    unless_null $P33, vivify_406
    get_hll_global $P33, "%LANG"
    unless_null $P33, vivify_407
    die "Contextual %*LANG not found"
  vivify_407:
    store_lex "%*LANG", $P33
  vivify_406:
    set $P33["Regex-actions"], $P32
.annotate 'line', 8
    get_hll_global $P34, ["NQP"], "Grammar"
    find_lex $P35, "%*LANG"
    unless_null $P35, vivify_408
    get_hll_global $P35, "%LANG"
    unless_null $P35, vivify_409
    die "Contextual %*LANG not found"
  vivify_409:
    store_lex "%*LANG", $P35
  vivify_408:
    set $P35["MAIN"], $P34
.annotate 'line', 9
    get_hll_global $P36, ["NQP"], "Actions"
    find_lex $P37, "%*LANG"
    unless_null $P37, vivify_410
    get_hll_global $P37, "%LANG"
    unless_null $P37, vivify_411
    die "Contextual %*LANG not found"
  vivify_411:
    store_lex "%*LANG", $P37
  vivify_410:
    set $P37["MAIN-actions"], $P36
    find_lex $P38, "%*HOW"
    unless_null $P38, vivify_412
    get_hll_global $P38, "%HOW"
    unless_null $P38, vivify_413
    die "Contextual %*HOW not found"
  vivify_413:
  vivify_412:
.annotate 'line', 13
    new $P39, "String"
    assign $P39, "KnowHOW"
    find_lex $P40, "%*HOW"
    unless_null $P40, vivify_414
    get_hll_global $P40, "%HOW"
    unless_null $P40, vivify_415
    die "Contextual %*HOW not found"
  vivify_415:
    store_lex "%*HOW", $P40
  vivify_414:
    set $P40["knowhow"], $P39
.annotate 'line', 14
    new $P41, "String"
    assign $P41, "NQPClassHOW"
    find_lex $P42, "%*HOW"
    unless_null $P42, vivify_416
    get_hll_global $P42, "%HOW"
    unless_null $P42, vivify_417
    die "Contextual %*HOW not found"
  vivify_417:
    store_lex "%*HOW", $P42
  vivify_416:
    set $P42["class"], $P41
.annotate 'line', 15
    new $P43, "String"
    assign $P43, "NQPClassHOW"
    find_lex $P44, "%*HOW"
    unless_null $P44, vivify_418
    get_hll_global $P44, "%HOW"
    unless_null $P44, vivify_419
    die "Contextual %*HOW not found"
  vivify_419:
    store_lex "%*HOW", $P44
  vivify_418:
    set $P44["grammar"], $P43
.annotate 'line', 16
    new $P45, "String"
    assign $P45, "NQPRoleHOW"
    find_lex $P46, "%*HOW"
    unless_null $P46, vivify_420
    get_hll_global $P46, "%HOW"
    unless_null $P46, vivify_421
    die "Contextual %*HOW not found"
  vivify_421:
    store_lex "%*HOW", $P46
  vivify_420:
    set $P46["role"], $P45
.annotate 'line', 17
    new $P47, "String"
    assign $P47, "NQPNativeHOW"
    find_lex $P48, "%*HOW"
    unless_null $P48, vivify_422
    get_hll_global $P48, "%HOW"
    unless_null $P48, vivify_423
    die "Contextual %*HOW not found"
  vivify_423:
    store_lex "%*HOW", $P48
  vivify_422:
    set $P48["native"], $P47
.annotate 'line', 20
    new $P49, "String"
    assign $P49, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P49
    find_lex $P50, "%*HOW-METAATTR"
    unless_null $P50, vivify_424
    get_hll_global $P50, "%HOW-METAATTR"
    unless_null $P50, vivify_425
    die "Contextual %*HOW-METAATTR not found"
  vivify_425:
  vivify_424:
.annotate 'line', 22
    new $P51, "String"
    assign $P51, "KnowHOWAttribute"
    find_lex $P52, "%*HOW-METAATTR"
    unless_null $P52, vivify_426
    get_hll_global $P52, "%HOW-METAATTR"
    unless_null $P52, vivify_427
    die "Contextual %*HOW-METAATTR not found"
  vivify_427:
    store_lex "%*HOW-METAATTR", $P52
  vivify_426:
    set $P52["knowhow"], $P51
.annotate 'line', 24
    new $P53, "String"
    assign $P53, ""
    store_lex "$*SCOPE", $P53
.annotate 'line', 25
    new $P54, "String"
    assign $P54, ""
    store_lex "$*MULTINESS", $P54
.annotate 'line', 26
    new $P55, "Integer"
    assign $P55, 0
    store_lex "$*INVOCANT_OK", $P55
.annotate 'line', 27
    new $P56, "Integer"
    assign $P56, 0
    store_lex "$*RETURN_USED", $P56
    find_lex $P57, "$*PACKAGE-SETUP"
    unless_null $P57, vivify_428
    get_hll_global $P57, "$PACKAGE-SETUP"
    unless_null $P57, vivify_429
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_429:
  vivify_428:
.annotate 'line', 29
    find_lex $P58, "self"
    $P59 = $P58."comp_unit"()
.annotate 'line', 4
    .return ($P59)
.end


.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx61_tgt
    .local int rx61_pos
    .local int rx61_off
    .local int rx61_eos
    .local int rx61_rep
    .local pmc rx61_cur
    .local pmc rx61_debug
    (rx61_cur, rx61_pos, rx61_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx61_cur
    .local pmc match
    .lex "$/", match
    length rx61_eos, rx61_tgt
    gt rx61_pos, rx61_eos, rx61_done
    set rx61_off, 0
    lt rx61_pos, 2, rx61_start
    sub rx61_off, rx61_pos, 1
    substr rx61_tgt, rx61_tgt, rx61_off
  rx61_start:
    eq $I10, 1, rx61_restart
    if_null rx61_debug, debug_430
    rx61_cur."!cursor_debug"("START", "identifier")
  debug_430:
    $I10 = self.'from'()
    ne $I10, -1, rxscan65_done
    goto rxscan65_scan
  rxscan65_loop:
    (rx61_pos) = rx61_cur."from"()
    inc rx61_pos
    rx61_cur."!cursor_from"(rx61_pos)
    ge rx61_pos, rx61_eos, rxscan65_done
  rxscan65_scan:
    set_addr $I10, rxscan65_loop
    rx61_cur."!mark_push"(0, rx61_pos, $I10)
  rxscan65_done:
.annotate 'line', 34
  # rx subrule "ident" subtype=method negate=
    rx61_cur."!cursor_pos"(rx61_pos)
    $P10 = rx61_cur."ident"()
    unless $P10, rx61_fail
    rx61_pos = $P10."pos"()
  # rx rxquantr66 ** 0..*
    set_addr $I10, rxquantr66_done
    rx61_cur."!mark_push"(0, rx61_pos, $I10)
  rxquantr66_loop:
  # rx enumcharlist negate=0 
    ge rx61_pos, rx61_eos, rx61_fail
    sub $I10, rx61_pos, rx61_off
    substr $S10, rx61_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx61_fail
    inc rx61_pos
  # rx subrule "ident" subtype=method negate=
    rx61_cur."!cursor_pos"(rx61_pos)
    $P10 = rx61_cur."ident"()
    unless $P10, rx61_fail
    rx61_pos = $P10."pos"()
    set_addr $I10, rxquantr66_done
    (rx61_rep) = rx61_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr66_done
    rx61_cur."!mark_push"(rx61_rep, rx61_pos, $I10)
    goto rxquantr66_loop
  rxquantr66_done:
  # rx pass
    rx61_cur."!cursor_pass"(rx61_pos, "identifier")
    if_null rx61_debug, debug_431
    rx61_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx61_pos)
  debug_431:
    .return (rx61_cur)
  rx61_restart:
.annotate 'line', 4
    if_null rx61_debug, debug_432
    rx61_cur."!cursor_debug"("NEXT", "identifier")
  debug_432:
  rx61_fail:
    (rx61_rep, rx61_pos, $I10, $P10) = rx61_cur."!mark_fail"(0)
    lt rx61_pos, -1, rx61_done
    eq rx61_pos, -1, rx61_fail
    jump $I10
  rx61_done:
    rx61_cur."!cursor_fail"()
    if_null rx61_debug, debug_433
    rx61_cur."!cursor_debug"("FAIL", "identifier")
  debug_433:
    .return (rx61_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1296306519.49046") :method
.annotate 'line', 4
    $P63 = self."!PREFIX__!subrule"("ident", "")
    new $P64, "ResizablePMCArray"
    push $P64, $P63
    .return ($P64)
.end


.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx68_tgt
    .local int rx68_pos
    .local int rx68_off
    .local int rx68_eos
    .local int rx68_rep
    .local pmc rx68_cur
    .local pmc rx68_debug
    (rx68_cur, rx68_pos, rx68_tgt, $I10) = self."!cursor_start"()
    rx68_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx68_cur
    .local pmc match
    .lex "$/", match
    length rx68_eos, rx68_tgt
    gt rx68_pos, rx68_eos, rx68_done
    set rx68_off, 0
    lt rx68_pos, 2, rx68_start
    sub rx68_off, rx68_pos, 1
    substr rx68_tgt, rx68_tgt, rx68_off
  rx68_start:
    eq $I10, 1, rx68_restart
    if_null rx68_debug, debug_434
    rx68_cur."!cursor_debug"("START", "name")
  debug_434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan71_done
    goto rxscan71_scan
  rxscan71_loop:
    (rx68_pos) = rx68_cur."from"()
    inc rx68_pos
    rx68_cur."!cursor_from"(rx68_pos)
    ge rx68_pos, rx68_eos, rxscan71_done
  rxscan71_scan:
    set_addr $I10, rxscan71_loop
    rx68_cur."!mark_push"(0, rx68_pos, $I10)
  rxscan71_done:
.annotate 'line', 36
  # rx rxquantr72 ** 1..*
    set_addr $I10, rxquantr72_done
    rx68_cur."!mark_push"(0, -1, $I10)
  rxquantr72_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx68_cur."!cursor_pos"(rx68_pos)
    $P10 = rx68_cur."identifier"()
    unless $P10, rx68_fail
    goto rxsubrule73_pass
  rxsubrule73_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx68_fail
  rxsubrule73_pass:
    set_addr $I10, rxsubrule73_back
    rx68_cur."!mark_push"(0, rx68_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx68_pos = $P10."pos"()
    set_addr $I10, rxquantr72_done
    (rx68_rep) = rx68_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr72_done
    rx68_cur."!mark_push"(rx68_rep, rx68_pos, $I10)
  # rx literal  "::"
    add $I11, rx68_pos, 2
    gt $I11, rx68_eos, rx68_fail
    sub $I11, rx68_pos, rx68_off
    substr $S10, rx68_tgt, $I11, 2
    ne $S10, "::", rx68_fail
    add rx68_pos, 2
    goto rxquantr72_loop
  rxquantr72_done:
  # rx pass
    rx68_cur."!cursor_pass"(rx68_pos, "name")
    if_null rx68_debug, debug_435
    rx68_cur."!cursor_debug"("PASS", "name", " at pos=", rx68_pos)
  debug_435:
    .return (rx68_cur)
  rx68_restart:
.annotate 'line', 4
    if_null rx68_debug, debug_436
    rx68_cur."!cursor_debug"("NEXT", "name")
  debug_436:
  rx68_fail:
    (rx68_rep, rx68_pos, $I10, $P10) = rx68_cur."!mark_fail"(0)
    lt rx68_pos, -1, rx68_done
    eq rx68_pos, -1, rx68_fail
    jump $I10
  rx68_done:
    rx68_cur."!cursor_fail"()
    if_null rx68_debug, debug_437
    rx68_cur."!cursor_debug"("FAIL", "name")
  debug_437:
    .return (rx68_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1296306519.49046") :method
.annotate 'line', 4
    new $P70, "ResizablePMCArray"
    push $P70, ""
    .return ($P70)
.end


.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx75_tgt
    .local int rx75_pos
    .local int rx75_off
    .local int rx75_eos
    .local int rx75_rep
    .local pmc rx75_cur
    .local pmc rx75_debug
    (rx75_cur, rx75_pos, rx75_tgt, $I10) = self."!cursor_start"()
    rx75_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx75_cur
    .local pmc match
    .lex "$/", match
    length rx75_eos, rx75_tgt
    gt rx75_pos, rx75_eos, rx75_done
    set rx75_off, 0
    lt rx75_pos, 2, rx75_start
    sub rx75_off, rx75_pos, 1
    substr rx75_tgt, rx75_tgt, rx75_off
  rx75_start:
    eq $I10, 1, rx75_restart
    if_null rx75_debug, debug_438
    rx75_cur."!cursor_debug"("START", "deflongname")
  debug_438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan79_done
    goto rxscan79_scan
  rxscan79_loop:
    (rx75_pos) = rx75_cur."from"()
    inc rx75_pos
    rx75_cur."!cursor_from"(rx75_pos)
    ge rx75_pos, rx75_eos, rxscan79_done
  rxscan79_scan:
    set_addr $I10, rxscan79_loop
    rx75_cur."!mark_push"(0, rx75_pos, $I10)
  rxscan79_done:
.annotate 'line', 39
  # rx subrule "identifier" subtype=capture negate=
    rx75_cur."!cursor_pos"(rx75_pos)
    $P10 = rx75_cur."identifier"()
    unless $P10, rx75_fail
    rx75_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx75_pos = $P10."pos"()
  # rx rxquantr80 ** 0..1
    set_addr $I10, rxquantr80_done
    rx75_cur."!mark_push"(0, rx75_pos, $I10)
  rxquantr80_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx75_cur."!cursor_pos"(rx75_pos)
    $P10 = rx75_cur."colonpair"()
    unless $P10, rx75_fail
    goto rxsubrule81_pass
  rxsubrule81_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx75_fail
  rxsubrule81_pass:
    set_addr $I10, rxsubrule81_back
    rx75_cur."!mark_push"(0, rx75_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx75_pos = $P10."pos"()
    set_addr $I10, rxquantr80_done
    (rx75_rep) = rx75_cur."!mark_commit"($I10)
  rxquantr80_done:
.annotate 'line', 38
  # rx pass
    rx75_cur."!cursor_pass"(rx75_pos, "deflongname")
    if_null rx75_debug, debug_439
    rx75_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx75_pos)
  debug_439:
    .return (rx75_cur)
  rx75_restart:
.annotate 'line', 4
    if_null rx75_debug, debug_440
    rx75_cur."!cursor_debug"("NEXT", "deflongname")
  debug_440:
  rx75_fail:
    (rx75_rep, rx75_pos, $I10, $P10) = rx75_cur."!mark_fail"(0)
    lt rx75_pos, -1, rx75_done
    eq rx75_pos, -1, rx75_fail
    jump $I10
  rx75_done:
    rx75_cur."!cursor_fail"()
    if_null rx75_debug, debug_441
    rx75_cur."!cursor_debug"("FAIL", "deflongname")
  debug_441:
    .return (rx75_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1296306519.49046") :method
.annotate 'line', 4
    $P77 = self."!PREFIX__!subrule"("identifier", "")
    new $P78, "ResizablePMCArray"
    push $P78, $P77
    .return ($P78)
.end


.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx83_tgt
    .local int rx83_pos
    .local int rx83_off
    .local int rx83_eos
    .local int rx83_rep
    .local pmc rx83_cur
    .local pmc rx83_debug
    (rx83_cur, rx83_pos, rx83_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx83_cur
    .local pmc match
    .lex "$/", match
    length rx83_eos, rx83_tgt
    gt rx83_pos, rx83_eos, rx83_done
    set rx83_off, 0
    lt rx83_pos, 2, rx83_start
    sub rx83_off, rx83_pos, 1
    substr rx83_tgt, rx83_tgt, rx83_off
  rx83_start:
    eq $I10, 1, rx83_restart
    if_null rx83_debug, debug_442
    rx83_cur."!cursor_debug"("START", "ENDSTMT")
  debug_442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan86_done
    goto rxscan86_scan
  rxscan86_loop:
    (rx83_pos) = rx83_cur."from"()
    inc rx83_pos
    rx83_cur."!cursor_from"(rx83_pos)
    ge rx83_pos, rx83_eos, rxscan86_done
  rxscan86_scan:
    set_addr $I10, rxscan86_loop
    rx83_cur."!mark_push"(0, rx83_pos, $I10)
  rxscan86_done:
.annotate 'line', 46
  # rx rxquantr87 ** 0..1
    set_addr $I10, rxquantr87_done
    rx83_cur."!mark_push"(0, rx83_pos, $I10)
  rxquantr87_loop:
  alt88_0:
.annotate 'line', 43
    set_addr $I10, alt88_1
    rx83_cur."!mark_push"(0, rx83_pos, $I10)
.annotate 'line', 44
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx83_pos, rx83_off
    set rx83_rep, 0
    sub $I12, rx83_eos, rx83_pos
  rxenumcharlistq89_loop:
    le $I12, 0, rxenumcharlistq89_done
    substr $S10, rx83_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq89_done
    inc rx83_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq89_loop
  rxenumcharlistq89_done:
    add rx83_pos, rx83_pos, rx83_rep
  # rxanchor eol
    sub $I10, rx83_pos, rx83_off
    is_cclass $I11, 4096, rx83_tgt, $I10
    if $I11, rxanchor90_done
    ne rx83_pos, rx83_eos, rx83_fail
    eq rx83_pos, 0, rxanchor90_done
    dec $I10
    is_cclass $I11, 4096, rx83_tgt, $I10
    if $I11, rx83_fail
  rxanchor90_done:
  # rx subrule "ws" subtype=method negate=
    rx83_cur."!cursor_pos"(rx83_pos)
    $P10 = rx83_cur."ws"()
    unless $P10, rx83_fail
    rx83_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx83_cur."!cursor_pos"(rx83_pos)
    $P10 = rx83_cur."MARKER"("endstmt")
    unless $P10, rx83_fail
    goto alt88_end
  alt88_1:
.annotate 'line', 45
  # rx rxquantr91 ** 0..1
    set_addr $I10, rxquantr91_done
    rx83_cur."!mark_push"(0, rx83_pos, $I10)
  rxquantr91_loop:
  # rx subrule "unv" subtype=method negate=
    rx83_cur."!cursor_pos"(rx83_pos)
    $P10 = rx83_cur."unv"()
    unless $P10, rx83_fail
    goto rxsubrule92_pass
  rxsubrule92_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx83_fail
  rxsubrule92_pass:
    set_addr $I10, rxsubrule92_back
    rx83_cur."!mark_push"(0, rx83_pos, $I10, $P10)
    rx83_pos = $P10."pos"()
    set_addr $I10, rxquantr91_done
    (rx83_rep) = rx83_cur."!mark_commit"($I10)
  rxquantr91_done:
  # rxanchor eol
    sub $I10, rx83_pos, rx83_off
    is_cclass $I11, 4096, rx83_tgt, $I10
    if $I11, rxanchor93_done
    ne rx83_pos, rx83_eos, rx83_fail
    eq rx83_pos, 0, rxanchor93_done
    dec $I10
    is_cclass $I11, 4096, rx83_tgt, $I10
    if $I11, rx83_fail
  rxanchor93_done:
  # rx subrule "ws" subtype=method negate=
    rx83_cur."!cursor_pos"(rx83_pos)
    $P10 = rx83_cur."ws"()
    unless $P10, rx83_fail
    rx83_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx83_cur."!cursor_pos"(rx83_pos)
    $P10 = rx83_cur."MARKER"("endstmt")
    unless $P10, rx83_fail
  alt88_end:
.annotate 'line', 46
    set_addr $I10, rxquantr87_done
    (rx83_rep) = rx83_cur."!mark_commit"($I10)
  rxquantr87_done:
.annotate 'line', 42
  # rx pass
    rx83_cur."!cursor_pass"(rx83_pos, "ENDSTMT")
    if_null rx83_debug, debug_443
    rx83_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx83_pos)
  debug_443:
    .return (rx83_cur)
  rx83_restart:
.annotate 'line', 4
    if_null rx83_debug, debug_444
    rx83_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_444:
  rx83_fail:
    (rx83_rep, rx83_pos, $I10, $P10) = rx83_cur."!mark_fail"(0)
    lt rx83_pos, -1, rx83_done
    eq rx83_pos, -1, rx83_fail
    jump $I10
  rx83_done:
    rx83_cur."!cursor_fail"()
    if_null rx83_debug, debug_445
    rx83_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_445:
    .return (rx83_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1296306519.49046") :method
.annotate 'line', 4
    new $P85, "ResizablePMCArray"
    push $P85, ""
    .return ($P85)
.end


.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx95_tgt
    .local int rx95_pos
    .local int rx95_off
    .local int rx95_eos
    .local int rx95_rep
    .local pmc rx95_cur
    .local pmc rx95_debug
    (rx95_cur, rx95_pos, rx95_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx95_cur
    .local pmc match
    .lex "$/", match
    length rx95_eos, rx95_tgt
    gt rx95_pos, rx95_eos, rx95_done
    set rx95_off, 0
    lt rx95_pos, 2, rx95_start
    sub rx95_off, rx95_pos, 1
    substr rx95_tgt, rx95_tgt, rx95_off
  rx95_start:
    eq $I10, 1, rx95_restart
    if_null rx95_debug, debug_446
    rx95_cur."!cursor_debug"("START", "ws")
  debug_446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan98_done
    goto rxscan98_scan
  rxscan98_loop:
    (rx95_pos) = rx95_cur."from"()
    inc rx95_pos
    rx95_cur."!cursor_from"(rx95_pos)
    ge rx95_pos, rx95_eos, rxscan98_done
  rxscan98_scan:
    set_addr $I10, rxscan98_loop
    rx95_cur."!mark_push"(0, rx95_pos, $I10)
  rxscan98_done:
  alt99_0:
.annotate 'line', 49
    set_addr $I10, alt99_1
    rx95_cur."!mark_push"(0, rx95_pos, $I10)
.annotate 'line', 50
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx95_cur."!cursor_pos"(rx95_pos)
    $P10 = rx95_cur."MARKED"("ws")
    unless $P10, rx95_fail
    goto alt99_end
  alt99_1:
.annotate 'line', 51
  # rx subrule "ww" subtype=zerowidth negate=1
    rx95_cur."!cursor_pos"(rx95_pos)
    $P10 = rx95_cur."ww"()
    if $P10, rx95_fail
.annotate 'line', 56
  # rx rxquantr100 ** 0..*
    set_addr $I10, rxquantr100_done
    rx95_cur."!mark_push"(0, rx95_pos, $I10)
  rxquantr100_loop:
  alt101_0:
.annotate 'line', 52
    set_addr $I10, alt101_1
    rx95_cur."!mark_push"(0, rx95_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx95_pos, rx95_off
    set rx95_rep, 0
    sub $I12, rx95_eos, rx95_pos
  rxenumcharlistq102_loop:
    le $I12, 0, rxenumcharlistq102_done
    substr $S10, rx95_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq102_done
    inc rx95_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq102_loop
  rxenumcharlistq102_done:
    lt rx95_rep, 1, rx95_fail
    add rx95_pos, rx95_pos, rx95_rep
    goto alt101_end
  alt101_1:
    set_addr $I10, alt101_2
    rx95_cur."!mark_push"(0, rx95_pos, $I10)
.annotate 'line', 53
  # rx literal  "#"
    add $I11, rx95_pos, 1
    gt $I11, rx95_eos, rx95_fail
    sub $I11, rx95_pos, rx95_off
    ord $I11, rx95_tgt, $I11
    ne $I11, 35, rx95_fail
    add rx95_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx95_pos, rx95_off
    find_cclass $I11, 4096, rx95_tgt, $I10, rx95_eos
    add rx95_pos, rx95_off, $I11
    goto alt101_end
  alt101_2:
    set_addr $I10, alt101_3
    rx95_cur."!mark_push"(0, rx95_pos, $I10)
.annotate 'line', 54
  # rxanchor bol
    eq rx95_pos, 0, rxanchor103_done
    ge rx95_pos, rx95_eos, rx95_fail
    sub $I10, rx95_pos, rx95_off
    dec $I10
    is_cclass $I11, 4096, rx95_tgt, $I10
    unless $I11, rx95_fail
  rxanchor103_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx95_cur."!cursor_pos"(rx95_pos)
    $P10 = rx95_cur."pod_comment"()
    unless $P10, rx95_fail
    rx95_pos = $P10."pos"()
    goto alt101_end
  alt101_3:
.annotate 'line', 55
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx95_pos, rx95_off
    set rx95_rep, 0
    sub $I12, rx95_eos, rx95_pos
  rxenumcharlistq104_loop:
    le $I12, 0, rxenumcharlistq104_done
    substr $S10, rx95_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq104_done
    inc rx95_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq104_loop
  rxenumcharlistq104_done:
    lt rx95_rep, 1, rx95_fail
    add rx95_pos, rx95_pos, rx95_rep
  alt101_end:
.annotate 'line', 56
    set_addr $I10, rxquantr100_done
    (rx95_rep) = rx95_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr100_done
    rx95_cur."!mark_push"(rx95_rep, rx95_pos, $I10)
    goto rxquantr100_loop
  rxquantr100_done:
.annotate 'line', 57
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx95_cur."!cursor_pos"(rx95_pos)
    $P10 = rx95_cur."MARKER"("ws")
    unless $P10, rx95_fail
  alt99_end:
.annotate 'line', 49
  # rx pass
    rx95_cur."!cursor_pass"(rx95_pos, "ws")
    if_null rx95_debug, debug_447
    rx95_cur."!cursor_debug"("PASS", "ws", " at pos=", rx95_pos)
  debug_447:
    .return (rx95_cur)
  rx95_restart:
.annotate 'line', 4
    if_null rx95_debug, debug_448
    rx95_cur."!cursor_debug"("NEXT", "ws")
  debug_448:
  rx95_fail:
    (rx95_rep, rx95_pos, $I10, $P10) = rx95_cur."!mark_fail"(0)
    lt rx95_pos, -1, rx95_done
    eq rx95_pos, -1, rx95_fail
    jump $I10
  rx95_done:
    rx95_cur."!cursor_fail"()
    if_null rx95_debug, debug_449
    rx95_cur."!cursor_debug"("FAIL", "ws")
  debug_449:
    .return (rx95_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1296306519.49046") :method
.annotate 'line', 4
    new $P97, "ResizablePMCArray"
    push $P97, ""
    push $P97, ""
    .return ($P97)
.end


.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P113 = "25_1296306519.49046" 
    capture_lex $P113
    .local string rx106_tgt
    .local int rx106_pos
    .local int rx106_off
    .local int rx106_eos
    .local int rx106_rep
    .local pmc rx106_cur
    .local pmc rx106_debug
    (rx106_cur, rx106_pos, rx106_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx106_cur
    .local pmc match
    .lex "$/", match
    length rx106_eos, rx106_tgt
    gt rx106_pos, rx106_eos, rx106_done
    set rx106_off, 0
    lt rx106_pos, 2, rx106_start
    sub rx106_off, rx106_pos, 1
    substr rx106_tgt, rx106_tgt, rx106_off
  rx106_start:
    eq $I10, 1, rx106_restart
    if_null rx106_debug, debug_450
    rx106_cur."!cursor_debug"("START", "unv")
  debug_450:
    $I10 = self.'from'()
    ne $I10, -1, rxscan109_done
    goto rxscan109_scan
  rxscan109_loop:
    (rx106_pos) = rx106_cur."from"()
    inc rx106_pos
    rx106_cur."!cursor_from"(rx106_pos)
    ge rx106_pos, rx106_eos, rxscan109_done
  rxscan109_scan:
    set_addr $I10, rxscan109_loop
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
  rxscan109_done:
  alt110_0:
.annotate 'line', 62
    set_addr $I10, alt110_1
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
.annotate 'line', 63
  # rxanchor bol
    eq rx106_pos, 0, rxanchor111_done
    ge rx106_pos, rx106_eos, rx106_fail
    sub $I10, rx106_pos, rx106_off
    dec $I10
    is_cclass $I11, 4096, rx106_tgt, $I10
    unless $I11, rx106_fail
  rxanchor111_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx106_cur."!cursor_pos"(rx106_pos)
    .const 'Sub' $P113 = "25_1296306519.49046" 
    capture_lex $P113
    $P10 = rx106_cur."before"($P113)
    unless $P10, rx106_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx106_cur."!cursor_pos"(rx106_pos)
    $P10 = rx106_cur."pod_comment"()
    unless $P10, rx106_fail
    rx106_pos = $P10."pos"()
    goto alt110_end
  alt110_1:
    set_addr $I10, alt110_2
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
.annotate 'line', 64
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx106_pos, rx106_off
    set rx106_rep, 0
    sub $I12, rx106_eos, rx106_pos
  rxenumcharlistq118_loop:
    le $I12, 0, rxenumcharlistq118_done
    substr $S10, rx106_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq118_done
    inc rx106_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq118_loop
  rxenumcharlistq118_done:
    add rx106_pos, rx106_pos, rx106_rep
  # rx literal  "#"
    add $I11, rx106_pos, 1
    gt $I11, rx106_eos, rx106_fail
    sub $I11, rx106_pos, rx106_off
    ord $I11, rx106_tgt, $I11
    ne $I11, 35, rx106_fail
    add rx106_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx106_pos, rx106_off
    find_cclass $I11, 4096, rx106_tgt, $I10, rx106_eos
    add rx106_pos, rx106_off, $I11
    goto alt110_end
  alt110_2:
.annotate 'line', 65
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx106_pos, rx106_off
    set rx106_rep, 0
    sub $I12, rx106_eos, rx106_pos
  rxenumcharlistq119_loop:
    le $I12, 0, rxenumcharlistq119_done
    substr $S10, rx106_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq119_done
    inc rx106_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq119_loop
  rxenumcharlistq119_done:
    lt rx106_rep, 1, rx106_fail
    add rx106_pos, rx106_pos, rx106_rep
  alt110_end:
.annotate 'line', 60
  # rx pass
    rx106_cur."!cursor_pass"(rx106_pos, "unv")
    if_null rx106_debug, debug_455
    rx106_cur."!cursor_debug"("PASS", "unv", " at pos=", rx106_pos)
  debug_455:
    .return (rx106_cur)
  rx106_restart:
.annotate 'line', 4
    if_null rx106_debug, debug_456
    rx106_cur."!cursor_debug"("NEXT", "unv")
  debug_456:
  rx106_fail:
    (rx106_rep, rx106_pos, $I10, $P10) = rx106_cur."!mark_fail"(0)
    lt rx106_pos, -1, rx106_done
    eq rx106_pos, -1, rx106_fail
    jump $I10
  rx106_done:
    rx106_cur."!cursor_fail"()
    if_null rx106_debug, debug_457
    rx106_cur."!cursor_debug"("FAIL", "unv")
  debug_457:
    .return (rx106_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1296306519.49046") :method
.annotate 'line', 4
    new $P108, "ResizablePMCArray"
    push $P108, ""
    push $P108, ""
    push $P108, ""
    .return ($P108)
.end


.namespace ["NQP";"Grammar"]
.sub "_block112"  :anon :subid("25_1296306519.49046") :method :outer("23_1296306519.49046")
.annotate 'line', 63
    .local string rx114_tgt
    .local int rx114_pos
    .local int rx114_off
    .local int rx114_eos
    .local int rx114_rep
    .local pmc rx114_cur
    .local pmc rx114_debug
    (rx114_cur, rx114_pos, rx114_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx114_cur
    .local pmc match
    .lex "$/", match
    length rx114_eos, rx114_tgt
    gt rx114_pos, rx114_eos, rx114_done
    set rx114_off, 0
    lt rx114_pos, 2, rx114_start
    sub rx114_off, rx114_pos, 1
    substr rx114_tgt, rx114_tgt, rx114_off
  rx114_start:
    eq $I10, 1, rx114_restart
    if_null rx114_debug, debug_451
    rx114_cur."!cursor_debug"("START", "")
  debug_451:
    $I10 = self.'from'()
    ne $I10, -1, rxscan115_done
    goto rxscan115_scan
  rxscan115_loop:
    (rx114_pos) = rx114_cur."from"()
    inc rx114_pos
    rx114_cur."!cursor_from"(rx114_pos)
    ge rx114_pos, rx114_eos, rxscan115_done
  rxscan115_scan:
    set_addr $I10, rxscan115_loop
    rx114_cur."!mark_push"(0, rx114_pos, $I10)
  rxscan115_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx114_pos, rx114_off
    set rx114_rep, 0
    sub $I12, rx114_eos, rx114_pos
  rxenumcharlistq116_loop:
    le $I12, 0, rxenumcharlistq116_done
    substr $S10, rx114_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq116_done
    inc rx114_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq116_loop
  rxenumcharlistq116_done:
    add rx114_pos, rx114_pos, rx114_rep
  # rx literal  "="
    add $I11, rx114_pos, 1
    gt $I11, rx114_eos, rx114_fail
    sub $I11, rx114_pos, rx114_off
    ord $I11, rx114_tgt, $I11
    ne $I11, 61, rx114_fail
    add rx114_pos, 1
  alt117_0:
    set_addr $I10, alt117_1
    rx114_cur."!mark_push"(0, rx114_pos, $I10)
  # rx charclass w
    ge rx114_pos, rx114_eos, rx114_fail
    sub $I10, rx114_pos, rx114_off
    is_cclass $I11, 8192, rx114_tgt, $I10
    unless $I11, rx114_fail
    inc rx114_pos
    goto alt117_end
  alt117_1:
  # rx literal  "\\"
    add $I11, rx114_pos, 1
    gt $I11, rx114_eos, rx114_fail
    sub $I11, rx114_pos, rx114_off
    ord $I11, rx114_tgt, $I11
    ne $I11, 92, rx114_fail
    add rx114_pos, 1
  alt117_end:
  # rx pass
    rx114_cur."!cursor_pass"(rx114_pos, "")
    if_null rx114_debug, debug_452
    rx114_cur."!cursor_debug"("PASS", "", " at pos=", rx114_pos)
  debug_452:
    .return (rx114_cur)
  rx114_restart:
    if_null rx114_debug, debug_453
    rx114_cur."!cursor_debug"("NEXT", "")
  debug_453:
  rx114_fail:
    (rx114_rep, rx114_pos, $I10, $P10) = rx114_cur."!mark_fail"(0)
    lt rx114_pos, -1, rx114_done
    eq rx114_pos, -1, rx114_fail
    jump $I10
  rx114_done:
    rx114_cur."!cursor_fail"()
    if_null rx114_debug, debug_454
    rx114_cur."!cursor_debug"("FAIL", "")
  debug_454:
    .return (rx114_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P152 = "28_1296306519.49046" 
    capture_lex $P152
    .local string rx121_tgt
    .local int rx121_pos
    .local int rx121_off
    .local int rx121_eos
    .local int rx121_rep
    .local pmc rx121_cur
    .local pmc rx121_debug
    (rx121_cur, rx121_pos, rx121_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx121_cur
    .local pmc match
    .lex "$/", match
    length rx121_eos, rx121_tgt
    gt rx121_pos, rx121_eos, rx121_done
    set rx121_off, 0
    lt rx121_pos, 2, rx121_start
    sub rx121_off, rx121_pos, 1
    substr rx121_tgt, rx121_tgt, rx121_off
  rx121_start:
    eq $I10, 1, rx121_restart
    if_null rx121_debug, debug_458
    rx121_cur."!cursor_debug"("START", "pod_comment")
  debug_458:
    $I10 = self.'from'()
    ne $I10, -1, rxscan124_done
    goto rxscan124_scan
  rxscan124_loop:
    (rx121_pos) = rx121_cur."from"()
    inc rx121_pos
    rx121_cur."!cursor_from"(rx121_pos)
    ge rx121_pos, rx121_eos, rxscan124_done
  rxscan124_scan:
    set_addr $I10, rxscan124_loop
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
  rxscan124_done:
.annotate 'line', 70
  # rxanchor bol
    eq rx121_pos, 0, rxanchor125_done
    ge rx121_pos, rx121_eos, rx121_fail
    sub $I10, rx121_pos, rx121_off
    dec $I10
    is_cclass $I11, 4096, rx121_tgt, $I10
    unless $I11, rx121_fail
  rxanchor125_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx121_pos, rx121_off
    set rx121_rep, 0
    sub $I12, rx121_eos, rx121_pos
  rxenumcharlistq126_loop:
    le $I12, 0, rxenumcharlistq126_done
    substr $S10, rx121_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq126_done
    inc rx121_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq126_loop
  rxenumcharlistq126_done:
    add rx121_pos, rx121_pos, rx121_rep
  # rx literal  "="
    add $I11, rx121_pos, 1
    gt $I11, rx121_eos, rx121_fail
    sub $I11, rx121_pos, rx121_off
    ord $I11, rx121_tgt, $I11
    ne $I11, 61, rx121_fail
    add rx121_pos, 1
  alt127_0:
.annotate 'line', 71
    set_addr $I10, alt127_1
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
.annotate 'line', 72
  # rx literal  "begin"
    add $I11, rx121_pos, 5
    gt $I11, rx121_eos, rx121_fail
    sub $I11, rx121_pos, rx121_off
    substr $S10, rx121_tgt, $I11, 5
    ne $S10, "begin", rx121_fail
    add rx121_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx121_pos, rx121_off
    set rx121_rep, 0
    sub $I12, rx121_eos, rx121_pos
  rxenumcharlistq128_loop:
    le $I12, 0, rxenumcharlistq128_done
    substr $S10, rx121_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq128_done
    inc rx121_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq128_loop
  rxenumcharlistq128_done:
    lt rx121_rep, 1, rx121_fail
    add rx121_pos, rx121_pos, rx121_rep
  # rx literal  "END"
    add $I11, rx121_pos, 3
    gt $I11, rx121_eos, rx121_fail
    sub $I11, rx121_pos, rx121_off
    substr $S10, rx121_tgt, $I11, 3
    ne $S10, "END", rx121_fail
    add rx121_pos, 3
  # rxanchor rwb
    le rx121_pos, 0, rx121_fail
    sub $I10, rx121_pos, rx121_off
    is_cclass $I11, 8192, rx121_tgt, $I10
    if $I11, rx121_fail
    dec $I10
    is_cclass $I11, 8192, rx121_tgt, $I10
    unless $I11, rx121_fail
  alt129_0:
.annotate 'line', 73
    set_addr $I10, alt129_1
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
  # rx rxquantf130 ** 0..*
    set_addr $I10, rxquantf130_loop
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
    goto rxquantf130_done
  rxquantf130_loop:
  # rx charclass .
    ge rx121_pos, rx121_eos, rx121_fail
    inc rx121_pos
    set_addr $I10, rxquantf130_loop
    rx121_cur."!mark_push"(rx121_rep, rx121_pos, $I10)
  rxquantf130_done:
  # rx charclass nl
    ge rx121_pos, rx121_eos, rx121_fail
    sub $I10, rx121_pos, rx121_off
    is_cclass $I11, 4096, rx121_tgt, $I10
    unless $I11, rx121_fail
    substr $S10, rx121_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx121_pos, $I11
    inc rx121_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx121_pos, rx121_off
    set rx121_rep, 0
    sub $I12, rx121_eos, rx121_pos
  rxenumcharlistq132_loop:
    le $I12, 0, rxenumcharlistq132_done
    substr $S10, rx121_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq132_done
    inc rx121_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq132_loop
  rxenumcharlistq132_done:
    add rx121_pos, rx121_pos, rx121_rep
  # rx literal  "=end"
    add $I11, rx121_pos, 4
    gt $I11, rx121_eos, rx121_fail
    sub $I11, rx121_pos, rx121_off
    substr $S10, rx121_tgt, $I11, 4
    ne $S10, "=end", rx121_fail
    add rx121_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx121_pos, rx121_off
    set rx121_rep, 0
    sub $I12, rx121_eos, rx121_pos
  rxenumcharlistq133_loop:
    le $I12, 0, rxenumcharlistq133_done
    substr $S10, rx121_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq133_done
    inc rx121_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq133_loop
  rxenumcharlistq133_done:
    lt rx121_rep, 1, rx121_fail
    add rx121_pos, rx121_pos, rx121_rep
  # rx literal  "END"
    add $I11, rx121_pos, 3
    gt $I11, rx121_eos, rx121_fail
    sub $I11, rx121_pos, rx121_off
    substr $S10, rx121_tgt, $I11, 3
    ne $S10, "END", rx121_fail
    add rx121_pos, 3
  # rxanchor rwb
    le rx121_pos, 0, rx121_fail
    sub $I10, rx121_pos, rx121_off
    is_cclass $I11, 8192, rx121_tgt, $I10
    if $I11, rx121_fail
    dec $I10
    is_cclass $I11, 8192, rx121_tgt, $I10
    unless $I11, rx121_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx121_pos, rx121_off
    find_cclass $I11, 4096, rx121_tgt, $I10, rx121_eos
    add rx121_pos, rx121_off, $I11
    goto alt129_end
  alt129_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx121_pos, rx121_off
    find_not_cclass $I11, 65535, rx121_tgt, $I10, rx121_eos
    add rx121_pos, rx121_off, $I11
  alt129_end:
.annotate 'line', 72
    goto alt127_end
  alt127_1:
    set_addr $I10, alt127_2
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
.annotate 'line', 74
  # rx literal  "begin"
    add $I11, rx121_pos, 5
    gt $I11, rx121_eos, rx121_fail
    sub $I11, rx121_pos, rx121_off
    substr $S10, rx121_tgt, $I11, 5
    ne $S10, "begin", rx121_fail
    add rx121_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx121_pos, rx121_off
    set rx121_rep, 0
    sub $I12, rx121_eos, rx121_pos
  rxenumcharlistq134_loop:
    le $I12, 0, rxenumcharlistq134_done
    substr $S10, rx121_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq134_done
    inc rx121_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq134_loop
  rxenumcharlistq134_done:
    lt rx121_rep, 1, rx121_fail
    add rx121_pos, rx121_pos, rx121_rep
  # rx subrule "identifier" subtype=capture negate=
    rx121_cur."!cursor_pos"(rx121_pos)
    $P10 = rx121_cur."identifier"()
    unless $P10, rx121_fail
    rx121_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx121_pos = $P10."pos"()
  alt135_0:
.annotate 'line', 75
    set_addr $I10, alt135_1
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
.annotate 'line', 76
  # rx rxquantf136 ** 0..*
    set_addr $I10, rxquantf136_loop
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
    goto rxquantf136_done
  rxquantf136_loop:
  # rx charclass .
    ge rx121_pos, rx121_eos, rx121_fail
    inc rx121_pos
    set_addr $I10, rxquantf136_loop
    rx121_cur."!mark_push"(rx121_rep, rx121_pos, $I10)
  rxquantf136_done:
  # rx charclass nl
    ge rx121_pos, rx121_eos, rx121_fail
    sub $I10, rx121_pos, rx121_off
    is_cclass $I11, 4096, rx121_tgt, $I10
    unless $I11, rx121_fail
    substr $S10, rx121_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx121_pos, $I11
    inc rx121_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx121_pos, rx121_off
    set rx121_rep, 0
    sub $I12, rx121_eos, rx121_pos
  rxenumcharlistq138_loop:
    le $I12, 0, rxenumcharlistq138_done
    substr $S10, rx121_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq138_done
    inc rx121_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq138_loop
  rxenumcharlistq138_done:
    add rx121_pos, rx121_pos, rx121_rep
  # rx literal  "=end"
    add $I11, rx121_pos, 4
    gt $I11, rx121_eos, rx121_fail
    sub $I11, rx121_pos, rx121_off
    substr $S10, rx121_tgt, $I11, 4
    ne $S10, "=end", rx121_fail
    add rx121_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx121_pos, rx121_off
    set rx121_rep, 0
    sub $I12, rx121_eos, rx121_pos
  rxenumcharlistq139_loop:
    le $I12, 0, rxenumcharlistq139_done
    substr $S10, rx121_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq139_done
    inc rx121_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq139_loop
  rxenumcharlistq139_done:
    lt rx121_rep, 1, rx121_fail
    add rx121_pos, rx121_pos, rx121_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx121_cur."!cursor_pos"(rx121_pos)
    $P10 = rx121_cur."!BACKREF"("identifier")
    unless $P10, rx121_fail
    rx121_pos = $P10."pos"()
  # rxanchor rwb
    le rx121_pos, 0, rx121_fail
    sub $I10, rx121_pos, rx121_off
    is_cclass $I11, 8192, rx121_tgt, $I10
    if $I11, rx121_fail
    dec $I10
    is_cclass $I11, 8192, rx121_tgt, $I10
    unless $I11, rx121_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx121_pos, rx121_off
    find_cclass $I11, 4096, rx121_tgt, $I10, rx121_eos
    add rx121_pos, rx121_off, $I11
    goto alt135_end
  alt135_1:
.annotate 'line', 77
  # rx subrule "panic" subtype=method negate=
    rx121_cur."!cursor_pos"(rx121_pos)
    $P10 = rx121_cur."panic"("=begin without matching =end")
    unless $P10, rx121_fail
    rx121_pos = $P10."pos"()
  alt135_end:
.annotate 'line', 74
    goto alt127_end
  alt127_2:
    set_addr $I10, alt127_3
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
.annotate 'line', 79
  # rx literal  "begin"
    add $I11, rx121_pos, 5
    gt $I11, rx121_eos, rx121_fail
    sub $I11, rx121_pos, rx121_off
    substr $S10, rx121_tgt, $I11, 5
    ne $S10, "begin", rx121_fail
    add rx121_pos, 5
  # rxanchor rwb
    le rx121_pos, 0, rx121_fail
    sub $I10, rx121_pos, rx121_off
    is_cclass $I11, 8192, rx121_tgt, $I10
    if $I11, rx121_fail
    dec $I10
    is_cclass $I11, 8192, rx121_tgt, $I10
    unless $I11, rx121_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx121_pos, rx121_off
    set rx121_rep, 0
    sub $I12, rx121_eos, rx121_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx121_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx121_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    add rx121_pos, rx121_pos, rx121_rep
  alt142_0:
.annotate 'line', 80
    set_addr $I10, alt142_1
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
  # rxanchor eol
    sub $I10, rx121_pos, rx121_off
    is_cclass $I11, 4096, rx121_tgt, $I10
    if $I11, rxanchor143_done
    ne rx121_pos, rx121_eos, rx121_fail
    eq rx121_pos, 0, rxanchor143_done
    dec $I10
    is_cclass $I11, 4096, rx121_tgt, $I10
    if $I11, rx121_fail
  rxanchor143_done:
    goto alt142_end
  alt142_1:
    set_addr $I10, alt142_2
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
  # rx literal  "#"
    add $I11, rx121_pos, 1
    gt $I11, rx121_eos, rx121_fail
    sub $I11, rx121_pos, rx121_off
    ord $I11, rx121_tgt, $I11
    ne $I11, 35, rx121_fail
    add rx121_pos, 1
    goto alt142_end
  alt142_2:
  # rx subrule "panic" subtype=method negate=
    rx121_cur."!cursor_pos"(rx121_pos)
    $P10 = rx121_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx121_fail
    rx121_pos = $P10."pos"()
  alt142_end:
  alt144_0:
.annotate 'line', 81
    set_addr $I10, alt144_1
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
.annotate 'line', 82
  # rx rxquantf145 ** 0..*
    set_addr $I10, rxquantf145_loop
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
    goto rxquantf145_done
  rxquantf145_loop:
  # rx charclass .
    ge rx121_pos, rx121_eos, rx121_fail
    inc rx121_pos
    set_addr $I10, rxquantf145_loop
    rx121_cur."!mark_push"(rx121_rep, rx121_pos, $I10)
  rxquantf145_done:
  # rx charclass nl
    ge rx121_pos, rx121_eos, rx121_fail
    sub $I10, rx121_pos, rx121_off
    is_cclass $I11, 4096, rx121_tgt, $I10
    unless $I11, rx121_fail
    substr $S10, rx121_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx121_pos, $I11
    inc rx121_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx121_pos, rx121_off
    set rx121_rep, 0
    sub $I12, rx121_eos, rx121_pos
  rxenumcharlistq147_loop:
    le $I12, 0, rxenumcharlistq147_done
    substr $S10, rx121_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq147_done
    inc rx121_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq147_loop
  rxenumcharlistq147_done:
    add rx121_pos, rx121_pos, rx121_rep
  # rx literal  "=end"
    add $I11, rx121_pos, 4
    gt $I11, rx121_eos, rx121_fail
    sub $I11, rx121_pos, rx121_off
    substr $S10, rx121_tgt, $I11, 4
    ne $S10, "=end", rx121_fail
    add rx121_pos, 4
  # rxanchor rwb
    le rx121_pos, 0, rx121_fail
    sub $I10, rx121_pos, rx121_off
    is_cclass $I11, 8192, rx121_tgt, $I10
    if $I11, rx121_fail
    dec $I10
    is_cclass $I11, 8192, rx121_tgt, $I10
    unless $I11, rx121_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx121_pos, rx121_off
    find_cclass $I11, 4096, rx121_tgt, $I10, rx121_eos
    add rx121_pos, rx121_off, $I11
    goto alt144_end
  alt144_1:
.annotate 'line', 83
  # rx subrule "panic" subtype=method negate=
    rx121_cur."!cursor_pos"(rx121_pos)
    $P10 = rx121_cur."panic"("=begin without matching =end")
    unless $P10, rx121_fail
    rx121_pos = $P10."pos"()
  alt144_end:
.annotate 'line', 79
    goto alt127_end
  alt127_3:
    set_addr $I10, alt127_4
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
.annotate 'line', 85
  # rx subrule "identifier" subtype=capture negate=
    rx121_cur."!cursor_pos"(rx121_pos)
    $P10 = rx121_cur."identifier"()
    unless $P10, rx121_fail
    rx121_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx121_pos = $P10."pos"()
.annotate 'line', 86
  # rx rxquantf148 ** 0..*
    set_addr $I10, rxquantf148_loop
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
    goto rxquantf148_done
  rxquantf148_loop:
  # rx charclass .
    ge rx121_pos, rx121_eos, rx121_fail
    inc rx121_pos
    set_addr $I10, rxquantf148_loop
    rx121_cur."!mark_push"(rx121_rep, rx121_pos, $I10)
  rxquantf148_done:
  # rxanchor bol
    eq rx121_pos, 0, rxanchor150_done
    ge rx121_pos, rx121_eos, rx121_fail
    sub $I10, rx121_pos, rx121_off
    dec $I10
    is_cclass $I11, 4096, rx121_tgt, $I10
    unless $I11, rx121_fail
  rxanchor150_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx121_cur."!cursor_pos"(rx121_pos)
    .const 'Sub' $P152 = "28_1296306519.49046" 
    capture_lex $P152
    $P10 = rx121_cur."before"($P152)
    unless $P10, rx121_fail
.annotate 'line', 85
    goto alt127_end
  alt127_4:
  alt158_0:
.annotate 'line', 92
    set_addr $I10, alt158_1
    rx121_cur."!mark_push"(0, rx121_pos, $I10)
  # rx charclass s
    ge rx121_pos, rx121_eos, rx121_fail
    sub $I10, rx121_pos, rx121_off
    is_cclass $I11, 32, rx121_tgt, $I10
    unless $I11, rx121_fail
    inc rx121_pos
    goto alt158_end
  alt158_1:
  # rx subrule "panic" subtype=method negate=
    rx121_cur."!cursor_pos"(rx121_pos)
    $P10 = rx121_cur."panic"("Illegal pod directive")
    unless $P10, rx121_fail
    rx121_pos = $P10."pos"()
  alt158_end:
.annotate 'line', 93
  # rx charclass_q N r 0..-1
    sub $I10, rx121_pos, rx121_off
    find_cclass $I11, 4096, rx121_tgt, $I10, rx121_eos
    add rx121_pos, rx121_off, $I11
  alt127_end:
.annotate 'line', 69
  # rx pass
    rx121_cur."!cursor_pass"(rx121_pos, "pod_comment")
    if_null rx121_debug, debug_463
    rx121_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx121_pos)
  debug_463:
    .return (rx121_cur)
  rx121_restart:
.annotate 'line', 4
    if_null rx121_debug, debug_464
    rx121_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_464:
  rx121_fail:
    (rx121_rep, rx121_pos, $I10, $P10) = rx121_cur."!mark_fail"(0)
    lt rx121_pos, -1, rx121_done
    eq rx121_pos, -1, rx121_fail
    jump $I10
  rx121_done:
    rx121_cur."!cursor_fail"()
    if_null rx121_debug, debug_465
    rx121_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_465:
    .return (rx121_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1296306519.49046") :method
.annotate 'line', 4
    new $P123, "ResizablePMCArray"
    push $P123, ""
    .return ($P123)
.end


.namespace ["NQP";"Grammar"]
.sub "_block151"  :anon :subid("28_1296306519.49046") :method :outer("26_1296306519.49046")
.annotate 'line', 86
    .local string rx153_tgt
    .local int rx153_pos
    .local int rx153_off
    .local int rx153_eos
    .local int rx153_rep
    .local pmc rx153_cur
    .local pmc rx153_debug
    (rx153_cur, rx153_pos, rx153_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx153_cur
    .local pmc match
    .lex "$/", match
    length rx153_eos, rx153_tgt
    gt rx153_pos, rx153_eos, rx153_done
    set rx153_off, 0
    lt rx153_pos, 2, rx153_start
    sub rx153_off, rx153_pos, 1
    substr rx153_tgt, rx153_tgt, rx153_off
  rx153_start:
    eq $I10, 1, rx153_restart
    if_null rx153_debug, debug_459
    rx153_cur."!cursor_debug"("START", "")
  debug_459:
    $I10 = self.'from'()
    ne $I10, -1, rxscan154_done
    goto rxscan154_scan
  rxscan154_loop:
    (rx153_pos) = rx153_cur."from"()
    inc rx153_pos
    rx153_cur."!cursor_from"(rx153_pos)
    ge rx153_pos, rx153_eos, rxscan154_done
  rxscan154_scan:
    set_addr $I10, rxscan154_loop
    rx153_cur."!mark_push"(0, rx153_pos, $I10)
  rxscan154_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx153_pos, rx153_off
    set rx153_rep, 0
    sub $I12, rx153_eos, rx153_pos
  rxenumcharlistq155_loop:
    le $I12, 0, rxenumcharlistq155_done
    substr $S10, rx153_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq155_done
    inc rx153_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq155_loop
  rxenumcharlistq155_done:
    add rx153_pos, rx153_pos, rx153_rep
  alt156_0:
    set_addr $I10, alt156_1
    rx153_cur."!mark_push"(0, rx153_pos, $I10)
.annotate 'line', 87
  # rx literal  "="
    add $I11, rx153_pos, 1
    gt $I11, rx153_eos, rx153_fail
    sub $I11, rx153_pos, rx153_off
    ord $I11, rx153_tgt, $I11
    ne $I11, 61, rx153_fail
    add rx153_pos, 1
.annotate 'line', 89
  # rx rxquantr157 ** 0..1
    set_addr $I10, rxquantr157_done
    rx153_cur."!mark_push"(0, rx153_pos, $I10)
  rxquantr157_loop:
.annotate 'line', 88
  # rx literal  "cut"
    add $I11, rx153_pos, 3
    gt $I11, rx153_eos, rx153_fail
    sub $I11, rx153_pos, rx153_off
    substr $S10, rx153_tgt, $I11, 3
    ne $S10, "cut", rx153_fail
    add rx153_pos, 3
  # rxanchor rwb
    le rx153_pos, 0, rx153_fail
    sub $I10, rx153_pos, rx153_off
    is_cclass $I11, 8192, rx153_tgt, $I10
    if $I11, rx153_fail
    dec $I10
    is_cclass $I11, 8192, rx153_tgt, $I10
    unless $I11, rx153_fail
.annotate 'line', 89
  # rx subrule "panic" subtype=method negate=
    rx153_cur."!cursor_pos"(rx153_pos)
    $P10 = rx153_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx153_fail
    rx153_pos = $P10."pos"()
    set_addr $I10, rxquantr157_done
    (rx153_rep) = rx153_cur."!mark_commit"($I10)
  rxquantr157_done:
.annotate 'line', 86
    goto alt156_end
  alt156_1:
.annotate 'line', 90
  # rx charclass nl
    ge rx153_pos, rx153_eos, rx153_fail
    sub $I10, rx153_pos, rx153_off
    is_cclass $I11, 4096, rx153_tgt, $I10
    unless $I11, rx153_fail
    substr $S10, rx153_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx153_pos, $I11
    inc rx153_pos
  alt156_end:
.annotate 'line', 86
  # rx pass
    rx153_cur."!cursor_pass"(rx153_pos, "")
    if_null rx153_debug, debug_460
    rx153_cur."!cursor_debug"("PASS", "", " at pos=", rx153_pos)
  debug_460:
    .return (rx153_cur)
  rx153_restart:
    if_null rx153_debug, debug_461
    rx153_cur."!cursor_debug"("NEXT", "")
  debug_461:
  rx153_fail:
    (rx153_rep, rx153_pos, $I10, $P10) = rx153_cur."!mark_fail"(0)
    lt rx153_pos, -1, rx153_done
    eq rx153_pos, -1, rx153_fail
    jump $I10
  rx153_done:
    rx153_cur."!cursor_fail"()
    if_null rx153_debug, debug_462
    rx153_cur."!cursor_debug"("FAIL", "")
  debug_462:
    .return (rx153_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx160_tgt
    .local int rx160_pos
    .local int rx160_off
    .local int rx160_eos
    .local int rx160_rep
    .local pmc rx160_cur
    .local pmc rx160_debug
    (rx160_cur, rx160_pos, rx160_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx160_cur
    .local pmc match
    .lex "$/", match
    length rx160_eos, rx160_tgt
    gt rx160_pos, rx160_eos, rx160_done
    set rx160_off, 0
    lt rx160_pos, 2, rx160_start
    sub rx160_off, rx160_pos, 1
    substr rx160_tgt, rx160_tgt, rx160_off
  rx160_start:
    eq $I10, 1, rx160_restart
    if_null rx160_debug, debug_466
    rx160_cur."!cursor_debug"("START", "comp_unit")
  debug_466:
    $I10 = self.'from'()
    ne $I10, -1, rxscan164_done
    goto rxscan164_scan
  rxscan164_loop:
    (rx160_pos) = rx160_cur."from"()
    inc rx160_pos
    rx160_cur."!cursor_from"(rx160_pos)
    ge rx160_pos, rx160_eos, rxscan164_done
  rxscan164_scan:
    set_addr $I10, rxscan164_loop
    rx160_cur."!mark_push"(0, rx160_pos, $I10)
  rxscan164_done:
.annotate 'line', 101
  # rx subrule "newpad" subtype=method negate=
    rx160_cur."!cursor_pos"(rx160_pos)
    $P10 = rx160_cur."newpad"()
    unless $P10, rx160_fail
    rx160_pos = $P10."pos"()
.annotate 'line', 102
  # rx subrule "outerctx" subtype=method negate=
    rx160_cur."!cursor_pos"(rx160_pos)
    $P10 = rx160_cur."outerctx"()
    unless $P10, rx160_fail
    rx160_pos = $P10."pos"()
.annotate 'line', 103
  # rx subrule "statementlist" subtype=capture negate=
    rx160_cur."!cursor_pos"(rx160_pos)
    $P10 = rx160_cur."statementlist"()
    unless $P10, rx160_fail
    rx160_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx160_pos = $P10."pos"()
  alt165_0:
.annotate 'line', 104
    set_addr $I10, alt165_1
    rx160_cur."!mark_push"(0, rx160_pos, $I10)
  # rxanchor eos
    ne rx160_pos, rx160_eos, rx160_fail
    goto alt165_end
  alt165_1:
  # rx subrule "panic" subtype=method negate=
    rx160_cur."!cursor_pos"(rx160_pos)
    $P10 = rx160_cur."panic"("Confused")
    unless $P10, rx160_fail
    rx160_pos = $P10."pos"()
  alt165_end:
.annotate 'line', 100
  # rx pass
    rx160_cur."!cursor_pass"(rx160_pos, "comp_unit")
    if_null rx160_debug, debug_467
    rx160_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx160_pos)
  debug_467:
    .return (rx160_cur)
  rx160_restart:
.annotate 'line', 4
    if_null rx160_debug, debug_468
    rx160_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_468:
  rx160_fail:
    (rx160_rep, rx160_pos, $I10, $P10) = rx160_cur."!mark_fail"(0)
    lt rx160_pos, -1, rx160_done
    eq rx160_pos, -1, rx160_fail
    jump $I10
  rx160_done:
    rx160_cur."!cursor_fail"()
    if_null rx160_debug, debug_469
    rx160_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_469:
    .return (rx160_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1296306519.49046") :method
.annotate 'line', 4
    $P162 = self."!PREFIX__!subrule"("newpad", "")
    new $P163, "ResizablePMCArray"
    push $P163, $P162
    .return ($P163)
.end


.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx167_tgt
    .local int rx167_pos
    .local int rx167_off
    .local int rx167_eos
    .local int rx167_rep
    .local pmc rx167_cur
    .local pmc rx167_debug
    (rx167_cur, rx167_pos, rx167_tgt, $I10) = self."!cursor_start"()
    rx167_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx167_cur
    .local pmc match
    .lex "$/", match
    length rx167_eos, rx167_tgt
    gt rx167_pos, rx167_eos, rx167_done
    set rx167_off, 0
    lt rx167_pos, 2, rx167_start
    sub rx167_off, rx167_pos, 1
    substr rx167_tgt, rx167_tgt, rx167_off
  rx167_start:
    eq $I10, 1, rx167_restart
    if_null rx167_debug, debug_470
    rx167_cur."!cursor_debug"("START", "statementlist")
  debug_470:
    $I10 = self.'from'()
    ne $I10, -1, rxscan172_done
    goto rxscan172_scan
  rxscan172_loop:
    (rx167_pos) = rx167_cur."from"()
    inc rx167_pos
    rx167_cur."!cursor_from"(rx167_pos)
    ge rx167_pos, rx167_eos, rxscan172_done
  rxscan172_scan:
    set_addr $I10, rxscan172_loop
    rx167_cur."!mark_push"(0, rx167_pos, $I10)
  rxscan172_done:
  alt173_0:
.annotate 'line', 107
    set_addr $I10, alt173_1
    rx167_cur."!mark_push"(0, rx167_pos, $I10)
.annotate 'line', 108
  # rx subrule "ws" subtype=method negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."ws"()
    unless $P10, rx167_fail
    rx167_pos = $P10."pos"()
  # rxanchor eos
    ne rx167_pos, rx167_eos, rx167_fail
  # rx subrule "ws" subtype=method negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."ws"()
    unless $P10, rx167_fail
    rx167_pos = $P10."pos"()
    goto alt173_end
  alt173_1:
.annotate 'line', 109
  # rx subrule "ws" subtype=method negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."ws"()
    unless $P10, rx167_fail
    rx167_pos = $P10."pos"()
  # rx rxquantr177 ** 0..*
    set_addr $I10, rxquantr177_done
    rx167_cur."!mark_push"(0, rx167_pos, $I10)
  rxquantr177_loop:
  # rx subrule "statement" subtype=capture negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."statement"()
    unless $P10, rx167_fail
    rx167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx167_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."eat_terminator"()
    unless $P10, rx167_fail
    rx167_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."ws"()
    unless $P10, rx167_fail
    rx167_pos = $P10."pos"()
    set_addr $I10, rxquantr177_done
    (rx167_rep) = rx167_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr177_done
    rx167_cur."!mark_push"(rx167_rep, rx167_pos, $I10)
    goto rxquantr177_loop
  rxquantr177_done:
  # rx subrule "ws" subtype=method negate=
    rx167_cur."!cursor_pos"(rx167_pos)
    $P10 = rx167_cur."ws"()
    unless $P10, rx167_fail
    rx167_pos = $P10."pos"()
  alt173_end:
.annotate 'line', 107
  # rx pass
    rx167_cur."!cursor_pass"(rx167_pos, "statementlist")
    if_null rx167_debug, debug_471
    rx167_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx167_pos)
  debug_471:
    .return (rx167_cur)
  rx167_restart:
.annotate 'line', 4
    if_null rx167_debug, debug_472
    rx167_cur."!cursor_debug"("NEXT", "statementlist")
  debug_472:
  rx167_fail:
    (rx167_rep, rx167_pos, $I10, $P10) = rx167_cur."!mark_fail"(0)
    lt rx167_pos, -1, rx167_done
    eq rx167_pos, -1, rx167_fail
    jump $I10
  rx167_done:
    rx167_cur."!cursor_fail"()
    if_null rx167_debug, debug_473
    rx167_cur."!cursor_debug"("FAIL", "statementlist")
  debug_473:
    .return (rx167_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1296306519.49046") :method
.annotate 'line', 4
    $P169 = self."!PREFIX__!subrule"("ws", "")
    $P170 = self."!PREFIX__!subrule"("ws", "")
    new $P171, "ResizablePMCArray"
    push $P171, $P169
    push $P171, $P170
    .return ($P171)
.end


.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P186 = "35_1296306519.49046" 
    capture_lex $P186
    .local string rx181_tgt
    .local int rx181_pos
    .local int rx181_off
    .local int rx181_eos
    .local int rx181_rep
    .local pmc rx181_cur
    .local pmc rx181_debug
    (rx181_cur, rx181_pos, rx181_tgt, $I10) = self."!cursor_start"()
    rx181_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx181_cur
    .local pmc match
    .lex "$/", match
    length rx181_eos, rx181_tgt
    gt rx181_pos, rx181_eos, rx181_done
    set rx181_off, 0
    lt rx181_pos, 2, rx181_start
    sub rx181_off, rx181_pos, 1
    substr rx181_tgt, rx181_tgt, rx181_off
  rx181_start:
    eq $I10, 1, rx181_restart
    if_null rx181_debug, debug_474
    rx181_cur."!cursor_debug"("START", "statement")
  debug_474:
    $I10 = self.'from'()
    ne $I10, -1, rxscan184_done
    goto rxscan184_scan
  rxscan184_loop:
    (rx181_pos) = rx181_cur."from"()
    inc rx181_pos
    rx181_cur."!cursor_from"(rx181_pos)
    ge rx181_pos, rx181_eos, rxscan184_done
  rxscan184_scan:
    set_addr $I10, rxscan184_loop
    rx181_cur."!mark_push"(0, rx181_pos, $I10)
  rxscan184_done:
.annotate 'line', 113
  # rx subrule "before" subtype=zerowidth negate=1
    rx181_cur."!cursor_pos"(rx181_pos)
    .const 'Sub' $P186 = "35_1296306519.49046" 
    capture_lex $P186
    $P10 = rx181_cur."before"($P186)
    if $P10, rx181_fail
  alt190_0:
.annotate 'line', 114
    set_addr $I10, alt190_1
    rx181_cur."!mark_push"(0, rx181_pos, $I10)
.annotate 'line', 115
  # rx subrule "statement_control" subtype=capture negate=
    rx181_cur."!cursor_pos"(rx181_pos)
    $P10 = rx181_cur."statement_control"()
    unless $P10, rx181_fail
    rx181_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx181_pos = $P10."pos"()
    goto alt190_end
  alt190_1:
.annotate 'line', 116
  # rx subrule "EXPR" subtype=capture negate=
    rx181_cur."!cursor_pos"(rx181_pos)
    $P10 = rx181_cur."EXPR"()
    unless $P10, rx181_fail
    rx181_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx181_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx181_cur."!cursor_pos"(rx181_pos)
    $P10 = rx181_cur."ws"()
    unless $P10, rx181_fail
    rx181_pos = $P10."pos"()
.annotate 'line', 121
  # rx rxquantr191 ** 0..1
    set_addr $I10, rxquantr191_done
    rx181_cur."!mark_push"(0, rx181_pos, $I10)
  rxquantr191_loop:
  alt192_0:
.annotate 'line', 117
    set_addr $I10, alt192_1
    rx181_cur."!mark_push"(0, rx181_pos, $I10)
.annotate 'line', 118
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx181_cur."!cursor_pos"(rx181_pos)
    $P10 = rx181_cur."MARKED"("endstmt")
    unless $P10, rx181_fail
    goto alt192_end
  alt192_1:
    set_addr $I10, alt192_2
    rx181_cur."!mark_push"(0, rx181_pos, $I10)
.annotate 'line', 119
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx181_cur."!cursor_pos"(rx181_pos)
    $P10 = rx181_cur."statement_mod_cond"()
    unless $P10, rx181_fail
    rx181_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx181_pos = $P10."pos"()
  # rx rxquantr193 ** 0..1
    set_addr $I10, rxquantr193_done
    rx181_cur."!mark_push"(0, rx181_pos, $I10)
  rxquantr193_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx181_cur."!cursor_pos"(rx181_pos)
    $P10 = rx181_cur."statement_mod_loop"()
    unless $P10, rx181_fail
    goto rxsubrule194_pass
  rxsubrule194_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx181_fail
  rxsubrule194_pass:
    set_addr $I10, rxsubrule194_back
    rx181_cur."!mark_push"(0, rx181_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx181_pos = $P10."pos"()
    set_addr $I10, rxquantr193_done
    (rx181_rep) = rx181_cur."!mark_commit"($I10)
  rxquantr193_done:
    goto alt192_end
  alt192_2:
.annotate 'line', 120
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx181_cur."!cursor_pos"(rx181_pos)
    $P10 = rx181_cur."statement_mod_loop"()
    unless $P10, rx181_fail
    rx181_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx181_pos = $P10."pos"()
  alt192_end:
.annotate 'line', 121
    set_addr $I10, rxquantr191_done
    (rx181_rep) = rx181_cur."!mark_commit"($I10)
  rxquantr191_done:
  alt190_end:
.annotate 'line', 112
  # rx pass
    rx181_cur."!cursor_pass"(rx181_pos, "statement")
    if_null rx181_debug, debug_479
    rx181_cur."!cursor_debug"("PASS", "statement", " at pos=", rx181_pos)
  debug_479:
    .return (rx181_cur)
  rx181_restart:
.annotate 'line', 4
    if_null rx181_debug, debug_480
    rx181_cur."!cursor_debug"("NEXT", "statement")
  debug_480:
  rx181_fail:
    (rx181_rep, rx181_pos, $I10, $P10) = rx181_cur."!mark_fail"(0)
    lt rx181_pos, -1, rx181_done
    eq rx181_pos, -1, rx181_fail
    jump $I10
  rx181_done:
    rx181_cur."!cursor_fail"()
    if_null rx181_debug, debug_481
    rx181_cur."!cursor_debug"("FAIL", "statement")
  debug_481:
    .return (rx181_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1296306519.49046") :method
.annotate 'line', 4
    new $P183, "ResizablePMCArray"
    push $P183, ""
    .return ($P183)
.end


.namespace ["NQP";"Grammar"]
.sub "_block185"  :anon :subid("35_1296306519.49046") :method :outer("33_1296306519.49046")
.annotate 'line', 113
    .local string rx187_tgt
    .local int rx187_pos
    .local int rx187_off
    .local int rx187_eos
    .local int rx187_rep
    .local pmc rx187_cur
    .local pmc rx187_debug
    (rx187_cur, rx187_pos, rx187_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx187_cur
    .local pmc match
    .lex "$/", match
    length rx187_eos, rx187_tgt
    gt rx187_pos, rx187_eos, rx187_done
    set rx187_off, 0
    lt rx187_pos, 2, rx187_start
    sub rx187_off, rx187_pos, 1
    substr rx187_tgt, rx187_tgt, rx187_off
  rx187_start:
    eq $I10, 1, rx187_restart
    if_null rx187_debug, debug_475
    rx187_cur."!cursor_debug"("START", "")
  debug_475:
    $I10 = self.'from'()
    ne $I10, -1, rxscan188_done
    goto rxscan188_scan
  rxscan188_loop:
    (rx187_pos) = rx187_cur."from"()
    inc rx187_pos
    rx187_cur."!cursor_from"(rx187_pos)
    ge rx187_pos, rx187_eos, rxscan188_done
  rxscan188_scan:
    set_addr $I10, rxscan188_loop
    rx187_cur."!mark_push"(0, rx187_pos, $I10)
  rxscan188_done:
  alt189_0:
    set_addr $I10, alt189_1
    rx187_cur."!mark_push"(0, rx187_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx187_pos, rx187_eos, rx187_fail
    sub $I10, rx187_pos, rx187_off
    substr $S10, rx187_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx187_fail
    inc rx187_pos
    goto alt189_end
  alt189_1:
  # rxanchor eos
    ne rx187_pos, rx187_eos, rx187_fail
  alt189_end:
  # rx pass
    rx187_cur."!cursor_pass"(rx187_pos, "")
    if_null rx187_debug, debug_476
    rx187_cur."!cursor_debug"("PASS", "", " at pos=", rx187_pos)
  debug_476:
    .return (rx187_cur)
  rx187_restart:
    if_null rx187_debug, debug_477
    rx187_cur."!cursor_debug"("NEXT", "")
  debug_477:
  rx187_fail:
    (rx187_rep, rx187_pos, $I10, $P10) = rx187_cur."!mark_fail"(0)
    lt rx187_pos, -1, rx187_done
    eq rx187_pos, -1, rx187_fail
    jump $I10
  rx187_done:
    rx187_cur."!cursor_fail"()
    if_null rx187_debug, debug_478
    rx187_cur."!cursor_debug"("FAIL", "")
  debug_478:
    .return (rx187_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx196_tgt
    .local int rx196_pos
    .local int rx196_off
    .local int rx196_eos
    .local int rx196_rep
    .local pmc rx196_cur
    .local pmc rx196_debug
    (rx196_cur, rx196_pos, rx196_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx196_cur
    .local pmc match
    .lex "$/", match
    length rx196_eos, rx196_tgt
    gt rx196_pos, rx196_eos, rx196_done
    set rx196_off, 0
    lt rx196_pos, 2, rx196_start
    sub rx196_off, rx196_pos, 1
    substr rx196_tgt, rx196_tgt, rx196_off
  rx196_start:
    eq $I10, 1, rx196_restart
    if_null rx196_debug, debug_482
    rx196_cur."!cursor_debug"("START", "eat_terminator")
  debug_482:
    $I10 = self.'from'()
    ne $I10, -1, rxscan199_done
    goto rxscan199_scan
  rxscan199_loop:
    (rx196_pos) = rx196_cur."from"()
    inc rx196_pos
    rx196_cur."!cursor_from"(rx196_pos)
    ge rx196_pos, rx196_eos, rxscan199_done
  rxscan199_scan:
    set_addr $I10, rxscan199_loop
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxscan199_done:
  alt200_0:
.annotate 'line', 125
    set_addr $I10, alt200_1
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 126
  # rx literal  ";"
    add $I11, rx196_pos, 1
    gt $I11, rx196_eos, rx196_fail
    sub $I11, rx196_pos, rx196_off
    ord $I11, rx196_tgt, $I11
    ne $I11, 59, rx196_fail
    add rx196_pos, 1
    goto alt200_end
  alt200_1:
    set_addr $I10, alt200_2
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 127
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."MARKED"("endstmt")
    unless $P10, rx196_fail
    goto alt200_end
  alt200_2:
    set_addr $I10, alt200_3
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 128
  # rx subrule "terminator" subtype=zerowidth negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."terminator"()
    unless $P10, rx196_fail
    goto alt200_end
  alt200_3:
.annotate 'line', 129
  # rxanchor eos
    ne rx196_pos, rx196_eos, rx196_fail
  alt200_end:
.annotate 'line', 125
  # rx pass
    rx196_cur."!cursor_pass"(rx196_pos, "eat_terminator")
    if_null rx196_debug, debug_483
    rx196_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx196_pos)
  debug_483:
    .return (rx196_cur)
  rx196_restart:
.annotate 'line', 4
    if_null rx196_debug, debug_484
    rx196_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_484:
  rx196_fail:
    (rx196_rep, rx196_pos, $I10, $P10) = rx196_cur."!mark_fail"(0)
    lt rx196_pos, -1, rx196_done
    eq rx196_pos, -1, rx196_fail
    jump $I10
  rx196_done:
    rx196_cur."!cursor_fail"()
    if_null rx196_debug, debug_485
    rx196_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_485:
    .return (rx196_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1296306519.49046") :method
.annotate 'line', 4
    new $P198, "ResizablePMCArray"
    push $P198, ""
    push $P198, ""
    push $P198, ""
    push $P198, ";"
    .return ($P198)
.end


.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx202_tgt
    .local int rx202_pos
    .local int rx202_off
    .local int rx202_eos
    .local int rx202_rep
    .local pmc rx202_cur
    .local pmc rx202_debug
    (rx202_cur, rx202_pos, rx202_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx202_cur
    .local pmc match
    .lex "$/", match
    length rx202_eos, rx202_tgt
    gt rx202_pos, rx202_eos, rx202_done
    set rx202_off, 0
    lt rx202_pos, 2, rx202_start
    sub rx202_off, rx202_pos, 1
    substr rx202_tgt, rx202_tgt, rx202_off
  rx202_start:
    eq $I10, 1, rx202_restart
    if_null rx202_debug, debug_486
    rx202_cur."!cursor_debug"("START", "xblock")
  debug_486:
    $I10 = self.'from'()
    ne $I10, -1, rxscan206_done
    goto rxscan206_scan
  rxscan206_loop:
    (rx202_pos) = rx202_cur."from"()
    inc rx202_pos
    rx202_cur."!cursor_from"(rx202_pos)
    ge rx202_pos, rx202_eos, rxscan206_done
  rxscan206_scan:
    set_addr $I10, rxscan206_loop
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
  rxscan206_done:
.annotate 'line', 133
  # rx subrule "EXPR" subtype=capture negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."EXPR"()
    unless $P10, rx202_fail
    rx202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx202_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."ws"()
    unless $P10, rx202_fail
    rx202_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."pblock"()
    unless $P10, rx202_fail
    rx202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx202_pos = $P10."pos"()
.annotate 'line', 132
  # rx pass
    rx202_cur."!cursor_pass"(rx202_pos, "xblock")
    if_null rx202_debug, debug_487
    rx202_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx202_pos)
  debug_487:
    .return (rx202_cur)
  rx202_restart:
.annotate 'line', 4
    if_null rx202_debug, debug_488
    rx202_cur."!cursor_debug"("NEXT", "xblock")
  debug_488:
  rx202_fail:
    (rx202_rep, rx202_pos, $I10, $P10) = rx202_cur."!mark_fail"(0)
    lt rx202_pos, -1, rx202_done
    eq rx202_pos, -1, rx202_fail
    jump $I10
  rx202_done:
    rx202_cur."!cursor_fail"()
    if_null rx202_debug, debug_489
    rx202_cur."!cursor_debug"("FAIL", "xblock")
  debug_489:
    .return (rx202_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1296306519.49046") :method
.annotate 'line', 4
    $P204 = self."!PREFIX__!subrule"("EXPR", "")
    new $P205, "ResizablePMCArray"
    push $P205, $P204
    .return ($P205)
.end


.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx208_tgt
    .local int rx208_pos
    .local int rx208_off
    .local int rx208_eos
    .local int rx208_rep
    .local pmc rx208_cur
    .local pmc rx208_debug
    (rx208_cur, rx208_pos, rx208_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx208_cur
    .local pmc match
    .lex "$/", match
    length rx208_eos, rx208_tgt
    gt rx208_pos, rx208_eos, rx208_done
    set rx208_off, 0
    lt rx208_pos, 2, rx208_start
    sub rx208_off, rx208_pos, 1
    substr rx208_tgt, rx208_tgt, rx208_off
  rx208_start:
    eq $I10, 1, rx208_restart
    if_null rx208_debug, debug_490
    rx208_cur."!cursor_debug"("START", "pblock")
  debug_490:
    $I10 = self.'from'()
    ne $I10, -1, rxscan213_done
    goto rxscan213_scan
  rxscan213_loop:
    (rx208_pos) = rx208_cur."from"()
    inc rx208_pos
    rx208_cur."!cursor_from"(rx208_pos)
    ge rx208_pos, rx208_eos, rxscan213_done
  rxscan213_scan:
    set_addr $I10, rxscan213_loop
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
  rxscan213_done:
  alt214_0:
.annotate 'line', 136
    set_addr $I10, alt214_1
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
.annotate 'line', 137
  # rx subrule "lambda" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."lambda"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
.annotate 'line', 138
  # rx subrule "newpad" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."newpad"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
.annotate 'line', 139
  # rx subrule "signature" subtype=capture negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."signature"()
    unless $P10, rx208_fail
    rx208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx208_pos = $P10."pos"()
.annotate 'line', 140
  # rx subrule "blockoid" subtype=capture negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."blockoid"()
    unless $P10, rx208_fail
    rx208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx208_pos = $P10."pos"()
.annotate 'line', 137
    goto alt214_end
  alt214_1:
    set_addr $I10, alt214_2
    rx208_cur."!mark_push"(0, rx208_pos, $I10)
.annotate 'line', 141
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx208_pos, rx208_off
    substr $S10, rx208_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx208_fail
.annotate 'line', 142
  # rx subrule "newpad" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."newpad"()
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
.annotate 'line', 143
  # rx subrule "blockoid" subtype=capture negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."blockoid"()
    unless $P10, rx208_fail
    rx208_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx208_pos = $P10."pos"()
.annotate 'line', 141
    goto alt214_end
  alt214_2:
.annotate 'line', 144
  # rx subrule "panic" subtype=method negate=
    rx208_cur."!cursor_pos"(rx208_pos)
    $P10 = rx208_cur."panic"("Missing block")
    unless $P10, rx208_fail
    rx208_pos = $P10."pos"()
  alt214_end:
.annotate 'line', 136
  # rx pass
    rx208_cur."!cursor_pass"(rx208_pos, "pblock")
    if_null rx208_debug, debug_491
    rx208_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx208_pos)
  debug_491:
    .return (rx208_cur)
  rx208_restart:
.annotate 'line', 4
    if_null rx208_debug, debug_492
    rx208_cur."!cursor_debug"("NEXT", "pblock")
  debug_492:
  rx208_fail:
    (rx208_rep, rx208_pos, $I10, $P10) = rx208_cur."!mark_fail"(0)
    lt rx208_pos, -1, rx208_done
    eq rx208_pos, -1, rx208_fail
    jump $I10
  rx208_done:
    rx208_cur."!cursor_fail"()
    if_null rx208_debug, debug_493
    rx208_cur."!cursor_debug"("FAIL", "pblock")
  debug_493:
    .return (rx208_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1296306519.49046") :method
.annotate 'line', 4
    $P210 = self."!PREFIX__!subrule"("panic", "")
    $P211 = self."!PREFIX__!subrule"("lambda", "")
    new $P212, "ResizablePMCArray"
    push $P212, $P210
    push $P212, "{"
    push $P212, $P211
    .return ($P212)
.end


.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx216_tgt
    .local int rx216_pos
    .local int rx216_off
    .local int rx216_eos
    .local int rx216_rep
    .local pmc rx216_cur
    .local pmc rx216_debug
    (rx216_cur, rx216_pos, rx216_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx216_cur
    .local pmc match
    .lex "$/", match
    length rx216_eos, rx216_tgt
    gt rx216_pos, rx216_eos, rx216_done
    set rx216_off, 0
    lt rx216_pos, 2, rx216_start
    sub rx216_off, rx216_pos, 1
    substr rx216_tgt, rx216_tgt, rx216_off
  rx216_start:
    eq $I10, 1, rx216_restart
    if_null rx216_debug, debug_494
    rx216_cur."!cursor_debug"("START", "lambda")
  debug_494:
    $I10 = self.'from'()
    ne $I10, -1, rxscan219_done
    goto rxscan219_scan
  rxscan219_loop:
    (rx216_pos) = rx216_cur."from"()
    inc rx216_pos
    rx216_cur."!cursor_from"(rx216_pos)
    ge rx216_pos, rx216_eos, rxscan219_done
  rxscan219_scan:
    set_addr $I10, rxscan219_loop
    rx216_cur."!mark_push"(0, rx216_pos, $I10)
  rxscan219_done:
  alt220_0:
.annotate 'line', 147
    set_addr $I10, alt220_1
    rx216_cur."!mark_push"(0, rx216_pos, $I10)
  # rx literal  "->"
    add $I11, rx216_pos, 2
    gt $I11, rx216_eos, rx216_fail
    sub $I11, rx216_pos, rx216_off
    substr $S10, rx216_tgt, $I11, 2
    ne $S10, "->", rx216_fail
    add rx216_pos, 2
    goto alt220_end
  alt220_1:
  # rx literal  "<->"
    add $I11, rx216_pos, 3
    gt $I11, rx216_eos, rx216_fail
    sub $I11, rx216_pos, rx216_off
    substr $S10, rx216_tgt, $I11, 3
    ne $S10, "<->", rx216_fail
    add rx216_pos, 3
  alt220_end:
  # rx pass
    rx216_cur."!cursor_pass"(rx216_pos, "lambda")
    if_null rx216_debug, debug_495
    rx216_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx216_pos)
  debug_495:
    .return (rx216_cur)
  rx216_restart:
.annotate 'line', 4
    if_null rx216_debug, debug_496
    rx216_cur."!cursor_debug"("NEXT", "lambda")
  debug_496:
  rx216_fail:
    (rx216_rep, rx216_pos, $I10, $P10) = rx216_cur."!mark_fail"(0)
    lt rx216_pos, -1, rx216_done
    eq rx216_pos, -1, rx216_fail
    jump $I10
  rx216_done:
    rx216_cur."!cursor_fail"()
    if_null rx216_debug, debug_497
    rx216_cur."!cursor_debug"("FAIL", "lambda")
  debug_497:
    .return (rx216_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1296306519.49046") :method
.annotate 'line', 4
    new $P218, "ResizablePMCArray"
    push $P218, "<->"
    push $P218, "->"
    .return ($P218)
.end


.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx222_tgt
    .local int rx222_pos
    .local int rx222_off
    .local int rx222_eos
    .local int rx222_rep
    .local pmc rx222_cur
    .local pmc rx222_debug
    (rx222_cur, rx222_pos, rx222_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx222_cur
    .local pmc match
    .lex "$/", match
    length rx222_eos, rx222_tgt
    gt rx222_pos, rx222_eos, rx222_done
    set rx222_off, 0
    lt rx222_pos, 2, rx222_start
    sub rx222_off, rx222_pos, 1
    substr rx222_tgt, rx222_tgt, rx222_off
  rx222_start:
    eq $I10, 1, rx222_restart
    if_null rx222_debug, debug_498
    rx222_cur."!cursor_debug"("START", "block")
  debug_498:
    $I10 = self.'from'()
    ne $I10, -1, rxscan226_done
    goto rxscan226_scan
  rxscan226_loop:
    (rx222_pos) = rx222_cur."from"()
    inc rx222_pos
    rx222_cur."!cursor_from"(rx222_pos)
    ge rx222_pos, rx222_eos, rxscan226_done
  rxscan226_scan:
    set_addr $I10, rxscan226_loop
    rx222_cur."!mark_push"(0, rx222_pos, $I10)
  rxscan226_done:
  alt227_0:
.annotate 'line', 150
    set_addr $I10, alt227_1
    rx222_cur."!mark_push"(0, rx222_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx222_pos, rx222_off
    substr $S10, rx222_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx222_fail
    goto alt227_end
  alt227_1:
  # rx subrule "panic" subtype=method negate=
    rx222_cur."!cursor_pos"(rx222_pos)
    $P10 = rx222_cur."panic"("Missing block")
    unless $P10, rx222_fail
    rx222_pos = $P10."pos"()
  alt227_end:
.annotate 'line', 151
  # rx subrule "newpad" subtype=method negate=
    rx222_cur."!cursor_pos"(rx222_pos)
    $P10 = rx222_cur."newpad"()
    unless $P10, rx222_fail
    rx222_pos = $P10."pos"()
.annotate 'line', 152
  # rx subrule "blockoid" subtype=capture negate=
    rx222_cur."!cursor_pos"(rx222_pos)
    $P10 = rx222_cur."blockoid"()
    unless $P10, rx222_fail
    rx222_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx222_pos = $P10."pos"()
.annotate 'line', 149
  # rx pass
    rx222_cur."!cursor_pass"(rx222_pos, "block")
    if_null rx222_debug, debug_499
    rx222_cur."!cursor_debug"("PASS", "block", " at pos=", rx222_pos)
  debug_499:
    .return (rx222_cur)
  rx222_restart:
.annotate 'line', 4
    if_null rx222_debug, debug_500
    rx222_cur."!cursor_debug"("NEXT", "block")
  debug_500:
  rx222_fail:
    (rx222_rep, rx222_pos, $I10, $P10) = rx222_cur."!mark_fail"(0)
    lt rx222_pos, -1, rx222_done
    eq rx222_pos, -1, rx222_fail
    jump $I10
  rx222_done:
    rx222_cur."!cursor_fail"()
    if_null rx222_debug, debug_501
    rx222_cur."!cursor_debug"("FAIL", "block")
  debug_501:
    .return (rx222_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1296306519.49046") :method
.annotate 'line', 4
    $P224 = self."!PREFIX__!subrule"("panic", "")
    new $P225, "ResizablePMCArray"
    push $P225, $P224
    push $P225, "{"
    .return ($P225)
.end


.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx229_tgt
    .local int rx229_pos
    .local int rx229_off
    .local int rx229_eos
    .local int rx229_rep
    .local pmc rx229_cur
    .local pmc rx229_debug
    (rx229_cur, rx229_pos, rx229_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx229_cur
    .local pmc match
    .lex "$/", match
    length rx229_eos, rx229_tgt
    gt rx229_pos, rx229_eos, rx229_done
    set rx229_off, 0
    lt rx229_pos, 2, rx229_start
    sub rx229_off, rx229_pos, 1
    substr rx229_tgt, rx229_tgt, rx229_off
  rx229_start:
    eq $I10, 1, rx229_restart
    if_null rx229_debug, debug_502
    rx229_cur."!cursor_debug"("START", "blockoid")
  debug_502:
    $I10 = self.'from'()
    ne $I10, -1, rxscan233_done
    goto rxscan233_scan
  rxscan233_loop:
    (rx229_pos) = rx229_cur."from"()
    inc rx229_pos
    rx229_cur."!cursor_from"(rx229_pos)
    ge rx229_pos, rx229_eos, rxscan233_done
  rxscan233_scan:
    set_addr $I10, rxscan233_loop
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
  rxscan233_done:
.annotate 'line', 156
  # rx subrule "finishpad" subtype=method negate=
    rx229_cur."!cursor_pos"(rx229_pos)
    $P10 = rx229_cur."finishpad"()
    unless $P10, rx229_fail
    rx229_pos = $P10."pos"()
.annotate 'line', 157
  # rx literal  "{"
    add $I11, rx229_pos, 1
    gt $I11, rx229_eos, rx229_fail
    sub $I11, rx229_pos, rx229_off
    ord $I11, rx229_tgt, $I11
    ne $I11, 123, rx229_fail
    add rx229_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx229_cur."!cursor_pos"(rx229_pos)
    $P10 = rx229_cur."statementlist"()
    unless $P10, rx229_fail
    rx229_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx229_pos = $P10."pos"()
  alt234_0:
    set_addr $I10, alt234_1
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
  # rx literal  "}"
    add $I11, rx229_pos, 1
    gt $I11, rx229_eos, rx229_fail
    sub $I11, rx229_pos, rx229_off
    ord $I11, rx229_tgt, $I11
    ne $I11, 125, rx229_fail
    add rx229_pos, 1
    goto alt234_end
  alt234_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx229_cur."!cursor_pos"(rx229_pos)
    $P10 = rx229_cur."FAILGOAL"("'}'")
    unless $P10, rx229_fail
    goto rxsubrule236_pass
  rxsubrule236_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx229_fail
  rxsubrule236_pass:
    set_addr $I10, rxsubrule236_back
    rx229_cur."!mark_push"(0, rx229_pos, $I10, $P10)
    rx229_pos = $P10."pos"()
  alt234_end:
.annotate 'line', 158
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx229_cur."!cursor_pos"(rx229_pos)
    $P10 = rx229_cur."ENDSTMT"()
    unless $P10, rx229_fail
.annotate 'line', 155
  # rx pass
    rx229_cur."!cursor_pass"(rx229_pos, "blockoid")
    if_null rx229_debug, debug_503
    rx229_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx229_pos)
  debug_503:
    .return (rx229_cur)
  rx229_restart:
.annotate 'line', 4
    if_null rx229_debug, debug_504
    rx229_cur."!cursor_debug"("NEXT", "blockoid")
  debug_504:
  rx229_fail:
    (rx229_rep, rx229_pos, $I10, $P10) = rx229_cur."!mark_fail"(0)
    lt rx229_pos, -1, rx229_done
    eq rx229_pos, -1, rx229_fail
    jump $I10
  rx229_done:
    rx229_cur."!cursor_fail"()
    if_null rx229_debug, debug_505
    rx229_cur."!cursor_debug"("FAIL", "blockoid")
  debug_505:
    .return (rx229_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1296306519.49046") :method
.annotate 'line', 4
    $P231 = self."!PREFIX__!subrule"("finishpad", "")
    new $P232, "ResizablePMCArray"
    push $P232, $P231
    .return ($P232)
.end


.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx238_tgt
    .local int rx238_pos
    .local int rx238_off
    .local int rx238_eos
    .local int rx238_rep
    .local pmc rx238_cur
    .local pmc rx238_debug
    (rx238_cur, rx238_pos, rx238_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx238_cur
    .local pmc match
    .lex "$/", match
    length rx238_eos, rx238_tgt
    gt rx238_pos, rx238_eos, rx238_done
    set rx238_off, 0
    lt rx238_pos, 2, rx238_start
    sub rx238_off, rx238_pos, 1
    substr rx238_tgt, rx238_tgt, rx238_off
  rx238_start:
    eq $I10, 1, rx238_restart
    if_null rx238_debug, debug_506
    rx238_cur."!cursor_debug"("START", "newpad")
  debug_506:
    $I10 = self.'from'()
    ne $I10, -1, rxscan241_done
    goto rxscan241_scan
  rxscan241_loop:
    (rx238_pos) = rx238_cur."from"()
    inc rx238_pos
    rx238_cur."!cursor_from"(rx238_pos)
    ge rx238_pos, rx238_eos, rxscan241_done
  rxscan241_scan:
    set_addr $I10, rxscan241_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  rxscan241_done:
.annotate 'line', 161
  # rx pass
    rx238_cur."!cursor_pass"(rx238_pos, "newpad")
    if_null rx238_debug, debug_507
    rx238_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx238_pos)
  debug_507:
    .return (rx238_cur)
  rx238_restart:
.annotate 'line', 4
    if_null rx238_debug, debug_508
    rx238_cur."!cursor_debug"("NEXT", "newpad")
  debug_508:
  rx238_fail:
    (rx238_rep, rx238_pos, $I10, $P10) = rx238_cur."!mark_fail"(0)
    lt rx238_pos, -1, rx238_done
    eq rx238_pos, -1, rx238_fail
    jump $I10
  rx238_done:
    rx238_cur."!cursor_fail"()
    if_null rx238_debug, debug_509
    rx238_cur."!cursor_debug"("FAIL", "newpad")
  debug_509:
    .return (rx238_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1296306519.49046") :method
.annotate 'line', 4
    new $P240, "ResizablePMCArray"
    push $P240, ""
    .return ($P240)
.end


.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx243_tgt
    .local int rx243_pos
    .local int rx243_off
    .local int rx243_eos
    .local int rx243_rep
    .local pmc rx243_cur
    .local pmc rx243_debug
    (rx243_cur, rx243_pos, rx243_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx243_cur
    .local pmc match
    .lex "$/", match
    length rx243_eos, rx243_tgt
    gt rx243_pos, rx243_eos, rx243_done
    set rx243_off, 0
    lt rx243_pos, 2, rx243_start
    sub rx243_off, rx243_pos, 1
    substr rx243_tgt, rx243_tgt, rx243_off
  rx243_start:
    eq $I10, 1, rx243_restart
    if_null rx243_debug, debug_510
    rx243_cur."!cursor_debug"("START", "outerctx")
  debug_510:
    $I10 = self.'from'()
    ne $I10, -1, rxscan246_done
    goto rxscan246_scan
  rxscan246_loop:
    (rx243_pos) = rx243_cur."from"()
    inc rx243_pos
    rx243_cur."!cursor_from"(rx243_pos)
    ge rx243_pos, rx243_eos, rxscan246_done
  rxscan246_scan:
    set_addr $I10, rxscan246_loop
    rx243_cur."!mark_push"(0, rx243_pos, $I10)
  rxscan246_done:
.annotate 'line', 162
  # rx pass
    rx243_cur."!cursor_pass"(rx243_pos, "outerctx")
    if_null rx243_debug, debug_511
    rx243_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx243_pos)
  debug_511:
    .return (rx243_cur)
  rx243_restart:
.annotate 'line', 4
    if_null rx243_debug, debug_512
    rx243_cur."!cursor_debug"("NEXT", "outerctx")
  debug_512:
  rx243_fail:
    (rx243_rep, rx243_pos, $I10, $P10) = rx243_cur."!mark_fail"(0)
    lt rx243_pos, -1, rx243_done
    eq rx243_pos, -1, rx243_fail
    jump $I10
  rx243_done:
    rx243_cur."!cursor_fail"()
    if_null rx243_debug, debug_513
    rx243_cur."!cursor_debug"("FAIL", "outerctx")
  debug_513:
    .return (rx243_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1296306519.49046") :method
.annotate 'line', 4
    new $P245, "ResizablePMCArray"
    push $P245, ""
    .return ($P245)
.end


.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx248_tgt
    .local int rx248_pos
    .local int rx248_off
    .local int rx248_eos
    .local int rx248_rep
    .local pmc rx248_cur
    .local pmc rx248_debug
    (rx248_cur, rx248_pos, rx248_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx248_cur
    .local pmc match
    .lex "$/", match
    length rx248_eos, rx248_tgt
    gt rx248_pos, rx248_eos, rx248_done
    set rx248_off, 0
    lt rx248_pos, 2, rx248_start
    sub rx248_off, rx248_pos, 1
    substr rx248_tgt, rx248_tgt, rx248_off
  rx248_start:
    eq $I10, 1, rx248_restart
    if_null rx248_debug, debug_514
    rx248_cur."!cursor_debug"("START", "finishpad")
  debug_514:
    $I10 = self.'from'()
    ne $I10, -1, rxscan251_done
    goto rxscan251_scan
  rxscan251_loop:
    (rx248_pos) = rx248_cur."from"()
    inc rx248_pos
    rx248_cur."!cursor_from"(rx248_pos)
    ge rx248_pos, rx248_eos, rxscan251_done
  rxscan251_scan:
    set_addr $I10, rxscan251_loop
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
  rxscan251_done:
.annotate 'line', 163
  # rx pass
    rx248_cur."!cursor_pass"(rx248_pos, "finishpad")
    if_null rx248_debug, debug_515
    rx248_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx248_pos)
  debug_515:
    .return (rx248_cur)
  rx248_restart:
.annotate 'line', 4
    if_null rx248_debug, debug_516
    rx248_cur."!cursor_debug"("NEXT", "finishpad")
  debug_516:
  rx248_fail:
    (rx248_rep, rx248_pos, $I10, $P10) = rx248_cur."!mark_fail"(0)
    lt rx248_pos, -1, rx248_done
    eq rx248_pos, -1, rx248_fail
    jump $I10
  rx248_done:
    rx248_cur."!cursor_fail"()
    if_null rx248_debug, debug_517
    rx248_cur."!cursor_debug"("FAIL", "finishpad")
  debug_517:
    .return (rx248_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1296306519.49046") :method
.annotate 'line', 4
    new $P250, "ResizablePMCArray"
    push $P250, ""
    .return ($P250)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("54_1296306519.49046")
    .param pmc param_253
.annotate 'line', 165
    .lex "self", param_253
    $P254 = param_253."!protoregex"("terminator")
    .return ($P254)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("55_1296306519.49046")
    .param pmc param_256
.annotate 'line', 165
    .lex "self", param_256
    $P257 = param_256."!PREFIX__!protoregex"("terminator")
    .return ($P257)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("56_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx259_tgt
    .local int rx259_pos
    .local int rx259_off
    .local int rx259_eos
    .local int rx259_rep
    .local pmc rx259_cur
    .local pmc rx259_debug
    (rx259_cur, rx259_pos, rx259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx259_cur
    .local pmc match
    .lex "$/", match
    length rx259_eos, rx259_tgt
    gt rx259_pos, rx259_eos, rx259_done
    set rx259_off, 0
    lt rx259_pos, 2, rx259_start
    sub rx259_off, rx259_pos, 1
    substr rx259_tgt, rx259_tgt, rx259_off
  rx259_start:
    eq $I10, 1, rx259_restart
    if_null rx259_debug, debug_518
    rx259_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_518:
    $I10 = self.'from'()
    ne $I10, -1, rxscan262_done
    goto rxscan262_scan
  rxscan262_loop:
    (rx259_pos) = rx259_cur."from"()
    inc rx259_pos
    rx259_cur."!cursor_from"(rx259_pos)
    ge rx259_pos, rx259_eos, rxscan262_done
  rxscan262_scan:
    set_addr $I10, rxscan262_loop
    rx259_cur."!mark_push"(0, rx259_pos, $I10)
  rxscan262_done:
.annotate 'line', 167
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx259_pos, rx259_off
    substr $S10, rx259_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx259_fail
  # rx pass
    rx259_cur."!cursor_pass"(rx259_pos, "terminator:sym<;>")
    if_null rx259_debug, debug_519
    rx259_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx259_pos)
  debug_519:
    .return (rx259_cur)
  rx259_restart:
.annotate 'line', 4
    if_null rx259_debug, debug_520
    rx259_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_520:
  rx259_fail:
    (rx259_rep, rx259_pos, $I10, $P10) = rx259_cur."!mark_fail"(0)
    lt rx259_pos, -1, rx259_done
    eq rx259_pos, -1, rx259_fail
    jump $I10
  rx259_done:
    rx259_cur."!cursor_fail"()
    if_null rx259_debug, debug_521
    rx259_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_521:
    .return (rx259_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("57_1296306519.49046") :method
.annotate 'line', 4
    new $P261, "ResizablePMCArray"
    push $P261, ";"
    .return ($P261)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("58_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx264_tgt
    .local int rx264_pos
    .local int rx264_off
    .local int rx264_eos
    .local int rx264_rep
    .local pmc rx264_cur
    .local pmc rx264_debug
    (rx264_cur, rx264_pos, rx264_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx264_cur
    .local pmc match
    .lex "$/", match
    length rx264_eos, rx264_tgt
    gt rx264_pos, rx264_eos, rx264_done
    set rx264_off, 0
    lt rx264_pos, 2, rx264_start
    sub rx264_off, rx264_pos, 1
    substr rx264_tgt, rx264_tgt, rx264_off
  rx264_start:
    eq $I10, 1, rx264_restart
    if_null rx264_debug, debug_522
    rx264_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_522:
    $I10 = self.'from'()
    ne $I10, -1, rxscan267_done
    goto rxscan267_scan
  rxscan267_loop:
    (rx264_pos) = rx264_cur."from"()
    inc rx264_pos
    rx264_cur."!cursor_from"(rx264_pos)
    ge rx264_pos, rx264_eos, rxscan267_done
  rxscan267_scan:
    set_addr $I10, rxscan267_loop
    rx264_cur."!mark_push"(0, rx264_pos, $I10)
  rxscan267_done:
.annotate 'line', 168
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx264_pos, rx264_off
    substr $S10, rx264_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx264_fail
  # rx pass
    rx264_cur."!cursor_pass"(rx264_pos, "terminator:sym<}>")
    if_null rx264_debug, debug_523
    rx264_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx264_pos)
  debug_523:
    .return (rx264_cur)
  rx264_restart:
.annotate 'line', 4
    if_null rx264_debug, debug_524
    rx264_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_524:
  rx264_fail:
    (rx264_rep, rx264_pos, $I10, $P10) = rx264_cur."!mark_fail"(0)
    lt rx264_pos, -1, rx264_done
    eq rx264_pos, -1, rx264_fail
    jump $I10
  rx264_done:
    rx264_cur."!cursor_fail"()
    if_null rx264_debug, debug_525
    rx264_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_525:
    .return (rx264_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("59_1296306519.49046") :method
.annotate 'line', 4
    new $P266, "ResizablePMCArray"
    push $P266, "}"
    .return ($P266)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("60_1296306519.49046")
    .param pmc param_269
.annotate 'line', 172
    .lex "self", param_269
    $P270 = param_269."!protoregex"("statement_control")
    .return ($P270)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("61_1296306519.49046")
    .param pmc param_272
.annotate 'line', 172
    .lex "self", param_272
    $P273 = param_272."!PREFIX__!protoregex"("statement_control")
    .return ($P273)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("62_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx275_tgt
    .local int rx275_pos
    .local int rx275_off
    .local int rx275_eos
    .local int rx275_rep
    .local pmc rx275_cur
    .local pmc rx275_debug
    (rx275_cur, rx275_pos, rx275_tgt, $I10) = self."!cursor_start"()
    rx275_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx275_cur
    .local pmc match
    .lex "$/", match
    length rx275_eos, rx275_tgt
    gt rx275_pos, rx275_eos, rx275_done
    set rx275_off, 0
    lt rx275_pos, 2, rx275_start
    sub rx275_off, rx275_pos, 1
    substr rx275_tgt, rx275_tgt, rx275_off
  rx275_start:
    eq $I10, 1, rx275_restart
    if_null rx275_debug, debug_526
    rx275_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_526:
    $I10 = self.'from'()
    ne $I10, -1, rxscan278_done
    goto rxscan278_scan
  rxscan278_loop:
    (rx275_pos) = rx275_cur."from"()
    inc rx275_pos
    rx275_cur."!cursor_from"(rx275_pos)
    ge rx275_pos, rx275_eos, rxscan278_done
  rxscan278_scan:
    set_addr $I10, rxscan278_loop
    rx275_cur."!mark_push"(0, rx275_pos, $I10)
  rxscan278_done:
.annotate 'line', 175
  # rx subcapture "sym"
    set_addr $I10, rxcap_279_fail
    rx275_cur."!mark_push"(0, rx275_pos, $I10)
  # rx literal  "if"
    add $I11, rx275_pos, 2
    gt $I11, rx275_eos, rx275_fail
    sub $I11, rx275_pos, rx275_off
    substr $S10, rx275_tgt, $I11, 2
    ne $S10, "if", rx275_fail
    add rx275_pos, 2
    set_addr $I10, rxcap_279_fail
    ($I12, $I11) = rx275_cur."!mark_peek"($I10)
    rx275_cur."!cursor_pos"($I11)
    ($P10) = rx275_cur."!cursor_start"()
    $P10."!cursor_pass"(rx275_pos, "")
    rx275_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_279_done
  rxcap_279_fail:
    goto rx275_fail
  rxcap_279_done:
  # rx charclass s
    ge rx275_pos, rx275_eos, rx275_fail
    sub $I10, rx275_pos, rx275_off
    is_cclass $I11, 32, rx275_tgt, $I10
    unless $I11, rx275_fail
    inc rx275_pos
  # rx subrule "ws" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."ws"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
.annotate 'line', 176
  # rx subrule "xblock" subtype=capture negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."xblock"()
    unless $P10, rx275_fail
    rx275_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx275_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."ws"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
.annotate 'line', 177
  # rx rxquantr282 ** 0..*
    set_addr $I10, rxquantr282_done
    rx275_cur."!mark_push"(0, rx275_pos, $I10)
  rxquantr282_loop:
  # rx subrule "ws" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."ws"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx275_pos, 5
    gt $I11, rx275_eos, rx275_fail
    sub $I11, rx275_pos, rx275_off
    substr $S10, rx275_tgt, $I11, 5
    ne $S10, "elsif", rx275_fail
    add rx275_pos, 5
  # rx charclass s
    ge rx275_pos, rx275_eos, rx275_fail
    sub $I10, rx275_pos, rx275_off
    is_cclass $I11, 32, rx275_tgt, $I10
    unless $I11, rx275_fail
    inc rx275_pos
  # rx subrule "ws" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."ws"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."xblock"()
    unless $P10, rx275_fail
    rx275_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx275_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."ws"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
    set_addr $I10, rxquantr282_done
    (rx275_rep) = rx275_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr282_done
    rx275_cur."!mark_push"(rx275_rep, rx275_pos, $I10)
    goto rxquantr282_loop
  rxquantr282_done:
  # rx subrule "ws" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."ws"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
.annotate 'line', 178
  # rx rxquantr287 ** 0..1
    set_addr $I10, rxquantr287_done
    rx275_cur."!mark_push"(0, rx275_pos, $I10)
  rxquantr287_loop:
  # rx subrule "ws" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."ws"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx275_pos, 4
    gt $I11, rx275_eos, rx275_fail
    sub $I11, rx275_pos, rx275_off
    substr $S10, rx275_tgt, $I11, 4
    ne $S10, "else", rx275_fail
    add rx275_pos, 4
  # rx charclass s
    ge rx275_pos, rx275_eos, rx275_fail
    sub $I10, rx275_pos, rx275_off
    is_cclass $I11, 32, rx275_tgt, $I10
    unless $I11, rx275_fail
    inc rx275_pos
  # rx subrule "ws" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."ws"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."pblock"()
    unless $P10, rx275_fail
    rx275_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx275_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."ws"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
    set_addr $I10, rxquantr287_done
    (rx275_rep) = rx275_cur."!mark_commit"($I10)
  rxquantr287_done:
  # rx subrule "ws" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."ws"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
.annotate 'line', 174
  # rx pass
    rx275_cur."!cursor_pass"(rx275_pos, "statement_control:sym<if>")
    if_null rx275_debug, debug_527
    rx275_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx275_pos)
  debug_527:
    .return (rx275_cur)
  rx275_restart:
.annotate 'line', 4
    if_null rx275_debug, debug_528
    rx275_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_528:
  rx275_fail:
    (rx275_rep, rx275_pos, $I10, $P10) = rx275_cur."!mark_fail"(0)
    lt rx275_pos, -1, rx275_done
    eq rx275_pos, -1, rx275_fail
    jump $I10
  rx275_done:
    rx275_cur."!cursor_fail"()
    if_null rx275_debug, debug_529
    rx275_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_529:
    .return (rx275_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("63_1296306519.49046") :method
.annotate 'line', 4
    new $P277, "ResizablePMCArray"
    push $P277, "if"
    .return ($P277)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("64_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P303 = "66_1296306519.49046" 
    capture_lex $P303
    .local string rx293_tgt
    .local int rx293_pos
    .local int rx293_off
    .local int rx293_eos
    .local int rx293_rep
    .local pmc rx293_cur
    .local pmc rx293_debug
    (rx293_cur, rx293_pos, rx293_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx293_cur
    .local pmc match
    .lex "$/", match
    length rx293_eos, rx293_tgt
    gt rx293_pos, rx293_eos, rx293_done
    set rx293_off, 0
    lt rx293_pos, 2, rx293_start
    sub rx293_off, rx293_pos, 1
    substr rx293_tgt, rx293_tgt, rx293_off
  rx293_start:
    eq $I10, 1, rx293_restart
    if_null rx293_debug, debug_530
    rx293_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_530:
    $I10 = self.'from'()
    ne $I10, -1, rxscan296_done
    goto rxscan296_scan
  rxscan296_loop:
    (rx293_pos) = rx293_cur."from"()
    inc rx293_pos
    rx293_cur."!cursor_from"(rx293_pos)
    ge rx293_pos, rx293_eos, rxscan296_done
  rxscan296_scan:
    set_addr $I10, rxscan296_loop
    rx293_cur."!mark_push"(0, rx293_pos, $I10)
  rxscan296_done:
.annotate 'line', 182
  # rx subcapture "sym"
    set_addr $I10, rxcap_297_fail
    rx293_cur."!mark_push"(0, rx293_pos, $I10)
  # rx literal  "unless"
    add $I11, rx293_pos, 6
    gt $I11, rx293_eos, rx293_fail
    sub $I11, rx293_pos, rx293_off
    substr $S10, rx293_tgt, $I11, 6
    ne $S10, "unless", rx293_fail
    add rx293_pos, 6
    set_addr $I10, rxcap_297_fail
    ($I12, $I11) = rx293_cur."!mark_peek"($I10)
    rx293_cur."!cursor_pos"($I11)
    ($P10) = rx293_cur."!cursor_start"()
    $P10."!cursor_pass"(rx293_pos, "")
    rx293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_297_done
  rxcap_297_fail:
    goto rx293_fail
  rxcap_297_done:
  # rx charclass s
    ge rx293_pos, rx293_eos, rx293_fail
    sub $I10, rx293_pos, rx293_off
    is_cclass $I11, 32, rx293_tgt, $I10
    unless $I11, rx293_fail
    inc rx293_pos
  # rx subrule "ws" subtype=method negate=
    rx293_cur."!cursor_pos"(rx293_pos)
    $P10 = rx293_cur."ws"()
    unless $P10, rx293_fail
    rx293_pos = $P10."pos"()
.annotate 'line', 183
  # rx subrule "xblock" subtype=capture negate=
    rx293_cur."!cursor_pos"(rx293_pos)
    $P10 = rx293_cur."xblock"()
    unless $P10, rx293_fail
    rx293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx293_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx293_cur."!cursor_pos"(rx293_pos)
    $P10 = rx293_cur."ws"()
    unless $P10, rx293_fail
    rx293_pos = $P10."pos"()
  alt300_0:
.annotate 'line', 184
    set_addr $I10, alt300_1
    rx293_cur."!mark_push"(0, rx293_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx293_cur."!cursor_pos"(rx293_pos)
    $P10 = rx293_cur."ws"()
    unless $P10, rx293_fail
    rx293_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx293_cur."!cursor_pos"(rx293_pos)
    .const 'Sub' $P303 = "66_1296306519.49046" 
    capture_lex $P303
    $P10 = rx293_cur."before"($P303)
    if $P10, rx293_fail
  # rx subrule "ws" subtype=method negate=
    rx293_cur."!cursor_pos"(rx293_pos)
    $P10 = rx293_cur."ws"()
    unless $P10, rx293_fail
    rx293_pos = $P10."pos"()
    goto alt300_end
  alt300_1:
  # rx subrule "ws" subtype=method negate=
    rx293_cur."!cursor_pos"(rx293_pos)
    $P10 = rx293_cur."ws"()
    unless $P10, rx293_fail
    rx293_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx293_cur."!cursor_pos"(rx293_pos)
    $P10 = rx293_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx293_fail
    rx293_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx293_cur."!cursor_pos"(rx293_pos)
    $P10 = rx293_cur."ws"()
    unless $P10, rx293_fail
    rx293_pos = $P10."pos"()
  alt300_end:
  # rx subrule "ws" subtype=method negate=
    rx293_cur."!cursor_pos"(rx293_pos)
    $P10 = rx293_cur."ws"()
    unless $P10, rx293_fail
    rx293_pos = $P10."pos"()
.annotate 'line', 181
  # rx pass
    rx293_cur."!cursor_pass"(rx293_pos, "statement_control:sym<unless>")
    if_null rx293_debug, debug_535
    rx293_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx293_pos)
  debug_535:
    .return (rx293_cur)
  rx293_restart:
.annotate 'line', 4
    if_null rx293_debug, debug_536
    rx293_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_536:
  rx293_fail:
    (rx293_rep, rx293_pos, $I10, $P10) = rx293_cur."!mark_fail"(0)
    lt rx293_pos, -1, rx293_done
    eq rx293_pos, -1, rx293_fail
    jump $I10
  rx293_done:
    rx293_cur."!cursor_fail"()
    if_null rx293_debug, debug_537
    rx293_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_537:
    .return (rx293_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("65_1296306519.49046") :method
.annotate 'line', 4
    new $P295, "ResizablePMCArray"
    push $P295, "unless"
    .return ($P295)
.end


.namespace ["NQP";"Grammar"]
.sub "_block302"  :anon :subid("66_1296306519.49046") :method :outer("64_1296306519.49046")
.annotate 'line', 184
    .local string rx304_tgt
    .local int rx304_pos
    .local int rx304_off
    .local int rx304_eos
    .local int rx304_rep
    .local pmc rx304_cur
    .local pmc rx304_debug
    (rx304_cur, rx304_pos, rx304_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx304_cur
    .local pmc match
    .lex "$/", match
    length rx304_eos, rx304_tgt
    gt rx304_pos, rx304_eos, rx304_done
    set rx304_off, 0
    lt rx304_pos, 2, rx304_start
    sub rx304_off, rx304_pos, 1
    substr rx304_tgt, rx304_tgt, rx304_off
  rx304_start:
    eq $I10, 1, rx304_restart
    if_null rx304_debug, debug_531
    rx304_cur."!cursor_debug"("START", "")
  debug_531:
    $I10 = self.'from'()
    ne $I10, -1, rxscan305_done
    goto rxscan305_scan
  rxscan305_loop:
    (rx304_pos) = rx304_cur."from"()
    inc rx304_pos
    rx304_cur."!cursor_from"(rx304_pos)
    ge rx304_pos, rx304_eos, rxscan305_done
  rxscan305_scan:
    set_addr $I10, rxscan305_loop
    rx304_cur."!mark_push"(0, rx304_pos, $I10)
  rxscan305_done:
  # rx literal  "else"
    add $I11, rx304_pos, 4
    gt $I11, rx304_eos, rx304_fail
    sub $I11, rx304_pos, rx304_off
    substr $S10, rx304_tgt, $I11, 4
    ne $S10, "else", rx304_fail
    add rx304_pos, 4
  # rx pass
    rx304_cur."!cursor_pass"(rx304_pos, "")
    if_null rx304_debug, debug_532
    rx304_cur."!cursor_debug"("PASS", "", " at pos=", rx304_pos)
  debug_532:
    .return (rx304_cur)
  rx304_restart:
    if_null rx304_debug, debug_533
    rx304_cur."!cursor_debug"("NEXT", "")
  debug_533:
  rx304_fail:
    (rx304_rep, rx304_pos, $I10, $P10) = rx304_cur."!mark_fail"(0)
    lt rx304_pos, -1, rx304_done
    eq rx304_pos, -1, rx304_fail
    jump $I10
  rx304_done:
    rx304_cur."!cursor_fail"()
    if_null rx304_debug, debug_534
    rx304_cur."!cursor_debug"("FAIL", "")
  debug_534:
    .return (rx304_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("67_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx311_tgt
    .local int rx311_pos
    .local int rx311_off
    .local int rx311_eos
    .local int rx311_rep
    .local pmc rx311_cur
    .local pmc rx311_debug
    (rx311_cur, rx311_pos, rx311_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx311_cur
    .local pmc match
    .lex "$/", match
    length rx311_eos, rx311_tgt
    gt rx311_pos, rx311_eos, rx311_done
    set rx311_off, 0
    lt rx311_pos, 2, rx311_start
    sub rx311_off, rx311_pos, 1
    substr rx311_tgt, rx311_tgt, rx311_off
  rx311_start:
    eq $I10, 1, rx311_restart
    if_null rx311_debug, debug_538
    rx311_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_538:
    $I10 = self.'from'()
    ne $I10, -1, rxscan314_done
    goto rxscan314_scan
  rxscan314_loop:
    (rx311_pos) = rx311_cur."from"()
    inc rx311_pos
    rx311_cur."!cursor_from"(rx311_pos)
    ge rx311_pos, rx311_eos, rxscan314_done
  rxscan314_scan:
    set_addr $I10, rxscan314_loop
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  rxscan314_done:
.annotate 'line', 188
  # rx subcapture "sym"
    set_addr $I10, rxcap_316_fail
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  alt315_0:
    set_addr $I10, alt315_1
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  # rx literal  "while"
    add $I11, rx311_pos, 5
    gt $I11, rx311_eos, rx311_fail
    sub $I11, rx311_pos, rx311_off
    substr $S10, rx311_tgt, $I11, 5
    ne $S10, "while", rx311_fail
    add rx311_pos, 5
    goto alt315_end
  alt315_1:
  # rx literal  "until"
    add $I11, rx311_pos, 5
    gt $I11, rx311_eos, rx311_fail
    sub $I11, rx311_pos, rx311_off
    substr $S10, rx311_tgt, $I11, 5
    ne $S10, "until", rx311_fail
    add rx311_pos, 5
  alt315_end:
    set_addr $I10, rxcap_316_fail
    ($I12, $I11) = rx311_cur."!mark_peek"($I10)
    rx311_cur."!cursor_pos"($I11)
    ($P10) = rx311_cur."!cursor_start"()
    $P10."!cursor_pass"(rx311_pos, "")
    rx311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_316_done
  rxcap_316_fail:
    goto rx311_fail
  rxcap_316_done:
  # rx charclass s
    ge rx311_pos, rx311_eos, rx311_fail
    sub $I10, rx311_pos, rx311_off
    is_cclass $I11, 32, rx311_tgt, $I10
    unless $I11, rx311_fail
    inc rx311_pos
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
.annotate 'line', 189
  # rx subrule "xblock" subtype=capture negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."xblock"()
    unless $P10, rx311_fail
    rx311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx311_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
.annotate 'line', 187
  # rx pass
    rx311_cur."!cursor_pass"(rx311_pos, "statement_control:sym<while>")
    if_null rx311_debug, debug_539
    rx311_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx311_pos)
  debug_539:
    .return (rx311_cur)
  rx311_restart:
.annotate 'line', 4
    if_null rx311_debug, debug_540
    rx311_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_540:
  rx311_fail:
    (rx311_rep, rx311_pos, $I10, $P10) = rx311_cur."!mark_fail"(0)
    lt rx311_pos, -1, rx311_done
    eq rx311_pos, -1, rx311_fail
    jump $I10
  rx311_done:
    rx311_cur."!cursor_fail"()
    if_null rx311_debug, debug_541
    rx311_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_541:
    .return (rx311_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("68_1296306519.49046") :method
.annotate 'line', 4
    new $P313, "ResizablePMCArray"
    push $P313, "until"
    push $P313, "while"
    .return ($P313)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("69_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx320_tgt
    .local int rx320_pos
    .local int rx320_off
    .local int rx320_eos
    .local int rx320_rep
    .local pmc rx320_cur
    .local pmc rx320_debug
    (rx320_cur, rx320_pos, rx320_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx320_cur
    .local pmc match
    .lex "$/", match
    length rx320_eos, rx320_tgt
    gt rx320_pos, rx320_eos, rx320_done
    set rx320_off, 0
    lt rx320_pos, 2, rx320_start
    sub rx320_off, rx320_pos, 1
    substr rx320_tgt, rx320_tgt, rx320_off
  rx320_start:
    eq $I10, 1, rx320_restart
    if_null rx320_debug, debug_542
    rx320_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_542:
    $I10 = self.'from'()
    ne $I10, -1, rxscan323_done
    goto rxscan323_scan
  rxscan323_loop:
    (rx320_pos) = rx320_cur."from"()
    inc rx320_pos
    rx320_cur."!cursor_from"(rx320_pos)
    ge rx320_pos, rx320_eos, rxscan323_done
  rxscan323_scan:
    set_addr $I10, rxscan323_loop
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  rxscan323_done:
.annotate 'line', 193
  # rx subcapture "sym"
    set_addr $I10, rxcap_324_fail
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx320_pos, 6
    gt $I11, rx320_eos, rx320_fail
    sub $I11, rx320_pos, rx320_off
    substr $S10, rx320_tgt, $I11, 6
    ne $S10, "repeat", rx320_fail
    add rx320_pos, 6
    set_addr $I10, rxcap_324_fail
    ($I12, $I11) = rx320_cur."!mark_peek"($I10)
    rx320_cur."!cursor_pos"($I11)
    ($P10) = rx320_cur."!cursor_start"()
    $P10."!cursor_pass"(rx320_pos, "")
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_324_done
  rxcap_324_fail:
    goto rx320_fail
  rxcap_324_done:
  # rx charclass s
    ge rx320_pos, rx320_eos, rx320_fail
    sub $I10, rx320_pos, rx320_off
    is_cclass $I11, 32, rx320_tgt, $I10
    unless $I11, rx320_fail
    inc rx320_pos
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  alt326_0:
.annotate 'line', 194
    set_addr $I10, alt326_1
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
.annotate 'line', 195
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_329_fail
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  alt328_0:
    set_addr $I10, alt328_1
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  # rx literal  "while"
    add $I11, rx320_pos, 5
    gt $I11, rx320_eos, rx320_fail
    sub $I11, rx320_pos, rx320_off
    substr $S10, rx320_tgt, $I11, 5
    ne $S10, "while", rx320_fail
    add rx320_pos, 5
    goto alt328_end
  alt328_1:
  # rx literal  "until"
    add $I11, rx320_pos, 5
    gt $I11, rx320_eos, rx320_fail
    sub $I11, rx320_pos, rx320_off
    substr $S10, rx320_tgt, $I11, 5
    ne $S10, "until", rx320_fail
    add rx320_pos, 5
  alt328_end:
    set_addr $I10, rxcap_329_fail
    ($I12, $I11) = rx320_cur."!mark_peek"($I10)
    rx320_cur."!cursor_pos"($I11)
    ($P10) = rx320_cur."!cursor_start"()
    $P10."!cursor_pass"(rx320_pos, "")
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_329_done
  rxcap_329_fail:
    goto rx320_fail
  rxcap_329_done:
  # rx charclass s
    ge rx320_pos, rx320_eos, rx320_fail
    sub $I10, rx320_pos, rx320_off
    is_cclass $I11, 32, rx320_tgt, $I10
    unless $I11, rx320_fail
    inc rx320_pos
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."xblock"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx320_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
    goto alt326_end
  alt326_1:
.annotate 'line', 196
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."pblock"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx320_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_335_fail
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  alt334_0:
    set_addr $I10, alt334_1
    rx320_cur."!mark_push"(0, rx320_pos, $I10)
  # rx literal  "while"
    add $I11, rx320_pos, 5
    gt $I11, rx320_eos, rx320_fail
    sub $I11, rx320_pos, rx320_off
    substr $S10, rx320_tgt, $I11, 5
    ne $S10, "while", rx320_fail
    add rx320_pos, 5
    goto alt334_end
  alt334_1:
  # rx literal  "until"
    add $I11, rx320_pos, 5
    gt $I11, rx320_eos, rx320_fail
    sub $I11, rx320_pos, rx320_off
    substr $S10, rx320_tgt, $I11, 5
    ne $S10, "until", rx320_fail
    add rx320_pos, 5
  alt334_end:
    set_addr $I10, rxcap_335_fail
    ($I12, $I11) = rx320_cur."!mark_peek"($I10)
    rx320_cur."!cursor_pos"($I11)
    ($P10) = rx320_cur."!cursor_start"()
    $P10."!cursor_pass"(rx320_pos, "")
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_335_done
  rxcap_335_fail:
    goto rx320_fail
  rxcap_335_done:
  # rx charclass s
    ge rx320_pos, rx320_eos, rx320_fail
    sub $I10, rx320_pos, rx320_off
    is_cclass $I11, 32, rx320_tgt, $I10
    unless $I11, rx320_fail
    inc rx320_pos
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."EXPR"()
    unless $P10, rx320_fail
    rx320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx320_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
  alt326_end:
.annotate 'line', 197
  # rx subrule "ws" subtype=method negate=
    rx320_cur."!cursor_pos"(rx320_pos)
    $P10 = rx320_cur."ws"()
    unless $P10, rx320_fail
    rx320_pos = $P10."pos"()
.annotate 'line', 192
  # rx pass
    rx320_cur."!cursor_pass"(rx320_pos, "statement_control:sym<repeat>")
    if_null rx320_debug, debug_543
    rx320_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx320_pos)
  debug_543:
    .return (rx320_cur)
  rx320_restart:
.annotate 'line', 4
    if_null rx320_debug, debug_544
    rx320_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_544:
  rx320_fail:
    (rx320_rep, rx320_pos, $I10, $P10) = rx320_cur."!mark_fail"(0)
    lt rx320_pos, -1, rx320_done
    eq rx320_pos, -1, rx320_fail
    jump $I10
  rx320_done:
    rx320_cur."!cursor_fail"()
    if_null rx320_debug, debug_545
    rx320_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_545:
    .return (rx320_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("70_1296306519.49046") :method
.annotate 'line', 4
    new $P322, "ResizablePMCArray"
    push $P322, "repeat"
    .return ($P322)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("71_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx340_tgt
    .local int rx340_pos
    .local int rx340_off
    .local int rx340_eos
    .local int rx340_rep
    .local pmc rx340_cur
    .local pmc rx340_debug
    (rx340_cur, rx340_pos, rx340_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx340_cur
    .local pmc match
    .lex "$/", match
    length rx340_eos, rx340_tgt
    gt rx340_pos, rx340_eos, rx340_done
    set rx340_off, 0
    lt rx340_pos, 2, rx340_start
    sub rx340_off, rx340_pos, 1
    substr rx340_tgt, rx340_tgt, rx340_off
  rx340_start:
    eq $I10, 1, rx340_restart
    if_null rx340_debug, debug_546
    rx340_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_546:
    $I10 = self.'from'()
    ne $I10, -1, rxscan343_done
    goto rxscan343_scan
  rxscan343_loop:
    (rx340_pos) = rx340_cur."from"()
    inc rx340_pos
    rx340_cur."!cursor_from"(rx340_pos)
    ge rx340_pos, rx340_eos, rxscan343_done
  rxscan343_scan:
    set_addr $I10, rxscan343_loop
    rx340_cur."!mark_push"(0, rx340_pos, $I10)
  rxscan343_done:
.annotate 'line', 201
  # rx subcapture "sym"
    set_addr $I10, rxcap_344_fail
    rx340_cur."!mark_push"(0, rx340_pos, $I10)
  # rx literal  "for"
    add $I11, rx340_pos, 3
    gt $I11, rx340_eos, rx340_fail
    sub $I11, rx340_pos, rx340_off
    substr $S10, rx340_tgt, $I11, 3
    ne $S10, "for", rx340_fail
    add rx340_pos, 3
    set_addr $I10, rxcap_344_fail
    ($I12, $I11) = rx340_cur."!mark_peek"($I10)
    rx340_cur."!cursor_pos"($I11)
    ($P10) = rx340_cur."!cursor_start"()
    $P10."!cursor_pass"(rx340_pos, "")
    rx340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_344_done
  rxcap_344_fail:
    goto rx340_fail
  rxcap_344_done:
  # rx charclass s
    ge rx340_pos, rx340_eos, rx340_fail
    sub $I10, rx340_pos, rx340_off
    is_cclass $I11, 32, rx340_tgt, $I10
    unless $I11, rx340_fail
    inc rx340_pos
  # rx subrule "ws" subtype=method negate=
    rx340_cur."!cursor_pos"(rx340_pos)
    $P10 = rx340_cur."ws"()
    unless $P10, rx340_fail
    rx340_pos = $P10."pos"()
.annotate 'line', 202
  # rx subrule "xblock" subtype=capture negate=
    rx340_cur."!cursor_pos"(rx340_pos)
    $P10 = rx340_cur."xblock"()
    unless $P10, rx340_fail
    rx340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx340_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx340_cur."!cursor_pos"(rx340_pos)
    $P10 = rx340_cur."ws"()
    unless $P10, rx340_fail
    rx340_pos = $P10."pos"()
.annotate 'line', 200
  # rx pass
    rx340_cur."!cursor_pass"(rx340_pos, "statement_control:sym<for>")
    if_null rx340_debug, debug_547
    rx340_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx340_pos)
  debug_547:
    .return (rx340_cur)
  rx340_restart:
.annotate 'line', 4
    if_null rx340_debug, debug_548
    rx340_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_548:
  rx340_fail:
    (rx340_rep, rx340_pos, $I10, $P10) = rx340_cur."!mark_fail"(0)
    lt rx340_pos, -1, rx340_done
    eq rx340_pos, -1, rx340_fail
    jump $I10
  rx340_done:
    rx340_cur."!cursor_fail"()
    if_null rx340_debug, debug_549
    rx340_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_549:
    .return (rx340_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("72_1296306519.49046") :method
.annotate 'line', 4
    new $P342, "ResizablePMCArray"
    push $P342, "for"
    .return ($P342)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("73_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx348_tgt
    .local int rx348_pos
    .local int rx348_off
    .local int rx348_eos
    .local int rx348_rep
    .local pmc rx348_cur
    .local pmc rx348_debug
    (rx348_cur, rx348_pos, rx348_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx348_cur
    .local pmc match
    .lex "$/", match
    length rx348_eos, rx348_tgt
    gt rx348_pos, rx348_eos, rx348_done
    set rx348_off, 0
    lt rx348_pos, 2, rx348_start
    sub rx348_off, rx348_pos, 1
    substr rx348_tgt, rx348_tgt, rx348_off
  rx348_start:
    eq $I10, 1, rx348_restart
    if_null rx348_debug, debug_550
    rx348_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_550:
    $I10 = self.'from'()
    ne $I10, -1, rxscan351_done
    goto rxscan351_scan
  rxscan351_loop:
    (rx348_pos) = rx348_cur."from"()
    inc rx348_pos
    rx348_cur."!cursor_from"(rx348_pos)
    ge rx348_pos, rx348_eos, rxscan351_done
  rxscan351_scan:
    set_addr $I10, rxscan351_loop
    rx348_cur."!mark_push"(0, rx348_pos, $I10)
  rxscan351_done:
.annotate 'line', 206
  # rx subcapture "sym"
    set_addr $I10, rxcap_352_fail
    rx348_cur."!mark_push"(0, rx348_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx348_pos, 5
    gt $I11, rx348_eos, rx348_fail
    sub $I11, rx348_pos, rx348_off
    substr $S10, rx348_tgt, $I11, 5
    ne $S10, "CATCH", rx348_fail
    add rx348_pos, 5
    set_addr $I10, rxcap_352_fail
    ($I12, $I11) = rx348_cur."!mark_peek"($I10)
    rx348_cur."!cursor_pos"($I11)
    ($P10) = rx348_cur."!cursor_start"()
    $P10."!cursor_pass"(rx348_pos, "")
    rx348_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_352_done
  rxcap_352_fail:
    goto rx348_fail
  rxcap_352_done:
  # rx charclass s
    ge rx348_pos, rx348_eos, rx348_fail
    sub $I10, rx348_pos, rx348_off
    is_cclass $I11, 32, rx348_tgt, $I10
    unless $I11, rx348_fail
    inc rx348_pos
  # rx subrule "ws" subtype=method negate=
    rx348_cur."!cursor_pos"(rx348_pos)
    $P10 = rx348_cur."ws"()
    unless $P10, rx348_fail
    rx348_pos = $P10."pos"()
.annotate 'line', 207
  # rx subrule "block" subtype=capture negate=
    rx348_cur."!cursor_pos"(rx348_pos)
    $P10 = rx348_cur."block"()
    unless $P10, rx348_fail
    rx348_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx348_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx348_cur."!cursor_pos"(rx348_pos)
    $P10 = rx348_cur."ws"()
    unless $P10, rx348_fail
    rx348_pos = $P10."pos"()
.annotate 'line', 205
  # rx pass
    rx348_cur."!cursor_pass"(rx348_pos, "statement_control:sym<CATCH>")
    if_null rx348_debug, debug_551
    rx348_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx348_pos)
  debug_551:
    .return (rx348_cur)
  rx348_restart:
.annotate 'line', 4
    if_null rx348_debug, debug_552
    rx348_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_552:
  rx348_fail:
    (rx348_rep, rx348_pos, $I10, $P10) = rx348_cur."!mark_fail"(0)
    lt rx348_pos, -1, rx348_done
    eq rx348_pos, -1, rx348_fail
    jump $I10
  rx348_done:
    rx348_cur."!cursor_fail"()
    if_null rx348_debug, debug_553
    rx348_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_553:
    .return (rx348_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("74_1296306519.49046") :method
.annotate 'line', 4
    new $P350, "ResizablePMCArray"
    push $P350, "CATCH"
    .return ($P350)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("75_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx356_tgt
    .local int rx356_pos
    .local int rx356_off
    .local int rx356_eos
    .local int rx356_rep
    .local pmc rx356_cur
    .local pmc rx356_debug
    (rx356_cur, rx356_pos, rx356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx356_cur
    .local pmc match
    .lex "$/", match
    length rx356_eos, rx356_tgt
    gt rx356_pos, rx356_eos, rx356_done
    set rx356_off, 0
    lt rx356_pos, 2, rx356_start
    sub rx356_off, rx356_pos, 1
    substr rx356_tgt, rx356_tgt, rx356_off
  rx356_start:
    eq $I10, 1, rx356_restart
    if_null rx356_debug, debug_554
    rx356_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_554:
    $I10 = self.'from'()
    ne $I10, -1, rxscan359_done
    goto rxscan359_scan
  rxscan359_loop:
    (rx356_pos) = rx356_cur."from"()
    inc rx356_pos
    rx356_cur."!cursor_from"(rx356_pos)
    ge rx356_pos, rx356_eos, rxscan359_done
  rxscan359_scan:
    set_addr $I10, rxscan359_loop
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
  rxscan359_done:
.annotate 'line', 211
  # rx subcapture "sym"
    set_addr $I10, rxcap_360_fail
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx356_pos, 7
    gt $I11, rx356_eos, rx356_fail
    sub $I11, rx356_pos, rx356_off
    substr $S10, rx356_tgt, $I11, 7
    ne $S10, "CONTROL", rx356_fail
    add rx356_pos, 7
    set_addr $I10, rxcap_360_fail
    ($I12, $I11) = rx356_cur."!mark_peek"($I10)
    rx356_cur."!cursor_pos"($I11)
    ($P10) = rx356_cur."!cursor_start"()
    $P10."!cursor_pass"(rx356_pos, "")
    rx356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_360_done
  rxcap_360_fail:
    goto rx356_fail
  rxcap_360_done:
  # rx charclass s
    ge rx356_pos, rx356_eos, rx356_fail
    sub $I10, rx356_pos, rx356_off
    is_cclass $I11, 32, rx356_tgt, $I10
    unless $I11, rx356_fail
    inc rx356_pos
  # rx subrule "ws" subtype=method negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."ws"()
    unless $P10, rx356_fail
    rx356_pos = $P10."pos"()
.annotate 'line', 212
  # rx subrule "block" subtype=capture negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."block"()
    unless $P10, rx356_fail
    rx356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx356_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."ws"()
    unless $P10, rx356_fail
    rx356_pos = $P10."pos"()
.annotate 'line', 210
  # rx pass
    rx356_cur."!cursor_pass"(rx356_pos, "statement_control:sym<CONTROL>")
    if_null rx356_debug, debug_555
    rx356_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx356_pos)
  debug_555:
    .return (rx356_cur)
  rx356_restart:
.annotate 'line', 4
    if_null rx356_debug, debug_556
    rx356_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_556:
  rx356_fail:
    (rx356_rep, rx356_pos, $I10, $P10) = rx356_cur."!mark_fail"(0)
    lt rx356_pos, -1, rx356_done
    eq rx356_pos, -1, rx356_fail
    jump $I10
  rx356_done:
    rx356_cur."!cursor_fail"()
    if_null rx356_debug, debug_557
    rx356_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_557:
    .return (rx356_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("76_1296306519.49046") :method
.annotate 'line', 4
    new $P358, "ResizablePMCArray"
    push $P358, "CONTROL"
    .return ($P358)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("77_1296306519.49046")
    .param pmc param_364
.annotate 'line', 215
    .lex "self", param_364
    $P365 = param_364."!protoregex"("statement_prefix")
    .return ($P365)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("78_1296306519.49046")
    .param pmc param_367
.annotate 'line', 215
    .lex "self", param_367
    $P368 = param_367."!PREFIX__!protoregex"("statement_prefix")
    .return ($P368)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("79_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx370_tgt
    .local int rx370_pos
    .local int rx370_off
    .local int rx370_eos
    .local int rx370_rep
    .local pmc rx370_cur
    .local pmc rx370_debug
    (rx370_cur, rx370_pos, rx370_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx370_cur
    .local pmc match
    .lex "$/", match
    length rx370_eos, rx370_tgt
    gt rx370_pos, rx370_eos, rx370_done
    set rx370_off, 0
    lt rx370_pos, 2, rx370_start
    sub rx370_off, rx370_pos, 1
    substr rx370_tgt, rx370_tgt, rx370_off
  rx370_start:
    eq $I10, 1, rx370_restart
    if_null rx370_debug, debug_558
    rx370_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_558:
    $I10 = self.'from'()
    ne $I10, -1, rxscan374_done
    goto rxscan374_scan
  rxscan374_loop:
    (rx370_pos) = rx370_cur."from"()
    inc rx370_pos
    rx370_cur."!cursor_from"(rx370_pos)
    ge rx370_pos, rx370_eos, rxscan374_done
  rxscan374_scan:
    set_addr $I10, rxscan374_loop
    rx370_cur."!mark_push"(0, rx370_pos, $I10)
  rxscan374_done:
.annotate 'line', 216
  # rx subcapture "sym"
    set_addr $I10, rxcap_375_fail
    rx370_cur."!mark_push"(0, rx370_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx370_pos, 4
    gt $I11, rx370_eos, rx370_fail
    sub $I11, rx370_pos, rx370_off
    substr $S10, rx370_tgt, $I11, 4
    ne $S10, "INIT", rx370_fail
    add rx370_pos, 4
    set_addr $I10, rxcap_375_fail
    ($I12, $I11) = rx370_cur."!mark_peek"($I10)
    rx370_cur."!cursor_pos"($I11)
    ($P10) = rx370_cur."!cursor_start"()
    $P10."!cursor_pass"(rx370_pos, "")
    rx370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_375_done
  rxcap_375_fail:
    goto rx370_fail
  rxcap_375_done:
  # rx subrule "blorst" subtype=capture negate=
    rx370_cur."!cursor_pos"(rx370_pos)
    $P10 = rx370_cur."blorst"()
    unless $P10, rx370_fail
    rx370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx370_pos = $P10."pos"()
  # rx pass
    rx370_cur."!cursor_pass"(rx370_pos, "statement_prefix:sym<INIT>")
    if_null rx370_debug, debug_559
    rx370_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx370_pos)
  debug_559:
    .return (rx370_cur)
  rx370_restart:
.annotate 'line', 4
    if_null rx370_debug, debug_560
    rx370_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_560:
  rx370_fail:
    (rx370_rep, rx370_pos, $I10, $P10) = rx370_cur."!mark_fail"(0)
    lt rx370_pos, -1, rx370_done
    eq rx370_pos, -1, rx370_fail
    jump $I10
  rx370_done:
    rx370_cur."!cursor_fail"()
    if_null rx370_debug, debug_561
    rx370_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_561:
    .return (rx370_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("80_1296306519.49046") :method
.annotate 'line', 4
    $P372 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P373, "ResizablePMCArray"
    push $P373, $P372
    .return ($P373)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("81_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx377_tgt
    .local int rx377_pos
    .local int rx377_off
    .local int rx377_eos
    .local int rx377_rep
    .local pmc rx377_cur
    .local pmc rx377_debug
    (rx377_cur, rx377_pos, rx377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx377_cur
    .local pmc match
    .lex "$/", match
    length rx377_eos, rx377_tgt
    gt rx377_pos, rx377_eos, rx377_done
    set rx377_off, 0
    lt rx377_pos, 2, rx377_start
    sub rx377_off, rx377_pos, 1
    substr rx377_tgt, rx377_tgt, rx377_off
  rx377_start:
    eq $I10, 1, rx377_restart
    if_null rx377_debug, debug_562
    rx377_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_562:
    $I10 = self.'from'()
    ne $I10, -1, rxscan381_done
    goto rxscan381_scan
  rxscan381_loop:
    (rx377_pos) = rx377_cur."from"()
    inc rx377_pos
    rx377_cur."!cursor_from"(rx377_pos)
    ge rx377_pos, rx377_eos, rxscan381_done
  rxscan381_scan:
    set_addr $I10, rxscan381_loop
    rx377_cur."!mark_push"(0, rx377_pos, $I10)
  rxscan381_done:
.annotate 'line', 219
  # rx subcapture "sym"
    set_addr $I10, rxcap_382_fail
    rx377_cur."!mark_push"(0, rx377_pos, $I10)
  # rx literal  "try"
    add $I11, rx377_pos, 3
    gt $I11, rx377_eos, rx377_fail
    sub $I11, rx377_pos, rx377_off
    substr $S10, rx377_tgt, $I11, 3
    ne $S10, "try", rx377_fail
    add rx377_pos, 3
    set_addr $I10, rxcap_382_fail
    ($I12, $I11) = rx377_cur."!mark_peek"($I10)
    rx377_cur."!cursor_pos"($I11)
    ($P10) = rx377_cur."!cursor_start"()
    $P10."!cursor_pass"(rx377_pos, "")
    rx377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_382_done
  rxcap_382_fail:
    goto rx377_fail
  rxcap_382_done:
.annotate 'line', 220
  # rx subrule "blorst" subtype=capture negate=
    rx377_cur."!cursor_pos"(rx377_pos)
    $P10 = rx377_cur."blorst"()
    unless $P10, rx377_fail
    rx377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx377_pos = $P10."pos"()
.annotate 'line', 218
  # rx pass
    rx377_cur."!cursor_pass"(rx377_pos, "statement_prefix:sym<try>")
    if_null rx377_debug, debug_563
    rx377_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx377_pos)
  debug_563:
    .return (rx377_cur)
  rx377_restart:
.annotate 'line', 4
    if_null rx377_debug, debug_564
    rx377_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_564:
  rx377_fail:
    (rx377_rep, rx377_pos, $I10, $P10) = rx377_cur."!mark_fail"(0)
    lt rx377_pos, -1, rx377_done
    eq rx377_pos, -1, rx377_fail
    jump $I10
  rx377_done:
    rx377_cur."!cursor_fail"()
    if_null rx377_debug, debug_565
    rx377_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_565:
    .return (rx377_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("82_1296306519.49046") :method
.annotate 'line', 4
    $P379 = self."!PREFIX__!subrule"("blorst", "try")
    new $P380, "ResizablePMCArray"
    push $P380, $P379
    .return ($P380)
.end


.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("83_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx384_tgt
    .local int rx384_pos
    .local int rx384_off
    .local int rx384_eos
    .local int rx384_rep
    .local pmc rx384_cur
    .local pmc rx384_debug
    (rx384_cur, rx384_pos, rx384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx384_cur
    .local pmc match
    .lex "$/", match
    length rx384_eos, rx384_tgt
    gt rx384_pos, rx384_eos, rx384_done
    set rx384_off, 0
    lt rx384_pos, 2, rx384_start
    sub rx384_off, rx384_pos, 1
    substr rx384_tgt, rx384_tgt, rx384_off
  rx384_start:
    eq $I10, 1, rx384_restart
    if_null rx384_debug, debug_566
    rx384_cur."!cursor_debug"("START", "blorst")
  debug_566:
    $I10 = self.'from'()
    ne $I10, -1, rxscan387_done
    goto rxscan387_scan
  rxscan387_loop:
    (rx384_pos) = rx384_cur."from"()
    inc rx384_pos
    rx384_cur."!cursor_from"(rx384_pos)
    ge rx384_pos, rx384_eos, rxscan387_done
  rxscan387_scan:
    set_addr $I10, rxscan387_loop
    rx384_cur."!mark_push"(0, rx384_pos, $I10)
  rxscan387_done:
.annotate 'line', 224
  # rx charclass s
    ge rx384_pos, rx384_eos, rx384_fail
    sub $I10, rx384_pos, rx384_off
    is_cclass $I11, 32, rx384_tgt, $I10
    unless $I11, rx384_fail
    inc rx384_pos
  # rx subrule "ws" subtype=method negate=
    rx384_cur."!cursor_pos"(rx384_pos)
    $P10 = rx384_cur."ws"()
    unless $P10, rx384_fail
    rx384_pos = $P10."pos"()
  alt388_0:
    set_addr $I10, alt388_1
    rx384_cur."!mark_push"(0, rx384_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx384_pos, rx384_off
    substr $S10, rx384_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx384_fail
  # rx subrule "block" subtype=capture negate=
    rx384_cur."!cursor_pos"(rx384_pos)
    $P10 = rx384_cur."block"()
    unless $P10, rx384_fail
    rx384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx384_pos = $P10."pos"()
    goto alt388_end
  alt388_1:
  # rx subrule "statement" subtype=capture negate=
    rx384_cur."!cursor_pos"(rx384_pos)
    $P10 = rx384_cur."statement"()
    unless $P10, rx384_fail
    rx384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx384_pos = $P10."pos"()
  alt388_end:
.annotate 'line', 223
  # rx pass
    rx384_cur."!cursor_pass"(rx384_pos, "blorst")
    if_null rx384_debug, debug_567
    rx384_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx384_pos)
  debug_567:
    .return (rx384_cur)
  rx384_restart:
.annotate 'line', 4
    if_null rx384_debug, debug_568
    rx384_cur."!cursor_debug"("NEXT", "blorst")
  debug_568:
  rx384_fail:
    (rx384_rep, rx384_pos, $I10, $P10) = rx384_cur."!mark_fail"(0)
    lt rx384_pos, -1, rx384_done
    eq rx384_pos, -1, rx384_fail
    jump $I10
  rx384_done:
    rx384_cur."!cursor_fail"()
    if_null rx384_debug, debug_569
    rx384_cur."!cursor_debug"("FAIL", "blorst")
  debug_569:
    .return (rx384_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("84_1296306519.49046") :method
.annotate 'line', 4
    new $P386, "ResizablePMCArray"
    push $P386, ""
    .return ($P386)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("85_1296306519.49046")
    .param pmc param_390
.annotate 'line', 229
    .lex "self", param_390
    $P391 = param_390."!protoregex"("statement_mod_cond")
    .return ($P391)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("86_1296306519.49046")
    .param pmc param_393
.annotate 'line', 229
    .lex "self", param_393
    $P394 = param_393."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P394)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("87_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx396_tgt
    .local int rx396_pos
    .local int rx396_off
    .local int rx396_eos
    .local int rx396_rep
    .local pmc rx396_cur
    .local pmc rx396_debug
    (rx396_cur, rx396_pos, rx396_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx396_cur
    .local pmc match
    .lex "$/", match
    length rx396_eos, rx396_tgt
    gt rx396_pos, rx396_eos, rx396_done
    set rx396_off, 0
    lt rx396_pos, 2, rx396_start
    sub rx396_off, rx396_pos, 1
    substr rx396_tgt, rx396_tgt, rx396_off
  rx396_start:
    eq $I10, 1, rx396_restart
    if_null rx396_debug, debug_570
    rx396_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_570:
    $I10 = self.'from'()
    ne $I10, -1, rxscan400_done
    goto rxscan400_scan
  rxscan400_loop:
    (rx396_pos) = rx396_cur."from"()
    inc rx396_pos
    rx396_cur."!cursor_from"(rx396_pos)
    ge rx396_pos, rx396_eos, rxscan400_done
  rxscan400_scan:
    set_addr $I10, rxscan400_loop
    rx396_cur."!mark_push"(0, rx396_pos, $I10)
  rxscan400_done:
.annotate 'line', 231
  # rx subcapture "sym"
    set_addr $I10, rxcap_401_fail
    rx396_cur."!mark_push"(0, rx396_pos, $I10)
  # rx literal  "if"
    add $I11, rx396_pos, 2
    gt $I11, rx396_eos, rx396_fail
    sub $I11, rx396_pos, rx396_off
    substr $S10, rx396_tgt, $I11, 2
    ne $S10, "if", rx396_fail
    add rx396_pos, 2
    set_addr $I10, rxcap_401_fail
    ($I12, $I11) = rx396_cur."!mark_peek"($I10)
    rx396_cur."!cursor_pos"($I11)
    ($P10) = rx396_cur."!cursor_start"()
    $P10."!cursor_pass"(rx396_pos, "")
    rx396_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_401_done
  rxcap_401_fail:
    goto rx396_fail
  rxcap_401_done:
  # rx subrule "ws" subtype=method negate=
    rx396_cur."!cursor_pos"(rx396_pos)
    $P10 = rx396_cur."ws"()
    unless $P10, rx396_fail
    rx396_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx396_cur."!cursor_pos"(rx396_pos)
    $P10 = rx396_cur."EXPR"()
    unless $P10, rx396_fail
    rx396_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx396_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx396_cur."!cursor_pos"(rx396_pos)
    $P10 = rx396_cur."ws"()
    unless $P10, rx396_fail
    rx396_pos = $P10."pos"()
  # rx pass
    rx396_cur."!cursor_pass"(rx396_pos, "statement_mod_cond:sym<if>")
    if_null rx396_debug, debug_571
    rx396_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx396_pos)
  debug_571:
    .return (rx396_cur)
  rx396_restart:
.annotate 'line', 4
    if_null rx396_debug, debug_572
    rx396_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_572:
  rx396_fail:
    (rx396_rep, rx396_pos, $I10, $P10) = rx396_cur."!mark_fail"(0)
    lt rx396_pos, -1, rx396_done
    eq rx396_pos, -1, rx396_fail
    jump $I10
  rx396_done:
    rx396_cur."!cursor_fail"()
    if_null rx396_debug, debug_573
    rx396_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_573:
    .return (rx396_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("88_1296306519.49046") :method
.annotate 'line', 4
    $P398 = self."!PREFIX__!subrule"("ws", "if")
    new $P399, "ResizablePMCArray"
    push $P399, $P398
    .return ($P399)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("89_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx405_tgt
    .local int rx405_pos
    .local int rx405_off
    .local int rx405_eos
    .local int rx405_rep
    .local pmc rx405_cur
    .local pmc rx405_debug
    (rx405_cur, rx405_pos, rx405_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx405_cur
    .local pmc match
    .lex "$/", match
    length rx405_eos, rx405_tgt
    gt rx405_pos, rx405_eos, rx405_done
    set rx405_off, 0
    lt rx405_pos, 2, rx405_start
    sub rx405_off, rx405_pos, 1
    substr rx405_tgt, rx405_tgt, rx405_off
  rx405_start:
    eq $I10, 1, rx405_restart
    if_null rx405_debug, debug_574
    rx405_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_574:
    $I10 = self.'from'()
    ne $I10, -1, rxscan409_done
    goto rxscan409_scan
  rxscan409_loop:
    (rx405_pos) = rx405_cur."from"()
    inc rx405_pos
    rx405_cur."!cursor_from"(rx405_pos)
    ge rx405_pos, rx405_eos, rxscan409_done
  rxscan409_scan:
    set_addr $I10, rxscan409_loop
    rx405_cur."!mark_push"(0, rx405_pos, $I10)
  rxscan409_done:
.annotate 'line', 232
  # rx subcapture "sym"
    set_addr $I10, rxcap_410_fail
    rx405_cur."!mark_push"(0, rx405_pos, $I10)
  # rx literal  "unless"
    add $I11, rx405_pos, 6
    gt $I11, rx405_eos, rx405_fail
    sub $I11, rx405_pos, rx405_off
    substr $S10, rx405_tgt, $I11, 6
    ne $S10, "unless", rx405_fail
    add rx405_pos, 6
    set_addr $I10, rxcap_410_fail
    ($I12, $I11) = rx405_cur."!mark_peek"($I10)
    rx405_cur."!cursor_pos"($I11)
    ($P10) = rx405_cur."!cursor_start"()
    $P10."!cursor_pass"(rx405_pos, "")
    rx405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_410_done
  rxcap_410_fail:
    goto rx405_fail
  rxcap_410_done:
  # rx subrule "ws" subtype=method negate=
    rx405_cur."!cursor_pos"(rx405_pos)
    $P10 = rx405_cur."ws"()
    unless $P10, rx405_fail
    rx405_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx405_cur."!cursor_pos"(rx405_pos)
    $P10 = rx405_cur."EXPR"()
    unless $P10, rx405_fail
    rx405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx405_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx405_cur."!cursor_pos"(rx405_pos)
    $P10 = rx405_cur."ws"()
    unless $P10, rx405_fail
    rx405_pos = $P10."pos"()
  # rx pass
    rx405_cur."!cursor_pass"(rx405_pos, "statement_mod_cond:sym<unless>")
    if_null rx405_debug, debug_575
    rx405_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx405_pos)
  debug_575:
    .return (rx405_cur)
  rx405_restart:
.annotate 'line', 4
    if_null rx405_debug, debug_576
    rx405_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_576:
  rx405_fail:
    (rx405_rep, rx405_pos, $I10, $P10) = rx405_cur."!mark_fail"(0)
    lt rx405_pos, -1, rx405_done
    eq rx405_pos, -1, rx405_fail
    jump $I10
  rx405_done:
    rx405_cur."!cursor_fail"()
    if_null rx405_debug, debug_577
    rx405_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_577:
    .return (rx405_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("90_1296306519.49046") :method
.annotate 'line', 4
    $P407 = self."!PREFIX__!subrule"("ws", "unless")
    new $P408, "ResizablePMCArray"
    push $P408, $P407
    .return ($P408)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("91_1296306519.49046")
    .param pmc param_414
.annotate 'line', 234
    .lex "self", param_414
    $P415 = param_414."!protoregex"("statement_mod_loop")
    .return ($P415)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("92_1296306519.49046")
    .param pmc param_417
.annotate 'line', 234
    .lex "self", param_417
    $P418 = param_417."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P418)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("93_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx420_tgt
    .local int rx420_pos
    .local int rx420_off
    .local int rx420_eos
    .local int rx420_rep
    .local pmc rx420_cur
    .local pmc rx420_debug
    (rx420_cur, rx420_pos, rx420_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx420_cur
    .local pmc match
    .lex "$/", match
    length rx420_eos, rx420_tgt
    gt rx420_pos, rx420_eos, rx420_done
    set rx420_off, 0
    lt rx420_pos, 2, rx420_start
    sub rx420_off, rx420_pos, 1
    substr rx420_tgt, rx420_tgt, rx420_off
  rx420_start:
    eq $I10, 1, rx420_restart
    if_null rx420_debug, debug_578
    rx420_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_578:
    $I10 = self.'from'()
    ne $I10, -1, rxscan424_done
    goto rxscan424_scan
  rxscan424_loop:
    (rx420_pos) = rx420_cur."from"()
    inc rx420_pos
    rx420_cur."!cursor_from"(rx420_pos)
    ge rx420_pos, rx420_eos, rxscan424_done
  rxscan424_scan:
    set_addr $I10, rxscan424_loop
    rx420_cur."!mark_push"(0, rx420_pos, $I10)
  rxscan424_done:
.annotate 'line', 236
  # rx subcapture "sym"
    set_addr $I10, rxcap_425_fail
    rx420_cur."!mark_push"(0, rx420_pos, $I10)
  # rx literal  "while"
    add $I11, rx420_pos, 5
    gt $I11, rx420_eos, rx420_fail
    sub $I11, rx420_pos, rx420_off
    substr $S10, rx420_tgt, $I11, 5
    ne $S10, "while", rx420_fail
    add rx420_pos, 5
    set_addr $I10, rxcap_425_fail
    ($I12, $I11) = rx420_cur."!mark_peek"($I10)
    rx420_cur."!cursor_pos"($I11)
    ($P10) = rx420_cur."!cursor_start"()
    $P10."!cursor_pass"(rx420_pos, "")
    rx420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_425_done
  rxcap_425_fail:
    goto rx420_fail
  rxcap_425_done:
  # rx subrule "ws" subtype=method negate=
    rx420_cur."!cursor_pos"(rx420_pos)
    $P10 = rx420_cur."ws"()
    unless $P10, rx420_fail
    rx420_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx420_cur."!cursor_pos"(rx420_pos)
    $P10 = rx420_cur."EXPR"()
    unless $P10, rx420_fail
    rx420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx420_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx420_cur."!cursor_pos"(rx420_pos)
    $P10 = rx420_cur."ws"()
    unless $P10, rx420_fail
    rx420_pos = $P10."pos"()
  # rx pass
    rx420_cur."!cursor_pass"(rx420_pos, "statement_mod_loop:sym<while>")
    if_null rx420_debug, debug_579
    rx420_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx420_pos)
  debug_579:
    .return (rx420_cur)
  rx420_restart:
.annotate 'line', 4
    if_null rx420_debug, debug_580
    rx420_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_580:
  rx420_fail:
    (rx420_rep, rx420_pos, $I10, $P10) = rx420_cur."!mark_fail"(0)
    lt rx420_pos, -1, rx420_done
    eq rx420_pos, -1, rx420_fail
    jump $I10
  rx420_done:
    rx420_cur."!cursor_fail"()
    if_null rx420_debug, debug_581
    rx420_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_581:
    .return (rx420_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("94_1296306519.49046") :method
.annotate 'line', 4
    $P422 = self."!PREFIX__!subrule"("ws", "while")
    new $P423, "ResizablePMCArray"
    push $P423, $P422
    .return ($P423)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("95_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx429_tgt
    .local int rx429_pos
    .local int rx429_off
    .local int rx429_eos
    .local int rx429_rep
    .local pmc rx429_cur
    .local pmc rx429_debug
    (rx429_cur, rx429_pos, rx429_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx429_cur
    .local pmc match
    .lex "$/", match
    length rx429_eos, rx429_tgt
    gt rx429_pos, rx429_eos, rx429_done
    set rx429_off, 0
    lt rx429_pos, 2, rx429_start
    sub rx429_off, rx429_pos, 1
    substr rx429_tgt, rx429_tgt, rx429_off
  rx429_start:
    eq $I10, 1, rx429_restart
    if_null rx429_debug, debug_582
    rx429_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_582:
    $I10 = self.'from'()
    ne $I10, -1, rxscan433_done
    goto rxscan433_scan
  rxscan433_loop:
    (rx429_pos) = rx429_cur."from"()
    inc rx429_pos
    rx429_cur."!cursor_from"(rx429_pos)
    ge rx429_pos, rx429_eos, rxscan433_done
  rxscan433_scan:
    set_addr $I10, rxscan433_loop
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  rxscan433_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_434_fail
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  # rx literal  "until"
    add $I11, rx429_pos, 5
    gt $I11, rx429_eos, rx429_fail
    sub $I11, rx429_pos, rx429_off
    substr $S10, rx429_tgt, $I11, 5
    ne $S10, "until", rx429_fail
    add rx429_pos, 5
    set_addr $I10, rxcap_434_fail
    ($I12, $I11) = rx429_cur."!mark_peek"($I10)
    rx429_cur."!cursor_pos"($I11)
    ($P10) = rx429_cur."!cursor_start"()
    $P10."!cursor_pass"(rx429_pos, "")
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_434_done
  rxcap_434_fail:
    goto rx429_fail
  rxcap_434_done:
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."EXPR"()
    unless $P10, rx429_fail
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx429_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
  # rx pass
    rx429_cur."!cursor_pass"(rx429_pos, "statement_mod_loop:sym<until>")
    if_null rx429_debug, debug_583
    rx429_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx429_pos)
  debug_583:
    .return (rx429_cur)
  rx429_restart:
.annotate 'line', 4
    if_null rx429_debug, debug_584
    rx429_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_584:
  rx429_fail:
    (rx429_rep, rx429_pos, $I10, $P10) = rx429_cur."!mark_fail"(0)
    lt rx429_pos, -1, rx429_done
    eq rx429_pos, -1, rx429_fail
    jump $I10
  rx429_done:
    rx429_cur."!cursor_fail"()
    if_null rx429_debug, debug_585
    rx429_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_585:
    .return (rx429_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("96_1296306519.49046") :method
.annotate 'line', 4
    $P431 = self."!PREFIX__!subrule"("ws", "until")
    new $P432, "ResizablePMCArray"
    push $P432, $P431
    .return ($P432)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("97_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx438_tgt
    .local int rx438_pos
    .local int rx438_off
    .local int rx438_eos
    .local int rx438_rep
    .local pmc rx438_cur
    .local pmc rx438_debug
    (rx438_cur, rx438_pos, rx438_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx438_cur
    .local pmc match
    .lex "$/", match
    length rx438_eos, rx438_tgt
    gt rx438_pos, rx438_eos, rx438_done
    set rx438_off, 0
    lt rx438_pos, 2, rx438_start
    sub rx438_off, rx438_pos, 1
    substr rx438_tgt, rx438_tgt, rx438_off
  rx438_start:
    eq $I10, 1, rx438_restart
    if_null rx438_debug, debug_586
    rx438_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_586:
    $I10 = self.'from'()
    ne $I10, -1, rxscan442_done
    goto rxscan442_scan
  rxscan442_loop:
    (rx438_pos) = rx438_cur."from"()
    inc rx438_pos
    rx438_cur."!cursor_from"(rx438_pos)
    ge rx438_pos, rx438_eos, rxscan442_done
  rxscan442_scan:
    set_addr $I10, rxscan442_loop
    rx438_cur."!mark_push"(0, rx438_pos, $I10)
  rxscan442_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_443_fail
    rx438_cur."!mark_push"(0, rx438_pos, $I10)
  # rx literal  "for"
    add $I11, rx438_pos, 3
    gt $I11, rx438_eos, rx438_fail
    sub $I11, rx438_pos, rx438_off
    substr $S10, rx438_tgt, $I11, 3
    ne $S10, "for", rx438_fail
    add rx438_pos, 3
    set_addr $I10, rxcap_443_fail
    ($I12, $I11) = rx438_cur."!mark_peek"($I10)
    rx438_cur."!cursor_pos"($I11)
    ($P10) = rx438_cur."!cursor_start"()
    $P10."!cursor_pass"(rx438_pos, "")
    rx438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_443_done
  rxcap_443_fail:
    goto rx438_fail
  rxcap_443_done:
  # rx subrule "ws" subtype=method negate=
    rx438_cur."!cursor_pos"(rx438_pos)
    $P10 = rx438_cur."ws"()
    unless $P10, rx438_fail
    rx438_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx438_cur."!cursor_pos"(rx438_pos)
    $P10 = rx438_cur."EXPR"()
    unless $P10, rx438_fail
    rx438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx438_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx438_cur."!cursor_pos"(rx438_pos)
    $P10 = rx438_cur."ws"()
    unless $P10, rx438_fail
    rx438_pos = $P10."pos"()
  # rx pass
    rx438_cur."!cursor_pass"(rx438_pos, "statement_mod_loop:sym<for>")
    if_null rx438_debug, debug_587
    rx438_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx438_pos)
  debug_587:
    .return (rx438_cur)
  rx438_restart:
.annotate 'line', 4
    if_null rx438_debug, debug_588
    rx438_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_588:
  rx438_fail:
    (rx438_rep, rx438_pos, $I10, $P10) = rx438_cur."!mark_fail"(0)
    lt rx438_pos, -1, rx438_done
    eq rx438_pos, -1, rx438_fail
    jump $I10
  rx438_done:
    rx438_cur."!cursor_fail"()
    if_null rx438_debug, debug_589
    rx438_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_589:
    .return (rx438_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("98_1296306519.49046") :method
.annotate 'line', 4
    $P440 = self."!PREFIX__!subrule"("ws", "for")
    new $P441, "ResizablePMCArray"
    push $P441, $P440
    .return ($P441)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("99_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx447_tgt
    .local int rx447_pos
    .local int rx447_off
    .local int rx447_eos
    .local int rx447_rep
    .local pmc rx447_cur
    .local pmc rx447_debug
    (rx447_cur, rx447_pos, rx447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx447_cur
    .local pmc match
    .lex "$/", match
    length rx447_eos, rx447_tgt
    gt rx447_pos, rx447_eos, rx447_done
    set rx447_off, 0
    lt rx447_pos, 2, rx447_start
    sub rx447_off, rx447_pos, 1
    substr rx447_tgt, rx447_tgt, rx447_off
  rx447_start:
    eq $I10, 1, rx447_restart
    if_null rx447_debug, debug_590
    rx447_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_590:
    $I10 = self.'from'()
    ne $I10, -1, rxscan451_done
    goto rxscan451_scan
  rxscan451_loop:
    (rx447_pos) = rx447_cur."from"()
    inc rx447_pos
    rx447_cur."!cursor_from"(rx447_pos)
    ge rx447_pos, rx447_eos, rxscan451_done
  rxscan451_scan:
    set_addr $I10, rxscan451_loop
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  rxscan451_done:
.annotate 'line', 242
  # rx subrule "fatarrow" subtype=capture negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."fatarrow"()
    unless $P10, rx447_fail
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx447_pos = $P10."pos"()
  # rx pass
    rx447_cur."!cursor_pass"(rx447_pos, "term:sym<fatarrow>")
    if_null rx447_debug, debug_591
    rx447_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx447_pos)
  debug_591:
    .return (rx447_cur)
  rx447_restart:
.annotate 'line', 4
    if_null rx447_debug, debug_592
    rx447_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_592:
  rx447_fail:
    (rx447_rep, rx447_pos, $I10, $P10) = rx447_cur."!mark_fail"(0)
    lt rx447_pos, -1, rx447_done
    eq rx447_pos, -1, rx447_fail
    jump $I10
  rx447_done:
    rx447_cur."!cursor_fail"()
    if_null rx447_debug, debug_593
    rx447_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_593:
    .return (rx447_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("100_1296306519.49046") :method
.annotate 'line', 4
    $P449 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P450, "ResizablePMCArray"
    push $P450, $P449
    .return ($P450)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("101_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx453_tgt
    .local int rx453_pos
    .local int rx453_off
    .local int rx453_eos
    .local int rx453_rep
    .local pmc rx453_cur
    .local pmc rx453_debug
    (rx453_cur, rx453_pos, rx453_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx453_cur
    .local pmc match
    .lex "$/", match
    length rx453_eos, rx453_tgt
    gt rx453_pos, rx453_eos, rx453_done
    set rx453_off, 0
    lt rx453_pos, 2, rx453_start
    sub rx453_off, rx453_pos, 1
    substr rx453_tgt, rx453_tgt, rx453_off
  rx453_start:
    eq $I10, 1, rx453_restart
    if_null rx453_debug, debug_594
    rx453_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_594:
    $I10 = self.'from'()
    ne $I10, -1, rxscan457_done
    goto rxscan457_scan
  rxscan457_loop:
    (rx453_pos) = rx453_cur."from"()
    inc rx453_pos
    rx453_cur."!cursor_from"(rx453_pos)
    ge rx453_pos, rx453_eos, rxscan457_done
  rxscan457_scan:
    set_addr $I10, rxscan457_loop
    rx453_cur."!mark_push"(0, rx453_pos, $I10)
  rxscan457_done:
.annotate 'line', 243
  # rx subrule "colonpair" subtype=capture negate=
    rx453_cur."!cursor_pos"(rx453_pos)
    $P10 = rx453_cur."colonpair"()
    unless $P10, rx453_fail
    rx453_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx453_pos = $P10."pos"()
  # rx pass
    rx453_cur."!cursor_pass"(rx453_pos, "term:sym<colonpair>")
    if_null rx453_debug, debug_595
    rx453_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx453_pos)
  debug_595:
    .return (rx453_cur)
  rx453_restart:
.annotate 'line', 4
    if_null rx453_debug, debug_596
    rx453_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_596:
  rx453_fail:
    (rx453_rep, rx453_pos, $I10, $P10) = rx453_cur."!mark_fail"(0)
    lt rx453_pos, -1, rx453_done
    eq rx453_pos, -1, rx453_fail
    jump $I10
  rx453_done:
    rx453_cur."!cursor_fail"()
    if_null rx453_debug, debug_597
    rx453_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_597:
    .return (rx453_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("102_1296306519.49046") :method
.annotate 'line', 4
    $P455 = self."!PREFIX__!subrule"("colonpair", "")
    new $P456, "ResizablePMCArray"
    push $P456, $P455
    .return ($P456)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("103_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx459_tgt
    .local int rx459_pos
    .local int rx459_off
    .local int rx459_eos
    .local int rx459_rep
    .local pmc rx459_cur
    .local pmc rx459_debug
    (rx459_cur, rx459_pos, rx459_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx459_cur
    .local pmc match
    .lex "$/", match
    length rx459_eos, rx459_tgt
    gt rx459_pos, rx459_eos, rx459_done
    set rx459_off, 0
    lt rx459_pos, 2, rx459_start
    sub rx459_off, rx459_pos, 1
    substr rx459_tgt, rx459_tgt, rx459_off
  rx459_start:
    eq $I10, 1, rx459_restart
    if_null rx459_debug, debug_598
    rx459_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_598:
    $I10 = self.'from'()
    ne $I10, -1, rxscan463_done
    goto rxscan463_scan
  rxscan463_loop:
    (rx459_pos) = rx459_cur."from"()
    inc rx459_pos
    rx459_cur."!cursor_from"(rx459_pos)
    ge rx459_pos, rx459_eos, rxscan463_done
  rxscan463_scan:
    set_addr $I10, rxscan463_loop
    rx459_cur."!mark_push"(0, rx459_pos, $I10)
  rxscan463_done:
.annotate 'line', 244
  # rx subrule "variable" subtype=capture negate=
    rx459_cur."!cursor_pos"(rx459_pos)
    $P10 = rx459_cur."variable"()
    unless $P10, rx459_fail
    rx459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx459_pos = $P10."pos"()
  # rx pass
    rx459_cur."!cursor_pass"(rx459_pos, "term:sym<variable>")
    if_null rx459_debug, debug_599
    rx459_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx459_pos)
  debug_599:
    .return (rx459_cur)
  rx459_restart:
.annotate 'line', 4
    if_null rx459_debug, debug_600
    rx459_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_600:
  rx459_fail:
    (rx459_rep, rx459_pos, $I10, $P10) = rx459_cur."!mark_fail"(0)
    lt rx459_pos, -1, rx459_done
    eq rx459_pos, -1, rx459_fail
    jump $I10
  rx459_done:
    rx459_cur."!cursor_fail"()
    if_null rx459_debug, debug_601
    rx459_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_601:
    .return (rx459_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("104_1296306519.49046") :method
.annotate 'line', 4
    $P461 = self."!PREFIX__!subrule"("variable", "")
    new $P462, "ResizablePMCArray"
    push $P462, $P461
    .return ($P462)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("105_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx465_tgt
    .local int rx465_pos
    .local int rx465_off
    .local int rx465_eos
    .local int rx465_rep
    .local pmc rx465_cur
    .local pmc rx465_debug
    (rx465_cur, rx465_pos, rx465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx465_cur
    .local pmc match
    .lex "$/", match
    length rx465_eos, rx465_tgt
    gt rx465_pos, rx465_eos, rx465_done
    set rx465_off, 0
    lt rx465_pos, 2, rx465_start
    sub rx465_off, rx465_pos, 1
    substr rx465_tgt, rx465_tgt, rx465_off
  rx465_start:
    eq $I10, 1, rx465_restart
    if_null rx465_debug, debug_602
    rx465_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan469_done
    goto rxscan469_scan
  rxscan469_loop:
    (rx465_pos) = rx465_cur."from"()
    inc rx465_pos
    rx465_cur."!cursor_from"(rx465_pos)
    ge rx465_pos, rx465_eos, rxscan469_done
  rxscan469_scan:
    set_addr $I10, rxscan469_loop
    rx465_cur."!mark_push"(0, rx465_pos, $I10)
  rxscan469_done:
.annotate 'line', 245
  # rx subrule "package_declarator" subtype=capture negate=
    rx465_cur."!cursor_pos"(rx465_pos)
    $P10 = rx465_cur."package_declarator"()
    unless $P10, rx465_fail
    rx465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx465_pos = $P10."pos"()
  # rx pass
    rx465_cur."!cursor_pass"(rx465_pos, "term:sym<package_declarator>")
    if_null rx465_debug, debug_603
    rx465_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx465_pos)
  debug_603:
    .return (rx465_cur)
  rx465_restart:
.annotate 'line', 4
    if_null rx465_debug, debug_604
    rx465_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_604:
  rx465_fail:
    (rx465_rep, rx465_pos, $I10, $P10) = rx465_cur."!mark_fail"(0)
    lt rx465_pos, -1, rx465_done
    eq rx465_pos, -1, rx465_fail
    jump $I10
  rx465_done:
    rx465_cur."!cursor_fail"()
    if_null rx465_debug, debug_605
    rx465_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_605:
    .return (rx465_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("106_1296306519.49046") :method
.annotate 'line', 4
    $P467 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P468, "ResizablePMCArray"
    push $P468, $P467
    .return ($P468)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("107_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx471_tgt
    .local int rx471_pos
    .local int rx471_off
    .local int rx471_eos
    .local int rx471_rep
    .local pmc rx471_cur
    .local pmc rx471_debug
    (rx471_cur, rx471_pos, rx471_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx471_cur
    .local pmc match
    .lex "$/", match
    length rx471_eos, rx471_tgt
    gt rx471_pos, rx471_eos, rx471_done
    set rx471_off, 0
    lt rx471_pos, 2, rx471_start
    sub rx471_off, rx471_pos, 1
    substr rx471_tgt, rx471_tgt, rx471_off
  rx471_start:
    eq $I10, 1, rx471_restart
    if_null rx471_debug, debug_606
    rx471_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan475_done
    goto rxscan475_scan
  rxscan475_loop:
    (rx471_pos) = rx471_cur."from"()
    inc rx471_pos
    rx471_cur."!cursor_from"(rx471_pos)
    ge rx471_pos, rx471_eos, rxscan475_done
  rxscan475_scan:
    set_addr $I10, rxscan475_loop
    rx471_cur."!mark_push"(0, rx471_pos, $I10)
  rxscan475_done:
.annotate 'line', 246
  # rx subrule "scope_declarator" subtype=capture negate=
    rx471_cur."!cursor_pos"(rx471_pos)
    $P10 = rx471_cur."scope_declarator"()
    unless $P10, rx471_fail
    rx471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx471_pos = $P10."pos"()
  # rx pass
    rx471_cur."!cursor_pass"(rx471_pos, "term:sym<scope_declarator>")
    if_null rx471_debug, debug_607
    rx471_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx471_pos)
  debug_607:
    .return (rx471_cur)
  rx471_restart:
.annotate 'line', 4
    if_null rx471_debug, debug_608
    rx471_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_608:
  rx471_fail:
    (rx471_rep, rx471_pos, $I10, $P10) = rx471_cur."!mark_fail"(0)
    lt rx471_pos, -1, rx471_done
    eq rx471_pos, -1, rx471_fail
    jump $I10
  rx471_done:
    rx471_cur."!cursor_fail"()
    if_null rx471_debug, debug_609
    rx471_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_609:
    .return (rx471_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("108_1296306519.49046") :method
.annotate 'line', 4
    $P473 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P474, "ResizablePMCArray"
    push $P474, $P473
    .return ($P474)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("109_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx477_tgt
    .local int rx477_pos
    .local int rx477_off
    .local int rx477_eos
    .local int rx477_rep
    .local pmc rx477_cur
    .local pmc rx477_debug
    (rx477_cur, rx477_pos, rx477_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx477_cur
    .local pmc match
    .lex "$/", match
    length rx477_eos, rx477_tgt
    gt rx477_pos, rx477_eos, rx477_done
    set rx477_off, 0
    lt rx477_pos, 2, rx477_start
    sub rx477_off, rx477_pos, 1
    substr rx477_tgt, rx477_tgt, rx477_off
  rx477_start:
    eq $I10, 1, rx477_restart
    if_null rx477_debug, debug_610
    rx477_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan481_done
    goto rxscan481_scan
  rxscan481_loop:
    (rx477_pos) = rx477_cur."from"()
    inc rx477_pos
    rx477_cur."!cursor_from"(rx477_pos)
    ge rx477_pos, rx477_eos, rxscan481_done
  rxscan481_scan:
    set_addr $I10, rxscan481_loop
    rx477_cur."!mark_push"(0, rx477_pos, $I10)
  rxscan481_done:
.annotate 'line', 247
  # rx subrule "routine_declarator" subtype=capture negate=
    rx477_cur."!cursor_pos"(rx477_pos)
    $P10 = rx477_cur."routine_declarator"()
    unless $P10, rx477_fail
    rx477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx477_pos = $P10."pos"()
  # rx pass
    rx477_cur."!cursor_pass"(rx477_pos, "term:sym<routine_declarator>")
    if_null rx477_debug, debug_611
    rx477_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx477_pos)
  debug_611:
    .return (rx477_cur)
  rx477_restart:
.annotate 'line', 4
    if_null rx477_debug, debug_612
    rx477_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_612:
  rx477_fail:
    (rx477_rep, rx477_pos, $I10, $P10) = rx477_cur."!mark_fail"(0)
    lt rx477_pos, -1, rx477_done
    eq rx477_pos, -1, rx477_fail
    jump $I10
  rx477_done:
    rx477_cur."!cursor_fail"()
    if_null rx477_debug, debug_613
    rx477_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_613:
    .return (rx477_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("110_1296306519.49046") :method
.annotate 'line', 4
    $P479 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P480, "ResizablePMCArray"
    push $P480, $P479
    .return ($P480)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("111_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P493 = "114_1296306519.49046" 
    capture_lex $P493
    .const 'Sub' $P488 = "113_1296306519.49046" 
    capture_lex $P488
    .local string rx483_tgt
    .local int rx483_pos
    .local int rx483_off
    .local int rx483_eos
    .local int rx483_rep
    .local pmc rx483_cur
    .local pmc rx483_debug
    (rx483_cur, rx483_pos, rx483_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx483_cur
    .local pmc match
    .lex "$/", match
    length rx483_eos, rx483_tgt
    gt rx483_pos, rx483_eos, rx483_done
    set rx483_off, 0
    lt rx483_pos, 2, rx483_start
    sub rx483_off, rx483_pos, 1
    substr rx483_tgt, rx483_tgt, rx483_off
  rx483_start:
    eq $I10, 1, rx483_restart
    if_null rx483_debug, debug_614
    rx483_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan486_done
    goto rxscan486_scan
  rxscan486_loop:
    (rx483_pos) = rx483_cur."from"()
    inc rx483_pos
    rx483_cur."!cursor_from"(rx483_pos)
    ge rx483_pos, rx483_eos, rxscan486_done
  rxscan486_scan:
    set_addr $I10, rxscan486_loop
    rx483_cur."!mark_push"(0, rx483_pos, $I10)
  rxscan486_done:
.annotate 'line', 249
  # rx subrule "before" subtype=zerowidth negate=
    rx483_cur."!cursor_pos"(rx483_pos)
    .const 'Sub' $P488 = "113_1296306519.49046" 
    capture_lex $P488
    $P10 = rx483_cur."before"($P488)
    unless $P10, rx483_fail
.annotate 'line', 250
  # rx subrule "before" subtype=zerowidth negate=1
    rx483_cur."!cursor_pos"(rx483_pos)
    .const 'Sub' $P493 = "114_1296306519.49046" 
    capture_lex $P493
    $P10 = rx483_cur."before"($P493)
    if $P10, rx483_fail
.annotate 'line', 251
  # rx subrule "multi_declarator" subtype=capture negate=
    rx483_cur."!cursor_pos"(rx483_pos)
    $P10 = rx483_cur."multi_declarator"()
    unless $P10, rx483_fail
    rx483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx483_pos = $P10."pos"()
.annotate 'line', 248
  # rx pass
    rx483_cur."!cursor_pass"(rx483_pos, "term:sym<multi_declarator>")
    if_null rx483_debug, debug_623
    rx483_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx483_pos)
  debug_623:
    .return (rx483_cur)
  rx483_restart:
.annotate 'line', 4
    if_null rx483_debug, debug_624
    rx483_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_624:
  rx483_fail:
    (rx483_rep, rx483_pos, $I10, $P10) = rx483_cur."!mark_fail"(0)
    lt rx483_pos, -1, rx483_done
    eq rx483_pos, -1, rx483_fail
    jump $I10
  rx483_done:
    rx483_cur."!cursor_fail"()
    if_null rx483_debug, debug_625
    rx483_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_625:
    .return (rx483_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("112_1296306519.49046") :method
.annotate 'line', 4
    new $P485, "ResizablePMCArray"
    push $P485, ""
    .return ($P485)
.end


.namespace ["NQP";"Grammar"]
.sub "_block487"  :anon :subid("113_1296306519.49046") :method :outer("111_1296306519.49046")
.annotate 'line', 249
    .local string rx489_tgt
    .local int rx489_pos
    .local int rx489_off
    .local int rx489_eos
    .local int rx489_rep
    .local pmc rx489_cur
    .local pmc rx489_debug
    (rx489_cur, rx489_pos, rx489_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx489_cur
    .local pmc match
    .lex "$/", match
    length rx489_eos, rx489_tgt
    gt rx489_pos, rx489_eos, rx489_done
    set rx489_off, 0
    lt rx489_pos, 2, rx489_start
    sub rx489_off, rx489_pos, 1
    substr rx489_tgt, rx489_tgt, rx489_off
  rx489_start:
    eq $I10, 1, rx489_restart
    if_null rx489_debug, debug_615
    rx489_cur."!cursor_debug"("START", "")
  debug_615:
    $I10 = self.'from'()
    ne $I10, -1, rxscan490_done
    goto rxscan490_scan
  rxscan490_loop:
    (rx489_pos) = rx489_cur."from"()
    inc rx489_pos
    rx489_cur."!cursor_from"(rx489_pos)
    ge rx489_pos, rx489_eos, rxscan490_done
  rxscan490_scan:
    set_addr $I10, rxscan490_loop
    rx489_cur."!mark_push"(0, rx489_pos, $I10)
  rxscan490_done:
  alt491_0:
    set_addr $I10, alt491_1
    rx489_cur."!mark_push"(0, rx489_pos, $I10)
  # rx literal  "multi"
    add $I11, rx489_pos, 5
    gt $I11, rx489_eos, rx489_fail
    sub $I11, rx489_pos, rx489_off
    substr $S10, rx489_tgt, $I11, 5
    ne $S10, "multi", rx489_fail
    add rx489_pos, 5
    goto alt491_end
  alt491_1:
    set_addr $I10, alt491_2
    rx489_cur."!mark_push"(0, rx489_pos, $I10)
  # rx literal  "proto"
    add $I11, rx489_pos, 5
    gt $I11, rx489_eos, rx489_fail
    sub $I11, rx489_pos, rx489_off
    substr $S10, rx489_tgt, $I11, 5
    ne $S10, "proto", rx489_fail
    add rx489_pos, 5
    goto alt491_end
  alt491_2:
  # rx literal  "only"
    add $I11, rx489_pos, 4
    gt $I11, rx489_eos, rx489_fail
    sub $I11, rx489_pos, rx489_off
    substr $S10, rx489_tgt, $I11, 4
    ne $S10, "only", rx489_fail
    add rx489_pos, 4
  alt491_end:
  # rx pass
    rx489_cur."!cursor_pass"(rx489_pos, "")
    if_null rx489_debug, debug_616
    rx489_cur."!cursor_debug"("PASS", "", " at pos=", rx489_pos)
  debug_616:
    .return (rx489_cur)
  rx489_restart:
    if_null rx489_debug, debug_617
    rx489_cur."!cursor_debug"("NEXT", "")
  debug_617:
  rx489_fail:
    (rx489_rep, rx489_pos, $I10, $P10) = rx489_cur."!mark_fail"(0)
    lt rx489_pos, -1, rx489_done
    eq rx489_pos, -1, rx489_fail
    jump $I10
  rx489_done:
    rx489_cur."!cursor_fail"()
    if_null rx489_debug, debug_618
    rx489_cur."!cursor_debug"("FAIL", "")
  debug_618:
    .return (rx489_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "_block492"  :anon :subid("114_1296306519.49046") :method :outer("111_1296306519.49046")
.annotate 'line', 250
    .local string rx494_tgt
    .local int rx494_pos
    .local int rx494_off
    .local int rx494_eos
    .local int rx494_rep
    .local pmc rx494_cur
    .local pmc rx494_debug
    (rx494_cur, rx494_pos, rx494_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx494_cur
    .local pmc match
    .lex "$/", match
    length rx494_eos, rx494_tgt
    gt rx494_pos, rx494_eos, rx494_done
    set rx494_off, 0
    lt rx494_pos, 2, rx494_start
    sub rx494_off, rx494_pos, 1
    substr rx494_tgt, rx494_tgt, rx494_off
  rx494_start:
    eq $I10, 1, rx494_restart
    if_null rx494_debug, debug_619
    rx494_cur."!cursor_debug"("START", "")
  debug_619:
    $I10 = self.'from'()
    ne $I10, -1, rxscan495_done
    goto rxscan495_scan
  rxscan495_loop:
    (rx494_pos) = rx494_cur."from"()
    inc rx494_pos
    rx494_cur."!cursor_from"(rx494_pos)
    ge rx494_pos, rx494_eos, rxscan495_done
  rxscan495_scan:
    set_addr $I10, rxscan495_loop
    rx494_cur."!mark_push"(0, rx494_pos, $I10)
  rxscan495_done:
  # rx literal  "proto"
    add $I11, rx494_pos, 5
    gt $I11, rx494_eos, rx494_fail
    sub $I11, rx494_pos, rx494_off
    substr $S10, rx494_tgt, $I11, 5
    ne $S10, "proto", rx494_fail
    add rx494_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx494_cur."!cursor_pos"(rx494_pos)
    $P10 = rx494_cur."ws"()
    unless $P10, rx494_fail
    rx494_pos = $P10."pos"()
  alt496_0:
    set_addr $I10, alt496_1
    rx494_cur."!mark_push"(0, rx494_pos, $I10)
  # rx literal  "regex"
    add $I11, rx494_pos, 5
    gt $I11, rx494_eos, rx494_fail
    sub $I11, rx494_pos, rx494_off
    substr $S10, rx494_tgt, $I11, 5
    ne $S10, "regex", rx494_fail
    add rx494_pos, 5
    goto alt496_end
  alt496_1:
    set_addr $I10, alt496_2
    rx494_cur."!mark_push"(0, rx494_pos, $I10)
  # rx literal  "token"
    add $I11, rx494_pos, 5
    gt $I11, rx494_eos, rx494_fail
    sub $I11, rx494_pos, rx494_off
    substr $S10, rx494_tgt, $I11, 5
    ne $S10, "token", rx494_fail
    add rx494_pos, 5
    goto alt496_end
  alt496_2:
  # rx literal  "rule"
    add $I11, rx494_pos, 4
    gt $I11, rx494_eos, rx494_fail
    sub $I11, rx494_pos, rx494_off
    substr $S10, rx494_tgt, $I11, 4
    ne $S10, "rule", rx494_fail
    add rx494_pos, 4
  alt496_end:
  # rx pass
    rx494_cur."!cursor_pass"(rx494_pos, "")
    if_null rx494_debug, debug_620
    rx494_cur."!cursor_debug"("PASS", "", " at pos=", rx494_pos)
  debug_620:
    .return (rx494_cur)
  rx494_restart:
    if_null rx494_debug, debug_621
    rx494_cur."!cursor_debug"("NEXT", "")
  debug_621:
  rx494_fail:
    (rx494_rep, rx494_pos, $I10, $P10) = rx494_cur."!mark_fail"(0)
    lt rx494_pos, -1, rx494_done
    eq rx494_pos, -1, rx494_fail
    jump $I10
  rx494_done:
    rx494_cur."!cursor_fail"()
    if_null rx494_debug, debug_622
    rx494_cur."!cursor_debug"("FAIL", "")
  debug_622:
    .return (rx494_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("115_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx498_tgt
    .local int rx498_pos
    .local int rx498_off
    .local int rx498_eos
    .local int rx498_rep
    .local pmc rx498_cur
    .local pmc rx498_debug
    (rx498_cur, rx498_pos, rx498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx498_cur
    .local pmc match
    .lex "$/", match
    length rx498_eos, rx498_tgt
    gt rx498_pos, rx498_eos, rx498_done
    set rx498_off, 0
    lt rx498_pos, 2, rx498_start
    sub rx498_off, rx498_pos, 1
    substr rx498_tgt, rx498_tgt, rx498_off
  rx498_start:
    eq $I10, 1, rx498_restart
    if_null rx498_debug, debug_626
    rx498_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_626:
    $I10 = self.'from'()
    ne $I10, -1, rxscan502_done
    goto rxscan502_scan
  rxscan502_loop:
    (rx498_pos) = rx498_cur."from"()
    inc rx498_pos
    rx498_cur."!cursor_from"(rx498_pos)
    ge rx498_pos, rx498_eos, rxscan502_done
  rxscan502_scan:
    set_addr $I10, rxscan502_loop
    rx498_cur."!mark_push"(0, rx498_pos, $I10)
  rxscan502_done:
.annotate 'line', 253
  # rx subrule "regex_declarator" subtype=capture negate=
    rx498_cur."!cursor_pos"(rx498_pos)
    $P10 = rx498_cur."regex_declarator"()
    unless $P10, rx498_fail
    rx498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx498_pos = $P10."pos"()
  # rx pass
    rx498_cur."!cursor_pass"(rx498_pos, "term:sym<regex_declarator>")
    if_null rx498_debug, debug_627
    rx498_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx498_pos)
  debug_627:
    .return (rx498_cur)
  rx498_restart:
.annotate 'line', 4
    if_null rx498_debug, debug_628
    rx498_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_628:
  rx498_fail:
    (rx498_rep, rx498_pos, $I10, $P10) = rx498_cur."!mark_fail"(0)
    lt rx498_pos, -1, rx498_done
    eq rx498_pos, -1, rx498_fail
    jump $I10
  rx498_done:
    rx498_cur."!cursor_fail"()
    if_null rx498_debug, debug_629
    rx498_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_629:
    .return (rx498_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("116_1296306519.49046") :method
.annotate 'line', 4
    $P500 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P501, "ResizablePMCArray"
    push $P501, $P500
    .return ($P501)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("117_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx504_tgt
    .local int rx504_pos
    .local int rx504_off
    .local int rx504_eos
    .local int rx504_rep
    .local pmc rx504_cur
    .local pmc rx504_debug
    (rx504_cur, rx504_pos, rx504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx504_cur
    .local pmc match
    .lex "$/", match
    length rx504_eos, rx504_tgt
    gt rx504_pos, rx504_eos, rx504_done
    set rx504_off, 0
    lt rx504_pos, 2, rx504_start
    sub rx504_off, rx504_pos, 1
    substr rx504_tgt, rx504_tgt, rx504_off
  rx504_start:
    eq $I10, 1, rx504_restart
    if_null rx504_debug, debug_630
    rx504_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan508_done
    goto rxscan508_scan
  rxscan508_loop:
    (rx504_pos) = rx504_cur."from"()
    inc rx504_pos
    rx504_cur."!cursor_from"(rx504_pos)
    ge rx504_pos, rx504_eos, rxscan508_done
  rxscan508_scan:
    set_addr $I10, rxscan508_loop
    rx504_cur."!mark_push"(0, rx504_pos, $I10)
  rxscan508_done:
.annotate 'line', 254
  # rx subrule "statement_prefix" subtype=capture negate=
    rx504_cur."!cursor_pos"(rx504_pos)
    $P10 = rx504_cur."statement_prefix"()
    unless $P10, rx504_fail
    rx504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx504_pos = $P10."pos"()
  # rx pass
    rx504_cur."!cursor_pass"(rx504_pos, "term:sym<statement_prefix>")
    if_null rx504_debug, debug_631
    rx504_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx504_pos)
  debug_631:
    .return (rx504_cur)
  rx504_restart:
.annotate 'line', 4
    if_null rx504_debug, debug_632
    rx504_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_632:
  rx504_fail:
    (rx504_rep, rx504_pos, $I10, $P10) = rx504_cur."!mark_fail"(0)
    lt rx504_pos, -1, rx504_done
    eq rx504_pos, -1, rx504_fail
    jump $I10
  rx504_done:
    rx504_cur."!cursor_fail"()
    if_null rx504_debug, debug_633
    rx504_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_633:
    .return (rx504_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("118_1296306519.49046") :method
.annotate 'line', 4
    $P506 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P507, "ResizablePMCArray"
    push $P507, $P506
    .return ($P507)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("119_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx510_tgt
    .local int rx510_pos
    .local int rx510_off
    .local int rx510_eos
    .local int rx510_rep
    .local pmc rx510_cur
    .local pmc rx510_debug
    (rx510_cur, rx510_pos, rx510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx510_cur
    .local pmc match
    .lex "$/", match
    length rx510_eos, rx510_tgt
    gt rx510_pos, rx510_eos, rx510_done
    set rx510_off, 0
    lt rx510_pos, 2, rx510_start
    sub rx510_off, rx510_pos, 1
    substr rx510_tgt, rx510_tgt, rx510_off
  rx510_start:
    eq $I10, 1, rx510_restart
    if_null rx510_debug, debug_634
    rx510_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan513_done
    goto rxscan513_scan
  rxscan513_loop:
    (rx510_pos) = rx510_cur."from"()
    inc rx510_pos
    rx510_cur."!cursor_from"(rx510_pos)
    ge rx510_pos, rx510_eos, rxscan513_done
  rxscan513_scan:
    set_addr $I10, rxscan513_loop
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  rxscan513_done:
.annotate 'line', 255
  # rx subrule "lambda" subtype=zerowidth negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."lambda"()
    unless $P10, rx510_fail
  # rx subrule "pblock" subtype=capture negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."pblock"()
    unless $P10, rx510_fail
    rx510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx510_pos = $P10."pos"()
  # rx pass
    rx510_cur."!cursor_pass"(rx510_pos, "term:sym<lambda>")
    if_null rx510_debug, debug_635
    rx510_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx510_pos)
  debug_635:
    .return (rx510_cur)
  rx510_restart:
.annotate 'line', 4
    if_null rx510_debug, debug_636
    rx510_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_636:
  rx510_fail:
    (rx510_rep, rx510_pos, $I10, $P10) = rx510_cur."!mark_fail"(0)
    lt rx510_pos, -1, rx510_done
    eq rx510_pos, -1, rx510_fail
    jump $I10
  rx510_done:
    rx510_cur."!cursor_fail"()
    if_null rx510_debug, debug_637
    rx510_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_637:
    .return (rx510_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("120_1296306519.49046") :method
.annotate 'line', 4
    new $P512, "ResizablePMCArray"
    push $P512, ""
    .return ($P512)
.end


.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("121_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx515_tgt
    .local int rx515_pos
    .local int rx515_off
    .local int rx515_eos
    .local int rx515_rep
    .local pmc rx515_cur
    .local pmc rx515_debug
    (rx515_cur, rx515_pos, rx515_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx515_cur
    .local pmc match
    .lex "$/", match
    length rx515_eos, rx515_tgt
    gt rx515_pos, rx515_eos, rx515_done
    set rx515_off, 0
    lt rx515_pos, 2, rx515_start
    sub rx515_off, rx515_pos, 1
    substr rx515_tgt, rx515_tgt, rx515_off
  rx515_start:
    eq $I10, 1, rx515_restart
    if_null rx515_debug, debug_638
    rx515_cur."!cursor_debug"("START", "fatarrow")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan519_done
    goto rxscan519_scan
  rxscan519_loop:
    (rx515_pos) = rx515_cur."from"()
    inc rx515_pos
    rx515_cur."!cursor_from"(rx515_pos)
    ge rx515_pos, rx515_eos, rxscan519_done
  rxscan519_scan:
    set_addr $I10, rxscan519_loop
    rx515_cur."!mark_push"(0, rx515_pos, $I10)
  rxscan519_done:
.annotate 'line', 258
  # rx subrule "identifier" subtype=capture negate=
    rx515_cur."!cursor_pos"(rx515_pos)
    $P10 = rx515_cur."identifier"()
    unless $P10, rx515_fail
    rx515_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx515_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx515_pos, rx515_off
    set rx515_rep, 0
    sub $I12, rx515_eos, rx515_pos
  rxenumcharlistq520_loop:
    le $I12, 0, rxenumcharlistq520_done
    substr $S10, rx515_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq520_done
    inc rx515_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq520_loop
  rxenumcharlistq520_done:
    add rx515_pos, rx515_pos, rx515_rep
  # rx literal  "=>"
    add $I11, rx515_pos, 2
    gt $I11, rx515_eos, rx515_fail
    sub $I11, rx515_pos, rx515_off
    substr $S10, rx515_tgt, $I11, 2
    ne $S10, "=>", rx515_fail
    add rx515_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx515_cur."!cursor_pos"(rx515_pos)
    $P10 = rx515_cur."ws"()
    unless $P10, rx515_fail
    rx515_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx515_cur."!cursor_pos"(rx515_pos)
    $P10 = rx515_cur."EXPR"("i=")
    unless $P10, rx515_fail
    rx515_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx515_pos = $P10."pos"()
.annotate 'line', 257
  # rx pass
    rx515_cur."!cursor_pass"(rx515_pos, "fatarrow")
    if_null rx515_debug, debug_639
    rx515_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx515_pos)
  debug_639:
    .return (rx515_cur)
  rx515_restart:
.annotate 'line', 4
    if_null rx515_debug, debug_640
    rx515_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_640:
  rx515_fail:
    (rx515_rep, rx515_pos, $I10, $P10) = rx515_cur."!mark_fail"(0)
    lt rx515_pos, -1, rx515_done
    eq rx515_pos, -1, rx515_fail
    jump $I10
  rx515_done:
    rx515_cur."!cursor_fail"()
    if_null rx515_debug, debug_641
    rx515_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_641:
    .return (rx515_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("122_1296306519.49046") :method
.annotate 'line', 4
    $P517 = self."!PREFIX__!subrule"("identifier", "")
    new $P518, "ResizablePMCArray"
    push $P518, $P517
    .return ($P518)
.end


.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("123_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx522_tgt
    .local int rx522_pos
    .local int rx522_off
    .local int rx522_eos
    .local int rx522_rep
    .local pmc rx522_cur
    .local pmc rx522_debug
    (rx522_cur, rx522_pos, rx522_tgt, $I10) = self."!cursor_start"()
    rx522_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx522_cur
    .local pmc match
    .lex "$/", match
    length rx522_eos, rx522_tgt
    gt rx522_pos, rx522_eos, rx522_done
    set rx522_off, 0
    lt rx522_pos, 2, rx522_start
    sub rx522_off, rx522_pos, 1
    substr rx522_tgt, rx522_tgt, rx522_off
  rx522_start:
    eq $I10, 1, rx522_restart
    if_null rx522_debug, debug_642
    rx522_cur."!cursor_debug"("START", "colonpair")
  debug_642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan528_done
    goto rxscan528_scan
  rxscan528_loop:
    (rx522_pos) = rx522_cur."from"()
    inc rx522_pos
    rx522_cur."!cursor_from"(rx522_pos)
    ge rx522_pos, rx522_eos, rxscan528_done
  rxscan528_scan:
    set_addr $I10, rxscan528_loop
    rx522_cur."!mark_push"(0, rx522_pos, $I10)
  rxscan528_done:
.annotate 'line', 262
  # rx literal  ":"
    add $I11, rx522_pos, 1
    gt $I11, rx522_eos, rx522_fail
    sub $I11, rx522_pos, rx522_off
    ord $I11, rx522_tgt, $I11
    ne $I11, 58, rx522_fail
    add rx522_pos, 1
  alt529_0:
.annotate 'line', 263
    set_addr $I10, alt529_1
    rx522_cur."!mark_push"(0, rx522_pos, $I10)
.annotate 'line', 264
  # rx subcapture "not"
    set_addr $I10, rxcap_530_fail
    rx522_cur."!mark_push"(0, rx522_pos, $I10)
  # rx literal  "!"
    add $I11, rx522_pos, 1
    gt $I11, rx522_eos, rx522_fail
    sub $I11, rx522_pos, rx522_off
    ord $I11, rx522_tgt, $I11
    ne $I11, 33, rx522_fail
    add rx522_pos, 1
    set_addr $I10, rxcap_530_fail
    ($I12, $I11) = rx522_cur."!mark_peek"($I10)
    rx522_cur."!cursor_pos"($I11)
    ($P10) = rx522_cur."!cursor_start"()
    $P10."!cursor_pass"(rx522_pos, "")
    rx522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_530_done
  rxcap_530_fail:
    goto rx522_fail
  rxcap_530_done:
  # rx subrule "identifier" subtype=capture negate=
    rx522_cur."!cursor_pos"(rx522_pos)
    $P10 = rx522_cur."identifier"()
    unless $P10, rx522_fail
    rx522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx522_pos = $P10."pos"()
    goto alt529_end
  alt529_1:
    set_addr $I10, alt529_2
    rx522_cur."!mark_push"(0, rx522_pos, $I10)
.annotate 'line', 265
  # rx subrule "identifier" subtype=capture negate=
    rx522_cur."!cursor_pos"(rx522_pos)
    $P10 = rx522_cur."identifier"()
    unless $P10, rx522_fail
    rx522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx522_pos = $P10."pos"()
  # rx rxquantr531 ** 0..1
    set_addr $I10, rxquantr531_done
    rx522_cur."!mark_push"(0, rx522_pos, $I10)
  rxquantr531_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx522_cur."!cursor_pos"(rx522_pos)
    $P10 = rx522_cur."circumfix"()
    unless $P10, rx522_fail
    goto rxsubrule532_pass
  rxsubrule532_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx522_fail
  rxsubrule532_pass:
    set_addr $I10, rxsubrule532_back
    rx522_cur."!mark_push"(0, rx522_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx522_pos = $P10."pos"()
    set_addr $I10, rxquantr531_done
    (rx522_rep) = rx522_cur."!mark_commit"($I10)
  rxquantr531_done:
    goto alt529_end
  alt529_2:
.annotate 'line', 266
  # rx subrule "circumfix" subtype=capture negate=
    rx522_cur."!cursor_pos"(rx522_pos)
    $P10 = rx522_cur."circumfix"()
    unless $P10, rx522_fail
    rx522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx522_pos = $P10."pos"()
  alt529_end:
.annotate 'line', 261
  # rx pass
    rx522_cur."!cursor_pass"(rx522_pos, "colonpair")
    if_null rx522_debug, debug_643
    rx522_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx522_pos)
  debug_643:
    .return (rx522_cur)
  rx522_restart:
.annotate 'line', 4
    if_null rx522_debug, debug_644
    rx522_cur."!cursor_debug"("NEXT", "colonpair")
  debug_644:
  rx522_fail:
    (rx522_rep, rx522_pos, $I10, $P10) = rx522_cur."!mark_fail"(0)
    lt rx522_pos, -1, rx522_done
    eq rx522_pos, -1, rx522_fail
    jump $I10
  rx522_done:
    rx522_cur."!cursor_fail"()
    if_null rx522_debug, debug_645
    rx522_cur."!cursor_debug"("FAIL", "colonpair")
  debug_645:
    .return (rx522_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("124_1296306519.49046") :method
.annotate 'line', 4
    $P524 = self."!PREFIX__!subrule"("circumfix", ":")
    $P525 = self."!PREFIX__!subrule"("identifier", ":")
    $P526 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P527, "ResizablePMCArray"
    push $P527, $P524
    push $P527, $P525
    push $P527, $P526
    .return ($P527)
.end


.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("125_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx534_tgt
    .local int rx534_pos
    .local int rx534_off
    .local int rx534_eos
    .local int rx534_rep
    .local pmc rx534_cur
    .local pmc rx534_debug
    (rx534_cur, rx534_pos, rx534_tgt, $I10) = self."!cursor_start"()
    rx534_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx534_cur
    .local pmc match
    .lex "$/", match
    length rx534_eos, rx534_tgt
    gt rx534_pos, rx534_eos, rx534_done
    set rx534_off, 0
    lt rx534_pos, 2, rx534_start
    sub rx534_off, rx534_pos, 1
    substr rx534_tgt, rx534_tgt, rx534_off
  rx534_start:
    eq $I10, 1, rx534_restart
    if_null rx534_debug, debug_646
    rx534_cur."!cursor_debug"("START", "variable")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan539_done
    goto rxscan539_scan
  rxscan539_loop:
    (rx534_pos) = rx534_cur."from"()
    inc rx534_pos
    rx534_cur."!cursor_from"(rx534_pos)
    ge rx534_pos, rx534_eos, rxscan539_done
  rxscan539_scan:
    set_addr $I10, rxscan539_loop
    rx534_cur."!mark_push"(0, rx534_pos, $I10)
  rxscan539_done:
  alt540_0:
.annotate 'line', 270
    set_addr $I10, alt540_1
    rx534_cur."!mark_push"(0, rx534_pos, $I10)
.annotate 'line', 271
  # rx subrule "sigil" subtype=capture negate=
    rx534_cur."!cursor_pos"(rx534_pos)
    $P10 = rx534_cur."sigil"()
    unless $P10, rx534_fail
    rx534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx534_pos = $P10."pos"()
  # rx rxquantr541 ** 0..1
    set_addr $I10, rxquantr541_done
    rx534_cur."!mark_push"(0, rx534_pos, $I10)
  rxquantr541_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx534_cur."!cursor_pos"(rx534_pos)
    $P10 = rx534_cur."twigil"()
    unless $P10, rx534_fail
    goto rxsubrule542_pass
  rxsubrule542_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx534_fail
  rxsubrule542_pass:
    set_addr $I10, rxsubrule542_back
    rx534_cur."!mark_push"(0, rx534_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx534_pos = $P10."pos"()
    set_addr $I10, rxquantr541_done
    (rx534_rep) = rx534_cur."!mark_commit"($I10)
  rxquantr541_done:
  # rx subrule "name" subtype=capture negate=
    rx534_cur."!cursor_pos"(rx534_pos)
    $P10 = rx534_cur."name"()
    unless $P10, rx534_fail
    rx534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx534_pos = $P10."pos"()
    goto alt540_end
  alt540_1:
    set_addr $I10, alt540_2
    rx534_cur."!mark_push"(0, rx534_pos, $I10)
.annotate 'line', 272
  # rx subrule "sigil" subtype=capture negate=
    rx534_cur."!cursor_pos"(rx534_pos)
    $P10 = rx534_cur."sigil"()
    unless $P10, rx534_fail
    rx534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx534_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx534_pos, rx534_off
    substr $S10, rx534_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx534_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx534_cur."!cursor_pos"(rx534_pos)
    $P10 = rx534_cur."postcircumfix"()
    unless $P10, rx534_fail
    rx534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx534_pos = $P10."pos"()
    goto alt540_end
  alt540_2:
.annotate 'line', 273
  # rx subcapture "sigil"
    set_addr $I10, rxcap_543_fail
    rx534_cur."!mark_push"(0, rx534_pos, $I10)
  # rx literal  "$"
    add $I11, rx534_pos, 1
    gt $I11, rx534_eos, rx534_fail
    sub $I11, rx534_pos, rx534_off
    ord $I11, rx534_tgt, $I11
    ne $I11, 36, rx534_fail
    add rx534_pos, 1
    set_addr $I10, rxcap_543_fail
    ($I12, $I11) = rx534_cur."!mark_peek"($I10)
    rx534_cur."!cursor_pos"($I11)
    ($P10) = rx534_cur."!cursor_start"()
    $P10."!cursor_pass"(rx534_pos, "")
    rx534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_543_done
  rxcap_543_fail:
    goto rx534_fail
  rxcap_543_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_544_fail
    rx534_cur."!mark_push"(0, rx534_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx534_pos, rx534_eos, rx534_fail
    sub $I10, rx534_pos, rx534_off
    substr $S10, rx534_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx534_fail
    inc rx534_pos
    set_addr $I10, rxcap_544_fail
    ($I12, $I11) = rx534_cur."!mark_peek"($I10)
    rx534_cur."!cursor_pos"($I11)
    ($P10) = rx534_cur."!cursor_start"()
    $P10."!cursor_pass"(rx534_pos, "")
    rx534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_544_done
  rxcap_544_fail:
    goto rx534_fail
  rxcap_544_done:
  alt540_end:
.annotate 'line', 270
  # rx pass
    rx534_cur."!cursor_pass"(rx534_pos, "variable")
    if_null rx534_debug, debug_647
    rx534_cur."!cursor_debug"("PASS", "variable", " at pos=", rx534_pos)
  debug_647:
    .return (rx534_cur)
  rx534_restart:
.annotate 'line', 4
    if_null rx534_debug, debug_648
    rx534_cur."!cursor_debug"("NEXT", "variable")
  debug_648:
  rx534_fail:
    (rx534_rep, rx534_pos, $I10, $P10) = rx534_cur."!mark_fail"(0)
    lt rx534_pos, -1, rx534_done
    eq rx534_pos, -1, rx534_fail
    jump $I10
  rx534_done:
    rx534_cur."!cursor_fail"()
    if_null rx534_debug, debug_649
    rx534_cur."!cursor_debug"("FAIL", "variable")
  debug_649:
    .return (rx534_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("126_1296306519.49046") :method
.annotate 'line', 4
    $P536 = self."!PREFIX__!subrule"("sigil", "")
    $P537 = self."!PREFIX__!subrule"("sigil", "")
    new $P538, "ResizablePMCArray"
    push $P538, "$!"
    push $P538, "$_"
    push $P538, "$/"
    push $P538, $P536
    push $P538, $P537
    .return ($P538)
.end


.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("127_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx546_tgt
    .local int rx546_pos
    .local int rx546_off
    .local int rx546_eos
    .local int rx546_rep
    .local pmc rx546_cur
    .local pmc rx546_debug
    (rx546_cur, rx546_pos, rx546_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx546_cur
    .local pmc match
    .lex "$/", match
    length rx546_eos, rx546_tgt
    gt rx546_pos, rx546_eos, rx546_done
    set rx546_off, 0
    lt rx546_pos, 2, rx546_start
    sub rx546_off, rx546_pos, 1
    substr rx546_tgt, rx546_tgt, rx546_off
  rx546_start:
    eq $I10, 1, rx546_restart
    if_null rx546_debug, debug_650
    rx546_cur."!cursor_debug"("START", "sigil")
  debug_650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan549_done
    goto rxscan549_scan
  rxscan549_loop:
    (rx546_pos) = rx546_cur."from"()
    inc rx546_pos
    rx546_cur."!cursor_from"(rx546_pos)
    ge rx546_pos, rx546_eos, rxscan549_done
  rxscan549_scan:
    set_addr $I10, rxscan549_loop
    rx546_cur."!mark_push"(0, rx546_pos, $I10)
  rxscan549_done:
.annotate 'line', 276
  # rx enumcharlist negate=0 
    ge rx546_pos, rx546_eos, rx546_fail
    sub $I10, rx546_pos, rx546_off
    substr $S10, rx546_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx546_fail
    inc rx546_pos
  # rx pass
    rx546_cur."!cursor_pass"(rx546_pos, "sigil")
    if_null rx546_debug, debug_651
    rx546_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx546_pos)
  debug_651:
    .return (rx546_cur)
  rx546_restart:
.annotate 'line', 4
    if_null rx546_debug, debug_652
    rx546_cur."!cursor_debug"("NEXT", "sigil")
  debug_652:
  rx546_fail:
    (rx546_rep, rx546_pos, $I10, $P10) = rx546_cur."!mark_fail"(0)
    lt rx546_pos, -1, rx546_done
    eq rx546_pos, -1, rx546_fail
    jump $I10
  rx546_done:
    rx546_cur."!cursor_fail"()
    if_null rx546_debug, debug_653
    rx546_cur."!cursor_debug"("FAIL", "sigil")
  debug_653:
    .return (rx546_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("128_1296306519.49046") :method
.annotate 'line', 4
    new $P548, "ResizablePMCArray"
    push $P548, "&"
    push $P548, "%"
    push $P548, "@"
    push $P548, "$"
    .return ($P548)
.end


.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("129_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx551_tgt
    .local int rx551_pos
    .local int rx551_off
    .local int rx551_eos
    .local int rx551_rep
    .local pmc rx551_cur
    .local pmc rx551_debug
    (rx551_cur, rx551_pos, rx551_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx551_cur
    .local pmc match
    .lex "$/", match
    length rx551_eos, rx551_tgt
    gt rx551_pos, rx551_eos, rx551_done
    set rx551_off, 0
    lt rx551_pos, 2, rx551_start
    sub rx551_off, rx551_pos, 1
    substr rx551_tgt, rx551_tgt, rx551_off
  rx551_start:
    eq $I10, 1, rx551_restart
    if_null rx551_debug, debug_654
    rx551_cur."!cursor_debug"("START", "twigil")
  debug_654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan554_done
    goto rxscan554_scan
  rxscan554_loop:
    (rx551_pos) = rx551_cur."from"()
    inc rx551_pos
    rx551_cur."!cursor_from"(rx551_pos)
    ge rx551_pos, rx551_eos, rxscan554_done
  rxscan554_scan:
    set_addr $I10, rxscan554_loop
    rx551_cur."!mark_push"(0, rx551_pos, $I10)
  rxscan554_done:
.annotate 'line', 278
  # rx enumcharlist negate=0 
    ge rx551_pos, rx551_eos, rx551_fail
    sub $I10, rx551_pos, rx551_off
    substr $S10, rx551_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx551_fail
    inc rx551_pos
  # rx pass
    rx551_cur."!cursor_pass"(rx551_pos, "twigil")
    if_null rx551_debug, debug_655
    rx551_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx551_pos)
  debug_655:
    .return (rx551_cur)
  rx551_restart:
.annotate 'line', 4
    if_null rx551_debug, debug_656
    rx551_cur."!cursor_debug"("NEXT", "twigil")
  debug_656:
  rx551_fail:
    (rx551_rep, rx551_pos, $I10, $P10) = rx551_cur."!mark_fail"(0)
    lt rx551_pos, -1, rx551_done
    eq rx551_pos, -1, rx551_fail
    jump $I10
  rx551_done:
    rx551_cur."!cursor_fail"()
    if_null rx551_debug, debug_657
    rx551_cur."!cursor_debug"("FAIL", "twigil")
  debug_657:
    .return (rx551_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("130_1296306519.49046") :method
.annotate 'line', 4
    new $P553, "ResizablePMCArray"
    push $P553, "?"
    push $P553, "!"
    push $P553, "*"
    .return ($P553)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("131_1296306519.49046")
    .param pmc param_556
.annotate 'line', 280
    .lex "self", param_556
    $P557 = param_556."!protoregex"("package_declarator")
    .return ($P557)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("132_1296306519.49046")
    .param pmc param_559
.annotate 'line', 280
    .lex "self", param_559
    $P560 = param_559."!PREFIX__!protoregex"("package_declarator")
    .return ($P560)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("133_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx562_tgt
    .local int rx562_pos
    .local int rx562_off
    .local int rx562_eos
    .local int rx562_rep
    .local pmc rx562_cur
    .local pmc rx562_debug
    (rx562_cur, rx562_pos, rx562_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx562_cur
    .local pmc match
    .lex "$/", match
    length rx562_eos, rx562_tgt
    gt rx562_pos, rx562_eos, rx562_done
    set rx562_off, 0
    lt rx562_pos, 2, rx562_start
    sub rx562_off, rx562_pos, 1
    substr rx562_tgt, rx562_tgt, rx562_off
  rx562_start:
    eq $I10, 1, rx562_restart
    if_null rx562_debug, debug_658
    rx562_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_658:
    $I10 = self.'from'()
    ne $I10, -1, rxscan566_done
    goto rxscan566_scan
  rxscan566_loop:
    (rx562_pos) = rx562_cur."from"()
    inc rx562_pos
    rx562_cur."!cursor_from"(rx562_pos)
    ge rx562_pos, rx562_eos, rxscan566_done
  rxscan566_scan:
    set_addr $I10, rxscan566_loop
    rx562_cur."!mark_push"(0, rx562_pos, $I10)
  rxscan566_done:
.annotate 'line', 281
  # rx subcapture "sym"
    set_addr $I10, rxcap_567_fail
    rx562_cur."!mark_push"(0, rx562_pos, $I10)
  # rx literal  "module"
    add $I11, rx562_pos, 6
    gt $I11, rx562_eos, rx562_fail
    sub $I11, rx562_pos, rx562_off
    substr $S10, rx562_tgt, $I11, 6
    ne $S10, "module", rx562_fail
    add rx562_pos, 6
    set_addr $I10, rxcap_567_fail
    ($I12, $I11) = rx562_cur."!mark_peek"($I10)
    rx562_cur."!cursor_pos"($I11)
    ($P10) = rx562_cur."!cursor_start"()
    $P10."!cursor_pass"(rx562_pos, "")
    rx562_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_567_done
  rxcap_567_fail:
    goto rx562_fail
  rxcap_567_done:
  # rx subrule "package_def" subtype=capture negate=
    rx562_cur."!cursor_pos"(rx562_pos)
    $P10 = rx562_cur."package_def"()
    unless $P10, rx562_fail
    rx562_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx562_pos = $P10."pos"()
  # rx pass
    rx562_cur."!cursor_pass"(rx562_pos, "package_declarator:sym<module>")
    if_null rx562_debug, debug_659
    rx562_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx562_pos)
  debug_659:
    .return (rx562_cur)
  rx562_restart:
.annotate 'line', 4
    if_null rx562_debug, debug_660
    rx562_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_660:
  rx562_fail:
    (rx562_rep, rx562_pos, $I10, $P10) = rx562_cur."!mark_fail"(0)
    lt rx562_pos, -1, rx562_done
    eq rx562_pos, -1, rx562_fail
    jump $I10
  rx562_done:
    rx562_cur."!cursor_fail"()
    if_null rx562_debug, debug_661
    rx562_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_661:
    .return (rx562_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("134_1296306519.49046") :method
.annotate 'line', 4
    $P564 = self."!PREFIX__!subrule"("package_def", "module")
    new $P565, "ResizablePMCArray"
    push $P565, $P564
    .return ($P565)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("135_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 283
    new $P569, "Undef"
    .lex "$*PACKAGE-SETUP", $P569
.annotate 'line', 284
    new $P570, "Undef"
    .lex "$*PKGDECL", $P570
.annotate 'line', 4
    .local string rx571_tgt
    .local int rx571_pos
    .local int rx571_off
    .local int rx571_eos
    .local int rx571_rep
    .local pmc rx571_cur
    .local pmc rx571_debug
    (rx571_cur, rx571_pos, rx571_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx571_cur
    .local pmc match
    .lex "$/", match
    length rx571_eos, rx571_tgt
    gt rx571_pos, rx571_eos, rx571_done
    set rx571_off, 0
    lt rx571_pos, 2, rx571_start
    sub rx571_off, rx571_pos, 1
    substr rx571_tgt, rx571_tgt, rx571_off
  rx571_start:
    eq $I10, 1, rx571_restart
    if_null rx571_debug, debug_662
    rx571_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_662:
    $I10 = self.'from'()
    ne $I10, -1, rxscan575_done
    goto rxscan575_scan
  rxscan575_loop:
    (rx571_pos) = rx571_cur."from"()
    inc rx571_pos
    rx571_cur."!cursor_from"(rx571_pos)
    ge rx571_pos, rx571_eos, rxscan575_done
  rxscan575_scan:
    set_addr $I10, rxscan575_loop
    rx571_cur."!mark_push"(0, rx571_pos, $I10)
  rxscan575_done:
.annotate 'line', 283
    rx571_cur."!cursor_pos"(rx571_pos)
    get_hll_global $P576, ["PAST"], "Stmts"
    $P577 = $P576."new"()
    store_lex "$*PACKAGE-SETUP", $P577
.annotate 'line', 284
    rx571_cur."!cursor_pos"(rx571_pos)
    new $P578, "String"
    assign $P578, "knowhow"
    store_lex "$*PKGDECL", $P578
.annotate 'line', 285
  # rx subcapture "sym"
    set_addr $I10, rxcap_579_fail
    rx571_cur."!mark_push"(0, rx571_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx571_pos, 7
    gt $I11, rx571_eos, rx571_fail
    sub $I11, rx571_pos, rx571_off
    substr $S10, rx571_tgt, $I11, 7
    ne $S10, "knowhow", rx571_fail
    add rx571_pos, 7
    set_addr $I10, rxcap_579_fail
    ($I12, $I11) = rx571_cur."!mark_peek"($I10)
    rx571_cur."!cursor_pos"($I11)
    ($P10) = rx571_cur."!cursor_start"()
    $P10."!cursor_pass"(rx571_pos, "")
    rx571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_579_done
  rxcap_579_fail:
    goto rx571_fail
  rxcap_579_done:
  # rx subrule "package_def" subtype=capture negate=
    rx571_cur."!cursor_pos"(rx571_pos)
    $P10 = rx571_cur."package_def"()
    unless $P10, rx571_fail
    rx571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx571_pos = $P10."pos"()
.annotate 'line', 282
  # rx pass
    rx571_cur."!cursor_pass"(rx571_pos, "package_declarator:sym<knowhow>")
    if_null rx571_debug, debug_663
    rx571_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx571_pos)
  debug_663:
    .return (rx571_cur)
  rx571_restart:
.annotate 'line', 4
    if_null rx571_debug, debug_664
    rx571_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_664:
  rx571_fail:
    (rx571_rep, rx571_pos, $I10, $P10) = rx571_cur."!mark_fail"(0)
    lt rx571_pos, -1, rx571_done
    eq rx571_pos, -1, rx571_fail
    jump $I10
  rx571_done:
    rx571_cur."!cursor_fail"()
    if_null rx571_debug, debug_665
    rx571_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_665:
    .return (rx571_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("136_1296306519.49046") :method
.annotate 'line', 4
    $P573 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P574, "ResizablePMCArray"
    push $P574, $P573
    .return ($P574)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("137_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 288
    new $P581, "Undef"
    .lex "$*PACKAGE-SETUP", $P581
.annotate 'line', 289
    new $P582, "Undef"
    .lex "$*PKGDECL", $P582
.annotate 'line', 4
    .local string rx583_tgt
    .local int rx583_pos
    .local int rx583_off
    .local int rx583_eos
    .local int rx583_rep
    .local pmc rx583_cur
    .local pmc rx583_debug
    (rx583_cur, rx583_pos, rx583_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx583_cur
    .local pmc match
    .lex "$/", match
    length rx583_eos, rx583_tgt
    gt rx583_pos, rx583_eos, rx583_done
    set rx583_off, 0
    lt rx583_pos, 2, rx583_start
    sub rx583_off, rx583_pos, 1
    substr rx583_tgt, rx583_tgt, rx583_off
  rx583_start:
    eq $I10, 1, rx583_restart
    if_null rx583_debug, debug_666
    rx583_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan587_done
    goto rxscan587_scan
  rxscan587_loop:
    (rx583_pos) = rx583_cur."from"()
    inc rx583_pos
    rx583_cur."!cursor_from"(rx583_pos)
    ge rx583_pos, rx583_eos, rxscan587_done
  rxscan587_scan:
    set_addr $I10, rxscan587_loop
    rx583_cur."!mark_push"(0, rx583_pos, $I10)
  rxscan587_done:
.annotate 'line', 288
    rx583_cur."!cursor_pos"(rx583_pos)
    get_hll_global $P588, ["PAST"], "Stmts"
    $P589 = $P588."new"()
    store_lex "$*PACKAGE-SETUP", $P589
.annotate 'line', 289
    rx583_cur."!cursor_pos"(rx583_pos)
    new $P590, "String"
    assign $P590, "class"
    store_lex "$*PKGDECL", $P590
.annotate 'line', 290
  # rx subcapture "sym"
    set_addr $I10, rxcap_591_fail
    rx583_cur."!mark_push"(0, rx583_pos, $I10)
  # rx literal  "class"
    add $I11, rx583_pos, 5
    gt $I11, rx583_eos, rx583_fail
    sub $I11, rx583_pos, rx583_off
    substr $S10, rx583_tgt, $I11, 5
    ne $S10, "class", rx583_fail
    add rx583_pos, 5
    set_addr $I10, rxcap_591_fail
    ($I12, $I11) = rx583_cur."!mark_peek"($I10)
    rx583_cur."!cursor_pos"($I11)
    ($P10) = rx583_cur."!cursor_start"()
    $P10."!cursor_pass"(rx583_pos, "")
    rx583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_591_done
  rxcap_591_fail:
    goto rx583_fail
  rxcap_591_done:
  # rx subrule "package_def" subtype=capture negate=
    rx583_cur."!cursor_pos"(rx583_pos)
    $P10 = rx583_cur."package_def"()
    unless $P10, rx583_fail
    rx583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx583_pos = $P10."pos"()
.annotate 'line', 287
  # rx pass
    rx583_cur."!cursor_pass"(rx583_pos, "package_declarator:sym<class>")
    if_null rx583_debug, debug_667
    rx583_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx583_pos)
  debug_667:
    .return (rx583_cur)
  rx583_restart:
.annotate 'line', 4
    if_null rx583_debug, debug_668
    rx583_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_668:
  rx583_fail:
    (rx583_rep, rx583_pos, $I10, $P10) = rx583_cur."!mark_fail"(0)
    lt rx583_pos, -1, rx583_done
    eq rx583_pos, -1, rx583_fail
    jump $I10
  rx583_done:
    rx583_cur."!cursor_fail"()
    if_null rx583_debug, debug_669
    rx583_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_669:
    .return (rx583_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("138_1296306519.49046") :method
.annotate 'line', 4
    $P585 = self."!PREFIX__!subrule"("package_def", "class")
    new $P586, "ResizablePMCArray"
    push $P586, $P585
    .return ($P586)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("139_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 293
    new $P593, "Undef"
    .lex "$*PACKAGE-SETUP", $P593
.annotate 'line', 294
    new $P594, "Undef"
    .lex "$*PKGDECL", $P594
.annotate 'line', 4
    .local string rx595_tgt
    .local int rx595_pos
    .local int rx595_off
    .local int rx595_eos
    .local int rx595_rep
    .local pmc rx595_cur
    .local pmc rx595_debug
    (rx595_cur, rx595_pos, rx595_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx595_cur
    .local pmc match
    .lex "$/", match
    length rx595_eos, rx595_tgt
    gt rx595_pos, rx595_eos, rx595_done
    set rx595_off, 0
    lt rx595_pos, 2, rx595_start
    sub rx595_off, rx595_pos, 1
    substr rx595_tgt, rx595_tgt, rx595_off
  rx595_start:
    eq $I10, 1, rx595_restart
    if_null rx595_debug, debug_670
    rx595_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_670:
    $I10 = self.'from'()
    ne $I10, -1, rxscan599_done
    goto rxscan599_scan
  rxscan599_loop:
    (rx595_pos) = rx595_cur."from"()
    inc rx595_pos
    rx595_cur."!cursor_from"(rx595_pos)
    ge rx595_pos, rx595_eos, rxscan599_done
  rxscan599_scan:
    set_addr $I10, rxscan599_loop
    rx595_cur."!mark_push"(0, rx595_pos, $I10)
  rxscan599_done:
.annotate 'line', 293
    rx595_cur."!cursor_pos"(rx595_pos)
    get_hll_global $P600, ["PAST"], "Stmts"
    $P601 = $P600."new"()
    store_lex "$*PACKAGE-SETUP", $P601
.annotate 'line', 294
    rx595_cur."!cursor_pos"(rx595_pos)
    new $P602, "String"
    assign $P602, "grammar"
    store_lex "$*PKGDECL", $P602
.annotate 'line', 295
  # rx subcapture "sym"
    set_addr $I10, rxcap_603_fail
    rx595_cur."!mark_push"(0, rx595_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx595_pos, 7
    gt $I11, rx595_eos, rx595_fail
    sub $I11, rx595_pos, rx595_off
    substr $S10, rx595_tgt, $I11, 7
    ne $S10, "grammar", rx595_fail
    add rx595_pos, 7
    set_addr $I10, rxcap_603_fail
    ($I12, $I11) = rx595_cur."!mark_peek"($I10)
    rx595_cur."!cursor_pos"($I11)
    ($P10) = rx595_cur."!cursor_start"()
    $P10."!cursor_pass"(rx595_pos, "")
    rx595_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_603_done
  rxcap_603_fail:
    goto rx595_fail
  rxcap_603_done:
  # rx subrule "package_def" subtype=capture negate=
    rx595_cur."!cursor_pos"(rx595_pos)
    $P10 = rx595_cur."package_def"()
    unless $P10, rx595_fail
    rx595_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx595_pos = $P10."pos"()
.annotate 'line', 292
  # rx pass
    rx595_cur."!cursor_pass"(rx595_pos, "package_declarator:sym<grammar>")
    if_null rx595_debug, debug_671
    rx595_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx595_pos)
  debug_671:
    .return (rx595_cur)
  rx595_restart:
.annotate 'line', 4
    if_null rx595_debug, debug_672
    rx595_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_672:
  rx595_fail:
    (rx595_rep, rx595_pos, $I10, $P10) = rx595_cur."!mark_fail"(0)
    lt rx595_pos, -1, rx595_done
    eq rx595_pos, -1, rx595_fail
    jump $I10
  rx595_done:
    rx595_cur."!cursor_fail"()
    if_null rx595_debug, debug_673
    rx595_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_673:
    .return (rx595_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("140_1296306519.49046") :method
.annotate 'line', 4
    $P597 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P598, "ResizablePMCArray"
    push $P598, $P597
    .return ($P598)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("141_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 298
    new $P605, "Undef"
    .lex "$*PACKAGE-SETUP", $P605
.annotate 'line', 299
    new $P606, "Undef"
    .lex "$*PKGDECL", $P606
.annotate 'line', 4
    .local string rx607_tgt
    .local int rx607_pos
    .local int rx607_off
    .local int rx607_eos
    .local int rx607_rep
    .local pmc rx607_cur
    .local pmc rx607_debug
    (rx607_cur, rx607_pos, rx607_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx607_cur
    .local pmc match
    .lex "$/", match
    length rx607_eos, rx607_tgt
    gt rx607_pos, rx607_eos, rx607_done
    set rx607_off, 0
    lt rx607_pos, 2, rx607_start
    sub rx607_off, rx607_pos, 1
    substr rx607_tgt, rx607_tgt, rx607_off
  rx607_start:
    eq $I10, 1, rx607_restart
    if_null rx607_debug, debug_674
    rx607_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_674:
    $I10 = self.'from'()
    ne $I10, -1, rxscan611_done
    goto rxscan611_scan
  rxscan611_loop:
    (rx607_pos) = rx607_cur."from"()
    inc rx607_pos
    rx607_cur."!cursor_from"(rx607_pos)
    ge rx607_pos, rx607_eos, rxscan611_done
  rxscan611_scan:
    set_addr $I10, rxscan611_loop
    rx607_cur."!mark_push"(0, rx607_pos, $I10)
  rxscan611_done:
.annotate 'line', 298
    rx607_cur."!cursor_pos"(rx607_pos)
    get_hll_global $P612, ["PAST"], "Stmts"
    $P613 = $P612."new"()
    store_lex "$*PACKAGE-SETUP", $P613
.annotate 'line', 299
    rx607_cur."!cursor_pos"(rx607_pos)
    new $P614, "String"
    assign $P614, "role"
    store_lex "$*PKGDECL", $P614
.annotate 'line', 300
  # rx subcapture "sym"
    set_addr $I10, rxcap_615_fail
    rx607_cur."!mark_push"(0, rx607_pos, $I10)
  # rx literal  "role"
    add $I11, rx607_pos, 4
    gt $I11, rx607_eos, rx607_fail
    sub $I11, rx607_pos, rx607_off
    substr $S10, rx607_tgt, $I11, 4
    ne $S10, "role", rx607_fail
    add rx607_pos, 4
    set_addr $I10, rxcap_615_fail
    ($I12, $I11) = rx607_cur."!mark_peek"($I10)
    rx607_cur."!cursor_pos"($I11)
    ($P10) = rx607_cur."!cursor_start"()
    $P10."!cursor_pass"(rx607_pos, "")
    rx607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_615_done
  rxcap_615_fail:
    goto rx607_fail
  rxcap_615_done:
  # rx subrule "package_def" subtype=capture negate=
    rx607_cur."!cursor_pos"(rx607_pos)
    $P10 = rx607_cur."package_def"()
    unless $P10, rx607_fail
    rx607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx607_pos = $P10."pos"()
.annotate 'line', 297
  # rx pass
    rx607_cur."!cursor_pass"(rx607_pos, "package_declarator:sym<role>")
    if_null rx607_debug, debug_675
    rx607_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx607_pos)
  debug_675:
    .return (rx607_cur)
  rx607_restart:
.annotate 'line', 4
    if_null rx607_debug, debug_676
    rx607_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_676:
  rx607_fail:
    (rx607_rep, rx607_pos, $I10, $P10) = rx607_cur."!mark_fail"(0)
    lt rx607_pos, -1, rx607_done
    eq rx607_pos, -1, rx607_fail
    jump $I10
  rx607_done:
    rx607_cur."!cursor_fail"()
    if_null rx607_debug, debug_677
    rx607_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_677:
    .return (rx607_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("142_1296306519.49046") :method
.annotate 'line', 4
    $P609 = self."!PREFIX__!subrule"("package_def", "role")
    new $P610, "ResizablePMCArray"
    push $P610, $P609
    .return ($P610)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("143_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 303
    new $P617, "Undef"
    .lex "$*PACKAGE-SETUP", $P617
.annotate 'line', 304
    new $P618, "Undef"
    .lex "$*PKGDECL", $P618
.annotate 'line', 4
    .local string rx619_tgt
    .local int rx619_pos
    .local int rx619_off
    .local int rx619_eos
    .local int rx619_rep
    .local pmc rx619_cur
    .local pmc rx619_debug
    (rx619_cur, rx619_pos, rx619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx619_cur
    .local pmc match
    .lex "$/", match
    length rx619_eos, rx619_tgt
    gt rx619_pos, rx619_eos, rx619_done
    set rx619_off, 0
    lt rx619_pos, 2, rx619_start
    sub rx619_off, rx619_pos, 1
    substr rx619_tgt, rx619_tgt, rx619_off
  rx619_start:
    eq $I10, 1, rx619_restart
    if_null rx619_debug, debug_678
    rx619_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_678:
    $I10 = self.'from'()
    ne $I10, -1, rxscan623_done
    goto rxscan623_scan
  rxscan623_loop:
    (rx619_pos) = rx619_cur."from"()
    inc rx619_pos
    rx619_cur."!cursor_from"(rx619_pos)
    ge rx619_pos, rx619_eos, rxscan623_done
  rxscan623_scan:
    set_addr $I10, rxscan623_loop
    rx619_cur."!mark_push"(0, rx619_pos, $I10)
  rxscan623_done:
.annotate 'line', 303
    rx619_cur."!cursor_pos"(rx619_pos)
    get_hll_global $P624, ["PAST"], "Stmts"
    $P625 = $P624."new"()
    store_lex "$*PACKAGE-SETUP", $P625
.annotate 'line', 304
    rx619_cur."!cursor_pos"(rx619_pos)
    new $P626, "String"
    assign $P626, "native"
    store_lex "$*PKGDECL", $P626
.annotate 'line', 305
  # rx subcapture "sym"
    set_addr $I10, rxcap_627_fail
    rx619_cur."!mark_push"(0, rx619_pos, $I10)
  # rx literal  "native"
    add $I11, rx619_pos, 6
    gt $I11, rx619_eos, rx619_fail
    sub $I11, rx619_pos, rx619_off
    substr $S10, rx619_tgt, $I11, 6
    ne $S10, "native", rx619_fail
    add rx619_pos, 6
    set_addr $I10, rxcap_627_fail
    ($I12, $I11) = rx619_cur."!mark_peek"($I10)
    rx619_cur."!cursor_pos"($I11)
    ($P10) = rx619_cur."!cursor_start"()
    $P10."!cursor_pass"(rx619_pos, "")
    rx619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_627_done
  rxcap_627_fail:
    goto rx619_fail
  rxcap_627_done:
  # rx subrule "package_def" subtype=capture negate=
    rx619_cur."!cursor_pos"(rx619_pos)
    $P10 = rx619_cur."package_def"()
    unless $P10, rx619_fail
    rx619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx619_pos = $P10."pos"()
.annotate 'line', 302
  # rx pass
    rx619_cur."!cursor_pass"(rx619_pos, "package_declarator:sym<native>")
    if_null rx619_debug, debug_679
    rx619_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx619_pos)
  debug_679:
    .return (rx619_cur)
  rx619_restart:
.annotate 'line', 4
    if_null rx619_debug, debug_680
    rx619_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_680:
  rx619_fail:
    (rx619_rep, rx619_pos, $I10, $P10) = rx619_cur."!mark_fail"(0)
    lt rx619_pos, -1, rx619_done
    eq rx619_pos, -1, rx619_fail
    jump $I10
  rx619_done:
    rx619_cur."!cursor_fail"()
    if_null rx619_debug, debug_681
    rx619_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_681:
    .return (rx619_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("144_1296306519.49046") :method
.annotate 'line', 4
    $P621 = self."!PREFIX__!subrule"("package_def", "native")
    new $P622, "ResizablePMCArray"
    push $P622, $P621
    .return ($P622)
.end


.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("145_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx629_tgt
    .local int rx629_pos
    .local int rx629_off
    .local int rx629_eos
    .local int rx629_rep
    .local pmc rx629_cur
    .local pmc rx629_debug
    (rx629_cur, rx629_pos, rx629_tgt, $I10) = self."!cursor_start"()
    rx629_cur."!cursor_caparray"("repr", "parent")
    .lex unicode:"$\x{a2}", rx629_cur
    .local pmc match
    .lex "$/", match
    length rx629_eos, rx629_tgt
    gt rx629_pos, rx629_eos, rx629_done
    set rx629_off, 0
    lt rx629_pos, 2, rx629_start
    sub rx629_off, rx629_pos, 1
    substr rx629_tgt, rx629_tgt, rx629_off
  rx629_start:
    eq $I10, 1, rx629_restart
    if_null rx629_debug, debug_682
    rx629_cur."!cursor_debug"("START", "package_def")
  debug_682:
    $I10 = self.'from'()
    ne $I10, -1, rxscan633_done
    goto rxscan633_scan
  rxscan633_loop:
    (rx629_pos) = rx629_cur."from"()
    inc rx629_pos
    rx629_cur."!cursor_from"(rx629_pos)
    ge rx629_pos, rx629_eos, rxscan633_done
  rxscan633_scan:
    set_addr $I10, rxscan633_loop
    rx629_cur."!mark_push"(0, rx629_pos, $I10)
  rxscan633_done:
.annotate 'line', 308
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
.annotate 'line', 309
  # rx subrule "name" subtype=capture negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."name"()
    unless $P10, rx629_fail
    rx629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx629_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
.annotate 'line', 310
  # rx rxquantr636 ** 0..1
    set_addr $I10, rxquantr636_done
    rx629_cur."!mark_push"(0, rx629_pos, $I10)
  rxquantr636_loop:
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx629_pos, 2
    gt $I11, rx629_eos, rx629_fail
    sub $I11, rx629_pos, rx629_off
    substr $S10, rx629_tgt, $I11, 2
    ne $S10, "is", rx629_fail
    add rx629_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx629_pos, 5
    gt $I11, rx629_eos, rx629_fail
    sub $I11, rx629_pos, rx629_off
    substr $S10, rx629_tgt, $I11, 5
    ne $S10, "repr(", rx629_fail
    add rx629_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."quote_EXPR"()
    unless $P10, rx629_fail
    rx629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx629_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx629_pos, 1
    gt $I11, rx629_eos, rx629_fail
    sub $I11, rx629_pos, rx629_off
    ord $I11, rx629_tgt, $I11
    ne $I11, 41, rx629_fail
    add rx629_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
    set_addr $I10, rxquantr636_done
    (rx629_rep) = rx629_cur."!mark_commit"($I10)
  rxquantr636_done:
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
.annotate 'line', 311
  # rx rxquantr643 ** 0..1
    set_addr $I10, rxquantr643_done
    rx629_cur."!mark_push"(0, rx629_pos, $I10)
  rxquantr643_loop:
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx629_pos, 2
    gt $I11, rx629_eos, rx629_fail
    sub $I11, rx629_pos, rx629_off
    substr $S10, rx629_tgt, $I11, 2
    ne $S10, "is", rx629_fail
    add rx629_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."name"()
    unless $P10, rx629_fail
    rx629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx629_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
    set_addr $I10, rxquantr643_done
    (rx629_rep) = rx629_cur."!mark_commit"($I10)
  rxquantr643_done:
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  alt648_0:
.annotate 'line', 312
    set_addr $I10, alt648_1
    rx629_cur."!mark_push"(0, rx629_pos, $I10)
.annotate 'line', 313
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx629_pos, 1
    gt $I11, rx629_eos, rx629_fail
    sub $I11, rx629_pos, rx629_off
    ord $I11, rx629_tgt, $I11
    ne $I11, 59, rx629_fail
    add rx629_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."comp_unit"()
    unless $P10, rx629_fail
    rx629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx629_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
    goto alt648_end
  alt648_1:
    set_addr $I10, alt648_2
    rx629_cur."!mark_push"(0, rx629_pos, $I10)
.annotate 'line', 314
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx629_pos, rx629_off
    substr $S10, rx629_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx629_fail
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."block"()
    unless $P10, rx629_fail
    rx629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx629_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
    goto alt648_end
  alt648_2:
.annotate 'line', 315
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."panic"("Malformed package declaration")
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
  alt648_end:
.annotate 'line', 316
  # rx subrule "ws" subtype=method negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."ws"()
    unless $P10, rx629_fail
    rx629_pos = $P10."pos"()
.annotate 'line', 308
  # rx pass
    rx629_cur."!cursor_pass"(rx629_pos, "package_def")
    if_null rx629_debug, debug_683
    rx629_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx629_pos)
  debug_683:
    .return (rx629_cur)
  rx629_restart:
.annotate 'line', 4
    if_null rx629_debug, debug_684
    rx629_cur."!cursor_debug"("NEXT", "package_def")
  debug_684:
  rx629_fail:
    (rx629_rep, rx629_pos, $I10, $P10) = rx629_cur."!mark_fail"(0)
    lt rx629_pos, -1, rx629_done
    eq rx629_pos, -1, rx629_fail
    jump $I10
  rx629_done:
    rx629_cur."!cursor_fail"()
    if_null rx629_debug, debug_685
    rx629_cur."!cursor_debug"("FAIL", "package_def")
  debug_685:
    .return (rx629_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("146_1296306519.49046") :method
.annotate 'line', 4
    $P631 = self."!PREFIX__!subrule"("ws", "")
    new $P632, "ResizablePMCArray"
    push $P632, $P631
    .return ($P632)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("147_1296306519.49046")
    .param pmc param_659
.annotate 'line', 319
    .lex "self", param_659
    $P660 = param_659."!protoregex"("scope_declarator")
    .return ($P660)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("148_1296306519.49046")
    .param pmc param_662
.annotate 'line', 319
    .lex "self", param_662
    $P663 = param_662."!PREFIX__!protoregex"("scope_declarator")
    .return ($P663)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("149_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx665_tgt
    .local int rx665_pos
    .local int rx665_off
    .local int rx665_eos
    .local int rx665_rep
    .local pmc rx665_cur
    .local pmc rx665_debug
    (rx665_cur, rx665_pos, rx665_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx665_cur
    .local pmc match
    .lex "$/", match
    length rx665_eos, rx665_tgt
    gt rx665_pos, rx665_eos, rx665_done
    set rx665_off, 0
    lt rx665_pos, 2, rx665_start
    sub rx665_off, rx665_pos, 1
    substr rx665_tgt, rx665_tgt, rx665_off
  rx665_start:
    eq $I10, 1, rx665_restart
    if_null rx665_debug, debug_686
    rx665_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan669_done
    goto rxscan669_scan
  rxscan669_loop:
    (rx665_pos) = rx665_cur."from"()
    inc rx665_pos
    rx665_cur."!cursor_from"(rx665_pos)
    ge rx665_pos, rx665_eos, rxscan669_done
  rxscan669_scan:
    set_addr $I10, rxscan669_loop
    rx665_cur."!mark_push"(0, rx665_pos, $I10)
  rxscan669_done:
.annotate 'line', 320
  # rx subcapture "sym"
    set_addr $I10, rxcap_670_fail
    rx665_cur."!mark_push"(0, rx665_pos, $I10)
  # rx literal  "my"
    add $I11, rx665_pos, 2
    gt $I11, rx665_eos, rx665_fail
    sub $I11, rx665_pos, rx665_off
    substr $S10, rx665_tgt, $I11, 2
    ne $S10, "my", rx665_fail
    add rx665_pos, 2
    set_addr $I10, rxcap_670_fail
    ($I12, $I11) = rx665_cur."!mark_peek"($I10)
    rx665_cur."!cursor_pos"($I11)
    ($P10) = rx665_cur."!cursor_start"()
    $P10."!cursor_pass"(rx665_pos, "")
    rx665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_670_done
  rxcap_670_fail:
    goto rx665_fail
  rxcap_670_done:
  # rx subrule "scoped" subtype=capture negate=
    rx665_cur."!cursor_pos"(rx665_pos)
    $P10 = rx665_cur."scoped"("my")
    unless $P10, rx665_fail
    rx665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx665_pos = $P10."pos"()
  # rx pass
    rx665_cur."!cursor_pass"(rx665_pos, "scope_declarator:sym<my>")
    if_null rx665_debug, debug_687
    rx665_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx665_pos)
  debug_687:
    .return (rx665_cur)
  rx665_restart:
.annotate 'line', 4
    if_null rx665_debug, debug_688
    rx665_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_688:
  rx665_fail:
    (rx665_rep, rx665_pos, $I10, $P10) = rx665_cur."!mark_fail"(0)
    lt rx665_pos, -1, rx665_done
    eq rx665_pos, -1, rx665_fail
    jump $I10
  rx665_done:
    rx665_cur."!cursor_fail"()
    if_null rx665_debug, debug_689
    rx665_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_689:
    .return (rx665_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("150_1296306519.49046") :method
.annotate 'line', 4
    $P667 = self."!PREFIX__!subrule"("scoped", "my")
    new $P668, "ResizablePMCArray"
    push $P668, $P667
    .return ($P668)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("151_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx672_tgt
    .local int rx672_pos
    .local int rx672_off
    .local int rx672_eos
    .local int rx672_rep
    .local pmc rx672_cur
    .local pmc rx672_debug
    (rx672_cur, rx672_pos, rx672_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx672_cur
    .local pmc match
    .lex "$/", match
    length rx672_eos, rx672_tgt
    gt rx672_pos, rx672_eos, rx672_done
    set rx672_off, 0
    lt rx672_pos, 2, rx672_start
    sub rx672_off, rx672_pos, 1
    substr rx672_tgt, rx672_tgt, rx672_off
  rx672_start:
    eq $I10, 1, rx672_restart
    if_null rx672_debug, debug_690
    rx672_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan676_done
    goto rxscan676_scan
  rxscan676_loop:
    (rx672_pos) = rx672_cur."from"()
    inc rx672_pos
    rx672_cur."!cursor_from"(rx672_pos)
    ge rx672_pos, rx672_eos, rxscan676_done
  rxscan676_scan:
    set_addr $I10, rxscan676_loop
    rx672_cur."!mark_push"(0, rx672_pos, $I10)
  rxscan676_done:
.annotate 'line', 321
  # rx subcapture "sym"
    set_addr $I10, rxcap_677_fail
    rx672_cur."!mark_push"(0, rx672_pos, $I10)
  # rx literal  "our"
    add $I11, rx672_pos, 3
    gt $I11, rx672_eos, rx672_fail
    sub $I11, rx672_pos, rx672_off
    substr $S10, rx672_tgt, $I11, 3
    ne $S10, "our", rx672_fail
    add rx672_pos, 3
    set_addr $I10, rxcap_677_fail
    ($I12, $I11) = rx672_cur."!mark_peek"($I10)
    rx672_cur."!cursor_pos"($I11)
    ($P10) = rx672_cur."!cursor_start"()
    $P10."!cursor_pass"(rx672_pos, "")
    rx672_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_677_done
  rxcap_677_fail:
    goto rx672_fail
  rxcap_677_done:
  # rx subrule "scoped" subtype=capture negate=
    rx672_cur."!cursor_pos"(rx672_pos)
    $P10 = rx672_cur."scoped"("our")
    unless $P10, rx672_fail
    rx672_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx672_pos = $P10."pos"()
  # rx pass
    rx672_cur."!cursor_pass"(rx672_pos, "scope_declarator:sym<our>")
    if_null rx672_debug, debug_691
    rx672_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx672_pos)
  debug_691:
    .return (rx672_cur)
  rx672_restart:
.annotate 'line', 4
    if_null rx672_debug, debug_692
    rx672_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_692:
  rx672_fail:
    (rx672_rep, rx672_pos, $I10, $P10) = rx672_cur."!mark_fail"(0)
    lt rx672_pos, -1, rx672_done
    eq rx672_pos, -1, rx672_fail
    jump $I10
  rx672_done:
    rx672_cur."!cursor_fail"()
    if_null rx672_debug, debug_693
    rx672_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_693:
    .return (rx672_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("152_1296306519.49046") :method
.annotate 'line', 4
    $P674 = self."!PREFIX__!subrule"("scoped", "our")
    new $P675, "ResizablePMCArray"
    push $P675, $P674
    .return ($P675)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("153_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx679_tgt
    .local int rx679_pos
    .local int rx679_off
    .local int rx679_eos
    .local int rx679_rep
    .local pmc rx679_cur
    .local pmc rx679_debug
    (rx679_cur, rx679_pos, rx679_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx679_cur
    .local pmc match
    .lex "$/", match
    length rx679_eos, rx679_tgt
    gt rx679_pos, rx679_eos, rx679_done
    set rx679_off, 0
    lt rx679_pos, 2, rx679_start
    sub rx679_off, rx679_pos, 1
    substr rx679_tgt, rx679_tgt, rx679_off
  rx679_start:
    eq $I10, 1, rx679_restart
    if_null rx679_debug, debug_694
    rx679_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_694:
    $I10 = self.'from'()
    ne $I10, -1, rxscan683_done
    goto rxscan683_scan
  rxscan683_loop:
    (rx679_pos) = rx679_cur."from"()
    inc rx679_pos
    rx679_cur."!cursor_from"(rx679_pos)
    ge rx679_pos, rx679_eos, rxscan683_done
  rxscan683_scan:
    set_addr $I10, rxscan683_loop
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxscan683_done:
.annotate 'line', 322
  # rx subcapture "sym"
    set_addr $I10, rxcap_684_fail
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  # rx literal  "has"
    add $I11, rx679_pos, 3
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 3
    ne $S10, "has", rx679_fail
    add rx679_pos, 3
    set_addr $I10, rxcap_684_fail
    ($I12, $I11) = rx679_cur."!mark_peek"($I10)
    rx679_cur."!cursor_pos"($I11)
    ($P10) = rx679_cur."!cursor_start"()
    $P10."!cursor_pass"(rx679_pos, "")
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_684_done
  rxcap_684_fail:
    goto rx679_fail
  rxcap_684_done:
  # rx subrule "scoped" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."scoped"("has")
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx679_pos = $P10."pos"()
  # rx pass
    rx679_cur."!cursor_pass"(rx679_pos, "scope_declarator:sym<has>")
    if_null rx679_debug, debug_695
    rx679_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx679_pos)
  debug_695:
    .return (rx679_cur)
  rx679_restart:
.annotate 'line', 4
    if_null rx679_debug, debug_696
    rx679_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_696:
  rx679_fail:
    (rx679_rep, rx679_pos, $I10, $P10) = rx679_cur."!mark_fail"(0)
    lt rx679_pos, -1, rx679_done
    eq rx679_pos, -1, rx679_fail
    jump $I10
  rx679_done:
    rx679_cur."!cursor_fail"()
    if_null rx679_debug, debug_697
    rx679_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_697:
    .return (rx679_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("154_1296306519.49046") :method
.annotate 'line', 4
    $P681 = self."!PREFIX__!subrule"("scoped", "has")
    new $P682, "ResizablePMCArray"
    push $P682, $P681
    .return ($P682)
.end


.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("155_1296306519.49046") :method :outer("11_1296306519.49046")
    .param pmc param_686
.annotate 'line', 324
    .lex "$*SCOPE", param_686
.annotate 'line', 4
    .local string rx687_tgt
    .local int rx687_pos
    .local int rx687_off
    .local int rx687_eos
    .local int rx687_rep
    .local pmc rx687_cur
    .local pmc rx687_debug
    (rx687_cur, rx687_pos, rx687_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx687_cur
    .local pmc match
    .lex "$/", match
    length rx687_eos, rx687_tgt
    gt rx687_pos, rx687_eos, rx687_done
    set rx687_off, 0
    lt rx687_pos, 2, rx687_start
    sub rx687_off, rx687_pos, 1
    substr rx687_tgt, rx687_tgt, rx687_off
  rx687_start:
    eq $I10, 1, rx687_restart
    if_null rx687_debug, debug_698
    rx687_cur."!cursor_debug"("START", "scoped")
  debug_698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan692_done
    goto rxscan692_scan
  rxscan692_loop:
    (rx687_pos) = rx687_cur."from"()
    inc rx687_pos
    rx687_cur."!cursor_from"(rx687_pos)
    ge rx687_pos, rx687_eos, rxscan692_done
  rxscan692_scan:
    set_addr $I10, rxscan692_loop
    rx687_cur."!mark_push"(0, rx687_pos, $I10)
  rxscan692_done:
  alt693_0:
.annotate 'line', 324
    set_addr $I10, alt693_1
    rx687_cur."!mark_push"(0, rx687_pos, $I10)
.annotate 'line', 325
  # rx subrule "ws" subtype=method negate=
    rx687_cur."!cursor_pos"(rx687_pos)
    $P10 = rx687_cur."ws"()
    unless $P10, rx687_fail
    rx687_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx687_cur."!cursor_pos"(rx687_pos)
    $P10 = rx687_cur."declarator"()
    unless $P10, rx687_fail
    rx687_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx687_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx687_cur."!cursor_pos"(rx687_pos)
    $P10 = rx687_cur."ws"()
    unless $P10, rx687_fail
    rx687_pos = $P10."pos"()
    goto alt693_end
  alt693_1:
.annotate 'line', 326
  # rx subrule "ws" subtype=method negate=
    rx687_cur."!cursor_pos"(rx687_pos)
    $P10 = rx687_cur."ws"()
    unless $P10, rx687_fail
    rx687_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx687_cur."!cursor_pos"(rx687_pos)
    $P10 = rx687_cur."multi_declarator"()
    unless $P10, rx687_fail
    rx687_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx687_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx687_cur."!cursor_pos"(rx687_pos)
    $P10 = rx687_cur."ws"()
    unless $P10, rx687_fail
    rx687_pos = $P10."pos"()
  alt693_end:
.annotate 'line', 324
  # rx pass
    rx687_cur."!cursor_pass"(rx687_pos, "scoped")
    if_null rx687_debug, debug_699
    rx687_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx687_pos)
  debug_699:
    .return (rx687_cur)
  rx687_restart:
.annotate 'line', 4
    if_null rx687_debug, debug_700
    rx687_cur."!cursor_debug"("NEXT", "scoped")
  debug_700:
  rx687_fail:
    (rx687_rep, rx687_pos, $I10, $P10) = rx687_cur."!mark_fail"(0)
    lt rx687_pos, -1, rx687_done
    eq rx687_pos, -1, rx687_fail
    jump $I10
  rx687_done:
    rx687_cur."!cursor_fail"()
    if_null rx687_debug, debug_701
    rx687_cur."!cursor_debug"("FAIL", "scoped")
  debug_701:
    .return (rx687_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("156_1296306519.49046") :method
.annotate 'line', 4
    $P689 = self."!PREFIX__!subrule"("ws", "")
    $P690 = self."!PREFIX__!subrule"("ws", "")
    new $P691, "ResizablePMCArray"
    push $P691, $P689
    push $P691, $P690
    .return ($P691)
.end


.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("157_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx699_tgt
    .local int rx699_pos
    .local int rx699_off
    .local int rx699_eos
    .local int rx699_rep
    .local pmc rx699_cur
    .local pmc rx699_debug
    (rx699_cur, rx699_pos, rx699_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx699_cur
    .local pmc match
    .lex "$/", match
    length rx699_eos, rx699_tgt
    gt rx699_pos, rx699_eos, rx699_done
    set rx699_off, 0
    lt rx699_pos, 2, rx699_start
    sub rx699_off, rx699_pos, 1
    substr rx699_tgt, rx699_tgt, rx699_off
  rx699_start:
    eq $I10, 1, rx699_restart
    if_null rx699_debug, debug_702
    rx699_cur."!cursor_debug"("START", "typename")
  debug_702:
    $I10 = self.'from'()
    ne $I10, -1, rxscan703_done
    goto rxscan703_scan
  rxscan703_loop:
    (rx699_pos) = rx699_cur."from"()
    inc rx699_pos
    rx699_cur."!cursor_from"(rx699_pos)
    ge rx699_pos, rx699_eos, rxscan703_done
  rxscan703_scan:
    set_addr $I10, rxscan703_loop
    rx699_cur."!mark_push"(0, rx699_pos, $I10)
  rxscan703_done:
.annotate 'line', 329
  # rx subrule "name" subtype=capture negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."name"()
    unless $P10, rx699_fail
    rx699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx699_pos = $P10."pos"()
  # rx pass
    rx699_cur."!cursor_pass"(rx699_pos, "typename")
    if_null rx699_debug, debug_703
    rx699_cur."!cursor_debug"("PASS", "typename", " at pos=", rx699_pos)
  debug_703:
    .return (rx699_cur)
  rx699_restart:
.annotate 'line', 4
    if_null rx699_debug, debug_704
    rx699_cur."!cursor_debug"("NEXT", "typename")
  debug_704:
  rx699_fail:
    (rx699_rep, rx699_pos, $I10, $P10) = rx699_cur."!mark_fail"(0)
    lt rx699_pos, -1, rx699_done
    eq rx699_pos, -1, rx699_fail
    jump $I10
  rx699_done:
    rx699_cur."!cursor_fail"()
    if_null rx699_debug, debug_705
    rx699_cur."!cursor_debug"("FAIL", "typename")
  debug_705:
    .return (rx699_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("158_1296306519.49046") :method
.annotate 'line', 4
    $P701 = self."!PREFIX__!subrule"("name", "")
    new $P702, "ResizablePMCArray"
    push $P702, $P701
    .return ($P702)
.end


.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("159_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx705_tgt
    .local int rx705_pos
    .local int rx705_off
    .local int rx705_eos
    .local int rx705_rep
    .local pmc rx705_cur
    .local pmc rx705_debug
    (rx705_cur, rx705_pos, rx705_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx705_cur
    .local pmc match
    .lex "$/", match
    length rx705_eos, rx705_tgt
    gt rx705_pos, rx705_eos, rx705_done
    set rx705_off, 0
    lt rx705_pos, 2, rx705_start
    sub rx705_off, rx705_pos, 1
    substr rx705_tgt, rx705_tgt, rx705_off
  rx705_start:
    eq $I10, 1, rx705_restart
    if_null rx705_debug, debug_706
    rx705_cur."!cursor_debug"("START", "declarator")
  debug_706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan710_done
    goto rxscan710_scan
  rxscan710_loop:
    (rx705_pos) = rx705_cur."from"()
    inc rx705_pos
    rx705_cur."!cursor_from"(rx705_pos)
    ge rx705_pos, rx705_eos, rxscan710_done
  rxscan710_scan:
    set_addr $I10, rxscan710_loop
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  rxscan710_done:
  alt711_0:
.annotate 'line', 331
    set_addr $I10, alt711_1
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
.annotate 'line', 332
  # rx subrule "variable_declarator" subtype=capture negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."variable_declarator"()
    unless $P10, rx705_fail
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx705_pos = $P10."pos"()
    goto alt711_end
  alt711_1:
.annotate 'line', 333
  # rx subrule "routine_declarator" subtype=capture negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."routine_declarator"()
    unless $P10, rx705_fail
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx705_pos = $P10."pos"()
  alt711_end:
.annotate 'line', 331
  # rx pass
    rx705_cur."!cursor_pass"(rx705_pos, "declarator")
    if_null rx705_debug, debug_707
    rx705_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx705_pos)
  debug_707:
    .return (rx705_cur)
  rx705_restart:
.annotate 'line', 4
    if_null rx705_debug, debug_708
    rx705_cur."!cursor_debug"("NEXT", "declarator")
  debug_708:
  rx705_fail:
    (rx705_rep, rx705_pos, $I10, $P10) = rx705_cur."!mark_fail"(0)
    lt rx705_pos, -1, rx705_done
    eq rx705_pos, -1, rx705_fail
    jump $I10
  rx705_done:
    rx705_cur."!cursor_fail"()
    if_null rx705_debug, debug_709
    rx705_cur."!cursor_debug"("FAIL", "declarator")
  debug_709:
    .return (rx705_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("160_1296306519.49046") :method
.annotate 'line', 4
    $P707 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P708 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P709, "ResizablePMCArray"
    push $P709, $P707
    push $P709, $P708
    .return ($P709)
.end


.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("161_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx713_tgt
    .local int rx713_pos
    .local int rx713_off
    .local int rx713_eos
    .local int rx713_rep
    .local pmc rx713_cur
    .local pmc rx713_debug
    (rx713_cur, rx713_pos, rx713_tgt, $I10) = self."!cursor_start"()
    rx713_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx713_cur
    .local pmc match
    .lex "$/", match
    length rx713_eos, rx713_tgt
    gt rx713_pos, rx713_eos, rx713_done
    set rx713_off, 0
    lt rx713_pos, 2, rx713_start
    sub rx713_off, rx713_pos, 1
    substr rx713_tgt, rx713_tgt, rx713_off
  rx713_start:
    eq $I10, 1, rx713_restart
    if_null rx713_debug, debug_710
    rx713_cur."!cursor_debug"("START", "variable_declarator")
  debug_710:
    $I10 = self.'from'()
    ne $I10, -1, rxscan717_done
    goto rxscan717_scan
  rxscan717_loop:
    (rx713_pos) = rx713_cur."from"()
    inc rx713_pos
    rx713_cur."!cursor_from"(rx713_pos)
    ge rx713_pos, rx713_eos, rxscan717_done
  rxscan717_scan:
    set_addr $I10, rxscan717_loop
    rx713_cur."!mark_push"(0, rx713_pos, $I10)
  rxscan717_done:
.annotate 'line', 336
  # rx subrule "ws" subtype=method negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."ws"()
    unless $P10, rx713_fail
    rx713_pos = $P10."pos"()
  # rx rxquantr719 ** 0..1
    set_addr $I10, rxquantr719_done
    rx713_cur."!mark_push"(0, rx713_pos, $I10)
  rxquantr719_loop:
  # rx subrule "typename" subtype=capture negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."typename"()
    unless $P10, rx713_fail
    goto rxsubrule720_pass
  rxsubrule720_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx713_fail
  rxsubrule720_pass:
    set_addr $I10, rxsubrule720_back
    rx713_cur."!mark_push"(0, rx713_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx713_pos = $P10."pos"()
    set_addr $I10, rxquantr719_done
    (rx713_rep) = rx713_cur."!mark_commit"($I10)
  rxquantr719_done:
  # rx subrule "ws" subtype=method negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."ws"()
    unless $P10, rx713_fail
    rx713_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."variable"()
    unless $P10, rx713_fail
    rx713_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx713_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx713_cur."!cursor_pos"(rx713_pos)
    $P10 = rx713_cur."ws"()
    unless $P10, rx713_fail
    rx713_pos = $P10."pos"()
  # rx pass
    rx713_cur."!cursor_pass"(rx713_pos, "variable_declarator")
    if_null rx713_debug, debug_711
    rx713_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx713_pos)
  debug_711:
    .return (rx713_cur)
  rx713_restart:
.annotate 'line', 4
    if_null rx713_debug, debug_712
    rx713_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_712:
  rx713_fail:
    (rx713_rep, rx713_pos, $I10, $P10) = rx713_cur."!mark_fail"(0)
    lt rx713_pos, -1, rx713_done
    eq rx713_pos, -1, rx713_fail
    jump $I10
  rx713_done:
    rx713_cur."!cursor_fail"()
    if_null rx713_debug, debug_713
    rx713_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_713:
    .return (rx713_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("162_1296306519.49046") :method
.annotate 'line', 4
    $P715 = self."!PREFIX__!subrule"("ws", "")
    new $P716, "ResizablePMCArray"
    push $P716, $P715
    .return ($P716)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("163_1296306519.49046")
    .param pmc param_724
.annotate 'line', 338
    .lex "self", param_724
    $P725 = param_724."!protoregex"("routine_declarator")
    .return ($P725)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("164_1296306519.49046")
    .param pmc param_727
.annotate 'line', 338
    .lex "self", param_727
    $P728 = param_727."!PREFIX__!protoregex"("routine_declarator")
    .return ($P728)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("165_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx730_tgt
    .local int rx730_pos
    .local int rx730_off
    .local int rx730_eos
    .local int rx730_rep
    .local pmc rx730_cur
    .local pmc rx730_debug
    (rx730_cur, rx730_pos, rx730_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx730_cur
    .local pmc match
    .lex "$/", match
    length rx730_eos, rx730_tgt
    gt rx730_pos, rx730_eos, rx730_done
    set rx730_off, 0
    lt rx730_pos, 2, rx730_start
    sub rx730_off, rx730_pos, 1
    substr rx730_tgt, rx730_tgt, rx730_off
  rx730_start:
    eq $I10, 1, rx730_restart
    if_null rx730_debug, debug_714
    rx730_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_714:
    $I10 = self.'from'()
    ne $I10, -1, rxscan734_done
    goto rxscan734_scan
  rxscan734_loop:
    (rx730_pos) = rx730_cur."from"()
    inc rx730_pos
    rx730_cur."!cursor_from"(rx730_pos)
    ge rx730_pos, rx730_eos, rxscan734_done
  rxscan734_scan:
    set_addr $I10, rxscan734_loop
    rx730_cur."!mark_push"(0, rx730_pos, $I10)
  rxscan734_done:
.annotate 'line', 339
  # rx subcapture "sym"
    set_addr $I10, rxcap_735_fail
    rx730_cur."!mark_push"(0, rx730_pos, $I10)
  # rx literal  "sub"
    add $I11, rx730_pos, 3
    gt $I11, rx730_eos, rx730_fail
    sub $I11, rx730_pos, rx730_off
    substr $S10, rx730_tgt, $I11, 3
    ne $S10, "sub", rx730_fail
    add rx730_pos, 3
    set_addr $I10, rxcap_735_fail
    ($I12, $I11) = rx730_cur."!mark_peek"($I10)
    rx730_cur."!cursor_pos"($I11)
    ($P10) = rx730_cur."!cursor_start"()
    $P10."!cursor_pass"(rx730_pos, "")
    rx730_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_735_done
  rxcap_735_fail:
    goto rx730_fail
  rxcap_735_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx730_cur."!cursor_pos"(rx730_pos)
    $P10 = rx730_cur."routine_def"()
    unless $P10, rx730_fail
    rx730_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx730_pos = $P10."pos"()
  # rx pass
    rx730_cur."!cursor_pass"(rx730_pos, "routine_declarator:sym<sub>")
    if_null rx730_debug, debug_715
    rx730_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx730_pos)
  debug_715:
    .return (rx730_cur)
  rx730_restart:
.annotate 'line', 4
    if_null rx730_debug, debug_716
    rx730_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_716:
  rx730_fail:
    (rx730_rep, rx730_pos, $I10, $P10) = rx730_cur."!mark_fail"(0)
    lt rx730_pos, -1, rx730_done
    eq rx730_pos, -1, rx730_fail
    jump $I10
  rx730_done:
    rx730_cur."!cursor_fail"()
    if_null rx730_debug, debug_717
    rx730_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_717:
    .return (rx730_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("166_1296306519.49046") :method
.annotate 'line', 4
    $P732 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P733, "ResizablePMCArray"
    push $P733, $P732
    .return ($P733)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("167_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx737_tgt
    .local int rx737_pos
    .local int rx737_off
    .local int rx737_eos
    .local int rx737_rep
    .local pmc rx737_cur
    .local pmc rx737_debug
    (rx737_cur, rx737_pos, rx737_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx737_cur
    .local pmc match
    .lex "$/", match
    length rx737_eos, rx737_tgt
    gt rx737_pos, rx737_eos, rx737_done
    set rx737_off, 0
    lt rx737_pos, 2, rx737_start
    sub rx737_off, rx737_pos, 1
    substr rx737_tgt, rx737_tgt, rx737_off
  rx737_start:
    eq $I10, 1, rx737_restart
    if_null rx737_debug, debug_718
    rx737_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_718:
    $I10 = self.'from'()
    ne $I10, -1, rxscan741_done
    goto rxscan741_scan
  rxscan741_loop:
    (rx737_pos) = rx737_cur."from"()
    inc rx737_pos
    rx737_cur."!cursor_from"(rx737_pos)
    ge rx737_pos, rx737_eos, rxscan741_done
  rxscan741_scan:
    set_addr $I10, rxscan741_loop
    rx737_cur."!mark_push"(0, rx737_pos, $I10)
  rxscan741_done:
.annotate 'line', 340
  # rx subcapture "sym"
    set_addr $I10, rxcap_742_fail
    rx737_cur."!mark_push"(0, rx737_pos, $I10)
  # rx literal  "method"
    add $I11, rx737_pos, 6
    gt $I11, rx737_eos, rx737_fail
    sub $I11, rx737_pos, rx737_off
    substr $S10, rx737_tgt, $I11, 6
    ne $S10, "method", rx737_fail
    add rx737_pos, 6
    set_addr $I10, rxcap_742_fail
    ($I12, $I11) = rx737_cur."!mark_peek"($I10)
    rx737_cur."!cursor_pos"($I11)
    ($P10) = rx737_cur."!cursor_start"()
    $P10."!cursor_pass"(rx737_pos, "")
    rx737_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_742_done
  rxcap_742_fail:
    goto rx737_fail
  rxcap_742_done:
  # rx subrule "method_def" subtype=capture negate=
    rx737_cur."!cursor_pos"(rx737_pos)
    $P10 = rx737_cur."method_def"()
    unless $P10, rx737_fail
    rx737_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx737_pos = $P10."pos"()
  # rx pass
    rx737_cur."!cursor_pass"(rx737_pos, "routine_declarator:sym<method>")
    if_null rx737_debug, debug_719
    rx737_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx737_pos)
  debug_719:
    .return (rx737_cur)
  rx737_restart:
.annotate 'line', 4
    if_null rx737_debug, debug_720
    rx737_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_720:
  rx737_fail:
    (rx737_rep, rx737_pos, $I10, $P10) = rx737_cur."!mark_fail"(0)
    lt rx737_pos, -1, rx737_done
    eq rx737_pos, -1, rx737_fail
    jump $I10
  rx737_done:
    rx737_cur."!cursor_fail"()
    if_null rx737_debug, debug_721
    rx737_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_721:
    .return (rx737_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("168_1296306519.49046") :method
.annotate 'line', 4
    $P739 = self."!PREFIX__!subrule"("method_def", "method")
    new $P740, "ResizablePMCArray"
    push $P740, $P739
    .return ($P740)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("169_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 343
    new $P744, "Undef"
    .lex "$*RETURN_USED", $P744
.annotate 'line', 4
    .local string rx745_tgt
    .local int rx745_pos
    .local int rx745_off
    .local int rx745_eos
    .local int rx745_rep
    .local pmc rx745_cur
    .local pmc rx745_debug
    (rx745_cur, rx745_pos, rx745_tgt, $I10) = self."!cursor_start"()
    rx745_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx745_cur
    .local pmc match
    .lex "$/", match
    length rx745_eos, rx745_tgt
    gt rx745_pos, rx745_eos, rx745_done
    set rx745_off, 0
    lt rx745_pos, 2, rx745_start
    sub rx745_off, rx745_pos, 1
    substr rx745_tgt, rx745_tgt, rx745_off
  rx745_start:
    eq $I10, 1, rx745_restart
    if_null rx745_debug, debug_722
    rx745_cur."!cursor_debug"("START", "routine_def")
  debug_722:
    $I10 = self.'from'()
    ne $I10, -1, rxscan749_done
    goto rxscan749_scan
  rxscan749_loop:
    (rx745_pos) = rx745_cur."from"()
    inc rx745_pos
    rx745_cur."!cursor_from"(rx745_pos)
    ge rx745_pos, rx745_eos, rxscan749_done
  rxscan749_scan:
    set_addr $I10, rxscan749_loop
    rx745_cur."!mark_push"(0, rx745_pos, $I10)
  rxscan749_done:
.annotate 'line', 342
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
.annotate 'line', 343
    rx745_cur."!cursor_pos"(rx745_pos)
    new $P751, "Integer"
    assign $P751, 0
    store_lex "$*RETURN_USED", $P751
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
.annotate 'line', 344
  # rx rxquantr753 ** 0..1
    set_addr $I10, rxquantr753_done
    rx745_cur."!mark_push"(0, rx745_pos, $I10)
  rxquantr753_loop:
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_756_fail
    rx745_cur."!mark_push"(0, rx745_pos, $I10)
  # rx rxquantr755 ** 0..1
    set_addr $I10, rxquantr755_done
    rx745_cur."!mark_push"(0, rx745_pos, $I10)
  rxquantr755_loop:
  # rx literal  "&"
    add $I11, rx745_pos, 1
    gt $I11, rx745_eos, rx745_fail
    sub $I11, rx745_pos, rx745_off
    ord $I11, rx745_tgt, $I11
    ne $I11, 38, rx745_fail
    add rx745_pos, 1
    set_addr $I10, rxquantr755_done
    (rx745_rep) = rx745_cur."!mark_commit"($I10)
  rxquantr755_done:
    set_addr $I10, rxcap_756_fail
    ($I12, $I11) = rx745_cur."!mark_peek"($I10)
    rx745_cur."!cursor_pos"($I11)
    ($P10) = rx745_cur."!cursor_start"()
    $P10."!cursor_pass"(rx745_pos, "")
    rx745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_756_done
  rxcap_756_fail:
    goto rx745_fail
  rxcap_756_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."deflongname"()
    unless $P10, rx745_fail
    rx745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx745_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
    set_addr $I10, rxquantr753_done
    (rx745_rep) = rx745_cur."!mark_commit"($I10)
  rxquantr753_done:
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
.annotate 'line', 345
  # rx subrule "newpad" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."newpad"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  alt760_0:
.annotate 'line', 346
    set_addr $I10, alt760_1
    rx745_cur."!mark_push"(0, rx745_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx745_pos, 1
    gt $I11, rx745_eos, rx745_fail
    sub $I11, rx745_pos, rx745_off
    ord $I11, rx745_tgt, $I11
    ne $I11, 40, rx745_fail
    add rx745_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."signature"()
    unless $P10, rx745_fail
    rx745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx745_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx745_pos, 1
    gt $I11, rx745_eos, rx745_fail
    sub $I11, rx745_pos, rx745_off
    ord $I11, rx745_tgt, $I11
    ne $I11, 41, rx745_fail
    add rx745_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
    goto alt760_end
  alt760_1:
.annotate 'line', 347
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  alt760_end:
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
.annotate 'line', 348
  # rx rxquantr768 ** 0..*
    set_addr $I10, rxquantr768_done
    rx745_cur."!mark_push"(0, rx745_pos, $I10)
  rxquantr768_loop:
  # rx subrule "trait" subtype=capture negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."trait"()
    unless $P10, rx745_fail
    goto rxsubrule769_pass
  rxsubrule769_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx745_fail
  rxsubrule769_pass:
    set_addr $I10, rxsubrule769_back
    rx745_cur."!mark_push"(0, rx745_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx745_pos = $P10."pos"()
    set_addr $I10, rxquantr768_done
    (rx745_rep) = rx745_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr768_done
    rx745_cur."!mark_push"(rx745_rep, rx745_pos, $I10)
    goto rxquantr768_loop
  rxquantr768_done:
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  alt771_0:
.annotate 'line', 349
    set_addr $I10, alt771_1
    rx745_cur."!mark_push"(0, rx745_pos, $I10)
.annotate 'line', 350
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."onlystar"()
    unless $P10, rx745_fail
    rx745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx745_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
    goto alt771_end
  alt771_1:
.annotate 'line', 351
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."blockoid"()
    unless $P10, rx745_fail
    rx745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx745_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
  alt771_end:
.annotate 'line', 352
  # rx subrule "ws" subtype=method negate=
    rx745_cur."!cursor_pos"(rx745_pos)
    $P10 = rx745_cur."ws"()
    unless $P10, rx745_fail
    rx745_pos = $P10."pos"()
.annotate 'line', 342
  # rx pass
    rx745_cur."!cursor_pass"(rx745_pos, "routine_def")
    if_null rx745_debug, debug_723
    rx745_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx745_pos)
  debug_723:
    .return (rx745_cur)
  rx745_restart:
.annotate 'line', 4
    if_null rx745_debug, debug_724
    rx745_cur."!cursor_debug"("NEXT", "routine_def")
  debug_724:
  rx745_fail:
    (rx745_rep, rx745_pos, $I10, $P10) = rx745_cur."!mark_fail"(0)
    lt rx745_pos, -1, rx745_done
    eq rx745_pos, -1, rx745_fail
    jump $I10
  rx745_done:
    rx745_cur."!cursor_fail"()
    if_null rx745_debug, debug_725
    rx745_cur."!cursor_debug"("FAIL", "routine_def")
  debug_725:
    .return (rx745_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("170_1296306519.49046") :method
.annotate 'line', 4
    $P747 = self."!PREFIX__!subrule"("ws", "")
    new $P748, "ResizablePMCArray"
    push $P748, $P747
    .return ($P748)
.end


.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("171_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P808 = "173_1296306519.49046" 
    capture_lex $P808
.annotate 'line', 356
    new $P778, "Undef"
    .lex "$*RETURN_USED", $P778
.annotate 'line', 357
    new $P779, "Undef"
    .lex "$*INVOCANT_OK", $P779
.annotate 'line', 4
    .local string rx780_tgt
    .local int rx780_pos
    .local int rx780_off
    .local int rx780_eos
    .local int rx780_rep
    .local pmc rx780_cur
    .local pmc rx780_debug
    (rx780_cur, rx780_pos, rx780_tgt, $I10) = self."!cursor_start"()
    rx780_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx780_cur
    .local pmc match
    .lex "$/", match
    length rx780_eos, rx780_tgt
    gt rx780_pos, rx780_eos, rx780_done
    set rx780_off, 0
    lt rx780_pos, 2, rx780_start
    sub rx780_off, rx780_pos, 1
    substr rx780_tgt, rx780_tgt, rx780_off
  rx780_start:
    eq $I10, 1, rx780_restart
    if_null rx780_debug, debug_726
    rx780_cur."!cursor_debug"("START", "method_def")
  debug_726:
    $I10 = self.'from'()
    ne $I10, -1, rxscan784_done
    goto rxscan784_scan
  rxscan784_loop:
    (rx780_pos) = rx780_cur."from"()
    inc rx780_pos
    rx780_cur."!cursor_from"(rx780_pos)
    ge rx780_pos, rx780_eos, rxscan784_done
  rxscan784_scan:
    set_addr $I10, rxscan784_loop
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  rxscan784_done:
.annotate 'line', 355
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
.annotate 'line', 356
    rx780_cur."!cursor_pos"(rx780_pos)
    new $P786, "Integer"
    assign $P786, 0
    store_lex "$*RETURN_USED", $P786
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
.annotate 'line', 357
    rx780_cur."!cursor_pos"(rx780_pos)
    new $P788, "Integer"
    assign $P788, 1
    store_lex "$*INVOCANT_OK", $P788
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
.annotate 'line', 358
  # rx subcapture "private"
    set_addr $I10, rxcap_791_fail
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  # rx rxquantr790 ** 0..1
    set_addr $I10, rxquantr790_done
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  rxquantr790_loop:
  # rx literal  "!"
    add $I11, rx780_pos, 1
    gt $I11, rx780_eos, rx780_fail
    sub $I11, rx780_pos, rx780_off
    ord $I11, rx780_tgt, $I11
    ne $I11, 33, rx780_fail
    add rx780_pos, 1
    set_addr $I10, rxquantr790_done
    (rx780_rep) = rx780_cur."!mark_commit"($I10)
  rxquantr790_done:
    set_addr $I10, rxcap_791_fail
    ($I12, $I11) = rx780_cur."!mark_peek"($I10)
    rx780_cur."!cursor_pos"($I11)
    ($P10) = rx780_cur."!cursor_start"()
    $P10."!cursor_pass"(rx780_pos, "")
    rx780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_791_done
  rxcap_791_fail:
    goto rx780_fail
  rxcap_791_done:
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
.annotate 'line', 359
  # rx rxquantr793 ** 0..1
    set_addr $I10, rxquantr793_done
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  rxquantr793_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."deflongname"()
    unless $P10, rx780_fail
    goto rxsubrule794_pass
  rxsubrule794_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx780_fail
  rxsubrule794_pass:
    set_addr $I10, rxsubrule794_back
    rx780_cur."!mark_push"(0, rx780_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx780_pos = $P10."pos"()
    set_addr $I10, rxquantr793_done
    (rx780_rep) = rx780_cur."!mark_commit"($I10)
  rxquantr793_done:
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
.annotate 'line', 360
  # rx subrule "newpad" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."newpad"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  alt797_0:
.annotate 'line', 361
    set_addr $I10, alt797_1
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx780_pos, 1
    gt $I11, rx780_eos, rx780_fail
    sub $I11, rx780_pos, rx780_off
    ord $I11, rx780_tgt, $I11
    ne $I11, 40, rx780_fail
    add rx780_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."signature"()
    unless $P10, rx780_fail
    rx780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx780_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx780_pos, 1
    gt $I11, rx780_eos, rx780_fail
    sub $I11, rx780_pos, rx780_off
    ord $I11, rx780_tgt, $I11
    ne $I11, 41, rx780_fail
    add rx780_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
    goto alt797_end
  alt797_1:
.annotate 'line', 362
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  alt797_end:
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
.annotate 'line', 363
    rx780_cur."!cursor_pos"(rx780_pos)
    find_lex $P805, unicode:"$\x{a2}"
    $P806 = $P805."MATCH"()
    store_lex "$/", $P806
    .const 'Sub' $P808 = "173_1296306519.49046" 
    capture_lex $P808
    $P810 = $P808()
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
.annotate 'line', 364
  # rx rxquantr812 ** 0..*
    set_addr $I10, rxquantr812_done
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
  rxquantr812_loop:
  # rx subrule "trait" subtype=capture negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."trait"()
    unless $P10, rx780_fail
    goto rxsubrule813_pass
  rxsubrule813_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx780_fail
  rxsubrule813_pass:
    set_addr $I10, rxsubrule813_back
    rx780_cur."!mark_push"(0, rx780_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx780_pos = $P10."pos"()
    set_addr $I10, rxquantr812_done
    (rx780_rep) = rx780_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr812_done
    rx780_cur."!mark_push"(rx780_rep, rx780_pos, $I10)
    goto rxquantr812_loop
  rxquantr812_done:
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  alt815_0:
.annotate 'line', 365
    set_addr $I10, alt815_1
    rx780_cur."!mark_push"(0, rx780_pos, $I10)
.annotate 'line', 366
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."onlystar"()
    unless $P10, rx780_fail
    rx780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx780_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
    goto alt815_end
  alt815_1:
.annotate 'line', 367
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."blockoid"()
    unless $P10, rx780_fail
    rx780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx780_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
  alt815_end:
.annotate 'line', 368
  # rx subrule "ws" subtype=method negate=
    rx780_cur."!cursor_pos"(rx780_pos)
    $P10 = rx780_cur."ws"()
    unless $P10, rx780_fail
    rx780_pos = $P10."pos"()
.annotate 'line', 355
  # rx pass
    rx780_cur."!cursor_pass"(rx780_pos, "method_def")
    if_null rx780_debug, debug_727
    rx780_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx780_pos)
  debug_727:
    .return (rx780_cur)
  rx780_restart:
.annotate 'line', 4
    if_null rx780_debug, debug_728
    rx780_cur."!cursor_debug"("NEXT", "method_def")
  debug_728:
  rx780_fail:
    (rx780_rep, rx780_pos, $I10, $P10) = rx780_cur."!mark_fail"(0)
    lt rx780_pos, -1, rx780_done
    eq rx780_pos, -1, rx780_fail
    jump $I10
  rx780_done:
    rx780_cur."!cursor_fail"()
    if_null rx780_debug, debug_729
    rx780_cur."!cursor_debug"("FAIL", "method_def")
  debug_729:
    .return (rx780_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("172_1296306519.49046") :method
.annotate 'line', 4
    $P782 = self."!PREFIX__!subrule"("ws", "")
    new $P783, "ResizablePMCArray"
    push $P783, $P782
    .return ($P783)
.end


.namespace ["NQP";"Grammar"]
.sub "_block807"  :anon :subid("173_1296306519.49046") :outer("171_1296306519.49046")
.annotate 'line', 363
    new $P809, "Integer"
    assign $P809, 0
    store_dynamic_lex "$*INVOCANT_OK", $P809
    .return ($P809)
.end


.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("174_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P829 = "176_1296306519.49046" 
    capture_lex $P829
    .local string rx822_tgt
    .local int rx822_pos
    .local int rx822_off
    .local int rx822_eos
    .local int rx822_rep
    .local pmc rx822_cur
    .local pmc rx822_debug
    (rx822_cur, rx822_pos, rx822_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx822_cur
    .local pmc match
    .lex "$/", match
    length rx822_eos, rx822_tgt
    gt rx822_pos, rx822_eos, rx822_done
    set rx822_off, 0
    lt rx822_pos, 2, rx822_start
    sub rx822_off, rx822_pos, 1
    substr rx822_tgt, rx822_tgt, rx822_off
  rx822_start:
    eq $I10, 1, rx822_restart
    if_null rx822_debug, debug_730
    rx822_cur."!cursor_debug"("START", "onlystar")
  debug_730:
    $I10 = self.'from'()
    ne $I10, -1, rxscan825_done
    goto rxscan825_scan
  rxscan825_loop:
    (rx822_pos) = rx822_cur."from"()
    inc rx822_pos
    rx822_cur."!cursor_from"(rx822_pos)
    ge rx822_pos, rx822_eos, rxscan825_done
  rxscan825_scan:
    set_addr $I10, rxscan825_loop
    rx822_cur."!mark_push"(0, rx822_pos, $I10)
  rxscan825_done:
.annotate 'line', 372
    rx822_cur."!cursor_pos"(rx822_pos)
    find_lex $P826, unicode:"$\x{a2}"
    $P827 = $P826."MATCH"()
    store_lex "$/", $P827
    .const 'Sub' $P829 = "176_1296306519.49046" 
    capture_lex $P829
    $P833 = $P829()
    unless $P833, rx822_fail
.annotate 'line', 373
  # rx literal  "{"
    add $I11, rx822_pos, 1
    gt $I11, rx822_eos, rx822_fail
    sub $I11, rx822_pos, rx822_off
    ord $I11, rx822_tgt, $I11
    ne $I11, 123, rx822_fail
    add rx822_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx822_pos, 1
    gt $I11, rx822_eos, rx822_fail
    sub $I11, rx822_pos, rx822_off
    ord $I11, rx822_tgt, $I11
    ne $I11, 42, rx822_fail
    add rx822_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ws"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx822_pos, 1
    gt $I11, rx822_eos, rx822_fail
    sub $I11, rx822_pos, rx822_off
    ord $I11, rx822_tgt, $I11
    ne $I11, 125, rx822_fail
    add rx822_pos, 1
.annotate 'line', 374
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."ENDSTMT"()
    unless $P10, rx822_fail
.annotate 'line', 375
  # rx subrule "finishpad" subtype=method negate=
    rx822_cur."!cursor_pos"(rx822_pos)
    $P10 = rx822_cur."finishpad"()
    unless $P10, rx822_fail
    rx822_pos = $P10."pos"()
.annotate 'line', 371
  # rx pass
    rx822_cur."!cursor_pass"(rx822_pos, "onlystar")
    if_null rx822_debug, debug_733
    rx822_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx822_pos)
  debug_733:
    .return (rx822_cur)
  rx822_restart:
.annotate 'line', 4
    if_null rx822_debug, debug_734
    rx822_cur."!cursor_debug"("NEXT", "onlystar")
  debug_734:
  rx822_fail:
    (rx822_rep, rx822_pos, $I10, $P10) = rx822_cur."!mark_fail"(0)
    lt rx822_pos, -1, rx822_done
    eq rx822_pos, -1, rx822_fail
    jump $I10
  rx822_done:
    rx822_cur."!cursor_fail"()
    if_null rx822_debug, debug_735
    rx822_cur."!cursor_debug"("FAIL", "onlystar")
  debug_735:
    .return (rx822_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("175_1296306519.49046") :method
.annotate 'line', 4
    new $P824, "ResizablePMCArray"
    push $P824, ""
    .return ($P824)
.end


.namespace ["NQP";"Grammar"]
.sub "_block828"  :anon :subid("176_1296306519.49046") :outer("174_1296306519.49046")
.annotate 'line', 372
    find_dynamic_lex $P830, "$*MULTINESS"
    unless_null $P830, vivify_731
    get_hll_global $P830, "$MULTINESS"
    unless_null $P830, vivify_732
    die "Contextual $*MULTINESS not found"
  vivify_732:
  vivify_731:
    set $S831, $P830
    iseq $I832, $S831, "proto"
    .return ($I832)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("177_1296306519.49046")
    .param pmc param_835
.annotate 'line', 378
    .lex "self", param_835
    $P836 = param_835."!protoregex"("multi_declarator")
    .return ($P836)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("178_1296306519.49046")
    .param pmc param_838
.annotate 'line', 378
    .lex "self", param_838
    $P839 = param_838."!PREFIX__!protoregex"("multi_declarator")
    .return ($P839)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("179_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 380
    new $P841, "Undef"
    .lex "$*MULTINESS", $P841
.annotate 'line', 4
    .local string rx842_tgt
    .local int rx842_pos
    .local int rx842_off
    .local int rx842_eos
    .local int rx842_rep
    .local pmc rx842_cur
    .local pmc rx842_debug
    (rx842_cur, rx842_pos, rx842_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx842_cur
    .local pmc match
    .lex "$/", match
    length rx842_eos, rx842_tgt
    gt rx842_pos, rx842_eos, rx842_done
    set rx842_off, 0
    lt rx842_pos, 2, rx842_start
    sub rx842_off, rx842_pos, 1
    substr rx842_tgt, rx842_tgt, rx842_off
  rx842_start:
    eq $I10, 1, rx842_restart
    if_null rx842_debug, debug_736
    rx842_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan846_done
    goto rxscan846_scan
  rxscan846_loop:
    (rx842_pos) = rx842_cur."from"()
    inc rx842_pos
    rx842_cur."!cursor_from"(rx842_pos)
    ge rx842_pos, rx842_eos, rxscan846_done
  rxscan846_scan:
    set_addr $I10, rxscan846_loop
    rx842_cur."!mark_push"(0, rx842_pos, $I10)
  rxscan846_done:
.annotate 'line', 380
    rx842_cur."!cursor_pos"(rx842_pos)
    new $P847, "String"
    assign $P847, "multi"
    store_lex "$*MULTINESS", $P847
.annotate 'line', 381
  # rx subcapture "sym"
    set_addr $I10, rxcap_848_fail
    rx842_cur."!mark_push"(0, rx842_pos, $I10)
  # rx literal  "multi"
    add $I11, rx842_pos, 5
    gt $I11, rx842_eos, rx842_fail
    sub $I11, rx842_pos, rx842_off
    substr $S10, rx842_tgt, $I11, 5
    ne $S10, "multi", rx842_fail
    add rx842_pos, 5
    set_addr $I10, rxcap_848_fail
    ($I12, $I11) = rx842_cur."!mark_peek"($I10)
    rx842_cur."!cursor_pos"($I11)
    ($P10) = rx842_cur."!cursor_start"()
    $P10."!cursor_pass"(rx842_pos, "")
    rx842_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_848_done
  rxcap_848_fail:
    goto rx842_fail
  rxcap_848_done:
.annotate 'line', 382
  # rx subrule "ws" subtype=method negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."ws"()
    unless $P10, rx842_fail
    rx842_pos = $P10."pos"()
  alt849_0:
    set_addr $I10, alt849_1
    rx842_cur."!mark_push"(0, rx842_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."declarator"()
    unless $P10, rx842_fail
    rx842_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx842_pos = $P10."pos"()
    goto alt849_end
  alt849_1:
    set_addr $I10, alt849_2
    rx842_cur."!mark_push"(0, rx842_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."routine_def"()
    unless $P10, rx842_fail
    rx842_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx842_pos = $P10."pos"()
    goto alt849_end
  alt849_2:
  # rx subrule "panic" subtype=method negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."panic"("Malformed multi")
    unless $P10, rx842_fail
    rx842_pos = $P10."pos"()
  alt849_end:
.annotate 'line', 379
  # rx pass
    rx842_cur."!cursor_pass"(rx842_pos, "multi_declarator:sym<multi>")
    if_null rx842_debug, debug_737
    rx842_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx842_pos)
  debug_737:
    .return (rx842_cur)
  rx842_restart:
.annotate 'line', 4
    if_null rx842_debug, debug_738
    rx842_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_738:
  rx842_fail:
    (rx842_rep, rx842_pos, $I10, $P10) = rx842_cur."!mark_fail"(0)
    lt rx842_pos, -1, rx842_done
    eq rx842_pos, -1, rx842_fail
    jump $I10
  rx842_done:
    rx842_cur."!cursor_fail"()
    if_null rx842_debug, debug_739
    rx842_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_739:
    .return (rx842_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("180_1296306519.49046") :method
.annotate 'line', 4
    $P844 = self."!PREFIX__!subrule"("ws", "multi")
    new $P845, "ResizablePMCArray"
    push $P845, $P844
    .return ($P845)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("181_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 385
    new $P851, "Undef"
    .lex "$*MULTINESS", $P851
.annotate 'line', 4
    .local string rx852_tgt
    .local int rx852_pos
    .local int rx852_off
    .local int rx852_eos
    .local int rx852_rep
    .local pmc rx852_cur
    .local pmc rx852_debug
    (rx852_cur, rx852_pos, rx852_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx852_cur
    .local pmc match
    .lex "$/", match
    length rx852_eos, rx852_tgt
    gt rx852_pos, rx852_eos, rx852_done
    set rx852_off, 0
    lt rx852_pos, 2, rx852_start
    sub rx852_off, rx852_pos, 1
    substr rx852_tgt, rx852_tgt, rx852_off
  rx852_start:
    eq $I10, 1, rx852_restart
    if_null rx852_debug, debug_740
    rx852_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_740:
    $I10 = self.'from'()
    ne $I10, -1, rxscan856_done
    goto rxscan856_scan
  rxscan856_loop:
    (rx852_pos) = rx852_cur."from"()
    inc rx852_pos
    rx852_cur."!cursor_from"(rx852_pos)
    ge rx852_pos, rx852_eos, rxscan856_done
  rxscan856_scan:
    set_addr $I10, rxscan856_loop
    rx852_cur."!mark_push"(0, rx852_pos, $I10)
  rxscan856_done:
.annotate 'line', 385
    rx852_cur."!cursor_pos"(rx852_pos)
    new $P857, "String"
    assign $P857, "proto"
    store_lex "$*MULTINESS", $P857
.annotate 'line', 386
  # rx subcapture "sym"
    set_addr $I10, rxcap_858_fail
    rx852_cur."!mark_push"(0, rx852_pos, $I10)
  # rx literal  "proto"
    add $I11, rx852_pos, 5
    gt $I11, rx852_eos, rx852_fail
    sub $I11, rx852_pos, rx852_off
    substr $S10, rx852_tgt, $I11, 5
    ne $S10, "proto", rx852_fail
    add rx852_pos, 5
    set_addr $I10, rxcap_858_fail
    ($I12, $I11) = rx852_cur."!mark_peek"($I10)
    rx852_cur."!cursor_pos"($I11)
    ($P10) = rx852_cur."!cursor_start"()
    $P10."!cursor_pass"(rx852_pos, "")
    rx852_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_858_done
  rxcap_858_fail:
    goto rx852_fail
  rxcap_858_done:
.annotate 'line', 387
  # rx subrule "ws" subtype=method negate=
    rx852_cur."!cursor_pos"(rx852_pos)
    $P10 = rx852_cur."ws"()
    unless $P10, rx852_fail
    rx852_pos = $P10."pos"()
  alt859_0:
    set_addr $I10, alt859_1
    rx852_cur."!mark_push"(0, rx852_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx852_cur."!cursor_pos"(rx852_pos)
    $P10 = rx852_cur."declarator"()
    unless $P10, rx852_fail
    rx852_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx852_pos = $P10."pos"()
    goto alt859_end
  alt859_1:
    set_addr $I10, alt859_2
    rx852_cur."!mark_push"(0, rx852_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx852_cur."!cursor_pos"(rx852_pos)
    $P10 = rx852_cur."routine_def"()
    unless $P10, rx852_fail
    rx852_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx852_pos = $P10."pos"()
    goto alt859_end
  alt859_2:
  # rx subrule "panic" subtype=method negate=
    rx852_cur."!cursor_pos"(rx852_pos)
    $P10 = rx852_cur."panic"("Malformed proto")
    unless $P10, rx852_fail
    rx852_pos = $P10."pos"()
  alt859_end:
.annotate 'line', 384
  # rx pass
    rx852_cur."!cursor_pass"(rx852_pos, "multi_declarator:sym<proto>")
    if_null rx852_debug, debug_741
    rx852_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx852_pos)
  debug_741:
    .return (rx852_cur)
  rx852_restart:
.annotate 'line', 4
    if_null rx852_debug, debug_742
    rx852_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_742:
  rx852_fail:
    (rx852_rep, rx852_pos, $I10, $P10) = rx852_cur."!mark_fail"(0)
    lt rx852_pos, -1, rx852_done
    eq rx852_pos, -1, rx852_fail
    jump $I10
  rx852_done:
    rx852_cur."!cursor_fail"()
    if_null rx852_debug, debug_743
    rx852_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_743:
    .return (rx852_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("182_1296306519.49046") :method
.annotate 'line', 4
    $P854 = self."!PREFIX__!subrule"("ws", "proto")
    new $P855, "ResizablePMCArray"
    push $P855, $P854
    .return ($P855)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("183_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 390
    new $P861, "Undef"
    .lex "$*MULTINESS", $P861
.annotate 'line', 4
    .local string rx862_tgt
    .local int rx862_pos
    .local int rx862_off
    .local int rx862_eos
    .local int rx862_rep
    .local pmc rx862_cur
    .local pmc rx862_debug
    (rx862_cur, rx862_pos, rx862_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx862_cur
    .local pmc match
    .lex "$/", match
    length rx862_eos, rx862_tgt
    gt rx862_pos, rx862_eos, rx862_done
    set rx862_off, 0
    lt rx862_pos, 2, rx862_start
    sub rx862_off, rx862_pos, 1
    substr rx862_tgt, rx862_tgt, rx862_off
  rx862_start:
    eq $I10, 1, rx862_restart
    if_null rx862_debug, debug_744
    rx862_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan866_done
    goto rxscan866_scan
  rxscan866_loop:
    (rx862_pos) = rx862_cur."from"()
    inc rx862_pos
    rx862_cur."!cursor_from"(rx862_pos)
    ge rx862_pos, rx862_eos, rxscan866_done
  rxscan866_scan:
    set_addr $I10, rxscan866_loop
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  rxscan866_done:
.annotate 'line', 390
    rx862_cur."!cursor_pos"(rx862_pos)
    new $P867, "String"
    assign $P867, ""
    store_lex "$*MULTINESS", $P867
.annotate 'line', 391
  # rx subrule "declarator" subtype=capture negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."declarator"()
    unless $P10, rx862_fail
    rx862_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx862_pos = $P10."pos"()
.annotate 'line', 389
  # rx pass
    rx862_cur."!cursor_pass"(rx862_pos, "multi_declarator:sym<null>")
    if_null rx862_debug, debug_745
    rx862_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx862_pos)
  debug_745:
    .return (rx862_cur)
  rx862_restart:
.annotate 'line', 4
    if_null rx862_debug, debug_746
    rx862_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_746:
  rx862_fail:
    (rx862_rep, rx862_pos, $I10, $P10) = rx862_cur."!mark_fail"(0)
    lt rx862_pos, -1, rx862_done
    eq rx862_pos, -1, rx862_fail
    jump $I10
  rx862_done:
    rx862_cur."!cursor_fail"()
    if_null rx862_debug, debug_747
    rx862_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_747:
    .return (rx862_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("184_1296306519.49046") :method
.annotate 'line', 4
    $P864 = self."!PREFIX__!subrule"("declarator", "")
    new $P865, "ResizablePMCArray"
    push $P865, $P864
    .return ($P865)
.end


.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("185_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P877 = "187_1296306519.49046" 
    capture_lex $P877
    .local string rx869_tgt
    .local int rx869_pos
    .local int rx869_off
    .local int rx869_eos
    .local int rx869_rep
    .local pmc rx869_cur
    .local pmc rx869_debug
    (rx869_cur, rx869_pos, rx869_tgt, $I10) = self."!cursor_start"()
    rx869_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx869_cur
    .local pmc match
    .lex "$/", match
    length rx869_eos, rx869_tgt
    gt rx869_pos, rx869_eos, rx869_done
    set rx869_off, 0
    lt rx869_pos, 2, rx869_start
    sub rx869_off, rx869_pos, 1
    substr rx869_tgt, rx869_tgt, rx869_off
  rx869_start:
    eq $I10, 1, rx869_restart
    if_null rx869_debug, debug_748
    rx869_cur."!cursor_debug"("START", "signature")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan872_done
    goto rxscan872_scan
  rxscan872_loop:
    (rx869_pos) = rx869_cur."from"()
    inc rx869_pos
    rx869_cur."!cursor_from"(rx869_pos)
    ge rx869_pos, rx869_eos, rxscan872_done
  rxscan872_scan:
    set_addr $I10, rxscan872_loop
    rx869_cur."!mark_push"(0, rx869_pos, $I10)
  rxscan872_done:
.annotate 'line', 395
  # rx rxquantr873 ** 0..1
    set_addr $I10, rxquantr873_done
    rx869_cur."!mark_push"(0, rx869_pos, $I10)
  rxquantr873_loop:
    rx869_cur."!cursor_pos"(rx869_pos)
    find_lex $P874, unicode:"$\x{a2}"
    $P875 = $P874."MATCH"()
    store_lex "$/", $P875
    .const 'Sub' $P877 = "187_1296306519.49046" 
    capture_lex $P877
    $P879 = $P877()
    unless $P879, rx869_fail
  # rx subrule "ws" subtype=method negate=
    rx869_cur."!cursor_pos"(rx869_pos)
    $P10 = rx869_cur."ws"()
    unless $P10, rx869_fail
    rx869_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx869_cur."!cursor_pos"(rx869_pos)
    $P10 = rx869_cur."parameter"()
    unless $P10, rx869_fail
    rx869_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx869_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx869_cur."!cursor_pos"(rx869_pos)
    $P10 = rx869_cur."ws"()
    unless $P10, rx869_fail
    rx869_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx869_pos, 1
    gt $I11, rx869_eos, rx869_fail
    sub $I11, rx869_pos, rx869_off
    ord $I11, rx869_tgt, $I11
    ne $I11, 58, rx869_fail
    add rx869_pos, 1
    set_addr $I10, rxquantr873_done
    (rx869_rep) = rx869_cur."!mark_commit"($I10)
  rxquantr873_done:
.annotate 'line', 396
  # rx rxquantr880 ** 0..1
    set_addr $I10, rxquantr880_done
    rx869_cur."!mark_push"(0, rx869_pos, $I10)
  rxquantr880_loop:
  # rx rxquantr881 ** 1..*
    set_addr $I10, rxquantr881_done
    rx869_cur."!mark_push"(0, -1, $I10)
  rxquantr881_loop:
  # rx subrule "ws" subtype=method negate=
    rx869_cur."!cursor_pos"(rx869_pos)
    $P10 = rx869_cur."ws"()
    unless $P10, rx869_fail
    rx869_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx869_cur."!cursor_pos"(rx869_pos)
    $P10 = rx869_cur."parameter"()
    unless $P10, rx869_fail
    rx869_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx869_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx869_cur."!cursor_pos"(rx869_pos)
    $P10 = rx869_cur."ws"()
    unless $P10, rx869_fail
    rx869_pos = $P10."pos"()
    set_addr $I10, rxquantr881_done
    (rx869_rep) = rx869_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr881_done
    rx869_cur."!mark_push"(rx869_rep, rx869_pos, $I10)
  # rx literal  ","
    add $I11, rx869_pos, 1
    gt $I11, rx869_eos, rx869_fail
    sub $I11, rx869_pos, rx869_off
    ord $I11, rx869_tgt, $I11
    ne $I11, 44, rx869_fail
    add rx869_pos, 1
    goto rxquantr881_loop
  rxquantr881_done:
    set_addr $I10, rxquantr880_done
    (rx869_rep) = rx869_cur."!mark_commit"($I10)
  rxquantr880_done:
.annotate 'line', 394
  # rx pass
    rx869_cur."!cursor_pass"(rx869_pos, "signature")
    if_null rx869_debug, debug_751
    rx869_cur."!cursor_debug"("PASS", "signature", " at pos=", rx869_pos)
  debug_751:
    .return (rx869_cur)
  rx869_restart:
.annotate 'line', 4
    if_null rx869_debug, debug_752
    rx869_cur."!cursor_debug"("NEXT", "signature")
  debug_752:
  rx869_fail:
    (rx869_rep, rx869_pos, $I10, $P10) = rx869_cur."!mark_fail"(0)
    lt rx869_pos, -1, rx869_done
    eq rx869_pos, -1, rx869_fail
    jump $I10
  rx869_done:
    rx869_cur."!cursor_fail"()
    if_null rx869_debug, debug_753
    rx869_cur."!cursor_debug"("FAIL", "signature")
  debug_753:
    .return (rx869_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("186_1296306519.49046") :method
.annotate 'line', 4
    new $P871, "ResizablePMCArray"
    push $P871, ""
    .return ($P871)
.end


.namespace ["NQP";"Grammar"]
.sub "_block876"  :anon :subid("187_1296306519.49046") :outer("185_1296306519.49046")
.annotate 'line', 395
    find_dynamic_lex $P878, "$*INVOCANT_OK"
    unless_null $P878, vivify_749
    get_hll_global $P878, "$INVOCANT_OK"
    unless_null $P878, vivify_750
    die "Contextual $*INVOCANT_OK not found"
  vivify_750:
  vivify_749:
    .return ($P878)
.end


.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("188_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx883_tgt
    .local int rx883_pos
    .local int rx883_off
    .local int rx883_eos
    .local int rx883_rep
    .local pmc rx883_cur
    .local pmc rx883_debug
    (rx883_cur, rx883_pos, rx883_tgt, $I10) = self."!cursor_start"()
    rx883_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx883_cur
    .local pmc match
    .lex "$/", match
    length rx883_eos, rx883_tgt
    gt rx883_pos, rx883_eos, rx883_done
    set rx883_off, 0
    lt rx883_pos, 2, rx883_start
    sub rx883_off, rx883_pos, 1
    substr rx883_tgt, rx883_tgt, rx883_off
  rx883_start:
    eq $I10, 1, rx883_restart
    if_null rx883_debug, debug_754
    rx883_cur."!cursor_debug"("START", "parameter")
  debug_754:
    $I10 = self.'from'()
    ne $I10, -1, rxscan886_done
    goto rxscan886_scan
  rxscan886_loop:
    (rx883_pos) = rx883_cur."from"()
    inc rx883_pos
    rx883_cur."!cursor_from"(rx883_pos)
    ge rx883_pos, rx883_eos, rxscan886_done
  rxscan886_scan:
    set_addr $I10, rxscan886_loop
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  rxscan886_done:
.annotate 'line', 400
  # rx rxquantr887 ** 0..*
    set_addr $I10, rxquantr887_done
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  rxquantr887_loop:
  # rx subrule "typename" subtype=capture negate=
    rx883_cur."!cursor_pos"(rx883_pos)
    $P10 = rx883_cur."typename"()
    unless $P10, rx883_fail
    rx883_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx883_pos = $P10."pos"()
  # rx rxquantr888 ** 0..1
    set_addr $I10, rxquantr888_done
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  rxquantr888_loop:
  # rx literal  ":"
    add $I11, rx883_pos, 1
    gt $I11, rx883_eos, rx883_fail
    sub $I11, rx883_pos, rx883_off
    ord $I11, rx883_tgt, $I11
    ne $I11, 58, rx883_fail
    add rx883_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_889_fail
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx883_pos, rx883_eos, rx883_fail
    sub $I10, rx883_pos, rx883_off
    substr $S10, rx883_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx883_fail
    inc rx883_pos
    set_addr $I10, rxcap_889_fail
    ($I12, $I11) = rx883_cur."!mark_peek"($I10)
    rx883_cur."!cursor_pos"($I11)
    ($P10) = rx883_cur."!cursor_start"()
    $P10."!cursor_pass"(rx883_pos, "")
    rx883_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_889_done
  rxcap_889_fail:
    goto rx883_fail
  rxcap_889_done:
    set_addr $I10, rxquantr888_done
    (rx883_rep) = rx883_cur."!mark_commit"($I10)
  rxquantr888_done:
  # rx subrule "ws" subtype=method negate=
    rx883_cur."!cursor_pos"(rx883_pos)
    $P10 = rx883_cur."ws"()
    unless $P10, rx883_fail
    rx883_pos = $P10."pos"()
    set_addr $I10, rxquantr887_done
    (rx883_rep) = rx883_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr887_done
    rx883_cur."!mark_push"(rx883_rep, rx883_pos, $I10)
    goto rxquantr887_loop
  rxquantr887_done:
  alt890_0:
.annotate 'line', 401
    set_addr $I10, alt890_1
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
.annotate 'line', 402
  # rx subcapture "quant"
    set_addr $I10, rxcap_891_fail
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  # rx literal  "*"
    add $I11, rx883_pos, 1
    gt $I11, rx883_eos, rx883_fail
    sub $I11, rx883_pos, rx883_off
    ord $I11, rx883_tgt, $I11
    ne $I11, 42, rx883_fail
    add rx883_pos, 1
    set_addr $I10, rxcap_891_fail
    ($I12, $I11) = rx883_cur."!mark_peek"($I10)
    rx883_cur."!cursor_pos"($I11)
    ($P10) = rx883_cur."!cursor_start"()
    $P10."!cursor_pass"(rx883_pos, "")
    rx883_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_891_done
  rxcap_891_fail:
    goto rx883_fail
  rxcap_891_done:
  # rx subrule "param_var" subtype=capture negate=
    rx883_cur."!cursor_pos"(rx883_pos)
    $P10 = rx883_cur."param_var"()
    unless $P10, rx883_fail
    rx883_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx883_pos = $P10."pos"()
    goto alt890_end
  alt890_1:
  alt892_0:
.annotate 'line', 403
    set_addr $I10, alt892_1
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx883_cur."!cursor_pos"(rx883_pos)
    $P10 = rx883_cur."param_var"()
    unless $P10, rx883_fail
    rx883_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx883_pos = $P10."pos"()
    goto alt892_end
  alt892_1:
  # rx subrule "named_param" subtype=capture negate=
    rx883_cur."!cursor_pos"(rx883_pos)
    $P10 = rx883_cur."named_param"()
    unless $P10, rx883_fail
    rx883_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx883_pos = $P10."pos"()
  alt892_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_894_fail
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  alt893_0:
    set_addr $I10, alt893_1
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  # rx literal  "?"
    add $I11, rx883_pos, 1
    gt $I11, rx883_eos, rx883_fail
    sub $I11, rx883_pos, rx883_off
    ord $I11, rx883_tgt, $I11
    ne $I11, 63, rx883_fail
    add rx883_pos, 1
    goto alt893_end
  alt893_1:
    set_addr $I10, alt893_2
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  # rx literal  "!"
    add $I11, rx883_pos, 1
    gt $I11, rx883_eos, rx883_fail
    sub $I11, rx883_pos, rx883_off
    ord $I11, rx883_tgt, $I11
    ne $I11, 33, rx883_fail
    add rx883_pos, 1
    goto alt893_end
  alt893_2:
  alt893_end:
    set_addr $I10, rxcap_894_fail
    ($I12, $I11) = rx883_cur."!mark_peek"($I10)
    rx883_cur."!cursor_pos"($I11)
    ($P10) = rx883_cur."!cursor_start"()
    $P10."!cursor_pass"(rx883_pos, "")
    rx883_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_894_done
  rxcap_894_fail:
    goto rx883_fail
  rxcap_894_done:
  alt890_end:
.annotate 'line', 405
  # rx rxquantr895 ** 0..1
    set_addr $I10, rxquantr895_done
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  rxquantr895_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx883_cur."!cursor_pos"(rx883_pos)
    $P10 = rx883_cur."default_value"()
    unless $P10, rx883_fail
    goto rxsubrule896_pass
  rxsubrule896_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx883_fail
  rxsubrule896_pass:
    set_addr $I10, rxsubrule896_back
    rx883_cur."!mark_push"(0, rx883_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx883_pos = $P10."pos"()
    set_addr $I10, rxquantr895_done
    (rx883_rep) = rx883_cur."!mark_commit"($I10)
  rxquantr895_done:
.annotate 'line', 399
  # rx pass
    rx883_cur."!cursor_pass"(rx883_pos, "parameter")
    if_null rx883_debug, debug_755
    rx883_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx883_pos)
  debug_755:
    .return (rx883_cur)
  rx883_restart:
.annotate 'line', 4
    if_null rx883_debug, debug_756
    rx883_cur."!cursor_debug"("NEXT", "parameter")
  debug_756:
  rx883_fail:
    (rx883_rep, rx883_pos, $I10, $P10) = rx883_cur."!mark_fail"(0)
    lt rx883_pos, -1, rx883_done
    eq rx883_pos, -1, rx883_fail
    jump $I10
  rx883_done:
    rx883_cur."!cursor_fail"()
    if_null rx883_debug, debug_757
    rx883_cur."!cursor_debug"("FAIL", "parameter")
  debug_757:
    .return (rx883_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("189_1296306519.49046") :method
.annotate 'line', 4
    new $P885, "ResizablePMCArray"
    push $P885, ""
    .return ($P885)
.end


.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("190_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx898_tgt
    .local int rx898_pos
    .local int rx898_off
    .local int rx898_eos
    .local int rx898_rep
    .local pmc rx898_cur
    .local pmc rx898_debug
    (rx898_cur, rx898_pos, rx898_tgt, $I10) = self."!cursor_start"()
    rx898_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx898_cur
    .local pmc match
    .lex "$/", match
    length rx898_eos, rx898_tgt
    gt rx898_pos, rx898_eos, rx898_done
    set rx898_off, 0
    lt rx898_pos, 2, rx898_start
    sub rx898_off, rx898_pos, 1
    substr rx898_tgt, rx898_tgt, rx898_off
  rx898_start:
    eq $I10, 1, rx898_restart
    if_null rx898_debug, debug_758
    rx898_cur."!cursor_debug"("START", "param_var")
  debug_758:
    $I10 = self.'from'()
    ne $I10, -1, rxscan902_done
    goto rxscan902_scan
  rxscan902_loop:
    (rx898_pos) = rx898_cur."from"()
    inc rx898_pos
    rx898_cur."!cursor_from"(rx898_pos)
    ge rx898_pos, rx898_eos, rxscan902_done
  rxscan902_scan:
    set_addr $I10, rxscan902_loop
    rx898_cur."!mark_push"(0, rx898_pos, $I10)
  rxscan902_done:
.annotate 'line', 409
  # rx subrule "sigil" subtype=capture negate=
    rx898_cur."!cursor_pos"(rx898_pos)
    $P10 = rx898_cur."sigil"()
    unless $P10, rx898_fail
    rx898_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx898_pos = $P10."pos"()
  # rx rxquantr903 ** 0..1
    set_addr $I10, rxquantr903_done
    rx898_cur."!mark_push"(0, rx898_pos, $I10)
  rxquantr903_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx898_cur."!cursor_pos"(rx898_pos)
    $P10 = rx898_cur."twigil"()
    unless $P10, rx898_fail
    goto rxsubrule904_pass
  rxsubrule904_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx898_fail
  rxsubrule904_pass:
    set_addr $I10, rxsubrule904_back
    rx898_cur."!mark_push"(0, rx898_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx898_pos = $P10."pos"()
    set_addr $I10, rxquantr903_done
    (rx898_rep) = rx898_cur."!mark_commit"($I10)
  rxquantr903_done:
  alt905_0:
.annotate 'line', 410
    set_addr $I10, alt905_1
    rx898_cur."!mark_push"(0, rx898_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx898_cur."!cursor_pos"(rx898_pos)
    $P10 = rx898_cur."ident"()
    unless $P10, rx898_fail
    rx898_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx898_pos = $P10."pos"()
    goto alt905_end
  alt905_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_906_fail
    rx898_cur."!mark_push"(0, rx898_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx898_pos, rx898_eos, rx898_fail
    sub $I10, rx898_pos, rx898_off
    substr $S10, rx898_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx898_fail
    inc rx898_pos
    set_addr $I10, rxcap_906_fail
    ($I12, $I11) = rx898_cur."!mark_peek"($I10)
    rx898_cur."!cursor_pos"($I11)
    ($P10) = rx898_cur."!cursor_start"()
    $P10."!cursor_pass"(rx898_pos, "")
    rx898_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_906_done
  rxcap_906_fail:
    goto rx898_fail
  rxcap_906_done:
  alt905_end:
.annotate 'line', 408
  # rx pass
    rx898_cur."!cursor_pass"(rx898_pos, "param_var")
    if_null rx898_debug, debug_759
    rx898_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx898_pos)
  debug_759:
    .return (rx898_cur)
  rx898_restart:
.annotate 'line', 4
    if_null rx898_debug, debug_760
    rx898_cur."!cursor_debug"("NEXT", "param_var")
  debug_760:
  rx898_fail:
    (rx898_rep, rx898_pos, $I10, $P10) = rx898_cur."!mark_fail"(0)
    lt rx898_pos, -1, rx898_done
    eq rx898_pos, -1, rx898_fail
    jump $I10
  rx898_done:
    rx898_cur."!cursor_fail"()
    if_null rx898_debug, debug_761
    rx898_cur."!cursor_debug"("FAIL", "param_var")
  debug_761:
    .return (rx898_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("191_1296306519.49046") :method
.annotate 'line', 4
    $P900 = self."!PREFIX__!subrule"("sigil", "")
    new $P901, "ResizablePMCArray"
    push $P901, $P900
    .return ($P901)
.end


.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("192_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx908_tgt
    .local int rx908_pos
    .local int rx908_off
    .local int rx908_eos
    .local int rx908_rep
    .local pmc rx908_cur
    .local pmc rx908_debug
    (rx908_cur, rx908_pos, rx908_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx908_cur
    .local pmc match
    .lex "$/", match
    length rx908_eos, rx908_tgt
    gt rx908_pos, rx908_eos, rx908_done
    set rx908_off, 0
    lt rx908_pos, 2, rx908_start
    sub rx908_off, rx908_pos, 1
    substr rx908_tgt, rx908_tgt, rx908_off
  rx908_start:
    eq $I10, 1, rx908_restart
    if_null rx908_debug, debug_762
    rx908_cur."!cursor_debug"("START", "named_param")
  debug_762:
    $I10 = self.'from'()
    ne $I10, -1, rxscan912_done
    goto rxscan912_scan
  rxscan912_loop:
    (rx908_pos) = rx908_cur."from"()
    inc rx908_pos
    rx908_cur."!cursor_from"(rx908_pos)
    ge rx908_pos, rx908_eos, rxscan912_done
  rxscan912_scan:
    set_addr $I10, rxscan912_loop
    rx908_cur."!mark_push"(0, rx908_pos, $I10)
  rxscan912_done:
.annotate 'line', 414
  # rx literal  ":"
    add $I11, rx908_pos, 1
    gt $I11, rx908_eos, rx908_fail
    sub $I11, rx908_pos, rx908_off
    ord $I11, rx908_tgt, $I11
    ne $I11, 58, rx908_fail
    add rx908_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx908_cur."!cursor_pos"(rx908_pos)
    $P10 = rx908_cur."param_var"()
    unless $P10, rx908_fail
    rx908_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx908_pos = $P10."pos"()
.annotate 'line', 413
  # rx pass
    rx908_cur."!cursor_pass"(rx908_pos, "named_param")
    if_null rx908_debug, debug_763
    rx908_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx908_pos)
  debug_763:
    .return (rx908_cur)
  rx908_restart:
.annotate 'line', 4
    if_null rx908_debug, debug_764
    rx908_cur."!cursor_debug"("NEXT", "named_param")
  debug_764:
  rx908_fail:
    (rx908_rep, rx908_pos, $I10, $P10) = rx908_cur."!mark_fail"(0)
    lt rx908_pos, -1, rx908_done
    eq rx908_pos, -1, rx908_fail
    jump $I10
  rx908_done:
    rx908_cur."!cursor_fail"()
    if_null rx908_debug, debug_765
    rx908_cur."!cursor_debug"("FAIL", "named_param")
  debug_765:
    .return (rx908_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("193_1296306519.49046") :method
.annotate 'line', 4
    $P910 = self."!PREFIX__!subrule"("param_var", ":")
    new $P911, "ResizablePMCArray"
    push $P911, $P910
    .return ($P911)
.end


.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("194_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx914_tgt
    .local int rx914_pos
    .local int rx914_off
    .local int rx914_eos
    .local int rx914_rep
    .local pmc rx914_cur
    .local pmc rx914_debug
    (rx914_cur, rx914_pos, rx914_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx914_cur
    .local pmc match
    .lex "$/", match
    length rx914_eos, rx914_tgt
    gt rx914_pos, rx914_eos, rx914_done
    set rx914_off, 0
    lt rx914_pos, 2, rx914_start
    sub rx914_off, rx914_pos, 1
    substr rx914_tgt, rx914_tgt, rx914_off
  rx914_start:
    eq $I10, 1, rx914_restart
    if_null rx914_debug, debug_766
    rx914_cur."!cursor_debug"("START", "default_value")
  debug_766:
    $I10 = self.'from'()
    ne $I10, -1, rxscan918_done
    goto rxscan918_scan
  rxscan918_loop:
    (rx914_pos) = rx914_cur."from"()
    inc rx914_pos
    rx914_cur."!cursor_from"(rx914_pos)
    ge rx914_pos, rx914_eos, rxscan918_done
  rxscan918_scan:
    set_addr $I10, rxscan918_loop
    rx914_cur."!mark_push"(0, rx914_pos, $I10)
  rxscan918_done:
.annotate 'line', 417
  # rx subrule "ws" subtype=method negate=
    rx914_cur."!cursor_pos"(rx914_pos)
    $P10 = rx914_cur."ws"()
    unless $P10, rx914_fail
    rx914_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx914_pos, 1
    gt $I11, rx914_eos, rx914_fail
    sub $I11, rx914_pos, rx914_off
    ord $I11, rx914_tgt, $I11
    ne $I11, 61, rx914_fail
    add rx914_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx914_cur."!cursor_pos"(rx914_pos)
    $P10 = rx914_cur."ws"()
    unless $P10, rx914_fail
    rx914_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx914_cur."!cursor_pos"(rx914_pos)
    $P10 = rx914_cur."EXPR"("i=")
    unless $P10, rx914_fail
    rx914_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx914_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx914_cur."!cursor_pos"(rx914_pos)
    $P10 = rx914_cur."ws"()
    unless $P10, rx914_fail
    rx914_pos = $P10."pos"()
  # rx pass
    rx914_cur."!cursor_pass"(rx914_pos, "default_value")
    if_null rx914_debug, debug_767
    rx914_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx914_pos)
  debug_767:
    .return (rx914_cur)
  rx914_restart:
.annotate 'line', 4
    if_null rx914_debug, debug_768
    rx914_cur."!cursor_debug"("NEXT", "default_value")
  debug_768:
  rx914_fail:
    (rx914_rep, rx914_pos, $I10, $P10) = rx914_cur."!mark_fail"(0)
    lt rx914_pos, -1, rx914_done
    eq rx914_pos, -1, rx914_fail
    jump $I10
  rx914_done:
    rx914_cur."!cursor_fail"()
    if_null rx914_debug, debug_769
    rx914_cur."!cursor_debug"("FAIL", "default_value")
  debug_769:
    .return (rx914_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("195_1296306519.49046") :method
.annotate 'line', 4
    $P916 = self."!PREFIX__!subrule"("ws", "")
    new $P917, "ResizablePMCArray"
    push $P917, $P916
    .return ($P917)
.end


.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("196_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx923_tgt
    .local int rx923_pos
    .local int rx923_off
    .local int rx923_eos
    .local int rx923_rep
    .local pmc rx923_cur
    .local pmc rx923_debug
    (rx923_cur, rx923_pos, rx923_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx923_cur
    .local pmc match
    .lex "$/", match
    length rx923_eos, rx923_tgt
    gt rx923_pos, rx923_eos, rx923_done
    set rx923_off, 0
    lt rx923_pos, 2, rx923_start
    sub rx923_off, rx923_pos, 1
    substr rx923_tgt, rx923_tgt, rx923_off
  rx923_start:
    eq $I10, 1, rx923_restart
    if_null rx923_debug, debug_770
    rx923_cur."!cursor_debug"("START", "trait")
  debug_770:
    $I10 = self.'from'()
    ne $I10, -1, rxscan927_done
    goto rxscan927_scan
  rxscan927_loop:
    (rx923_pos) = rx923_cur."from"()
    inc rx923_pos
    rx923_cur."!cursor_from"(rx923_pos)
    ge rx923_pos, rx923_eos, rxscan927_done
  rxscan927_scan:
    set_addr $I10, rxscan927_loop
    rx923_cur."!mark_push"(0, rx923_pos, $I10)
  rxscan927_done:
.annotate 'line', 419
  # rx subrule "ws" subtype=method negate=
    rx923_cur."!cursor_pos"(rx923_pos)
    $P10 = rx923_cur."ws"()
    unless $P10, rx923_fail
    rx923_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx923_cur."!cursor_pos"(rx923_pos)
    $P10 = rx923_cur."trait_mod"()
    unless $P10, rx923_fail
    rx923_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx923_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx923_cur."!cursor_pos"(rx923_pos)
    $P10 = rx923_cur."ws"()
    unless $P10, rx923_fail
    rx923_pos = $P10."pos"()
  # rx pass
    rx923_cur."!cursor_pass"(rx923_pos, "trait")
    if_null rx923_debug, debug_771
    rx923_cur."!cursor_debug"("PASS", "trait", " at pos=", rx923_pos)
  debug_771:
    .return (rx923_cur)
  rx923_restart:
.annotate 'line', 4
    if_null rx923_debug, debug_772
    rx923_cur."!cursor_debug"("NEXT", "trait")
  debug_772:
  rx923_fail:
    (rx923_rep, rx923_pos, $I10, $P10) = rx923_cur."!mark_fail"(0)
    lt rx923_pos, -1, rx923_done
    eq rx923_pos, -1, rx923_fail
    jump $I10
  rx923_done:
    rx923_cur."!cursor_fail"()
    if_null rx923_debug, debug_773
    rx923_cur."!cursor_debug"("FAIL", "trait")
  debug_773:
    .return (rx923_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("197_1296306519.49046") :method
.annotate 'line', 4
    $P925 = self."!PREFIX__!subrule"("ws", "")
    new $P926, "ResizablePMCArray"
    push $P926, $P925
    .return ($P926)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("198_1296306519.49046")
    .param pmc param_931
.annotate 'line', 421
    .lex "self", param_931
    $P932 = param_931."!protoregex"("trait_mod")
    .return ($P932)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("199_1296306519.49046")
    .param pmc param_934
.annotate 'line', 421
    .lex "self", param_934
    $P935 = param_934."!PREFIX__!protoregex"("trait_mod")
    .return ($P935)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("200_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx937_tgt
    .local int rx937_pos
    .local int rx937_off
    .local int rx937_eos
    .local int rx937_rep
    .local pmc rx937_cur
    .local pmc rx937_debug
    (rx937_cur, rx937_pos, rx937_tgt, $I10) = self."!cursor_start"()
    rx937_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx937_cur
    .local pmc match
    .lex "$/", match
    length rx937_eos, rx937_tgt
    gt rx937_pos, rx937_eos, rx937_done
    set rx937_off, 0
    lt rx937_pos, 2, rx937_start
    sub rx937_off, rx937_pos, 1
    substr rx937_tgt, rx937_tgt, rx937_off
  rx937_start:
    eq $I10, 1, rx937_restart
    if_null rx937_debug, debug_774
    rx937_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_774:
    $I10 = self.'from'()
    ne $I10, -1, rxscan941_done
    goto rxscan941_scan
  rxscan941_loop:
    (rx937_pos) = rx937_cur."from"()
    inc rx937_pos
    rx937_cur."!cursor_from"(rx937_pos)
    ge rx937_pos, rx937_eos, rxscan941_done
  rxscan941_scan:
    set_addr $I10, rxscan941_loop
    rx937_cur."!mark_push"(0, rx937_pos, $I10)
  rxscan941_done:
.annotate 'line', 422
  # rx subcapture "sym"
    set_addr $I10, rxcap_942_fail
    rx937_cur."!mark_push"(0, rx937_pos, $I10)
  # rx literal  "is"
    add $I11, rx937_pos, 2
    gt $I11, rx937_eos, rx937_fail
    sub $I11, rx937_pos, rx937_off
    substr $S10, rx937_tgt, $I11, 2
    ne $S10, "is", rx937_fail
    add rx937_pos, 2
    set_addr $I10, rxcap_942_fail
    ($I12, $I11) = rx937_cur."!mark_peek"($I10)
    rx937_cur."!cursor_pos"($I11)
    ($P10) = rx937_cur."!cursor_start"()
    $P10."!cursor_pass"(rx937_pos, "")
    rx937_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_942_done
  rxcap_942_fail:
    goto rx937_fail
  rxcap_942_done:
  # rx subrule "ws" subtype=method negate=
    rx937_cur."!cursor_pos"(rx937_pos)
    $P10 = rx937_cur."ws"()
    unless $P10, rx937_fail
    rx937_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx937_cur."!cursor_pos"(rx937_pos)
    $P10 = rx937_cur."deflongname"()
    unless $P10, rx937_fail
    rx937_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx937_pos = $P10."pos"()
  # rx rxquantr944 ** 0..1
    set_addr $I10, rxquantr944_done
    rx937_cur."!mark_push"(0, rx937_pos, $I10)
  rxquantr944_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx937_cur."!cursor_pos"(rx937_pos)
    $P10 = rx937_cur."circumfix"()
    unless $P10, rx937_fail
    goto rxsubrule945_pass
  rxsubrule945_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx937_fail
  rxsubrule945_pass:
    set_addr $I10, rxsubrule945_back
    rx937_cur."!mark_push"(0, rx937_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx937_pos = $P10."pos"()
    set_addr $I10, rxquantr944_done
    (rx937_rep) = rx937_cur."!mark_commit"($I10)
  rxquantr944_done:
  # rx subrule "ws" subtype=method negate=
    rx937_cur."!cursor_pos"(rx937_pos)
    $P10 = rx937_cur."ws"()
    unless $P10, rx937_fail
    rx937_pos = $P10."pos"()
  # rx pass
    rx937_cur."!cursor_pass"(rx937_pos, "trait_mod:sym<is>")
    if_null rx937_debug, debug_775
    rx937_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx937_pos)
  debug_775:
    .return (rx937_cur)
  rx937_restart:
.annotate 'line', 4
    if_null rx937_debug, debug_776
    rx937_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_776:
  rx937_fail:
    (rx937_rep, rx937_pos, $I10, $P10) = rx937_cur."!mark_fail"(0)
    lt rx937_pos, -1, rx937_done
    eq rx937_pos, -1, rx937_fail
    jump $I10
  rx937_done:
    rx937_cur."!cursor_fail"()
    if_null rx937_debug, debug_777
    rx937_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_777:
    .return (rx937_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("201_1296306519.49046") :method
.annotate 'line', 4
    $P939 = self."!PREFIX__!subrule"("ws", "is")
    new $P940, "ResizablePMCArray"
    push $P940, $P939
    .return ($P940)
.end


.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("202_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx948_tgt
    .local int rx948_pos
    .local int rx948_off
    .local int rx948_eos
    .local int rx948_rep
    .local pmc rx948_cur
    .local pmc rx948_debug
    (rx948_cur, rx948_pos, rx948_tgt, $I10) = self."!cursor_start"()
    rx948_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx948_cur
    .local pmc match
    .lex "$/", match
    length rx948_eos, rx948_tgt
    gt rx948_pos, rx948_eos, rx948_done
    set rx948_off, 0
    lt rx948_pos, 2, rx948_start
    sub rx948_off, rx948_pos, 1
    substr rx948_tgt, rx948_tgt, rx948_off
  rx948_start:
    eq $I10, 1, rx948_restart
    if_null rx948_debug, debug_778
    rx948_cur."!cursor_debug"("START", "regex_declarator")
  debug_778:
    $I10 = self.'from'()
    ne $I10, -1, rxscan952_done
    goto rxscan952_scan
  rxscan952_loop:
    (rx948_pos) = rx948_cur."from"()
    inc rx948_pos
    rx948_cur."!cursor_from"(rx948_pos)
    ge rx948_pos, rx948_eos, rxscan952_done
  rxscan952_scan:
    set_addr $I10, rxscan952_loop
    rx948_cur."!mark_push"(0, rx948_pos, $I10)
  rxscan952_done:
.annotate 'line', 424
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  alt954_0:
.annotate 'line', 425
    set_addr $I10, alt954_1
    rx948_cur."!mark_push"(0, rx948_pos, $I10)
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_956_fail
    rx948_cur."!mark_push"(0, rx948_pos, $I10)
  # rx literal  "proto"
    add $I11, rx948_pos, 5
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    substr $S10, rx948_tgt, $I11, 5
    ne $S10, "proto", rx948_fail
    add rx948_pos, 5
    set_addr $I10, rxcap_956_fail
    ($I12, $I11) = rx948_cur."!mark_peek"($I10)
    rx948_cur."!cursor_pos"($I11)
    ($P10) = rx948_cur."!cursor_start"()
    $P10."!cursor_pass"(rx948_pos, "")
    rx948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_956_done
  rxcap_956_fail:
    goto rx948_fail
  rxcap_956_done:
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  alt958_0:
    set_addr $I10, alt958_1
    rx948_cur."!mark_push"(0, rx948_pos, $I10)
  # rx literal  "regex"
    add $I11, rx948_pos, 5
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    substr $S10, rx948_tgt, $I11, 5
    ne $S10, "regex", rx948_fail
    add rx948_pos, 5
    goto alt958_end
  alt958_1:
    set_addr $I10, alt958_2
    rx948_cur."!mark_push"(0, rx948_pos, $I10)
  # rx literal  "token"
    add $I11, rx948_pos, 5
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    substr $S10, rx948_tgt, $I11, 5
    ne $S10, "token", rx948_fail
    add rx948_pos, 5
    goto alt958_end
  alt958_2:
  # rx literal  "rule"
    add $I11, rx948_pos, 4
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    substr $S10, rx948_tgt, $I11, 4
    ne $S10, "rule", rx948_fail
    add rx948_pos, 4
  alt958_end:
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
.annotate 'line', 427
  # rx subrule "deflongname" subtype=capture negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."deflongname"()
    unless $P10, rx948_fail
    rx948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  alt961_0:
.annotate 'line', 428
    set_addr $I10, alt961_1
    rx948_cur."!mark_push"(0, rx948_pos, $I10)
.annotate 'line', 429
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx948_pos, 1
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    ord $I11, rx948_tgt, $I11
    ne $I11, 123, rx948_fail
    add rx948_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx948_pos, 5
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    substr $S10, rx948_tgt, $I11, 5
    ne $S10, "<...>", rx948_fail
    add rx948_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx948_pos, 1
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    ord $I11, rx948_tgt, $I11
    ne $I11, 125, rx948_fail
    add rx948_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ENDSTMT"()
    unless $P10, rx948_fail
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
    goto alt961_end
  alt961_1:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."panic"("Proto regex body must be <...>")
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  alt961_end:
.annotate 'line', 431
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
.annotate 'line', 426
    goto alt954_end
  alt954_1:
.annotate 'line', 432
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_971_fail
    rx948_cur."!mark_push"(0, rx948_pos, $I10)
  alt970_0:
    set_addr $I10, alt970_1
    rx948_cur."!mark_push"(0, rx948_pos, $I10)
  # rx literal  "regex"
    add $I11, rx948_pos, 5
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    substr $S10, rx948_tgt, $I11, 5
    ne $S10, "regex", rx948_fail
    add rx948_pos, 5
    goto alt970_end
  alt970_1:
    set_addr $I10, alt970_2
    rx948_cur."!mark_push"(0, rx948_pos, $I10)
  # rx literal  "token"
    add $I11, rx948_pos, 5
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    substr $S10, rx948_tgt, $I11, 5
    ne $S10, "token", rx948_fail
    add rx948_pos, 5
    goto alt970_end
  alt970_2:
  # rx literal  "rule"
    add $I11, rx948_pos, 4
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    substr $S10, rx948_tgt, $I11, 4
    ne $S10, "rule", rx948_fail
    add rx948_pos, 4
  alt970_end:
    set_addr $I10, rxcap_971_fail
    ($I12, $I11) = rx948_cur."!mark_peek"($I10)
    rx948_cur."!cursor_pos"($I11)
    ($P10) = rx948_cur."!cursor_start"()
    $P10."!cursor_pass"(rx948_pos, "")
    rx948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_971_done
  rxcap_971_fail:
    goto rx948_fail
  rxcap_971_done:
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
.annotate 'line', 433
  # rx subrule "deflongname" subtype=capture negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."deflongname"()
    unless $P10, rx948_fail
    rx948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
.annotate 'line', 434
  # rx subrule "newpad" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."newpad"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
.annotate 'line', 435
  # rx rxquantr975 ** 0..1
    set_addr $I10, rxquantr975_done
    rx948_cur."!mark_push"(0, rx948_pos, $I10)
  rxquantr975_loop:
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx948_pos, 1
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    ord $I11, rx948_tgt, $I11
    ne $I11, 40, rx948_fail
    add rx948_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."signature"()
    unless $P10, rx948_fail
    rx948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx948_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx948_pos, 1
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    ord $I11, rx948_tgt, $I11
    ne $I11, 41, rx948_fail
    add rx948_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
    set_addr $I10, rxquantr975_done
    (rx948_rep) = rx948_cur."!mark_commit"($I10)
  rxquantr975_done:
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
.annotate 'line', 436
  # rx reduce name="regex_declarator" key="open"
    rx948_cur."!cursor_pos"(rx948_pos)
    rx948_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
.annotate 'line', 437
  # rx literal  "{"
    add $I11, rx948_pos, 1
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    ord $I11, rx948_tgt, $I11
    ne $I11, 123, rx948_fail
    add rx948_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."LANG"("Regex", "nibbler")
    unless $P10, rx948_fail
    rx948_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx948_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx948_pos, 1
    gt $I11, rx948_eos, rx948_fail
    sub $I11, rx948_pos, rx948_off
    ord $I11, rx948_tgt, $I11
    ne $I11, 125, rx948_fail
    add rx948_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ENDSTMT"()
    unless $P10, rx948_fail
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
  alt954_end:
.annotate 'line', 438
  # rx subrule "ws" subtype=method negate=
    rx948_cur."!cursor_pos"(rx948_pos)
    $P10 = rx948_cur."ws"()
    unless $P10, rx948_fail
    rx948_pos = $P10."pos"()
.annotate 'line', 424
  # rx pass
    rx948_cur."!cursor_pass"(rx948_pos, "regex_declarator")
    if_null rx948_debug, debug_779
    rx948_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx948_pos)
  debug_779:
    .return (rx948_cur)
  rx948_restart:
.annotate 'line', 4
    if_null rx948_debug, debug_780
    rx948_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_780:
  rx948_fail:
    (rx948_rep, rx948_pos, $I10, $P10) = rx948_cur."!mark_fail"(0)
    lt rx948_pos, -1, rx948_done
    eq rx948_pos, -1, rx948_fail
    jump $I10
  rx948_done:
    rx948_cur."!cursor_fail"()
    if_null rx948_debug, debug_781
    rx948_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_781:
    .return (rx948_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("203_1296306519.49046") :method
.annotate 'line', 4
    $P950 = self."!PREFIX__!subrule"("ws", "")
    new $P951, "ResizablePMCArray"
    push $P951, $P950
    .return ($P951)
.end


.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("204_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx985_tgt
    .local int rx985_pos
    .local int rx985_off
    .local int rx985_eos
    .local int rx985_rep
    .local pmc rx985_cur
    .local pmc rx985_debug
    (rx985_cur, rx985_pos, rx985_tgt, $I10) = self."!cursor_start"()
    rx985_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx985_cur
    .local pmc match
    .lex "$/", match
    length rx985_eos, rx985_tgt
    gt rx985_pos, rx985_eos, rx985_done
    set rx985_off, 0
    lt rx985_pos, 2, rx985_start
    sub rx985_off, rx985_pos, 1
    substr rx985_tgt, rx985_tgt, rx985_off
  rx985_start:
    eq $I10, 1, rx985_restart
    if_null rx985_debug, debug_782
    rx985_cur."!cursor_debug"("START", "dotty")
  debug_782:
    $I10 = self.'from'()
    ne $I10, -1, rxscan989_done
    goto rxscan989_scan
  rxscan989_loop:
    (rx985_pos) = rx985_cur."from"()
    inc rx985_pos
    rx985_cur."!cursor_from"(rx985_pos)
    ge rx985_pos, rx985_eos, rxscan989_done
  rxscan989_scan:
    set_addr $I10, rxscan989_loop
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  rxscan989_done:
.annotate 'line', 442
  # rx literal  "."
    add $I11, rx985_pos, 1
    gt $I11, rx985_eos, rx985_fail
    sub $I11, rx985_pos, rx985_off
    ord $I11, rx985_tgt, $I11
    ne $I11, 46, rx985_fail
    add rx985_pos, 1
  alt990_0:
.annotate 'line', 443
    set_addr $I10, alt990_1
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."deflongname"()
    unless $P10, rx985_fail
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx985_pos = $P10."pos"()
    goto alt990_end
  alt990_1:
.annotate 'line', 444
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx985_pos, rx985_off
    substr $S10, rx985_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx985_fail
  # rx subrule "quote" subtype=capture negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."quote"()
    unless $P10, rx985_fail
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx985_pos = $P10."pos"()
  alt991_0:
.annotate 'line', 445
    set_addr $I10, alt991_1
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx985_pos, rx985_off
    substr $S10, rx985_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx985_fail
    goto alt991_end
  alt991_1:
  # rx subrule "panic" subtype=method negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx985_fail
    rx985_pos = $P10."pos"()
  alt991_end:
  alt990_end:
.annotate 'line', 451
  # rx rxquantr992 ** 0..1
    set_addr $I10, rxquantr992_done
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
  rxquantr992_loop:
  alt993_0:
.annotate 'line', 448
    set_addr $I10, alt993_1
    rx985_cur."!mark_push"(0, rx985_pos, $I10)
.annotate 'line', 449
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx985_pos, rx985_off
    substr $S10, rx985_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx985_fail
  # rx subrule "args" subtype=capture negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."args"()
    unless $P10, rx985_fail
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx985_pos = $P10."pos"()
    goto alt993_end
  alt993_1:
.annotate 'line', 450
  # rx literal  ":"
    add $I11, rx985_pos, 1
    gt $I11, rx985_eos, rx985_fail
    sub $I11, rx985_pos, rx985_off
    ord $I11, rx985_tgt, $I11
    ne $I11, 58, rx985_fail
    add rx985_pos, 1
  # rx charclass s
    ge rx985_pos, rx985_eos, rx985_fail
    sub $I10, rx985_pos, rx985_off
    is_cclass $I11, 32, rx985_tgt, $I10
    unless $I11, rx985_fail
    inc rx985_pos
  # rx subrule "arglist" subtype=capture negate=
    rx985_cur."!cursor_pos"(rx985_pos)
    $P10 = rx985_cur."arglist"()
    unless $P10, rx985_fail
    rx985_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx985_pos = $P10."pos"()
  alt993_end:
.annotate 'line', 451
    set_addr $I10, rxquantr992_done
    (rx985_rep) = rx985_cur."!mark_commit"($I10)
  rxquantr992_done:
.annotate 'line', 441
  # rx pass
    rx985_cur."!cursor_pass"(rx985_pos, "dotty")
    if_null rx985_debug, debug_783
    rx985_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx985_pos)
  debug_783:
    .return (rx985_cur)
  rx985_restart:
.annotate 'line', 4
    if_null rx985_debug, debug_784
    rx985_cur."!cursor_debug"("NEXT", "dotty")
  debug_784:
  rx985_fail:
    (rx985_rep, rx985_pos, $I10, $P10) = rx985_cur."!mark_fail"(0)
    lt rx985_pos, -1, rx985_done
    eq rx985_pos, -1, rx985_fail
    jump $I10
  rx985_done:
    rx985_cur."!cursor_fail"()
    if_null rx985_debug, debug_785
    rx985_cur."!cursor_debug"("FAIL", "dotty")
  debug_785:
    .return (rx985_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("205_1296306519.49046") :method
.annotate 'line', 4
    $P987 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P988, "ResizablePMCArray"
    push $P988, "'"
    push $P988, "\""
    push $P988, $P987
    .return ($P988)
.end


.namespace ["NQP";"Grammar"]
.sub "term"  :subid("206_1296306519.49046")
    .param pmc param_995
.annotate 'line', 455
    .lex "self", param_995
    $P996 = param_995."!protoregex"("term")
    .return ($P996)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("207_1296306519.49046")
    .param pmc param_998
.annotate 'line', 455
    .lex "self", param_998
    $P999 = param_998."!PREFIX__!protoregex"("term")
    .return ($P999)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("208_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1001_tgt
    .local int rx1001_pos
    .local int rx1001_off
    .local int rx1001_eos
    .local int rx1001_rep
    .local pmc rx1001_cur
    .local pmc rx1001_debug
    (rx1001_cur, rx1001_pos, rx1001_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1001_cur
    .local pmc match
    .lex "$/", match
    length rx1001_eos, rx1001_tgt
    gt rx1001_pos, rx1001_eos, rx1001_done
    set rx1001_off, 0
    lt rx1001_pos, 2, rx1001_start
    sub rx1001_off, rx1001_pos, 1
    substr rx1001_tgt, rx1001_tgt, rx1001_off
  rx1001_start:
    eq $I10, 1, rx1001_restart
    if_null rx1001_debug, debug_786
    rx1001_cur."!cursor_debug"("START", "term:sym<self>")
  debug_786:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1004_done
    goto rxscan1004_scan
  rxscan1004_loop:
    (rx1001_pos) = rx1001_cur."from"()
    inc rx1001_pos
    rx1001_cur."!cursor_from"(rx1001_pos)
    ge rx1001_pos, rx1001_eos, rxscan1004_done
  rxscan1004_scan:
    set_addr $I10, rxscan1004_loop
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  rxscan1004_done:
.annotate 'line', 457
  # rx subcapture "sym"
    set_addr $I10, rxcap_1005_fail
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  # rx literal  "self"
    add $I11, rx1001_pos, 4
    gt $I11, rx1001_eos, rx1001_fail
    sub $I11, rx1001_pos, rx1001_off
    substr $S10, rx1001_tgt, $I11, 4
    ne $S10, "self", rx1001_fail
    add rx1001_pos, 4
    set_addr $I10, rxcap_1005_fail
    ($I12, $I11) = rx1001_cur."!mark_peek"($I10)
    rx1001_cur."!cursor_pos"($I11)
    ($P10) = rx1001_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1001_pos, "")
    rx1001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1005_done
  rxcap_1005_fail:
    goto rx1001_fail
  rxcap_1005_done:
  # rxanchor rwb
    le rx1001_pos, 0, rx1001_fail
    sub $I10, rx1001_pos, rx1001_off
    is_cclass $I11, 8192, rx1001_tgt, $I10
    if $I11, rx1001_fail
    dec $I10
    is_cclass $I11, 8192, rx1001_tgt, $I10
    unless $I11, rx1001_fail
  # rx pass
    rx1001_cur."!cursor_pass"(rx1001_pos, "term:sym<self>")
    if_null rx1001_debug, debug_787
    rx1001_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1001_pos)
  debug_787:
    .return (rx1001_cur)
  rx1001_restart:
.annotate 'line', 4
    if_null rx1001_debug, debug_788
    rx1001_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_788:
  rx1001_fail:
    (rx1001_rep, rx1001_pos, $I10, $P10) = rx1001_cur."!mark_fail"(0)
    lt rx1001_pos, -1, rx1001_done
    eq rx1001_pos, -1, rx1001_fail
    jump $I10
  rx1001_done:
    rx1001_cur."!cursor_fail"()
    if_null rx1001_debug, debug_789
    rx1001_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_789:
    .return (rx1001_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("209_1296306519.49046") :method
.annotate 'line', 4
    new $P1003, "ResizablePMCArray"
    push $P1003, "self"
    .return ($P1003)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("210_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1007_tgt
    .local int rx1007_pos
    .local int rx1007_off
    .local int rx1007_eos
    .local int rx1007_rep
    .local pmc rx1007_cur
    .local pmc rx1007_debug
    (rx1007_cur, rx1007_pos, rx1007_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1007_cur
    .local pmc match
    .lex "$/", match
    length rx1007_eos, rx1007_tgt
    gt rx1007_pos, rx1007_eos, rx1007_done
    set rx1007_off, 0
    lt rx1007_pos, 2, rx1007_start
    sub rx1007_off, rx1007_pos, 1
    substr rx1007_tgt, rx1007_tgt, rx1007_off
  rx1007_start:
    eq $I10, 1, rx1007_restart
    if_null rx1007_debug, debug_790
    rx1007_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_790:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1011_done
    goto rxscan1011_scan
  rxscan1011_loop:
    (rx1007_pos) = rx1007_cur."from"()
    inc rx1007_pos
    rx1007_cur."!cursor_from"(rx1007_pos)
    ge rx1007_pos, rx1007_eos, rxscan1011_done
  rxscan1011_scan:
    set_addr $I10, rxscan1011_loop
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
  rxscan1011_done:
.annotate 'line', 460
  # rx subrule "deflongname" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."deflongname"()
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1007_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1007_pos, rx1007_off
    substr $S10, rx1007_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1007_fail
  # rx subrule "args" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."args"()
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1007_pos = $P10."pos"()
.annotate 'line', 459
  # rx pass
    rx1007_cur."!cursor_pass"(rx1007_pos, "term:sym<identifier>")
    if_null rx1007_debug, debug_791
    rx1007_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1007_pos)
  debug_791:
    .return (rx1007_cur)
  rx1007_restart:
.annotate 'line', 4
    if_null rx1007_debug, debug_792
    rx1007_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_792:
  rx1007_fail:
    (rx1007_rep, rx1007_pos, $I10, $P10) = rx1007_cur."!mark_fail"(0)
    lt rx1007_pos, -1, rx1007_done
    eq rx1007_pos, -1, rx1007_fail
    jump $I10
  rx1007_done:
    rx1007_cur."!cursor_fail"()
    if_null rx1007_debug, debug_793
    rx1007_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_793:
    .return (rx1007_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("211_1296306519.49046") :method
.annotate 'line', 4
    $P1009 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1010, "ResizablePMCArray"
    push $P1010, $P1009
    .return ($P1010)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("212_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1013_tgt
    .local int rx1013_pos
    .local int rx1013_off
    .local int rx1013_eos
    .local int rx1013_rep
    .local pmc rx1013_cur
    .local pmc rx1013_debug
    (rx1013_cur, rx1013_pos, rx1013_tgt, $I10) = self."!cursor_start"()
    rx1013_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1013_cur
    .local pmc match
    .lex "$/", match
    length rx1013_eos, rx1013_tgt
    gt rx1013_pos, rx1013_eos, rx1013_done
    set rx1013_off, 0
    lt rx1013_pos, 2, rx1013_start
    sub rx1013_off, rx1013_pos, 1
    substr rx1013_tgt, rx1013_tgt, rx1013_off
  rx1013_start:
    eq $I10, 1, rx1013_restart
    if_null rx1013_debug, debug_794
    rx1013_cur."!cursor_debug"("START", "term:sym<name>")
  debug_794:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1017_done
    goto rxscan1017_scan
  rxscan1017_loop:
    (rx1013_pos) = rx1013_cur."from"()
    inc rx1013_pos
    rx1013_cur."!cursor_from"(rx1013_pos)
    ge rx1013_pos, rx1013_eos, rxscan1017_done
  rxscan1017_scan:
    set_addr $I10, rxscan1017_loop
    rx1013_cur."!mark_push"(0, rx1013_pos, $I10)
  rxscan1017_done:
.annotate 'line', 464
  # rx subrule "name" subtype=capture negate=
    rx1013_cur."!cursor_pos"(rx1013_pos)
    $P10 = rx1013_cur."name"()
    unless $P10, rx1013_fail
    rx1013_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1013_pos = $P10."pos"()
  # rx rxquantr1018 ** 0..1
    set_addr $I10, rxquantr1018_done
    rx1013_cur."!mark_push"(0, rx1013_pos, $I10)
  rxquantr1018_loop:
  # rx subrule "args" subtype=capture negate=
    rx1013_cur."!cursor_pos"(rx1013_pos)
    $P10 = rx1013_cur."args"()
    unless $P10, rx1013_fail
    goto rxsubrule1019_pass
  rxsubrule1019_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1013_fail
  rxsubrule1019_pass:
    set_addr $I10, rxsubrule1019_back
    rx1013_cur."!mark_push"(0, rx1013_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1013_pos = $P10."pos"()
    set_addr $I10, rxquantr1018_done
    (rx1013_rep) = rx1013_cur."!mark_commit"($I10)
  rxquantr1018_done:
.annotate 'line', 463
  # rx pass
    rx1013_cur."!cursor_pass"(rx1013_pos, "term:sym<name>")
    if_null rx1013_debug, debug_795
    rx1013_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1013_pos)
  debug_795:
    .return (rx1013_cur)
  rx1013_restart:
.annotate 'line', 4
    if_null rx1013_debug, debug_796
    rx1013_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_796:
  rx1013_fail:
    (rx1013_rep, rx1013_pos, $I10, $P10) = rx1013_cur."!mark_fail"(0)
    lt rx1013_pos, -1, rx1013_done
    eq rx1013_pos, -1, rx1013_fail
    jump $I10
  rx1013_done:
    rx1013_cur."!cursor_fail"()
    if_null rx1013_debug, debug_797
    rx1013_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_797:
    .return (rx1013_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("213_1296306519.49046") :method
.annotate 'line', 4
    $P1015 = self."!PREFIX__!subrule"("name", "")
    new $P1016, "ResizablePMCArray"
    push $P1016, $P1015
    .return ($P1016)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("214_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1021_tgt
    .local int rx1021_pos
    .local int rx1021_off
    .local int rx1021_eos
    .local int rx1021_rep
    .local pmc rx1021_cur
    .local pmc rx1021_debug
    (rx1021_cur, rx1021_pos, rx1021_tgt, $I10) = self."!cursor_start"()
    rx1021_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1021_cur
    .local pmc match
    .lex "$/", match
    length rx1021_eos, rx1021_tgt
    gt rx1021_pos, rx1021_eos, rx1021_done
    set rx1021_off, 0
    lt rx1021_pos, 2, rx1021_start
    sub rx1021_off, rx1021_pos, 1
    substr rx1021_tgt, rx1021_tgt, rx1021_off
  rx1021_start:
    eq $I10, 1, rx1021_restart
    if_null rx1021_debug, debug_798
    rx1021_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_798:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1024_done
    goto rxscan1024_scan
  rxscan1024_loop:
    (rx1021_pos) = rx1021_cur."from"()
    inc rx1021_pos
    rx1021_cur."!cursor_from"(rx1021_pos)
    ge rx1021_pos, rx1021_eos, rxscan1024_done
  rxscan1024_scan:
    set_addr $I10, rxscan1024_loop
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  rxscan1024_done:
.annotate 'line', 468
  # rx literal  "pir::"
    add $I11, rx1021_pos, 5
    gt $I11, rx1021_eos, rx1021_fail
    sub $I11, rx1021_pos, rx1021_off
    substr $S10, rx1021_tgt, $I11, 5
    ne $S10, "pir::", rx1021_fail
    add rx1021_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1025_fail
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1021_pos, rx1021_off
    find_not_cclass $I11, 8192, rx1021_tgt, $I10, rx1021_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1021_fail
    add rx1021_pos, rx1021_off, $I11
    set_addr $I10, rxcap_1025_fail
    ($I12, $I11) = rx1021_cur."!mark_peek"($I10)
    rx1021_cur."!cursor_pos"($I11)
    ($P10) = rx1021_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1021_pos, "")
    rx1021_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1025_done
  rxcap_1025_fail:
    goto rx1021_fail
  rxcap_1025_done:
  # rx rxquantr1026 ** 0..1
    set_addr $I10, rxquantr1026_done
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10)
  rxquantr1026_loop:
  # rx subrule "args" subtype=capture negate=
    rx1021_cur."!cursor_pos"(rx1021_pos)
    $P10 = rx1021_cur."args"()
    unless $P10, rx1021_fail
    goto rxsubrule1027_pass
  rxsubrule1027_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1021_fail
  rxsubrule1027_pass:
    set_addr $I10, rxsubrule1027_back
    rx1021_cur."!mark_push"(0, rx1021_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1021_pos = $P10."pos"()
    set_addr $I10, rxquantr1026_done
    (rx1021_rep) = rx1021_cur."!mark_commit"($I10)
  rxquantr1026_done:
.annotate 'line', 467
  # rx pass
    rx1021_cur."!cursor_pass"(rx1021_pos, "term:sym<pir::op>")
    if_null rx1021_debug, debug_799
    rx1021_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1021_pos)
  debug_799:
    .return (rx1021_cur)
  rx1021_restart:
.annotate 'line', 4
    if_null rx1021_debug, debug_800
    rx1021_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_800:
  rx1021_fail:
    (rx1021_rep, rx1021_pos, $I10, $P10) = rx1021_cur."!mark_fail"(0)
    lt rx1021_pos, -1, rx1021_done
    eq rx1021_pos, -1, rx1021_fail
    jump $I10
  rx1021_done:
    rx1021_cur."!cursor_fail"()
    if_null rx1021_debug, debug_801
    rx1021_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_801:
    .return (rx1021_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("215_1296306519.49046") :method
.annotate 'line', 4
    new $P1023, "ResizablePMCArray"
    push $P1023, "pir::"
    .return ($P1023)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("216_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P1037 = "218_1296306519.49046" 
    capture_lex $P1037
    .local string rx1029_tgt
    .local int rx1029_pos
    .local int rx1029_off
    .local int rx1029_eos
    .local int rx1029_rep
    .local pmc rx1029_cur
    .local pmc rx1029_debug
    (rx1029_cur, rx1029_pos, rx1029_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1029_cur
    .local pmc match
    .lex "$/", match
    length rx1029_eos, rx1029_tgt
    gt rx1029_pos, rx1029_eos, rx1029_done
    set rx1029_off, 0
    lt rx1029_pos, 2, rx1029_start
    sub rx1029_off, rx1029_pos, 1
    substr rx1029_tgt, rx1029_tgt, rx1029_off
  rx1029_start:
    eq $I10, 1, rx1029_restart
    if_null rx1029_debug, debug_802
    rx1029_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_802:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1032_done
    goto rxscan1032_scan
  rxscan1032_loop:
    (rx1029_pos) = rx1029_cur."from"()
    inc rx1029_pos
    rx1029_cur."!cursor_from"(rx1029_pos)
    ge rx1029_pos, rx1029_eos, rxscan1032_done
  rxscan1032_scan:
    set_addr $I10, rxscan1032_loop
    rx1029_cur."!mark_push"(0, rx1029_pos, $I10)
  rxscan1032_done:
.annotate 'line', 472
  # rx literal  "{*}"
    add $I11, rx1029_pos, 3
    gt $I11, rx1029_eos, rx1029_fail
    sub $I11, rx1029_pos, rx1029_off
    substr $S10, rx1029_tgt, $I11, 3
    ne $S10, "{*}", rx1029_fail
    add rx1029_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1029_cur."!cursor_pos"(rx1029_pos)
    $P10 = rx1029_cur."ENDSTMT"()
    unless $P10, rx1029_fail
  alt1033_0:
.annotate 'line', 473
    set_addr $I10, alt1033_1
    rx1029_cur."!mark_push"(0, rx1029_pos, $I10)
    rx1029_cur."!cursor_pos"(rx1029_pos)
    find_lex $P1034, unicode:"$\x{a2}"
    $P1035 = $P1034."MATCH"()
    store_lex "$/", $P1035
    .const 'Sub' $P1037 = "218_1296306519.49046" 
    capture_lex $P1037
    $P1041 = $P1037()
    unless $P1041, rx1029_fail
    goto alt1033_end
  alt1033_1:
  # rx subrule "panic" subtype=method negate=
    rx1029_cur."!cursor_pos"(rx1029_pos)
    $P10 = rx1029_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1029_fail
    rx1029_pos = $P10."pos"()
  alt1033_end:
.annotate 'line', 471
  # rx pass
    rx1029_cur."!cursor_pass"(rx1029_pos, "term:sym<onlystar>")
    if_null rx1029_debug, debug_805
    rx1029_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1029_pos)
  debug_805:
    .return (rx1029_cur)
  rx1029_restart:
.annotate 'line', 4
    if_null rx1029_debug, debug_806
    rx1029_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_806:
  rx1029_fail:
    (rx1029_rep, rx1029_pos, $I10, $P10) = rx1029_cur."!mark_fail"(0)
    lt rx1029_pos, -1, rx1029_done
    eq rx1029_pos, -1, rx1029_fail
    jump $I10
  rx1029_done:
    rx1029_cur."!cursor_fail"()
    if_null rx1029_debug, debug_807
    rx1029_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_807:
    .return (rx1029_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("217_1296306519.49046") :method
.annotate 'line', 4
    new $P1031, "ResizablePMCArray"
    push $P1031, "{*}"
    .return ($P1031)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1036"  :anon :subid("218_1296306519.49046") :outer("216_1296306519.49046")
.annotate 'line', 473
    find_dynamic_lex $P1038, "$*MULTINESS"
    unless_null $P1038, vivify_803
    get_hll_global $P1038, "$MULTINESS"
    unless_null $P1038, vivify_804
    die "Contextual $*MULTINESS not found"
  vivify_804:
  vivify_803:
    set $S1039, $P1038
    iseq $I1040, $S1039, "proto"
    .return ($I1040)
.end


.namespace ["NQP";"Grammar"]
.sub "args"  :subid("219_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1043_tgt
    .local int rx1043_pos
    .local int rx1043_off
    .local int rx1043_eos
    .local int rx1043_rep
    .local pmc rx1043_cur
    .local pmc rx1043_debug
    (rx1043_cur, rx1043_pos, rx1043_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1043_cur
    .local pmc match
    .lex "$/", match
    length rx1043_eos, rx1043_tgt
    gt rx1043_pos, rx1043_eos, rx1043_done
    set rx1043_off, 0
    lt rx1043_pos, 2, rx1043_start
    sub rx1043_off, rx1043_pos, 1
    substr rx1043_tgt, rx1043_tgt, rx1043_off
  rx1043_start:
    eq $I10, 1, rx1043_restart
    if_null rx1043_debug, debug_808
    rx1043_cur."!cursor_debug"("START", "args")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1047_done
    goto rxscan1047_scan
  rxscan1047_loop:
    (rx1043_pos) = rx1043_cur."from"()
    inc rx1043_pos
    rx1043_cur."!cursor_from"(rx1043_pos)
    ge rx1043_pos, rx1043_eos, rxscan1047_done
  rxscan1047_scan:
    set_addr $I10, rxscan1047_loop
    rx1043_cur."!mark_push"(0, rx1043_pos, $I10)
  rxscan1047_done:
.annotate 'line', 477
  # rx literal  "("
    add $I11, rx1043_pos, 1
    gt $I11, rx1043_eos, rx1043_fail
    sub $I11, rx1043_pos, rx1043_off
    ord $I11, rx1043_tgt, $I11
    ne $I11, 40, rx1043_fail
    add rx1043_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1043_cur."!cursor_pos"(rx1043_pos)
    $P10 = rx1043_cur."arglist"()
    unless $P10, rx1043_fail
    rx1043_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1043_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1043_pos, 1
    gt $I11, rx1043_eos, rx1043_fail
    sub $I11, rx1043_pos, rx1043_off
    ord $I11, rx1043_tgt, $I11
    ne $I11, 41, rx1043_fail
    add rx1043_pos, 1
  # rx pass
    rx1043_cur."!cursor_pass"(rx1043_pos, "args")
    if_null rx1043_debug, debug_809
    rx1043_cur."!cursor_debug"("PASS", "args", " at pos=", rx1043_pos)
  debug_809:
    .return (rx1043_cur)
  rx1043_restart:
.annotate 'line', 4
    if_null rx1043_debug, debug_810
    rx1043_cur."!cursor_debug"("NEXT", "args")
  debug_810:
  rx1043_fail:
    (rx1043_rep, rx1043_pos, $I10, $P10) = rx1043_cur."!mark_fail"(0)
    lt rx1043_pos, -1, rx1043_done
    eq rx1043_pos, -1, rx1043_fail
    jump $I10
  rx1043_done:
    rx1043_cur."!cursor_fail"()
    if_null rx1043_debug, debug_811
    rx1043_cur."!cursor_debug"("FAIL", "args")
  debug_811:
    .return (rx1043_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("220_1296306519.49046") :method
.annotate 'line', 4
    $P1045 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1046, "ResizablePMCArray"
    push $P1046, $P1045
    .return ($P1046)
.end


.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("221_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1049_tgt
    .local int rx1049_pos
    .local int rx1049_off
    .local int rx1049_eos
    .local int rx1049_rep
    .local pmc rx1049_cur
    .local pmc rx1049_debug
    (rx1049_cur, rx1049_pos, rx1049_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1049_cur
    .local pmc match
    .lex "$/", match
    length rx1049_eos, rx1049_tgt
    gt rx1049_pos, rx1049_eos, rx1049_done
    set rx1049_off, 0
    lt rx1049_pos, 2, rx1049_start
    sub rx1049_off, rx1049_pos, 1
    substr rx1049_tgt, rx1049_tgt, rx1049_off
  rx1049_start:
    eq $I10, 1, rx1049_restart
    if_null rx1049_debug, debug_812
    rx1049_cur."!cursor_debug"("START", "arglist")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1053_done
    goto rxscan1053_scan
  rxscan1053_loop:
    (rx1049_pos) = rx1049_cur."from"()
    inc rx1049_pos
    rx1049_cur."!cursor_from"(rx1049_pos)
    ge rx1049_pos, rx1049_eos, rxscan1053_done
  rxscan1053_scan:
    set_addr $I10, rxscan1053_loop
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
  rxscan1053_done:
.annotate 'line', 481
  # rx subrule "ws" subtype=method negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."ws"()
    unless $P10, rx1049_fail
    rx1049_pos = $P10."pos"()
  alt1054_0:
.annotate 'line', 482
    set_addr $I10, alt1054_1
    rx1049_cur."!mark_push"(0, rx1049_pos, $I10)
.annotate 'line', 483
  # rx subrule "EXPR" subtype=capture negate=
    rx1049_cur."!cursor_pos"(rx1049_pos)
    $P10 = rx1049_cur."EXPR"("f=")
    unless $P10, rx1049_fail
    rx1049_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1049_pos = $P10."pos"()
    goto alt1054_end
  alt1054_1:
  alt1054_end:
.annotate 'line', 480
  # rx pass
    rx1049_cur."!cursor_pass"(rx1049_pos, "arglist")
    if_null rx1049_debug, debug_813
    rx1049_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1049_pos)
  debug_813:
    .return (rx1049_cur)
  rx1049_restart:
.annotate 'line', 4
    if_null rx1049_debug, debug_814
    rx1049_cur."!cursor_debug"("NEXT", "arglist")
  debug_814:
  rx1049_fail:
    (rx1049_rep, rx1049_pos, $I10, $P10) = rx1049_cur."!mark_fail"(0)
    lt rx1049_pos, -1, rx1049_done
    eq rx1049_pos, -1, rx1049_fail
    jump $I10
  rx1049_done:
    rx1049_cur."!cursor_fail"()
    if_null rx1049_debug, debug_815
    rx1049_cur."!cursor_debug"("FAIL", "arglist")
  debug_815:
    .return (rx1049_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("222_1296306519.49046") :method
.annotate 'line', 4
    $P1051 = self."!PREFIX__!subrule"("ws", "")
    new $P1052, "ResizablePMCArray"
    push $P1052, $P1051
    .return ($P1052)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("223_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1056_tgt
    .local int rx1056_pos
    .local int rx1056_off
    .local int rx1056_eos
    .local int rx1056_rep
    .local pmc rx1056_cur
    .local pmc rx1056_debug
    (rx1056_cur, rx1056_pos, rx1056_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1056_cur
    .local pmc match
    .lex "$/", match
    length rx1056_eos, rx1056_tgt
    gt rx1056_pos, rx1056_eos, rx1056_done
    set rx1056_off, 0
    lt rx1056_pos, 2, rx1056_start
    sub rx1056_off, rx1056_pos, 1
    substr rx1056_tgt, rx1056_tgt, rx1056_off
  rx1056_start:
    eq $I10, 1, rx1056_restart
    if_null rx1056_debug, debug_816
    rx1056_cur."!cursor_debug"("START", "term:sym<value>")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1060_done
    goto rxscan1060_scan
  rxscan1060_loop:
    (rx1056_pos) = rx1056_cur."from"()
    inc rx1056_pos
    rx1056_cur."!cursor_from"(rx1056_pos)
    ge rx1056_pos, rx1056_eos, rxscan1060_done
  rxscan1060_scan:
    set_addr $I10, rxscan1060_loop
    rx1056_cur."!mark_push"(0, rx1056_pos, $I10)
  rxscan1060_done:
.annotate 'line', 489
  # rx subrule "value" subtype=capture negate=
    rx1056_cur."!cursor_pos"(rx1056_pos)
    $P10 = rx1056_cur."value"()
    unless $P10, rx1056_fail
    rx1056_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1056_pos = $P10."pos"()
  # rx pass
    rx1056_cur."!cursor_pass"(rx1056_pos, "term:sym<value>")
    if_null rx1056_debug, debug_817
    rx1056_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1056_pos)
  debug_817:
    .return (rx1056_cur)
  rx1056_restart:
.annotate 'line', 4
    if_null rx1056_debug, debug_818
    rx1056_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_818:
  rx1056_fail:
    (rx1056_rep, rx1056_pos, $I10, $P10) = rx1056_cur."!mark_fail"(0)
    lt rx1056_pos, -1, rx1056_done
    eq rx1056_pos, -1, rx1056_fail
    jump $I10
  rx1056_done:
    rx1056_cur."!cursor_fail"()
    if_null rx1056_debug, debug_819
    rx1056_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_819:
    .return (rx1056_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("224_1296306519.49046") :method
.annotate 'line', 4
    $P1058 = self."!PREFIX__!subrule"("value", "")
    new $P1059, "ResizablePMCArray"
    push $P1059, $P1058
    .return ($P1059)
.end


.namespace ["NQP";"Grammar"]
.sub "value"  :subid("225_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1062_tgt
    .local int rx1062_pos
    .local int rx1062_off
    .local int rx1062_eos
    .local int rx1062_rep
    .local pmc rx1062_cur
    .local pmc rx1062_debug
    (rx1062_cur, rx1062_pos, rx1062_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1062_cur
    .local pmc match
    .lex "$/", match
    length rx1062_eos, rx1062_tgt
    gt rx1062_pos, rx1062_eos, rx1062_done
    set rx1062_off, 0
    lt rx1062_pos, 2, rx1062_start
    sub rx1062_off, rx1062_pos, 1
    substr rx1062_tgt, rx1062_tgt, rx1062_off
  rx1062_start:
    eq $I10, 1, rx1062_restart
    if_null rx1062_debug, debug_820
    rx1062_cur."!cursor_debug"("START", "value")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1067_done
    goto rxscan1067_scan
  rxscan1067_loop:
    (rx1062_pos) = rx1062_cur."from"()
    inc rx1062_pos
    rx1062_cur."!cursor_from"(rx1062_pos)
    ge rx1062_pos, rx1062_eos, rxscan1067_done
  rxscan1067_scan:
    set_addr $I10, rxscan1067_loop
    rx1062_cur."!mark_push"(0, rx1062_pos, $I10)
  rxscan1067_done:
  alt1068_0:
.annotate 'line', 491
    set_addr $I10, alt1068_1
    rx1062_cur."!mark_push"(0, rx1062_pos, $I10)
.annotate 'line', 492
  # rx subrule "quote" subtype=capture negate=
    rx1062_cur."!cursor_pos"(rx1062_pos)
    $P10 = rx1062_cur."quote"()
    unless $P10, rx1062_fail
    rx1062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1062_pos = $P10."pos"()
    goto alt1068_end
  alt1068_1:
.annotate 'line', 493
  # rx subrule "number" subtype=capture negate=
    rx1062_cur."!cursor_pos"(rx1062_pos)
    $P10 = rx1062_cur."number"()
    unless $P10, rx1062_fail
    rx1062_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1062_pos = $P10."pos"()
  alt1068_end:
.annotate 'line', 491
  # rx pass
    rx1062_cur."!cursor_pass"(rx1062_pos, "value")
    if_null rx1062_debug, debug_821
    rx1062_cur."!cursor_debug"("PASS", "value", " at pos=", rx1062_pos)
  debug_821:
    .return (rx1062_cur)
  rx1062_restart:
.annotate 'line', 4
    if_null rx1062_debug, debug_822
    rx1062_cur."!cursor_debug"("NEXT", "value")
  debug_822:
  rx1062_fail:
    (rx1062_rep, rx1062_pos, $I10, $P10) = rx1062_cur."!mark_fail"(0)
    lt rx1062_pos, -1, rx1062_done
    eq rx1062_pos, -1, rx1062_fail
    jump $I10
  rx1062_done:
    rx1062_cur."!cursor_fail"()
    if_null rx1062_debug, debug_823
    rx1062_cur."!cursor_debug"("FAIL", "value")
  debug_823:
    .return (rx1062_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("226_1296306519.49046") :method
.annotate 'line', 4
    $P1064 = self."!PREFIX__!subrule"("number", "")
    $P1065 = self."!PREFIX__!subrule"("quote", "")
    new $P1066, "ResizablePMCArray"
    push $P1066, $P1064
    push $P1066, $P1065
    .return ($P1066)
.end


.namespace ["NQP";"Grammar"]
.sub "number"  :subid("227_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1070_tgt
    .local int rx1070_pos
    .local int rx1070_off
    .local int rx1070_eos
    .local int rx1070_rep
    .local pmc rx1070_cur
    .local pmc rx1070_debug
    (rx1070_cur, rx1070_pos, rx1070_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1070_cur
    .local pmc match
    .lex "$/", match
    length rx1070_eos, rx1070_tgt
    gt rx1070_pos, rx1070_eos, rx1070_done
    set rx1070_off, 0
    lt rx1070_pos, 2, rx1070_start
    sub rx1070_off, rx1070_pos, 1
    substr rx1070_tgt, rx1070_tgt, rx1070_off
  rx1070_start:
    eq $I10, 1, rx1070_restart
    if_null rx1070_debug, debug_824
    rx1070_cur."!cursor_debug"("START", "number")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1073_done
    goto rxscan1073_scan
  rxscan1073_loop:
    (rx1070_pos) = rx1070_cur."from"()
    inc rx1070_pos
    rx1070_cur."!cursor_from"(rx1070_pos)
    ge rx1070_pos, rx1070_eos, rxscan1073_done
  rxscan1073_scan:
    set_addr $I10, rxscan1073_loop
    rx1070_cur."!mark_push"(0, rx1070_pos, $I10)
  rxscan1073_done:
.annotate 'line', 497
  # rx subcapture "sign"
    set_addr $I10, rxcap_1075_fail
    rx1070_cur."!mark_push"(0, rx1070_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1070_pos, rx1070_off
    set rx1070_rep, 0
    sub $I12, rx1070_eos, rx1070_pos
    le $I12, 1, rxenumcharlistq1074_loop
    set $I12, 1
  rxenumcharlistq1074_loop:
    le $I12, 0, rxenumcharlistq1074_done
    substr $S10, rx1070_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1074_done
    inc rx1070_rep
  rxenumcharlistq1074_done:
    add rx1070_pos, rx1070_pos, rx1070_rep
    set_addr $I10, rxcap_1075_fail
    ($I12, $I11) = rx1070_cur."!mark_peek"($I10)
    rx1070_cur."!cursor_pos"($I11)
    ($P10) = rx1070_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1070_pos, "")
    rx1070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1075_done
  rxcap_1075_fail:
    goto rx1070_fail
  rxcap_1075_done:
  alt1076_0:
.annotate 'line', 498
    set_addr $I10, alt1076_1
    rx1070_cur."!mark_push"(0, rx1070_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1070_cur."!cursor_pos"(rx1070_pos)
    $P10 = rx1070_cur."dec_number"()
    unless $P10, rx1070_fail
    rx1070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1070_pos = $P10."pos"()
    goto alt1076_end
  alt1076_1:
  # rx subrule "integer" subtype=capture negate=
    rx1070_cur."!cursor_pos"(rx1070_pos)
    $P10 = rx1070_cur."integer"()
    unless $P10, rx1070_fail
    rx1070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1070_pos = $P10."pos"()
  alt1076_end:
.annotate 'line', 496
  # rx pass
    rx1070_cur."!cursor_pass"(rx1070_pos, "number")
    if_null rx1070_debug, debug_825
    rx1070_cur."!cursor_debug"("PASS", "number", " at pos=", rx1070_pos)
  debug_825:
    .return (rx1070_cur)
  rx1070_restart:
.annotate 'line', 4
    if_null rx1070_debug, debug_826
    rx1070_cur."!cursor_debug"("NEXT", "number")
  debug_826:
  rx1070_fail:
    (rx1070_rep, rx1070_pos, $I10, $P10) = rx1070_cur."!mark_fail"(0)
    lt rx1070_pos, -1, rx1070_done
    eq rx1070_pos, -1, rx1070_fail
    jump $I10
  rx1070_done:
    rx1070_cur."!cursor_fail"()
    if_null rx1070_debug, debug_827
    rx1070_cur."!cursor_debug"("FAIL", "number")
  debug_827:
    .return (rx1070_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("228_1296306519.49046") :method
.annotate 'line', 4
    new $P1072, "ResizablePMCArray"
    push $P1072, ""
    .return ($P1072)
.end


.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("229_1296306519.49046")
    .param pmc param_1078
.annotate 'line', 501
    .lex "self", param_1078
    $P1079 = param_1078."!protoregex"("quote")
    .return ($P1079)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("230_1296306519.49046")
    .param pmc param_1081
.annotate 'line', 501
    .lex "self", param_1081
    $P1082 = param_1081."!PREFIX__!protoregex"("quote")
    .return ($P1082)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("231_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1084_tgt
    .local int rx1084_pos
    .local int rx1084_off
    .local int rx1084_eos
    .local int rx1084_rep
    .local pmc rx1084_cur
    .local pmc rx1084_debug
    (rx1084_cur, rx1084_pos, rx1084_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1084_cur
    .local pmc match
    .lex "$/", match
    length rx1084_eos, rx1084_tgt
    gt rx1084_pos, rx1084_eos, rx1084_done
    set rx1084_off, 0
    lt rx1084_pos, 2, rx1084_start
    sub rx1084_off, rx1084_pos, 1
    substr rx1084_tgt, rx1084_tgt, rx1084_off
  rx1084_start:
    eq $I10, 1, rx1084_restart
    if_null rx1084_debug, debug_828
    rx1084_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1087_done
    goto rxscan1087_scan
  rxscan1087_loop:
    (rx1084_pos) = rx1084_cur."from"()
    inc rx1084_pos
    rx1084_cur."!cursor_from"(rx1084_pos)
    ge rx1084_pos, rx1084_eos, rxscan1087_done
  rxscan1087_scan:
    set_addr $I10, rxscan1087_loop
    rx1084_cur."!mark_push"(0, rx1084_pos, $I10)
  rxscan1087_done:
.annotate 'line', 502
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1084_pos, rx1084_off
    substr $S10, rx1084_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1084_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1084_cur."!cursor_pos"(rx1084_pos)
    $P10 = rx1084_cur."quote_EXPR"(":q")
    unless $P10, rx1084_fail
    rx1084_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1084_pos = $P10."pos"()
  # rx pass
    rx1084_cur."!cursor_pass"(rx1084_pos, "quote:sym<apos>")
    if_null rx1084_debug, debug_829
    rx1084_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1084_pos)
  debug_829:
    .return (rx1084_cur)
  rx1084_restart:
.annotate 'line', 4
    if_null rx1084_debug, debug_830
    rx1084_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_830:
  rx1084_fail:
    (rx1084_rep, rx1084_pos, $I10, $P10) = rx1084_cur."!mark_fail"(0)
    lt rx1084_pos, -1, rx1084_done
    eq rx1084_pos, -1, rx1084_fail
    jump $I10
  rx1084_done:
    rx1084_cur."!cursor_fail"()
    if_null rx1084_debug, debug_831
    rx1084_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_831:
    .return (rx1084_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("232_1296306519.49046") :method
.annotate 'line', 4
    new $P1086, "ResizablePMCArray"
    push $P1086, "'"
    .return ($P1086)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("233_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1089_tgt
    .local int rx1089_pos
    .local int rx1089_off
    .local int rx1089_eos
    .local int rx1089_rep
    .local pmc rx1089_cur
    .local pmc rx1089_debug
    (rx1089_cur, rx1089_pos, rx1089_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1089_cur
    .local pmc match
    .lex "$/", match
    length rx1089_eos, rx1089_tgt
    gt rx1089_pos, rx1089_eos, rx1089_done
    set rx1089_off, 0
    lt rx1089_pos, 2, rx1089_start
    sub rx1089_off, rx1089_pos, 1
    substr rx1089_tgt, rx1089_tgt, rx1089_off
  rx1089_start:
    eq $I10, 1, rx1089_restart
    if_null rx1089_debug, debug_832
    rx1089_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1092_done
    goto rxscan1092_scan
  rxscan1092_loop:
    (rx1089_pos) = rx1089_cur."from"()
    inc rx1089_pos
    rx1089_cur."!cursor_from"(rx1089_pos)
    ge rx1089_pos, rx1089_eos, rxscan1092_done
  rxscan1092_scan:
    set_addr $I10, rxscan1092_loop
    rx1089_cur."!mark_push"(0, rx1089_pos, $I10)
  rxscan1092_done:
.annotate 'line', 503
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1089_pos, rx1089_off
    substr $S10, rx1089_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1089_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1089_cur."!cursor_pos"(rx1089_pos)
    $P10 = rx1089_cur."quote_EXPR"(":qq")
    unless $P10, rx1089_fail
    rx1089_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1089_pos = $P10."pos"()
  # rx pass
    rx1089_cur."!cursor_pass"(rx1089_pos, "quote:sym<dblq>")
    if_null rx1089_debug, debug_833
    rx1089_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1089_pos)
  debug_833:
    .return (rx1089_cur)
  rx1089_restart:
.annotate 'line', 4
    if_null rx1089_debug, debug_834
    rx1089_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_834:
  rx1089_fail:
    (rx1089_rep, rx1089_pos, $I10, $P10) = rx1089_cur."!mark_fail"(0)
    lt rx1089_pos, -1, rx1089_done
    eq rx1089_pos, -1, rx1089_fail
    jump $I10
  rx1089_done:
    rx1089_cur."!cursor_fail"()
    if_null rx1089_debug, debug_835
    rx1089_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_835:
    .return (rx1089_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("234_1296306519.49046") :method
.annotate 'line', 4
    new $P1091, "ResizablePMCArray"
    push $P1091, "\""
    .return ($P1091)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("235_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1094_tgt
    .local int rx1094_pos
    .local int rx1094_off
    .local int rx1094_eos
    .local int rx1094_rep
    .local pmc rx1094_cur
    .local pmc rx1094_debug
    (rx1094_cur, rx1094_pos, rx1094_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1094_cur
    .local pmc match
    .lex "$/", match
    length rx1094_eos, rx1094_tgt
    gt rx1094_pos, rx1094_eos, rx1094_done
    set rx1094_off, 0
    lt rx1094_pos, 2, rx1094_start
    sub rx1094_off, rx1094_pos, 1
    substr rx1094_tgt, rx1094_tgt, rx1094_off
  rx1094_start:
    eq $I10, 1, rx1094_restart
    if_null rx1094_debug, debug_836
    rx1094_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1098_done
    goto rxscan1098_scan
  rxscan1098_loop:
    (rx1094_pos) = rx1094_cur."from"()
    inc rx1094_pos
    rx1094_cur."!cursor_from"(rx1094_pos)
    ge rx1094_pos, rx1094_eos, rxscan1098_done
  rxscan1098_scan:
    set_addr $I10, rxscan1098_loop
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  rxscan1098_done:
.annotate 'line', 504
  # rx literal  "q"
    add $I11, rx1094_pos, 1
    gt $I11, rx1094_eos, rx1094_fail
    sub $I11, rx1094_pos, rx1094_off
    ord $I11, rx1094_tgt, $I11
    ne $I11, 113, rx1094_fail
    add rx1094_pos, 1
  # rxanchor rwb
    le rx1094_pos, 0, rx1094_fail
    sub $I10, rx1094_pos, rx1094_off
    is_cclass $I11, 8192, rx1094_tgt, $I10
    if $I11, rx1094_fail
    dec $I10
    is_cclass $I11, 8192, rx1094_tgt, $I10
    unless $I11, rx1094_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1094_pos, rx1094_off
    substr $S10, rx1094_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1094_fail
  # rx subrule "ws" subtype=method negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."ws"()
    unless $P10, rx1094_fail
    rx1094_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."quote_EXPR"(":q")
    unless $P10, rx1094_fail
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1094_pos = $P10."pos"()
  # rx pass
    rx1094_cur."!cursor_pass"(rx1094_pos, "quote:sym<q>")
    if_null rx1094_debug, debug_837
    rx1094_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1094_pos)
  debug_837:
    .return (rx1094_cur)
  rx1094_restart:
.annotate 'line', 4
    if_null rx1094_debug, debug_838
    rx1094_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_838:
  rx1094_fail:
    (rx1094_rep, rx1094_pos, $I10, $P10) = rx1094_cur."!mark_fail"(0)
    lt rx1094_pos, -1, rx1094_done
    eq rx1094_pos, -1, rx1094_fail
    jump $I10
  rx1094_done:
    rx1094_cur."!cursor_fail"()
    if_null rx1094_debug, debug_839
    rx1094_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_839:
    .return (rx1094_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("236_1296306519.49046") :method
.annotate 'line', 4
    $P1096 = self."!PREFIX__!subrule"("ws", "q")
    new $P1097, "ResizablePMCArray"
    push $P1097, $P1096
    .return ($P1097)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("237_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1100_tgt
    .local int rx1100_pos
    .local int rx1100_off
    .local int rx1100_eos
    .local int rx1100_rep
    .local pmc rx1100_cur
    .local pmc rx1100_debug
    (rx1100_cur, rx1100_pos, rx1100_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1100_cur
    .local pmc match
    .lex "$/", match
    length rx1100_eos, rx1100_tgt
    gt rx1100_pos, rx1100_eos, rx1100_done
    set rx1100_off, 0
    lt rx1100_pos, 2, rx1100_start
    sub rx1100_off, rx1100_pos, 1
    substr rx1100_tgt, rx1100_tgt, rx1100_off
  rx1100_start:
    eq $I10, 1, rx1100_restart
    if_null rx1100_debug, debug_840
    rx1100_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1104_done
    goto rxscan1104_scan
  rxscan1104_loop:
    (rx1100_pos) = rx1100_cur."from"()
    inc rx1100_pos
    rx1100_cur."!cursor_from"(rx1100_pos)
    ge rx1100_pos, rx1100_eos, rxscan1104_done
  rxscan1104_scan:
    set_addr $I10, rxscan1104_loop
    rx1100_cur."!mark_push"(0, rx1100_pos, $I10)
  rxscan1104_done:
.annotate 'line', 505
  # rx literal  "qq"
    add $I11, rx1100_pos, 2
    gt $I11, rx1100_eos, rx1100_fail
    sub $I11, rx1100_pos, rx1100_off
    substr $S10, rx1100_tgt, $I11, 2
    ne $S10, "qq", rx1100_fail
    add rx1100_pos, 2
  # rxanchor rwb
    le rx1100_pos, 0, rx1100_fail
    sub $I10, rx1100_pos, rx1100_off
    is_cclass $I11, 8192, rx1100_tgt, $I10
    if $I11, rx1100_fail
    dec $I10
    is_cclass $I11, 8192, rx1100_tgt, $I10
    unless $I11, rx1100_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1100_pos, rx1100_off
    substr $S10, rx1100_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1100_fail
  # rx subrule "ws" subtype=method negate=
    rx1100_cur."!cursor_pos"(rx1100_pos)
    $P10 = rx1100_cur."ws"()
    unless $P10, rx1100_fail
    rx1100_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1100_cur."!cursor_pos"(rx1100_pos)
    $P10 = rx1100_cur."quote_EXPR"(":qq")
    unless $P10, rx1100_fail
    rx1100_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1100_pos = $P10."pos"()
  # rx pass
    rx1100_cur."!cursor_pass"(rx1100_pos, "quote:sym<qq>")
    if_null rx1100_debug, debug_841
    rx1100_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1100_pos)
  debug_841:
    .return (rx1100_cur)
  rx1100_restart:
.annotate 'line', 4
    if_null rx1100_debug, debug_842
    rx1100_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_842:
  rx1100_fail:
    (rx1100_rep, rx1100_pos, $I10, $P10) = rx1100_cur."!mark_fail"(0)
    lt rx1100_pos, -1, rx1100_done
    eq rx1100_pos, -1, rx1100_fail
    jump $I10
  rx1100_done:
    rx1100_cur."!cursor_fail"()
    if_null rx1100_debug, debug_843
    rx1100_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_843:
    .return (rx1100_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("238_1296306519.49046") :method
.annotate 'line', 4
    $P1102 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1103, "ResizablePMCArray"
    push $P1103, $P1102
    .return ($P1103)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("239_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1106_tgt
    .local int rx1106_pos
    .local int rx1106_off
    .local int rx1106_eos
    .local int rx1106_rep
    .local pmc rx1106_cur
    .local pmc rx1106_debug
    (rx1106_cur, rx1106_pos, rx1106_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1106_cur
    .local pmc match
    .lex "$/", match
    length rx1106_eos, rx1106_tgt
    gt rx1106_pos, rx1106_eos, rx1106_done
    set rx1106_off, 0
    lt rx1106_pos, 2, rx1106_start
    sub rx1106_off, rx1106_pos, 1
    substr rx1106_tgt, rx1106_tgt, rx1106_off
  rx1106_start:
    eq $I10, 1, rx1106_restart
    if_null rx1106_debug, debug_844
    rx1106_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1110_done
    goto rxscan1110_scan
  rxscan1110_loop:
    (rx1106_pos) = rx1106_cur."from"()
    inc rx1106_pos
    rx1106_cur."!cursor_from"(rx1106_pos)
    ge rx1106_pos, rx1106_eos, rxscan1110_done
  rxscan1110_scan:
    set_addr $I10, rxscan1110_loop
    rx1106_cur."!mark_push"(0, rx1106_pos, $I10)
  rxscan1110_done:
.annotate 'line', 506
  # rx literal  "Q"
    add $I11, rx1106_pos, 1
    gt $I11, rx1106_eos, rx1106_fail
    sub $I11, rx1106_pos, rx1106_off
    ord $I11, rx1106_tgt, $I11
    ne $I11, 81, rx1106_fail
    add rx1106_pos, 1
  # rxanchor rwb
    le rx1106_pos, 0, rx1106_fail
    sub $I10, rx1106_pos, rx1106_off
    is_cclass $I11, 8192, rx1106_tgt, $I10
    if $I11, rx1106_fail
    dec $I10
    is_cclass $I11, 8192, rx1106_tgt, $I10
    unless $I11, rx1106_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1106_pos, rx1106_off
    substr $S10, rx1106_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1106_fail
  # rx subrule "ws" subtype=method negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."ws"()
    unless $P10, rx1106_fail
    rx1106_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."quote_EXPR"()
    unless $P10, rx1106_fail
    rx1106_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1106_pos = $P10."pos"()
  # rx pass
    rx1106_cur."!cursor_pass"(rx1106_pos, "quote:sym<Q>")
    if_null rx1106_debug, debug_845
    rx1106_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1106_pos)
  debug_845:
    .return (rx1106_cur)
  rx1106_restart:
.annotate 'line', 4
    if_null rx1106_debug, debug_846
    rx1106_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_846:
  rx1106_fail:
    (rx1106_rep, rx1106_pos, $I10, $P10) = rx1106_cur."!mark_fail"(0)
    lt rx1106_pos, -1, rx1106_done
    eq rx1106_pos, -1, rx1106_fail
    jump $I10
  rx1106_done:
    rx1106_cur."!cursor_fail"()
    if_null rx1106_debug, debug_847
    rx1106_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_847:
    .return (rx1106_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("240_1296306519.49046") :method
.annotate 'line', 4
    $P1108 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1109, "ResizablePMCArray"
    push $P1109, $P1108
    .return ($P1109)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("241_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1112_tgt
    .local int rx1112_pos
    .local int rx1112_off
    .local int rx1112_eos
    .local int rx1112_rep
    .local pmc rx1112_cur
    .local pmc rx1112_debug
    (rx1112_cur, rx1112_pos, rx1112_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1112_cur
    .local pmc match
    .lex "$/", match
    length rx1112_eos, rx1112_tgt
    gt rx1112_pos, rx1112_eos, rx1112_done
    set rx1112_off, 0
    lt rx1112_pos, 2, rx1112_start
    sub rx1112_off, rx1112_pos, 1
    substr rx1112_tgt, rx1112_tgt, rx1112_off
  rx1112_start:
    eq $I10, 1, rx1112_restart
    if_null rx1112_debug, debug_848
    rx1112_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1116_done
    goto rxscan1116_scan
  rxscan1116_loop:
    (rx1112_pos) = rx1112_cur."from"()
    inc rx1112_pos
    rx1112_cur."!cursor_from"(rx1112_pos)
    ge rx1112_pos, rx1112_eos, rxscan1116_done
  rxscan1116_scan:
    set_addr $I10, rxscan1116_loop
    rx1112_cur."!mark_push"(0, rx1112_pos, $I10)
  rxscan1116_done:
.annotate 'line', 507
  # rx literal  "Q:PIR"
    add $I11, rx1112_pos, 5
    gt $I11, rx1112_eos, rx1112_fail
    sub $I11, rx1112_pos, rx1112_off
    substr $S10, rx1112_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1112_fail
    add rx1112_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."ws"()
    unless $P10, rx1112_fail
    rx1112_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."quote_EXPR"()
    unless $P10, rx1112_fail
    rx1112_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1112_pos = $P10."pos"()
  # rx pass
    rx1112_cur."!cursor_pass"(rx1112_pos, "quote:sym<Q:PIR>")
    if_null rx1112_debug, debug_849
    rx1112_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1112_pos)
  debug_849:
    .return (rx1112_cur)
  rx1112_restart:
.annotate 'line', 4
    if_null rx1112_debug, debug_850
    rx1112_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_850:
  rx1112_fail:
    (rx1112_rep, rx1112_pos, $I10, $P10) = rx1112_cur."!mark_fail"(0)
    lt rx1112_pos, -1, rx1112_done
    eq rx1112_pos, -1, rx1112_fail
    jump $I10
  rx1112_done:
    rx1112_cur."!cursor_fail"()
    if_null rx1112_debug, debug_851
    rx1112_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_851:
    .return (rx1112_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("242_1296306519.49046") :method
.annotate 'line', 4
    $P1114 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1115, "ResizablePMCArray"
    push $P1115, $P1114
    .return ($P1115)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("243_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1118_tgt
    .local int rx1118_pos
    .local int rx1118_off
    .local int rx1118_eos
    .local int rx1118_rep
    .local pmc rx1118_cur
    .local pmc rx1118_debug
    (rx1118_cur, rx1118_pos, rx1118_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1118_cur
    .local pmc match
    .lex "$/", match
    length rx1118_eos, rx1118_tgt
    gt rx1118_pos, rx1118_eos, rx1118_done
    set rx1118_off, 0
    lt rx1118_pos, 2, rx1118_start
    sub rx1118_off, rx1118_pos, 1
    substr rx1118_tgt, rx1118_tgt, rx1118_off
  rx1118_start:
    eq $I10, 1, rx1118_restart
    if_null rx1118_debug, debug_852
    rx1118_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1122_done
    goto rxscan1122_scan
  rxscan1122_loop:
    (rx1118_pos) = rx1118_cur."from"()
    inc rx1118_pos
    rx1118_cur."!cursor_from"(rx1118_pos)
    ge rx1118_pos, rx1118_eos, rxscan1122_done
  rxscan1122_scan:
    set_addr $I10, rxscan1122_loop
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  rxscan1122_done:
.annotate 'line', 509
  # rx literal  "/"
    add $I11, rx1118_pos, 1
    gt $I11, rx1118_eos, rx1118_fail
    sub $I11, rx1118_pos, rx1118_off
    ord $I11, rx1118_tgt, $I11
    ne $I11, 47, rx1118_fail
    add rx1118_pos, 1
.annotate 'line', 510
  # rx subrule "newpad" subtype=method negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."newpad"()
    unless $P10, rx1118_fail
    rx1118_pos = $P10."pos"()
.annotate 'line', 511
  # rx reduce name="quote:sym</ />" key="open"
    rx1118_cur."!cursor_pos"(rx1118_pos)
    rx1118_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 512
  # rx subrule "LANG" subtype=capture negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1118_fail
    rx1118_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1118_pos = $P10."pos"()
.annotate 'line', 513
  # rx literal  "/"
    add $I11, rx1118_pos, 1
    gt $I11, rx1118_eos, rx1118_fail
    sub $I11, rx1118_pos, rx1118_off
    ord $I11, rx1118_tgt, $I11
    ne $I11, 47, rx1118_fail
    add rx1118_pos, 1
.annotate 'line', 508
  # rx pass
    rx1118_cur."!cursor_pass"(rx1118_pos, "quote:sym</ />")
    if_null rx1118_debug, debug_853
    rx1118_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1118_pos)
  debug_853:
    .return (rx1118_cur)
  rx1118_restart:
.annotate 'line', 4
    if_null rx1118_debug, debug_854
    rx1118_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_854:
  rx1118_fail:
    (rx1118_rep, rx1118_pos, $I10, $P10) = rx1118_cur."!mark_fail"(0)
    lt rx1118_pos, -1, rx1118_done
    eq rx1118_pos, -1, rx1118_fail
    jump $I10
  rx1118_done:
    rx1118_cur."!cursor_fail"()
    if_null rx1118_debug, debug_855
    rx1118_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_855:
    .return (rx1118_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("244_1296306519.49046") :method
.annotate 'line', 4
    $P1120 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1121, "ResizablePMCArray"
    push $P1121, $P1120
    .return ($P1121)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("245_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1124_tgt
    .local int rx1124_pos
    .local int rx1124_off
    .local int rx1124_eos
    .local int rx1124_rep
    .local pmc rx1124_cur
    .local pmc rx1124_debug
    (rx1124_cur, rx1124_pos, rx1124_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1124_cur
    .local pmc match
    .lex "$/", match
    length rx1124_eos, rx1124_tgt
    gt rx1124_pos, rx1124_eos, rx1124_done
    set rx1124_off, 0
    lt rx1124_pos, 2, rx1124_start
    sub rx1124_off, rx1124_pos, 1
    substr rx1124_tgt, rx1124_tgt, rx1124_off
  rx1124_start:
    eq $I10, 1, rx1124_restart
    if_null rx1124_debug, debug_856
    rx1124_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1127_done
    goto rxscan1127_scan
  rxscan1127_loop:
    (rx1124_pos) = rx1124_cur."from"()
    inc rx1124_pos
    rx1124_cur."!cursor_from"(rx1124_pos)
    ge rx1124_pos, rx1124_eos, rxscan1127_done
  rxscan1127_scan:
    set_addr $I10, rxscan1127_loop
    rx1124_cur."!mark_push"(0, rx1124_pos, $I10)
  rxscan1127_done:
.annotate 'line', 516
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1124_pos, rx1124_off
    substr $S10, rx1124_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1124_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."quotemod_check"("s")
    unless $P10, rx1124_fail
  # rx subrule "variable" subtype=capture negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."variable"()
    unless $P10, rx1124_fail
    rx1124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1124_pos = $P10."pos"()
  # rx pass
    rx1124_cur."!cursor_pass"(rx1124_pos, "quote_escape:sym<$>")
    if_null rx1124_debug, debug_857
    rx1124_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1124_pos)
  debug_857:
    .return (rx1124_cur)
  rx1124_restart:
.annotate 'line', 4
    if_null rx1124_debug, debug_858
    rx1124_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_858:
  rx1124_fail:
    (rx1124_rep, rx1124_pos, $I10, $P10) = rx1124_cur."!mark_fail"(0)
    lt rx1124_pos, -1, rx1124_done
    eq rx1124_pos, -1, rx1124_fail
    jump $I10
  rx1124_done:
    rx1124_cur."!cursor_fail"()
    if_null rx1124_debug, debug_859
    rx1124_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_859:
    .return (rx1124_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("246_1296306519.49046") :method
.annotate 'line', 4
    new $P1126, "ResizablePMCArray"
    push $P1126, "$"
    .return ($P1126)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("247_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1129_tgt
    .local int rx1129_pos
    .local int rx1129_off
    .local int rx1129_eos
    .local int rx1129_rep
    .local pmc rx1129_cur
    .local pmc rx1129_debug
    (rx1129_cur, rx1129_pos, rx1129_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1129_cur
    .local pmc match
    .lex "$/", match
    length rx1129_eos, rx1129_tgt
    gt rx1129_pos, rx1129_eos, rx1129_done
    set rx1129_off, 0
    lt rx1129_pos, 2, rx1129_start
    sub rx1129_off, rx1129_pos, 1
    substr rx1129_tgt, rx1129_tgt, rx1129_off
  rx1129_start:
    eq $I10, 1, rx1129_restart
    if_null rx1129_debug, debug_860
    rx1129_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1132_done
    goto rxscan1132_scan
  rxscan1132_loop:
    (rx1129_pos) = rx1129_cur."from"()
    inc rx1129_pos
    rx1129_cur."!cursor_from"(rx1129_pos)
    ge rx1129_pos, rx1129_eos, rxscan1132_done
  rxscan1132_scan:
    set_addr $I10, rxscan1132_loop
    rx1129_cur."!mark_push"(0, rx1129_pos, $I10)
  rxscan1132_done:
.annotate 'line', 517
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1129_pos, rx1129_off
    substr $S10, rx1129_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1129_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1129_cur."!cursor_pos"(rx1129_pos)
    $P10 = rx1129_cur."quotemod_check"("c")
    unless $P10, rx1129_fail
  # rx subrule "block" subtype=capture negate=
    rx1129_cur."!cursor_pos"(rx1129_pos)
    $P10 = rx1129_cur."block"()
    unless $P10, rx1129_fail
    rx1129_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1129_pos = $P10."pos"()
  # rx pass
    rx1129_cur."!cursor_pass"(rx1129_pos, "quote_escape:sym<{ }>")
    if_null rx1129_debug, debug_861
    rx1129_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1129_pos)
  debug_861:
    .return (rx1129_cur)
  rx1129_restart:
.annotate 'line', 4
    if_null rx1129_debug, debug_862
    rx1129_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_862:
  rx1129_fail:
    (rx1129_rep, rx1129_pos, $I10, $P10) = rx1129_cur."!mark_fail"(0)
    lt rx1129_pos, -1, rx1129_done
    eq rx1129_pos, -1, rx1129_fail
    jump $I10
  rx1129_done:
    rx1129_cur."!cursor_fail"()
    if_null rx1129_debug, debug_863
    rx1129_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_863:
    .return (rx1129_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("248_1296306519.49046") :method
.annotate 'line', 4
    new $P1131, "ResizablePMCArray"
    push $P1131, "{"
    .return ($P1131)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("249_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1134_tgt
    .local int rx1134_pos
    .local int rx1134_off
    .local int rx1134_eos
    .local int rx1134_rep
    .local pmc rx1134_cur
    .local pmc rx1134_debug
    (rx1134_cur, rx1134_pos, rx1134_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1134_cur
    .local pmc match
    .lex "$/", match
    length rx1134_eos, rx1134_tgt
    gt rx1134_pos, rx1134_eos, rx1134_done
    set rx1134_off, 0
    lt rx1134_pos, 2, rx1134_start
    sub rx1134_off, rx1134_pos, 1
    substr rx1134_tgt, rx1134_tgt, rx1134_off
  rx1134_start:
    eq $I10, 1, rx1134_restart
    if_null rx1134_debug, debug_864
    rx1134_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1137_done
    goto rxscan1137_scan
  rxscan1137_loop:
    (rx1134_pos) = rx1134_cur."from"()
    inc rx1134_pos
    rx1134_cur."!cursor_from"(rx1134_pos)
    ge rx1134_pos, rx1134_eos, rxscan1137_done
  rxscan1137_scan:
    set_addr $I10, rxscan1137_loop
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  rxscan1137_done:
.annotate 'line', 518
  # rx literal  "\\e"
    add $I11, rx1134_pos, 2
    gt $I11, rx1134_eos, rx1134_fail
    sub $I11, rx1134_pos, rx1134_off
    substr $S10, rx1134_tgt, $I11, 2
    ne $S10, "\\e", rx1134_fail
    add rx1134_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."quotemod_check"("b")
    unless $P10, rx1134_fail
  # rx pass
    rx1134_cur."!cursor_pass"(rx1134_pos, "quote_escape:sym<esc>")
    if_null rx1134_debug, debug_865
    rx1134_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1134_pos)
  debug_865:
    .return (rx1134_cur)
  rx1134_restart:
.annotate 'line', 4
    if_null rx1134_debug, debug_866
    rx1134_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_866:
  rx1134_fail:
    (rx1134_rep, rx1134_pos, $I10, $P10) = rx1134_cur."!mark_fail"(0)
    lt rx1134_pos, -1, rx1134_done
    eq rx1134_pos, -1, rx1134_fail
    jump $I10
  rx1134_done:
    rx1134_cur."!cursor_fail"()
    if_null rx1134_debug, debug_867
    rx1134_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_867:
    .return (rx1134_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("250_1296306519.49046") :method
.annotate 'line', 4
    new $P1136, "ResizablePMCArray"
    push $P1136, "\\e"
    .return ($P1136)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("251_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1139_tgt
    .local int rx1139_pos
    .local int rx1139_off
    .local int rx1139_eos
    .local int rx1139_rep
    .local pmc rx1139_cur
    .local pmc rx1139_debug
    (rx1139_cur, rx1139_pos, rx1139_tgt, $I10) = self."!cursor_start"()
    rx1139_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1139_cur
    .local pmc match
    .lex "$/", match
    length rx1139_eos, rx1139_tgt
    gt rx1139_pos, rx1139_eos, rx1139_done
    set rx1139_off, 0
    lt rx1139_pos, 2, rx1139_start
    sub rx1139_off, rx1139_pos, 1
    substr rx1139_tgt, rx1139_tgt, rx1139_off
  rx1139_start:
    eq $I10, 1, rx1139_restart
    if_null rx1139_debug, debug_868
    rx1139_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1143_done
    goto rxscan1143_scan
  rxscan1143_loop:
    (rx1139_pos) = rx1139_cur."from"()
    inc rx1139_pos
    rx1139_cur."!cursor_from"(rx1139_pos)
    ge rx1139_pos, rx1139_eos, rxscan1143_done
  rxscan1143_scan:
    set_addr $I10, rxscan1143_loop
    rx1139_cur."!mark_push"(0, rx1139_pos, $I10)
  rxscan1143_done:
.annotate 'line', 520
  # rx literal  "("
    add $I11, rx1139_pos, 1
    gt $I11, rx1139_eos, rx1139_fail
    sub $I11, rx1139_pos, rx1139_off
    ord $I11, rx1139_tgt, $I11
    ne $I11, 40, rx1139_fail
    add rx1139_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1139_cur."!cursor_pos"(rx1139_pos)
    $P10 = rx1139_cur."ws"()
    unless $P10, rx1139_fail
    rx1139_pos = $P10."pos"()
  # rx rxquantr1144 ** 0..1
    set_addr $I10, rxquantr1144_done
    rx1139_cur."!mark_push"(0, rx1139_pos, $I10)
  rxquantr1144_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1139_cur."!cursor_pos"(rx1139_pos)
    $P10 = rx1139_cur."EXPR"()
    unless $P10, rx1139_fail
    goto rxsubrule1145_pass
  rxsubrule1145_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1139_fail
  rxsubrule1145_pass:
    set_addr $I10, rxsubrule1145_back
    rx1139_cur."!mark_push"(0, rx1139_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1139_pos = $P10."pos"()
    set_addr $I10, rxquantr1144_done
    (rx1139_rep) = rx1139_cur."!mark_commit"($I10)
  rxquantr1144_done:
  # rx literal  ")"
    add $I11, rx1139_pos, 1
    gt $I11, rx1139_eos, rx1139_fail
    sub $I11, rx1139_pos, rx1139_off
    ord $I11, rx1139_tgt, $I11
    ne $I11, 41, rx1139_fail
    add rx1139_pos, 1
  # rx pass
    rx1139_cur."!cursor_pass"(rx1139_pos, "circumfix:sym<( )>")
    if_null rx1139_debug, debug_869
    rx1139_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1139_pos)
  debug_869:
    .return (rx1139_cur)
  rx1139_restart:
.annotate 'line', 4
    if_null rx1139_debug, debug_870
    rx1139_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_870:
  rx1139_fail:
    (rx1139_rep, rx1139_pos, $I10, $P10) = rx1139_cur."!mark_fail"(0)
    lt rx1139_pos, -1, rx1139_done
    eq rx1139_pos, -1, rx1139_fail
    jump $I10
  rx1139_done:
    rx1139_cur."!cursor_fail"()
    if_null rx1139_debug, debug_871
    rx1139_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_871:
    .return (rx1139_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("252_1296306519.49046") :method
.annotate 'line', 4
    $P1141 = self."!PREFIX__!subrule"("ws", "(")
    new $P1142, "ResizablePMCArray"
    push $P1142, $P1141
    .return ($P1142)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("253_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1147_tgt
    .local int rx1147_pos
    .local int rx1147_off
    .local int rx1147_eos
    .local int rx1147_rep
    .local pmc rx1147_cur
    .local pmc rx1147_debug
    (rx1147_cur, rx1147_pos, rx1147_tgt, $I10) = self."!cursor_start"()
    rx1147_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1147_cur
    .local pmc match
    .lex "$/", match
    length rx1147_eos, rx1147_tgt
    gt rx1147_pos, rx1147_eos, rx1147_done
    set rx1147_off, 0
    lt rx1147_pos, 2, rx1147_start
    sub rx1147_off, rx1147_pos, 1
    substr rx1147_tgt, rx1147_tgt, rx1147_off
  rx1147_start:
    eq $I10, 1, rx1147_restart
    if_null rx1147_debug, debug_872
    rx1147_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1151_done
    goto rxscan1151_scan
  rxscan1151_loop:
    (rx1147_pos) = rx1147_cur."from"()
    inc rx1147_pos
    rx1147_cur."!cursor_from"(rx1147_pos)
    ge rx1147_pos, rx1147_eos, rxscan1151_done
  rxscan1151_scan:
    set_addr $I10, rxscan1151_loop
    rx1147_cur."!mark_push"(0, rx1147_pos, $I10)
  rxscan1151_done:
.annotate 'line', 521
  # rx literal  "["
    add $I11, rx1147_pos, 1
    gt $I11, rx1147_eos, rx1147_fail
    sub $I11, rx1147_pos, rx1147_off
    ord $I11, rx1147_tgt, $I11
    ne $I11, 91, rx1147_fail
    add rx1147_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1147_cur."!cursor_pos"(rx1147_pos)
    $P10 = rx1147_cur."ws"()
    unless $P10, rx1147_fail
    rx1147_pos = $P10."pos"()
  # rx rxquantr1152 ** 0..1
    set_addr $I10, rxquantr1152_done
    rx1147_cur."!mark_push"(0, rx1147_pos, $I10)
  rxquantr1152_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1147_cur."!cursor_pos"(rx1147_pos)
    $P10 = rx1147_cur."EXPR"()
    unless $P10, rx1147_fail
    goto rxsubrule1153_pass
  rxsubrule1153_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1147_fail
  rxsubrule1153_pass:
    set_addr $I10, rxsubrule1153_back
    rx1147_cur."!mark_push"(0, rx1147_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1147_pos = $P10."pos"()
    set_addr $I10, rxquantr1152_done
    (rx1147_rep) = rx1147_cur."!mark_commit"($I10)
  rxquantr1152_done:
  # rx literal  "]"
    add $I11, rx1147_pos, 1
    gt $I11, rx1147_eos, rx1147_fail
    sub $I11, rx1147_pos, rx1147_off
    ord $I11, rx1147_tgt, $I11
    ne $I11, 93, rx1147_fail
    add rx1147_pos, 1
  # rx pass
    rx1147_cur."!cursor_pass"(rx1147_pos, "circumfix:sym<[ ]>")
    if_null rx1147_debug, debug_873
    rx1147_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1147_pos)
  debug_873:
    .return (rx1147_cur)
  rx1147_restart:
.annotate 'line', 4
    if_null rx1147_debug, debug_874
    rx1147_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_874:
  rx1147_fail:
    (rx1147_rep, rx1147_pos, $I10, $P10) = rx1147_cur."!mark_fail"(0)
    lt rx1147_pos, -1, rx1147_done
    eq rx1147_pos, -1, rx1147_fail
    jump $I10
  rx1147_done:
    rx1147_cur."!cursor_fail"()
    if_null rx1147_debug, debug_875
    rx1147_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_875:
    .return (rx1147_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("254_1296306519.49046") :method
.annotate 'line', 4
    $P1149 = self."!PREFIX__!subrule"("ws", "[")
    new $P1150, "ResizablePMCArray"
    push $P1150, $P1149
    .return ($P1150)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("255_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1155_tgt
    .local int rx1155_pos
    .local int rx1155_off
    .local int rx1155_eos
    .local int rx1155_rep
    .local pmc rx1155_cur
    .local pmc rx1155_debug
    (rx1155_cur, rx1155_pos, rx1155_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1155_cur
    .local pmc match
    .lex "$/", match
    length rx1155_eos, rx1155_tgt
    gt rx1155_pos, rx1155_eos, rx1155_done
    set rx1155_off, 0
    lt rx1155_pos, 2, rx1155_start
    sub rx1155_off, rx1155_pos, 1
    substr rx1155_tgt, rx1155_tgt, rx1155_off
  rx1155_start:
    eq $I10, 1, rx1155_restart
    if_null rx1155_debug, debug_876
    rx1155_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1158_done
    goto rxscan1158_scan
  rxscan1158_loop:
    (rx1155_pos) = rx1155_cur."from"()
    inc rx1155_pos
    rx1155_cur."!cursor_from"(rx1155_pos)
    ge rx1155_pos, rx1155_eos, rxscan1158_done
  rxscan1158_scan:
    set_addr $I10, rxscan1158_loop
    rx1155_cur."!mark_push"(0, rx1155_pos, $I10)
  rxscan1158_done:
.annotate 'line', 522
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1155_pos, rx1155_off
    substr $S10, rx1155_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1155_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1155_cur."!cursor_pos"(rx1155_pos)
    $P10 = rx1155_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1155_fail
    rx1155_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1155_pos = $P10."pos"()
  # rx pass
    rx1155_cur."!cursor_pass"(rx1155_pos, "circumfix:sym<ang>")
    if_null rx1155_debug, debug_877
    rx1155_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1155_pos)
  debug_877:
    .return (rx1155_cur)
  rx1155_restart:
.annotate 'line', 4
    if_null rx1155_debug, debug_878
    rx1155_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_878:
  rx1155_fail:
    (rx1155_rep, rx1155_pos, $I10, $P10) = rx1155_cur."!mark_fail"(0)
    lt rx1155_pos, -1, rx1155_done
    eq rx1155_pos, -1, rx1155_fail
    jump $I10
  rx1155_done:
    rx1155_cur."!cursor_fail"()
    if_null rx1155_debug, debug_879
    rx1155_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_879:
    .return (rx1155_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("256_1296306519.49046") :method
.annotate 'line', 4
    new $P1157, "ResizablePMCArray"
    push $P1157, "<"
    .return ($P1157)
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("257_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1160_tgt
    .local int rx1160_pos
    .local int rx1160_off
    .local int rx1160_eos
    .local int rx1160_rep
    .local pmc rx1160_cur
    .local pmc rx1160_debug
    (rx1160_cur, rx1160_pos, rx1160_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1160_cur
    .local pmc match
    .lex "$/", match
    length rx1160_eos, rx1160_tgt
    gt rx1160_pos, rx1160_eos, rx1160_done
    set rx1160_off, 0
    lt rx1160_pos, 2, rx1160_start
    sub rx1160_off, rx1160_pos, 1
    substr rx1160_tgt, rx1160_tgt, rx1160_off
  rx1160_start:
    eq $I10, 1, rx1160_restart
    if_null rx1160_debug, debug_880
    rx1160_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_880:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1163_done
    goto rxscan1163_scan
  rxscan1163_loop:
    (rx1160_pos) = rx1160_cur."from"()
    inc rx1160_pos
    rx1160_cur."!cursor_from"(rx1160_pos)
    ge rx1160_pos, rx1160_eos, rxscan1163_done
  rxscan1163_scan:
    set_addr $I10, rxscan1163_loop
    rx1160_cur."!mark_push"(0, rx1160_pos, $I10)
  rxscan1163_done:
.annotate 'line', 523
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1160_pos, rx1160_off
    substr $S10, rx1160_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1160_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1160_cur."!cursor_pos"(rx1160_pos)
    $P10 = rx1160_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1160_fail
    rx1160_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1160_pos = $P10."pos"()
  # rx pass
    rx1160_cur."!cursor_pass"(rx1160_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1160_debug, debug_881
    rx1160_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1160_pos)
  debug_881:
    .return (rx1160_cur)
  rx1160_restart:
.annotate 'line', 4
    if_null rx1160_debug, debug_882
    rx1160_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_882:
  rx1160_fail:
    (rx1160_rep, rx1160_pos, $I10, $P10) = rx1160_cur."!mark_fail"(0)
    lt rx1160_pos, -1, rx1160_done
    eq rx1160_pos, -1, rx1160_fail
    jump $I10
  rx1160_done:
    rx1160_cur."!cursor_fail"()
    if_null rx1160_debug, debug_883
    rx1160_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_883:
    .return (rx1160_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("258_1296306519.49046") :method
.annotate 'line', 4
    new $P1162, "ResizablePMCArray"
    push $P1162, unicode:"\x{ab}"
    .return ($P1162)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("259_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1165_tgt
    .local int rx1165_pos
    .local int rx1165_off
    .local int rx1165_eos
    .local int rx1165_rep
    .local pmc rx1165_cur
    .local pmc rx1165_debug
    (rx1165_cur, rx1165_pos, rx1165_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1165_cur
    .local pmc match
    .lex "$/", match
    length rx1165_eos, rx1165_tgt
    gt rx1165_pos, rx1165_eos, rx1165_done
    set rx1165_off, 0
    lt rx1165_pos, 2, rx1165_start
    sub rx1165_off, rx1165_pos, 1
    substr rx1165_tgt, rx1165_tgt, rx1165_off
  rx1165_start:
    eq $I10, 1, rx1165_restart
    if_null rx1165_debug, debug_884
    rx1165_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1168_done
    goto rxscan1168_scan
  rxscan1168_loop:
    (rx1165_pos) = rx1165_cur."from"()
    inc rx1165_pos
    rx1165_cur."!cursor_from"(rx1165_pos)
    ge rx1165_pos, rx1165_eos, rxscan1168_done
  rxscan1168_scan:
    set_addr $I10, rxscan1168_loop
    rx1165_cur."!mark_push"(0, rx1165_pos, $I10)
  rxscan1168_done:
.annotate 'line', 524
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1165_pos, rx1165_off
    substr $S10, rx1165_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1165_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1165_cur."!cursor_pos"(rx1165_pos)
    $P10 = rx1165_cur."pblock"()
    unless $P10, rx1165_fail
    rx1165_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1165_pos = $P10."pos"()
  # rx pass
    rx1165_cur."!cursor_pass"(rx1165_pos, "circumfix:sym<{ }>")
    if_null rx1165_debug, debug_885
    rx1165_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1165_pos)
  debug_885:
    .return (rx1165_cur)
  rx1165_restart:
.annotate 'line', 4
    if_null rx1165_debug, debug_886
    rx1165_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_886:
  rx1165_fail:
    (rx1165_rep, rx1165_pos, $I10, $P10) = rx1165_cur."!mark_fail"(0)
    lt rx1165_pos, -1, rx1165_done
    eq rx1165_pos, -1, rx1165_fail
    jump $I10
  rx1165_done:
    rx1165_cur."!cursor_fail"()
    if_null rx1165_debug, debug_887
    rx1165_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_887:
    .return (rx1165_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("260_1296306519.49046") :method
.annotate 'line', 4
    new $P1167, "ResizablePMCArray"
    push $P1167, "{"
    .return ($P1167)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("261_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1170_tgt
    .local int rx1170_pos
    .local int rx1170_off
    .local int rx1170_eos
    .local int rx1170_rep
    .local pmc rx1170_cur
    .local pmc rx1170_debug
    (rx1170_cur, rx1170_pos, rx1170_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1170_cur
    .local pmc match
    .lex "$/", match
    length rx1170_eos, rx1170_tgt
    gt rx1170_pos, rx1170_eos, rx1170_done
    set rx1170_off, 0
    lt rx1170_pos, 2, rx1170_start
    sub rx1170_off, rx1170_pos, 1
    substr rx1170_tgt, rx1170_tgt, rx1170_off
  rx1170_start:
    eq $I10, 1, rx1170_restart
    if_null rx1170_debug, debug_888
    rx1170_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_888:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1174_done
    goto rxscan1174_scan
  rxscan1174_loop:
    (rx1170_pos) = rx1170_cur."from"()
    inc rx1170_pos
    rx1170_cur."!cursor_from"(rx1170_pos)
    ge rx1170_pos, rx1170_eos, rxscan1174_done
  rxscan1174_scan:
    set_addr $I10, rxscan1174_loop
    rx1170_cur."!mark_push"(0, rx1170_pos, $I10)
  rxscan1174_done:
.annotate 'line', 525
  # rx subrule "sigil" subtype=capture negate=
    rx1170_cur."!cursor_pos"(rx1170_pos)
    $P10 = rx1170_cur."sigil"()
    unless $P10, rx1170_fail
    rx1170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1170_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1170_pos, 1
    gt $I11, rx1170_eos, rx1170_fail
    sub $I11, rx1170_pos, rx1170_off
    ord $I11, rx1170_tgt, $I11
    ne $I11, 40, rx1170_fail
    add rx1170_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1170_cur."!cursor_pos"(rx1170_pos)
    $P10 = rx1170_cur."semilist"()
    unless $P10, rx1170_fail
    rx1170_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1170_pos = $P10."pos"()
  alt1175_0:
    set_addr $I10, alt1175_1
    rx1170_cur."!mark_push"(0, rx1170_pos, $I10)
  # rx literal  ")"
    add $I11, rx1170_pos, 1
    gt $I11, rx1170_eos, rx1170_fail
    sub $I11, rx1170_pos, rx1170_off
    ord $I11, rx1170_tgt, $I11
    ne $I11, 41, rx1170_fail
    add rx1170_pos, 1
    goto alt1175_end
  alt1175_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1170_cur."!cursor_pos"(rx1170_pos)
    $P10 = rx1170_cur."FAILGOAL"("')'")
    unless $P10, rx1170_fail
    goto rxsubrule1177_pass
  rxsubrule1177_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1170_fail
  rxsubrule1177_pass:
    set_addr $I10, rxsubrule1177_back
    rx1170_cur."!mark_push"(0, rx1170_pos, $I10, $P10)
    rx1170_pos = $P10."pos"()
  alt1175_end:
  # rx pass
    rx1170_cur."!cursor_pass"(rx1170_pos, "circumfix:sym<sigil>")
    if_null rx1170_debug, debug_889
    rx1170_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1170_pos)
  debug_889:
    .return (rx1170_cur)
  rx1170_restart:
.annotate 'line', 4
    if_null rx1170_debug, debug_890
    rx1170_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_890:
  rx1170_fail:
    (rx1170_rep, rx1170_pos, $I10, $P10) = rx1170_cur."!mark_fail"(0)
    lt rx1170_pos, -1, rx1170_done
    eq rx1170_pos, -1, rx1170_fail
    jump $I10
  rx1170_done:
    rx1170_cur."!cursor_fail"()
    if_null rx1170_debug, debug_891
    rx1170_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_891:
    .return (rx1170_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("262_1296306519.49046") :method
.annotate 'line', 4
    $P1172 = self."!PREFIX__!subrule"("sigil", "")
    new $P1173, "ResizablePMCArray"
    push $P1173, $P1172
    .return ($P1173)
.end


.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("263_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1179_tgt
    .local int rx1179_pos
    .local int rx1179_off
    .local int rx1179_eos
    .local int rx1179_rep
    .local pmc rx1179_cur
    .local pmc rx1179_debug
    (rx1179_cur, rx1179_pos, rx1179_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1179_cur
    .local pmc match
    .lex "$/", match
    length rx1179_eos, rx1179_tgt
    gt rx1179_pos, rx1179_eos, rx1179_done
    set rx1179_off, 0
    lt rx1179_pos, 2, rx1179_start
    sub rx1179_off, rx1179_pos, 1
    substr rx1179_tgt, rx1179_tgt, rx1179_off
  rx1179_start:
    eq $I10, 1, rx1179_restart
    if_null rx1179_debug, debug_892
    rx1179_cur."!cursor_debug"("START", "semilist")
  debug_892:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1183_done
    goto rxscan1183_scan
  rxscan1183_loop:
    (rx1179_pos) = rx1179_cur."from"()
    inc rx1179_pos
    rx1179_cur."!cursor_from"(rx1179_pos)
    ge rx1179_pos, rx1179_eos, rxscan1183_done
  rxscan1183_scan:
    set_addr $I10, rxscan1183_loop
    rx1179_cur."!mark_push"(0, rx1179_pos, $I10)
  rxscan1183_done:
.annotate 'line', 527
  # rx subrule "ws" subtype=method negate=
    rx1179_cur."!cursor_pos"(rx1179_pos)
    $P10 = rx1179_cur."ws"()
    unless $P10, rx1179_fail
    rx1179_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1179_cur."!cursor_pos"(rx1179_pos)
    $P10 = rx1179_cur."statement"()
    unless $P10, rx1179_fail
    rx1179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1179_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1179_cur."!cursor_pos"(rx1179_pos)
    $P10 = rx1179_cur."ws"()
    unless $P10, rx1179_fail
    rx1179_pos = $P10."pos"()
  # rx pass
    rx1179_cur."!cursor_pass"(rx1179_pos, "semilist")
    if_null rx1179_debug, debug_893
    rx1179_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1179_pos)
  debug_893:
    .return (rx1179_cur)
  rx1179_restart:
.annotate 'line', 4
    if_null rx1179_debug, debug_894
    rx1179_cur."!cursor_debug"("NEXT", "semilist")
  debug_894:
  rx1179_fail:
    (rx1179_rep, rx1179_pos, $I10, $P10) = rx1179_cur."!mark_fail"(0)
    lt rx1179_pos, -1, rx1179_done
    eq rx1179_pos, -1, rx1179_fail
    jump $I10
  rx1179_done:
    rx1179_cur."!cursor_fail"()
    if_null rx1179_debug, debug_895
    rx1179_cur."!cursor_debug"("FAIL", "semilist")
  debug_895:
    .return (rx1179_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("264_1296306519.49046") :method
.annotate 'line', 4
    $P1181 = self."!PREFIX__!subrule"("ws", "")
    new $P1182, "ResizablePMCArray"
    push $P1182, $P1181
    .return ($P1182)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1186"  :anon :subid("265_1296306519.49046") :outer("11_1296306519.49046")
.annotate 'line', 4
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post896") :outer("265_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P1187 = "265_1296306519.49046" 
    .local pmc block
    set block, $P1187
.annotate 'line', 532
    get_hll_global $P1188, ["NQP"], "Grammar"
    $P1188."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 533
    get_hll_global $P1189, ["NQP"], "Grammar"
    $P1189."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 534
    get_hll_global $P1190, ["NQP"], "Grammar"
    $P1190."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 535
    get_hll_global $P1191, ["NQP"], "Grammar"
    $P1191."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 536
    get_hll_global $P1192, ["NQP"], "Grammar"
    $P1192."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 537
    get_hll_global $P1193, ["NQP"], "Grammar"
    $P1193."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 538
    get_hll_global $P1194, ["NQP"], "Grammar"
    $P1194."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 539
    get_hll_global $P1195, ["NQP"], "Grammar"
    $P1195."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 540
    get_hll_global $P1196, ["NQP"], "Grammar"
    $P1196."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 541
    get_hll_global $P1197, ["NQP"], "Grammar"
    $P1197."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 542
    get_hll_global $P1198, ["NQP"], "Grammar"
    $P1198."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 543
    get_hll_global $P1199, ["NQP"], "Grammar"
    $P1199."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 544
    get_hll_global $P1200, ["NQP"], "Grammar"
    $P1200."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 545
    get_hll_global $P1201, ["NQP"], "Grammar"
    $P1201."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 546
    get_hll_global $P1202, ["NQP"], "Grammar"
    $P1202."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("266_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1204_tgt
    .local int rx1204_pos
    .local int rx1204_off
    .local int rx1204_eos
    .local int rx1204_rep
    .local pmc rx1204_cur
    .local pmc rx1204_debug
    (rx1204_cur, rx1204_pos, rx1204_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1204_cur
    .local pmc match
    .lex "$/", match
    length rx1204_eos, rx1204_tgt
    gt rx1204_pos, rx1204_eos, rx1204_done
    set rx1204_off, 0
    lt rx1204_pos, 2, rx1204_start
    sub rx1204_off, rx1204_pos, 1
    substr rx1204_tgt, rx1204_tgt, rx1204_off
  rx1204_start:
    eq $I10, 1, rx1204_restart
    if_null rx1204_debug, debug_897
    rx1204_cur."!cursor_debug"("START", "infixish")
  debug_897:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1207_done
    goto rxscan1207_scan
  rxscan1207_loop:
    (rx1204_pos) = rx1204_cur."from"()
    inc rx1204_pos
    rx1204_cur."!cursor_from"(rx1204_pos)
    ge rx1204_pos, rx1204_eos, rxscan1207_done
  rxscan1207_scan:
    set_addr $I10, rxscan1207_loop
    rx1204_cur."!mark_push"(0, rx1204_pos, $I10)
  rxscan1207_done:
.annotate 'line', 550
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."infixstopper"()
    if $P10, rx1204_fail
  # rx subrule "infix" subtype=capture negate=
    rx1204_cur."!cursor_pos"(rx1204_pos)
    $P10 = rx1204_cur."infix"()
    unless $P10, rx1204_fail
    rx1204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1204_pos = $P10."pos"()
  # rx pass
    rx1204_cur."!cursor_pass"(rx1204_pos, "infixish")
    if_null rx1204_debug, debug_898
    rx1204_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1204_pos)
  debug_898:
    .return (rx1204_cur)
  rx1204_restart:
.annotate 'line', 4
    if_null rx1204_debug, debug_899
    rx1204_cur."!cursor_debug"("NEXT", "infixish")
  debug_899:
  rx1204_fail:
    (rx1204_rep, rx1204_pos, $I10, $P10) = rx1204_cur."!mark_fail"(0)
    lt rx1204_pos, -1, rx1204_done
    eq rx1204_pos, -1, rx1204_fail
    jump $I10
  rx1204_done:
    rx1204_cur."!cursor_fail"()
    if_null rx1204_debug, debug_900
    rx1204_cur."!cursor_debug"("FAIL", "infixish")
  debug_900:
    .return (rx1204_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("267_1296306519.49046") :method
.annotate 'line', 4
    new $P1206, "ResizablePMCArray"
    push $P1206, ""
    .return ($P1206)
.end


.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("268_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1209_tgt
    .local int rx1209_pos
    .local int rx1209_off
    .local int rx1209_eos
    .local int rx1209_rep
    .local pmc rx1209_cur
    .local pmc rx1209_debug
    (rx1209_cur, rx1209_pos, rx1209_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1209_cur
    .local pmc match
    .lex "$/", match
    length rx1209_eos, rx1209_tgt
    gt rx1209_pos, rx1209_eos, rx1209_done
    set rx1209_off, 0
    lt rx1209_pos, 2, rx1209_start
    sub rx1209_off, rx1209_pos, 1
    substr rx1209_tgt, rx1209_tgt, rx1209_off
  rx1209_start:
    eq $I10, 1, rx1209_restart
    if_null rx1209_debug, debug_901
    rx1209_cur."!cursor_debug"("START", "infixstopper")
  debug_901:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1212_done
    goto rxscan1212_scan
  rxscan1212_loop:
    (rx1209_pos) = rx1209_cur."from"()
    inc rx1209_pos
    rx1209_cur."!cursor_from"(rx1209_pos)
    ge rx1209_pos, rx1209_eos, rxscan1212_done
  rxscan1212_scan:
    set_addr $I10, rxscan1212_loop
    rx1209_cur."!mark_push"(0, rx1209_pos, $I10)
  rxscan1212_done:
.annotate 'line', 551
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."lambda"()
    unless $P10, rx1209_fail
  # rx pass
    rx1209_cur."!cursor_pass"(rx1209_pos, "infixstopper")
    if_null rx1209_debug, debug_902
    rx1209_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1209_pos)
  debug_902:
    .return (rx1209_cur)
  rx1209_restart:
.annotate 'line', 4
    if_null rx1209_debug, debug_903
    rx1209_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_903:
  rx1209_fail:
    (rx1209_rep, rx1209_pos, $I10, $P10) = rx1209_cur."!mark_fail"(0)
    lt rx1209_pos, -1, rx1209_done
    eq rx1209_pos, -1, rx1209_fail
    jump $I10
  rx1209_done:
    rx1209_cur."!cursor_fail"()
    if_null rx1209_debug, debug_904
    rx1209_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_904:
    .return (rx1209_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("269_1296306519.49046") :method
.annotate 'line', 4
    new $P1211, "ResizablePMCArray"
    push $P1211, ""
    .return ($P1211)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("270_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1214_tgt
    .local int rx1214_pos
    .local int rx1214_off
    .local int rx1214_eos
    .local int rx1214_rep
    .local pmc rx1214_cur
    .local pmc rx1214_debug
    (rx1214_cur, rx1214_pos, rx1214_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1214_cur
    .local pmc match
    .lex "$/", match
    length rx1214_eos, rx1214_tgt
    gt rx1214_pos, rx1214_eos, rx1214_done
    set rx1214_off, 0
    lt rx1214_pos, 2, rx1214_start
    sub rx1214_off, rx1214_pos, 1
    substr rx1214_tgt, rx1214_tgt, rx1214_off
  rx1214_start:
    eq $I10, 1, rx1214_restart
    if_null rx1214_debug, debug_905
    rx1214_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_905:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1218_done
    goto rxscan1218_scan
  rxscan1218_loop:
    (rx1214_pos) = rx1214_cur."from"()
    inc rx1214_pos
    rx1214_cur."!cursor_from"(rx1214_pos)
    ge rx1214_pos, rx1214_eos, rxscan1218_done
  rxscan1218_scan:
    set_addr $I10, rxscan1218_loop
    rx1214_cur."!mark_push"(0, rx1214_pos, $I10)
  rxscan1218_done:
.annotate 'line', 554
  # rx literal  "["
    add $I11, rx1214_pos, 1
    gt $I11, rx1214_eos, rx1214_fail
    sub $I11, rx1214_pos, rx1214_off
    ord $I11, rx1214_tgt, $I11
    ne $I11, 91, rx1214_fail
    add rx1214_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1214_cur."!cursor_pos"(rx1214_pos)
    $P10 = rx1214_cur."ws"()
    unless $P10, rx1214_fail
    rx1214_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1214_cur."!cursor_pos"(rx1214_pos)
    $P10 = rx1214_cur."EXPR"()
    unless $P10, rx1214_fail
    rx1214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1214_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1214_pos, 1
    gt $I11, rx1214_eos, rx1214_fail
    sub $I11, rx1214_pos, rx1214_off
    ord $I11, rx1214_tgt, $I11
    ne $I11, 93, rx1214_fail
    add rx1214_pos, 1
.annotate 'line', 555
  # rx subrule "O" subtype=capture negate=
    rx1214_cur."!cursor_pos"(rx1214_pos)
    $P10 = rx1214_cur."O"("%methodop")
    unless $P10, rx1214_fail
    rx1214_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1214_pos = $P10."pos"()
.annotate 'line', 553
  # rx pass
    rx1214_cur."!cursor_pass"(rx1214_pos, "postcircumfix:sym<[ ]>")
    if_null rx1214_debug, debug_906
    rx1214_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1214_pos)
  debug_906:
    .return (rx1214_cur)
  rx1214_restart:
.annotate 'line', 4
    if_null rx1214_debug, debug_907
    rx1214_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_907:
  rx1214_fail:
    (rx1214_rep, rx1214_pos, $I10, $P10) = rx1214_cur."!mark_fail"(0)
    lt rx1214_pos, -1, rx1214_done
    eq rx1214_pos, -1, rx1214_fail
    jump $I10
  rx1214_done:
    rx1214_cur."!cursor_fail"()
    if_null rx1214_debug, debug_908
    rx1214_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_908:
    .return (rx1214_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("271_1296306519.49046") :method
.annotate 'line', 4
    $P1216 = self."!PREFIX__!subrule"("ws", "[")
    new $P1217, "ResizablePMCArray"
    push $P1217, $P1216
    .return ($P1217)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("272_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1220_tgt
    .local int rx1220_pos
    .local int rx1220_off
    .local int rx1220_eos
    .local int rx1220_rep
    .local pmc rx1220_cur
    .local pmc rx1220_debug
    (rx1220_cur, rx1220_pos, rx1220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1220_cur
    .local pmc match
    .lex "$/", match
    length rx1220_eos, rx1220_tgt
    gt rx1220_pos, rx1220_eos, rx1220_done
    set rx1220_off, 0
    lt rx1220_pos, 2, rx1220_start
    sub rx1220_off, rx1220_pos, 1
    substr rx1220_tgt, rx1220_tgt, rx1220_off
  rx1220_start:
    eq $I10, 1, rx1220_restart
    if_null rx1220_debug, debug_909
    rx1220_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_909:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1220_pos) = rx1220_cur."from"()
    inc rx1220_pos
    rx1220_cur."!cursor_from"(rx1220_pos)
    ge rx1220_pos, rx1220_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10)
  rxscan1224_done:
.annotate 'line', 559
  # rx literal  "{"
    add $I11, rx1220_pos, 1
    gt $I11, rx1220_eos, rx1220_fail
    sub $I11, rx1220_pos, rx1220_off
    ord $I11, rx1220_tgt, $I11
    ne $I11, 123, rx1220_fail
    add rx1220_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."ws"()
    unless $P10, rx1220_fail
    rx1220_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."EXPR"()
    unless $P10, rx1220_fail
    rx1220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1220_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1220_pos, 1
    gt $I11, rx1220_eos, rx1220_fail
    sub $I11, rx1220_pos, rx1220_off
    ord $I11, rx1220_tgt, $I11
    ne $I11, 125, rx1220_fail
    add rx1220_pos, 1
.annotate 'line', 560
  # rx subrule "O" subtype=capture negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."O"("%methodop")
    unless $P10, rx1220_fail
    rx1220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1220_pos = $P10."pos"()
.annotate 'line', 558
  # rx pass
    rx1220_cur."!cursor_pass"(rx1220_pos, "postcircumfix:sym<{ }>")
    if_null rx1220_debug, debug_910
    rx1220_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1220_pos)
  debug_910:
    .return (rx1220_cur)
  rx1220_restart:
.annotate 'line', 4
    if_null rx1220_debug, debug_911
    rx1220_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_911:
  rx1220_fail:
    (rx1220_rep, rx1220_pos, $I10, $P10) = rx1220_cur."!mark_fail"(0)
    lt rx1220_pos, -1, rx1220_done
    eq rx1220_pos, -1, rx1220_fail
    jump $I10
  rx1220_done:
    rx1220_cur."!cursor_fail"()
    if_null rx1220_debug, debug_912
    rx1220_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_912:
    .return (rx1220_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("273_1296306519.49046") :method
.annotate 'line', 4
    $P1222 = self."!PREFIX__!subrule"("ws", "{")
    new $P1223, "ResizablePMCArray"
    push $P1223, $P1222
    .return ($P1223)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("274_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1226_tgt
    .local int rx1226_pos
    .local int rx1226_off
    .local int rx1226_eos
    .local int rx1226_rep
    .local pmc rx1226_cur
    .local pmc rx1226_debug
    (rx1226_cur, rx1226_pos, rx1226_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1226_cur
    .local pmc match
    .lex "$/", match
    length rx1226_eos, rx1226_tgt
    gt rx1226_pos, rx1226_eos, rx1226_done
    set rx1226_off, 0
    lt rx1226_pos, 2, rx1226_start
    sub rx1226_off, rx1226_pos, 1
    substr rx1226_tgt, rx1226_tgt, rx1226_off
  rx1226_start:
    eq $I10, 1, rx1226_restart
    if_null rx1226_debug, debug_913
    rx1226_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_913:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1229_done
    goto rxscan1229_scan
  rxscan1229_loop:
    (rx1226_pos) = rx1226_cur."from"()
    inc rx1226_pos
    rx1226_cur."!cursor_from"(rx1226_pos)
    ge rx1226_pos, rx1226_eos, rxscan1229_done
  rxscan1229_scan:
    set_addr $I10, rxscan1229_loop
    rx1226_cur."!mark_push"(0, rx1226_pos, $I10)
  rxscan1229_done:
.annotate 'line', 564
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1226_pos, rx1226_off
    substr $S10, rx1226_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1226_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."quote_EXPR"(":q")
    unless $P10, rx1226_fail
    rx1226_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1226_pos = $P10."pos"()
.annotate 'line', 565
  # rx subrule "O" subtype=capture negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."O"("%methodop")
    unless $P10, rx1226_fail
    rx1226_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1226_pos = $P10."pos"()
.annotate 'line', 563
  # rx pass
    rx1226_cur."!cursor_pass"(rx1226_pos, "postcircumfix:sym<ang>")
    if_null rx1226_debug, debug_914
    rx1226_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1226_pos)
  debug_914:
    .return (rx1226_cur)
  rx1226_restart:
.annotate 'line', 4
    if_null rx1226_debug, debug_915
    rx1226_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_915:
  rx1226_fail:
    (rx1226_rep, rx1226_pos, $I10, $P10) = rx1226_cur."!mark_fail"(0)
    lt rx1226_pos, -1, rx1226_done
    eq rx1226_pos, -1, rx1226_fail
    jump $I10
  rx1226_done:
    rx1226_cur."!cursor_fail"()
    if_null rx1226_debug, debug_916
    rx1226_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_916:
    .return (rx1226_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("275_1296306519.49046") :method
.annotate 'line', 4
    new $P1228, "ResizablePMCArray"
    push $P1228, "<"
    .return ($P1228)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("276_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1231_tgt
    .local int rx1231_pos
    .local int rx1231_off
    .local int rx1231_eos
    .local int rx1231_rep
    .local pmc rx1231_cur
    .local pmc rx1231_debug
    (rx1231_cur, rx1231_pos, rx1231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1231_cur
    .local pmc match
    .lex "$/", match
    length rx1231_eos, rx1231_tgt
    gt rx1231_pos, rx1231_eos, rx1231_done
    set rx1231_off, 0
    lt rx1231_pos, 2, rx1231_start
    sub rx1231_off, rx1231_pos, 1
    substr rx1231_tgt, rx1231_tgt, rx1231_off
  rx1231_start:
    eq $I10, 1, rx1231_restart
    if_null rx1231_debug, debug_917
    rx1231_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_917:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1235_done
    goto rxscan1235_scan
  rxscan1235_loop:
    (rx1231_pos) = rx1231_cur."from"()
    inc rx1231_pos
    rx1231_cur."!cursor_from"(rx1231_pos)
    ge rx1231_pos, rx1231_eos, rxscan1235_done
  rxscan1235_scan:
    set_addr $I10, rxscan1235_loop
    rx1231_cur."!mark_push"(0, rx1231_pos, $I10)
  rxscan1235_done:
.annotate 'line', 569
  # rx literal  "("
    add $I11, rx1231_pos, 1
    gt $I11, rx1231_eos, rx1231_fail
    sub $I11, rx1231_pos, rx1231_off
    ord $I11, rx1231_tgt, $I11
    ne $I11, 40, rx1231_fail
    add rx1231_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1231_cur."!cursor_pos"(rx1231_pos)
    $P10 = rx1231_cur."ws"()
    unless $P10, rx1231_fail
    rx1231_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1231_cur."!cursor_pos"(rx1231_pos)
    $P10 = rx1231_cur."arglist"()
    unless $P10, rx1231_fail
    rx1231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1231_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1231_pos, 1
    gt $I11, rx1231_eos, rx1231_fail
    sub $I11, rx1231_pos, rx1231_off
    ord $I11, rx1231_tgt, $I11
    ne $I11, 41, rx1231_fail
    add rx1231_pos, 1
.annotate 'line', 570
  # rx subrule "O" subtype=capture negate=
    rx1231_cur."!cursor_pos"(rx1231_pos)
    $P10 = rx1231_cur."O"("%methodop")
    unless $P10, rx1231_fail
    rx1231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1231_pos = $P10."pos"()
.annotate 'line', 568
  # rx pass
    rx1231_cur."!cursor_pass"(rx1231_pos, "postcircumfix:sym<( )>")
    if_null rx1231_debug, debug_918
    rx1231_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1231_pos)
  debug_918:
    .return (rx1231_cur)
  rx1231_restart:
.annotate 'line', 4
    if_null rx1231_debug, debug_919
    rx1231_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_919:
  rx1231_fail:
    (rx1231_rep, rx1231_pos, $I10, $P10) = rx1231_cur."!mark_fail"(0)
    lt rx1231_pos, -1, rx1231_done
    eq rx1231_pos, -1, rx1231_fail
    jump $I10
  rx1231_done:
    rx1231_cur."!cursor_fail"()
    if_null rx1231_debug, debug_920
    rx1231_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_920:
    .return (rx1231_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("277_1296306519.49046") :method
.annotate 'line', 4
    $P1233 = self."!PREFIX__!subrule"("ws", "(")
    new $P1234, "ResizablePMCArray"
    push $P1234, $P1233
    .return ($P1234)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("278_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1237_tgt
    .local int rx1237_pos
    .local int rx1237_off
    .local int rx1237_eos
    .local int rx1237_rep
    .local pmc rx1237_cur
    .local pmc rx1237_debug
    (rx1237_cur, rx1237_pos, rx1237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1237_cur
    .local pmc match
    .lex "$/", match
    length rx1237_eos, rx1237_tgt
    gt rx1237_pos, rx1237_eos, rx1237_done
    set rx1237_off, 0
    lt rx1237_pos, 2, rx1237_start
    sub rx1237_off, rx1237_pos, 1
    substr rx1237_tgt, rx1237_tgt, rx1237_off
  rx1237_start:
    eq $I10, 1, rx1237_restart
    if_null rx1237_debug, debug_921
    rx1237_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_921:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1241_done
    goto rxscan1241_scan
  rxscan1241_loop:
    (rx1237_pos) = rx1237_cur."from"()
    inc rx1237_pos
    rx1237_cur."!cursor_from"(rx1237_pos)
    ge rx1237_pos, rx1237_eos, rxscan1241_done
  rxscan1241_scan:
    set_addr $I10, rxscan1241_loop
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxscan1241_done:
.annotate 'line', 573
  # rx subrule "dotty" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."dotty"()
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1237_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."O"("%methodop")
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1237_pos = $P10."pos"()
  # rx pass
    rx1237_cur."!cursor_pass"(rx1237_pos, "postfix:sym<.>")
    if_null rx1237_debug, debug_922
    rx1237_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1237_pos)
  debug_922:
    .return (rx1237_cur)
  rx1237_restart:
.annotate 'line', 4
    if_null rx1237_debug, debug_923
    rx1237_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_923:
  rx1237_fail:
    (rx1237_rep, rx1237_pos, $I10, $P10) = rx1237_cur."!mark_fail"(0)
    lt rx1237_pos, -1, rx1237_done
    eq rx1237_pos, -1, rx1237_fail
    jump $I10
  rx1237_done:
    rx1237_cur."!cursor_fail"()
    if_null rx1237_debug, debug_924
    rx1237_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_924:
    .return (rx1237_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("279_1296306519.49046") :method
.annotate 'line', 4
    $P1239 = self."!PREFIX__!subrule"("dotty", "")
    new $P1240, "ResizablePMCArray"
    push $P1240, $P1239
    .return ($P1240)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("280_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1243_tgt
    .local int rx1243_pos
    .local int rx1243_off
    .local int rx1243_eos
    .local int rx1243_rep
    .local pmc rx1243_cur
    .local pmc rx1243_debug
    (rx1243_cur, rx1243_pos, rx1243_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1243_cur
    .local pmc match
    .lex "$/", match
    length rx1243_eos, rx1243_tgt
    gt rx1243_pos, rx1243_eos, rx1243_done
    set rx1243_off, 0
    lt rx1243_pos, 2, rx1243_start
    sub rx1243_off, rx1243_pos, 1
    substr rx1243_tgt, rx1243_tgt, rx1243_off
  rx1243_start:
    eq $I10, 1, rx1243_restart
    if_null rx1243_debug, debug_925
    rx1243_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_925:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1247_done
    goto rxscan1247_scan
  rxscan1247_loop:
    (rx1243_pos) = rx1243_cur."from"()
    inc rx1243_pos
    rx1243_cur."!cursor_from"(rx1243_pos)
    ge rx1243_pos, rx1243_eos, rxscan1247_done
  rxscan1247_scan:
    set_addr $I10, rxscan1247_loop
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  rxscan1247_done:
.annotate 'line', 575
  # rx subcapture "sym"
    set_addr $I10, rxcap_1248_fail
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  # rx literal  "++"
    add $I11, rx1243_pos, 2
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    substr $S10, rx1243_tgt, $I11, 2
    ne $S10, "++", rx1243_fail
    add rx1243_pos, 2
    set_addr $I10, rxcap_1248_fail
    ($I12, $I11) = rx1243_cur."!mark_peek"($I10)
    rx1243_cur."!cursor_pos"($I11)
    ($P10) = rx1243_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1243_pos, "")
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1248_done
  rxcap_1248_fail:
    goto rx1243_fail
  rxcap_1248_done:
  # rx subrule "O" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1243_fail
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1243_pos = $P10."pos"()
  # rx pass
    rx1243_cur."!cursor_pass"(rx1243_pos, "prefix:sym<++>")
    if_null rx1243_debug, debug_926
    rx1243_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1243_pos)
  debug_926:
    .return (rx1243_cur)
  rx1243_restart:
.annotate 'line', 4
    if_null rx1243_debug, debug_927
    rx1243_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_927:
  rx1243_fail:
    (rx1243_rep, rx1243_pos, $I10, $P10) = rx1243_cur."!mark_fail"(0)
    lt rx1243_pos, -1, rx1243_done
    eq rx1243_pos, -1, rx1243_fail
    jump $I10
  rx1243_done:
    rx1243_cur."!cursor_fail"()
    if_null rx1243_debug, debug_928
    rx1243_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_928:
    .return (rx1243_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("281_1296306519.49046") :method
.annotate 'line', 4
    $P1245 = self."!PREFIX__!subrule"("O", "++")
    new $P1246, "ResizablePMCArray"
    push $P1246, $P1245
    .return ($P1246)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("282_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1250_tgt
    .local int rx1250_pos
    .local int rx1250_off
    .local int rx1250_eos
    .local int rx1250_rep
    .local pmc rx1250_cur
    .local pmc rx1250_debug
    (rx1250_cur, rx1250_pos, rx1250_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1250_cur
    .local pmc match
    .lex "$/", match
    length rx1250_eos, rx1250_tgt
    gt rx1250_pos, rx1250_eos, rx1250_done
    set rx1250_off, 0
    lt rx1250_pos, 2, rx1250_start
    sub rx1250_off, rx1250_pos, 1
    substr rx1250_tgt, rx1250_tgt, rx1250_off
  rx1250_start:
    eq $I10, 1, rx1250_restart
    if_null rx1250_debug, debug_929
    rx1250_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_929:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1254_done
    goto rxscan1254_scan
  rxscan1254_loop:
    (rx1250_pos) = rx1250_cur."from"()
    inc rx1250_pos
    rx1250_cur."!cursor_from"(rx1250_pos)
    ge rx1250_pos, rx1250_eos, rxscan1254_done
  rxscan1254_scan:
    set_addr $I10, rxscan1254_loop
    rx1250_cur."!mark_push"(0, rx1250_pos, $I10)
  rxscan1254_done:
.annotate 'line', 576
  # rx subcapture "sym"
    set_addr $I10, rxcap_1255_fail
    rx1250_cur."!mark_push"(0, rx1250_pos, $I10)
  # rx literal  "--"
    add $I11, rx1250_pos, 2
    gt $I11, rx1250_eos, rx1250_fail
    sub $I11, rx1250_pos, rx1250_off
    substr $S10, rx1250_tgt, $I11, 2
    ne $S10, "--", rx1250_fail
    add rx1250_pos, 2
    set_addr $I10, rxcap_1255_fail
    ($I12, $I11) = rx1250_cur."!mark_peek"($I10)
    rx1250_cur."!cursor_pos"($I11)
    ($P10) = rx1250_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1250_pos, "")
    rx1250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1255_done
  rxcap_1255_fail:
    goto rx1250_fail
  rxcap_1255_done:
  # rx subrule "O" subtype=capture negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1250_fail
    rx1250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1250_pos = $P10."pos"()
  # rx pass
    rx1250_cur."!cursor_pass"(rx1250_pos, "prefix:sym<-->")
    if_null rx1250_debug, debug_930
    rx1250_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1250_pos)
  debug_930:
    .return (rx1250_cur)
  rx1250_restart:
.annotate 'line', 4
    if_null rx1250_debug, debug_931
    rx1250_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_931:
  rx1250_fail:
    (rx1250_rep, rx1250_pos, $I10, $P10) = rx1250_cur."!mark_fail"(0)
    lt rx1250_pos, -1, rx1250_done
    eq rx1250_pos, -1, rx1250_fail
    jump $I10
  rx1250_done:
    rx1250_cur."!cursor_fail"()
    if_null rx1250_debug, debug_932
    rx1250_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_932:
    .return (rx1250_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("283_1296306519.49046") :method
.annotate 'line', 4
    $P1252 = self."!PREFIX__!subrule"("O", "--")
    new $P1253, "ResizablePMCArray"
    push $P1253, $P1252
    .return ($P1253)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("284_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1257_tgt
    .local int rx1257_pos
    .local int rx1257_off
    .local int rx1257_eos
    .local int rx1257_rep
    .local pmc rx1257_cur
    .local pmc rx1257_debug
    (rx1257_cur, rx1257_pos, rx1257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1257_cur
    .local pmc match
    .lex "$/", match
    length rx1257_eos, rx1257_tgt
    gt rx1257_pos, rx1257_eos, rx1257_done
    set rx1257_off, 0
    lt rx1257_pos, 2, rx1257_start
    sub rx1257_off, rx1257_pos, 1
    substr rx1257_tgt, rx1257_tgt, rx1257_off
  rx1257_start:
    eq $I10, 1, rx1257_restart
    if_null rx1257_debug, debug_933
    rx1257_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_933:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1261_done
    goto rxscan1261_scan
  rxscan1261_loop:
    (rx1257_pos) = rx1257_cur."from"()
    inc rx1257_pos
    rx1257_cur."!cursor_from"(rx1257_pos)
    ge rx1257_pos, rx1257_eos, rxscan1261_done
  rxscan1261_scan:
    set_addr $I10, rxscan1261_loop
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
  rxscan1261_done:
.annotate 'line', 579
  # rx subcapture "sym"
    set_addr $I10, rxcap_1262_fail
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
  # rx literal  "++"
    add $I11, rx1257_pos, 2
    gt $I11, rx1257_eos, rx1257_fail
    sub $I11, rx1257_pos, rx1257_off
    substr $S10, rx1257_tgt, $I11, 2
    ne $S10, "++", rx1257_fail
    add rx1257_pos, 2
    set_addr $I10, rxcap_1262_fail
    ($I12, $I11) = rx1257_cur."!mark_peek"($I10)
    rx1257_cur."!cursor_pos"($I11)
    ($P10) = rx1257_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1257_pos, "")
    rx1257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1262_done
  rxcap_1262_fail:
    goto rx1257_fail
  rxcap_1262_done:
  # rx subrule "O" subtype=capture negate=
    rx1257_cur."!cursor_pos"(rx1257_pos)
    $P10 = rx1257_cur."O"("%autoincrement")
    unless $P10, rx1257_fail
    rx1257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1257_pos = $P10."pos"()
  # rx pass
    rx1257_cur."!cursor_pass"(rx1257_pos, "postfix:sym<++>")
    if_null rx1257_debug, debug_934
    rx1257_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1257_pos)
  debug_934:
    .return (rx1257_cur)
  rx1257_restart:
.annotate 'line', 4
    if_null rx1257_debug, debug_935
    rx1257_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_935:
  rx1257_fail:
    (rx1257_rep, rx1257_pos, $I10, $P10) = rx1257_cur."!mark_fail"(0)
    lt rx1257_pos, -1, rx1257_done
    eq rx1257_pos, -1, rx1257_fail
    jump $I10
  rx1257_done:
    rx1257_cur."!cursor_fail"()
    if_null rx1257_debug, debug_936
    rx1257_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_936:
    .return (rx1257_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("285_1296306519.49046") :method
.annotate 'line', 4
    $P1259 = self."!PREFIX__!subrule"("O", "++")
    new $P1260, "ResizablePMCArray"
    push $P1260, $P1259
    .return ($P1260)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("286_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1264_tgt
    .local int rx1264_pos
    .local int rx1264_off
    .local int rx1264_eos
    .local int rx1264_rep
    .local pmc rx1264_cur
    .local pmc rx1264_debug
    (rx1264_cur, rx1264_pos, rx1264_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1264_cur
    .local pmc match
    .lex "$/", match
    length rx1264_eos, rx1264_tgt
    gt rx1264_pos, rx1264_eos, rx1264_done
    set rx1264_off, 0
    lt rx1264_pos, 2, rx1264_start
    sub rx1264_off, rx1264_pos, 1
    substr rx1264_tgt, rx1264_tgt, rx1264_off
  rx1264_start:
    eq $I10, 1, rx1264_restart
    if_null rx1264_debug, debug_937
    rx1264_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_937:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1268_done
    goto rxscan1268_scan
  rxscan1268_loop:
    (rx1264_pos) = rx1264_cur."from"()
    inc rx1264_pos
    rx1264_cur."!cursor_from"(rx1264_pos)
    ge rx1264_pos, rx1264_eos, rxscan1268_done
  rxscan1268_scan:
    set_addr $I10, rxscan1268_loop
    rx1264_cur."!mark_push"(0, rx1264_pos, $I10)
  rxscan1268_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1269_fail
    rx1264_cur."!mark_push"(0, rx1264_pos, $I10)
  # rx literal  "--"
    add $I11, rx1264_pos, 2
    gt $I11, rx1264_eos, rx1264_fail
    sub $I11, rx1264_pos, rx1264_off
    substr $S10, rx1264_tgt, $I11, 2
    ne $S10, "--", rx1264_fail
    add rx1264_pos, 2
    set_addr $I10, rxcap_1269_fail
    ($I12, $I11) = rx1264_cur."!mark_peek"($I10)
    rx1264_cur."!cursor_pos"($I11)
    ($P10) = rx1264_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1264_pos, "")
    rx1264_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1269_done
  rxcap_1269_fail:
    goto rx1264_fail
  rxcap_1269_done:
  # rx subrule "O" subtype=capture negate=
    rx1264_cur."!cursor_pos"(rx1264_pos)
    $P10 = rx1264_cur."O"("%autoincrement")
    unless $P10, rx1264_fail
    rx1264_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1264_pos = $P10."pos"()
  # rx pass
    rx1264_cur."!cursor_pass"(rx1264_pos, "postfix:sym<-->")
    if_null rx1264_debug, debug_938
    rx1264_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1264_pos)
  debug_938:
    .return (rx1264_cur)
  rx1264_restart:
.annotate 'line', 4
    if_null rx1264_debug, debug_939
    rx1264_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_939:
  rx1264_fail:
    (rx1264_rep, rx1264_pos, $I10, $P10) = rx1264_cur."!mark_fail"(0)
    lt rx1264_pos, -1, rx1264_done
    eq rx1264_pos, -1, rx1264_fail
    jump $I10
  rx1264_done:
    rx1264_cur."!cursor_fail"()
    if_null rx1264_debug, debug_940
    rx1264_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_940:
    .return (rx1264_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("287_1296306519.49046") :method
.annotate 'line', 4
    $P1266 = self."!PREFIX__!subrule"("O", "--")
    new $P1267, "ResizablePMCArray"
    push $P1267, $P1266
    .return ($P1267)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("288_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1271_tgt
    .local int rx1271_pos
    .local int rx1271_off
    .local int rx1271_eos
    .local int rx1271_rep
    .local pmc rx1271_cur
    .local pmc rx1271_debug
    (rx1271_cur, rx1271_pos, rx1271_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1271_cur
    .local pmc match
    .lex "$/", match
    length rx1271_eos, rx1271_tgt
    gt rx1271_pos, rx1271_eos, rx1271_done
    set rx1271_off, 0
    lt rx1271_pos, 2, rx1271_start
    sub rx1271_off, rx1271_pos, 1
    substr rx1271_tgt, rx1271_tgt, rx1271_off
  rx1271_start:
    eq $I10, 1, rx1271_restart
    if_null rx1271_debug, debug_941
    rx1271_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1275_done
    goto rxscan1275_scan
  rxscan1275_loop:
    (rx1271_pos) = rx1271_cur."from"()
    inc rx1271_pos
    rx1271_cur."!cursor_from"(rx1271_pos)
    ge rx1271_pos, rx1271_eos, rxscan1275_done
  rxscan1275_scan:
    set_addr $I10, rxscan1275_loop
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  rxscan1275_done:
.annotate 'line', 582
  # rx subcapture "sym"
    set_addr $I10, rxcap_1276_fail
    rx1271_cur."!mark_push"(0, rx1271_pos, $I10)
  # rx literal  "**"
    add $I11, rx1271_pos, 2
    gt $I11, rx1271_eos, rx1271_fail
    sub $I11, rx1271_pos, rx1271_off
    substr $S10, rx1271_tgt, $I11, 2
    ne $S10, "**", rx1271_fail
    add rx1271_pos, 2
    set_addr $I10, rxcap_1276_fail
    ($I12, $I11) = rx1271_cur."!mark_peek"($I10)
    rx1271_cur."!cursor_pos"($I11)
    ($P10) = rx1271_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1271_pos, "")
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1276_done
  rxcap_1276_fail:
    goto rx1271_fail
  rxcap_1276_done:
  # rx subrule "O" subtype=capture negate=
    rx1271_cur."!cursor_pos"(rx1271_pos)
    $P10 = rx1271_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1271_fail
    rx1271_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1271_pos = $P10."pos"()
  # rx pass
    rx1271_cur."!cursor_pass"(rx1271_pos, "infix:sym<**>")
    if_null rx1271_debug, debug_942
    rx1271_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1271_pos)
  debug_942:
    .return (rx1271_cur)
  rx1271_restart:
.annotate 'line', 4
    if_null rx1271_debug, debug_943
    rx1271_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_943:
  rx1271_fail:
    (rx1271_rep, rx1271_pos, $I10, $P10) = rx1271_cur."!mark_fail"(0)
    lt rx1271_pos, -1, rx1271_done
    eq rx1271_pos, -1, rx1271_fail
    jump $I10
  rx1271_done:
    rx1271_cur."!cursor_fail"()
    if_null rx1271_debug, debug_944
    rx1271_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_944:
    .return (rx1271_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("289_1296306519.49046") :method
.annotate 'line', 4
    $P1273 = self."!PREFIX__!subrule"("O", "**")
    new $P1274, "ResizablePMCArray"
    push $P1274, $P1273
    .return ($P1274)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("290_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1278_tgt
    .local int rx1278_pos
    .local int rx1278_off
    .local int rx1278_eos
    .local int rx1278_rep
    .local pmc rx1278_cur
    .local pmc rx1278_debug
    (rx1278_cur, rx1278_pos, rx1278_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1278_cur
    .local pmc match
    .lex "$/", match
    length rx1278_eos, rx1278_tgt
    gt rx1278_pos, rx1278_eos, rx1278_done
    set rx1278_off, 0
    lt rx1278_pos, 2, rx1278_start
    sub rx1278_off, rx1278_pos, 1
    substr rx1278_tgt, rx1278_tgt, rx1278_off
  rx1278_start:
    eq $I10, 1, rx1278_restart
    if_null rx1278_debug, debug_945
    rx1278_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1282_done
    goto rxscan1282_scan
  rxscan1282_loop:
    (rx1278_pos) = rx1278_cur."from"()
    inc rx1278_pos
    rx1278_cur."!cursor_from"(rx1278_pos)
    ge rx1278_pos, rx1278_eos, rxscan1282_done
  rxscan1282_scan:
    set_addr $I10, rxscan1282_loop
    rx1278_cur."!mark_push"(0, rx1278_pos, $I10)
  rxscan1282_done:
.annotate 'line', 584
  # rx subcapture "sym"
    set_addr $I10, rxcap_1283_fail
    rx1278_cur."!mark_push"(0, rx1278_pos, $I10)
  # rx literal  "+"
    add $I11, rx1278_pos, 1
    gt $I11, rx1278_eos, rx1278_fail
    sub $I11, rx1278_pos, rx1278_off
    ord $I11, rx1278_tgt, $I11
    ne $I11, 43, rx1278_fail
    add rx1278_pos, 1
    set_addr $I10, rxcap_1283_fail
    ($I12, $I11) = rx1278_cur."!mark_peek"($I10)
    rx1278_cur."!cursor_pos"($I11)
    ($P10) = rx1278_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1278_pos, "")
    rx1278_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1283_done
  rxcap_1283_fail:
    goto rx1278_fail
  rxcap_1283_done:
  # rx subrule "O" subtype=capture negate=
    rx1278_cur."!cursor_pos"(rx1278_pos)
    $P10 = rx1278_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1278_fail
    rx1278_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1278_pos = $P10."pos"()
  # rx pass
    rx1278_cur."!cursor_pass"(rx1278_pos, "prefix:sym<+>")
    if_null rx1278_debug, debug_946
    rx1278_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1278_pos)
  debug_946:
    .return (rx1278_cur)
  rx1278_restart:
.annotate 'line', 4
    if_null rx1278_debug, debug_947
    rx1278_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_947:
  rx1278_fail:
    (rx1278_rep, rx1278_pos, $I10, $P10) = rx1278_cur."!mark_fail"(0)
    lt rx1278_pos, -1, rx1278_done
    eq rx1278_pos, -1, rx1278_fail
    jump $I10
  rx1278_done:
    rx1278_cur."!cursor_fail"()
    if_null rx1278_debug, debug_948
    rx1278_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_948:
    .return (rx1278_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("291_1296306519.49046") :method
.annotate 'line', 4
    $P1280 = self."!PREFIX__!subrule"("O", "+")
    new $P1281, "ResizablePMCArray"
    push $P1281, $P1280
    .return ($P1281)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("292_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1285_tgt
    .local int rx1285_pos
    .local int rx1285_off
    .local int rx1285_eos
    .local int rx1285_rep
    .local pmc rx1285_cur
    .local pmc rx1285_debug
    (rx1285_cur, rx1285_pos, rx1285_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1285_cur
    .local pmc match
    .lex "$/", match
    length rx1285_eos, rx1285_tgt
    gt rx1285_pos, rx1285_eos, rx1285_done
    set rx1285_off, 0
    lt rx1285_pos, 2, rx1285_start
    sub rx1285_off, rx1285_pos, 1
    substr rx1285_tgt, rx1285_tgt, rx1285_off
  rx1285_start:
    eq $I10, 1, rx1285_restart
    if_null rx1285_debug, debug_949
    rx1285_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1289_done
    goto rxscan1289_scan
  rxscan1289_loop:
    (rx1285_pos) = rx1285_cur."from"()
    inc rx1285_pos
    rx1285_cur."!cursor_from"(rx1285_pos)
    ge rx1285_pos, rx1285_eos, rxscan1289_done
  rxscan1289_scan:
    set_addr $I10, rxscan1289_loop
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
  rxscan1289_done:
.annotate 'line', 585
  # rx subcapture "sym"
    set_addr $I10, rxcap_1290_fail
    rx1285_cur."!mark_push"(0, rx1285_pos, $I10)
  # rx literal  "~"
    add $I11, rx1285_pos, 1
    gt $I11, rx1285_eos, rx1285_fail
    sub $I11, rx1285_pos, rx1285_off
    ord $I11, rx1285_tgt, $I11
    ne $I11, 126, rx1285_fail
    add rx1285_pos, 1
    set_addr $I10, rxcap_1290_fail
    ($I12, $I11) = rx1285_cur."!mark_peek"($I10)
    rx1285_cur."!cursor_pos"($I11)
    ($P10) = rx1285_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1285_pos, "")
    rx1285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1290_done
  rxcap_1290_fail:
    goto rx1285_fail
  rxcap_1290_done:
  # rx subrule "O" subtype=capture negate=
    rx1285_cur."!cursor_pos"(rx1285_pos)
    $P10 = rx1285_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1285_fail
    rx1285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1285_pos = $P10."pos"()
  # rx pass
    rx1285_cur."!cursor_pass"(rx1285_pos, "prefix:sym<~>")
    if_null rx1285_debug, debug_950
    rx1285_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1285_pos)
  debug_950:
    .return (rx1285_cur)
  rx1285_restart:
.annotate 'line', 4
    if_null rx1285_debug, debug_951
    rx1285_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_951:
  rx1285_fail:
    (rx1285_rep, rx1285_pos, $I10, $P10) = rx1285_cur."!mark_fail"(0)
    lt rx1285_pos, -1, rx1285_done
    eq rx1285_pos, -1, rx1285_fail
    jump $I10
  rx1285_done:
    rx1285_cur."!cursor_fail"()
    if_null rx1285_debug, debug_952
    rx1285_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_952:
    .return (rx1285_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("293_1296306519.49046") :method
.annotate 'line', 4
    $P1287 = self."!PREFIX__!subrule"("O", "~")
    new $P1288, "ResizablePMCArray"
    push $P1288, $P1287
    .return ($P1288)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("294_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1292_tgt
    .local int rx1292_pos
    .local int rx1292_off
    .local int rx1292_eos
    .local int rx1292_rep
    .local pmc rx1292_cur
    .local pmc rx1292_debug
    (rx1292_cur, rx1292_pos, rx1292_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1292_cur
    .local pmc match
    .lex "$/", match
    length rx1292_eos, rx1292_tgt
    gt rx1292_pos, rx1292_eos, rx1292_done
    set rx1292_off, 0
    lt rx1292_pos, 2, rx1292_start
    sub rx1292_off, rx1292_pos, 1
    substr rx1292_tgt, rx1292_tgt, rx1292_off
  rx1292_start:
    eq $I10, 1, rx1292_restart
    if_null rx1292_debug, debug_953
    rx1292_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1295_done
    goto rxscan1295_scan
  rxscan1295_loop:
    (rx1292_pos) = rx1292_cur."from"()
    inc rx1292_pos
    rx1292_cur."!cursor_from"(rx1292_pos)
    ge rx1292_pos, rx1292_eos, rxscan1295_done
  rxscan1295_scan:
    set_addr $I10, rxscan1295_loop
    rx1292_cur."!mark_push"(0, rx1292_pos, $I10)
  rxscan1295_done:
.annotate 'line', 586
  # rx subcapture "sym"
    set_addr $I10, rxcap_1296_fail
    rx1292_cur."!mark_push"(0, rx1292_pos, $I10)
  # rx literal  "-"
    add $I11, rx1292_pos, 1
    gt $I11, rx1292_eos, rx1292_fail
    sub $I11, rx1292_pos, rx1292_off
    ord $I11, rx1292_tgt, $I11
    ne $I11, 45, rx1292_fail
    add rx1292_pos, 1
    set_addr $I10, rxcap_1296_fail
    ($I12, $I11) = rx1292_cur."!mark_peek"($I10)
    rx1292_cur."!cursor_pos"($I11)
    ($P10) = rx1292_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1292_pos, "")
    rx1292_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1296_done
  rxcap_1296_fail:
    goto rx1292_fail
  rxcap_1296_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1292_pos, rx1292_off
    substr $S10, rx1292_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1292_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1292_cur."!cursor_pos"(rx1292_pos)
    $P10 = rx1292_cur."number"()
    if $P10, rx1292_fail
  # rx subrule "O" subtype=capture negate=
    rx1292_cur."!cursor_pos"(rx1292_pos)
    $P10 = rx1292_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1292_fail
    rx1292_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1292_pos = $P10."pos"()
  # rx pass
    rx1292_cur."!cursor_pass"(rx1292_pos, "prefix:sym<->")
    if_null rx1292_debug, debug_954
    rx1292_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1292_pos)
  debug_954:
    .return (rx1292_cur)
  rx1292_restart:
.annotate 'line', 4
    if_null rx1292_debug, debug_955
    rx1292_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_955:
  rx1292_fail:
    (rx1292_rep, rx1292_pos, $I10, $P10) = rx1292_cur."!mark_fail"(0)
    lt rx1292_pos, -1, rx1292_done
    eq rx1292_pos, -1, rx1292_fail
    jump $I10
  rx1292_done:
    rx1292_cur."!cursor_fail"()
    if_null rx1292_debug, debug_956
    rx1292_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_956:
    .return (rx1292_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("295_1296306519.49046") :method
.annotate 'line', 4
    new $P1294, "ResizablePMCArray"
    push $P1294, "-"
    .return ($P1294)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("296_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1298_tgt
    .local int rx1298_pos
    .local int rx1298_off
    .local int rx1298_eos
    .local int rx1298_rep
    .local pmc rx1298_cur
    .local pmc rx1298_debug
    (rx1298_cur, rx1298_pos, rx1298_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1298_cur
    .local pmc match
    .lex "$/", match
    length rx1298_eos, rx1298_tgt
    gt rx1298_pos, rx1298_eos, rx1298_done
    set rx1298_off, 0
    lt rx1298_pos, 2, rx1298_start
    sub rx1298_off, rx1298_pos, 1
    substr rx1298_tgt, rx1298_tgt, rx1298_off
  rx1298_start:
    eq $I10, 1, rx1298_restart
    if_null rx1298_debug, debug_957
    rx1298_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_957:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1302_done
    goto rxscan1302_scan
  rxscan1302_loop:
    (rx1298_pos) = rx1298_cur."from"()
    inc rx1298_pos
    rx1298_cur."!cursor_from"(rx1298_pos)
    ge rx1298_pos, rx1298_eos, rxscan1302_done
  rxscan1302_scan:
    set_addr $I10, rxscan1302_loop
    rx1298_cur."!mark_push"(0, rx1298_pos, $I10)
  rxscan1302_done:
.annotate 'line', 587
  # rx subcapture "sym"
    set_addr $I10, rxcap_1303_fail
    rx1298_cur."!mark_push"(0, rx1298_pos, $I10)
  # rx literal  "?"
    add $I11, rx1298_pos, 1
    gt $I11, rx1298_eos, rx1298_fail
    sub $I11, rx1298_pos, rx1298_off
    ord $I11, rx1298_tgt, $I11
    ne $I11, 63, rx1298_fail
    add rx1298_pos, 1
    set_addr $I10, rxcap_1303_fail
    ($I12, $I11) = rx1298_cur."!mark_peek"($I10)
    rx1298_cur."!cursor_pos"($I11)
    ($P10) = rx1298_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1298_pos, "")
    rx1298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1303_done
  rxcap_1303_fail:
    goto rx1298_fail
  rxcap_1303_done:
  # rx subrule "O" subtype=capture negate=
    rx1298_cur."!cursor_pos"(rx1298_pos)
    $P10 = rx1298_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1298_fail
    rx1298_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1298_pos = $P10."pos"()
  # rx pass
    rx1298_cur."!cursor_pass"(rx1298_pos, "prefix:sym<?>")
    if_null rx1298_debug, debug_958
    rx1298_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1298_pos)
  debug_958:
    .return (rx1298_cur)
  rx1298_restart:
.annotate 'line', 4
    if_null rx1298_debug, debug_959
    rx1298_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_959:
  rx1298_fail:
    (rx1298_rep, rx1298_pos, $I10, $P10) = rx1298_cur."!mark_fail"(0)
    lt rx1298_pos, -1, rx1298_done
    eq rx1298_pos, -1, rx1298_fail
    jump $I10
  rx1298_done:
    rx1298_cur."!cursor_fail"()
    if_null rx1298_debug, debug_960
    rx1298_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_960:
    .return (rx1298_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("297_1296306519.49046") :method
.annotate 'line', 4
    $P1300 = self."!PREFIX__!subrule"("O", "?")
    new $P1301, "ResizablePMCArray"
    push $P1301, $P1300
    .return ($P1301)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("298_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1305_tgt
    .local int rx1305_pos
    .local int rx1305_off
    .local int rx1305_eos
    .local int rx1305_rep
    .local pmc rx1305_cur
    .local pmc rx1305_debug
    (rx1305_cur, rx1305_pos, rx1305_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1305_cur
    .local pmc match
    .lex "$/", match
    length rx1305_eos, rx1305_tgt
    gt rx1305_pos, rx1305_eos, rx1305_done
    set rx1305_off, 0
    lt rx1305_pos, 2, rx1305_start
    sub rx1305_off, rx1305_pos, 1
    substr rx1305_tgt, rx1305_tgt, rx1305_off
  rx1305_start:
    eq $I10, 1, rx1305_restart
    if_null rx1305_debug, debug_961
    rx1305_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_961:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1309_done
    goto rxscan1309_scan
  rxscan1309_loop:
    (rx1305_pos) = rx1305_cur."from"()
    inc rx1305_pos
    rx1305_cur."!cursor_from"(rx1305_pos)
    ge rx1305_pos, rx1305_eos, rxscan1309_done
  rxscan1309_scan:
    set_addr $I10, rxscan1309_loop
    rx1305_cur."!mark_push"(0, rx1305_pos, $I10)
  rxscan1309_done:
.annotate 'line', 588
  # rx subcapture "sym"
    set_addr $I10, rxcap_1310_fail
    rx1305_cur."!mark_push"(0, rx1305_pos, $I10)
  # rx literal  "!"
    add $I11, rx1305_pos, 1
    gt $I11, rx1305_eos, rx1305_fail
    sub $I11, rx1305_pos, rx1305_off
    ord $I11, rx1305_tgt, $I11
    ne $I11, 33, rx1305_fail
    add rx1305_pos, 1
    set_addr $I10, rxcap_1310_fail
    ($I12, $I11) = rx1305_cur."!mark_peek"($I10)
    rx1305_cur."!cursor_pos"($I11)
    ($P10) = rx1305_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1305_pos, "")
    rx1305_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1310_done
  rxcap_1310_fail:
    goto rx1305_fail
  rxcap_1310_done:
  # rx subrule "O" subtype=capture negate=
    rx1305_cur."!cursor_pos"(rx1305_pos)
    $P10 = rx1305_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1305_fail
    rx1305_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1305_pos = $P10."pos"()
  # rx pass
    rx1305_cur."!cursor_pass"(rx1305_pos, "prefix:sym<!>")
    if_null rx1305_debug, debug_962
    rx1305_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1305_pos)
  debug_962:
    .return (rx1305_cur)
  rx1305_restart:
.annotate 'line', 4
    if_null rx1305_debug, debug_963
    rx1305_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_963:
  rx1305_fail:
    (rx1305_rep, rx1305_pos, $I10, $P10) = rx1305_cur."!mark_fail"(0)
    lt rx1305_pos, -1, rx1305_done
    eq rx1305_pos, -1, rx1305_fail
    jump $I10
  rx1305_done:
    rx1305_cur."!cursor_fail"()
    if_null rx1305_debug, debug_964
    rx1305_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_964:
    .return (rx1305_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("299_1296306519.49046") :method
.annotate 'line', 4
    $P1307 = self."!PREFIX__!subrule"("O", "!")
    new $P1308, "ResizablePMCArray"
    push $P1308, $P1307
    .return ($P1308)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("300_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1312_tgt
    .local int rx1312_pos
    .local int rx1312_off
    .local int rx1312_eos
    .local int rx1312_rep
    .local pmc rx1312_cur
    .local pmc rx1312_debug
    (rx1312_cur, rx1312_pos, rx1312_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1312_cur
    .local pmc match
    .lex "$/", match
    length rx1312_eos, rx1312_tgt
    gt rx1312_pos, rx1312_eos, rx1312_done
    set rx1312_off, 0
    lt rx1312_pos, 2, rx1312_start
    sub rx1312_off, rx1312_pos, 1
    substr rx1312_tgt, rx1312_tgt, rx1312_off
  rx1312_start:
    eq $I10, 1, rx1312_restart
    if_null rx1312_debug, debug_965
    rx1312_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_965:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1316_done
    goto rxscan1316_scan
  rxscan1316_loop:
    (rx1312_pos) = rx1312_cur."from"()
    inc rx1312_pos
    rx1312_cur."!cursor_from"(rx1312_pos)
    ge rx1312_pos, rx1312_eos, rxscan1316_done
  rxscan1316_scan:
    set_addr $I10, rxscan1316_loop
    rx1312_cur."!mark_push"(0, rx1312_pos, $I10)
  rxscan1316_done:
.annotate 'line', 589
  # rx subcapture "sym"
    set_addr $I10, rxcap_1317_fail
    rx1312_cur."!mark_push"(0, rx1312_pos, $I10)
  # rx literal  "|"
    add $I11, rx1312_pos, 1
    gt $I11, rx1312_eos, rx1312_fail
    sub $I11, rx1312_pos, rx1312_off
    ord $I11, rx1312_tgt, $I11
    ne $I11, 124, rx1312_fail
    add rx1312_pos, 1
    set_addr $I10, rxcap_1317_fail
    ($I12, $I11) = rx1312_cur."!mark_peek"($I10)
    rx1312_cur."!cursor_pos"($I11)
    ($P10) = rx1312_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1312_pos, "")
    rx1312_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1317_done
  rxcap_1317_fail:
    goto rx1312_fail
  rxcap_1317_done:
  # rx subrule "O" subtype=capture negate=
    rx1312_cur."!cursor_pos"(rx1312_pos)
    $P10 = rx1312_cur."O"("%symbolic_unary")
    unless $P10, rx1312_fail
    rx1312_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1312_pos = $P10."pos"()
  # rx pass
    rx1312_cur."!cursor_pass"(rx1312_pos, "prefix:sym<|>")
    if_null rx1312_debug, debug_966
    rx1312_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1312_pos)
  debug_966:
    .return (rx1312_cur)
  rx1312_restart:
.annotate 'line', 4
    if_null rx1312_debug, debug_967
    rx1312_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_967:
  rx1312_fail:
    (rx1312_rep, rx1312_pos, $I10, $P10) = rx1312_cur."!mark_fail"(0)
    lt rx1312_pos, -1, rx1312_done
    eq rx1312_pos, -1, rx1312_fail
    jump $I10
  rx1312_done:
    rx1312_cur."!cursor_fail"()
    if_null rx1312_debug, debug_968
    rx1312_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_968:
    .return (rx1312_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("301_1296306519.49046") :method
.annotate 'line', 4
    $P1314 = self."!PREFIX__!subrule"("O", "|")
    new $P1315, "ResizablePMCArray"
    push $P1315, $P1314
    .return ($P1315)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("302_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1319_tgt
    .local int rx1319_pos
    .local int rx1319_off
    .local int rx1319_eos
    .local int rx1319_rep
    .local pmc rx1319_cur
    .local pmc rx1319_debug
    (rx1319_cur, rx1319_pos, rx1319_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1319_cur
    .local pmc match
    .lex "$/", match
    length rx1319_eos, rx1319_tgt
    gt rx1319_pos, rx1319_eos, rx1319_done
    set rx1319_off, 0
    lt rx1319_pos, 2, rx1319_start
    sub rx1319_off, rx1319_pos, 1
    substr rx1319_tgt, rx1319_tgt, rx1319_off
  rx1319_start:
    eq $I10, 1, rx1319_restart
    if_null rx1319_debug, debug_969
    rx1319_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_969:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1323_done
    goto rxscan1323_scan
  rxscan1323_loop:
    (rx1319_pos) = rx1319_cur."from"()
    inc rx1319_pos
    rx1319_cur."!cursor_from"(rx1319_pos)
    ge rx1319_pos, rx1319_eos, rxscan1323_done
  rxscan1323_scan:
    set_addr $I10, rxscan1323_loop
    rx1319_cur."!mark_push"(0, rx1319_pos, $I10)
  rxscan1323_done:
.annotate 'line', 591
  # rx subcapture "sym"
    set_addr $I10, rxcap_1324_fail
    rx1319_cur."!mark_push"(0, rx1319_pos, $I10)
  # rx literal  "*"
    add $I11, rx1319_pos, 1
    gt $I11, rx1319_eos, rx1319_fail
    sub $I11, rx1319_pos, rx1319_off
    ord $I11, rx1319_tgt, $I11
    ne $I11, 42, rx1319_fail
    add rx1319_pos, 1
    set_addr $I10, rxcap_1324_fail
    ($I12, $I11) = rx1319_cur."!mark_peek"($I10)
    rx1319_cur."!cursor_pos"($I11)
    ($P10) = rx1319_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1319_pos, "")
    rx1319_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1324_done
  rxcap_1324_fail:
    goto rx1319_fail
  rxcap_1324_done:
  # rx subrule "O" subtype=capture negate=
    rx1319_cur."!cursor_pos"(rx1319_pos)
    $P10 = rx1319_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1319_fail
    rx1319_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1319_pos = $P10."pos"()
  # rx pass
    rx1319_cur."!cursor_pass"(rx1319_pos, "infix:sym<*>")
    if_null rx1319_debug, debug_970
    rx1319_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1319_pos)
  debug_970:
    .return (rx1319_cur)
  rx1319_restart:
.annotate 'line', 4
    if_null rx1319_debug, debug_971
    rx1319_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_971:
  rx1319_fail:
    (rx1319_rep, rx1319_pos, $I10, $P10) = rx1319_cur."!mark_fail"(0)
    lt rx1319_pos, -1, rx1319_done
    eq rx1319_pos, -1, rx1319_fail
    jump $I10
  rx1319_done:
    rx1319_cur."!cursor_fail"()
    if_null rx1319_debug, debug_972
    rx1319_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_972:
    .return (rx1319_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("303_1296306519.49046") :method
.annotate 'line', 4
    $P1321 = self."!PREFIX__!subrule"("O", "*")
    new $P1322, "ResizablePMCArray"
    push $P1322, $P1321
    .return ($P1322)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("304_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1326_tgt
    .local int rx1326_pos
    .local int rx1326_off
    .local int rx1326_eos
    .local int rx1326_rep
    .local pmc rx1326_cur
    .local pmc rx1326_debug
    (rx1326_cur, rx1326_pos, rx1326_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1326_cur
    .local pmc match
    .lex "$/", match
    length rx1326_eos, rx1326_tgt
    gt rx1326_pos, rx1326_eos, rx1326_done
    set rx1326_off, 0
    lt rx1326_pos, 2, rx1326_start
    sub rx1326_off, rx1326_pos, 1
    substr rx1326_tgt, rx1326_tgt, rx1326_off
  rx1326_start:
    eq $I10, 1, rx1326_restart
    if_null rx1326_debug, debug_973
    rx1326_cur."!cursor_debug"("START", "infix:sym</>")
  debug_973:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1330_done
    goto rxscan1330_scan
  rxscan1330_loop:
    (rx1326_pos) = rx1326_cur."from"()
    inc rx1326_pos
    rx1326_cur."!cursor_from"(rx1326_pos)
    ge rx1326_pos, rx1326_eos, rxscan1330_done
  rxscan1330_scan:
    set_addr $I10, rxscan1330_loop
    rx1326_cur."!mark_push"(0, rx1326_pos, $I10)
  rxscan1330_done:
.annotate 'line', 592
  # rx subcapture "sym"
    set_addr $I10, rxcap_1331_fail
    rx1326_cur."!mark_push"(0, rx1326_pos, $I10)
  # rx literal  "/"
    add $I11, rx1326_pos, 1
    gt $I11, rx1326_eos, rx1326_fail
    sub $I11, rx1326_pos, rx1326_off
    ord $I11, rx1326_tgt, $I11
    ne $I11, 47, rx1326_fail
    add rx1326_pos, 1
    set_addr $I10, rxcap_1331_fail
    ($I12, $I11) = rx1326_cur."!mark_peek"($I10)
    rx1326_cur."!cursor_pos"($I11)
    ($P10) = rx1326_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1326_pos, "")
    rx1326_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1331_done
  rxcap_1331_fail:
    goto rx1326_fail
  rxcap_1331_done:
  # rx subrule "O" subtype=capture negate=
    rx1326_cur."!cursor_pos"(rx1326_pos)
    $P10 = rx1326_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1326_fail
    rx1326_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1326_pos = $P10."pos"()
  # rx pass
    rx1326_cur."!cursor_pass"(rx1326_pos, "infix:sym</>")
    if_null rx1326_debug, debug_974
    rx1326_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1326_pos)
  debug_974:
    .return (rx1326_cur)
  rx1326_restart:
.annotate 'line', 4
    if_null rx1326_debug, debug_975
    rx1326_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_975:
  rx1326_fail:
    (rx1326_rep, rx1326_pos, $I10, $P10) = rx1326_cur."!mark_fail"(0)
    lt rx1326_pos, -1, rx1326_done
    eq rx1326_pos, -1, rx1326_fail
    jump $I10
  rx1326_done:
    rx1326_cur."!cursor_fail"()
    if_null rx1326_debug, debug_976
    rx1326_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_976:
    .return (rx1326_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("305_1296306519.49046") :method
.annotate 'line', 4
    $P1328 = self."!PREFIX__!subrule"("O", "/")
    new $P1329, "ResizablePMCArray"
    push $P1329, $P1328
    .return ($P1329)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("306_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1333_tgt
    .local int rx1333_pos
    .local int rx1333_off
    .local int rx1333_eos
    .local int rx1333_rep
    .local pmc rx1333_cur
    .local pmc rx1333_debug
    (rx1333_cur, rx1333_pos, rx1333_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1333_cur
    .local pmc match
    .lex "$/", match
    length rx1333_eos, rx1333_tgt
    gt rx1333_pos, rx1333_eos, rx1333_done
    set rx1333_off, 0
    lt rx1333_pos, 2, rx1333_start
    sub rx1333_off, rx1333_pos, 1
    substr rx1333_tgt, rx1333_tgt, rx1333_off
  rx1333_start:
    eq $I10, 1, rx1333_restart
    if_null rx1333_debug, debug_977
    rx1333_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1337_done
    goto rxscan1337_scan
  rxscan1337_loop:
    (rx1333_pos) = rx1333_cur."from"()
    inc rx1333_pos
    rx1333_cur."!cursor_from"(rx1333_pos)
    ge rx1333_pos, rx1333_eos, rxscan1337_done
  rxscan1337_scan:
    set_addr $I10, rxscan1337_loop
    rx1333_cur."!mark_push"(0, rx1333_pos, $I10)
  rxscan1337_done:
.annotate 'line', 593
  # rx subcapture "sym"
    set_addr $I10, rxcap_1338_fail
    rx1333_cur."!mark_push"(0, rx1333_pos, $I10)
  # rx literal  "%"
    add $I11, rx1333_pos, 1
    gt $I11, rx1333_eos, rx1333_fail
    sub $I11, rx1333_pos, rx1333_off
    ord $I11, rx1333_tgt, $I11
    ne $I11, 37, rx1333_fail
    add rx1333_pos, 1
    set_addr $I10, rxcap_1338_fail
    ($I12, $I11) = rx1333_cur."!mark_peek"($I10)
    rx1333_cur."!cursor_pos"($I11)
    ($P10) = rx1333_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1333_pos, "")
    rx1333_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1338_done
  rxcap_1338_fail:
    goto rx1333_fail
  rxcap_1338_done:
  # rx subrule "O" subtype=capture negate=
    rx1333_cur."!cursor_pos"(rx1333_pos)
    $P10 = rx1333_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1333_fail
    rx1333_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1333_pos = $P10."pos"()
  # rx pass
    rx1333_cur."!cursor_pass"(rx1333_pos, "infix:sym<%>")
    if_null rx1333_debug, debug_978
    rx1333_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1333_pos)
  debug_978:
    .return (rx1333_cur)
  rx1333_restart:
.annotate 'line', 4
    if_null rx1333_debug, debug_979
    rx1333_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_979:
  rx1333_fail:
    (rx1333_rep, rx1333_pos, $I10, $P10) = rx1333_cur."!mark_fail"(0)
    lt rx1333_pos, -1, rx1333_done
    eq rx1333_pos, -1, rx1333_fail
    jump $I10
  rx1333_done:
    rx1333_cur."!cursor_fail"()
    if_null rx1333_debug, debug_980
    rx1333_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_980:
    .return (rx1333_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("307_1296306519.49046") :method
.annotate 'line', 4
    $P1335 = self."!PREFIX__!subrule"("O", "%")
    new $P1336, "ResizablePMCArray"
    push $P1336, $P1335
    .return ($P1336)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("308_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1340_tgt
    .local int rx1340_pos
    .local int rx1340_off
    .local int rx1340_eos
    .local int rx1340_rep
    .local pmc rx1340_cur
    .local pmc rx1340_debug
    (rx1340_cur, rx1340_pos, rx1340_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1340_cur
    .local pmc match
    .lex "$/", match
    length rx1340_eos, rx1340_tgt
    gt rx1340_pos, rx1340_eos, rx1340_done
    set rx1340_off, 0
    lt rx1340_pos, 2, rx1340_start
    sub rx1340_off, rx1340_pos, 1
    substr rx1340_tgt, rx1340_tgt, rx1340_off
  rx1340_start:
    eq $I10, 1, rx1340_restart
    if_null rx1340_debug, debug_981
    rx1340_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1344_done
    goto rxscan1344_scan
  rxscan1344_loop:
    (rx1340_pos) = rx1340_cur."from"()
    inc rx1340_pos
    rx1340_cur."!cursor_from"(rx1340_pos)
    ge rx1340_pos, rx1340_eos, rxscan1344_done
  rxscan1344_scan:
    set_addr $I10, rxscan1344_loop
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  rxscan1344_done:
.annotate 'line', 594
  # rx subcapture "sym"
    set_addr $I10, rxcap_1345_fail
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1340_pos, 2
    gt $I11, rx1340_eos, rx1340_fail
    sub $I11, rx1340_pos, rx1340_off
    substr $S10, rx1340_tgt, $I11, 2
    ne $S10, "+&", rx1340_fail
    add rx1340_pos, 2
    set_addr $I10, rxcap_1345_fail
    ($I12, $I11) = rx1340_cur."!mark_peek"($I10)
    rx1340_cur."!cursor_pos"($I11)
    ($P10) = rx1340_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1340_pos, "")
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1345_done
  rxcap_1345_fail:
    goto rx1340_fail
  rxcap_1345_done:
  # rx subrule "O" subtype=capture negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1340_fail
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1340_pos = $P10."pos"()
  # rx pass
    rx1340_cur."!cursor_pass"(rx1340_pos, "infix:sym<+&>")
    if_null rx1340_debug, debug_982
    rx1340_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1340_pos)
  debug_982:
    .return (rx1340_cur)
  rx1340_restart:
.annotate 'line', 4
    if_null rx1340_debug, debug_983
    rx1340_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_983:
  rx1340_fail:
    (rx1340_rep, rx1340_pos, $I10, $P10) = rx1340_cur."!mark_fail"(0)
    lt rx1340_pos, -1, rx1340_done
    eq rx1340_pos, -1, rx1340_fail
    jump $I10
  rx1340_done:
    rx1340_cur."!cursor_fail"()
    if_null rx1340_debug, debug_984
    rx1340_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_984:
    .return (rx1340_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("309_1296306519.49046") :method
.annotate 'line', 4
    $P1342 = self."!PREFIX__!subrule"("O", "+&")
    new $P1343, "ResizablePMCArray"
    push $P1343, $P1342
    .return ($P1343)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("310_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1347_tgt
    .local int rx1347_pos
    .local int rx1347_off
    .local int rx1347_eos
    .local int rx1347_rep
    .local pmc rx1347_cur
    .local pmc rx1347_debug
    (rx1347_cur, rx1347_pos, rx1347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1347_cur
    .local pmc match
    .lex "$/", match
    length rx1347_eos, rx1347_tgt
    gt rx1347_pos, rx1347_eos, rx1347_done
    set rx1347_off, 0
    lt rx1347_pos, 2, rx1347_start
    sub rx1347_off, rx1347_pos, 1
    substr rx1347_tgt, rx1347_tgt, rx1347_off
  rx1347_start:
    eq $I10, 1, rx1347_restart
    if_null rx1347_debug, debug_985
    rx1347_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1351_done
    goto rxscan1351_scan
  rxscan1351_loop:
    (rx1347_pos) = rx1347_cur."from"()
    inc rx1347_pos
    rx1347_cur."!cursor_from"(rx1347_pos)
    ge rx1347_pos, rx1347_eos, rxscan1351_done
  rxscan1351_scan:
    set_addr $I10, rxscan1351_loop
    rx1347_cur."!mark_push"(0, rx1347_pos, $I10)
  rxscan1351_done:
.annotate 'line', 596
  # rx subcapture "sym"
    set_addr $I10, rxcap_1352_fail
    rx1347_cur."!mark_push"(0, rx1347_pos, $I10)
  # rx literal  "+"
    add $I11, rx1347_pos, 1
    gt $I11, rx1347_eos, rx1347_fail
    sub $I11, rx1347_pos, rx1347_off
    ord $I11, rx1347_tgt, $I11
    ne $I11, 43, rx1347_fail
    add rx1347_pos, 1
    set_addr $I10, rxcap_1352_fail
    ($I12, $I11) = rx1347_cur."!mark_peek"($I10)
    rx1347_cur."!cursor_pos"($I11)
    ($P10) = rx1347_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1347_pos, "")
    rx1347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1352_done
  rxcap_1352_fail:
    goto rx1347_fail
  rxcap_1352_done:
  # rx subrule "O" subtype=capture negate=
    rx1347_cur."!cursor_pos"(rx1347_pos)
    $P10 = rx1347_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1347_fail
    rx1347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1347_pos = $P10."pos"()
  # rx pass
    rx1347_cur."!cursor_pass"(rx1347_pos, "infix:sym<+>")
    if_null rx1347_debug, debug_986
    rx1347_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1347_pos)
  debug_986:
    .return (rx1347_cur)
  rx1347_restart:
.annotate 'line', 4
    if_null rx1347_debug, debug_987
    rx1347_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_987:
  rx1347_fail:
    (rx1347_rep, rx1347_pos, $I10, $P10) = rx1347_cur."!mark_fail"(0)
    lt rx1347_pos, -1, rx1347_done
    eq rx1347_pos, -1, rx1347_fail
    jump $I10
  rx1347_done:
    rx1347_cur."!cursor_fail"()
    if_null rx1347_debug, debug_988
    rx1347_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_988:
    .return (rx1347_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("311_1296306519.49046") :method
.annotate 'line', 4
    $P1349 = self."!PREFIX__!subrule"("O", "+")
    new $P1350, "ResizablePMCArray"
    push $P1350, $P1349
    .return ($P1350)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("312_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1354_tgt
    .local int rx1354_pos
    .local int rx1354_off
    .local int rx1354_eos
    .local int rx1354_rep
    .local pmc rx1354_cur
    .local pmc rx1354_debug
    (rx1354_cur, rx1354_pos, rx1354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1354_cur
    .local pmc match
    .lex "$/", match
    length rx1354_eos, rx1354_tgt
    gt rx1354_pos, rx1354_eos, rx1354_done
    set rx1354_off, 0
    lt rx1354_pos, 2, rx1354_start
    sub rx1354_off, rx1354_pos, 1
    substr rx1354_tgt, rx1354_tgt, rx1354_off
  rx1354_start:
    eq $I10, 1, rx1354_restart
    if_null rx1354_debug, debug_989
    rx1354_cur."!cursor_debug"("START", "infix:sym<->")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1358_done
    goto rxscan1358_scan
  rxscan1358_loop:
    (rx1354_pos) = rx1354_cur."from"()
    inc rx1354_pos
    rx1354_cur."!cursor_from"(rx1354_pos)
    ge rx1354_pos, rx1354_eos, rxscan1358_done
  rxscan1358_scan:
    set_addr $I10, rxscan1358_loop
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
  rxscan1358_done:
.annotate 'line', 597
  # rx subcapture "sym"
    set_addr $I10, rxcap_1359_fail
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
  # rx literal  "-"
    add $I11, rx1354_pos, 1
    gt $I11, rx1354_eos, rx1354_fail
    sub $I11, rx1354_pos, rx1354_off
    ord $I11, rx1354_tgt, $I11
    ne $I11, 45, rx1354_fail
    add rx1354_pos, 1
    set_addr $I10, rxcap_1359_fail
    ($I12, $I11) = rx1354_cur."!mark_peek"($I10)
    rx1354_cur."!cursor_pos"($I11)
    ($P10) = rx1354_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1354_pos, "")
    rx1354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1359_done
  rxcap_1359_fail:
    goto rx1354_fail
  rxcap_1359_done:
  # rx subrule "O" subtype=capture negate=
    rx1354_cur."!cursor_pos"(rx1354_pos)
    $P10 = rx1354_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1354_fail
    rx1354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1354_pos = $P10."pos"()
  # rx pass
    rx1354_cur."!cursor_pass"(rx1354_pos, "infix:sym<->")
    if_null rx1354_debug, debug_990
    rx1354_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1354_pos)
  debug_990:
    .return (rx1354_cur)
  rx1354_restart:
.annotate 'line', 4
    if_null rx1354_debug, debug_991
    rx1354_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_991:
  rx1354_fail:
    (rx1354_rep, rx1354_pos, $I10, $P10) = rx1354_cur."!mark_fail"(0)
    lt rx1354_pos, -1, rx1354_done
    eq rx1354_pos, -1, rx1354_fail
    jump $I10
  rx1354_done:
    rx1354_cur."!cursor_fail"()
    if_null rx1354_debug, debug_992
    rx1354_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_992:
    .return (rx1354_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("313_1296306519.49046") :method
.annotate 'line', 4
    $P1356 = self."!PREFIX__!subrule"("O", "-")
    new $P1357, "ResizablePMCArray"
    push $P1357, $P1356
    .return ($P1357)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("314_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1361_tgt
    .local int rx1361_pos
    .local int rx1361_off
    .local int rx1361_eos
    .local int rx1361_rep
    .local pmc rx1361_cur
    .local pmc rx1361_debug
    (rx1361_cur, rx1361_pos, rx1361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1361_cur
    .local pmc match
    .lex "$/", match
    length rx1361_eos, rx1361_tgt
    gt rx1361_pos, rx1361_eos, rx1361_done
    set rx1361_off, 0
    lt rx1361_pos, 2, rx1361_start
    sub rx1361_off, rx1361_pos, 1
    substr rx1361_tgt, rx1361_tgt, rx1361_off
  rx1361_start:
    eq $I10, 1, rx1361_restart
    if_null rx1361_debug, debug_993
    rx1361_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1365_done
    goto rxscan1365_scan
  rxscan1365_loop:
    (rx1361_pos) = rx1361_cur."from"()
    inc rx1361_pos
    rx1361_cur."!cursor_from"(rx1361_pos)
    ge rx1361_pos, rx1361_eos, rxscan1365_done
  rxscan1365_scan:
    set_addr $I10, rxscan1365_loop
    rx1361_cur."!mark_push"(0, rx1361_pos, $I10)
  rxscan1365_done:
.annotate 'line', 598
  # rx subcapture "sym"
    set_addr $I10, rxcap_1366_fail
    rx1361_cur."!mark_push"(0, rx1361_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1361_pos, 2
    gt $I11, rx1361_eos, rx1361_fail
    sub $I11, rx1361_pos, rx1361_off
    substr $S10, rx1361_tgt, $I11, 2
    ne $S10, "+|", rx1361_fail
    add rx1361_pos, 2
    set_addr $I10, rxcap_1366_fail
    ($I12, $I11) = rx1361_cur."!mark_peek"($I10)
    rx1361_cur."!cursor_pos"($I11)
    ($P10) = rx1361_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1361_pos, "")
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1366_done
  rxcap_1366_fail:
    goto rx1361_fail
  rxcap_1366_done:
  # rx subrule "O" subtype=capture negate=
    rx1361_cur."!cursor_pos"(rx1361_pos)
    $P10 = rx1361_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1361_fail
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1361_pos = $P10."pos"()
  # rx pass
    rx1361_cur."!cursor_pass"(rx1361_pos, "infix:sym<+|>")
    if_null rx1361_debug, debug_994
    rx1361_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1361_pos)
  debug_994:
    .return (rx1361_cur)
  rx1361_restart:
.annotate 'line', 4
    if_null rx1361_debug, debug_995
    rx1361_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_995:
  rx1361_fail:
    (rx1361_rep, rx1361_pos, $I10, $P10) = rx1361_cur."!mark_fail"(0)
    lt rx1361_pos, -1, rx1361_done
    eq rx1361_pos, -1, rx1361_fail
    jump $I10
  rx1361_done:
    rx1361_cur."!cursor_fail"()
    if_null rx1361_debug, debug_996
    rx1361_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_996:
    .return (rx1361_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("315_1296306519.49046") :method
.annotate 'line', 4
    $P1363 = self."!PREFIX__!subrule"("O", "+|")
    new $P1364, "ResizablePMCArray"
    push $P1364, $P1363
    .return ($P1364)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("316_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1368_tgt
    .local int rx1368_pos
    .local int rx1368_off
    .local int rx1368_eos
    .local int rx1368_rep
    .local pmc rx1368_cur
    .local pmc rx1368_debug
    (rx1368_cur, rx1368_pos, rx1368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1368_cur
    .local pmc match
    .lex "$/", match
    length rx1368_eos, rx1368_tgt
    gt rx1368_pos, rx1368_eos, rx1368_done
    set rx1368_off, 0
    lt rx1368_pos, 2, rx1368_start
    sub rx1368_off, rx1368_pos, 1
    substr rx1368_tgt, rx1368_tgt, rx1368_off
  rx1368_start:
    eq $I10, 1, rx1368_restart
    if_null rx1368_debug, debug_997
    rx1368_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1372_done
    goto rxscan1372_scan
  rxscan1372_loop:
    (rx1368_pos) = rx1368_cur."from"()
    inc rx1368_pos
    rx1368_cur."!cursor_from"(rx1368_pos)
    ge rx1368_pos, rx1368_eos, rxscan1372_done
  rxscan1372_scan:
    set_addr $I10, rxscan1372_loop
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  rxscan1372_done:
.annotate 'line', 599
  # rx subcapture "sym"
    set_addr $I10, rxcap_1373_fail
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1368_pos, 2
    gt $I11, rx1368_eos, rx1368_fail
    sub $I11, rx1368_pos, rx1368_off
    substr $S10, rx1368_tgt, $I11, 2
    ne $S10, "+^", rx1368_fail
    add rx1368_pos, 2
    set_addr $I10, rxcap_1373_fail
    ($I12, $I11) = rx1368_cur."!mark_peek"($I10)
    rx1368_cur."!cursor_pos"($I11)
    ($P10) = rx1368_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1368_pos, "")
    rx1368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1373_done
  rxcap_1373_fail:
    goto rx1368_fail
  rxcap_1373_done:
  # rx subrule "O" subtype=capture negate=
    rx1368_cur."!cursor_pos"(rx1368_pos)
    $P10 = rx1368_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1368_fail
    rx1368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1368_pos = $P10."pos"()
  # rx pass
    rx1368_cur."!cursor_pass"(rx1368_pos, "infix:sym<+^>")
    if_null rx1368_debug, debug_998
    rx1368_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1368_pos)
  debug_998:
    .return (rx1368_cur)
  rx1368_restart:
.annotate 'line', 4
    if_null rx1368_debug, debug_999
    rx1368_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_999:
  rx1368_fail:
    (rx1368_rep, rx1368_pos, $I10, $P10) = rx1368_cur."!mark_fail"(0)
    lt rx1368_pos, -1, rx1368_done
    eq rx1368_pos, -1, rx1368_fail
    jump $I10
  rx1368_done:
    rx1368_cur."!cursor_fail"()
    if_null rx1368_debug, debug_1000
    rx1368_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1000:
    .return (rx1368_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("317_1296306519.49046") :method
.annotate 'line', 4
    $P1370 = self."!PREFIX__!subrule"("O", "+^")
    new $P1371, "ResizablePMCArray"
    push $P1371, $P1370
    .return ($P1371)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("318_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1375_tgt
    .local int rx1375_pos
    .local int rx1375_off
    .local int rx1375_eos
    .local int rx1375_rep
    .local pmc rx1375_cur
    .local pmc rx1375_debug
    (rx1375_cur, rx1375_pos, rx1375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1375_cur
    .local pmc match
    .lex "$/", match
    length rx1375_eos, rx1375_tgt
    gt rx1375_pos, rx1375_eos, rx1375_done
    set rx1375_off, 0
    lt rx1375_pos, 2, rx1375_start
    sub rx1375_off, rx1375_pos, 1
    substr rx1375_tgt, rx1375_tgt, rx1375_off
  rx1375_start:
    eq $I10, 1, rx1375_restart
    if_null rx1375_debug, debug_1001
    rx1375_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1379_done
    goto rxscan1379_scan
  rxscan1379_loop:
    (rx1375_pos) = rx1375_cur."from"()
    inc rx1375_pos
    rx1375_cur."!cursor_from"(rx1375_pos)
    ge rx1375_pos, rx1375_eos, rxscan1379_done
  rxscan1379_scan:
    set_addr $I10, rxscan1379_loop
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  rxscan1379_done:
.annotate 'line', 601
  # rx subcapture "sym"
    set_addr $I10, rxcap_1380_fail
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  # rx literal  "~"
    add $I11, rx1375_pos, 1
    gt $I11, rx1375_eos, rx1375_fail
    sub $I11, rx1375_pos, rx1375_off
    ord $I11, rx1375_tgt, $I11
    ne $I11, 126, rx1375_fail
    add rx1375_pos, 1
    set_addr $I10, rxcap_1380_fail
    ($I12, $I11) = rx1375_cur."!mark_peek"($I10)
    rx1375_cur."!cursor_pos"($I11)
    ($P10) = rx1375_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1375_pos, "")
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1380_done
  rxcap_1380_fail:
    goto rx1375_fail
  rxcap_1380_done:
  # rx subrule "O" subtype=capture negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1375_fail
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1375_pos = $P10."pos"()
  # rx pass
    rx1375_cur."!cursor_pass"(rx1375_pos, "infix:sym<~>")
    if_null rx1375_debug, debug_1002
    rx1375_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1375_pos)
  debug_1002:
    .return (rx1375_cur)
  rx1375_restart:
.annotate 'line', 4
    if_null rx1375_debug, debug_1003
    rx1375_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1003:
  rx1375_fail:
    (rx1375_rep, rx1375_pos, $I10, $P10) = rx1375_cur."!mark_fail"(0)
    lt rx1375_pos, -1, rx1375_done
    eq rx1375_pos, -1, rx1375_fail
    jump $I10
  rx1375_done:
    rx1375_cur."!cursor_fail"()
    if_null rx1375_debug, debug_1004
    rx1375_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1004:
    .return (rx1375_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("319_1296306519.49046") :method
.annotate 'line', 4
    $P1377 = self."!PREFIX__!subrule"("O", "~")
    new $P1378, "ResizablePMCArray"
    push $P1378, $P1377
    .return ($P1378)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("320_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1382_tgt
    .local int rx1382_pos
    .local int rx1382_off
    .local int rx1382_eos
    .local int rx1382_rep
    .local pmc rx1382_cur
    .local pmc rx1382_debug
    (rx1382_cur, rx1382_pos, rx1382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1382_cur
    .local pmc match
    .lex "$/", match
    length rx1382_eos, rx1382_tgt
    gt rx1382_pos, rx1382_eos, rx1382_done
    set rx1382_off, 0
    lt rx1382_pos, 2, rx1382_start
    sub rx1382_off, rx1382_pos, 1
    substr rx1382_tgt, rx1382_tgt, rx1382_off
  rx1382_start:
    eq $I10, 1, rx1382_restart
    if_null rx1382_debug, debug_1005
    rx1382_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1386_done
    goto rxscan1386_scan
  rxscan1386_loop:
    (rx1382_pos) = rx1382_cur."from"()
    inc rx1382_pos
    rx1382_cur."!cursor_from"(rx1382_pos)
    ge rx1382_pos, rx1382_eos, rxscan1386_done
  rxscan1386_scan:
    set_addr $I10, rxscan1386_loop
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  rxscan1386_done:
.annotate 'line', 603
  # rx subcapture "sym"
    set_addr $I10, rxcap_1387_fail
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  # rx literal  "=="
    add $I11, rx1382_pos, 2
    gt $I11, rx1382_eos, rx1382_fail
    sub $I11, rx1382_pos, rx1382_off
    substr $S10, rx1382_tgt, $I11, 2
    ne $S10, "==", rx1382_fail
    add rx1382_pos, 2
    set_addr $I10, rxcap_1387_fail
    ($I12, $I11) = rx1382_cur."!mark_peek"($I10)
    rx1382_cur."!cursor_pos"($I11)
    ($P10) = rx1382_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1382_pos, "")
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1387_done
  rxcap_1387_fail:
    goto rx1382_fail
  rxcap_1387_done:
  # rx subrule "O" subtype=capture negate=
    rx1382_cur."!cursor_pos"(rx1382_pos)
    $P10 = rx1382_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1382_fail
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1382_pos = $P10."pos"()
  # rx pass
    rx1382_cur."!cursor_pass"(rx1382_pos, "infix:sym<==>")
    if_null rx1382_debug, debug_1006
    rx1382_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1382_pos)
  debug_1006:
    .return (rx1382_cur)
  rx1382_restart:
.annotate 'line', 4
    if_null rx1382_debug, debug_1007
    rx1382_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1007:
  rx1382_fail:
    (rx1382_rep, rx1382_pos, $I10, $P10) = rx1382_cur."!mark_fail"(0)
    lt rx1382_pos, -1, rx1382_done
    eq rx1382_pos, -1, rx1382_fail
    jump $I10
  rx1382_done:
    rx1382_cur."!cursor_fail"()
    if_null rx1382_debug, debug_1008
    rx1382_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1008:
    .return (rx1382_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("321_1296306519.49046") :method
.annotate 'line', 4
    $P1384 = self."!PREFIX__!subrule"("O", "==")
    new $P1385, "ResizablePMCArray"
    push $P1385, $P1384
    .return ($P1385)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("322_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1389_tgt
    .local int rx1389_pos
    .local int rx1389_off
    .local int rx1389_eos
    .local int rx1389_rep
    .local pmc rx1389_cur
    .local pmc rx1389_debug
    (rx1389_cur, rx1389_pos, rx1389_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1389_cur
    .local pmc match
    .lex "$/", match
    length rx1389_eos, rx1389_tgt
    gt rx1389_pos, rx1389_eos, rx1389_done
    set rx1389_off, 0
    lt rx1389_pos, 2, rx1389_start
    sub rx1389_off, rx1389_pos, 1
    substr rx1389_tgt, rx1389_tgt, rx1389_off
  rx1389_start:
    eq $I10, 1, rx1389_restart
    if_null rx1389_debug, debug_1009
    rx1389_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1393_done
    goto rxscan1393_scan
  rxscan1393_loop:
    (rx1389_pos) = rx1389_cur."from"()
    inc rx1389_pos
    rx1389_cur."!cursor_from"(rx1389_pos)
    ge rx1389_pos, rx1389_eos, rxscan1393_done
  rxscan1393_scan:
    set_addr $I10, rxscan1393_loop
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  rxscan1393_done:
.annotate 'line', 604
  # rx subcapture "sym"
    set_addr $I10, rxcap_1394_fail
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  # rx literal  "!="
    add $I11, rx1389_pos, 2
    gt $I11, rx1389_eos, rx1389_fail
    sub $I11, rx1389_pos, rx1389_off
    substr $S10, rx1389_tgt, $I11, 2
    ne $S10, "!=", rx1389_fail
    add rx1389_pos, 2
    set_addr $I10, rxcap_1394_fail
    ($I12, $I11) = rx1389_cur."!mark_peek"($I10)
    rx1389_cur."!cursor_pos"($I11)
    ($P10) = rx1389_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1389_pos, "")
    rx1389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1394_done
  rxcap_1394_fail:
    goto rx1389_fail
  rxcap_1394_done:
  # rx subrule "O" subtype=capture negate=
    rx1389_cur."!cursor_pos"(rx1389_pos)
    $P10 = rx1389_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1389_fail
    rx1389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1389_pos = $P10."pos"()
  # rx pass
    rx1389_cur."!cursor_pass"(rx1389_pos, "infix:sym<!=>")
    if_null rx1389_debug, debug_1010
    rx1389_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1389_pos)
  debug_1010:
    .return (rx1389_cur)
  rx1389_restart:
.annotate 'line', 4
    if_null rx1389_debug, debug_1011
    rx1389_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1011:
  rx1389_fail:
    (rx1389_rep, rx1389_pos, $I10, $P10) = rx1389_cur."!mark_fail"(0)
    lt rx1389_pos, -1, rx1389_done
    eq rx1389_pos, -1, rx1389_fail
    jump $I10
  rx1389_done:
    rx1389_cur."!cursor_fail"()
    if_null rx1389_debug, debug_1012
    rx1389_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1012:
    .return (rx1389_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("323_1296306519.49046") :method
.annotate 'line', 4
    $P1391 = self."!PREFIX__!subrule"("O", "!=")
    new $P1392, "ResizablePMCArray"
    push $P1392, $P1391
    .return ($P1392)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("324_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1396_tgt
    .local int rx1396_pos
    .local int rx1396_off
    .local int rx1396_eos
    .local int rx1396_rep
    .local pmc rx1396_cur
    .local pmc rx1396_debug
    (rx1396_cur, rx1396_pos, rx1396_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1396_cur
    .local pmc match
    .lex "$/", match
    length rx1396_eos, rx1396_tgt
    gt rx1396_pos, rx1396_eos, rx1396_done
    set rx1396_off, 0
    lt rx1396_pos, 2, rx1396_start
    sub rx1396_off, rx1396_pos, 1
    substr rx1396_tgt, rx1396_tgt, rx1396_off
  rx1396_start:
    eq $I10, 1, rx1396_restart
    if_null rx1396_debug, debug_1013
    rx1396_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1400_done
    goto rxscan1400_scan
  rxscan1400_loop:
    (rx1396_pos) = rx1396_cur."from"()
    inc rx1396_pos
    rx1396_cur."!cursor_from"(rx1396_pos)
    ge rx1396_pos, rx1396_eos, rxscan1400_done
  rxscan1400_scan:
    set_addr $I10, rxscan1400_loop
    rx1396_cur."!mark_push"(0, rx1396_pos, $I10)
  rxscan1400_done:
.annotate 'line', 605
  # rx subcapture "sym"
    set_addr $I10, rxcap_1401_fail
    rx1396_cur."!mark_push"(0, rx1396_pos, $I10)
  # rx literal  "<="
    add $I11, rx1396_pos, 2
    gt $I11, rx1396_eos, rx1396_fail
    sub $I11, rx1396_pos, rx1396_off
    substr $S10, rx1396_tgt, $I11, 2
    ne $S10, "<=", rx1396_fail
    add rx1396_pos, 2
    set_addr $I10, rxcap_1401_fail
    ($I12, $I11) = rx1396_cur."!mark_peek"($I10)
    rx1396_cur."!cursor_pos"($I11)
    ($P10) = rx1396_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1396_pos, "")
    rx1396_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1401_done
  rxcap_1401_fail:
    goto rx1396_fail
  rxcap_1401_done:
  # rx subrule "O" subtype=capture negate=
    rx1396_cur."!cursor_pos"(rx1396_pos)
    $P10 = rx1396_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1396_fail
    rx1396_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1396_pos = $P10."pos"()
  # rx pass
    rx1396_cur."!cursor_pass"(rx1396_pos, "infix:sym<<=>")
    if_null rx1396_debug, debug_1014
    rx1396_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1396_pos)
  debug_1014:
    .return (rx1396_cur)
  rx1396_restart:
.annotate 'line', 4
    if_null rx1396_debug, debug_1015
    rx1396_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1015:
  rx1396_fail:
    (rx1396_rep, rx1396_pos, $I10, $P10) = rx1396_cur."!mark_fail"(0)
    lt rx1396_pos, -1, rx1396_done
    eq rx1396_pos, -1, rx1396_fail
    jump $I10
  rx1396_done:
    rx1396_cur."!cursor_fail"()
    if_null rx1396_debug, debug_1016
    rx1396_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1016:
    .return (rx1396_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("325_1296306519.49046") :method
.annotate 'line', 4
    $P1398 = self."!PREFIX__!subrule"("O", "<=")
    new $P1399, "ResizablePMCArray"
    push $P1399, $P1398
    .return ($P1399)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("326_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1403_tgt
    .local int rx1403_pos
    .local int rx1403_off
    .local int rx1403_eos
    .local int rx1403_rep
    .local pmc rx1403_cur
    .local pmc rx1403_debug
    (rx1403_cur, rx1403_pos, rx1403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1403_cur
    .local pmc match
    .lex "$/", match
    length rx1403_eos, rx1403_tgt
    gt rx1403_pos, rx1403_eos, rx1403_done
    set rx1403_off, 0
    lt rx1403_pos, 2, rx1403_start
    sub rx1403_off, rx1403_pos, 1
    substr rx1403_tgt, rx1403_tgt, rx1403_off
  rx1403_start:
    eq $I10, 1, rx1403_restart
    if_null rx1403_debug, debug_1017
    rx1403_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1407_done
    goto rxscan1407_scan
  rxscan1407_loop:
    (rx1403_pos) = rx1403_cur."from"()
    inc rx1403_pos
    rx1403_cur."!cursor_from"(rx1403_pos)
    ge rx1403_pos, rx1403_eos, rxscan1407_done
  rxscan1407_scan:
    set_addr $I10, rxscan1407_loop
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  rxscan1407_done:
.annotate 'line', 606
  # rx subcapture "sym"
    set_addr $I10, rxcap_1408_fail
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  # rx literal  ">="
    add $I11, rx1403_pos, 2
    gt $I11, rx1403_eos, rx1403_fail
    sub $I11, rx1403_pos, rx1403_off
    substr $S10, rx1403_tgt, $I11, 2
    ne $S10, ">=", rx1403_fail
    add rx1403_pos, 2
    set_addr $I10, rxcap_1408_fail
    ($I12, $I11) = rx1403_cur."!mark_peek"($I10)
    rx1403_cur."!cursor_pos"($I11)
    ($P10) = rx1403_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1403_pos, "")
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1408_done
  rxcap_1408_fail:
    goto rx1403_fail
  rxcap_1408_done:
  # rx subrule "O" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1403_pos = $P10."pos"()
  # rx pass
    rx1403_cur."!cursor_pass"(rx1403_pos, "infix:sym<>=>")
    if_null rx1403_debug, debug_1018
    rx1403_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1403_pos)
  debug_1018:
    .return (rx1403_cur)
  rx1403_restart:
.annotate 'line', 4
    if_null rx1403_debug, debug_1019
    rx1403_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1019:
  rx1403_fail:
    (rx1403_rep, rx1403_pos, $I10, $P10) = rx1403_cur."!mark_fail"(0)
    lt rx1403_pos, -1, rx1403_done
    eq rx1403_pos, -1, rx1403_fail
    jump $I10
  rx1403_done:
    rx1403_cur."!cursor_fail"()
    if_null rx1403_debug, debug_1020
    rx1403_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1020:
    .return (rx1403_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("327_1296306519.49046") :method
.annotate 'line', 4
    $P1405 = self."!PREFIX__!subrule"("O", ">=")
    new $P1406, "ResizablePMCArray"
    push $P1406, $P1405
    .return ($P1406)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("328_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1410_tgt
    .local int rx1410_pos
    .local int rx1410_off
    .local int rx1410_eos
    .local int rx1410_rep
    .local pmc rx1410_cur
    .local pmc rx1410_debug
    (rx1410_cur, rx1410_pos, rx1410_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1410_cur
    .local pmc match
    .lex "$/", match
    length rx1410_eos, rx1410_tgt
    gt rx1410_pos, rx1410_eos, rx1410_done
    set rx1410_off, 0
    lt rx1410_pos, 2, rx1410_start
    sub rx1410_off, rx1410_pos, 1
    substr rx1410_tgt, rx1410_tgt, rx1410_off
  rx1410_start:
    eq $I10, 1, rx1410_restart
    if_null rx1410_debug, debug_1021
    rx1410_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1414_done
    goto rxscan1414_scan
  rxscan1414_loop:
    (rx1410_pos) = rx1410_cur."from"()
    inc rx1410_pos
    rx1410_cur."!cursor_from"(rx1410_pos)
    ge rx1410_pos, rx1410_eos, rxscan1414_done
  rxscan1414_scan:
    set_addr $I10, rxscan1414_loop
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  rxscan1414_done:
.annotate 'line', 607
  # rx subcapture "sym"
    set_addr $I10, rxcap_1415_fail
    rx1410_cur."!mark_push"(0, rx1410_pos, $I10)
  # rx literal  "<"
    add $I11, rx1410_pos, 1
    gt $I11, rx1410_eos, rx1410_fail
    sub $I11, rx1410_pos, rx1410_off
    ord $I11, rx1410_tgt, $I11
    ne $I11, 60, rx1410_fail
    add rx1410_pos, 1
    set_addr $I10, rxcap_1415_fail
    ($I12, $I11) = rx1410_cur."!mark_peek"($I10)
    rx1410_cur."!cursor_pos"($I11)
    ($P10) = rx1410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1410_pos, "")
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1415_done
  rxcap_1415_fail:
    goto rx1410_fail
  rxcap_1415_done:
  # rx subrule "O" subtype=capture negate=
    rx1410_cur."!cursor_pos"(rx1410_pos)
    $P10 = rx1410_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1410_fail
    rx1410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1410_pos = $P10."pos"()
  # rx pass
    rx1410_cur."!cursor_pass"(rx1410_pos, "infix:sym<<>")
    if_null rx1410_debug, debug_1022
    rx1410_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1410_pos)
  debug_1022:
    .return (rx1410_cur)
  rx1410_restart:
.annotate 'line', 4
    if_null rx1410_debug, debug_1023
    rx1410_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1023:
  rx1410_fail:
    (rx1410_rep, rx1410_pos, $I10, $P10) = rx1410_cur."!mark_fail"(0)
    lt rx1410_pos, -1, rx1410_done
    eq rx1410_pos, -1, rx1410_fail
    jump $I10
  rx1410_done:
    rx1410_cur."!cursor_fail"()
    if_null rx1410_debug, debug_1024
    rx1410_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1024:
    .return (rx1410_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("329_1296306519.49046") :method
.annotate 'line', 4
    $P1412 = self."!PREFIX__!subrule"("O", "<")
    new $P1413, "ResizablePMCArray"
    push $P1413, $P1412
    .return ($P1413)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("330_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1417_tgt
    .local int rx1417_pos
    .local int rx1417_off
    .local int rx1417_eos
    .local int rx1417_rep
    .local pmc rx1417_cur
    .local pmc rx1417_debug
    (rx1417_cur, rx1417_pos, rx1417_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1417_cur
    .local pmc match
    .lex "$/", match
    length rx1417_eos, rx1417_tgt
    gt rx1417_pos, rx1417_eos, rx1417_done
    set rx1417_off, 0
    lt rx1417_pos, 2, rx1417_start
    sub rx1417_off, rx1417_pos, 1
    substr rx1417_tgt, rx1417_tgt, rx1417_off
  rx1417_start:
    eq $I10, 1, rx1417_restart
    if_null rx1417_debug, debug_1025
    rx1417_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1421_done
    goto rxscan1421_scan
  rxscan1421_loop:
    (rx1417_pos) = rx1417_cur."from"()
    inc rx1417_pos
    rx1417_cur."!cursor_from"(rx1417_pos)
    ge rx1417_pos, rx1417_eos, rxscan1421_done
  rxscan1421_scan:
    set_addr $I10, rxscan1421_loop
    rx1417_cur."!mark_push"(0, rx1417_pos, $I10)
  rxscan1421_done:
.annotate 'line', 608
  # rx subcapture "sym"
    set_addr $I10, rxcap_1422_fail
    rx1417_cur."!mark_push"(0, rx1417_pos, $I10)
  # rx literal  ">"
    add $I11, rx1417_pos, 1
    gt $I11, rx1417_eos, rx1417_fail
    sub $I11, rx1417_pos, rx1417_off
    ord $I11, rx1417_tgt, $I11
    ne $I11, 62, rx1417_fail
    add rx1417_pos, 1
    set_addr $I10, rxcap_1422_fail
    ($I12, $I11) = rx1417_cur."!mark_peek"($I10)
    rx1417_cur."!cursor_pos"($I11)
    ($P10) = rx1417_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1417_pos, "")
    rx1417_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1422_done
  rxcap_1422_fail:
    goto rx1417_fail
  rxcap_1422_done:
  # rx subrule "O" subtype=capture negate=
    rx1417_cur."!cursor_pos"(rx1417_pos)
    $P10 = rx1417_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1417_fail
    rx1417_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1417_pos = $P10."pos"()
  # rx pass
    rx1417_cur."!cursor_pass"(rx1417_pos, "infix:sym<>>")
    if_null rx1417_debug, debug_1026
    rx1417_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1417_pos)
  debug_1026:
    .return (rx1417_cur)
  rx1417_restart:
.annotate 'line', 4
    if_null rx1417_debug, debug_1027
    rx1417_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1027:
  rx1417_fail:
    (rx1417_rep, rx1417_pos, $I10, $P10) = rx1417_cur."!mark_fail"(0)
    lt rx1417_pos, -1, rx1417_done
    eq rx1417_pos, -1, rx1417_fail
    jump $I10
  rx1417_done:
    rx1417_cur."!cursor_fail"()
    if_null rx1417_debug, debug_1028
    rx1417_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1028:
    .return (rx1417_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("331_1296306519.49046") :method
.annotate 'line', 4
    $P1419 = self."!PREFIX__!subrule"("O", ">")
    new $P1420, "ResizablePMCArray"
    push $P1420, $P1419
    .return ($P1420)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("332_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1424_tgt
    .local int rx1424_pos
    .local int rx1424_off
    .local int rx1424_eos
    .local int rx1424_rep
    .local pmc rx1424_cur
    .local pmc rx1424_debug
    (rx1424_cur, rx1424_pos, rx1424_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1424_cur
    .local pmc match
    .lex "$/", match
    length rx1424_eos, rx1424_tgt
    gt rx1424_pos, rx1424_eos, rx1424_done
    set rx1424_off, 0
    lt rx1424_pos, 2, rx1424_start
    sub rx1424_off, rx1424_pos, 1
    substr rx1424_tgt, rx1424_tgt, rx1424_off
  rx1424_start:
    eq $I10, 1, rx1424_restart
    if_null rx1424_debug, debug_1029
    rx1424_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1428_done
    goto rxscan1428_scan
  rxscan1428_loop:
    (rx1424_pos) = rx1424_cur."from"()
    inc rx1424_pos
    rx1424_cur."!cursor_from"(rx1424_pos)
    ge rx1424_pos, rx1424_eos, rxscan1428_done
  rxscan1428_scan:
    set_addr $I10, rxscan1428_loop
    rx1424_cur."!mark_push"(0, rx1424_pos, $I10)
  rxscan1428_done:
.annotate 'line', 609
  # rx subcapture "sym"
    set_addr $I10, rxcap_1429_fail
    rx1424_cur."!mark_push"(0, rx1424_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1424_pos, 2
    gt $I11, rx1424_eos, rx1424_fail
    sub $I11, rx1424_pos, rx1424_off
    substr $S10, rx1424_tgt, $I11, 2
    ne $S10, "eq", rx1424_fail
    add rx1424_pos, 2
    set_addr $I10, rxcap_1429_fail
    ($I12, $I11) = rx1424_cur."!mark_peek"($I10)
    rx1424_cur."!cursor_pos"($I11)
    ($P10) = rx1424_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1424_pos, "")
    rx1424_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1429_done
  rxcap_1429_fail:
    goto rx1424_fail
  rxcap_1429_done:
  # rx subrule "O" subtype=capture negate=
    rx1424_cur."!cursor_pos"(rx1424_pos)
    $P10 = rx1424_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1424_fail
    rx1424_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1424_pos = $P10."pos"()
  # rx pass
    rx1424_cur."!cursor_pass"(rx1424_pos, "infix:sym<eq>")
    if_null rx1424_debug, debug_1030
    rx1424_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1424_pos)
  debug_1030:
    .return (rx1424_cur)
  rx1424_restart:
.annotate 'line', 4
    if_null rx1424_debug, debug_1031
    rx1424_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1031:
  rx1424_fail:
    (rx1424_rep, rx1424_pos, $I10, $P10) = rx1424_cur."!mark_fail"(0)
    lt rx1424_pos, -1, rx1424_done
    eq rx1424_pos, -1, rx1424_fail
    jump $I10
  rx1424_done:
    rx1424_cur."!cursor_fail"()
    if_null rx1424_debug, debug_1032
    rx1424_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1032:
    .return (rx1424_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("333_1296306519.49046") :method
.annotate 'line', 4
    $P1426 = self."!PREFIX__!subrule"("O", "eq")
    new $P1427, "ResizablePMCArray"
    push $P1427, $P1426
    .return ($P1427)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("334_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1431_tgt
    .local int rx1431_pos
    .local int rx1431_off
    .local int rx1431_eos
    .local int rx1431_rep
    .local pmc rx1431_cur
    .local pmc rx1431_debug
    (rx1431_cur, rx1431_pos, rx1431_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1431_cur
    .local pmc match
    .lex "$/", match
    length rx1431_eos, rx1431_tgt
    gt rx1431_pos, rx1431_eos, rx1431_done
    set rx1431_off, 0
    lt rx1431_pos, 2, rx1431_start
    sub rx1431_off, rx1431_pos, 1
    substr rx1431_tgt, rx1431_tgt, rx1431_off
  rx1431_start:
    eq $I10, 1, rx1431_restart
    if_null rx1431_debug, debug_1033
    rx1431_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1435_done
    goto rxscan1435_scan
  rxscan1435_loop:
    (rx1431_pos) = rx1431_cur."from"()
    inc rx1431_pos
    rx1431_cur."!cursor_from"(rx1431_pos)
    ge rx1431_pos, rx1431_eos, rxscan1435_done
  rxscan1435_scan:
    set_addr $I10, rxscan1435_loop
    rx1431_cur."!mark_push"(0, rx1431_pos, $I10)
  rxscan1435_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1436_fail
    rx1431_cur."!mark_push"(0, rx1431_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1431_pos, 2
    gt $I11, rx1431_eos, rx1431_fail
    sub $I11, rx1431_pos, rx1431_off
    substr $S10, rx1431_tgt, $I11, 2
    ne $S10, "ne", rx1431_fail
    add rx1431_pos, 2
    set_addr $I10, rxcap_1436_fail
    ($I12, $I11) = rx1431_cur."!mark_peek"($I10)
    rx1431_cur."!cursor_pos"($I11)
    ($P10) = rx1431_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1431_pos, "")
    rx1431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1436_done
  rxcap_1436_fail:
    goto rx1431_fail
  rxcap_1436_done:
  # rx subrule "O" subtype=capture negate=
    rx1431_cur."!cursor_pos"(rx1431_pos)
    $P10 = rx1431_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1431_fail
    rx1431_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1431_pos = $P10."pos"()
  # rx pass
    rx1431_cur."!cursor_pass"(rx1431_pos, "infix:sym<ne>")
    if_null rx1431_debug, debug_1034
    rx1431_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1431_pos)
  debug_1034:
    .return (rx1431_cur)
  rx1431_restart:
.annotate 'line', 4
    if_null rx1431_debug, debug_1035
    rx1431_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1035:
  rx1431_fail:
    (rx1431_rep, rx1431_pos, $I10, $P10) = rx1431_cur."!mark_fail"(0)
    lt rx1431_pos, -1, rx1431_done
    eq rx1431_pos, -1, rx1431_fail
    jump $I10
  rx1431_done:
    rx1431_cur."!cursor_fail"()
    if_null rx1431_debug, debug_1036
    rx1431_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1036:
    .return (rx1431_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("335_1296306519.49046") :method
.annotate 'line', 4
    $P1433 = self."!PREFIX__!subrule"("O", "ne")
    new $P1434, "ResizablePMCArray"
    push $P1434, $P1433
    .return ($P1434)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("336_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1438_tgt
    .local int rx1438_pos
    .local int rx1438_off
    .local int rx1438_eos
    .local int rx1438_rep
    .local pmc rx1438_cur
    .local pmc rx1438_debug
    (rx1438_cur, rx1438_pos, rx1438_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1438_cur
    .local pmc match
    .lex "$/", match
    length rx1438_eos, rx1438_tgt
    gt rx1438_pos, rx1438_eos, rx1438_done
    set rx1438_off, 0
    lt rx1438_pos, 2, rx1438_start
    sub rx1438_off, rx1438_pos, 1
    substr rx1438_tgt, rx1438_tgt, rx1438_off
  rx1438_start:
    eq $I10, 1, rx1438_restart
    if_null rx1438_debug, debug_1037
    rx1438_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1442_done
    goto rxscan1442_scan
  rxscan1442_loop:
    (rx1438_pos) = rx1438_cur."from"()
    inc rx1438_pos
    rx1438_cur."!cursor_from"(rx1438_pos)
    ge rx1438_pos, rx1438_eos, rxscan1442_done
  rxscan1442_scan:
    set_addr $I10, rxscan1442_loop
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  rxscan1442_done:
.annotate 'line', 611
  # rx subcapture "sym"
    set_addr $I10, rxcap_1443_fail
    rx1438_cur."!mark_push"(0, rx1438_pos, $I10)
  # rx literal  "le"
    add $I11, rx1438_pos, 2
    gt $I11, rx1438_eos, rx1438_fail
    sub $I11, rx1438_pos, rx1438_off
    substr $S10, rx1438_tgt, $I11, 2
    ne $S10, "le", rx1438_fail
    add rx1438_pos, 2
    set_addr $I10, rxcap_1443_fail
    ($I12, $I11) = rx1438_cur."!mark_peek"($I10)
    rx1438_cur."!cursor_pos"($I11)
    ($P10) = rx1438_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1438_pos, "")
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1443_done
  rxcap_1443_fail:
    goto rx1438_fail
  rxcap_1443_done:
  # rx subrule "O" subtype=capture negate=
    rx1438_cur."!cursor_pos"(rx1438_pos)
    $P10 = rx1438_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1438_fail
    rx1438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1438_pos = $P10."pos"()
  # rx pass
    rx1438_cur."!cursor_pass"(rx1438_pos, "infix:sym<le>")
    if_null rx1438_debug, debug_1038
    rx1438_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1438_pos)
  debug_1038:
    .return (rx1438_cur)
  rx1438_restart:
.annotate 'line', 4
    if_null rx1438_debug, debug_1039
    rx1438_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1039:
  rx1438_fail:
    (rx1438_rep, rx1438_pos, $I10, $P10) = rx1438_cur."!mark_fail"(0)
    lt rx1438_pos, -1, rx1438_done
    eq rx1438_pos, -1, rx1438_fail
    jump $I10
  rx1438_done:
    rx1438_cur."!cursor_fail"()
    if_null rx1438_debug, debug_1040
    rx1438_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1040:
    .return (rx1438_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("337_1296306519.49046") :method
.annotate 'line', 4
    $P1440 = self."!PREFIX__!subrule"("O", "le")
    new $P1441, "ResizablePMCArray"
    push $P1441, $P1440
    .return ($P1441)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("338_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1445_tgt
    .local int rx1445_pos
    .local int rx1445_off
    .local int rx1445_eos
    .local int rx1445_rep
    .local pmc rx1445_cur
    .local pmc rx1445_debug
    (rx1445_cur, rx1445_pos, rx1445_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1445_cur
    .local pmc match
    .lex "$/", match
    length rx1445_eos, rx1445_tgt
    gt rx1445_pos, rx1445_eos, rx1445_done
    set rx1445_off, 0
    lt rx1445_pos, 2, rx1445_start
    sub rx1445_off, rx1445_pos, 1
    substr rx1445_tgt, rx1445_tgt, rx1445_off
  rx1445_start:
    eq $I10, 1, rx1445_restart
    if_null rx1445_debug, debug_1041
    rx1445_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1449_done
    goto rxscan1449_scan
  rxscan1449_loop:
    (rx1445_pos) = rx1445_cur."from"()
    inc rx1445_pos
    rx1445_cur."!cursor_from"(rx1445_pos)
    ge rx1445_pos, rx1445_eos, rxscan1449_done
  rxscan1449_scan:
    set_addr $I10, rxscan1449_loop
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  rxscan1449_done:
.annotate 'line', 612
  # rx subcapture "sym"
    set_addr $I10, rxcap_1450_fail
    rx1445_cur."!mark_push"(0, rx1445_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1445_pos, 2
    gt $I11, rx1445_eos, rx1445_fail
    sub $I11, rx1445_pos, rx1445_off
    substr $S10, rx1445_tgt, $I11, 2
    ne $S10, "ge", rx1445_fail
    add rx1445_pos, 2
    set_addr $I10, rxcap_1450_fail
    ($I12, $I11) = rx1445_cur."!mark_peek"($I10)
    rx1445_cur."!cursor_pos"($I11)
    ($P10) = rx1445_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1445_pos, "")
    rx1445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1450_done
  rxcap_1450_fail:
    goto rx1445_fail
  rxcap_1450_done:
  # rx subrule "O" subtype=capture negate=
    rx1445_cur."!cursor_pos"(rx1445_pos)
    $P10 = rx1445_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1445_fail
    rx1445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1445_pos = $P10."pos"()
  # rx pass
    rx1445_cur."!cursor_pass"(rx1445_pos, "infix:sym<ge>")
    if_null rx1445_debug, debug_1042
    rx1445_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1445_pos)
  debug_1042:
    .return (rx1445_cur)
  rx1445_restart:
.annotate 'line', 4
    if_null rx1445_debug, debug_1043
    rx1445_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1043:
  rx1445_fail:
    (rx1445_rep, rx1445_pos, $I10, $P10) = rx1445_cur."!mark_fail"(0)
    lt rx1445_pos, -1, rx1445_done
    eq rx1445_pos, -1, rx1445_fail
    jump $I10
  rx1445_done:
    rx1445_cur."!cursor_fail"()
    if_null rx1445_debug, debug_1044
    rx1445_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1044:
    .return (rx1445_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("339_1296306519.49046") :method
.annotate 'line', 4
    $P1447 = self."!PREFIX__!subrule"("O", "ge")
    new $P1448, "ResizablePMCArray"
    push $P1448, $P1447
    .return ($P1448)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("340_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1452_tgt
    .local int rx1452_pos
    .local int rx1452_off
    .local int rx1452_eos
    .local int rx1452_rep
    .local pmc rx1452_cur
    .local pmc rx1452_debug
    (rx1452_cur, rx1452_pos, rx1452_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1452_cur
    .local pmc match
    .lex "$/", match
    length rx1452_eos, rx1452_tgt
    gt rx1452_pos, rx1452_eos, rx1452_done
    set rx1452_off, 0
    lt rx1452_pos, 2, rx1452_start
    sub rx1452_off, rx1452_pos, 1
    substr rx1452_tgt, rx1452_tgt, rx1452_off
  rx1452_start:
    eq $I10, 1, rx1452_restart
    if_null rx1452_debug, debug_1045
    rx1452_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1456_done
    goto rxscan1456_scan
  rxscan1456_loop:
    (rx1452_pos) = rx1452_cur."from"()
    inc rx1452_pos
    rx1452_cur."!cursor_from"(rx1452_pos)
    ge rx1452_pos, rx1452_eos, rxscan1456_done
  rxscan1456_scan:
    set_addr $I10, rxscan1456_loop
    rx1452_cur."!mark_push"(0, rx1452_pos, $I10)
  rxscan1456_done:
.annotate 'line', 613
  # rx subcapture "sym"
    set_addr $I10, rxcap_1457_fail
    rx1452_cur."!mark_push"(0, rx1452_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1452_pos, 2
    gt $I11, rx1452_eos, rx1452_fail
    sub $I11, rx1452_pos, rx1452_off
    substr $S10, rx1452_tgt, $I11, 2
    ne $S10, "lt", rx1452_fail
    add rx1452_pos, 2
    set_addr $I10, rxcap_1457_fail
    ($I12, $I11) = rx1452_cur."!mark_peek"($I10)
    rx1452_cur."!cursor_pos"($I11)
    ($P10) = rx1452_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1452_pos, "")
    rx1452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1457_done
  rxcap_1457_fail:
    goto rx1452_fail
  rxcap_1457_done:
  # rx subrule "O" subtype=capture negate=
    rx1452_cur."!cursor_pos"(rx1452_pos)
    $P10 = rx1452_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1452_fail
    rx1452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1452_pos = $P10."pos"()
  # rx pass
    rx1452_cur."!cursor_pass"(rx1452_pos, "infix:sym<lt>")
    if_null rx1452_debug, debug_1046
    rx1452_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1452_pos)
  debug_1046:
    .return (rx1452_cur)
  rx1452_restart:
.annotate 'line', 4
    if_null rx1452_debug, debug_1047
    rx1452_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1047:
  rx1452_fail:
    (rx1452_rep, rx1452_pos, $I10, $P10) = rx1452_cur."!mark_fail"(0)
    lt rx1452_pos, -1, rx1452_done
    eq rx1452_pos, -1, rx1452_fail
    jump $I10
  rx1452_done:
    rx1452_cur."!cursor_fail"()
    if_null rx1452_debug, debug_1048
    rx1452_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1048:
    .return (rx1452_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("341_1296306519.49046") :method
.annotate 'line', 4
    $P1454 = self."!PREFIX__!subrule"("O", "lt")
    new $P1455, "ResizablePMCArray"
    push $P1455, $P1454
    .return ($P1455)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("342_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1459_tgt
    .local int rx1459_pos
    .local int rx1459_off
    .local int rx1459_eos
    .local int rx1459_rep
    .local pmc rx1459_cur
    .local pmc rx1459_debug
    (rx1459_cur, rx1459_pos, rx1459_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1459_cur
    .local pmc match
    .lex "$/", match
    length rx1459_eos, rx1459_tgt
    gt rx1459_pos, rx1459_eos, rx1459_done
    set rx1459_off, 0
    lt rx1459_pos, 2, rx1459_start
    sub rx1459_off, rx1459_pos, 1
    substr rx1459_tgt, rx1459_tgt, rx1459_off
  rx1459_start:
    eq $I10, 1, rx1459_restart
    if_null rx1459_debug, debug_1049
    rx1459_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1463_done
    goto rxscan1463_scan
  rxscan1463_loop:
    (rx1459_pos) = rx1459_cur."from"()
    inc rx1459_pos
    rx1459_cur."!cursor_from"(rx1459_pos)
    ge rx1459_pos, rx1459_eos, rxscan1463_done
  rxscan1463_scan:
    set_addr $I10, rxscan1463_loop
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  rxscan1463_done:
.annotate 'line', 614
  # rx subcapture "sym"
    set_addr $I10, rxcap_1464_fail
    rx1459_cur."!mark_push"(0, rx1459_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1459_pos, 2
    gt $I11, rx1459_eos, rx1459_fail
    sub $I11, rx1459_pos, rx1459_off
    substr $S10, rx1459_tgt, $I11, 2
    ne $S10, "gt", rx1459_fail
    add rx1459_pos, 2
    set_addr $I10, rxcap_1464_fail
    ($I12, $I11) = rx1459_cur."!mark_peek"($I10)
    rx1459_cur."!cursor_pos"($I11)
    ($P10) = rx1459_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1459_pos, "")
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1464_done
  rxcap_1464_fail:
    goto rx1459_fail
  rxcap_1464_done:
  # rx subrule "O" subtype=capture negate=
    rx1459_cur."!cursor_pos"(rx1459_pos)
    $P10 = rx1459_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1459_fail
    rx1459_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1459_pos = $P10."pos"()
  # rx pass
    rx1459_cur."!cursor_pass"(rx1459_pos, "infix:sym<gt>")
    if_null rx1459_debug, debug_1050
    rx1459_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1459_pos)
  debug_1050:
    .return (rx1459_cur)
  rx1459_restart:
.annotate 'line', 4
    if_null rx1459_debug, debug_1051
    rx1459_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1051:
  rx1459_fail:
    (rx1459_rep, rx1459_pos, $I10, $P10) = rx1459_cur."!mark_fail"(0)
    lt rx1459_pos, -1, rx1459_done
    eq rx1459_pos, -1, rx1459_fail
    jump $I10
  rx1459_done:
    rx1459_cur."!cursor_fail"()
    if_null rx1459_debug, debug_1052
    rx1459_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1052:
    .return (rx1459_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("343_1296306519.49046") :method
.annotate 'line', 4
    $P1461 = self."!PREFIX__!subrule"("O", "gt")
    new $P1462, "ResizablePMCArray"
    push $P1462, $P1461
    .return ($P1462)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("344_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1466_tgt
    .local int rx1466_pos
    .local int rx1466_off
    .local int rx1466_eos
    .local int rx1466_rep
    .local pmc rx1466_cur
    .local pmc rx1466_debug
    (rx1466_cur, rx1466_pos, rx1466_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1466_cur
    .local pmc match
    .lex "$/", match
    length rx1466_eos, rx1466_tgt
    gt rx1466_pos, rx1466_eos, rx1466_done
    set rx1466_off, 0
    lt rx1466_pos, 2, rx1466_start
    sub rx1466_off, rx1466_pos, 1
    substr rx1466_tgt, rx1466_tgt, rx1466_off
  rx1466_start:
    eq $I10, 1, rx1466_restart
    if_null rx1466_debug, debug_1053
    rx1466_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1470_done
    goto rxscan1470_scan
  rxscan1470_loop:
    (rx1466_pos) = rx1466_cur."from"()
    inc rx1466_pos
    rx1466_cur."!cursor_from"(rx1466_pos)
    ge rx1466_pos, rx1466_eos, rxscan1470_done
  rxscan1470_scan:
    set_addr $I10, rxscan1470_loop
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  rxscan1470_done:
.annotate 'line', 615
  # rx subcapture "sym"
    set_addr $I10, rxcap_1471_fail
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1466_pos, 3
    gt $I11, rx1466_eos, rx1466_fail
    sub $I11, rx1466_pos, rx1466_off
    substr $S10, rx1466_tgt, $I11, 3
    ne $S10, "=:=", rx1466_fail
    add rx1466_pos, 3
    set_addr $I10, rxcap_1471_fail
    ($I12, $I11) = rx1466_cur."!mark_peek"($I10)
    rx1466_cur."!cursor_pos"($I11)
    ($P10) = rx1466_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1466_pos, "")
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1471_done
  rxcap_1471_fail:
    goto rx1466_fail
  rxcap_1471_done:
  # rx subrule "O" subtype=capture negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1466_fail
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1466_pos = $P10."pos"()
  # rx pass
    rx1466_cur."!cursor_pass"(rx1466_pos, "infix:sym<=:=>")
    if_null rx1466_debug, debug_1054
    rx1466_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1466_pos)
  debug_1054:
    .return (rx1466_cur)
  rx1466_restart:
.annotate 'line', 4
    if_null rx1466_debug, debug_1055
    rx1466_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1055:
  rx1466_fail:
    (rx1466_rep, rx1466_pos, $I10, $P10) = rx1466_cur."!mark_fail"(0)
    lt rx1466_pos, -1, rx1466_done
    eq rx1466_pos, -1, rx1466_fail
    jump $I10
  rx1466_done:
    rx1466_cur."!cursor_fail"()
    if_null rx1466_debug, debug_1056
    rx1466_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1056:
    .return (rx1466_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("345_1296306519.49046") :method
.annotate 'line', 4
    $P1468 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1469, "ResizablePMCArray"
    push $P1469, $P1468
    .return ($P1469)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("346_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1473_tgt
    .local int rx1473_pos
    .local int rx1473_off
    .local int rx1473_eos
    .local int rx1473_rep
    .local pmc rx1473_cur
    .local pmc rx1473_debug
    (rx1473_cur, rx1473_pos, rx1473_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1473_cur
    .local pmc match
    .lex "$/", match
    length rx1473_eos, rx1473_tgt
    gt rx1473_pos, rx1473_eos, rx1473_done
    set rx1473_off, 0
    lt rx1473_pos, 2, rx1473_start
    sub rx1473_off, rx1473_pos, 1
    substr rx1473_tgt, rx1473_tgt, rx1473_off
  rx1473_start:
    eq $I10, 1, rx1473_restart
    if_null rx1473_debug, debug_1057
    rx1473_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1477_done
    goto rxscan1477_scan
  rxscan1477_loop:
    (rx1473_pos) = rx1473_cur."from"()
    inc rx1473_pos
    rx1473_cur."!cursor_from"(rx1473_pos)
    ge rx1473_pos, rx1473_eos, rxscan1477_done
  rxscan1477_scan:
    set_addr $I10, rxscan1477_loop
    rx1473_cur."!mark_push"(0, rx1473_pos, $I10)
  rxscan1477_done:
.annotate 'line', 616
  # rx subcapture "sym"
    set_addr $I10, rxcap_1478_fail
    rx1473_cur."!mark_push"(0, rx1473_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1473_pos, 2
    gt $I11, rx1473_eos, rx1473_fail
    sub $I11, rx1473_pos, rx1473_off
    substr $S10, rx1473_tgt, $I11, 2
    ne $S10, "~~", rx1473_fail
    add rx1473_pos, 2
    set_addr $I10, rxcap_1478_fail
    ($I12, $I11) = rx1473_cur."!mark_peek"($I10)
    rx1473_cur."!cursor_pos"($I11)
    ($P10) = rx1473_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1473_pos, "")
    rx1473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1478_done
  rxcap_1478_fail:
    goto rx1473_fail
  rxcap_1478_done:
  # rx subrule "O" subtype=capture negate=
    rx1473_cur."!cursor_pos"(rx1473_pos)
    $P10 = rx1473_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1473_fail
    rx1473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1473_pos = $P10."pos"()
  # rx pass
    rx1473_cur."!cursor_pass"(rx1473_pos, "infix:sym<~~>")
    if_null rx1473_debug, debug_1058
    rx1473_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1473_pos)
  debug_1058:
    .return (rx1473_cur)
  rx1473_restart:
.annotate 'line', 4
    if_null rx1473_debug, debug_1059
    rx1473_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1059:
  rx1473_fail:
    (rx1473_rep, rx1473_pos, $I10, $P10) = rx1473_cur."!mark_fail"(0)
    lt rx1473_pos, -1, rx1473_done
    eq rx1473_pos, -1, rx1473_fail
    jump $I10
  rx1473_done:
    rx1473_cur."!cursor_fail"()
    if_null rx1473_debug, debug_1060
    rx1473_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1060:
    .return (rx1473_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("347_1296306519.49046") :method
.annotate 'line', 4
    $P1475 = self."!PREFIX__!subrule"("O", "~~")
    new $P1476, "ResizablePMCArray"
    push $P1476, $P1475
    .return ($P1476)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("348_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1480_tgt
    .local int rx1480_pos
    .local int rx1480_off
    .local int rx1480_eos
    .local int rx1480_rep
    .local pmc rx1480_cur
    .local pmc rx1480_debug
    (rx1480_cur, rx1480_pos, rx1480_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1480_cur
    .local pmc match
    .lex "$/", match
    length rx1480_eos, rx1480_tgt
    gt rx1480_pos, rx1480_eos, rx1480_done
    set rx1480_off, 0
    lt rx1480_pos, 2, rx1480_start
    sub rx1480_off, rx1480_pos, 1
    substr rx1480_tgt, rx1480_tgt, rx1480_off
  rx1480_start:
    eq $I10, 1, rx1480_restart
    if_null rx1480_debug, debug_1061
    rx1480_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1484_done
    goto rxscan1484_scan
  rxscan1484_loop:
    (rx1480_pos) = rx1480_cur."from"()
    inc rx1480_pos
    rx1480_cur."!cursor_from"(rx1480_pos)
    ge rx1480_pos, rx1480_eos, rxscan1484_done
  rxscan1484_scan:
    set_addr $I10, rxscan1484_loop
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  rxscan1484_done:
.annotate 'line', 618
  # rx subcapture "sym"
    set_addr $I10, rxcap_1485_fail
    rx1480_cur."!mark_push"(0, rx1480_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1480_pos, 2
    gt $I11, rx1480_eos, rx1480_fail
    sub $I11, rx1480_pos, rx1480_off
    substr $S10, rx1480_tgt, $I11, 2
    ne $S10, "&&", rx1480_fail
    add rx1480_pos, 2
    set_addr $I10, rxcap_1485_fail
    ($I12, $I11) = rx1480_cur."!mark_peek"($I10)
    rx1480_cur."!cursor_pos"($I11)
    ($P10) = rx1480_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1480_pos, "")
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1485_done
  rxcap_1485_fail:
    goto rx1480_fail
  rxcap_1485_done:
  # rx subrule "O" subtype=capture negate=
    rx1480_cur."!cursor_pos"(rx1480_pos)
    $P10 = rx1480_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1480_fail
    rx1480_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1480_pos = $P10."pos"()
  # rx pass
    rx1480_cur."!cursor_pass"(rx1480_pos, "infix:sym<&&>")
    if_null rx1480_debug, debug_1062
    rx1480_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1480_pos)
  debug_1062:
    .return (rx1480_cur)
  rx1480_restart:
.annotate 'line', 4
    if_null rx1480_debug, debug_1063
    rx1480_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1063:
  rx1480_fail:
    (rx1480_rep, rx1480_pos, $I10, $P10) = rx1480_cur."!mark_fail"(0)
    lt rx1480_pos, -1, rx1480_done
    eq rx1480_pos, -1, rx1480_fail
    jump $I10
  rx1480_done:
    rx1480_cur."!cursor_fail"()
    if_null rx1480_debug, debug_1064
    rx1480_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1064:
    .return (rx1480_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("349_1296306519.49046") :method
.annotate 'line', 4
    $P1482 = self."!PREFIX__!subrule"("O", "&&")
    new $P1483, "ResizablePMCArray"
    push $P1483, $P1482
    .return ($P1483)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("350_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1487_tgt
    .local int rx1487_pos
    .local int rx1487_off
    .local int rx1487_eos
    .local int rx1487_rep
    .local pmc rx1487_cur
    .local pmc rx1487_debug
    (rx1487_cur, rx1487_pos, rx1487_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1487_cur
    .local pmc match
    .lex "$/", match
    length rx1487_eos, rx1487_tgt
    gt rx1487_pos, rx1487_eos, rx1487_done
    set rx1487_off, 0
    lt rx1487_pos, 2, rx1487_start
    sub rx1487_off, rx1487_pos, 1
    substr rx1487_tgt, rx1487_tgt, rx1487_off
  rx1487_start:
    eq $I10, 1, rx1487_restart
    if_null rx1487_debug, debug_1065
    rx1487_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1491_done
    goto rxscan1491_scan
  rxscan1491_loop:
    (rx1487_pos) = rx1487_cur."from"()
    inc rx1487_pos
    rx1487_cur."!cursor_from"(rx1487_pos)
    ge rx1487_pos, rx1487_eos, rxscan1491_done
  rxscan1491_scan:
    set_addr $I10, rxscan1491_loop
    rx1487_cur."!mark_push"(0, rx1487_pos, $I10)
  rxscan1491_done:
.annotate 'line', 620
  # rx subcapture "sym"
    set_addr $I10, rxcap_1492_fail
    rx1487_cur."!mark_push"(0, rx1487_pos, $I10)
  # rx literal  "||"
    add $I11, rx1487_pos, 2
    gt $I11, rx1487_eos, rx1487_fail
    sub $I11, rx1487_pos, rx1487_off
    substr $S10, rx1487_tgt, $I11, 2
    ne $S10, "||", rx1487_fail
    add rx1487_pos, 2
    set_addr $I10, rxcap_1492_fail
    ($I12, $I11) = rx1487_cur."!mark_peek"($I10)
    rx1487_cur."!cursor_pos"($I11)
    ($P10) = rx1487_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1487_pos, "")
    rx1487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1492_done
  rxcap_1492_fail:
    goto rx1487_fail
  rxcap_1492_done:
  # rx subrule "O" subtype=capture negate=
    rx1487_cur."!cursor_pos"(rx1487_pos)
    $P10 = rx1487_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1487_fail
    rx1487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1487_pos = $P10."pos"()
  # rx pass
    rx1487_cur."!cursor_pass"(rx1487_pos, "infix:sym<||>")
    if_null rx1487_debug, debug_1066
    rx1487_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1487_pos)
  debug_1066:
    .return (rx1487_cur)
  rx1487_restart:
.annotate 'line', 4
    if_null rx1487_debug, debug_1067
    rx1487_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1067:
  rx1487_fail:
    (rx1487_rep, rx1487_pos, $I10, $P10) = rx1487_cur."!mark_fail"(0)
    lt rx1487_pos, -1, rx1487_done
    eq rx1487_pos, -1, rx1487_fail
    jump $I10
  rx1487_done:
    rx1487_cur."!cursor_fail"()
    if_null rx1487_debug, debug_1068
    rx1487_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1068:
    .return (rx1487_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("351_1296306519.49046") :method
.annotate 'line', 4
    $P1489 = self."!PREFIX__!subrule"("O", "||")
    new $P1490, "ResizablePMCArray"
    push $P1490, $P1489
    .return ($P1490)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("352_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1494_tgt
    .local int rx1494_pos
    .local int rx1494_off
    .local int rx1494_eos
    .local int rx1494_rep
    .local pmc rx1494_cur
    .local pmc rx1494_debug
    (rx1494_cur, rx1494_pos, rx1494_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1494_cur
    .local pmc match
    .lex "$/", match
    length rx1494_eos, rx1494_tgt
    gt rx1494_pos, rx1494_eos, rx1494_done
    set rx1494_off, 0
    lt rx1494_pos, 2, rx1494_start
    sub rx1494_off, rx1494_pos, 1
    substr rx1494_tgt, rx1494_tgt, rx1494_off
  rx1494_start:
    eq $I10, 1, rx1494_restart
    if_null rx1494_debug, debug_1069
    rx1494_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1498_done
    goto rxscan1498_scan
  rxscan1498_loop:
    (rx1494_pos) = rx1494_cur."from"()
    inc rx1494_pos
    rx1494_cur."!cursor_from"(rx1494_pos)
    ge rx1494_pos, rx1494_eos, rxscan1498_done
  rxscan1498_scan:
    set_addr $I10, rxscan1498_loop
    rx1494_cur."!mark_push"(0, rx1494_pos, $I10)
  rxscan1498_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1499_fail
    rx1494_cur."!mark_push"(0, rx1494_pos, $I10)
  # rx literal  "//"
    add $I11, rx1494_pos, 2
    gt $I11, rx1494_eos, rx1494_fail
    sub $I11, rx1494_pos, rx1494_off
    substr $S10, rx1494_tgt, $I11, 2
    ne $S10, "//", rx1494_fail
    add rx1494_pos, 2
    set_addr $I10, rxcap_1499_fail
    ($I12, $I11) = rx1494_cur."!mark_peek"($I10)
    rx1494_cur."!cursor_pos"($I11)
    ($P10) = rx1494_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1494_pos, "")
    rx1494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1499_done
  rxcap_1499_fail:
    goto rx1494_fail
  rxcap_1499_done:
  # rx subrule "O" subtype=capture negate=
    rx1494_cur."!cursor_pos"(rx1494_pos)
    $P10 = rx1494_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1494_fail
    rx1494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1494_pos = $P10."pos"()
  # rx pass
    rx1494_cur."!cursor_pass"(rx1494_pos, "infix:sym<//>")
    if_null rx1494_debug, debug_1070
    rx1494_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1494_pos)
  debug_1070:
    .return (rx1494_cur)
  rx1494_restart:
.annotate 'line', 4
    if_null rx1494_debug, debug_1071
    rx1494_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1071:
  rx1494_fail:
    (rx1494_rep, rx1494_pos, $I10, $P10) = rx1494_cur."!mark_fail"(0)
    lt rx1494_pos, -1, rx1494_done
    eq rx1494_pos, -1, rx1494_fail
    jump $I10
  rx1494_done:
    rx1494_cur."!cursor_fail"()
    if_null rx1494_debug, debug_1072
    rx1494_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1072:
    .return (rx1494_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("353_1296306519.49046") :method
.annotate 'line', 4
    $P1496 = self."!PREFIX__!subrule"("O", "//")
    new $P1497, "ResizablePMCArray"
    push $P1497, $P1496
    .return ($P1497)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("354_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1501_tgt
    .local int rx1501_pos
    .local int rx1501_off
    .local int rx1501_eos
    .local int rx1501_rep
    .local pmc rx1501_cur
    .local pmc rx1501_debug
    (rx1501_cur, rx1501_pos, rx1501_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1501_cur
    .local pmc match
    .lex "$/", match
    length rx1501_eos, rx1501_tgt
    gt rx1501_pos, rx1501_eos, rx1501_done
    set rx1501_off, 0
    lt rx1501_pos, 2, rx1501_start
    sub rx1501_off, rx1501_pos, 1
    substr rx1501_tgt, rx1501_tgt, rx1501_off
  rx1501_start:
    eq $I10, 1, rx1501_restart
    if_null rx1501_debug, debug_1073
    rx1501_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1505_done
    goto rxscan1505_scan
  rxscan1505_loop:
    (rx1501_pos) = rx1501_cur."from"()
    inc rx1501_pos
    rx1501_cur."!cursor_from"(rx1501_pos)
    ge rx1501_pos, rx1501_eos, rxscan1505_done
  rxscan1505_scan:
    set_addr $I10, rxscan1505_loop
    rx1501_cur."!mark_push"(0, rx1501_pos, $I10)
  rxscan1505_done:
.annotate 'line', 624
  # rx literal  "??"
    add $I11, rx1501_pos, 2
    gt $I11, rx1501_eos, rx1501_fail
    sub $I11, rx1501_pos, rx1501_off
    substr $S10, rx1501_tgt, $I11, 2
    ne $S10, "??", rx1501_fail
    add rx1501_pos, 2
.annotate 'line', 625
  # rx subrule "ws" subtype=method negate=
    rx1501_cur."!cursor_pos"(rx1501_pos)
    $P10 = rx1501_cur."ws"()
    unless $P10, rx1501_fail
    rx1501_pos = $P10."pos"()
.annotate 'line', 626
  # rx subrule "EXPR" subtype=capture negate=
    rx1501_cur."!cursor_pos"(rx1501_pos)
    $P10 = rx1501_cur."EXPR"("i=")
    unless $P10, rx1501_fail
    rx1501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1501_pos = $P10."pos"()
.annotate 'line', 627
  # rx literal  "!!"
    add $I11, rx1501_pos, 2
    gt $I11, rx1501_eos, rx1501_fail
    sub $I11, rx1501_pos, rx1501_off
    substr $S10, rx1501_tgt, $I11, 2
    ne $S10, "!!", rx1501_fail
    add rx1501_pos, 2
.annotate 'line', 628
  # rx subrule "O" subtype=capture negate=
    rx1501_cur."!cursor_pos"(rx1501_pos)
    $P10 = rx1501_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1501_fail
    rx1501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1501_pos = $P10."pos"()
.annotate 'line', 623
  # rx pass
    rx1501_cur."!cursor_pass"(rx1501_pos, "infix:sym<?? !!>")
    if_null rx1501_debug, debug_1074
    rx1501_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1501_pos)
  debug_1074:
    .return (rx1501_cur)
  rx1501_restart:
.annotate 'line', 4
    if_null rx1501_debug, debug_1075
    rx1501_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1075:
  rx1501_fail:
    (rx1501_rep, rx1501_pos, $I10, $P10) = rx1501_cur."!mark_fail"(0)
    lt rx1501_pos, -1, rx1501_done
    eq rx1501_pos, -1, rx1501_fail
    jump $I10
  rx1501_done:
    rx1501_cur."!cursor_fail"()
    if_null rx1501_debug, debug_1076
    rx1501_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1076:
    .return (rx1501_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("355_1296306519.49046") :method
.annotate 'line', 4
    $P1503 = self."!PREFIX__!subrule"("ws", "??")
    new $P1504, "ResizablePMCArray"
    push $P1504, $P1503
    .return ($P1504)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("356_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1507_tgt
    .local int rx1507_pos
    .local int rx1507_off
    .local int rx1507_eos
    .local int rx1507_rep
    .local pmc rx1507_cur
    .local pmc rx1507_debug
    (rx1507_cur, rx1507_pos, rx1507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1507_cur
    .local pmc match
    .lex "$/", match
    length rx1507_eos, rx1507_tgt
    gt rx1507_pos, rx1507_eos, rx1507_done
    set rx1507_off, 0
    lt rx1507_pos, 2, rx1507_start
    sub rx1507_off, rx1507_pos, 1
    substr rx1507_tgt, rx1507_tgt, rx1507_off
  rx1507_start:
    eq $I10, 1, rx1507_restart
    if_null rx1507_debug, debug_1077
    rx1507_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1507_pos) = rx1507_cur."from"()
    inc rx1507_pos
    rx1507_cur."!cursor_from"(rx1507_pos)
    ge rx1507_pos, rx1507_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  rxscan1511_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1512_fail
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  # rx literal  "="
    add $I11, rx1507_pos, 1
    gt $I11, rx1507_eos, rx1507_fail
    sub $I11, rx1507_pos, rx1507_off
    ord $I11, rx1507_tgt, $I11
    ne $I11, 61, rx1507_fail
    add rx1507_pos, 1
    set_addr $I10, rxcap_1512_fail
    ($I12, $I11) = rx1507_cur."!mark_peek"($I10)
    rx1507_cur."!cursor_pos"($I11)
    ($P10) = rx1507_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1507_pos, "")
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1512_done
  rxcap_1512_fail:
    goto rx1507_fail
  rxcap_1512_done:
  # rx subrule "panic" subtype=method negate=
    rx1507_cur."!cursor_pos"(rx1507_pos)
    $P10 = rx1507_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1507_fail
    rx1507_pos = $P10."pos"()
.annotate 'line', 631
  # rx pass
    rx1507_cur."!cursor_pass"(rx1507_pos, "infix:sym<=>")
    if_null rx1507_debug, debug_1078
    rx1507_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1507_pos)
  debug_1078:
    .return (rx1507_cur)
  rx1507_restart:
.annotate 'line', 4
    if_null rx1507_debug, debug_1079
    rx1507_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1079:
  rx1507_fail:
    (rx1507_rep, rx1507_pos, $I10, $P10) = rx1507_cur."!mark_fail"(0)
    lt rx1507_pos, -1, rx1507_done
    eq rx1507_pos, -1, rx1507_fail
    jump $I10
  rx1507_done:
    rx1507_cur."!cursor_fail"()
    if_null rx1507_debug, debug_1080
    rx1507_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1080:
    .return (rx1507_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("357_1296306519.49046") :method
.annotate 'line', 4
    $P1509 = self."!PREFIX__!subrule"("panic", "=")
    new $P1510, "ResizablePMCArray"
    push $P1510, $P1509
    .return ($P1510)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("358_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1514_tgt
    .local int rx1514_pos
    .local int rx1514_off
    .local int rx1514_eos
    .local int rx1514_rep
    .local pmc rx1514_cur
    .local pmc rx1514_debug
    (rx1514_cur, rx1514_pos, rx1514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1514_cur
    .local pmc match
    .lex "$/", match
    length rx1514_eos, rx1514_tgt
    gt rx1514_pos, rx1514_eos, rx1514_done
    set rx1514_off, 0
    lt rx1514_pos, 2, rx1514_start
    sub rx1514_off, rx1514_pos, 1
    substr rx1514_tgt, rx1514_tgt, rx1514_off
  rx1514_start:
    eq $I10, 1, rx1514_restart
    if_null rx1514_debug, debug_1081
    rx1514_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1518_done
    goto rxscan1518_scan
  rxscan1518_loop:
    (rx1514_pos) = rx1514_cur."from"()
    inc rx1514_pos
    rx1514_cur."!cursor_from"(rx1514_pos)
    ge rx1514_pos, rx1514_eos, rxscan1518_done
  rxscan1518_scan:
    set_addr $I10, rxscan1518_loop
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  rxscan1518_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1519_fail
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  # rx literal  ":="
    add $I11, rx1514_pos, 2
    gt $I11, rx1514_eos, rx1514_fail
    sub $I11, rx1514_pos, rx1514_off
    substr $S10, rx1514_tgt, $I11, 2
    ne $S10, ":=", rx1514_fail
    add rx1514_pos, 2
    set_addr $I10, rxcap_1519_fail
    ($I12, $I11) = rx1514_cur."!mark_peek"($I10)
    rx1514_cur."!cursor_pos"($I11)
    ($P10) = rx1514_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1514_pos, "")
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1519_done
  rxcap_1519_fail:
    goto rx1514_fail
  rxcap_1519_done:
  # rx subrule "O" subtype=capture negate=
    rx1514_cur."!cursor_pos"(rx1514_pos)
    $P10 = rx1514_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1514_fail
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1514_pos = $P10."pos"()
  # rx pass
    rx1514_cur."!cursor_pass"(rx1514_pos, "infix:sym<:=>")
    if_null rx1514_debug, debug_1082
    rx1514_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1514_pos)
  debug_1082:
    .return (rx1514_cur)
  rx1514_restart:
.annotate 'line', 4
    if_null rx1514_debug, debug_1083
    rx1514_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1083:
  rx1514_fail:
    (rx1514_rep, rx1514_pos, $I10, $P10) = rx1514_cur."!mark_fail"(0)
    lt rx1514_pos, -1, rx1514_done
    eq rx1514_pos, -1, rx1514_fail
    jump $I10
  rx1514_done:
    rx1514_cur."!cursor_fail"()
    if_null rx1514_debug, debug_1084
    rx1514_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1084:
    .return (rx1514_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("359_1296306519.49046") :method
.annotate 'line', 4
    $P1516 = self."!PREFIX__!subrule"("O", ":=")
    new $P1517, "ResizablePMCArray"
    push $P1517, $P1516
    .return ($P1517)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("360_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1521_tgt
    .local int rx1521_pos
    .local int rx1521_off
    .local int rx1521_eos
    .local int rx1521_rep
    .local pmc rx1521_cur
    .local pmc rx1521_debug
    (rx1521_cur, rx1521_pos, rx1521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1521_cur
    .local pmc match
    .lex "$/", match
    length rx1521_eos, rx1521_tgt
    gt rx1521_pos, rx1521_eos, rx1521_done
    set rx1521_off, 0
    lt rx1521_pos, 2, rx1521_start
    sub rx1521_off, rx1521_pos, 1
    substr rx1521_tgt, rx1521_tgt, rx1521_off
  rx1521_start:
    eq $I10, 1, rx1521_restart
    if_null rx1521_debug, debug_1085
    rx1521_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1525_done
    goto rxscan1525_scan
  rxscan1525_loop:
    (rx1521_pos) = rx1521_cur."from"()
    inc rx1521_pos
    rx1521_cur."!cursor_from"(rx1521_pos)
    ge rx1521_pos, rx1521_eos, rxscan1525_done
  rxscan1525_scan:
    set_addr $I10, rxscan1525_loop
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  rxscan1525_done:
.annotate 'line', 635
  # rx subcapture "sym"
    set_addr $I10, rxcap_1526_fail
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  # rx literal  "::="
    add $I11, rx1521_pos, 3
    gt $I11, rx1521_eos, rx1521_fail
    sub $I11, rx1521_pos, rx1521_off
    substr $S10, rx1521_tgt, $I11, 3
    ne $S10, "::=", rx1521_fail
    add rx1521_pos, 3
    set_addr $I10, rxcap_1526_fail
    ($I12, $I11) = rx1521_cur."!mark_peek"($I10)
    rx1521_cur."!cursor_pos"($I11)
    ($P10) = rx1521_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1521_pos, "")
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1526_done
  rxcap_1526_fail:
    goto rx1521_fail
  rxcap_1526_done:
  # rx subrule "O" subtype=capture negate=
    rx1521_cur."!cursor_pos"(rx1521_pos)
    $P10 = rx1521_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1521_fail
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1521_pos = $P10."pos"()
  # rx pass
    rx1521_cur."!cursor_pass"(rx1521_pos, "infix:sym<::=>")
    if_null rx1521_debug, debug_1086
    rx1521_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1521_pos)
  debug_1086:
    .return (rx1521_cur)
  rx1521_restart:
.annotate 'line', 4
    if_null rx1521_debug, debug_1087
    rx1521_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1087:
  rx1521_fail:
    (rx1521_rep, rx1521_pos, $I10, $P10) = rx1521_cur."!mark_fail"(0)
    lt rx1521_pos, -1, rx1521_done
    eq rx1521_pos, -1, rx1521_fail
    jump $I10
  rx1521_done:
    rx1521_cur."!cursor_fail"()
    if_null rx1521_debug, debug_1088
    rx1521_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1088:
    .return (rx1521_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("361_1296306519.49046") :method
.annotate 'line', 4
    $P1523 = self."!PREFIX__!subrule"("O", "::=")
    new $P1524, "ResizablePMCArray"
    push $P1524, $P1523
    .return ($P1524)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("362_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1089
    rx1528_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1532_done
    goto rxscan1532_scan
  rxscan1532_loop:
    (rx1528_pos) = rx1528_cur."from"()
    inc rx1528_pos
    rx1528_cur."!cursor_from"(rx1528_pos)
    ge rx1528_pos, rx1528_eos, rxscan1532_done
  rxscan1532_scan:
    set_addr $I10, rxscan1532_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1532_done:
.annotate 'line', 637
  # rx subcapture "sym"
    set_addr $I10, rxcap_1533_fail
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  # rx literal  ","
    add $I11, rx1528_pos, 1
    gt $I11, rx1528_eos, rx1528_fail
    sub $I11, rx1528_pos, rx1528_off
    ord $I11, rx1528_tgt, $I11
    ne $I11, 44, rx1528_fail
    add rx1528_pos, 1
    set_addr $I10, rxcap_1533_fail
    ($I12, $I11) = rx1528_cur."!mark_peek"($I10)
    rx1528_cur."!cursor_pos"($I11)
    ($P10) = rx1528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1528_pos, "")
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1533_done
  rxcap_1533_fail:
    goto rx1528_fail
  rxcap_1533_done:
  # rx subrule "O" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1528_pos = $P10."pos"()
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "infix:sym<,>")
    if_null rx1528_debug, debug_1090
    rx1528_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1528_pos)
  debug_1090:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 4
    if_null rx1528_debug, debug_1091
    rx1528_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1091:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1092
    rx1528_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1092:
    .return (rx1528_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("363_1296306519.49046") :method
.annotate 'line', 4
    $P1530 = self."!PREFIX__!subrule"("O", ",")
    new $P1531, "ResizablePMCArray"
    push $P1531, $P1530
    .return ($P1531)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("364_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P1543 = "366_1296306519.49046" 
    capture_lex $P1543
    .local string rx1535_tgt
    .local int rx1535_pos
    .local int rx1535_off
    .local int rx1535_eos
    .local int rx1535_rep
    .local pmc rx1535_cur
    .local pmc rx1535_debug
    (rx1535_cur, rx1535_pos, rx1535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1535_cur
    .local pmc match
    .lex "$/", match
    length rx1535_eos, rx1535_tgt
    gt rx1535_pos, rx1535_eos, rx1535_done
    set rx1535_off, 0
    lt rx1535_pos, 2, rx1535_start
    sub rx1535_off, rx1535_pos, 1
    substr rx1535_tgt, rx1535_tgt, rx1535_off
  rx1535_start:
    eq $I10, 1, rx1535_restart
    if_null rx1535_debug, debug_1093
    rx1535_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1535_pos) = rx1535_cur."from"()
    inc rx1535_pos
    rx1535_cur."!cursor_from"(rx1535_pos)
    ge rx1535_pos, rx1535_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  rxscan1538_done:
.annotate 'line', 639
  # rx subcapture "sym"
    set_addr $I10, rxcap_1539_fail
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  # rx literal  "return"
    add $I11, rx1535_pos, 6
    gt $I11, rx1535_eos, rx1535_fail
    sub $I11, rx1535_pos, rx1535_off
    substr $S10, rx1535_tgt, $I11, 6
    ne $S10, "return", rx1535_fail
    add rx1535_pos, 6
    set_addr $I10, rxcap_1539_fail
    ($I12, $I11) = rx1535_cur."!mark_peek"($I10)
    rx1535_cur."!cursor_pos"($I11)
    ($P10) = rx1535_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1535_pos, "")
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1539_done
  rxcap_1539_fail:
    goto rx1535_fail
  rxcap_1539_done:
  # rx charclass s
    ge rx1535_pos, rx1535_eos, rx1535_fail
    sub $I10, rx1535_pos, rx1535_off
    is_cclass $I11, 32, rx1535_tgt, $I10
    unless $I11, rx1535_fail
    inc rx1535_pos
  # rx subrule "O" subtype=capture negate=
    rx1535_cur."!cursor_pos"(rx1535_pos)
    $P10 = rx1535_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1535_fail
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1535_pos = $P10."pos"()
    rx1535_cur."!cursor_pos"(rx1535_pos)
    find_lex $P1540, unicode:"$\x{a2}"
    $P1541 = $P1540."MATCH"()
    store_lex "$/", $P1541
    .const 'Sub' $P1543 = "366_1296306519.49046" 
    capture_lex $P1543
    $P1545 = $P1543()
  # rx pass
    rx1535_cur."!cursor_pass"(rx1535_pos, "prefix:sym<return>")
    if_null rx1535_debug, debug_1094
    rx1535_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1535_pos)
  debug_1094:
    .return (rx1535_cur)
  rx1535_restart:
.annotate 'line', 4
    if_null rx1535_debug, debug_1095
    rx1535_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1095:
  rx1535_fail:
    (rx1535_rep, rx1535_pos, $I10, $P10) = rx1535_cur."!mark_fail"(0)
    lt rx1535_pos, -1, rx1535_done
    eq rx1535_pos, -1, rx1535_fail
    jump $I10
  rx1535_done:
    rx1535_cur."!cursor_fail"()
    if_null rx1535_debug, debug_1096
    rx1535_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1096:
    .return (rx1535_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("365_1296306519.49046") :method
.annotate 'line', 4
    new $P1537, "ResizablePMCArray"
    push $P1537, "return"
    .return ($P1537)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1542"  :anon :subid("366_1296306519.49046") :outer("364_1296306519.49046")
.annotate 'line', 639
    new $P1544, "Integer"
    assign $P1544, 1
    store_dynamic_lex "$*RETURN_USED", $P1544
    .return ($P1544)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("367_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1547_tgt
    .local int rx1547_pos
    .local int rx1547_off
    .local int rx1547_eos
    .local int rx1547_rep
    .local pmc rx1547_cur
    .local pmc rx1547_debug
    (rx1547_cur, rx1547_pos, rx1547_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1547_cur
    .local pmc match
    .lex "$/", match
    length rx1547_eos, rx1547_tgt
    gt rx1547_pos, rx1547_eos, rx1547_done
    set rx1547_off, 0
    lt rx1547_pos, 2, rx1547_start
    sub rx1547_off, rx1547_pos, 1
    substr rx1547_tgt, rx1547_tgt, rx1547_off
  rx1547_start:
    eq $I10, 1, rx1547_restart
    if_null rx1547_debug, debug_1097
    rx1547_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1550_done
    goto rxscan1550_scan
  rxscan1550_loop:
    (rx1547_pos) = rx1547_cur."from"()
    inc rx1547_pos
    rx1547_cur."!cursor_from"(rx1547_pos)
    ge rx1547_pos, rx1547_eos, rxscan1550_done
  rxscan1550_scan:
    set_addr $I10, rxscan1550_loop
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  rxscan1550_done:
.annotate 'line', 640
  # rx subcapture "sym"
    set_addr $I10, rxcap_1551_fail
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  # rx literal  "make"
    add $I11, rx1547_pos, 4
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 4
    ne $S10, "make", rx1547_fail
    add rx1547_pos, 4
    set_addr $I10, rxcap_1551_fail
    ($I12, $I11) = rx1547_cur."!mark_peek"($I10)
    rx1547_cur."!cursor_pos"($I11)
    ($P10) = rx1547_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1547_pos, "")
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1551_done
  rxcap_1551_fail:
    goto rx1547_fail
  rxcap_1551_done:
  # rx charclass s
    ge rx1547_pos, rx1547_eos, rx1547_fail
    sub $I10, rx1547_pos, rx1547_off
    is_cclass $I11, 32, rx1547_tgt, $I10
    unless $I11, rx1547_fail
    inc rx1547_pos
  # rx subrule "O" subtype=capture negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."O"("%list_prefix")
    unless $P10, rx1547_fail
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1547_pos = $P10."pos"()
  # rx pass
    rx1547_cur."!cursor_pass"(rx1547_pos, "prefix:sym<make>")
    if_null rx1547_debug, debug_1098
    rx1547_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1547_pos)
  debug_1098:
    .return (rx1547_cur)
  rx1547_restart:
.annotate 'line', 4
    if_null rx1547_debug, debug_1099
    rx1547_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1099:
  rx1547_fail:
    (rx1547_rep, rx1547_pos, $I10, $P10) = rx1547_cur."!mark_fail"(0)
    lt rx1547_pos, -1, rx1547_done
    eq rx1547_pos, -1, rx1547_fail
    jump $I10
  rx1547_done:
    rx1547_cur."!cursor_fail"()
    if_null rx1547_debug, debug_1100
    rx1547_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1100:
    .return (rx1547_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("368_1296306519.49046") :method
.annotate 'line', 4
    new $P1549, "ResizablePMCArray"
    push $P1549, "make"
    .return ($P1549)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("369_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1553_tgt
    .local int rx1553_pos
    .local int rx1553_off
    .local int rx1553_eos
    .local int rx1553_rep
    .local pmc rx1553_cur
    .local pmc rx1553_debug
    (rx1553_cur, rx1553_pos, rx1553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1553_cur
    .local pmc match
    .lex "$/", match
    length rx1553_eos, rx1553_tgt
    gt rx1553_pos, rx1553_eos, rx1553_done
    set rx1553_off, 0
    lt rx1553_pos, 2, rx1553_start
    sub rx1553_off, rx1553_pos, 1
    substr rx1553_tgt, rx1553_tgt, rx1553_off
  rx1553_start:
    eq $I10, 1, rx1553_restart
    if_null rx1553_debug, debug_1101
    rx1553_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1101:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1556_done
    goto rxscan1556_scan
  rxscan1556_loop:
    (rx1553_pos) = rx1553_cur."from"()
    inc rx1553_pos
    rx1553_cur."!cursor_from"(rx1553_pos)
    ge rx1553_pos, rx1553_eos, rxscan1556_done
  rxscan1556_scan:
    set_addr $I10, rxscan1556_loop
    rx1553_cur."!mark_push"(0, rx1553_pos, $I10)
  rxscan1556_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1557_fail
    rx1553_cur."!mark_push"(0, rx1553_pos, $I10)
  # rx literal  "last"
    add $I11, rx1553_pos, 4
    gt $I11, rx1553_eos, rx1553_fail
    sub $I11, rx1553_pos, rx1553_off
    substr $S10, rx1553_tgt, $I11, 4
    ne $S10, "last", rx1553_fail
    add rx1553_pos, 4
    set_addr $I10, rxcap_1557_fail
    ($I12, $I11) = rx1553_cur."!mark_peek"($I10)
    rx1553_cur."!cursor_pos"($I11)
    ($P10) = rx1553_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1553_pos, "")
    rx1553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1557_done
  rxcap_1557_fail:
    goto rx1553_fail
  rxcap_1557_done:
  # rx pass
    rx1553_cur."!cursor_pass"(rx1553_pos, "term:sym<last>")
    if_null rx1553_debug, debug_1102
    rx1553_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1553_pos)
  debug_1102:
    .return (rx1553_cur)
  rx1553_restart:
.annotate 'line', 4
    if_null rx1553_debug, debug_1103
    rx1553_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1103:
  rx1553_fail:
    (rx1553_rep, rx1553_pos, $I10, $P10) = rx1553_cur."!mark_fail"(0)
    lt rx1553_pos, -1, rx1553_done
    eq rx1553_pos, -1, rx1553_fail
    jump $I10
  rx1553_done:
    rx1553_cur."!cursor_fail"()
    if_null rx1553_debug, debug_1104
    rx1553_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1104:
    .return (rx1553_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("370_1296306519.49046") :method
.annotate 'line', 4
    new $P1555, "ResizablePMCArray"
    push $P1555, "last"
    .return ($P1555)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("371_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1559_tgt
    .local int rx1559_pos
    .local int rx1559_off
    .local int rx1559_eos
    .local int rx1559_rep
    .local pmc rx1559_cur
    .local pmc rx1559_debug
    (rx1559_cur, rx1559_pos, rx1559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1559_cur
    .local pmc match
    .lex "$/", match
    length rx1559_eos, rx1559_tgt
    gt rx1559_pos, rx1559_eos, rx1559_done
    set rx1559_off, 0
    lt rx1559_pos, 2, rx1559_start
    sub rx1559_off, rx1559_pos, 1
    substr rx1559_tgt, rx1559_tgt, rx1559_off
  rx1559_start:
    eq $I10, 1, rx1559_restart
    if_null rx1559_debug, debug_1105
    rx1559_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1105:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1559_pos) = rx1559_cur."from"()
    inc rx1559_pos
    rx1559_cur."!cursor_from"(rx1559_pos)
    ge rx1559_pos, rx1559_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  rxscan1562_done:
.annotate 'line', 642
  # rx subcapture "sym"
    set_addr $I10, rxcap_1563_fail
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  # rx literal  "next"
    add $I11, rx1559_pos, 4
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    substr $S10, rx1559_tgt, $I11, 4
    ne $S10, "next", rx1559_fail
    add rx1559_pos, 4
    set_addr $I10, rxcap_1563_fail
    ($I12, $I11) = rx1559_cur."!mark_peek"($I10)
    rx1559_cur."!cursor_pos"($I11)
    ($P10) = rx1559_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1559_pos, "")
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1563_done
  rxcap_1563_fail:
    goto rx1559_fail
  rxcap_1563_done:
  # rx pass
    rx1559_cur."!cursor_pass"(rx1559_pos, "term:sym<next>")
    if_null rx1559_debug, debug_1106
    rx1559_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1559_pos)
  debug_1106:
    .return (rx1559_cur)
  rx1559_restart:
.annotate 'line', 4
    if_null rx1559_debug, debug_1107
    rx1559_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1107:
  rx1559_fail:
    (rx1559_rep, rx1559_pos, $I10, $P10) = rx1559_cur."!mark_fail"(0)
    lt rx1559_pos, -1, rx1559_done
    eq rx1559_pos, -1, rx1559_fail
    jump $I10
  rx1559_done:
    rx1559_cur."!cursor_fail"()
    if_null rx1559_debug, debug_1108
    rx1559_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1108:
    .return (rx1559_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("372_1296306519.49046") :method
.annotate 'line', 4
    new $P1561, "ResizablePMCArray"
    push $P1561, "next"
    .return ($P1561)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("373_1296306519.49046") :method :outer("11_1296306519.49046")
.annotate 'line', 4
    .local string rx1565_tgt
    .local int rx1565_pos
    .local int rx1565_off
    .local int rx1565_eos
    .local int rx1565_rep
    .local pmc rx1565_cur
    .local pmc rx1565_debug
    (rx1565_cur, rx1565_pos, rx1565_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1565_cur
    .local pmc match
    .lex "$/", match
    length rx1565_eos, rx1565_tgt
    gt rx1565_pos, rx1565_eos, rx1565_done
    set rx1565_off, 0
    lt rx1565_pos, 2, rx1565_start
    sub rx1565_off, rx1565_pos, 1
    substr rx1565_tgt, rx1565_tgt, rx1565_off
  rx1565_start:
    eq $I10, 1, rx1565_restart
    if_null rx1565_debug, debug_1109
    rx1565_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1109:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1568_done
    goto rxscan1568_scan
  rxscan1568_loop:
    (rx1565_pos) = rx1565_cur."from"()
    inc rx1565_pos
    rx1565_cur."!cursor_from"(rx1565_pos)
    ge rx1565_pos, rx1565_eos, rxscan1568_done
  rxscan1568_scan:
    set_addr $I10, rxscan1568_loop
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  rxscan1568_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1569_fail
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1565_pos, 4
    gt $I11, rx1565_eos, rx1565_fail
    sub $I11, rx1565_pos, rx1565_off
    substr $S10, rx1565_tgt, $I11, 4
    ne $S10, "redo", rx1565_fail
    add rx1565_pos, 4
    set_addr $I10, rxcap_1569_fail
    ($I12, $I11) = rx1565_cur."!mark_peek"($I10)
    rx1565_cur."!cursor_pos"($I11)
    ($P10) = rx1565_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1565_pos, "")
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1569_done
  rxcap_1569_fail:
    goto rx1565_fail
  rxcap_1569_done:
  # rx pass
    rx1565_cur."!cursor_pass"(rx1565_pos, "term:sym<redo>")
    if_null rx1565_debug, debug_1110
    rx1565_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1565_pos)
  debug_1110:
    .return (rx1565_cur)
  rx1565_restart:
.annotate 'line', 4
    if_null rx1565_debug, debug_1111
    rx1565_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1111:
  rx1565_fail:
    (rx1565_rep, rx1565_pos, $I10, $P10) = rx1565_cur."!mark_fail"(0)
    lt rx1565_pos, -1, rx1565_done
    eq rx1565_pos, -1, rx1565_fail
    jump $I10
  rx1565_done:
    rx1565_cur."!cursor_fail"()
    if_null rx1565_debug, debug_1112
    rx1565_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1112:
    .return (rx1565_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("374_1296306519.49046") :method
.annotate 'line', 4
    new $P1567, "ResizablePMCArray"
    push $P1567, "redo"
    .return ($P1567)
.end


.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("375_1296306519.49046") :outer("11_1296306519.49046")
    .param pmc param_1571
    .param pmc param_1572
.annotate 'line', 645
    .lex "self", param_1571
    .lex "$/", param_1572
.annotate 'line', 647
    new $P1573, "Undef"
    .lex "$t", $P1573
    find_lex $P1574, "$/"
    unless_null $P1574, vivify_1113
    $P1574 = root_new ['parrot';'ResizablePMCArray']
  vivify_1113:
    set $P1575, $P1574[0]
    unless_null $P1575, vivify_1114
    new $P1575, "Undef"
  vivify_1114:
    store_lex "$t", $P1575
    find_lex $P1576, "$/"
    unless_null $P1576, vivify_1115
    $P1576 = root_new ['parrot';'ResizablePMCArray']
  vivify_1115:
    set $P1577, $P1576[1]
    unless_null $P1577, vivify_1116
    new $P1577, "Undef"
  vivify_1116:
    find_lex $P1578, "$/"
    unless_null $P1578, vivify_1117
    $P1578 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1578
  vivify_1117:
    set $P1578[0], $P1577
    find_lex $P1579, "$t"
    find_lex $P1580, "$/"
    unless_null $P1580, vivify_1118
    $P1580 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1580
  vivify_1118:
    set $P1580[1], $P1579
.annotate 'line', 645
    .return ($P1579)
.end


.namespace ["NQP";"Regex"]
.sub "_block1581"  :subid("376_1296306519.49046") :outer("11_1296306519.49046")
.annotate 'line', 651
    .const 'Sub' $P1646 = "397_1296306519.49046" 
    capture_lex $P1646
    .const 'Sub' $P1639 = "395_1296306519.49046" 
    capture_lex $P1639
    .const 'Sub' $P1634 = "393_1296306519.49046" 
    capture_lex $P1634
    .const 'Sub' $P1622 = "390_1296306519.49046" 
    capture_lex $P1622
    .const 'Sub' $P1612 = "387_1296306519.49046" 
    capture_lex $P1612
    .const 'Sub' $P1607 = "385_1296306519.49046" 
    capture_lex $P1607
    .const 'Sub' $P1598 = "382_1296306519.49046" 
    capture_lex $P1598
    .const 'Sub' $P1593 = "380_1296306519.49046" 
    capture_lex $P1593
    .const 'Sub' $P1584 = "377_1296306519.49046" 
    capture_lex $P1584
    get_global $P1583, "$?CLASS"
    .const 'Sub' $P1639 = "395_1296306519.49046" 
    capture_lex $P1639
    .return ($P1639)
.end


.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1119") :outer("376_1296306519.49046")
.annotate 'line', 651
    get_hll_global $P1582, ["NQP";"Regex"], "_block1581" 
    .local pmc block
    set block, $P1582
    .const 'Sub' $P1646 = "397_1296306519.49046" 
    capture_lex $P1646
    $P1646()
.end


.namespace ["NQP";"Regex"]
.sub "_block1645"  :anon :subid("397_1296306519.49046") :outer("376_1296306519.49046")
.annotate 'line', 651
    get_hll_global $P1647, "NQPClassHOW"
    $P1648 = $P1647."new_type"("Regex" :named("name"))
    .local pmc type_obj
    set type_obj, $P1648
    set_hll_global ["NQP"], "Regex", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1649, type_obj
    .const 'Sub' $P1650 = "377_1296306519.49046" 
    $P1649."add_method"(type_obj, "metachar:sym<:my>", $P1650)
    get_how $P1651, type_obj
    get_global $P1652, "!PREFIX__metachar:sym<:my>"
    $P1651."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P1652)
    get_how $P1653, type_obj
    .const 'Sub' $P1654 = "380_1296306519.49046" 
    $P1653."add_method"(type_obj, "metachar:sym<{ }>", $P1654)
    get_how $P1655, type_obj
    get_global $P1656, "!PREFIX__metachar:sym<{ }>"
    $P1655."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P1656)
    get_how $P1657, type_obj
    .const 'Sub' $P1658 = "382_1296306519.49046" 
    $P1657."add_method"(type_obj, "metachar:sym<nqpvar>", $P1658)
    get_how $P1659, type_obj
    get_global $P1660, "!PREFIX__metachar:sym<nqpvar>"
    $P1659."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P1660)
    get_how $P1661, type_obj
    .const 'Sub' $P1662 = "385_1296306519.49046" 
    $P1661."add_method"(type_obj, "assertion:sym<{ }>", $P1662)
    get_how $P1663, type_obj
    get_global $P1664, "!PREFIX__assertion:sym<{ }>"
    $P1663."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P1664)
    get_how $P1665, type_obj
    .const 'Sub' $P1666 = "387_1296306519.49046" 
    $P1665."add_method"(type_obj, "assertion:sym<?{ }>", $P1666)
    get_how $P1667, type_obj
    get_global $P1668, "!PREFIX__assertion:sym<?{ }>"
    $P1667."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P1668)
    get_how $P1669, type_obj
    .const 'Sub' $P1670 = "390_1296306519.49046" 
    $P1669."add_method"(type_obj, "assertion:sym<name>", $P1670)
    get_how $P1671, type_obj
    get_global $P1672, "!PREFIX__assertion:sym<name>"
    $P1671."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P1672)
    get_how $P1673, type_obj
    .const 'Sub' $P1674 = "393_1296306519.49046" 
    $P1673."add_method"(type_obj, "assertion:sym<var>", $P1674)
    get_how $P1675, type_obj
    get_global $P1676, "!PREFIX__assertion:sym<var>"
    $P1675."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P1676)
    get_how $P1677, type_obj
    .const 'Sub' $P1678 = "395_1296306519.49046" 
    $P1677."add_method"(type_obj, "codeblock", $P1678)
    get_how $P1679, type_obj
    get_global $P1680, "!PREFIX__codeblock"
    $P1679."add_method"(type_obj, "!PREFIX__codeblock", $P1680)
    get_how $P1681, type_obj
    get_hll_global $P1682, ["Regex";"P6Regex"], "Grammar"
    $P1681."add_parent"(type_obj, $P1682)
    get_how $P1683, type_obj
    $P1684 = $P1683."compose"(type_obj)
    .return ($P1684)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("377_1296306519.49046") :method :outer("376_1296306519.49046")
.annotate 'line', 651
    .const 'Sub' $P1590 = "379_1296306519.49046" 
    capture_lex $P1590
    .local string rx1585_tgt
    .local int rx1585_pos
    .local int rx1585_off
    .local int rx1585_eos
    .local int rx1585_rep
    .local pmc rx1585_cur
    .local pmc rx1585_debug
    (rx1585_cur, rx1585_pos, rx1585_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1585_cur
    .local pmc match
    .lex "$/", match
    length rx1585_eos, rx1585_tgt
    gt rx1585_pos, rx1585_eos, rx1585_done
    set rx1585_off, 0
    lt rx1585_pos, 2, rx1585_start
    sub rx1585_off, rx1585_pos, 1
    substr rx1585_tgt, rx1585_tgt, rx1585_off
  rx1585_start:
    eq $I10, 1, rx1585_restart
    if_null rx1585_debug, debug_1120
    rx1585_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1120:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1585_pos) = rx1585_cur."from"()
    inc rx1585_pos
    rx1585_cur."!cursor_from"(rx1585_pos)
    ge rx1585_pos, rx1585_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1585_cur."!mark_push"(0, rx1585_pos, $I10)
  rxscan1588_done:
.annotate 'line', 653
  # rx literal  ":"
    add $I11, rx1585_pos, 1
    gt $I11, rx1585_eos, rx1585_fail
    sub $I11, rx1585_pos, rx1585_off
    ord $I11, rx1585_tgt, $I11
    ne $I11, 58, rx1585_fail
    add rx1585_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1585_cur."!cursor_pos"(rx1585_pos)
    .const 'Sub' $P1590 = "379_1296306519.49046" 
    capture_lex $P1590
    $P10 = rx1585_cur."before"($P1590)
    unless $P10, rx1585_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1585_cur."!cursor_pos"(rx1585_pos)
    $P10 = rx1585_cur."LANG"("MAIN", "statement")
    unless $P10, rx1585_fail
    rx1585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1585_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1585_cur."!cursor_pos"(rx1585_pos)
    $P10 = rx1585_cur."ws"()
    unless $P10, rx1585_fail
    rx1585_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1585_pos, 1
    gt $I11, rx1585_eos, rx1585_fail
    sub $I11, rx1585_pos, rx1585_off
    ord $I11, rx1585_tgt, $I11
    ne $I11, 59, rx1585_fail
    add rx1585_pos, 1
.annotate 'line', 652
  # rx pass
    rx1585_cur."!cursor_pass"(rx1585_pos, "metachar:sym<:my>")
    if_null rx1585_debug, debug_1125
    rx1585_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1585_pos)
  debug_1125:
    .return (rx1585_cur)
  rx1585_restart:
.annotate 'line', 651
    if_null rx1585_debug, debug_1126
    rx1585_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1126:
  rx1585_fail:
    (rx1585_rep, rx1585_pos, $I10, $P10) = rx1585_cur."!mark_fail"(0)
    lt rx1585_pos, -1, rx1585_done
    eq rx1585_pos, -1, rx1585_fail
    jump $I10
  rx1585_done:
    rx1585_cur."!cursor_fail"()
    if_null rx1585_debug, debug_1127
    rx1585_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1127:
    .return (rx1585_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("378_1296306519.49046") :method
.annotate 'line', 651
    new $P1587, "ResizablePMCArray"
    push $P1587, ":"
    .return ($P1587)
.end


.namespace ["NQP";"Regex"]
.sub "_block1589"  :anon :subid("379_1296306519.49046") :method :outer("377_1296306519.49046")
.annotate 'line', 653
    .local string rx1591_tgt
    .local int rx1591_pos
    .local int rx1591_off
    .local int rx1591_eos
    .local int rx1591_rep
    .local pmc rx1591_cur
    .local pmc rx1591_debug
    (rx1591_cur, rx1591_pos, rx1591_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1591_cur
    .local pmc match
    .lex "$/", match
    length rx1591_eos, rx1591_tgt
    gt rx1591_pos, rx1591_eos, rx1591_done
    set rx1591_off, 0
    lt rx1591_pos, 2, rx1591_start
    sub rx1591_off, rx1591_pos, 1
    substr rx1591_tgt, rx1591_tgt, rx1591_off
  rx1591_start:
    eq $I10, 1, rx1591_restart
    if_null rx1591_debug, debug_1121
    rx1591_cur."!cursor_debug"("START", "")
  debug_1121:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1592_done
    goto rxscan1592_scan
  rxscan1592_loop:
    (rx1591_pos) = rx1591_cur."from"()
    inc rx1591_pos
    rx1591_cur."!cursor_from"(rx1591_pos)
    ge rx1591_pos, rx1591_eos, rxscan1592_done
  rxscan1592_scan:
    set_addr $I10, rxscan1592_loop
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxscan1592_done:
  # rx literal  "my"
    add $I11, rx1591_pos, 2
    gt $I11, rx1591_eos, rx1591_fail
    sub $I11, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I11, 2
    ne $S10, "my", rx1591_fail
    add rx1591_pos, 2
  # rx pass
    rx1591_cur."!cursor_pass"(rx1591_pos, "")
    if_null rx1591_debug, debug_1122
    rx1591_cur."!cursor_debug"("PASS", "", " at pos=", rx1591_pos)
  debug_1122:
    .return (rx1591_cur)
  rx1591_restart:
    if_null rx1591_debug, debug_1123
    rx1591_cur."!cursor_debug"("NEXT", "")
  debug_1123:
  rx1591_fail:
    (rx1591_rep, rx1591_pos, $I10, $P10) = rx1591_cur."!mark_fail"(0)
    lt rx1591_pos, -1, rx1591_done
    eq rx1591_pos, -1, rx1591_fail
    jump $I10
  rx1591_done:
    rx1591_cur."!cursor_fail"()
    if_null rx1591_debug, debug_1124
    rx1591_cur."!cursor_debug"("FAIL", "")
  debug_1124:
    .return (rx1591_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("380_1296306519.49046") :method :outer("376_1296306519.49046")
.annotate 'line', 651
    .local string rx1594_tgt
    .local int rx1594_pos
    .local int rx1594_off
    .local int rx1594_eos
    .local int rx1594_rep
    .local pmc rx1594_cur
    .local pmc rx1594_debug
    (rx1594_cur, rx1594_pos, rx1594_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1594_cur
    .local pmc match
    .lex "$/", match
    length rx1594_eos, rx1594_tgt
    gt rx1594_pos, rx1594_eos, rx1594_done
    set rx1594_off, 0
    lt rx1594_pos, 2, rx1594_start
    sub rx1594_off, rx1594_pos, 1
    substr rx1594_tgt, rx1594_tgt, rx1594_off
  rx1594_start:
    eq $I10, 1, rx1594_restart
    if_null rx1594_debug, debug_1128
    rx1594_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1128:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1597_done
    goto rxscan1597_scan
  rxscan1597_loop:
    (rx1594_pos) = rx1594_cur."from"()
    inc rx1594_pos
    rx1594_cur."!cursor_from"(rx1594_pos)
    ge rx1594_pos, rx1594_eos, rxscan1597_done
  rxscan1597_scan:
    set_addr $I10, rxscan1597_loop
    rx1594_cur."!mark_push"(0, rx1594_pos, $I10)
  rxscan1597_done:
.annotate 'line', 657
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1594_pos, rx1594_off
    substr $S10, rx1594_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1594_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1594_cur."!cursor_pos"(rx1594_pos)
    $P10 = rx1594_cur."codeblock"()
    unless $P10, rx1594_fail
    rx1594_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1594_pos = $P10."pos"()
.annotate 'line', 656
  # rx pass
    rx1594_cur."!cursor_pass"(rx1594_pos, "metachar:sym<{ }>")
    if_null rx1594_debug, debug_1129
    rx1594_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1594_pos)
  debug_1129:
    .return (rx1594_cur)
  rx1594_restart:
.annotate 'line', 651
    if_null rx1594_debug, debug_1130
    rx1594_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1130:
  rx1594_fail:
    (rx1594_rep, rx1594_pos, $I10, $P10) = rx1594_cur."!mark_fail"(0)
    lt rx1594_pos, -1, rx1594_done
    eq rx1594_pos, -1, rx1594_fail
    jump $I10
  rx1594_done:
    rx1594_cur."!cursor_fail"()
    if_null rx1594_debug, debug_1131
    rx1594_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1131:
    .return (rx1594_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("381_1296306519.49046") :method
.annotate 'line', 651
    new $P1596, "ResizablePMCArray"
    push $P1596, "{"
    .return ($P1596)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("382_1296306519.49046") :method :outer("376_1296306519.49046")
.annotate 'line', 651
    .const 'Sub' $P1604 = "384_1296306519.49046" 
    capture_lex $P1604
    .local string rx1599_tgt
    .local int rx1599_pos
    .local int rx1599_off
    .local int rx1599_eos
    .local int rx1599_rep
    .local pmc rx1599_cur
    .local pmc rx1599_debug
    (rx1599_cur, rx1599_pos, rx1599_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1599_cur
    .local pmc match
    .lex "$/", match
    length rx1599_eos, rx1599_tgt
    gt rx1599_pos, rx1599_eos, rx1599_done
    set rx1599_off, 0
    lt rx1599_pos, 2, rx1599_start
    sub rx1599_off, rx1599_pos, 1
    substr rx1599_tgt, rx1599_tgt, rx1599_off
  rx1599_start:
    eq $I10, 1, rx1599_restart
    if_null rx1599_debug, debug_1132
    rx1599_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1132:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1602_done
    goto rxscan1602_scan
  rxscan1602_loop:
    (rx1599_pos) = rx1599_cur."from"()
    inc rx1599_pos
    rx1599_cur."!cursor_from"(rx1599_pos)
    ge rx1599_pos, rx1599_eos, rxscan1602_done
  rxscan1602_scan:
    set_addr $I10, rxscan1602_loop
    rx1599_cur."!mark_push"(0, rx1599_pos, $I10)
  rxscan1602_done:
.annotate 'line', 661
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1599_pos, rx1599_off
    substr $S10, rx1599_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1599_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1599_cur."!cursor_pos"(rx1599_pos)
    .const 'Sub' $P1604 = "384_1296306519.49046" 
    capture_lex $P1604
    $P10 = rx1599_cur."before"($P1604)
    unless $P10, rx1599_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1599_cur."!cursor_pos"(rx1599_pos)
    $P10 = rx1599_cur."LANG"("MAIN", "variable")
    unless $P10, rx1599_fail
    rx1599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1599_pos = $P10."pos"()
.annotate 'line', 660
  # rx pass
    rx1599_cur."!cursor_pass"(rx1599_pos, "metachar:sym<nqpvar>")
    if_null rx1599_debug, debug_1137
    rx1599_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1599_pos)
  debug_1137:
    .return (rx1599_cur)
  rx1599_restart:
.annotate 'line', 651
    if_null rx1599_debug, debug_1138
    rx1599_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1138:
  rx1599_fail:
    (rx1599_rep, rx1599_pos, $I10, $P10) = rx1599_cur."!mark_fail"(0)
    lt rx1599_pos, -1, rx1599_done
    eq rx1599_pos, -1, rx1599_fail
    jump $I10
  rx1599_done:
    rx1599_cur."!cursor_fail"()
    if_null rx1599_debug, debug_1139
    rx1599_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1139:
    .return (rx1599_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("383_1296306519.49046") :method
.annotate 'line', 651
    new $P1601, "ResizablePMCArray"
    push $P1601, "$"
    push $P1601, "@"
    .return ($P1601)
.end


.namespace ["NQP";"Regex"]
.sub "_block1603"  :anon :subid("384_1296306519.49046") :method :outer("382_1296306519.49046")
.annotate 'line', 661
    .local string rx1605_tgt
    .local int rx1605_pos
    .local int rx1605_off
    .local int rx1605_eos
    .local int rx1605_rep
    .local pmc rx1605_cur
    .local pmc rx1605_debug
    (rx1605_cur, rx1605_pos, rx1605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1605_cur
    .local pmc match
    .lex "$/", match
    length rx1605_eos, rx1605_tgt
    gt rx1605_pos, rx1605_eos, rx1605_done
    set rx1605_off, 0
    lt rx1605_pos, 2, rx1605_start
    sub rx1605_off, rx1605_pos, 1
    substr rx1605_tgt, rx1605_tgt, rx1605_off
  rx1605_start:
    eq $I10, 1, rx1605_restart
    if_null rx1605_debug, debug_1133
    rx1605_cur."!cursor_debug"("START", "")
  debug_1133:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1606_done
    goto rxscan1606_scan
  rxscan1606_loop:
    (rx1605_pos) = rx1605_cur."from"()
    inc rx1605_pos
    rx1605_cur."!cursor_from"(rx1605_pos)
    ge rx1605_pos, rx1605_eos, rxscan1606_done
  rxscan1606_scan:
    set_addr $I10, rxscan1606_loop
    rx1605_cur."!mark_push"(0, rx1605_pos, $I10)
  rxscan1606_done:
  # rx charclass .
    ge rx1605_pos, rx1605_eos, rx1605_fail
    inc rx1605_pos
  # rx charclass w
    ge rx1605_pos, rx1605_eos, rx1605_fail
    sub $I10, rx1605_pos, rx1605_off
    is_cclass $I11, 8192, rx1605_tgt, $I10
    unless $I11, rx1605_fail
    inc rx1605_pos
  # rx pass
    rx1605_cur."!cursor_pass"(rx1605_pos, "")
    if_null rx1605_debug, debug_1134
    rx1605_cur."!cursor_debug"("PASS", "", " at pos=", rx1605_pos)
  debug_1134:
    .return (rx1605_cur)
  rx1605_restart:
    if_null rx1605_debug, debug_1135
    rx1605_cur."!cursor_debug"("NEXT", "")
  debug_1135:
  rx1605_fail:
    (rx1605_rep, rx1605_pos, $I10, $P10) = rx1605_cur."!mark_fail"(0)
    lt rx1605_pos, -1, rx1605_done
    eq rx1605_pos, -1, rx1605_fail
    jump $I10
  rx1605_done:
    rx1605_cur."!cursor_fail"()
    if_null rx1605_debug, debug_1136
    rx1605_cur."!cursor_debug"("FAIL", "")
  debug_1136:
    .return (rx1605_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("385_1296306519.49046") :method :outer("376_1296306519.49046")
.annotate 'line', 651
    .local string rx1608_tgt
    .local int rx1608_pos
    .local int rx1608_off
    .local int rx1608_eos
    .local int rx1608_rep
    .local pmc rx1608_cur
    .local pmc rx1608_debug
    (rx1608_cur, rx1608_pos, rx1608_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1608_cur
    .local pmc match
    .lex "$/", match
    length rx1608_eos, rx1608_tgt
    gt rx1608_pos, rx1608_eos, rx1608_done
    set rx1608_off, 0
    lt rx1608_pos, 2, rx1608_start
    sub rx1608_off, rx1608_pos, 1
    substr rx1608_tgt, rx1608_tgt, rx1608_off
  rx1608_start:
    eq $I10, 1, rx1608_restart
    if_null rx1608_debug, debug_1140
    rx1608_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1611_done
    goto rxscan1611_scan
  rxscan1611_loop:
    (rx1608_pos) = rx1608_cur."from"()
    inc rx1608_pos
    rx1608_cur."!cursor_from"(rx1608_pos)
    ge rx1608_pos, rx1608_eos, rxscan1611_done
  rxscan1611_scan:
    set_addr $I10, rxscan1611_loop
    rx1608_cur."!mark_push"(0, rx1608_pos, $I10)
  rxscan1611_done:
.annotate 'line', 665
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1608_pos, rx1608_off
    substr $S10, rx1608_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1608_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1608_cur."!cursor_pos"(rx1608_pos)
    $P10 = rx1608_cur."codeblock"()
    unless $P10, rx1608_fail
    rx1608_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1608_pos = $P10."pos"()
.annotate 'line', 664
  # rx pass
    rx1608_cur."!cursor_pass"(rx1608_pos, "assertion:sym<{ }>")
    if_null rx1608_debug, debug_1141
    rx1608_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1608_pos)
  debug_1141:
    .return (rx1608_cur)
  rx1608_restart:
.annotate 'line', 651
    if_null rx1608_debug, debug_1142
    rx1608_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1142:
  rx1608_fail:
    (rx1608_rep, rx1608_pos, $I10, $P10) = rx1608_cur."!mark_fail"(0)
    lt rx1608_pos, -1, rx1608_done
    eq rx1608_pos, -1, rx1608_fail
    jump $I10
  rx1608_done:
    rx1608_cur."!cursor_fail"()
    if_null rx1608_debug, debug_1143
    rx1608_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1143:
    .return (rx1608_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("386_1296306519.49046") :method
.annotate 'line', 651
    new $P1610, "ResizablePMCArray"
    push $P1610, "{"
    .return ($P1610)
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("387_1296306519.49046") :method :outer("376_1296306519.49046")
.annotate 'line', 651
    .const 'Sub' $P1618 = "389_1296306519.49046" 
    capture_lex $P1618
    .local string rx1613_tgt
    .local int rx1613_pos
    .local int rx1613_off
    .local int rx1613_eos
    .local int rx1613_rep
    .local pmc rx1613_cur
    .local pmc rx1613_debug
    (rx1613_cur, rx1613_pos, rx1613_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1613_cur
    .local pmc match
    .lex "$/", match
    length rx1613_eos, rx1613_tgt
    gt rx1613_pos, rx1613_eos, rx1613_done
    set rx1613_off, 0
    lt rx1613_pos, 2, rx1613_start
    sub rx1613_off, rx1613_pos, 1
    substr rx1613_tgt, rx1613_tgt, rx1613_off
  rx1613_start:
    eq $I10, 1, rx1613_restart
    if_null rx1613_debug, debug_1144
    rx1613_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1144:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1616_done
    goto rxscan1616_scan
  rxscan1616_loop:
    (rx1613_pos) = rx1613_cur."from"()
    inc rx1613_pos
    rx1613_cur."!cursor_from"(rx1613_pos)
    ge rx1613_pos, rx1613_eos, rxscan1616_done
  rxscan1616_scan:
    set_addr $I10, rxscan1616_loop
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  rxscan1616_done:
.annotate 'line', 669
  # rx subcapture "zw"
    set_addr $I10, rxcap_1621_fail
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1613_pos, rx1613_eos, rx1613_fail
    sub $I10, rx1613_pos, rx1613_off
    substr $S10, rx1613_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1613_fail
    inc rx1613_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1613_cur."!cursor_pos"(rx1613_pos)
    .const 'Sub' $P1618 = "389_1296306519.49046" 
    capture_lex $P1618
    $P10 = rx1613_cur."before"($P1618)
    unless $P10, rx1613_fail
    set_addr $I10, rxcap_1621_fail
    ($I12, $I11) = rx1613_cur."!mark_peek"($I10)
    rx1613_cur."!cursor_pos"($I11)
    ($P10) = rx1613_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1613_pos, "")
    rx1613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1621_done
  rxcap_1621_fail:
    goto rx1613_fail
  rxcap_1621_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1613_cur."!cursor_pos"(rx1613_pos)
    $P10 = rx1613_cur."codeblock"()
    unless $P10, rx1613_fail
    rx1613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1613_pos = $P10."pos"()
.annotate 'line', 668
  # rx pass
    rx1613_cur."!cursor_pass"(rx1613_pos, "assertion:sym<?{ }>")
    if_null rx1613_debug, debug_1149
    rx1613_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1613_pos)
  debug_1149:
    .return (rx1613_cur)
  rx1613_restart:
.annotate 'line', 651
    if_null rx1613_debug, debug_1150
    rx1613_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1150:
  rx1613_fail:
    (rx1613_rep, rx1613_pos, $I10, $P10) = rx1613_cur."!mark_fail"(0)
    lt rx1613_pos, -1, rx1613_done
    eq rx1613_pos, -1, rx1613_fail
    jump $I10
  rx1613_done:
    rx1613_cur."!cursor_fail"()
    if_null rx1613_debug, debug_1151
    rx1613_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1151:
    .return (rx1613_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("388_1296306519.49046") :method
.annotate 'line', 651
    new $P1615, "ResizablePMCArray"
    push $P1615, "!"
    push $P1615, "?"
    .return ($P1615)
.end


.namespace ["NQP";"Regex"]
.sub "_block1617"  :anon :subid("389_1296306519.49046") :method :outer("387_1296306519.49046")
.annotate 'line', 669
    .local string rx1619_tgt
    .local int rx1619_pos
    .local int rx1619_off
    .local int rx1619_eos
    .local int rx1619_rep
    .local pmc rx1619_cur
    .local pmc rx1619_debug
    (rx1619_cur, rx1619_pos, rx1619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1619_cur
    .local pmc match
    .lex "$/", match
    length rx1619_eos, rx1619_tgt
    gt rx1619_pos, rx1619_eos, rx1619_done
    set rx1619_off, 0
    lt rx1619_pos, 2, rx1619_start
    sub rx1619_off, rx1619_pos, 1
    substr rx1619_tgt, rx1619_tgt, rx1619_off
  rx1619_start:
    eq $I10, 1, rx1619_restart
    if_null rx1619_debug, debug_1145
    rx1619_cur."!cursor_debug"("START", "")
  debug_1145:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1620_done
    goto rxscan1620_scan
  rxscan1620_loop:
    (rx1619_pos) = rx1619_cur."from"()
    inc rx1619_pos
    rx1619_cur."!cursor_from"(rx1619_pos)
    ge rx1619_pos, rx1619_eos, rxscan1620_done
  rxscan1620_scan:
    set_addr $I10, rxscan1620_loop
    rx1619_cur."!mark_push"(0, rx1619_pos, $I10)
  rxscan1620_done:
  # rx literal  "{"
    add $I11, rx1619_pos, 1
    gt $I11, rx1619_eos, rx1619_fail
    sub $I11, rx1619_pos, rx1619_off
    ord $I11, rx1619_tgt, $I11
    ne $I11, 123, rx1619_fail
    add rx1619_pos, 1
  # rx pass
    rx1619_cur."!cursor_pass"(rx1619_pos, "")
    if_null rx1619_debug, debug_1146
    rx1619_cur."!cursor_debug"("PASS", "", " at pos=", rx1619_pos)
  debug_1146:
    .return (rx1619_cur)
  rx1619_restart:
    if_null rx1619_debug, debug_1147
    rx1619_cur."!cursor_debug"("NEXT", "")
  debug_1147:
  rx1619_fail:
    (rx1619_rep, rx1619_pos, $I10, $P10) = rx1619_cur."!mark_fail"(0)
    lt rx1619_pos, -1, rx1619_done
    eq rx1619_pos, -1, rx1619_fail
    jump $I10
  rx1619_done:
    rx1619_cur."!cursor_fail"()
    if_null rx1619_debug, debug_1148
    rx1619_cur."!cursor_debug"("FAIL", "")
  debug_1148:
    .return (rx1619_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("390_1296306519.49046") :method :outer("376_1296306519.49046")
.annotate 'line', 651
    .const 'Sub' $P1631 = "392_1296306519.49046" 
    capture_lex $P1631
    .local string rx1623_tgt
    .local int rx1623_pos
    .local int rx1623_off
    .local int rx1623_eos
    .local int rx1623_rep
    .local pmc rx1623_cur
    .local pmc rx1623_debug
    (rx1623_cur, rx1623_pos, rx1623_tgt, $I10) = self."!cursor_start"()
    rx1623_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1623_cur
    .local pmc match
    .lex "$/", match
    length rx1623_eos, rx1623_tgt
    gt rx1623_pos, rx1623_eos, rx1623_done
    set rx1623_off, 0
    lt rx1623_pos, 2, rx1623_start
    sub rx1623_off, rx1623_pos, 1
    substr rx1623_tgt, rx1623_tgt, rx1623_off
  rx1623_start:
    eq $I10, 1, rx1623_restart
    if_null rx1623_debug, debug_1152
    rx1623_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1152:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1627_done
    goto rxscan1627_scan
  rxscan1627_loop:
    (rx1623_pos) = rx1623_cur."from"()
    inc rx1623_pos
    rx1623_cur."!cursor_from"(rx1623_pos)
    ge rx1623_pos, rx1623_eos, rxscan1627_done
  rxscan1627_scan:
    set_addr $I10, rxscan1627_loop
    rx1623_cur."!mark_push"(0, rx1623_pos, $I10)
  rxscan1627_done:
.annotate 'line', 673
  # rx subrule "identifier" subtype=capture negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    $P10 = rx1623_cur."identifier"()
    unless $P10, rx1623_fail
    rx1623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1623_pos = $P10."pos"()
.annotate 'line', 680
  # rx rxquantr1628 ** 0..1
    set_addr $I10, rxquantr1628_done
    rx1623_cur."!mark_push"(0, rx1623_pos, $I10)
  rxquantr1628_loop:
  alt1629_0:
.annotate 'line', 674
    set_addr $I10, alt1629_1
    rx1623_cur."!mark_push"(0, rx1623_pos, $I10)
.annotate 'line', 675
  # rx subrule "before" subtype=zerowidth negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    .const 'Sub' $P1631 = "392_1296306519.49046" 
    capture_lex $P1631
    $P10 = rx1623_cur."before"($P1631)
    unless $P10, rx1623_fail
    goto alt1629_end
  alt1629_1:
    set_addr $I10, alt1629_2
    rx1623_cur."!mark_push"(0, rx1623_pos, $I10)
.annotate 'line', 676
  # rx literal  "="
    add $I11, rx1623_pos, 1
    gt $I11, rx1623_eos, rx1623_fail
    sub $I11, rx1623_pos, rx1623_off
    ord $I11, rx1623_tgt, $I11
    ne $I11, 61, rx1623_fail
    add rx1623_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    $P10 = rx1623_cur."assertion"()
    unless $P10, rx1623_fail
    rx1623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1623_pos = $P10."pos"()
    goto alt1629_end
  alt1629_2:
    set_addr $I10, alt1629_3
    rx1623_cur."!mark_push"(0, rx1623_pos, $I10)
.annotate 'line', 677
  # rx literal  ":"
    add $I11, rx1623_pos, 1
    gt $I11, rx1623_eos, rx1623_fail
    sub $I11, rx1623_pos, rx1623_off
    ord $I11, rx1623_tgt, $I11
    ne $I11, 58, rx1623_fail
    add rx1623_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    $P10 = rx1623_cur."arglist"()
    unless $P10, rx1623_fail
    rx1623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1623_pos = $P10."pos"()
    goto alt1629_end
  alt1629_3:
    set_addr $I10, alt1629_4
    rx1623_cur."!mark_push"(0, rx1623_pos, $I10)
.annotate 'line', 678
  # rx literal  "("
    add $I11, rx1623_pos, 1
    gt $I11, rx1623_eos, rx1623_fail
    sub $I11, rx1623_pos, rx1623_off
    ord $I11, rx1623_tgt, $I11
    ne $I11, 40, rx1623_fail
    add rx1623_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    $P10 = rx1623_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1623_fail
    rx1623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1623_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1623_pos, 1
    gt $I11, rx1623_eos, rx1623_fail
    sub $I11, rx1623_pos, rx1623_off
    ord $I11, rx1623_tgt, $I11
    ne $I11, 41, rx1623_fail
    add rx1623_pos, 1
    goto alt1629_end
  alt1629_4:
.annotate 'line', 679
  # rx subrule "normspace" subtype=method negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    $P10 = rx1623_cur."normspace"()
    unless $P10, rx1623_fail
    rx1623_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    $P10 = rx1623_cur."nibbler"()
    unless $P10, rx1623_fail
    rx1623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1623_pos = $P10."pos"()
  alt1629_end:
.annotate 'line', 680
    set_addr $I10, rxquantr1628_done
    (rx1623_rep) = rx1623_cur."!mark_commit"($I10)
  rxquantr1628_done:
.annotate 'line', 672
  # rx pass
    rx1623_cur."!cursor_pass"(rx1623_pos, "assertion:sym<name>")
    if_null rx1623_debug, debug_1157
    rx1623_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1623_pos)
  debug_1157:
    .return (rx1623_cur)
  rx1623_restart:
.annotate 'line', 651
    if_null rx1623_debug, debug_1158
    rx1623_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1158:
  rx1623_fail:
    (rx1623_rep, rx1623_pos, $I10, $P10) = rx1623_cur."!mark_fail"(0)
    lt rx1623_pos, -1, rx1623_done
    eq rx1623_pos, -1, rx1623_fail
    jump $I10
  rx1623_done:
    rx1623_cur."!cursor_fail"()
    if_null rx1623_debug, debug_1159
    rx1623_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1159:
    .return (rx1623_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("391_1296306519.49046") :method
.annotate 'line', 651
    $P1625 = self."!PREFIX__!subrule"("identifier", "")
    new $P1626, "ResizablePMCArray"
    push $P1626, $P1625
    .return ($P1626)
.end


.namespace ["NQP";"Regex"]
.sub "_block1630"  :anon :subid("392_1296306519.49046") :method :outer("390_1296306519.49046")
.annotate 'line', 675
    .local string rx1632_tgt
    .local int rx1632_pos
    .local int rx1632_off
    .local int rx1632_eos
    .local int rx1632_rep
    .local pmc rx1632_cur
    .local pmc rx1632_debug
    (rx1632_cur, rx1632_pos, rx1632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1632_cur
    .local pmc match
    .lex "$/", match
    length rx1632_eos, rx1632_tgt
    gt rx1632_pos, rx1632_eos, rx1632_done
    set rx1632_off, 0
    lt rx1632_pos, 2, rx1632_start
    sub rx1632_off, rx1632_pos, 1
    substr rx1632_tgt, rx1632_tgt, rx1632_off
  rx1632_start:
    eq $I10, 1, rx1632_restart
    if_null rx1632_debug, debug_1153
    rx1632_cur."!cursor_debug"("START", "")
  debug_1153:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1633_done
    goto rxscan1633_scan
  rxscan1633_loop:
    (rx1632_pos) = rx1632_cur."from"()
    inc rx1632_pos
    rx1632_cur."!cursor_from"(rx1632_pos)
    ge rx1632_pos, rx1632_eos, rxscan1633_done
  rxscan1633_scan:
    set_addr $I10, rxscan1633_loop
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  rxscan1633_done:
  # rx literal  ">"
    add $I11, rx1632_pos, 1
    gt $I11, rx1632_eos, rx1632_fail
    sub $I11, rx1632_pos, rx1632_off
    ord $I11, rx1632_tgt, $I11
    ne $I11, 62, rx1632_fail
    add rx1632_pos, 1
  # rx pass
    rx1632_cur."!cursor_pass"(rx1632_pos, "")
    if_null rx1632_debug, debug_1154
    rx1632_cur."!cursor_debug"("PASS", "", " at pos=", rx1632_pos)
  debug_1154:
    .return (rx1632_cur)
  rx1632_restart:
    if_null rx1632_debug, debug_1155
    rx1632_cur."!cursor_debug"("NEXT", "")
  debug_1155:
  rx1632_fail:
    (rx1632_rep, rx1632_pos, $I10, $P10) = rx1632_cur."!mark_fail"(0)
    lt rx1632_pos, -1, rx1632_done
    eq rx1632_pos, -1, rx1632_fail
    jump $I10
  rx1632_done:
    rx1632_cur."!cursor_fail"()
    if_null rx1632_debug, debug_1156
    rx1632_cur."!cursor_debug"("FAIL", "")
  debug_1156:
    .return (rx1632_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("393_1296306519.49046") :method :outer("376_1296306519.49046")
.annotate 'line', 651
    .local string rx1635_tgt
    .local int rx1635_pos
    .local int rx1635_off
    .local int rx1635_eos
    .local int rx1635_rep
    .local pmc rx1635_cur
    .local pmc rx1635_debug
    (rx1635_cur, rx1635_pos, rx1635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1635_cur
    .local pmc match
    .lex "$/", match
    length rx1635_eos, rx1635_tgt
    gt rx1635_pos, rx1635_eos, rx1635_done
    set rx1635_off, 0
    lt rx1635_pos, 2, rx1635_start
    sub rx1635_off, rx1635_pos, 1
    substr rx1635_tgt, rx1635_tgt, rx1635_off
  rx1635_start:
    eq $I10, 1, rx1635_restart
    if_null rx1635_debug, debug_1160
    rx1635_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1638_done
    goto rxscan1638_scan
  rxscan1638_loop:
    (rx1635_pos) = rx1635_cur."from"()
    inc rx1635_pos
    rx1635_cur."!cursor_from"(rx1635_pos)
    ge rx1635_pos, rx1635_eos, rxscan1638_done
  rxscan1638_scan:
    set_addr $I10, rxscan1638_loop
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  rxscan1638_done:
.annotate 'line', 684
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1635_pos, rx1635_off
    substr $S10, rx1635_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1635_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    $P10 = rx1635_cur."LANG"("MAIN", "variable")
    unless $P10, rx1635_fail
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1635_pos = $P10."pos"()
.annotate 'line', 683
  # rx pass
    rx1635_cur."!cursor_pass"(rx1635_pos, "assertion:sym<var>")
    if_null rx1635_debug, debug_1161
    rx1635_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1635_pos)
  debug_1161:
    .return (rx1635_cur)
  rx1635_restart:
.annotate 'line', 651
    if_null rx1635_debug, debug_1162
    rx1635_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1162:
  rx1635_fail:
    (rx1635_rep, rx1635_pos, $I10, $P10) = rx1635_cur."!mark_fail"(0)
    lt rx1635_pos, -1, rx1635_done
    eq rx1635_pos, -1, rx1635_fail
    jump $I10
  rx1635_done:
    rx1635_cur."!cursor_fail"()
    if_null rx1635_debug, debug_1163
    rx1635_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1163:
    .return (rx1635_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("394_1296306519.49046") :method
.annotate 'line', 651
    new $P1637, "ResizablePMCArray"
    push $P1637, "$"
    push $P1637, "@"
    .return ($P1637)
.end


.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("395_1296306519.49046") :method :outer("376_1296306519.49046")
.annotate 'line', 651
    .local string rx1640_tgt
    .local int rx1640_pos
    .local int rx1640_off
    .local int rx1640_eos
    .local int rx1640_rep
    .local pmc rx1640_cur
    .local pmc rx1640_debug
    (rx1640_cur, rx1640_pos, rx1640_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1640_cur
    .local pmc match
    .lex "$/", match
    length rx1640_eos, rx1640_tgt
    gt rx1640_pos, rx1640_eos, rx1640_done
    set rx1640_off, 0
    lt rx1640_pos, 2, rx1640_start
    sub rx1640_off, rx1640_pos, 1
    substr rx1640_tgt, rx1640_tgt, rx1640_off
  rx1640_start:
    eq $I10, 1, rx1640_restart
    if_null rx1640_debug, debug_1164
    rx1640_cur."!cursor_debug"("START", "codeblock")
  debug_1164:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1644_done
    goto rxscan1644_scan
  rxscan1644_loop:
    (rx1640_pos) = rx1640_cur."from"()
    inc rx1640_pos
    rx1640_cur."!cursor_from"(rx1640_pos)
    ge rx1640_pos, rx1640_eos, rxscan1644_done
  rxscan1644_scan:
    set_addr $I10, rxscan1644_loop
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  rxscan1644_done:
.annotate 'line', 688
  # rx subrule "LANG" subtype=capture negate=
    rx1640_cur."!cursor_pos"(rx1640_pos)
    $P10 = rx1640_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1640_fail
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1640_pos = $P10."pos"()
.annotate 'line', 687
  # rx pass
    rx1640_cur."!cursor_pass"(rx1640_pos, "codeblock")
    if_null rx1640_debug, debug_1165
    rx1640_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1640_pos)
  debug_1165:
    .return (rx1640_cur)
  rx1640_restart:
.annotate 'line', 651
    if_null rx1640_debug, debug_1166
    rx1640_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1166:
  rx1640_fail:
    (rx1640_rep, rx1640_pos, $I10, $P10) = rx1640_cur."!mark_fail"(0)
    lt rx1640_pos, -1, rx1640_done
    eq rx1640_pos, -1, rx1640_fail
    jump $I10
  rx1640_done:
    rx1640_cur."!cursor_fail"()
    if_null rx1640_debug, debug_1167
    rx1640_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1167:
    .return (rx1640_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("396_1296306519.49046") :method
.annotate 'line', 651
    $P1642 = self."!PREFIX__!subrule"("LANG", "")
    new $P1643, "ResizablePMCArray"
    push $P1643, $P1642
    .return ($P1643)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1686" :load :anon :subid("398_1296306519.49046")
.annotate 'line', 4
    .const 'Sub' $P1688 = "11_1296306519.49046" 
    $P1689 = $P1688()
    .return ($P1689)
.end


.namespace []
.sub "_block2403" :load :anon :subid("400_1296306519.49046")
.annotate 'line', 1
    .const 'Sub' $P2405 = "10_1296306519.49046" 
    $P2406 = $P2405()
    .return ($P2406)
.end

### .include 'gen/nqp-actions.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1296306531.71605")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Actions"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
    $P3142 = $P15()
.annotate 'line', 1
    .return ($P3142)
    .const 'Sub' $P3144 = "168_1296306531.71605" 
    .return ($P3144)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block14"  :subid("11_1296306531.71605") :outer("10_1296306531.71605")
.annotate 'line', 3
    .const 'Sub' $P2923 = "167_1296306531.71605" 
    capture_lex $P2923
    get_hll_global $P2797, ["NQP";"RegexActions"], "_block2796" 
    capture_lex $P2797
    .const 'Sub' $P2788 = "156_1296306531.71605" 
    capture_lex $P2788
    .const 'Sub' $P2783 = "155_1296306531.71605" 
    capture_lex $P2783
    .const 'Sub' $P2778 = "154_1296306531.71605" 
    capture_lex $P2778
    .const 'Sub' $P2773 = "153_1296306531.71605" 
    capture_lex $P2773
    .const 'Sub' $P2762 = "152_1296306531.71605" 
    capture_lex $P2762
    .const 'Sub' $P2754 = "151_1296306531.71605" 
    capture_lex $P2754
    .const 'Sub' $P2746 = "150_1296306531.71605" 
    capture_lex $P2746
    .const 'Sub' $P2738 = "149_1296306531.71605" 
    capture_lex $P2738
    .const 'Sub' $P2733 = "148_1296306531.71605" 
    capture_lex $P2733
    .const 'Sub' $P2721 = "147_1296306531.71605" 
    capture_lex $P2721
    .const 'Sub' $P2713 = "146_1296306531.71605" 
    capture_lex $P2713
    .const 'Sub' $P2675 = "145_1296306531.71605" 
    capture_lex $P2675
    .const 'Sub' $P2663 = "144_1296306531.71605" 
    capture_lex $P2663
    .const 'Sub' $P2655 = "143_1296306531.71605" 
    capture_lex $P2655
    .const 'Sub' $P2647 = "142_1296306531.71605" 
    capture_lex $P2647
    .const 'Sub' $P2639 = "141_1296306531.71605" 
    capture_lex $P2639
    .const 'Sub' $P2631 = "140_1296306531.71605" 
    capture_lex $P2631
    .const 'Sub' $P2623 = "139_1296306531.71605" 
    capture_lex $P2623
    .const 'Sub' $P2597 = "138_1296306531.71605" 
    capture_lex $P2597
    .const 'Sub' $P2582 = "137_1296306531.71605" 
    capture_lex $P2582
    .const 'Sub' $P2574 = "136_1296306531.71605" 
    capture_lex $P2574
    .const 'Sub' $P2563 = "135_1296306531.71605" 
    capture_lex $P2563
    .const 'Sub' $P2552 = "134_1296306531.71605" 
    capture_lex $P2552
    .const 'Sub' $P2541 = "133_1296306531.71605" 
    capture_lex $P2541
    .const 'Sub' $P2533 = "132_1296306531.71605" 
    capture_lex $P2533
    .const 'Sub' $P2506 = "131_1296306531.71605" 
    capture_lex $P2506
    .const 'Sub' $P2484 = "130_1296306531.71605" 
    capture_lex $P2484
    .const 'Sub' $P2476 = "129_1296306531.71605" 
    capture_lex $P2476
    .const 'Sub' $P2468 = "128_1296306531.71605" 
    capture_lex $P2468
    .const 'Sub' $P2443 = "127_1296306531.71605" 
    capture_lex $P2443
    .const 'Sub' $P2427 = "126_1296306531.71605" 
    capture_lex $P2427
    .const 'Sub' $P2419 = "125_1296306531.71605" 
    capture_lex $P2419
    .const 'Sub' $P2411 = "124_1296306531.71605" 
    capture_lex $P2411
    .const 'Sub' $P2309 = "121_1296306531.71605" 
    capture_lex $P2309
    .const 'Sub' $P2301 = "120_1296306531.71605" 
    capture_lex $P2301
    .const 'Sub' $P2294 = "119_1296306531.71605" 
    capture_lex $P2294
    .const 'Sub' $P2267 = "118_1296306531.71605" 
    capture_lex $P2267
    .const 'Sub' $P2227 = "117_1296306531.71605" 
    capture_lex $P2227
    .const 'Sub' $P2213 = "116_1296306531.71605" 
    capture_lex $P2213
    .const 'Sub' $P2206 = "115_1296306531.71605" 
    capture_lex $P2206
    .const 'Sub' $P2162 = "114_1296306531.71605" 
    capture_lex $P2162
    .const 'Sub' $P1997 = "110_1296306531.71605" 
    capture_lex $P1997
    .const 'Sub' $P1957 = "108_1296306531.71605" 
    capture_lex $P1957
    .const 'Sub' $P1949 = "107_1296306531.71605" 
    capture_lex $P1949
    .const 'Sub' $P1934 = "106_1296306531.71605" 
    capture_lex $P1934
    .const 'Sub' $P1919 = "105_1296306531.71605" 
    capture_lex $P1919
    .const 'Sub' $P1901 = "104_1296306531.71605" 
    capture_lex $P1901
    .const 'Sub' $P1802 = "103_1296306531.71605" 
    capture_lex $P1802
    .const 'Sub' $P1758 = "100_1296306531.71605" 
    capture_lex $P1758
    .const 'Sub' $P1633 = "97_1296306531.71605" 
    capture_lex $P1633
    .const 'Sub' $P1391 = "90_1296306531.71605" 
    capture_lex $P1391
    .const 'Sub' $P1383 = "89_1296306531.71605" 
    capture_lex $P1383
    .const 'Sub' $P1375 = "88_1296306531.71605" 
    capture_lex $P1375
    .const 'Sub' $P1274 = "84_1296306531.71605" 
    capture_lex $P1274
    .const 'Sub' $P1266 = "83_1296306531.71605" 
    capture_lex $P1266
    .const 'Sub' $P1251 = "82_1296306531.71605" 
    capture_lex $P1251
    .const 'Sub' $P1236 = "81_1296306531.71605" 
    capture_lex $P1236
    .const 'Sub' $P1221 = "80_1296306531.71605" 
    capture_lex $P1221
    .const 'Sub' $P1206 = "79_1296306531.71605" 
    capture_lex $P1206
    .const 'Sub' $P1198 = "78_1296306531.71605" 
    capture_lex $P1198
    .const 'Sub' $P1190 = "77_1296306531.71605" 
    capture_lex $P1190
    .const 'Sub' $P1182 = "76_1296306531.71605" 
    capture_lex $P1182
    .const 'Sub' $P1160 = "75_1296306531.71605" 
    capture_lex $P1160
    .const 'Sub' $P1152 = "74_1296306531.71605" 
    capture_lex $P1152
    .const 'Sub' $P1145 = "73_1296306531.71605" 
    capture_lex $P1145
    .const 'Sub' $P1138 = "72_1296306531.71605" 
    capture_lex $P1138
    .const 'Sub' $P1131 = "71_1296306531.71605" 
    capture_lex $P1131
    .const 'Sub' $P1124 = "70_1296306531.71605" 
    capture_lex $P1124
    .const 'Sub' $P1116 = "69_1296306531.71605" 
    capture_lex $P1116
    .const 'Sub' $P1026 = "67_1296306531.71605" 
    capture_lex $P1026
    .const 'Sub' $P1002 = "66_1296306531.71605" 
    capture_lex $P1002
    .const 'Sub' $P988 = "65_1296306531.71605" 
    capture_lex $P988
    .const 'Sub' $P980 = "64_1296306531.71605" 
    capture_lex $P980
    .const 'Sub' $P972 = "63_1296306531.71605" 
    capture_lex $P972
    .const 'Sub' $P964 = "62_1296306531.71605" 
    capture_lex $P964
    .const 'Sub' $P956 = "61_1296306531.71605" 
    capture_lex $P956
    .const 'Sub' $P948 = "60_1296306531.71605" 
    capture_lex $P948
    .const 'Sub' $P940 = "59_1296306531.71605" 
    capture_lex $P940
    .const 'Sub' $P932 = "58_1296306531.71605" 
    capture_lex $P932
    .const 'Sub' $P924 = "57_1296306531.71605" 
    capture_lex $P924
    .const 'Sub' $P916 = "56_1296306531.71605" 
    capture_lex $P916
    .const 'Sub' $P908 = "55_1296306531.71605" 
    capture_lex $P908
    .const 'Sub' $P900 = "54_1296306531.71605" 
    capture_lex $P900
    .const 'Sub' $P892 = "53_1296306531.71605" 
    capture_lex $P892
    .const 'Sub' $P884 = "52_1296306531.71605" 
    capture_lex $P884
    .const 'Sub' $P868 = "51_1296306531.71605" 
    capture_lex $P868
    .const 'Sub' $P835 = "50_1296306531.71605" 
    capture_lex $P835
    .const 'Sub' $P821 = "49_1296306531.71605" 
    capture_lex $P821
    .const 'Sub' $P802 = "48_1296306531.71605" 
    capture_lex $P802
    .const 'Sub' $P784 = "47_1296306531.71605" 
    capture_lex $P784
    .const 'Sub' $P760 = "46_1296306531.71605" 
    capture_lex $P760
    .const 'Sub' $P726 = "45_1296306531.71605" 
    capture_lex $P726
    .const 'Sub' $P711 = "44_1296306531.71605" 
    capture_lex $P711
    .const 'Sub' $P699 = "43_1296306531.71605" 
    capture_lex $P699
    .const 'Sub' $P648 = "41_1296306531.71605" 
    capture_lex $P648
    .const 'Sub' $P639 = "40_1296306531.71605" 
    capture_lex $P639
    .const 'Sub' $P628 = "39_1296306531.71605" 
    capture_lex $P628
    .const 'Sub' $P610 = "38_1296306531.71605" 
    capture_lex $P610
    .const 'Sub' $P602 = "37_1296306531.71605" 
    capture_lex $P602
    .const 'Sub' $P594 = "36_1296306531.71605" 
    capture_lex $P594
    .const 'Sub' $P580 = "35_1296306531.71605" 
    capture_lex $P580
    .const 'Sub' $P499 = "33_1296306531.71605" 
    capture_lex $P499
    .const 'Sub' $P458 = "31_1296306531.71605" 
    capture_lex $P458
    .const 'Sub' $P424 = "30_1296306531.71605" 
    capture_lex $P424
    .const 'Sub' $P393 = "29_1296306531.71605" 
    capture_lex $P393
    .const 'Sub' $P385 = "28_1296306531.71605" 
    capture_lex $P385
    .const 'Sub' $P377 = "26_1296306531.71605" 
    capture_lex $P377
    .const 'Sub' $P363 = "25_1296306531.71605" 
    capture_lex $P363
    .const 'Sub' $P298 = "23_1296306531.71605" 
    capture_lex $P298
    .const 'Sub' $P288 = "22_1296306531.71605" 
    capture_lex $P288
    .const 'Sub' $P139 = "19_1296306531.71605" 
    capture_lex $P139
    .const 'Sub' $P91 = "18_1296306531.71605" 
    capture_lex $P91
    .const 'Sub' $P78 = "17_1296306531.71605" 
    capture_lex $P78
    .const 'Sub' $P60 = "16_1296306531.71605" 
    capture_lex $P60
    .const 'Sub' $P27 = "13_1296306531.71605" 
    capture_lex $P27
    .const 'Sub' $P19 = "12_1296306531.71605" 
    capture_lex $P19
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "RegexActions"
    get_global $P18, "@BLOCK"
    unless_null $P18, vivify_170
    $P18 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P18
  vivify_170:
.annotate 'line', 9
    .const 'Sub' $P19 = "12_1296306531.71605" 
    newclosure $P26, $P19
    .lex "xblock_immediate", $P26
.annotate 'line', 14
    .const 'Sub' $P27 = "13_1296306531.71605" 
    newclosure $P59, $P27
    .lex "block_immediate", $P59
.annotate 'line', 24
    .const 'Sub' $P60 = "16_1296306531.71605" 
    newclosure $P77, $P60
    .lex "vivitype", $P77
.annotate 'line', 43
    .const 'Sub' $P78 = "17_1296306531.71605" 
    newclosure $P90, $P78
    .lex "colonpair_str", $P90
.annotate 'line', 223
    .const 'Sub' $P91 = "18_1296306531.71605" 
    newclosure $P138, $P91
    .lex "push_block_handler", $P138
.annotate 'line', 375
    .const 'Sub' $P139 = "19_1296306531.71605" 
    newclosure $P287, $P139
    .lex "package", $P287
.annotate 'line', 733
    .const 'Sub' $P288 = "22_1296306531.71605" 
    newclosure $P297, $P288
    .lex "only_star_block", $P297
.annotate 'line', 742
    .const 'Sub' $P298 = "23_1296306531.71605" 
    newclosure $P362, $P298
    .lex "attach_multi_signature", $P362
.annotate 'line', 1194
    .const 'Sub' $P363 = "25_1296306531.71605" 
    newclosure $P374, $P363
    .lex "control", $P374
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P375, "@BLOCK"
    .const 'Sub' $P377 = "26_1296306531.71605" 
    capture_lex $P377
    $P377()
    find_lex $P382, "xblock_immediate"
    find_lex $P383, "block_immediate"
    find_lex $P384, "vivitype"
.annotate 'line', 35
    find_lex $P423, "colonpair_str"
.annotate 'line', 216
    find_lex $P820, "push_block_handler"
.annotate 'line', 373
    find_lex $P1159, "package"
.annotate 'line', 660
    find_lex $P1756, "only_star_block"
    find_lex $P1757, "attach_multi_signature"
.annotate 'line', 1185
    find_lex $P2772, "control"
.annotate 'line', 1212
    get_hll_global $P2797, ["NQP";"RegexActions"], "_block2796" 
    capture_lex $P2797
    $P2917 = $P2797()
.annotate 'line', 3
    .return ($P2917)
    .const 'Sub' $P2919 = "166_1296306531.71605" 
    .return ($P2919)
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post169") :outer("11_1296306531.71605")
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P2923 = "167_1296306531.71605" 
    capture_lex $P2923
    $P2923()
.end


.namespace ["NQP";"Actions"]
.sub "_block2922"  :anon :subid("167_1296306531.71605") :outer("11_1296306531.71605")
.annotate 'line', 3
    get_hll_global $P2924, "NQPClassHOW"
    $P2925 = $P2924."new_type"("Actions" :named("name"))
    .local pmc type_obj
    set type_obj, $P2925
    set_hll_global ["NQP"], "Actions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2926, type_obj
    .const 'Sub' $P2927 = "28_1296306531.71605" 
    $P2926."add_method"(type_obj, "TOP", $P2927)
    get_how $P2928, type_obj
    .const 'Sub' $P2929 = "29_1296306531.71605" 
    $P2928."add_method"(type_obj, "deflongname", $P2929)
    get_how $P2930, type_obj
    .const 'Sub' $P2931 = "30_1296306531.71605" 
    $P2930."add_method"(type_obj, "comp_unit", $P2931)
    get_how $P2932, type_obj
    .const 'Sub' $P2933 = "31_1296306531.71605" 
    $P2932."add_method"(type_obj, "statementlist", $P2933)
    get_how $P2934, type_obj
    .const 'Sub' $P2935 = "33_1296306531.71605" 
    $P2934."add_method"(type_obj, "statement", $P2935)
    get_how $P2936, type_obj
    .const 'Sub' $P2937 = "35_1296306531.71605" 
    $P2936."add_method"(type_obj, "xblock", $P2937)
    get_how $P2938, type_obj
    .const 'Sub' $P2939 = "36_1296306531.71605" 
    $P2938."add_method"(type_obj, "pblock", $P2939)
    get_how $P2940, type_obj
    .const 'Sub' $P2941 = "37_1296306531.71605" 
    $P2940."add_method"(type_obj, "block", $P2941)
    get_how $P2942, type_obj
    .const 'Sub' $P2943 = "38_1296306531.71605" 
    $P2942."add_method"(type_obj, "blockoid", $P2943)
    get_how $P2944, type_obj
    .const 'Sub' $P2945 = "39_1296306531.71605" 
    $P2944."add_method"(type_obj, "newpad", $P2945)
    get_how $P2946, type_obj
    .const 'Sub' $P2947 = "40_1296306531.71605" 
    $P2946."add_method"(type_obj, "outerctx", $P2947)
    get_how $P2948, type_obj
    .const 'Sub' $P2949 = "41_1296306531.71605" 
    $P2948."add_method"(type_obj, "statement_control:sym<if>", $P2949)
    get_how $P2950, type_obj
    .const 'Sub' $P2951 = "43_1296306531.71605" 
    $P2950."add_method"(type_obj, "statement_control:sym<unless>", $P2951)
    get_how $P2952, type_obj
    .const 'Sub' $P2953 = "44_1296306531.71605" 
    $P2952."add_method"(type_obj, "statement_control:sym<while>", $P2953)
    get_how $P2954, type_obj
    .const 'Sub' $P2955 = "45_1296306531.71605" 
    $P2954."add_method"(type_obj, "statement_control:sym<repeat>", $P2955)
    get_how $P2956, type_obj
    .const 'Sub' $P2957 = "46_1296306531.71605" 
    $P2956."add_method"(type_obj, "statement_control:sym<for>", $P2957)
    get_how $P2958, type_obj
    .const 'Sub' $P2959 = "47_1296306531.71605" 
    $P2958."add_method"(type_obj, "statement_control:sym<CATCH>", $P2959)
    get_how $P2960, type_obj
    .const 'Sub' $P2961 = "48_1296306531.71605" 
    $P2960."add_method"(type_obj, "statement_control:sym<CONTROL>", $P2961)
    get_how $P2962, type_obj
    .const 'Sub' $P2963 = "49_1296306531.71605" 
    $P2962."add_method"(type_obj, "statement_prefix:sym<INIT>", $P2963)
    get_how $P2964, type_obj
    .const 'Sub' $P2965 = "50_1296306531.71605" 
    $P2964."add_method"(type_obj, "statement_prefix:sym<try>", $P2965)
    get_how $P2966, type_obj
    .const 'Sub' $P2967 = "51_1296306531.71605" 
    $P2966."add_method"(type_obj, "blorst", $P2967)
    get_how $P2968, type_obj
    .const 'Sub' $P2969 = "52_1296306531.71605" 
    $P2968."add_method"(type_obj, "statement_mod_cond:sym<if>", $P2969)
    get_how $P2970, type_obj
    .const 'Sub' $P2971 = "53_1296306531.71605" 
    $P2970."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P2971)
    get_how $P2972, type_obj
    .const 'Sub' $P2973 = "54_1296306531.71605" 
    $P2972."add_method"(type_obj, "statement_mod_loop:sym<while>", $P2973)
    get_how $P2974, type_obj
    .const 'Sub' $P2975 = "55_1296306531.71605" 
    $P2974."add_method"(type_obj, "statement_mod_loop:sym<until>", $P2975)
    get_how $P2976, type_obj
    .const 'Sub' $P2977 = "56_1296306531.71605" 
    $P2976."add_method"(type_obj, "term:sym<fatarrow>", $P2977)
    get_how $P2978, type_obj
    .const 'Sub' $P2979 = "57_1296306531.71605" 
    $P2978."add_method"(type_obj, "term:sym<colonpair>", $P2979)
    get_how $P2980, type_obj
    .const 'Sub' $P2981 = "58_1296306531.71605" 
    $P2980."add_method"(type_obj, "term:sym<variable>", $P2981)
    get_how $P2982, type_obj
    .const 'Sub' $P2983 = "59_1296306531.71605" 
    $P2982."add_method"(type_obj, "term:sym<package_declarator>", $P2983)
    get_how $P2984, type_obj
    .const 'Sub' $P2985 = "60_1296306531.71605" 
    $P2984."add_method"(type_obj, "term:sym<scope_declarator>", $P2985)
    get_how $P2986, type_obj
    .const 'Sub' $P2987 = "61_1296306531.71605" 
    $P2986."add_method"(type_obj, "term:sym<routine_declarator>", $P2987)
    get_how $P2988, type_obj
    .const 'Sub' $P2989 = "62_1296306531.71605" 
    $P2988."add_method"(type_obj, "term:sym<regex_declarator>", $P2989)
    get_how $P2990, type_obj
    .const 'Sub' $P2991 = "63_1296306531.71605" 
    $P2990."add_method"(type_obj, "term:sym<statement_prefix>", $P2991)
    get_how $P2992, type_obj
    .const 'Sub' $P2993 = "64_1296306531.71605" 
    $P2992."add_method"(type_obj, "term:sym<lambda>", $P2993)
    get_how $P2994, type_obj
    .const 'Sub' $P2995 = "65_1296306531.71605" 
    $P2994."add_method"(type_obj, "fatarrow", $P2995)
    get_how $P2996, type_obj
    .const 'Sub' $P2997 = "66_1296306531.71605" 
    $P2996."add_method"(type_obj, "colonpair", $P2997)
    get_how $P2998, type_obj
    .const 'Sub' $P2999 = "67_1296306531.71605" 
    $P2998."add_method"(type_obj, "variable", $P2999)
    get_how $P3000, type_obj
    .const 'Sub' $P3001 = "69_1296306531.71605" 
    $P3000."add_method"(type_obj, "package_declarator:sym<module>", $P3001)
    get_how $P3002, type_obj
    .const 'Sub' $P3003 = "70_1296306531.71605" 
    $P3002."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3003)
    get_how $P3004, type_obj
    .const 'Sub' $P3005 = "71_1296306531.71605" 
    $P3004."add_method"(type_obj, "package_declarator:sym<class>", $P3005)
    get_how $P3006, type_obj
    .const 'Sub' $P3007 = "72_1296306531.71605" 
    $P3006."add_method"(type_obj, "package_declarator:sym<grammar>", $P3007)
    get_how $P3008, type_obj
    .const 'Sub' $P3009 = "73_1296306531.71605" 
    $P3008."add_method"(type_obj, "package_declarator:sym<role>", $P3009)
    get_how $P3010, type_obj
    .const 'Sub' $P3011 = "74_1296306531.71605" 
    $P3010."add_method"(type_obj, "package_declarator:sym<native>", $P3011)
    get_how $P3012, type_obj
    .const 'Sub' $P3013 = "75_1296306531.71605" 
    $P3012."add_method"(type_obj, "package_def", $P3013)
    get_how $P3014, type_obj
    .const 'Sub' $P3015 = "76_1296306531.71605" 
    $P3014."add_method"(type_obj, "scope_declarator:sym<my>", $P3015)
    get_how $P3016, type_obj
    .const 'Sub' $P3017 = "77_1296306531.71605" 
    $P3016."add_method"(type_obj, "scope_declarator:sym<our>", $P3017)
    get_how $P3018, type_obj
    .const 'Sub' $P3019 = "78_1296306531.71605" 
    $P3018."add_method"(type_obj, "scope_declarator:sym<has>", $P3019)
    get_how $P3020, type_obj
    .const 'Sub' $P3021 = "79_1296306531.71605" 
    $P3020."add_method"(type_obj, "scoped", $P3021)
    get_how $P3022, type_obj
    .const 'Sub' $P3023 = "80_1296306531.71605" 
    $P3022."add_method"(type_obj, "declarator", $P3023)
    get_how $P3024, type_obj
    .const 'Sub' $P3025 = "81_1296306531.71605" 
    $P3024."add_method"(type_obj, "multi_declarator:sym<multi>", $P3025)
    get_how $P3026, type_obj
    .const 'Sub' $P3027 = "82_1296306531.71605" 
    $P3026."add_method"(type_obj, "multi_declarator:sym<proto>", $P3027)
    get_how $P3028, type_obj
    .const 'Sub' $P3029 = "83_1296306531.71605" 
    $P3028."add_method"(type_obj, "multi_declarator:sym<null>", $P3029)
    get_how $P3030, type_obj
    .const 'Sub' $P3031 = "84_1296306531.71605" 
    $P3030."add_method"(type_obj, "variable_declarator", $P3031)
    get_how $P3032, type_obj
    .const 'Sub' $P3033 = "88_1296306531.71605" 
    $P3032."add_method"(type_obj, "routine_declarator:sym<sub>", $P3033)
    get_how $P3034, type_obj
    .const 'Sub' $P3035 = "89_1296306531.71605" 
    $P3034."add_method"(type_obj, "routine_declarator:sym<method>", $P3035)
    get_how $P3036, type_obj
    .const 'Sub' $P3037 = "90_1296306531.71605" 
    $P3036."add_method"(type_obj, "routine_def", $P3037)
    get_how $P3038, type_obj
    .const 'Sub' $P3039 = "97_1296306531.71605" 
    $P3038."add_method"(type_obj, "method_def", $P3039)
    get_how $P3040, type_obj
    .const 'Sub' $P3041 = "100_1296306531.71605" 
    $P3040."add_method"(type_obj, "signature", $P3041)
    get_how $P3042, type_obj
    .const 'Sub' $P3043 = "103_1296306531.71605" 
    $P3042."add_method"(type_obj, "parameter", $P3043)
    get_how $P3044, type_obj
    .const 'Sub' $P3045 = "104_1296306531.71605" 
    $P3044."add_method"(type_obj, "param_var", $P3045)
    get_how $P3046, type_obj
    .const 'Sub' $P3047 = "105_1296306531.71605" 
    $P3046."add_method"(type_obj, "named_param", $P3047)
    get_how $P3048, type_obj
    .const 'Sub' $P3049 = "106_1296306531.71605" 
    $P3048."add_method"(type_obj, "typename", $P3049)
    get_how $P3050, type_obj
    .const 'Sub' $P3051 = "107_1296306531.71605" 
    $P3050."add_method"(type_obj, "trait", $P3051)
    get_how $P3052, type_obj
    .const 'Sub' $P3053 = "108_1296306531.71605" 
    $P3052."add_method"(type_obj, "trait_mod:sym<is>", $P3053)
    get_how $P3054, type_obj
    .const 'Sub' $P3055 = "110_1296306531.71605" 
    $P3054."add_method"(type_obj, "regex_declarator", $P3055)
    get_how $P3056, type_obj
    .const 'Sub' $P3057 = "114_1296306531.71605" 
    $P3056."add_method"(type_obj, "dotty", $P3057)
    get_how $P3058, type_obj
    .const 'Sub' $P3059 = "115_1296306531.71605" 
    $P3058."add_method"(type_obj, "term:sym<self>", $P3059)
    get_how $P3060, type_obj
    .const 'Sub' $P3061 = "116_1296306531.71605" 
    $P3060."add_method"(type_obj, "term:sym<identifier>", $P3061)
    get_how $P3062, type_obj
    .const 'Sub' $P3063 = "117_1296306531.71605" 
    $P3062."add_method"(type_obj, "term:sym<name>", $P3063)
    get_how $P3064, type_obj
    .const 'Sub' $P3065 = "118_1296306531.71605" 
    $P3064."add_method"(type_obj, "term:sym<pir::op>", $P3065)
    get_how $P3066, type_obj
    .const 'Sub' $P3067 = "119_1296306531.71605" 
    $P3066."add_method"(type_obj, "term:sym<onlystar>", $P3067)
    get_how $P3068, type_obj
    .const 'Sub' $P3069 = "120_1296306531.71605" 
    $P3068."add_method"(type_obj, "args", $P3069)
    get_how $P3070, type_obj
    .const 'Sub' $P3071 = "121_1296306531.71605" 
    $P3070."add_method"(type_obj, "arglist", $P3071)
    get_how $P3072, type_obj
    .const 'Sub' $P3073 = "124_1296306531.71605" 
    $P3072."add_method"(type_obj, "term:sym<multi_declarator>", $P3073)
    get_how $P3074, type_obj
    .const 'Sub' $P3075 = "125_1296306531.71605" 
    $P3074."add_method"(type_obj, "term:sym<value>", $P3075)
    get_how $P3076, type_obj
    .const 'Sub' $P3077 = "126_1296306531.71605" 
    $P3076."add_method"(type_obj, "circumfix:sym<( )>", $P3077)
    get_how $P3078, type_obj
    .const 'Sub' $P3079 = "127_1296306531.71605" 
    $P3078."add_method"(type_obj, "circumfix:sym<[ ]>", $P3079)
    get_how $P3080, type_obj
    .const 'Sub' $P3081 = "128_1296306531.71605" 
    $P3080."add_method"(type_obj, "circumfix:sym<ang>", $P3081)
    get_how $P3082, type_obj
    .const 'Sub' $P3083 = "129_1296306531.71605" 
    $P3082."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3083)
    get_how $P3084, type_obj
    .const 'Sub' $P3085 = "130_1296306531.71605" 
    $P3084."add_method"(type_obj, "circumfix:sym<{ }>", $P3085)
    get_how $P3086, type_obj
    .const 'Sub' $P3087 = "131_1296306531.71605" 
    $P3086."add_method"(type_obj, "circumfix:sym<sigil>", $P3087)
    get_how $P3088, type_obj
    .const 'Sub' $P3089 = "132_1296306531.71605" 
    $P3088."add_method"(type_obj, "semilist", $P3089)
    get_how $P3090, type_obj
    .const 'Sub' $P3091 = "133_1296306531.71605" 
    $P3090."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3091)
    get_how $P3092, type_obj
    .const 'Sub' $P3093 = "134_1296306531.71605" 
    $P3092."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3093)
    get_how $P3094, type_obj
    .const 'Sub' $P3095 = "135_1296306531.71605" 
    $P3094."add_method"(type_obj, "postcircumfix:sym<ang>", $P3095)
    get_how $P3096, type_obj
    .const 'Sub' $P3097 = "136_1296306531.71605" 
    $P3096."add_method"(type_obj, "postcircumfix:sym<( )>", $P3097)
    get_how $P3098, type_obj
    .const 'Sub' $P3099 = "137_1296306531.71605" 
    $P3098."add_method"(type_obj, "value", $P3099)
    get_how $P3100, type_obj
    .const 'Sub' $P3101 = "138_1296306531.71605" 
    $P3100."add_method"(type_obj, "number", $P3101)
    get_how $P3102, type_obj
    .const 'Sub' $P3103 = "139_1296306531.71605" 
    $P3102."add_method"(type_obj, "quote:sym<apos>", $P3103)
    get_how $P3104, type_obj
    .const 'Sub' $P3105 = "140_1296306531.71605" 
    $P3104."add_method"(type_obj, "quote:sym<dblq>", $P3105)
    get_how $P3106, type_obj
    .const 'Sub' $P3107 = "141_1296306531.71605" 
    $P3106."add_method"(type_obj, "quote:sym<qq>", $P3107)
    get_how $P3108, type_obj
    .const 'Sub' $P3109 = "142_1296306531.71605" 
    $P3108."add_method"(type_obj, "quote:sym<q>", $P3109)
    get_how $P3110, type_obj
    .const 'Sub' $P3111 = "143_1296306531.71605" 
    $P3110."add_method"(type_obj, "quote:sym<Q>", $P3111)
    get_how $P3112, type_obj
    .const 'Sub' $P3113 = "144_1296306531.71605" 
    $P3112."add_method"(type_obj, "quote:sym<Q:PIR>", $P3113)
    get_how $P3114, type_obj
    .const 'Sub' $P3115 = "145_1296306531.71605" 
    $P3114."add_method"(type_obj, "quote:sym</ />", $P3115)
    get_how $P3116, type_obj
    .const 'Sub' $P3117 = "146_1296306531.71605" 
    $P3116."add_method"(type_obj, "quote_escape:sym<$>", $P3117)
    get_how $P3118, type_obj
    .const 'Sub' $P3119 = "147_1296306531.71605" 
    $P3118."add_method"(type_obj, "quote_escape:sym<{ }>", $P3119)
    get_how $P3120, type_obj
    .const 'Sub' $P3121 = "148_1296306531.71605" 
    $P3120."add_method"(type_obj, "quote_escape:sym<esc>", $P3121)
    get_how $P3122, type_obj
    .const 'Sub' $P3123 = "149_1296306531.71605" 
    $P3122."add_method"(type_obj, "postfix:sym<.>", $P3123)
    get_how $P3124, type_obj
    .const 'Sub' $P3125 = "150_1296306531.71605" 
    $P3124."add_method"(type_obj, "postfix:sym<++>", $P3125)
    get_how $P3126, type_obj
    .const 'Sub' $P3127 = "151_1296306531.71605" 
    $P3126."add_method"(type_obj, "postfix:sym<-->", $P3127)
    get_how $P3128, type_obj
    .const 'Sub' $P3129 = "152_1296306531.71605" 
    $P3128."add_method"(type_obj, "prefix:sym<make>", $P3129)
    get_how $P3130, type_obj
    .const 'Sub' $P3131 = "153_1296306531.71605" 
    $P3130."add_method"(type_obj, "term:sym<next>", $P3131)
    get_how $P3132, type_obj
    .const 'Sub' $P3133 = "154_1296306531.71605" 
    $P3132."add_method"(type_obj, "term:sym<last>", $P3133)
    get_how $P3134, type_obj
    .const 'Sub' $P3135 = "155_1296306531.71605" 
    $P3134."add_method"(type_obj, "term:sym<redo>", $P3135)
    get_how $P3136, type_obj
    .const 'Sub' $P3137 = "156_1296306531.71605" 
    $P3136."add_method"(type_obj, "infix:sym<~~>", $P3137)
    get_how $P3138, type_obj
    get_hll_global $P3139, ["HLL"], "Actions"
    $P3138."add_parent"(type_obj, $P3139)
    get_how $P3140, type_obj
    $P3141 = $P3140."compose"(type_obj)
    .return ($P3141)
.end


.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_20
.annotate 'line', 9
    .lex "$xblock", param_20
.annotate 'line', 10
    find_lex $P21, "$xblock"
    unless_null $P21, vivify_171
    $P21 = root_new ['parrot';'ResizablePMCArray']
  vivify_171:
    set $P22, $P21[1]
    unless_null $P22, vivify_172
    new $P22, "Undef"
  vivify_172:
    $P23 = "block_immediate"($P22)
    find_lex $P24, "$xblock"
    unless_null $P24, vivify_173
    $P24 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P24
  vivify_173:
    set $P24[1], $P23
    find_lex $P25, "$xblock"
.annotate 'line', 9
    .return ($P25)
.end


.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_28
.annotate 'line', 14
    .const 'Sub' $P38 = "14_1296306531.71605" 
    capture_lex $P38
    .lex "$block", param_28
.annotate 'line', 15
    find_lex $P29, "$block"
    $P29."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P33, "$block"
    $P34 = $P33."symtable"()
    unless $P34, unless_32
    set $P31, $P34
    goto unless_32_end
  unless_32:
    find_lex $P35, "$block"
    $P36 = $P35."handlers"()
    set $P31, $P36
  unless_32_end:
    if $P31, unless_30_end
    .const 'Sub' $P38 = "14_1296306531.71605" 
    capture_lex $P38
    $P38()
  unless_30_end:
    find_lex $P58, "$block"
.annotate 'line', 14
    .return ($P58)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block37"  :anon :subid("14_1296306531.71605") :outer("13_1296306531.71605")
.annotate 'line', 16
    .const 'Sub' $P49 = "15_1296306531.71605" 
    capture_lex $P49
.annotate 'line', 17
    new $P39, "Undef"
    .lex "$stmts", $P39
    get_hll_global $P40, ["PAST"], "Stmts"
    find_lex $P41, "$block"
    $P42 = $P40."new"($P41 :named("node"))
    store_lex "$stmts", $P42
.annotate 'line', 18
    find_lex $P44, "$block"
    $P45 = $P44."list"()
    defined $I46, $P45
    unless $I46, for_undef_174
    iter $P43, $P45
    new $P55, 'ExceptionHandler'
    set_addr $P55, loop54_handler
    $P55."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P55
  loop54_test:
    unless $P43, loop54_done
    shift $P47, $P43
  loop54_redo:
    .const 'Sub' $P49 = "15_1296306531.71605" 
    capture_lex $P49
    $P49($P47)
  loop54_next:
    goto loop54_test
  loop54_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P56, exception, 'type'
    eq $P56, .CONTROL_LOOP_NEXT, loop54_next
    eq $P56, .CONTROL_LOOP_REDO, loop54_redo
  loop54_done:
    pop_eh 
  for_undef_174:
.annotate 'line', 19
    find_lex $P57, "$stmts"
    store_lex "$block", $P57
.annotate 'line', 16
    .return ($P57)
.end


.namespace ["NQP";"Actions"]
.sub "_block48"  :anon :subid("15_1296306531.71605") :outer("14_1296306531.71605")
    .param pmc param_50
.annotate 'line', 18
    .lex "$_", param_50
    find_lex $P51, "$stmts"
    find_lex $P52, "$_"
    $P53 = $P51."push"($P52)
    .return ($P53)
.end


.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_61
.annotate 'line', 24
    .lex "$sigil", param_61
.annotate 'line', 25
    find_lex $P64, "$sigil"
    set $S65, $P64
    iseq $I66, $S65, "%"
    if $I66, if_63
.annotate 'line', 27
    find_lex $P71, "$sigil"
    set $S72, $P71
    iseq $I73, $S72, "@"
    if $I73, if_70
    new $P76, "String"
    assign $P76, "Undef"
    set $P69, $P76
    goto if_70_end
  if_70:
.annotate 'line', 28
    get_hll_global $P74, ["PAST"], "Op"
    $P75 = $P74."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P69, $P75
  if_70_end:
    set $P62, $P69
.annotate 'line', 25
    goto if_63_end
  if_63:
.annotate 'line', 26
    get_hll_global $P67, ["PAST"], "Op"
    $P68 = $P67."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P62, $P68
  if_63_end:
.annotate 'line', 24
    .return ($P62)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_79
.annotate 'line', 43
    .lex "$ast", param_79
.annotate 'line', 44
    get_hll_global $P82, ["PAST"], "Op"
    find_lex $P83, "$ast"
    $P84 = $P82."ACCEPTS"($P83)
    if $P84, if_81
.annotate 'line', 46
    find_lex $P88, "$ast"
    $P89 = $P88."value"()
    set $P80, $P89
.annotate 'line', 44
    goto if_81_end
  if_81:
.annotate 'line', 45
    find_lex $P85, "$ast"
    $P86 = $P85."list"()
    join $S87, " ", $P86
    new $P80, 'String'
    set $P80, $S87
  if_81_end:
.annotate 'line', 43
    .return ($P80)
.end


.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_92
    .param pmc param_93
.annotate 'line', 223
    .lex "$/", param_92
    .lex "$block", param_93
.annotate 'line', 224
    get_global $P95, "@BLOCK"
    unless_null $P95, vivify_175
    $P95 = root_new ['parrot';'ResizablePMCArray']
  vivify_175:
    set $P96, $P95[0]
    unless_null $P96, vivify_176
    new $P96, "Undef"
  vivify_176:
    $P97 = $P96."handlers"()
    if $P97, unless_94_end
.annotate 'line', 225
    get_global $P98, "@BLOCK"
    unless_null $P98, vivify_177
    $P98 = root_new ['parrot';'ResizablePMCArray']
  vivify_177:
    set $P99, $P98[0]
    unless_null $P99, vivify_178
    new $P99, "Undef"
  vivify_178:
    new $P100, "ResizablePMCArray"
    $P99."handlers"($P100)
  unless_94_end:
.annotate 'line', 227
    find_lex $P102, "$block"
    $P103 = $P102."arity"()
    if $P103, unless_101_end
.annotate 'line', 228
    find_lex $P104, "$block"
.annotate 'line', 229
    get_hll_global $P105, ["PAST"], "Op"
.annotate 'line', 230
    get_hll_global $P106, ["PAST"], "Var"
    $P107 = $P106."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 231
    get_hll_global $P108, ["PAST"], "Var"
    $P109 = $P108."new"("lexical" :named("scope"), "$_" :named("name"))
    $P110 = $P105."new"($P107, $P109, "bind" :named("pasttype"))
.annotate 'line', 229
    $P104."unshift"($P110)
.annotate 'line', 234
    find_lex $P111, "$block"
    get_hll_global $P112, ["PAST"], "Var"
    $P113 = $P112."new"("$_" :named("name"), "parameter" :named("scope"))
    $P111."unshift"($P113)
.annotate 'line', 235
    find_lex $P114, "$block"
    $P114."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 236
    find_lex $P115, "$block"
    $P115."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 237
    find_lex $P116, "$block"
    $P116."arity"(1)
  unless_101_end:
.annotate 'line', 239
    find_lex $P117, "$block"
    $P117."blocktype"("declaration")
.annotate 'line', 240
    get_global $P118, "@BLOCK"
    unless_null $P118, vivify_179
    $P118 = root_new ['parrot';'ResizablePMCArray']
  vivify_179:
    set $P119, $P118[0]
    unless_null $P119, vivify_180
    new $P119, "Undef"
  vivify_180:
    $P120 = $P119."handlers"()
.annotate 'line', 241
    get_hll_global $P121, ["PAST"], "Control"
    find_lex $P122, "$/"
.annotate 'line', 243
    get_hll_global $P123, ["PAST"], "Stmts"
.annotate 'line', 244
    get_hll_global $P124, ["PAST"], "Op"
    find_lex $P125, "$block"
.annotate 'line', 246
    get_hll_global $P126, ["PAST"], "Var"
    $P127 = $P126."new"("register" :named("scope"), "exception" :named("name"))
    $P128 = $P124."new"($P125, $P127, "call" :named("pasttype"))
.annotate 'line', 248
    get_hll_global $P129, ["PAST"], "Op"
.annotate 'line', 249
    get_hll_global $P130, ["PAST"], "Var"
.annotate 'line', 250
    get_hll_global $P131, ["PAST"], "Var"
    $P132 = $P131."new"("register" :named("scope"), "exception" :named("name"))
    $P133 = $P130."new"($P132, "handled", "keyed" :named("scope"))
.annotate 'line', 249
    $P134 = $P129."new"($P133, 1, "bind" :named("pasttype"))
.annotate 'line', 248
    $P135 = $P123."new"($P128, $P134)
.annotate 'line', 243
    $P136 = $P121."new"($P135, $P122 :named("node"))
.annotate 'line', 241
    $P137 = $P120."unshift"($P136)
.annotate 'line', 223
    .return ($P137)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package"  :subid("19_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_142
.annotate 'line', 375
    .const 'Sub' $P212 = "21_1296306531.71605" 
    capture_lex $P212
    .const 'Sub' $P193 = "20_1296306531.71605" 
    capture_lex $P193
    new $P141, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P141, control_140
    push_eh $P141
    .lex "$/", param_142
.annotate 'line', 376
    $P143 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P143
.annotate 'line', 377
    new $P144, "Undef"
    .lex "$name", $P144
.annotate 'line', 450
    new $P145, "Undef"
    .lex "$past", $P145
.annotate 'line', 376
    find_lex $P146, "$/"
    unless_null $P146, vivify_181
    $P146 = root_new ['parrot';'Hash']
  vivify_181:
    set $P147, $P146["package_def"]
    unless_null $P147, vivify_182
    $P147 = root_new ['parrot';'Hash']
  vivify_182:
    set $P148, $P147["name"]
    unless_null $P148, vivify_183
    $P148 = root_new ['parrot';'Hash']
  vivify_183:
    set $P149, $P148["identifier"]
    unless_null $P149, vivify_184
    new $P149, "Undef"
  vivify_184:
    clone $P150, $P149
    store_lex "@ns", $P150
.annotate 'line', 377
    find_lex $P151, "@ns"
    $P152 = $P151."pop"()
    set $S153, $P152
    new $P154, 'String'
    set $P154, $S153
    store_lex "$name", $P154
.annotate 'line', 381
    find_dynamic_lex $P155, "$*PACKAGE-SETUP"
    unless_null $P155, vivify_185
    get_hll_global $P155, "$PACKAGE-SETUP"
    unless_null $P155, vivify_186
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_186:
  vivify_185:
    get_hll_global $P156, ["PAST"], "Stmts"
.annotate 'line', 382
    get_hll_global $P157, ["PAST"], "Op"
.annotate 'line', 383
    get_hll_global $P158, ["PAST"], "Var"
    $P159 = $P158."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 384
    get_hll_global $P160, ["PAST"], "Op"
.annotate 'line', 386
    get_hll_global $P161, ["PAST"], "Var"
    find_lex $P162, "$/"
    unless_null $P162, vivify_187
    $P162 = root_new ['parrot';'Hash']
  vivify_187:
    set $P163, $P162["sym"]
    unless_null $P163, vivify_188
    new $P163, "Undef"
  vivify_188:
    set $S164, $P163
    find_dynamic_lex $P165, "%*HOW"
    unless_null $P165, vivify_189
    get_hll_global $P165, "%HOW"
    unless_null $P165, vivify_190
    die "Contextual %*HOW not found"
  vivify_190:
  vivify_189:
    set $P166, $P165[$S164]
    unless_null $P166, vivify_191
    new $P166, "Undef"
  vivify_191:
    $P167 = $P161."new"($P166 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 387
    get_hll_global $P168, ["PAST"], "Val"
    find_lex $P169, "$name"
    $P170 = $P168."new"($P169 :named("value"), "name" :named("named"))
    $P171 = $P160."new"($P167, $P170, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 384
    $P172 = $P157."new"($P159, $P171, "bind" :named("pasttype"))
.annotate 'line', 390
    get_hll_global $P173, ["PAST"], "Op"
.annotate 'line', 391
    get_hll_global $P174, ["PAST"], "Var"
    find_lex $P175, "$name"
    find_lex $P176, "@ns"
    $P177 = $P174."new"($P175 :named("name"), $P176 :named("namespace"), "package" :named("scope"))
.annotate 'line', 392
    get_hll_global $P178, ["PAST"], "Var"
    $P179 = $P178."new"("type_obj" :named("name"), "register" :named("scope"))
    $P180 = $P173."new"($P177, $P179, "bind" :named("pasttype"))
.annotate 'line', 394
    get_hll_global $P181, ["PAST"], "Op"
.annotate 'line', 395
    get_hll_global $P182, ["PAST"], "Var"
    $P183 = $P182."new"("$?CLASS" :named("name"))
.annotate 'line', 396
    get_hll_global $P184, ["PAST"], "Var"
    $P185 = $P184."new"("type_obj" :named("name"), "register" :named("scope"))
    $P186 = $P181."new"($P183, $P185, "bind" :named("pasttype"))
.annotate 'line', 394
    $P187 = $P156."new"($P172, $P180, $P186)
.annotate 'line', 381
    $P155."unshift"($P187)
.annotate 'line', 399
    find_lex $P189, "$/"
    unless_null $P189, vivify_192
    $P189 = root_new ['parrot';'Hash']
  vivify_192:
    set $P190, $P189["package_def"]
    unless_null $P190, vivify_193
    $P190 = root_new ['parrot';'Hash']
  vivify_193:
    set $P191, $P190["repr"]
    unless_null $P191, vivify_194
    new $P191, "Undef"
  vivify_194:
    unless $P191, if_188_end
    .const 'Sub' $P193 = "20_1296306531.71605" 
    capture_lex $P193
    $P193()
  if_188_end:
.annotate 'line', 407
    find_lex $P208, "$/"
    unless_null $P208, vivify_204
    $P208 = root_new ['parrot';'Hash']
  vivify_204:
    set $P209, $P208["package_def"]
    unless_null $P209, vivify_205
    $P209 = root_new ['parrot';'Hash']
  vivify_205:
    set $P210, $P209["parent"]
    unless_null $P210, vivify_206
    new $P210, "Undef"
  vivify_206:
    if $P210, if_207
.annotate 'line', 421
    find_lex $P241, "$/"
    unless_null $P241, vivify_207
    $P241 = root_new ['parrot';'Hash']
  vivify_207:
    set $P242, $P241["sym"]
    unless_null $P242, vivify_208
    new $P242, "Undef"
  vivify_208:
    set $S243, $P242
    iseq $I244, $S243, "grammar"
    unless $I244, if_240_end
.annotate 'line', 422
    find_dynamic_lex $P245, "$*PACKAGE-SETUP"
    unless_null $P245, vivify_209
    get_hll_global $P245, "$PACKAGE-SETUP"
    unless_null $P245, vivify_210
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_210:
  vivify_209:
    get_hll_global $P246, ["PAST"], "Op"
.annotate 'line', 424
    get_hll_global $P247, ["PAST"], "Op"
.annotate 'line', 427
    get_hll_global $P248, ["PAST"], "Var"
    $P249 = $P248."new"("type_obj" :named("name"), "register" :named("scope"))
    $P250 = $P247."new"($P249, "get_how PP" :named("pirop"))
.annotate 'line', 429
    get_hll_global $P251, ["PAST"], "Var"
    $P252 = $P251."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 430
    get_hll_global $P253, ["PAST"], "Var"
    $P254 = $P253."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P255 = $P246."new"($P250, $P252, $P254, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 422
    $P245."push"($P255)
  if_240_end:
.annotate 'line', 421
    goto if_207_end
  if_207:
.annotate 'line', 407
    .const 'Sub' $P212 = "21_1296306531.71605" 
    capture_lex $P212
    $P212()
  if_207_end:
.annotate 'line', 435
    find_dynamic_lex $P256, "$*PACKAGE-SETUP"
    unless_null $P256, vivify_218
    get_hll_global $P256, "$PACKAGE-SETUP"
    unless_null $P256, vivify_219
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_219:
  vivify_218:
    get_hll_global $P257, ["PAST"], "Op"
.annotate 'line', 437
    get_hll_global $P258, ["PAST"], "Op"
.annotate 'line', 440
    get_hll_global $P259, ["PAST"], "Var"
    $P260 = $P259."new"("type_obj" :named("name"), "register" :named("scope"))
    $P261 = $P258."new"($P260, "get_how PP" :named("pirop"))
.annotate 'line', 442
    get_hll_global $P262, ["PAST"], "Var"
    $P263 = $P262."new"("type_obj" :named("name"), "register" :named("scope"))
    $P264 = $P257."new"($P261, $P263, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 435
    $P256."push"($P264)
.annotate 'line', 446
    get_global $P265, "@BLOCK"
    unless_null $P265, vivify_220
    $P265 = root_new ['parrot';'ResizablePMCArray']
  vivify_220:
    set $P266, $P265[0]
    unless_null $P266, vivify_221
    $P266 = root_new ['parrot';'ResizablePMCArray']
  vivify_221:
    set $P267, $P266[0]
    unless_null $P267, vivify_222
    new $P267, "Undef"
  vivify_222:
    get_hll_global $P268, ["PAST"], "Var"
    find_lex $P269, "$name"
    find_lex $P270, "@ns"
    $P271 = $P268."new"($P269 :named("name"), $P270 :named("namespace"), "package" :named("scope"), 1 :named("isdecl"))
    $P267."unshift"($P271)
.annotate 'line', 450
    find_lex $P272, "$/"
    unless_null $P272, vivify_223
    $P272 = root_new ['parrot';'Hash']
  vivify_223:
    set $P273, $P272["package_def"]
    unless_null $P273, vivify_224
    new $P273, "Undef"
  vivify_224:
    $P274 = $P273."ast"()
    store_lex "$past", $P274
.annotate 'line', 451
    find_lex $P275, "$past"
    get_hll_global $P276, ["PAST"], "Var"
    $P277 = $P276."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P275."unshift"($P277)
.annotate 'line', 452
    find_lex $P278, "$past"
    $P278."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 455
    find_lex $P279, "$past"
    $P280 = $P279."loadinit"()
    get_hll_global $P281, ["PAST"], "Block"
    find_dynamic_lex $P282, "$*PACKAGE-SETUP"
    unless_null $P282, vivify_225
    get_hll_global $P282, "$PACKAGE-SETUP"
    unless_null $P282, vivify_226
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_226:
  vivify_225:
    $P283 = $P281."new"($P282, "immediate" :named("blocktype"))
    $P280."push"($P283)
.annotate 'line', 457
    new $P284, "Exception"
    set $P284['type'], .CONTROL_RETURN
    find_lex $P285, "$past"
    setattribute $P284, 'payload', $P285
    throw $P284
.annotate 'line', 375
    .return ()
  control_140:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P286, exception, "payload"
    .return ($P286)
.end


.namespace ["NQP";"Actions"]
.sub "_block192"  :anon :subid("20_1296306531.71605") :outer("19_1296306531.71605")
.annotate 'line', 400
    new $P194, "Undef"
    .lex "$repr_name", $P194
    find_lex $P195, "$/"
    unless_null $P195, vivify_195
    $P195 = root_new ['parrot';'Hash']
  vivify_195:
    set $P196, $P195["package_def"]
    unless_null $P196, vivify_196
    $P196 = root_new ['parrot';'Hash']
  vivify_196:
    set $P197, $P196["repr"]
    unless_null $P197, vivify_197
    $P197 = root_new ['parrot';'ResizablePMCArray']
  vivify_197:
    set $P198, $P197[0]
    unless_null $P198, vivify_198
    new $P198, "Undef"
  vivify_198:
    $P199 = $P198."ast"()
    store_lex "$repr_name", $P199
.annotate 'line', 401
    find_lex $P200, "$repr_name"
    $P200."named"("repr")
.annotate 'line', 402
    find_dynamic_lex $P201, "$*PACKAGE-SETUP"
    unless_null $P201, vivify_199
    get_hll_global $P201, "$PACKAGE-SETUP"
    unless_null $P201, vivify_200
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_200:
  vivify_199:
    set $P202, $P201[0]
    unless_null $P202, vivify_201
    $P202 = root_new ['parrot';'ResizablePMCArray']
  vivify_201:
    set $P203, $P202[0]
    unless_null $P203, vivify_202
    $P203 = root_new ['parrot';'ResizablePMCArray']
  vivify_202:
    set $P204, $P203[1]
    unless_null $P204, vivify_203
    new $P204, "Undef"
  vivify_203:
    find_lex $P205, "$repr_name"
    $P206 = $P204."push"($P205)
.annotate 'line', 399
    .return ($P206)
.end


.namespace ["NQP";"Actions"]
.sub "_block211"  :anon :subid("21_1296306531.71605") :outer("19_1296306531.71605")
.annotate 'line', 408
    $P213 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P213
.annotate 'line', 409
    new $P214, "Undef"
    .lex "$name", $P214
.annotate 'line', 408
    find_lex $P215, "$/"
    unless_null $P215, vivify_211
    $P215 = root_new ['parrot';'Hash']
  vivify_211:
    set $P216, $P215["package_def"]
    unless_null $P216, vivify_212
    $P216 = root_new ['parrot';'Hash']
  vivify_212:
    set $P217, $P216["parent"]
    unless_null $P217, vivify_213
    $P217 = root_new ['parrot';'ResizablePMCArray']
  vivify_213:
    set $P218, $P217[0]
    unless_null $P218, vivify_214
    $P218 = root_new ['parrot';'Hash']
  vivify_214:
    set $P219, $P218["identifier"]
    unless_null $P219, vivify_215
    new $P219, "Undef"
  vivify_215:
    clone $P220, $P219
    store_lex "@ns", $P220
.annotate 'line', 409
    find_lex $P221, "@ns"
    $P222 = $P221."pop"()
    set $S223, $P222
    new $P224, 'String'
    set $P224, $S223
    store_lex "$name", $P224
.annotate 'line', 410
    find_dynamic_lex $P225, "$*PACKAGE-SETUP"
    unless_null $P225, vivify_216
    get_hll_global $P225, "$PACKAGE-SETUP"
    unless_null $P225, vivify_217
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_217:
  vivify_216:
    get_hll_global $P226, ["PAST"], "Op"
.annotate 'line', 412
    get_hll_global $P227, ["PAST"], "Op"
.annotate 'line', 415
    get_hll_global $P228, ["PAST"], "Var"
    $P229 = $P228."new"("type_obj" :named("name"), "register" :named("scope"))
    $P230 = $P227."new"($P229, "get_how PP" :named("pirop"))
.annotate 'line', 417
    get_hll_global $P231, ["PAST"], "Var"
    $P232 = $P231."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 418
    get_hll_global $P233, ["PAST"], "Var"
    find_lex $P234, "$name"
    set $S235, $P234
    find_lex $P236, "@ns"
    $P237 = $P233."new"($S235 :named("name"), $P236 :named("namespace"), "package" :named("scope"))
    $P238 = $P226."new"($P230, $P232, $P237, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 410
    $P239 = $P225."push"($P238)
.annotate 'line', 407
    .return ($P239)
.end


.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("22_1296306531.71605") :outer("11_1296306531.71605")
.annotate 'line', 734
    new $P289, "Undef"
    .lex "$past", $P289
    get_global $P290, "@BLOCK"
    $P291 = $P290."shift"()
    store_lex "$past", $P291
.annotate 'line', 735
    find_lex $P292, "$past"
    $P292."closure"(1)
.annotate 'line', 736
    find_lex $P293, "$past"
    get_hll_global $P294, ["PAST"], "Op"
    $P295 = $P294."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P293."push"($P295)
    find_lex $P296, "$past"
.annotate 'line', 733
    .return ($P296)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("23_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_299
.annotate 'line', 742
    .const 'Sub' $P313 = "24_1296306531.71605" 
    capture_lex $P313
    .lex "$routine", param_299
.annotate 'line', 746
    new $P300, "Undef"
    .lex "$types", $P300
.annotate 'line', 747
    new $P301, "Undef"
    .lex "$definednesses", $P301
.annotate 'line', 746
    get_hll_global $P302, ["PAST"], "Op"
    $P303 = $P302."new"("list" :named("pasttype"))
    store_lex "$types", $P303
.annotate 'line', 747
    get_hll_global $P304, ["PAST"], "Op"
    $P305 = $P304."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P305
.annotate 'line', 748
    find_lex $P307, "$routine"
    unless_null $P307, vivify_227
    $P307 = root_new ['parrot';'ResizablePMCArray']
  vivify_227:
    set $P308, $P307[0]
    unless_null $P308, vivify_228
    new $P308, "Undef"
  vivify_228:
    $P309 = $P308."list"()
    defined $I310, $P309
    unless $I310, for_undef_229
    iter $P306, $P309
    new $P351, 'ExceptionHandler'
    set_addr $P351, loop350_handler
    $P351."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P351
  loop350_test:
    unless $P306, loop350_done
    shift $P311, $P306
  loop350_redo:
    .const 'Sub' $P313 = "24_1296306531.71605" 
    capture_lex $P313
    $P313($P311)
  loop350_next:
    goto loop350_test
  loop350_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P352, exception, 'type'
    eq $P352, .CONTROL_LOOP_NEXT, loop350_next
    eq $P352, .CONTROL_LOOP_REDO, loop350_redo
  loop350_done:
    pop_eh 
  for_undef_229:
.annotate 'line', 755
    find_lex $P353, "$routine"
    $P354 = $P353."loadinit"()
    get_hll_global $P355, ["PAST"], "Op"
.annotate 'line', 756
    get_hll_global $P356, ["PAST"], "Var"
    $P357 = $P356."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P358, "$types"
    find_lex $P359, "$definednesses"
    $P360 = $P355."new"($P357, $P358, $P359, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 755
    $P361 = $P354."push"($P360)
.annotate 'line', 742
    .return ($P361)
.end


.namespace ["NQP";"Actions"]
.sub "_block312"  :anon :subid("24_1296306531.71605") :outer("23_1296306531.71605")
    .param pmc param_314
.annotate 'line', 748
    .lex "$_", param_314
.annotate 'line', 749
    get_hll_global $P319, ["PAST"], "Var"
    find_lex $P320, "$_"
    $P321 = $P319."ACCEPTS"($P320)
    if $P321, if_318
    set $P317, $P321
    goto if_318_end
  if_318:
    find_lex $P322, "$_"
    $S323 = $P322."scope"()
    iseq $I324, $S323, "parameter"
    new $P317, 'Integer'
    set $P317, $I324
  if_318_end:
    if $P317, if_316
    set $P315, $P317
    goto if_316_end
  if_316:
.annotate 'line', 750
    find_lex $P325, "$types"
    find_lex $P327, "$_"
    $P328 = $P327."multitype"()
    set $P326, $P328
    defined $I330, $P326
    if $I330, default_329
    get_hll_global $P331, ["PAST"], "Op"
    $P332 = $P331."new"("null P" :named("pirop"))
    set $P326, $P332
  default_329:
    $P325."push"($P326)
.annotate 'line', 751
    find_lex $P333, "$definednesses"
    find_lex $P336, "$_"
    unless_null $P336, vivify_230
    $P336 = root_new ['parrot';'Hash']
  vivify_230:
    set $P337, $P336["definedness"]
    unless_null $P337, vivify_231
    new $P337, "Undef"
  vivify_231:
    set $S338, $P337
    iseq $I339, $S338, "D"
    if $I339, if_335
.annotate 'line', 752
    find_lex $P343, "$_"
    unless_null $P343, vivify_232
    $P343 = root_new ['parrot';'Hash']
  vivify_232:
    set $P344, $P343["definedness"]
    unless_null $P344, vivify_233
    new $P344, "Undef"
  vivify_233:
    set $S345, $P344
    iseq $I346, $S345, "U"
    if $I346, if_342
    new $P348, "Integer"
    assign $P348, 0
    set $P341, $P348
    goto if_342_end
  if_342:
    new $P347, "Integer"
    assign $P347, 2
    set $P341, $P347
  if_342_end:
    set $P334, $P341
.annotate 'line', 751
    goto if_335_end
  if_335:
    new $P340, "Integer"
    assign $P340, 1
    set $P334, $P340
  if_335_end:
    $P349 = $P333."push"($P334)
.annotate 'line', 749
    set $P315, $P349
  if_316_end:
.annotate 'line', 748
    .return ($P315)
.end


.namespace ["NQP";"Actions"]
.sub "control"  :subid("25_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_364
    .param pmc param_365
.annotate 'line', 1194
    .lex "$/", param_364
    .lex "$type", param_365
.annotate 'line', 1195
    find_lex $P366, "$/"
    get_hll_global $P367, ["PAST"], "Op"
    find_lex $P368, "$/"
.annotate 'line', 1199
    get_hll_global $P369, ["PAST"], "Val"
    find_lex $P370, "$type"
    $P371 = $P369."new"($P370 :named("value"), "!except_types" :named("returns"))
    $P372 = $P367."new"(0, $P371, $P368 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1195
    $P373 = $P366."!make"($P372)
.annotate 'line', 1194
    .return ($P373)
.end


.namespace ["NQP";"Actions"]
.sub "_block376"  :anon :subid("26_1296306531.71605") :outer("11_1296306531.71605")
.annotate 'line', 3
    .const 'Sub' $P379 = "27_1296306531.71605" 
    capture_lex $P379
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post234") :outer("26_1296306531.71605")
.annotate 'line', 3
    .const 'Sub' $P377 = "26_1296306531.71605" 
    .local pmc block
    set block, $P377
.annotate 'line', 5
    .const 'Sub' $P379 = "27_1296306531.71605" 
    capture_lex $P379
    $P379()
.end


.namespace ["NQP";"Actions"]
.sub "_block378"  :anon :subid("27_1296306531.71605") :outer("26_1296306531.71605")
.annotate 'line', 6
    get_global $P380, "@BLOCK"
    unless_null $P380, vivify_235
    $P380 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P380
  vivify_235:
 $P381 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P381
.annotate 'line', 5
    .return ($P381)
.end


.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("28_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_386
    .param pmc param_387
.annotate 'line', 33
    .lex "self", param_386
    .lex "$/", param_387
    find_lex $P388, "$/"
    find_lex $P389, "$/"
    unless_null $P389, vivify_236
    $P389 = root_new ['parrot';'Hash']
  vivify_236:
    set $P390, $P389["comp_unit"]
    unless_null $P390, vivify_237
    new $P390, "Undef"
  vivify_237:
    $P391 = $P390."ast"()
    $P392 = $P388."!make"($P391)
    .return ($P392)
.end


.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("29_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_394
    .param pmc param_395
.annotate 'line', 35
    .lex "self", param_394
    .lex "$/", param_395
.annotate 'line', 36
    find_lex $P396, "$/"
.annotate 'line', 37
    find_lex $P399, "$/"
    unless_null $P399, vivify_238
    $P399 = root_new ['parrot';'Hash']
  vivify_238:
    set $P400, $P399["colonpair"]
    unless_null $P400, vivify_239
    new $P400, "Undef"
  vivify_239:
    if $P400, if_398
.annotate 'line', 39
    find_lex $P420, "$/"
    set $S421, $P420
    new $P397, 'String'
    set $P397, $S421
.annotate 'line', 37
    goto if_398_end
  if_398:
    find_lex $P401, "$/"
    unless_null $P401, vivify_240
    $P401 = root_new ['parrot';'Hash']
  vivify_240:
    set $P402, $P401["identifier"]
    unless_null $P402, vivify_241
    new $P402, "Undef"
  vivify_241:
    set $S403, $P402
    new $P404, 'String'
    set $P404, $S403
    concat $P405, $P404, ":"
    find_lex $P406, "$/"
    unless_null $P406, vivify_242
    $P406 = root_new ['parrot';'Hash']
  vivify_242:
    set $P407, $P406["colonpair"]
    unless_null $P407, vivify_243
    $P407 = root_new ['parrot';'ResizablePMCArray']
  vivify_243:
    set $P408, $P407[0]
    unless_null $P408, vivify_244
    new $P408, "Undef"
  vivify_244:
    $P409 = $P408."ast"()
    $S410 = $P409."named"()
    concat $P411, $P405, $S410
    concat $P412, $P411, "<"
.annotate 'line', 38
    find_lex $P413, "$/"
    unless_null $P413, vivify_245
    $P413 = root_new ['parrot';'Hash']
  vivify_245:
    set $P414, $P413["colonpair"]
    unless_null $P414, vivify_246
    $P414 = root_new ['parrot';'ResizablePMCArray']
  vivify_246:
    set $P415, $P414[0]
    unless_null $P415, vivify_247
    new $P415, "Undef"
  vivify_247:
    $P416 = $P415."ast"()
    $S417 = "colonpair_str"($P416)
    concat $P418, $P412, $S417
    concat $P419, $P418, ">"
    set $P397, $P419
  if_398_end:
.annotate 'line', 37
    $P422 = $P396."!make"($P397)
.annotate 'line', 35
    .return ($P422)
.end


.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("30_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_425
    .param pmc param_426
.annotate 'line', 49
    .lex "self", param_425
    .lex "$/", param_426
.annotate 'line', 50
    new $P427, "Undef"
    .lex "$mainline", $P427
.annotate 'line', 51
    new $P428, "Undef"
    .lex "$unit", $P428
.annotate 'line', 50
    find_lex $P429, "$/"
    unless_null $P429, vivify_248
    $P429 = root_new ['parrot';'Hash']
  vivify_248:
    set $P430, $P429["statementlist"]
    unless_null $P430, vivify_249
    new $P430, "Undef"
  vivify_249:
    $P431 = $P430."ast"()
    store_lex "$mainline", $P431
.annotate 'line', 51
    get_global $P432, "@BLOCK"
    $P433 = $P432."shift"()
    store_lex "$unit", $P433
.annotate 'line', 55
    find_lex $P434, "$unit"
    find_lex $P435, "self"
    $P436 = $P435."CTXSAVE"()
    $P434."push"($P436)
.annotate 'line', 58
    find_lex $P437, "$unit"
    $P437."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 59
    find_lex $P438, "$unit"
    get_hll_global $P439, ["PAST"], "Op"
    $P440 = $P439."new"("nqp_dynop_setup v" :named("pirop"))
    $P438."unshift"($P440)
.annotate 'line', 64
    find_lex $P441, "$unit"
.annotate 'line', 65
    get_hll_global $P442, ["PAST"], "Op"
    find_lex $P443, "$mainline"
    $P444 = $P442."new"($P443, "return" :named("pirop"))
    $P441."push"($P444)
.annotate 'line', 70
    find_lex $P445, "$unit"
.annotate 'line', 71
    get_hll_global $P446, ["PAST"], "Block"
.annotate 'line', 73
    get_hll_global $P447, ["PAST"], "Op"
    get_hll_global $P448, ["PAST"], "Val"
    find_lex $P449, "$unit"
    $P450 = $P448."new"($P449 :named("value"))
    $P451 = $P447."new"($P450, "call" :named("pasttype"))
    $P452 = $P446."new"($P451, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 71
    $P445."push"($P452)
.annotate 'line', 76
    find_lex $P453, "$unit"
    find_lex $P454, "$/"
    $P453."node"($P454)
.annotate 'line', 77
    find_lex $P455, "$/"
    find_lex $P456, "$unit"
    $P457 = $P455."!make"($P456)
.annotate 'line', 49
    .return ($P457)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("31_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_459
    .param pmc param_460
.annotate 'line', 80
    .const 'Sub' $P474 = "32_1296306531.71605" 
    capture_lex $P474
    .lex "self", param_459
    .lex "$/", param_460
.annotate 'line', 81
    new $P461, "Undef"
    .lex "$past", $P461
    get_hll_global $P462, ["PAST"], "Stmts"
    find_lex $P463, "$/"
    $P464 = $P462."new"($P463 :named("node"))
    store_lex "$past", $P464
.annotate 'line', 82
    find_lex $P466, "$/"
    unless_null $P466, vivify_250
    $P466 = root_new ['parrot';'Hash']
  vivify_250:
    set $P467, $P466["statement"]
    unless_null $P467, vivify_251
    new $P467, "Undef"
  vivify_251:
    unless $P467, if_465_end
.annotate 'line', 83
    find_lex $P469, "$/"
    unless_null $P469, vivify_252
    $P469 = root_new ['parrot';'Hash']
  vivify_252:
    set $P470, $P469["statement"]
    unless_null $P470, vivify_253
    new $P470, "Undef"
  vivify_253:
    defined $I471, $P470
    unless $I471, for_undef_254
    iter $P468, $P470
    new $P494, 'ExceptionHandler'
    set_addr $P494, loop493_handler
    $P494."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P494
  loop493_test:
    unless $P468, loop493_done
    shift $P472, $P468
  loop493_redo:
    .const 'Sub' $P474 = "32_1296306531.71605" 
    capture_lex $P474
    $P474($P472)
  loop493_next:
    goto loop493_test
  loop493_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P495, exception, 'type'
    eq $P495, .CONTROL_LOOP_NEXT, loop493_next
    eq $P495, .CONTROL_LOOP_REDO, loop493_redo
  loop493_done:
    pop_eh 
  for_undef_254:
  if_465_end:
.annotate 'line', 90
    find_lex $P496, "$/"
    find_lex $P497, "$past"
    $P498 = $P496."!make"($P497)
.annotate 'line', 80
    .return ($P498)
.end


.namespace ["NQP";"Actions"]
.sub "_block473"  :anon :subid("32_1296306531.71605") :outer("31_1296306531.71605")
    .param pmc param_476
.annotate 'line', 84
    new $P475, "Undef"
    .lex "$ast", $P475
    .lex "$_", param_476
    find_lex $P477, "$_"
    $P478 = $P477."ast"()
    store_lex "$ast", $P478
.annotate 'line', 85
    find_lex $P480, "$ast"
    unless_null $P480, vivify_255
    $P480 = root_new ['parrot';'Hash']
  vivify_255:
    set $P481, $P480["sink"]
    unless_null $P481, vivify_256
    new $P481, "Undef"
  vivify_256:
    defined $I482, $P481
    unless $I482, if_479_end
    find_lex $P483, "$ast"
    unless_null $P483, vivify_257
    $P483 = root_new ['parrot';'Hash']
  vivify_257:
    set $P484, $P483["sink"]
    unless_null $P484, vivify_258
    new $P484, "Undef"
  vivify_258:
    store_lex "$ast", $P484
  if_479_end:
.annotate 'line', 86
    find_lex $P486, "$ast"
    unless_null $P486, vivify_259
    $P486 = root_new ['parrot';'Hash']
  vivify_259:
    set $P487, $P486["bareblock"]
    unless_null $P487, vivify_260
    new $P487, "Undef"
  vivify_260:
    unless $P487, if_485_end
    find_lex $P488, "$ast"
    $P489 = "block_immediate"($P488)
    store_lex "$ast", $P489
  if_485_end:
.annotate 'line', 87
    find_lex $P490, "$past"
    find_lex $P491, "$ast"
    $P492 = $P490."push"($P491)
.annotate 'line', 83
    .return ($P492)
.end


.namespace ["NQP";"Actions"]
.sub "statement"  :subid("33_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_500
    .param pmc param_501
    .param pmc param_502 :optional
    .param int has_param_502 :opt_flag
.annotate 'line', 93
    .const 'Sub' $P510 = "34_1296306531.71605" 
    capture_lex $P510
    .lex "self", param_500
    .lex "$/", param_501
    if has_param_502, optparam_261
    new $P503, "Undef"
    set param_502, $P503
  optparam_261:
    .lex "$key", param_502
.annotate 'line', 94
    new $P504, "Undef"
    .lex "$past", $P504
.annotate 'line', 93
    find_lex $P505, "$past"
.annotate 'line', 95
    find_lex $P507, "$/"
    unless_null $P507, vivify_262
    $P507 = root_new ['parrot';'Hash']
  vivify_262:
    set $P508, $P507["EXPR"]
    unless_null $P508, vivify_263
    new $P508, "Undef"
  vivify_263:
    if $P508, if_506
.annotate 'line', 116
    find_lex $P571, "$/"
    unless_null $P571, vivify_264
    $P571 = root_new ['parrot';'Hash']
  vivify_264:
    set $P572, $P571["statement_control"]
    unless_null $P572, vivify_265
    new $P572, "Undef"
  vivify_265:
    if $P572, if_570
.annotate 'line', 117
    new $P576, "Integer"
    assign $P576, 0
    store_lex "$past", $P576
    goto if_570_end
  if_570:
.annotate 'line', 116
    find_lex $P573, "$/"
    unless_null $P573, vivify_266
    $P573 = root_new ['parrot';'Hash']
  vivify_266:
    set $P574, $P573["statement_control"]
    unless_null $P574, vivify_267
    new $P574, "Undef"
  vivify_267:
    $P575 = $P574."ast"()
    store_lex "$past", $P575
  if_570_end:
    goto if_506_end
  if_506:
.annotate 'line', 95
    .const 'Sub' $P510 = "34_1296306531.71605" 
    capture_lex $P510
    $P510()
  if_506_end:
.annotate 'line', 118
    find_lex $P577, "$/"
    find_lex $P578, "$past"
    $P579 = $P577."!make"($P578)
.annotate 'line', 93
    .return ($P579)
.end


.namespace ["NQP";"Actions"]
.sub "_block509"  :anon :subid("34_1296306531.71605") :outer("33_1296306531.71605")
.annotate 'line', 96
    new $P511, "Undef"
    .lex "$mc", $P511
.annotate 'line', 97
    new $P512, "Undef"
    .lex "$ml", $P512
.annotate 'line', 96
    find_lex $P513, "$/"
    unless_null $P513, vivify_268
    $P513 = root_new ['parrot';'Hash']
  vivify_268:
    set $P514, $P513["statement_mod_cond"]
    unless_null $P514, vivify_269
    $P514 = root_new ['parrot';'ResizablePMCArray']
  vivify_269:
    set $P515, $P514[0]
    unless_null $P515, vivify_270
    new $P515, "Undef"
  vivify_270:
    store_lex "$mc", $P515
.annotate 'line', 97
    find_lex $P516, "$/"
    unless_null $P516, vivify_271
    $P516 = root_new ['parrot';'Hash']
  vivify_271:
    set $P517, $P516["statement_mod_loop"]
    unless_null $P517, vivify_272
    $P517 = root_new ['parrot';'ResizablePMCArray']
  vivify_272:
    set $P518, $P517[0]
    unless_null $P518, vivify_273
    new $P518, "Undef"
  vivify_273:
    store_lex "$ml", $P518
.annotate 'line', 98
    find_lex $P519, "$/"
    unless_null $P519, vivify_274
    $P519 = root_new ['parrot';'Hash']
  vivify_274:
    set $P520, $P519["EXPR"]
    unless_null $P520, vivify_275
    new $P520, "Undef"
  vivify_275:
    $P521 = $P520."ast"()
    store_lex "$past", $P521
.annotate 'line', 99
    find_lex $P523, "$mc"
    unless $P523, if_522_end
.annotate 'line', 100
    get_hll_global $P524, ["PAST"], "Op"
    find_lex $P525, "$mc"
    unless_null $P525, vivify_276
    $P525 = root_new ['parrot';'Hash']
  vivify_276:
    set $P526, $P525["cond"]
    unless_null $P526, vivify_277
    new $P526, "Undef"
  vivify_277:
    $P527 = $P526."ast"()
    find_lex $P528, "$past"
    find_lex $P529, "$mc"
    unless_null $P529, vivify_278
    $P529 = root_new ['parrot';'Hash']
  vivify_278:
    set $P530, $P529["sym"]
    unless_null $P530, vivify_279
    new $P530, "Undef"
  vivify_279:
    set $S531, $P530
    find_lex $P532, "$/"
    $P533 = $P524."new"($P527, $P528, $S531 :named("pasttype"), $P532 :named("node"))
    store_lex "$past", $P533
  if_522_end:
.annotate 'line', 102
    find_lex $P536, "$ml"
    if $P536, if_535
    set $P534, $P536
    goto if_535_end
  if_535:
.annotate 'line', 103
    find_lex $P539, "$ml"
    unless_null $P539, vivify_280
    $P539 = root_new ['parrot';'Hash']
  vivify_280:
    set $P540, $P539["sym"]
    unless_null $P540, vivify_281
    new $P540, "Undef"
  vivify_281:
    set $S541, $P540
    iseq $I542, $S541, "for"
    if $I542, if_538
.annotate 'line', 112
    get_hll_global $P560, ["PAST"], "Op"
    find_lex $P561, "$ml"
    unless_null $P561, vivify_282
    $P561 = root_new ['parrot';'Hash']
  vivify_282:
    set $P562, $P561["cond"]
    unless_null $P562, vivify_283
    new $P562, "Undef"
  vivify_283:
    $P563 = $P562."ast"()
    find_lex $P564, "$past"
    find_lex $P565, "$ml"
    unless_null $P565, vivify_284
    $P565 = root_new ['parrot';'Hash']
  vivify_284:
    set $P566, $P565["sym"]
    unless_null $P566, vivify_285
    new $P566, "Undef"
  vivify_285:
    set $S567, $P566
    find_lex $P568, "$/"
    $P569 = $P560."new"($P563, $P564, $S567 :named("pasttype"), $P568 :named("node"))
    store_lex "$past", $P569
.annotate 'line', 111
    set $P537, $P569
.annotate 'line', 103
    goto if_538_end
  if_538:
.annotate 'line', 104
    get_hll_global $P543, ["PAST"], "Block"
.annotate 'line', 105
    get_hll_global $P544, ["PAST"], "Var"
    $P545 = $P544."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P546, "$past"
    $P547 = $P543."new"($P545, $P546, "immediate" :named("blocktype"))
.annotate 'line', 104
    store_lex "$past", $P547
.annotate 'line', 107
    find_lex $P548, "$past"
    $P548."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 108
    find_lex $P549, "$past"
    $P549."arity"(1)
.annotate 'line', 109
    get_hll_global $P550, ["PAST"], "Op"
    find_lex $P551, "$ml"
    unless_null $P551, vivify_286
    $P551 = root_new ['parrot';'Hash']
  vivify_286:
    set $P552, $P551["cond"]
    unless_null $P552, vivify_287
    new $P552, "Undef"
  vivify_287:
    $P553 = $P552."ast"()
    find_lex $P554, "$past"
    find_lex $P555, "$ml"
    unless_null $P555, vivify_288
    $P555 = root_new ['parrot';'Hash']
  vivify_288:
    set $P556, $P555["sym"]
    unless_null $P556, vivify_289
    new $P556, "Undef"
  vivify_289:
    set $S557, $P556
    find_lex $P558, "$/"
    $P559 = $P550."new"($P553, $P554, $S557 :named("pasttype"), $P558 :named("node"))
    store_lex "$past", $P559
.annotate 'line', 103
    set $P537, $P559
  if_538_end:
.annotate 'line', 102
    set $P534, $P537
  if_535_end:
.annotate 'line', 95
    .return ($P534)
.end


.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("35_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_581
    .param pmc param_582
.annotate 'line', 121
    .lex "self", param_581
    .lex "$/", param_582
.annotate 'line', 122
    find_lex $P583, "$/"
    get_hll_global $P584, ["PAST"], "Op"
    find_lex $P585, "$/"
    unless_null $P585, vivify_290
    $P585 = root_new ['parrot';'Hash']
  vivify_290:
    set $P586, $P585["EXPR"]
    unless_null $P586, vivify_291
    new $P586, "Undef"
  vivify_291:
    $P587 = $P586."ast"()
    find_lex $P588, "$/"
    unless_null $P588, vivify_292
    $P588 = root_new ['parrot';'Hash']
  vivify_292:
    set $P589, $P588["pblock"]
    unless_null $P589, vivify_293
    new $P589, "Undef"
  vivify_293:
    $P590 = $P589."ast"()
    find_lex $P591, "$/"
    $P592 = $P584."new"($P587, $P590, "if" :named("pasttype"), $P591 :named("node"))
    $P593 = $P583."!make"($P592)
.annotate 'line', 121
    .return ($P593)
.end


.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("36_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_595
    .param pmc param_596
.annotate 'line', 125
    .lex "self", param_595
    .lex "$/", param_596
.annotate 'line', 126
    find_lex $P597, "$/"
    find_lex $P598, "$/"
    unless_null $P598, vivify_294
    $P598 = root_new ['parrot';'Hash']
  vivify_294:
    set $P599, $P598["blockoid"]
    unless_null $P599, vivify_295
    new $P599, "Undef"
  vivify_295:
    $P600 = $P599."ast"()
    $P601 = $P597."!make"($P600)
.annotate 'line', 125
    .return ($P601)
.end


.namespace ["NQP";"Actions"]
.sub "block"  :subid("37_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_603
    .param pmc param_604
.annotate 'line', 129
    .lex "self", param_603
    .lex "$/", param_604
.annotate 'line', 130
    find_lex $P605, "$/"
    find_lex $P606, "$/"
    unless_null $P606, vivify_296
    $P606 = root_new ['parrot';'Hash']
  vivify_296:
    set $P607, $P606["blockoid"]
    unless_null $P607, vivify_297
    new $P607, "Undef"
  vivify_297:
    $P608 = $P607."ast"()
    $P609 = $P605."!make"($P608)
.annotate 'line', 129
    .return ($P609)
.end


.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("38_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_611
    .param pmc param_612
.annotate 'line', 133
    .lex "self", param_611
    .lex "$/", param_612
.annotate 'line', 134
    new $P613, "Undef"
    .lex "$past", $P613
.annotate 'line', 135
    new $P614, "Undef"
    .lex "$BLOCK", $P614
.annotate 'line', 134
    find_lex $P615, "$/"
    unless_null $P615, vivify_298
    $P615 = root_new ['parrot';'Hash']
  vivify_298:
    set $P616, $P615["statementlist"]
    unless_null $P616, vivify_299
    new $P616, "Undef"
  vivify_299:
    $P617 = $P616."ast"()
    store_lex "$past", $P617
.annotate 'line', 135
    get_global $P618, "@BLOCK"
    $P619 = $P618."shift"()
    store_lex "$BLOCK", $P619
.annotate 'line', 136
    find_lex $P620, "$BLOCK"
    find_lex $P621, "$past"
    $P620."push"($P621)
.annotate 'line', 137
    find_lex $P622, "$BLOCK"
    find_lex $P623, "$/"
    $P622."node"($P623)
.annotate 'line', 138
    find_lex $P624, "$BLOCK"
    $P624."closure"(1)
.annotate 'line', 139
    find_lex $P625, "$/"
    find_lex $P626, "$BLOCK"
    $P627 = $P625."!make"($P626)
.annotate 'line', 133
    .return ($P627)
.end


.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("39_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_629
    .param pmc param_630
.annotate 'line', 142
    .lex "self", param_629
    .lex "$/", param_630
.annotate 'line', 143
    get_global $P631, "@BLOCK"
    unless_null $P631, vivify_300
    $P631 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P631
  vivify_300:
.annotate 'line', 142
    get_global $P632, "@BLOCK"
.annotate 'line', 144
    get_global $P633, "@BLOCK"
    get_hll_global $P634, ["PAST"], "Block"
    get_hll_global $P635, ["PAST"], "Stmts"
    $P636 = $P635."new"()
    $P637 = $P634."new"($P636)
    $P638 = $P633."unshift"($P637)
.annotate 'line', 142
    .return ($P638)
.end


.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("40_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_640
    .param pmc param_641
.annotate 'line', 147
    .lex "self", param_640
    .lex "$/", param_641
.annotate 'line', 148
    get_global $P642, "@BLOCK"
    unless_null $P642, vivify_301
    $P642 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P642
  vivify_301:
.annotate 'line', 147
    get_global $P643, "@BLOCK"
.annotate 'line', 149
    find_lex $P644, "self"
    get_global $P645, "@BLOCK"
    unless_null $P645, vivify_302
    $P645 = root_new ['parrot';'ResizablePMCArray']
  vivify_302:
    set $P646, $P645[0]
    unless_null $P646, vivify_303
    new $P646, "Undef"
  vivify_303:
    $P647 = $P644."SET_BLOCK_OUTER_CTX"($P646)
.annotate 'line', 147
    .return ($P647)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("41_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_649
    .param pmc param_650
.annotate 'line', 154
    .const 'Sub' $P678 = "42_1296306531.71605" 
    capture_lex $P678
    .lex "self", param_649
    .lex "$/", param_650
.annotate 'line', 155
    new $P651, "Undef"
    .lex "$count", $P651
.annotate 'line', 156
    new $P652, "Undef"
    .lex "$past", $P652
.annotate 'line', 155
    find_lex $P653, "$/"
    unless_null $P653, vivify_304
    $P653 = root_new ['parrot';'Hash']
  vivify_304:
    set $P654, $P653["xblock"]
    unless_null $P654, vivify_305
    new $P654, "Undef"
  vivify_305:
    set $N655, $P654
    new $P656, 'Float'
    set $P656, $N655
    sub $P657, $P656, 1
    store_lex "$count", $P657
.annotate 'line', 156
    find_lex $P658, "$count"
    set $I659, $P658
    find_lex $P660, "$/"
    unless_null $P660, vivify_306
    $P660 = root_new ['parrot';'Hash']
  vivify_306:
    set $P661, $P660["xblock"]
    unless_null $P661, vivify_307
    $P661 = root_new ['parrot';'ResizablePMCArray']
  vivify_307:
    set $P662, $P661[$I659]
    unless_null $P662, vivify_308
    new $P662, "Undef"
  vivify_308:
    $P663 = $P662."ast"()
    $P664 = "xblock_immediate"($P663)
    store_lex "$past", $P664
.annotate 'line', 157
    find_lex $P666, "$/"
    unless_null $P666, vivify_309
    $P666 = root_new ['parrot';'Hash']
  vivify_309:
    set $P667, $P666["else"]
    unless_null $P667, vivify_310
    new $P667, "Undef"
  vivify_310:
    unless $P667, if_665_end
.annotate 'line', 158
    find_lex $P668, "$past"
    find_lex $P669, "$/"
    unless_null $P669, vivify_311
    $P669 = root_new ['parrot';'Hash']
  vivify_311:
    set $P670, $P669["else"]
    unless_null $P670, vivify_312
    $P670 = root_new ['parrot';'ResizablePMCArray']
  vivify_312:
    set $P671, $P670[0]
    unless_null $P671, vivify_313
    new $P671, "Undef"
  vivify_313:
    $P672 = $P671."ast"()
    $P673 = "block_immediate"($P672)
    $P668."push"($P673)
  if_665_end:
.annotate 'line', 161
    new $P694, 'ExceptionHandler'
    set_addr $P694, loop693_handler
    $P694."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P694
  loop693_test:
    find_lex $P674, "$count"
    set $N675, $P674
    isgt $I676, $N675, 0.0
    unless $I676, loop693_done
  loop693_redo:
    .const 'Sub' $P678 = "42_1296306531.71605" 
    capture_lex $P678
    $P678()
  loop693_next:
    goto loop693_test
  loop693_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P695, exception, 'type'
    eq $P695, .CONTROL_LOOP_NEXT, loop693_next
    eq $P695, .CONTROL_LOOP_REDO, loop693_redo
  loop693_done:
    pop_eh 
.annotate 'line', 167
    find_lex $P696, "$/"
    find_lex $P697, "$past"
    $P698 = $P696."!make"($P697)
.annotate 'line', 154
    .return ($P698)
.end


.namespace ["NQP";"Actions"]
.sub "_block677"  :anon :subid("42_1296306531.71605") :outer("41_1296306531.71605")
.annotate 'line', 163
    new $P679, "Undef"
    .lex "$else", $P679
.annotate 'line', 161
    find_lex $P680, "$count"
    clone $P681, $P680
    dec $P680
.annotate 'line', 163
    find_lex $P682, "$past"
    store_lex "$else", $P682
.annotate 'line', 164
    find_lex $P683, "$count"
    set $I684, $P683
    find_lex $P685, "$/"
    unless_null $P685, vivify_314
    $P685 = root_new ['parrot';'Hash']
  vivify_314:
    set $P686, $P685["xblock"]
    unless_null $P686, vivify_315
    $P686 = root_new ['parrot';'ResizablePMCArray']
  vivify_315:
    set $P687, $P686[$I684]
    unless_null $P687, vivify_316
    new $P687, "Undef"
  vivify_316:
    $P688 = $P687."ast"()
    $P689 = "xblock_immediate"($P688)
    store_lex "$past", $P689
.annotate 'line', 165
    find_lex $P690, "$past"
    find_lex $P691, "$else"
    $P692 = $P690."push"($P691)
.annotate 'line', 161
    .return ($P692)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("43_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_700
    .param pmc param_701
.annotate 'line', 170
    .lex "self", param_700
    .lex "$/", param_701
.annotate 'line', 171
    new $P702, "Undef"
    .lex "$past", $P702
    find_lex $P703, "$/"
    unless_null $P703, vivify_317
    $P703 = root_new ['parrot';'Hash']
  vivify_317:
    set $P704, $P703["xblock"]
    unless_null $P704, vivify_318
    new $P704, "Undef"
  vivify_318:
    $P705 = $P704."ast"()
    $P706 = "xblock_immediate"($P705)
    store_lex "$past", $P706
.annotate 'line', 172
    find_lex $P707, "$past"
    $P707."pasttype"("unless")
.annotate 'line', 173
    find_lex $P708, "$/"
    find_lex $P709, "$past"
    $P710 = $P708."!make"($P709)
.annotate 'line', 170
    .return ($P710)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("44_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_712
    .param pmc param_713
.annotate 'line', 176
    .lex "self", param_712
    .lex "$/", param_713
.annotate 'line', 177
    new $P714, "Undef"
    .lex "$past", $P714
    find_lex $P715, "$/"
    unless_null $P715, vivify_319
    $P715 = root_new ['parrot';'Hash']
  vivify_319:
    set $P716, $P715["xblock"]
    unless_null $P716, vivify_320
    new $P716, "Undef"
  vivify_320:
    $P717 = $P716."ast"()
    $P718 = "xblock_immediate"($P717)
    store_lex "$past", $P718
.annotate 'line', 178
    find_lex $P719, "$past"
    find_lex $P720, "$/"
    unless_null $P720, vivify_321
    $P720 = root_new ['parrot';'Hash']
  vivify_321:
    set $P721, $P720["sym"]
    unless_null $P721, vivify_322
    new $P721, "Undef"
  vivify_322:
    set $S722, $P721
    $P719."pasttype"($S722)
.annotate 'line', 179
    find_lex $P723, "$/"
    find_lex $P724, "$past"
    $P725 = $P723."!make"($P724)
.annotate 'line', 176
    .return ($P725)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("45_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_727
    .param pmc param_728
.annotate 'line', 182
    .lex "self", param_727
    .lex "$/", param_728
.annotate 'line', 183
    new $P729, "Undef"
    .lex "$pasttype", $P729
.annotate 'line', 184
    new $P730, "Undef"
    .lex "$past", $P730
.annotate 'line', 183
    new $P731, "String"
    assign $P731, "repeat_"
    find_lex $P732, "$/"
    unless_null $P732, vivify_323
    $P732 = root_new ['parrot';'Hash']
  vivify_323:
    set $P733, $P732["wu"]
    unless_null $P733, vivify_324
    new $P733, "Undef"
  vivify_324:
    set $S734, $P733
    concat $P735, $P731, $S734
    store_lex "$pasttype", $P735
    find_lex $P736, "$past"
.annotate 'line', 185
    find_lex $P738, "$/"
    unless_null $P738, vivify_325
    $P738 = root_new ['parrot';'Hash']
  vivify_325:
    set $P739, $P738["xblock"]
    unless_null $P739, vivify_326
    new $P739, "Undef"
  vivify_326:
    if $P739, if_737
.annotate 'line', 190
    get_hll_global $P746, ["PAST"], "Op"
    find_lex $P747, "$/"
    unless_null $P747, vivify_327
    $P747 = root_new ['parrot';'Hash']
  vivify_327:
    set $P748, $P747["EXPR"]
    unless_null $P748, vivify_328
    new $P748, "Undef"
  vivify_328:
    $P749 = $P748."ast"()
    find_lex $P750, "$/"
    unless_null $P750, vivify_329
    $P750 = root_new ['parrot';'Hash']
  vivify_329:
    set $P751, $P750["pblock"]
    unless_null $P751, vivify_330
    new $P751, "Undef"
  vivify_330:
    $P752 = $P751."ast"()
    $P753 = "block_immediate"($P752)
    find_lex $P754, "$pasttype"
    find_lex $P755, "$/"
    $P756 = $P746."new"($P749, $P753, $P754 :named("pasttype"), $P755 :named("node"))
    store_lex "$past", $P756
.annotate 'line', 189
    goto if_737_end
  if_737:
.annotate 'line', 186
    find_lex $P740, "$/"
    unless_null $P740, vivify_331
    $P740 = root_new ['parrot';'Hash']
  vivify_331:
    set $P741, $P740["xblock"]
    unless_null $P741, vivify_332
    new $P741, "Undef"
  vivify_332:
    $P742 = $P741."ast"()
    $P743 = "xblock_immediate"($P742)
    store_lex "$past", $P743
.annotate 'line', 187
    find_lex $P744, "$past"
    find_lex $P745, "$pasttype"
    $P744."pasttype"($P745)
  if_737_end:
.annotate 'line', 193
    find_lex $P757, "$/"
    find_lex $P758, "$past"
    $P759 = $P757."!make"($P758)
.annotate 'line', 182
    .return ($P759)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("46_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_761
    .param pmc param_762
.annotate 'line', 196
    .lex "self", param_761
    .lex "$/", param_762
.annotate 'line', 197
    new $P763, "Undef"
    .lex "$past", $P763
.annotate 'line', 199
    new $P764, "Undef"
    .lex "$block", $P764
.annotate 'line', 197
    find_lex $P765, "$/"
    unless_null $P765, vivify_333
    $P765 = root_new ['parrot';'Hash']
  vivify_333:
    set $P766, $P765["xblock"]
    unless_null $P766, vivify_334
    new $P766, "Undef"
  vivify_334:
    $P767 = $P766."ast"()
    store_lex "$past", $P767
.annotate 'line', 198
    find_lex $P768, "$past"
    $P768."pasttype"("for")
.annotate 'line', 199
    find_lex $P769, "$past"
    unless_null $P769, vivify_335
    $P769 = root_new ['parrot';'ResizablePMCArray']
  vivify_335:
    set $P770, $P769[1]
    unless_null $P770, vivify_336
    new $P770, "Undef"
  vivify_336:
    store_lex "$block", $P770
.annotate 'line', 200
    find_lex $P772, "$block"
    $P773 = $P772."arity"()
    if $P773, unless_771_end
.annotate 'line', 201
    find_lex $P774, "$block"
    unless_null $P774, vivify_337
    $P774 = root_new ['parrot';'ResizablePMCArray']
  vivify_337:
    set $P775, $P774[0]
    unless_null $P775, vivify_338
    new $P775, "Undef"
  vivify_338:
    get_hll_global $P776, ["PAST"], "Var"
    $P777 = $P776."new"("$_" :named("name"), "parameter" :named("scope"))
    $P775."push"($P777)
.annotate 'line', 202
    find_lex $P778, "$block"
    $P778."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 203
    find_lex $P779, "$block"
    $P779."arity"(1)
  unless_771_end:
.annotate 'line', 205
    find_lex $P780, "$block"
    $P780."blocktype"("immediate")
.annotate 'line', 206
    find_lex $P781, "$/"
    find_lex $P782, "$past"
    $P783 = $P781."!make"($P782)
.annotate 'line', 196
    .return ($P783)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("47_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_785
    .param pmc param_786
.annotate 'line', 209
    .lex "self", param_785
    .lex "$/", param_786
.annotate 'line', 210
    new $P787, "Undef"
    .lex "$block", $P787
    find_lex $P788, "$/"
    unless_null $P788, vivify_339
    $P788 = root_new ['parrot';'Hash']
  vivify_339:
    set $P789, $P788["block"]
    unless_null $P789, vivify_340
    new $P789, "Undef"
  vivify_340:
    $P790 = $P789."ast"()
    store_lex "$block", $P790
.annotate 'line', 211
    find_lex $P791, "$/"
    find_lex $P792, "$block"
    "push_block_handler"($P791, $P792)
.annotate 'line', 212
    get_global $P793, "@BLOCK"
    unless_null $P793, vivify_341
    $P793 = root_new ['parrot';'ResizablePMCArray']
  vivify_341:
    set $P794, $P793[0]
    unless_null $P794, vivify_342
    new $P794, "Undef"
  vivify_342:
    $P795 = $P794."handlers"()
    set $P796, $P795[0]
    unless_null $P796, vivify_343
    new $P796, "Undef"
  vivify_343:
    $P796."handle_types_except"("CONTROL")
.annotate 'line', 213
    find_lex $P797, "$/"
    get_hll_global $P798, ["PAST"], "Stmts"
    find_lex $P799, "$/"
    $P800 = $P798."new"($P799 :named("node"))
    $P801 = $P797."!make"($P800)
.annotate 'line', 209
    .return ($P801)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("48_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_803
    .param pmc param_804
.annotate 'line', 216
    .lex "self", param_803
    .lex "$/", param_804
.annotate 'line', 217
    new $P805, "Undef"
    .lex "$block", $P805
    find_lex $P806, "$/"
    unless_null $P806, vivify_344
    $P806 = root_new ['parrot';'Hash']
  vivify_344:
    set $P807, $P806["block"]
    unless_null $P807, vivify_345
    new $P807, "Undef"
  vivify_345:
    $P808 = $P807."ast"()
    store_lex "$block", $P808
.annotate 'line', 218
    find_lex $P809, "$/"
    find_lex $P810, "$block"
    "push_block_handler"($P809, $P810)
.annotate 'line', 219
    get_global $P811, "@BLOCK"
    unless_null $P811, vivify_346
    $P811 = root_new ['parrot';'ResizablePMCArray']
  vivify_346:
    set $P812, $P811[0]
    unless_null $P812, vivify_347
    new $P812, "Undef"
  vivify_347:
    $P813 = $P812."handlers"()
    set $P814, $P813[0]
    unless_null $P814, vivify_348
    new $P814, "Undef"
  vivify_348:
    $P814."handle_types"("CONTROL")
.annotate 'line', 220
    find_lex $P815, "$/"
    get_hll_global $P816, ["PAST"], "Stmts"
    find_lex $P817, "$/"
    $P818 = $P816."new"($P817 :named("node"))
    $P819 = $P815."!make"($P818)
.annotate 'line', 216
    .return ($P819)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("49_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_822
    .param pmc param_823
.annotate 'line', 260
    .lex "self", param_822
    .lex "$/", param_823
.annotate 'line', 261
    new $P824, "Undef"
    .lex "$init_block", $P824
    get_hll_global $P825, ["PAST"], "Block"
    $P826 = $P825."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P826
.annotate 'line', 262
    find_lex $P827, "$init_block"
    $P828 = $P827."loadinit"()
    find_lex $P829, "$/"
    unless_null $P829, vivify_349
    $P829 = root_new ['parrot';'Hash']
  vivify_349:
    set $P830, $P829["blorst"]
    unless_null $P830, vivify_350
    new $P830, "Undef"
  vivify_350:
    $P831 = $P830."ast"()
    $P828."push"($P831)
.annotate 'line', 263
    find_lex $P832, "$/"
    find_lex $P833, "$init_block"
    $P834 = $P832."!make"($P833)
.annotate 'line', 260
    .return ($P834)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("50_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_836
    .param pmc param_837
.annotate 'line', 266
    .lex "self", param_836
    .lex "$/", param_837
.annotate 'line', 267
    new $P838, "Undef"
    .lex "$past", $P838
    find_lex $P839, "$/"
    unless_null $P839, vivify_351
    $P839 = root_new ['parrot';'Hash']
  vivify_351:
    set $P840, $P839["blorst"]
    unless_null $P840, vivify_352
    new $P840, "Undef"
  vivify_352:
    $P841 = $P840."ast"()
    store_lex "$past", $P841
.annotate 'line', 268
    get_hll_global $P843, ["PAST"], "Block"
    find_lex $P844, "$past"
    $P845 = $P843."ACCEPTS"($P844)
    if $P845, unless_842_end
.annotate 'line', 269
    get_hll_global $P846, ["PAST"], "Block"
    find_lex $P847, "$past"
    find_lex $P848, "$/"
    $P849 = $P846."new"($P847, "immediate" :named("blocktype"), $P848 :named("node"))
    store_lex "$past", $P849
  unless_842_end:
.annotate 'line', 271
    find_lex $P851, "$past"
    $P852 = $P851."handlers"()
    if $P852, unless_850_end
.annotate 'line', 272
    find_lex $P853, "$past"
    get_hll_global $P854, ["PAST"], "Control"
.annotate 'line', 274
    get_hll_global $P855, ["PAST"], "Stmts"
.annotate 'line', 275
    get_hll_global $P856, ["PAST"], "Op"
.annotate 'line', 276
    get_hll_global $P857, ["PAST"], "Var"
.annotate 'line', 277
    get_hll_global $P858, ["PAST"], "Var"
    $P859 = $P858."new"("register" :named("scope"), "exception" :named("name"))
    $P860 = $P857."new"($P859, "handled", "keyed" :named("scope"))
.annotate 'line', 276
    $P861 = $P856."new"($P860, 1, "bind" :named("pasttype"))
.annotate 'line', 275
    $P862 = $P855."new"($P861)
.annotate 'line', 274
    $P863 = $P854."new"($P862, "CONTROL" :named("handle_types_except"))
.annotate 'line', 272
    new $P864, "ResizablePMCArray"
    push $P864, $P863
    $P853."handlers"($P864)
  unless_850_end:
.annotate 'line', 286
    find_lex $P865, "$/"
    find_lex $P866, "$past"
    $P867 = $P865."!make"($P866)
.annotate 'line', 266
    .return ($P867)
.end


.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("51_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_869
    .param pmc param_870
.annotate 'line', 289
    .lex "self", param_869
    .lex "$/", param_870
.annotate 'line', 290
    find_lex $P871, "$/"
.annotate 'line', 291
    find_lex $P874, "$/"
    unless_null $P874, vivify_353
    $P874 = root_new ['parrot';'Hash']
  vivify_353:
    set $P875, $P874["block"]
    unless_null $P875, vivify_354
    new $P875, "Undef"
  vivify_354:
    if $P875, if_873
.annotate 'line', 292
    find_lex $P880, "$/"
    unless_null $P880, vivify_355
    $P880 = root_new ['parrot';'Hash']
  vivify_355:
    set $P881, $P880["statement"]
    unless_null $P881, vivify_356
    new $P881, "Undef"
  vivify_356:
    $P882 = $P881."ast"()
    set $P872, $P882
.annotate 'line', 291
    goto if_873_end
  if_873:
    find_lex $P876, "$/"
    unless_null $P876, vivify_357
    $P876 = root_new ['parrot';'Hash']
  vivify_357:
    set $P877, $P876["block"]
    unless_null $P877, vivify_358
    new $P877, "Undef"
  vivify_358:
    $P878 = $P877."ast"()
    $P879 = "block_immediate"($P878)
    set $P872, $P879
  if_873_end:
    $P883 = $P871."!make"($P872)
.annotate 'line', 289
    .return ($P883)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("52_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_885
    .param pmc param_886
.annotate 'line', 297
    .lex "self", param_885
    .lex "$/", param_886
    find_lex $P887, "$/"
    find_lex $P888, "$/"
    unless_null $P888, vivify_359
    $P888 = root_new ['parrot';'Hash']
  vivify_359:
    set $P889, $P888["cond"]
    unless_null $P889, vivify_360
    new $P889, "Undef"
  vivify_360:
    $P890 = $P889."ast"()
    $P891 = $P887."!make"($P890)
    .return ($P891)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("53_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_893
    .param pmc param_894
.annotate 'line', 298
    .lex "self", param_893
    .lex "$/", param_894
    find_lex $P895, "$/"
    find_lex $P896, "$/"
    unless_null $P896, vivify_361
    $P896 = root_new ['parrot';'Hash']
  vivify_361:
    set $P897, $P896["cond"]
    unless_null $P897, vivify_362
    new $P897, "Undef"
  vivify_362:
    $P898 = $P897."ast"()
    $P899 = $P895."!make"($P898)
    .return ($P899)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("54_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_901
    .param pmc param_902
.annotate 'line', 300
    .lex "self", param_901
    .lex "$/", param_902
    find_lex $P903, "$/"
    find_lex $P904, "$/"
    unless_null $P904, vivify_363
    $P904 = root_new ['parrot';'Hash']
  vivify_363:
    set $P905, $P904["cond"]
    unless_null $P905, vivify_364
    new $P905, "Undef"
  vivify_364:
    $P906 = $P905."ast"()
    $P907 = $P903."!make"($P906)
    .return ($P907)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("55_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_909
    .param pmc param_910
.annotate 'line', 301
    .lex "self", param_909
    .lex "$/", param_910
    find_lex $P911, "$/"
    find_lex $P912, "$/"
    unless_null $P912, vivify_365
    $P912 = root_new ['parrot';'Hash']
  vivify_365:
    set $P913, $P912["cond"]
    unless_null $P913, vivify_366
    new $P913, "Undef"
  vivify_366:
    $P914 = $P913."ast"()
    $P915 = $P911."!make"($P914)
    .return ($P915)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("56_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_917
    .param pmc param_918
.annotate 'line', 305
    .lex "self", param_917
    .lex "$/", param_918
    find_lex $P919, "$/"
    find_lex $P920, "$/"
    unless_null $P920, vivify_367
    $P920 = root_new ['parrot';'Hash']
  vivify_367:
    set $P921, $P920["fatarrow"]
    unless_null $P921, vivify_368
    new $P921, "Undef"
  vivify_368:
    $P922 = $P921."ast"()
    $P923 = $P919."!make"($P922)
    .return ($P923)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("57_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_925
    .param pmc param_926
.annotate 'line', 306
    .lex "self", param_925
    .lex "$/", param_926
    find_lex $P927, "$/"
    find_lex $P928, "$/"
    unless_null $P928, vivify_369
    $P928 = root_new ['parrot';'Hash']
  vivify_369:
    set $P929, $P928["colonpair"]
    unless_null $P929, vivify_370
    new $P929, "Undef"
  vivify_370:
    $P930 = $P929."ast"()
    $P931 = $P927."!make"($P930)
    .return ($P931)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("58_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_933
    .param pmc param_934
.annotate 'line', 307
    .lex "self", param_933
    .lex "$/", param_934
    find_lex $P935, "$/"
    find_lex $P936, "$/"
    unless_null $P936, vivify_371
    $P936 = root_new ['parrot';'Hash']
  vivify_371:
    set $P937, $P936["variable"]
    unless_null $P937, vivify_372
    new $P937, "Undef"
  vivify_372:
    $P938 = $P937."ast"()
    $P939 = $P935."!make"($P938)
    .return ($P939)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("59_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_941
    .param pmc param_942
.annotate 'line', 308
    .lex "self", param_941
    .lex "$/", param_942
    find_lex $P943, "$/"
    find_lex $P944, "$/"
    unless_null $P944, vivify_373
    $P944 = root_new ['parrot';'Hash']
  vivify_373:
    set $P945, $P944["package_declarator"]
    unless_null $P945, vivify_374
    new $P945, "Undef"
  vivify_374:
    $P946 = $P945."ast"()
    $P947 = $P943."!make"($P946)
    .return ($P947)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("60_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_949
    .param pmc param_950
.annotate 'line', 309
    .lex "self", param_949
    .lex "$/", param_950
    find_lex $P951, "$/"
    find_lex $P952, "$/"
    unless_null $P952, vivify_375
    $P952 = root_new ['parrot';'Hash']
  vivify_375:
    set $P953, $P952["scope_declarator"]
    unless_null $P953, vivify_376
    new $P953, "Undef"
  vivify_376:
    $P954 = $P953."ast"()
    $P955 = $P951."!make"($P954)
    .return ($P955)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("61_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_957
    .param pmc param_958
.annotate 'line', 310
    .lex "self", param_957
    .lex "$/", param_958
    find_lex $P959, "$/"
    find_lex $P960, "$/"
    unless_null $P960, vivify_377
    $P960 = root_new ['parrot';'Hash']
  vivify_377:
    set $P961, $P960["routine_declarator"]
    unless_null $P961, vivify_378
    new $P961, "Undef"
  vivify_378:
    $P962 = $P961."ast"()
    $P963 = $P959."!make"($P962)
    .return ($P963)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("62_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_965
    .param pmc param_966
.annotate 'line', 311
    .lex "self", param_965
    .lex "$/", param_966
    find_lex $P967, "$/"
    find_lex $P968, "$/"
    unless_null $P968, vivify_379
    $P968 = root_new ['parrot';'Hash']
  vivify_379:
    set $P969, $P968["regex_declarator"]
    unless_null $P969, vivify_380
    new $P969, "Undef"
  vivify_380:
    $P970 = $P969."ast"()
    $P971 = $P967."!make"($P970)
    .return ($P971)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("63_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_973
    .param pmc param_974
.annotate 'line', 312
    .lex "self", param_973
    .lex "$/", param_974
    find_lex $P975, "$/"
    find_lex $P976, "$/"
    unless_null $P976, vivify_381
    $P976 = root_new ['parrot';'Hash']
  vivify_381:
    set $P977, $P976["statement_prefix"]
    unless_null $P977, vivify_382
    new $P977, "Undef"
  vivify_382:
    $P978 = $P977."ast"()
    $P979 = $P975."!make"($P978)
    .return ($P979)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("64_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_981
    .param pmc param_982
.annotate 'line', 313
    .lex "self", param_981
    .lex "$/", param_982
    find_lex $P983, "$/"
    find_lex $P984, "$/"
    unless_null $P984, vivify_383
    $P984 = root_new ['parrot';'Hash']
  vivify_383:
    set $P985, $P984["pblock"]
    unless_null $P985, vivify_384
    new $P985, "Undef"
  vivify_384:
    $P986 = $P985."ast"()
    $P987 = $P983."!make"($P986)
    .return ($P987)
.end


.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("65_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_989
    .param pmc param_990
.annotate 'line', 315
    .lex "self", param_989
    .lex "$/", param_990
.annotate 'line', 316
    new $P991, "Undef"
    .lex "$past", $P991
    find_lex $P992, "$/"
    unless_null $P992, vivify_385
    $P992 = root_new ['parrot';'Hash']
  vivify_385:
    set $P993, $P992["val"]
    unless_null $P993, vivify_386
    new $P993, "Undef"
  vivify_386:
    $P994 = $P993."ast"()
    store_lex "$past", $P994
.annotate 'line', 317
    find_lex $P995, "$past"
    find_lex $P996, "$/"
    unless_null $P996, vivify_387
    $P996 = root_new ['parrot';'Hash']
  vivify_387:
    set $P997, $P996["key"]
    unless_null $P997, vivify_388
    new $P997, "Undef"
  vivify_388:
    $P998 = $P997."Str"()
    $P995."named"($P998)
.annotate 'line', 318
    find_lex $P999, "$/"
    find_lex $P1000, "$past"
    $P1001 = $P999."!make"($P1000)
.annotate 'line', 315
    .return ($P1001)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("66_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1003
    .param pmc param_1004
.annotate 'line', 321
    .lex "self", param_1003
    .lex "$/", param_1004
.annotate 'line', 322
    new $P1005, "Undef"
    .lex "$past", $P1005
.annotate 'line', 323
    find_lex $P1008, "$/"
    unless_null $P1008, vivify_389
    $P1008 = root_new ['parrot';'Hash']
  vivify_389:
    set $P1009, $P1008["circumfix"]
    unless_null $P1009, vivify_390
    new $P1009, "Undef"
  vivify_390:
    if $P1009, if_1007
.annotate 'line', 324
    get_hll_global $P1014, ["PAST"], "Val"
    find_lex $P1015, "$/"
    unless_null $P1015, vivify_391
    $P1015 = root_new ['parrot';'Hash']
  vivify_391:
    set $P1016, $P1015["not"]
    unless_null $P1016, vivify_392
    new $P1016, "Undef"
  vivify_392:
    isfalse $I1017, $P1016
    $P1018 = $P1014."new"($I1017 :named("value"))
    set $P1006, $P1018
.annotate 'line', 323
    goto if_1007_end
  if_1007:
    find_lex $P1010, "$/"
    unless_null $P1010, vivify_393
    $P1010 = root_new ['parrot';'Hash']
  vivify_393:
    set $P1011, $P1010["circumfix"]
    unless_null $P1011, vivify_394
    $P1011 = root_new ['parrot';'ResizablePMCArray']
  vivify_394:
    set $P1012, $P1011[0]
    unless_null $P1012, vivify_395
    new $P1012, "Undef"
  vivify_395:
    $P1013 = $P1012."ast"()
    set $P1006, $P1013
  if_1007_end:
    store_lex "$past", $P1006
.annotate 'line', 325
    find_lex $P1019, "$past"
    find_lex $P1020, "$/"
    unless_null $P1020, vivify_396
    $P1020 = root_new ['parrot';'Hash']
  vivify_396:
    set $P1021, $P1020["identifier"]
    unless_null $P1021, vivify_397
    new $P1021, "Undef"
  vivify_397:
    set $S1022, $P1021
    $P1019."named"($S1022)
.annotate 'line', 326
    find_lex $P1023, "$/"
    find_lex $P1024, "$past"
    $P1025 = $P1023."!make"($P1024)
.annotate 'line', 321
    .return ($P1025)
.end


.namespace ["NQP";"Actions"]
.sub "variable"  :subid("67_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1027
    .param pmc param_1028
.annotate 'line', 329
    .const 'Sub' $P1041 = "68_1296306531.71605" 
    capture_lex $P1041
    .lex "self", param_1027
    .lex "$/", param_1028
.annotate 'line', 330
    new $P1029, "Undef"
    .lex "$past", $P1029
.annotate 'line', 329
    find_lex $P1030, "$past"
.annotate 'line', 331
    find_lex $P1032, "$/"
    unless_null $P1032, vivify_398
    $P1032 = root_new ['parrot';'Hash']
  vivify_398:
    set $P1033, $P1032["postcircumfix"]
    unless_null $P1033, vivify_399
    new $P1033, "Undef"
  vivify_399:
    if $P1033, if_1031
.annotate 'line', 335
    .const 'Sub' $P1041 = "68_1296306531.71605" 
    capture_lex $P1041
    $P1041()
    goto if_1031_end
  if_1031:
.annotate 'line', 332
    find_lex $P1034, "$/"
    unless_null $P1034, vivify_416
    $P1034 = root_new ['parrot';'Hash']
  vivify_416:
    set $P1035, $P1034["postcircumfix"]
    unless_null $P1035, vivify_417
    new $P1035, "Undef"
  vivify_417:
    $P1036 = $P1035."ast"()
    store_lex "$past", $P1036
.annotate 'line', 333
    find_lex $P1037, "$past"
    get_hll_global $P1038, ["PAST"], "Var"
    $P1039 = $P1038."new"("$/" :named("name"))
    $P1037."unshift"($P1039)
  if_1031_end:
.annotate 'line', 365
    find_lex $P1113, "$/"
    find_lex $P1114, "$past"
    $P1115 = $P1113."!make"($P1114)
.annotate 'line', 329
    .return ($P1115)
.end


.namespace ["NQP";"Actions"]
.sub "_block1040"  :anon :subid("68_1296306531.71605") :outer("67_1296306531.71605")
.annotate 'line', 336
    $P1042 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P1042
    get_hll_global $P1043, ["NQP"], "Compiler"
    find_lex $P1044, "$/"
    set $S1045, $P1044
    $P1046 = $P1043."parse_name"($S1045)
    store_lex "@name", $P1046
.annotate 'line', 337
    get_hll_global $P1047, ["PAST"], "Var"
    find_lex $P1048, "@name"
    $P1049 = $P1048."pop"()
    set $S1050, $P1049
    $P1051 = $P1047."new"($S1050 :named("name"))
    store_lex "$past", $P1051
.annotate 'line', 338
    find_lex $P1053, "@name"
    unless $P1053, if_1052_end
.annotate 'line', 339
    find_lex $P1055, "@name"
    unless_null $P1055, vivify_400
    $P1055 = root_new ['parrot';'ResizablePMCArray']
  vivify_400:
    set $P1056, $P1055[0]
    unless_null $P1056, vivify_401
    new $P1056, "Undef"
  vivify_401:
    set $S1057, $P1056
    iseq $I1058, $S1057, "GLOBAL"
    unless $I1058, if_1054_end
    find_lex $P1059, "@name"
    $P1059."shift"()
  if_1054_end:
.annotate 'line', 340
    find_lex $P1060, "$past"
    find_lex $P1061, "@name"
    $P1060."namespace"($P1061)
.annotate 'line', 341
    find_lex $P1062, "$past"
    $P1062."scope"("package")
.annotate 'line', 342
    find_lex $P1063, "$past"
    find_lex $P1064, "$/"
    unless_null $P1064, vivify_402
    $P1064 = root_new ['parrot';'Hash']
  vivify_402:
    set $P1065, $P1064["sigil"]
    unless_null $P1065, vivify_403
    new $P1065, "Undef"
  vivify_403:
    $P1066 = "vivitype"($P1065)
    $P1063."viviself"($P1066)
.annotate 'line', 343
    find_lex $P1067, "$past"
    $P1067."lvalue"(1)
  if_1052_end:
.annotate 'line', 345
    find_lex $P1070, "$/"
    unless_null $P1070, vivify_404
    $P1070 = root_new ['parrot';'Hash']
  vivify_404:
    set $P1071, $P1070["twigil"]
    unless_null $P1071, vivify_405
    $P1071 = root_new ['parrot';'ResizablePMCArray']
  vivify_405:
    set $P1072, $P1071[0]
    unless_null $P1072, vivify_406
    new $P1072, "Undef"
  vivify_406:
    set $S1073, $P1072
    iseq $I1074, $S1073, "*"
    if $I1074, if_1069
.annotate 'line', 358
    find_lex $P1096, "$/"
    unless_null $P1096, vivify_407
    $P1096 = root_new ['parrot';'Hash']
  vivify_407:
    set $P1097, $P1096["twigil"]
    unless_null $P1097, vivify_408
    $P1097 = root_new ['parrot';'ResizablePMCArray']
  vivify_408:
    set $P1098, $P1097[0]
    unless_null $P1098, vivify_409
    new $P1098, "Undef"
  vivify_409:
    set $S1099, $P1098
    iseq $I1100, $S1099, "!"
    if $I1100, if_1095
    new $P1094, 'Integer'
    set $P1094, $I1100
    goto if_1095_end
  if_1095:
.annotate 'line', 359
    find_lex $P1101, "$past"
    get_hll_global $P1102, ["PAST"], "Var"
    $P1103 = $P1102."new"("self" :named("name"))
    $P1101."push"($P1103)
.annotate 'line', 360
    find_lex $P1104, "$past"
    $P1104."scope"("attribute")
.annotate 'line', 361
    find_lex $P1105, "$past"
    find_lex $P1106, "$/"
    unless_null $P1106, vivify_410
    $P1106 = root_new ['parrot';'Hash']
  vivify_410:
    set $P1107, $P1106["sigil"]
    unless_null $P1107, vivify_411
    new $P1107, "Undef"
  vivify_411:
    $P1108 = "vivitype"($P1107)
    $P1105."viviself"($P1108)
.annotate 'line', 362
    find_lex $P1109, "$past"
    get_hll_global $P1110, ["PAST"], "Var"
    $P1111 = $P1110."new"("$?CLASS" :named("name"))
    $P1112 = $P1109."push"($P1111)
.annotate 'line', 358
    set $P1094, $P1112
  if_1095_end:
    set $P1068, $P1094
.annotate 'line', 345
    goto if_1069_end
  if_1069:
.annotate 'line', 346
    find_lex $P1075, "$past"
    $P1075."scope"("contextual")
.annotate 'line', 347
    find_lex $P1076, "$past"
.annotate 'line', 348
    get_hll_global $P1077, ["PAST"], "Var"
.annotate 'line', 350
    find_lex $P1078, "$/"
    unless_null $P1078, vivify_412
    $P1078 = root_new ['parrot';'Hash']
  vivify_412:
    set $P1079, $P1078["sigil"]
    unless_null $P1079, vivify_413
    new $P1079, "Undef"
  vivify_413:
    set $S1080, $P1079
    new $P1081, 'String'
    set $P1081, $S1080
    find_lex $P1082, "$/"
    unless_null $P1082, vivify_414
    $P1082 = root_new ['parrot';'Hash']
  vivify_414:
    set $P1083, $P1082["desigilname"]
    unless_null $P1083, vivify_415
    new $P1083, "Undef"
  vivify_415:
    concat $P1084, $P1081, $P1083
.annotate 'line', 352
    get_hll_global $P1085, ["PAST"], "Op"
    new $P1086, "String"
    assign $P1086, "Contextual "
    find_lex $P1087, "$/"
    set $S1088, $P1087
    concat $P1089, $P1086, $S1088
    concat $P1090, $P1089, " not found"
    $P1091 = $P1085."new"($P1090, "die" :named("pirop"))
    $P1092 = $P1077."new"("package" :named("scope"), "" :named("namespace"), $P1084 :named("name"), $P1091 :named("viviself"))
.annotate 'line', 348
    $P1093 = $P1076."viviself"($P1092)
.annotate 'line', 345
    set $P1068, $P1093
  if_1069_end:
.annotate 'line', 335
    .return ($P1068)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("69_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1117
    .param pmc param_1118
.annotate 'line', 368
    .lex "self", param_1117
    .lex "$/", param_1118
    find_lex $P1119, "$/"
    find_lex $P1120, "$/"
    unless_null $P1120, vivify_418
    $P1120 = root_new ['parrot';'Hash']
  vivify_418:
    set $P1121, $P1120["package_def"]
    unless_null $P1121, vivify_419
    new $P1121, "Undef"
  vivify_419:
    $P1122 = $P1121."ast"()
    $P1123 = $P1119."!make"($P1122)
    .return ($P1123)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("70_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1125
    .param pmc param_1126
.annotate 'line', 369
    .lex "self", param_1125
    .lex "$/", param_1126
    find_lex $P1127, "$/"
    find_lex $P1128, "$/"
    $P1129 = "package"($P1128)
    $P1130 = $P1127."!make"($P1129)
    .return ($P1130)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("71_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1132
    .param pmc param_1133
.annotate 'line', 370
    .lex "self", param_1132
    .lex "$/", param_1133
    find_lex $P1134, "$/"
    find_lex $P1135, "$/"
    $P1136 = "package"($P1135)
    $P1137 = $P1134."!make"($P1136)
    .return ($P1137)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("72_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1139
    .param pmc param_1140
.annotate 'line', 371
    .lex "self", param_1139
    .lex "$/", param_1140
    find_lex $P1141, "$/"
    find_lex $P1142, "$/"
    $P1143 = "package"($P1142)
    $P1144 = $P1141."!make"($P1143)
    .return ($P1144)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("73_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1146
    .param pmc param_1147
.annotate 'line', 372
    .lex "self", param_1146
    .lex "$/", param_1147
    find_lex $P1148, "$/"
    find_lex $P1149, "$/"
    $P1150 = "package"($P1149)
    $P1151 = $P1148."!make"($P1150)
    .return ($P1151)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("74_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1153
    .param pmc param_1154
.annotate 'line', 373
    .lex "self", param_1153
    .lex "$/", param_1154
    find_lex $P1155, "$/"
    find_lex $P1156, "$/"
    $P1157 = "package"($P1156)
    $P1158 = $P1155."!make"($P1157)
    .return ($P1158)
.end


.namespace ["NQP";"Actions"]
.sub "package_def"  :subid("75_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1161
    .param pmc param_1162
.annotate 'line', 460
    .lex "self", param_1161
    .lex "$/", param_1162
.annotate 'line', 461
    new $P1163, "Undef"
    .lex "$past", $P1163
    find_lex $P1166, "$/"
    unless_null $P1166, vivify_420
    $P1166 = root_new ['parrot';'Hash']
  vivify_420:
    set $P1167, $P1166["block"]
    unless_null $P1167, vivify_421
    new $P1167, "Undef"
  vivify_421:
    if $P1167, if_1165
    find_lex $P1171, "$/"
    unless_null $P1171, vivify_422
    $P1171 = root_new ['parrot';'Hash']
  vivify_422:
    set $P1172, $P1171["comp_unit"]
    unless_null $P1172, vivify_423
    new $P1172, "Undef"
  vivify_423:
    $P1173 = $P1172."ast"()
    set $P1164, $P1173
    goto if_1165_end
  if_1165:
    find_lex $P1168, "$/"
    unless_null $P1168, vivify_424
    $P1168 = root_new ['parrot';'Hash']
  vivify_424:
    set $P1169, $P1168["block"]
    unless_null $P1169, vivify_425
    new $P1169, "Undef"
  vivify_425:
    $P1170 = $P1169."ast"()
    set $P1164, $P1170
  if_1165_end:
    store_lex "$past", $P1164
.annotate 'line', 462
    find_lex $P1174, "$past"
    find_lex $P1175, "$/"
    unless_null $P1175, vivify_426
    $P1175 = root_new ['parrot';'Hash']
  vivify_426:
    set $P1176, $P1175["name"]
    unless_null $P1176, vivify_427
    $P1176 = root_new ['parrot';'Hash']
  vivify_427:
    set $P1177, $P1176["identifier"]
    unless_null $P1177, vivify_428
    new $P1177, "Undef"
  vivify_428:
    $P1174."namespace"($P1177)
.annotate 'line', 463
    find_lex $P1178, "$past"
    $P1178."blocktype"("immediate")
.annotate 'line', 464
    find_lex $P1179, "$/"
    find_lex $P1180, "$past"
    $P1181 = $P1179."!make"($P1180)
.annotate 'line', 460
    .return ($P1181)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("76_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1183
    .param pmc param_1184
.annotate 'line', 467
    .lex "self", param_1183
    .lex "$/", param_1184
    find_lex $P1185, "$/"
    find_lex $P1186, "$/"
    unless_null $P1186, vivify_429
    $P1186 = root_new ['parrot';'Hash']
  vivify_429:
    set $P1187, $P1186["scoped"]
    unless_null $P1187, vivify_430
    new $P1187, "Undef"
  vivify_430:
    $P1188 = $P1187."ast"()
    $P1189 = $P1185."!make"($P1188)
    .return ($P1189)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("77_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1191
    .param pmc param_1192
.annotate 'line', 468
    .lex "self", param_1191
    .lex "$/", param_1192
    find_lex $P1193, "$/"
    find_lex $P1194, "$/"
    unless_null $P1194, vivify_431
    $P1194 = root_new ['parrot';'Hash']
  vivify_431:
    set $P1195, $P1194["scoped"]
    unless_null $P1195, vivify_432
    new $P1195, "Undef"
  vivify_432:
    $P1196 = $P1195."ast"()
    $P1197 = $P1193."!make"($P1196)
    .return ($P1197)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("78_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1199
    .param pmc param_1200
.annotate 'line', 469
    .lex "self", param_1199
    .lex "$/", param_1200
    find_lex $P1201, "$/"
    find_lex $P1202, "$/"
    unless_null $P1202, vivify_433
    $P1202 = root_new ['parrot';'Hash']
  vivify_433:
    set $P1203, $P1202["scoped"]
    unless_null $P1203, vivify_434
    new $P1203, "Undef"
  vivify_434:
    $P1204 = $P1203."ast"()
    $P1205 = $P1201."!make"($P1204)
    .return ($P1205)
.end


.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("79_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1207
    .param pmc param_1208
.annotate 'line', 471
    .lex "self", param_1207
    .lex "$/", param_1208
.annotate 'line', 472
    find_lex $P1209, "$/"
.annotate 'line', 473
    find_lex $P1212, "$/"
    unless_null $P1212, vivify_435
    $P1212 = root_new ['parrot';'Hash']
  vivify_435:
    set $P1213, $P1212["declarator"]
    unless_null $P1213, vivify_436
    new $P1213, "Undef"
  vivify_436:
    if $P1213, if_1211
.annotate 'line', 474
    find_lex $P1217, "$/"
    unless_null $P1217, vivify_437
    $P1217 = root_new ['parrot';'Hash']
  vivify_437:
    set $P1218, $P1217["multi_declarator"]
    unless_null $P1218, vivify_438
    new $P1218, "Undef"
  vivify_438:
    $P1219 = $P1218."ast"()
    set $P1210, $P1219
.annotate 'line', 473
    goto if_1211_end
  if_1211:
    find_lex $P1214, "$/"
    unless_null $P1214, vivify_439
    $P1214 = root_new ['parrot';'Hash']
  vivify_439:
    set $P1215, $P1214["declarator"]
    unless_null $P1215, vivify_440
    new $P1215, "Undef"
  vivify_440:
    $P1216 = $P1215."ast"()
    set $P1210, $P1216
  if_1211_end:
    $P1220 = $P1209."!make"($P1210)
.annotate 'line', 471
    .return ($P1220)
.end


.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("80_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1222
    .param pmc param_1223
.annotate 'line', 477
    .lex "self", param_1222
    .lex "$/", param_1223
.annotate 'line', 478
    find_lex $P1224, "$/"
.annotate 'line', 479
    find_lex $P1227, "$/"
    unless_null $P1227, vivify_441
    $P1227 = root_new ['parrot';'Hash']
  vivify_441:
    set $P1228, $P1227["routine_declarator"]
    unless_null $P1228, vivify_442
    new $P1228, "Undef"
  vivify_442:
    if $P1228, if_1226
.annotate 'line', 480
    find_lex $P1232, "$/"
    unless_null $P1232, vivify_443
    $P1232 = root_new ['parrot';'Hash']
  vivify_443:
    set $P1233, $P1232["variable_declarator"]
    unless_null $P1233, vivify_444
    new $P1233, "Undef"
  vivify_444:
    $P1234 = $P1233."ast"()
    set $P1225, $P1234
.annotate 'line', 479
    goto if_1226_end
  if_1226:
    find_lex $P1229, "$/"
    unless_null $P1229, vivify_445
    $P1229 = root_new ['parrot';'Hash']
  vivify_445:
    set $P1230, $P1229["routine_declarator"]
    unless_null $P1230, vivify_446
    new $P1230, "Undef"
  vivify_446:
    $P1231 = $P1230."ast"()
    set $P1225, $P1231
  if_1226_end:
    $P1235 = $P1224."!make"($P1225)
.annotate 'line', 477
    .return ($P1235)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("81_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1237
    .param pmc param_1238
.annotate 'line', 483
    .lex "self", param_1237
    .lex "$/", param_1238
    find_lex $P1239, "$/"
    find_lex $P1242, "$/"
    unless_null $P1242, vivify_447
    $P1242 = root_new ['parrot';'Hash']
  vivify_447:
    set $P1243, $P1242["declarator"]
    unless_null $P1243, vivify_448
    new $P1243, "Undef"
  vivify_448:
    if $P1243, if_1241
    find_lex $P1247, "$/"
    unless_null $P1247, vivify_449
    $P1247 = root_new ['parrot';'Hash']
  vivify_449:
    set $P1248, $P1247["routine_def"]
    unless_null $P1248, vivify_450
    new $P1248, "Undef"
  vivify_450:
    $P1249 = $P1248."ast"()
    set $P1240, $P1249
    goto if_1241_end
  if_1241:
    find_lex $P1244, "$/"
    unless_null $P1244, vivify_451
    $P1244 = root_new ['parrot';'Hash']
  vivify_451:
    set $P1245, $P1244["declarator"]
    unless_null $P1245, vivify_452
    new $P1245, "Undef"
  vivify_452:
    $P1246 = $P1245."ast"()
    set $P1240, $P1246
  if_1241_end:
    $P1250 = $P1239."!make"($P1240)
    .return ($P1250)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("82_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1252
    .param pmc param_1253
.annotate 'line', 484
    .lex "self", param_1252
    .lex "$/", param_1253
    find_lex $P1254, "$/"
    find_lex $P1257, "$/"
    unless_null $P1257, vivify_453
    $P1257 = root_new ['parrot';'Hash']
  vivify_453:
    set $P1258, $P1257["declarator"]
    unless_null $P1258, vivify_454
    new $P1258, "Undef"
  vivify_454:
    if $P1258, if_1256
    find_lex $P1262, "$/"
    unless_null $P1262, vivify_455
    $P1262 = root_new ['parrot';'Hash']
  vivify_455:
    set $P1263, $P1262["routine_def"]
    unless_null $P1263, vivify_456
    new $P1263, "Undef"
  vivify_456:
    $P1264 = $P1263."ast"()
    set $P1255, $P1264
    goto if_1256_end
  if_1256:
    find_lex $P1259, "$/"
    unless_null $P1259, vivify_457
    $P1259 = root_new ['parrot';'Hash']
  vivify_457:
    set $P1260, $P1259["declarator"]
    unless_null $P1260, vivify_458
    new $P1260, "Undef"
  vivify_458:
    $P1261 = $P1260."ast"()
    set $P1255, $P1261
  if_1256_end:
    $P1265 = $P1254."!make"($P1255)
    .return ($P1265)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("83_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1267
    .param pmc param_1268
.annotate 'line', 485
    .lex "self", param_1267
    .lex "$/", param_1268
    find_lex $P1269, "$/"
    find_lex $P1270, "$/"
    unless_null $P1270, vivify_459
    $P1270 = root_new ['parrot';'Hash']
  vivify_459:
    set $P1271, $P1270["declarator"]
    unless_null $P1271, vivify_460
    new $P1271, "Undef"
  vivify_460:
    $P1272 = $P1271."ast"()
    $P1273 = $P1269."!make"($P1272)
    .return ($P1273)
.end


.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("84_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1275
    .param pmc param_1276
.annotate 'line', 488
    .const 'Sub' $P1348 = "87_1296306531.71605" 
    capture_lex $P1348
    .const 'Sub' $P1303 = "85_1296306531.71605" 
    capture_lex $P1303
    .lex "self", param_1275
    .lex "$/", param_1276
.annotate 'line', 489
    new $P1277, "Undef"
    .lex "$past", $P1277
.annotate 'line', 490
    new $P1278, "Undef"
    .lex "$sigil", $P1278
.annotate 'line', 491
    new $P1279, "Undef"
    .lex "$name", $P1279
.annotate 'line', 492
    new $P1280, "Undef"
    .lex "$BLOCK", $P1280
.annotate 'line', 489
    find_lex $P1281, "$/"
    unless_null $P1281, vivify_461
    $P1281 = root_new ['parrot';'Hash']
  vivify_461:
    set $P1282, $P1281["variable"]
    unless_null $P1282, vivify_462
    new $P1282, "Undef"
  vivify_462:
    $P1283 = $P1282."ast"()
    store_lex "$past", $P1283
.annotate 'line', 490
    find_lex $P1284, "$/"
    unless_null $P1284, vivify_463
    $P1284 = root_new ['parrot';'Hash']
  vivify_463:
    set $P1285, $P1284["variable"]
    unless_null $P1285, vivify_464
    $P1285 = root_new ['parrot';'Hash']
  vivify_464:
    set $P1286, $P1285["sigil"]
    unless_null $P1286, vivify_465
    new $P1286, "Undef"
  vivify_465:
    store_lex "$sigil", $P1286
.annotate 'line', 491
    find_lex $P1287, "$past"
    $P1288 = $P1287."name"()
    store_lex "$name", $P1288
.annotate 'line', 492
    get_global $P1289, "@BLOCK"
    unless_null $P1289, vivify_466
    $P1289 = root_new ['parrot';'ResizablePMCArray']
  vivify_466:
    set $P1290, $P1289[0]
    unless_null $P1290, vivify_467
    new $P1290, "Undef"
  vivify_467:
    store_lex "$BLOCK", $P1290
.annotate 'line', 493
    find_lex $P1292, "$BLOCK"
    find_lex $P1293, "$name"
    $P1294 = $P1292."symbol"($P1293)
    unless $P1294, if_1291_end
.annotate 'line', 494
    find_lex $P1295, "$/"
    $P1296 = $P1295."CURSOR"()
    find_lex $P1297, "$name"
    $P1296."panic"("Redeclaration of symbol ", $P1297)
  if_1291_end:
.annotate 'line', 496
    find_dynamic_lex $P1299, "$*SCOPE"
    unless_null $P1299, vivify_468
    get_hll_global $P1299, "$SCOPE"
    unless_null $P1299, vivify_469
    die "Contextual $*SCOPE not found"
  vivify_469:
  vivify_468:
    set $S1300, $P1299
    iseq $I1301, $S1300, "has"
    if $I1301, if_1298
.annotate 'line', 521
    .const 'Sub' $P1348 = "87_1296306531.71605" 
    capture_lex $P1348
    $P1348()
    goto if_1298_end
  if_1298:
.annotate 'line', 496
    .const 'Sub' $P1303 = "85_1296306531.71605" 
    capture_lex $P1303
    $P1303()
  if_1298_end:
.annotate 'line', 529
    find_lex $P1372, "$/"
    find_lex $P1373, "$past"
    $P1374 = $P1372."!make"($P1373)
.annotate 'line', 488
    .return ($P1374)
.end


.namespace ["NQP";"Actions"]
.sub "_block1347"  :anon :subid("87_1296306531.71605") :outer("84_1296306531.71605")
.annotate 'line', 522
    new $P1349, "Undef"
    .lex "$scope", $P1349
.annotate 'line', 523
    new $P1350, "Undef"
    .lex "$decl", $P1350
.annotate 'line', 522
    find_dynamic_lex $P1353, "$*SCOPE"
    unless_null $P1353, vivify_470
    get_hll_global $P1353, "$SCOPE"
    unless_null $P1353, vivify_471
    die "Contextual $*SCOPE not found"
  vivify_471:
  vivify_470:
    set $S1354, $P1353
    iseq $I1355, $S1354, "our"
    if $I1355, if_1352
    new $P1357, "String"
    assign $P1357, "lexical"
    set $P1351, $P1357
    goto if_1352_end
  if_1352:
    new $P1356, "String"
    assign $P1356, "package"
    set $P1351, $P1356
  if_1352_end:
    store_lex "$scope", $P1351
.annotate 'line', 523
    get_hll_global $P1358, ["PAST"], "Var"
    find_lex $P1359, "$name"
    find_lex $P1360, "$scope"
.annotate 'line', 524
    find_lex $P1361, "$sigil"
    $P1362 = "vivitype"($P1361)
    find_lex $P1363, "$/"
    $P1364 = $P1358."new"($P1359 :named("name"), $P1360 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1362 :named("viviself"), $P1363 :named("node"))
.annotate 'line', 523
    store_lex "$decl", $P1364
.annotate 'line', 526
    find_lex $P1365, "$BLOCK"
    find_lex $P1366, "$name"
    find_lex $P1367, "$scope"
    $P1365."symbol"($P1366, $P1367 :named("scope"))
.annotate 'line', 527
    find_lex $P1368, "$BLOCK"
    unless_null $P1368, vivify_472
    $P1368 = root_new ['parrot';'ResizablePMCArray']
  vivify_472:
    set $P1369, $P1368[0]
    unless_null $P1369, vivify_473
    new $P1369, "Undef"
  vivify_473:
    find_lex $P1370, "$decl"
    $P1371 = $P1369."push"($P1370)
.annotate 'line', 521
    .return ($P1371)
.end


.namespace ["NQP";"Actions"]
.sub "_block1302"  :anon :subid("85_1296306531.71605") :outer("84_1296306531.71605")
.annotate 'line', 496
    .const 'Sub' $P1333 = "86_1296306531.71605" 
    capture_lex $P1333
.annotate 'line', 498
    new $P1304, "Undef"
    .lex "$meta-attr-type", $P1304
.annotate 'line', 506
    new $P1305, "Undef"
    .lex "$meta_args", $P1305
.annotate 'line', 498
    find_dynamic_lex $P1308, "$*PKGDECL"
    unless_null $P1308, vivify_474
    get_hll_global $P1308, "$PKGDECL"
    unless_null $P1308, vivify_475
    die "Contextual $*PKGDECL not found"
  vivify_475:
  vivify_474:
    find_dynamic_lex $P1309, "%*HOW-METAATTR"
    unless_null $P1309, vivify_476
    get_hll_global $P1309, "%HOW-METAATTR"
    unless_null $P1309, vivify_477
    die "Contextual %*HOW-METAATTR not found"
  vivify_477:
  vivify_476:
    set $P1310, $P1309[$P1308]
    unless_null $P1310, vivify_478
    new $P1310, "Undef"
  vivify_478:
    unless $P1310, unless_1307
    set $P1306, $P1310
    goto unless_1307_end
  unless_1307:
    find_dynamic_lex $P1311, "$*DEFAULT-METAATTR"
    unless_null $P1311, vivify_479
    get_hll_global $P1311, "$DEFAULT-METAATTR"
    unless_null $P1311, vivify_480
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_480:
  vivify_479:
    set $P1306, $P1311
  unless_1307_end:
    store_lex "$meta-attr-type", $P1306
.annotate 'line', 499
    find_dynamic_lex $P1312, "$*PACKAGE-SETUP"
    unless_null $P1312, vivify_481
    get_hll_global $P1312, "$PACKAGE-SETUP"
    unless_null $P1312, vivify_482
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_482:
  vivify_481:
    get_hll_global $P1313, ["PAST"], "Op"
.annotate 'line', 501
    get_hll_global $P1314, ["PAST"], "Op"
.annotate 'line', 503
    get_hll_global $P1315, ["PAST"], "Var"
    $P1316 = $P1315."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1317 = $P1314."new"($P1316, "get_how PP" :named("pirop"))
.annotate 'line', 505
    get_hll_global $P1318, ["PAST"], "Var"
    $P1319 = $P1318."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 506
    get_hll_global $P1320, ["PAST"], "Op"
.annotate 'line', 508
    get_hll_global $P1321, ["PAST"], "Var"
    find_lex $P1322, "$meta-attr-type"
    $P1323 = $P1321."new"($P1322 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 509
    get_hll_global $P1324, ["PAST"], "Val"
    find_lex $P1325, "$name"
    $P1326 = $P1324."new"($P1325 :named("value"), "name" :named("named"))
    $P1327 = $P1320."new"($P1323, $P1326, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 506
    store_lex "$meta_args", $P1327
    $P1328 = $P1313."new"($P1317, $P1319, $P1327, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 499
    $P1312."push"($P1328)
.annotate 'line', 512
    find_lex $P1330, "$/"
    unless_null $P1330, vivify_483
    $P1330 = root_new ['parrot';'Hash']
  vivify_483:
    set $P1331, $P1330["typename"]
    unless_null $P1331, vivify_484
    new $P1331, "Undef"
  vivify_484:
    unless $P1331, if_1329_end
    .const 'Sub' $P1333 = "86_1296306531.71605" 
    capture_lex $P1333
    $P1333()
  if_1329_end:
.annotate 'line', 518
    find_lex $P1343, "$BLOCK"
    find_lex $P1344, "$name"
    $P1343."symbol"($P1344, "attribute" :named("scope"))
.annotate 'line', 519
    get_hll_global $P1345, ["PAST"], "Stmts"
    $P1346 = $P1345."new"()
    store_lex "$past", $P1346
.annotate 'line', 496
    .return ($P1346)
.end


.namespace ["NQP";"Actions"]
.sub "_block1332"  :anon :subid("86_1296306531.71605") :outer("85_1296306531.71605")
.annotate 'line', 513
    new $P1334, "Undef"
    .lex "$type", $P1334
    find_lex $P1335, "$/"
    unless_null $P1335, vivify_485
    $P1335 = root_new ['parrot';'Hash']
  vivify_485:
    set $P1336, $P1335["typename"]
    unless_null $P1336, vivify_486
    $P1336 = root_new ['parrot';'ResizablePMCArray']
  vivify_486:
    set $P1337, $P1336[0]
    unless_null $P1337, vivify_487
    new $P1337, "Undef"
  vivify_487:
    $P1338 = $P1337."ast"()
    store_lex "$type", $P1338
.annotate 'line', 514
    find_lex $P1339, "$type"
    $P1339."named"("type")
.annotate 'line', 515
    find_lex $P1340, "$meta_args"
    find_lex $P1341, "$type"
    $P1342 = $P1340."push"($P1341)
.annotate 'line', 512
    .return ($P1342)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("88_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1376
    .param pmc param_1377
.annotate 'line', 532
    .lex "self", param_1376
    .lex "$/", param_1377
    find_lex $P1378, "$/"
    find_lex $P1379, "$/"
    unless_null $P1379, vivify_488
    $P1379 = root_new ['parrot';'Hash']
  vivify_488:
    set $P1380, $P1379["routine_def"]
    unless_null $P1380, vivify_489
    new $P1380, "Undef"
  vivify_489:
    $P1381 = $P1380."ast"()
    $P1382 = $P1378."!make"($P1381)
    .return ($P1382)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("89_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1384
    .param pmc param_1385
.annotate 'line', 533
    .lex "self", param_1384
    .lex "$/", param_1385
    find_lex $P1386, "$/"
    find_lex $P1387, "$/"
    unless_null $P1387, vivify_490
    $P1387 = root_new ['parrot';'Hash']
  vivify_490:
    set $P1388, $P1387["method_def"]
    unless_null $P1388, vivify_491
    new $P1388, "Undef"
  vivify_491:
    $P1389 = $P1388."ast"()
    $P1390 = $P1386."!make"($P1389)
    .return ($P1390)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("90_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1392
    .param pmc param_1393
.annotate 'line', 535
    .const 'Sub' $P1621 = "96_1296306531.71605" 
    capture_lex $P1621
    .const 'Sub' $P1413 = "91_1296306531.71605" 
    capture_lex $P1413
    .lex "self", param_1392
    .lex "$/", param_1393
.annotate 'line', 538
    new $P1394, "Undef"
    .lex "$past", $P1394
.annotate 'line', 549
    new $P1395, "Undef"
    .lex "$block", $P1395
.annotate 'line', 535
    find_lex $P1396, "$past"
.annotate 'line', 539
    find_lex $P1398, "$/"
    unless_null $P1398, vivify_492
    $P1398 = root_new ['parrot';'Hash']
  vivify_492:
    set $P1399, $P1398["onlystar"]
    unless_null $P1399, vivify_493
    new $P1399, "Undef"
  vivify_493:
    if $P1399, if_1397
.annotate 'line', 543
    find_lex $P1401, "$/"
    unless_null $P1401, vivify_494
    $P1401 = root_new ['parrot';'Hash']
  vivify_494:
    set $P1402, $P1401["blockoid"]
    unless_null $P1402, vivify_495
    new $P1402, "Undef"
  vivify_495:
    $P1403 = $P1402."ast"()
    store_lex "$past", $P1403
.annotate 'line', 544
    find_lex $P1404, "$past"
    $P1404."blocktype"("declaration")
.annotate 'line', 545
    find_dynamic_lex $P1406, "$*RETURN_USED"
    unless_null $P1406, vivify_496
    get_hll_global $P1406, "$RETURN_USED"
    unless_null $P1406, vivify_497
    die "Contextual $*RETURN_USED not found"
  vivify_497:
  vivify_496:
    unless $P1406, if_1405_end
.annotate 'line', 546
    find_lex $P1407, "$past"
    $P1407."control"("return_pir")
  if_1405_end:
.annotate 'line', 542
    goto if_1397_end
  if_1397:
.annotate 'line', 540
    $P1400 = "only_star_block"()
    store_lex "$past", $P1400
  if_1397_end:
.annotate 'line', 549
    find_lex $P1408, "$past"
    store_lex "$block", $P1408
.annotate 'line', 551
    find_lex $P1410, "$/"
    unless_null $P1410, vivify_498
    $P1410 = root_new ['parrot';'Hash']
  vivify_498:
    set $P1411, $P1410["deflongname"]
    unless_null $P1411, vivify_499
    new $P1411, "Undef"
  vivify_499:
    unless $P1411, if_1409_end
    .const 'Sub' $P1413 = "91_1296306531.71605" 
    capture_lex $P1413
    $P1413()
  if_1409_end:
.annotate 'line', 651
    find_lex $P1610, "$block"
    find_lex $P1611, "$past"
    unless_null $P1611, vivify_560
    $P1611 = root_new ['parrot';'Hash']
    store_lex "$past", $P1611
  vivify_560:
    set $P1611["block_past"], $P1610
.annotate 'line', 652
    find_lex $P1613, "$/"
    unless_null $P1613, vivify_561
    $P1613 = root_new ['parrot';'Hash']
  vivify_561:
    set $P1614, $P1613["trait"]
    unless_null $P1614, vivify_562
    new $P1614, "Undef"
  vivify_562:
    unless $P1614, if_1612_end
.annotate 'line', 653
    find_lex $P1616, "$/"
    unless_null $P1616, vivify_563
    $P1616 = root_new ['parrot';'Hash']
  vivify_563:
    set $P1617, $P1616["trait"]
    unless_null $P1617, vivify_564
    new $P1617, "Undef"
  vivify_564:
    defined $I1618, $P1617
    unless $I1618, for_undef_565
    iter $P1615, $P1617
    new $P1628, 'ExceptionHandler'
    set_addr $P1628, loop1627_handler
    $P1628."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1628
  loop1627_test:
    unless $P1615, loop1627_done
    shift $P1619, $P1615
  loop1627_redo:
    .const 'Sub' $P1621 = "96_1296306531.71605" 
    capture_lex $P1621
    $P1621($P1619)
  loop1627_next:
    goto loop1627_test
  loop1627_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1629, exception, 'type'
    eq $P1629, .CONTROL_LOOP_NEXT, loop1627_next
    eq $P1629, .CONTROL_LOOP_REDO, loop1627_redo
  loop1627_done:
    pop_eh 
  for_undef_565:
  if_1612_end:
.annotate 'line', 656
    find_lex $P1630, "$/"
    find_lex $P1631, "$past"
    $P1632 = $P1630."!make"($P1631)
.annotate 'line', 535
    .return ($P1632)
.end


.namespace ["NQP";"Actions"]
.sub "_block1412"  :anon :subid("91_1296306531.71605") :outer("90_1296306531.71605")
.annotate 'line', 551
    .const 'Sub' $P1536 = "95_1296306531.71605" 
    capture_lex $P1536
    .const 'Sub' $P1447 = "92_1296306531.71605" 
    capture_lex $P1447
.annotate 'line', 552
    new $P1414, "Undef"
    .lex "$name", $P1414
    find_lex $P1415, "$/"
    unless_null $P1415, vivify_500
    $P1415 = root_new ['parrot';'Hash']
  vivify_500:
    set $P1416, $P1415["sigil"]
    unless_null $P1416, vivify_501
    $P1416 = root_new ['parrot';'ResizablePMCArray']
  vivify_501:
    set $P1417, $P1416[0]
    unless_null $P1417, vivify_502
    new $P1417, "Undef"
  vivify_502:
    set $S1418, $P1417
    new $P1419, 'String'
    set $P1419, $S1418
    find_lex $P1420, "$/"
    unless_null $P1420, vivify_503
    $P1420 = root_new ['parrot';'Hash']
  vivify_503:
    set $P1421, $P1420["deflongname"]
    unless_null $P1421, vivify_504
    $P1421 = root_new ['parrot';'ResizablePMCArray']
  vivify_504:
    set $P1422, $P1421[0]
    unless_null $P1422, vivify_505
    new $P1422, "Undef"
  vivify_505:
    $S1423 = $P1422."ast"()
    concat $P1424, $P1419, $S1423
    store_lex "$name", $P1424
.annotate 'line', 553
    find_lex $P1425, "$past"
    find_lex $P1426, "$name"
    $P1425."name"($P1426)
.annotate 'line', 554
    find_dynamic_lex $P1433, "$*SCOPE"
    unless_null $P1433, vivify_506
    get_hll_global $P1433, "$SCOPE"
    unless_null $P1433, vivify_507
    die "Contextual $*SCOPE not found"
  vivify_507:
  vivify_506:
    set $S1434, $P1433
    iseq $I1435, $S1434, ""
    unless $I1435, unless_1432
    new $P1431, 'Integer'
    set $P1431, $I1435
    goto unless_1432_end
  unless_1432:
    find_dynamic_lex $P1436, "$*SCOPE"
    unless_null $P1436, vivify_508
    get_hll_global $P1436, "$SCOPE"
    unless_null $P1436, vivify_509
    die "Contextual $*SCOPE not found"
  vivify_509:
  vivify_508:
    set $S1437, $P1436
    iseq $I1438, $S1437, "my"
    new $P1431, 'Integer'
    set $P1431, $I1438
  unless_1432_end:
    unless $P1431, unless_1430
    set $P1429, $P1431
    goto unless_1430_end
  unless_1430:
    find_dynamic_lex $P1439, "$*SCOPE"
    unless_null $P1439, vivify_510
    get_hll_global $P1439, "$SCOPE"
    unless_null $P1439, vivify_511
    die "Contextual $*SCOPE not found"
  vivify_511:
  vivify_510:
    set $S1440, $P1439
    iseq $I1441, $S1440, "our"
    new $P1429, 'Integer'
    set $P1429, $I1441
  unless_1430_end:
    if $P1429, if_1428
.annotate 'line', 646
    find_lex $P1605, "$/"
    $P1606 = $P1605."CURSOR"()
    find_dynamic_lex $P1607, "$*SCOPE"
    unless_null $P1607, vivify_512
    get_hll_global $P1607, "$SCOPE"
    unless_null $P1607, vivify_513
    die "Contextual $*SCOPE not found"
  vivify_513:
  vivify_512:
    concat $P1608, $P1607, " scoped routines are not supported yet"
    $P1609 = $P1606."panic"($P1608)
.annotate 'line', 645
    set $P1427, $P1609
.annotate 'line', 554
    goto if_1428_end
  if_1428:
.annotate 'line', 555
    find_dynamic_lex $P1443, "$*MULTINESS"
    unless_null $P1443, vivify_514
    get_hll_global $P1443, "$MULTINESS"
    unless_null $P1443, vivify_515
    die "Contextual $*MULTINESS not found"
  vivify_515:
  vivify_514:
    set $S1444, $P1443
    iseq $I1445, $S1444, "multi"
    if $I1445, if_1442
.annotate 'line', 606
    find_dynamic_lex $P1532, "$*MULTINESS"
    unless_null $P1532, vivify_516
    get_hll_global $P1532, "$MULTINESS"
    unless_null $P1532, vivify_517
    die "Contextual $*MULTINESS not found"
  vivify_517:
  vivify_516:
    set $S1533, $P1532
    iseq $I1534, $S1533, "proto"
    if $I1534, if_1531
.annotate 'line', 625
    get_global $P1566, "@BLOCK"
    unless_null $P1566, vivify_518
    $P1566 = root_new ['parrot';'ResizablePMCArray']
  vivify_518:
    set $P1567, $P1566[0]
    unless_null $P1567, vivify_519
    $P1567 = root_new ['parrot';'ResizablePMCArray']
  vivify_519:
    set $P1568, $P1567[0]
    unless_null $P1568, vivify_520
    new $P1568, "Undef"
  vivify_520:
    get_hll_global $P1569, ["PAST"], "Var"
    find_lex $P1570, "$name"
    find_lex $P1571, "$past"
    $P1572 = $P1569."new"($P1570 :named("name"), 1 :named("isdecl"), $P1571 :named("viviself"), "lexical" :named("scope"))
    $P1568."push"($P1572)
.annotate 'line', 627
    get_global $P1573, "@BLOCK"
    unless_null $P1573, vivify_521
    $P1573 = root_new ['parrot';'ResizablePMCArray']
  vivify_521:
    set $P1574, $P1573[0]
    unless_null $P1574, vivify_522
    new $P1574, "Undef"
  vivify_522:
    find_lex $P1575, "$name"
    $P1574."symbol"($P1575, "lexical" :named("scope"))
.annotate 'line', 628
    find_dynamic_lex $P1577, "$*SCOPE"
    unless_null $P1577, vivify_523
    get_hll_global $P1577, "$SCOPE"
    unless_null $P1577, vivify_524
    die "Contextual $*SCOPE not found"
  vivify_524:
  vivify_523:
    set $S1578, $P1577
    iseq $I1579, $S1578, "our"
    unless $I1579, if_1576_end
.annotate 'line', 631
    get_global $P1580, "@BLOCK"
    unless_null $P1580, vivify_525
    $P1580 = root_new ['parrot';'ResizablePMCArray']
  vivify_525:
    set $P1581, $P1580[0]
    unless_null $P1581, vivify_526
    $P1581 = root_new ['parrot';'ResizablePMCArray']
  vivify_526:
    set $P1582, $P1581[0]
    unless_null $P1582, vivify_527
    new $P1582, "Undef"
  vivify_527:
    get_hll_global $P1583, ["PAST"], "Op"
.annotate 'line', 633
    get_hll_global $P1584, ["PAST"], "Var"
    find_lex $P1585, "$name"
    $P1586 = $P1584."new"($P1585 :named("name"), "package" :named("scope"))
.annotate 'line', 634
    get_hll_global $P1587, ["PAST"], "Var"
    find_lex $P1588, "$name"
    $P1589 = $P1587."new"($P1588 :named("name"), "lexical" :named("scope"))
    $P1590 = $P1583."new"($P1586, $P1589, "bind" :named("pasttype"))
.annotate 'line', 631
    $P1582."push"($P1590)
.annotate 'line', 636
    get_global $P1591, "@BLOCK"
    unless_null $P1591, vivify_528
    $P1591 = root_new ['parrot';'ResizablePMCArray']
  vivify_528:
    set $P1592, $P1591[0]
    unless_null $P1592, vivify_529
    new $P1592, "Undef"
  vivify_529:
    $P1593 = $P1592."loadinit"()
    get_hll_global $P1594, ["PAST"], "Op"
.annotate 'line', 638
    get_hll_global $P1595, ["PAST"], "Var"
    find_lex $P1596, "$name"
    $P1597 = $P1595."new"($P1596 :named("name"), "package" :named("scope"))
.annotate 'line', 639
    get_hll_global $P1598, ["PAST"], "Val"
    find_lex $P1599, "$past"
    $P1600 = $P1598."new"($P1599 :named("value"))
    $P1601 = $P1594."new"($P1597, $P1600, "bind" :named("pasttype"))
.annotate 'line', 636
    $P1593."push"($P1601)
  if_1576_end:
.annotate 'line', 624
    goto if_1531_end
  if_1531:
.annotate 'line', 606
    .const 'Sub' $P1536 = "95_1296306531.71605" 
    capture_lex $P1536
    $P1536()
  if_1531_end:
    goto if_1442_end
  if_1442:
.annotate 'line', 555
    .const 'Sub' $P1447 = "92_1296306531.71605" 
    capture_lex $P1447
    $P1447()
  if_1442_end:
.annotate 'line', 643
    get_hll_global $P1602, ["PAST"], "Var"
    find_lex $P1603, "$name"
    $P1604 = $P1602."new"($P1603 :named("name"))
    store_lex "$past", $P1604
.annotate 'line', 554
    set $P1427, $P1604
  if_1428_end:
.annotate 'line', 551
    .return ($P1427)
.end


.namespace ["NQP";"Actions"]
.sub "_block1535"  :anon :subid("95_1296306531.71605") :outer("91_1296306531.71605")
.annotate 'line', 611
    new $P1537, "Undef"
    .lex "$cholder", $P1537
.annotate 'line', 610
    find_dynamic_lex $P1539, "$*SCOPE"
    unless_null $P1539, vivify_530
    get_hll_global $P1539, "$SCOPE"
    unless_null $P1539, vivify_531
    die "Contextual $*SCOPE not found"
  vivify_531:
  vivify_530:
    set $S1540, $P1539
    iseq $I1541, $S1540, "our"
    unless $I1541, if_1538_end
    die "our-scoped protos not yet implemented"
  if_1538_end:
.annotate 'line', 611
    get_hll_global $P1542, ["PAST"], "Op"
    $P1543 = $P1542."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1543
.annotate 'line', 612
    get_global $P1544, "@BLOCK"
    unless_null $P1544, vivify_532
    $P1544 = root_new ['parrot';'ResizablePMCArray']
  vivify_532:
    set $P1545, $P1544[0]
    unless_null $P1545, vivify_533
    $P1545 = root_new ['parrot';'ResizablePMCArray']
  vivify_533:
    set $P1546, $P1545[0]
    unless_null $P1546, vivify_534
    new $P1546, "Undef"
  vivify_534:
    get_hll_global $P1547, ["PAST"], "Var"
    find_lex $P1548, "$name"
    find_lex $P1549, "$past"
    $P1550 = $P1547."new"($P1548 :named("name"), 1 :named("isdecl"), $P1549 :named("viviself"), "lexical" :named("scope"))
    $P1546."push"($P1550)
.annotate 'line', 614
    get_global $P1551, "@BLOCK"
    unless_null $P1551, vivify_535
    $P1551 = root_new ['parrot';'ResizablePMCArray']
  vivify_535:
    set $P1552, $P1551[0]
    unless_null $P1552, vivify_536
    $P1552 = root_new ['parrot';'ResizablePMCArray']
  vivify_536:
    set $P1553, $P1552[0]
    unless_null $P1553, vivify_537
    new $P1553, "Undef"
  vivify_537:
    get_hll_global $P1554, ["PAST"], "Op"
.annotate 'line', 616
    get_hll_global $P1555, ["PAST"], "Var"
    find_lex $P1556, "$name"
    $P1557 = $P1555."new"($P1556 :named("name"))
    find_lex $P1558, "$cholder"
    $P1559 = $P1554."new"($P1557, $P1558, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 614
    $P1553."push"($P1559)
.annotate 'line', 619
    get_global $P1560, "@BLOCK"
    unless_null $P1560, vivify_538
    $P1560 = root_new ['parrot';'ResizablePMCArray']
  vivify_538:
    set $P1561, $P1560[0]
    unless_null $P1561, vivify_539
    new $P1561, "Undef"
  vivify_539:
    find_lex $P1562, "$name"
    find_lex $P1563, "$cholder"
    $P1561."symbol"($P1562, "lexical" :named("scope"), 1 :named("proto"), $P1563 :named("cholder"))
.annotate 'line', 622
    find_lex $P1564, "$past"
    $P1565 = $P1564."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 606
    .return ($P1565)
.end


.namespace ["NQP";"Actions"]
.sub "_block1446"  :anon :subid("92_1296306531.71605") :outer("91_1296306531.71605")
.annotate 'line', 555
    .const 'Sub' $P1465 = "93_1296306531.71605" 
    capture_lex $P1465
.annotate 'line', 558
    new $P1448, "Undef"
    .lex "$cholder", $P1448
.annotate 'line', 559
    $P1449 = root_new ['parrot';'Hash']
    .lex "%sym", $P1449
.annotate 'line', 557
    find_dynamic_lex $P1451, "$*SCOPE"
    unless_null $P1451, vivify_540
    get_hll_global $P1451, "$SCOPE"
    unless_null $P1451, vivify_541
    die "Contextual $*SCOPE not found"
  vivify_541:
  vivify_540:
    set $S1452, $P1451
    iseq $I1453, $S1452, "our"
    unless $I1453, if_1450_end
    die "our-scoped multis not yet implemented"
  if_1450_end:
    find_lex $P1454, "$cholder"
.annotate 'line', 559
    get_global $P1455, "@BLOCK"
    unless_null $P1455, vivify_542
    $P1455 = root_new ['parrot';'ResizablePMCArray']
  vivify_542:
    set $P1456, $P1455[0]
    unless_null $P1456, vivify_543
    new $P1456, "Undef"
  vivify_543:
    find_lex $P1457, "$name"
    $P1458 = $P1456."symbol"($P1457)
    store_lex "%sym", $P1458
.annotate 'line', 560
    find_lex $P1460, "%sym"
    unless_null $P1460, vivify_544
    $P1460 = root_new ['parrot';'Hash']
  vivify_544:
    set $P1461, $P1460["cholder"]
    unless_null $P1461, vivify_545
    new $P1461, "Undef"
  vivify_545:
    if $P1461, if_1459
.annotate 'line', 565
    .const 'Sub' $P1465 = "93_1296306531.71605" 
    capture_lex $P1465
    $P1465()
    goto if_1459_end
  if_1459:
.annotate 'line', 561
    find_lex $P1462, "%sym"
    unless_null $P1462, vivify_558
    $P1462 = root_new ['parrot';'Hash']
  vivify_558:
    set $P1463, $P1462["cholder"]
    unless_null $P1463, vivify_559
    new $P1463, "Undef"
  vivify_559:
    store_lex "$cholder", $P1463
  if_1459_end:
.annotate 'line', 601
    find_lex $P1527, "$cholder"
    find_lex $P1528, "$past"
    $P1527."push"($P1528)
.annotate 'line', 604
    find_lex $P1529, "$past"
    $P1530 = "attach_multi_signature"($P1529)
.annotate 'line', 555
    .return ($P1530)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1464"  :anon :subid("93_1296306531.71605") :outer("92_1296306531.71605")
.annotate 'line', 565
    .const 'Sub' $P1479 = "94_1296306531.71605" 
    capture_lex $P1479
.annotate 'line', 572
    new $P1466, "Undef"
    .lex "$found_proto", $P1466
.annotate 'line', 590
    new $P1467, "Undef"
    .lex "$dispatch_setup", $P1467
.annotate 'line', 567
    find_lex $P1469, "%sym"
    unless_null $P1469, vivify_546
    $P1469 = root_new ['parrot';'Hash']
  vivify_546:
    set $P1470, $P1469["proto"]
    unless_null $P1470, vivify_547
    new $P1470, "Undef"
  vivify_547:
    unless $P1470, if_1468_end
.annotate 'line', 570
    find_lex $P1471, "$/"
    $P1472 = $P1471."CURSOR"()
    $P1472."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1468_end:
.annotate 'line', 567
    find_lex $P1473, "$found_proto"
.annotate 'line', 573
    get_global $P1475, "@BLOCK"
    defined $I1476, $P1475
    unless $I1476, for_undef_548
    iter $P1474, $P1475
    new $P1501, 'ExceptionHandler'
    set_addr $P1501, loop1500_handler
    $P1501."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1501
  loop1500_test:
    unless $P1474, loop1500_done
    shift $P1477, $P1474
  loop1500_redo:
    .const 'Sub' $P1479 = "94_1296306531.71605" 
    capture_lex $P1479
    $P1479($P1477)
  loop1500_next:
    goto loop1500_test
  loop1500_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1502, exception, 'type'
    eq $P1502, .CONTROL_LOOP_NEXT, loop1500_next
    eq $P1502, .CONTROL_LOOP_REDO, loop1500_redo
  loop1500_done:
    pop_eh 
  for_undef_548:
.annotate 'line', 584
    find_lex $P1504, "$found_proto"
    if $P1504, unless_1503_end
.annotate 'line', 585
    find_lex $P1505, "$/"
    $P1506 = $P1505."CURSOR"()
    $P1506."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1503_end:
.annotate 'line', 589
    get_hll_global $P1507, ["PAST"], "Op"
    $P1508 = $P1507."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1508
.annotate 'line', 590
    get_hll_global $P1509, ["PAST"], "Op"
.annotate 'line', 592
    get_hll_global $P1510, ["PAST"], "Var"
    find_lex $P1511, "$name"
    $P1512 = $P1510."new"($P1511 :named("name"), "outer" :named("scope"))
    find_lex $P1513, "$cholder"
    $P1514 = $P1509."new"($P1512, $P1513, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 590
    store_lex "$dispatch_setup", $P1514
.annotate 'line', 595
    get_global $P1515, "@BLOCK"
    unless_null $P1515, vivify_553
    $P1515 = root_new ['parrot';'ResizablePMCArray']
  vivify_553:
    set $P1516, $P1515[0]
    unless_null $P1516, vivify_554
    $P1516 = root_new ['parrot';'ResizablePMCArray']
  vivify_554:
    set $P1517, $P1516[0]
    unless_null $P1517, vivify_555
    new $P1517, "Undef"
  vivify_555:
    get_hll_global $P1518, ["PAST"], "Var"
    find_lex $P1519, "$name"
    find_lex $P1520, "$dispatch_setup"
    $P1521 = $P1518."new"($P1519 :named("name"), 1 :named("isdecl"), $P1520 :named("viviself"), "lexical" :named("scope"))
    $P1517."push"($P1521)
.annotate 'line', 597
    get_global $P1522, "@BLOCK"
    unless_null $P1522, vivify_556
    $P1522 = root_new ['parrot';'ResizablePMCArray']
  vivify_556:
    set $P1523, $P1522[0]
    unless_null $P1523, vivify_557
    new $P1523, "Undef"
  vivify_557:
    find_lex $P1524, "$name"
    find_lex $P1525, "$cholder"
    $P1526 = $P1523."symbol"($P1524, "lexical" :named("scope"), $P1525 :named("cholder"))
.annotate 'line', 565
    .return ($P1526)
.end


.namespace ["NQP";"Actions"]
.sub "_block1478"  :anon :subid("94_1296306531.71605") :outer("93_1296306531.71605")
    .param pmc param_1481
.annotate 'line', 574
    $P1480 = root_new ['parrot';'Hash']
    .lex "%sym", $P1480
    .lex "$_", param_1481
    find_lex $P1482, "$_"
    find_lex $P1483, "$name"
    $P1484 = $P1482."symbol"($P1483)
    store_lex "%sym", $P1484
.annotate 'line', 575
    find_lex $P1489, "%sym"
    unless_null $P1489, vivify_549
    $P1489 = root_new ['parrot';'Hash']
  vivify_549:
    set $P1490, $P1489["proto"]
    unless_null $P1490, vivify_550
    new $P1490, "Undef"
  vivify_550:
    unless $P1490, unless_1488
    set $P1487, $P1490
    goto unless_1488_end
  unless_1488:
    find_lex $P1491, "%sym"
    unless_null $P1491, vivify_551
    $P1491 = root_new ['parrot';'Hash']
  vivify_551:
    set $P1492, $P1491["cholder"]
    unless_null $P1492, vivify_552
    new $P1492, "Undef"
  vivify_552:
    set $P1487, $P1492
  unless_1488_end:
    if $P1487, if_1486
.annotate 'line', 578
    find_lex $P1496, "%sym"
    if $P1496, if_1495
    set $P1494, $P1496
    goto if_1495_end
  if_1495:
.annotate 'line', 579
    find_lex $P1497, "$/"
    $P1498 = $P1497."CURSOR"()
    $P1499 = $P1498."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 578
    set $P1494, $P1499
  if_1495_end:
    set $P1485, $P1494
.annotate 'line', 575
    goto if_1486_end
  if_1486:
.annotate 'line', 576
    new $P1493, "Integer"
    assign $P1493, 1
    store_lex "$found_proto", $P1493
.annotate 'line', 575
    set $P1485, $P1493
  if_1486_end:
.annotate 'line', 573
    .return ($P1485)
.end


.namespace ["NQP";"Actions"]
.sub "_block1620"  :anon :subid("96_1296306531.71605") :outer("90_1296306531.71605")
    .param pmc param_1622
.annotate 'line', 653
    .lex "$_", param_1622
    find_lex $P1623, "$_"
    $P1624 = $P1623."ast"()
    find_lex $P1625, "$/"
    $P1626 = $P1624($P1625)
    .return ($P1626)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("97_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1634
    .param pmc param_1635
.annotate 'line', 660
    .const 'Sub' $P1744 = "99_1296306531.71605" 
    capture_lex $P1744
    .const 'Sub' $P1663 = "98_1296306531.71605" 
    capture_lex $P1663
    .lex "self", param_1634
    .lex "$/", param_1635
.annotate 'line', 663
    new $P1636, "Undef"
    .lex "$past", $P1636
.annotate 'line', 660
    find_lex $P1637, "$past"
.annotate 'line', 664
    find_lex $P1639, "$/"
    unless_null $P1639, vivify_566
    $P1639 = root_new ['parrot';'Hash']
  vivify_566:
    set $P1640, $P1639["onlystar"]
    unless_null $P1640, vivify_567
    new $P1640, "Undef"
  vivify_567:
    if $P1640, if_1638
.annotate 'line', 668
    find_lex $P1642, "$/"
    unless_null $P1642, vivify_568
    $P1642 = root_new ['parrot';'Hash']
  vivify_568:
    set $P1643, $P1642["blockoid"]
    unless_null $P1643, vivify_569
    new $P1643, "Undef"
  vivify_569:
    $P1644 = $P1643."ast"()
    store_lex "$past", $P1644
.annotate 'line', 669
    find_lex $P1645, "$past"
    $P1645."blocktype"("declaration")
.annotate 'line', 670
    find_dynamic_lex $P1647, "$*RETURN_USED"
    unless_null $P1647, vivify_570
    get_hll_global $P1647, "$RETURN_USED"
    unless_null $P1647, vivify_571
    die "Contextual $*RETURN_USED not found"
  vivify_571:
  vivify_570:
    unless $P1647, if_1646_end
.annotate 'line', 671
    find_lex $P1648, "$past"
    $P1648."control"("return_pir")
  if_1646_end:
.annotate 'line', 667
    goto if_1638_end
  if_1638:
.annotate 'line', 665
    $P1641 = "only_star_block"()
    store_lex "$past", $P1641
  if_1638_end:
.annotate 'line', 676
    find_lex $P1650, "$past"
    unless_null $P1650, vivify_572
    $P1650 = root_new ['parrot';'Hash']
  vivify_572:
    set $P1651, $P1650["signature_has_invocant"]
    unless_null $P1651, vivify_573
    new $P1651, "Undef"
  vivify_573:
    if $P1651, unless_1649_end
.annotate 'line', 677
    find_lex $P1652, "$past"
    unless_null $P1652, vivify_574
    $P1652 = root_new ['parrot';'ResizablePMCArray']
  vivify_574:
    set $P1653, $P1652[0]
    unless_null $P1653, vivify_575
    new $P1653, "Undef"
  vivify_575:
    get_hll_global $P1654, ["PAST"], "Var"
.annotate 'line', 679
    get_hll_global $P1655, ["PAST"], "Var"
    $P1656 = $P1655."new"("$?CLASS" :named("name"), "package" :named("scope"))
    $P1657 = $P1654."new"("self" :named("name"), "parameter" :named("scope"), $P1656 :named("multitype"))
.annotate 'line', 677
    $P1653."unshift"($P1657)
  unless_1649_end:
.annotate 'line', 682
    find_lex $P1658, "$past"
    $P1658."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 685
    find_lex $P1660, "$/"
    unless_null $P1660, vivify_576
    $P1660 = root_new ['parrot';'Hash']
  vivify_576:
    set $P1661, $P1660["deflongname"]
    unless_null $P1661, vivify_577
    new $P1661, "Undef"
  vivify_577:
    unless $P1661, if_1659_end
    .const 'Sub' $P1663 = "98_1296306531.71605" 
    capture_lex $P1663
    $P1663()
  if_1659_end:
.annotate 'line', 720
    find_dynamic_lex $P1729, "$*SCOPE"
    unless_null $P1729, vivify_595
    get_hll_global $P1729, "$SCOPE"
    unless_null $P1729, vivify_596
    die "Contextual $*SCOPE not found"
  vivify_596:
  vivify_595:
    set $S1730, $P1729
    iseq $I1731, $S1730, "our"
    unless $I1731, if_1728_end
.annotate 'line', 721
    find_lex $P1732, "$past"
    $P1732."pirflags"(":nsentry")
  if_1728_end:
.annotate 'line', 725
    find_lex $P1733, "$past"
    find_lex $P1734, "$past"
    unless_null $P1734, vivify_597
    $P1734 = root_new ['parrot';'Hash']
    store_lex "$past", $P1734
  vivify_597:
    set $P1734["block_past"], $P1733
.annotate 'line', 726
    find_lex $P1736, "$/"
    unless_null $P1736, vivify_598
    $P1736 = root_new ['parrot';'Hash']
  vivify_598:
    set $P1737, $P1736["trait"]
    unless_null $P1737, vivify_599
    new $P1737, "Undef"
  vivify_599:
    unless $P1737, if_1735_end
.annotate 'line', 727
    find_lex $P1739, "$/"
    unless_null $P1739, vivify_600
    $P1739 = root_new ['parrot';'Hash']
  vivify_600:
    set $P1740, $P1739["trait"]
    unless_null $P1740, vivify_601
    new $P1740, "Undef"
  vivify_601:
    defined $I1741, $P1740
    unless $I1741, for_undef_602
    iter $P1738, $P1740
    new $P1751, 'ExceptionHandler'
    set_addr $P1751, loop1750_handler
    $P1751."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1751
  loop1750_test:
    unless $P1738, loop1750_done
    shift $P1742, $P1738
  loop1750_redo:
    .const 'Sub' $P1744 = "99_1296306531.71605" 
    capture_lex $P1744
    $P1744($P1742)
  loop1750_next:
    goto loop1750_test
  loop1750_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1752, exception, 'type'
    eq $P1752, .CONTROL_LOOP_NEXT, loop1750_next
    eq $P1752, .CONTROL_LOOP_REDO, loop1750_redo
  loop1750_done:
    pop_eh 
  for_undef_602:
  if_1735_end:
.annotate 'line', 730
    find_lex $P1753, "$/"
    find_lex $P1754, "$past"
    $P1755 = $P1753."!make"($P1754)
.annotate 'line', 660
    .return ($P1755)
.end


.namespace ["NQP";"Actions"]
.sub "_block1662"  :anon :subid("98_1296306531.71605") :outer("97_1296306531.71605")
.annotate 'line', 687
    new $P1664, "Undef"
    .lex "$name", $P1664
.annotate 'line', 692
    new $P1665, "Undef"
    .lex "$to_add", $P1665
.annotate 'line', 687
    find_lex $P1666, "$/"
    unless_null $P1666, vivify_578
    $P1666 = root_new ['parrot';'Hash']
  vivify_578:
    set $P1667, $P1666["private"]
    unless_null $P1667, vivify_579
    new $P1667, "Undef"
  vivify_579:
    set $S1668, $P1667
    new $P1669, 'String'
    set $P1669, $S1668
    find_lex $P1670, "$/"
    unless_null $P1670, vivify_580
    $P1670 = root_new ['parrot';'Hash']
  vivify_580:
    set $P1671, $P1670["deflongname"]
    unless_null $P1671, vivify_581
    $P1671 = root_new ['parrot';'ResizablePMCArray']
  vivify_581:
    set $P1672, $P1671[0]
    unless_null $P1672, vivify_582
    new $P1672, "Undef"
  vivify_582:
    $P1673 = $P1672."ast"()
    set $S1674, $P1673
    concat $P1675, $P1669, $S1674
    store_lex "$name", $P1675
.annotate 'line', 688
    find_lex $P1676, "$past"
    find_lex $P1677, "$name"
    $P1676."name"($P1677)
.annotate 'line', 692
    find_dynamic_lex $P1680, "$*MULTINESS"
    unless_null $P1680, vivify_583
    get_hll_global $P1680, "$MULTINESS"
    unless_null $P1680, vivify_584
    die "Contextual $*MULTINESS not found"
  vivify_584:
  vivify_583:
    set $S1681, $P1680
    isne $I1682, $S1681, "proto"
    if $I1682, if_1679
.annotate 'line', 694
    get_hll_global $P1686, ["PAST"], "Op"
.annotate 'line', 696
    get_hll_global $P1687, ["PAST"], "Val"
    find_lex $P1688, "$past"
    $P1689 = $P1687."new"($P1688 :named("value"))
.annotate 'line', 697
    get_hll_global $P1690, ["PAST"], "Op"
    $P1691 = $P1690."new"("list" :named("pasttype"))
    $P1692 = $P1686."new"($P1689, $P1691, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 694
    set $P1678, $P1692
.annotate 'line', 692
    goto if_1679_end
  if_1679:
.annotate 'line', 693
    get_hll_global $P1683, ["PAST"], "Val"
    find_lex $P1684, "$past"
    $P1685 = $P1683."new"($P1684 :named("value"))
    set $P1678, $P1685
  if_1679_end:
.annotate 'line', 692
    store_lex "$to_add", $P1678
.annotate 'line', 699
    find_dynamic_lex $P1694, "$*MULTINESS"
    unless_null $P1694, vivify_585
    get_hll_global $P1694, "$MULTINESS"
    unless_null $P1694, vivify_586
    die "Contextual $*MULTINESS not found"
  vivify_586:
  vivify_585:
    set $S1695, $P1694
    iseq $I1696, $S1695, "proto"
    unless $I1696, if_1693_end
    find_lex $P1697, "$past"
    $P1697."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1693_end:
.annotate 'line', 703
    find_dynamic_lex $P1699, "$*MULTINESS"
    unless_null $P1699, vivify_587
    get_hll_global $P1699, "$MULTINESS"
    unless_null $P1699, vivify_588
    die "Contextual $*MULTINESS not found"
  vivify_588:
  vivify_587:
    set $S1700, $P1699
    iseq $I1701, $S1700, "multi"
    unless $I1701, if_1698_end
    find_lex $P1702, "$past"
    "attach_multi_signature"($P1702)
  if_1698_end:
.annotate 'line', 706
    find_dynamic_lex $P1705, "$*PACKAGE-SETUP"
    unless_null $P1705, vivify_589
    get_hll_global $P1705, "$PACKAGE-SETUP"
    unless_null $P1705, vivify_590
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_590:
  vivify_589:
    defined $I1706, $P1705
    if $I1706, if_1704
    new $P1703, 'Integer'
    set $P1703, $I1706
    goto if_1704_end
  if_1704:
.annotate 'line', 707
    find_dynamic_lex $P1707, "$*PACKAGE-SETUP"
    unless_null $P1707, vivify_591
    get_hll_global $P1707, "$PACKAGE-SETUP"
    unless_null $P1707, vivify_592
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_592:
  vivify_591:
    get_hll_global $P1708, ["PAST"], "Op"
.annotate 'line', 708
    find_dynamic_lex $P1711, "$*MULTINESS"
    unless_null $P1711, vivify_593
    get_hll_global $P1711, "$MULTINESS"
    unless_null $P1711, vivify_594
    die "Contextual $*MULTINESS not found"
  vivify_594:
  vivify_593:
    set $S1712, $P1711
    iseq $I1713, $S1712, "multi"
    if $I1713, if_1710
    new $P1715, "String"
    assign $P1715, "add_method"
    set $P1709, $P1715
    goto if_1710_end
  if_1710:
    new $P1714, "String"
    assign $P1714, "add_multi_method"
    set $P1709, $P1714
  if_1710_end:
.annotate 'line', 709
    get_hll_global $P1716, ["PAST"], "Op"
.annotate 'line', 712
    get_hll_global $P1717, ["PAST"], "Var"
    $P1718 = $P1717."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1719 = $P1716."new"($P1718, "get_how PP" :named("pirop"))
.annotate 'line', 714
    get_hll_global $P1720, ["PAST"], "Var"
    $P1721 = $P1720."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 715
    get_hll_global $P1722, ["PAST"], "Val"
    find_lex $P1723, "$name"
    $P1724 = $P1722."new"($P1723 :named("value"))
    find_lex $P1725, "$to_add"
    $P1726 = $P1708."new"($P1719, $P1721, $P1724, $P1725, "callmethod" :named("pasttype"), $P1709 :named("name"))
.annotate 'line', 707
    $P1727 = $P1707."push"($P1726)
.annotate 'line', 706
    set $P1703, $P1727
  if_1704_end:
.annotate 'line', 685
    .return ($P1703)
.end


.namespace ["NQP";"Actions"]
.sub "_block1743"  :anon :subid("99_1296306531.71605") :outer("97_1296306531.71605")
    .param pmc param_1745
.annotate 'line', 727
    .lex "$_", param_1745
    find_lex $P1746, "$_"
    $P1747 = $P1746."ast"()
    find_lex $P1748, "$/"
    $P1749 = $P1747($P1748)
    .return ($P1749)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("100_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1759
    .param pmc param_1760
.annotate 'line', 761
    .const 'Sub' $P1793 = "102_1296306531.71605" 
    capture_lex $P1793
    .const 'Sub' $P1769 = "101_1296306531.71605" 
    capture_lex $P1769
    .lex "self", param_1759
    .lex "$/", param_1760
.annotate 'line', 762
    new $P1761, "Undef"
    .lex "$BLOCKINIT", $P1761
    get_global $P1762, "@BLOCK"
    unless_null $P1762, vivify_603
    $P1762 = root_new ['parrot';'ResizablePMCArray']
  vivify_603:
    set $P1763, $P1762[0]
    unless_null $P1763, vivify_604
    $P1763 = root_new ['parrot';'ResizablePMCArray']
  vivify_604:
    set $P1764, $P1763[0]
    unless_null $P1764, vivify_605
    new $P1764, "Undef"
  vivify_605:
    store_lex "$BLOCKINIT", $P1764
.annotate 'line', 763
    find_lex $P1766, "$/"
    unless_null $P1766, vivify_606
    $P1766 = root_new ['parrot';'Hash']
  vivify_606:
    set $P1767, $P1766["invocant"]
    unless_null $P1767, vivify_607
    new $P1767, "Undef"
  vivify_607:
    unless $P1767, if_1765_end
    .const 'Sub' $P1769 = "101_1296306531.71605" 
    capture_lex $P1769
    $P1769()
  if_1765_end:
.annotate 'line', 772
    find_lex $P1788, "$/"
    unless_null $P1788, vivify_613
    $P1788 = root_new ['parrot';'Hash']
  vivify_613:
    set $P1789, $P1788["parameter"]
    unless_null $P1789, vivify_614
    new $P1789, "Undef"
  vivify_614:
    defined $I1790, $P1789
    unless $I1790, for_undef_615
    iter $P1787, $P1789
    new $P1800, 'ExceptionHandler'
    set_addr $P1800, loop1799_handler
    $P1800."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1800
  loop1799_test:
    unless $P1787, loop1799_done
    shift $P1791, $P1787
  loop1799_redo:
    .const 'Sub' $P1793 = "102_1296306531.71605" 
    capture_lex $P1793
    $P1793($P1791)
  loop1799_next:
    goto loop1799_test
  loop1799_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1801, exception, 'type'
    eq $P1801, .CONTROL_LOOP_NEXT, loop1799_next
    eq $P1801, .CONTROL_LOOP_REDO, loop1799_redo
  loop1799_done:
    pop_eh 
  for_undef_615:
.annotate 'line', 761
    .return ($P1787)
.end


.namespace ["NQP";"Actions"]
.sub "_block1768"  :anon :subid("101_1296306531.71605") :outer("100_1296306531.71605")
.annotate 'line', 764
    new $P1770, "Undef"
    .lex "$inv", $P1770
    find_lex $P1771, "$/"
    unless_null $P1771, vivify_608
    $P1771 = root_new ['parrot';'Hash']
  vivify_608:
    set $P1772, $P1771["invocant"]
    unless_null $P1772, vivify_609
    $P1772 = root_new ['parrot';'ResizablePMCArray']
  vivify_609:
    set $P1773, $P1772[0]
    unless_null $P1773, vivify_610
    new $P1773, "Undef"
  vivify_610:
    $P1774 = $P1773."ast"()
    store_lex "$inv", $P1774
.annotate 'line', 765
    find_lex $P1775, "$BLOCKINIT"
    find_lex $P1776, "$inv"
    $P1775."push"($P1776)
.annotate 'line', 766
    find_lex $P1777, "$BLOCKINIT"
    get_hll_global $P1778, ["PAST"], "Var"
.annotate 'line', 768
    get_hll_global $P1779, ["PAST"], "Var"
    find_lex $P1780, "$inv"
    $P1781 = $P1780."name"()
    $P1782 = $P1779."new"("lexical" :named("scope"), $P1781 :named("name"))
    $P1783 = $P1778."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1782 :named("viviself"))
.annotate 'line', 766
    $P1777."push"($P1783)
.annotate 'line', 770
    new $P1784, "Integer"
    assign $P1784, 1
    get_global $P1785, "@BLOCK"
    unless_null $P1785, vivify_611
    $P1785 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1785
  vivify_611:
    set $P1786, $P1785[0]
    unless_null $P1786, vivify_612
    $P1786 = root_new ['parrot';'Hash']
    set $P1785[0], $P1786
  vivify_612:
    set $P1786["signature_has_invocant"], $P1784
.annotate 'line', 763
    .return ($P1784)
.end


.namespace ["NQP";"Actions"]
.sub "_block1792"  :anon :subid("102_1296306531.71605") :outer("100_1296306531.71605")
    .param pmc param_1794
.annotate 'line', 772
    .lex "$_", param_1794
    find_lex $P1795, "$BLOCKINIT"
    find_lex $P1796, "$_"
    $P1797 = $P1796."ast"()
    $P1798 = $P1795."push"($P1797)
    .return ($P1798)
.end


.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("103_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1803
    .param pmc param_1804
.annotate 'line', 775
    .lex "self", param_1803
    .lex "$/", param_1804
.annotate 'line', 776
    new $P1805, "Undef"
    .lex "$quant", $P1805
.annotate 'line', 777
    new $P1806, "Undef"
    .lex "$past", $P1806
.annotate 'line', 776
    find_lex $P1807, "$/"
    unless_null $P1807, vivify_616
    $P1807 = root_new ['parrot';'Hash']
  vivify_616:
    set $P1808, $P1807["quant"]
    unless_null $P1808, vivify_617
    new $P1808, "Undef"
  vivify_617:
    store_lex "$quant", $P1808
    find_lex $P1809, "$past"
.annotate 'line', 778
    find_lex $P1811, "$/"
    unless_null $P1811, vivify_618
    $P1811 = root_new ['parrot';'Hash']
  vivify_618:
    set $P1812, $P1811["named_param"]
    unless_null $P1812, vivify_619
    new $P1812, "Undef"
  vivify_619:
    if $P1812, if_1810
.annotate 'line', 785
    find_lex $P1826, "$/"
    unless_null $P1826, vivify_620
    $P1826 = root_new ['parrot';'Hash']
  vivify_620:
    set $P1827, $P1826["param_var"]
    unless_null $P1827, vivify_621
    new $P1827, "Undef"
  vivify_621:
    $P1828 = $P1827."ast"()
    store_lex "$past", $P1828
.annotate 'line', 786
    find_lex $P1830, "$quant"
    set $S1831, $P1830
    iseq $I1832, $S1831, "*"
    if $I1832, if_1829
.annotate 'line', 790
    find_lex $P1841, "$quant"
    set $S1842, $P1841
    iseq $I1843, $S1842, "?"
    unless $I1843, if_1840_end
.annotate 'line', 791
    find_lex $P1844, "$past"
    find_lex $P1845, "$/"
    unless_null $P1845, vivify_622
    $P1845 = root_new ['parrot';'Hash']
  vivify_622:
    set $P1846, $P1845["param_var"]
    unless_null $P1846, vivify_623
    $P1846 = root_new ['parrot';'Hash']
  vivify_623:
    set $P1847, $P1846["sigil"]
    unless_null $P1847, vivify_624
    new $P1847, "Undef"
  vivify_624:
    $P1848 = "vivitype"($P1847)
    $P1844."viviself"($P1848)
  if_1840_end:
.annotate 'line', 790
    goto if_1829_end
  if_1829:
.annotate 'line', 787
    find_lex $P1833, "$past"
    $P1833."slurpy"(1)
.annotate 'line', 788
    find_lex $P1834, "$past"
    find_lex $P1835, "$/"
    unless_null $P1835, vivify_625
    $P1835 = root_new ['parrot';'Hash']
  vivify_625:
    set $P1836, $P1835["param_var"]
    unless_null $P1836, vivify_626
    $P1836 = root_new ['parrot';'Hash']
  vivify_626:
    set $P1837, $P1836["sigil"]
    unless_null $P1837, vivify_627
    new $P1837, "Undef"
  vivify_627:
    set $S1838, $P1837
    iseq $I1839, $S1838, "%"
    $P1834."named"($I1839)
  if_1829_end:
.annotate 'line', 784
    goto if_1810_end
  if_1810:
.annotate 'line', 779
    find_lex $P1813, "$/"
    unless_null $P1813, vivify_628
    $P1813 = root_new ['parrot';'Hash']
  vivify_628:
    set $P1814, $P1813["named_param"]
    unless_null $P1814, vivify_629
    new $P1814, "Undef"
  vivify_629:
    $P1815 = $P1814."ast"()
    store_lex "$past", $P1815
.annotate 'line', 780
    find_lex $P1817, "$quant"
    set $S1818, $P1817
    isne $I1819, $S1818, "!"
    unless $I1819, if_1816_end
.annotate 'line', 781
    find_lex $P1820, "$past"
    find_lex $P1821, "$/"
    unless_null $P1821, vivify_630
    $P1821 = root_new ['parrot';'Hash']
  vivify_630:
    set $P1822, $P1821["named_param"]
    unless_null $P1822, vivify_631
    $P1822 = root_new ['parrot';'Hash']
  vivify_631:
    set $P1823, $P1822["param_var"]
    unless_null $P1823, vivify_632
    $P1823 = root_new ['parrot';'Hash']
  vivify_632:
    set $P1824, $P1823["sigil"]
    unless_null $P1824, vivify_633
    new $P1824, "Undef"
  vivify_633:
    $P1825 = "vivitype"($P1824)
    $P1820."viviself"($P1825)
  if_1816_end:
  if_1810_end:
.annotate 'line', 794
    find_lex $P1850, "$/"
    unless_null $P1850, vivify_634
    $P1850 = root_new ['parrot';'Hash']
  vivify_634:
    set $P1851, $P1850["default_value"]
    unless_null $P1851, vivify_635
    new $P1851, "Undef"
  vivify_635:
    unless $P1851, if_1849_end
.annotate 'line', 795
    find_lex $P1853, "$quant"
    set $S1854, $P1853
    iseq $I1855, $S1854, "*"
    unless $I1855, if_1852_end
.annotate 'line', 796
    find_lex $P1856, "$/"
    $P1857 = $P1856."CURSOR"()
    $P1857."panic"("Can't put default on slurpy parameter")
  if_1852_end:
.annotate 'line', 798
    find_lex $P1859, "$quant"
    set $S1860, $P1859
    iseq $I1861, $S1860, "!"
    unless $I1861, if_1858_end
.annotate 'line', 799
    find_lex $P1862, "$/"
    $P1863 = $P1862."CURSOR"()
    $P1863."panic"("Can't put default on required parameter")
  if_1858_end:
.annotate 'line', 801
    find_lex $P1864, "$past"
    find_lex $P1865, "$/"
    unless_null $P1865, vivify_636
    $P1865 = root_new ['parrot';'Hash']
  vivify_636:
    set $P1866, $P1865["default_value"]
    unless_null $P1866, vivify_637
    $P1866 = root_new ['parrot';'ResizablePMCArray']
  vivify_637:
    set $P1867, $P1866[0]
    unless_null $P1867, vivify_638
    $P1867 = root_new ['parrot';'Hash']
  vivify_638:
    set $P1868, $P1867["EXPR"]
    unless_null $P1868, vivify_639
    new $P1868, "Undef"
  vivify_639:
    $P1869 = $P1868."ast"()
    $P1864."viviself"($P1869)
  if_1849_end:
.annotate 'line', 803
    find_lex $P1871, "$past"
    $P1872 = $P1871."viviself"()
    if $P1872, unless_1870_end
    get_global $P1873, "@BLOCK"
    unless_null $P1873, vivify_640
    $P1873 = root_new ['parrot';'ResizablePMCArray']
  vivify_640:
    set $P1874, $P1873[0]
    unless_null $P1874, vivify_641
    new $P1874, "Undef"
  vivify_641:
    get_global $P1875, "@BLOCK"
    unless_null $P1875, vivify_642
    $P1875 = root_new ['parrot';'ResizablePMCArray']
  vivify_642:
    set $P1876, $P1875[0]
    unless_null $P1876, vivify_643
    new $P1876, "Undef"
  vivify_643:
    $P1877 = $P1876."arity"()
    set $N1878, $P1877
    new $P1879, 'Float'
    set $P1879, $N1878
    add $P1880, $P1879, 1
    $P1874."arity"($P1880)
  unless_1870_end:
.annotate 'line', 807
    find_lex $P1882, "$/"
    unless_null $P1882, vivify_644
    $P1882 = root_new ['parrot';'Hash']
  vivify_644:
    set $P1883, $P1882["typename"]
    unless_null $P1883, vivify_645
    new $P1883, "Undef"
  vivify_645:
    unless $P1883, if_1881_end
.annotate 'line', 808
    find_lex $P1884, "$past"
    find_lex $P1885, "$/"
    unless_null $P1885, vivify_646
    $P1885 = root_new ['parrot';'Hash']
  vivify_646:
    set $P1886, $P1885["typename"]
    unless_null $P1886, vivify_647
    $P1886 = root_new ['parrot';'ResizablePMCArray']
  vivify_647:
    set $P1887, $P1886[0]
    unless_null $P1887, vivify_648
    new $P1887, "Undef"
  vivify_648:
    $P1888 = $P1887."ast"()
    $P1884."multitype"($P1888)
  if_1881_end:
.annotate 'line', 812
    find_lex $P1890, "$/"
    unless_null $P1890, vivify_649
    $P1890 = root_new ['parrot';'Hash']
  vivify_649:
    set $P1891, $P1890["definedness"]
    unless_null $P1891, vivify_650
    new $P1891, "Undef"
  vivify_650:
    unless $P1891, if_1889_end
.annotate 'line', 813
    find_lex $P1892, "$/"
    unless_null $P1892, vivify_651
    $P1892 = root_new ['parrot';'Hash']
  vivify_651:
    set $P1893, $P1892["definedness"]
    unless_null $P1893, vivify_652
    $P1893 = root_new ['parrot';'ResizablePMCArray']
  vivify_652:
    set $P1894, $P1893[0]
    unless_null $P1894, vivify_653
    new $P1894, "Undef"
  vivify_653:
    set $S1895, $P1894
    new $P1896, 'String'
    set $P1896, $S1895
    find_lex $P1897, "$past"
    unless_null $P1897, vivify_654
    $P1897 = root_new ['parrot';'Hash']
    store_lex "$past", $P1897
  vivify_654:
    set $P1897["definedness"], $P1896
  if_1889_end:
.annotate 'line', 816
    find_lex $P1898, "$/"
    find_lex $P1899, "$past"
    $P1900 = $P1898."!make"($P1899)
.annotate 'line', 775
    .return ($P1900)
.end


.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("104_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1902
    .param pmc param_1903
.annotate 'line', 819
    .lex "self", param_1902
    .lex "$/", param_1903
.annotate 'line', 820
    new $P1904, "Undef"
    .lex "$name", $P1904
.annotate 'line', 821
    new $P1905, "Undef"
    .lex "$past", $P1905
.annotate 'line', 820
    find_lex $P1906, "$/"
    set $S1907, $P1906
    new $P1908, 'String'
    set $P1908, $S1907
    store_lex "$name", $P1908
.annotate 'line', 821
    get_hll_global $P1909, ["PAST"], "Var"
    find_lex $P1910, "$name"
    find_lex $P1911, "$/"
    $P1912 = $P1909."new"($P1910 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P1911 :named("node"))
    store_lex "$past", $P1912
.annotate 'line', 823
    get_global $P1913, "@BLOCK"
    unless_null $P1913, vivify_655
    $P1913 = root_new ['parrot';'ResizablePMCArray']
  vivify_655:
    set $P1914, $P1913[0]
    unless_null $P1914, vivify_656
    new $P1914, "Undef"
  vivify_656:
    find_lex $P1915, "$name"
    $P1914."symbol"($P1915, "lexical" :named("scope"))
.annotate 'line', 824
    find_lex $P1916, "$/"
    find_lex $P1917, "$past"
    $P1918 = $P1916."!make"($P1917)
.annotate 'line', 819
    .return ($P1918)
.end


.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("105_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1920
    .param pmc param_1921
.annotate 'line', 827
    .lex "self", param_1920
    .lex "$/", param_1921
.annotate 'line', 828
    new $P1922, "Undef"
    .lex "$past", $P1922
    find_lex $P1923, "$/"
    unless_null $P1923, vivify_657
    $P1923 = root_new ['parrot';'Hash']
  vivify_657:
    set $P1924, $P1923["param_var"]
    unless_null $P1924, vivify_658
    new $P1924, "Undef"
  vivify_658:
    $P1925 = $P1924."ast"()
    store_lex "$past", $P1925
.annotate 'line', 829
    find_lex $P1926, "$past"
    find_lex $P1927, "$/"
    unless_null $P1927, vivify_659
    $P1927 = root_new ['parrot';'Hash']
  vivify_659:
    set $P1928, $P1927["param_var"]
    unless_null $P1928, vivify_660
    $P1928 = root_new ['parrot';'Hash']
  vivify_660:
    set $P1929, $P1928["name"]
    unless_null $P1929, vivify_661
    new $P1929, "Undef"
  vivify_661:
    set $S1930, $P1929
    $P1926."named"($S1930)
.annotate 'line', 830
    find_lex $P1931, "$/"
    find_lex $P1932, "$past"
    $P1933 = $P1931."!make"($P1932)
.annotate 'line', 827
    .return ($P1933)
.end


.namespace ["NQP";"Actions"]
.sub "typename"  :subid("106_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1935
    .param pmc param_1936
.annotate 'line', 833
    .lex "self", param_1935
    .lex "$/", param_1936
.annotate 'line', 834
    $P1937 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P1937
    get_hll_global $P1938, ["HLL"], "Compiler"
    find_lex $P1939, "$/"
    set $S1940, $P1939
    $P1941 = $P1938."parse_name"($S1940)
    store_lex "@name", $P1941
.annotate 'line', 835
    find_lex $P1942, "$/"
    get_hll_global $P1943, ["PAST"], "Var"
.annotate 'line', 836
    find_lex $P1944, "@name"
    $P1945 = $P1944."pop"()
    find_lex $P1946, "@name"
    $P1947 = $P1943."new"($P1945 :named("name"), $P1946 :named("namespace"), "package" :named("scope"))
.annotate 'line', 835
    $P1948 = $P1942."!make"($P1947)
.annotate 'line', 833
    .return ($P1948)
.end


.namespace ["NQP";"Actions"]
.sub "trait"  :subid("107_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1950
    .param pmc param_1951
.annotate 'line', 842
    .lex "self", param_1950
    .lex "$/", param_1951
.annotate 'line', 843
    find_lex $P1952, "$/"
    find_lex $P1953, "$/"
    unless_null $P1953, vivify_662
    $P1953 = root_new ['parrot';'Hash']
  vivify_662:
    set $P1954, $P1953["trait_mod"]
    unless_null $P1954, vivify_663
    new $P1954, "Undef"
  vivify_663:
    $P1955 = $P1954."ast"()
    $P1956 = $P1952."!make"($P1955)
.annotate 'line', 842
    .return ($P1956)
.end


.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("108_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_1958
    .param pmc param_1959
.annotate 'line', 846
    .const 'Sub' $P1979 = "109_1296306531.71605" 
    capture_lex $P1979
    .lex "self", param_1958
    .lex "$/", param_1959
.annotate 'line', 847
    new $P1960, "Undef"
    .lex "$cpast", $P1960
    find_lex $P1961, "$/"
    unless_null $P1961, vivify_664
    $P1961 = root_new ['parrot';'Hash']
  vivify_664:
    set $P1962, $P1961["circumfix"]
    unless_null $P1962, vivify_665
    $P1962 = root_new ['parrot';'ResizablePMCArray']
  vivify_665:
    set $P1963, $P1962[0]
    unless_null $P1963, vivify_666
    new $P1963, "Undef"
  vivify_666:
    $P1964 = $P1963."ast"()
    store_lex "$cpast", $P1964
.annotate 'line', 848
    find_lex $P1967, "$/"
    unless_null $P1967, vivify_667
    $P1967 = root_new ['parrot';'Hash']
  vivify_667:
    set $P1968, $P1967["longname"]
    unless_null $P1968, vivify_668
    new $P1968, "Undef"
  vivify_668:
    set $S1969, $P1968
    iseq $I1970, $S1969, "pirflags"
    if $I1970, if_1966
.annotate 'line', 854
    find_lex $P1989, "$/"
    $P1990 = $P1989."CURSOR"()
    new $P1991, 'String'
    set $P1991, "Trait '"
    find_lex $P1992, "$/"
    unless_null $P1992, vivify_669
    $P1992 = root_new ['parrot';'Hash']
  vivify_669:
    set $P1993, $P1992["longname"]
    unless_null $P1993, vivify_670
    new $P1993, "Undef"
  vivify_670:
    concat $P1994, $P1991, $P1993
    concat $P1995, $P1994, "' not implemented"
    $P1996 = $P1990."panic"($P1995)
.annotate 'line', 853
    set $P1965, $P1996
.annotate 'line', 848
    goto if_1966_end
  if_1966:
.annotate 'line', 850
    get_hll_global $P1972, ["PAST"], "Val"
    find_lex $P1973, "$cpast"
    $P1974 = $P1972."ACCEPTS"($P1973)
    if $P1974, unless_1971_end
.annotate 'line', 849
    find_lex $P1975, "$/"
    $P1976 = $P1975."CURSOR"()
    $P1976."panic"("Trait 'pirflags' requires constant scalar argument")
  unless_1971_end:
.annotate 'line', 851
    find_lex $P1977, "$/"
    .const 'Sub' $P1979 = "109_1296306531.71605" 
    newclosure $P1987, $P1979
    $P1988 = $P1977."!make"($P1987)
.annotate 'line', 848
    set $P1965, $P1988
  if_1966_end:
.annotate 'line', 846
    .return ($P1965)
.end


.namespace ["NQP";"Actions"]
.sub "_block1978"  :anon :subid("109_1296306531.71605") :outer("108_1296306531.71605")
    .param pmc param_1980
.annotate 'line', 851
    .lex "$match", param_1980
    find_lex $P1981, "$match"
    $P1982 = $P1981."ast"()
    set $P1983, $P1982["block_past"]
    unless_null $P1983, vivify_671
    new $P1983, "Undef"
  vivify_671:
    find_lex $P1984, "$cpast"
    $P1985 = $P1984."value"()
    $P1986 = $P1983."pirflags"($P1985)
    .return ($P1986)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("110_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2000
    .param pmc param_2001
    .param pmc param_2002 :optional
    .param int has_param_2002 :opt_flag
.annotate 'line', 858
    .const 'Sub' $P2100 = "113_1296306531.71605" 
    capture_lex $P2100
    .const 'Sub' $P2072 = "112_1296306531.71605" 
    capture_lex $P2072
    .const 'Sub' $P2045 = "111_1296306531.71605" 
    capture_lex $P2045
    new $P1999, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1999, control_1998
    push_eh $P1999
    .lex "self", param_2000
    .lex "$/", param_2001
    if has_param_2002, optparam_672
    new $P2003, "Undef"
    set param_2002, $P2003
  optparam_672:
    .lex "$key", param_2002
.annotate 'line', 859
    $P2004 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2004
.annotate 'line', 862
    new $P2005, "Undef"
    .lex "$name", $P2005
.annotate 'line', 863
    new $P2006, "Undef"
    .lex "$past", $P2006
.annotate 'line', 859

        $P2007 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2007
.annotate 'line', 862
    find_lex $P2008, "$/"
    unless_null $P2008, vivify_673
    $P2008 = root_new ['parrot';'Hash']
  vivify_673:
    set $P2009, $P2008["deflongname"]
    unless_null $P2009, vivify_674
    new $P2009, "Undef"
  vivify_674:
    $P2010 = $P2009."ast"()
    set $S2011, $P2010
    new $P2012, 'String'
    set $P2012, $S2011
    store_lex "$name", $P2012
    find_lex $P2013, "$past"
.annotate 'line', 864
    find_lex $P2015, "$/"
    unless_null $P2015, vivify_675
    $P2015 = root_new ['parrot';'Hash']
  vivify_675:
    set $P2016, $P2015["proto"]
    unless_null $P2016, vivify_676
    new $P2016, "Undef"
  vivify_676:
    if $P2016, if_2014
.annotate 'line', 903
    find_lex $P2068, "$key"
    set $S2069, $P2068
    iseq $I2070, $S2069, "open"
    if $I2070, if_2067
.annotate 'line', 916
    .const 'Sub' $P2100 = "113_1296306531.71605" 
    capture_lex $P2100
    $P2100()
    goto if_2067_end
  if_2067:
.annotate 'line', 903
    .const 'Sub' $P2072 = "112_1296306531.71605" 
    capture_lex $P2072
    $P2072()
  if_2067_end:
    goto if_2014_end
  if_2014:
.annotate 'line', 866
    get_hll_global $P2017, ["PAST"], "Stmts"
.annotate 'line', 867
    get_hll_global $P2018, ["PAST"], "Block"
    find_lex $P2019, "$name"
.annotate 'line', 868
    get_hll_global $P2020, ["PAST"], "Op"
.annotate 'line', 869
    get_hll_global $P2021, ["PAST"], "Var"
    $P2022 = $P2021."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2023, "$name"
    $P2024 = $P2020."new"($P2022, $P2023, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 868
    find_lex $P2025, "$/"
    $P2026 = $P2018."new"($P2024, $P2019 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2025 :named("node"))
.annotate 'line', 878
    get_hll_global $P2027, ["PAST"], "Block"
    new $P2028, "String"
    assign $P2028, "!PREFIX__"
    find_lex $P2029, "$name"
    concat $P2030, $P2028, $P2029
.annotate 'line', 879
    get_hll_global $P2031, ["PAST"], "Op"
.annotate 'line', 880
    get_hll_global $P2032, ["PAST"], "Var"
    $P2033 = $P2032."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2034, "$name"
    $P2035 = $P2031."new"($P2033, $P2034, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 879
    find_lex $P2036, "$/"
    $P2037 = $P2027."new"($P2035, $P2030 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2036 :named("node"))
.annotate 'line', 878
    $P2038 = $P2017."new"($P2026, $P2037)
.annotate 'line', 866
    store_lex "$past", $P2038
.annotate 'line', 890
    find_lex $P2040, "$past"
    $P2041 = $P2040."list"()
    defined $I2042, $P2041
    unless $I2042, for_undef_697
    iter $P2039, $P2041
    new $P2065, 'ExceptionHandler'
    set_addr $P2065, loop2064_handler
    $P2065."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2065
  loop2064_test:
    unless $P2039, loop2064_done
    shift $P2043, $P2039
  loop2064_redo:
    .const 'Sub' $P2045 = "111_1296306531.71605" 
    capture_lex $P2045
    $P2045($P2043)
  loop2064_next:
    goto loop2064_test
  loop2064_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2066, exception, 'type'
    eq $P2066, .CONTROL_LOOP_NEXT, loop2064_next
    eq $P2066, .CONTROL_LOOP_REDO, loop2064_redo
  loop2064_done:
    pop_eh 
  for_undef_697:
  if_2014_end:
.annotate 'line', 952
    find_lex $P2158, "$/"
    find_lex $P2159, "$past"
    $P2160 = $P2158."!make"($P2159)
.annotate 'line', 858
    .return ($P2160)
  control_1998:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2161, exception, "payload"
    .return ($P2161)
.end


.namespace ["NQP";"Actions"]
.sub "_block2099"  :anon :subid("113_1296306531.71605") :outer("110_1296306531.71605")
.annotate 'line', 917
    new $P2101, "Undef"
    .lex "$regex", $P2101
.annotate 'line', 918
    get_hll_global $P2102, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2103, "$/"
    unless_null $P2103, vivify_677
    $P2103 = root_new ['parrot';'Hash']
  vivify_677:
    set $P2104, $P2103["p6regex"]
    unless_null $P2104, vivify_678
    new $P2104, "Undef"
  vivify_678:
    $P2105 = $P2104."ast"()
    get_global $P2106, "@BLOCK"
    $P2107 = $P2106."shift"()
    $P2108 = $P2102($P2105, $P2107)
    store_lex "$regex", $P2108
.annotate 'line', 919
    find_lex $P2109, "$regex"
    find_lex $P2110, "$name"
    $P2109."name"($P2110)
.annotate 'line', 921
    get_hll_global $P2111, ["PAST"], "Op"
.annotate 'line', 923
    get_hll_global $P2112, ["PAST"], "Var"
    new $P2113, "ResizablePMCArray"
    push $P2113, "Regex"
    $P2114 = $P2112."new"("Method" :named("name"), $P2113 :named("namespace"), "package" :named("scope"))
    find_lex $P2115, "$regex"
    $P2116 = $P2111."new"($P2114, $P2115, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 921
    store_lex "$past", $P2116
.annotate 'line', 926
    find_dynamic_lex $P2118, "$*PACKAGE-SETUP"
    unless_null $P2118, vivify_679
    get_hll_global $P2118, "$PACKAGE-SETUP"
    unless_null $P2118, vivify_680
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_680:
  vivify_679:
    defined $I2119, $P2118
    unless $I2119, if_2117_end
.annotate 'line', 927
    find_dynamic_lex $P2120, "$*PACKAGE-SETUP"
    unless_null $P2120, vivify_681
    get_hll_global $P2120, "$PACKAGE-SETUP"
    unless_null $P2120, vivify_682
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_682:
  vivify_681:
    get_hll_global $P2121, ["PAST"], "Op"
.annotate 'line', 929
    get_hll_global $P2122, ["PAST"], "Op"
.annotate 'line', 931
    get_hll_global $P2123, ["PAST"], "Var"
    $P2124 = $P2123."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2125 = $P2122."new"($P2124, "get_how PP" :named("pirop"))
.annotate 'line', 933
    get_hll_global $P2126, ["PAST"], "Var"
    $P2127 = $P2126."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 934
    get_hll_global $P2128, ["PAST"], "Val"
    find_lex $P2129, "$name"
    $P2130 = $P2128."new"($P2129 :named("value"))
.annotate 'line', 935
    get_hll_global $P2131, ["PAST"], "Val"
    find_lex $P2132, "$regex"
    $P2133 = $P2131."new"($P2132 :named("value"))
    $P2134 = $P2121."new"($P2125, $P2127, $P2130, $P2133, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 927
    $P2120."push"($P2134)
.annotate 'line', 937
    find_dynamic_lex $P2135, "$*PACKAGE-SETUP"
    unless_null $P2135, vivify_683
    get_hll_global $P2135, "$PACKAGE-SETUP"
    unless_null $P2135, vivify_684
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_684:
  vivify_683:
    get_hll_global $P2136, ["PAST"], "Op"
.annotate 'line', 939
    get_hll_global $P2137, ["PAST"], "Op"
.annotate 'line', 941
    get_hll_global $P2138, ["PAST"], "Var"
    $P2139 = $P2138."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2140 = $P2137."new"($P2139, "get_how PP" :named("pirop"))
.annotate 'line', 943
    get_hll_global $P2141, ["PAST"], "Var"
    $P2142 = $P2141."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 944
    get_hll_global $P2143, ["PAST"], "Val"
    new $P2144, "String"
    assign $P2144, "!PREFIX__"
    find_lex $P2145, "$name"
    concat $P2146, $P2144, $P2145
    $P2147 = $P2143."new"($P2146 :named("value"))
.annotate 'line', 945
    get_hll_global $P2148, ["PAST"], "Var"
    new $P2149, "String"
    assign $P2149, "!PREFIX__"
    find_lex $P2150, "$name"
    concat $P2151, $P2149, $P2150
    $P2152 = $P2148."new"($P2151 :named("name"), "package" :named("scope"))
    $P2153 = $P2136."new"($P2140, $P2142, $P2147, $P2152, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 937
    $P2135."push"($P2153)
  if_2117_end:
.annotate 'line', 949
    find_lex $P2154, "$regex"
    find_lex $P2155, "$past"
    unless_null $P2155, vivify_685
    $P2155 = root_new ['parrot';'Hash']
    store_lex "$past", $P2155
  vivify_685:
    set $P2155["sink"], $P2154
.annotate 'line', 950
    find_lex $P2156, "@MODIFIERS"
    $P2157 = $P2156."shift"()
.annotate 'line', 916
    .return ($P2157)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2071"  :anon :subid("112_1296306531.71605") :outer("110_1296306531.71605")
.annotate 'line', 904
    $P2073 = root_new ['parrot';'Hash']
    .lex "%h", $P2073
.annotate 'line', 903
    find_lex $P2074, "%h"
.annotate 'line', 905
    find_lex $P2076, "$/"
    unless_null $P2076, vivify_686
    $P2076 = root_new ['parrot';'Hash']
  vivify_686:
    set $P2077, $P2076["sym"]
    unless_null $P2077, vivify_687
    new $P2077, "Undef"
  vivify_687:
    set $S2078, $P2077
    iseq $I2079, $S2078, "token"
    unless $I2079, if_2075_end
    new $P2080, "Integer"
    assign $P2080, 1
    find_lex $P2081, "%h"
    unless_null $P2081, vivify_688
    $P2081 = root_new ['parrot';'Hash']
    store_lex "%h", $P2081
  vivify_688:
    set $P2081["r"], $P2080
  if_2075_end:
.annotate 'line', 906
    find_lex $P2083, "$/"
    unless_null $P2083, vivify_689
    $P2083 = root_new ['parrot';'Hash']
  vivify_689:
    set $P2084, $P2083["sym"]
    unless_null $P2084, vivify_690
    new $P2084, "Undef"
  vivify_690:
    set $S2085, $P2084
    iseq $I2086, $S2085, "rule"
    unless $I2086, if_2082_end
    new $P2087, "Integer"
    assign $P2087, 1
    find_lex $P2088, "%h"
    unless_null $P2088, vivify_691
    $P2088 = root_new ['parrot';'Hash']
    store_lex "%h", $P2088
  vivify_691:
    set $P2088["r"], $P2087
    new $P2089, "Integer"
    assign $P2089, 1
    find_lex $P2090, "%h"
    unless_null $P2090, vivify_692
    $P2090 = root_new ['parrot';'Hash']
    store_lex "%h", $P2090
  vivify_692:
    set $P2090["s"], $P2089
  if_2082_end:
.annotate 'line', 907
    find_lex $P2091, "@MODIFIERS"
    find_lex $P2092, "%h"
    $P2091."unshift"($P2092)
.annotate 'line', 908

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 912
    get_global $P2093, "@BLOCK"
    unless_null $P2093, vivify_693
    $P2093 = root_new ['parrot';'ResizablePMCArray']
  vivify_693:
    set $P2094, $P2093[0]
    unless_null $P2094, vivify_694
    new $P2094, "Undef"
  vivify_694:
    $P2094."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 913
    get_global $P2095, "@BLOCK"
    unless_null $P2095, vivify_695
    $P2095 = root_new ['parrot';'ResizablePMCArray']
  vivify_695:
    set $P2096, $P2095[0]
    unless_null $P2096, vivify_696
    new $P2096, "Undef"
  vivify_696:
    $P2096."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 914
    new $P2097, "Exception"
    set $P2097['type'], .CONTROL_RETURN
    new $P2098, "Integer"
    assign $P2098, 0
    setattribute $P2097, 'payload', $P2098
    throw $P2097
.annotate 'line', 903
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "_block2044"  :anon :subid("111_1296306531.71605") :outer("110_1296306531.71605")
    .param pmc param_2046
.annotate 'line', 890
    .lex "$_", param_2046
.annotate 'line', 891
    find_dynamic_lex $P2047, "$*PACKAGE-SETUP"
    unless_null $P2047, vivify_698
    get_hll_global $P2047, "$PACKAGE-SETUP"
    unless_null $P2047, vivify_699
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_699:
  vivify_698:
    get_hll_global $P2048, ["PAST"], "Op"
.annotate 'line', 893
    get_hll_global $P2049, ["PAST"], "Op"
.annotate 'line', 895
    get_hll_global $P2050, ["PAST"], "Var"
    $P2051 = $P2050."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2052 = $P2049."new"($P2051, "get_how PP" :named("pirop"))
.annotate 'line', 897
    get_hll_global $P2053, ["PAST"], "Var"
    $P2054 = $P2053."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 898
    get_hll_global $P2055, ["PAST"], "Val"
    find_lex $P2056, "$_"
    $P2057 = $P2056."name"()
    $P2058 = $P2055."new"($P2057 :named("value"))
.annotate 'line', 899
    get_hll_global $P2059, ["PAST"], "Val"
    find_lex $P2060, "$_"
    $P2061 = $P2059."new"($P2060 :named("value"))
    $P2062 = $P2048."new"($P2052, $P2054, $P2058, $P2061, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 891
    $P2063 = $P2047."push"($P2062)
.annotate 'line', 890
    .return ($P2063)
.end


.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("114_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2163
    .param pmc param_2164
.annotate 'line', 956
    .lex "self", param_2163
    .lex "$/", param_2164
.annotate 'line', 957
    new $P2165, "Undef"
    .lex "$past", $P2165
    find_lex $P2168, "$/"
    unless_null $P2168, vivify_700
    $P2168 = root_new ['parrot';'Hash']
  vivify_700:
    set $P2169, $P2168["args"]
    unless_null $P2169, vivify_701
    new $P2169, "Undef"
  vivify_701:
    if $P2169, if_2167
    get_hll_global $P2174, ["PAST"], "Op"
    find_lex $P2175, "$/"
    $P2176 = $P2174."new"($P2175 :named("node"))
    set $P2166, $P2176
    goto if_2167_end
  if_2167:
    find_lex $P2170, "$/"
    unless_null $P2170, vivify_702
    $P2170 = root_new ['parrot';'Hash']
  vivify_702:
    set $P2171, $P2170["args"]
    unless_null $P2171, vivify_703
    $P2171 = root_new ['parrot';'ResizablePMCArray']
  vivify_703:
    set $P2172, $P2171[0]
    unless_null $P2172, vivify_704
    new $P2172, "Undef"
  vivify_704:
    $P2173 = $P2172."ast"()
    set $P2166, $P2173
  if_2167_end:
    store_lex "$past", $P2166
.annotate 'line', 958
    find_lex $P2178, "$/"
    unless_null $P2178, vivify_705
    $P2178 = root_new ['parrot';'Hash']
  vivify_705:
    set $P2179, $P2178["quote"]
    unless_null $P2179, vivify_706
    new $P2179, "Undef"
  vivify_706:
    if $P2179, if_2177
.annotate 'line', 962
    find_lex $P2186, "$/"
    unless_null $P2186, vivify_707
    $P2186 = root_new ['parrot';'Hash']
  vivify_707:
    set $P2187, $P2186["longname"]
    unless_null $P2187, vivify_708
    new $P2187, "Undef"
  vivify_708:
    set $S2188, $P2187
    iseq $I2189, $S2188, "HOW"
    if $I2189, if_2185
.annotate 'line', 966
    find_lex $P2193, "$/"
    unless_null $P2193, vivify_709
    $P2193 = root_new ['parrot';'Hash']
  vivify_709:
    set $P2194, $P2193["longname"]
    unless_null $P2194, vivify_710
    new $P2194, "Undef"
  vivify_710:
    set $S2195, $P2194
    iseq $I2196, $S2195, "WHAT"
    if $I2196, if_2192
.annotate 'line', 970
    find_lex $P2198, "$past"
    find_lex $P2199, "$/"
    unless_null $P2199, vivify_711
    $P2199 = root_new ['parrot';'Hash']
  vivify_711:
    set $P2200, $P2199["longname"]
    unless_null $P2200, vivify_712
    new $P2200, "Undef"
  vivify_712:
    set $S2201, $P2200
    $P2198."name"($S2201)
.annotate 'line', 971
    find_lex $P2202, "$past"
    $P2202."pasttype"("callmethod")
.annotate 'line', 969
    goto if_2192_end
  if_2192:
.annotate 'line', 967
    find_lex $P2197, "$past"
    $P2197."pirop"("get_what PP")
  if_2192_end:
.annotate 'line', 966
    goto if_2185_end
  if_2185:
.annotate 'line', 963
    find_lex $P2190, "$past"
    $P2190."pirop"("get_how PP")
.annotate 'line', 964
    find_lex $P2191, "$past"
    $P2191."pasttype"("pirop")
  if_2185_end:
.annotate 'line', 962
    goto if_2177_end
  if_2177:
.annotate 'line', 959
    find_lex $P2180, "$past"
    find_lex $P2181, "$/"
    unless_null $P2181, vivify_713
    $P2181 = root_new ['parrot';'Hash']
  vivify_713:
    set $P2182, $P2181["quote"]
    unless_null $P2182, vivify_714
    new $P2182, "Undef"
  vivify_714:
    $P2183 = $P2182."ast"()
    $P2180."name"($P2183)
.annotate 'line', 960
    find_lex $P2184, "$past"
    $P2184."pasttype"("callmethod")
  if_2177_end:
.annotate 'line', 973
    find_lex $P2203, "$/"
    find_lex $P2204, "$past"
    $P2205 = $P2203."!make"($P2204)
.annotate 'line', 956
    .return ($P2205)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("115_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2207
    .param pmc param_2208
.annotate 'line', 978
    .lex "self", param_2207
    .lex "$/", param_2208
.annotate 'line', 979
    find_lex $P2209, "$/"
    get_hll_global $P2210, ["PAST"], "Var"
    $P2211 = $P2210."new"("self" :named("name"))
    $P2212 = $P2209."!make"($P2211)
.annotate 'line', 978
    .return ($P2212)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("116_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2214
    .param pmc param_2215
.annotate 'line', 982
    .lex "self", param_2214
    .lex "$/", param_2215
.annotate 'line', 983
    new $P2216, "Undef"
    .lex "$past", $P2216
    find_lex $P2217, "$/"
    unless_null $P2217, vivify_715
    $P2217 = root_new ['parrot';'Hash']
  vivify_715:
    set $P2218, $P2217["args"]
    unless_null $P2218, vivify_716
    new $P2218, "Undef"
  vivify_716:
    $P2219 = $P2218."ast"()
    store_lex "$past", $P2219
.annotate 'line', 984
    find_lex $P2220, "$past"
    find_lex $P2221, "$/"
    unless_null $P2221, vivify_717
    $P2221 = root_new ['parrot';'Hash']
  vivify_717:
    set $P2222, $P2221["deflongname"]
    unless_null $P2222, vivify_718
    new $P2222, "Undef"
  vivify_718:
    set $S2223, $P2222
    $P2220."name"($S2223)
.annotate 'line', 985
    find_lex $P2224, "$/"
    find_lex $P2225, "$past"
    $P2226 = $P2224."!make"($P2225)
.annotate 'line', 982
    .return ($P2226)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("117_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2228
    .param pmc param_2229
.annotate 'line', 988
    .lex "self", param_2228
    .lex "$/", param_2229
.annotate 'line', 989
    $P2230 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2230
.annotate 'line', 990
    new $P2231, "Undef"
    .lex "$name", $P2231
.annotate 'line', 992
    new $P2232, "Undef"
    .lex "$var", $P2232
.annotate 'line', 994
    new $P2233, "Undef"
    .lex "$past", $P2233
.annotate 'line', 989
    find_lex $P2234, "$/"
    unless_null $P2234, vivify_719
    $P2234 = root_new ['parrot';'Hash']
  vivify_719:
    set $P2235, $P2234["name"]
    unless_null $P2235, vivify_720
    $P2235 = root_new ['parrot';'Hash']
  vivify_720:
    set $P2236, $P2235["identifier"]
    unless_null $P2236, vivify_721
    new $P2236, "Undef"
  vivify_721:
    clone $P2237, $P2236
    store_lex "@ns", $P2237
.annotate 'line', 990
    find_lex $P2238, "@ns"
    $P2239 = $P2238."pop"()
    store_lex "$name", $P2239
.annotate 'line', 991
    find_lex $P2243, "@ns"
    if $P2243, if_2242
    set $P2241, $P2243
    goto if_2242_end
  if_2242:
    find_lex $P2244, "@ns"
    unless_null $P2244, vivify_722
    $P2244 = root_new ['parrot';'ResizablePMCArray']
  vivify_722:
    set $P2245, $P2244[0]
    unless_null $P2245, vivify_723
    new $P2245, "Undef"
  vivify_723:
    set $S2246, $P2245
    iseq $I2247, $S2246, "GLOBAL"
    new $P2241, 'Integer'
    set $P2241, $I2247
  if_2242_end:
    unless $P2241, if_2240_end
    find_lex $P2248, "@ns"
    $P2248."shift"()
  if_2240_end:
.annotate 'line', 993
    get_hll_global $P2249, ["PAST"], "Var"
    find_lex $P2250, "$name"
    set $S2251, $P2250
    find_lex $P2252, "@ns"
    $P2253 = $P2249."new"($S2251 :named("name"), $P2252 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2253
.annotate 'line', 994
    find_lex $P2254, "$var"
    store_lex "$past", $P2254
.annotate 'line', 995
    find_lex $P2256, "$/"
    unless_null $P2256, vivify_724
    $P2256 = root_new ['parrot';'Hash']
  vivify_724:
    set $P2257, $P2256["args"]
    unless_null $P2257, vivify_725
    new $P2257, "Undef"
  vivify_725:
    unless $P2257, if_2255_end
.annotate 'line', 996
    find_lex $P2258, "$/"
    unless_null $P2258, vivify_726
    $P2258 = root_new ['parrot';'Hash']
  vivify_726:
    set $P2259, $P2258["args"]
    unless_null $P2259, vivify_727
    $P2259 = root_new ['parrot';'ResizablePMCArray']
  vivify_727:
    set $P2260, $P2259[0]
    unless_null $P2260, vivify_728
    new $P2260, "Undef"
  vivify_728:
    $P2261 = $P2260."ast"()
    store_lex "$past", $P2261
.annotate 'line', 997
    find_lex $P2262, "$past"
    find_lex $P2263, "$var"
    $P2262."unshift"($P2263)
  if_2255_end:
.annotate 'line', 999
    find_lex $P2264, "$/"
    find_lex $P2265, "$past"
    $P2266 = $P2264."!make"($P2265)
.annotate 'line', 988
    .return ($P2266)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("118_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2268
    .param pmc param_2269
.annotate 'line', 1002
    .lex "self", param_2268
    .lex "$/", param_2269
.annotate 'line', 1003
    new $P2270, "Undef"
    .lex "$past", $P2270
.annotate 'line', 1004
    new $P2271, "Undef"
    .lex "$pirop", $P2271
.annotate 'line', 1003
    find_lex $P2274, "$/"
    unless_null $P2274, vivify_729
    $P2274 = root_new ['parrot';'Hash']
  vivify_729:
    set $P2275, $P2274["args"]
    unless_null $P2275, vivify_730
    new $P2275, "Undef"
  vivify_730:
    if $P2275, if_2273
    get_hll_global $P2280, ["PAST"], "Op"
    find_lex $P2281, "$/"
    $P2282 = $P2280."new"($P2281 :named("node"))
    set $P2272, $P2282
    goto if_2273_end
  if_2273:
    find_lex $P2276, "$/"
    unless_null $P2276, vivify_731
    $P2276 = root_new ['parrot';'Hash']
  vivify_731:
    set $P2277, $P2276["args"]
    unless_null $P2277, vivify_732
    $P2277 = root_new ['parrot';'ResizablePMCArray']
  vivify_732:
    set $P2278, $P2277[0]
    unless_null $P2278, vivify_733
    new $P2278, "Undef"
  vivify_733:
    $P2279 = $P2278."ast"()
    set $P2272, $P2279
  if_2273_end:
    store_lex "$past", $P2272
.annotate 'line', 1004
    find_lex $P2283, "$/"
    unless_null $P2283, vivify_734
    $P2283 = root_new ['parrot';'Hash']
  vivify_734:
    set $P2284, $P2283["op"]
    unless_null $P2284, vivify_735
    new $P2284, "Undef"
  vivify_735:
    set $S2285, $P2284
    new $P2286, 'String'
    set $P2286, $S2285
    store_lex "$pirop", $P2286
.annotate 'line', 1005

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2287 = box $S0
    
    store_lex "$pirop", $P2287
.annotate 'line', 1012
    find_lex $P2288, "$past"
    find_lex $P2289, "$pirop"
    $P2288."pirop"($P2289)
.annotate 'line', 1013
    find_lex $P2290, "$past"
    $P2290."pasttype"("pirop")
.annotate 'line', 1014
    find_lex $P2291, "$/"
    find_lex $P2292, "$past"
    $P2293 = $P2291."!make"($P2292)
.annotate 'line', 1002
    .return ($P2293)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("119_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2295
    .param pmc param_2296
.annotate 'line', 1017
    .lex "self", param_2295
    .lex "$/", param_2296
.annotate 'line', 1018
    find_lex $P2297, "$/"
    get_hll_global $P2298, ["PAST"], "Op"
    $P2299 = $P2298."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2300 = $P2297."!make"($P2299)
.annotate 'line', 1017
    .return ($P2300)
.end


.namespace ["NQP";"Actions"]
.sub "args"  :subid("120_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2302
    .param pmc param_2303
.annotate 'line', 1023
    .lex "self", param_2302
    .lex "$/", param_2303
    find_lex $P2304, "$/"
    find_lex $P2305, "$/"
    unless_null $P2305, vivify_736
    $P2305 = root_new ['parrot';'Hash']
  vivify_736:
    set $P2306, $P2305["arglist"]
    unless_null $P2306, vivify_737
    new $P2306, "Undef"
  vivify_737:
    $P2307 = $P2306."ast"()
    $P2308 = $P2304."!make"($P2307)
    .return ($P2308)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("121_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2310
    .param pmc param_2311
.annotate 'line', 1025
    .const 'Sub' $P2322 = "122_1296306531.71605" 
    capture_lex $P2322
    .lex "self", param_2310
    .lex "$/", param_2311
.annotate 'line', 1026
    new $P2312, "Undef"
    .lex "$past", $P2312
.annotate 'line', 1034
    new $P2313, "Undef"
    .lex "$i", $P2313
.annotate 'line', 1035
    new $P2314, "Undef"
    .lex "$n", $P2314
.annotate 'line', 1026
    get_hll_global $P2315, ["PAST"], "Op"
    find_lex $P2316, "$/"
    $P2317 = $P2315."new"("call" :named("pasttype"), $P2316 :named("node"))
    store_lex "$past", $P2317
.annotate 'line', 1027
    find_lex $P2319, "$/"
    unless_null $P2319, vivify_738
    $P2319 = root_new ['parrot';'Hash']
  vivify_738:
    set $P2320, $P2319["EXPR"]
    unless_null $P2320, vivify_739
    new $P2320, "Undef"
  vivify_739:
    unless $P2320, if_2318_end
    .const 'Sub' $P2322 = "122_1296306531.71605" 
    capture_lex $P2322
    $P2322()
  if_2318_end:
.annotate 'line', 1034
    new $P2354, "Integer"
    assign $P2354, 0
    store_lex "$i", $P2354
.annotate 'line', 1035
    find_lex $P2355, "$past"
    $P2356 = $P2355."list"()
    set $N2357, $P2356
    new $P2358, 'Float'
    set $P2358, $N2357
    store_lex "$n", $P2358
.annotate 'line', 1036
    new $P2406, 'ExceptionHandler'
    set_addr $P2406, loop2405_handler
    $P2406."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2406
  loop2405_test:
    find_lex $P2359, "$i"
    set $N2360, $P2359
    find_lex $P2361, "$n"
    set $N2362, $P2361
    islt $I2363, $N2360, $N2362
    unless $I2363, loop2405_done
  loop2405_redo:
.annotate 'line', 1037
    find_lex $P2365, "$i"
    set $I2366, $P2365
    find_lex $P2367, "$past"
    unless_null $P2367, vivify_743
    $P2367 = root_new ['parrot';'ResizablePMCArray']
  vivify_743:
    set $P2368, $P2367[$I2366]
    unless_null $P2368, vivify_744
    new $P2368, "Undef"
  vivify_744:
    $S2369 = $P2368."name"()
    iseq $I2370, $S2369, "&prefix:<|>"
    unless $I2370, if_2364_end
.annotate 'line', 1038
    find_lex $P2371, "$i"
    set $I2372, $P2371
    find_lex $P2373, "$past"
    unless_null $P2373, vivify_745
    $P2373 = root_new ['parrot';'ResizablePMCArray']
  vivify_745:
    set $P2374, $P2373[$I2372]
    unless_null $P2374, vivify_746
    $P2374 = root_new ['parrot';'ResizablePMCArray']
  vivify_746:
    set $P2375, $P2374[0]
    unless_null $P2375, vivify_747
    new $P2375, "Undef"
  vivify_747:
    find_lex $P2376, "$i"
    set $I2377, $P2376
    find_lex $P2378, "$past"
    unless_null $P2378, vivify_748
    $P2378 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2378
  vivify_748:
    set $P2378[$I2377], $P2375
.annotate 'line', 1039
    find_lex $P2379, "$i"
    set $I2380, $P2379
    find_lex $P2381, "$past"
    unless_null $P2381, vivify_749
    $P2381 = root_new ['parrot';'ResizablePMCArray']
  vivify_749:
    set $P2382, $P2381[$I2380]
    unless_null $P2382, vivify_750
    new $P2382, "Undef"
  vivify_750:
    $P2382."flat"(1)
.annotate 'line', 1040
    find_lex $P2386, "$i"
    set $I2387, $P2386
    find_lex $P2388, "$past"
    unless_null $P2388, vivify_751
    $P2388 = root_new ['parrot';'ResizablePMCArray']
  vivify_751:
    set $P2389, $P2388[$I2387]
    unless_null $P2389, vivify_752
    new $P2389, "Undef"
  vivify_752:
    get_hll_global $P2390, ["PAST"], "Val"
    $P2391 = $P2389."isa"($P2390)
    if $P2391, if_2385
    set $P2384, $P2391
    goto if_2385_end
  if_2385:
.annotate 'line', 1041
    find_lex $P2392, "$i"
    set $I2393, $P2392
    find_lex $P2394, "$past"
    unless_null $P2394, vivify_753
    $P2394 = root_new ['parrot';'ResizablePMCArray']
  vivify_753:
    set $P2395, $P2394[$I2393]
    unless_null $P2395, vivify_754
    new $P2395, "Undef"
  vivify_754:
    $S2396 = $P2395."name"()
    substr $S2397, $S2396, 0, 1
    iseq $I2398, $S2397, "%"
    new $P2384, 'Integer'
    set $P2384, $I2398
  if_2385_end:
    unless $P2384, if_2383_end
.annotate 'line', 1042
    find_lex $P2399, "$i"
    set $I2400, $P2399
    find_lex $P2401, "$past"
    unless_null $P2401, vivify_755
    $P2401 = root_new ['parrot';'ResizablePMCArray']
  vivify_755:
    set $P2402, $P2401[$I2400]
    unless_null $P2402, vivify_756
    new $P2402, "Undef"
  vivify_756:
    $P2402."named"(1)
  if_2383_end:
  if_2364_end:
.annotate 'line', 1037
    find_lex $P2403, "$i"
    clone $P2404, $P2403
    inc $P2403
  loop2405_next:
.annotate 'line', 1036
    goto loop2405_test
  loop2405_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2407, exception, 'type'
    eq $P2407, .CONTROL_LOOP_NEXT, loop2405_next
    eq $P2407, .CONTROL_LOOP_REDO, loop2405_redo
  loop2405_done:
    pop_eh 
.annotate 'line', 1047
    find_lex $P2408, "$/"
    find_lex $P2409, "$past"
    $P2410 = $P2408."!make"($P2409)
.annotate 'line', 1025
    .return ($P2410)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2321"  :anon :subid("122_1296306531.71605") :outer("121_1296306531.71605")
.annotate 'line', 1027
    .const 'Sub' $P2343 = "123_1296306531.71605" 
    capture_lex $P2343
.annotate 'line', 1028
    new $P2323, "Undef"
    .lex "$expr", $P2323
    find_lex $P2324, "$/"
    unless_null $P2324, vivify_740
    $P2324 = root_new ['parrot';'Hash']
  vivify_740:
    set $P2325, $P2324["EXPR"]
    unless_null $P2325, vivify_741
    new $P2325, "Undef"
  vivify_741:
    $P2326 = $P2325."ast"()
    store_lex "$expr", $P2326
.annotate 'line', 1029
    find_lex $P2331, "$expr"
    $S2332 = $P2331."name"()
    iseq $I2333, $S2332, "&infix:<,>"
    if $I2333, if_2330
    new $P2329, 'Integer'
    set $P2329, $I2333
    goto if_2330_end
  if_2330:
    find_lex $P2334, "$expr"
    $P2335 = $P2334."named"()
    isfalse $I2336, $P2335
    new $P2329, 'Integer'
    set $P2329, $I2336
  if_2330_end:
    if $P2329, if_2328
.annotate 'line', 1032
    find_lex $P2351, "$past"
    find_lex $P2352, "$expr"
    $P2353 = $P2351."push"($P2352)
    set $P2327, $P2353
.annotate 'line', 1029
    goto if_2328_end
  if_2328:
.annotate 'line', 1030
    find_lex $P2338, "$expr"
    $P2339 = $P2338."list"()
    defined $I2340, $P2339
    unless $I2340, for_undef_742
    iter $P2337, $P2339
    new $P2349, 'ExceptionHandler'
    set_addr $P2349, loop2348_handler
    $P2349."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2349
  loop2348_test:
    unless $P2337, loop2348_done
    shift $P2341, $P2337
  loop2348_redo:
    .const 'Sub' $P2343 = "123_1296306531.71605" 
    capture_lex $P2343
    $P2343($P2341)
  loop2348_next:
    goto loop2348_test
  loop2348_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2350, exception, 'type'
    eq $P2350, .CONTROL_LOOP_NEXT, loop2348_next
    eq $P2350, .CONTROL_LOOP_REDO, loop2348_redo
  loop2348_done:
    pop_eh 
  for_undef_742:
.annotate 'line', 1029
    set $P2327, $P2337
  if_2328_end:
.annotate 'line', 1027
    .return ($P2327)
.end


.namespace ["NQP";"Actions"]
.sub "_block2342"  :anon :subid("123_1296306531.71605") :outer("122_1296306531.71605")
    .param pmc param_2344
.annotate 'line', 1030
    .lex "$_", param_2344
    find_lex $P2345, "$past"
    find_lex $P2346, "$_"
    $P2347 = $P2345."push"($P2346)
    .return ($P2347)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("124_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2412
    .param pmc param_2413
.annotate 'line', 1050
    .lex "self", param_2412
    .lex "$/", param_2413
    find_lex $P2414, "$/"
    find_lex $P2415, "$/"
    unless_null $P2415, vivify_757
    $P2415 = root_new ['parrot';'Hash']
  vivify_757:
    set $P2416, $P2415["multi_declarator"]
    unless_null $P2416, vivify_758
    new $P2416, "Undef"
  vivify_758:
    $P2417 = $P2416."ast"()
    $P2418 = $P2414."!make"($P2417)
    .return ($P2418)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("125_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2420
    .param pmc param_2421
.annotate 'line', 1052
    .lex "self", param_2420
    .lex "$/", param_2421
    find_lex $P2422, "$/"
    find_lex $P2423, "$/"
    unless_null $P2423, vivify_759
    $P2423 = root_new ['parrot';'Hash']
  vivify_759:
    set $P2424, $P2423["value"]
    unless_null $P2424, vivify_760
    new $P2424, "Undef"
  vivify_760:
    $P2425 = $P2424."ast"()
    $P2426 = $P2422."!make"($P2425)
    .return ($P2426)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("126_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2428
    .param pmc param_2429
.annotate 'line', 1054
    .lex "self", param_2428
    .lex "$/", param_2429
.annotate 'line', 1055
    find_lex $P2430, "$/"
.annotate 'line', 1056
    find_lex $P2433, "$/"
    unless_null $P2433, vivify_761
    $P2433 = root_new ['parrot';'Hash']
  vivify_761:
    set $P2434, $P2433["EXPR"]
    unless_null $P2434, vivify_762
    new $P2434, "Undef"
  vivify_762:
    if $P2434, if_2432
.annotate 'line', 1057
    get_hll_global $P2439, ["PAST"], "Op"
    find_lex $P2440, "$/"
    $P2441 = $P2439."new"("list" :named("pasttype"), $P2440 :named("node"))
    set $P2431, $P2441
.annotate 'line', 1056
    goto if_2432_end
  if_2432:
    find_lex $P2435, "$/"
    unless_null $P2435, vivify_763
    $P2435 = root_new ['parrot';'Hash']
  vivify_763:
    set $P2436, $P2435["EXPR"]
    unless_null $P2436, vivify_764
    $P2436 = root_new ['parrot';'ResizablePMCArray']
  vivify_764:
    set $P2437, $P2436[0]
    unless_null $P2437, vivify_765
    new $P2437, "Undef"
  vivify_765:
    $P2438 = $P2437."ast"()
    set $P2431, $P2438
  if_2432_end:
    $P2442 = $P2430."!make"($P2431)
.annotate 'line', 1054
    .return ($P2442)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("127_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2444
    .param pmc param_2445
.annotate 'line', 1060
    .lex "self", param_2444
    .lex "$/", param_2445
.annotate 'line', 1061
    new $P2446, "Undef"
    .lex "$past", $P2446
.annotate 'line', 1060
    find_lex $P2447, "$past"
.annotate 'line', 1062
    find_lex $P2449, "$/"
    unless_null $P2449, vivify_766
    $P2449 = root_new ['parrot';'Hash']
  vivify_766:
    set $P2450, $P2449["EXPR"]
    unless_null $P2450, vivify_767
    new $P2450, "Undef"
  vivify_767:
    if $P2450, if_2448
.annotate 'line', 1069
    get_hll_global $P2462, ["PAST"], "Op"
    $P2463 = $P2462."new"("list" :named("pasttype"))
    store_lex "$past", $P2463
.annotate 'line', 1068
    goto if_2448_end
  if_2448:
.annotate 'line', 1063
    find_lex $P2451, "$/"
    unless_null $P2451, vivify_768
    $P2451 = root_new ['parrot';'Hash']
  vivify_768:
    set $P2452, $P2451["EXPR"]
    unless_null $P2452, vivify_769
    $P2452 = root_new ['parrot';'ResizablePMCArray']
  vivify_769:
    set $P2453, $P2452[0]
    unless_null $P2453, vivify_770
    new $P2453, "Undef"
  vivify_770:
    $P2454 = $P2453."ast"()
    store_lex "$past", $P2454
.annotate 'line', 1064
    find_lex $P2456, "$past"
    $S2457 = $P2456."name"()
    isne $I2458, $S2457, "&infix:<,>"
    unless $I2458, if_2455_end
.annotate 'line', 1065
    get_hll_global $P2459, ["PAST"], "Op"
    find_lex $P2460, "$past"
    $P2461 = $P2459."new"($P2460, "list" :named("pasttype"))
    store_lex "$past", $P2461
  if_2455_end:
  if_2448_end:
.annotate 'line', 1071
    find_lex $P2464, "$past"
    $P2464."name"("&circumfix:<[ ]>")
.annotate 'line', 1072
    find_lex $P2465, "$/"
    find_lex $P2466, "$past"
    $P2467 = $P2465."!make"($P2466)
.annotate 'line', 1060
    .return ($P2467)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("128_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2469
    .param pmc param_2470
.annotate 'line', 1075
    .lex "self", param_2469
    .lex "$/", param_2470
    find_lex $P2471, "$/"
    find_lex $P2472, "$/"
    unless_null $P2472, vivify_771
    $P2472 = root_new ['parrot';'Hash']
  vivify_771:
    set $P2473, $P2472["quote_EXPR"]
    unless_null $P2473, vivify_772
    new $P2473, "Undef"
  vivify_772:
    $P2474 = $P2473."ast"()
    $P2475 = $P2471."!make"($P2474)
    .return ($P2475)
.end


.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("129_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2477
    .param pmc param_2478
.annotate 'line', 1076
    .lex "self", param_2477
    .lex "$/", param_2478
    find_lex $P2479, "$/"
    find_lex $P2480, "$/"
    unless_null $P2480, vivify_773
    $P2480 = root_new ['parrot';'Hash']
  vivify_773:
    set $P2481, $P2480["quote_EXPR"]
    unless_null $P2481, vivify_774
    new $P2481, "Undef"
  vivify_774:
    $P2482 = $P2481."ast"()
    $P2483 = $P2479."!make"($P2482)
    .return ($P2483)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("130_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2485
    .param pmc param_2486
.annotate 'line', 1078
    .lex "self", param_2485
    .lex "$/", param_2486
.annotate 'line', 1079
    new $P2487, "Undef"
    .lex "$past", $P2487
    find_lex $P2490, "$/"
    unless_null $P2490, vivify_775
    $P2490 = root_new ['parrot';'Hash']
  vivify_775:
    set $P2491, $P2490["pblock"]
    unless_null $P2491, vivify_776
    $P2491 = root_new ['parrot';'Hash']
  vivify_776:
    set $P2492, $P2491["blockoid"]
    unless_null $P2492, vivify_777
    $P2492 = root_new ['parrot';'Hash']
  vivify_777:
    set $P2493, $P2492["statementlist"]
    unless_null $P2493, vivify_778
    $P2493 = root_new ['parrot';'Hash']
  vivify_778:
    set $P2494, $P2493["statement"]
    unless_null $P2494, vivify_779
    new $P2494, "Undef"
  vivify_779:
    set $N2495, $P2494
    isgt $I2496, $N2495, 0.0
    if $I2496, if_2489
.annotate 'line', 1081
    $P2500 = "vivitype"("%")
    set $P2488, $P2500
.annotate 'line', 1079
    goto if_2489_end
  if_2489:
.annotate 'line', 1080
    find_lex $P2497, "$/"
    unless_null $P2497, vivify_780
    $P2497 = root_new ['parrot';'Hash']
  vivify_780:
    set $P2498, $P2497["pblock"]
    unless_null $P2498, vivify_781
    new $P2498, "Undef"
  vivify_781:
    $P2499 = $P2498."ast"()
    set $P2488, $P2499
  if_2489_end:
    store_lex "$past", $P2488
.annotate 'line', 1082
    new $P2501, "Integer"
    assign $P2501, 1
    find_lex $P2502, "$past"
    unless_null $P2502, vivify_782
    $P2502 = root_new ['parrot';'Hash']
    store_lex "$past", $P2502
  vivify_782:
    set $P2502["bareblock"], $P2501
.annotate 'line', 1083
    find_lex $P2503, "$/"
    find_lex $P2504, "$past"
    $P2505 = $P2503."!make"($P2504)
.annotate 'line', 1078
    .return ($P2505)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("131_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2507
    .param pmc param_2508
.annotate 'line', 1086
    .lex "self", param_2507
    .lex "$/", param_2508
.annotate 'line', 1087
    new $P2509, "Undef"
    .lex "$name", $P2509
    find_lex $P2512, "$/"
    unless_null $P2512, vivify_783
    $P2512 = root_new ['parrot';'Hash']
  vivify_783:
    set $P2513, $P2512["sigil"]
    unless_null $P2513, vivify_784
    new $P2513, "Undef"
  vivify_784:
    set $S2514, $P2513
    iseq $I2515, $S2514, "@"
    if $I2515, if_2511
.annotate 'line', 1088
    find_lex $P2519, "$/"
    unless_null $P2519, vivify_785
    $P2519 = root_new ['parrot';'Hash']
  vivify_785:
    set $P2520, $P2519["sigil"]
    unless_null $P2520, vivify_786
    new $P2520, "Undef"
  vivify_786:
    set $S2521, $P2520
    iseq $I2522, $S2521, "%"
    if $I2522, if_2518
    new $P2524, "String"
    assign $P2524, "item"
    set $P2517, $P2524
    goto if_2518_end
  if_2518:
    new $P2523, "String"
    assign $P2523, "hash"
    set $P2517, $P2523
  if_2518_end:
    set $P2510, $P2517
.annotate 'line', 1087
    goto if_2511_end
  if_2511:
    new $P2516, "String"
    assign $P2516, "list"
    set $P2510, $P2516
  if_2511_end:
    store_lex "$name", $P2510
.annotate 'line', 1090
    find_lex $P2525, "$/"
    get_hll_global $P2526, ["PAST"], "Op"
    find_lex $P2527, "$name"
    find_lex $P2528, "$/"
    unless_null $P2528, vivify_787
    $P2528 = root_new ['parrot';'Hash']
  vivify_787:
    set $P2529, $P2528["semilist"]
    unless_null $P2529, vivify_788
    new $P2529, "Undef"
  vivify_788:
    $P2530 = $P2529."ast"()
    $P2531 = $P2526."new"($P2530, "callmethod" :named("pasttype"), $P2527 :named("name"))
    $P2532 = $P2525."!make"($P2531)
.annotate 'line', 1086
    .return ($P2532)
.end


.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("132_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2534
    .param pmc param_2535
.annotate 'line', 1093
    .lex "self", param_2534
    .lex "$/", param_2535
    find_lex $P2536, "$/"
    find_lex $P2537, "$/"
    unless_null $P2537, vivify_789
    $P2537 = root_new ['parrot';'Hash']
  vivify_789:
    set $P2538, $P2537["statement"]
    unless_null $P2538, vivify_790
    new $P2538, "Undef"
  vivify_790:
    $P2539 = $P2538."ast"()
    $P2540 = $P2536."!make"($P2539)
    .return ($P2540)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("133_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2542
    .param pmc param_2543
.annotate 'line', 1095
    .lex "self", param_2542
    .lex "$/", param_2543
.annotate 'line', 1096
    find_lex $P2544, "$/"
    get_hll_global $P2545, ["PAST"], "Var"
    find_lex $P2546, "$/"
    unless_null $P2546, vivify_791
    $P2546 = root_new ['parrot';'Hash']
  vivify_791:
    set $P2547, $P2546["EXPR"]
    unless_null $P2547, vivify_792
    new $P2547, "Undef"
  vivify_792:
    $P2548 = $P2547."ast"()
.annotate 'line', 1098
    $P2549 = "vivitype"("@")
    $P2550 = $P2545."new"($P2548, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2549 :named("vivibase"))
.annotate 'line', 1096
    $P2551 = $P2544."!make"($P2550)
.annotate 'line', 1095
    .return ($P2551)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("134_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2553
    .param pmc param_2554
.annotate 'line', 1101
    .lex "self", param_2553
    .lex "$/", param_2554
.annotate 'line', 1102
    find_lex $P2555, "$/"
    get_hll_global $P2556, ["PAST"], "Var"
    find_lex $P2557, "$/"
    unless_null $P2557, vivify_793
    $P2557 = root_new ['parrot';'Hash']
  vivify_793:
    set $P2558, $P2557["EXPR"]
    unless_null $P2558, vivify_794
    new $P2558, "Undef"
  vivify_794:
    $P2559 = $P2558."ast"()
.annotate 'line', 1104
    $P2560 = "vivitype"("%")
    $P2561 = $P2556."new"($P2559, "keyed" :named("scope"), "Undef" :named("viviself"), $P2560 :named("vivibase"))
.annotate 'line', 1102
    $P2562 = $P2555."!make"($P2561)
.annotate 'line', 1101
    .return ($P2562)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("135_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2564
    .param pmc param_2565
.annotate 'line', 1107
    .lex "self", param_2564
    .lex "$/", param_2565
.annotate 'line', 1108
    find_lex $P2566, "$/"
    get_hll_global $P2567, ["PAST"], "Var"
    find_lex $P2568, "$/"
    unless_null $P2568, vivify_795
    $P2568 = root_new ['parrot';'Hash']
  vivify_795:
    set $P2569, $P2568["quote_EXPR"]
    unless_null $P2569, vivify_796
    new $P2569, "Undef"
  vivify_796:
    $P2570 = $P2569."ast"()
.annotate 'line', 1110
    $P2571 = "vivitype"("%")
    $P2572 = $P2567."new"($P2570, "keyed" :named("scope"), "Undef" :named("viviself"), $P2571 :named("vivibase"))
.annotate 'line', 1108
    $P2573 = $P2566."!make"($P2572)
.annotate 'line', 1107
    .return ($P2573)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("136_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2575
    .param pmc param_2576
.annotate 'line', 1113
    .lex "self", param_2575
    .lex "$/", param_2576
.annotate 'line', 1114
    find_lex $P2577, "$/"
    find_lex $P2578, "$/"
    unless_null $P2578, vivify_797
    $P2578 = root_new ['parrot';'Hash']
  vivify_797:
    set $P2579, $P2578["arglist"]
    unless_null $P2579, vivify_798
    new $P2579, "Undef"
  vivify_798:
    $P2580 = $P2579."ast"()
    $P2581 = $P2577."!make"($P2580)
.annotate 'line', 1113
    .return ($P2581)
.end


.namespace ["NQP";"Actions"]
.sub "value"  :subid("137_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2583
    .param pmc param_2584
.annotate 'line', 1117
    .lex "self", param_2583
    .lex "$/", param_2584
.annotate 'line', 1118
    find_lex $P2585, "$/"
    find_lex $P2588, "$/"
    unless_null $P2588, vivify_799
    $P2588 = root_new ['parrot';'Hash']
  vivify_799:
    set $P2589, $P2588["quote"]
    unless_null $P2589, vivify_800
    new $P2589, "Undef"
  vivify_800:
    if $P2589, if_2587
    find_lex $P2593, "$/"
    unless_null $P2593, vivify_801
    $P2593 = root_new ['parrot';'Hash']
  vivify_801:
    set $P2594, $P2593["number"]
    unless_null $P2594, vivify_802
    new $P2594, "Undef"
  vivify_802:
    $P2595 = $P2594."ast"()
    set $P2586, $P2595
    goto if_2587_end
  if_2587:
    find_lex $P2590, "$/"
    unless_null $P2590, vivify_803
    $P2590 = root_new ['parrot';'Hash']
  vivify_803:
    set $P2591, $P2590["quote"]
    unless_null $P2591, vivify_804
    new $P2591, "Undef"
  vivify_804:
    $P2592 = $P2591."ast"()
    set $P2586, $P2592
  if_2587_end:
    $P2596 = $P2585."!make"($P2586)
.annotate 'line', 1117
    .return ($P2596)
.end


.namespace ["NQP";"Actions"]
.sub "number"  :subid("138_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2598
    .param pmc param_2599
.annotate 'line', 1121
    .lex "self", param_2598
    .lex "$/", param_2599
.annotate 'line', 1122
    new $P2600, "Undef"
    .lex "$value", $P2600
    find_lex $P2603, "$/"
    unless_null $P2603, vivify_805
    $P2603 = root_new ['parrot';'Hash']
  vivify_805:
    set $P2604, $P2603["dec_number"]
    unless_null $P2604, vivify_806
    new $P2604, "Undef"
  vivify_806:
    if $P2604, if_2602
    find_lex $P2608, "$/"
    unless_null $P2608, vivify_807
    $P2608 = root_new ['parrot';'Hash']
  vivify_807:
    set $P2609, $P2608["integer"]
    unless_null $P2609, vivify_808
    new $P2609, "Undef"
  vivify_808:
    $P2610 = $P2609."ast"()
    set $P2601, $P2610
    goto if_2602_end
  if_2602:
    find_lex $P2605, "$/"
    unless_null $P2605, vivify_809
    $P2605 = root_new ['parrot';'Hash']
  vivify_809:
    set $P2606, $P2605["dec_number"]
    unless_null $P2606, vivify_810
    new $P2606, "Undef"
  vivify_810:
    $P2607 = $P2606."ast"()
    set $P2601, $P2607
  if_2602_end:
    store_lex "$value", $P2601
.annotate 'line', 1123
    find_lex $P2612, "$/"
    unless_null $P2612, vivify_811
    $P2612 = root_new ['parrot';'Hash']
  vivify_811:
    set $P2613, $P2612["sign"]
    unless_null $P2613, vivify_812
    new $P2613, "Undef"
  vivify_812:
    set $S2614, $P2613
    iseq $I2615, $S2614, "-"
    unless $I2615, if_2611_end
    find_lex $P2616, "$value"
    neg $P2617, $P2616
    store_lex "$value", $P2617
  if_2611_end:
.annotate 'line', 1124
    find_lex $P2618, "$/"
    get_hll_global $P2619, ["PAST"], "Val"
    find_lex $P2620, "$value"
    $P2621 = $P2619."new"($P2620 :named("value"))
    $P2622 = $P2618."!make"($P2621)
.annotate 'line', 1121
    .return ($P2622)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("139_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2624
    .param pmc param_2625
.annotate 'line', 1127
    .lex "self", param_2624
    .lex "$/", param_2625
    find_lex $P2626, "$/"
    find_lex $P2627, "$/"
    unless_null $P2627, vivify_813
    $P2627 = root_new ['parrot';'Hash']
  vivify_813:
    set $P2628, $P2627["quote_EXPR"]
    unless_null $P2628, vivify_814
    new $P2628, "Undef"
  vivify_814:
    $P2629 = $P2628."ast"()
    $P2630 = $P2626."!make"($P2629)
    .return ($P2630)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("140_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2632
    .param pmc param_2633
.annotate 'line', 1128
    .lex "self", param_2632
    .lex "$/", param_2633
    find_lex $P2634, "$/"
    find_lex $P2635, "$/"
    unless_null $P2635, vivify_815
    $P2635 = root_new ['parrot';'Hash']
  vivify_815:
    set $P2636, $P2635["quote_EXPR"]
    unless_null $P2636, vivify_816
    new $P2636, "Undef"
  vivify_816:
    $P2637 = $P2636."ast"()
    $P2638 = $P2634."!make"($P2637)
    .return ($P2638)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("141_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2640
    .param pmc param_2641
.annotate 'line', 1129
    .lex "self", param_2640
    .lex "$/", param_2641
    find_lex $P2642, "$/"
    find_lex $P2643, "$/"
    unless_null $P2643, vivify_817
    $P2643 = root_new ['parrot';'Hash']
  vivify_817:
    set $P2644, $P2643["quote_EXPR"]
    unless_null $P2644, vivify_818
    new $P2644, "Undef"
  vivify_818:
    $P2645 = $P2644."ast"()
    $P2646 = $P2642."!make"($P2645)
    .return ($P2646)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("142_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2648
    .param pmc param_2649
.annotate 'line', 1130
    .lex "self", param_2648
    .lex "$/", param_2649
    find_lex $P2650, "$/"
    find_lex $P2651, "$/"
    unless_null $P2651, vivify_819
    $P2651 = root_new ['parrot';'Hash']
  vivify_819:
    set $P2652, $P2651["quote_EXPR"]
    unless_null $P2652, vivify_820
    new $P2652, "Undef"
  vivify_820:
    $P2653 = $P2652."ast"()
    $P2654 = $P2650."!make"($P2653)
    .return ($P2654)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("143_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2656
    .param pmc param_2657
.annotate 'line', 1131
    .lex "self", param_2656
    .lex "$/", param_2657
    find_lex $P2658, "$/"
    find_lex $P2659, "$/"
    unless_null $P2659, vivify_821
    $P2659 = root_new ['parrot';'Hash']
  vivify_821:
    set $P2660, $P2659["quote_EXPR"]
    unless_null $P2660, vivify_822
    new $P2660, "Undef"
  vivify_822:
    $P2661 = $P2660."ast"()
    $P2662 = $P2658."!make"($P2661)
    .return ($P2662)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("144_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2664
    .param pmc param_2665
.annotate 'line', 1132
    .lex "self", param_2664
    .lex "$/", param_2665
.annotate 'line', 1133
    find_lex $P2666, "$/"
    get_hll_global $P2667, ["PAST"], "Op"
    find_lex $P2668, "$/"
    unless_null $P2668, vivify_823
    $P2668 = root_new ['parrot';'Hash']
  vivify_823:
    set $P2669, $P2668["quote_EXPR"]
    unless_null $P2669, vivify_824
    new $P2669, "Undef"
  vivify_824:
    $P2670 = $P2669."ast"()
    $P2671 = $P2670."value"()
    find_lex $P2672, "$/"
    $P2673 = $P2667."new"($P2671 :named("inline"), "inline" :named("pasttype"), $P2672 :named("node"))
    $P2674 = $P2666."!make"($P2673)
.annotate 'line', 1132
    .return ($P2674)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("145_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2678
    .param pmc param_2679
    .param pmc param_2680 :optional
    .param int has_param_2680 :opt_flag
.annotate 'line', 1138
    new $P2677, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2677, control_2676
    push_eh $P2677
    .lex "self", param_2678
    .lex "$/", param_2679
    if has_param_2680, optparam_825
    new $P2681, "Undef"
    set param_2680, $P2681
  optparam_825:
    .lex "$key", param_2680
.annotate 'line', 1148
    new $P2682, "Undef"
    .lex "$regex", $P2682
.annotate 'line', 1150
    new $P2683, "Undef"
    .lex "$past", $P2683
.annotate 'line', 1139
    find_lex $P2685, "$key"
    set $S2686, $P2685
    iseq $I2687, $S2686, "open"
    unless $I2687, if_2684_end
.annotate 'line', 1140

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1144
    get_global $P2688, "@BLOCK"
    unless_null $P2688, vivify_826
    $P2688 = root_new ['parrot';'ResizablePMCArray']
  vivify_826:
    set $P2689, $P2688[0]
    unless_null $P2689, vivify_827
    new $P2689, "Undef"
  vivify_827:
    $P2689."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1145
    get_global $P2690, "@BLOCK"
    unless_null $P2690, vivify_828
    $P2690 = root_new ['parrot';'ResizablePMCArray']
  vivify_828:
    set $P2691, $P2690[0]
    unless_null $P2691, vivify_829
    new $P2691, "Undef"
  vivify_829:
    $P2691."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1146
    new $P2692, "Exception"
    set $P2692['type'], .CONTROL_RETURN
    new $P2693, "Integer"
    assign $P2693, 0
    setattribute $P2692, 'payload', $P2693
    throw $P2692
  if_2684_end:
.annotate 'line', 1149
    get_hll_global $P2694, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2695, "$/"
    unless_null $P2695, vivify_830
    $P2695 = root_new ['parrot';'Hash']
  vivify_830:
    set $P2696, $P2695["p6regex"]
    unless_null $P2696, vivify_831
    new $P2696, "Undef"
  vivify_831:
    $P2697 = $P2696."ast"()
    get_global $P2698, "@BLOCK"
    $P2699 = $P2698."shift"()
    $P2700 = $P2694($P2697, $P2699)
    store_lex "$regex", $P2700
.annotate 'line', 1151
    get_hll_global $P2701, ["PAST"], "Op"
.annotate 'line', 1153
    get_hll_global $P2702, ["PAST"], "Var"
    new $P2703, "ResizablePMCArray"
    push $P2703, "Regex"
    $P2704 = $P2702."new"("Regex" :named("name"), $P2703 :named("namespace"), "package" :named("scope"))
    find_lex $P2705, "$regex"
    $P2706 = $P2701."new"($P2704, $P2705, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1151
    store_lex "$past", $P2706
.annotate 'line', 1157
    find_lex $P2707, "$regex"
    find_lex $P2708, "$past"
    unless_null $P2708, vivify_832
    $P2708 = root_new ['parrot';'Hash']
    store_lex "$past", $P2708
  vivify_832:
    set $P2708["sink"], $P2707
.annotate 'line', 1158
    find_lex $P2709, "$/"
    find_lex $P2710, "$past"
    $P2711 = $P2709."!make"($P2710)
.annotate 'line', 1138
    .return ($P2711)
  control_2676:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2712, exception, "payload"
    .return ($P2712)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("146_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2714
    .param pmc param_2715
.annotate 'line', 1161
    .lex "self", param_2714
    .lex "$/", param_2715
    find_lex $P2716, "$/"
    find_lex $P2717, "$/"
    unless_null $P2717, vivify_833
    $P2717 = root_new ['parrot';'Hash']
  vivify_833:
    set $P2718, $P2717["variable"]
    unless_null $P2718, vivify_834
    new $P2718, "Undef"
  vivify_834:
    $P2719 = $P2718."ast"()
    $P2720 = $P2716."!make"($P2719)
    .return ($P2720)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("147_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2722
    .param pmc param_2723
.annotate 'line', 1162
    .lex "self", param_2722
    .lex "$/", param_2723
.annotate 'line', 1163
    find_lex $P2724, "$/"
    get_hll_global $P2725, ["PAST"], "Op"
.annotate 'line', 1164
    find_lex $P2726, "$/"
    unless_null $P2726, vivify_835
    $P2726 = root_new ['parrot';'Hash']
  vivify_835:
    set $P2727, $P2726["block"]
    unless_null $P2727, vivify_836
    new $P2727, "Undef"
  vivify_836:
    $P2728 = $P2727."ast"()
    $P2729 = "block_immediate"($P2728)
    find_lex $P2730, "$/"
    $P2731 = $P2725."new"($P2729, "set S*" :named("pirop"), $P2730 :named("node"))
.annotate 'line', 1163
    $P2732 = $P2724."!make"($P2731)
.annotate 'line', 1162
    .return ($P2732)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("148_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2734
    .param pmc param_2735
.annotate 'line', 1167
    .lex "self", param_2734
    .lex "$/", param_2735
    find_lex $P2736, "$/"
    $P2737 = $P2736."!make"("\e")
    .return ($P2737)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("149_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2739
    .param pmc param_2740
.annotate 'line', 1171
    .lex "self", param_2739
    .lex "$/", param_2740
    find_lex $P2741, "$/"
    find_lex $P2742, "$/"
    unless_null $P2742, vivify_837
    $P2742 = root_new ['parrot';'Hash']
  vivify_837:
    set $P2743, $P2742["dotty"]
    unless_null $P2743, vivify_838
    new $P2743, "Undef"
  vivify_838:
    $P2744 = $P2743."ast"()
    $P2745 = $P2741."!make"($P2744)
    .return ($P2745)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("150_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2747
    .param pmc param_2748
.annotate 'line', 1173
    .lex "self", param_2747
    .lex "$/", param_2748
.annotate 'line', 1174
    find_lex $P2749, "$/"
    get_hll_global $P2750, ["PAST"], "Op"
.annotate 'line', 1175
    new $P2751, "ResizablePMCArray"
    push $P2751, "    clone %r, %0"
    push $P2751, "    inc %0"
    $P2752 = $P2750."new"("postfix:<++>" :named("name"), $P2751 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1174
    $P2753 = $P2749."!make"($P2752)
.annotate 'line', 1173
    .return ($P2753)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("151_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2755
    .param pmc param_2756
.annotate 'line', 1179
    .lex "self", param_2755
    .lex "$/", param_2756
.annotate 'line', 1180
    find_lex $P2757, "$/"
    get_hll_global $P2758, ["PAST"], "Op"
.annotate 'line', 1181
    new $P2759, "ResizablePMCArray"
    push $P2759, "    clone %r, %0"
    push $P2759, "    dec %0"
    $P2760 = $P2758."new"("postfix:<-->" :named("name"), $P2759 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1180
    $P2761 = $P2757."!make"($P2760)
.annotate 'line', 1179
    .return ($P2761)
.end


.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("152_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2763
    .param pmc param_2764
.annotate 'line', 1185
    .lex "self", param_2763
    .lex "$/", param_2764
.annotate 'line', 1186
    find_lex $P2765, "$/"
    get_hll_global $P2766, ["PAST"], "Op"
.annotate 'line', 1187
    get_hll_global $P2767, ["PAST"], "Var"
    $P2768 = $P2767."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2769, "$/"
    $P2770 = $P2766."new"($P2768, "callmethod" :named("pasttype"), "!make" :named("name"), $P2769 :named("node"))
.annotate 'line', 1186
    $P2771 = $P2765."!make"($P2770)
.annotate 'line', 1185
    .return ($P2771)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("153_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2774
    .param pmc param_2775
.annotate 'line', 1203
    .lex "self", param_2774
    .lex "$/", param_2775
    find_lex $P2776, "$/"
    $P2777 = "control"($P2776, "CONTROL_LOOP_NEXT")
    .return ($P2777)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("154_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2779
    .param pmc param_2780
.annotate 'line', 1204
    .lex "self", param_2779
    .lex "$/", param_2780
    find_lex $P2781, "$/"
    $P2782 = "control"($P2781, "CONTROL_LOOP_LAST")
    .return ($P2782)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("155_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2784
    .param pmc param_2785
.annotate 'line', 1205
    .lex "self", param_2784
    .lex "$/", param_2785
    find_lex $P2786, "$/"
    $P2787 = "control"($P2786, "CONTROL_LOOP_REDO")
    .return ($P2787)
.end


.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("156_1296306531.71605") :outer("11_1296306531.71605")
    .param pmc param_2789
    .param pmc param_2790
.annotate 'line', 1207
    .lex "self", param_2789
    .lex "$/", param_2790
.annotate 'line', 1208
    find_lex $P2791, "$/"
    get_hll_global $P2792, ["PAST"], "Op"
    find_lex $P2793, "$/"
    $P2794 = $P2792."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2793 :named("node"))
    $P2795 = $P2791."!make"($P2794)
.annotate 'line', 1207
    .return ($P2795)
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2796"  :subid("157_1296306531.71605") :outer("11_1296306531.71605")
.annotate 'line', 1212
    .const 'Sub' $P2896 = "165_1296306531.71605" 
    capture_lex $P2896
    .const 'Sub' $P2871 = "164_1296306531.71605" 
    capture_lex $P2871
    .const 'Sub' $P2860 = "163_1296306531.71605" 
    capture_lex $P2860
    .const 'Sub' $P2845 = "162_1296306531.71605" 
    capture_lex $P2845
    .const 'Sub' $P2834 = "161_1296306531.71605" 
    capture_lex $P2834
    .const 'Sub' $P2823 = "160_1296306531.71605" 
    capture_lex $P2823
    .const 'Sub' $P2812 = "159_1296306531.71605" 
    capture_lex $P2812
    .const 'Sub' $P2799 = "158_1296306531.71605" 
    capture_lex $P2799
    get_global $P2798, "$?CLASS"
.annotate 'line', 1246
    .const 'Sub' $P2871 = "164_1296306531.71605" 
    newclosure $P2894, $P2871
.annotate 'line', 1212
    .return ($P2894)
.end


.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post839") :outer("157_1296306531.71605")
.annotate 'line', 1212
    get_hll_global $P2797, ["NQP";"RegexActions"], "_block2796" 
    .local pmc block
    set block, $P2797
    .const 'Sub' $P2896 = "165_1296306531.71605" 
    capture_lex $P2896
    $P2896()
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2895"  :anon :subid("165_1296306531.71605") :outer("157_1296306531.71605")
.annotate 'line', 1212
    get_hll_global $P2897, "NQPClassHOW"
    $P2898 = $P2897."new_type"("RegexActions" :named("name"))
    .local pmc type_obj
    set type_obj, $P2898
    set_hll_global ["NQP"], "RegexActions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2899, type_obj
    .const 'Sub' $P2900 = "158_1296306531.71605" 
    $P2899."add_method"(type_obj, "metachar:sym<:my>", $P2900)
    get_how $P2901, type_obj
    .const 'Sub' $P2902 = "159_1296306531.71605" 
    $P2901."add_method"(type_obj, "metachar:sym<{ }>", $P2902)
    get_how $P2903, type_obj
    .const 'Sub' $P2904 = "160_1296306531.71605" 
    $P2903."add_method"(type_obj, "metachar:sym<nqpvar>", $P2904)
    get_how $P2905, type_obj
    .const 'Sub' $P2906 = "161_1296306531.71605" 
    $P2905."add_method"(type_obj, "assertion:sym<{ }>", $P2906)
    get_how $P2907, type_obj
    .const 'Sub' $P2908 = "162_1296306531.71605" 
    $P2907."add_method"(type_obj, "assertion:sym<?{ }>", $P2908)
    get_how $P2909, type_obj
    .const 'Sub' $P2910 = "163_1296306531.71605" 
    $P2909."add_method"(type_obj, "assertion:sym<var>", $P2910)
    get_how $P2911, type_obj
    .const 'Sub' $P2912 = "164_1296306531.71605" 
    $P2911."add_method"(type_obj, "codeblock", $P2912)
    get_how $P2913, type_obj
    get_hll_global $P2914, ["Regex";"P6Regex"], "Actions"
    $P2913."add_parent"(type_obj, $P2914)
    get_how $P2915, type_obj
    $P2916 = $P2915."compose"(type_obj)
    .return ($P2916)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("158_1296306531.71605") :outer("157_1296306531.71605")
    .param pmc param_2800
    .param pmc param_2801
.annotate 'line', 1214
    .lex "self", param_2800
    .lex "$/", param_2801
.annotate 'line', 1215
    new $P2802, "Undef"
    .lex "$past", $P2802
    find_lex $P2803, "$/"
    unless_null $P2803, vivify_840
    $P2803 = root_new ['parrot';'Hash']
  vivify_840:
    set $P2804, $P2803["statement"]
    unless_null $P2804, vivify_841
    new $P2804, "Undef"
  vivify_841:
    $P2805 = $P2804."ast"()
    store_lex "$past", $P2805
.annotate 'line', 1216
    find_lex $P2806, "$/"
    get_hll_global $P2807, ["PAST"], "Regex"
    find_lex $P2808, "$past"
    find_lex $P2809, "$/"
    $P2810 = $P2807."new"($P2808, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P2809 :named("node"))
    $P2811 = $P2806."!make"($P2810)
.annotate 'line', 1214
    .return ($P2811)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("159_1296306531.71605") :outer("157_1296306531.71605")
    .param pmc param_2813
    .param pmc param_2814
.annotate 'line', 1220
    .lex "self", param_2813
    .lex "$/", param_2814
.annotate 'line', 1221
    find_lex $P2815, "$/"
    get_hll_global $P2816, ["PAST"], "Regex"
    find_lex $P2817, "$/"
    unless_null $P2817, vivify_842
    $P2817 = root_new ['parrot';'Hash']
  vivify_842:
    set $P2818, $P2817["codeblock"]
    unless_null $P2818, vivify_843
    new $P2818, "Undef"
  vivify_843:
    $P2819 = $P2818."ast"()
    find_lex $P2820, "$/"
    $P2821 = $P2816."new"($P2819, "pastnode" :named("pasttype"), $P2820 :named("node"))
    $P2822 = $P2815."!make"($P2821)
.annotate 'line', 1220
    .return ($P2822)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("160_1296306531.71605") :outer("157_1296306531.71605")
    .param pmc param_2824
    .param pmc param_2825
.annotate 'line', 1225
    .lex "self", param_2824
    .lex "$/", param_2825
.annotate 'line', 1226
    find_lex $P2826, "$/"
    get_hll_global $P2827, ["PAST"], "Regex"
    find_lex $P2828, "$/"
    unless_null $P2828, vivify_844
    $P2828 = root_new ['parrot';'Hash']
  vivify_844:
    set $P2829, $P2828["var"]
    unless_null $P2829, vivify_845
    new $P2829, "Undef"
  vivify_845:
    $P2830 = $P2829."ast"()
    find_lex $P2831, "$/"
    $P2832 = $P2827."new"("!INTERPOLATE", $P2830, "subrule" :named("pasttype"), "method" :named("subtype"), $P2831 :named("node"))
    $P2833 = $P2826."!make"($P2832)
.annotate 'line', 1225
    .return ($P2833)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("161_1296306531.71605") :outer("157_1296306531.71605")
    .param pmc param_2835
    .param pmc param_2836
.annotate 'line', 1230
    .lex "self", param_2835
    .lex "$/", param_2836
.annotate 'line', 1231
    find_lex $P2837, "$/"
    get_hll_global $P2838, ["PAST"], "Regex"
    find_lex $P2839, "$/"
    unless_null $P2839, vivify_846
    $P2839 = root_new ['parrot';'Hash']
  vivify_846:
    set $P2840, $P2839["codeblock"]
    unless_null $P2840, vivify_847
    new $P2840, "Undef"
  vivify_847:
    $P2841 = $P2840."ast"()
    find_lex $P2842, "$/"
    $P2843 = $P2838."new"("!INTERPOLATE_REGEX", $P2841, "subrule" :named("pasttype"), "method" :named("subtype"), $P2842 :named("node"))
    $P2844 = $P2837."!make"($P2843)
.annotate 'line', 1230
    .return ($P2844)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("162_1296306531.71605") :outer("157_1296306531.71605")
    .param pmc param_2846
    .param pmc param_2847
.annotate 'line', 1235
    .lex "self", param_2846
    .lex "$/", param_2847
.annotate 'line', 1236
    find_lex $P2848, "$/"
    get_hll_global $P2849, ["PAST"], "Regex"
    find_lex $P2850, "$/"
    unless_null $P2850, vivify_848
    $P2850 = root_new ['parrot';'Hash']
  vivify_848:
    set $P2851, $P2850["codeblock"]
    unless_null $P2851, vivify_849
    new $P2851, "Undef"
  vivify_849:
    $P2852 = $P2851."ast"()
.annotate 'line', 1237
    find_lex $P2853, "$/"
    unless_null $P2853, vivify_850
    $P2853 = root_new ['parrot';'Hash']
  vivify_850:
    set $P2854, $P2853["zw"]
    unless_null $P2854, vivify_851
    new $P2854, "Undef"
  vivify_851:
    set $S2855, $P2854
    iseq $I2856, $S2855, "!"
    find_lex $P2857, "$/"
    $P2858 = $P2849."new"($P2852, "zerowidth" :named("subtype"), $I2856 :named("negate"), "pastnode" :named("pasttype"), $P2857 :named("node"))
.annotate 'line', 1236
    $P2859 = $P2848."!make"($P2858)
.annotate 'line', 1235
    .return ($P2859)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("163_1296306531.71605") :outer("157_1296306531.71605")
    .param pmc param_2861
    .param pmc param_2862
.annotate 'line', 1241
    .lex "self", param_2861
    .lex "$/", param_2862
.annotate 'line', 1242
    find_lex $P2863, "$/"
    get_hll_global $P2864, ["PAST"], "Regex"
    find_lex $P2865, "$/"
    unless_null $P2865, vivify_852
    $P2865 = root_new ['parrot';'Hash']
  vivify_852:
    set $P2866, $P2865["var"]
    unless_null $P2866, vivify_853
    new $P2866, "Undef"
  vivify_853:
    $P2867 = $P2866."ast"()
    find_lex $P2868, "$/"
    $P2869 = $P2864."new"("!INTERPOLATE_REGEX", $P2867, "subrule" :named("pasttype"), "method" :named("subtype"), $P2868 :named("node"))
    $P2870 = $P2863."!make"($P2869)
.annotate 'line', 1241
    .return ($P2870)
.end


.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("164_1296306531.71605") :outer("157_1296306531.71605")
    .param pmc param_2872
    .param pmc param_2873
.annotate 'line', 1246
    .lex "self", param_2872
    .lex "$/", param_2873
.annotate 'line', 1247
    new $P2874, "Undef"
    .lex "$block", $P2874
.annotate 'line', 1249
    new $P2875, "Undef"
    .lex "$past", $P2875
.annotate 'line', 1247
    find_lex $P2876, "$/"
    unless_null $P2876, vivify_854
    $P2876 = root_new ['parrot';'Hash']
  vivify_854:
    set $P2877, $P2876["block"]
    unless_null $P2877, vivify_855
    new $P2877, "Undef"
  vivify_855:
    $P2878 = $P2877."ast"()
    store_lex "$block", $P2878
.annotate 'line', 1248
    find_lex $P2879, "$block"
    $P2879."blocktype"("immediate")
.annotate 'line', 1250
    get_hll_global $P2880, ["PAST"], "Stmts"
.annotate 'line', 1251
    get_hll_global $P2881, ["PAST"], "Op"
.annotate 'line', 1252
    get_hll_global $P2882, ["PAST"], "Var"
    $P2883 = $P2882."new"("$/" :named("name"))
.annotate 'line', 1253
    get_hll_global $P2884, ["PAST"], "Op"
.annotate 'line', 1254
    get_hll_global $P2885, ["PAST"], "Var"
    $P2886 = $P2885."new"(unicode:"$\x{a2}" :named("name"))
    $P2887 = $P2884."new"($P2886, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1253
    $P2888 = $P2881."new"($P2883, $P2887, "bind" :named("pasttype"))
.annotate 'line', 1251
    find_lex $P2889, "$block"
    $P2890 = $P2880."new"($P2888, $P2889)
.annotate 'line', 1250
    store_lex "$past", $P2890
.annotate 'line', 1262
    find_lex $P2891, "$/"
    find_lex $P2892, "$past"
    $P2893 = $P2891."!make"($P2892)
.annotate 'line', 1246
    .return ($P2893)
.end


.namespace ["NQP";"Actions"]
.sub "_block2918" :load :anon :subid("166_1296306531.71605")
.annotate 'line', 3
    .const 'Sub' $P2920 = "11_1296306531.71605" 
    $P2921 = $P2920()
    .return ($P2921)
.end


.namespace []
.sub "_block3143" :load :anon :subid("168_1296306531.71605")
.annotate 'line', 1
    .const 'Sub' $P3145 = "10_1296306531.71605" 
    $P3146 = $P3145()
    .return ($P3146)
.end

### .include 'gen/nqp-compiler.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1296306534.07135")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Compiler"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
    $P25 = $P15()
    .return ($P25)
    .const 'Sub' $P27 = "13_1296306534.07135" 
    .return ($P27)
.end


.namespace ["NQP";"Compiler"]
.sub "_block14"  :subid("11_1296306534.07135") :outer("10_1296306534.07135")
.annotate 'line', 1
    .const 'Sub' $P18 = "12_1296306534.07135" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    .return ()
.end


.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post14") :outer("11_1296306534.07135")
.annotate 'line', 1
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P18 = "12_1296306534.07135" 
    capture_lex $P18
    $P18()
.end


.namespace ["NQP";"Compiler"]
.sub "_block17"  :anon :subid("12_1296306534.07135") :outer("11_1296306534.07135")
.annotate 'line', 1
    get_hll_global $P19, "NQPClassHOW"
    $P20 = $P19."new_type"("Compiler" :named("name"))
    .local pmc type_obj
    set type_obj, $P20
    set_hll_global ["NQP"], "Compiler", type_obj
    set_global "$?CLASS", type_obj
    get_how $P21, type_obj
    get_hll_global $P22, ["HLL"], "Compiler"
    $P21."add_parent"(type_obj, $P22)
    get_how $P23, type_obj
    $P24 = $P23."compose"(type_obj)
    .return ($P24)
.end


.namespace []
.sub "_block26" :load :anon :subid("13_1296306534.07135")
.annotate 'line', 1
    .const 'Sub' $P28 = "10_1296306534.07135" 
    $P29 = $P28()
    .return ($P29)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " # "
        print description
  no_description:
    print "\n"

    unless condition goto not_ok
    .return (1)
  not_ok:
    .return (0)
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('NQP-rx')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'NQP-rx'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
