
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1303391609.928")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    get_hll_global $P6107, ["NQP";"Compiler"], "_block6106" 
    capture_lex $P6107
    get_hll_global $P5986, ["NQP";"RegexActions"], "_block5985" 
    capture_lex $P5986
    get_hll_global $P2533, ["NQP";"Actions"], "_block2532" 
    capture_lex $P2533
    get_hll_global $P2429, ["NQP";"Regex"], "_block2428" 
    capture_lex $P2429
    get_hll_global $P36, ["NQP";"Grammar"], "_block35" 
    capture_lex $P36
    .const 'Sub' $P16 = "11_1303391609.928" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2231
    .const 'Sub' $P16 = "11_1303391609.928" 
    newclosure $P34, $P16
    .lex "MAIN", $P34
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    get_hll_global $P36, ["NQP";"Grammar"], "_block35" 
    capture_lex $P36
    $P36()
.annotate 'line', 710
    get_hll_global $P2429, ["NQP";"Regex"], "_block2428" 
    capture_lex $P2429
    $P2429()
.annotate 'line', 753
    get_hll_global $P2533, ["NQP";"Actions"], "_block2532" 
    capture_lex $P2533
    $P2533()
.annotate 'line', 2173
    get_hll_global $P5986, ["NQP";"RegexActions"], "_block5985" 
    capture_lex $P5986
    $P5986()
.annotate 'line', 2228
    get_hll_global $P6107, ["NQP";"Compiler"], "_block6106" 
    capture_lex $P6107
    $P6107()
    find_lex $P6117, "MAIN"
    find_lex $P6120, "@ARGS"
    if $P6120, if_6119
    set $P6118, $P6120
    goto if_6119_end
  if_6119:
    .const 'Sub' $P6121 = "11_1303391609.928" 
    find_lex $P6122, "@ARGS"
    $P6123 = $P6121($P6122 :flat)
    set $P6118, $P6123
  if_6119_end:
.annotate 'line', 1
    .return ($P6118)
    .const 'Sub' $P6125 = "573_1303391609.928" 
    .return ($P6125)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post574") :outer("10_1303391609.928")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1303391609.928" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P6129, "1303391598.821"
    isnull $I6130, $P6129
    if $I6130, if_6128
    .const 'Sub' $P6234 = "10_1303391609.928" 
    $P6235 = $P6234."get_lexinfo"()
    nqp_get_sc_object $P6236, "1303391598.821", 0
    $P6235."set_static_lexpad_value"("GLOBALish", $P6236)
    .const 'Sub' $P6237 = "10_1303391609.928" 
    $P6238 = $P6237."get_lexinfo"()
    $P6238."finish_static_lexpad"()
    .const 'Sub' $P6239 = "10_1303391609.928" 
    $P6240 = $P6239."get_lexinfo"()
    nqp_get_sc_object $P6241, "1303391598.821", 0
    $P6240."set_static_lexpad_value"("$?PACKAGE", $P6241)
    .const 'Sub' $P6242 = "10_1303391609.928" 
    $P6243 = $P6242."get_lexinfo"()
    $P6243."finish_static_lexpad"()
    nqp_get_sc_object $P6244, "1303391598.821", 1
    set_hll_global ["NQP"], "Grammar", $P6244
    .const 'Sub' $P6245 = "12_1303391609.928" 
    $P6246 = $P6245."get_lexinfo"()
    nqp_get_sc_object $P6247, "1303391598.821", 1
    $P6246."set_static_lexpad_value"("$?PACKAGE", $P6247)
    .const 'Sub' $P6248 = "12_1303391609.928" 
    $P6249 = $P6248."get_lexinfo"()
    $P6249."finish_static_lexpad"()
    .const 'Sub' $P6250 = "12_1303391609.928" 
    $P6251 = $P6250."get_lexinfo"()
    nqp_get_sc_object $P6252, "1303391598.821", 1
    $P6251."set_static_lexpad_value"("$?CLASS", $P6252)
    .const 'Sub' $P6253 = "12_1303391609.928" 
    $P6254 = $P6253."get_lexinfo"()
    $P6254."finish_static_lexpad"()
    nqp_get_sc_object $P6255, "1303391598.821", 2
    set_hll_global ["NQP"], "Regex", $P6255
    .const 'Sub' $P6256 = "384_1303391609.928" 
    $P6257 = $P6256."get_lexinfo"()
    nqp_get_sc_object $P6258, "1303391598.821", 2
    $P6257."set_static_lexpad_value"("$?PACKAGE", $P6258)
    .const 'Sub' $P6259 = "384_1303391609.928" 
    $P6260 = $P6259."get_lexinfo"()
    $P6260."finish_static_lexpad"()
    .const 'Sub' $P6261 = "384_1303391609.928" 
    $P6262 = $P6261."get_lexinfo"()
    nqp_get_sc_object $P6263, "1303391598.821", 2
    $P6262."set_static_lexpad_value"("$?CLASS", $P6263)
    .const 'Sub' $P6264 = "384_1303391609.928" 
    $P6265 = $P6264."get_lexinfo"()
    $P6265."finish_static_lexpad"()
    nqp_get_sc_object $P6266, "1303391598.821", 3
    set_hll_global ["NQP"], "Actions", $P6266
    .const 'Sub' $P6267 = "406_1303391609.928" 
    $P6268 = $P6267."get_lexinfo"()
    nqp_get_sc_object $P6269, "1303391598.821", 3
    $P6268."set_static_lexpad_value"("$?PACKAGE", $P6269)
    .const 'Sub' $P6270 = "406_1303391609.928" 
    $P6271 = $P6270."get_lexinfo"()
    $P6271."finish_static_lexpad"()
    .const 'Sub' $P6272 = "406_1303391609.928" 
    $P6273 = $P6272."get_lexinfo"()
    nqp_get_sc_object $P6274, "1303391598.821", 3
    $P6273."set_static_lexpad_value"("$?CLASS", $P6274)
    .const 'Sub' $P6275 = "406_1303391609.928" 
    $P6276 = $P6275."get_lexinfo"()
    $P6276."finish_static_lexpad"()
    nqp_get_sc_object $P6277, "1303391598.821", 4
    set_hll_global ["NQP"], "RegexActions", $P6277
    .const 'Sub' $P6278 = "562_1303391609.928" 
    $P6279 = $P6278."get_lexinfo"()
    nqp_get_sc_object $P6280, "1303391598.821", 4
    $P6279."set_static_lexpad_value"("$?PACKAGE", $P6280)
    .const 'Sub' $P6281 = "562_1303391609.928" 
    $P6282 = $P6281."get_lexinfo"()
    $P6282."finish_static_lexpad"()
    .const 'Sub' $P6283 = "562_1303391609.928" 
    $P6284 = $P6283."get_lexinfo"()
    nqp_get_sc_object $P6285, "1303391598.821", 4
    $P6284."set_static_lexpad_value"("$?CLASS", $P6285)
    .const 'Sub' $P6286 = "562_1303391609.928" 
    $P6287 = $P6286."get_lexinfo"()
    $P6287."finish_static_lexpad"()
    nqp_get_sc_object $P6288, "1303391598.821", 5
    set_hll_global ["NQP"], "Compiler", $P6288
    .const 'Sub' $P6289 = "571_1303391609.928" 
    $P6290 = $P6289."get_lexinfo"()
    nqp_get_sc_object $P6291, "1303391598.821", 5
    $P6290."set_static_lexpad_value"("$?PACKAGE", $P6291)
    .const 'Sub' $P6292 = "571_1303391609.928" 
    $P6293 = $P6292."get_lexinfo"()
    $P6293."finish_static_lexpad"()
    .const 'Sub' $P6294 = "571_1303391609.928" 
    $P6295 = $P6294."get_lexinfo"()
    nqp_get_sc_object $P6296, "1303391598.821", 5
    $P6295."set_static_lexpad_value"("$?CLASS", $P6296)
    .const 'Sub' $P6297 = "571_1303391609.928" 
    $P6298 = $P6297."get_lexinfo"()
    $P6298."finish_static_lexpad"()
    goto if_6128_end
  if_6128:
    nqp_dynop_setup 
    getinterp $P6131
    get_class $P6132, "LexPad"
    get_class $P6133, "NQPLexPad"
    $P6131."hll_map"($P6132, $P6133)
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P6134, "1303391598.821"
    .local pmc cur_sc
    set cur_sc, $P6134
    load_bytecode "SettingManager.pbc"
    get_hll_global $P6135, ["HLL"], "SettingManager"
    $P6136 = $P6135."load_setting"("NQPCORE")
    block."set_outer_ctx"($P6136)
    get_hll_global $P6137, "KnowHOW"
    $P6138 = $P6137."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P6138, cur_sc
    nqp_set_sc_object "1303391598.821", 0, $P6138
    .const 'Sub' $P6139 = "10_1303391609.928" 
    $P6140 = $P6139."get_lexinfo"()
    nqp_get_sc_object $P6141, "1303391598.821", 0
    $P6140."set_static_lexpad_value"("GLOBALish", $P6141)
    .const 'Sub' $P6142 = "10_1303391609.928" 
    $P6143 = $P6142."get_lexinfo"()
    $P6143."finish_static_lexpad"()
    .const 'Sub' $P6144 = "10_1303391609.928" 
    $P6145 = $P6144."get_lexinfo"()
    nqp_get_sc_object $P6146, "1303391598.821", 0
    $P6145."set_static_lexpad_value"("$?PACKAGE", $P6146)
    .const 'Sub' $P6147 = "10_1303391609.928" 
    $P6148 = $P6147."get_lexinfo"()
    $P6148."finish_static_lexpad"()
    load_bytecode "P6Regex.pbc"
    get_hll_global $P6149, "NQPClassHOW"
    $P6150 = $P6149."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P6150, cur_sc
    nqp_set_sc_object "1303391598.821", 1, $P6150
    nqp_get_sc_object $P6151, "1303391598.821", 1
    nqp_get_sc_object $P6152, "1303391598.821", 0
    nqp_get_package_through_who $P6153, $P6152, "NQP"
    get_who $P6154, $P6153
    set $P6154["Grammar"], $P6151
    nqp_get_sc_object $P6155, "1303391598.821", 1
    set_hll_global ["NQP"], "Grammar", $P6155
    .const 'Sub' $P6156 = "12_1303391609.928" 
    $P6157 = $P6156."get_lexinfo"()
    nqp_get_sc_object $P6158, "1303391598.821", 1
    $P6157."set_static_lexpad_value"("$?PACKAGE", $P6158)
    .const 'Sub' $P6159 = "12_1303391609.928" 
    $P6160 = $P6159."get_lexinfo"()
    $P6160."finish_static_lexpad"()
    .const 'Sub' $P6161 = "12_1303391609.928" 
    $P6162 = $P6161."get_lexinfo"()
    nqp_get_sc_object $P6163, "1303391598.821", 1
    $P6162."set_static_lexpad_value"("$?CLASS", $P6163)
    .const 'Sub' $P6164 = "12_1303391609.928" 
    $P6165 = $P6164."get_lexinfo"()
    $P6165."finish_static_lexpad"()
    get_hll_global $P6166, "NQPClassHOW"
    $P6167 = $P6166."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P6167, cur_sc
    nqp_set_sc_object "1303391598.821", 2, $P6167
    nqp_get_sc_object $P6168, "1303391598.821", 2
    nqp_get_sc_object $P6169, "1303391598.821", 0
    nqp_get_package_through_who $P6170, $P6169, "NQP"
    get_who $P6171, $P6170
    set $P6171["Regex"], $P6168
    nqp_get_sc_object $P6172, "1303391598.821", 2
    set_hll_global ["NQP"], "Regex", $P6172
    .const 'Sub' $P6173 = "384_1303391609.928" 
    $P6174 = $P6173."get_lexinfo"()
    nqp_get_sc_object $P6175, "1303391598.821", 2
    $P6174."set_static_lexpad_value"("$?PACKAGE", $P6175)
    .const 'Sub' $P6176 = "384_1303391609.928" 
    $P6177 = $P6176."get_lexinfo"()
    $P6177."finish_static_lexpad"()
    .const 'Sub' $P6178 = "384_1303391609.928" 
    $P6179 = $P6178."get_lexinfo"()
    nqp_get_sc_object $P6180, "1303391598.821", 2
    $P6179."set_static_lexpad_value"("$?CLASS", $P6180)
    .const 'Sub' $P6181 = "384_1303391609.928" 
    $P6182 = $P6181."get_lexinfo"()
    $P6182."finish_static_lexpad"()
    get_hll_global $P6183, "NQPClassHOW"
    $P6184 = $P6183."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P6184, cur_sc
    nqp_set_sc_object "1303391598.821", 3, $P6184
    nqp_get_sc_object $P6185, "1303391598.821", 3
    nqp_get_sc_object $P6186, "1303391598.821", 0
    nqp_get_package_through_who $P6187, $P6186, "NQP"
    get_who $P6188, $P6187
    set $P6188["Actions"], $P6185
    nqp_get_sc_object $P6189, "1303391598.821", 3
    set_hll_global ["NQP"], "Actions", $P6189
    .const 'Sub' $P6190 = "406_1303391609.928" 
    $P6191 = $P6190."get_lexinfo"()
    nqp_get_sc_object $P6192, "1303391598.821", 3
    $P6191."set_static_lexpad_value"("$?PACKAGE", $P6192)
    .const 'Sub' $P6193 = "406_1303391609.928" 
    $P6194 = $P6193."get_lexinfo"()
    $P6194."finish_static_lexpad"()
    .const 'Sub' $P6195 = "406_1303391609.928" 
    $P6196 = $P6195."get_lexinfo"()
    nqp_get_sc_object $P6197, "1303391598.821", 3
    $P6196."set_static_lexpad_value"("$?CLASS", $P6197)
    .const 'Sub' $P6198 = "406_1303391609.928" 
    $P6199 = $P6198."get_lexinfo"()
    $P6199."finish_static_lexpad"()
    get_hll_global $P6200, "NQPClassHOW"
    $P6201 = $P6200."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P6201, cur_sc
    nqp_set_sc_object "1303391598.821", 4, $P6201
    nqp_get_sc_object $P6202, "1303391598.821", 4
    nqp_get_sc_object $P6203, "1303391598.821", 0
    nqp_get_package_through_who $P6204, $P6203, "NQP"
    get_who $P6205, $P6204
    set $P6205["RegexActions"], $P6202
    nqp_get_sc_object $P6206, "1303391598.821", 4
    set_hll_global ["NQP"], "RegexActions", $P6206
    .const 'Sub' $P6207 = "562_1303391609.928" 
    $P6208 = $P6207."get_lexinfo"()
    nqp_get_sc_object $P6209, "1303391598.821", 4
    $P6208."set_static_lexpad_value"("$?PACKAGE", $P6209)
    .const 'Sub' $P6210 = "562_1303391609.928" 
    $P6211 = $P6210."get_lexinfo"()
    $P6211."finish_static_lexpad"()
    .const 'Sub' $P6212 = "562_1303391609.928" 
    $P6213 = $P6212."get_lexinfo"()
    nqp_get_sc_object $P6214, "1303391598.821", 4
    $P6213."set_static_lexpad_value"("$?CLASS", $P6214)
    .const 'Sub' $P6215 = "562_1303391609.928" 
    $P6216 = $P6215."get_lexinfo"()
    $P6216."finish_static_lexpad"()
    get_hll_global $P6217, "NQPClassHOW"
    $P6218 = $P6217."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P6218, cur_sc
    nqp_set_sc_object "1303391598.821", 5, $P6218
    nqp_get_sc_object $P6219, "1303391598.821", 5
    nqp_get_sc_object $P6220, "1303391598.821", 0
    nqp_get_package_through_who $P6221, $P6220, "NQP"
    get_who $P6222, $P6221
    set $P6222["Compiler"], $P6219
    nqp_get_sc_object $P6223, "1303391598.821", 5
    set_hll_global ["NQP"], "Compiler", $P6223
    .const 'Sub' $P6224 = "571_1303391609.928" 
    $P6225 = $P6224."get_lexinfo"()
    nqp_get_sc_object $P6226, "1303391598.821", 5
    $P6225."set_static_lexpad_value"("$?PACKAGE", $P6226)
    .const 'Sub' $P6227 = "571_1303391609.928" 
    $P6228 = $P6227."get_lexinfo"()
    $P6228."finish_static_lexpad"()
    .const 'Sub' $P6229 = "571_1303391609.928" 
    $P6230 = $P6229."get_lexinfo"()
    nqp_get_sc_object $P6231, "1303391598.821", 5
    $P6230."set_static_lexpad_value"("$?CLASS", $P6231)
    .const 'Sub' $P6232 = "571_1303391609.928" 
    $P6233 = $P6232."get_lexinfo"()
    $P6233."finish_static_lexpad"()
  if_6128_end:
    nqp_get_sc_object $P6299, "1303391598.821", 0
    set_hll_global "GLOBAL", $P6299
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1303391609.928") :outer("10_1303391609.928")
    .param pmc param_17
.annotate 'line', 2231
    .lex "@ARGS", param_17
.annotate 'line', 2233
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2239
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2233
    get_hll_global $P20, ["NQP"], "Compiler"
    $P21 = $P20."new"()
    store_lex "$nqpcomp", $P21
.annotate 'line', 2234
    find_lex $P22, "$nqpcomp"
    unless_null $P22, vivify_575
    new $P22, "Undef"
  vivify_575:
    $P22."language"("nqp")
.annotate 'line', 2235
    find_lex $P23, "$nqpcomp"
    unless_null $P23, vivify_576
    new $P23, "Undef"
  vivify_576:
    get_hll_global $P24, ["NQP"], "Grammar"
    $P23."parsegrammar"($P24)
.annotate 'line', 2236
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_577
    new $P25, "Undef"
  vivify_577:
    get_hll_global $P26, ["NQP"], "Actions"
    $P25."parseactions"($P26)
.annotate 'line', 2239
    find_lex $P27, "$nqpcomp"
    unless_null $P27, vivify_578
    new $P27, "Undef"
  vivify_578:
    $P28 = $P27."commandline_options"()
    store_lex "@clo", $P28
.annotate 'line', 2240
    find_lex $P29, "@clo"
    unless_null $P29, vivify_579
    $P29 = root_new ['parrot';'ResizablePMCArray']
  vivify_579:
    $P29."push"("parsetrace")
.annotate 'line', 2241
    find_lex $P30, "@clo"
    unless_null $P30, vivify_580
    $P30 = root_new ['parrot';'ResizablePMCArray']
  vivify_580:
    $P30."push"("setting=s")
.annotate 'line', 2244
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_581
    new $P31, "Undef"
  vivify_581:
    find_lex $P32, "@ARGS"
    unless_null $P32, vivify_582
    $P32 = root_new ['parrot';'ResizablePMCArray']
  vivify_582:
    $P33 = $P31."command_line"($P32, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2231
    .return ($P33)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block35"  :subid("12_1303391609.928") :outer("10_1303391609.928")
.annotate 'line', 9
    .const 'Sub' $P1706 = "383_1303391609.928" 
    capture_lex $P1706
    .const 'Sub' $P1693 = "382_1303391609.928" 
    capture_lex $P1693
    .const 'Sub' $P1687 = "380_1303391609.928" 
    capture_lex $P1687
    .const 'Sub' $P1681 = "378_1303391609.928" 
    capture_lex $P1681
    .const 'Sub' $P1675 = "376_1303391609.928" 
    capture_lex $P1675
    .const 'Sub' $P1669 = "374_1303391609.928" 
    capture_lex $P1669
    .const 'Sub' $P1657 = "371_1303391609.928" 
    capture_lex $P1657
    .const 'Sub' $P1650 = "369_1303391609.928" 
    capture_lex $P1650
    .const 'Sub' $P1643 = "367_1303391609.928" 
    capture_lex $P1643
    .const 'Sub' $P1636 = "365_1303391609.928" 
    capture_lex $P1636
    .const 'Sub' $P1629 = "363_1303391609.928" 
    capture_lex $P1629
    .const 'Sub' $P1623 = "361_1303391609.928" 
    capture_lex $P1623
    .const 'Sub' $P1616 = "359_1303391609.928" 
    capture_lex $P1616
    .const 'Sub' $P1609 = "357_1303391609.928" 
    capture_lex $P1609
    .const 'Sub' $P1602 = "355_1303391609.928" 
    capture_lex $P1602
    .const 'Sub' $P1595 = "353_1303391609.928" 
    capture_lex $P1595
    .const 'Sub' $P1588 = "351_1303391609.928" 
    capture_lex $P1588
    .const 'Sub' $P1581 = "349_1303391609.928" 
    capture_lex $P1581
    .const 'Sub' $P1574 = "347_1303391609.928" 
    capture_lex $P1574
    .const 'Sub' $P1567 = "345_1303391609.928" 
    capture_lex $P1567
    .const 'Sub' $P1560 = "343_1303391609.928" 
    capture_lex $P1560
    .const 'Sub' $P1553 = "341_1303391609.928" 
    capture_lex $P1553
    .const 'Sub' $P1546 = "339_1303391609.928" 
    capture_lex $P1546
    .const 'Sub' $P1539 = "337_1303391609.928" 
    capture_lex $P1539
    .const 'Sub' $P1532 = "335_1303391609.928" 
    capture_lex $P1532
    .const 'Sub' $P1525 = "333_1303391609.928" 
    capture_lex $P1525
    .const 'Sub' $P1518 = "331_1303391609.928" 
    capture_lex $P1518
    .const 'Sub' $P1511 = "329_1303391609.928" 
    capture_lex $P1511
    .const 'Sub' $P1504 = "327_1303391609.928" 
    capture_lex $P1504
    .const 'Sub' $P1497 = "325_1303391609.928" 
    capture_lex $P1497
    .const 'Sub' $P1490 = "323_1303391609.928" 
    capture_lex $P1490
    .const 'Sub' $P1483 = "321_1303391609.928" 
    capture_lex $P1483
    .const 'Sub' $P1476 = "319_1303391609.928" 
    capture_lex $P1476
    .const 'Sub' $P1469 = "317_1303391609.928" 
    capture_lex $P1469
    .const 'Sub' $P1462 = "315_1303391609.928" 
    capture_lex $P1462
    .const 'Sub' $P1455 = "313_1303391609.928" 
    capture_lex $P1455
    .const 'Sub' $P1448 = "311_1303391609.928" 
    capture_lex $P1448
    .const 'Sub' $P1441 = "309_1303391609.928" 
    capture_lex $P1441
    .const 'Sub' $P1434 = "307_1303391609.928" 
    capture_lex $P1434
    .const 'Sub' $P1427 = "305_1303391609.928" 
    capture_lex $P1427
    .const 'Sub' $P1420 = "303_1303391609.928" 
    capture_lex $P1420
    .const 'Sub' $P1414 = "301_1303391609.928" 
    capture_lex $P1414
    .const 'Sub' $P1407 = "299_1303391609.928" 
    capture_lex $P1407
    .const 'Sub' $P1400 = "297_1303391609.928" 
    capture_lex $P1400
    .const 'Sub' $P1393 = "295_1303391609.928" 
    capture_lex $P1393
    .const 'Sub' $P1386 = "293_1303391609.928" 
    capture_lex $P1386
    .const 'Sub' $P1379 = "291_1303391609.928" 
    capture_lex $P1379
    .const 'Sub' $P1372 = "289_1303391609.928" 
    capture_lex $P1372
    .const 'Sub' $P1365 = "287_1303391609.928" 
    capture_lex $P1365
    .const 'Sub' $P1359 = "285_1303391609.928" 
    capture_lex $P1359
    .const 'Sub' $P1353 = "283_1303391609.928" 
    capture_lex $P1353
    .const 'Sub' $P1348 = "281_1303391609.928" 
    capture_lex $P1348
    .const 'Sub' $P1342 = "279_1303391609.928" 
    capture_lex $P1342
    .const 'Sub' $P1336 = "277_1303391609.928" 
    capture_lex $P1336
    .const 'Sub' $P1331 = "275_1303391609.928" 
    capture_lex $P1331
    .const 'Sub' $P1326 = "273_1303391609.928" 
    capture_lex $P1326
    .const 'Sub' $P1318 = "271_1303391609.928" 
    capture_lex $P1318
    .const 'Sub' $P1309 = "269_1303391609.928" 
    capture_lex $P1309
    .const 'Sub' $P1304 = "267_1303391609.928" 
    capture_lex $P1304
    .const 'Sub' $P1299 = "265_1303391609.928" 
    capture_lex $P1299
    .const 'Sub' $P1294 = "263_1303391609.928" 
    capture_lex $P1294
    .const 'Sub' $P1286 = "261_1303391609.928" 
    capture_lex $P1286
    .const 'Sub' $P1278 = "259_1303391609.928" 
    capture_lex $P1278
    .const 'Sub' $P1273 = "257_1303391609.928" 
    capture_lex $P1273
    .const 'Sub' $P1268 = "255_1303391609.928" 
    capture_lex $P1268
    .const 'Sub' $P1263 = "253_1303391609.928" 
    capture_lex $P1263
    .const 'Sub' $P1257 = "251_1303391609.928" 
    capture_lex $P1257
    .const 'Sub' $P1250 = "249_1303391609.928" 
    capture_lex $P1250
    .const 'Sub' $P1243 = "247_1303391609.928" 
    capture_lex $P1243
    .const 'Sub' $P1236 = "245_1303391609.928" 
    capture_lex $P1236
    .const 'Sub' $P1229 = "243_1303391609.928" 
    capture_lex $P1229
    .const 'Sub' $P1224 = "241_1303391609.928" 
    capture_lex $P1224
    .const 'Sub' $P1219 = "239_1303391609.928" 
    capture_lex $P1219
    .const 'Sub' $P1205 = "235_1303391609.928" 
    capture_lex $P1205
    .const 'Sub' $P1197 = "233_1303391609.928" 
    capture_lex $P1197
    .const 'Sub' $P1191 = "231_1303391609.928" 
    capture_lex $P1191
    .const 'Sub' $P1184 = "229_1303391609.928" 
    capture_lex $P1184
    .const 'Sub' $P1178 = "227_1303391609.928" 
    capture_lex $P1178
    .const 'Sub' $P1164 = "224_1303391609.928" 
    capture_lex $P1164
    .const 'Sub' $P1156 = "222_1303391609.928" 
    capture_lex $P1156
    .const 'Sub' $P1148 = "220_1303391609.928" 
    capture_lex $P1148
    .const 'Sub' $P1142 = "218_1303391609.928" 
    capture_lex $P1142
    .const 'Sub' $P1136 = "216_1303391609.928" 
    capture_lex $P1136
    .const 'Sub' $P1120 = "212_1303391609.928" 
    capture_lex $P1120
    .const 'Sub' $P1079 = "210_1303391609.928" 
    capture_lex $P1079
    .const 'Sub' $P1068 = "208_1303391609.928" 
    capture_lex $P1068
    .const 'Sub' $P1054 = "204_1303391609.928" 
    capture_lex $P1054
    .const 'Sub' $P1045 = "202_1303391609.928" 
    capture_lex $P1045
    .const 'Sub' $P1039 = "200_1303391609.928" 
    capture_lex $P1039
    .const 'Sub' $P1029 = "198_1303391609.928" 
    capture_lex $P1029
    .const 'Sub' $P1014 = "196_1303391609.928" 
    capture_lex $P1014
    .const 'Sub' $P1000 = "193_1303391609.928" 
    capture_lex $P1000
    .const 'Sub' $P992 = "191_1303391609.928" 
    capture_lex $P992
    .const 'Sub' $P982 = "189_1303391609.928" 
    capture_lex $P982
    .const 'Sub' $P972 = "187_1303391609.928" 
    capture_lex $P972
    .const 'Sub' $P953 = "182_1303391609.928" 
    capture_lex $P953
    .const 'Sub' $P909 = "179_1303391609.928" 
    capture_lex $P909
    .const 'Sub' $P875 = "177_1303391609.928" 
    capture_lex $P875
    .const 'Sub' $P868 = "175_1303391609.928" 
    capture_lex $P868
    .const 'Sub' $P861 = "173_1303391609.928" 
    capture_lex $P861
    .const 'Sub' $P844 = "169_1303391609.928" 
    capture_lex $P844
    .const 'Sub' $P836 = "167_1303391609.928" 
    capture_lex $P836
    .const 'Sub' $P830 = "165_1303391609.928" 
    capture_lex $P830
    .const 'Sub' $P814 = "163_1303391609.928" 
    capture_lex $P814
    .const 'Sub' $P807 = "161_1303391609.928" 
    capture_lex $P807
    .const 'Sub' $P800 = "159_1303391609.928" 
    capture_lex $P800
    .const 'Sub' $P793 = "157_1303391609.928" 
    capture_lex $P793
    .const 'Sub' $P715 = "152_1303391609.928" 
    capture_lex $P715
    .const 'Sub' $P701 = "150_1303391609.928" 
    capture_lex $P701
    .const 'Sub' $P687 = "148_1303391609.928" 
    capture_lex $P687
    .const 'Sub' $P673 = "146_1303391609.928" 
    capture_lex $P673
    .const 'Sub' $P659 = "144_1303391609.928" 
    capture_lex $P659
    .const 'Sub' $P645 = "142_1303391609.928" 
    capture_lex $P645
    .const 'Sub' $P631 = "140_1303391609.928" 
    capture_lex $P631
    .const 'Sub' $P620 = "136_1303391609.928" 
    capture_lex $P620
    .const 'Sub' $P615 = "134_1303391609.928" 
    capture_lex $P615
    .const 'Sub' $P603 = "132_1303391609.928" 
    capture_lex $P603
    .const 'Sub' $P591 = "130_1303391609.928" 
    capture_lex $P591
    .const 'Sub' $P584 = "128_1303391609.928" 
    capture_lex $P584
    .const 'Sub' $P579 = "126_1303391609.928" 
    capture_lex $P579
    .const 'Sub' $P573 = "124_1303391609.928" 
    capture_lex $P573
    .const 'Sub' $P567 = "122_1303391609.928" 
    capture_lex $P567
    .const 'Sub' $P552 = "118_1303391609.928" 
    capture_lex $P552
    .const 'Sub' $P546 = "116_1303391609.928" 
    capture_lex $P546
    .const 'Sub' $P540 = "114_1303391609.928" 
    capture_lex $P540
    .const 'Sub' $P534 = "112_1303391609.928" 
    capture_lex $P534
    .const 'Sub' $P528 = "110_1303391609.928" 
    capture_lex $P528
    .const 'Sub' $P522 = "108_1303391609.928" 
    capture_lex $P522
    .const 'Sub' $P516 = "106_1303391609.928" 
    capture_lex $P516
    .const 'Sub' $P507 = "104_1303391609.928" 
    capture_lex $P507
    .const 'Sub' $P498 = "102_1303391609.928" 
    capture_lex $P498
    .const 'Sub' $P489 = "100_1303391609.928" 
    capture_lex $P489
    .const 'Sub' $P474 = "96_1303391609.928" 
    capture_lex $P474
    .const 'Sub' $P465 = "94_1303391609.928" 
    capture_lex $P465
    .const 'Sub' $P453 = "90_1303391609.928" 
    capture_lex $P453
    .const 'Sub' $P446 = "88_1303391609.928" 
    capture_lex $P446
    .const 'Sub' $P439 = "86_1303391609.928" 
    capture_lex $P439
    .const 'Sub' $P425 = "82_1303391609.928" 
    capture_lex $P425
    .const 'Sub' $P417 = "80_1303391609.928" 
    capture_lex $P417
    .const 'Sub' $P409 = "78_1303391609.928" 
    capture_lex $P409
    .const 'Sub' $P389 = "76_1303391609.928" 
    capture_lex $P389
    .const 'Sub' $P380 = "74_1303391609.928" 
    capture_lex $P380
    .const 'Sub' $P362 = "71_1303391609.928" 
    capture_lex $P362
    .const 'Sub' $P344 = "69_1303391609.928" 
    capture_lex $P344
    .const 'Sub' $P336 = "67_1303391609.928" 
    capture_lex $P336
    .const 'Sub' $P325 = "63_1303391609.928" 
    capture_lex $P325
    .const 'Sub' $P320 = "61_1303391609.928" 
    capture_lex $P320
    .const 'Sub' $P309 = "57_1303391609.928" 
    capture_lex $P309
    .const 'Sub' $P304 = "55_1303391609.928" 
    capture_lex $P304
    .const 'Sub' $P299 = "53_1303391609.928" 
    capture_lex $P299
    .const 'Sub' $P294 = "51_1303391609.928" 
    capture_lex $P294
    .const 'Sub' $P289 = "49_1303391609.928" 
    capture_lex $P289
    .const 'Sub' $P279 = "47_1303391609.928" 
    capture_lex $P279
    .const 'Sub' $P272 = "45_1303391609.928" 
    capture_lex $P272
    .const 'Sub' $P266 = "43_1303391609.928" 
    capture_lex $P266
    .const 'Sub' $P258 = "41_1303391609.928" 
    capture_lex $P258
    .const 'Sub' $P252 = "39_1303391609.928" 
    capture_lex $P252
    .const 'Sub' $P246 = "37_1303391609.928" 
    capture_lex $P246
    .const 'Sub' $P231 = "34_1303391609.928" 
    capture_lex $P231
    .const 'Sub' $P217 = "32_1303391609.928" 
    capture_lex $P217
    .const 'Sub' $P202 = "30_1303391609.928" 
    capture_lex $P202
    .const 'Sub' $P163 = "27_1303391609.928" 
    capture_lex $P163
    .const 'Sub' $P148 = "24_1303391609.928" 
    capture_lex $P148
    .const 'Sub' $P137 = "22_1303391609.928" 
    capture_lex $P137
    .const 'Sub' $P125 = "20_1303391609.928" 
    capture_lex $P125
    .const 'Sub' $P117 = "18_1303391609.928" 
    capture_lex $P117
    .const 'Sub' $P110 = "16_1303391609.928" 
    capture_lex $P110
    .const 'Sub' $P103 = "14_1303391609.928" 
    capture_lex $P103
    .const 'Sub' $P54 = "13_1303391609.928" 
    capture_lex $P54
    .lex "$?PACKAGE", $P37
    .lex "$?CLASS", $P38
.annotate 'line', 591
    get_hll_global $P39, ["NQP"], "Grammar"
    $P39."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 592
    get_hll_global $P40, ["NQP"], "Grammar"
    $P40."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 593
    get_hll_global $P41, ["NQP"], "Grammar"
    $P41."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 594
    get_hll_global $P42, ["NQP"], "Grammar"
    $P42."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 595
    get_hll_global $P43, ["NQP"], "Grammar"
    $P43."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 596
    get_hll_global $P44, ["NQP"], "Grammar"
    $P44."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 597
    get_hll_global $P45, ["NQP"], "Grammar"
    $P45."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 598
    get_hll_global $P46, ["NQP"], "Grammar"
    $P46."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 599
    get_hll_global $P47, ["NQP"], "Grammar"
    $P47."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 600
    get_hll_global $P48, ["NQP"], "Grammar"
    $P48."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 601
    get_hll_global $P49, ["NQP"], "Grammar"
    $P49."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 602
    get_hll_global $P50, ["NQP"], "Grammar"
    $P50."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 603
    get_hll_global $P51, ["NQP"], "Grammar"
    $P51."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 604
    get_hll_global $P52, ["NQP"], "Grammar"
    $P52."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 605
    get_hll_global $P53, ["NQP"], "Grammar"
    $P53."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 704
    .const 'Sub' $P1693 = "382_1303391609.928" 
    newclosure $P1704, $P1693
.annotate 'line', 9
    .return ($P1704)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post583") :outer("12_1303391609.928")
.annotate 'line', 9
    get_hll_global $P36, ["NQP";"Grammar"], "_block35" 
    .local pmc block
    set block, $P36
    .const 'Sub' $P1706 = "383_1303391609.928" 
    capture_lex $P1706
    $P1706()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1705"  :anon :subid("383_1303391609.928") :outer("12_1303391609.928")
.annotate 'line', 9
    nqp_get_sc_object $P1707, "1303391598.821", 1
    .local pmc type_obj
    set type_obj, $P1707
    get_how $P1708, type_obj
    .const 'Sub' $P1709 = "13_1303391609.928" 
    $P1708."add_method"(type_obj, "TOP", $P1709)
    get_how $P1710, type_obj
    .const 'Sub' $P1711 = "14_1303391609.928" 
    $P1710."add_method"(type_obj, "identifier", $P1711)
    get_how $P1712, type_obj
    get_global $P1713, "!PREFIX__identifier"
    $P1712."add_method"(type_obj, "!PREFIX__identifier", $P1713)
    get_how $P1714, type_obj
    .const 'Sub' $P1715 = "16_1303391609.928" 
    $P1714."add_method"(type_obj, "name", $P1715)
    get_how $P1716, type_obj
    get_global $P1717, "!PREFIX__name"
    $P1716."add_method"(type_obj, "!PREFIX__name", $P1717)
    get_how $P1718, type_obj
    .const 'Sub' $P1719 = "18_1303391609.928" 
    $P1718."add_method"(type_obj, "deflongname", $P1719)
    get_how $P1720, type_obj
    get_global $P1721, "!PREFIX__deflongname"
    $P1720."add_method"(type_obj, "!PREFIX__deflongname", $P1721)
    get_how $P1722, type_obj
    .const 'Sub' $P1723 = "20_1303391609.928" 
    $P1722."add_method"(type_obj, "ENDSTMT", $P1723)
    get_how $P1724, type_obj
    get_global $P1725, "!PREFIX__ENDSTMT"
    $P1724."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1725)
    get_how $P1726, type_obj
    .const 'Sub' $P1727 = "22_1303391609.928" 
    $P1726."add_method"(type_obj, "ws", $P1727)
    get_how $P1728, type_obj
    get_global $P1729, "!PREFIX__ws"
    $P1728."add_method"(type_obj, "!PREFIX__ws", $P1729)
    get_how $P1730, type_obj
    .const 'Sub' $P1731 = "24_1303391609.928" 
    $P1730."add_method"(type_obj, "unv", $P1731)
    get_how $P1732, type_obj
    get_global $P1733, "!PREFIX__unv"
    $P1732."add_method"(type_obj, "!PREFIX__unv", $P1733)
    get_how $P1734, type_obj
    .const 'Sub' $P1735 = "27_1303391609.928" 
    $P1734."add_method"(type_obj, "pod_comment", $P1735)
    get_how $P1736, type_obj
    get_global $P1737, "!PREFIX__pod_comment"
    $P1736."add_method"(type_obj, "!PREFIX__pod_comment", $P1737)
    get_how $P1738, type_obj
    .const 'Sub' $P1739 = "30_1303391609.928" 
    $P1738."add_method"(type_obj, "comp_unit", $P1739)
    get_how $P1740, type_obj
    get_global $P1741, "!PREFIX__comp_unit"
    $P1740."add_method"(type_obj, "!PREFIX__comp_unit", $P1741)
    get_how $P1742, type_obj
    .const 'Sub' $P1743 = "32_1303391609.928" 
    $P1742."add_method"(type_obj, "statementlist", $P1743)
    get_how $P1744, type_obj
    get_global $P1745, "!PREFIX__statementlist"
    $P1744."add_method"(type_obj, "!PREFIX__statementlist", $P1745)
    get_how $P1746, type_obj
    .const 'Sub' $P1747 = "34_1303391609.928" 
    $P1746."add_method"(type_obj, "statement", $P1747)
    get_how $P1748, type_obj
    get_global $P1749, "!PREFIX__statement"
    $P1748."add_method"(type_obj, "!PREFIX__statement", $P1749)
    get_how $P1750, type_obj
    .const 'Sub' $P1751 = "37_1303391609.928" 
    $P1750."add_method"(type_obj, "eat_terminator", $P1751)
    get_how $P1752, type_obj
    get_global $P1753, "!PREFIX__eat_terminator"
    $P1752."add_method"(type_obj, "!PREFIX__eat_terminator", $P1753)
    get_how $P1754, type_obj
    .const 'Sub' $P1755 = "39_1303391609.928" 
    $P1754."add_method"(type_obj, "xblock", $P1755)
    get_how $P1756, type_obj
    get_global $P1757, "!PREFIX__xblock"
    $P1756."add_method"(type_obj, "!PREFIX__xblock", $P1757)
    get_how $P1758, type_obj
    .const 'Sub' $P1759 = "41_1303391609.928" 
    $P1758."add_method"(type_obj, "pblock", $P1759)
    get_how $P1760, type_obj
    get_global $P1761, "!PREFIX__pblock"
    $P1760."add_method"(type_obj, "!PREFIX__pblock", $P1761)
    get_how $P1762, type_obj
    .const 'Sub' $P1763 = "43_1303391609.928" 
    $P1762."add_method"(type_obj, "lambda", $P1763)
    get_how $P1764, type_obj
    get_global $P1765, "!PREFIX__lambda"
    $P1764."add_method"(type_obj, "!PREFIX__lambda", $P1765)
    get_how $P1766, type_obj
    .const 'Sub' $P1767 = "45_1303391609.928" 
    $P1766."add_method"(type_obj, "block", $P1767)
    get_how $P1768, type_obj
    get_global $P1769, "!PREFIX__block"
    $P1768."add_method"(type_obj, "!PREFIX__block", $P1769)
    get_how $P1770, type_obj
    .const 'Sub' $P1771 = "47_1303391609.928" 
    $P1770."add_method"(type_obj, "blockoid", $P1771)
    get_how $P1772, type_obj
    get_global $P1773, "!PREFIX__blockoid"
    $P1772."add_method"(type_obj, "!PREFIX__blockoid", $P1773)
    get_how $P1774, type_obj
    .const 'Sub' $P1775 = "49_1303391609.928" 
    $P1774."add_method"(type_obj, "newpad", $P1775)
    get_how $P1776, type_obj
    get_global $P1777, "!PREFIX__newpad"
    $P1776."add_method"(type_obj, "!PREFIX__newpad", $P1777)
    get_how $P1778, type_obj
    .const 'Sub' $P1779 = "51_1303391609.928" 
    $P1778."add_method"(type_obj, "outerctx", $P1779)
    get_how $P1780, type_obj
    get_global $P1781, "!PREFIX__outerctx"
    $P1780."add_method"(type_obj, "!PREFIX__outerctx", $P1781)
    get_how $P1782, type_obj
    .const 'Sub' $P1783 = "53_1303391609.928" 
    $P1782."add_method"(type_obj, "GLOBALish", $P1783)
    get_how $P1784, type_obj
    get_global $P1785, "!PREFIX__GLOBALish"
    $P1784."add_method"(type_obj, "!PREFIX__GLOBALish", $P1785)
    get_how $P1786, type_obj
    .const 'Sub' $P1787 = "55_1303391609.928" 
    $P1786."add_method"(type_obj, "finishpad", $P1787)
    get_how $P1788, type_obj
    get_global $P1789, "!PREFIX__finishpad"
    $P1788."add_method"(type_obj, "!PREFIX__finishpad", $P1789)
    get_how $P1790, type_obj
    .const 'Sub' $P1791 = "57_1303391609.928" 
    $P1790."add_method"(type_obj, "you_are_here", $P1791)
    get_how $P1792, type_obj
    get_global $P1793, "!PREFIX__you_are_here"
    $P1792."add_method"(type_obj, "!PREFIX__you_are_here", $P1793)
    get_how $P1794, type_obj
    .const 'Sub' $P1795 = "59_1303391609.928" 
    $P1794."add_method"(type_obj, "terminator", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "60_1303391609.928" 
    $P1796."add_method"(type_obj, "!PREFIX__terminator", $P1797)
    get_how $P1798, type_obj
    .const 'Sub' $P1799 = "61_1303391609.928" 
    $P1798."add_method"(type_obj, "terminator:sym<;>", $P1799)
    get_how $P1800, type_obj
    get_global $P1801, "!PREFIX__terminator:sym<;>"
    $P1800."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1801)
    get_how $P1802, type_obj
    .const 'Sub' $P1803 = "63_1303391609.928" 
    $P1802."add_method"(type_obj, "terminator:sym<}>", $P1803)
    get_how $P1804, type_obj
    get_global $P1805, "!PREFIX__terminator:sym<}>"
    $P1804."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1805)
    get_how $P1806, type_obj
    .const 'Sub' $P1807 = "65_1303391609.928" 
    $P1806."add_method"(type_obj, "statement_control", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "66_1303391609.928" 
    $P1808."add_method"(type_obj, "!PREFIX__statement_control", $P1809)
    get_how $P1810, type_obj
    .const 'Sub' $P1811 = "67_1303391609.928" 
    $P1810."add_method"(type_obj, "statement_control:sym<use>", $P1811)
    get_how $P1812, type_obj
    get_global $P1813, "!PREFIX__statement_control:sym<use>"
    $P1812."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1813)
    get_how $P1814, type_obj
    .const 'Sub' $P1815 = "69_1303391609.928" 
    $P1814."add_method"(type_obj, "statement_control:sym<if>", $P1815)
    get_how $P1816, type_obj
    get_global $P1817, "!PREFIX__statement_control:sym<if>"
    $P1816."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1817)
    get_how $P1818, type_obj
    .const 'Sub' $P1819 = "71_1303391609.928" 
    $P1818."add_method"(type_obj, "statement_control:sym<unless>", $P1819)
    get_how $P1820, type_obj
    get_global $P1821, "!PREFIX__statement_control:sym<unless>"
    $P1820."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1821)
    get_how $P1822, type_obj
    .const 'Sub' $P1823 = "74_1303391609.928" 
    $P1822."add_method"(type_obj, "statement_control:sym<while>", $P1823)
    get_how $P1824, type_obj
    get_global $P1825, "!PREFIX__statement_control:sym<while>"
    $P1824."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1825)
    get_how $P1826, type_obj
    .const 'Sub' $P1827 = "76_1303391609.928" 
    $P1826."add_method"(type_obj, "statement_control:sym<repeat>", $P1827)
    get_how $P1828, type_obj
    get_global $P1829, "!PREFIX__statement_control:sym<repeat>"
    $P1828."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1829)
    get_how $P1830, type_obj
    .const 'Sub' $P1831 = "78_1303391609.928" 
    $P1830."add_method"(type_obj, "statement_control:sym<for>", $P1831)
    get_how $P1832, type_obj
    get_global $P1833, "!PREFIX__statement_control:sym<for>"
    $P1832."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1833)
    get_how $P1834, type_obj
    .const 'Sub' $P1835 = "80_1303391609.928" 
    $P1834."add_method"(type_obj, "statement_control:sym<CATCH>", $P1835)
    get_how $P1836, type_obj
    get_global $P1837, "!PREFIX__statement_control:sym<CATCH>"
    $P1836."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1837)
    get_how $P1838, type_obj
    .const 'Sub' $P1839 = "82_1303391609.928" 
    $P1838."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1839)
    get_how $P1840, type_obj
    get_global $P1841, "!PREFIX__statement_control:sym<CONTROL>"
    $P1840."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1841)
    get_how $P1842, type_obj
    .const 'Sub' $P1843 = "84_1303391609.928" 
    $P1842."add_method"(type_obj, "statement_prefix", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "85_1303391609.928" 
    $P1844."add_method"(type_obj, "!PREFIX__statement_prefix", $P1845)
    get_how $P1846, type_obj
    .const 'Sub' $P1847 = "86_1303391609.928" 
    $P1846."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1847)
    get_how $P1848, type_obj
    get_global $P1849, "!PREFIX__statement_prefix:sym<INIT>"
    $P1848."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1849)
    get_how $P1850, type_obj
    .const 'Sub' $P1851 = "88_1303391609.928" 
    $P1850."add_method"(type_obj, "statement_prefix:sym<try>", $P1851)
    get_how $P1852, type_obj
    get_global $P1853, "!PREFIX__statement_prefix:sym<try>"
    $P1852."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1853)
    get_how $P1854, type_obj
    .const 'Sub' $P1855 = "90_1303391609.928" 
    $P1854."add_method"(type_obj, "blorst", $P1855)
    get_how $P1856, type_obj
    get_global $P1857, "!PREFIX__blorst"
    $P1856."add_method"(type_obj, "!PREFIX__blorst", $P1857)
    get_how $P1858, type_obj
    .const 'Sub' $P1859 = "92_1303391609.928" 
    $P1858."add_method"(type_obj, "statement_mod_cond", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "93_1303391609.928" 
    $P1860."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1861)
    get_how $P1862, type_obj
    .const 'Sub' $P1863 = "94_1303391609.928" 
    $P1862."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1863)
    get_how $P1864, type_obj
    get_global $P1865, "!PREFIX__statement_mod_cond:sym<if>"
    $P1864."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1865)
    get_how $P1866, type_obj
    .const 'Sub' $P1867 = "96_1303391609.928" 
    $P1866."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1867)
    get_how $P1868, type_obj
    get_global $P1869, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1868."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1869)
    get_how $P1870, type_obj
    .const 'Sub' $P1871 = "98_1303391609.928" 
    $P1870."add_method"(type_obj, "statement_mod_loop", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "99_1303391609.928" 
    $P1872."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1873)
    get_how $P1874, type_obj
    .const 'Sub' $P1875 = "100_1303391609.928" 
    $P1874."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1875)
    get_how $P1876, type_obj
    get_global $P1877, "!PREFIX__statement_mod_loop:sym<while>"
    $P1876."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1877)
    get_how $P1878, type_obj
    .const 'Sub' $P1879 = "102_1303391609.928" 
    $P1878."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1879)
    get_how $P1880, type_obj
    get_global $P1881, "!PREFIX__statement_mod_loop:sym<until>"
    $P1880."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1881)
    get_how $P1882, type_obj
    .const 'Sub' $P1883 = "104_1303391609.928" 
    $P1882."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1883)
    get_how $P1884, type_obj
    get_global $P1885, "!PREFIX__statement_mod_loop:sym<for>"
    $P1884."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1885)
    get_how $P1886, type_obj
    .const 'Sub' $P1887 = "106_1303391609.928" 
    $P1886."add_method"(type_obj, "term:sym<fatarrow>", $P1887)
    get_how $P1888, type_obj
    get_global $P1889, "!PREFIX__term:sym<fatarrow>"
    $P1888."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1889)
    get_how $P1890, type_obj
    .const 'Sub' $P1891 = "108_1303391609.928" 
    $P1890."add_method"(type_obj, "term:sym<colonpair>", $P1891)
    get_how $P1892, type_obj
    get_global $P1893, "!PREFIX__term:sym<colonpair>"
    $P1892."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1893)
    get_how $P1894, type_obj
    .const 'Sub' $P1895 = "110_1303391609.928" 
    $P1894."add_method"(type_obj, "term:sym<variable>", $P1895)
    get_how $P1896, type_obj
    get_global $P1897, "!PREFIX__term:sym<variable>"
    $P1896."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1897)
    get_how $P1898, type_obj
    .const 'Sub' $P1899 = "112_1303391609.928" 
    $P1898."add_method"(type_obj, "term:sym<package_declarator>", $P1899)
    get_how $P1900, type_obj
    get_global $P1901, "!PREFIX__term:sym<package_declarator>"
    $P1900."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1901)
    get_how $P1902, type_obj
    .const 'Sub' $P1903 = "114_1303391609.928" 
    $P1902."add_method"(type_obj, "term:sym<scope_declarator>", $P1903)
    get_how $P1904, type_obj
    get_global $P1905, "!PREFIX__term:sym<scope_declarator>"
    $P1904."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1905)
    get_how $P1906, type_obj
    .const 'Sub' $P1907 = "116_1303391609.928" 
    $P1906."add_method"(type_obj, "term:sym<routine_declarator>", $P1907)
    get_how $P1908, type_obj
    get_global $P1909, "!PREFIX__term:sym<routine_declarator>"
    $P1908."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1909)
    get_how $P1910, type_obj
    .const 'Sub' $P1911 = "118_1303391609.928" 
    $P1910."add_method"(type_obj, "term:sym<multi_declarator>", $P1911)
    get_how $P1912, type_obj
    get_global $P1913, "!PREFIX__term:sym<multi_declarator>"
    $P1912."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1913)
    get_how $P1914, type_obj
    .const 'Sub' $P1915 = "122_1303391609.928" 
    $P1914."add_method"(type_obj, "term:sym<regex_declarator>", $P1915)
    get_how $P1916, type_obj
    get_global $P1917, "!PREFIX__term:sym<regex_declarator>"
    $P1916."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1917)
    get_how $P1918, type_obj
    .const 'Sub' $P1919 = "124_1303391609.928" 
    $P1918."add_method"(type_obj, "term:sym<statement_prefix>", $P1919)
    get_how $P1920, type_obj
    get_global $P1921, "!PREFIX__term:sym<statement_prefix>"
    $P1920."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1921)
    get_how $P1922, type_obj
    .const 'Sub' $P1923 = "126_1303391609.928" 
    $P1922."add_method"(type_obj, "term:sym<lambda>", $P1923)
    get_how $P1924, type_obj
    get_global $P1925, "!PREFIX__term:sym<lambda>"
    $P1924."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1925)
    get_how $P1926, type_obj
    .const 'Sub' $P1927 = "128_1303391609.928" 
    $P1926."add_method"(type_obj, "fatarrow", $P1927)
    get_how $P1928, type_obj
    get_global $P1929, "!PREFIX__fatarrow"
    $P1928."add_method"(type_obj, "!PREFIX__fatarrow", $P1929)
    get_how $P1930, type_obj
    .const 'Sub' $P1931 = "130_1303391609.928" 
    $P1930."add_method"(type_obj, "colonpair", $P1931)
    get_how $P1932, type_obj
    get_global $P1933, "!PREFIX__colonpair"
    $P1932."add_method"(type_obj, "!PREFIX__colonpair", $P1933)
    get_how $P1934, type_obj
    .const 'Sub' $P1935 = "132_1303391609.928" 
    $P1934."add_method"(type_obj, "variable", $P1935)
    get_how $P1936, type_obj
    get_global $P1937, "!PREFIX__variable"
    $P1936."add_method"(type_obj, "!PREFIX__variable", $P1937)
    get_how $P1938, type_obj
    .const 'Sub' $P1939 = "134_1303391609.928" 
    $P1938."add_method"(type_obj, "sigil", $P1939)
    get_how $P1940, type_obj
    get_global $P1941, "!PREFIX__sigil"
    $P1940."add_method"(type_obj, "!PREFIX__sigil", $P1941)
    get_how $P1942, type_obj
    .const 'Sub' $P1943 = "136_1303391609.928" 
    $P1942."add_method"(type_obj, "twigil", $P1943)
    get_how $P1944, type_obj
    get_global $P1945, "!PREFIX__twigil"
    $P1944."add_method"(type_obj, "!PREFIX__twigil", $P1945)
    get_how $P1946, type_obj
    .const 'Sub' $P1947 = "138_1303391609.928" 
    $P1946."add_method"(type_obj, "package_declarator", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "139_1303391609.928" 
    $P1948."add_method"(type_obj, "!PREFIX__package_declarator", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "140_1303391609.928" 
    $P1950."add_method"(type_obj, "package_declarator:sym<module>", $P1951)
    get_how $P1952, type_obj
    get_global $P1953, "!PREFIX__package_declarator:sym<module>"
    $P1952."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1953)
    get_how $P1954, type_obj
    .const 'Sub' $P1955 = "142_1303391609.928" 
    $P1954."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1955)
    get_how $P1956, type_obj
    get_global $P1957, "!PREFIX__package_declarator:sym<knowhow>"
    $P1956."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1957)
    get_how $P1958, type_obj
    .const 'Sub' $P1959 = "144_1303391609.928" 
    $P1958."add_method"(type_obj, "package_declarator:sym<class>", $P1959)
    get_how $P1960, type_obj
    get_global $P1961, "!PREFIX__package_declarator:sym<class>"
    $P1960."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1961)
    get_how $P1962, type_obj
    .const 'Sub' $P1963 = "146_1303391609.928" 
    $P1962."add_method"(type_obj, "package_declarator:sym<grammar>", $P1963)
    get_how $P1964, type_obj
    get_global $P1965, "!PREFIX__package_declarator:sym<grammar>"
    $P1964."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1965)
    get_how $P1966, type_obj
    .const 'Sub' $P1967 = "148_1303391609.928" 
    $P1966."add_method"(type_obj, "package_declarator:sym<role>", $P1967)
    get_how $P1968, type_obj
    get_global $P1969, "!PREFIX__package_declarator:sym<role>"
    $P1968."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1969)
    get_how $P1970, type_obj
    .const 'Sub' $P1971 = "150_1303391609.928" 
    $P1970."add_method"(type_obj, "package_declarator:sym<native>", $P1971)
    get_how $P1972, type_obj
    get_global $P1973, "!PREFIX__package_declarator:sym<native>"
    $P1972."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1973)
    get_how $P1974, type_obj
    .const 'Sub' $P1975 = "152_1303391609.928" 
    $P1974."add_method"(type_obj, "package_def", $P1975)
    get_how $P1976, type_obj
    get_global $P1977, "!PREFIX__package_def"
    $P1976."add_method"(type_obj, "!PREFIX__package_def", $P1977)
    get_how $P1978, type_obj
    .const 'Sub' $P1979 = "155_1303391609.928" 
    $P1978."add_method"(type_obj, "scope_declarator", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "156_1303391609.928" 
    $P1980."add_method"(type_obj, "!PREFIX__scope_declarator", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "157_1303391609.928" 
    $P1982."add_method"(type_obj, "scope_declarator:sym<my>", $P1983)
    get_how $P1984, type_obj
    get_global $P1985, "!PREFIX__scope_declarator:sym<my>"
    $P1984."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1985)
    get_how $P1986, type_obj
    .const 'Sub' $P1987 = "159_1303391609.928" 
    $P1986."add_method"(type_obj, "scope_declarator:sym<our>", $P1987)
    get_how $P1988, type_obj
    get_global $P1989, "!PREFIX__scope_declarator:sym<our>"
    $P1988."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1989)
    get_how $P1990, type_obj
    .const 'Sub' $P1991 = "161_1303391609.928" 
    $P1990."add_method"(type_obj, "scope_declarator:sym<has>", $P1991)
    get_how $P1992, type_obj
    get_global $P1993, "!PREFIX__scope_declarator:sym<has>"
    $P1992."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1993)
    get_how $P1994, type_obj
    .const 'Sub' $P1995 = "163_1303391609.928" 
    $P1994."add_method"(type_obj, "scoped", $P1995)
    get_how $P1996, type_obj
    get_global $P1997, "!PREFIX__scoped"
    $P1996."add_method"(type_obj, "!PREFIX__scoped", $P1997)
    get_how $P1998, type_obj
    .const 'Sub' $P1999 = "165_1303391609.928" 
    $P1998."add_method"(type_obj, "typename", $P1999)
    get_how $P2000, type_obj
    get_global $P2001, "!PREFIX__typename"
    $P2000."add_method"(type_obj, "!PREFIX__typename", $P2001)
    get_how $P2002, type_obj
    .const 'Sub' $P2003 = "167_1303391609.928" 
    $P2002."add_method"(type_obj, "declarator", $P2003)
    get_how $P2004, type_obj
    get_global $P2005, "!PREFIX__declarator"
    $P2004."add_method"(type_obj, "!PREFIX__declarator", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "169_1303391609.928" 
    $P2006."add_method"(type_obj, "variable_declarator", $P2007)
    get_how $P2008, type_obj
    get_global $P2009, "!PREFIX__variable_declarator"
    $P2008."add_method"(type_obj, "!PREFIX__variable_declarator", $P2009)
    get_how $P2010, type_obj
    .const 'Sub' $P2011 = "171_1303391609.928" 
    $P2010."add_method"(type_obj, "routine_declarator", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "172_1303391609.928" 
    $P2012."add_method"(type_obj, "!PREFIX__routine_declarator", $P2013)
    get_how $P2014, type_obj
    .const 'Sub' $P2015 = "173_1303391609.928" 
    $P2014."add_method"(type_obj, "routine_declarator:sym<sub>", $P2015)
    get_how $P2016, type_obj
    get_global $P2017, "!PREFIX__routine_declarator:sym<sub>"
    $P2016."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2017)
    get_how $P2018, type_obj
    .const 'Sub' $P2019 = "175_1303391609.928" 
    $P2018."add_method"(type_obj, "routine_declarator:sym<method>", $P2019)
    get_how $P2020, type_obj
    get_global $P2021, "!PREFIX__routine_declarator:sym<method>"
    $P2020."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2021)
    get_how $P2022, type_obj
    .const 'Sub' $P2023 = "177_1303391609.928" 
    $P2022."add_method"(type_obj, "routine_def", $P2023)
    get_how $P2024, type_obj
    get_global $P2025, "!PREFIX__routine_def"
    $P2024."add_method"(type_obj, "!PREFIX__routine_def", $P2025)
    get_how $P2026, type_obj
    .const 'Sub' $P2027 = "179_1303391609.928" 
    $P2026."add_method"(type_obj, "method_def", $P2027)
    get_how $P2028, type_obj
    get_global $P2029, "!PREFIX__method_def"
    $P2028."add_method"(type_obj, "!PREFIX__method_def", $P2029)
    get_how $P2030, type_obj
    .const 'Sub' $P2031 = "182_1303391609.928" 
    $P2030."add_method"(type_obj, "onlystar", $P2031)
    get_how $P2032, type_obj
    get_global $P2033, "!PREFIX__onlystar"
    $P2032."add_method"(type_obj, "!PREFIX__onlystar", $P2033)
    get_how $P2034, type_obj
    .const 'Sub' $P2035 = "185_1303391609.928" 
    $P2034."add_method"(type_obj, "multi_declarator", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "186_1303391609.928" 
    $P2036."add_method"(type_obj, "!PREFIX__multi_declarator", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "187_1303391609.928" 
    $P2038."add_method"(type_obj, "multi_declarator:sym<multi>", $P2039)
    get_how $P2040, type_obj
    get_global $P2041, "!PREFIX__multi_declarator:sym<multi>"
    $P2040."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2041)
    get_how $P2042, type_obj
    .const 'Sub' $P2043 = "189_1303391609.928" 
    $P2042."add_method"(type_obj, "multi_declarator:sym<proto>", $P2043)
    get_how $P2044, type_obj
    get_global $P2045, "!PREFIX__multi_declarator:sym<proto>"
    $P2044."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "191_1303391609.928" 
    $P2046."add_method"(type_obj, "multi_declarator:sym<null>", $P2047)
    get_how $P2048, type_obj
    get_global $P2049, "!PREFIX__multi_declarator:sym<null>"
    $P2048."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2049)
    get_how $P2050, type_obj
    .const 'Sub' $P2051 = "193_1303391609.928" 
    $P2050."add_method"(type_obj, "signature", $P2051)
    get_how $P2052, type_obj
    get_global $P2053, "!PREFIX__signature"
    $P2052."add_method"(type_obj, "!PREFIX__signature", $P2053)
    get_how $P2054, type_obj
    .const 'Sub' $P2055 = "196_1303391609.928" 
    $P2054."add_method"(type_obj, "parameter", $P2055)
    get_how $P2056, type_obj
    get_global $P2057, "!PREFIX__parameter"
    $P2056."add_method"(type_obj, "!PREFIX__parameter", $P2057)
    get_how $P2058, type_obj
    .const 'Sub' $P2059 = "198_1303391609.928" 
    $P2058."add_method"(type_obj, "param_var", $P2059)
    get_how $P2060, type_obj
    get_global $P2061, "!PREFIX__param_var"
    $P2060."add_method"(type_obj, "!PREFIX__param_var", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "200_1303391609.928" 
    $P2062."add_method"(type_obj, "named_param", $P2063)
    get_how $P2064, type_obj
    get_global $P2065, "!PREFIX__named_param"
    $P2064."add_method"(type_obj, "!PREFIX__named_param", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "202_1303391609.928" 
    $P2066."add_method"(type_obj, "default_value", $P2067)
    get_how $P2068, type_obj
    get_global $P2069, "!PREFIX__default_value"
    $P2068."add_method"(type_obj, "!PREFIX__default_value", $P2069)
    get_how $P2070, type_obj
    .const 'Sub' $P2071 = "204_1303391609.928" 
    $P2070."add_method"(type_obj, "trait", $P2071)
    get_how $P2072, type_obj
    get_global $P2073, "!PREFIX__trait"
    $P2072."add_method"(type_obj, "!PREFIX__trait", $P2073)
    get_how $P2074, type_obj
    .const 'Sub' $P2075 = "206_1303391609.928" 
    $P2074."add_method"(type_obj, "trait_mod", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "207_1303391609.928" 
    $P2076."add_method"(type_obj, "!PREFIX__trait_mod", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "208_1303391609.928" 
    $P2078."add_method"(type_obj, "trait_mod:sym<is>", $P2079)
    get_how $P2080, type_obj
    get_global $P2081, "!PREFIX__trait_mod:sym<is>"
    $P2080."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2081)
    get_how $P2082, type_obj
    .const 'Sub' $P2083 = "210_1303391609.928" 
    $P2082."add_method"(type_obj, "regex_declarator", $P2083)
    get_how $P2084, type_obj
    get_global $P2085, "!PREFIX__regex_declarator"
    $P2084."add_method"(type_obj, "!PREFIX__regex_declarator", $P2085)
    get_how $P2086, type_obj
    .const 'Sub' $P2087 = "212_1303391609.928" 
    $P2086."add_method"(type_obj, "dotty", $P2087)
    get_how $P2088, type_obj
    get_global $P2089, "!PREFIX__dotty"
    $P2088."add_method"(type_obj, "!PREFIX__dotty", $P2089)
    get_how $P2090, type_obj
    .const 'Sub' $P2091 = "214_1303391609.928" 
    $P2090."add_method"(type_obj, "term", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "215_1303391609.928" 
    $P2092."add_method"(type_obj, "!PREFIX__term", $P2093)
    get_how $P2094, type_obj
    .const 'Sub' $P2095 = "216_1303391609.928" 
    $P2094."add_method"(type_obj, "term:sym<self>", $P2095)
    get_how $P2096, type_obj
    get_global $P2097, "!PREFIX__term:sym<self>"
    $P2096."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2097)
    get_how $P2098, type_obj
    .const 'Sub' $P2099 = "218_1303391609.928" 
    $P2098."add_method"(type_obj, "term:sym<identifier>", $P2099)
    get_how $P2100, type_obj
    get_global $P2101, "!PREFIX__term:sym<identifier>"
    $P2100."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2101)
    get_how $P2102, type_obj
    .const 'Sub' $P2103 = "220_1303391609.928" 
    $P2102."add_method"(type_obj, "term:sym<name>", $P2103)
    get_how $P2104, type_obj
    get_global $P2105, "!PREFIX__term:sym<name>"
    $P2104."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2105)
    get_how $P2106, type_obj
    .const 'Sub' $P2107 = "222_1303391609.928" 
    $P2106."add_method"(type_obj, "term:sym<pir::op>", $P2107)
    get_how $P2108, type_obj
    get_global $P2109, "!PREFIX__term:sym<pir::op>"
    $P2108."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2109)
    get_how $P2110, type_obj
    .const 'Sub' $P2111 = "224_1303391609.928" 
    $P2110."add_method"(type_obj, "term:sym<onlystar>", $P2111)
    get_how $P2112, type_obj
    get_global $P2113, "!PREFIX__term:sym<onlystar>"
    $P2112."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2113)
    get_how $P2114, type_obj
    .const 'Sub' $P2115 = "227_1303391609.928" 
    $P2114."add_method"(type_obj, "args", $P2115)
    get_how $P2116, type_obj
    get_global $P2117, "!PREFIX__args"
    $P2116."add_method"(type_obj, "!PREFIX__args", $P2117)
    get_how $P2118, type_obj
    .const 'Sub' $P2119 = "229_1303391609.928" 
    $P2118."add_method"(type_obj, "arglist", $P2119)
    get_how $P2120, type_obj
    get_global $P2121, "!PREFIX__arglist"
    $P2120."add_method"(type_obj, "!PREFIX__arglist", $P2121)
    get_how $P2122, type_obj
    .const 'Sub' $P2123 = "231_1303391609.928" 
    $P2122."add_method"(type_obj, "term:sym<value>", $P2123)
    get_how $P2124, type_obj
    get_global $P2125, "!PREFIX__term:sym<value>"
    $P2124."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2125)
    get_how $P2126, type_obj
    .const 'Sub' $P2127 = "233_1303391609.928" 
    $P2126."add_method"(type_obj, "value", $P2127)
    get_how $P2128, type_obj
    get_global $P2129, "!PREFIX__value"
    $P2128."add_method"(type_obj, "!PREFIX__value", $P2129)
    get_how $P2130, type_obj
    .const 'Sub' $P2131 = "235_1303391609.928" 
    $P2130."add_method"(type_obj, "number", $P2131)
    get_how $P2132, type_obj
    get_global $P2133, "!PREFIX__number"
    $P2132."add_method"(type_obj, "!PREFIX__number", $P2133)
    get_how $P2134, type_obj
    .const 'Sub' $P2135 = "237_1303391609.928" 
    $P2134."add_method"(type_obj, "quote", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "238_1303391609.928" 
    $P2136."add_method"(type_obj, "!PREFIX__quote", $P2137)
    get_how $P2138, type_obj
    .const 'Sub' $P2139 = "239_1303391609.928" 
    $P2138."add_method"(type_obj, "quote:sym<apos>", $P2139)
    get_how $P2140, type_obj
    get_global $P2141, "!PREFIX__quote:sym<apos>"
    $P2140."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2141)
    get_how $P2142, type_obj
    .const 'Sub' $P2143 = "241_1303391609.928" 
    $P2142."add_method"(type_obj, "quote:sym<dblq>", $P2143)
    get_how $P2144, type_obj
    get_global $P2145, "!PREFIX__quote:sym<dblq>"
    $P2144."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2145)
    get_how $P2146, type_obj
    .const 'Sub' $P2147 = "243_1303391609.928" 
    $P2146."add_method"(type_obj, "quote:sym<q>", $P2147)
    get_how $P2148, type_obj
    get_global $P2149, "!PREFIX__quote:sym<q>"
    $P2148."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2149)
    get_how $P2150, type_obj
    .const 'Sub' $P2151 = "245_1303391609.928" 
    $P2150."add_method"(type_obj, "quote:sym<qq>", $P2151)
    get_how $P2152, type_obj
    get_global $P2153, "!PREFIX__quote:sym<qq>"
    $P2152."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2153)
    get_how $P2154, type_obj
    .const 'Sub' $P2155 = "247_1303391609.928" 
    $P2154."add_method"(type_obj, "quote:sym<Q>", $P2155)
    get_how $P2156, type_obj
    get_global $P2157, "!PREFIX__quote:sym<Q>"
    $P2156."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2157)
    get_how $P2158, type_obj
    .const 'Sub' $P2159 = "249_1303391609.928" 
    $P2158."add_method"(type_obj, "quote:sym<Q:PIR>", $P2159)
    get_how $P2160, type_obj
    get_global $P2161, "!PREFIX__quote:sym<Q:PIR>"
    $P2160."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2161)
    get_how $P2162, type_obj
    .const 'Sub' $P2163 = "251_1303391609.928" 
    $P2162."add_method"(type_obj, "quote:sym</ />", $P2163)
    get_how $P2164, type_obj
    get_global $P2165, "!PREFIX__quote:sym</ />"
    $P2164."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2165)
    get_how $P2166, type_obj
    .const 'Sub' $P2167 = "253_1303391609.928" 
    $P2166."add_method"(type_obj, "quote_escape:sym<$>", $P2167)
    get_how $P2168, type_obj
    get_global $P2169, "!PREFIX__quote_escape:sym<$>"
    $P2168."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2169)
    get_how $P2170, type_obj
    .const 'Sub' $P2171 = "255_1303391609.928" 
    $P2170."add_method"(type_obj, "quote_escape:sym<{ }>", $P2171)
    get_how $P2172, type_obj
    get_global $P2173, "!PREFIX__quote_escape:sym<{ }>"
    $P2172."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2173)
    get_how $P2174, type_obj
    .const 'Sub' $P2175 = "257_1303391609.928" 
    $P2174."add_method"(type_obj, "quote_escape:sym<esc>", $P2175)
    get_how $P2176, type_obj
    get_global $P2177, "!PREFIX__quote_escape:sym<esc>"
    $P2176."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2177)
    get_how $P2178, type_obj
    .const 'Sub' $P2179 = "259_1303391609.928" 
    $P2178."add_method"(type_obj, "circumfix:sym<( )>", $P2179)
    get_how $P2180, type_obj
    get_global $P2181, "!PREFIX__circumfix:sym<( )>"
    $P2180."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2181)
    get_how $P2182, type_obj
    .const 'Sub' $P2183 = "261_1303391609.928" 
    $P2182."add_method"(type_obj, "circumfix:sym<[ ]>", $P2183)
    get_how $P2184, type_obj
    get_global $P2185, "!PREFIX__circumfix:sym<[ ]>"
    $P2184."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2185)
    get_how $P2186, type_obj
    .const 'Sub' $P2187 = "263_1303391609.928" 
    $P2186."add_method"(type_obj, "circumfix:sym<ang>", $P2187)
    get_how $P2188, type_obj
    get_global $P2189, "!PREFIX__circumfix:sym<ang>"
    $P2188."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2189)
    get_how $P2190, type_obj
    .const 'Sub' $P2191 = "265_1303391609.928" 
    $P2190."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2191)
    get_how $P2192, type_obj
    get_global $P2193, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2192."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2193)
    get_how $P2194, type_obj
    .const 'Sub' $P2195 = "267_1303391609.928" 
    $P2194."add_method"(type_obj, "circumfix:sym<{ }>", $P2195)
    get_how $P2196, type_obj
    get_global $P2197, "!PREFIX__circumfix:sym<{ }>"
    $P2196."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2197)
    get_how $P2198, type_obj
    .const 'Sub' $P2199 = "269_1303391609.928" 
    $P2198."add_method"(type_obj, "circumfix:sym<sigil>", $P2199)
    get_how $P2200, type_obj
    get_global $P2201, "!PREFIX__circumfix:sym<sigil>"
    $P2200."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2201)
    get_how $P2202, type_obj
    .const 'Sub' $P2203 = "271_1303391609.928" 
    $P2202."add_method"(type_obj, "semilist", $P2203)
    get_how $P2204, type_obj
    get_global $P2205, "!PREFIX__semilist"
    $P2204."add_method"(type_obj, "!PREFIX__semilist", $P2205)
    get_how $P2206, type_obj
    .const 'Sub' $P2207 = "273_1303391609.928" 
    $P2206."add_method"(type_obj, "infixish", $P2207)
    get_how $P2208, type_obj
    get_global $P2209, "!PREFIX__infixish"
    $P2208."add_method"(type_obj, "!PREFIX__infixish", $P2209)
    get_how $P2210, type_obj
    .const 'Sub' $P2211 = "275_1303391609.928" 
    $P2210."add_method"(type_obj, "infixstopper", $P2211)
    get_how $P2212, type_obj
    get_global $P2213, "!PREFIX__infixstopper"
    $P2212."add_method"(type_obj, "!PREFIX__infixstopper", $P2213)
    get_how $P2214, type_obj
    .const 'Sub' $P2215 = "277_1303391609.928" 
    $P2214."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2215)
    get_how $P2216, type_obj
    get_global $P2217, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2216."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2217)
    get_how $P2218, type_obj
    .const 'Sub' $P2219 = "279_1303391609.928" 
    $P2218."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2219)
    get_how $P2220, type_obj
    get_global $P2221, "!PREFIX__postcircumfix:sym<{ }>"
    $P2220."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2221)
    get_how $P2222, type_obj
    .const 'Sub' $P2223 = "281_1303391609.928" 
    $P2222."add_method"(type_obj, "postcircumfix:sym<ang>", $P2223)
    get_how $P2224, type_obj
    get_global $P2225, "!PREFIX__postcircumfix:sym<ang>"
    $P2224."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2225)
    get_how $P2226, type_obj
    .const 'Sub' $P2227 = "283_1303391609.928" 
    $P2226."add_method"(type_obj, "postcircumfix:sym<( )>", $P2227)
    get_how $P2228, type_obj
    get_global $P2229, "!PREFIX__postcircumfix:sym<( )>"
    $P2228."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2229)
    get_how $P2230, type_obj
    .const 'Sub' $P2231 = "285_1303391609.928" 
    $P2230."add_method"(type_obj, "postfix:sym<.>", $P2231)
    get_how $P2232, type_obj
    get_global $P2233, "!PREFIX__postfix:sym<.>"
    $P2232."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2233)
    get_how $P2234, type_obj
    .const 'Sub' $P2235 = "287_1303391609.928" 
    $P2234."add_method"(type_obj, "prefix:sym<++>", $P2235)
    get_how $P2236, type_obj
    get_global $P2237, "!PREFIX__prefix:sym<++>"
    $P2236."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2237)
    get_how $P2238, type_obj
    .const 'Sub' $P2239 = "289_1303391609.928" 
    $P2238."add_method"(type_obj, "prefix:sym<-->", $P2239)
    get_how $P2240, type_obj
    get_global $P2241, "!PREFIX__prefix:sym<-->"
    $P2240."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2241)
    get_how $P2242, type_obj
    .const 'Sub' $P2243 = "291_1303391609.928" 
    $P2242."add_method"(type_obj, "postfix:sym<++>", $P2243)
    get_how $P2244, type_obj
    get_global $P2245, "!PREFIX__postfix:sym<++>"
    $P2244."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2245)
    get_how $P2246, type_obj
    .const 'Sub' $P2247 = "293_1303391609.928" 
    $P2246."add_method"(type_obj, "postfix:sym<-->", $P2247)
    get_how $P2248, type_obj
    get_global $P2249, "!PREFIX__postfix:sym<-->"
    $P2248."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2249)
    get_how $P2250, type_obj
    .const 'Sub' $P2251 = "295_1303391609.928" 
    $P2250."add_method"(type_obj, "infix:sym<**>", $P2251)
    get_how $P2252, type_obj
    get_global $P2253, "!PREFIX__infix:sym<**>"
    $P2252."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2253)
    get_how $P2254, type_obj
    .const 'Sub' $P2255 = "297_1303391609.928" 
    $P2254."add_method"(type_obj, "prefix:sym<+>", $P2255)
    get_how $P2256, type_obj
    get_global $P2257, "!PREFIX__prefix:sym<+>"
    $P2256."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2257)
    get_how $P2258, type_obj
    .const 'Sub' $P2259 = "299_1303391609.928" 
    $P2258."add_method"(type_obj, "prefix:sym<~>", $P2259)
    get_how $P2260, type_obj
    get_global $P2261, "!PREFIX__prefix:sym<~>"
    $P2260."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2261)
    get_how $P2262, type_obj
    .const 'Sub' $P2263 = "301_1303391609.928" 
    $P2262."add_method"(type_obj, "prefix:sym<->", $P2263)
    get_how $P2264, type_obj
    get_global $P2265, "!PREFIX__prefix:sym<->"
    $P2264."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2265)
    get_how $P2266, type_obj
    .const 'Sub' $P2267 = "303_1303391609.928" 
    $P2266."add_method"(type_obj, "prefix:sym<?>", $P2267)
    get_how $P2268, type_obj
    get_global $P2269, "!PREFIX__prefix:sym<?>"
    $P2268."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2269)
    get_how $P2270, type_obj
    .const 'Sub' $P2271 = "305_1303391609.928" 
    $P2270."add_method"(type_obj, "prefix:sym<!>", $P2271)
    get_how $P2272, type_obj
    get_global $P2273, "!PREFIX__prefix:sym<!>"
    $P2272."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2273)
    get_how $P2274, type_obj
    .const 'Sub' $P2275 = "307_1303391609.928" 
    $P2274."add_method"(type_obj, "prefix:sym<|>", $P2275)
    get_how $P2276, type_obj
    get_global $P2277, "!PREFIX__prefix:sym<|>"
    $P2276."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2277)
    get_how $P2278, type_obj
    .const 'Sub' $P2279 = "309_1303391609.928" 
    $P2278."add_method"(type_obj, "infix:sym<*>", $P2279)
    get_how $P2280, type_obj
    get_global $P2281, "!PREFIX__infix:sym<*>"
    $P2280."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2281)
    get_how $P2282, type_obj
    .const 'Sub' $P2283 = "311_1303391609.928" 
    $P2282."add_method"(type_obj, "infix:sym</>", $P2283)
    get_how $P2284, type_obj
    get_global $P2285, "!PREFIX__infix:sym</>"
    $P2284."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2285)
    get_how $P2286, type_obj
    .const 'Sub' $P2287 = "313_1303391609.928" 
    $P2286."add_method"(type_obj, "infix:sym<%>", $P2287)
    get_how $P2288, type_obj
    get_global $P2289, "!PREFIX__infix:sym<%>"
    $P2288."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2289)
    get_how $P2290, type_obj
    .const 'Sub' $P2291 = "315_1303391609.928" 
    $P2290."add_method"(type_obj, "infix:sym<+&>", $P2291)
    get_how $P2292, type_obj
    get_global $P2293, "!PREFIX__infix:sym<+&>"
    $P2292."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2293)
    get_how $P2294, type_obj
    .const 'Sub' $P2295 = "317_1303391609.928" 
    $P2294."add_method"(type_obj, "infix:sym<+>", $P2295)
    get_how $P2296, type_obj
    get_global $P2297, "!PREFIX__infix:sym<+>"
    $P2296."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2297)
    get_how $P2298, type_obj
    .const 'Sub' $P2299 = "319_1303391609.928" 
    $P2298."add_method"(type_obj, "infix:sym<->", $P2299)
    get_how $P2300, type_obj
    get_global $P2301, "!PREFIX__infix:sym<->"
    $P2300."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2301)
    get_how $P2302, type_obj
    .const 'Sub' $P2303 = "321_1303391609.928" 
    $P2302."add_method"(type_obj, "infix:sym<+|>", $P2303)
    get_how $P2304, type_obj
    get_global $P2305, "!PREFIX__infix:sym<+|>"
    $P2304."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2305)
    get_how $P2306, type_obj
    .const 'Sub' $P2307 = "323_1303391609.928" 
    $P2306."add_method"(type_obj, "infix:sym<+^>", $P2307)
    get_how $P2308, type_obj
    get_global $P2309, "!PREFIX__infix:sym<+^>"
    $P2308."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2309)
    get_how $P2310, type_obj
    .const 'Sub' $P2311 = "325_1303391609.928" 
    $P2310."add_method"(type_obj, "infix:sym<~>", $P2311)
    get_how $P2312, type_obj
    get_global $P2313, "!PREFIX__infix:sym<~>"
    $P2312."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2313)
    get_how $P2314, type_obj
    .const 'Sub' $P2315 = "327_1303391609.928" 
    $P2314."add_method"(type_obj, "infix:sym<==>", $P2315)
    get_how $P2316, type_obj
    get_global $P2317, "!PREFIX__infix:sym<==>"
    $P2316."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2317)
    get_how $P2318, type_obj
    .const 'Sub' $P2319 = "329_1303391609.928" 
    $P2318."add_method"(type_obj, "infix:sym<!=>", $P2319)
    get_how $P2320, type_obj
    get_global $P2321, "!PREFIX__infix:sym<!=>"
    $P2320."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2321)
    get_how $P2322, type_obj
    .const 'Sub' $P2323 = "331_1303391609.928" 
    $P2322."add_method"(type_obj, "infix:sym<<=>", $P2323)
    get_how $P2324, type_obj
    get_global $P2325, "!PREFIX__infix:sym<<=>"
    $P2324."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2325)
    get_how $P2326, type_obj
    .const 'Sub' $P2327 = "333_1303391609.928" 
    $P2326."add_method"(type_obj, "infix:sym<>=>", $P2327)
    get_how $P2328, type_obj
    get_global $P2329, "!PREFIX__infix:sym<>=>"
    $P2328."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2329)
    get_how $P2330, type_obj
    .const 'Sub' $P2331 = "335_1303391609.928" 
    $P2330."add_method"(type_obj, "infix:sym<<>", $P2331)
    get_how $P2332, type_obj
    get_global $P2333, "!PREFIX__infix:sym<<>"
    $P2332."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2333)
    get_how $P2334, type_obj
    .const 'Sub' $P2335 = "337_1303391609.928" 
    $P2334."add_method"(type_obj, "infix:sym<>>", $P2335)
    get_how $P2336, type_obj
    get_global $P2337, "!PREFIX__infix:sym<>>"
    $P2336."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2337)
    get_how $P2338, type_obj
    .const 'Sub' $P2339 = "339_1303391609.928" 
    $P2338."add_method"(type_obj, "infix:sym<eq>", $P2339)
    get_how $P2340, type_obj
    get_global $P2341, "!PREFIX__infix:sym<eq>"
    $P2340."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2341)
    get_how $P2342, type_obj
    .const 'Sub' $P2343 = "341_1303391609.928" 
    $P2342."add_method"(type_obj, "infix:sym<ne>", $P2343)
    get_how $P2344, type_obj
    get_global $P2345, "!PREFIX__infix:sym<ne>"
    $P2344."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2345)
    get_how $P2346, type_obj
    .const 'Sub' $P2347 = "343_1303391609.928" 
    $P2346."add_method"(type_obj, "infix:sym<le>", $P2347)
    get_how $P2348, type_obj
    get_global $P2349, "!PREFIX__infix:sym<le>"
    $P2348."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2349)
    get_how $P2350, type_obj
    .const 'Sub' $P2351 = "345_1303391609.928" 
    $P2350."add_method"(type_obj, "infix:sym<ge>", $P2351)
    get_how $P2352, type_obj
    get_global $P2353, "!PREFIX__infix:sym<ge>"
    $P2352."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2353)
    get_how $P2354, type_obj
    .const 'Sub' $P2355 = "347_1303391609.928" 
    $P2354."add_method"(type_obj, "infix:sym<lt>", $P2355)
    get_how $P2356, type_obj
    get_global $P2357, "!PREFIX__infix:sym<lt>"
    $P2356."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2357)
    get_how $P2358, type_obj
    .const 'Sub' $P2359 = "349_1303391609.928" 
    $P2358."add_method"(type_obj, "infix:sym<gt>", $P2359)
    get_how $P2360, type_obj
    get_global $P2361, "!PREFIX__infix:sym<gt>"
    $P2360."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2361)
    get_how $P2362, type_obj
    .const 'Sub' $P2363 = "351_1303391609.928" 
    $P2362."add_method"(type_obj, "infix:sym<=:=>", $P2363)
    get_how $P2364, type_obj
    get_global $P2365, "!PREFIX__infix:sym<=:=>"
    $P2364."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2365)
    get_how $P2366, type_obj
    .const 'Sub' $P2367 = "353_1303391609.928" 
    $P2366."add_method"(type_obj, "infix:sym<~~>", $P2367)
    get_how $P2368, type_obj
    get_global $P2369, "!PREFIX__infix:sym<~~>"
    $P2368."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2369)
    get_how $P2370, type_obj
    .const 'Sub' $P2371 = "355_1303391609.928" 
    $P2370."add_method"(type_obj, "infix:sym<&&>", $P2371)
    get_how $P2372, type_obj
    get_global $P2373, "!PREFIX__infix:sym<&&>"
    $P2372."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2373)
    get_how $P2374, type_obj
    .const 'Sub' $P2375 = "357_1303391609.928" 
    $P2374."add_method"(type_obj, "infix:sym<||>", $P2375)
    get_how $P2376, type_obj
    get_global $P2377, "!PREFIX__infix:sym<||>"
    $P2376."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2377)
    get_how $P2378, type_obj
    .const 'Sub' $P2379 = "359_1303391609.928" 
    $P2378."add_method"(type_obj, "infix:sym<//>", $P2379)
    get_how $P2380, type_obj
    get_global $P2381, "!PREFIX__infix:sym<//>"
    $P2380."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2381)
    get_how $P2382, type_obj
    .const 'Sub' $P2383 = "361_1303391609.928" 
    $P2382."add_method"(type_obj, "infix:sym<?? !!>", $P2383)
    get_how $P2384, type_obj
    get_global $P2385, "!PREFIX__infix:sym<?? !!>"
    $P2384."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2385)
    get_how $P2386, type_obj
    .const 'Sub' $P2387 = "363_1303391609.928" 
    $P2386."add_method"(type_obj, "infix:sym<=>", $P2387)
    get_how $P2388, type_obj
    get_global $P2389, "!PREFIX__infix:sym<=>"
    $P2388."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2389)
    get_how $P2390, type_obj
    .const 'Sub' $P2391 = "365_1303391609.928" 
    $P2390."add_method"(type_obj, "infix:sym<:=>", $P2391)
    get_how $P2392, type_obj
    get_global $P2393, "!PREFIX__infix:sym<:=>"
    $P2392."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2393)
    get_how $P2394, type_obj
    .const 'Sub' $P2395 = "367_1303391609.928" 
    $P2394."add_method"(type_obj, "infix:sym<::=>", $P2395)
    get_how $P2396, type_obj
    get_global $P2397, "!PREFIX__infix:sym<::=>"
    $P2396."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2397)
    get_how $P2398, type_obj
    .const 'Sub' $P2399 = "369_1303391609.928" 
    $P2398."add_method"(type_obj, "infix:sym<,>", $P2399)
    get_how $P2400, type_obj
    get_global $P2401, "!PREFIX__infix:sym<,>"
    $P2400."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2401)
    get_how $P2402, type_obj
    .const 'Sub' $P2403 = "371_1303391609.928" 
    $P2402."add_method"(type_obj, "prefix:sym<return>", $P2403)
    get_how $P2404, type_obj
    get_global $P2405, "!PREFIX__prefix:sym<return>"
    $P2404."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2405)
    get_how $P2406, type_obj
    .const 'Sub' $P2407 = "374_1303391609.928" 
    $P2406."add_method"(type_obj, "prefix:sym<make>", $P2407)
    get_how $P2408, type_obj
    get_global $P2409, "!PREFIX__prefix:sym<make>"
    $P2408."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2409)
    get_how $P2410, type_obj
    .const 'Sub' $P2411 = "376_1303391609.928" 
    $P2410."add_method"(type_obj, "term:sym<last>", $P2411)
    get_how $P2412, type_obj
    get_global $P2413, "!PREFIX__term:sym<last>"
    $P2412."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2413)
    get_how $P2414, type_obj
    .const 'Sub' $P2415 = "378_1303391609.928" 
    $P2414."add_method"(type_obj, "term:sym<next>", $P2415)
    get_how $P2416, type_obj
    get_global $P2417, "!PREFIX__term:sym<next>"
    $P2416."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2417)
    get_how $P2418, type_obj
    .const 'Sub' $P2419 = "380_1303391609.928" 
    $P2418."add_method"(type_obj, "term:sym<redo>", $P2419)
    get_how $P2420, type_obj
    get_global $P2421, "!PREFIX__term:sym<redo>"
    $P2420."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2421)
    get_how $P2422, type_obj
    .const 'Sub' $P2423 = "382_1303391609.928" 
    $P2422."add_method"(type_obj, "smartmatch", $P2423)
    get_how $P2424, type_obj
    get_hll_global $P2425, ["HLL"], "Grammar"
    $P2424."add_parent"(type_obj, $P2425)
    get_how $P2426, type_obj
    $P2427 = $P2426."compose"(type_obj)
    .return ($P2427)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1303391609.928") :outer("12_1303391609.928")
    .param pmc param_55
.annotate 'line', 10
    .lex "self", param_55
.annotate 'line', 12
    $P56 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P56
.annotate 'line', 19
    $P57 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P57
.annotate 'line', 28
    new $P58, "Undef"
    .lex "$*DEFAULT-METAATTR", $P58
.annotate 'line', 29
    $P59 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P59
.annotate 'line', 35
    new $P60, "Undef"
    .lex "$*SC", $P60
.annotate 'line', 39
    new $P61, "Undef"
    .lex "$*SCOPE", $P61
.annotate 'line', 40
    new $P62, "Undef"
    .lex "$*MULTINESS", $P62
.annotate 'line', 41
    new $P63, "Undef"
    .lex "$*INVOCANT_OK", $P63
.annotate 'line', 42
    new $P64, "Undef"
    .lex "$*RETURN_USED", $P64
.annotate 'line', 43
    new $P65, "Undef"
    .lex "$*PACKAGE-SETUP", $P65
.annotate 'line', 10
    find_lex $P66, "%*LANG"
    unless_null $P66, vivify_584
    get_hll_global $P66, "%LANG"
    unless_null $P66, vivify_585
    die "Contextual %*LANG not found"
  vivify_585:
  vivify_584:
.annotate 'line', 13
    get_hll_global $P67, ["NQP"], "Regex"
    find_lex $P68, "%*LANG"
    unless_null $P68, vivify_586
    get_hll_global $P68, "%LANG"
    unless_null $P68, vivify_587
    die "Contextual %*LANG not found"
  vivify_587:
    store_lex "%*LANG", $P68
  vivify_586:
    set $P68["Regex"], $P67
.annotate 'line', 14
    get_hll_global $P69, ["NQP"], "RegexActions"
    find_lex $P70, "%*LANG"
    unless_null $P70, vivify_588
    get_hll_global $P70, "%LANG"
    unless_null $P70, vivify_589
    die "Contextual %*LANG not found"
  vivify_589:
    store_lex "%*LANG", $P70
  vivify_588:
    set $P70["Regex-actions"], $P69
.annotate 'line', 15
    get_hll_global $P71, ["NQP"], "Grammar"
    find_lex $P72, "%*LANG"
    unless_null $P72, vivify_590
    get_hll_global $P72, "%LANG"
    unless_null $P72, vivify_591
    die "Contextual %*LANG not found"
  vivify_591:
    store_lex "%*LANG", $P72
  vivify_590:
    set $P72["MAIN"], $P71
.annotate 'line', 16
    get_hll_global $P73, ["NQP"], "Actions"
    find_lex $P74, "%*LANG"
    unless_null $P74, vivify_592
    get_hll_global $P74, "%LANG"
    unless_null $P74, vivify_593
    die "Contextual %*LANG not found"
  vivify_593:
    store_lex "%*LANG", $P74
  vivify_592:
    set $P74["MAIN-actions"], $P73
    find_lex $P75, "%*HOW"
    unless_null $P75, vivify_594
    get_hll_global $P75, "%HOW"
    unless_null $P75, vivify_595
    die "Contextual %*HOW not found"
  vivify_595:
  vivify_594:
.annotate 'line', 20
    get_hll_global $P76, "KnowHOW"
    find_lex $P77, "%*HOW"
    unless_null $P77, vivify_596
    get_hll_global $P77, "%HOW"
    unless_null $P77, vivify_597
    die "Contextual %*HOW not found"
  vivify_597:
    store_lex "%*HOW", $P77
  vivify_596:
    set $P77["knowhow"], $P76
.annotate 'line', 21
    get_hll_global $P78, "NQPModuleHOW"
    find_lex $P79, "%*HOW"
    unless_null $P79, vivify_598
    get_hll_global $P79, "%HOW"
    unless_null $P79, vivify_599
    die "Contextual %*HOW not found"
  vivify_599:
    store_lex "%*HOW", $P79
  vivify_598:
    set $P79["module"], $P78
.annotate 'line', 22
    get_hll_global $P80, "NQPClassHOW"
    find_lex $P81, "%*HOW"
    unless_null $P81, vivify_600
    get_hll_global $P81, "%HOW"
    unless_null $P81, vivify_601
    die "Contextual %*HOW not found"
  vivify_601:
    store_lex "%*HOW", $P81
  vivify_600:
    set $P81["class"], $P80
.annotate 'line', 23
    get_hll_global $P82, "NQPClassHOW"
    find_lex $P83, "%*HOW"
    unless_null $P83, vivify_602
    get_hll_global $P83, "%HOW"
    unless_null $P83, vivify_603
    die "Contextual %*HOW not found"
  vivify_603:
    store_lex "%*HOW", $P83
  vivify_602:
    set $P83["grammar"], $P82
.annotate 'line', 24
    get_hll_global $P84, "NQPParametricRoleHOW"
    find_lex $P85, "%*HOW"
    unless_null $P85, vivify_604
    get_hll_global $P85, "%HOW"
    unless_null $P85, vivify_605
    die "Contextual %*HOW not found"
  vivify_605:
    store_lex "%*HOW", $P85
  vivify_604:
    set $P85["role"], $P84
.annotate 'line', 25
    get_hll_global $P86, "NQPNativeHOW"
    find_lex $P87, "%*HOW"
    unless_null $P87, vivify_606
    get_hll_global $P87, "%HOW"
    unless_null $P87, vivify_607
    die "Contextual %*HOW not found"
  vivify_607:
    store_lex "%*HOW", $P87
  vivify_606:
    set $P87["native"], $P86
.annotate 'line', 28
    new $P88, "String"
    assign $P88, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P88
    find_lex $P89, "%*HOW-METAATTR"
    unless_null $P89, vivify_608
    get_hll_global $P89, "%HOW-METAATTR"
    unless_null $P89, vivify_609
    die "Contextual %*HOW-METAATTR not found"
  vivify_609:
  vivify_608:
.annotate 'line', 30
    new $P90, "String"
    assign $P90, "KnowHOWAttribute"
    find_lex $P91, "%*HOW-METAATTR"
    unless_null $P91, vivify_610
    get_hll_global $P91, "%HOW-METAATTR"
    unless_null $P91, vivify_611
    die "Contextual %*HOW-METAATTR not found"
  vivify_611:
    store_lex "%*HOW-METAATTR", $P91
  vivify_610:
    set $P91["knowhow"], $P90
.annotate 'line', 35
    get_hll_global $P92, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 37
    time $N93
    set $S94, $N93
    $P95 = $P92."new"($S94 :named("handle"))
.annotate 'line', 35
    store_lex "$*SC", $P95
.annotate 'line', 39
    new $P96, "String"
    assign $P96, ""
    store_lex "$*SCOPE", $P96
.annotate 'line', 40
    new $P97, "String"
    assign $P97, ""
    store_lex "$*MULTINESS", $P97
.annotate 'line', 41
    new $P98, "Integer"
    assign $P98, 0
    store_lex "$*INVOCANT_OK", $P98
.annotate 'line', 42
    new $P99, "Integer"
    assign $P99, 0
    store_lex "$*RETURN_USED", $P99
    find_lex $P100, "$*PACKAGE-SETUP"
    unless_null $P100, vivify_612
    get_hll_global $P100, "$PACKAGE-SETUP"
    unless_null $P100, vivify_613
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_613:
  vivify_612:
.annotate 'line', 44
    find_lex $P101, "self"
    $P102 = $P101."comp_unit"()
.annotate 'line', 10
    .return ($P102)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx104_tgt
    .local int rx104_pos
    .local int rx104_off
    .local int rx104_eos
    .local int rx104_rep
    .local pmc rx104_cur
    .local pmc rx104_debug
    (rx104_cur, rx104_pos, rx104_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx104_cur
    .local pmc match
    .lex "$/", match
    length rx104_eos, rx104_tgt
    gt rx104_pos, rx104_eos, rx104_done
    set rx104_off, 0
    lt rx104_pos, 2, rx104_start
    sub rx104_off, rx104_pos, 1
    substr rx104_tgt, rx104_tgt, rx104_off
  rx104_start:
    eq $I10, 1, rx104_restart
    if_null rx104_debug, debug_614
    rx104_cur."!cursor_debug"("START", "identifier")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan108_done
    goto rxscan108_scan
  rxscan108_loop:
    (rx104_pos) = rx104_cur."from"()
    inc rx104_pos
    rx104_cur."!cursor_from"(rx104_pos)
    ge rx104_pos, rx104_eos, rxscan108_done
  rxscan108_scan:
    set_addr $I10, rxscan108_loop
    rx104_cur."!mark_push"(0, rx104_pos, $I10)
  rxscan108_done:
.annotate 'line', 49
  # rx subrule "ident" subtype=method negate=
    rx104_cur."!cursor_pos"(rx104_pos)
    $P10 = rx104_cur."ident"()
    unless $P10, rx104_fail
    rx104_pos = $P10."pos"()
  # rx rxquantr109 ** 0..*
    set_addr $I10, rxquantr109_done
    rx104_cur."!mark_push"(0, rx104_pos, $I10)
  rxquantr109_loop:
  # rx enumcharlist negate=0 
    ge rx104_pos, rx104_eos, rx104_fail
    sub $I10, rx104_pos, rx104_off
    substr $S10, rx104_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx104_fail
    inc rx104_pos
  # rx subrule "ident" subtype=method negate=
    rx104_cur."!cursor_pos"(rx104_pos)
    $P10 = rx104_cur."ident"()
    unless $P10, rx104_fail
    rx104_pos = $P10."pos"()
    set_addr $I10, rxquantr109_done
    (rx104_rep) = rx104_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr109_done
    rx104_cur."!mark_push"(rx104_rep, rx104_pos, $I10)
    goto rxquantr109_loop
  rxquantr109_done:
  # rx pass
    rx104_cur."!cursor_pass"(rx104_pos, "identifier")
    if_null rx104_debug, debug_615
    rx104_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx104_pos)
  debug_615:
    .return (rx104_cur)
  rx104_restart:
.annotate 'line', 10
    if_null rx104_debug, debug_616
    rx104_cur."!cursor_debug"("NEXT", "identifier")
  debug_616:
  rx104_fail:
    (rx104_rep, rx104_pos, $I10, $P10) = rx104_cur."!mark_fail"(0)
    lt rx104_pos, -1, rx104_done
    eq rx104_pos, -1, rx104_fail
    jump $I10
  rx104_done:
    rx104_cur."!cursor_fail"()
    if_null rx104_debug, debug_617
    rx104_cur."!cursor_debug"("FAIL", "identifier")
  debug_617:
    .return (rx104_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1303391609.928") :method
.annotate 'line', 10
    $P106 = self."!PREFIX__!subrule"("ident", "")
    new $P107, "ResizablePMCArray"
    push $P107, $P106
    .return ($P107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx111_tgt
    .local int rx111_pos
    .local int rx111_off
    .local int rx111_eos
    .local int rx111_rep
    .local pmc rx111_cur
    .local pmc rx111_debug
    (rx111_cur, rx111_pos, rx111_tgt, $I10) = self."!cursor_start"()
    rx111_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx111_cur
    .local pmc match
    .lex "$/", match
    length rx111_eos, rx111_tgt
    gt rx111_pos, rx111_eos, rx111_done
    set rx111_off, 0
    lt rx111_pos, 2, rx111_start
    sub rx111_off, rx111_pos, 1
    substr rx111_tgt, rx111_tgt, rx111_off
  rx111_start:
    eq $I10, 1, rx111_restart
    if_null rx111_debug, debug_618
    rx111_cur."!cursor_debug"("START", "name")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan114_done
    goto rxscan114_scan
  rxscan114_loop:
    (rx111_pos) = rx111_cur."from"()
    inc rx111_pos
    rx111_cur."!cursor_from"(rx111_pos)
    ge rx111_pos, rx111_eos, rxscan114_done
  rxscan114_scan:
    set_addr $I10, rxscan114_loop
    rx111_cur."!mark_push"(0, rx111_pos, $I10)
  rxscan114_done:
.annotate 'line', 51
  # rx rxquantr115 ** 1..*
    set_addr $I10, rxquantr115_done
    rx111_cur."!mark_push"(0, -1, $I10)
  rxquantr115_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx111_cur."!cursor_pos"(rx111_pos)
    $P10 = rx111_cur."identifier"()
    unless $P10, rx111_fail
    goto rxsubrule116_pass
  rxsubrule116_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx111_fail
  rxsubrule116_pass:
    set_addr $I10, rxsubrule116_back
    rx111_cur."!mark_push"(0, rx111_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx111_pos = $P10."pos"()
    set_addr $I10, rxquantr115_done
    (rx111_rep) = rx111_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr115_done
    rx111_cur."!mark_push"(rx111_rep, rx111_pos, $I10)
  # rx literal  "::"
    add $I11, rx111_pos, 2
    gt $I11, rx111_eos, rx111_fail
    sub $I11, rx111_pos, rx111_off
    substr $S10, rx111_tgt, $I11, 2
    ne $S10, "::", rx111_fail
    add rx111_pos, 2
    goto rxquantr115_loop
  rxquantr115_done:
  # rx pass
    rx111_cur."!cursor_pass"(rx111_pos, "name")
    if_null rx111_debug, debug_619
    rx111_cur."!cursor_debug"("PASS", "name", " at pos=", rx111_pos)
  debug_619:
    .return (rx111_cur)
  rx111_restart:
.annotate 'line', 10
    if_null rx111_debug, debug_620
    rx111_cur."!cursor_debug"("NEXT", "name")
  debug_620:
  rx111_fail:
    (rx111_rep, rx111_pos, $I10, $P10) = rx111_cur."!mark_fail"(0)
    lt rx111_pos, -1, rx111_done
    eq rx111_pos, -1, rx111_fail
    jump $I10
  rx111_done:
    rx111_cur."!cursor_fail"()
    if_null rx111_debug, debug_621
    rx111_cur."!cursor_debug"("FAIL", "name")
  debug_621:
    .return (rx111_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1303391609.928") :method
.annotate 'line', 10
    new $P113, "ResizablePMCArray"
    push $P113, ""
    .return ($P113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx118_tgt
    .local int rx118_pos
    .local int rx118_off
    .local int rx118_eos
    .local int rx118_rep
    .local pmc rx118_cur
    .local pmc rx118_debug
    (rx118_cur, rx118_pos, rx118_tgt, $I10) = self."!cursor_start"()
    rx118_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx118_cur
    .local pmc match
    .lex "$/", match
    length rx118_eos, rx118_tgt
    gt rx118_pos, rx118_eos, rx118_done
    set rx118_off, 0
    lt rx118_pos, 2, rx118_start
    sub rx118_off, rx118_pos, 1
    substr rx118_tgt, rx118_tgt, rx118_off
  rx118_start:
    eq $I10, 1, rx118_restart
    if_null rx118_debug, debug_622
    rx118_cur."!cursor_debug"("START", "deflongname")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan122_done
    goto rxscan122_scan
  rxscan122_loop:
    (rx118_pos) = rx118_cur."from"()
    inc rx118_pos
    rx118_cur."!cursor_from"(rx118_pos)
    ge rx118_pos, rx118_eos, rxscan122_done
  rxscan122_scan:
    set_addr $I10, rxscan122_loop
    rx118_cur."!mark_push"(0, rx118_pos, $I10)
  rxscan122_done:
.annotate 'line', 54
  # rx subrule "identifier" subtype=capture negate=
    rx118_cur."!cursor_pos"(rx118_pos)
    $P10 = rx118_cur."identifier"()
    unless $P10, rx118_fail
    rx118_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx118_pos = $P10."pos"()
  # rx rxquantr123 ** 0..1
    set_addr $I10, rxquantr123_done
    rx118_cur."!mark_push"(0, rx118_pos, $I10)
  rxquantr123_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx118_cur."!cursor_pos"(rx118_pos)
    $P10 = rx118_cur."colonpair"()
    unless $P10, rx118_fail
    goto rxsubrule124_pass
  rxsubrule124_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx118_fail
  rxsubrule124_pass:
    set_addr $I10, rxsubrule124_back
    rx118_cur."!mark_push"(0, rx118_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx118_pos = $P10."pos"()
    set_addr $I10, rxquantr123_done
    (rx118_rep) = rx118_cur."!mark_commit"($I10)
  rxquantr123_done:
.annotate 'line', 53
  # rx pass
    rx118_cur."!cursor_pass"(rx118_pos, "deflongname")
    if_null rx118_debug, debug_623
    rx118_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx118_pos)
  debug_623:
    .return (rx118_cur)
  rx118_restart:
.annotate 'line', 10
    if_null rx118_debug, debug_624
    rx118_cur."!cursor_debug"("NEXT", "deflongname")
  debug_624:
  rx118_fail:
    (rx118_rep, rx118_pos, $I10, $P10) = rx118_cur."!mark_fail"(0)
    lt rx118_pos, -1, rx118_done
    eq rx118_pos, -1, rx118_fail
    jump $I10
  rx118_done:
    rx118_cur."!cursor_fail"()
    if_null rx118_debug, debug_625
    rx118_cur."!cursor_debug"("FAIL", "deflongname")
  debug_625:
    .return (rx118_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1303391609.928") :method
.annotate 'line', 10
    $P120 = self."!PREFIX__!subrule"("identifier", "")
    new $P121, "ResizablePMCArray"
    push $P121, $P120
    .return ($P121)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx126_tgt
    .local int rx126_pos
    .local int rx126_off
    .local int rx126_eos
    .local int rx126_rep
    .local pmc rx126_cur
    .local pmc rx126_debug
    (rx126_cur, rx126_pos, rx126_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx126_cur
    .local pmc match
    .lex "$/", match
    length rx126_eos, rx126_tgt
    gt rx126_pos, rx126_eos, rx126_done
    set rx126_off, 0
    lt rx126_pos, 2, rx126_start
    sub rx126_off, rx126_pos, 1
    substr rx126_tgt, rx126_tgt, rx126_off
  rx126_start:
    eq $I10, 1, rx126_restart
    if_null rx126_debug, debug_626
    rx126_cur."!cursor_debug"("START", "ENDSTMT")
  debug_626:
    $I10 = self.'from'()
    ne $I10, -1, rxscan129_done
    goto rxscan129_scan
  rxscan129_loop:
    (rx126_pos) = rx126_cur."from"()
    inc rx126_pos
    rx126_cur."!cursor_from"(rx126_pos)
    ge rx126_pos, rx126_eos, rxscan129_done
  rxscan129_scan:
    set_addr $I10, rxscan129_loop
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  rxscan129_done:
.annotate 'line', 61
  # rx rxquantr130 ** 0..1
    set_addr $I10, rxquantr130_done
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  rxquantr130_loop:
  alt131_0:
.annotate 'line', 58
    set_addr $I10, alt131_1
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
.annotate 'line', 59
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx126_pos, rx126_off
    set rx126_rep, 0
    sub $I12, rx126_eos, rx126_pos
  rxenumcharlistq132_loop:
    le $I12, 0, rxenumcharlistq132_done
    substr $S10, rx126_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq132_done
    inc rx126_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq132_loop
  rxenumcharlistq132_done:
    add rx126_pos, rx126_pos, rx126_rep
  # rxanchor eol
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 4096, rx126_tgt, $I10
    if $I11, rxanchor133_done
    ne rx126_pos, rx126_eos, rx126_fail
    eq rx126_pos, 0, rxanchor133_done
    dec $I10
    is_cclass $I11, 4096, rx126_tgt, $I10
    if $I11, rx126_fail
  rxanchor133_done:
  # rx subrule "ws" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."ws"()
    unless $P10, rx126_fail
    rx126_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."MARKER"("endstmt")
    unless $P10, rx126_fail
    goto alt131_end
  alt131_1:
.annotate 'line', 60
  # rx rxquantr134 ** 0..1
    set_addr $I10, rxquantr134_done
    rx126_cur."!mark_push"(0, rx126_pos, $I10)
  rxquantr134_loop:
  # rx subrule "unv" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."unv"()
    unless $P10, rx126_fail
    goto rxsubrule135_pass
  rxsubrule135_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx126_fail
  rxsubrule135_pass:
    set_addr $I10, rxsubrule135_back
    rx126_cur."!mark_push"(0, rx126_pos, $I10, $P10)
    rx126_pos = $P10."pos"()
    set_addr $I10, rxquantr134_done
    (rx126_rep) = rx126_cur."!mark_commit"($I10)
  rxquantr134_done:
  # rxanchor eol
    sub $I10, rx126_pos, rx126_off
    is_cclass $I11, 4096, rx126_tgt, $I10
    if $I11, rxanchor136_done
    ne rx126_pos, rx126_eos, rx126_fail
    eq rx126_pos, 0, rxanchor136_done
    dec $I10
    is_cclass $I11, 4096, rx126_tgt, $I10
    if $I11, rx126_fail
  rxanchor136_done:
  # rx subrule "ws" subtype=method negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."ws"()
    unless $P10, rx126_fail
    rx126_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx126_cur."!cursor_pos"(rx126_pos)
    $P10 = rx126_cur."MARKER"("endstmt")
    unless $P10, rx126_fail
  alt131_end:
.annotate 'line', 61
    set_addr $I10, rxquantr130_done
    (rx126_rep) = rx126_cur."!mark_commit"($I10)
  rxquantr130_done:
.annotate 'line', 57
  # rx pass
    rx126_cur."!cursor_pass"(rx126_pos, "ENDSTMT")
    if_null rx126_debug, debug_627
    rx126_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx126_pos)
  debug_627:
    .return (rx126_cur)
  rx126_restart:
.annotate 'line', 10
    if_null rx126_debug, debug_628
    rx126_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_628:
  rx126_fail:
    (rx126_rep, rx126_pos, $I10, $P10) = rx126_cur."!mark_fail"(0)
    lt rx126_pos, -1, rx126_done
    eq rx126_pos, -1, rx126_fail
    jump $I10
  rx126_done:
    rx126_cur."!cursor_fail"()
    if_null rx126_debug, debug_629
    rx126_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_629:
    .return (rx126_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1303391609.928") :method
.annotate 'line', 10
    new $P128, "ResizablePMCArray"
    push $P128, ""
    .return ($P128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx138_tgt
    .local int rx138_pos
    .local int rx138_off
    .local int rx138_eos
    .local int rx138_rep
    .local pmc rx138_cur
    .local pmc rx138_debug
    (rx138_cur, rx138_pos, rx138_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx138_cur
    .local pmc match
    .lex "$/", match
    length rx138_eos, rx138_tgt
    gt rx138_pos, rx138_eos, rx138_done
    set rx138_off, 0
    lt rx138_pos, 2, rx138_start
    sub rx138_off, rx138_pos, 1
    substr rx138_tgt, rx138_tgt, rx138_off
  rx138_start:
    eq $I10, 1, rx138_restart
    if_null rx138_debug, debug_630
    rx138_cur."!cursor_debug"("START", "ws")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan141_done
    goto rxscan141_scan
  rxscan141_loop:
    (rx138_pos) = rx138_cur."from"()
    inc rx138_pos
    rx138_cur."!cursor_from"(rx138_pos)
    ge rx138_pos, rx138_eos, rxscan141_done
  rxscan141_scan:
    set_addr $I10, rxscan141_loop
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
  rxscan141_done:
  alt142_0:
.annotate 'line', 64
    set_addr $I10, alt142_1
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
.annotate 'line', 65
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx138_cur."!cursor_pos"(rx138_pos)
    $P10 = rx138_cur."MARKED"("ws")
    unless $P10, rx138_fail
    goto alt142_end
  alt142_1:
.annotate 'line', 66
  # rx subrule "ww" subtype=zerowidth negate=1
    rx138_cur."!cursor_pos"(rx138_pos)
    $P10 = rx138_cur."ww"()
    if $P10, rx138_fail
.annotate 'line', 71
  # rx rxquantr143 ** 0..*
    set_addr $I10, rxquantr143_done
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
  rxquantr143_loop:
  alt144_0:
.annotate 'line', 67
    set_addr $I10, alt144_1
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx138_pos, rx138_off
    set rx138_rep, 0
    sub $I12, rx138_eos, rx138_pos
  rxenumcharlistq145_loop:
    le $I12, 0, rxenumcharlistq145_done
    substr $S10, rx138_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq145_done
    inc rx138_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq145_loop
  rxenumcharlistq145_done:
    lt rx138_rep, 1, rx138_fail
    add rx138_pos, rx138_pos, rx138_rep
    goto alt144_end
  alt144_1:
    set_addr $I10, alt144_2
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
.annotate 'line', 68
  # rx literal  "#"
    add $I11, rx138_pos, 1
    gt $I11, rx138_eos, rx138_fail
    sub $I11, rx138_pos, rx138_off
    ord $I11, rx138_tgt, $I11
    ne $I11, 35, rx138_fail
    add rx138_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx138_pos, rx138_off
    find_cclass $I11, 4096, rx138_tgt, $I10, rx138_eos
    add rx138_pos, rx138_off, $I11
    goto alt144_end
  alt144_2:
    set_addr $I10, alt144_3
    rx138_cur."!mark_push"(0, rx138_pos, $I10)
.annotate 'line', 69
  # rxanchor bol
    eq rx138_pos, 0, rxanchor146_done
    ge rx138_pos, rx138_eos, rx138_fail
    sub $I10, rx138_pos, rx138_off
    dec $I10
    is_cclass $I11, 4096, rx138_tgt, $I10
    unless $I11, rx138_fail
  rxanchor146_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx138_cur."!cursor_pos"(rx138_pos)
    $P10 = rx138_cur."pod_comment"()
    unless $P10, rx138_fail
    rx138_pos = $P10."pos"()
    goto alt144_end
  alt144_3:
.annotate 'line', 70
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx138_pos, rx138_off
    set rx138_rep, 0
    sub $I12, rx138_eos, rx138_pos
  rxenumcharlistq147_loop:
    le $I12, 0, rxenumcharlistq147_done
    substr $S10, rx138_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq147_done
    inc rx138_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq147_loop
  rxenumcharlistq147_done:
    lt rx138_rep, 1, rx138_fail
    add rx138_pos, rx138_pos, rx138_rep
  alt144_end:
.annotate 'line', 71
    set_addr $I10, rxquantr143_done
    (rx138_rep) = rx138_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr143_done
    rx138_cur."!mark_push"(rx138_rep, rx138_pos, $I10)
    goto rxquantr143_loop
  rxquantr143_done:
.annotate 'line', 72
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx138_cur."!cursor_pos"(rx138_pos)
    $P10 = rx138_cur."MARKER"("ws")
    unless $P10, rx138_fail
  alt142_end:
.annotate 'line', 64
  # rx pass
    rx138_cur."!cursor_pass"(rx138_pos, "ws")
    if_null rx138_debug, debug_631
    rx138_cur."!cursor_debug"("PASS", "ws", " at pos=", rx138_pos)
  debug_631:
    .return (rx138_cur)
  rx138_restart:
.annotate 'line', 10
    if_null rx138_debug, debug_632
    rx138_cur."!cursor_debug"("NEXT", "ws")
  debug_632:
  rx138_fail:
    (rx138_rep, rx138_pos, $I10, $P10) = rx138_cur."!mark_fail"(0)
    lt rx138_pos, -1, rx138_done
    eq rx138_pos, -1, rx138_fail
    jump $I10
  rx138_done:
    rx138_cur."!cursor_fail"()
    if_null rx138_debug, debug_633
    rx138_cur."!cursor_debug"("FAIL", "ws")
  debug_633:
    .return (rx138_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1303391609.928") :method
.annotate 'line', 10
    new $P140, "ResizablePMCArray"
    push $P140, ""
    push $P140, ""
    .return ($P140)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P156 = "26_1303391609.928" 
    capture_lex $P156
    .local string rx149_tgt
    .local int rx149_pos
    .local int rx149_off
    .local int rx149_eos
    .local int rx149_rep
    .local pmc rx149_cur
    .local pmc rx149_debug
    (rx149_cur, rx149_pos, rx149_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx149_cur
    .local pmc match
    .lex "$/", match
    length rx149_eos, rx149_tgt
    gt rx149_pos, rx149_eos, rx149_done
    set rx149_off, 0
    lt rx149_pos, 2, rx149_start
    sub rx149_off, rx149_pos, 1
    substr rx149_tgt, rx149_tgt, rx149_off
  rx149_start:
    eq $I10, 1, rx149_restart
    if_null rx149_debug, debug_634
    rx149_cur."!cursor_debug"("START", "unv")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan152_done
    goto rxscan152_scan
  rxscan152_loop:
    (rx149_pos) = rx149_cur."from"()
    inc rx149_pos
    rx149_cur."!cursor_from"(rx149_pos)
    ge rx149_pos, rx149_eos, rxscan152_done
  rxscan152_scan:
    set_addr $I10, rxscan152_loop
    rx149_cur."!mark_push"(0, rx149_pos, $I10)
  rxscan152_done:
  alt153_0:
.annotate 'line', 77
    set_addr $I10, alt153_1
    rx149_cur."!mark_push"(0, rx149_pos, $I10)
.annotate 'line', 78
  # rxanchor bol
    eq rx149_pos, 0, rxanchor154_done
    ge rx149_pos, rx149_eos, rx149_fail
    sub $I10, rx149_pos, rx149_off
    dec $I10
    is_cclass $I11, 4096, rx149_tgt, $I10
    unless $I11, rx149_fail
  rxanchor154_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx149_cur."!cursor_pos"(rx149_pos)
    .const 'Sub' $P156 = "26_1303391609.928" 
    capture_lex $P156
    $P10 = rx149_cur."before"($P156)
    unless $P10, rx149_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx149_cur."!cursor_pos"(rx149_pos)
    $P10 = rx149_cur."pod_comment"()
    unless $P10, rx149_fail
    rx149_pos = $P10."pos"()
    goto alt153_end
  alt153_1:
    set_addr $I10, alt153_2
    rx149_cur."!mark_push"(0, rx149_pos, $I10)
.annotate 'line', 79
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx149_pos, rx149_off
    set rx149_rep, 0
    sub $I12, rx149_eos, rx149_pos
  rxenumcharlistq161_loop:
    le $I12, 0, rxenumcharlistq161_done
    substr $S10, rx149_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq161_done
    inc rx149_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq161_loop
  rxenumcharlistq161_done:
    add rx149_pos, rx149_pos, rx149_rep
  # rx literal  "#"
    add $I11, rx149_pos, 1
    gt $I11, rx149_eos, rx149_fail
    sub $I11, rx149_pos, rx149_off
    ord $I11, rx149_tgt, $I11
    ne $I11, 35, rx149_fail
    add rx149_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx149_pos, rx149_off
    find_cclass $I11, 4096, rx149_tgt, $I10, rx149_eos
    add rx149_pos, rx149_off, $I11
    goto alt153_end
  alt153_2:
.annotate 'line', 80
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx149_pos, rx149_off
    set rx149_rep, 0
    sub $I12, rx149_eos, rx149_pos
  rxenumcharlistq162_loop:
    le $I12, 0, rxenumcharlistq162_done
    substr $S10, rx149_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq162_done
    inc rx149_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq162_loop
  rxenumcharlistq162_done:
    lt rx149_rep, 1, rx149_fail
    add rx149_pos, rx149_pos, rx149_rep
  alt153_end:
.annotate 'line', 75
  # rx pass
    rx149_cur."!cursor_pass"(rx149_pos, "unv")
    if_null rx149_debug, debug_639
    rx149_cur."!cursor_debug"("PASS", "unv", " at pos=", rx149_pos)
  debug_639:
    .return (rx149_cur)
  rx149_restart:
.annotate 'line', 10
    if_null rx149_debug, debug_640
    rx149_cur."!cursor_debug"("NEXT", "unv")
  debug_640:
  rx149_fail:
    (rx149_rep, rx149_pos, $I10, $P10) = rx149_cur."!mark_fail"(0)
    lt rx149_pos, -1, rx149_done
    eq rx149_pos, -1, rx149_fail
    jump $I10
  rx149_done:
    rx149_cur."!cursor_fail"()
    if_null rx149_debug, debug_641
    rx149_cur."!cursor_debug"("FAIL", "unv")
  debug_641:
    .return (rx149_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1303391609.928") :method
.annotate 'line', 10
    new $P151, "ResizablePMCArray"
    push $P151, ""
    push $P151, ""
    push $P151, ""
    .return ($P151)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block155"  :anon :subid("26_1303391609.928") :method :outer("24_1303391609.928")
.annotate 'line', 78
    .local string rx157_tgt
    .local int rx157_pos
    .local int rx157_off
    .local int rx157_eos
    .local int rx157_rep
    .local pmc rx157_cur
    .local pmc rx157_debug
    (rx157_cur, rx157_pos, rx157_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx157_cur
    .local pmc match
    .lex "$/", match
    length rx157_eos, rx157_tgt
    gt rx157_pos, rx157_eos, rx157_done
    set rx157_off, 0
    lt rx157_pos, 2, rx157_start
    sub rx157_off, rx157_pos, 1
    substr rx157_tgt, rx157_tgt, rx157_off
  rx157_start:
    eq $I10, 1, rx157_restart
    if_null rx157_debug, debug_635
    rx157_cur."!cursor_debug"("START", "")
  debug_635:
    $I10 = self.'from'()
    ne $I10, -1, rxscan158_done
    goto rxscan158_scan
  rxscan158_loop:
    (rx157_pos) = rx157_cur."from"()
    inc rx157_pos
    rx157_cur."!cursor_from"(rx157_pos)
    ge rx157_pos, rx157_eos, rxscan158_done
  rxscan158_scan:
    set_addr $I10, rxscan158_loop
    rx157_cur."!mark_push"(0, rx157_pos, $I10)
  rxscan158_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx157_pos, rx157_off
    set rx157_rep, 0
    sub $I12, rx157_eos, rx157_pos
  rxenumcharlistq159_loop:
    le $I12, 0, rxenumcharlistq159_done
    substr $S10, rx157_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq159_done
    inc rx157_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq159_loop
  rxenumcharlistq159_done:
    add rx157_pos, rx157_pos, rx157_rep
  # rx literal  "="
    add $I11, rx157_pos, 1
    gt $I11, rx157_eos, rx157_fail
    sub $I11, rx157_pos, rx157_off
    ord $I11, rx157_tgt, $I11
    ne $I11, 61, rx157_fail
    add rx157_pos, 1
  alt160_0:
    set_addr $I10, alt160_1
    rx157_cur."!mark_push"(0, rx157_pos, $I10)
  # rx charclass w
    ge rx157_pos, rx157_eos, rx157_fail
    sub $I10, rx157_pos, rx157_off
    is_cclass $I11, 8192, rx157_tgt, $I10
    unless $I11, rx157_fail
    inc rx157_pos
    goto alt160_end
  alt160_1:
  # rx literal  "\\"
    add $I11, rx157_pos, 1
    gt $I11, rx157_eos, rx157_fail
    sub $I11, rx157_pos, rx157_off
    ord $I11, rx157_tgt, $I11
    ne $I11, 92, rx157_fail
    add rx157_pos, 1
  alt160_end:
  # rx pass
    rx157_cur."!cursor_pass"(rx157_pos, "")
    if_null rx157_debug, debug_636
    rx157_cur."!cursor_debug"("PASS", "", " at pos=", rx157_pos)
  debug_636:
    .return (rx157_cur)
  rx157_restart:
    if_null rx157_debug, debug_637
    rx157_cur."!cursor_debug"("NEXT", "")
  debug_637:
  rx157_fail:
    (rx157_rep, rx157_pos, $I10, $P10) = rx157_cur."!mark_fail"(0)
    lt rx157_pos, -1, rx157_done
    eq rx157_pos, -1, rx157_fail
    jump $I10
  rx157_done:
    rx157_cur."!cursor_fail"()
    if_null rx157_debug, debug_638
    rx157_cur."!cursor_debug"("FAIL", "")
  debug_638:
    .return (rx157_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P195 = "29_1303391609.928" 
    capture_lex $P195
    .local string rx164_tgt
    .local int rx164_pos
    .local int rx164_off
    .local int rx164_eos
    .local int rx164_rep
    .local pmc rx164_cur
    .local pmc rx164_debug
    (rx164_cur, rx164_pos, rx164_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx164_cur
    .local pmc match
    .lex "$/", match
    length rx164_eos, rx164_tgt
    gt rx164_pos, rx164_eos, rx164_done
    set rx164_off, 0
    lt rx164_pos, 2, rx164_start
    sub rx164_off, rx164_pos, 1
    substr rx164_tgt, rx164_tgt, rx164_off
  rx164_start:
    eq $I10, 1, rx164_restart
    if_null rx164_debug, debug_642
    rx164_cur."!cursor_debug"("START", "pod_comment")
  debug_642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan167_done
    goto rxscan167_scan
  rxscan167_loop:
    (rx164_pos) = rx164_cur."from"()
    inc rx164_pos
    rx164_cur."!cursor_from"(rx164_pos)
    ge rx164_pos, rx164_eos, rxscan167_done
  rxscan167_scan:
    set_addr $I10, rxscan167_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  rxscan167_done:
.annotate 'line', 85
  # rxanchor bol
    eq rx164_pos, 0, rxanchor168_done
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    dec $I10
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
  rxanchor168_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq169_loop:
    le $I12, 0, rxenumcharlistq169_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq169_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq169_loop
  rxenumcharlistq169_done:
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "="
    add $I11, rx164_pos, 1
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    ord $I11, rx164_tgt, $I11
    ne $I11, 61, rx164_fail
    add rx164_pos, 1
  alt170_0:
.annotate 'line', 86
    set_addr $I10, alt170_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx164_pos, 5
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 5
    ne $S10, "begin", rx164_fail
    add rx164_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq171_loop:
    le $I12, 0, rxenumcharlistq171_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq171_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq171_loop
  rxenumcharlistq171_done:
    lt rx164_rep, 1, rx164_fail
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "END"
    add $I11, rx164_pos, 3
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 3
    ne $S10, "END", rx164_fail
    add rx164_pos, 3
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
  alt172_0:
.annotate 'line', 88
    set_addr $I10, alt172_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  # rx rxquantf173 ** 0..*
    set_addr $I10, rxquantf173_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
    goto rxquantf173_done
  rxquantf173_loop:
  # rx charclass .
    ge rx164_pos, rx164_eos, rx164_fail
    inc rx164_pos
    set_addr $I10, rxquantf173_loop
    rx164_cur."!mark_push"(rx164_rep, rx164_pos, $I10)
  rxquantf173_done:
  # rx charclass nl
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
    substr $S10, rx164_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx164_pos, $I11
    inc rx164_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq175_loop:
    le $I12, 0, rxenumcharlistq175_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq175_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq175_loop
  rxenumcharlistq175_done:
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "=end"
    add $I11, rx164_pos, 4
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 4
    ne $S10, "=end", rx164_fail
    add rx164_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq176_loop:
    le $I12, 0, rxenumcharlistq176_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq176_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq176_loop
  rxenumcharlistq176_done:
    lt rx164_rep, 1, rx164_fail
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "END"
    add $I11, rx164_pos, 3
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 3
    ne $S10, "END", rx164_fail
    add rx164_pos, 3
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx164_pos, rx164_off
    find_cclass $I11, 4096, rx164_tgt, $I10, rx164_eos
    add rx164_pos, rx164_off, $I11
    goto alt172_end
  alt172_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx164_pos, rx164_off
    find_not_cclass $I11, 65535, rx164_tgt, $I10, rx164_eos
    add rx164_pos, rx164_off, $I11
  alt172_end:
.annotate 'line', 87
    goto alt170_end
  alt170_1:
    set_addr $I10, alt170_2
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 89
  # rx literal  "begin"
    add $I11, rx164_pos, 5
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 5
    ne $S10, "begin", rx164_fail
    add rx164_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq177_loop:
    le $I12, 0, rxenumcharlistq177_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq177_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq177_loop
  rxenumcharlistq177_done:
    lt rx164_rep, 1, rx164_fail
    add rx164_pos, rx164_pos, rx164_rep
  # rx subrule "identifier" subtype=capture negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."identifier"()
    unless $P10, rx164_fail
    rx164_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx164_pos = $P10."pos"()
  alt178_0:
.annotate 'line', 90
    set_addr $I10, alt178_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 91
  # rx rxquantf179 ** 0..*
    set_addr $I10, rxquantf179_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
    goto rxquantf179_done
  rxquantf179_loop:
  # rx charclass .
    ge rx164_pos, rx164_eos, rx164_fail
    inc rx164_pos
    set_addr $I10, rxquantf179_loop
    rx164_cur."!mark_push"(rx164_rep, rx164_pos, $I10)
  rxquantf179_done:
  # rx charclass nl
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
    substr $S10, rx164_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx164_pos, $I11
    inc rx164_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq181_loop:
    le $I12, 0, rxenumcharlistq181_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq181_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq181_loop
  rxenumcharlistq181_done:
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "=end"
    add $I11, rx164_pos, 4
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 4
    ne $S10, "=end", rx164_fail
    add rx164_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq182_loop:
    le $I12, 0, rxenumcharlistq182_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq182_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq182_loop
  rxenumcharlistq182_done:
    lt rx164_rep, 1, rx164_fail
    add rx164_pos, rx164_pos, rx164_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."!BACKREF"("identifier")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx164_pos, rx164_off
    find_cclass $I11, 4096, rx164_tgt, $I10, rx164_eos
    add rx164_pos, rx164_off, $I11
    goto alt178_end
  alt178_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."panic"("=begin without matching =end")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
  alt178_end:
.annotate 'line', 89
    goto alt170_end
  alt170_2:
    set_addr $I10, alt170_3
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 94
  # rx literal  "begin"
    add $I11, rx164_pos, 5
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 5
    ne $S10, "begin", rx164_fail
    add rx164_pos, 5
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq184_loop:
    le $I12, 0, rxenumcharlistq184_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq184_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq184_loop
  rxenumcharlistq184_done:
    add rx164_pos, rx164_pos, rx164_rep
  alt185_0:
.annotate 'line', 95
    set_addr $I10, alt185_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  # rxanchor eol
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 4096, rx164_tgt, $I10
    if $I11, rxanchor186_done
    ne rx164_pos, rx164_eos, rx164_fail
    eq rx164_pos, 0, rxanchor186_done
    dec $I10
    is_cclass $I11, 4096, rx164_tgt, $I10
    if $I11, rx164_fail
  rxanchor186_done:
    goto alt185_end
  alt185_1:
    set_addr $I10, alt185_2
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  # rx literal  "#"
    add $I11, rx164_pos, 1
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    ord $I11, rx164_tgt, $I11
    ne $I11, 35, rx164_fail
    add rx164_pos, 1
    goto alt185_end
  alt185_2:
  # rx subrule "panic" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
  alt185_end:
  alt187_0:
.annotate 'line', 96
    set_addr $I10, alt187_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 97
  # rx rxquantf188 ** 0..*
    set_addr $I10, rxquantf188_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
    goto rxquantf188_done
  rxquantf188_loop:
  # rx charclass .
    ge rx164_pos, rx164_eos, rx164_fail
    inc rx164_pos
    set_addr $I10, rxquantf188_loop
    rx164_cur."!mark_push"(rx164_rep, rx164_pos, $I10)
  rxquantf188_done:
  # rx charclass nl
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
    substr $S10, rx164_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx164_pos, $I11
    inc rx164_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx164_pos, rx164_off
    set rx164_rep, 0
    sub $I12, rx164_eos, rx164_pos
  rxenumcharlistq190_loop:
    le $I12, 0, rxenumcharlistq190_done
    substr $S10, rx164_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq190_done
    inc rx164_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq190_loop
  rxenumcharlistq190_done:
    add rx164_pos, rx164_pos, rx164_rep
  # rx literal  "=end"
    add $I11, rx164_pos, 4
    gt $I11, rx164_eos, rx164_fail
    sub $I11, rx164_pos, rx164_off
    substr $S10, rx164_tgt, $I11, 4
    ne $S10, "=end", rx164_fail
    add rx164_pos, 4
  # rxanchor rwb
    le rx164_pos, 0, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 8192, rx164_tgt, $I10
    if $I11, rx164_fail
    dec $I10
    is_cclass $I11, 8192, rx164_tgt, $I10
    unless $I11, rx164_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx164_pos, rx164_off
    find_cclass $I11, 4096, rx164_tgt, $I10, rx164_eos
    add rx164_pos, rx164_off, $I11
    goto alt187_end
  alt187_1:
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."panic"("=begin without matching =end")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
  alt187_end:
.annotate 'line', 94
    goto alt170_end
  alt170_3:
    set_addr $I10, alt170_4
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
.annotate 'line', 100
  # rx subrule "identifier" subtype=capture negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."identifier"()
    unless $P10, rx164_fail
    rx164_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx164_pos = $P10."pos"()
.annotate 'line', 101
  # rx rxquantf191 ** 0..*
    set_addr $I10, rxquantf191_loop
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
    goto rxquantf191_done
  rxquantf191_loop:
  # rx charclass .
    ge rx164_pos, rx164_eos, rx164_fail
    inc rx164_pos
    set_addr $I10, rxquantf191_loop
    rx164_cur."!mark_push"(rx164_rep, rx164_pos, $I10)
  rxquantf191_done:
  # rxanchor bol
    eq rx164_pos, 0, rxanchor193_done
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    dec $I10
    is_cclass $I11, 4096, rx164_tgt, $I10
    unless $I11, rx164_fail
  rxanchor193_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    .const 'Sub' $P195 = "29_1303391609.928" 
    capture_lex $P195
    $P10 = rx164_cur."before"($P195)
    unless $P10, rx164_fail
.annotate 'line', 100
    goto alt170_end
  alt170_4:
  alt201_0:
.annotate 'line', 107
    set_addr $I10, alt201_1
    rx164_cur."!mark_push"(0, rx164_pos, $I10)
  # rx charclass s
    ge rx164_pos, rx164_eos, rx164_fail
    sub $I10, rx164_pos, rx164_off
    is_cclass $I11, 32, rx164_tgt, $I10
    unless $I11, rx164_fail
    inc rx164_pos
    goto alt201_end
  alt201_1:
  # rx subrule "panic" subtype=method negate=
    rx164_cur."!cursor_pos"(rx164_pos)
    $P10 = rx164_cur."panic"("Illegal pod directive")
    unless $P10, rx164_fail
    rx164_pos = $P10."pos"()
  alt201_end:
.annotate 'line', 108
  # rx charclass_q N r 0..-1
    sub $I10, rx164_pos, rx164_off
    find_cclass $I11, 4096, rx164_tgt, $I10, rx164_eos
    add rx164_pos, rx164_off, $I11
  alt170_end:
.annotate 'line', 84
  # rx pass
    rx164_cur."!cursor_pass"(rx164_pos, "pod_comment")
    if_null rx164_debug, debug_647
    rx164_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx164_pos)
  debug_647:
    .return (rx164_cur)
  rx164_restart:
.annotate 'line', 10
    if_null rx164_debug, debug_648
    rx164_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_648:
  rx164_fail:
    (rx164_rep, rx164_pos, $I10, $P10) = rx164_cur."!mark_fail"(0)
    lt rx164_pos, -1, rx164_done
    eq rx164_pos, -1, rx164_fail
    jump $I10
  rx164_done:
    rx164_cur."!cursor_fail"()
    if_null rx164_debug, debug_649
    rx164_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_649:
    .return (rx164_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1303391609.928") :method
.annotate 'line', 10
    new $P166, "ResizablePMCArray"
    push $P166, ""
    .return ($P166)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block194"  :anon :subid("29_1303391609.928") :method :outer("27_1303391609.928")
.annotate 'line', 101
    .local string rx196_tgt
    .local int rx196_pos
    .local int rx196_off
    .local int rx196_eos
    .local int rx196_rep
    .local pmc rx196_cur
    .local pmc rx196_debug
    (rx196_cur, rx196_pos, rx196_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx196_cur
    .local pmc match
    .lex "$/", match
    length rx196_eos, rx196_tgt
    gt rx196_pos, rx196_eos, rx196_done
    set rx196_off, 0
    lt rx196_pos, 2, rx196_start
    sub rx196_off, rx196_pos, 1
    substr rx196_tgt, rx196_tgt, rx196_off
  rx196_start:
    eq $I10, 1, rx196_restart
    if_null rx196_debug, debug_643
    rx196_cur."!cursor_debug"("START", "")
  debug_643:
    $I10 = self.'from'()
    ne $I10, -1, rxscan197_done
    goto rxscan197_scan
  rxscan197_loop:
    (rx196_pos) = rx196_cur."from"()
    inc rx196_pos
    rx196_cur."!cursor_from"(rx196_pos)
    ge rx196_pos, rx196_eos, rxscan197_done
  rxscan197_scan:
    set_addr $I10, rxscan197_loop
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxscan197_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx196_pos, rx196_off
    set rx196_rep, 0
    sub $I12, rx196_eos, rx196_pos
  rxenumcharlistq198_loop:
    le $I12, 0, rxenumcharlistq198_done
    substr $S10, rx196_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq198_done
    inc rx196_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq198_loop
  rxenumcharlistq198_done:
    add rx196_pos, rx196_pos, rx196_rep
  alt199_0:
    set_addr $I10, alt199_1
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 102
  # rx literal  "="
    add $I11, rx196_pos, 1
    gt $I11, rx196_eos, rx196_fail
    sub $I11, rx196_pos, rx196_off
    ord $I11, rx196_tgt, $I11
    ne $I11, 61, rx196_fail
    add rx196_pos, 1
.annotate 'line', 104
  # rx rxquantr200 ** 0..1
    set_addr $I10, rxquantr200_done
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxquantr200_loop:
.annotate 'line', 103
  # rx literal  "cut"
    add $I11, rx196_pos, 3
    gt $I11, rx196_eos, rx196_fail
    sub $I11, rx196_pos, rx196_off
    substr $S10, rx196_tgt, $I11, 3
    ne $S10, "cut", rx196_fail
    add rx196_pos, 3
  # rxanchor rwb
    le rx196_pos, 0, rx196_fail
    sub $I10, rx196_pos, rx196_off
    is_cclass $I11, 8192, rx196_tgt, $I10
    if $I11, rx196_fail
    dec $I10
    is_cclass $I11, 8192, rx196_tgt, $I10
    unless $I11, rx196_fail
.annotate 'line', 104
  # rx subrule "panic" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
    set_addr $I10, rxquantr200_done
    (rx196_rep) = rx196_cur."!mark_commit"($I10)
  rxquantr200_done:
.annotate 'line', 101
    goto alt199_end
  alt199_1:
.annotate 'line', 105
  # rx charclass nl
    ge rx196_pos, rx196_eos, rx196_fail
    sub $I10, rx196_pos, rx196_off
    is_cclass $I11, 4096, rx196_tgt, $I10
    unless $I11, rx196_fail
    substr $S10, rx196_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx196_pos, $I11
    inc rx196_pos
  alt199_end:
.annotate 'line', 101
  # rx pass
    rx196_cur."!cursor_pass"(rx196_pos, "")
    if_null rx196_debug, debug_644
    rx196_cur."!cursor_debug"("PASS", "", " at pos=", rx196_pos)
  debug_644:
    .return (rx196_cur)
  rx196_restart:
    if_null rx196_debug, debug_645
    rx196_cur."!cursor_debug"("NEXT", "")
  debug_645:
  rx196_fail:
    (rx196_rep, rx196_pos, $I10, $P10) = rx196_cur."!mark_fail"(0)
    lt rx196_pos, -1, rx196_done
    eq rx196_pos, -1, rx196_fail
    jump $I10
  rx196_done:
    rx196_cur."!cursor_fail"()
    if_null rx196_debug, debug_646
    rx196_cur."!cursor_debug"("FAIL", "")
  debug_646:
    .return (rx196_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 116
    new $P203, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P203
.annotate 'line', 117
    new $P204, "Undef"
    .lex "$*MAIN_SUB", $P204
.annotate 'line', 121
    new $P205, "Undef"
    .lex "$*PACKAGE", $P205
.annotate 'line', 122
    new $P206, "Undef"
    .lex "$*GLOBALish", $P206
.annotate 'line', 10
    .local string rx207_tgt
    .local int rx207_pos
    .local int rx207_off
    .local int rx207_eos
    .local int rx207_rep
    .local pmc rx207_cur
    .local pmc rx207_debug
    (rx207_cur, rx207_pos, rx207_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx207_cur
    .local pmc match
    .lex "$/", match
    length rx207_eos, rx207_tgt
    gt rx207_pos, rx207_eos, rx207_done
    set rx207_off, 0
    lt rx207_pos, 2, rx207_start
    sub rx207_off, rx207_pos, 1
    substr rx207_tgt, rx207_tgt, rx207_off
  rx207_start:
    eq $I10, 1, rx207_restart
    if_null rx207_debug, debug_650
    rx207_cur."!cursor_debug"("START", "comp_unit")
  debug_650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan211_done
    goto rxscan211_scan
  rxscan211_loop:
    (rx207_pos) = rx207_cur."from"()
    inc rx207_pos
    rx207_cur."!cursor_from"(rx207_pos)
    ge rx207_pos, rx207_eos, rxscan211_done
  rxscan211_scan:
    set_addr $I10, rxscan211_loop
    rx207_cur."!mark_push"(0, rx207_pos, $I10)
  rxscan211_done:
.annotate 'line', 116
    rx207_cur."!cursor_pos"(rx207_pos)
    new $P212, "Integer"
    assign $P212, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P212
.annotate 'line', 117
    rx207_cur."!cursor_pos"(rx207_pos)
    find_lex $P213, "$*MAIN_SUB"
    unless_null $P213, vivify_651
    get_hll_global $P213, "$MAIN_SUB"
    unless_null $P213, vivify_652
    die "Contextual $*MAIN_SUB not found"
  vivify_652:
  vivify_651:
.annotate 'line', 118
  # rx subrule "newpad" subtype=method negate=
    rx207_cur."!cursor_pos"(rx207_pos)
    $P10 = rx207_cur."newpad"()
    unless $P10, rx207_fail
    rx207_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx207_cur."!cursor_pos"(rx207_pos)
    $P10 = rx207_cur."outerctx"()
    unless $P10, rx207_fail
    rx207_pos = $P10."pos"()
.annotate 'line', 121
    rx207_cur."!cursor_pos"(rx207_pos)
    find_lex $P214, "$*PACKAGE"
    unless_null $P214, vivify_653
    get_hll_global $P214, "$PACKAGE"
    unless_null $P214, vivify_654
    die "Contextual $*PACKAGE not found"
  vivify_654:
  vivify_653:
.annotate 'line', 122
    rx207_cur."!cursor_pos"(rx207_pos)
    find_lex $P215, "$*GLOBALish"
    unless_null $P215, vivify_655
    get_hll_global $P215, "$GLOBALish"
    unless_null $P215, vivify_656
    die "Contextual $*GLOBALish not found"
  vivify_656:
  vivify_655:
.annotate 'line', 123
  # rx subrule "GLOBALish" subtype=method negate=
    rx207_cur."!cursor_pos"(rx207_pos)
    $P10 = rx207_cur."GLOBALish"()
    unless $P10, rx207_fail
    rx207_pos = $P10."pos"()
.annotate 'line', 125
  # rx subrule "statementlist" subtype=capture negate=
    rx207_cur."!cursor_pos"(rx207_pos)
    $P10 = rx207_cur."statementlist"()
    unless $P10, rx207_fail
    rx207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx207_pos = $P10."pos"()
  alt216_0:
.annotate 'line', 126
    set_addr $I10, alt216_1
    rx207_cur."!mark_push"(0, rx207_pos, $I10)
  # rxanchor eos
    ne rx207_pos, rx207_eos, rx207_fail
    goto alt216_end
  alt216_1:
  # rx subrule "panic" subtype=method negate=
    rx207_cur."!cursor_pos"(rx207_pos)
    $P10 = rx207_cur."panic"("Confused")
    unless $P10, rx207_fail
    rx207_pos = $P10."pos"()
  alt216_end:
.annotate 'line', 115
  # rx pass
    rx207_cur."!cursor_pass"(rx207_pos, "comp_unit")
    if_null rx207_debug, debug_657
    rx207_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx207_pos)
  debug_657:
    .return (rx207_cur)
  rx207_restart:
.annotate 'line', 10
    if_null rx207_debug, debug_658
    rx207_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_658:
  rx207_fail:
    (rx207_rep, rx207_pos, $I10, $P10) = rx207_cur."!mark_fail"(0)
    lt rx207_pos, -1, rx207_done
    eq rx207_pos, -1, rx207_fail
    jump $I10
  rx207_done:
    rx207_cur."!cursor_fail"()
    if_null rx207_debug, debug_659
    rx207_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_659:
    .return (rx207_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1303391609.928") :method
.annotate 'line', 10
    $P209 = self."!PREFIX__!subrule"("newpad", "")
    new $P210, "ResizablePMCArray"
    push $P210, $P209
    .return ($P210)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx218_tgt
    .local int rx218_pos
    .local int rx218_off
    .local int rx218_eos
    .local int rx218_rep
    .local pmc rx218_cur
    .local pmc rx218_debug
    (rx218_cur, rx218_pos, rx218_tgt, $I10) = self."!cursor_start"()
    rx218_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx218_cur
    .local pmc match
    .lex "$/", match
    length rx218_eos, rx218_tgt
    gt rx218_pos, rx218_eos, rx218_done
    set rx218_off, 0
    lt rx218_pos, 2, rx218_start
    sub rx218_off, rx218_pos, 1
    substr rx218_tgt, rx218_tgt, rx218_off
  rx218_start:
    eq $I10, 1, rx218_restart
    if_null rx218_debug, debug_660
    rx218_cur."!cursor_debug"("START", "statementlist")
  debug_660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan223_done
    goto rxscan223_scan
  rxscan223_loop:
    (rx218_pos) = rx218_cur."from"()
    inc rx218_pos
    rx218_cur."!cursor_from"(rx218_pos)
    ge rx218_pos, rx218_eos, rxscan223_done
  rxscan223_scan:
    set_addr $I10, rxscan223_loop
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  rxscan223_done:
  alt224_0:
.annotate 'line', 129
    set_addr $I10, alt224_1
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
.annotate 'line', 130
  # rx subrule "ws" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."ws"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
  # rxanchor eos
    ne rx218_pos, rx218_eos, rx218_fail
  # rx subrule "ws" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."ws"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
    goto alt224_end
  alt224_1:
.annotate 'line', 131
  # rx subrule "ws" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."ws"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
  # rx rxquantr228 ** 0..*
    set_addr $I10, rxquantr228_done
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  rxquantr228_loop:
  # rx subrule "statement" subtype=capture negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."statement"()
    unless $P10, rx218_fail
    rx218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx218_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."eat_terminator"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."ws"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
    set_addr $I10, rxquantr228_done
    (rx218_rep) = rx218_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr228_done
    rx218_cur."!mark_push"(rx218_rep, rx218_pos, $I10)
    goto rxquantr228_loop
  rxquantr228_done:
  # rx subrule "ws" subtype=method negate=
    rx218_cur."!cursor_pos"(rx218_pos)
    $P10 = rx218_cur."ws"()
    unless $P10, rx218_fail
    rx218_pos = $P10."pos"()
  alt224_end:
.annotate 'line', 129
  # rx pass
    rx218_cur."!cursor_pass"(rx218_pos, "statementlist")
    if_null rx218_debug, debug_661
    rx218_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx218_pos)
  debug_661:
    .return (rx218_cur)
  rx218_restart:
.annotate 'line', 10
    if_null rx218_debug, debug_662
    rx218_cur."!cursor_debug"("NEXT", "statementlist")
  debug_662:
  rx218_fail:
    (rx218_rep, rx218_pos, $I10, $P10) = rx218_cur."!mark_fail"(0)
    lt rx218_pos, -1, rx218_done
    eq rx218_pos, -1, rx218_fail
    jump $I10
  rx218_done:
    rx218_cur."!cursor_fail"()
    if_null rx218_debug, debug_663
    rx218_cur."!cursor_debug"("FAIL", "statementlist")
  debug_663:
    .return (rx218_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1303391609.928") :method
.annotate 'line', 10
    $P220 = self."!PREFIX__!subrule"("ws", "")
    $P221 = self."!PREFIX__!subrule"("ws", "")
    new $P222, "ResizablePMCArray"
    push $P222, $P220
    push $P222, $P221
    .return ($P222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P237 = "36_1303391609.928" 
    capture_lex $P237
    .local string rx232_tgt
    .local int rx232_pos
    .local int rx232_off
    .local int rx232_eos
    .local int rx232_rep
    .local pmc rx232_cur
    .local pmc rx232_debug
    (rx232_cur, rx232_pos, rx232_tgt, $I10) = self."!cursor_start"()
    rx232_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx232_cur
    .local pmc match
    .lex "$/", match
    length rx232_eos, rx232_tgt
    gt rx232_pos, rx232_eos, rx232_done
    set rx232_off, 0
    lt rx232_pos, 2, rx232_start
    sub rx232_off, rx232_pos, 1
    substr rx232_tgt, rx232_tgt, rx232_off
  rx232_start:
    eq $I10, 1, rx232_restart
    if_null rx232_debug, debug_664
    rx232_cur."!cursor_debug"("START", "statement")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan235_done
    goto rxscan235_scan
  rxscan235_loop:
    (rx232_pos) = rx232_cur."from"()
    inc rx232_pos
    rx232_cur."!cursor_from"(rx232_pos)
    ge rx232_pos, rx232_eos, rxscan235_done
  rxscan235_scan:
    set_addr $I10, rxscan235_loop
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
  rxscan235_done:
.annotate 'line', 135
  # rx subrule "before" subtype=zerowidth negate=1
    rx232_cur."!cursor_pos"(rx232_pos)
    .const 'Sub' $P237 = "36_1303391609.928" 
    capture_lex $P237
    $P10 = rx232_cur."before"($P237)
    if $P10, rx232_fail
  alt241_0:
.annotate 'line', 136
    set_addr $I10, alt241_1
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
.annotate 'line', 137
  # rx subrule "statement_control" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."statement_control"()
    unless $P10, rx232_fail
    rx232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx232_pos = $P10."pos"()
    goto alt241_end
  alt241_1:
.annotate 'line', 138
  # rx subrule "EXPR" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."EXPR"()
    unless $P10, rx232_fail
    rx232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx232_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."ws"()
    unless $P10, rx232_fail
    rx232_pos = $P10."pos"()
.annotate 'line', 143
  # rx rxquantr242 ** 0..1
    set_addr $I10, rxquantr242_done
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
  rxquantr242_loop:
  alt243_0:
.annotate 'line', 139
    set_addr $I10, alt243_1
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
.annotate 'line', 140
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."MARKED"("endstmt")
    unless $P10, rx232_fail
    goto alt243_end
  alt243_1:
    set_addr $I10, alt243_2
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
.annotate 'line', 141
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."statement_mod_cond"()
    unless $P10, rx232_fail
    rx232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx232_pos = $P10."pos"()
  # rx rxquantr244 ** 0..1
    set_addr $I10, rxquantr244_done
    rx232_cur."!mark_push"(0, rx232_pos, $I10)
  rxquantr244_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."statement_mod_loop"()
    unless $P10, rx232_fail
    goto rxsubrule245_pass
  rxsubrule245_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx232_fail
  rxsubrule245_pass:
    set_addr $I10, rxsubrule245_back
    rx232_cur."!mark_push"(0, rx232_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx232_pos = $P10."pos"()
    set_addr $I10, rxquantr244_done
    (rx232_rep) = rx232_cur."!mark_commit"($I10)
  rxquantr244_done:
    goto alt243_end
  alt243_2:
.annotate 'line', 142
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx232_cur."!cursor_pos"(rx232_pos)
    $P10 = rx232_cur."statement_mod_loop"()
    unless $P10, rx232_fail
    rx232_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx232_pos = $P10."pos"()
  alt243_end:
.annotate 'line', 143
    set_addr $I10, rxquantr242_done
    (rx232_rep) = rx232_cur."!mark_commit"($I10)
  rxquantr242_done:
  alt241_end:
.annotate 'line', 134
  # rx pass
    rx232_cur."!cursor_pass"(rx232_pos, "statement")
    if_null rx232_debug, debug_669
    rx232_cur."!cursor_debug"("PASS", "statement", " at pos=", rx232_pos)
  debug_669:
    .return (rx232_cur)
  rx232_restart:
.annotate 'line', 10
    if_null rx232_debug, debug_670
    rx232_cur."!cursor_debug"("NEXT", "statement")
  debug_670:
  rx232_fail:
    (rx232_rep, rx232_pos, $I10, $P10) = rx232_cur."!mark_fail"(0)
    lt rx232_pos, -1, rx232_done
    eq rx232_pos, -1, rx232_fail
    jump $I10
  rx232_done:
    rx232_cur."!cursor_fail"()
    if_null rx232_debug, debug_671
    rx232_cur."!cursor_debug"("FAIL", "statement")
  debug_671:
    .return (rx232_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1303391609.928") :method
.annotate 'line', 10
    new $P234, "ResizablePMCArray"
    push $P234, ""
    .return ($P234)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block236"  :anon :subid("36_1303391609.928") :method :outer("34_1303391609.928")
.annotate 'line', 135
    .local string rx238_tgt
    .local int rx238_pos
    .local int rx238_off
    .local int rx238_eos
    .local int rx238_rep
    .local pmc rx238_cur
    .local pmc rx238_debug
    (rx238_cur, rx238_pos, rx238_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx238_cur
    .local pmc match
    .lex "$/", match
    length rx238_eos, rx238_tgt
    gt rx238_pos, rx238_eos, rx238_done
    set rx238_off, 0
    lt rx238_pos, 2, rx238_start
    sub rx238_off, rx238_pos, 1
    substr rx238_tgt, rx238_tgt, rx238_off
  rx238_start:
    eq $I10, 1, rx238_restart
    if_null rx238_debug, debug_665
    rx238_cur."!cursor_debug"("START", "")
  debug_665:
    $I10 = self.'from'()
    ne $I10, -1, rxscan239_done
    goto rxscan239_scan
  rxscan239_loop:
    (rx238_pos) = rx238_cur."from"()
    inc rx238_pos
    rx238_cur."!cursor_from"(rx238_pos)
    ge rx238_pos, rx238_eos, rxscan239_done
  rxscan239_scan:
    set_addr $I10, rxscan239_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  rxscan239_done:
  alt240_0:
    set_addr $I10, alt240_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx238_fail
    inc rx238_pos
    goto alt240_end
  alt240_1:
  # rxanchor eos
    ne rx238_pos, rx238_eos, rx238_fail
  alt240_end:
  # rx pass
    rx238_cur."!cursor_pass"(rx238_pos, "")
    if_null rx238_debug, debug_666
    rx238_cur."!cursor_debug"("PASS", "", " at pos=", rx238_pos)
  debug_666:
    .return (rx238_cur)
  rx238_restart:
    if_null rx238_debug, debug_667
    rx238_cur."!cursor_debug"("NEXT", "")
  debug_667:
  rx238_fail:
    (rx238_rep, rx238_pos, $I10, $P10) = rx238_cur."!mark_fail"(0)
    lt rx238_pos, -1, rx238_done
    eq rx238_pos, -1, rx238_fail
    jump $I10
  rx238_done:
    rx238_cur."!cursor_fail"()
    if_null rx238_debug, debug_668
    rx238_cur."!cursor_debug"("FAIL", "")
  debug_668:
    .return (rx238_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx247_tgt
    .local int rx247_pos
    .local int rx247_off
    .local int rx247_eos
    .local int rx247_rep
    .local pmc rx247_cur
    .local pmc rx247_debug
    (rx247_cur, rx247_pos, rx247_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx247_cur
    .local pmc match
    .lex "$/", match
    length rx247_eos, rx247_tgt
    gt rx247_pos, rx247_eos, rx247_done
    set rx247_off, 0
    lt rx247_pos, 2, rx247_start
    sub rx247_off, rx247_pos, 1
    substr rx247_tgt, rx247_tgt, rx247_off
  rx247_start:
    eq $I10, 1, rx247_restart
    if_null rx247_debug, debug_672
    rx247_cur."!cursor_debug"("START", "eat_terminator")
  debug_672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan250_done
    goto rxscan250_scan
  rxscan250_loop:
    (rx247_pos) = rx247_cur."from"()
    inc rx247_pos
    rx247_cur."!cursor_from"(rx247_pos)
    ge rx247_pos, rx247_eos, rxscan250_done
  rxscan250_scan:
    set_addr $I10, rxscan250_loop
    rx247_cur."!mark_push"(0, rx247_pos, $I10)
  rxscan250_done:
  alt251_0:
.annotate 'line', 147
    set_addr $I10, alt251_1
    rx247_cur."!mark_push"(0, rx247_pos, $I10)
.annotate 'line', 148
  # rx literal  ";"
    add $I11, rx247_pos, 1
    gt $I11, rx247_eos, rx247_fail
    sub $I11, rx247_pos, rx247_off
    ord $I11, rx247_tgt, $I11
    ne $I11, 59, rx247_fail
    add rx247_pos, 1
    goto alt251_end
  alt251_1:
    set_addr $I10, alt251_2
    rx247_cur."!mark_push"(0, rx247_pos, $I10)
.annotate 'line', 149
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx247_cur."!cursor_pos"(rx247_pos)
    $P10 = rx247_cur."MARKED"("endstmt")
    unless $P10, rx247_fail
    goto alt251_end
  alt251_2:
    set_addr $I10, alt251_3
    rx247_cur."!mark_push"(0, rx247_pos, $I10)
.annotate 'line', 150
  # rx subrule "terminator" subtype=zerowidth negate=
    rx247_cur."!cursor_pos"(rx247_pos)
    $P10 = rx247_cur."terminator"()
    unless $P10, rx247_fail
    goto alt251_end
  alt251_3:
.annotate 'line', 151
  # rxanchor eos
    ne rx247_pos, rx247_eos, rx247_fail
  alt251_end:
.annotate 'line', 147
  # rx pass
    rx247_cur."!cursor_pass"(rx247_pos, "eat_terminator")
    if_null rx247_debug, debug_673
    rx247_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx247_pos)
  debug_673:
    .return (rx247_cur)
  rx247_restart:
.annotate 'line', 10
    if_null rx247_debug, debug_674
    rx247_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_674:
  rx247_fail:
    (rx247_rep, rx247_pos, $I10, $P10) = rx247_cur."!mark_fail"(0)
    lt rx247_pos, -1, rx247_done
    eq rx247_pos, -1, rx247_fail
    jump $I10
  rx247_done:
    rx247_cur."!cursor_fail"()
    if_null rx247_debug, debug_675
    rx247_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_675:
    .return (rx247_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1303391609.928") :method
.annotate 'line', 10
    new $P249, "ResizablePMCArray"
    push $P249, ""
    push $P249, ""
    push $P249, ""
    push $P249, ";"
    .return ($P249)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx253_tgt
    .local int rx253_pos
    .local int rx253_off
    .local int rx253_eos
    .local int rx253_rep
    .local pmc rx253_cur
    .local pmc rx253_debug
    (rx253_cur, rx253_pos, rx253_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx253_cur
    .local pmc match
    .lex "$/", match
    length rx253_eos, rx253_tgt
    gt rx253_pos, rx253_eos, rx253_done
    set rx253_off, 0
    lt rx253_pos, 2, rx253_start
    sub rx253_off, rx253_pos, 1
    substr rx253_tgt, rx253_tgt, rx253_off
  rx253_start:
    eq $I10, 1, rx253_restart
    if_null rx253_debug, debug_676
    rx253_cur."!cursor_debug"("START", "xblock")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan257_done
    goto rxscan257_scan
  rxscan257_loop:
    (rx253_pos) = rx253_cur."from"()
    inc rx253_pos
    rx253_cur."!cursor_from"(rx253_pos)
    ge rx253_pos, rx253_eos, rxscan257_done
  rxscan257_scan:
    set_addr $I10, rxscan257_loop
    rx253_cur."!mark_push"(0, rx253_pos, $I10)
  rxscan257_done:
.annotate 'line', 155
  # rx subrule "EXPR" subtype=capture negate=
    rx253_cur."!cursor_pos"(rx253_pos)
    $P10 = rx253_cur."EXPR"()
    unless $P10, rx253_fail
    rx253_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx253_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx253_cur."!cursor_pos"(rx253_pos)
    $P10 = rx253_cur."ws"()
    unless $P10, rx253_fail
    rx253_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx253_cur."!cursor_pos"(rx253_pos)
    $P10 = rx253_cur."pblock"()
    unless $P10, rx253_fail
    rx253_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx253_pos = $P10."pos"()
.annotate 'line', 154
  # rx pass
    rx253_cur."!cursor_pass"(rx253_pos, "xblock")
    if_null rx253_debug, debug_677
    rx253_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx253_pos)
  debug_677:
    .return (rx253_cur)
  rx253_restart:
.annotate 'line', 10
    if_null rx253_debug, debug_678
    rx253_cur."!cursor_debug"("NEXT", "xblock")
  debug_678:
  rx253_fail:
    (rx253_rep, rx253_pos, $I10, $P10) = rx253_cur."!mark_fail"(0)
    lt rx253_pos, -1, rx253_done
    eq rx253_pos, -1, rx253_fail
    jump $I10
  rx253_done:
    rx253_cur."!cursor_fail"()
    if_null rx253_debug, debug_679
    rx253_cur."!cursor_debug"("FAIL", "xblock")
  debug_679:
    .return (rx253_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1303391609.928") :method
.annotate 'line', 10
    $P255 = self."!PREFIX__!subrule"("EXPR", "")
    new $P256, "ResizablePMCArray"
    push $P256, $P255
    .return ($P256)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx259_tgt
    .local int rx259_pos
    .local int rx259_off
    .local int rx259_eos
    .local int rx259_rep
    .local pmc rx259_cur
    .local pmc rx259_debug
    (rx259_cur, rx259_pos, rx259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx259_cur
    .local pmc match
    .lex "$/", match
    length rx259_eos, rx259_tgt
    gt rx259_pos, rx259_eos, rx259_done
    set rx259_off, 0
    lt rx259_pos, 2, rx259_start
    sub rx259_off, rx259_pos, 1
    substr rx259_tgt, rx259_tgt, rx259_off
  rx259_start:
    eq $I10, 1, rx259_restart
    if_null rx259_debug, debug_680
    rx259_cur."!cursor_debug"("START", "pblock")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan264_done
    goto rxscan264_scan
  rxscan264_loop:
    (rx259_pos) = rx259_cur."from"()
    inc rx259_pos
    rx259_cur."!cursor_from"(rx259_pos)
    ge rx259_pos, rx259_eos, rxscan264_done
  rxscan264_scan:
    set_addr $I10, rxscan264_loop
    rx259_cur."!mark_push"(0, rx259_pos, $I10)
  rxscan264_done:
  alt265_0:
.annotate 'line', 158
    set_addr $I10, alt265_1
    rx259_cur."!mark_push"(0, rx259_pos, $I10)
.annotate 'line', 159
  # rx subrule "lambda" subtype=method negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."lambda"()
    unless $P10, rx259_fail
    rx259_pos = $P10."pos"()
.annotate 'line', 160
  # rx subrule "newpad" subtype=method negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."newpad"()
    unless $P10, rx259_fail
    rx259_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "signature" subtype=capture negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."signature"()
    unless $P10, rx259_fail
    rx259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx259_pos = $P10."pos"()
.annotate 'line', 162
  # rx subrule "blockoid" subtype=capture negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."blockoid"()
    unless $P10, rx259_fail
    rx259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx259_pos = $P10."pos"()
.annotate 'line', 159
    goto alt265_end
  alt265_1:
    set_addr $I10, alt265_2
    rx259_cur."!mark_push"(0, rx259_pos, $I10)
.annotate 'line', 163
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx259_pos, rx259_off
    substr $S10, rx259_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx259_fail
.annotate 'line', 164
  # rx subrule "newpad" subtype=method negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."newpad"()
    unless $P10, rx259_fail
    rx259_pos = $P10."pos"()
.annotate 'line', 165
  # rx subrule "blockoid" subtype=capture negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."blockoid"()
    unless $P10, rx259_fail
    rx259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx259_pos = $P10."pos"()
.annotate 'line', 163
    goto alt265_end
  alt265_2:
.annotate 'line', 166
  # rx subrule "panic" subtype=method negate=
    rx259_cur."!cursor_pos"(rx259_pos)
    $P10 = rx259_cur."panic"("Missing block")
    unless $P10, rx259_fail
    rx259_pos = $P10."pos"()
  alt265_end:
.annotate 'line', 158
  # rx pass
    rx259_cur."!cursor_pass"(rx259_pos, "pblock")
    if_null rx259_debug, debug_681
    rx259_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx259_pos)
  debug_681:
    .return (rx259_cur)
  rx259_restart:
.annotate 'line', 10
    if_null rx259_debug, debug_682
    rx259_cur."!cursor_debug"("NEXT", "pblock")
  debug_682:
  rx259_fail:
    (rx259_rep, rx259_pos, $I10, $P10) = rx259_cur."!mark_fail"(0)
    lt rx259_pos, -1, rx259_done
    eq rx259_pos, -1, rx259_fail
    jump $I10
  rx259_done:
    rx259_cur."!cursor_fail"()
    if_null rx259_debug, debug_683
    rx259_cur."!cursor_debug"("FAIL", "pblock")
  debug_683:
    .return (rx259_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1303391609.928") :method
.annotate 'line', 10
    $P261 = self."!PREFIX__!subrule"("panic", "")
    $P262 = self."!PREFIX__!subrule"("lambda", "")
    new $P263, "ResizablePMCArray"
    push $P263, $P261
    push $P263, "{"
    push $P263, $P262
    .return ($P263)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx267_tgt
    .local int rx267_pos
    .local int rx267_off
    .local int rx267_eos
    .local int rx267_rep
    .local pmc rx267_cur
    .local pmc rx267_debug
    (rx267_cur, rx267_pos, rx267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx267_cur
    .local pmc match
    .lex "$/", match
    length rx267_eos, rx267_tgt
    gt rx267_pos, rx267_eos, rx267_done
    set rx267_off, 0
    lt rx267_pos, 2, rx267_start
    sub rx267_off, rx267_pos, 1
    substr rx267_tgt, rx267_tgt, rx267_off
  rx267_start:
    eq $I10, 1, rx267_restart
    if_null rx267_debug, debug_684
    rx267_cur."!cursor_debug"("START", "lambda")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan270_done
    goto rxscan270_scan
  rxscan270_loop:
    (rx267_pos) = rx267_cur."from"()
    inc rx267_pos
    rx267_cur."!cursor_from"(rx267_pos)
    ge rx267_pos, rx267_eos, rxscan270_done
  rxscan270_scan:
    set_addr $I10, rxscan270_loop
    rx267_cur."!mark_push"(0, rx267_pos, $I10)
  rxscan270_done:
  alt271_0:
.annotate 'line', 169
    set_addr $I10, alt271_1
    rx267_cur."!mark_push"(0, rx267_pos, $I10)
  # rx literal  "->"
    add $I11, rx267_pos, 2
    gt $I11, rx267_eos, rx267_fail
    sub $I11, rx267_pos, rx267_off
    substr $S10, rx267_tgt, $I11, 2
    ne $S10, "->", rx267_fail
    add rx267_pos, 2
    goto alt271_end
  alt271_1:
  # rx literal  "<->"
    add $I11, rx267_pos, 3
    gt $I11, rx267_eos, rx267_fail
    sub $I11, rx267_pos, rx267_off
    substr $S10, rx267_tgt, $I11, 3
    ne $S10, "<->", rx267_fail
    add rx267_pos, 3
  alt271_end:
  # rx pass
    rx267_cur."!cursor_pass"(rx267_pos, "lambda")
    if_null rx267_debug, debug_685
    rx267_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx267_pos)
  debug_685:
    .return (rx267_cur)
  rx267_restart:
.annotate 'line', 10
    if_null rx267_debug, debug_686
    rx267_cur."!cursor_debug"("NEXT", "lambda")
  debug_686:
  rx267_fail:
    (rx267_rep, rx267_pos, $I10, $P10) = rx267_cur."!mark_fail"(0)
    lt rx267_pos, -1, rx267_done
    eq rx267_pos, -1, rx267_fail
    jump $I10
  rx267_done:
    rx267_cur."!cursor_fail"()
    if_null rx267_debug, debug_687
    rx267_cur."!cursor_debug"("FAIL", "lambda")
  debug_687:
    .return (rx267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1303391609.928") :method
.annotate 'line', 10
    new $P269, "ResizablePMCArray"
    push $P269, "<->"
    push $P269, "->"
    .return ($P269)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx273_tgt
    .local int rx273_pos
    .local int rx273_off
    .local int rx273_eos
    .local int rx273_rep
    .local pmc rx273_cur
    .local pmc rx273_debug
    (rx273_cur, rx273_pos, rx273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx273_cur
    .local pmc match
    .lex "$/", match
    length rx273_eos, rx273_tgt
    gt rx273_pos, rx273_eos, rx273_done
    set rx273_off, 0
    lt rx273_pos, 2, rx273_start
    sub rx273_off, rx273_pos, 1
    substr rx273_tgt, rx273_tgt, rx273_off
  rx273_start:
    eq $I10, 1, rx273_restart
    if_null rx273_debug, debug_688
    rx273_cur."!cursor_debug"("START", "block")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan277_done
    goto rxscan277_scan
  rxscan277_loop:
    (rx273_pos) = rx273_cur."from"()
    inc rx273_pos
    rx273_cur."!cursor_from"(rx273_pos)
    ge rx273_pos, rx273_eos, rxscan277_done
  rxscan277_scan:
    set_addr $I10, rxscan277_loop
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  rxscan277_done:
  alt278_0:
.annotate 'line', 172
    set_addr $I10, alt278_1
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx273_pos, rx273_off
    substr $S10, rx273_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx273_fail
    goto alt278_end
  alt278_1:
  # rx subrule "panic" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."panic"("Missing block")
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
  alt278_end:
.annotate 'line', 173
  # rx subrule "newpad" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."newpad"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
.annotate 'line', 174
  # rx subrule "blockoid" subtype=capture negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."blockoid"()
    unless $P10, rx273_fail
    rx273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx273_pos = $P10."pos"()
.annotate 'line', 171
  # rx pass
    rx273_cur."!cursor_pass"(rx273_pos, "block")
    if_null rx273_debug, debug_689
    rx273_cur."!cursor_debug"("PASS", "block", " at pos=", rx273_pos)
  debug_689:
    .return (rx273_cur)
  rx273_restart:
.annotate 'line', 10
    if_null rx273_debug, debug_690
    rx273_cur."!cursor_debug"("NEXT", "block")
  debug_690:
  rx273_fail:
    (rx273_rep, rx273_pos, $I10, $P10) = rx273_cur."!mark_fail"(0)
    lt rx273_pos, -1, rx273_done
    eq rx273_pos, -1, rx273_fail
    jump $I10
  rx273_done:
    rx273_cur."!cursor_fail"()
    if_null rx273_debug, debug_691
    rx273_cur."!cursor_debug"("FAIL", "block")
  debug_691:
    .return (rx273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1303391609.928") :method
.annotate 'line', 10
    $P275 = self."!PREFIX__!subrule"("panic", "")
    new $P276, "ResizablePMCArray"
    push $P276, $P275
    push $P276, "{"
    .return ($P276)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx280_tgt
    .local int rx280_pos
    .local int rx280_off
    .local int rx280_eos
    .local int rx280_rep
    .local pmc rx280_cur
    .local pmc rx280_debug
    (rx280_cur, rx280_pos, rx280_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx280_cur
    .local pmc match
    .lex "$/", match
    length rx280_eos, rx280_tgt
    gt rx280_pos, rx280_eos, rx280_done
    set rx280_off, 0
    lt rx280_pos, 2, rx280_start
    sub rx280_off, rx280_pos, 1
    substr rx280_tgt, rx280_tgt, rx280_off
  rx280_start:
    eq $I10, 1, rx280_restart
    if_null rx280_debug, debug_692
    rx280_cur."!cursor_debug"("START", "blockoid")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan284_done
    goto rxscan284_scan
  rxscan284_loop:
    (rx280_pos) = rx280_cur."from"()
    inc rx280_pos
    rx280_cur."!cursor_from"(rx280_pos)
    ge rx280_pos, rx280_eos, rxscan284_done
  rxscan284_scan:
    set_addr $I10, rxscan284_loop
    rx280_cur."!mark_push"(0, rx280_pos, $I10)
  rxscan284_done:
.annotate 'line', 178
  # rx subrule "finishpad" subtype=method negate=
    rx280_cur."!cursor_pos"(rx280_pos)
    $P10 = rx280_cur."finishpad"()
    unless $P10, rx280_fail
    rx280_pos = $P10."pos"()
  alt285_0:
.annotate 'line', 179
    set_addr $I10, alt285_1
    rx280_cur."!mark_push"(0, rx280_pos, $I10)
.annotate 'line', 180
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx280_pos, 14
    gt $I11, rx280_eos, rx280_fail
    sub $I11, rx280_pos, rx280_off
    substr $S10, rx280_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx280_fail
    add rx280_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx280_cur."!cursor_pos"(rx280_pos)
    $P10 = rx280_cur."you_are_here"()
    unless $P10, rx280_fail
    rx280_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx280_pos = $P10."pos"()
    goto alt285_end
  alt285_1:
.annotate 'line', 181
  # rx literal  "{"
    add $I11, rx280_pos, 1
    gt $I11, rx280_eos, rx280_fail
    sub $I11, rx280_pos, rx280_off
    ord $I11, rx280_tgt, $I11
    ne $I11, 123, rx280_fail
    add rx280_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx280_cur."!cursor_pos"(rx280_pos)
    $P10 = rx280_cur."statementlist"()
    unless $P10, rx280_fail
    rx280_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx280_pos = $P10."pos"()
  alt286_0:
    set_addr $I10, alt286_1
    rx280_cur."!mark_push"(0, rx280_pos, $I10)
  # rx literal  "}"
    add $I11, rx280_pos, 1
    gt $I11, rx280_eos, rx280_fail
    sub $I11, rx280_pos, rx280_off
    ord $I11, rx280_tgt, $I11
    ne $I11, 125, rx280_fail
    add rx280_pos, 1
    goto alt286_end
  alt286_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx280_cur."!cursor_pos"(rx280_pos)
    $P10 = rx280_cur."FAILGOAL"("'}'")
    unless $P10, rx280_fail
    goto rxsubrule288_pass
  rxsubrule288_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx280_fail
  rxsubrule288_pass:
    set_addr $I10, rxsubrule288_back
    rx280_cur."!mark_push"(0, rx280_pos, $I10, $P10)
    rx280_pos = $P10."pos"()
  alt286_end:
  alt285_end:
.annotate 'line', 183
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx280_cur."!cursor_pos"(rx280_pos)
    $P10 = rx280_cur."ENDSTMT"()
    unless $P10, rx280_fail
.annotate 'line', 177
  # rx pass
    rx280_cur."!cursor_pass"(rx280_pos, "blockoid")
    if_null rx280_debug, debug_693
    rx280_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx280_pos)
  debug_693:
    .return (rx280_cur)
  rx280_restart:
.annotate 'line', 10
    if_null rx280_debug, debug_694
    rx280_cur."!cursor_debug"("NEXT", "blockoid")
  debug_694:
  rx280_fail:
    (rx280_rep, rx280_pos, $I10, $P10) = rx280_cur."!mark_fail"(0)
    lt rx280_pos, -1, rx280_done
    eq rx280_pos, -1, rx280_fail
    jump $I10
  rx280_done:
    rx280_cur."!cursor_fail"()
    if_null rx280_debug, debug_695
    rx280_cur."!cursor_debug"("FAIL", "blockoid")
  debug_695:
    .return (rx280_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1303391609.928") :method
.annotate 'line', 10
    $P282 = self."!PREFIX__!subrule"("finishpad", "")
    new $P283, "ResizablePMCArray"
    push $P283, $P282
    .return ($P283)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx290_tgt
    .local int rx290_pos
    .local int rx290_off
    .local int rx290_eos
    .local int rx290_rep
    .local pmc rx290_cur
    .local pmc rx290_debug
    (rx290_cur, rx290_pos, rx290_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx290_cur
    .local pmc match
    .lex "$/", match
    length rx290_eos, rx290_tgt
    gt rx290_pos, rx290_eos, rx290_done
    set rx290_off, 0
    lt rx290_pos, 2, rx290_start
    sub rx290_off, rx290_pos, 1
    substr rx290_tgt, rx290_tgt, rx290_off
  rx290_start:
    eq $I10, 1, rx290_restart
    if_null rx290_debug, debug_696
    rx290_cur."!cursor_debug"("START", "newpad")
  debug_696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan293_done
    goto rxscan293_scan
  rxscan293_loop:
    (rx290_pos) = rx290_cur."from"()
    inc rx290_pos
    rx290_cur."!cursor_from"(rx290_pos)
    ge rx290_pos, rx290_eos, rxscan293_done
  rxscan293_scan:
    set_addr $I10, rxscan293_loop
    rx290_cur."!mark_push"(0, rx290_pos, $I10)
  rxscan293_done:
.annotate 'line', 186
  # rx pass
    rx290_cur."!cursor_pass"(rx290_pos, "newpad")
    if_null rx290_debug, debug_697
    rx290_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx290_pos)
  debug_697:
    .return (rx290_cur)
  rx290_restart:
.annotate 'line', 10
    if_null rx290_debug, debug_698
    rx290_cur."!cursor_debug"("NEXT", "newpad")
  debug_698:
  rx290_fail:
    (rx290_rep, rx290_pos, $I10, $P10) = rx290_cur."!mark_fail"(0)
    lt rx290_pos, -1, rx290_done
    eq rx290_pos, -1, rx290_fail
    jump $I10
  rx290_done:
    rx290_cur."!cursor_fail"()
    if_null rx290_debug, debug_699
    rx290_cur."!cursor_debug"("FAIL", "newpad")
  debug_699:
    .return (rx290_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1303391609.928") :method
.annotate 'line', 10
    new $P292, "ResizablePMCArray"
    push $P292, ""
    .return ($P292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx295_tgt
    .local int rx295_pos
    .local int rx295_off
    .local int rx295_eos
    .local int rx295_rep
    .local pmc rx295_cur
    .local pmc rx295_debug
    (rx295_cur, rx295_pos, rx295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx295_cur
    .local pmc match
    .lex "$/", match
    length rx295_eos, rx295_tgt
    gt rx295_pos, rx295_eos, rx295_done
    set rx295_off, 0
    lt rx295_pos, 2, rx295_start
    sub rx295_off, rx295_pos, 1
    substr rx295_tgt, rx295_tgt, rx295_off
  rx295_start:
    eq $I10, 1, rx295_restart
    if_null rx295_debug, debug_700
    rx295_cur."!cursor_debug"("START", "outerctx")
  debug_700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan298_done
    goto rxscan298_scan
  rxscan298_loop:
    (rx295_pos) = rx295_cur."from"()
    inc rx295_pos
    rx295_cur."!cursor_from"(rx295_pos)
    ge rx295_pos, rx295_eos, rxscan298_done
  rxscan298_scan:
    set_addr $I10, rxscan298_loop
    rx295_cur."!mark_push"(0, rx295_pos, $I10)
  rxscan298_done:
.annotate 'line', 187
  # rx pass
    rx295_cur."!cursor_pass"(rx295_pos, "outerctx")
    if_null rx295_debug, debug_701
    rx295_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx295_pos)
  debug_701:
    .return (rx295_cur)
  rx295_restart:
.annotate 'line', 10
    if_null rx295_debug, debug_702
    rx295_cur."!cursor_debug"("NEXT", "outerctx")
  debug_702:
  rx295_fail:
    (rx295_rep, rx295_pos, $I10, $P10) = rx295_cur."!mark_fail"(0)
    lt rx295_pos, -1, rx295_done
    eq rx295_pos, -1, rx295_fail
    jump $I10
  rx295_done:
    rx295_cur."!cursor_fail"()
    if_null rx295_debug, debug_703
    rx295_cur."!cursor_debug"("FAIL", "outerctx")
  debug_703:
    .return (rx295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1303391609.928") :method
.annotate 'line', 10
    new $P297, "ResizablePMCArray"
    push $P297, ""
    .return ($P297)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx300_tgt
    .local int rx300_pos
    .local int rx300_off
    .local int rx300_eos
    .local int rx300_rep
    .local pmc rx300_cur
    .local pmc rx300_debug
    (rx300_cur, rx300_pos, rx300_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx300_cur
    .local pmc match
    .lex "$/", match
    length rx300_eos, rx300_tgt
    gt rx300_pos, rx300_eos, rx300_done
    set rx300_off, 0
    lt rx300_pos, 2, rx300_start
    sub rx300_off, rx300_pos, 1
    substr rx300_tgt, rx300_tgt, rx300_off
  rx300_start:
    eq $I10, 1, rx300_restart
    if_null rx300_debug, debug_704
    rx300_cur."!cursor_debug"("START", "GLOBALish")
  debug_704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan303_done
    goto rxscan303_scan
  rxscan303_loop:
    (rx300_pos) = rx300_cur."from"()
    inc rx300_pos
    rx300_cur."!cursor_from"(rx300_pos)
    ge rx300_pos, rx300_eos, rxscan303_done
  rxscan303_scan:
    set_addr $I10, rxscan303_loop
    rx300_cur."!mark_push"(0, rx300_pos, $I10)
  rxscan303_done:
.annotate 'line', 188
  # rx pass
    rx300_cur."!cursor_pass"(rx300_pos, "GLOBALish")
    if_null rx300_debug, debug_705
    rx300_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx300_pos)
  debug_705:
    .return (rx300_cur)
  rx300_restart:
.annotate 'line', 10
    if_null rx300_debug, debug_706
    rx300_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_706:
  rx300_fail:
    (rx300_rep, rx300_pos, $I10, $P10) = rx300_cur."!mark_fail"(0)
    lt rx300_pos, -1, rx300_done
    eq rx300_pos, -1, rx300_fail
    jump $I10
  rx300_done:
    rx300_cur."!cursor_fail"()
    if_null rx300_debug, debug_707
    rx300_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_707:
    .return (rx300_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1303391609.928") :method
.annotate 'line', 10
    new $P302, "ResizablePMCArray"
    push $P302, ""
    .return ($P302)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx305_tgt
    .local int rx305_pos
    .local int rx305_off
    .local int rx305_eos
    .local int rx305_rep
    .local pmc rx305_cur
    .local pmc rx305_debug
    (rx305_cur, rx305_pos, rx305_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx305_cur
    .local pmc match
    .lex "$/", match
    length rx305_eos, rx305_tgt
    gt rx305_pos, rx305_eos, rx305_done
    set rx305_off, 0
    lt rx305_pos, 2, rx305_start
    sub rx305_off, rx305_pos, 1
    substr rx305_tgt, rx305_tgt, rx305_off
  rx305_start:
    eq $I10, 1, rx305_restart
    if_null rx305_debug, debug_708
    rx305_cur."!cursor_debug"("START", "finishpad")
  debug_708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan308_done
    goto rxscan308_scan
  rxscan308_loop:
    (rx305_pos) = rx305_cur."from"()
    inc rx305_pos
    rx305_cur."!cursor_from"(rx305_pos)
    ge rx305_pos, rx305_eos, rxscan308_done
  rxscan308_scan:
    set_addr $I10, rxscan308_loop
    rx305_cur."!mark_push"(0, rx305_pos, $I10)
  rxscan308_done:
.annotate 'line', 189
  # rx pass
    rx305_cur."!cursor_pass"(rx305_pos, "finishpad")
    if_null rx305_debug, debug_709
    rx305_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx305_pos)
  debug_709:
    .return (rx305_cur)
  rx305_restart:
.annotate 'line', 10
    if_null rx305_debug, debug_710
    rx305_cur."!cursor_debug"("NEXT", "finishpad")
  debug_710:
  rx305_fail:
    (rx305_rep, rx305_pos, $I10, $P10) = rx305_cur."!mark_fail"(0)
    lt rx305_pos, -1, rx305_done
    eq rx305_pos, -1, rx305_fail
    jump $I10
  rx305_done:
    rx305_cur."!cursor_fail"()
    if_null rx305_debug, debug_711
    rx305_cur."!cursor_debug"("FAIL", "finishpad")
  debug_711:
    .return (rx305_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1303391609.928") :method
.annotate 'line', 10
    new $P307, "ResizablePMCArray"
    push $P307, ""
    .return ($P307)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx310_tgt
    .local int rx310_pos
    .local int rx310_off
    .local int rx310_eos
    .local int rx310_rep
    .local pmc rx310_cur
    .local pmc rx310_debug
    (rx310_cur, rx310_pos, rx310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx310_cur
    .local pmc match
    .lex "$/", match
    length rx310_eos, rx310_tgt
    gt rx310_pos, rx310_eos, rx310_done
    set rx310_off, 0
    lt rx310_pos, 2, rx310_start
    sub rx310_off, rx310_pos, 1
    substr rx310_tgt, rx310_tgt, rx310_off
  rx310_start:
    eq $I10, 1, rx310_restart
    if_null rx310_debug, debug_712
    rx310_cur."!cursor_debug"("START", "you_are_here")
  debug_712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan313_done
    goto rxscan313_scan
  rxscan313_loop:
    (rx310_pos) = rx310_cur."from"()
    inc rx310_pos
    rx310_cur."!cursor_from"(rx310_pos)
    ge rx310_pos, rx310_eos, rxscan313_done
  rxscan313_scan:
    set_addr $I10, rxscan313_loop
    rx310_cur."!mark_push"(0, rx310_pos, $I10)
  rxscan313_done:
.annotate 'line', 190
  # rx pass
    rx310_cur."!cursor_pass"(rx310_pos, "you_are_here")
    if_null rx310_debug, debug_713
    rx310_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx310_pos)
  debug_713:
    .return (rx310_cur)
  rx310_restart:
.annotate 'line', 10
    if_null rx310_debug, debug_714
    rx310_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_714:
  rx310_fail:
    (rx310_rep, rx310_pos, $I10, $P10) = rx310_cur."!mark_fail"(0)
    lt rx310_pos, -1, rx310_done
    eq rx310_pos, -1, rx310_fail
    jump $I10
  rx310_done:
    rx310_cur."!cursor_fail"()
    if_null rx310_debug, debug_715
    rx310_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_715:
    .return (rx310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1303391609.928") :method
.annotate 'line', 10
    new $P312, "ResizablePMCArray"
    push $P312, ""
    .return ($P312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1303391609.928")
    .param pmc param_315
.annotate 'line', 192
    .lex "self", param_315
    $P316 = param_315."!protoregex"("terminator")
    .return ($P316)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1303391609.928")
    .param pmc param_318
.annotate 'line', 192
    .lex "self", param_318
    $P319 = param_318."!PREFIX__!protoregex"("terminator")
    .return ($P319)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx321_tgt
    .local int rx321_pos
    .local int rx321_off
    .local int rx321_eos
    .local int rx321_rep
    .local pmc rx321_cur
    .local pmc rx321_debug
    (rx321_cur, rx321_pos, rx321_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx321_cur
    .local pmc match
    .lex "$/", match
    length rx321_eos, rx321_tgt
    gt rx321_pos, rx321_eos, rx321_done
    set rx321_off, 0
    lt rx321_pos, 2, rx321_start
    sub rx321_off, rx321_pos, 1
    substr rx321_tgt, rx321_tgt, rx321_off
  rx321_start:
    eq $I10, 1, rx321_restart
    if_null rx321_debug, debug_716
    rx321_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_716:
    $I10 = self.'from'()
    ne $I10, -1, rxscan324_done
    goto rxscan324_scan
  rxscan324_loop:
    (rx321_pos) = rx321_cur."from"()
    inc rx321_pos
    rx321_cur."!cursor_from"(rx321_pos)
    ge rx321_pos, rx321_eos, rxscan324_done
  rxscan324_scan:
    set_addr $I10, rxscan324_loop
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
  rxscan324_done:
.annotate 'line', 194
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx321_pos, rx321_off
    substr $S10, rx321_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx321_fail
  # rx pass
    rx321_cur."!cursor_pass"(rx321_pos, "terminator:sym<;>")
    if_null rx321_debug, debug_717
    rx321_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx321_pos)
  debug_717:
    .return (rx321_cur)
  rx321_restart:
.annotate 'line', 10
    if_null rx321_debug, debug_718
    rx321_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_718:
  rx321_fail:
    (rx321_rep, rx321_pos, $I10, $P10) = rx321_cur."!mark_fail"(0)
    lt rx321_pos, -1, rx321_done
    eq rx321_pos, -1, rx321_fail
    jump $I10
  rx321_done:
    rx321_cur."!cursor_fail"()
    if_null rx321_debug, debug_719
    rx321_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_719:
    .return (rx321_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1303391609.928") :method
.annotate 'line', 10
    new $P323, "ResizablePMCArray"
    push $P323, ";"
    .return ($P323)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx326_tgt
    .local int rx326_pos
    .local int rx326_off
    .local int rx326_eos
    .local int rx326_rep
    .local pmc rx326_cur
    .local pmc rx326_debug
    (rx326_cur, rx326_pos, rx326_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx326_cur
    .local pmc match
    .lex "$/", match
    length rx326_eos, rx326_tgt
    gt rx326_pos, rx326_eos, rx326_done
    set rx326_off, 0
    lt rx326_pos, 2, rx326_start
    sub rx326_off, rx326_pos, 1
    substr rx326_tgt, rx326_tgt, rx326_off
  rx326_start:
    eq $I10, 1, rx326_restart
    if_null rx326_debug, debug_720
    rx326_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_720:
    $I10 = self.'from'()
    ne $I10, -1, rxscan329_done
    goto rxscan329_scan
  rxscan329_loop:
    (rx326_pos) = rx326_cur."from"()
    inc rx326_pos
    rx326_cur."!cursor_from"(rx326_pos)
    ge rx326_pos, rx326_eos, rxscan329_done
  rxscan329_scan:
    set_addr $I10, rxscan329_loop
    rx326_cur."!mark_push"(0, rx326_pos, $I10)
  rxscan329_done:
.annotate 'line', 195
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx326_pos, rx326_off
    substr $S10, rx326_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx326_fail
  # rx pass
    rx326_cur."!cursor_pass"(rx326_pos, "terminator:sym<}>")
    if_null rx326_debug, debug_721
    rx326_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx326_pos)
  debug_721:
    .return (rx326_cur)
  rx326_restart:
.annotate 'line', 10
    if_null rx326_debug, debug_722
    rx326_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_722:
  rx326_fail:
    (rx326_rep, rx326_pos, $I10, $P10) = rx326_cur."!mark_fail"(0)
    lt rx326_pos, -1, rx326_done
    eq rx326_pos, -1, rx326_fail
    jump $I10
  rx326_done:
    rx326_cur."!cursor_fail"()
    if_null rx326_debug, debug_723
    rx326_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_723:
    .return (rx326_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1303391609.928") :method
.annotate 'line', 10
    new $P328, "ResizablePMCArray"
    push $P328, "}"
    .return ($P328)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1303391609.928")
    .param pmc param_331
.annotate 'line', 199
    .lex "self", param_331
    $P332 = param_331."!protoregex"("statement_control")
    .return ($P332)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1303391609.928")
    .param pmc param_334
.annotate 'line', 199
    .lex "self", param_334
    $P335 = param_334."!PREFIX__!protoregex"("statement_control")
    .return ($P335)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx337_tgt
    .local int rx337_pos
    .local int rx337_off
    .local int rx337_eos
    .local int rx337_rep
    .local pmc rx337_cur
    .local pmc rx337_debug
    (rx337_cur, rx337_pos, rx337_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx337_cur
    .local pmc match
    .lex "$/", match
    length rx337_eos, rx337_tgt
    gt rx337_pos, rx337_eos, rx337_done
    set rx337_off, 0
    lt rx337_pos, 2, rx337_start
    sub rx337_off, rx337_pos, 1
    substr rx337_tgt, rx337_tgt, rx337_off
  rx337_start:
    eq $I10, 1, rx337_restart
    if_null rx337_debug, debug_724
    rx337_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan340_done
    goto rxscan340_scan
  rxscan340_loop:
    (rx337_pos) = rx337_cur."from"()
    inc rx337_pos
    rx337_cur."!cursor_from"(rx337_pos)
    ge rx337_pos, rx337_eos, rxscan340_done
  rxscan340_scan:
    set_addr $I10, rxscan340_loop
    rx337_cur."!mark_push"(0, rx337_pos, $I10)
  rxscan340_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_341_fail
    rx337_cur."!mark_push"(0, rx337_pos, $I10)
  # rx literal  "use"
    add $I11, rx337_pos, 3
    gt $I11, rx337_eos, rx337_fail
    sub $I11, rx337_pos, rx337_off
    substr $S10, rx337_tgt, $I11, 3
    ne $S10, "use", rx337_fail
    add rx337_pos, 3
    set_addr $I10, rxcap_341_fail
    ($I12, $I11) = rx337_cur."!mark_peek"($I10)
    rx337_cur."!cursor_pos"($I11)
    ($P10) = rx337_cur."!cursor_start"()
    $P10."!cursor_pass"(rx337_pos, "")
    rx337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_341_done
  rxcap_341_fail:
    goto rx337_fail
  rxcap_341_done:
  # rx charclass s
    ge rx337_pos, rx337_eos, rx337_fail
    sub $I10, rx337_pos, rx337_off
    is_cclass $I11, 32, rx337_tgt, $I10
    unless $I11, rx337_fail
    inc rx337_pos
  # rx subrule "ws" subtype=method negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."ws"()
    unless $P10, rx337_fail
    rx337_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."name"()
    unless $P10, rx337_fail
    rx337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx337_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."ws"()
    unless $P10, rx337_fail
    rx337_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx337_cur."!cursor_pass"(rx337_pos, "statement_control:sym<use>")
    if_null rx337_debug, debug_725
    rx337_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx337_pos)
  debug_725:
    .return (rx337_cur)
  rx337_restart:
.annotate 'line', 10
    if_null rx337_debug, debug_726
    rx337_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_726:
  rx337_fail:
    (rx337_rep, rx337_pos, $I10, $P10) = rx337_cur."!mark_fail"(0)
    lt rx337_pos, -1, rx337_done
    eq rx337_pos, -1, rx337_fail
    jump $I10
  rx337_done:
    rx337_cur."!cursor_fail"()
    if_null rx337_debug, debug_727
    rx337_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_727:
    .return (rx337_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1303391609.928") :method
.annotate 'line', 10
    new $P339, "ResizablePMCArray"
    push $P339, "use"
    .return ($P339)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx345_tgt
    .local int rx345_pos
    .local int rx345_off
    .local int rx345_eos
    .local int rx345_rep
    .local pmc rx345_cur
    .local pmc rx345_debug
    (rx345_cur, rx345_pos, rx345_tgt, $I10) = self."!cursor_start"()
    rx345_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx345_cur
    .local pmc match
    .lex "$/", match
    length rx345_eos, rx345_tgt
    gt rx345_pos, rx345_eos, rx345_done
    set rx345_off, 0
    lt rx345_pos, 2, rx345_start
    sub rx345_off, rx345_pos, 1
    substr rx345_tgt, rx345_tgt, rx345_off
  rx345_start:
    eq $I10, 1, rx345_restart
    if_null rx345_debug, debug_728
    rx345_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan348_done
    goto rxscan348_scan
  rxscan348_loop:
    (rx345_pos) = rx345_cur."from"()
    inc rx345_pos
    rx345_cur."!cursor_from"(rx345_pos)
    ge rx345_pos, rx345_eos, rxscan348_done
  rxscan348_scan:
    set_addr $I10, rxscan348_loop
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  rxscan348_done:
.annotate 'line', 206
  # rx subcapture "sym"
    set_addr $I10, rxcap_349_fail
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  # rx literal  "if"
    add $I11, rx345_pos, 2
    gt $I11, rx345_eos, rx345_fail
    sub $I11, rx345_pos, rx345_off
    substr $S10, rx345_tgt, $I11, 2
    ne $S10, "if", rx345_fail
    add rx345_pos, 2
    set_addr $I10, rxcap_349_fail
    ($I12, $I11) = rx345_cur."!mark_peek"($I10)
    rx345_cur."!cursor_pos"($I11)
    ($P10) = rx345_cur."!cursor_start"()
    $P10."!cursor_pass"(rx345_pos, "")
    rx345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_349_done
  rxcap_349_fail:
    goto rx345_fail
  rxcap_349_done:
  # rx charclass s
    ge rx345_pos, rx345_eos, rx345_fail
    sub $I10, rx345_pos, rx345_off
    is_cclass $I11, 32, rx345_tgt, $I10
    unless $I11, rx345_fail
    inc rx345_pos
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
.annotate 'line', 207
  # rx subrule "xblock" subtype=capture negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."xblock"()
    unless $P10, rx345_fail
    rx345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx345_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
.annotate 'line', 208
  # rx rxquantr352 ** 0..*
    set_addr $I10, rxquantr352_done
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  rxquantr352_loop:
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx345_pos, 5
    gt $I11, rx345_eos, rx345_fail
    sub $I11, rx345_pos, rx345_off
    substr $S10, rx345_tgt, $I11, 5
    ne $S10, "elsif", rx345_fail
    add rx345_pos, 5
  # rx charclass s
    ge rx345_pos, rx345_eos, rx345_fail
    sub $I10, rx345_pos, rx345_off
    is_cclass $I11, 32, rx345_tgt, $I10
    unless $I11, rx345_fail
    inc rx345_pos
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."xblock"()
    unless $P10, rx345_fail
    rx345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx345_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
    set_addr $I10, rxquantr352_done
    (rx345_rep) = rx345_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr352_done
    rx345_cur."!mark_push"(rx345_rep, rx345_pos, $I10)
    goto rxquantr352_loop
  rxquantr352_done:
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
.annotate 'line', 209
  # rx rxquantr357 ** 0..1
    set_addr $I10, rxquantr357_done
    rx345_cur."!mark_push"(0, rx345_pos, $I10)
  rxquantr357_loop:
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx345_pos, 4
    gt $I11, rx345_eos, rx345_fail
    sub $I11, rx345_pos, rx345_off
    substr $S10, rx345_tgt, $I11, 4
    ne $S10, "else", rx345_fail
    add rx345_pos, 4
  # rx charclass s
    ge rx345_pos, rx345_eos, rx345_fail
    sub $I10, rx345_pos, rx345_off
    is_cclass $I11, 32, rx345_tgt, $I10
    unless $I11, rx345_fail
    inc rx345_pos
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."pblock"()
    unless $P10, rx345_fail
    rx345_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx345_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
    set_addr $I10, rxquantr357_done
    (rx345_rep) = rx345_cur."!mark_commit"($I10)
  rxquantr357_done:
  # rx subrule "ws" subtype=method negate=
    rx345_cur."!cursor_pos"(rx345_pos)
    $P10 = rx345_cur."ws"()
    unless $P10, rx345_fail
    rx345_pos = $P10."pos"()
.annotate 'line', 205
  # rx pass
    rx345_cur."!cursor_pass"(rx345_pos, "statement_control:sym<if>")
    if_null rx345_debug, debug_729
    rx345_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx345_pos)
  debug_729:
    .return (rx345_cur)
  rx345_restart:
.annotate 'line', 10
    if_null rx345_debug, debug_730
    rx345_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_730:
  rx345_fail:
    (rx345_rep, rx345_pos, $I10, $P10) = rx345_cur."!mark_fail"(0)
    lt rx345_pos, -1, rx345_done
    eq rx345_pos, -1, rx345_fail
    jump $I10
  rx345_done:
    rx345_cur."!cursor_fail"()
    if_null rx345_debug, debug_731
    rx345_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_731:
    .return (rx345_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1303391609.928") :method
.annotate 'line', 10
    new $P347, "ResizablePMCArray"
    push $P347, "if"
    .return ($P347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P373 = "73_1303391609.928" 
    capture_lex $P373
    .local string rx363_tgt
    .local int rx363_pos
    .local int rx363_off
    .local int rx363_eos
    .local int rx363_rep
    .local pmc rx363_cur
    .local pmc rx363_debug
    (rx363_cur, rx363_pos, rx363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx363_cur
    .local pmc match
    .lex "$/", match
    length rx363_eos, rx363_tgt
    gt rx363_pos, rx363_eos, rx363_done
    set rx363_off, 0
    lt rx363_pos, 2, rx363_start
    sub rx363_off, rx363_pos, 1
    substr rx363_tgt, rx363_tgt, rx363_off
  rx363_start:
    eq $I10, 1, rx363_restart
    if_null rx363_debug, debug_732
    rx363_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan366_done
    goto rxscan366_scan
  rxscan366_loop:
    (rx363_pos) = rx363_cur."from"()
    inc rx363_pos
    rx363_cur."!cursor_from"(rx363_pos)
    ge rx363_pos, rx363_eos, rxscan366_done
  rxscan366_scan:
    set_addr $I10, rxscan366_loop
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  rxscan366_done:
.annotate 'line', 213
  # rx subcapture "sym"
    set_addr $I10, rxcap_367_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "unless"
    add $I11, rx363_pos, 6
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 6
    ne $S10, "unless", rx363_fail
    add rx363_pos, 6
    set_addr $I10, rxcap_367_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_367_done
  rxcap_367_fail:
    goto rx363_fail
  rxcap_367_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 214
  # rx subrule "xblock" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."xblock"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  alt370_0:
.annotate 'line', 215
    set_addr $I10, alt370_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx363_cur."!cursor_pos"(rx363_pos)
    .const 'Sub' $P373 = "73_1303391609.928" 
    capture_lex $P373
    $P10 = rx363_cur."before"($P373)
    if $P10, rx363_fail
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
    goto alt370_end
  alt370_1:
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  alt370_end:
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 212
  # rx pass
    rx363_cur."!cursor_pass"(rx363_pos, "statement_control:sym<unless>")
    if_null rx363_debug, debug_737
    rx363_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx363_pos)
  debug_737:
    .return (rx363_cur)
  rx363_restart:
.annotate 'line', 10
    if_null rx363_debug, debug_738
    rx363_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_738:
  rx363_fail:
    (rx363_rep, rx363_pos, $I10, $P10) = rx363_cur."!mark_fail"(0)
    lt rx363_pos, -1, rx363_done
    eq rx363_pos, -1, rx363_fail
    jump $I10
  rx363_done:
    rx363_cur."!cursor_fail"()
    if_null rx363_debug, debug_739
    rx363_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_739:
    .return (rx363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1303391609.928") :method
.annotate 'line', 10
    new $P365, "ResizablePMCArray"
    push $P365, "unless"
    .return ($P365)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block372"  :anon :subid("73_1303391609.928") :method :outer("71_1303391609.928")
.annotate 'line', 215
    .local string rx374_tgt
    .local int rx374_pos
    .local int rx374_off
    .local int rx374_eos
    .local int rx374_rep
    .local pmc rx374_cur
    .local pmc rx374_debug
    (rx374_cur, rx374_pos, rx374_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx374_cur
    .local pmc match
    .lex "$/", match
    length rx374_eos, rx374_tgt
    gt rx374_pos, rx374_eos, rx374_done
    set rx374_off, 0
    lt rx374_pos, 2, rx374_start
    sub rx374_off, rx374_pos, 1
    substr rx374_tgt, rx374_tgt, rx374_off
  rx374_start:
    eq $I10, 1, rx374_restart
    if_null rx374_debug, debug_733
    rx374_cur."!cursor_debug"("START", "")
  debug_733:
    $I10 = self.'from'()
    ne $I10, -1, rxscan375_done
    goto rxscan375_scan
  rxscan375_loop:
    (rx374_pos) = rx374_cur."from"()
    inc rx374_pos
    rx374_cur."!cursor_from"(rx374_pos)
    ge rx374_pos, rx374_eos, rxscan375_done
  rxscan375_scan:
    set_addr $I10, rxscan375_loop
    rx374_cur."!mark_push"(0, rx374_pos, $I10)
  rxscan375_done:
  # rx literal  "else"
    add $I11, rx374_pos, 4
    gt $I11, rx374_eos, rx374_fail
    sub $I11, rx374_pos, rx374_off
    substr $S10, rx374_tgt, $I11, 4
    ne $S10, "else", rx374_fail
    add rx374_pos, 4
  # rx pass
    rx374_cur."!cursor_pass"(rx374_pos, "")
    if_null rx374_debug, debug_734
    rx374_cur."!cursor_debug"("PASS", "", " at pos=", rx374_pos)
  debug_734:
    .return (rx374_cur)
  rx374_restart:
    if_null rx374_debug, debug_735
    rx374_cur."!cursor_debug"("NEXT", "")
  debug_735:
  rx374_fail:
    (rx374_rep, rx374_pos, $I10, $P10) = rx374_cur."!mark_fail"(0)
    lt rx374_pos, -1, rx374_done
    eq rx374_pos, -1, rx374_fail
    jump $I10
  rx374_done:
    rx374_cur."!cursor_fail"()
    if_null rx374_debug, debug_736
    rx374_cur."!cursor_debug"("FAIL", "")
  debug_736:
    .return (rx374_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx381_tgt
    .local int rx381_pos
    .local int rx381_off
    .local int rx381_eos
    .local int rx381_rep
    .local pmc rx381_cur
    .local pmc rx381_debug
    (rx381_cur, rx381_pos, rx381_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx381_cur
    .local pmc match
    .lex "$/", match
    length rx381_eos, rx381_tgt
    gt rx381_pos, rx381_eos, rx381_done
    set rx381_off, 0
    lt rx381_pos, 2, rx381_start
    sub rx381_off, rx381_pos, 1
    substr rx381_tgt, rx381_tgt, rx381_off
  rx381_start:
    eq $I10, 1, rx381_restart
    if_null rx381_debug, debug_740
    rx381_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_740:
    $I10 = self.'from'()
    ne $I10, -1, rxscan384_done
    goto rxscan384_scan
  rxscan384_loop:
    (rx381_pos) = rx381_cur."from"()
    inc rx381_pos
    rx381_cur."!cursor_from"(rx381_pos)
    ge rx381_pos, rx381_eos, rxscan384_done
  rxscan384_scan:
    set_addr $I10, rxscan384_loop
    rx381_cur."!mark_push"(0, rx381_pos, $I10)
  rxscan384_done:
.annotate 'line', 219
  # rx subcapture "sym"
    set_addr $I10, rxcap_386_fail
    rx381_cur."!mark_push"(0, rx381_pos, $I10)
  alt385_0:
    set_addr $I10, alt385_1
    rx381_cur."!mark_push"(0, rx381_pos, $I10)
  # rx literal  "while"
    add $I11, rx381_pos, 5
    gt $I11, rx381_eos, rx381_fail
    sub $I11, rx381_pos, rx381_off
    substr $S10, rx381_tgt, $I11, 5
    ne $S10, "while", rx381_fail
    add rx381_pos, 5
    goto alt385_end
  alt385_1:
  # rx literal  "until"
    add $I11, rx381_pos, 5
    gt $I11, rx381_eos, rx381_fail
    sub $I11, rx381_pos, rx381_off
    substr $S10, rx381_tgt, $I11, 5
    ne $S10, "until", rx381_fail
    add rx381_pos, 5
  alt385_end:
    set_addr $I10, rxcap_386_fail
    ($I12, $I11) = rx381_cur."!mark_peek"($I10)
    rx381_cur."!cursor_pos"($I11)
    ($P10) = rx381_cur."!cursor_start"()
    $P10."!cursor_pass"(rx381_pos, "")
    rx381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_386_done
  rxcap_386_fail:
    goto rx381_fail
  rxcap_386_done:
  # rx charclass s
    ge rx381_pos, rx381_eos, rx381_fail
    sub $I10, rx381_pos, rx381_off
    is_cclass $I11, 32, rx381_tgt, $I10
    unless $I11, rx381_fail
    inc rx381_pos
  # rx subrule "ws" subtype=method negate=
    rx381_cur."!cursor_pos"(rx381_pos)
    $P10 = rx381_cur."ws"()
    unless $P10, rx381_fail
    rx381_pos = $P10."pos"()
.annotate 'line', 220
  # rx subrule "xblock" subtype=capture negate=
    rx381_cur."!cursor_pos"(rx381_pos)
    $P10 = rx381_cur."xblock"()
    unless $P10, rx381_fail
    rx381_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx381_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx381_cur."!cursor_pos"(rx381_pos)
    $P10 = rx381_cur."ws"()
    unless $P10, rx381_fail
    rx381_pos = $P10."pos"()
.annotate 'line', 218
  # rx pass
    rx381_cur."!cursor_pass"(rx381_pos, "statement_control:sym<while>")
    if_null rx381_debug, debug_741
    rx381_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx381_pos)
  debug_741:
    .return (rx381_cur)
  rx381_restart:
.annotate 'line', 10
    if_null rx381_debug, debug_742
    rx381_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_742:
  rx381_fail:
    (rx381_rep, rx381_pos, $I10, $P10) = rx381_cur."!mark_fail"(0)
    lt rx381_pos, -1, rx381_done
    eq rx381_pos, -1, rx381_fail
    jump $I10
  rx381_done:
    rx381_cur."!cursor_fail"()
    if_null rx381_debug, debug_743
    rx381_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_743:
    .return (rx381_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1303391609.928") :method
.annotate 'line', 10
    new $P383, "ResizablePMCArray"
    push $P383, "until"
    push $P383, "while"
    .return ($P383)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx390_tgt
    .local int rx390_pos
    .local int rx390_off
    .local int rx390_eos
    .local int rx390_rep
    .local pmc rx390_cur
    .local pmc rx390_debug
    (rx390_cur, rx390_pos, rx390_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx390_cur
    .local pmc match
    .lex "$/", match
    length rx390_eos, rx390_tgt
    gt rx390_pos, rx390_eos, rx390_done
    set rx390_off, 0
    lt rx390_pos, 2, rx390_start
    sub rx390_off, rx390_pos, 1
    substr rx390_tgt, rx390_tgt, rx390_off
  rx390_start:
    eq $I10, 1, rx390_restart
    if_null rx390_debug, debug_744
    rx390_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan393_done
    goto rxscan393_scan
  rxscan393_loop:
    (rx390_pos) = rx390_cur."from"()
    inc rx390_pos
    rx390_cur."!cursor_from"(rx390_pos)
    ge rx390_pos, rx390_eos, rxscan393_done
  rxscan393_scan:
    set_addr $I10, rxscan393_loop
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  rxscan393_done:
.annotate 'line', 224
  # rx subcapture "sym"
    set_addr $I10, rxcap_394_fail
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx390_pos, 6
    gt $I11, rx390_eos, rx390_fail
    sub $I11, rx390_pos, rx390_off
    substr $S10, rx390_tgt, $I11, 6
    ne $S10, "repeat", rx390_fail
    add rx390_pos, 6
    set_addr $I10, rxcap_394_fail
    ($I12, $I11) = rx390_cur."!mark_peek"($I10)
    rx390_cur."!cursor_pos"($I11)
    ($P10) = rx390_cur."!cursor_start"()
    $P10."!cursor_pass"(rx390_pos, "")
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_394_done
  rxcap_394_fail:
    goto rx390_fail
  rxcap_394_done:
  # rx charclass s
    ge rx390_pos, rx390_eos, rx390_fail
    sub $I10, rx390_pos, rx390_off
    is_cclass $I11, 32, rx390_tgt, $I10
    unless $I11, rx390_fail
    inc rx390_pos
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  alt396_0:
.annotate 'line', 225
    set_addr $I10, alt396_1
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
.annotate 'line', 226
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_399_fail
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  alt398_0:
    set_addr $I10, alt398_1
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  # rx literal  "while"
    add $I11, rx390_pos, 5
    gt $I11, rx390_eos, rx390_fail
    sub $I11, rx390_pos, rx390_off
    substr $S10, rx390_tgt, $I11, 5
    ne $S10, "while", rx390_fail
    add rx390_pos, 5
    goto alt398_end
  alt398_1:
  # rx literal  "until"
    add $I11, rx390_pos, 5
    gt $I11, rx390_eos, rx390_fail
    sub $I11, rx390_pos, rx390_off
    substr $S10, rx390_tgt, $I11, 5
    ne $S10, "until", rx390_fail
    add rx390_pos, 5
  alt398_end:
    set_addr $I10, rxcap_399_fail
    ($I12, $I11) = rx390_cur."!mark_peek"($I10)
    rx390_cur."!cursor_pos"($I11)
    ($P10) = rx390_cur."!cursor_start"()
    $P10."!cursor_pass"(rx390_pos, "")
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_399_done
  rxcap_399_fail:
    goto rx390_fail
  rxcap_399_done:
  # rx charclass s
    ge rx390_pos, rx390_eos, rx390_fail
    sub $I10, rx390_pos, rx390_off
    is_cclass $I11, 32, rx390_tgt, $I10
    unless $I11, rx390_fail
    inc rx390_pos
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."xblock"()
    unless $P10, rx390_fail
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx390_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
    goto alt396_end
  alt396_1:
.annotate 'line', 227
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."pblock"()
    unless $P10, rx390_fail
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx390_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_405_fail
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  alt404_0:
    set_addr $I10, alt404_1
    rx390_cur."!mark_push"(0, rx390_pos, $I10)
  # rx literal  "while"
    add $I11, rx390_pos, 5
    gt $I11, rx390_eos, rx390_fail
    sub $I11, rx390_pos, rx390_off
    substr $S10, rx390_tgt, $I11, 5
    ne $S10, "while", rx390_fail
    add rx390_pos, 5
    goto alt404_end
  alt404_1:
  # rx literal  "until"
    add $I11, rx390_pos, 5
    gt $I11, rx390_eos, rx390_fail
    sub $I11, rx390_pos, rx390_off
    substr $S10, rx390_tgt, $I11, 5
    ne $S10, "until", rx390_fail
    add rx390_pos, 5
  alt404_end:
    set_addr $I10, rxcap_405_fail
    ($I12, $I11) = rx390_cur."!mark_peek"($I10)
    rx390_cur."!cursor_pos"($I11)
    ($P10) = rx390_cur."!cursor_start"()
    $P10."!cursor_pass"(rx390_pos, "")
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_405_done
  rxcap_405_fail:
    goto rx390_fail
  rxcap_405_done:
  # rx charclass s
    ge rx390_pos, rx390_eos, rx390_fail
    sub $I10, rx390_pos, rx390_off
    is_cclass $I11, 32, rx390_tgt, $I10
    unless $I11, rx390_fail
    inc rx390_pos
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."EXPR"()
    unless $P10, rx390_fail
    rx390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx390_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
  alt396_end:
.annotate 'line', 228
  # rx subrule "ws" subtype=method negate=
    rx390_cur."!cursor_pos"(rx390_pos)
    $P10 = rx390_cur."ws"()
    unless $P10, rx390_fail
    rx390_pos = $P10."pos"()
.annotate 'line', 223
  # rx pass
    rx390_cur."!cursor_pass"(rx390_pos, "statement_control:sym<repeat>")
    if_null rx390_debug, debug_745
    rx390_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx390_pos)
  debug_745:
    .return (rx390_cur)
  rx390_restart:
.annotate 'line', 10
    if_null rx390_debug, debug_746
    rx390_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_746:
  rx390_fail:
    (rx390_rep, rx390_pos, $I10, $P10) = rx390_cur."!mark_fail"(0)
    lt rx390_pos, -1, rx390_done
    eq rx390_pos, -1, rx390_fail
    jump $I10
  rx390_done:
    rx390_cur."!cursor_fail"()
    if_null rx390_debug, debug_747
    rx390_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_747:
    .return (rx390_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1303391609.928") :method
.annotate 'line', 10
    new $P392, "ResizablePMCArray"
    push $P392, "repeat"
    .return ($P392)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx410_tgt
    .local int rx410_pos
    .local int rx410_off
    .local int rx410_eos
    .local int rx410_rep
    .local pmc rx410_cur
    .local pmc rx410_debug
    (rx410_cur, rx410_pos, rx410_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx410_cur
    .local pmc match
    .lex "$/", match
    length rx410_eos, rx410_tgt
    gt rx410_pos, rx410_eos, rx410_done
    set rx410_off, 0
    lt rx410_pos, 2, rx410_start
    sub rx410_off, rx410_pos, 1
    substr rx410_tgt, rx410_tgt, rx410_off
  rx410_start:
    eq $I10, 1, rx410_restart
    if_null rx410_debug, debug_748
    rx410_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan413_done
    goto rxscan413_scan
  rxscan413_loop:
    (rx410_pos) = rx410_cur."from"()
    inc rx410_pos
    rx410_cur."!cursor_from"(rx410_pos)
    ge rx410_pos, rx410_eos, rxscan413_done
  rxscan413_scan:
    set_addr $I10, rxscan413_loop
    rx410_cur."!mark_push"(0, rx410_pos, $I10)
  rxscan413_done:
.annotate 'line', 232
  # rx subcapture "sym"
    set_addr $I10, rxcap_414_fail
    rx410_cur."!mark_push"(0, rx410_pos, $I10)
  # rx literal  "for"
    add $I11, rx410_pos, 3
    gt $I11, rx410_eos, rx410_fail
    sub $I11, rx410_pos, rx410_off
    substr $S10, rx410_tgt, $I11, 3
    ne $S10, "for", rx410_fail
    add rx410_pos, 3
    set_addr $I10, rxcap_414_fail
    ($I12, $I11) = rx410_cur."!mark_peek"($I10)
    rx410_cur."!cursor_pos"($I11)
    ($P10) = rx410_cur."!cursor_start"()
    $P10."!cursor_pass"(rx410_pos, "")
    rx410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_414_done
  rxcap_414_fail:
    goto rx410_fail
  rxcap_414_done:
  # rx charclass s
    ge rx410_pos, rx410_eos, rx410_fail
    sub $I10, rx410_pos, rx410_off
    is_cclass $I11, 32, rx410_tgt, $I10
    unless $I11, rx410_fail
    inc rx410_pos
  # rx subrule "ws" subtype=method negate=
    rx410_cur."!cursor_pos"(rx410_pos)
    $P10 = rx410_cur."ws"()
    unless $P10, rx410_fail
    rx410_pos = $P10."pos"()
.annotate 'line', 233
  # rx subrule "xblock" subtype=capture negate=
    rx410_cur."!cursor_pos"(rx410_pos)
    $P10 = rx410_cur."xblock"()
    unless $P10, rx410_fail
    rx410_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx410_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx410_cur."!cursor_pos"(rx410_pos)
    $P10 = rx410_cur."ws"()
    unless $P10, rx410_fail
    rx410_pos = $P10."pos"()
.annotate 'line', 231
  # rx pass
    rx410_cur."!cursor_pass"(rx410_pos, "statement_control:sym<for>")
    if_null rx410_debug, debug_749
    rx410_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx410_pos)
  debug_749:
    .return (rx410_cur)
  rx410_restart:
.annotate 'line', 10
    if_null rx410_debug, debug_750
    rx410_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_750:
  rx410_fail:
    (rx410_rep, rx410_pos, $I10, $P10) = rx410_cur."!mark_fail"(0)
    lt rx410_pos, -1, rx410_done
    eq rx410_pos, -1, rx410_fail
    jump $I10
  rx410_done:
    rx410_cur."!cursor_fail"()
    if_null rx410_debug, debug_751
    rx410_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_751:
    .return (rx410_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1303391609.928") :method
.annotate 'line', 10
    new $P412, "ResizablePMCArray"
    push $P412, "for"
    .return ($P412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx418_tgt
    .local int rx418_pos
    .local int rx418_off
    .local int rx418_eos
    .local int rx418_rep
    .local pmc rx418_cur
    .local pmc rx418_debug
    (rx418_cur, rx418_pos, rx418_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx418_cur
    .local pmc match
    .lex "$/", match
    length rx418_eos, rx418_tgt
    gt rx418_pos, rx418_eos, rx418_done
    set rx418_off, 0
    lt rx418_pos, 2, rx418_start
    sub rx418_off, rx418_pos, 1
    substr rx418_tgt, rx418_tgt, rx418_off
  rx418_start:
    eq $I10, 1, rx418_restart
    if_null rx418_debug, debug_752
    rx418_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan421_done
    goto rxscan421_scan
  rxscan421_loop:
    (rx418_pos) = rx418_cur."from"()
    inc rx418_pos
    rx418_cur."!cursor_from"(rx418_pos)
    ge rx418_pos, rx418_eos, rxscan421_done
  rxscan421_scan:
    set_addr $I10, rxscan421_loop
    rx418_cur."!mark_push"(0, rx418_pos, $I10)
  rxscan421_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_422_fail
    rx418_cur."!mark_push"(0, rx418_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx418_pos, 5
    gt $I11, rx418_eos, rx418_fail
    sub $I11, rx418_pos, rx418_off
    substr $S10, rx418_tgt, $I11, 5
    ne $S10, "CATCH", rx418_fail
    add rx418_pos, 5
    set_addr $I10, rxcap_422_fail
    ($I12, $I11) = rx418_cur."!mark_peek"($I10)
    rx418_cur."!cursor_pos"($I11)
    ($P10) = rx418_cur."!cursor_start"()
    $P10."!cursor_pass"(rx418_pos, "")
    rx418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_422_done
  rxcap_422_fail:
    goto rx418_fail
  rxcap_422_done:
  # rx charclass s
    ge rx418_pos, rx418_eos, rx418_fail
    sub $I10, rx418_pos, rx418_off
    is_cclass $I11, 32, rx418_tgt, $I10
    unless $I11, rx418_fail
    inc rx418_pos
  # rx subrule "ws" subtype=method negate=
    rx418_cur."!cursor_pos"(rx418_pos)
    $P10 = rx418_cur."ws"()
    unless $P10, rx418_fail
    rx418_pos = $P10."pos"()
.annotate 'line', 238
  # rx subrule "block" subtype=capture negate=
    rx418_cur."!cursor_pos"(rx418_pos)
    $P10 = rx418_cur."block"()
    unless $P10, rx418_fail
    rx418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx418_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx418_cur."!cursor_pos"(rx418_pos)
    $P10 = rx418_cur."ws"()
    unless $P10, rx418_fail
    rx418_pos = $P10."pos"()
.annotate 'line', 236
  # rx pass
    rx418_cur."!cursor_pass"(rx418_pos, "statement_control:sym<CATCH>")
    if_null rx418_debug, debug_753
    rx418_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx418_pos)
  debug_753:
    .return (rx418_cur)
  rx418_restart:
.annotate 'line', 10
    if_null rx418_debug, debug_754
    rx418_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_754:
  rx418_fail:
    (rx418_rep, rx418_pos, $I10, $P10) = rx418_cur."!mark_fail"(0)
    lt rx418_pos, -1, rx418_done
    eq rx418_pos, -1, rx418_fail
    jump $I10
  rx418_done:
    rx418_cur."!cursor_fail"()
    if_null rx418_debug, debug_755
    rx418_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_755:
    .return (rx418_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1303391609.928") :method
.annotate 'line', 10
    new $P420, "ResizablePMCArray"
    push $P420, "CATCH"
    .return ($P420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx426_tgt
    .local int rx426_pos
    .local int rx426_off
    .local int rx426_eos
    .local int rx426_rep
    .local pmc rx426_cur
    .local pmc rx426_debug
    (rx426_cur, rx426_pos, rx426_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx426_cur
    .local pmc match
    .lex "$/", match
    length rx426_eos, rx426_tgt
    gt rx426_pos, rx426_eos, rx426_done
    set rx426_off, 0
    lt rx426_pos, 2, rx426_start
    sub rx426_off, rx426_pos, 1
    substr rx426_tgt, rx426_tgt, rx426_off
  rx426_start:
    eq $I10, 1, rx426_restart
    if_null rx426_debug, debug_756
    rx426_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan429_done
    goto rxscan429_scan
  rxscan429_loop:
    (rx426_pos) = rx426_cur."from"()
    inc rx426_pos
    rx426_cur."!cursor_from"(rx426_pos)
    ge rx426_pos, rx426_eos, rxscan429_done
  rxscan429_scan:
    set_addr $I10, rxscan429_loop
    rx426_cur."!mark_push"(0, rx426_pos, $I10)
  rxscan429_done:
.annotate 'line', 242
  # rx subcapture "sym"
    set_addr $I10, rxcap_430_fail
    rx426_cur."!mark_push"(0, rx426_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx426_pos, 7
    gt $I11, rx426_eos, rx426_fail
    sub $I11, rx426_pos, rx426_off
    substr $S10, rx426_tgt, $I11, 7
    ne $S10, "CONTROL", rx426_fail
    add rx426_pos, 7
    set_addr $I10, rxcap_430_fail
    ($I12, $I11) = rx426_cur."!mark_peek"($I10)
    rx426_cur."!cursor_pos"($I11)
    ($P10) = rx426_cur."!cursor_start"()
    $P10."!cursor_pass"(rx426_pos, "")
    rx426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_430_done
  rxcap_430_fail:
    goto rx426_fail
  rxcap_430_done:
  # rx charclass s
    ge rx426_pos, rx426_eos, rx426_fail
    sub $I10, rx426_pos, rx426_off
    is_cclass $I11, 32, rx426_tgt, $I10
    unless $I11, rx426_fail
    inc rx426_pos
  # rx subrule "ws" subtype=method negate=
    rx426_cur."!cursor_pos"(rx426_pos)
    $P10 = rx426_cur."ws"()
    unless $P10, rx426_fail
    rx426_pos = $P10."pos"()
.annotate 'line', 243
  # rx subrule "block" subtype=capture negate=
    rx426_cur."!cursor_pos"(rx426_pos)
    $P10 = rx426_cur."block"()
    unless $P10, rx426_fail
    rx426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx426_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx426_cur."!cursor_pos"(rx426_pos)
    $P10 = rx426_cur."ws"()
    unless $P10, rx426_fail
    rx426_pos = $P10."pos"()
.annotate 'line', 241
  # rx pass
    rx426_cur."!cursor_pass"(rx426_pos, "statement_control:sym<CONTROL>")
    if_null rx426_debug, debug_757
    rx426_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx426_pos)
  debug_757:
    .return (rx426_cur)
  rx426_restart:
.annotate 'line', 10
    if_null rx426_debug, debug_758
    rx426_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_758:
  rx426_fail:
    (rx426_rep, rx426_pos, $I10, $P10) = rx426_cur."!mark_fail"(0)
    lt rx426_pos, -1, rx426_done
    eq rx426_pos, -1, rx426_fail
    jump $I10
  rx426_done:
    rx426_cur."!cursor_fail"()
    if_null rx426_debug, debug_759
    rx426_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_759:
    .return (rx426_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1303391609.928") :method
.annotate 'line', 10
    new $P428, "ResizablePMCArray"
    push $P428, "CONTROL"
    .return ($P428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1303391609.928")
    .param pmc param_434
.annotate 'line', 246
    .lex "self", param_434
    $P435 = param_434."!protoregex"("statement_prefix")
    .return ($P435)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1303391609.928")
    .param pmc param_437
.annotate 'line', 246
    .lex "self", param_437
    $P438 = param_437."!PREFIX__!protoregex"("statement_prefix")
    .return ($P438)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx440_tgt
    .local int rx440_pos
    .local int rx440_off
    .local int rx440_eos
    .local int rx440_rep
    .local pmc rx440_cur
    .local pmc rx440_debug
    (rx440_cur, rx440_pos, rx440_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx440_cur
    .local pmc match
    .lex "$/", match
    length rx440_eos, rx440_tgt
    gt rx440_pos, rx440_eos, rx440_done
    set rx440_off, 0
    lt rx440_pos, 2, rx440_start
    sub rx440_off, rx440_pos, 1
    substr rx440_tgt, rx440_tgt, rx440_off
  rx440_start:
    eq $I10, 1, rx440_restart
    if_null rx440_debug, debug_760
    rx440_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_760:
    $I10 = self.'from'()
    ne $I10, -1, rxscan444_done
    goto rxscan444_scan
  rxscan444_loop:
    (rx440_pos) = rx440_cur."from"()
    inc rx440_pos
    rx440_cur."!cursor_from"(rx440_pos)
    ge rx440_pos, rx440_eos, rxscan444_done
  rxscan444_scan:
    set_addr $I10, rxscan444_loop
    rx440_cur."!mark_push"(0, rx440_pos, $I10)
  rxscan444_done:
.annotate 'line', 247
  # rx subcapture "sym"
    set_addr $I10, rxcap_445_fail
    rx440_cur."!mark_push"(0, rx440_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx440_pos, 4
    gt $I11, rx440_eos, rx440_fail
    sub $I11, rx440_pos, rx440_off
    substr $S10, rx440_tgt, $I11, 4
    ne $S10, "INIT", rx440_fail
    add rx440_pos, 4
    set_addr $I10, rxcap_445_fail
    ($I12, $I11) = rx440_cur."!mark_peek"($I10)
    rx440_cur."!cursor_pos"($I11)
    ($P10) = rx440_cur."!cursor_start"()
    $P10."!cursor_pass"(rx440_pos, "")
    rx440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_445_done
  rxcap_445_fail:
    goto rx440_fail
  rxcap_445_done:
  # rx subrule "blorst" subtype=capture negate=
    rx440_cur."!cursor_pos"(rx440_pos)
    $P10 = rx440_cur."blorst"()
    unless $P10, rx440_fail
    rx440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx440_pos = $P10."pos"()
  # rx pass
    rx440_cur."!cursor_pass"(rx440_pos, "statement_prefix:sym<INIT>")
    if_null rx440_debug, debug_761
    rx440_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx440_pos)
  debug_761:
    .return (rx440_cur)
  rx440_restart:
.annotate 'line', 10
    if_null rx440_debug, debug_762
    rx440_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_762:
  rx440_fail:
    (rx440_rep, rx440_pos, $I10, $P10) = rx440_cur."!mark_fail"(0)
    lt rx440_pos, -1, rx440_done
    eq rx440_pos, -1, rx440_fail
    jump $I10
  rx440_done:
    rx440_cur."!cursor_fail"()
    if_null rx440_debug, debug_763
    rx440_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_763:
    .return (rx440_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1303391609.928") :method
.annotate 'line', 10
    $P442 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P443, "ResizablePMCArray"
    push $P443, $P442
    .return ($P443)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx447_tgt
    .local int rx447_pos
    .local int rx447_off
    .local int rx447_eos
    .local int rx447_rep
    .local pmc rx447_cur
    .local pmc rx447_debug
    (rx447_cur, rx447_pos, rx447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx447_cur
    .local pmc match
    .lex "$/", match
    length rx447_eos, rx447_tgt
    gt rx447_pos, rx447_eos, rx447_done
    set rx447_off, 0
    lt rx447_pos, 2, rx447_start
    sub rx447_off, rx447_pos, 1
    substr rx447_tgt, rx447_tgt, rx447_off
  rx447_start:
    eq $I10, 1, rx447_restart
    if_null rx447_debug, debug_764
    rx447_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_764:
    $I10 = self.'from'()
    ne $I10, -1, rxscan451_done
    goto rxscan451_scan
  rxscan451_loop:
    (rx447_pos) = rx447_cur."from"()
    inc rx447_pos
    rx447_cur."!cursor_from"(rx447_pos)
    ge rx447_pos, rx447_eos, rxscan451_done
  rxscan451_scan:
    set_addr $I10, rxscan451_loop
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  rxscan451_done:
.annotate 'line', 250
  # rx subcapture "sym"
    set_addr $I10, rxcap_452_fail
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  # rx literal  "try"
    add $I11, rx447_pos, 3
    gt $I11, rx447_eos, rx447_fail
    sub $I11, rx447_pos, rx447_off
    substr $S10, rx447_tgt, $I11, 3
    ne $S10, "try", rx447_fail
    add rx447_pos, 3
    set_addr $I10, rxcap_452_fail
    ($I12, $I11) = rx447_cur."!mark_peek"($I10)
    rx447_cur."!cursor_pos"($I11)
    ($P10) = rx447_cur."!cursor_start"()
    $P10."!cursor_pass"(rx447_pos, "")
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_452_done
  rxcap_452_fail:
    goto rx447_fail
  rxcap_452_done:
.annotate 'line', 251
  # rx subrule "blorst" subtype=capture negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."blorst"()
    unless $P10, rx447_fail
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx447_pos = $P10."pos"()
.annotate 'line', 249
  # rx pass
    rx447_cur."!cursor_pass"(rx447_pos, "statement_prefix:sym<try>")
    if_null rx447_debug, debug_765
    rx447_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx447_pos)
  debug_765:
    .return (rx447_cur)
  rx447_restart:
.annotate 'line', 10
    if_null rx447_debug, debug_766
    rx447_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_766:
  rx447_fail:
    (rx447_rep, rx447_pos, $I10, $P10) = rx447_cur."!mark_fail"(0)
    lt rx447_pos, -1, rx447_done
    eq rx447_pos, -1, rx447_fail
    jump $I10
  rx447_done:
    rx447_cur."!cursor_fail"()
    if_null rx447_debug, debug_767
    rx447_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_767:
    .return (rx447_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1303391609.928") :method
.annotate 'line', 10
    $P449 = self."!PREFIX__!subrule"("blorst", "try")
    new $P450, "ResizablePMCArray"
    push $P450, $P449
    .return ($P450)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx454_tgt
    .local int rx454_pos
    .local int rx454_off
    .local int rx454_eos
    .local int rx454_rep
    .local pmc rx454_cur
    .local pmc rx454_debug
    (rx454_cur, rx454_pos, rx454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx454_cur
    .local pmc match
    .lex "$/", match
    length rx454_eos, rx454_tgt
    gt rx454_pos, rx454_eos, rx454_done
    set rx454_off, 0
    lt rx454_pos, 2, rx454_start
    sub rx454_off, rx454_pos, 1
    substr rx454_tgt, rx454_tgt, rx454_off
  rx454_start:
    eq $I10, 1, rx454_restart
    if_null rx454_debug, debug_768
    rx454_cur."!cursor_debug"("START", "blorst")
  debug_768:
    $I10 = self.'from'()
    ne $I10, -1, rxscan457_done
    goto rxscan457_scan
  rxscan457_loop:
    (rx454_pos) = rx454_cur."from"()
    inc rx454_pos
    rx454_cur."!cursor_from"(rx454_pos)
    ge rx454_pos, rx454_eos, rxscan457_done
  rxscan457_scan:
    set_addr $I10, rxscan457_loop
    rx454_cur."!mark_push"(0, rx454_pos, $I10)
  rxscan457_done:
.annotate 'line', 255
  # rx charclass s
    ge rx454_pos, rx454_eos, rx454_fail
    sub $I10, rx454_pos, rx454_off
    is_cclass $I11, 32, rx454_tgt, $I10
    unless $I11, rx454_fail
    inc rx454_pos
  # rx subrule "ws" subtype=method negate=
    rx454_cur."!cursor_pos"(rx454_pos)
    $P10 = rx454_cur."ws"()
    unless $P10, rx454_fail
    rx454_pos = $P10."pos"()
  alt458_0:
    set_addr $I10, alt458_1
    rx454_cur."!mark_push"(0, rx454_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx454_pos, rx454_off
    substr $S10, rx454_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx454_fail
  # rx subrule "block" subtype=capture negate=
    rx454_cur."!cursor_pos"(rx454_pos)
    $P10 = rx454_cur."block"()
    unless $P10, rx454_fail
    rx454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx454_pos = $P10."pos"()
    goto alt458_end
  alt458_1:
  # rx subrule "statement" subtype=capture negate=
    rx454_cur."!cursor_pos"(rx454_pos)
    $P10 = rx454_cur."statement"()
    unless $P10, rx454_fail
    rx454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx454_pos = $P10."pos"()
  alt458_end:
.annotate 'line', 254
  # rx pass
    rx454_cur."!cursor_pass"(rx454_pos, "blorst")
    if_null rx454_debug, debug_769
    rx454_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx454_pos)
  debug_769:
    .return (rx454_cur)
  rx454_restart:
.annotate 'line', 10
    if_null rx454_debug, debug_770
    rx454_cur."!cursor_debug"("NEXT", "blorst")
  debug_770:
  rx454_fail:
    (rx454_rep, rx454_pos, $I10, $P10) = rx454_cur."!mark_fail"(0)
    lt rx454_pos, -1, rx454_done
    eq rx454_pos, -1, rx454_fail
    jump $I10
  rx454_done:
    rx454_cur."!cursor_fail"()
    if_null rx454_debug, debug_771
    rx454_cur."!cursor_debug"("FAIL", "blorst")
  debug_771:
    .return (rx454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1303391609.928") :method
.annotate 'line', 10
    new $P456, "ResizablePMCArray"
    push $P456, ""
    .return ($P456)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1303391609.928")
    .param pmc param_460
.annotate 'line', 260
    .lex "self", param_460
    $P461 = param_460."!protoregex"("statement_mod_cond")
    .return ($P461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1303391609.928")
    .param pmc param_463
.annotate 'line', 260
    .lex "self", param_463
    $P464 = param_463."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P464)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx466_tgt
    .local int rx466_pos
    .local int rx466_off
    .local int rx466_eos
    .local int rx466_rep
    .local pmc rx466_cur
    .local pmc rx466_debug
    (rx466_cur, rx466_pos, rx466_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx466_cur
    .local pmc match
    .lex "$/", match
    length rx466_eos, rx466_tgt
    gt rx466_pos, rx466_eos, rx466_done
    set rx466_off, 0
    lt rx466_pos, 2, rx466_start
    sub rx466_off, rx466_pos, 1
    substr rx466_tgt, rx466_tgt, rx466_off
  rx466_start:
    eq $I10, 1, rx466_restart
    if_null rx466_debug, debug_772
    rx466_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_772:
    $I10 = self.'from'()
    ne $I10, -1, rxscan470_done
    goto rxscan470_scan
  rxscan470_loop:
    (rx466_pos) = rx466_cur."from"()
    inc rx466_pos
    rx466_cur."!cursor_from"(rx466_pos)
    ge rx466_pos, rx466_eos, rxscan470_done
  rxscan470_scan:
    set_addr $I10, rxscan470_loop
    rx466_cur."!mark_push"(0, rx466_pos, $I10)
  rxscan470_done:
.annotate 'line', 262
  # rx subcapture "sym"
    set_addr $I10, rxcap_471_fail
    rx466_cur."!mark_push"(0, rx466_pos, $I10)
  # rx literal  "if"
    add $I11, rx466_pos, 2
    gt $I11, rx466_eos, rx466_fail
    sub $I11, rx466_pos, rx466_off
    substr $S10, rx466_tgt, $I11, 2
    ne $S10, "if", rx466_fail
    add rx466_pos, 2
    set_addr $I10, rxcap_471_fail
    ($I12, $I11) = rx466_cur."!mark_peek"($I10)
    rx466_cur."!cursor_pos"($I11)
    ($P10) = rx466_cur."!cursor_start"()
    $P10."!cursor_pass"(rx466_pos, "")
    rx466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_471_done
  rxcap_471_fail:
    goto rx466_fail
  rxcap_471_done:
  # rx subrule "ws" subtype=method negate=
    rx466_cur."!cursor_pos"(rx466_pos)
    $P10 = rx466_cur."ws"()
    unless $P10, rx466_fail
    rx466_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx466_cur."!cursor_pos"(rx466_pos)
    $P10 = rx466_cur."EXPR"()
    unless $P10, rx466_fail
    rx466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx466_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx466_cur."!cursor_pos"(rx466_pos)
    $P10 = rx466_cur."ws"()
    unless $P10, rx466_fail
    rx466_pos = $P10."pos"()
  # rx pass
    rx466_cur."!cursor_pass"(rx466_pos, "statement_mod_cond:sym<if>")
    if_null rx466_debug, debug_773
    rx466_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx466_pos)
  debug_773:
    .return (rx466_cur)
  rx466_restart:
.annotate 'line', 10
    if_null rx466_debug, debug_774
    rx466_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_774:
  rx466_fail:
    (rx466_rep, rx466_pos, $I10, $P10) = rx466_cur."!mark_fail"(0)
    lt rx466_pos, -1, rx466_done
    eq rx466_pos, -1, rx466_fail
    jump $I10
  rx466_done:
    rx466_cur."!cursor_fail"()
    if_null rx466_debug, debug_775
    rx466_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_775:
    .return (rx466_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1303391609.928") :method
.annotate 'line', 10
    $P468 = self."!PREFIX__!subrule"("ws", "if")
    new $P469, "ResizablePMCArray"
    push $P469, $P468
    .return ($P469)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx475_tgt
    .local int rx475_pos
    .local int rx475_off
    .local int rx475_eos
    .local int rx475_rep
    .local pmc rx475_cur
    .local pmc rx475_debug
    (rx475_cur, rx475_pos, rx475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx475_cur
    .local pmc match
    .lex "$/", match
    length rx475_eos, rx475_tgt
    gt rx475_pos, rx475_eos, rx475_done
    set rx475_off, 0
    lt rx475_pos, 2, rx475_start
    sub rx475_off, rx475_pos, 1
    substr rx475_tgt, rx475_tgt, rx475_off
  rx475_start:
    eq $I10, 1, rx475_restart
    if_null rx475_debug, debug_776
    rx475_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan479_done
    goto rxscan479_scan
  rxscan479_loop:
    (rx475_pos) = rx475_cur."from"()
    inc rx475_pos
    rx475_cur."!cursor_from"(rx475_pos)
    ge rx475_pos, rx475_eos, rxscan479_done
  rxscan479_scan:
    set_addr $I10, rxscan479_loop
    rx475_cur."!mark_push"(0, rx475_pos, $I10)
  rxscan479_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_480_fail
    rx475_cur."!mark_push"(0, rx475_pos, $I10)
  # rx literal  "unless"
    add $I11, rx475_pos, 6
    gt $I11, rx475_eos, rx475_fail
    sub $I11, rx475_pos, rx475_off
    substr $S10, rx475_tgt, $I11, 6
    ne $S10, "unless", rx475_fail
    add rx475_pos, 6
    set_addr $I10, rxcap_480_fail
    ($I12, $I11) = rx475_cur."!mark_peek"($I10)
    rx475_cur."!cursor_pos"($I11)
    ($P10) = rx475_cur."!cursor_start"()
    $P10."!cursor_pass"(rx475_pos, "")
    rx475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_480_done
  rxcap_480_fail:
    goto rx475_fail
  rxcap_480_done:
  # rx subrule "ws" subtype=method negate=
    rx475_cur."!cursor_pos"(rx475_pos)
    $P10 = rx475_cur."ws"()
    unless $P10, rx475_fail
    rx475_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx475_cur."!cursor_pos"(rx475_pos)
    $P10 = rx475_cur."EXPR"()
    unless $P10, rx475_fail
    rx475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx475_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx475_cur."!cursor_pos"(rx475_pos)
    $P10 = rx475_cur."ws"()
    unless $P10, rx475_fail
    rx475_pos = $P10."pos"()
  # rx pass
    rx475_cur."!cursor_pass"(rx475_pos, "statement_mod_cond:sym<unless>")
    if_null rx475_debug, debug_777
    rx475_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx475_pos)
  debug_777:
    .return (rx475_cur)
  rx475_restart:
.annotate 'line', 10
    if_null rx475_debug, debug_778
    rx475_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_778:
  rx475_fail:
    (rx475_rep, rx475_pos, $I10, $P10) = rx475_cur."!mark_fail"(0)
    lt rx475_pos, -1, rx475_done
    eq rx475_pos, -1, rx475_fail
    jump $I10
  rx475_done:
    rx475_cur."!cursor_fail"()
    if_null rx475_debug, debug_779
    rx475_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_779:
    .return (rx475_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1303391609.928") :method
.annotate 'line', 10
    $P477 = self."!PREFIX__!subrule"("ws", "unless")
    new $P478, "ResizablePMCArray"
    push $P478, $P477
    .return ($P478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1303391609.928")
    .param pmc param_484
.annotate 'line', 265
    .lex "self", param_484
    $P485 = param_484."!protoregex"("statement_mod_loop")
    .return ($P485)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1303391609.928")
    .param pmc param_487
.annotate 'line', 265
    .lex "self", param_487
    $P488 = param_487."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P488)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx490_tgt
    .local int rx490_pos
    .local int rx490_off
    .local int rx490_eos
    .local int rx490_rep
    .local pmc rx490_cur
    .local pmc rx490_debug
    (rx490_cur, rx490_pos, rx490_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx490_cur
    .local pmc match
    .lex "$/", match
    length rx490_eos, rx490_tgt
    gt rx490_pos, rx490_eos, rx490_done
    set rx490_off, 0
    lt rx490_pos, 2, rx490_start
    sub rx490_off, rx490_pos, 1
    substr rx490_tgt, rx490_tgt, rx490_off
  rx490_start:
    eq $I10, 1, rx490_restart
    if_null rx490_debug, debug_780
    rx490_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan494_done
    goto rxscan494_scan
  rxscan494_loop:
    (rx490_pos) = rx490_cur."from"()
    inc rx490_pos
    rx490_cur."!cursor_from"(rx490_pos)
    ge rx490_pos, rx490_eos, rxscan494_done
  rxscan494_scan:
    set_addr $I10, rxscan494_loop
    rx490_cur."!mark_push"(0, rx490_pos, $I10)
  rxscan494_done:
.annotate 'line', 267
  # rx subcapture "sym"
    set_addr $I10, rxcap_495_fail
    rx490_cur."!mark_push"(0, rx490_pos, $I10)
  # rx literal  "while"
    add $I11, rx490_pos, 5
    gt $I11, rx490_eos, rx490_fail
    sub $I11, rx490_pos, rx490_off
    substr $S10, rx490_tgt, $I11, 5
    ne $S10, "while", rx490_fail
    add rx490_pos, 5
    set_addr $I10, rxcap_495_fail
    ($I12, $I11) = rx490_cur."!mark_peek"($I10)
    rx490_cur."!cursor_pos"($I11)
    ($P10) = rx490_cur."!cursor_start"()
    $P10."!cursor_pass"(rx490_pos, "")
    rx490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_495_done
  rxcap_495_fail:
    goto rx490_fail
  rxcap_495_done:
  # rx subrule "ws" subtype=method negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."ws"()
    unless $P10, rx490_fail
    rx490_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."EXPR"()
    unless $P10, rx490_fail
    rx490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx490_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."ws"()
    unless $P10, rx490_fail
    rx490_pos = $P10."pos"()
  # rx pass
    rx490_cur."!cursor_pass"(rx490_pos, "statement_mod_loop:sym<while>")
    if_null rx490_debug, debug_781
    rx490_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx490_pos)
  debug_781:
    .return (rx490_cur)
  rx490_restart:
.annotate 'line', 10
    if_null rx490_debug, debug_782
    rx490_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_782:
  rx490_fail:
    (rx490_rep, rx490_pos, $I10, $P10) = rx490_cur."!mark_fail"(0)
    lt rx490_pos, -1, rx490_done
    eq rx490_pos, -1, rx490_fail
    jump $I10
  rx490_done:
    rx490_cur."!cursor_fail"()
    if_null rx490_debug, debug_783
    rx490_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_783:
    .return (rx490_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1303391609.928") :method
.annotate 'line', 10
    $P492 = self."!PREFIX__!subrule"("ws", "while")
    new $P493, "ResizablePMCArray"
    push $P493, $P492
    .return ($P493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx499_tgt
    .local int rx499_pos
    .local int rx499_off
    .local int rx499_eos
    .local int rx499_rep
    .local pmc rx499_cur
    .local pmc rx499_debug
    (rx499_cur, rx499_pos, rx499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx499_cur
    .local pmc match
    .lex "$/", match
    length rx499_eos, rx499_tgt
    gt rx499_pos, rx499_eos, rx499_done
    set rx499_off, 0
    lt rx499_pos, 2, rx499_start
    sub rx499_off, rx499_pos, 1
    substr rx499_tgt, rx499_tgt, rx499_off
  rx499_start:
    eq $I10, 1, rx499_restart
    if_null rx499_debug, debug_784
    rx499_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan503_done
    goto rxscan503_scan
  rxscan503_loop:
    (rx499_pos) = rx499_cur."from"()
    inc rx499_pos
    rx499_cur."!cursor_from"(rx499_pos)
    ge rx499_pos, rx499_eos, rxscan503_done
  rxscan503_scan:
    set_addr $I10, rxscan503_loop
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  rxscan503_done:
.annotate 'line', 268
  # rx subcapture "sym"
    set_addr $I10, rxcap_504_fail
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  # rx literal  "until"
    add $I11, rx499_pos, 5
    gt $I11, rx499_eos, rx499_fail
    sub $I11, rx499_pos, rx499_off
    substr $S10, rx499_tgt, $I11, 5
    ne $S10, "until", rx499_fail
    add rx499_pos, 5
    set_addr $I10, rxcap_504_fail
    ($I12, $I11) = rx499_cur."!mark_peek"($I10)
    rx499_cur."!cursor_pos"($I11)
    ($P10) = rx499_cur."!cursor_start"()
    $P10."!cursor_pass"(rx499_pos, "")
    rx499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_504_done
  rxcap_504_fail:
    goto rx499_fail
  rxcap_504_done:
  # rx subrule "ws" subtype=method negate=
    rx499_cur."!cursor_pos"(rx499_pos)
    $P10 = rx499_cur."ws"()
    unless $P10, rx499_fail
    rx499_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx499_cur."!cursor_pos"(rx499_pos)
    $P10 = rx499_cur."EXPR"()
    unless $P10, rx499_fail
    rx499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx499_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx499_cur."!cursor_pos"(rx499_pos)
    $P10 = rx499_cur."ws"()
    unless $P10, rx499_fail
    rx499_pos = $P10."pos"()
  # rx pass
    rx499_cur."!cursor_pass"(rx499_pos, "statement_mod_loop:sym<until>")
    if_null rx499_debug, debug_785
    rx499_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx499_pos)
  debug_785:
    .return (rx499_cur)
  rx499_restart:
.annotate 'line', 10
    if_null rx499_debug, debug_786
    rx499_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_786:
  rx499_fail:
    (rx499_rep, rx499_pos, $I10, $P10) = rx499_cur."!mark_fail"(0)
    lt rx499_pos, -1, rx499_done
    eq rx499_pos, -1, rx499_fail
    jump $I10
  rx499_done:
    rx499_cur."!cursor_fail"()
    if_null rx499_debug, debug_787
    rx499_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_787:
    .return (rx499_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1303391609.928") :method
.annotate 'line', 10
    $P501 = self."!PREFIX__!subrule"("ws", "until")
    new $P502, "ResizablePMCArray"
    push $P502, $P501
    .return ($P502)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx508_tgt
    .local int rx508_pos
    .local int rx508_off
    .local int rx508_eos
    .local int rx508_rep
    .local pmc rx508_cur
    .local pmc rx508_debug
    (rx508_cur, rx508_pos, rx508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx508_cur
    .local pmc match
    .lex "$/", match
    length rx508_eos, rx508_tgt
    gt rx508_pos, rx508_eos, rx508_done
    set rx508_off, 0
    lt rx508_pos, 2, rx508_start
    sub rx508_off, rx508_pos, 1
    substr rx508_tgt, rx508_tgt, rx508_off
  rx508_start:
    eq $I10, 1, rx508_restart
    if_null rx508_debug, debug_788
    rx508_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan512_done
    goto rxscan512_scan
  rxscan512_loop:
    (rx508_pos) = rx508_cur."from"()
    inc rx508_pos
    rx508_cur."!cursor_from"(rx508_pos)
    ge rx508_pos, rx508_eos, rxscan512_done
  rxscan512_scan:
    set_addr $I10, rxscan512_loop
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  rxscan512_done:
.annotate 'line', 269
  # rx subcapture "sym"
    set_addr $I10, rxcap_513_fail
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  # rx literal  "for"
    add $I11, rx508_pos, 3
    gt $I11, rx508_eos, rx508_fail
    sub $I11, rx508_pos, rx508_off
    substr $S10, rx508_tgt, $I11, 3
    ne $S10, "for", rx508_fail
    add rx508_pos, 3
    set_addr $I10, rxcap_513_fail
    ($I12, $I11) = rx508_cur."!mark_peek"($I10)
    rx508_cur."!cursor_pos"($I11)
    ($P10) = rx508_cur."!cursor_start"()
    $P10."!cursor_pass"(rx508_pos, "")
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_513_done
  rxcap_513_fail:
    goto rx508_fail
  rxcap_513_done:
  # rx subrule "ws" subtype=method negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."ws"()
    unless $P10, rx508_fail
    rx508_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."EXPR"()
    unless $P10, rx508_fail
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx508_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."ws"()
    unless $P10, rx508_fail
    rx508_pos = $P10."pos"()
  # rx pass
    rx508_cur."!cursor_pass"(rx508_pos, "statement_mod_loop:sym<for>")
    if_null rx508_debug, debug_789
    rx508_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx508_pos)
  debug_789:
    .return (rx508_cur)
  rx508_restart:
.annotate 'line', 10
    if_null rx508_debug, debug_790
    rx508_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_790:
  rx508_fail:
    (rx508_rep, rx508_pos, $I10, $P10) = rx508_cur."!mark_fail"(0)
    lt rx508_pos, -1, rx508_done
    eq rx508_pos, -1, rx508_fail
    jump $I10
  rx508_done:
    rx508_cur."!cursor_fail"()
    if_null rx508_debug, debug_791
    rx508_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_791:
    .return (rx508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1303391609.928") :method
.annotate 'line', 10
    $P510 = self."!PREFIX__!subrule"("ws", "for")
    new $P511, "ResizablePMCArray"
    push $P511, $P510
    .return ($P511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx517_tgt
    .local int rx517_pos
    .local int rx517_off
    .local int rx517_eos
    .local int rx517_rep
    .local pmc rx517_cur
    .local pmc rx517_debug
    (rx517_cur, rx517_pos, rx517_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx517_cur
    .local pmc match
    .lex "$/", match
    length rx517_eos, rx517_tgt
    gt rx517_pos, rx517_eos, rx517_done
    set rx517_off, 0
    lt rx517_pos, 2, rx517_start
    sub rx517_off, rx517_pos, 1
    substr rx517_tgt, rx517_tgt, rx517_off
  rx517_start:
    eq $I10, 1, rx517_restart
    if_null rx517_debug, debug_792
    rx517_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_792:
    $I10 = self.'from'()
    ne $I10, -1, rxscan521_done
    goto rxscan521_scan
  rxscan521_loop:
    (rx517_pos) = rx517_cur."from"()
    inc rx517_pos
    rx517_cur."!cursor_from"(rx517_pos)
    ge rx517_pos, rx517_eos, rxscan521_done
  rxscan521_scan:
    set_addr $I10, rxscan521_loop
    rx517_cur."!mark_push"(0, rx517_pos, $I10)
  rxscan521_done:
.annotate 'line', 273
  # rx subrule "fatarrow" subtype=capture negate=
    rx517_cur."!cursor_pos"(rx517_pos)
    $P10 = rx517_cur."fatarrow"()
    unless $P10, rx517_fail
    rx517_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx517_pos = $P10."pos"()
  # rx pass
    rx517_cur."!cursor_pass"(rx517_pos, "term:sym<fatarrow>")
    if_null rx517_debug, debug_793
    rx517_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx517_pos)
  debug_793:
    .return (rx517_cur)
  rx517_restart:
.annotate 'line', 10
    if_null rx517_debug, debug_794
    rx517_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_794:
  rx517_fail:
    (rx517_rep, rx517_pos, $I10, $P10) = rx517_cur."!mark_fail"(0)
    lt rx517_pos, -1, rx517_done
    eq rx517_pos, -1, rx517_fail
    jump $I10
  rx517_done:
    rx517_cur."!cursor_fail"()
    if_null rx517_debug, debug_795
    rx517_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_795:
    .return (rx517_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1303391609.928") :method
.annotate 'line', 10
    $P519 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P520, "ResizablePMCArray"
    push $P520, $P519
    .return ($P520)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx523_tgt
    .local int rx523_pos
    .local int rx523_off
    .local int rx523_eos
    .local int rx523_rep
    .local pmc rx523_cur
    .local pmc rx523_debug
    (rx523_cur, rx523_pos, rx523_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx523_cur
    .local pmc match
    .lex "$/", match
    length rx523_eos, rx523_tgt
    gt rx523_pos, rx523_eos, rx523_done
    set rx523_off, 0
    lt rx523_pos, 2, rx523_start
    sub rx523_off, rx523_pos, 1
    substr rx523_tgt, rx523_tgt, rx523_off
  rx523_start:
    eq $I10, 1, rx523_restart
    if_null rx523_debug, debug_796
    rx523_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_796:
    $I10 = self.'from'()
    ne $I10, -1, rxscan527_done
    goto rxscan527_scan
  rxscan527_loop:
    (rx523_pos) = rx523_cur."from"()
    inc rx523_pos
    rx523_cur."!cursor_from"(rx523_pos)
    ge rx523_pos, rx523_eos, rxscan527_done
  rxscan527_scan:
    set_addr $I10, rxscan527_loop
    rx523_cur."!mark_push"(0, rx523_pos, $I10)
  rxscan527_done:
.annotate 'line', 274
  # rx subrule "colonpair" subtype=capture negate=
    rx523_cur."!cursor_pos"(rx523_pos)
    $P10 = rx523_cur."colonpair"()
    unless $P10, rx523_fail
    rx523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx523_pos = $P10."pos"()
  # rx pass
    rx523_cur."!cursor_pass"(rx523_pos, "term:sym<colonpair>")
    if_null rx523_debug, debug_797
    rx523_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx523_pos)
  debug_797:
    .return (rx523_cur)
  rx523_restart:
.annotate 'line', 10
    if_null rx523_debug, debug_798
    rx523_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_798:
  rx523_fail:
    (rx523_rep, rx523_pos, $I10, $P10) = rx523_cur."!mark_fail"(0)
    lt rx523_pos, -1, rx523_done
    eq rx523_pos, -1, rx523_fail
    jump $I10
  rx523_done:
    rx523_cur."!cursor_fail"()
    if_null rx523_debug, debug_799
    rx523_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_799:
    .return (rx523_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1303391609.928") :method
.annotate 'line', 10
    $P525 = self."!PREFIX__!subrule"("colonpair", "")
    new $P526, "ResizablePMCArray"
    push $P526, $P525
    .return ($P526)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx529_tgt
    .local int rx529_pos
    .local int rx529_off
    .local int rx529_eos
    .local int rx529_rep
    .local pmc rx529_cur
    .local pmc rx529_debug
    (rx529_cur, rx529_pos, rx529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx529_cur
    .local pmc match
    .lex "$/", match
    length rx529_eos, rx529_tgt
    gt rx529_pos, rx529_eos, rx529_done
    set rx529_off, 0
    lt rx529_pos, 2, rx529_start
    sub rx529_off, rx529_pos, 1
    substr rx529_tgt, rx529_tgt, rx529_off
  rx529_start:
    eq $I10, 1, rx529_restart
    if_null rx529_debug, debug_800
    rx529_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_800:
    $I10 = self.'from'()
    ne $I10, -1, rxscan533_done
    goto rxscan533_scan
  rxscan533_loop:
    (rx529_pos) = rx529_cur."from"()
    inc rx529_pos
    rx529_cur."!cursor_from"(rx529_pos)
    ge rx529_pos, rx529_eos, rxscan533_done
  rxscan533_scan:
    set_addr $I10, rxscan533_loop
    rx529_cur."!mark_push"(0, rx529_pos, $I10)
  rxscan533_done:
.annotate 'line', 275
  # rx subrule "variable" subtype=capture negate=
    rx529_cur."!cursor_pos"(rx529_pos)
    $P10 = rx529_cur."variable"()
    unless $P10, rx529_fail
    rx529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx529_pos = $P10."pos"()
  # rx pass
    rx529_cur."!cursor_pass"(rx529_pos, "term:sym<variable>")
    if_null rx529_debug, debug_801
    rx529_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx529_pos)
  debug_801:
    .return (rx529_cur)
  rx529_restart:
.annotate 'line', 10
    if_null rx529_debug, debug_802
    rx529_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_802:
  rx529_fail:
    (rx529_rep, rx529_pos, $I10, $P10) = rx529_cur."!mark_fail"(0)
    lt rx529_pos, -1, rx529_done
    eq rx529_pos, -1, rx529_fail
    jump $I10
  rx529_done:
    rx529_cur."!cursor_fail"()
    if_null rx529_debug, debug_803
    rx529_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_803:
    .return (rx529_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1303391609.928") :method
.annotate 'line', 10
    $P531 = self."!PREFIX__!subrule"("variable", "")
    new $P532, "ResizablePMCArray"
    push $P532, $P531
    .return ($P532)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx535_tgt
    .local int rx535_pos
    .local int rx535_off
    .local int rx535_eos
    .local int rx535_rep
    .local pmc rx535_cur
    .local pmc rx535_debug
    (rx535_cur, rx535_pos, rx535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx535_cur
    .local pmc match
    .lex "$/", match
    length rx535_eos, rx535_tgt
    gt rx535_pos, rx535_eos, rx535_done
    set rx535_off, 0
    lt rx535_pos, 2, rx535_start
    sub rx535_off, rx535_pos, 1
    substr rx535_tgt, rx535_tgt, rx535_off
  rx535_start:
    eq $I10, 1, rx535_restart
    if_null rx535_debug, debug_804
    rx535_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_804:
    $I10 = self.'from'()
    ne $I10, -1, rxscan539_done
    goto rxscan539_scan
  rxscan539_loop:
    (rx535_pos) = rx535_cur."from"()
    inc rx535_pos
    rx535_cur."!cursor_from"(rx535_pos)
    ge rx535_pos, rx535_eos, rxscan539_done
  rxscan539_scan:
    set_addr $I10, rxscan539_loop
    rx535_cur."!mark_push"(0, rx535_pos, $I10)
  rxscan539_done:
.annotate 'line', 276
  # rx subrule "package_declarator" subtype=capture negate=
    rx535_cur."!cursor_pos"(rx535_pos)
    $P10 = rx535_cur."package_declarator"()
    unless $P10, rx535_fail
    rx535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx535_pos = $P10."pos"()
  # rx pass
    rx535_cur."!cursor_pass"(rx535_pos, "term:sym<package_declarator>")
    if_null rx535_debug, debug_805
    rx535_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx535_pos)
  debug_805:
    .return (rx535_cur)
  rx535_restart:
.annotate 'line', 10
    if_null rx535_debug, debug_806
    rx535_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_806:
  rx535_fail:
    (rx535_rep, rx535_pos, $I10, $P10) = rx535_cur."!mark_fail"(0)
    lt rx535_pos, -1, rx535_done
    eq rx535_pos, -1, rx535_fail
    jump $I10
  rx535_done:
    rx535_cur."!cursor_fail"()
    if_null rx535_debug, debug_807
    rx535_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_807:
    .return (rx535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1303391609.928") :method
.annotate 'line', 10
    $P537 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P538, "ResizablePMCArray"
    push $P538, $P537
    .return ($P538)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx541_tgt
    .local int rx541_pos
    .local int rx541_off
    .local int rx541_eos
    .local int rx541_rep
    .local pmc rx541_cur
    .local pmc rx541_debug
    (rx541_cur, rx541_pos, rx541_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx541_cur
    .local pmc match
    .lex "$/", match
    length rx541_eos, rx541_tgt
    gt rx541_pos, rx541_eos, rx541_done
    set rx541_off, 0
    lt rx541_pos, 2, rx541_start
    sub rx541_off, rx541_pos, 1
    substr rx541_tgt, rx541_tgt, rx541_off
  rx541_start:
    eq $I10, 1, rx541_restart
    if_null rx541_debug, debug_808
    rx541_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan545_done
    goto rxscan545_scan
  rxscan545_loop:
    (rx541_pos) = rx541_cur."from"()
    inc rx541_pos
    rx541_cur."!cursor_from"(rx541_pos)
    ge rx541_pos, rx541_eos, rxscan545_done
  rxscan545_scan:
    set_addr $I10, rxscan545_loop
    rx541_cur."!mark_push"(0, rx541_pos, $I10)
  rxscan545_done:
.annotate 'line', 277
  # rx subrule "scope_declarator" subtype=capture negate=
    rx541_cur."!cursor_pos"(rx541_pos)
    $P10 = rx541_cur."scope_declarator"()
    unless $P10, rx541_fail
    rx541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx541_pos = $P10."pos"()
  # rx pass
    rx541_cur."!cursor_pass"(rx541_pos, "term:sym<scope_declarator>")
    if_null rx541_debug, debug_809
    rx541_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx541_pos)
  debug_809:
    .return (rx541_cur)
  rx541_restart:
.annotate 'line', 10
    if_null rx541_debug, debug_810
    rx541_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_810:
  rx541_fail:
    (rx541_rep, rx541_pos, $I10, $P10) = rx541_cur."!mark_fail"(0)
    lt rx541_pos, -1, rx541_done
    eq rx541_pos, -1, rx541_fail
    jump $I10
  rx541_done:
    rx541_cur."!cursor_fail"()
    if_null rx541_debug, debug_811
    rx541_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_811:
    .return (rx541_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1303391609.928") :method
.annotate 'line', 10
    $P543 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P544, "ResizablePMCArray"
    push $P544, $P543
    .return ($P544)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx547_tgt
    .local int rx547_pos
    .local int rx547_off
    .local int rx547_eos
    .local int rx547_rep
    .local pmc rx547_cur
    .local pmc rx547_debug
    (rx547_cur, rx547_pos, rx547_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx547_cur
    .local pmc match
    .lex "$/", match
    length rx547_eos, rx547_tgt
    gt rx547_pos, rx547_eos, rx547_done
    set rx547_off, 0
    lt rx547_pos, 2, rx547_start
    sub rx547_off, rx547_pos, 1
    substr rx547_tgt, rx547_tgt, rx547_off
  rx547_start:
    eq $I10, 1, rx547_restart
    if_null rx547_debug, debug_812
    rx547_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan551_done
    goto rxscan551_scan
  rxscan551_loop:
    (rx547_pos) = rx547_cur."from"()
    inc rx547_pos
    rx547_cur."!cursor_from"(rx547_pos)
    ge rx547_pos, rx547_eos, rxscan551_done
  rxscan551_scan:
    set_addr $I10, rxscan551_loop
    rx547_cur."!mark_push"(0, rx547_pos, $I10)
  rxscan551_done:
.annotate 'line', 278
  # rx subrule "routine_declarator" subtype=capture negate=
    rx547_cur."!cursor_pos"(rx547_pos)
    $P10 = rx547_cur."routine_declarator"()
    unless $P10, rx547_fail
    rx547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx547_pos = $P10."pos"()
  # rx pass
    rx547_cur."!cursor_pass"(rx547_pos, "term:sym<routine_declarator>")
    if_null rx547_debug, debug_813
    rx547_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx547_pos)
  debug_813:
    .return (rx547_cur)
  rx547_restart:
.annotate 'line', 10
    if_null rx547_debug, debug_814
    rx547_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_814:
  rx547_fail:
    (rx547_rep, rx547_pos, $I10, $P10) = rx547_cur."!mark_fail"(0)
    lt rx547_pos, -1, rx547_done
    eq rx547_pos, -1, rx547_fail
    jump $I10
  rx547_done:
    rx547_cur."!cursor_fail"()
    if_null rx547_debug, debug_815
    rx547_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_815:
    .return (rx547_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1303391609.928") :method
.annotate 'line', 10
    $P549 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P550, "ResizablePMCArray"
    push $P550, $P549
    .return ($P550)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P563 = "121_1303391609.928" 
    capture_lex $P563
    .const 'Sub' $P558 = "120_1303391609.928" 
    capture_lex $P558
    .local string rx553_tgt
    .local int rx553_pos
    .local int rx553_off
    .local int rx553_eos
    .local int rx553_rep
    .local pmc rx553_cur
    .local pmc rx553_debug
    (rx553_cur, rx553_pos, rx553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx553_cur
    .local pmc match
    .lex "$/", match
    length rx553_eos, rx553_tgt
    gt rx553_pos, rx553_eos, rx553_done
    set rx553_off, 0
    lt rx553_pos, 2, rx553_start
    sub rx553_off, rx553_pos, 1
    substr rx553_tgt, rx553_tgt, rx553_off
  rx553_start:
    eq $I10, 1, rx553_restart
    if_null rx553_debug, debug_816
    rx553_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan556_done
    goto rxscan556_scan
  rxscan556_loop:
    (rx553_pos) = rx553_cur."from"()
    inc rx553_pos
    rx553_cur."!cursor_from"(rx553_pos)
    ge rx553_pos, rx553_eos, rxscan556_done
  rxscan556_scan:
    set_addr $I10, rxscan556_loop
    rx553_cur."!mark_push"(0, rx553_pos, $I10)
  rxscan556_done:
.annotate 'line', 280
  # rx subrule "before" subtype=zerowidth negate=
    rx553_cur."!cursor_pos"(rx553_pos)
    .const 'Sub' $P558 = "120_1303391609.928" 
    capture_lex $P558
    $P10 = rx553_cur."before"($P558)
    unless $P10, rx553_fail
.annotate 'line', 281
  # rx subrule "before" subtype=zerowidth negate=1
    rx553_cur."!cursor_pos"(rx553_pos)
    .const 'Sub' $P563 = "121_1303391609.928" 
    capture_lex $P563
    $P10 = rx553_cur."before"($P563)
    if $P10, rx553_fail
.annotate 'line', 282
  # rx subrule "multi_declarator" subtype=capture negate=
    rx553_cur."!cursor_pos"(rx553_pos)
    $P10 = rx553_cur."multi_declarator"()
    unless $P10, rx553_fail
    rx553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx553_pos = $P10."pos"()
.annotate 'line', 279
  # rx pass
    rx553_cur."!cursor_pass"(rx553_pos, "term:sym<multi_declarator>")
    if_null rx553_debug, debug_825
    rx553_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx553_pos)
  debug_825:
    .return (rx553_cur)
  rx553_restart:
.annotate 'line', 10
    if_null rx553_debug, debug_826
    rx553_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_826:
  rx553_fail:
    (rx553_rep, rx553_pos, $I10, $P10) = rx553_cur."!mark_fail"(0)
    lt rx553_pos, -1, rx553_done
    eq rx553_pos, -1, rx553_fail
    jump $I10
  rx553_done:
    rx553_cur."!cursor_fail"()
    if_null rx553_debug, debug_827
    rx553_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_827:
    .return (rx553_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1303391609.928") :method
.annotate 'line', 10
    new $P555, "ResizablePMCArray"
    push $P555, ""
    .return ($P555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block557"  :anon :subid("120_1303391609.928") :method :outer("118_1303391609.928")
.annotate 'line', 280
    .local string rx559_tgt
    .local int rx559_pos
    .local int rx559_off
    .local int rx559_eos
    .local int rx559_rep
    .local pmc rx559_cur
    .local pmc rx559_debug
    (rx559_cur, rx559_pos, rx559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx559_cur
    .local pmc match
    .lex "$/", match
    length rx559_eos, rx559_tgt
    gt rx559_pos, rx559_eos, rx559_done
    set rx559_off, 0
    lt rx559_pos, 2, rx559_start
    sub rx559_off, rx559_pos, 1
    substr rx559_tgt, rx559_tgt, rx559_off
  rx559_start:
    eq $I10, 1, rx559_restart
    if_null rx559_debug, debug_817
    rx559_cur."!cursor_debug"("START", "")
  debug_817:
    $I10 = self.'from'()
    ne $I10, -1, rxscan560_done
    goto rxscan560_scan
  rxscan560_loop:
    (rx559_pos) = rx559_cur."from"()
    inc rx559_pos
    rx559_cur."!cursor_from"(rx559_pos)
    ge rx559_pos, rx559_eos, rxscan560_done
  rxscan560_scan:
    set_addr $I10, rxscan560_loop
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  rxscan560_done:
  alt561_0:
    set_addr $I10, alt561_1
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  # rx literal  "multi"
    add $I11, rx559_pos, 5
    gt $I11, rx559_eos, rx559_fail
    sub $I11, rx559_pos, rx559_off
    substr $S10, rx559_tgt, $I11, 5
    ne $S10, "multi", rx559_fail
    add rx559_pos, 5
    goto alt561_end
  alt561_1:
    set_addr $I10, alt561_2
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  # rx literal  "proto"
    add $I11, rx559_pos, 5
    gt $I11, rx559_eos, rx559_fail
    sub $I11, rx559_pos, rx559_off
    substr $S10, rx559_tgt, $I11, 5
    ne $S10, "proto", rx559_fail
    add rx559_pos, 5
    goto alt561_end
  alt561_2:
  # rx literal  "only"
    add $I11, rx559_pos, 4
    gt $I11, rx559_eos, rx559_fail
    sub $I11, rx559_pos, rx559_off
    substr $S10, rx559_tgt, $I11, 4
    ne $S10, "only", rx559_fail
    add rx559_pos, 4
  alt561_end:
  # rx pass
    rx559_cur."!cursor_pass"(rx559_pos, "")
    if_null rx559_debug, debug_818
    rx559_cur."!cursor_debug"("PASS", "", " at pos=", rx559_pos)
  debug_818:
    .return (rx559_cur)
  rx559_restart:
    if_null rx559_debug, debug_819
    rx559_cur."!cursor_debug"("NEXT", "")
  debug_819:
  rx559_fail:
    (rx559_rep, rx559_pos, $I10, $P10) = rx559_cur."!mark_fail"(0)
    lt rx559_pos, -1, rx559_done
    eq rx559_pos, -1, rx559_fail
    jump $I10
  rx559_done:
    rx559_cur."!cursor_fail"()
    if_null rx559_debug, debug_820
    rx559_cur."!cursor_debug"("FAIL", "")
  debug_820:
    .return (rx559_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block562"  :anon :subid("121_1303391609.928") :method :outer("118_1303391609.928")
.annotate 'line', 281
    .local string rx564_tgt
    .local int rx564_pos
    .local int rx564_off
    .local int rx564_eos
    .local int rx564_rep
    .local pmc rx564_cur
    .local pmc rx564_debug
    (rx564_cur, rx564_pos, rx564_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx564_cur
    .local pmc match
    .lex "$/", match
    length rx564_eos, rx564_tgt
    gt rx564_pos, rx564_eos, rx564_done
    set rx564_off, 0
    lt rx564_pos, 2, rx564_start
    sub rx564_off, rx564_pos, 1
    substr rx564_tgt, rx564_tgt, rx564_off
  rx564_start:
    eq $I10, 1, rx564_restart
    if_null rx564_debug, debug_821
    rx564_cur."!cursor_debug"("START", "")
  debug_821:
    $I10 = self.'from'()
    ne $I10, -1, rxscan565_done
    goto rxscan565_scan
  rxscan565_loop:
    (rx564_pos) = rx564_cur."from"()
    inc rx564_pos
    rx564_cur."!cursor_from"(rx564_pos)
    ge rx564_pos, rx564_eos, rxscan565_done
  rxscan565_scan:
    set_addr $I10, rxscan565_loop
    rx564_cur."!mark_push"(0, rx564_pos, $I10)
  rxscan565_done:
  # rx literal  "proto"
    add $I11, rx564_pos, 5
    gt $I11, rx564_eos, rx564_fail
    sub $I11, rx564_pos, rx564_off
    substr $S10, rx564_tgt, $I11, 5
    ne $S10, "proto", rx564_fail
    add rx564_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx564_cur."!cursor_pos"(rx564_pos)
    $P10 = rx564_cur."ws"()
    unless $P10, rx564_fail
    rx564_pos = $P10."pos"()
  alt566_0:
    set_addr $I10, alt566_1
    rx564_cur."!mark_push"(0, rx564_pos, $I10)
  # rx literal  "regex"
    add $I11, rx564_pos, 5
    gt $I11, rx564_eos, rx564_fail
    sub $I11, rx564_pos, rx564_off
    substr $S10, rx564_tgt, $I11, 5
    ne $S10, "regex", rx564_fail
    add rx564_pos, 5
    goto alt566_end
  alt566_1:
    set_addr $I10, alt566_2
    rx564_cur."!mark_push"(0, rx564_pos, $I10)
  # rx literal  "token"
    add $I11, rx564_pos, 5
    gt $I11, rx564_eos, rx564_fail
    sub $I11, rx564_pos, rx564_off
    substr $S10, rx564_tgt, $I11, 5
    ne $S10, "token", rx564_fail
    add rx564_pos, 5
    goto alt566_end
  alt566_2:
  # rx literal  "rule"
    add $I11, rx564_pos, 4
    gt $I11, rx564_eos, rx564_fail
    sub $I11, rx564_pos, rx564_off
    substr $S10, rx564_tgt, $I11, 4
    ne $S10, "rule", rx564_fail
    add rx564_pos, 4
  alt566_end:
  # rx pass
    rx564_cur."!cursor_pass"(rx564_pos, "")
    if_null rx564_debug, debug_822
    rx564_cur."!cursor_debug"("PASS", "", " at pos=", rx564_pos)
  debug_822:
    .return (rx564_cur)
  rx564_restart:
    if_null rx564_debug, debug_823
    rx564_cur."!cursor_debug"("NEXT", "")
  debug_823:
  rx564_fail:
    (rx564_rep, rx564_pos, $I10, $P10) = rx564_cur."!mark_fail"(0)
    lt rx564_pos, -1, rx564_done
    eq rx564_pos, -1, rx564_fail
    jump $I10
  rx564_done:
    rx564_cur."!cursor_fail"()
    if_null rx564_debug, debug_824
    rx564_cur."!cursor_debug"("FAIL", "")
  debug_824:
    .return (rx564_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx568_tgt
    .local int rx568_pos
    .local int rx568_off
    .local int rx568_eos
    .local int rx568_rep
    .local pmc rx568_cur
    .local pmc rx568_debug
    (rx568_cur, rx568_pos, rx568_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx568_cur
    .local pmc match
    .lex "$/", match
    length rx568_eos, rx568_tgt
    gt rx568_pos, rx568_eos, rx568_done
    set rx568_off, 0
    lt rx568_pos, 2, rx568_start
    sub rx568_off, rx568_pos, 1
    substr rx568_tgt, rx568_tgt, rx568_off
  rx568_start:
    eq $I10, 1, rx568_restart
    if_null rx568_debug, debug_828
    rx568_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan572_done
    goto rxscan572_scan
  rxscan572_loop:
    (rx568_pos) = rx568_cur."from"()
    inc rx568_pos
    rx568_cur."!cursor_from"(rx568_pos)
    ge rx568_pos, rx568_eos, rxscan572_done
  rxscan572_scan:
    set_addr $I10, rxscan572_loop
    rx568_cur."!mark_push"(0, rx568_pos, $I10)
  rxscan572_done:
.annotate 'line', 284
  # rx subrule "regex_declarator" subtype=capture negate=
    rx568_cur."!cursor_pos"(rx568_pos)
    $P10 = rx568_cur."regex_declarator"()
    unless $P10, rx568_fail
    rx568_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx568_pos = $P10."pos"()
  # rx pass
    rx568_cur."!cursor_pass"(rx568_pos, "term:sym<regex_declarator>")
    if_null rx568_debug, debug_829
    rx568_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx568_pos)
  debug_829:
    .return (rx568_cur)
  rx568_restart:
.annotate 'line', 10
    if_null rx568_debug, debug_830
    rx568_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_830:
  rx568_fail:
    (rx568_rep, rx568_pos, $I10, $P10) = rx568_cur."!mark_fail"(0)
    lt rx568_pos, -1, rx568_done
    eq rx568_pos, -1, rx568_fail
    jump $I10
  rx568_done:
    rx568_cur."!cursor_fail"()
    if_null rx568_debug, debug_831
    rx568_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_831:
    .return (rx568_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1303391609.928") :method
.annotate 'line', 10
    $P570 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P571, "ResizablePMCArray"
    push $P571, $P570
    .return ($P571)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx574_tgt
    .local int rx574_pos
    .local int rx574_off
    .local int rx574_eos
    .local int rx574_rep
    .local pmc rx574_cur
    .local pmc rx574_debug
    (rx574_cur, rx574_pos, rx574_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx574_cur
    .local pmc match
    .lex "$/", match
    length rx574_eos, rx574_tgt
    gt rx574_pos, rx574_eos, rx574_done
    set rx574_off, 0
    lt rx574_pos, 2, rx574_start
    sub rx574_off, rx574_pos, 1
    substr rx574_tgt, rx574_tgt, rx574_off
  rx574_start:
    eq $I10, 1, rx574_restart
    if_null rx574_debug, debug_832
    rx574_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan578_done
    goto rxscan578_scan
  rxscan578_loop:
    (rx574_pos) = rx574_cur."from"()
    inc rx574_pos
    rx574_cur."!cursor_from"(rx574_pos)
    ge rx574_pos, rx574_eos, rxscan578_done
  rxscan578_scan:
    set_addr $I10, rxscan578_loop
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  rxscan578_done:
.annotate 'line', 285
  # rx subrule "statement_prefix" subtype=capture negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."statement_prefix"()
    unless $P10, rx574_fail
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx574_pos = $P10."pos"()
  # rx pass
    rx574_cur."!cursor_pass"(rx574_pos, "term:sym<statement_prefix>")
    if_null rx574_debug, debug_833
    rx574_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx574_pos)
  debug_833:
    .return (rx574_cur)
  rx574_restart:
.annotate 'line', 10
    if_null rx574_debug, debug_834
    rx574_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_834:
  rx574_fail:
    (rx574_rep, rx574_pos, $I10, $P10) = rx574_cur."!mark_fail"(0)
    lt rx574_pos, -1, rx574_done
    eq rx574_pos, -1, rx574_fail
    jump $I10
  rx574_done:
    rx574_cur."!cursor_fail"()
    if_null rx574_debug, debug_835
    rx574_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_835:
    .return (rx574_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1303391609.928") :method
.annotate 'line', 10
    $P576 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P577, "ResizablePMCArray"
    push $P577, $P576
    .return ($P577)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx580_tgt
    .local int rx580_pos
    .local int rx580_off
    .local int rx580_eos
    .local int rx580_rep
    .local pmc rx580_cur
    .local pmc rx580_debug
    (rx580_cur, rx580_pos, rx580_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx580_cur
    .local pmc match
    .lex "$/", match
    length rx580_eos, rx580_tgt
    gt rx580_pos, rx580_eos, rx580_done
    set rx580_off, 0
    lt rx580_pos, 2, rx580_start
    sub rx580_off, rx580_pos, 1
    substr rx580_tgt, rx580_tgt, rx580_off
  rx580_start:
    eq $I10, 1, rx580_restart
    if_null rx580_debug, debug_836
    rx580_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan583_done
    goto rxscan583_scan
  rxscan583_loop:
    (rx580_pos) = rx580_cur."from"()
    inc rx580_pos
    rx580_cur."!cursor_from"(rx580_pos)
    ge rx580_pos, rx580_eos, rxscan583_done
  rxscan583_scan:
    set_addr $I10, rxscan583_loop
    rx580_cur."!mark_push"(0, rx580_pos, $I10)
  rxscan583_done:
.annotate 'line', 286
  # rx subrule "lambda" subtype=zerowidth negate=
    rx580_cur."!cursor_pos"(rx580_pos)
    $P10 = rx580_cur."lambda"()
    unless $P10, rx580_fail
  # rx subrule "pblock" subtype=capture negate=
    rx580_cur."!cursor_pos"(rx580_pos)
    $P10 = rx580_cur."pblock"()
    unless $P10, rx580_fail
    rx580_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx580_pos = $P10."pos"()
  # rx pass
    rx580_cur."!cursor_pass"(rx580_pos, "term:sym<lambda>")
    if_null rx580_debug, debug_837
    rx580_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx580_pos)
  debug_837:
    .return (rx580_cur)
  rx580_restart:
.annotate 'line', 10
    if_null rx580_debug, debug_838
    rx580_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_838:
  rx580_fail:
    (rx580_rep, rx580_pos, $I10, $P10) = rx580_cur."!mark_fail"(0)
    lt rx580_pos, -1, rx580_done
    eq rx580_pos, -1, rx580_fail
    jump $I10
  rx580_done:
    rx580_cur."!cursor_fail"()
    if_null rx580_debug, debug_839
    rx580_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_839:
    .return (rx580_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1303391609.928") :method
.annotate 'line', 10
    new $P582, "ResizablePMCArray"
    push $P582, ""
    .return ($P582)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx585_tgt
    .local int rx585_pos
    .local int rx585_off
    .local int rx585_eos
    .local int rx585_rep
    .local pmc rx585_cur
    .local pmc rx585_debug
    (rx585_cur, rx585_pos, rx585_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx585_cur
    .local pmc match
    .lex "$/", match
    length rx585_eos, rx585_tgt
    gt rx585_pos, rx585_eos, rx585_done
    set rx585_off, 0
    lt rx585_pos, 2, rx585_start
    sub rx585_off, rx585_pos, 1
    substr rx585_tgt, rx585_tgt, rx585_off
  rx585_start:
    eq $I10, 1, rx585_restart
    if_null rx585_debug, debug_840
    rx585_cur."!cursor_debug"("START", "fatarrow")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan589_done
    goto rxscan589_scan
  rxscan589_loop:
    (rx585_pos) = rx585_cur."from"()
    inc rx585_pos
    rx585_cur."!cursor_from"(rx585_pos)
    ge rx585_pos, rx585_eos, rxscan589_done
  rxscan589_scan:
    set_addr $I10, rxscan589_loop
    rx585_cur."!mark_push"(0, rx585_pos, $I10)
  rxscan589_done:
.annotate 'line', 289
  # rx subrule "identifier" subtype=capture negate=
    rx585_cur."!cursor_pos"(rx585_pos)
    $P10 = rx585_cur."identifier"()
    unless $P10, rx585_fail
    rx585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx585_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx585_pos, rx585_off
    set rx585_rep, 0
    sub $I12, rx585_eos, rx585_pos
  rxenumcharlistq590_loop:
    le $I12, 0, rxenumcharlistq590_done
    substr $S10, rx585_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq590_done
    inc rx585_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq590_loop
  rxenumcharlistq590_done:
    add rx585_pos, rx585_pos, rx585_rep
  # rx literal  "=>"
    add $I11, rx585_pos, 2
    gt $I11, rx585_eos, rx585_fail
    sub $I11, rx585_pos, rx585_off
    substr $S10, rx585_tgt, $I11, 2
    ne $S10, "=>", rx585_fail
    add rx585_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx585_cur."!cursor_pos"(rx585_pos)
    $P10 = rx585_cur."ws"()
    unless $P10, rx585_fail
    rx585_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx585_cur."!cursor_pos"(rx585_pos)
    $P10 = rx585_cur."EXPR"("i=")
    unless $P10, rx585_fail
    rx585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx585_pos = $P10."pos"()
.annotate 'line', 288
  # rx pass
    rx585_cur."!cursor_pass"(rx585_pos, "fatarrow")
    if_null rx585_debug, debug_841
    rx585_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx585_pos)
  debug_841:
    .return (rx585_cur)
  rx585_restart:
.annotate 'line', 10
    if_null rx585_debug, debug_842
    rx585_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_842:
  rx585_fail:
    (rx585_rep, rx585_pos, $I10, $P10) = rx585_cur."!mark_fail"(0)
    lt rx585_pos, -1, rx585_done
    eq rx585_pos, -1, rx585_fail
    jump $I10
  rx585_done:
    rx585_cur."!cursor_fail"()
    if_null rx585_debug, debug_843
    rx585_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_843:
    .return (rx585_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1303391609.928") :method
.annotate 'line', 10
    $P587 = self."!PREFIX__!subrule"("identifier", "")
    new $P588, "ResizablePMCArray"
    push $P588, $P587
    .return ($P588)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx592_tgt
    .local int rx592_pos
    .local int rx592_off
    .local int rx592_eos
    .local int rx592_rep
    .local pmc rx592_cur
    .local pmc rx592_debug
    (rx592_cur, rx592_pos, rx592_tgt, $I10) = self."!cursor_start"()
    rx592_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx592_cur
    .local pmc match
    .lex "$/", match
    length rx592_eos, rx592_tgt
    gt rx592_pos, rx592_eos, rx592_done
    set rx592_off, 0
    lt rx592_pos, 2, rx592_start
    sub rx592_off, rx592_pos, 1
    substr rx592_tgt, rx592_tgt, rx592_off
  rx592_start:
    eq $I10, 1, rx592_restart
    if_null rx592_debug, debug_844
    rx592_cur."!cursor_debug"("START", "colonpair")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan598_done
    goto rxscan598_scan
  rxscan598_loop:
    (rx592_pos) = rx592_cur."from"()
    inc rx592_pos
    rx592_cur."!cursor_from"(rx592_pos)
    ge rx592_pos, rx592_eos, rxscan598_done
  rxscan598_scan:
    set_addr $I10, rxscan598_loop
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  rxscan598_done:
.annotate 'line', 293
  # rx literal  ":"
    add $I11, rx592_pos, 1
    gt $I11, rx592_eos, rx592_fail
    sub $I11, rx592_pos, rx592_off
    ord $I11, rx592_tgt, $I11
    ne $I11, 58, rx592_fail
    add rx592_pos, 1
  alt599_0:
.annotate 'line', 294
    set_addr $I10, alt599_1
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
.annotate 'line', 295
  # rx subcapture "not"
    set_addr $I10, rxcap_600_fail
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  # rx literal  "!"
    add $I11, rx592_pos, 1
    gt $I11, rx592_eos, rx592_fail
    sub $I11, rx592_pos, rx592_off
    ord $I11, rx592_tgt, $I11
    ne $I11, 33, rx592_fail
    add rx592_pos, 1
    set_addr $I10, rxcap_600_fail
    ($I12, $I11) = rx592_cur."!mark_peek"($I10)
    rx592_cur."!cursor_pos"($I11)
    ($P10) = rx592_cur."!cursor_start"()
    $P10."!cursor_pass"(rx592_pos, "")
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_600_done
  rxcap_600_fail:
    goto rx592_fail
  rxcap_600_done:
  # rx subrule "identifier" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."identifier"()
    unless $P10, rx592_fail
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx592_pos = $P10."pos"()
    goto alt599_end
  alt599_1:
    set_addr $I10, alt599_2
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
.annotate 'line', 296
  # rx subrule "identifier" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."identifier"()
    unless $P10, rx592_fail
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx592_pos = $P10."pos"()
  # rx rxquantr601 ** 0..1
    set_addr $I10, rxquantr601_done
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  rxquantr601_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."circumfix"()
    unless $P10, rx592_fail
    goto rxsubrule602_pass
  rxsubrule602_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx592_fail
  rxsubrule602_pass:
    set_addr $I10, rxsubrule602_back
    rx592_cur."!mark_push"(0, rx592_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx592_pos = $P10."pos"()
    set_addr $I10, rxquantr601_done
    (rx592_rep) = rx592_cur."!mark_commit"($I10)
  rxquantr601_done:
    goto alt599_end
  alt599_2:
.annotate 'line', 297
  # rx subrule "circumfix" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."circumfix"()
    unless $P10, rx592_fail
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx592_pos = $P10."pos"()
  alt599_end:
.annotate 'line', 292
  # rx pass
    rx592_cur."!cursor_pass"(rx592_pos, "colonpair")
    if_null rx592_debug, debug_845
    rx592_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx592_pos)
  debug_845:
    .return (rx592_cur)
  rx592_restart:
.annotate 'line', 10
    if_null rx592_debug, debug_846
    rx592_cur."!cursor_debug"("NEXT", "colonpair")
  debug_846:
  rx592_fail:
    (rx592_rep, rx592_pos, $I10, $P10) = rx592_cur."!mark_fail"(0)
    lt rx592_pos, -1, rx592_done
    eq rx592_pos, -1, rx592_fail
    jump $I10
  rx592_done:
    rx592_cur."!cursor_fail"()
    if_null rx592_debug, debug_847
    rx592_cur."!cursor_debug"("FAIL", "colonpair")
  debug_847:
    .return (rx592_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1303391609.928") :method
.annotate 'line', 10
    $P594 = self."!PREFIX__!subrule"("circumfix", ":")
    $P595 = self."!PREFIX__!subrule"("identifier", ":")
    $P596 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P597, "ResizablePMCArray"
    push $P597, $P594
    push $P597, $P595
    push $P597, $P596
    .return ($P597)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx604_tgt
    .local int rx604_pos
    .local int rx604_off
    .local int rx604_eos
    .local int rx604_rep
    .local pmc rx604_cur
    .local pmc rx604_debug
    (rx604_cur, rx604_pos, rx604_tgt, $I10) = self."!cursor_start"()
    rx604_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx604_cur
    .local pmc match
    .lex "$/", match
    length rx604_eos, rx604_tgt
    gt rx604_pos, rx604_eos, rx604_done
    set rx604_off, 0
    lt rx604_pos, 2, rx604_start
    sub rx604_off, rx604_pos, 1
    substr rx604_tgt, rx604_tgt, rx604_off
  rx604_start:
    eq $I10, 1, rx604_restart
    if_null rx604_debug, debug_848
    rx604_cur."!cursor_debug"("START", "variable")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan609_done
    goto rxscan609_scan
  rxscan609_loop:
    (rx604_pos) = rx604_cur."from"()
    inc rx604_pos
    rx604_cur."!cursor_from"(rx604_pos)
    ge rx604_pos, rx604_eos, rxscan609_done
  rxscan609_scan:
    set_addr $I10, rxscan609_loop
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
  rxscan609_done:
  alt610_0:
.annotate 'line', 301
    set_addr $I10, alt610_1
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
.annotate 'line', 302
  # rx subrule "sigil" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."sigil"()
    unless $P10, rx604_fail
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx604_pos = $P10."pos"()
  # rx rxquantr611 ** 0..1
    set_addr $I10, rxquantr611_done
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
  rxquantr611_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."twigil"()
    unless $P10, rx604_fail
    goto rxsubrule612_pass
  rxsubrule612_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx604_fail
  rxsubrule612_pass:
    set_addr $I10, rxsubrule612_back
    rx604_cur."!mark_push"(0, rx604_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx604_pos = $P10."pos"()
    set_addr $I10, rxquantr611_done
    (rx604_rep) = rx604_cur."!mark_commit"($I10)
  rxquantr611_done:
  # rx subrule "name" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."name"()
    unless $P10, rx604_fail
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx604_pos = $P10."pos"()
    goto alt610_end
  alt610_1:
    set_addr $I10, alt610_2
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
.annotate 'line', 303
  # rx subrule "sigil" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."sigil"()
    unless $P10, rx604_fail
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx604_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx604_pos, rx604_off
    substr $S10, rx604_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx604_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx604_cur."!cursor_pos"(rx604_pos)
    $P10 = rx604_cur."postcircumfix"()
    unless $P10, rx604_fail
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx604_pos = $P10."pos"()
    goto alt610_end
  alt610_2:
.annotate 'line', 304
  # rx subcapture "sigil"
    set_addr $I10, rxcap_613_fail
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
  # rx literal  "$"
    add $I11, rx604_pos, 1
    gt $I11, rx604_eos, rx604_fail
    sub $I11, rx604_pos, rx604_off
    ord $I11, rx604_tgt, $I11
    ne $I11, 36, rx604_fail
    add rx604_pos, 1
    set_addr $I10, rxcap_613_fail
    ($I12, $I11) = rx604_cur."!mark_peek"($I10)
    rx604_cur."!cursor_pos"($I11)
    ($P10) = rx604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx604_pos, "")
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_613_done
  rxcap_613_fail:
    goto rx604_fail
  rxcap_613_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_614_fail
    rx604_cur."!mark_push"(0, rx604_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx604_pos, rx604_eos, rx604_fail
    sub $I10, rx604_pos, rx604_off
    substr $S10, rx604_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx604_fail
    inc rx604_pos
    set_addr $I10, rxcap_614_fail
    ($I12, $I11) = rx604_cur."!mark_peek"($I10)
    rx604_cur."!cursor_pos"($I11)
    ($P10) = rx604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx604_pos, "")
    rx604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_614_done
  rxcap_614_fail:
    goto rx604_fail
  rxcap_614_done:
  alt610_end:
.annotate 'line', 301
  # rx pass
    rx604_cur."!cursor_pass"(rx604_pos, "variable")
    if_null rx604_debug, debug_849
    rx604_cur."!cursor_debug"("PASS", "variable", " at pos=", rx604_pos)
  debug_849:
    .return (rx604_cur)
  rx604_restart:
.annotate 'line', 10
    if_null rx604_debug, debug_850
    rx604_cur."!cursor_debug"("NEXT", "variable")
  debug_850:
  rx604_fail:
    (rx604_rep, rx604_pos, $I10, $P10) = rx604_cur."!mark_fail"(0)
    lt rx604_pos, -1, rx604_done
    eq rx604_pos, -1, rx604_fail
    jump $I10
  rx604_done:
    rx604_cur."!cursor_fail"()
    if_null rx604_debug, debug_851
    rx604_cur."!cursor_debug"("FAIL", "variable")
  debug_851:
    .return (rx604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1303391609.928") :method
.annotate 'line', 10
    $P606 = self."!PREFIX__!subrule"("sigil", "")
    $P607 = self."!PREFIX__!subrule"("sigil", "")
    new $P608, "ResizablePMCArray"
    push $P608, "$!"
    push $P608, "$_"
    push $P608, "$/"
    push $P608, $P606
    push $P608, $P607
    .return ($P608)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx616_tgt
    .local int rx616_pos
    .local int rx616_off
    .local int rx616_eos
    .local int rx616_rep
    .local pmc rx616_cur
    .local pmc rx616_debug
    (rx616_cur, rx616_pos, rx616_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx616_cur
    .local pmc match
    .lex "$/", match
    length rx616_eos, rx616_tgt
    gt rx616_pos, rx616_eos, rx616_done
    set rx616_off, 0
    lt rx616_pos, 2, rx616_start
    sub rx616_off, rx616_pos, 1
    substr rx616_tgt, rx616_tgt, rx616_off
  rx616_start:
    eq $I10, 1, rx616_restart
    if_null rx616_debug, debug_852
    rx616_cur."!cursor_debug"("START", "sigil")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan619_done
    goto rxscan619_scan
  rxscan619_loop:
    (rx616_pos) = rx616_cur."from"()
    inc rx616_pos
    rx616_cur."!cursor_from"(rx616_pos)
    ge rx616_pos, rx616_eos, rxscan619_done
  rxscan619_scan:
    set_addr $I10, rxscan619_loop
    rx616_cur."!mark_push"(0, rx616_pos, $I10)
  rxscan619_done:
.annotate 'line', 307
  # rx enumcharlist negate=0 
    ge rx616_pos, rx616_eos, rx616_fail
    sub $I10, rx616_pos, rx616_off
    substr $S10, rx616_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx616_fail
    inc rx616_pos
  # rx pass
    rx616_cur."!cursor_pass"(rx616_pos, "sigil")
    if_null rx616_debug, debug_853
    rx616_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx616_pos)
  debug_853:
    .return (rx616_cur)
  rx616_restart:
.annotate 'line', 10
    if_null rx616_debug, debug_854
    rx616_cur."!cursor_debug"("NEXT", "sigil")
  debug_854:
  rx616_fail:
    (rx616_rep, rx616_pos, $I10, $P10) = rx616_cur."!mark_fail"(0)
    lt rx616_pos, -1, rx616_done
    eq rx616_pos, -1, rx616_fail
    jump $I10
  rx616_done:
    rx616_cur."!cursor_fail"()
    if_null rx616_debug, debug_855
    rx616_cur."!cursor_debug"("FAIL", "sigil")
  debug_855:
    .return (rx616_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1303391609.928") :method
.annotate 'line', 10
    new $P618, "ResizablePMCArray"
    push $P618, "&"
    push $P618, "%"
    push $P618, "@"
    push $P618, "$"
    .return ($P618)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx621_tgt
    .local int rx621_pos
    .local int rx621_off
    .local int rx621_eos
    .local int rx621_rep
    .local pmc rx621_cur
    .local pmc rx621_debug
    (rx621_cur, rx621_pos, rx621_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx621_cur
    .local pmc match
    .lex "$/", match
    length rx621_eos, rx621_tgt
    gt rx621_pos, rx621_eos, rx621_done
    set rx621_off, 0
    lt rx621_pos, 2, rx621_start
    sub rx621_off, rx621_pos, 1
    substr rx621_tgt, rx621_tgt, rx621_off
  rx621_start:
    eq $I10, 1, rx621_restart
    if_null rx621_debug, debug_856
    rx621_cur."!cursor_debug"("START", "twigil")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan624_done
    goto rxscan624_scan
  rxscan624_loop:
    (rx621_pos) = rx621_cur."from"()
    inc rx621_pos
    rx621_cur."!cursor_from"(rx621_pos)
    ge rx621_pos, rx621_eos, rxscan624_done
  rxscan624_scan:
    set_addr $I10, rxscan624_loop
    rx621_cur."!mark_push"(0, rx621_pos, $I10)
  rxscan624_done:
.annotate 'line', 309
  # rx enumcharlist negate=0 
    ge rx621_pos, rx621_eos, rx621_fail
    sub $I10, rx621_pos, rx621_off
    substr $S10, rx621_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx621_fail
    inc rx621_pos
  # rx pass
    rx621_cur."!cursor_pass"(rx621_pos, "twigil")
    if_null rx621_debug, debug_857
    rx621_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx621_pos)
  debug_857:
    .return (rx621_cur)
  rx621_restart:
.annotate 'line', 10
    if_null rx621_debug, debug_858
    rx621_cur."!cursor_debug"("NEXT", "twigil")
  debug_858:
  rx621_fail:
    (rx621_rep, rx621_pos, $I10, $P10) = rx621_cur."!mark_fail"(0)
    lt rx621_pos, -1, rx621_done
    eq rx621_pos, -1, rx621_fail
    jump $I10
  rx621_done:
    rx621_cur."!cursor_fail"()
    if_null rx621_debug, debug_859
    rx621_cur."!cursor_debug"("FAIL", "twigil")
  debug_859:
    .return (rx621_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1303391609.928") :method
.annotate 'line', 10
    new $P623, "ResizablePMCArray"
    push $P623, "?"
    push $P623, "!"
    push $P623, "*"
    .return ($P623)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1303391609.928")
    .param pmc param_626
.annotate 'line', 311
    .lex "self", param_626
    $P627 = param_626."!protoregex"("package_declarator")
    .return ($P627)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1303391609.928")
    .param pmc param_629
.annotate 'line', 311
    .lex "self", param_629
    $P630 = param_629."!PREFIX__!protoregex"("package_declarator")
    .return ($P630)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 313
    new $P632, "Undef"
    .lex "$*OUTERPACKAGE", $P632
.annotate 'line', 314
    new $P633, "Undef"
    .lex "$*PACKAGE-SETUP", $P633
.annotate 'line', 315
    new $P634, "Undef"
    .lex "$*PKGDECL", $P634
.annotate 'line', 10
    .local string rx635_tgt
    .local int rx635_pos
    .local int rx635_off
    .local int rx635_eos
    .local int rx635_rep
    .local pmc rx635_cur
    .local pmc rx635_debug
    (rx635_cur, rx635_pos, rx635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx635_cur
    .local pmc match
    .lex "$/", match
    length rx635_eos, rx635_tgt
    gt rx635_pos, rx635_eos, rx635_done
    set rx635_off, 0
    lt rx635_pos, 2, rx635_start
    sub rx635_off, rx635_pos, 1
    substr rx635_tgt, rx635_tgt, rx635_off
  rx635_start:
    eq $I10, 1, rx635_restart
    if_null rx635_debug, debug_860
    rx635_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan639_done
    goto rxscan639_scan
  rxscan639_loop:
    (rx635_pos) = rx635_cur."from"()
    inc rx635_pos
    rx635_cur."!cursor_from"(rx635_pos)
    ge rx635_pos, rx635_eos, rxscan639_done
  rxscan639_scan:
    set_addr $I10, rxscan639_loop
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  rxscan639_done:
.annotate 'line', 313
    rx635_cur."!cursor_pos"(rx635_pos)
    find_dynamic_lex $P640, "$*PACKAGE"
    unless_null $P640, vivify_861
    get_hll_global $P640, "$PACKAGE"
    unless_null $P640, vivify_862
    die "Contextual $*PACKAGE not found"
  vivify_862:
  vivify_861:
    store_lex "$*OUTERPACKAGE", $P640
.annotate 'line', 314
    rx635_cur."!cursor_pos"(rx635_pos)
    get_hll_global $P641, ["PAST"], "Stmts"
    $P642 = $P641."new"()
    store_lex "$*PACKAGE-SETUP", $P642
.annotate 'line', 315
    rx635_cur."!cursor_pos"(rx635_pos)
    new $P643, "String"
    assign $P643, "module"
    store_lex "$*PKGDECL", $P643
.annotate 'line', 316
  # rx subcapture "sym"
    set_addr $I10, rxcap_644_fail
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  # rx literal  "module"
    add $I11, rx635_pos, 6
    gt $I11, rx635_eos, rx635_fail
    sub $I11, rx635_pos, rx635_off
    substr $S10, rx635_tgt, $I11, 6
    ne $S10, "module", rx635_fail
    add rx635_pos, 6
    set_addr $I10, rxcap_644_fail
    ($I12, $I11) = rx635_cur."!mark_peek"($I10)
    rx635_cur."!cursor_pos"($I11)
    ($P10) = rx635_cur."!cursor_start"()
    $P10."!cursor_pass"(rx635_pos, "")
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_644_done
  rxcap_644_fail:
    goto rx635_fail
  rxcap_644_done:
  # rx subrule "package_def" subtype=capture negate=
    rx635_cur."!cursor_pos"(rx635_pos)
    $P10 = rx635_cur."package_def"()
    unless $P10, rx635_fail
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx635_pos = $P10."pos"()
.annotate 'line', 312
  # rx pass
    rx635_cur."!cursor_pass"(rx635_pos, "package_declarator:sym<module>")
    if_null rx635_debug, debug_863
    rx635_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx635_pos)
  debug_863:
    .return (rx635_cur)
  rx635_restart:
.annotate 'line', 10
    if_null rx635_debug, debug_864
    rx635_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_864:
  rx635_fail:
    (rx635_rep, rx635_pos, $I10, $P10) = rx635_cur."!mark_fail"(0)
    lt rx635_pos, -1, rx635_done
    eq rx635_pos, -1, rx635_fail
    jump $I10
  rx635_done:
    rx635_cur."!cursor_fail"()
    if_null rx635_debug, debug_865
    rx635_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_865:
    .return (rx635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1303391609.928") :method
.annotate 'line', 10
    $P637 = self."!PREFIX__!subrule"("package_def", "module")
    new $P638, "ResizablePMCArray"
    push $P638, $P637
    .return ($P638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 319
    new $P646, "Undef"
    .lex "$*OUTERPACKAGE", $P646
.annotate 'line', 320
    new $P647, "Undef"
    .lex "$*PACKAGE-SETUP", $P647
.annotate 'line', 321
    new $P648, "Undef"
    .lex "$*PKGDECL", $P648
.annotate 'line', 10
    .local string rx649_tgt
    .local int rx649_pos
    .local int rx649_off
    .local int rx649_eos
    .local int rx649_rep
    .local pmc rx649_cur
    .local pmc rx649_debug
    (rx649_cur, rx649_pos, rx649_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx649_cur
    .local pmc match
    .lex "$/", match
    length rx649_eos, rx649_tgt
    gt rx649_pos, rx649_eos, rx649_done
    set rx649_off, 0
    lt rx649_pos, 2, rx649_start
    sub rx649_off, rx649_pos, 1
    substr rx649_tgt, rx649_tgt, rx649_off
  rx649_start:
    eq $I10, 1, rx649_restart
    if_null rx649_debug, debug_866
    rx649_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_866:
    $I10 = self.'from'()
    ne $I10, -1, rxscan653_done
    goto rxscan653_scan
  rxscan653_loop:
    (rx649_pos) = rx649_cur."from"()
    inc rx649_pos
    rx649_cur."!cursor_from"(rx649_pos)
    ge rx649_pos, rx649_eos, rxscan653_done
  rxscan653_scan:
    set_addr $I10, rxscan653_loop
    rx649_cur."!mark_push"(0, rx649_pos, $I10)
  rxscan653_done:
.annotate 'line', 319
    rx649_cur."!cursor_pos"(rx649_pos)
    find_dynamic_lex $P654, "$*PACKAGE"
    unless_null $P654, vivify_867
    get_hll_global $P654, "$PACKAGE"
    unless_null $P654, vivify_868
    die "Contextual $*PACKAGE not found"
  vivify_868:
  vivify_867:
    store_lex "$*OUTERPACKAGE", $P654
.annotate 'line', 320
    rx649_cur."!cursor_pos"(rx649_pos)
    get_hll_global $P655, ["PAST"], "Stmts"
    $P656 = $P655."new"()
    store_lex "$*PACKAGE-SETUP", $P656
.annotate 'line', 321
    rx649_cur."!cursor_pos"(rx649_pos)
    new $P657, "String"
    assign $P657, "knowhow"
    store_lex "$*PKGDECL", $P657
.annotate 'line', 322
  # rx subcapture "sym"
    set_addr $I10, rxcap_658_fail
    rx649_cur."!mark_push"(0, rx649_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx649_pos, 7
    gt $I11, rx649_eos, rx649_fail
    sub $I11, rx649_pos, rx649_off
    substr $S10, rx649_tgt, $I11, 7
    ne $S10, "knowhow", rx649_fail
    add rx649_pos, 7
    set_addr $I10, rxcap_658_fail
    ($I12, $I11) = rx649_cur."!mark_peek"($I10)
    rx649_cur."!cursor_pos"($I11)
    ($P10) = rx649_cur."!cursor_start"()
    $P10."!cursor_pass"(rx649_pos, "")
    rx649_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_658_done
  rxcap_658_fail:
    goto rx649_fail
  rxcap_658_done:
  # rx subrule "package_def" subtype=capture negate=
    rx649_cur."!cursor_pos"(rx649_pos)
    $P10 = rx649_cur."package_def"()
    unless $P10, rx649_fail
    rx649_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx649_pos = $P10."pos"()
.annotate 'line', 318
  # rx pass
    rx649_cur."!cursor_pass"(rx649_pos, "package_declarator:sym<knowhow>")
    if_null rx649_debug, debug_869
    rx649_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx649_pos)
  debug_869:
    .return (rx649_cur)
  rx649_restart:
.annotate 'line', 10
    if_null rx649_debug, debug_870
    rx649_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_870:
  rx649_fail:
    (rx649_rep, rx649_pos, $I10, $P10) = rx649_cur."!mark_fail"(0)
    lt rx649_pos, -1, rx649_done
    eq rx649_pos, -1, rx649_fail
    jump $I10
  rx649_done:
    rx649_cur."!cursor_fail"()
    if_null rx649_debug, debug_871
    rx649_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_871:
    .return (rx649_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1303391609.928") :method
.annotate 'line', 10
    $P651 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P652, "ResizablePMCArray"
    push $P652, $P651
    .return ($P652)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 325
    new $P660, "Undef"
    .lex "$*OUTERPACKAGE", $P660
.annotate 'line', 326
    new $P661, "Undef"
    .lex "$*PACKAGE-SETUP", $P661
.annotate 'line', 327
    new $P662, "Undef"
    .lex "$*PKGDECL", $P662
.annotate 'line', 10
    .local string rx663_tgt
    .local int rx663_pos
    .local int rx663_off
    .local int rx663_eos
    .local int rx663_rep
    .local pmc rx663_cur
    .local pmc rx663_debug
    (rx663_cur, rx663_pos, rx663_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx663_cur
    .local pmc match
    .lex "$/", match
    length rx663_eos, rx663_tgt
    gt rx663_pos, rx663_eos, rx663_done
    set rx663_off, 0
    lt rx663_pos, 2, rx663_start
    sub rx663_off, rx663_pos, 1
    substr rx663_tgt, rx663_tgt, rx663_off
  rx663_start:
    eq $I10, 1, rx663_restart
    if_null rx663_debug, debug_872
    rx663_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan667_done
    goto rxscan667_scan
  rxscan667_loop:
    (rx663_pos) = rx663_cur."from"()
    inc rx663_pos
    rx663_cur."!cursor_from"(rx663_pos)
    ge rx663_pos, rx663_eos, rxscan667_done
  rxscan667_scan:
    set_addr $I10, rxscan667_loop
    rx663_cur."!mark_push"(0, rx663_pos, $I10)
  rxscan667_done:
.annotate 'line', 325
    rx663_cur."!cursor_pos"(rx663_pos)
    find_dynamic_lex $P668, "$*PACKAGE"
    unless_null $P668, vivify_873
    get_hll_global $P668, "$PACKAGE"
    unless_null $P668, vivify_874
    die "Contextual $*PACKAGE not found"
  vivify_874:
  vivify_873:
    store_lex "$*OUTERPACKAGE", $P668
.annotate 'line', 326
    rx663_cur."!cursor_pos"(rx663_pos)
    get_hll_global $P669, ["PAST"], "Stmts"
    $P670 = $P669."new"()
    store_lex "$*PACKAGE-SETUP", $P670
.annotate 'line', 327
    rx663_cur."!cursor_pos"(rx663_pos)
    new $P671, "String"
    assign $P671, "class"
    store_lex "$*PKGDECL", $P671
.annotate 'line', 328
  # rx subcapture "sym"
    set_addr $I10, rxcap_672_fail
    rx663_cur."!mark_push"(0, rx663_pos, $I10)
  # rx literal  "class"
    add $I11, rx663_pos, 5
    gt $I11, rx663_eos, rx663_fail
    sub $I11, rx663_pos, rx663_off
    substr $S10, rx663_tgt, $I11, 5
    ne $S10, "class", rx663_fail
    add rx663_pos, 5
    set_addr $I10, rxcap_672_fail
    ($I12, $I11) = rx663_cur."!mark_peek"($I10)
    rx663_cur."!cursor_pos"($I11)
    ($P10) = rx663_cur."!cursor_start"()
    $P10."!cursor_pass"(rx663_pos, "")
    rx663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_672_done
  rxcap_672_fail:
    goto rx663_fail
  rxcap_672_done:
  # rx subrule "package_def" subtype=capture negate=
    rx663_cur."!cursor_pos"(rx663_pos)
    $P10 = rx663_cur."package_def"()
    unless $P10, rx663_fail
    rx663_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx663_pos = $P10."pos"()
.annotate 'line', 324
  # rx pass
    rx663_cur."!cursor_pass"(rx663_pos, "package_declarator:sym<class>")
    if_null rx663_debug, debug_875
    rx663_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx663_pos)
  debug_875:
    .return (rx663_cur)
  rx663_restart:
.annotate 'line', 10
    if_null rx663_debug, debug_876
    rx663_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_876:
  rx663_fail:
    (rx663_rep, rx663_pos, $I10, $P10) = rx663_cur."!mark_fail"(0)
    lt rx663_pos, -1, rx663_done
    eq rx663_pos, -1, rx663_fail
    jump $I10
  rx663_done:
    rx663_cur."!cursor_fail"()
    if_null rx663_debug, debug_877
    rx663_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_877:
    .return (rx663_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1303391609.928") :method
.annotate 'line', 10
    $P665 = self."!PREFIX__!subrule"("package_def", "class")
    new $P666, "ResizablePMCArray"
    push $P666, $P665
    .return ($P666)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 331
    new $P674, "Undef"
    .lex "$*OUTERPACKAGE", $P674
.annotate 'line', 332
    new $P675, "Undef"
    .lex "$*PACKAGE-SETUP", $P675
.annotate 'line', 333
    new $P676, "Undef"
    .lex "$*PKGDECL", $P676
.annotate 'line', 10
    .local string rx677_tgt
    .local int rx677_pos
    .local int rx677_off
    .local int rx677_eos
    .local int rx677_rep
    .local pmc rx677_cur
    .local pmc rx677_debug
    (rx677_cur, rx677_pos, rx677_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx677_cur
    .local pmc match
    .lex "$/", match
    length rx677_eos, rx677_tgt
    gt rx677_pos, rx677_eos, rx677_done
    set rx677_off, 0
    lt rx677_pos, 2, rx677_start
    sub rx677_off, rx677_pos, 1
    substr rx677_tgt, rx677_tgt, rx677_off
  rx677_start:
    eq $I10, 1, rx677_restart
    if_null rx677_debug, debug_878
    rx677_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_878:
    $I10 = self.'from'()
    ne $I10, -1, rxscan681_done
    goto rxscan681_scan
  rxscan681_loop:
    (rx677_pos) = rx677_cur."from"()
    inc rx677_pos
    rx677_cur."!cursor_from"(rx677_pos)
    ge rx677_pos, rx677_eos, rxscan681_done
  rxscan681_scan:
    set_addr $I10, rxscan681_loop
    rx677_cur."!mark_push"(0, rx677_pos, $I10)
  rxscan681_done:
.annotate 'line', 331
    rx677_cur."!cursor_pos"(rx677_pos)
    find_dynamic_lex $P682, "$*PACKAGE"
    unless_null $P682, vivify_879
    get_hll_global $P682, "$PACKAGE"
    unless_null $P682, vivify_880
    die "Contextual $*PACKAGE not found"
  vivify_880:
  vivify_879:
    store_lex "$*OUTERPACKAGE", $P682
.annotate 'line', 332
    rx677_cur."!cursor_pos"(rx677_pos)
    get_hll_global $P683, ["PAST"], "Stmts"
    $P684 = $P683."new"()
    store_lex "$*PACKAGE-SETUP", $P684
.annotate 'line', 333
    rx677_cur."!cursor_pos"(rx677_pos)
    new $P685, "String"
    assign $P685, "grammar"
    store_lex "$*PKGDECL", $P685
.annotate 'line', 334
  # rx subcapture "sym"
    set_addr $I10, rxcap_686_fail
    rx677_cur."!mark_push"(0, rx677_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx677_pos, 7
    gt $I11, rx677_eos, rx677_fail
    sub $I11, rx677_pos, rx677_off
    substr $S10, rx677_tgt, $I11, 7
    ne $S10, "grammar", rx677_fail
    add rx677_pos, 7
    set_addr $I10, rxcap_686_fail
    ($I12, $I11) = rx677_cur."!mark_peek"($I10)
    rx677_cur."!cursor_pos"($I11)
    ($P10) = rx677_cur."!cursor_start"()
    $P10."!cursor_pass"(rx677_pos, "")
    rx677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_686_done
  rxcap_686_fail:
    goto rx677_fail
  rxcap_686_done:
  # rx subrule "package_def" subtype=capture negate=
    rx677_cur."!cursor_pos"(rx677_pos)
    $P10 = rx677_cur."package_def"()
    unless $P10, rx677_fail
    rx677_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx677_pos = $P10."pos"()
.annotate 'line', 330
  # rx pass
    rx677_cur."!cursor_pass"(rx677_pos, "package_declarator:sym<grammar>")
    if_null rx677_debug, debug_881
    rx677_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx677_pos)
  debug_881:
    .return (rx677_cur)
  rx677_restart:
.annotate 'line', 10
    if_null rx677_debug, debug_882
    rx677_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_882:
  rx677_fail:
    (rx677_rep, rx677_pos, $I10, $P10) = rx677_cur."!mark_fail"(0)
    lt rx677_pos, -1, rx677_done
    eq rx677_pos, -1, rx677_fail
    jump $I10
  rx677_done:
    rx677_cur."!cursor_fail"()
    if_null rx677_debug, debug_883
    rx677_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_883:
    .return (rx677_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1303391609.928") :method
.annotate 'line', 10
    $P679 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P680, "ResizablePMCArray"
    push $P680, $P679
    .return ($P680)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 337
    new $P688, "Undef"
    .lex "$*OUTERPACKAGE", $P688
.annotate 'line', 338
    new $P689, "Undef"
    .lex "$*PACKAGE-SETUP", $P689
.annotate 'line', 339
    new $P690, "Undef"
    .lex "$*PKGDECL", $P690
.annotate 'line', 10
    .local string rx691_tgt
    .local int rx691_pos
    .local int rx691_off
    .local int rx691_eos
    .local int rx691_rep
    .local pmc rx691_cur
    .local pmc rx691_debug
    (rx691_cur, rx691_pos, rx691_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx691_cur
    .local pmc match
    .lex "$/", match
    length rx691_eos, rx691_tgt
    gt rx691_pos, rx691_eos, rx691_done
    set rx691_off, 0
    lt rx691_pos, 2, rx691_start
    sub rx691_off, rx691_pos, 1
    substr rx691_tgt, rx691_tgt, rx691_off
  rx691_start:
    eq $I10, 1, rx691_restart
    if_null rx691_debug, debug_884
    rx691_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan695_done
    goto rxscan695_scan
  rxscan695_loop:
    (rx691_pos) = rx691_cur."from"()
    inc rx691_pos
    rx691_cur."!cursor_from"(rx691_pos)
    ge rx691_pos, rx691_eos, rxscan695_done
  rxscan695_scan:
    set_addr $I10, rxscan695_loop
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  rxscan695_done:
.annotate 'line', 337
    rx691_cur."!cursor_pos"(rx691_pos)
    find_dynamic_lex $P696, "$*PACKAGE"
    unless_null $P696, vivify_885
    get_hll_global $P696, "$PACKAGE"
    unless_null $P696, vivify_886
    die "Contextual $*PACKAGE not found"
  vivify_886:
  vivify_885:
    store_lex "$*OUTERPACKAGE", $P696
.annotate 'line', 338
    rx691_cur."!cursor_pos"(rx691_pos)
    get_hll_global $P697, ["PAST"], "Stmts"
    $P698 = $P697."new"()
    store_lex "$*PACKAGE-SETUP", $P698
.annotate 'line', 339
    rx691_cur."!cursor_pos"(rx691_pos)
    new $P699, "String"
    assign $P699, "role"
    store_lex "$*PKGDECL", $P699
.annotate 'line', 340
  # rx subcapture "sym"
    set_addr $I10, rxcap_700_fail
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  # rx literal  "role"
    add $I11, rx691_pos, 4
    gt $I11, rx691_eos, rx691_fail
    sub $I11, rx691_pos, rx691_off
    substr $S10, rx691_tgt, $I11, 4
    ne $S10, "role", rx691_fail
    add rx691_pos, 4
    set_addr $I10, rxcap_700_fail
    ($I12, $I11) = rx691_cur."!mark_peek"($I10)
    rx691_cur."!cursor_pos"($I11)
    ($P10) = rx691_cur."!cursor_start"()
    $P10."!cursor_pass"(rx691_pos, "")
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_700_done
  rxcap_700_fail:
    goto rx691_fail
  rxcap_700_done:
  # rx subrule "package_def" subtype=capture negate=
    rx691_cur."!cursor_pos"(rx691_pos)
    $P10 = rx691_cur."package_def"()
    unless $P10, rx691_fail
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx691_pos = $P10."pos"()
.annotate 'line', 336
  # rx pass
    rx691_cur."!cursor_pass"(rx691_pos, "package_declarator:sym<role>")
    if_null rx691_debug, debug_887
    rx691_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx691_pos)
  debug_887:
    .return (rx691_cur)
  rx691_restart:
.annotate 'line', 10
    if_null rx691_debug, debug_888
    rx691_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_888:
  rx691_fail:
    (rx691_rep, rx691_pos, $I10, $P10) = rx691_cur."!mark_fail"(0)
    lt rx691_pos, -1, rx691_done
    eq rx691_pos, -1, rx691_fail
    jump $I10
  rx691_done:
    rx691_cur."!cursor_fail"()
    if_null rx691_debug, debug_889
    rx691_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_889:
    .return (rx691_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1303391609.928") :method
.annotate 'line', 10
    $P693 = self."!PREFIX__!subrule"("package_def", "role")
    new $P694, "ResizablePMCArray"
    push $P694, $P693
    .return ($P694)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 343
    new $P702, "Undef"
    .lex "$*OUTERPACKAGE", $P702
.annotate 'line', 344
    new $P703, "Undef"
    .lex "$*PACKAGE-SETUP", $P703
.annotate 'line', 345
    new $P704, "Undef"
    .lex "$*PKGDECL", $P704
.annotate 'line', 10
    .local string rx705_tgt
    .local int rx705_pos
    .local int rx705_off
    .local int rx705_eos
    .local int rx705_rep
    .local pmc rx705_cur
    .local pmc rx705_debug
    (rx705_cur, rx705_pos, rx705_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx705_cur
    .local pmc match
    .lex "$/", match
    length rx705_eos, rx705_tgt
    gt rx705_pos, rx705_eos, rx705_done
    set rx705_off, 0
    lt rx705_pos, 2, rx705_start
    sub rx705_off, rx705_pos, 1
    substr rx705_tgt, rx705_tgt, rx705_off
  rx705_start:
    eq $I10, 1, rx705_restart
    if_null rx705_debug, debug_890
    rx705_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_890:
    $I10 = self.'from'()
    ne $I10, -1, rxscan709_done
    goto rxscan709_scan
  rxscan709_loop:
    (rx705_pos) = rx705_cur."from"()
    inc rx705_pos
    rx705_cur."!cursor_from"(rx705_pos)
    ge rx705_pos, rx705_eos, rxscan709_done
  rxscan709_scan:
    set_addr $I10, rxscan709_loop
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  rxscan709_done:
.annotate 'line', 343
    rx705_cur."!cursor_pos"(rx705_pos)
    find_dynamic_lex $P710, "$*PACKAGE"
    unless_null $P710, vivify_891
    get_hll_global $P710, "$PACKAGE"
    unless_null $P710, vivify_892
    die "Contextual $*PACKAGE not found"
  vivify_892:
  vivify_891:
    store_lex "$*OUTERPACKAGE", $P710
.annotate 'line', 344
    rx705_cur."!cursor_pos"(rx705_pos)
    get_hll_global $P711, ["PAST"], "Stmts"
    $P712 = $P711."new"()
    store_lex "$*PACKAGE-SETUP", $P712
.annotate 'line', 345
    rx705_cur."!cursor_pos"(rx705_pos)
    new $P713, "String"
    assign $P713, "native"
    store_lex "$*PKGDECL", $P713
.annotate 'line', 346
  # rx subcapture "sym"
    set_addr $I10, rxcap_714_fail
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  # rx literal  "native"
    add $I11, rx705_pos, 6
    gt $I11, rx705_eos, rx705_fail
    sub $I11, rx705_pos, rx705_off
    substr $S10, rx705_tgt, $I11, 6
    ne $S10, "native", rx705_fail
    add rx705_pos, 6
    set_addr $I10, rxcap_714_fail
    ($I12, $I11) = rx705_cur."!mark_peek"($I10)
    rx705_cur."!cursor_pos"($I11)
    ($P10) = rx705_cur."!cursor_start"()
    $P10."!cursor_pass"(rx705_pos, "")
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_714_done
  rxcap_714_fail:
    goto rx705_fail
  rxcap_714_done:
  # rx subrule "package_def" subtype=capture negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."package_def"()
    unless $P10, rx705_fail
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx705_pos = $P10."pos"()
.annotate 'line', 342
  # rx pass
    rx705_cur."!cursor_pass"(rx705_pos, "package_declarator:sym<native>")
    if_null rx705_debug, debug_893
    rx705_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx705_pos)
  debug_893:
    .return (rx705_cur)
  rx705_restart:
.annotate 'line', 10
    if_null rx705_debug, debug_894
    rx705_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_894:
  rx705_fail:
    (rx705_rep, rx705_pos, $I10, $P10) = rx705_cur."!mark_fail"(0)
    lt rx705_pos, -1, rx705_done
    eq rx705_pos, -1, rx705_fail
    jump $I10
  rx705_done:
    rx705_cur."!cursor_fail"()
    if_null rx705_debug, debug_895
    rx705_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_895:
    .return (rx705_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1303391609.928") :method
.annotate 'line', 10
    $P707 = self."!PREFIX__!subrule"("package_def", "native")
    new $P708, "ResizablePMCArray"
    push $P708, $P707
    .return ($P708)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P739 = "154_1303391609.928" 
    capture_lex $P739
.annotate 'line', 350
    new $P716, "Undef"
    .lex "$*PACKAGE", $P716
.annotate 'line', 351
    $P717 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P717
.annotate 'line', 10
    .local string rx718_tgt
    .local int rx718_pos
    .local int rx718_off
    .local int rx718_eos
    .local int rx718_rep
    .local pmc rx718_cur
    .local pmc rx718_debug
    (rx718_cur, rx718_pos, rx718_tgt, $I10) = self."!cursor_start"()
    rx718_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx718_cur
    .local pmc match
    .lex "$/", match
    length rx718_eos, rx718_tgt
    gt rx718_pos, rx718_eos, rx718_done
    set rx718_off, 0
    lt rx718_pos, 2, rx718_start
    sub rx718_off, rx718_pos, 1
    substr rx718_tgt, rx718_tgt, rx718_off
  rx718_start:
    eq $I10, 1, rx718_restart
    if_null rx718_debug, debug_896
    rx718_cur."!cursor_debug"("START", "package_def")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan722_done
    goto rxscan722_scan
  rxscan722_loop:
    (rx718_pos) = rx718_cur."from"()
    inc rx718_pos
    rx718_cur."!cursor_from"(rx718_pos)
    ge rx718_pos, rx718_eos, rxscan722_done
  rxscan722_scan:
    set_addr $I10, rxscan722_loop
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
  rxscan722_done:
.annotate 'line', 349
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 350
    rx718_cur."!cursor_pos"(rx718_pos)
    find_lex $P724, "$*PACKAGE"
    unless_null $P724, vivify_897
    get_hll_global $P724, "$PACKAGE"
    unless_null $P724, vivify_898
    die "Contextual $*PACKAGE not found"
  vivify_898:
  vivify_897:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 351
    rx718_cur."!cursor_pos"(rx718_pos)
    find_lex $P726, "%*ATTR-CHECK"
    unless_null $P726, vivify_899
    get_hll_global $P726, "%ATTR-CHECK"
    unless_null $P726, vivify_900
    die "Contextual %*ATTR-CHECK not found"
  vivify_900:
  vivify_899:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 353
  # rx subrule "name" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."name"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 354
  # rx rxquantr729 ** 0..1
    set_addr $I10, rxquantr729_done
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
  rxquantr729_loop:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx718_pos, 2
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I11, 2
    ne $S10, "is", rx718_fail
    add rx718_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx718_pos, 5
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I11, 5
    ne $S10, "repr(", rx718_fail
    add rx718_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."quote_EXPR"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx718_pos, 1
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    ord $I11, rx718_tgt, $I11
    ne $I11, 41, rx718_fail
    add rx718_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
    set_addr $I10, rxquantr729_done
    (rx718_rep) = rx718_cur."!mark_commit"($I10)
  rxquantr729_done:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 356
    rx718_cur."!cursor_pos"(rx718_pos)
    find_lex $P736, unicode:"$\x{a2}"
    $P737 = $P736."MATCH"()
    store_lex "$/", $P737
    .const 'Sub' $P739 = "154_1303391609.928" 
    capture_lex $P739
    $P765 = $P739()
.annotate 'line', 365
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 367
  # rx rxquantr767 ** 0..1
    set_addr $I10, rxquantr767_done
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
  rxquantr767_loop:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx718_pos, 2
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I11, 2
    ne $S10, "is", rx718_fail
    add rx718_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."name"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
    set_addr $I10, rxquantr767_done
    (rx718_rep) = rx718_cur."!mark_commit"($I10)
  rxquantr767_done:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 368
  # rx rxquantr772 ** 0..*
    set_addr $I10, rxquantr772_done
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
  rxquantr772_loop:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx718_pos, 4
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I11, 4
    ne $S10, "does", rx718_fail
    add rx718_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."name"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
    set_addr $I10, rxquantr772_done
    (rx718_rep) = rx718_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr772_done
    rx718_cur."!mark_push"(rx718_rep, rx718_pos, $I10)
    goto rxquantr772_loop
  rxquantr772_done:
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  alt777_0:
.annotate 'line', 369
    set_addr $I10, alt777_1
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
.annotate 'line', 370
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx718_pos, 1
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    ord $I11, rx718_tgt, $I11
    ne $I11, 59, rx718_fail
    add rx718_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."comp_unit"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
    goto alt777_end
  alt777_1:
    set_addr $I10, alt777_2
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
.annotate 'line', 371
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx718_fail
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."block"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
    goto alt777_end
  alt777_2:
.annotate 'line', 372
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."panic"("Malformed package declaration")
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
  alt777_end:
.annotate 'line', 373
  # rx subrule "ws" subtype=method negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."ws"()
    unless $P10, rx718_fail
    rx718_pos = $P10."pos"()
.annotate 'line', 349
  # rx pass
    rx718_cur."!cursor_pass"(rx718_pos, "package_def")
    if_null rx718_debug, debug_922
    rx718_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx718_pos)
  debug_922:
    .return (rx718_cur)
  rx718_restart:
.annotate 'line', 10
    if_null rx718_debug, debug_923
    rx718_cur."!cursor_debug"("NEXT", "package_def")
  debug_923:
  rx718_fail:
    (rx718_rep, rx718_pos, $I10, $P10) = rx718_cur."!mark_fail"(0)
    lt rx718_pos, -1, rx718_done
    eq rx718_pos, -1, rx718_fail
    jump $I10
  rx718_done:
    rx718_cur."!cursor_fail"()
    if_null rx718_debug, debug_924
    rx718_cur."!cursor_debug"("FAIL", "package_def")
  debug_924:
    .return (rx718_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1303391609.928") :method
.annotate 'line', 10
    $P720 = self."!PREFIX__!subrule"("ws", "")
    new $P721, "ResizablePMCArray"
    push $P721, $P720
    .return ($P721)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block738"  :anon :subid("154_1303391609.928") :outer("152_1303391609.928")
.annotate 'line', 359
    $P740 = root_new ['parrot';'Hash']
    .lex "%args", $P740
.annotate 'line', 356
    find_lex $P741, "%args"
    unless_null $P741, vivify_901
    $P741 = root_new ['parrot';'Hash']
  vivify_901:
.annotate 'line', 360
    find_lex $P742, "$/"
    unless_null $P742, vivify_902
    $P742 = root_new ['parrot';'Hash']
  vivify_902:
    set $P743, $P742["name"]
    unless_null $P743, vivify_903
    new $P743, "Undef"
  vivify_903:
    set $S744, $P743
    new $P745, 'String'
    set $P745, $S744
    find_lex $P746, "%args"
    unless_null $P746, vivify_904
    $P746 = root_new ['parrot';'Hash']
    store_lex "%args", $P746
  vivify_904:
    set $P746["name"], $P745
.annotate 'line', 361
    find_lex $P748, "$/"
    unless_null $P748, vivify_905
    $P748 = root_new ['parrot';'Hash']
  vivify_905:
    set $P749, $P748["repr"]
    unless_null $P749, vivify_906
    new $P749, "Undef"
  vivify_906:
    unless $P749, if_747_end
.annotate 'line', 362
    find_lex $P750, "$/"
    unless_null $P750, vivify_907
    $P750 = root_new ['parrot';'Hash']
  vivify_907:
    set $P751, $P750["repr"]
    unless_null $P751, vivify_908
    $P751 = root_new ['parrot';'ResizablePMCArray']
  vivify_908:
    set $P752, $P751[0]
    unless_null $P752, vivify_909
    $P752 = root_new ['parrot';'Hash']
  vivify_909:
    set $P753, $P752["quote_delimited"]
    unless_null $P753, vivify_910
    $P753 = root_new ['parrot';'Hash']
  vivify_910:
    set $P754, $P753["quote_atom"]
    unless_null $P754, vivify_911
    $P754 = root_new ['parrot';'ResizablePMCArray']
  vivify_911:
    set $P755, $P754[0]
    unless_null $P755, vivify_912
    new $P755, "Undef"
  vivify_912:
    set $S756, $P755
    new $P757, 'String'
    set $P757, $S756
    find_lex $P758, "%args"
    unless_null $P758, vivify_913
    $P758 = root_new ['parrot';'Hash']
    store_lex "%args", $P758
  vivify_913:
    set $P758["repr"], $P757
  if_747_end:
.annotate 'line', 364
    find_dynamic_lex $P759, "$*SC"
    unless_null $P759, vivify_914
    get_hll_global $P759, "$SC"
    unless_null $P759, vivify_915
    die "Contextual $*SC not found"
  vivify_915:
  vivify_914:
    find_dynamic_lex $P760, "$*PKGDECL"
    unless_null $P760, vivify_916
    get_hll_global $P760, "$PKGDECL"
    unless_null $P760, vivify_917
    die "Contextual $*PKGDECL not found"
  vivify_917:
  vivify_916:
    find_dynamic_lex $P761, "%*HOW"
    unless_null $P761, vivify_918
    get_hll_global $P761, "%HOW"
    unless_null $P761, vivify_919
    die "Contextual %*HOW not found"
  vivify_919:
  vivify_918:
    set $P762, $P761[$P760]
    unless_null $P762, vivify_920
    new $P762, "Undef"
  vivify_920:
    find_lex $P763, "%args"
    unless_null $P763, vivify_921
    $P763 = root_new ['parrot';'Hash']
  vivify_921:
    $P764 = $P759."pkg_create_mo"($P762, $P763 :flat)
    store_dynamic_lex "$*PACKAGE", $P764
.annotate 'line', 356
    .return ($P764)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1303391609.928")
    .param pmc param_788
.annotate 'line', 376
    .lex "self", param_788
    $P789 = param_788."!protoregex"("scope_declarator")
    .return ($P789)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1303391609.928")
    .param pmc param_791
.annotate 'line', 376
    .lex "self", param_791
    $P792 = param_791."!PREFIX__!protoregex"("scope_declarator")
    .return ($P792)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx794_tgt
    .local int rx794_pos
    .local int rx794_off
    .local int rx794_eos
    .local int rx794_rep
    .local pmc rx794_cur
    .local pmc rx794_debug
    (rx794_cur, rx794_pos, rx794_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx794_cur
    .local pmc match
    .lex "$/", match
    length rx794_eos, rx794_tgt
    gt rx794_pos, rx794_eos, rx794_done
    set rx794_off, 0
    lt rx794_pos, 2, rx794_start
    sub rx794_off, rx794_pos, 1
    substr rx794_tgt, rx794_tgt, rx794_off
  rx794_start:
    eq $I10, 1, rx794_restart
    if_null rx794_debug, debug_925
    rx794_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_925:
    $I10 = self.'from'()
    ne $I10, -1, rxscan798_done
    goto rxscan798_scan
  rxscan798_loop:
    (rx794_pos) = rx794_cur."from"()
    inc rx794_pos
    rx794_cur."!cursor_from"(rx794_pos)
    ge rx794_pos, rx794_eos, rxscan798_done
  rxscan798_scan:
    set_addr $I10, rxscan798_loop
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
  rxscan798_done:
.annotate 'line', 377
  # rx subcapture "sym"
    set_addr $I10, rxcap_799_fail
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
  # rx literal  "my"
    add $I11, rx794_pos, 2
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I11, 2
    ne $S10, "my", rx794_fail
    add rx794_pos, 2
    set_addr $I10, rxcap_799_fail
    ($I12, $I11) = rx794_cur."!mark_peek"($I10)
    rx794_cur."!cursor_pos"($I11)
    ($P10) = rx794_cur."!cursor_start"()
    $P10."!cursor_pass"(rx794_pos, "")
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_799_done
  rxcap_799_fail:
    goto rx794_fail
  rxcap_799_done:
  # rx subrule "scoped" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."scoped"("my")
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx794_pos = $P10."pos"()
  # rx pass
    rx794_cur."!cursor_pass"(rx794_pos, "scope_declarator:sym<my>")
    if_null rx794_debug, debug_926
    rx794_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx794_pos)
  debug_926:
    .return (rx794_cur)
  rx794_restart:
.annotate 'line', 10
    if_null rx794_debug, debug_927
    rx794_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_927:
  rx794_fail:
    (rx794_rep, rx794_pos, $I10, $P10) = rx794_cur."!mark_fail"(0)
    lt rx794_pos, -1, rx794_done
    eq rx794_pos, -1, rx794_fail
    jump $I10
  rx794_done:
    rx794_cur."!cursor_fail"()
    if_null rx794_debug, debug_928
    rx794_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_928:
    .return (rx794_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1303391609.928") :method
.annotate 'line', 10
    $P796 = self."!PREFIX__!subrule"("scoped", "my")
    new $P797, "ResizablePMCArray"
    push $P797, $P796
    .return ($P797)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx801_tgt
    .local int rx801_pos
    .local int rx801_off
    .local int rx801_eos
    .local int rx801_rep
    .local pmc rx801_cur
    .local pmc rx801_debug
    (rx801_cur, rx801_pos, rx801_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx801_cur
    .local pmc match
    .lex "$/", match
    length rx801_eos, rx801_tgt
    gt rx801_pos, rx801_eos, rx801_done
    set rx801_off, 0
    lt rx801_pos, 2, rx801_start
    sub rx801_off, rx801_pos, 1
    substr rx801_tgt, rx801_tgt, rx801_off
  rx801_start:
    eq $I10, 1, rx801_restart
    if_null rx801_debug, debug_929
    rx801_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_929:
    $I10 = self.'from'()
    ne $I10, -1, rxscan805_done
    goto rxscan805_scan
  rxscan805_loop:
    (rx801_pos) = rx801_cur."from"()
    inc rx801_pos
    rx801_cur."!cursor_from"(rx801_pos)
    ge rx801_pos, rx801_eos, rxscan805_done
  rxscan805_scan:
    set_addr $I10, rxscan805_loop
    rx801_cur."!mark_push"(0, rx801_pos, $I10)
  rxscan805_done:
.annotate 'line', 378
  # rx subcapture "sym"
    set_addr $I10, rxcap_806_fail
    rx801_cur."!mark_push"(0, rx801_pos, $I10)
  # rx literal  "our"
    add $I11, rx801_pos, 3
    gt $I11, rx801_eos, rx801_fail
    sub $I11, rx801_pos, rx801_off
    substr $S10, rx801_tgt, $I11, 3
    ne $S10, "our", rx801_fail
    add rx801_pos, 3
    set_addr $I10, rxcap_806_fail
    ($I12, $I11) = rx801_cur."!mark_peek"($I10)
    rx801_cur."!cursor_pos"($I11)
    ($P10) = rx801_cur."!cursor_start"()
    $P10."!cursor_pass"(rx801_pos, "")
    rx801_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_806_done
  rxcap_806_fail:
    goto rx801_fail
  rxcap_806_done:
  # rx subrule "scoped" subtype=capture negate=
    rx801_cur."!cursor_pos"(rx801_pos)
    $P10 = rx801_cur."scoped"("our")
    unless $P10, rx801_fail
    rx801_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx801_pos = $P10."pos"()
  # rx pass
    rx801_cur."!cursor_pass"(rx801_pos, "scope_declarator:sym<our>")
    if_null rx801_debug, debug_930
    rx801_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx801_pos)
  debug_930:
    .return (rx801_cur)
  rx801_restart:
.annotate 'line', 10
    if_null rx801_debug, debug_931
    rx801_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_931:
  rx801_fail:
    (rx801_rep, rx801_pos, $I10, $P10) = rx801_cur."!mark_fail"(0)
    lt rx801_pos, -1, rx801_done
    eq rx801_pos, -1, rx801_fail
    jump $I10
  rx801_done:
    rx801_cur."!cursor_fail"()
    if_null rx801_debug, debug_932
    rx801_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_932:
    .return (rx801_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1303391609.928") :method
.annotate 'line', 10
    $P803 = self."!PREFIX__!subrule"("scoped", "our")
    new $P804, "ResizablePMCArray"
    push $P804, $P803
    .return ($P804)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx808_tgt
    .local int rx808_pos
    .local int rx808_off
    .local int rx808_eos
    .local int rx808_rep
    .local pmc rx808_cur
    .local pmc rx808_debug
    (rx808_cur, rx808_pos, rx808_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx808_cur
    .local pmc match
    .lex "$/", match
    length rx808_eos, rx808_tgt
    gt rx808_pos, rx808_eos, rx808_done
    set rx808_off, 0
    lt rx808_pos, 2, rx808_start
    sub rx808_off, rx808_pos, 1
    substr rx808_tgt, rx808_tgt, rx808_off
  rx808_start:
    eq $I10, 1, rx808_restart
    if_null rx808_debug, debug_933
    rx808_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_933:
    $I10 = self.'from'()
    ne $I10, -1, rxscan812_done
    goto rxscan812_scan
  rxscan812_loop:
    (rx808_pos) = rx808_cur."from"()
    inc rx808_pos
    rx808_cur."!cursor_from"(rx808_pos)
    ge rx808_pos, rx808_eos, rxscan812_done
  rxscan812_scan:
    set_addr $I10, rxscan812_loop
    rx808_cur."!mark_push"(0, rx808_pos, $I10)
  rxscan812_done:
.annotate 'line', 379
  # rx subcapture "sym"
    set_addr $I10, rxcap_813_fail
    rx808_cur."!mark_push"(0, rx808_pos, $I10)
  # rx literal  "has"
    add $I11, rx808_pos, 3
    gt $I11, rx808_eos, rx808_fail
    sub $I11, rx808_pos, rx808_off
    substr $S10, rx808_tgt, $I11, 3
    ne $S10, "has", rx808_fail
    add rx808_pos, 3
    set_addr $I10, rxcap_813_fail
    ($I12, $I11) = rx808_cur."!mark_peek"($I10)
    rx808_cur."!cursor_pos"($I11)
    ($P10) = rx808_cur."!cursor_start"()
    $P10."!cursor_pass"(rx808_pos, "")
    rx808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_813_done
  rxcap_813_fail:
    goto rx808_fail
  rxcap_813_done:
  # rx subrule "scoped" subtype=capture negate=
    rx808_cur."!cursor_pos"(rx808_pos)
    $P10 = rx808_cur."scoped"("has")
    unless $P10, rx808_fail
    rx808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx808_pos = $P10."pos"()
  # rx pass
    rx808_cur."!cursor_pass"(rx808_pos, "scope_declarator:sym<has>")
    if_null rx808_debug, debug_934
    rx808_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx808_pos)
  debug_934:
    .return (rx808_cur)
  rx808_restart:
.annotate 'line', 10
    if_null rx808_debug, debug_935
    rx808_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_935:
  rx808_fail:
    (rx808_rep, rx808_pos, $I10, $P10) = rx808_cur."!mark_fail"(0)
    lt rx808_pos, -1, rx808_done
    eq rx808_pos, -1, rx808_fail
    jump $I10
  rx808_done:
    rx808_cur."!cursor_fail"()
    if_null rx808_debug, debug_936
    rx808_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_936:
    .return (rx808_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1303391609.928") :method
.annotate 'line', 10
    $P810 = self."!PREFIX__!subrule"("scoped", "has")
    new $P811, "ResizablePMCArray"
    push $P811, $P810
    .return ($P811)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1303391609.928") :method :outer("12_1303391609.928")
    .param pmc param_815
.annotate 'line', 381
    .lex "$*SCOPE", param_815
.annotate 'line', 10
    .local string rx816_tgt
    .local int rx816_pos
    .local int rx816_off
    .local int rx816_eos
    .local int rx816_rep
    .local pmc rx816_cur
    .local pmc rx816_debug
    (rx816_cur, rx816_pos, rx816_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx816_cur
    .local pmc match
    .lex "$/", match
    length rx816_eos, rx816_tgt
    gt rx816_pos, rx816_eos, rx816_done
    set rx816_off, 0
    lt rx816_pos, 2, rx816_start
    sub rx816_off, rx816_pos, 1
    substr rx816_tgt, rx816_tgt, rx816_off
  rx816_start:
    eq $I10, 1, rx816_restart
    if_null rx816_debug, debug_937
    rx816_cur."!cursor_debug"("START", "scoped")
  debug_937:
    $I10 = self.'from'()
    ne $I10, -1, rxscan822_done
    goto rxscan822_scan
  rxscan822_loop:
    (rx816_pos) = rx816_cur."from"()
    inc rx816_pos
    rx816_cur."!cursor_from"(rx816_pos)
    ge rx816_pos, rx816_eos, rxscan822_done
  rxscan822_scan:
    set_addr $I10, rxscan822_loop
    rx816_cur."!mark_push"(0, rx816_pos, $I10)
  rxscan822_done:
  alt823_0:
.annotate 'line', 381
    set_addr $I10, alt823_1
    rx816_cur."!mark_push"(0, rx816_pos, $I10)
.annotate 'line', 382
  # rx subrule "ws" subtype=method negate=
    rx816_cur."!cursor_pos"(rx816_pos)
    $P10 = rx816_cur."ws"()
    unless $P10, rx816_fail
    rx816_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx816_cur."!cursor_pos"(rx816_pos)
    $P10 = rx816_cur."declarator"()
    unless $P10, rx816_fail
    rx816_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx816_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx816_cur."!cursor_pos"(rx816_pos)
    $P10 = rx816_cur."ws"()
    unless $P10, rx816_fail
    rx816_pos = $P10."pos"()
    goto alt823_end
  alt823_1:
    set_addr $I10, alt823_2
    rx816_cur."!mark_push"(0, rx816_pos, $I10)
.annotate 'line', 383
  # rx subrule "ws" subtype=method negate=
    rx816_cur."!cursor_pos"(rx816_pos)
    $P10 = rx816_cur."ws"()
    unless $P10, rx816_fail
    rx816_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx816_cur."!cursor_pos"(rx816_pos)
    $P10 = rx816_cur."multi_declarator"()
    unless $P10, rx816_fail
    rx816_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx816_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx816_cur."!cursor_pos"(rx816_pos)
    $P10 = rx816_cur."ws"()
    unless $P10, rx816_fail
    rx816_pos = $P10."pos"()
    goto alt823_end
  alt823_2:
.annotate 'line', 384
  # rx subrule "ws" subtype=method negate=
    rx816_cur."!cursor_pos"(rx816_pos)
    $P10 = rx816_cur."ws"()
    unless $P10, rx816_fail
    rx816_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx816_cur."!cursor_pos"(rx816_pos)
    $P10 = rx816_cur."package_declarator"()
    unless $P10, rx816_fail
    rx816_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx816_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx816_cur."!cursor_pos"(rx816_pos)
    $P10 = rx816_cur."ws"()
    unless $P10, rx816_fail
    rx816_pos = $P10."pos"()
  alt823_end:
.annotate 'line', 381
  # rx pass
    rx816_cur."!cursor_pass"(rx816_pos, "scoped")
    if_null rx816_debug, debug_938
    rx816_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx816_pos)
  debug_938:
    .return (rx816_cur)
  rx816_restart:
.annotate 'line', 10
    if_null rx816_debug, debug_939
    rx816_cur."!cursor_debug"("NEXT", "scoped")
  debug_939:
  rx816_fail:
    (rx816_rep, rx816_pos, $I10, $P10) = rx816_cur."!mark_fail"(0)
    lt rx816_pos, -1, rx816_done
    eq rx816_pos, -1, rx816_fail
    jump $I10
  rx816_done:
    rx816_cur."!cursor_fail"()
    if_null rx816_debug, debug_940
    rx816_cur."!cursor_debug"("FAIL", "scoped")
  debug_940:
    .return (rx816_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1303391609.928") :method
.annotate 'line', 10
    $P818 = self."!PREFIX__!subrule"("ws", "")
    $P819 = self."!PREFIX__!subrule"("ws", "")
    $P820 = self."!PREFIX__!subrule"("ws", "")
    new $P821, "ResizablePMCArray"
    push $P821, $P818
    push $P821, $P819
    push $P821, $P820
    .return ($P821)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx831_tgt
    .local int rx831_pos
    .local int rx831_off
    .local int rx831_eos
    .local int rx831_rep
    .local pmc rx831_cur
    .local pmc rx831_debug
    (rx831_cur, rx831_pos, rx831_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx831_cur
    .local pmc match
    .lex "$/", match
    length rx831_eos, rx831_tgt
    gt rx831_pos, rx831_eos, rx831_done
    set rx831_off, 0
    lt rx831_pos, 2, rx831_start
    sub rx831_off, rx831_pos, 1
    substr rx831_tgt, rx831_tgt, rx831_off
  rx831_start:
    eq $I10, 1, rx831_restart
    if_null rx831_debug, debug_941
    rx831_cur."!cursor_debug"("START", "typename")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan835_done
    goto rxscan835_scan
  rxscan835_loop:
    (rx831_pos) = rx831_cur."from"()
    inc rx831_pos
    rx831_cur."!cursor_from"(rx831_pos)
    ge rx831_pos, rx831_eos, rxscan835_done
  rxscan835_scan:
    set_addr $I10, rxscan835_loop
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  rxscan835_done:
.annotate 'line', 387
  # rx subrule "name" subtype=capture negate=
    rx831_cur."!cursor_pos"(rx831_pos)
    $P10 = rx831_cur."name"()
    unless $P10, rx831_fail
    rx831_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx831_pos = $P10."pos"()
  # rx pass
    rx831_cur."!cursor_pass"(rx831_pos, "typename")
    if_null rx831_debug, debug_942
    rx831_cur."!cursor_debug"("PASS", "typename", " at pos=", rx831_pos)
  debug_942:
    .return (rx831_cur)
  rx831_restart:
.annotate 'line', 10
    if_null rx831_debug, debug_943
    rx831_cur."!cursor_debug"("NEXT", "typename")
  debug_943:
  rx831_fail:
    (rx831_rep, rx831_pos, $I10, $P10) = rx831_cur."!mark_fail"(0)
    lt rx831_pos, -1, rx831_done
    eq rx831_pos, -1, rx831_fail
    jump $I10
  rx831_done:
    rx831_cur."!cursor_fail"()
    if_null rx831_debug, debug_944
    rx831_cur."!cursor_debug"("FAIL", "typename")
  debug_944:
    .return (rx831_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1303391609.928") :method
.annotate 'line', 10
    $P833 = self."!PREFIX__!subrule"("name", "")
    new $P834, "ResizablePMCArray"
    push $P834, $P833
    .return ($P834)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("167_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx837_tgt
    .local int rx837_pos
    .local int rx837_off
    .local int rx837_eos
    .local int rx837_rep
    .local pmc rx837_cur
    .local pmc rx837_debug
    (rx837_cur, rx837_pos, rx837_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx837_cur
    .local pmc match
    .lex "$/", match
    length rx837_eos, rx837_tgt
    gt rx837_pos, rx837_eos, rx837_done
    set rx837_off, 0
    lt rx837_pos, 2, rx837_start
    sub rx837_off, rx837_pos, 1
    substr rx837_tgt, rx837_tgt, rx837_off
  rx837_start:
    eq $I10, 1, rx837_restart
    if_null rx837_debug, debug_945
    rx837_cur."!cursor_debug"("START", "declarator")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan842_done
    goto rxscan842_scan
  rxscan842_loop:
    (rx837_pos) = rx837_cur."from"()
    inc rx837_pos
    rx837_cur."!cursor_from"(rx837_pos)
    ge rx837_pos, rx837_eos, rxscan842_done
  rxscan842_scan:
    set_addr $I10, rxscan842_loop
    rx837_cur."!mark_push"(0, rx837_pos, $I10)
  rxscan842_done:
  alt843_0:
.annotate 'line', 389
    set_addr $I10, alt843_1
    rx837_cur."!mark_push"(0, rx837_pos, $I10)
.annotate 'line', 390
  # rx subrule "variable_declarator" subtype=capture negate=
    rx837_cur."!cursor_pos"(rx837_pos)
    $P10 = rx837_cur."variable_declarator"()
    unless $P10, rx837_fail
    rx837_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx837_pos = $P10."pos"()
    goto alt843_end
  alt843_1:
.annotate 'line', 391
  # rx subrule "routine_declarator" subtype=capture negate=
    rx837_cur."!cursor_pos"(rx837_pos)
    $P10 = rx837_cur."routine_declarator"()
    unless $P10, rx837_fail
    rx837_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx837_pos = $P10."pos"()
  alt843_end:
.annotate 'line', 389
  # rx pass
    rx837_cur."!cursor_pass"(rx837_pos, "declarator")
    if_null rx837_debug, debug_946
    rx837_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx837_pos)
  debug_946:
    .return (rx837_cur)
  rx837_restart:
.annotate 'line', 10
    if_null rx837_debug, debug_947
    rx837_cur."!cursor_debug"("NEXT", "declarator")
  debug_947:
  rx837_fail:
    (rx837_rep, rx837_pos, $I10, $P10) = rx837_cur."!mark_fail"(0)
    lt rx837_pos, -1, rx837_done
    eq rx837_pos, -1, rx837_fail
    jump $I10
  rx837_done:
    rx837_cur."!cursor_fail"()
    if_null rx837_debug, debug_948
    rx837_cur."!cursor_debug"("FAIL", "declarator")
  debug_948:
    .return (rx837_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("168_1303391609.928") :method
.annotate 'line', 10
    $P839 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P840 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P841, "ResizablePMCArray"
    push $P841, $P839
    push $P841, $P840
    .return ($P841)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("169_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx845_tgt
    .local int rx845_pos
    .local int rx845_off
    .local int rx845_eos
    .local int rx845_rep
    .local pmc rx845_cur
    .local pmc rx845_debug
    (rx845_cur, rx845_pos, rx845_tgt, $I10) = self."!cursor_start"()
    rx845_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx845_cur
    .local pmc match
    .lex "$/", match
    length rx845_eos, rx845_tgt
    gt rx845_pos, rx845_eos, rx845_done
    set rx845_off, 0
    lt rx845_pos, 2, rx845_start
    sub rx845_off, rx845_pos, 1
    substr rx845_tgt, rx845_tgt, rx845_off
  rx845_start:
    eq $I10, 1, rx845_restart
    if_null rx845_debug, debug_949
    rx845_cur."!cursor_debug"("START", "variable_declarator")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan849_done
    goto rxscan849_scan
  rxscan849_loop:
    (rx845_pos) = rx845_cur."from"()
    inc rx845_pos
    rx845_cur."!cursor_from"(rx845_pos)
    ge rx845_pos, rx845_eos, rxscan849_done
  rxscan849_scan:
    set_addr $I10, rxscan849_loop
    rx845_cur."!mark_push"(0, rx845_pos, $I10)
  rxscan849_done:
.annotate 'line', 394
  # rx subrule "ws" subtype=method negate=
    rx845_cur."!cursor_pos"(rx845_pos)
    $P10 = rx845_cur."ws"()
    unless $P10, rx845_fail
    rx845_pos = $P10."pos"()
  # rx rxquantr851 ** 0..1
    set_addr $I10, rxquantr851_done
    rx845_cur."!mark_push"(0, rx845_pos, $I10)
  rxquantr851_loop:
  # rx subrule "typename" subtype=capture negate=
    rx845_cur."!cursor_pos"(rx845_pos)
    $P10 = rx845_cur."typename"()
    unless $P10, rx845_fail
    goto rxsubrule852_pass
  rxsubrule852_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx845_fail
  rxsubrule852_pass:
    set_addr $I10, rxsubrule852_back
    rx845_cur."!mark_push"(0, rx845_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx845_pos = $P10."pos"()
    set_addr $I10, rxquantr851_done
    (rx845_rep) = rx845_cur."!mark_commit"($I10)
  rxquantr851_done:
  # rx subrule "ws" subtype=method negate=
    rx845_cur."!cursor_pos"(rx845_pos)
    $P10 = rx845_cur."ws"()
    unless $P10, rx845_fail
    rx845_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx845_cur."!cursor_pos"(rx845_pos)
    $P10 = rx845_cur."variable"()
    unless $P10, rx845_fail
    rx845_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx845_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx845_cur."!cursor_pos"(rx845_pos)
    $P10 = rx845_cur."ws"()
    unless $P10, rx845_fail
    rx845_pos = $P10."pos"()
  # rx pass
    rx845_cur."!cursor_pass"(rx845_pos, "variable_declarator")
    if_null rx845_debug, debug_950
    rx845_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx845_pos)
  debug_950:
    .return (rx845_cur)
  rx845_restart:
.annotate 'line', 10
    if_null rx845_debug, debug_951
    rx845_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_951:
  rx845_fail:
    (rx845_rep, rx845_pos, $I10, $P10) = rx845_cur."!mark_fail"(0)
    lt rx845_pos, -1, rx845_done
    eq rx845_pos, -1, rx845_fail
    jump $I10
  rx845_done:
    rx845_cur."!cursor_fail"()
    if_null rx845_debug, debug_952
    rx845_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_952:
    .return (rx845_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("170_1303391609.928") :method
.annotate 'line', 10
    $P847 = self."!PREFIX__!subrule"("ws", "")
    new $P848, "ResizablePMCArray"
    push $P848, $P847
    .return ($P848)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("171_1303391609.928")
    .param pmc param_856
.annotate 'line', 396
    .lex "self", param_856
    $P857 = param_856."!protoregex"("routine_declarator")
    .return ($P857)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("172_1303391609.928")
    .param pmc param_859
.annotate 'line', 396
    .lex "self", param_859
    $P860 = param_859."!PREFIX__!protoregex"("routine_declarator")
    .return ($P860)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("173_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx862_tgt
    .local int rx862_pos
    .local int rx862_off
    .local int rx862_eos
    .local int rx862_rep
    .local pmc rx862_cur
    .local pmc rx862_debug
    (rx862_cur, rx862_pos, rx862_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx862_cur
    .local pmc match
    .lex "$/", match
    length rx862_eos, rx862_tgt
    gt rx862_pos, rx862_eos, rx862_done
    set rx862_off, 0
    lt rx862_pos, 2, rx862_start
    sub rx862_off, rx862_pos, 1
    substr rx862_tgt, rx862_tgt, rx862_off
  rx862_start:
    eq $I10, 1, rx862_restart
    if_null rx862_debug, debug_953
    rx862_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan866_done
    goto rxscan866_scan
  rxscan866_loop:
    (rx862_pos) = rx862_cur."from"()
    inc rx862_pos
    rx862_cur."!cursor_from"(rx862_pos)
    ge rx862_pos, rx862_eos, rxscan866_done
  rxscan866_scan:
    set_addr $I10, rxscan866_loop
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  rxscan866_done:
.annotate 'line', 397
  # rx subcapture "sym"
    set_addr $I10, rxcap_867_fail
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  # rx literal  "sub"
    add $I11, rx862_pos, 3
    gt $I11, rx862_eos, rx862_fail
    sub $I11, rx862_pos, rx862_off
    substr $S10, rx862_tgt, $I11, 3
    ne $S10, "sub", rx862_fail
    add rx862_pos, 3
    set_addr $I10, rxcap_867_fail
    ($I12, $I11) = rx862_cur."!mark_peek"($I10)
    rx862_cur."!cursor_pos"($I11)
    ($P10) = rx862_cur."!cursor_start"()
    $P10."!cursor_pass"(rx862_pos, "")
    rx862_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_867_done
  rxcap_867_fail:
    goto rx862_fail
  rxcap_867_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."routine_def"()
    unless $P10, rx862_fail
    rx862_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx862_pos = $P10."pos"()
  # rx pass
    rx862_cur."!cursor_pass"(rx862_pos, "routine_declarator:sym<sub>")
    if_null rx862_debug, debug_954
    rx862_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx862_pos)
  debug_954:
    .return (rx862_cur)
  rx862_restart:
.annotate 'line', 10
    if_null rx862_debug, debug_955
    rx862_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_955:
  rx862_fail:
    (rx862_rep, rx862_pos, $I10, $P10) = rx862_cur."!mark_fail"(0)
    lt rx862_pos, -1, rx862_done
    eq rx862_pos, -1, rx862_fail
    jump $I10
  rx862_done:
    rx862_cur."!cursor_fail"()
    if_null rx862_debug, debug_956
    rx862_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_956:
    .return (rx862_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("174_1303391609.928") :method
.annotate 'line', 10
    $P864 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P865, "ResizablePMCArray"
    push $P865, $P864
    .return ($P865)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("175_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx869_tgt
    .local int rx869_pos
    .local int rx869_off
    .local int rx869_eos
    .local int rx869_rep
    .local pmc rx869_cur
    .local pmc rx869_debug
    (rx869_cur, rx869_pos, rx869_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx869_cur
    .local pmc match
    .lex "$/", match
    length rx869_eos, rx869_tgt
    gt rx869_pos, rx869_eos, rx869_done
    set rx869_off, 0
    lt rx869_pos, 2, rx869_start
    sub rx869_off, rx869_pos, 1
    substr rx869_tgt, rx869_tgt, rx869_off
  rx869_start:
    eq $I10, 1, rx869_restart
    if_null rx869_debug, debug_957
    rx869_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_957:
    $I10 = self.'from'()
    ne $I10, -1, rxscan873_done
    goto rxscan873_scan
  rxscan873_loop:
    (rx869_pos) = rx869_cur."from"()
    inc rx869_pos
    rx869_cur."!cursor_from"(rx869_pos)
    ge rx869_pos, rx869_eos, rxscan873_done
  rxscan873_scan:
    set_addr $I10, rxscan873_loop
    rx869_cur."!mark_push"(0, rx869_pos, $I10)
  rxscan873_done:
.annotate 'line', 398
  # rx subcapture "sym"
    set_addr $I10, rxcap_874_fail
    rx869_cur."!mark_push"(0, rx869_pos, $I10)
  # rx literal  "method"
    add $I11, rx869_pos, 6
    gt $I11, rx869_eos, rx869_fail
    sub $I11, rx869_pos, rx869_off
    substr $S10, rx869_tgt, $I11, 6
    ne $S10, "method", rx869_fail
    add rx869_pos, 6
    set_addr $I10, rxcap_874_fail
    ($I12, $I11) = rx869_cur."!mark_peek"($I10)
    rx869_cur."!cursor_pos"($I11)
    ($P10) = rx869_cur."!cursor_start"()
    $P10."!cursor_pass"(rx869_pos, "")
    rx869_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_874_done
  rxcap_874_fail:
    goto rx869_fail
  rxcap_874_done:
  # rx subrule "method_def" subtype=capture negate=
    rx869_cur."!cursor_pos"(rx869_pos)
    $P10 = rx869_cur."method_def"()
    unless $P10, rx869_fail
    rx869_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx869_pos = $P10."pos"()
  # rx pass
    rx869_cur."!cursor_pass"(rx869_pos, "routine_declarator:sym<method>")
    if_null rx869_debug, debug_958
    rx869_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx869_pos)
  debug_958:
    .return (rx869_cur)
  rx869_restart:
.annotate 'line', 10
    if_null rx869_debug, debug_959
    rx869_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_959:
  rx869_fail:
    (rx869_rep, rx869_pos, $I10, $P10) = rx869_cur."!mark_fail"(0)
    lt rx869_pos, -1, rx869_done
    eq rx869_pos, -1, rx869_fail
    jump $I10
  rx869_done:
    rx869_cur."!cursor_fail"()
    if_null rx869_debug, debug_960
    rx869_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_960:
    .return (rx869_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("176_1303391609.928") :method
.annotate 'line', 10
    $P871 = self."!PREFIX__!subrule"("method_def", "method")
    new $P872, "ResizablePMCArray"
    push $P872, $P871
    .return ($P872)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("177_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 401
    new $P876, "Undef"
    .lex "$*RETURN_USED", $P876
.annotate 'line', 10
    .local string rx877_tgt
    .local int rx877_pos
    .local int rx877_off
    .local int rx877_eos
    .local int rx877_rep
    .local pmc rx877_cur
    .local pmc rx877_debug
    (rx877_cur, rx877_pos, rx877_tgt, $I10) = self."!cursor_start"()
    rx877_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx877_cur
    .local pmc match
    .lex "$/", match
    length rx877_eos, rx877_tgt
    gt rx877_pos, rx877_eos, rx877_done
    set rx877_off, 0
    lt rx877_pos, 2, rx877_start
    sub rx877_off, rx877_pos, 1
    substr rx877_tgt, rx877_tgt, rx877_off
  rx877_start:
    eq $I10, 1, rx877_restart
    if_null rx877_debug, debug_961
    rx877_cur."!cursor_debug"("START", "routine_def")
  debug_961:
    $I10 = self.'from'()
    ne $I10, -1, rxscan881_done
    goto rxscan881_scan
  rxscan881_loop:
    (rx877_pos) = rx877_cur."from"()
    inc rx877_pos
    rx877_cur."!cursor_from"(rx877_pos)
    ge rx877_pos, rx877_eos, rxscan881_done
  rxscan881_scan:
    set_addr $I10, rxscan881_loop
    rx877_cur."!mark_push"(0, rx877_pos, $I10)
  rxscan881_done:
.annotate 'line', 400
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
.annotate 'line', 401
    rx877_cur."!cursor_pos"(rx877_pos)
    new $P883, "Integer"
    assign $P883, 0
    store_lex "$*RETURN_USED", $P883
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
.annotate 'line', 402
  # rx rxquantr885 ** 0..1
    set_addr $I10, rxquantr885_done
    rx877_cur."!mark_push"(0, rx877_pos, $I10)
  rxquantr885_loop:
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_888_fail
    rx877_cur."!mark_push"(0, rx877_pos, $I10)
  # rx rxquantr887 ** 0..1
    set_addr $I10, rxquantr887_done
    rx877_cur."!mark_push"(0, rx877_pos, $I10)
  rxquantr887_loop:
  # rx literal  "&"
    add $I11, rx877_pos, 1
    gt $I11, rx877_eos, rx877_fail
    sub $I11, rx877_pos, rx877_off
    ord $I11, rx877_tgt, $I11
    ne $I11, 38, rx877_fail
    add rx877_pos, 1
    set_addr $I10, rxquantr887_done
    (rx877_rep) = rx877_cur."!mark_commit"($I10)
  rxquantr887_done:
    set_addr $I10, rxcap_888_fail
    ($I12, $I11) = rx877_cur."!mark_peek"($I10)
    rx877_cur."!cursor_pos"($I11)
    ($P10) = rx877_cur."!cursor_start"()
    $P10."!cursor_pass"(rx877_pos, "")
    rx877_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_888_done
  rxcap_888_fail:
    goto rx877_fail
  rxcap_888_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."deflongname"()
    unless $P10, rx877_fail
    rx877_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx877_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
    set_addr $I10, rxquantr885_done
    (rx877_rep) = rx877_cur."!mark_commit"($I10)
  rxquantr885_done:
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
.annotate 'line', 403
  # rx subrule "newpad" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."newpad"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  alt892_0:
.annotate 'line', 404
    set_addr $I10, alt892_1
    rx877_cur."!mark_push"(0, rx877_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx877_pos, 1
    gt $I11, rx877_eos, rx877_fail
    sub $I11, rx877_pos, rx877_off
    ord $I11, rx877_tgt, $I11
    ne $I11, 40, rx877_fail
    add rx877_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."signature"()
    unless $P10, rx877_fail
    rx877_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx877_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx877_pos, 1
    gt $I11, rx877_eos, rx877_fail
    sub $I11, rx877_pos, rx877_off
    ord $I11, rx877_tgt, $I11
    ne $I11, 41, rx877_fail
    add rx877_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
    goto alt892_end
  alt892_1:
.annotate 'line', 405
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  alt892_end:
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
.annotate 'line', 406
  # rx rxquantr900 ** 0..*
    set_addr $I10, rxquantr900_done
    rx877_cur."!mark_push"(0, rx877_pos, $I10)
  rxquantr900_loop:
  # rx subrule "trait" subtype=capture negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."trait"()
    unless $P10, rx877_fail
    goto rxsubrule901_pass
  rxsubrule901_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx877_fail
  rxsubrule901_pass:
    set_addr $I10, rxsubrule901_back
    rx877_cur."!mark_push"(0, rx877_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx877_pos = $P10."pos"()
    set_addr $I10, rxquantr900_done
    (rx877_rep) = rx877_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr900_done
    rx877_cur."!mark_push"(rx877_rep, rx877_pos, $I10)
    goto rxquantr900_loop
  rxquantr900_done:
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  alt903_0:
.annotate 'line', 407
    set_addr $I10, alt903_1
    rx877_cur."!mark_push"(0, rx877_pos, $I10)
.annotate 'line', 408
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."onlystar"()
    unless $P10, rx877_fail
    rx877_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx877_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
    goto alt903_end
  alt903_1:
.annotate 'line', 409
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."blockoid"()
    unless $P10, rx877_fail
    rx877_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx877_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
  alt903_end:
.annotate 'line', 410
  # rx subrule "ws" subtype=method negate=
    rx877_cur."!cursor_pos"(rx877_pos)
    $P10 = rx877_cur."ws"()
    unless $P10, rx877_fail
    rx877_pos = $P10."pos"()
.annotate 'line', 400
  # rx pass
    rx877_cur."!cursor_pass"(rx877_pos, "routine_def")
    if_null rx877_debug, debug_962
    rx877_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx877_pos)
  debug_962:
    .return (rx877_cur)
  rx877_restart:
.annotate 'line', 10
    if_null rx877_debug, debug_963
    rx877_cur."!cursor_debug"("NEXT", "routine_def")
  debug_963:
  rx877_fail:
    (rx877_rep, rx877_pos, $I10, $P10) = rx877_cur."!mark_fail"(0)
    lt rx877_pos, -1, rx877_done
    eq rx877_pos, -1, rx877_fail
    jump $I10
  rx877_done:
    rx877_cur."!cursor_fail"()
    if_null rx877_debug, debug_964
    rx877_cur."!cursor_debug"("FAIL", "routine_def")
  debug_964:
    .return (rx877_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("178_1303391609.928") :method
.annotate 'line', 10
    $P879 = self."!PREFIX__!subrule"("ws", "")
    new $P880, "ResizablePMCArray"
    push $P880, $P879
    .return ($P880)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("179_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P940 = "181_1303391609.928" 
    capture_lex $P940
.annotate 'line', 414
    new $P910, "Undef"
    .lex "$*RETURN_USED", $P910
.annotate 'line', 415
    new $P911, "Undef"
    .lex "$*INVOCANT_OK", $P911
.annotate 'line', 10
    .local string rx912_tgt
    .local int rx912_pos
    .local int rx912_off
    .local int rx912_eos
    .local int rx912_rep
    .local pmc rx912_cur
    .local pmc rx912_debug
    (rx912_cur, rx912_pos, rx912_tgt, $I10) = self."!cursor_start"()
    rx912_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx912_cur
    .local pmc match
    .lex "$/", match
    length rx912_eos, rx912_tgt
    gt rx912_pos, rx912_eos, rx912_done
    set rx912_off, 0
    lt rx912_pos, 2, rx912_start
    sub rx912_off, rx912_pos, 1
    substr rx912_tgt, rx912_tgt, rx912_off
  rx912_start:
    eq $I10, 1, rx912_restart
    if_null rx912_debug, debug_965
    rx912_cur."!cursor_debug"("START", "method_def")
  debug_965:
    $I10 = self.'from'()
    ne $I10, -1, rxscan916_done
    goto rxscan916_scan
  rxscan916_loop:
    (rx912_pos) = rx912_cur."from"()
    inc rx912_pos
    rx912_cur."!cursor_from"(rx912_pos)
    ge rx912_pos, rx912_eos, rxscan916_done
  rxscan916_scan:
    set_addr $I10, rxscan916_loop
    rx912_cur."!mark_push"(0, rx912_pos, $I10)
  rxscan916_done:
.annotate 'line', 413
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
.annotate 'line', 414
    rx912_cur."!cursor_pos"(rx912_pos)
    new $P918, "Integer"
    assign $P918, 0
    store_lex "$*RETURN_USED", $P918
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
.annotate 'line', 415
    rx912_cur."!cursor_pos"(rx912_pos)
    new $P920, "Integer"
    assign $P920, 1
    store_lex "$*INVOCANT_OK", $P920
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
.annotate 'line', 416
  # rx subcapture "private"
    set_addr $I10, rxcap_923_fail
    rx912_cur."!mark_push"(0, rx912_pos, $I10)
  # rx rxquantr922 ** 0..1
    set_addr $I10, rxquantr922_done
    rx912_cur."!mark_push"(0, rx912_pos, $I10)
  rxquantr922_loop:
  # rx literal  "!"
    add $I11, rx912_pos, 1
    gt $I11, rx912_eos, rx912_fail
    sub $I11, rx912_pos, rx912_off
    ord $I11, rx912_tgt, $I11
    ne $I11, 33, rx912_fail
    add rx912_pos, 1
    set_addr $I10, rxquantr922_done
    (rx912_rep) = rx912_cur."!mark_commit"($I10)
  rxquantr922_done:
    set_addr $I10, rxcap_923_fail
    ($I12, $I11) = rx912_cur."!mark_peek"($I10)
    rx912_cur."!cursor_pos"($I11)
    ($P10) = rx912_cur."!cursor_start"()
    $P10."!cursor_pass"(rx912_pos, "")
    rx912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_923_done
  rxcap_923_fail:
    goto rx912_fail
  rxcap_923_done:
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
.annotate 'line', 417
  # rx rxquantr925 ** 0..1
    set_addr $I10, rxquantr925_done
    rx912_cur."!mark_push"(0, rx912_pos, $I10)
  rxquantr925_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."deflongname"()
    unless $P10, rx912_fail
    goto rxsubrule926_pass
  rxsubrule926_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx912_fail
  rxsubrule926_pass:
    set_addr $I10, rxsubrule926_back
    rx912_cur."!mark_push"(0, rx912_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx912_pos = $P10."pos"()
    set_addr $I10, rxquantr925_done
    (rx912_rep) = rx912_cur."!mark_commit"($I10)
  rxquantr925_done:
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
.annotate 'line', 418
  # rx subrule "newpad" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."newpad"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  alt929_0:
.annotate 'line', 419
    set_addr $I10, alt929_1
    rx912_cur."!mark_push"(0, rx912_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx912_pos, 1
    gt $I11, rx912_eos, rx912_fail
    sub $I11, rx912_pos, rx912_off
    ord $I11, rx912_tgt, $I11
    ne $I11, 40, rx912_fail
    add rx912_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."signature"()
    unless $P10, rx912_fail
    rx912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx912_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx912_pos, 1
    gt $I11, rx912_eos, rx912_fail
    sub $I11, rx912_pos, rx912_off
    ord $I11, rx912_tgt, $I11
    ne $I11, 41, rx912_fail
    add rx912_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
    goto alt929_end
  alt929_1:
.annotate 'line', 420
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  alt929_end:
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
.annotate 'line', 421
    rx912_cur."!cursor_pos"(rx912_pos)
    find_lex $P937, unicode:"$\x{a2}"
    $P938 = $P937."MATCH"()
    store_lex "$/", $P938
    .const 'Sub' $P940 = "181_1303391609.928" 
    capture_lex $P940
    $P942 = $P940()
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
.annotate 'line', 422
  # rx rxquantr944 ** 0..*
    set_addr $I10, rxquantr944_done
    rx912_cur."!mark_push"(0, rx912_pos, $I10)
  rxquantr944_loop:
  # rx subrule "trait" subtype=capture negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."trait"()
    unless $P10, rx912_fail
    goto rxsubrule945_pass
  rxsubrule945_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx912_fail
  rxsubrule945_pass:
    set_addr $I10, rxsubrule945_back
    rx912_cur."!mark_push"(0, rx912_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx912_pos = $P10."pos"()
    set_addr $I10, rxquantr944_done
    (rx912_rep) = rx912_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr944_done
    rx912_cur."!mark_push"(rx912_rep, rx912_pos, $I10)
    goto rxquantr944_loop
  rxquantr944_done:
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  alt947_0:
.annotate 'line', 423
    set_addr $I10, alt947_1
    rx912_cur."!mark_push"(0, rx912_pos, $I10)
.annotate 'line', 424
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."onlystar"()
    unless $P10, rx912_fail
    rx912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx912_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
    goto alt947_end
  alt947_1:
.annotate 'line', 425
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."blockoid"()
    unless $P10, rx912_fail
    rx912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx912_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
  alt947_end:
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx912_cur."!cursor_pos"(rx912_pos)
    $P10 = rx912_cur."ws"()
    unless $P10, rx912_fail
    rx912_pos = $P10."pos"()
.annotate 'line', 413
  # rx pass
    rx912_cur."!cursor_pass"(rx912_pos, "method_def")
    if_null rx912_debug, debug_966
    rx912_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx912_pos)
  debug_966:
    .return (rx912_cur)
  rx912_restart:
.annotate 'line', 10
    if_null rx912_debug, debug_967
    rx912_cur."!cursor_debug"("NEXT", "method_def")
  debug_967:
  rx912_fail:
    (rx912_rep, rx912_pos, $I10, $P10) = rx912_cur."!mark_fail"(0)
    lt rx912_pos, -1, rx912_done
    eq rx912_pos, -1, rx912_fail
    jump $I10
  rx912_done:
    rx912_cur."!cursor_fail"()
    if_null rx912_debug, debug_968
    rx912_cur."!cursor_debug"("FAIL", "method_def")
  debug_968:
    .return (rx912_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("180_1303391609.928") :method
.annotate 'line', 10
    $P914 = self."!PREFIX__!subrule"("ws", "")
    new $P915, "ResizablePMCArray"
    push $P915, $P914
    .return ($P915)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block939"  :anon :subid("181_1303391609.928") :outer("179_1303391609.928")
.annotate 'line', 421
    new $P941, "Integer"
    assign $P941, 0
    store_dynamic_lex "$*INVOCANT_OK", $P941
    .return ($P941)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("182_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P961 = "184_1303391609.928" 
    capture_lex $P961
    .local string rx954_tgt
    .local int rx954_pos
    .local int rx954_off
    .local int rx954_eos
    .local int rx954_rep
    .local pmc rx954_cur
    .local pmc rx954_debug
    (rx954_cur, rx954_pos, rx954_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx954_cur
    .local pmc match
    .lex "$/", match
    length rx954_eos, rx954_tgt
    gt rx954_pos, rx954_eos, rx954_done
    set rx954_off, 0
    lt rx954_pos, 2, rx954_start
    sub rx954_off, rx954_pos, 1
    substr rx954_tgt, rx954_tgt, rx954_off
  rx954_start:
    eq $I10, 1, rx954_restart
    if_null rx954_debug, debug_969
    rx954_cur."!cursor_debug"("START", "onlystar")
  debug_969:
    $I10 = self.'from'()
    ne $I10, -1, rxscan957_done
    goto rxscan957_scan
  rxscan957_loop:
    (rx954_pos) = rx954_cur."from"()
    inc rx954_pos
    rx954_cur."!cursor_from"(rx954_pos)
    ge rx954_pos, rx954_eos, rxscan957_done
  rxscan957_scan:
    set_addr $I10, rxscan957_loop
    rx954_cur."!mark_push"(0, rx954_pos, $I10)
  rxscan957_done:
.annotate 'line', 430
    rx954_cur."!cursor_pos"(rx954_pos)
    find_lex $P958, unicode:"$\x{a2}"
    $P959 = $P958."MATCH"()
    store_lex "$/", $P959
    .const 'Sub' $P961 = "184_1303391609.928" 
    capture_lex $P961
    $P965 = $P961()
    unless $P965, rx954_fail
.annotate 'line', 431
  # rx literal  "{"
    add $I11, rx954_pos, 1
    gt $I11, rx954_eos, rx954_fail
    sub $I11, rx954_pos, rx954_off
    ord $I11, rx954_tgt, $I11
    ne $I11, 123, rx954_fail
    add rx954_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx954_cur."!cursor_pos"(rx954_pos)
    $P10 = rx954_cur."ws"()
    unless $P10, rx954_fail
    rx954_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx954_pos, 1
    gt $I11, rx954_eos, rx954_fail
    sub $I11, rx954_pos, rx954_off
    ord $I11, rx954_tgt, $I11
    ne $I11, 42, rx954_fail
    add rx954_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx954_cur."!cursor_pos"(rx954_pos)
    $P10 = rx954_cur."ws"()
    unless $P10, rx954_fail
    rx954_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx954_pos, 1
    gt $I11, rx954_eos, rx954_fail
    sub $I11, rx954_pos, rx954_off
    ord $I11, rx954_tgt, $I11
    ne $I11, 125, rx954_fail
    add rx954_pos, 1
.annotate 'line', 432
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx954_cur."!cursor_pos"(rx954_pos)
    $P10 = rx954_cur."ENDSTMT"()
    unless $P10, rx954_fail
.annotate 'line', 433
  # rx subrule "finishpad" subtype=method negate=
    rx954_cur."!cursor_pos"(rx954_pos)
    $P10 = rx954_cur."finishpad"()
    unless $P10, rx954_fail
    rx954_pos = $P10."pos"()
.annotate 'line', 429
  # rx pass
    rx954_cur."!cursor_pass"(rx954_pos, "onlystar")
    if_null rx954_debug, debug_972
    rx954_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx954_pos)
  debug_972:
    .return (rx954_cur)
  rx954_restart:
.annotate 'line', 10
    if_null rx954_debug, debug_973
    rx954_cur."!cursor_debug"("NEXT", "onlystar")
  debug_973:
  rx954_fail:
    (rx954_rep, rx954_pos, $I10, $P10) = rx954_cur."!mark_fail"(0)
    lt rx954_pos, -1, rx954_done
    eq rx954_pos, -1, rx954_fail
    jump $I10
  rx954_done:
    rx954_cur."!cursor_fail"()
    if_null rx954_debug, debug_974
    rx954_cur."!cursor_debug"("FAIL", "onlystar")
  debug_974:
    .return (rx954_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("183_1303391609.928") :method
.annotate 'line', 10
    new $P956, "ResizablePMCArray"
    push $P956, ""
    .return ($P956)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block960"  :anon :subid("184_1303391609.928") :outer("182_1303391609.928")
.annotate 'line', 430
    find_dynamic_lex $P962, "$*MULTINESS"
    unless_null $P962, vivify_970
    get_hll_global $P962, "$MULTINESS"
    unless_null $P962, vivify_971
    die "Contextual $*MULTINESS not found"
  vivify_971:
  vivify_970:
    set $S963, $P962
    iseq $I964, $S963, "proto"
    .return ($I964)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("185_1303391609.928")
    .param pmc param_967
.annotate 'line', 436
    .lex "self", param_967
    $P968 = param_967."!protoregex"("multi_declarator")
    .return ($P968)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("186_1303391609.928")
    .param pmc param_970
.annotate 'line', 436
    .lex "self", param_970
    $P971 = param_970."!PREFIX__!protoregex"("multi_declarator")
    .return ($P971)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("187_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 438
    new $P973, "Undef"
    .lex "$*MULTINESS", $P973
.annotate 'line', 10
    .local string rx974_tgt
    .local int rx974_pos
    .local int rx974_off
    .local int rx974_eos
    .local int rx974_rep
    .local pmc rx974_cur
    .local pmc rx974_debug
    (rx974_cur, rx974_pos, rx974_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx974_cur
    .local pmc match
    .lex "$/", match
    length rx974_eos, rx974_tgt
    gt rx974_pos, rx974_eos, rx974_done
    set rx974_off, 0
    lt rx974_pos, 2, rx974_start
    sub rx974_off, rx974_pos, 1
    substr rx974_tgt, rx974_tgt, rx974_off
  rx974_start:
    eq $I10, 1, rx974_restart
    if_null rx974_debug, debug_975
    rx974_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan978_done
    goto rxscan978_scan
  rxscan978_loop:
    (rx974_pos) = rx974_cur."from"()
    inc rx974_pos
    rx974_cur."!cursor_from"(rx974_pos)
    ge rx974_pos, rx974_eos, rxscan978_done
  rxscan978_scan:
    set_addr $I10, rxscan978_loop
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  rxscan978_done:
.annotate 'line', 438
    rx974_cur."!cursor_pos"(rx974_pos)
    new $P979, "String"
    assign $P979, "multi"
    store_lex "$*MULTINESS", $P979
.annotate 'line', 439
  # rx subcapture "sym"
    set_addr $I10, rxcap_980_fail
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  # rx literal  "multi"
    add $I11, rx974_pos, 5
    gt $I11, rx974_eos, rx974_fail
    sub $I11, rx974_pos, rx974_off
    substr $S10, rx974_tgt, $I11, 5
    ne $S10, "multi", rx974_fail
    add rx974_pos, 5
    set_addr $I10, rxcap_980_fail
    ($I12, $I11) = rx974_cur."!mark_peek"($I10)
    rx974_cur."!cursor_pos"($I11)
    ($P10) = rx974_cur."!cursor_start"()
    $P10."!cursor_pass"(rx974_pos, "")
    rx974_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_980_done
  rxcap_980_fail:
    goto rx974_fail
  rxcap_980_done:
.annotate 'line', 440
  # rx subrule "ws" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."ws"()
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  alt981_0:
    set_addr $I10, alt981_1
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."declarator"()
    unless $P10, rx974_fail
    rx974_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx974_pos = $P10."pos"()
    goto alt981_end
  alt981_1:
    set_addr $I10, alt981_2
    rx974_cur."!mark_push"(0, rx974_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."routine_def"()
    unless $P10, rx974_fail
    rx974_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx974_pos = $P10."pos"()
    goto alt981_end
  alt981_2:
  # rx subrule "panic" subtype=method negate=
    rx974_cur."!cursor_pos"(rx974_pos)
    $P10 = rx974_cur."panic"("Malformed multi")
    unless $P10, rx974_fail
    rx974_pos = $P10."pos"()
  alt981_end:
.annotate 'line', 437
  # rx pass
    rx974_cur."!cursor_pass"(rx974_pos, "multi_declarator:sym<multi>")
    if_null rx974_debug, debug_976
    rx974_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx974_pos)
  debug_976:
    .return (rx974_cur)
  rx974_restart:
.annotate 'line', 10
    if_null rx974_debug, debug_977
    rx974_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_977:
  rx974_fail:
    (rx974_rep, rx974_pos, $I10, $P10) = rx974_cur."!mark_fail"(0)
    lt rx974_pos, -1, rx974_done
    eq rx974_pos, -1, rx974_fail
    jump $I10
  rx974_done:
    rx974_cur."!cursor_fail"()
    if_null rx974_debug, debug_978
    rx974_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_978:
    .return (rx974_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("188_1303391609.928") :method
.annotate 'line', 10
    $P976 = self."!PREFIX__!subrule"("ws", "multi")
    new $P977, "ResizablePMCArray"
    push $P977, $P976
    .return ($P977)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("189_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 443
    new $P983, "Undef"
    .lex "$*MULTINESS", $P983
.annotate 'line', 10
    .local string rx984_tgt
    .local int rx984_pos
    .local int rx984_off
    .local int rx984_eos
    .local int rx984_rep
    .local pmc rx984_cur
    .local pmc rx984_debug
    (rx984_cur, rx984_pos, rx984_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx984_cur
    .local pmc match
    .lex "$/", match
    length rx984_eos, rx984_tgt
    gt rx984_pos, rx984_eos, rx984_done
    set rx984_off, 0
    lt rx984_pos, 2, rx984_start
    sub rx984_off, rx984_pos, 1
    substr rx984_tgt, rx984_tgt, rx984_off
  rx984_start:
    eq $I10, 1, rx984_restart
    if_null rx984_debug, debug_979
    rx984_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan988_done
    goto rxscan988_scan
  rxscan988_loop:
    (rx984_pos) = rx984_cur."from"()
    inc rx984_pos
    rx984_cur."!cursor_from"(rx984_pos)
    ge rx984_pos, rx984_eos, rxscan988_done
  rxscan988_scan:
    set_addr $I10, rxscan988_loop
    rx984_cur."!mark_push"(0, rx984_pos, $I10)
  rxscan988_done:
.annotate 'line', 443
    rx984_cur."!cursor_pos"(rx984_pos)
    new $P989, "String"
    assign $P989, "proto"
    store_lex "$*MULTINESS", $P989
.annotate 'line', 444
  # rx subcapture "sym"
    set_addr $I10, rxcap_990_fail
    rx984_cur."!mark_push"(0, rx984_pos, $I10)
  # rx literal  "proto"
    add $I11, rx984_pos, 5
    gt $I11, rx984_eos, rx984_fail
    sub $I11, rx984_pos, rx984_off
    substr $S10, rx984_tgt, $I11, 5
    ne $S10, "proto", rx984_fail
    add rx984_pos, 5
    set_addr $I10, rxcap_990_fail
    ($I12, $I11) = rx984_cur."!mark_peek"($I10)
    rx984_cur."!cursor_pos"($I11)
    ($P10) = rx984_cur."!cursor_start"()
    $P10."!cursor_pass"(rx984_pos, "")
    rx984_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_990_done
  rxcap_990_fail:
    goto rx984_fail
  rxcap_990_done:
.annotate 'line', 445
  # rx subrule "ws" subtype=method negate=
    rx984_cur."!cursor_pos"(rx984_pos)
    $P10 = rx984_cur."ws"()
    unless $P10, rx984_fail
    rx984_pos = $P10."pos"()
  alt991_0:
    set_addr $I10, alt991_1
    rx984_cur."!mark_push"(0, rx984_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx984_cur."!cursor_pos"(rx984_pos)
    $P10 = rx984_cur."declarator"()
    unless $P10, rx984_fail
    rx984_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx984_pos = $P10."pos"()
    goto alt991_end
  alt991_1:
    set_addr $I10, alt991_2
    rx984_cur."!mark_push"(0, rx984_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx984_cur."!cursor_pos"(rx984_pos)
    $P10 = rx984_cur."routine_def"()
    unless $P10, rx984_fail
    rx984_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx984_pos = $P10."pos"()
    goto alt991_end
  alt991_2:
  # rx subrule "panic" subtype=method negate=
    rx984_cur."!cursor_pos"(rx984_pos)
    $P10 = rx984_cur."panic"("Malformed proto")
    unless $P10, rx984_fail
    rx984_pos = $P10."pos"()
  alt991_end:
.annotate 'line', 442
  # rx pass
    rx984_cur."!cursor_pass"(rx984_pos, "multi_declarator:sym<proto>")
    if_null rx984_debug, debug_980
    rx984_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx984_pos)
  debug_980:
    .return (rx984_cur)
  rx984_restart:
.annotate 'line', 10
    if_null rx984_debug, debug_981
    rx984_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_981:
  rx984_fail:
    (rx984_rep, rx984_pos, $I10, $P10) = rx984_cur."!mark_fail"(0)
    lt rx984_pos, -1, rx984_done
    eq rx984_pos, -1, rx984_fail
    jump $I10
  rx984_done:
    rx984_cur."!cursor_fail"()
    if_null rx984_debug, debug_982
    rx984_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_982:
    .return (rx984_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("190_1303391609.928") :method
.annotate 'line', 10
    $P986 = self."!PREFIX__!subrule"("ws", "proto")
    new $P987, "ResizablePMCArray"
    push $P987, $P986
    .return ($P987)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("191_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 448
    new $P993, "Undef"
    .lex "$*MULTINESS", $P993
.annotate 'line', 10
    .local string rx994_tgt
    .local int rx994_pos
    .local int rx994_off
    .local int rx994_eos
    .local int rx994_rep
    .local pmc rx994_cur
    .local pmc rx994_debug
    (rx994_cur, rx994_pos, rx994_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx994_cur
    .local pmc match
    .lex "$/", match
    length rx994_eos, rx994_tgt
    gt rx994_pos, rx994_eos, rx994_done
    set rx994_off, 0
    lt rx994_pos, 2, rx994_start
    sub rx994_off, rx994_pos, 1
    substr rx994_tgt, rx994_tgt, rx994_off
  rx994_start:
    eq $I10, 1, rx994_restart
    if_null rx994_debug, debug_983
    rx994_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan998_done
    goto rxscan998_scan
  rxscan998_loop:
    (rx994_pos) = rx994_cur."from"()
    inc rx994_pos
    rx994_cur."!cursor_from"(rx994_pos)
    ge rx994_pos, rx994_eos, rxscan998_done
  rxscan998_scan:
    set_addr $I10, rxscan998_loop
    rx994_cur."!mark_push"(0, rx994_pos, $I10)
  rxscan998_done:
.annotate 'line', 448
    rx994_cur."!cursor_pos"(rx994_pos)
    new $P999, "String"
    assign $P999, ""
    store_lex "$*MULTINESS", $P999
.annotate 'line', 449
  # rx subrule "declarator" subtype=capture negate=
    rx994_cur."!cursor_pos"(rx994_pos)
    $P10 = rx994_cur."declarator"()
    unless $P10, rx994_fail
    rx994_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx994_pos = $P10."pos"()
.annotate 'line', 447
  # rx pass
    rx994_cur."!cursor_pass"(rx994_pos, "multi_declarator:sym<null>")
    if_null rx994_debug, debug_984
    rx994_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx994_pos)
  debug_984:
    .return (rx994_cur)
  rx994_restart:
.annotate 'line', 10
    if_null rx994_debug, debug_985
    rx994_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_985:
  rx994_fail:
    (rx994_rep, rx994_pos, $I10, $P10) = rx994_cur."!mark_fail"(0)
    lt rx994_pos, -1, rx994_done
    eq rx994_pos, -1, rx994_fail
    jump $I10
  rx994_done:
    rx994_cur."!cursor_fail"()
    if_null rx994_debug, debug_986
    rx994_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_986:
    .return (rx994_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("192_1303391609.928") :method
.annotate 'line', 10
    $P996 = self."!PREFIX__!subrule"("declarator", "")
    new $P997, "ResizablePMCArray"
    push $P997, $P996
    .return ($P997)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("193_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P1009 = "195_1303391609.928" 
    capture_lex $P1009
    .local string rx1001_tgt
    .local int rx1001_pos
    .local int rx1001_off
    .local int rx1001_eos
    .local int rx1001_rep
    .local pmc rx1001_cur
    .local pmc rx1001_debug
    (rx1001_cur, rx1001_pos, rx1001_tgt, $I10) = self."!cursor_start"()
    rx1001_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1001_cur
    .local pmc match
    .lex "$/", match
    length rx1001_eos, rx1001_tgt
    gt rx1001_pos, rx1001_eos, rx1001_done
    set rx1001_off, 0
    lt rx1001_pos, 2, rx1001_start
    sub rx1001_off, rx1001_pos, 1
    substr rx1001_tgt, rx1001_tgt, rx1001_off
  rx1001_start:
    eq $I10, 1, rx1001_restart
    if_null rx1001_debug, debug_987
    rx1001_cur."!cursor_debug"("START", "signature")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1004_done
    goto rxscan1004_scan
  rxscan1004_loop:
    (rx1001_pos) = rx1001_cur."from"()
    inc rx1001_pos
    rx1001_cur."!cursor_from"(rx1001_pos)
    ge rx1001_pos, rx1001_eos, rxscan1004_done
  rxscan1004_scan:
    set_addr $I10, rxscan1004_loop
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  rxscan1004_done:
.annotate 'line', 453
  # rx rxquantr1005 ** 0..1
    set_addr $I10, rxquantr1005_done
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  rxquantr1005_loop:
    rx1001_cur."!cursor_pos"(rx1001_pos)
    find_lex $P1006, unicode:"$\x{a2}"
    $P1007 = $P1006."MATCH"()
    store_lex "$/", $P1007
    .const 'Sub' $P1009 = "195_1303391609.928" 
    capture_lex $P1009
    $P1011 = $P1009()
    unless $P1011, rx1001_fail
  # rx subrule "ws" subtype=method negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."ws"()
    unless $P10, rx1001_fail
    rx1001_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."parameter"()
    unless $P10, rx1001_fail
    rx1001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1001_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."ws"()
    unless $P10, rx1001_fail
    rx1001_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1001_pos, 1
    gt $I11, rx1001_eos, rx1001_fail
    sub $I11, rx1001_pos, rx1001_off
    ord $I11, rx1001_tgt, $I11
    ne $I11, 58, rx1001_fail
    add rx1001_pos, 1
    set_addr $I10, rxquantr1005_done
    (rx1001_rep) = rx1001_cur."!mark_commit"($I10)
  rxquantr1005_done:
.annotate 'line', 454
  # rx rxquantr1012 ** 0..1
    set_addr $I10, rxquantr1012_done
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  rxquantr1012_loop:
  # rx rxquantr1013 ** 1..*
    set_addr $I10, rxquantr1013_done
    rx1001_cur."!mark_push"(0, -1, $I10)
  rxquantr1013_loop:
  # rx subrule "ws" subtype=method negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."ws"()
    unless $P10, rx1001_fail
    rx1001_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."parameter"()
    unless $P10, rx1001_fail
    rx1001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1001_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."ws"()
    unless $P10, rx1001_fail
    rx1001_pos = $P10."pos"()
    set_addr $I10, rxquantr1013_done
    (rx1001_rep) = rx1001_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1013_done
    rx1001_cur."!mark_push"(rx1001_rep, rx1001_pos, $I10)
  # rx literal  ","
    add $I11, rx1001_pos, 1
    gt $I11, rx1001_eos, rx1001_fail
    sub $I11, rx1001_pos, rx1001_off
    ord $I11, rx1001_tgt, $I11
    ne $I11, 44, rx1001_fail
    add rx1001_pos, 1
    goto rxquantr1013_loop
  rxquantr1013_done:
    set_addr $I10, rxquantr1012_done
    (rx1001_rep) = rx1001_cur."!mark_commit"($I10)
  rxquantr1012_done:
.annotate 'line', 452
  # rx pass
    rx1001_cur."!cursor_pass"(rx1001_pos, "signature")
    if_null rx1001_debug, debug_990
    rx1001_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1001_pos)
  debug_990:
    .return (rx1001_cur)
  rx1001_restart:
.annotate 'line', 10
    if_null rx1001_debug, debug_991
    rx1001_cur."!cursor_debug"("NEXT", "signature")
  debug_991:
  rx1001_fail:
    (rx1001_rep, rx1001_pos, $I10, $P10) = rx1001_cur."!mark_fail"(0)
    lt rx1001_pos, -1, rx1001_done
    eq rx1001_pos, -1, rx1001_fail
    jump $I10
  rx1001_done:
    rx1001_cur."!cursor_fail"()
    if_null rx1001_debug, debug_992
    rx1001_cur."!cursor_debug"("FAIL", "signature")
  debug_992:
    .return (rx1001_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("194_1303391609.928") :method
.annotate 'line', 10
    new $P1003, "ResizablePMCArray"
    push $P1003, ""
    .return ($P1003)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1008"  :anon :subid("195_1303391609.928") :outer("193_1303391609.928")
.annotate 'line', 453
    find_dynamic_lex $P1010, "$*INVOCANT_OK"
    unless_null $P1010, vivify_988
    get_hll_global $P1010, "$INVOCANT_OK"
    unless_null $P1010, vivify_989
    die "Contextual $*INVOCANT_OK not found"
  vivify_989:
  vivify_988:
    .return ($P1010)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("196_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1015_tgt
    .local int rx1015_pos
    .local int rx1015_off
    .local int rx1015_eos
    .local int rx1015_rep
    .local pmc rx1015_cur
    .local pmc rx1015_debug
    (rx1015_cur, rx1015_pos, rx1015_tgt, $I10) = self."!cursor_start"()
    rx1015_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1015_cur
    .local pmc match
    .lex "$/", match
    length rx1015_eos, rx1015_tgt
    gt rx1015_pos, rx1015_eos, rx1015_done
    set rx1015_off, 0
    lt rx1015_pos, 2, rx1015_start
    sub rx1015_off, rx1015_pos, 1
    substr rx1015_tgt, rx1015_tgt, rx1015_off
  rx1015_start:
    eq $I10, 1, rx1015_restart
    if_null rx1015_debug, debug_993
    rx1015_cur."!cursor_debug"("START", "parameter")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1018_done
    goto rxscan1018_scan
  rxscan1018_loop:
    (rx1015_pos) = rx1015_cur."from"()
    inc rx1015_pos
    rx1015_cur."!cursor_from"(rx1015_pos)
    ge rx1015_pos, rx1015_eos, rxscan1018_done
  rxscan1018_scan:
    set_addr $I10, rxscan1018_loop
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  rxscan1018_done:
.annotate 'line', 458
  # rx rxquantr1019 ** 0..*
    set_addr $I10, rxquantr1019_done
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  rxquantr1019_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."typename"()
    unless $P10, rx1015_fail
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1015_pos = $P10."pos"()
  # rx rxquantr1020 ** 0..1
    set_addr $I10, rxquantr1020_done
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  rxquantr1020_loop:
  # rx literal  ":"
    add $I11, rx1015_pos, 1
    gt $I11, rx1015_eos, rx1015_fail
    sub $I11, rx1015_pos, rx1015_off
    ord $I11, rx1015_tgt, $I11
    ne $I11, 58, rx1015_fail
    add rx1015_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1021_fail
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1015_pos, rx1015_eos, rx1015_fail
    sub $I10, rx1015_pos, rx1015_off
    substr $S10, rx1015_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1015_fail
    inc rx1015_pos
    set_addr $I10, rxcap_1021_fail
    ($I12, $I11) = rx1015_cur."!mark_peek"($I10)
    rx1015_cur."!cursor_pos"($I11)
    ($P10) = rx1015_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1015_pos, "")
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1021_done
  rxcap_1021_fail:
    goto rx1015_fail
  rxcap_1021_done:
    set_addr $I10, rxquantr1020_done
    (rx1015_rep) = rx1015_cur."!mark_commit"($I10)
  rxquantr1020_done:
  # rx subrule "ws" subtype=method negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."ws"()
    unless $P10, rx1015_fail
    rx1015_pos = $P10."pos"()
    set_addr $I10, rxquantr1019_done
    (rx1015_rep) = rx1015_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1019_done
    rx1015_cur."!mark_push"(rx1015_rep, rx1015_pos, $I10)
    goto rxquantr1019_loop
  rxquantr1019_done:
  alt1022_0:
.annotate 'line', 459
    set_addr $I10, alt1022_1
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
.annotate 'line', 460
  # rx subcapture "quant"
    set_addr $I10, rxcap_1023_fail
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  # rx literal  "*"
    add $I11, rx1015_pos, 1
    gt $I11, rx1015_eos, rx1015_fail
    sub $I11, rx1015_pos, rx1015_off
    ord $I11, rx1015_tgt, $I11
    ne $I11, 42, rx1015_fail
    add rx1015_pos, 1
    set_addr $I10, rxcap_1023_fail
    ($I12, $I11) = rx1015_cur."!mark_peek"($I10)
    rx1015_cur."!cursor_pos"($I11)
    ($P10) = rx1015_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1015_pos, "")
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1023_done
  rxcap_1023_fail:
    goto rx1015_fail
  rxcap_1023_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."param_var"()
    unless $P10, rx1015_fail
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1015_pos = $P10."pos"()
    goto alt1022_end
  alt1022_1:
  alt1024_0:
.annotate 'line', 461
    set_addr $I10, alt1024_1
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."param_var"()
    unless $P10, rx1015_fail
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1015_pos = $P10."pos"()
    goto alt1024_end
  alt1024_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."named_param"()
    unless $P10, rx1015_fail
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1015_pos = $P10."pos"()
  alt1024_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1026_fail
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  alt1025_0:
    set_addr $I10, alt1025_1
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  # rx literal  "?"
    add $I11, rx1015_pos, 1
    gt $I11, rx1015_eos, rx1015_fail
    sub $I11, rx1015_pos, rx1015_off
    ord $I11, rx1015_tgt, $I11
    ne $I11, 63, rx1015_fail
    add rx1015_pos, 1
    goto alt1025_end
  alt1025_1:
    set_addr $I10, alt1025_2
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  # rx literal  "!"
    add $I11, rx1015_pos, 1
    gt $I11, rx1015_eos, rx1015_fail
    sub $I11, rx1015_pos, rx1015_off
    ord $I11, rx1015_tgt, $I11
    ne $I11, 33, rx1015_fail
    add rx1015_pos, 1
    goto alt1025_end
  alt1025_2:
  alt1025_end:
    set_addr $I10, rxcap_1026_fail
    ($I12, $I11) = rx1015_cur."!mark_peek"($I10)
    rx1015_cur."!cursor_pos"($I11)
    ($P10) = rx1015_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1015_pos, "")
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1026_done
  rxcap_1026_fail:
    goto rx1015_fail
  rxcap_1026_done:
  alt1022_end:
.annotate 'line', 463
  # rx rxquantr1027 ** 0..1
    set_addr $I10, rxquantr1027_done
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  rxquantr1027_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."default_value"()
    unless $P10, rx1015_fail
    goto rxsubrule1028_pass
  rxsubrule1028_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1015_fail
  rxsubrule1028_pass:
    set_addr $I10, rxsubrule1028_back
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1015_pos = $P10."pos"()
    set_addr $I10, rxquantr1027_done
    (rx1015_rep) = rx1015_cur."!mark_commit"($I10)
  rxquantr1027_done:
.annotate 'line', 457
  # rx pass
    rx1015_cur."!cursor_pass"(rx1015_pos, "parameter")
    if_null rx1015_debug, debug_994
    rx1015_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1015_pos)
  debug_994:
    .return (rx1015_cur)
  rx1015_restart:
.annotate 'line', 10
    if_null rx1015_debug, debug_995
    rx1015_cur."!cursor_debug"("NEXT", "parameter")
  debug_995:
  rx1015_fail:
    (rx1015_rep, rx1015_pos, $I10, $P10) = rx1015_cur."!mark_fail"(0)
    lt rx1015_pos, -1, rx1015_done
    eq rx1015_pos, -1, rx1015_fail
    jump $I10
  rx1015_done:
    rx1015_cur."!cursor_fail"()
    if_null rx1015_debug, debug_996
    rx1015_cur."!cursor_debug"("FAIL", "parameter")
  debug_996:
    .return (rx1015_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("197_1303391609.928") :method
.annotate 'line', 10
    new $P1017, "ResizablePMCArray"
    push $P1017, ""
    .return ($P1017)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("198_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1030_tgt
    .local int rx1030_pos
    .local int rx1030_off
    .local int rx1030_eos
    .local int rx1030_rep
    .local pmc rx1030_cur
    .local pmc rx1030_debug
    (rx1030_cur, rx1030_pos, rx1030_tgt, $I10) = self."!cursor_start"()
    rx1030_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1030_cur
    .local pmc match
    .lex "$/", match
    length rx1030_eos, rx1030_tgt
    gt rx1030_pos, rx1030_eos, rx1030_done
    set rx1030_off, 0
    lt rx1030_pos, 2, rx1030_start
    sub rx1030_off, rx1030_pos, 1
    substr rx1030_tgt, rx1030_tgt, rx1030_off
  rx1030_start:
    eq $I10, 1, rx1030_restart
    if_null rx1030_debug, debug_997
    rx1030_cur."!cursor_debug"("START", "param_var")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1034_done
    goto rxscan1034_scan
  rxscan1034_loop:
    (rx1030_pos) = rx1030_cur."from"()
    inc rx1030_pos
    rx1030_cur."!cursor_from"(rx1030_pos)
    ge rx1030_pos, rx1030_eos, rxscan1034_done
  rxscan1034_scan:
    set_addr $I10, rxscan1034_loop
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxscan1034_done:
.annotate 'line', 467
  # rx subrule "sigil" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."sigil"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1030_pos = $P10."pos"()
  # rx rxquantr1035 ** 0..1
    set_addr $I10, rxquantr1035_done
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxquantr1035_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."twigil"()
    unless $P10, rx1030_fail
    goto rxsubrule1036_pass
  rxsubrule1036_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1030_fail
  rxsubrule1036_pass:
    set_addr $I10, rxsubrule1036_back
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1030_pos = $P10."pos"()
    set_addr $I10, rxquantr1035_done
    (rx1030_rep) = rx1030_cur."!mark_commit"($I10)
  rxquantr1035_done:
  alt1037_0:
.annotate 'line', 468
    set_addr $I10, alt1037_1
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ident"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1030_pos = $P10."pos"()
    goto alt1037_end
  alt1037_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1038_fail
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1030_pos, rx1030_eos, rx1030_fail
    sub $I10, rx1030_pos, rx1030_off
    substr $S10, rx1030_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1030_fail
    inc rx1030_pos
    set_addr $I10, rxcap_1038_fail
    ($I12, $I11) = rx1030_cur."!mark_peek"($I10)
    rx1030_cur."!cursor_pos"($I11)
    ($P10) = rx1030_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1030_pos, "")
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1038_done
  rxcap_1038_fail:
    goto rx1030_fail
  rxcap_1038_done:
  alt1037_end:
.annotate 'line', 466
  # rx pass
    rx1030_cur."!cursor_pass"(rx1030_pos, "param_var")
    if_null rx1030_debug, debug_998
    rx1030_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1030_pos)
  debug_998:
    .return (rx1030_cur)
  rx1030_restart:
.annotate 'line', 10
    if_null rx1030_debug, debug_999
    rx1030_cur."!cursor_debug"("NEXT", "param_var")
  debug_999:
  rx1030_fail:
    (rx1030_rep, rx1030_pos, $I10, $P10) = rx1030_cur."!mark_fail"(0)
    lt rx1030_pos, -1, rx1030_done
    eq rx1030_pos, -1, rx1030_fail
    jump $I10
  rx1030_done:
    rx1030_cur."!cursor_fail"()
    if_null rx1030_debug, debug_1000
    rx1030_cur."!cursor_debug"("FAIL", "param_var")
  debug_1000:
    .return (rx1030_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("199_1303391609.928") :method
.annotate 'line', 10
    $P1032 = self."!PREFIX__!subrule"("sigil", "")
    new $P1033, "ResizablePMCArray"
    push $P1033, $P1032
    .return ($P1033)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("200_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1040_tgt
    .local int rx1040_pos
    .local int rx1040_off
    .local int rx1040_eos
    .local int rx1040_rep
    .local pmc rx1040_cur
    .local pmc rx1040_debug
    (rx1040_cur, rx1040_pos, rx1040_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1040_cur
    .local pmc match
    .lex "$/", match
    length rx1040_eos, rx1040_tgt
    gt rx1040_pos, rx1040_eos, rx1040_done
    set rx1040_off, 0
    lt rx1040_pos, 2, rx1040_start
    sub rx1040_off, rx1040_pos, 1
    substr rx1040_tgt, rx1040_tgt, rx1040_off
  rx1040_start:
    eq $I10, 1, rx1040_restart
    if_null rx1040_debug, debug_1001
    rx1040_cur."!cursor_debug"("START", "named_param")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1044_done
    goto rxscan1044_scan
  rxscan1044_loop:
    (rx1040_pos) = rx1040_cur."from"()
    inc rx1040_pos
    rx1040_cur."!cursor_from"(rx1040_pos)
    ge rx1040_pos, rx1040_eos, rxscan1044_done
  rxscan1044_scan:
    set_addr $I10, rxscan1044_loop
    rx1040_cur."!mark_push"(0, rx1040_pos, $I10)
  rxscan1044_done:
.annotate 'line', 472
  # rx literal  ":"
    add $I11, rx1040_pos, 1
    gt $I11, rx1040_eos, rx1040_fail
    sub $I11, rx1040_pos, rx1040_off
    ord $I11, rx1040_tgt, $I11
    ne $I11, 58, rx1040_fail
    add rx1040_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1040_cur."!cursor_pos"(rx1040_pos)
    $P10 = rx1040_cur."param_var"()
    unless $P10, rx1040_fail
    rx1040_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1040_pos = $P10."pos"()
.annotate 'line', 471
  # rx pass
    rx1040_cur."!cursor_pass"(rx1040_pos, "named_param")
    if_null rx1040_debug, debug_1002
    rx1040_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1040_pos)
  debug_1002:
    .return (rx1040_cur)
  rx1040_restart:
.annotate 'line', 10
    if_null rx1040_debug, debug_1003
    rx1040_cur."!cursor_debug"("NEXT", "named_param")
  debug_1003:
  rx1040_fail:
    (rx1040_rep, rx1040_pos, $I10, $P10) = rx1040_cur."!mark_fail"(0)
    lt rx1040_pos, -1, rx1040_done
    eq rx1040_pos, -1, rx1040_fail
    jump $I10
  rx1040_done:
    rx1040_cur."!cursor_fail"()
    if_null rx1040_debug, debug_1004
    rx1040_cur."!cursor_debug"("FAIL", "named_param")
  debug_1004:
    .return (rx1040_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("201_1303391609.928") :method
.annotate 'line', 10
    $P1042 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1043, "ResizablePMCArray"
    push $P1043, $P1042
    .return ($P1043)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("202_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1046_tgt
    .local int rx1046_pos
    .local int rx1046_off
    .local int rx1046_eos
    .local int rx1046_rep
    .local pmc rx1046_cur
    .local pmc rx1046_debug
    (rx1046_cur, rx1046_pos, rx1046_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1046_cur
    .local pmc match
    .lex "$/", match
    length rx1046_eos, rx1046_tgt
    gt rx1046_pos, rx1046_eos, rx1046_done
    set rx1046_off, 0
    lt rx1046_pos, 2, rx1046_start
    sub rx1046_off, rx1046_pos, 1
    substr rx1046_tgt, rx1046_tgt, rx1046_off
  rx1046_start:
    eq $I10, 1, rx1046_restart
    if_null rx1046_debug, debug_1005
    rx1046_cur."!cursor_debug"("START", "default_value")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1050_done
    goto rxscan1050_scan
  rxscan1050_loop:
    (rx1046_pos) = rx1046_cur."from"()
    inc rx1046_pos
    rx1046_cur."!cursor_from"(rx1046_pos)
    ge rx1046_pos, rx1046_eos, rxscan1050_done
  rxscan1050_scan:
    set_addr $I10, rxscan1050_loop
    rx1046_cur."!mark_push"(0, rx1046_pos, $I10)
  rxscan1050_done:
.annotate 'line', 475
  # rx subrule "ws" subtype=method negate=
    rx1046_cur."!cursor_pos"(rx1046_pos)
    $P10 = rx1046_cur."ws"()
    unless $P10, rx1046_fail
    rx1046_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1046_pos, 1
    gt $I11, rx1046_eos, rx1046_fail
    sub $I11, rx1046_pos, rx1046_off
    ord $I11, rx1046_tgt, $I11
    ne $I11, 61, rx1046_fail
    add rx1046_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1046_cur."!cursor_pos"(rx1046_pos)
    $P10 = rx1046_cur."ws"()
    unless $P10, rx1046_fail
    rx1046_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1046_cur."!cursor_pos"(rx1046_pos)
    $P10 = rx1046_cur."EXPR"("i=")
    unless $P10, rx1046_fail
    rx1046_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1046_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1046_cur."!cursor_pos"(rx1046_pos)
    $P10 = rx1046_cur."ws"()
    unless $P10, rx1046_fail
    rx1046_pos = $P10."pos"()
  # rx pass
    rx1046_cur."!cursor_pass"(rx1046_pos, "default_value")
    if_null rx1046_debug, debug_1006
    rx1046_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1046_pos)
  debug_1006:
    .return (rx1046_cur)
  rx1046_restart:
.annotate 'line', 10
    if_null rx1046_debug, debug_1007
    rx1046_cur."!cursor_debug"("NEXT", "default_value")
  debug_1007:
  rx1046_fail:
    (rx1046_rep, rx1046_pos, $I10, $P10) = rx1046_cur."!mark_fail"(0)
    lt rx1046_pos, -1, rx1046_done
    eq rx1046_pos, -1, rx1046_fail
    jump $I10
  rx1046_done:
    rx1046_cur."!cursor_fail"()
    if_null rx1046_debug, debug_1008
    rx1046_cur."!cursor_debug"("FAIL", "default_value")
  debug_1008:
    .return (rx1046_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("203_1303391609.928") :method
.annotate 'line', 10
    $P1048 = self."!PREFIX__!subrule"("ws", "")
    new $P1049, "ResizablePMCArray"
    push $P1049, $P1048
    .return ($P1049)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("204_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1055_tgt
    .local int rx1055_pos
    .local int rx1055_off
    .local int rx1055_eos
    .local int rx1055_rep
    .local pmc rx1055_cur
    .local pmc rx1055_debug
    (rx1055_cur, rx1055_pos, rx1055_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1055_cur
    .local pmc match
    .lex "$/", match
    length rx1055_eos, rx1055_tgt
    gt rx1055_pos, rx1055_eos, rx1055_done
    set rx1055_off, 0
    lt rx1055_pos, 2, rx1055_start
    sub rx1055_off, rx1055_pos, 1
    substr rx1055_tgt, rx1055_tgt, rx1055_off
  rx1055_start:
    eq $I10, 1, rx1055_restart
    if_null rx1055_debug, debug_1009
    rx1055_cur."!cursor_debug"("START", "trait")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1059_done
    goto rxscan1059_scan
  rxscan1059_loop:
    (rx1055_pos) = rx1055_cur."from"()
    inc rx1055_pos
    rx1055_cur."!cursor_from"(rx1055_pos)
    ge rx1055_pos, rx1055_eos, rxscan1059_done
  rxscan1059_scan:
    set_addr $I10, rxscan1059_loop
    rx1055_cur."!mark_push"(0, rx1055_pos, $I10)
  rxscan1059_done:
.annotate 'line', 477
  # rx subrule "ws" subtype=method negate=
    rx1055_cur."!cursor_pos"(rx1055_pos)
    $P10 = rx1055_cur."ws"()
    unless $P10, rx1055_fail
    rx1055_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1055_cur."!cursor_pos"(rx1055_pos)
    $P10 = rx1055_cur."trait_mod"()
    unless $P10, rx1055_fail
    rx1055_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1055_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1055_cur."!cursor_pos"(rx1055_pos)
    $P10 = rx1055_cur."ws"()
    unless $P10, rx1055_fail
    rx1055_pos = $P10."pos"()
  # rx pass
    rx1055_cur."!cursor_pass"(rx1055_pos, "trait")
    if_null rx1055_debug, debug_1010
    rx1055_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1055_pos)
  debug_1010:
    .return (rx1055_cur)
  rx1055_restart:
.annotate 'line', 10
    if_null rx1055_debug, debug_1011
    rx1055_cur."!cursor_debug"("NEXT", "trait")
  debug_1011:
  rx1055_fail:
    (rx1055_rep, rx1055_pos, $I10, $P10) = rx1055_cur."!mark_fail"(0)
    lt rx1055_pos, -1, rx1055_done
    eq rx1055_pos, -1, rx1055_fail
    jump $I10
  rx1055_done:
    rx1055_cur."!cursor_fail"()
    if_null rx1055_debug, debug_1012
    rx1055_cur."!cursor_debug"("FAIL", "trait")
  debug_1012:
    .return (rx1055_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("205_1303391609.928") :method
.annotate 'line', 10
    $P1057 = self."!PREFIX__!subrule"("ws", "")
    new $P1058, "ResizablePMCArray"
    push $P1058, $P1057
    .return ($P1058)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("206_1303391609.928")
    .param pmc param_1063
.annotate 'line', 479
    .lex "self", param_1063
    $P1064 = param_1063."!protoregex"("trait_mod")
    .return ($P1064)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("207_1303391609.928")
    .param pmc param_1066
.annotate 'line', 479
    .lex "self", param_1066
    $P1067 = param_1066."!PREFIX__!protoregex"("trait_mod")
    .return ($P1067)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("208_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1069_tgt
    .local int rx1069_pos
    .local int rx1069_off
    .local int rx1069_eos
    .local int rx1069_rep
    .local pmc rx1069_cur
    .local pmc rx1069_debug
    (rx1069_cur, rx1069_pos, rx1069_tgt, $I10) = self."!cursor_start"()
    rx1069_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1069_cur
    .local pmc match
    .lex "$/", match
    length rx1069_eos, rx1069_tgt
    gt rx1069_pos, rx1069_eos, rx1069_done
    set rx1069_off, 0
    lt rx1069_pos, 2, rx1069_start
    sub rx1069_off, rx1069_pos, 1
    substr rx1069_tgt, rx1069_tgt, rx1069_off
  rx1069_start:
    eq $I10, 1, rx1069_restart
    if_null rx1069_debug, debug_1013
    rx1069_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1073_done
    goto rxscan1073_scan
  rxscan1073_loop:
    (rx1069_pos) = rx1069_cur."from"()
    inc rx1069_pos
    rx1069_cur."!cursor_from"(rx1069_pos)
    ge rx1069_pos, rx1069_eos, rxscan1073_done
  rxscan1073_scan:
    set_addr $I10, rxscan1073_loop
    rx1069_cur."!mark_push"(0, rx1069_pos, $I10)
  rxscan1073_done:
.annotate 'line', 480
  # rx subcapture "sym"
    set_addr $I10, rxcap_1074_fail
    rx1069_cur."!mark_push"(0, rx1069_pos, $I10)
  # rx literal  "is"
    add $I11, rx1069_pos, 2
    gt $I11, rx1069_eos, rx1069_fail
    sub $I11, rx1069_pos, rx1069_off
    substr $S10, rx1069_tgt, $I11, 2
    ne $S10, "is", rx1069_fail
    add rx1069_pos, 2
    set_addr $I10, rxcap_1074_fail
    ($I12, $I11) = rx1069_cur."!mark_peek"($I10)
    rx1069_cur."!cursor_pos"($I11)
    ($P10) = rx1069_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1069_pos, "")
    rx1069_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1074_done
  rxcap_1074_fail:
    goto rx1069_fail
  rxcap_1074_done:
  # rx subrule "ws" subtype=method negate=
    rx1069_cur."!cursor_pos"(rx1069_pos)
    $P10 = rx1069_cur."ws"()
    unless $P10, rx1069_fail
    rx1069_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1069_cur."!cursor_pos"(rx1069_pos)
    $P10 = rx1069_cur."deflongname"()
    unless $P10, rx1069_fail
    rx1069_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1069_pos = $P10."pos"()
  # rx rxquantr1076 ** 0..1
    set_addr $I10, rxquantr1076_done
    rx1069_cur."!mark_push"(0, rx1069_pos, $I10)
  rxquantr1076_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1069_cur."!cursor_pos"(rx1069_pos)
    $P10 = rx1069_cur."circumfix"()
    unless $P10, rx1069_fail
    goto rxsubrule1077_pass
  rxsubrule1077_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1069_fail
  rxsubrule1077_pass:
    set_addr $I10, rxsubrule1077_back
    rx1069_cur."!mark_push"(0, rx1069_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1069_pos = $P10."pos"()
    set_addr $I10, rxquantr1076_done
    (rx1069_rep) = rx1069_cur."!mark_commit"($I10)
  rxquantr1076_done:
  # rx subrule "ws" subtype=method negate=
    rx1069_cur."!cursor_pos"(rx1069_pos)
    $P10 = rx1069_cur."ws"()
    unless $P10, rx1069_fail
    rx1069_pos = $P10."pos"()
  # rx pass
    rx1069_cur."!cursor_pass"(rx1069_pos, "trait_mod:sym<is>")
    if_null rx1069_debug, debug_1014
    rx1069_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1069_pos)
  debug_1014:
    .return (rx1069_cur)
  rx1069_restart:
.annotate 'line', 10
    if_null rx1069_debug, debug_1015
    rx1069_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1015:
  rx1069_fail:
    (rx1069_rep, rx1069_pos, $I10, $P10) = rx1069_cur."!mark_fail"(0)
    lt rx1069_pos, -1, rx1069_done
    eq rx1069_pos, -1, rx1069_fail
    jump $I10
  rx1069_done:
    rx1069_cur."!cursor_fail"()
    if_null rx1069_debug, debug_1016
    rx1069_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1016:
    .return (rx1069_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("209_1303391609.928") :method
.annotate 'line', 10
    $P1071 = self."!PREFIX__!subrule"("ws", "is")
    new $P1072, "ResizablePMCArray"
    push $P1072, $P1071
    .return ($P1072)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("210_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1080_tgt
    .local int rx1080_pos
    .local int rx1080_off
    .local int rx1080_eos
    .local int rx1080_rep
    .local pmc rx1080_cur
    .local pmc rx1080_debug
    (rx1080_cur, rx1080_pos, rx1080_tgt, $I10) = self."!cursor_start"()
    rx1080_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1080_cur
    .local pmc match
    .lex "$/", match
    length rx1080_eos, rx1080_tgt
    gt rx1080_pos, rx1080_eos, rx1080_done
    set rx1080_off, 0
    lt rx1080_pos, 2, rx1080_start
    sub rx1080_off, rx1080_pos, 1
    substr rx1080_tgt, rx1080_tgt, rx1080_off
  rx1080_start:
    eq $I10, 1, rx1080_restart
    if_null rx1080_debug, debug_1017
    rx1080_cur."!cursor_debug"("START", "regex_declarator")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1084_done
    goto rxscan1084_scan
  rxscan1084_loop:
    (rx1080_pos) = rx1080_cur."from"()
    inc rx1080_pos
    rx1080_cur."!cursor_from"(rx1080_pos)
    ge rx1080_pos, rx1080_eos, rxscan1084_done
  rxscan1084_scan:
    set_addr $I10, rxscan1084_loop
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxscan1084_done:
.annotate 'line', 482
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  alt1086_0:
.annotate 'line', 483
    set_addr $I10, alt1086_1
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
.annotate 'line', 484
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1088_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1080_pos, 5
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 5
    ne $S10, "proto", rx1080_fail
    add rx1080_pos, 5
    set_addr $I10, rxcap_1088_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1088_done
  rxcap_1088_fail:
    goto rx1080_fail
  rxcap_1088_done:
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  alt1090_0:
    set_addr $I10, alt1090_1
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1080_pos, 5
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 5
    ne $S10, "regex", rx1080_fail
    add rx1080_pos, 5
    goto alt1090_end
  alt1090_1:
    set_addr $I10, alt1090_2
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "token"
    add $I11, rx1080_pos, 5
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 5
    ne $S10, "token", rx1080_fail
    add rx1080_pos, 5
    goto alt1090_end
  alt1090_2:
  # rx literal  "rule"
    add $I11, rx1080_pos, 4
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 4
    ne $S10, "rule", rx1080_fail
    add rx1080_pos, 4
  alt1090_end:
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
.annotate 'line', 485
  # rx subrule "deflongname" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."deflongname"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1080_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  alt1093_0:
.annotate 'line', 486
    set_addr $I10, alt1093_1
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
.annotate 'line', 487
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 123, rx1080_fail
    add rx1080_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1080_pos, 5
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 5
    ne $S10, "<...>", rx1080_fail
    add rx1080_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 125, rx1080_fail
    add rx1080_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ENDSTMT"()
    unless $P10, rx1080_fail
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
    goto alt1093_end
  alt1093_1:
    set_addr $I10, alt1093_2
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
.annotate 'line', 488
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 123, rx1080_fail
    add rx1080_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1080_pos, 3
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 3
    ne $S10, "<*>", rx1080_fail
    add rx1080_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 125, rx1080_fail
    add rx1080_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ENDSTMT"()
    unless $P10, rx1080_fail
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
    goto alt1093_end
  alt1093_2:
.annotate 'line', 489
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  alt1093_end:
.annotate 'line', 490
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
.annotate 'line', 484
    goto alt1086_end
  alt1086_1:
.annotate 'line', 491
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1107_fail
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  alt1106_0:
    set_addr $I10, alt1106_1
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1080_pos, 5
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 5
    ne $S10, "regex", rx1080_fail
    add rx1080_pos, 5
    goto alt1106_end
  alt1106_1:
    set_addr $I10, alt1106_2
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  # rx literal  "token"
    add $I11, rx1080_pos, 5
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 5
    ne $S10, "token", rx1080_fail
    add rx1080_pos, 5
    goto alt1106_end
  alt1106_2:
  # rx literal  "rule"
    add $I11, rx1080_pos, 4
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    substr $S10, rx1080_tgt, $I11, 4
    ne $S10, "rule", rx1080_fail
    add rx1080_pos, 4
  alt1106_end:
    set_addr $I10, rxcap_1107_fail
    ($I12, $I11) = rx1080_cur."!mark_peek"($I10)
    rx1080_cur."!cursor_pos"($I11)
    ($P10) = rx1080_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1080_pos, "")
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1107_done
  rxcap_1107_fail:
    goto rx1080_fail
  rxcap_1107_done:
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
.annotate 'line', 492
  # rx subrule "deflongname" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."deflongname"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1080_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
.annotate 'line', 493
  # rx subrule "newpad" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."newpad"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
.annotate 'line', 494
  # rx rxquantr1111 ** 0..1
    set_addr $I10, rxquantr1111_done
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxquantr1111_loop:
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 40, rx1080_fail
    add rx1080_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."signature"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1080_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 41, rx1080_fail
    add rx1080_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
    set_addr $I10, rxquantr1111_done
    (rx1080_rep) = rx1080_cur."!mark_commit"($I10)
  rxquantr1111_done:
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
.annotate 'line', 495
  # rx reduce name="regex_declarator" key="open"
    rx1080_cur."!cursor_pos"(rx1080_pos)
    rx1080_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
.annotate 'line', 496
  # rx literal  "{"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 123, rx1080_fail
    add rx1080_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1080_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1080_pos, 1
    gt $I11, rx1080_eos, rx1080_fail
    sub $I11, rx1080_pos, rx1080_off
    ord $I11, rx1080_tgt, $I11
    ne $I11, 125, rx1080_fail
    add rx1080_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ENDSTMT"()
    unless $P10, rx1080_fail
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
  alt1086_end:
.annotate 'line', 497
  # rx subrule "ws" subtype=method negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."ws"()
    unless $P10, rx1080_fail
    rx1080_pos = $P10."pos"()
.annotate 'line', 482
  # rx pass
    rx1080_cur."!cursor_pass"(rx1080_pos, "regex_declarator")
    if_null rx1080_debug, debug_1018
    rx1080_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1080_pos)
  debug_1018:
    .return (rx1080_cur)
  rx1080_restart:
.annotate 'line', 10
    if_null rx1080_debug, debug_1019
    rx1080_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1019:
  rx1080_fail:
    (rx1080_rep, rx1080_pos, $I10, $P10) = rx1080_cur."!mark_fail"(0)
    lt rx1080_pos, -1, rx1080_done
    eq rx1080_pos, -1, rx1080_fail
    jump $I10
  rx1080_done:
    rx1080_cur."!cursor_fail"()
    if_null rx1080_debug, debug_1020
    rx1080_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1020:
    .return (rx1080_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("211_1303391609.928") :method
.annotate 'line', 10
    $P1082 = self."!PREFIX__!subrule"("ws", "")
    new $P1083, "ResizablePMCArray"
    push $P1083, $P1082
    .return ($P1083)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("212_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1121_tgt
    .local int rx1121_pos
    .local int rx1121_off
    .local int rx1121_eos
    .local int rx1121_rep
    .local pmc rx1121_cur
    .local pmc rx1121_debug
    (rx1121_cur, rx1121_pos, rx1121_tgt, $I10) = self."!cursor_start"()
    rx1121_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1121_cur
    .local pmc match
    .lex "$/", match
    length rx1121_eos, rx1121_tgt
    gt rx1121_pos, rx1121_eos, rx1121_done
    set rx1121_off, 0
    lt rx1121_pos, 2, rx1121_start
    sub rx1121_off, rx1121_pos, 1
    substr rx1121_tgt, rx1121_tgt, rx1121_off
  rx1121_start:
    eq $I10, 1, rx1121_restart
    if_null rx1121_debug, debug_1021
    rx1121_cur."!cursor_debug"("START", "dotty")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1125_done
    goto rxscan1125_scan
  rxscan1125_loop:
    (rx1121_pos) = rx1121_cur."from"()
    inc rx1121_pos
    rx1121_cur."!cursor_from"(rx1121_pos)
    ge rx1121_pos, rx1121_eos, rxscan1125_done
  rxscan1125_scan:
    set_addr $I10, rxscan1125_loop
    rx1121_cur."!mark_push"(0, rx1121_pos, $I10)
  rxscan1125_done:
.annotate 'line', 501
  # rx literal  "."
    add $I11, rx1121_pos, 1
    gt $I11, rx1121_eos, rx1121_fail
    sub $I11, rx1121_pos, rx1121_off
    ord $I11, rx1121_tgt, $I11
    ne $I11, 46, rx1121_fail
    add rx1121_pos, 1
  alt1126_0:
.annotate 'line', 502
    set_addr $I10, alt1126_1
    rx1121_cur."!mark_push"(0, rx1121_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."deflongname"()
    unless $P10, rx1121_fail
    rx1121_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1121_pos = $P10."pos"()
    goto alt1126_end
  alt1126_1:
.annotate 'line', 503
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1121_pos, rx1121_off
    substr $S10, rx1121_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1121_fail
  # rx subrule "quote" subtype=capture negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."quote"()
    unless $P10, rx1121_fail
    rx1121_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1121_pos = $P10."pos"()
  alt1127_0:
.annotate 'line', 504
    set_addr $I10, alt1127_1
    rx1121_cur."!mark_push"(0, rx1121_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1121_pos, rx1121_off
    substr $S10, rx1121_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1121_fail
    goto alt1127_end
  alt1127_1:
  # rx subrule "panic" subtype=method negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1121_fail
    rx1121_pos = $P10."pos"()
  alt1127_end:
  alt1126_end:
.annotate 'line', 510
  # rx rxquantr1128 ** 0..1
    set_addr $I10, rxquantr1128_done
    rx1121_cur."!mark_push"(0, rx1121_pos, $I10)
  rxquantr1128_loop:
  alt1129_0:
.annotate 'line', 507
    set_addr $I10, alt1129_1
    rx1121_cur."!mark_push"(0, rx1121_pos, $I10)
.annotate 'line', 508
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1121_pos, rx1121_off
    substr $S10, rx1121_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1121_fail
  # rx subrule "args" subtype=capture negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."args"()
    unless $P10, rx1121_fail
    rx1121_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1121_pos = $P10."pos"()
    goto alt1129_end
  alt1129_1:
.annotate 'line', 509
  # rx literal  ":"
    add $I11, rx1121_pos, 1
    gt $I11, rx1121_eos, rx1121_fail
    sub $I11, rx1121_pos, rx1121_off
    ord $I11, rx1121_tgt, $I11
    ne $I11, 58, rx1121_fail
    add rx1121_pos, 1
  # rx charclass s
    ge rx1121_pos, rx1121_eos, rx1121_fail
    sub $I10, rx1121_pos, rx1121_off
    is_cclass $I11, 32, rx1121_tgt, $I10
    unless $I11, rx1121_fail
    inc rx1121_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."arglist"()
    unless $P10, rx1121_fail
    rx1121_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1121_pos = $P10."pos"()
  alt1129_end:
.annotate 'line', 510
    set_addr $I10, rxquantr1128_done
    (rx1121_rep) = rx1121_cur."!mark_commit"($I10)
  rxquantr1128_done:
.annotate 'line', 500
  # rx pass
    rx1121_cur."!cursor_pass"(rx1121_pos, "dotty")
    if_null rx1121_debug, debug_1022
    rx1121_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1121_pos)
  debug_1022:
    .return (rx1121_cur)
  rx1121_restart:
.annotate 'line', 10
    if_null rx1121_debug, debug_1023
    rx1121_cur."!cursor_debug"("NEXT", "dotty")
  debug_1023:
  rx1121_fail:
    (rx1121_rep, rx1121_pos, $I10, $P10) = rx1121_cur."!mark_fail"(0)
    lt rx1121_pos, -1, rx1121_done
    eq rx1121_pos, -1, rx1121_fail
    jump $I10
  rx1121_done:
    rx1121_cur."!cursor_fail"()
    if_null rx1121_debug, debug_1024
    rx1121_cur."!cursor_debug"("FAIL", "dotty")
  debug_1024:
    .return (rx1121_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("213_1303391609.928") :method
.annotate 'line', 10
    $P1123 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1124, "ResizablePMCArray"
    push $P1124, "'"
    push $P1124, "\""
    push $P1124, $P1123
    .return ($P1124)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("214_1303391609.928")
    .param pmc param_1131
.annotate 'line', 514
    .lex "self", param_1131
    $P1132 = param_1131."!protoregex"("term")
    .return ($P1132)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("215_1303391609.928")
    .param pmc param_1134
.annotate 'line', 514
    .lex "self", param_1134
    $P1135 = param_1134."!PREFIX__!protoregex"("term")
    .return ($P1135)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("216_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1137_tgt
    .local int rx1137_pos
    .local int rx1137_off
    .local int rx1137_eos
    .local int rx1137_rep
    .local pmc rx1137_cur
    .local pmc rx1137_debug
    (rx1137_cur, rx1137_pos, rx1137_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1137_cur
    .local pmc match
    .lex "$/", match
    length rx1137_eos, rx1137_tgt
    gt rx1137_pos, rx1137_eos, rx1137_done
    set rx1137_off, 0
    lt rx1137_pos, 2, rx1137_start
    sub rx1137_off, rx1137_pos, 1
    substr rx1137_tgt, rx1137_tgt, rx1137_off
  rx1137_start:
    eq $I10, 1, rx1137_restart
    if_null rx1137_debug, debug_1025
    rx1137_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1140_done
    goto rxscan1140_scan
  rxscan1140_loop:
    (rx1137_pos) = rx1137_cur."from"()
    inc rx1137_pos
    rx1137_cur."!cursor_from"(rx1137_pos)
    ge rx1137_pos, rx1137_eos, rxscan1140_done
  rxscan1140_scan:
    set_addr $I10, rxscan1140_loop
    rx1137_cur."!mark_push"(0, rx1137_pos, $I10)
  rxscan1140_done:
.annotate 'line', 516
  # rx subcapture "sym"
    set_addr $I10, rxcap_1141_fail
    rx1137_cur."!mark_push"(0, rx1137_pos, $I10)
  # rx literal  "self"
    add $I11, rx1137_pos, 4
    gt $I11, rx1137_eos, rx1137_fail
    sub $I11, rx1137_pos, rx1137_off
    substr $S10, rx1137_tgt, $I11, 4
    ne $S10, "self", rx1137_fail
    add rx1137_pos, 4
    set_addr $I10, rxcap_1141_fail
    ($I12, $I11) = rx1137_cur."!mark_peek"($I10)
    rx1137_cur."!cursor_pos"($I11)
    ($P10) = rx1137_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1137_pos, "")
    rx1137_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1141_done
  rxcap_1141_fail:
    goto rx1137_fail
  rxcap_1141_done:
  # rxanchor rwb
    le rx1137_pos, 0, rx1137_fail
    sub $I10, rx1137_pos, rx1137_off
    is_cclass $I11, 8192, rx1137_tgt, $I10
    if $I11, rx1137_fail
    dec $I10
    is_cclass $I11, 8192, rx1137_tgt, $I10
    unless $I11, rx1137_fail
  # rx pass
    rx1137_cur."!cursor_pass"(rx1137_pos, "term:sym<self>")
    if_null rx1137_debug, debug_1026
    rx1137_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1137_pos)
  debug_1026:
    .return (rx1137_cur)
  rx1137_restart:
.annotate 'line', 10
    if_null rx1137_debug, debug_1027
    rx1137_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1027:
  rx1137_fail:
    (rx1137_rep, rx1137_pos, $I10, $P10) = rx1137_cur."!mark_fail"(0)
    lt rx1137_pos, -1, rx1137_done
    eq rx1137_pos, -1, rx1137_fail
    jump $I10
  rx1137_done:
    rx1137_cur."!cursor_fail"()
    if_null rx1137_debug, debug_1028
    rx1137_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1028:
    .return (rx1137_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("217_1303391609.928") :method
.annotate 'line', 10
    new $P1139, "ResizablePMCArray"
    push $P1139, "self"
    .return ($P1139)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("218_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1143_tgt
    .local int rx1143_pos
    .local int rx1143_off
    .local int rx1143_eos
    .local int rx1143_rep
    .local pmc rx1143_cur
    .local pmc rx1143_debug
    (rx1143_cur, rx1143_pos, rx1143_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1143_cur
    .local pmc match
    .lex "$/", match
    length rx1143_eos, rx1143_tgt
    gt rx1143_pos, rx1143_eos, rx1143_done
    set rx1143_off, 0
    lt rx1143_pos, 2, rx1143_start
    sub rx1143_off, rx1143_pos, 1
    substr rx1143_tgt, rx1143_tgt, rx1143_off
  rx1143_start:
    eq $I10, 1, rx1143_restart
    if_null rx1143_debug, debug_1029
    rx1143_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1147_done
    goto rxscan1147_scan
  rxscan1147_loop:
    (rx1143_pos) = rx1143_cur."from"()
    inc rx1143_pos
    rx1143_cur."!cursor_from"(rx1143_pos)
    ge rx1143_pos, rx1143_eos, rxscan1147_done
  rxscan1147_scan:
    set_addr $I10, rxscan1147_loop
    rx1143_cur."!mark_push"(0, rx1143_pos, $I10)
  rxscan1147_done:
.annotate 'line', 519
  # rx subrule "deflongname" subtype=capture negate=
    rx1143_cur."!cursor_pos"(rx1143_pos)
    $P10 = rx1143_cur."deflongname"()
    unless $P10, rx1143_fail
    rx1143_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1143_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1143_pos, rx1143_off
    substr $S10, rx1143_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1143_fail
  # rx subrule "args" subtype=capture negate=
    rx1143_cur."!cursor_pos"(rx1143_pos)
    $P10 = rx1143_cur."args"()
    unless $P10, rx1143_fail
    rx1143_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1143_pos = $P10."pos"()
.annotate 'line', 518
  # rx pass
    rx1143_cur."!cursor_pass"(rx1143_pos, "term:sym<identifier>")
    if_null rx1143_debug, debug_1030
    rx1143_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1143_pos)
  debug_1030:
    .return (rx1143_cur)
  rx1143_restart:
.annotate 'line', 10
    if_null rx1143_debug, debug_1031
    rx1143_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1031:
  rx1143_fail:
    (rx1143_rep, rx1143_pos, $I10, $P10) = rx1143_cur."!mark_fail"(0)
    lt rx1143_pos, -1, rx1143_done
    eq rx1143_pos, -1, rx1143_fail
    jump $I10
  rx1143_done:
    rx1143_cur."!cursor_fail"()
    if_null rx1143_debug, debug_1032
    rx1143_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1032:
    .return (rx1143_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("219_1303391609.928") :method
.annotate 'line', 10
    $P1145 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1146, "ResizablePMCArray"
    push $P1146, $P1145
    .return ($P1146)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("220_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1149_tgt
    .local int rx1149_pos
    .local int rx1149_off
    .local int rx1149_eos
    .local int rx1149_rep
    .local pmc rx1149_cur
    .local pmc rx1149_debug
    (rx1149_cur, rx1149_pos, rx1149_tgt, $I10) = self."!cursor_start"()
    rx1149_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1149_cur
    .local pmc match
    .lex "$/", match
    length rx1149_eos, rx1149_tgt
    gt rx1149_pos, rx1149_eos, rx1149_done
    set rx1149_off, 0
    lt rx1149_pos, 2, rx1149_start
    sub rx1149_off, rx1149_pos, 1
    substr rx1149_tgt, rx1149_tgt, rx1149_off
  rx1149_start:
    eq $I10, 1, rx1149_restart
    if_null rx1149_debug, debug_1033
    rx1149_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1153_done
    goto rxscan1153_scan
  rxscan1153_loop:
    (rx1149_pos) = rx1149_cur."from"()
    inc rx1149_pos
    rx1149_cur."!cursor_from"(rx1149_pos)
    ge rx1149_pos, rx1149_eos, rxscan1153_done
  rxscan1153_scan:
    set_addr $I10, rxscan1153_loop
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10)
  rxscan1153_done:
.annotate 'line', 523
  # rx subrule "name" subtype=capture negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."name"()
    unless $P10, rx1149_fail
    rx1149_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1149_pos = $P10."pos"()
  # rx rxquantr1154 ** 0..1
    set_addr $I10, rxquantr1154_done
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10)
  rxquantr1154_loop:
  # rx subrule "args" subtype=capture negate=
    rx1149_cur."!cursor_pos"(rx1149_pos)
    $P10 = rx1149_cur."args"()
    unless $P10, rx1149_fail
    goto rxsubrule1155_pass
  rxsubrule1155_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1149_fail
  rxsubrule1155_pass:
    set_addr $I10, rxsubrule1155_back
    rx1149_cur."!mark_push"(0, rx1149_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1149_pos = $P10."pos"()
    set_addr $I10, rxquantr1154_done
    (rx1149_rep) = rx1149_cur."!mark_commit"($I10)
  rxquantr1154_done:
.annotate 'line', 522
  # rx pass
    rx1149_cur."!cursor_pass"(rx1149_pos, "term:sym<name>")
    if_null rx1149_debug, debug_1034
    rx1149_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1149_pos)
  debug_1034:
    .return (rx1149_cur)
  rx1149_restart:
.annotate 'line', 10
    if_null rx1149_debug, debug_1035
    rx1149_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1035:
  rx1149_fail:
    (rx1149_rep, rx1149_pos, $I10, $P10) = rx1149_cur."!mark_fail"(0)
    lt rx1149_pos, -1, rx1149_done
    eq rx1149_pos, -1, rx1149_fail
    jump $I10
  rx1149_done:
    rx1149_cur."!cursor_fail"()
    if_null rx1149_debug, debug_1036
    rx1149_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1036:
    .return (rx1149_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("221_1303391609.928") :method
.annotate 'line', 10
    $P1151 = self."!PREFIX__!subrule"("name", "")
    new $P1152, "ResizablePMCArray"
    push $P1152, $P1151
    .return ($P1152)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("222_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1157_tgt
    .local int rx1157_pos
    .local int rx1157_off
    .local int rx1157_eos
    .local int rx1157_rep
    .local pmc rx1157_cur
    .local pmc rx1157_debug
    (rx1157_cur, rx1157_pos, rx1157_tgt, $I10) = self."!cursor_start"()
    rx1157_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1157_cur
    .local pmc match
    .lex "$/", match
    length rx1157_eos, rx1157_tgt
    gt rx1157_pos, rx1157_eos, rx1157_done
    set rx1157_off, 0
    lt rx1157_pos, 2, rx1157_start
    sub rx1157_off, rx1157_pos, 1
    substr rx1157_tgt, rx1157_tgt, rx1157_off
  rx1157_start:
    eq $I10, 1, rx1157_restart
    if_null rx1157_debug, debug_1037
    rx1157_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1160_done
    goto rxscan1160_scan
  rxscan1160_loop:
    (rx1157_pos) = rx1157_cur."from"()
    inc rx1157_pos
    rx1157_cur."!cursor_from"(rx1157_pos)
    ge rx1157_pos, rx1157_eos, rxscan1160_done
  rxscan1160_scan:
    set_addr $I10, rxscan1160_loop
    rx1157_cur."!mark_push"(0, rx1157_pos, $I10)
  rxscan1160_done:
.annotate 'line', 527
  # rx literal  "pir::"
    add $I11, rx1157_pos, 5
    gt $I11, rx1157_eos, rx1157_fail
    sub $I11, rx1157_pos, rx1157_off
    substr $S10, rx1157_tgt, $I11, 5
    ne $S10, "pir::", rx1157_fail
    add rx1157_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1161_fail
    rx1157_cur."!mark_push"(0, rx1157_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1157_pos, rx1157_off
    find_not_cclass $I11, 8192, rx1157_tgt, $I10, rx1157_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1157_fail
    add rx1157_pos, rx1157_off, $I11
    set_addr $I10, rxcap_1161_fail
    ($I12, $I11) = rx1157_cur."!mark_peek"($I10)
    rx1157_cur."!cursor_pos"($I11)
    ($P10) = rx1157_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1157_pos, "")
    rx1157_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1161_done
  rxcap_1161_fail:
    goto rx1157_fail
  rxcap_1161_done:
  # rx rxquantr1162 ** 0..1
    set_addr $I10, rxquantr1162_done
    rx1157_cur."!mark_push"(0, rx1157_pos, $I10)
  rxquantr1162_loop:
  # rx subrule "args" subtype=capture negate=
    rx1157_cur."!cursor_pos"(rx1157_pos)
    $P10 = rx1157_cur."args"()
    unless $P10, rx1157_fail
    goto rxsubrule1163_pass
  rxsubrule1163_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1157_fail
  rxsubrule1163_pass:
    set_addr $I10, rxsubrule1163_back
    rx1157_cur."!mark_push"(0, rx1157_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1157_pos = $P10."pos"()
    set_addr $I10, rxquantr1162_done
    (rx1157_rep) = rx1157_cur."!mark_commit"($I10)
  rxquantr1162_done:
.annotate 'line', 526
  # rx pass
    rx1157_cur."!cursor_pass"(rx1157_pos, "term:sym<pir::op>")
    if_null rx1157_debug, debug_1038
    rx1157_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1157_pos)
  debug_1038:
    .return (rx1157_cur)
  rx1157_restart:
.annotate 'line', 10
    if_null rx1157_debug, debug_1039
    rx1157_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1039:
  rx1157_fail:
    (rx1157_rep, rx1157_pos, $I10, $P10) = rx1157_cur."!mark_fail"(0)
    lt rx1157_pos, -1, rx1157_done
    eq rx1157_pos, -1, rx1157_fail
    jump $I10
  rx1157_done:
    rx1157_cur."!cursor_fail"()
    if_null rx1157_debug, debug_1040
    rx1157_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1040:
    .return (rx1157_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("223_1303391609.928") :method
.annotate 'line', 10
    new $P1159, "ResizablePMCArray"
    push $P1159, "pir::"
    .return ($P1159)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("224_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P1173 = "226_1303391609.928" 
    capture_lex $P1173
    .local string rx1165_tgt
    .local int rx1165_pos
    .local int rx1165_off
    .local int rx1165_eos
    .local int rx1165_rep
    .local pmc rx1165_cur
    .local pmc rx1165_debug
    (rx1165_cur, rx1165_pos, rx1165_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1165_cur
    .local pmc match
    .lex "$/", match
    length rx1165_eos, rx1165_tgt
    gt rx1165_pos, rx1165_eos, rx1165_done
    set rx1165_off, 0
    lt rx1165_pos, 2, rx1165_start
    sub rx1165_off, rx1165_pos, 1
    substr rx1165_tgt, rx1165_tgt, rx1165_off
  rx1165_start:
    eq $I10, 1, rx1165_restart
    if_null rx1165_debug, debug_1041
    rx1165_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1168_done
    goto rxscan1168_scan
  rxscan1168_loop:
    (rx1165_pos) = rx1165_cur."from"()
    inc rx1165_pos
    rx1165_cur."!cursor_from"(rx1165_pos)
    ge rx1165_pos, rx1165_eos, rxscan1168_done
  rxscan1168_scan:
    set_addr $I10, rxscan1168_loop
    rx1165_cur."!mark_push"(0, rx1165_pos, $I10)
  rxscan1168_done:
.annotate 'line', 531
  # rx literal  "{*}"
    add $I11, rx1165_pos, 3
    gt $I11, rx1165_eos, rx1165_fail
    sub $I11, rx1165_pos, rx1165_off
    substr $S10, rx1165_tgt, $I11, 3
    ne $S10, "{*}", rx1165_fail
    add rx1165_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1165_cur."!cursor_pos"(rx1165_pos)
    $P10 = rx1165_cur."ENDSTMT"()
    unless $P10, rx1165_fail
  alt1169_0:
.annotate 'line', 532
    set_addr $I10, alt1169_1
    rx1165_cur."!mark_push"(0, rx1165_pos, $I10)
    rx1165_cur."!cursor_pos"(rx1165_pos)
    find_lex $P1170, unicode:"$\x{a2}"
    $P1171 = $P1170."MATCH"()
    store_lex "$/", $P1171
    .const 'Sub' $P1173 = "226_1303391609.928" 
    capture_lex $P1173
    $P1177 = $P1173()
    unless $P1177, rx1165_fail
    goto alt1169_end
  alt1169_1:
  # rx subrule "panic" subtype=method negate=
    rx1165_cur."!cursor_pos"(rx1165_pos)
    $P10 = rx1165_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1165_fail
    rx1165_pos = $P10."pos"()
  alt1169_end:
.annotate 'line', 530
  # rx pass
    rx1165_cur."!cursor_pass"(rx1165_pos, "term:sym<onlystar>")
    if_null rx1165_debug, debug_1044
    rx1165_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1165_pos)
  debug_1044:
    .return (rx1165_cur)
  rx1165_restart:
.annotate 'line', 10
    if_null rx1165_debug, debug_1045
    rx1165_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1045:
  rx1165_fail:
    (rx1165_rep, rx1165_pos, $I10, $P10) = rx1165_cur."!mark_fail"(0)
    lt rx1165_pos, -1, rx1165_done
    eq rx1165_pos, -1, rx1165_fail
    jump $I10
  rx1165_done:
    rx1165_cur."!cursor_fail"()
    if_null rx1165_debug, debug_1046
    rx1165_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1046:
    .return (rx1165_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("225_1303391609.928") :method
.annotate 'line', 10
    new $P1167, "ResizablePMCArray"
    push $P1167, "{*}"
    .return ($P1167)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1172"  :anon :subid("226_1303391609.928") :outer("224_1303391609.928")
.annotate 'line', 532
    find_dynamic_lex $P1174, "$*MULTINESS"
    unless_null $P1174, vivify_1042
    get_hll_global $P1174, "$MULTINESS"
    unless_null $P1174, vivify_1043
    die "Contextual $*MULTINESS not found"
  vivify_1043:
  vivify_1042:
    set $S1175, $P1174
    iseq $I1176, $S1175, "proto"
    .return ($I1176)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("227_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1179_tgt
    .local int rx1179_pos
    .local int rx1179_off
    .local int rx1179_eos
    .local int rx1179_rep
    .local pmc rx1179_cur
    .local pmc rx1179_debug
    (rx1179_cur, rx1179_pos, rx1179_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1179_cur
    .local pmc match
    .lex "$/", match
    length rx1179_eos, rx1179_tgt
    gt rx1179_pos, rx1179_eos, rx1179_done
    set rx1179_off, 0
    lt rx1179_pos, 2, rx1179_start
    sub rx1179_off, rx1179_pos, 1
    substr rx1179_tgt, rx1179_tgt, rx1179_off
  rx1179_start:
    eq $I10, 1, rx1179_restart
    if_null rx1179_debug, debug_1047
    rx1179_cur."!cursor_debug"("START", "args")
  debug_1047:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1183_done
    goto rxscan1183_scan
  rxscan1183_loop:
    (rx1179_pos) = rx1179_cur."from"()
    inc rx1179_pos
    rx1179_cur."!cursor_from"(rx1179_pos)
    ge rx1179_pos, rx1179_eos, rxscan1183_done
  rxscan1183_scan:
    set_addr $I10, rxscan1183_loop
    rx1179_cur."!mark_push"(0, rx1179_pos, $I10)
  rxscan1183_done:
.annotate 'line', 536
  # rx literal  "("
    add $I11, rx1179_pos, 1
    gt $I11, rx1179_eos, rx1179_fail
    sub $I11, rx1179_pos, rx1179_off
    ord $I11, rx1179_tgt, $I11
    ne $I11, 40, rx1179_fail
    add rx1179_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1179_cur."!cursor_pos"(rx1179_pos)
    $P10 = rx1179_cur."arglist"()
    unless $P10, rx1179_fail
    rx1179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1179_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1179_pos, 1
    gt $I11, rx1179_eos, rx1179_fail
    sub $I11, rx1179_pos, rx1179_off
    ord $I11, rx1179_tgt, $I11
    ne $I11, 41, rx1179_fail
    add rx1179_pos, 1
  # rx pass
    rx1179_cur."!cursor_pass"(rx1179_pos, "args")
    if_null rx1179_debug, debug_1048
    rx1179_cur."!cursor_debug"("PASS", "args", " at pos=", rx1179_pos)
  debug_1048:
    .return (rx1179_cur)
  rx1179_restart:
.annotate 'line', 10
    if_null rx1179_debug, debug_1049
    rx1179_cur."!cursor_debug"("NEXT", "args")
  debug_1049:
  rx1179_fail:
    (rx1179_rep, rx1179_pos, $I10, $P10) = rx1179_cur."!mark_fail"(0)
    lt rx1179_pos, -1, rx1179_done
    eq rx1179_pos, -1, rx1179_fail
    jump $I10
  rx1179_done:
    rx1179_cur."!cursor_fail"()
    if_null rx1179_debug, debug_1050
    rx1179_cur."!cursor_debug"("FAIL", "args")
  debug_1050:
    .return (rx1179_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("228_1303391609.928") :method
.annotate 'line', 10
    $P1181 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1182, "ResizablePMCArray"
    push $P1182, $P1181
    .return ($P1182)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("229_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1185_tgt
    .local int rx1185_pos
    .local int rx1185_off
    .local int rx1185_eos
    .local int rx1185_rep
    .local pmc rx1185_cur
    .local pmc rx1185_debug
    (rx1185_cur, rx1185_pos, rx1185_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1185_cur
    .local pmc match
    .lex "$/", match
    length rx1185_eos, rx1185_tgt
    gt rx1185_pos, rx1185_eos, rx1185_done
    set rx1185_off, 0
    lt rx1185_pos, 2, rx1185_start
    sub rx1185_off, rx1185_pos, 1
    substr rx1185_tgt, rx1185_tgt, rx1185_off
  rx1185_start:
    eq $I10, 1, rx1185_restart
    if_null rx1185_debug, debug_1051
    rx1185_cur."!cursor_debug"("START", "arglist")
  debug_1051:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1189_done
    goto rxscan1189_scan
  rxscan1189_loop:
    (rx1185_pos) = rx1185_cur."from"()
    inc rx1185_pos
    rx1185_cur."!cursor_from"(rx1185_pos)
    ge rx1185_pos, rx1185_eos, rxscan1189_done
  rxscan1189_scan:
    set_addr $I10, rxscan1189_loop
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  rxscan1189_done:
.annotate 'line', 540
  # rx subrule "ws" subtype=method negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."ws"()
    unless $P10, rx1185_fail
    rx1185_pos = $P10."pos"()
  alt1190_0:
.annotate 'line', 541
    set_addr $I10, alt1190_1
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
.annotate 'line', 542
  # rx subrule "EXPR" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."EXPR"("f=")
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1185_pos = $P10."pos"()
    goto alt1190_end
  alt1190_1:
  alt1190_end:
.annotate 'line', 539
  # rx pass
    rx1185_cur."!cursor_pass"(rx1185_pos, "arglist")
    if_null rx1185_debug, debug_1052
    rx1185_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1185_pos)
  debug_1052:
    .return (rx1185_cur)
  rx1185_restart:
.annotate 'line', 10
    if_null rx1185_debug, debug_1053
    rx1185_cur."!cursor_debug"("NEXT", "arglist")
  debug_1053:
  rx1185_fail:
    (rx1185_rep, rx1185_pos, $I10, $P10) = rx1185_cur."!mark_fail"(0)
    lt rx1185_pos, -1, rx1185_done
    eq rx1185_pos, -1, rx1185_fail
    jump $I10
  rx1185_done:
    rx1185_cur."!cursor_fail"()
    if_null rx1185_debug, debug_1054
    rx1185_cur."!cursor_debug"("FAIL", "arglist")
  debug_1054:
    .return (rx1185_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("230_1303391609.928") :method
.annotate 'line', 10
    $P1187 = self."!PREFIX__!subrule"("ws", "")
    new $P1188, "ResizablePMCArray"
    push $P1188, $P1187
    .return ($P1188)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("231_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1192_tgt
    .local int rx1192_pos
    .local int rx1192_off
    .local int rx1192_eos
    .local int rx1192_rep
    .local pmc rx1192_cur
    .local pmc rx1192_debug
    (rx1192_cur, rx1192_pos, rx1192_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1192_cur
    .local pmc match
    .lex "$/", match
    length rx1192_eos, rx1192_tgt
    gt rx1192_pos, rx1192_eos, rx1192_done
    set rx1192_off, 0
    lt rx1192_pos, 2, rx1192_start
    sub rx1192_off, rx1192_pos, 1
    substr rx1192_tgt, rx1192_tgt, rx1192_off
  rx1192_start:
    eq $I10, 1, rx1192_restart
    if_null rx1192_debug, debug_1055
    rx1192_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1055:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1196_done
    goto rxscan1196_scan
  rxscan1196_loop:
    (rx1192_pos) = rx1192_cur."from"()
    inc rx1192_pos
    rx1192_cur."!cursor_from"(rx1192_pos)
    ge rx1192_pos, rx1192_eos, rxscan1196_done
  rxscan1196_scan:
    set_addr $I10, rxscan1196_loop
    rx1192_cur."!mark_push"(0, rx1192_pos, $I10)
  rxscan1196_done:
.annotate 'line', 548
  # rx subrule "value" subtype=capture negate=
    rx1192_cur."!cursor_pos"(rx1192_pos)
    $P10 = rx1192_cur."value"()
    unless $P10, rx1192_fail
    rx1192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1192_pos = $P10."pos"()
  # rx pass
    rx1192_cur."!cursor_pass"(rx1192_pos, "term:sym<value>")
    if_null rx1192_debug, debug_1056
    rx1192_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1192_pos)
  debug_1056:
    .return (rx1192_cur)
  rx1192_restart:
.annotate 'line', 10
    if_null rx1192_debug, debug_1057
    rx1192_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1057:
  rx1192_fail:
    (rx1192_rep, rx1192_pos, $I10, $P10) = rx1192_cur."!mark_fail"(0)
    lt rx1192_pos, -1, rx1192_done
    eq rx1192_pos, -1, rx1192_fail
    jump $I10
  rx1192_done:
    rx1192_cur."!cursor_fail"()
    if_null rx1192_debug, debug_1058
    rx1192_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1058:
    .return (rx1192_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("232_1303391609.928") :method
.annotate 'line', 10
    $P1194 = self."!PREFIX__!subrule"("value", "")
    new $P1195, "ResizablePMCArray"
    push $P1195, $P1194
    .return ($P1195)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("233_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1198_tgt
    .local int rx1198_pos
    .local int rx1198_off
    .local int rx1198_eos
    .local int rx1198_rep
    .local pmc rx1198_cur
    .local pmc rx1198_debug
    (rx1198_cur, rx1198_pos, rx1198_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1198_cur
    .local pmc match
    .lex "$/", match
    length rx1198_eos, rx1198_tgt
    gt rx1198_pos, rx1198_eos, rx1198_done
    set rx1198_off, 0
    lt rx1198_pos, 2, rx1198_start
    sub rx1198_off, rx1198_pos, 1
    substr rx1198_tgt, rx1198_tgt, rx1198_off
  rx1198_start:
    eq $I10, 1, rx1198_restart
    if_null rx1198_debug, debug_1059
    rx1198_cur."!cursor_debug"("START", "value")
  debug_1059:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1203_done
    goto rxscan1203_scan
  rxscan1203_loop:
    (rx1198_pos) = rx1198_cur."from"()
    inc rx1198_pos
    rx1198_cur."!cursor_from"(rx1198_pos)
    ge rx1198_pos, rx1198_eos, rxscan1203_done
  rxscan1203_scan:
    set_addr $I10, rxscan1203_loop
    rx1198_cur."!mark_push"(0, rx1198_pos, $I10)
  rxscan1203_done:
  alt1204_0:
.annotate 'line', 550
    set_addr $I10, alt1204_1
    rx1198_cur."!mark_push"(0, rx1198_pos, $I10)
.annotate 'line', 551
  # rx subrule "quote" subtype=capture negate=
    rx1198_cur."!cursor_pos"(rx1198_pos)
    $P10 = rx1198_cur."quote"()
    unless $P10, rx1198_fail
    rx1198_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1198_pos = $P10."pos"()
    goto alt1204_end
  alt1204_1:
.annotate 'line', 552
  # rx subrule "number" subtype=capture negate=
    rx1198_cur."!cursor_pos"(rx1198_pos)
    $P10 = rx1198_cur."number"()
    unless $P10, rx1198_fail
    rx1198_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1198_pos = $P10."pos"()
  alt1204_end:
.annotate 'line', 550
  # rx pass
    rx1198_cur."!cursor_pass"(rx1198_pos, "value")
    if_null rx1198_debug, debug_1060
    rx1198_cur."!cursor_debug"("PASS", "value", " at pos=", rx1198_pos)
  debug_1060:
    .return (rx1198_cur)
  rx1198_restart:
.annotate 'line', 10
    if_null rx1198_debug, debug_1061
    rx1198_cur."!cursor_debug"("NEXT", "value")
  debug_1061:
  rx1198_fail:
    (rx1198_rep, rx1198_pos, $I10, $P10) = rx1198_cur."!mark_fail"(0)
    lt rx1198_pos, -1, rx1198_done
    eq rx1198_pos, -1, rx1198_fail
    jump $I10
  rx1198_done:
    rx1198_cur."!cursor_fail"()
    if_null rx1198_debug, debug_1062
    rx1198_cur."!cursor_debug"("FAIL", "value")
  debug_1062:
    .return (rx1198_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("234_1303391609.928") :method
.annotate 'line', 10
    $P1200 = self."!PREFIX__!subrule"("number", "")
    $P1201 = self."!PREFIX__!subrule"("quote", "")
    new $P1202, "ResizablePMCArray"
    push $P1202, $P1200
    push $P1202, $P1201
    .return ($P1202)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("235_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1206_tgt
    .local int rx1206_pos
    .local int rx1206_off
    .local int rx1206_eos
    .local int rx1206_rep
    .local pmc rx1206_cur
    .local pmc rx1206_debug
    (rx1206_cur, rx1206_pos, rx1206_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1206_cur
    .local pmc match
    .lex "$/", match
    length rx1206_eos, rx1206_tgt
    gt rx1206_pos, rx1206_eos, rx1206_done
    set rx1206_off, 0
    lt rx1206_pos, 2, rx1206_start
    sub rx1206_off, rx1206_pos, 1
    substr rx1206_tgt, rx1206_tgt, rx1206_off
  rx1206_start:
    eq $I10, 1, rx1206_restart
    if_null rx1206_debug, debug_1063
    rx1206_cur."!cursor_debug"("START", "number")
  debug_1063:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1209_done
    goto rxscan1209_scan
  rxscan1209_loop:
    (rx1206_pos) = rx1206_cur."from"()
    inc rx1206_pos
    rx1206_cur."!cursor_from"(rx1206_pos)
    ge rx1206_pos, rx1206_eos, rxscan1209_done
  rxscan1209_scan:
    set_addr $I10, rxscan1209_loop
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
  rxscan1209_done:
.annotate 'line', 556
  # rx subcapture "sign"
    set_addr $I10, rxcap_1211_fail
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1206_pos, rx1206_off
    set rx1206_rep, 0
    sub $I12, rx1206_eos, rx1206_pos
    le $I12, 1, rxenumcharlistq1210_loop
    set $I12, 1
  rxenumcharlistq1210_loop:
    le $I12, 0, rxenumcharlistq1210_done
    substr $S10, rx1206_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1210_done
    inc rx1206_rep
  rxenumcharlistq1210_done:
    add rx1206_pos, rx1206_pos, rx1206_rep
    set_addr $I10, rxcap_1211_fail
    ($I12, $I11) = rx1206_cur."!mark_peek"($I10)
    rx1206_cur."!cursor_pos"($I11)
    ($P10) = rx1206_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1206_pos, "")
    rx1206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1211_done
  rxcap_1211_fail:
    goto rx1206_fail
  rxcap_1211_done:
  alt1212_0:
.annotate 'line', 557
    set_addr $I10, alt1212_1
    rx1206_cur."!mark_push"(0, rx1206_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1206_cur."!cursor_pos"(rx1206_pos)
    $P10 = rx1206_cur."dec_number"()
    unless $P10, rx1206_fail
    rx1206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1206_pos = $P10."pos"()
    goto alt1212_end
  alt1212_1:
  # rx subrule "integer" subtype=capture negate=
    rx1206_cur."!cursor_pos"(rx1206_pos)
    $P10 = rx1206_cur."integer"()
    unless $P10, rx1206_fail
    rx1206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1206_pos = $P10."pos"()
  alt1212_end:
.annotate 'line', 555
  # rx pass
    rx1206_cur."!cursor_pass"(rx1206_pos, "number")
    if_null rx1206_debug, debug_1064
    rx1206_cur."!cursor_debug"("PASS", "number", " at pos=", rx1206_pos)
  debug_1064:
    .return (rx1206_cur)
  rx1206_restart:
.annotate 'line', 10
    if_null rx1206_debug, debug_1065
    rx1206_cur."!cursor_debug"("NEXT", "number")
  debug_1065:
  rx1206_fail:
    (rx1206_rep, rx1206_pos, $I10, $P10) = rx1206_cur."!mark_fail"(0)
    lt rx1206_pos, -1, rx1206_done
    eq rx1206_pos, -1, rx1206_fail
    jump $I10
  rx1206_done:
    rx1206_cur."!cursor_fail"()
    if_null rx1206_debug, debug_1066
    rx1206_cur."!cursor_debug"("FAIL", "number")
  debug_1066:
    .return (rx1206_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("236_1303391609.928") :method
.annotate 'line', 10
    new $P1208, "ResizablePMCArray"
    push $P1208, ""
    .return ($P1208)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("237_1303391609.928")
    .param pmc param_1214
.annotate 'line', 560
    .lex "self", param_1214
    $P1215 = param_1214."!protoregex"("quote")
    .return ($P1215)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("238_1303391609.928")
    .param pmc param_1217
.annotate 'line', 560
    .lex "self", param_1217
    $P1218 = param_1217."!PREFIX__!protoregex"("quote")
    .return ($P1218)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("239_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1220_tgt
    .local int rx1220_pos
    .local int rx1220_off
    .local int rx1220_eos
    .local int rx1220_rep
    .local pmc rx1220_cur
    .local pmc rx1220_debug
    (rx1220_cur, rx1220_pos, rx1220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1220_cur
    .local pmc match
    .lex "$/", match
    length rx1220_eos, rx1220_tgt
    gt rx1220_pos, rx1220_eos, rx1220_done
    set rx1220_off, 0
    lt rx1220_pos, 2, rx1220_start
    sub rx1220_off, rx1220_pos, 1
    substr rx1220_tgt, rx1220_tgt, rx1220_off
  rx1220_start:
    eq $I10, 1, rx1220_restart
    if_null rx1220_debug, debug_1067
    rx1220_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1067:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1223_done
    goto rxscan1223_scan
  rxscan1223_loop:
    (rx1220_pos) = rx1220_cur."from"()
    inc rx1220_pos
    rx1220_cur."!cursor_from"(rx1220_pos)
    ge rx1220_pos, rx1220_eos, rxscan1223_done
  rxscan1223_scan:
    set_addr $I10, rxscan1223_loop
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10)
  rxscan1223_done:
.annotate 'line', 561
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1220_pos, rx1220_off
    substr $S10, rx1220_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1220_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."quote_EXPR"(":q")
    unless $P10, rx1220_fail
    rx1220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1220_pos = $P10."pos"()
  # rx pass
    rx1220_cur."!cursor_pass"(rx1220_pos, "quote:sym<apos>")
    if_null rx1220_debug, debug_1068
    rx1220_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1220_pos)
  debug_1068:
    .return (rx1220_cur)
  rx1220_restart:
.annotate 'line', 10
    if_null rx1220_debug, debug_1069
    rx1220_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1069:
  rx1220_fail:
    (rx1220_rep, rx1220_pos, $I10, $P10) = rx1220_cur."!mark_fail"(0)
    lt rx1220_pos, -1, rx1220_done
    eq rx1220_pos, -1, rx1220_fail
    jump $I10
  rx1220_done:
    rx1220_cur."!cursor_fail"()
    if_null rx1220_debug, debug_1070
    rx1220_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1070:
    .return (rx1220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("240_1303391609.928") :method
.annotate 'line', 10
    new $P1222, "ResizablePMCArray"
    push $P1222, "'"
    .return ($P1222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("241_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1225_tgt
    .local int rx1225_pos
    .local int rx1225_off
    .local int rx1225_eos
    .local int rx1225_rep
    .local pmc rx1225_cur
    .local pmc rx1225_debug
    (rx1225_cur, rx1225_pos, rx1225_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1225_cur
    .local pmc match
    .lex "$/", match
    length rx1225_eos, rx1225_tgt
    gt rx1225_pos, rx1225_eos, rx1225_done
    set rx1225_off, 0
    lt rx1225_pos, 2, rx1225_start
    sub rx1225_off, rx1225_pos, 1
    substr rx1225_tgt, rx1225_tgt, rx1225_off
  rx1225_start:
    eq $I10, 1, rx1225_restart
    if_null rx1225_debug, debug_1071
    rx1225_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1071:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1228_done
    goto rxscan1228_scan
  rxscan1228_loop:
    (rx1225_pos) = rx1225_cur."from"()
    inc rx1225_pos
    rx1225_cur."!cursor_from"(rx1225_pos)
    ge rx1225_pos, rx1225_eos, rxscan1228_done
  rxscan1228_scan:
    set_addr $I10, rxscan1228_loop
    rx1225_cur."!mark_push"(0, rx1225_pos, $I10)
  rxscan1228_done:
.annotate 'line', 562
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1225_pos, rx1225_off
    substr $S10, rx1225_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1225_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1225_cur."!cursor_pos"(rx1225_pos)
    $P10 = rx1225_cur."quote_EXPR"(":qq")
    unless $P10, rx1225_fail
    rx1225_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1225_pos = $P10."pos"()
  # rx pass
    rx1225_cur."!cursor_pass"(rx1225_pos, "quote:sym<dblq>")
    if_null rx1225_debug, debug_1072
    rx1225_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1225_pos)
  debug_1072:
    .return (rx1225_cur)
  rx1225_restart:
.annotate 'line', 10
    if_null rx1225_debug, debug_1073
    rx1225_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1073:
  rx1225_fail:
    (rx1225_rep, rx1225_pos, $I10, $P10) = rx1225_cur."!mark_fail"(0)
    lt rx1225_pos, -1, rx1225_done
    eq rx1225_pos, -1, rx1225_fail
    jump $I10
  rx1225_done:
    rx1225_cur."!cursor_fail"()
    if_null rx1225_debug, debug_1074
    rx1225_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1074:
    .return (rx1225_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("242_1303391609.928") :method
.annotate 'line', 10
    new $P1227, "ResizablePMCArray"
    push $P1227, "\""
    .return ($P1227)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("243_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1230_tgt
    .local int rx1230_pos
    .local int rx1230_off
    .local int rx1230_eos
    .local int rx1230_rep
    .local pmc rx1230_cur
    .local pmc rx1230_debug
    (rx1230_cur, rx1230_pos, rx1230_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1230_cur
    .local pmc match
    .lex "$/", match
    length rx1230_eos, rx1230_tgt
    gt rx1230_pos, rx1230_eos, rx1230_done
    set rx1230_off, 0
    lt rx1230_pos, 2, rx1230_start
    sub rx1230_off, rx1230_pos, 1
    substr rx1230_tgt, rx1230_tgt, rx1230_off
  rx1230_start:
    eq $I10, 1, rx1230_restart
    if_null rx1230_debug, debug_1075
    rx1230_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1075:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1234_done
    goto rxscan1234_scan
  rxscan1234_loop:
    (rx1230_pos) = rx1230_cur."from"()
    inc rx1230_pos
    rx1230_cur."!cursor_from"(rx1230_pos)
    ge rx1230_pos, rx1230_eos, rxscan1234_done
  rxscan1234_scan:
    set_addr $I10, rxscan1234_loop
    rx1230_cur."!mark_push"(0, rx1230_pos, $I10)
  rxscan1234_done:
.annotate 'line', 563
  # rx subcapture "sym"
    set_addr $I10, rxcap_1235_fail
    rx1230_cur."!mark_push"(0, rx1230_pos, $I10)
  # rx literal  "q"
    add $I11, rx1230_pos, 1
    gt $I11, rx1230_eos, rx1230_fail
    sub $I11, rx1230_pos, rx1230_off
    ord $I11, rx1230_tgt, $I11
    ne $I11, 113, rx1230_fail
    add rx1230_pos, 1
    set_addr $I10, rxcap_1235_fail
    ($I12, $I11) = rx1230_cur."!mark_peek"($I10)
    rx1230_cur."!cursor_pos"($I11)
    ($P10) = rx1230_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1230_pos, "")
    rx1230_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1235_done
  rxcap_1235_fail:
    goto rx1230_fail
  rxcap_1235_done:
  # rxanchor rwb
    le rx1230_pos, 0, rx1230_fail
    sub $I10, rx1230_pos, rx1230_off
    is_cclass $I11, 8192, rx1230_tgt, $I10
    if $I11, rx1230_fail
    dec $I10
    is_cclass $I11, 8192, rx1230_tgt, $I10
    unless $I11, rx1230_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1230_pos, rx1230_off
    substr $S10, rx1230_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1230_fail
  # rx subrule "ws" subtype=method negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."ws"()
    unless $P10, rx1230_fail
    rx1230_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."quote_EXPR"(":q")
    unless $P10, rx1230_fail
    rx1230_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1230_pos = $P10."pos"()
  # rx pass
    rx1230_cur."!cursor_pass"(rx1230_pos, "quote:sym<q>")
    if_null rx1230_debug, debug_1076
    rx1230_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1230_pos)
  debug_1076:
    .return (rx1230_cur)
  rx1230_restart:
.annotate 'line', 10
    if_null rx1230_debug, debug_1077
    rx1230_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1077:
  rx1230_fail:
    (rx1230_rep, rx1230_pos, $I10, $P10) = rx1230_cur."!mark_fail"(0)
    lt rx1230_pos, -1, rx1230_done
    eq rx1230_pos, -1, rx1230_fail
    jump $I10
  rx1230_done:
    rx1230_cur."!cursor_fail"()
    if_null rx1230_debug, debug_1078
    rx1230_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1078:
    .return (rx1230_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("244_1303391609.928") :method
.annotate 'line', 10
    $P1232 = self."!PREFIX__!subrule"("ws", "q")
    new $P1233, "ResizablePMCArray"
    push $P1233, $P1232
    .return ($P1233)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("245_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1237_tgt
    .local int rx1237_pos
    .local int rx1237_off
    .local int rx1237_eos
    .local int rx1237_rep
    .local pmc rx1237_cur
    .local pmc rx1237_debug
    (rx1237_cur, rx1237_pos, rx1237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1237_cur
    .local pmc match
    .lex "$/", match
    length rx1237_eos, rx1237_tgt
    gt rx1237_pos, rx1237_eos, rx1237_done
    set rx1237_off, 0
    lt rx1237_pos, 2, rx1237_start
    sub rx1237_off, rx1237_pos, 1
    substr rx1237_tgt, rx1237_tgt, rx1237_off
  rx1237_start:
    eq $I10, 1, rx1237_restart
    if_null rx1237_debug, debug_1079
    rx1237_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1079:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1241_done
    goto rxscan1241_scan
  rxscan1241_loop:
    (rx1237_pos) = rx1237_cur."from"()
    inc rx1237_pos
    rx1237_cur."!cursor_from"(rx1237_pos)
    ge rx1237_pos, rx1237_eos, rxscan1241_done
  rxscan1241_scan:
    set_addr $I10, rxscan1241_loop
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxscan1241_done:
.annotate 'line', 564
  # rx subcapture "sym"
    set_addr $I10, rxcap_1242_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1237_pos, 2
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    substr $S10, rx1237_tgt, $I11, 2
    ne $S10, "qq", rx1237_fail
    add rx1237_pos, 2
    set_addr $I10, rxcap_1242_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1242_done
  rxcap_1242_fail:
    goto rx1237_fail
  rxcap_1242_done:
  # rxanchor rwb
    le rx1237_pos, 0, rx1237_fail
    sub $I10, rx1237_pos, rx1237_off
    is_cclass $I11, 8192, rx1237_tgt, $I10
    if $I11, rx1237_fail
    dec $I10
    is_cclass $I11, 8192, rx1237_tgt, $I10
    unless $I11, rx1237_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1237_pos, rx1237_off
    substr $S10, rx1237_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1237_fail
  # rx subrule "ws" subtype=method negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."ws"()
    unless $P10, rx1237_fail
    rx1237_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."quote_EXPR"(":qq")
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1237_pos = $P10."pos"()
  # rx pass
    rx1237_cur."!cursor_pass"(rx1237_pos, "quote:sym<qq>")
    if_null rx1237_debug, debug_1080
    rx1237_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1237_pos)
  debug_1080:
    .return (rx1237_cur)
  rx1237_restart:
.annotate 'line', 10
    if_null rx1237_debug, debug_1081
    rx1237_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1081:
  rx1237_fail:
    (rx1237_rep, rx1237_pos, $I10, $P10) = rx1237_cur."!mark_fail"(0)
    lt rx1237_pos, -1, rx1237_done
    eq rx1237_pos, -1, rx1237_fail
    jump $I10
  rx1237_done:
    rx1237_cur."!cursor_fail"()
    if_null rx1237_debug, debug_1082
    rx1237_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1082:
    .return (rx1237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("246_1303391609.928") :method
.annotate 'line', 10
    $P1239 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1240, "ResizablePMCArray"
    push $P1240, $P1239
    .return ($P1240)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("247_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1244_tgt
    .local int rx1244_pos
    .local int rx1244_off
    .local int rx1244_eos
    .local int rx1244_rep
    .local pmc rx1244_cur
    .local pmc rx1244_debug
    (rx1244_cur, rx1244_pos, rx1244_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1244_cur
    .local pmc match
    .lex "$/", match
    length rx1244_eos, rx1244_tgt
    gt rx1244_pos, rx1244_eos, rx1244_done
    set rx1244_off, 0
    lt rx1244_pos, 2, rx1244_start
    sub rx1244_off, rx1244_pos, 1
    substr rx1244_tgt, rx1244_tgt, rx1244_off
  rx1244_start:
    eq $I10, 1, rx1244_restart
    if_null rx1244_debug, debug_1083
    rx1244_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1083:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1248_done
    goto rxscan1248_scan
  rxscan1248_loop:
    (rx1244_pos) = rx1244_cur."from"()
    inc rx1244_pos
    rx1244_cur."!cursor_from"(rx1244_pos)
    ge rx1244_pos, rx1244_eos, rxscan1248_done
  rxscan1248_scan:
    set_addr $I10, rxscan1248_loop
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxscan1248_done:
.annotate 'line', 565
  # rx subcapture "sym"
    set_addr $I10, rxcap_1249_fail
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 81, rx1244_fail
    add rx1244_pos, 1
    set_addr $I10, rxcap_1249_fail
    ($I12, $I11) = rx1244_cur."!mark_peek"($I10)
    rx1244_cur."!cursor_pos"($I11)
    ($P10) = rx1244_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1244_pos, "")
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1249_done
  rxcap_1249_fail:
    goto rx1244_fail
  rxcap_1249_done:
  # rxanchor rwb
    le rx1244_pos, 0, rx1244_fail
    sub $I10, rx1244_pos, rx1244_off
    is_cclass $I11, 8192, rx1244_tgt, $I10
    if $I11, rx1244_fail
    dec $I10
    is_cclass $I11, 8192, rx1244_tgt, $I10
    unless $I11, rx1244_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1244_pos, rx1244_off
    substr $S10, rx1244_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1244_fail
  # rx subrule "ws" subtype=method negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."ws"()
    unless $P10, rx1244_fail
    rx1244_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."quote_EXPR"()
    unless $P10, rx1244_fail
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1244_pos = $P10."pos"()
  # rx pass
    rx1244_cur."!cursor_pass"(rx1244_pos, "quote:sym<Q>")
    if_null rx1244_debug, debug_1084
    rx1244_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1244_pos)
  debug_1084:
    .return (rx1244_cur)
  rx1244_restart:
.annotate 'line', 10
    if_null rx1244_debug, debug_1085
    rx1244_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1085:
  rx1244_fail:
    (rx1244_rep, rx1244_pos, $I10, $P10) = rx1244_cur."!mark_fail"(0)
    lt rx1244_pos, -1, rx1244_done
    eq rx1244_pos, -1, rx1244_fail
    jump $I10
  rx1244_done:
    rx1244_cur."!cursor_fail"()
    if_null rx1244_debug, debug_1086
    rx1244_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1086:
    .return (rx1244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("248_1303391609.928") :method
.annotate 'line', 10
    $P1246 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("249_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1251_tgt
    .local int rx1251_pos
    .local int rx1251_off
    .local int rx1251_eos
    .local int rx1251_rep
    .local pmc rx1251_cur
    .local pmc rx1251_debug
    (rx1251_cur, rx1251_pos, rx1251_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1251_cur
    .local pmc match
    .lex "$/", match
    length rx1251_eos, rx1251_tgt
    gt rx1251_pos, rx1251_eos, rx1251_done
    set rx1251_off, 0
    lt rx1251_pos, 2, rx1251_start
    sub rx1251_off, rx1251_pos, 1
    substr rx1251_tgt, rx1251_tgt, rx1251_off
  rx1251_start:
    eq $I10, 1, rx1251_restart
    if_null rx1251_debug, debug_1087
    rx1251_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1087:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1255_done
    goto rxscan1255_scan
  rxscan1255_loop:
    (rx1251_pos) = rx1251_cur."from"()
    inc rx1251_pos
    rx1251_cur."!cursor_from"(rx1251_pos)
    ge rx1251_pos, rx1251_eos, rxscan1255_done
  rxscan1255_scan:
    set_addr $I10, rxscan1255_loop
    rx1251_cur."!mark_push"(0, rx1251_pos, $I10)
  rxscan1255_done:
.annotate 'line', 566
  # rx subcapture "sym"
    set_addr $I10, rxcap_1256_fail
    rx1251_cur."!mark_push"(0, rx1251_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1251_pos, 5
    gt $I11, rx1251_eos, rx1251_fail
    sub $I11, rx1251_pos, rx1251_off
    substr $S10, rx1251_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1251_fail
    add rx1251_pos, 5
    set_addr $I10, rxcap_1256_fail
    ($I12, $I11) = rx1251_cur."!mark_peek"($I10)
    rx1251_cur."!cursor_pos"($I11)
    ($P10) = rx1251_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1251_pos, "")
    rx1251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1256_done
  rxcap_1256_fail:
    goto rx1251_fail
  rxcap_1256_done:
  # rx subrule "ws" subtype=method negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."ws"()
    unless $P10, rx1251_fail
    rx1251_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."quote_EXPR"()
    unless $P10, rx1251_fail
    rx1251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1251_pos = $P10."pos"()
  # rx pass
    rx1251_cur."!cursor_pass"(rx1251_pos, "quote:sym<Q:PIR>")
    if_null rx1251_debug, debug_1088
    rx1251_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1251_pos)
  debug_1088:
    .return (rx1251_cur)
  rx1251_restart:
.annotate 'line', 10
    if_null rx1251_debug, debug_1089
    rx1251_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1089:
  rx1251_fail:
    (rx1251_rep, rx1251_pos, $I10, $P10) = rx1251_cur."!mark_fail"(0)
    lt rx1251_pos, -1, rx1251_done
    eq rx1251_pos, -1, rx1251_fail
    jump $I10
  rx1251_done:
    rx1251_cur."!cursor_fail"()
    if_null rx1251_debug, debug_1090
    rx1251_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1090:
    .return (rx1251_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("250_1303391609.928") :method
.annotate 'line', 10
    $P1253 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1254, "ResizablePMCArray"
    push $P1254, $P1253
    .return ($P1254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("251_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1258_tgt
    .local int rx1258_pos
    .local int rx1258_off
    .local int rx1258_eos
    .local int rx1258_rep
    .local pmc rx1258_cur
    .local pmc rx1258_debug
    (rx1258_cur, rx1258_pos, rx1258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1258_cur
    .local pmc match
    .lex "$/", match
    length rx1258_eos, rx1258_tgt
    gt rx1258_pos, rx1258_eos, rx1258_done
    set rx1258_off, 0
    lt rx1258_pos, 2, rx1258_start
    sub rx1258_off, rx1258_pos, 1
    substr rx1258_tgt, rx1258_tgt, rx1258_off
  rx1258_start:
    eq $I10, 1, rx1258_restart
    if_null rx1258_debug, debug_1091
    rx1258_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1091:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1262_done
    goto rxscan1262_scan
  rxscan1262_loop:
    (rx1258_pos) = rx1258_cur."from"()
    inc rx1258_pos
    rx1258_cur."!cursor_from"(rx1258_pos)
    ge rx1258_pos, rx1258_eos, rxscan1262_done
  rxscan1262_scan:
    set_addr $I10, rxscan1262_loop
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  rxscan1262_done:
.annotate 'line', 568
  # rx literal  "/"
    add $I11, rx1258_pos, 1
    gt $I11, rx1258_eos, rx1258_fail
    sub $I11, rx1258_pos, rx1258_off
    ord $I11, rx1258_tgt, $I11
    ne $I11, 47, rx1258_fail
    add rx1258_pos, 1
.annotate 'line', 569
  # rx subrule "newpad" subtype=method negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."newpad"()
    unless $P10, rx1258_fail
    rx1258_pos = $P10."pos"()
.annotate 'line', 570
  # rx reduce name="quote:sym</ />" key="open"
    rx1258_cur."!cursor_pos"(rx1258_pos)
    rx1258_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 571
  # rx subrule "LANG" subtype=capture negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1258_fail
    rx1258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1258_pos = $P10."pos"()
.annotate 'line', 572
  # rx literal  "/"
    add $I11, rx1258_pos, 1
    gt $I11, rx1258_eos, rx1258_fail
    sub $I11, rx1258_pos, rx1258_off
    ord $I11, rx1258_tgt, $I11
    ne $I11, 47, rx1258_fail
    add rx1258_pos, 1
.annotate 'line', 567
  # rx pass
    rx1258_cur."!cursor_pass"(rx1258_pos, "quote:sym</ />")
    if_null rx1258_debug, debug_1092
    rx1258_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1258_pos)
  debug_1092:
    .return (rx1258_cur)
  rx1258_restart:
.annotate 'line', 10
    if_null rx1258_debug, debug_1093
    rx1258_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1093:
  rx1258_fail:
    (rx1258_rep, rx1258_pos, $I10, $P10) = rx1258_cur."!mark_fail"(0)
    lt rx1258_pos, -1, rx1258_done
    eq rx1258_pos, -1, rx1258_fail
    jump $I10
  rx1258_done:
    rx1258_cur."!cursor_fail"()
    if_null rx1258_debug, debug_1094
    rx1258_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1094:
    .return (rx1258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("252_1303391609.928") :method
.annotate 'line', 10
    $P1260 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1261, "ResizablePMCArray"
    push $P1261, $P1260
    .return ($P1261)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("253_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1264_tgt
    .local int rx1264_pos
    .local int rx1264_off
    .local int rx1264_eos
    .local int rx1264_rep
    .local pmc rx1264_cur
    .local pmc rx1264_debug
    (rx1264_cur, rx1264_pos, rx1264_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1264_cur
    .local pmc match
    .lex "$/", match
    length rx1264_eos, rx1264_tgt
    gt rx1264_pos, rx1264_eos, rx1264_done
    set rx1264_off, 0
    lt rx1264_pos, 2, rx1264_start
    sub rx1264_off, rx1264_pos, 1
    substr rx1264_tgt, rx1264_tgt, rx1264_off
  rx1264_start:
    eq $I10, 1, rx1264_restart
    if_null rx1264_debug, debug_1095
    rx1264_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1095:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1267_done
    goto rxscan1267_scan
  rxscan1267_loop:
    (rx1264_pos) = rx1264_cur."from"()
    inc rx1264_pos
    rx1264_cur."!cursor_from"(rx1264_pos)
    ge rx1264_pos, rx1264_eos, rxscan1267_done
  rxscan1267_scan:
    set_addr $I10, rxscan1267_loop
    rx1264_cur."!mark_push"(0, rx1264_pos, $I10)
  rxscan1267_done:
.annotate 'line', 575
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1264_pos, rx1264_off
    substr $S10, rx1264_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1264_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1264_cur."!cursor_pos"(rx1264_pos)
    $P10 = rx1264_cur."quotemod_check"("s")
    unless $P10, rx1264_fail
  # rx subrule "variable" subtype=capture negate=
    rx1264_cur."!cursor_pos"(rx1264_pos)
    $P10 = rx1264_cur."variable"()
    unless $P10, rx1264_fail
    rx1264_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1264_pos = $P10."pos"()
  # rx pass
    rx1264_cur."!cursor_pass"(rx1264_pos, "quote_escape:sym<$>")
    if_null rx1264_debug, debug_1096
    rx1264_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1264_pos)
  debug_1096:
    .return (rx1264_cur)
  rx1264_restart:
.annotate 'line', 10
    if_null rx1264_debug, debug_1097
    rx1264_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1097:
  rx1264_fail:
    (rx1264_rep, rx1264_pos, $I10, $P10) = rx1264_cur."!mark_fail"(0)
    lt rx1264_pos, -1, rx1264_done
    eq rx1264_pos, -1, rx1264_fail
    jump $I10
  rx1264_done:
    rx1264_cur."!cursor_fail"()
    if_null rx1264_debug, debug_1098
    rx1264_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1098:
    .return (rx1264_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("254_1303391609.928") :method
.annotate 'line', 10
    new $P1266, "ResizablePMCArray"
    push $P1266, "$"
    .return ($P1266)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("255_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1269_tgt
    .local int rx1269_pos
    .local int rx1269_off
    .local int rx1269_eos
    .local int rx1269_rep
    .local pmc rx1269_cur
    .local pmc rx1269_debug
    (rx1269_cur, rx1269_pos, rx1269_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1269_cur
    .local pmc match
    .lex "$/", match
    length rx1269_eos, rx1269_tgt
    gt rx1269_pos, rx1269_eos, rx1269_done
    set rx1269_off, 0
    lt rx1269_pos, 2, rx1269_start
    sub rx1269_off, rx1269_pos, 1
    substr rx1269_tgt, rx1269_tgt, rx1269_off
  rx1269_start:
    eq $I10, 1, rx1269_restart
    if_null rx1269_debug, debug_1099
    rx1269_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1099:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1272_done
    goto rxscan1272_scan
  rxscan1272_loop:
    (rx1269_pos) = rx1269_cur."from"()
    inc rx1269_pos
    rx1269_cur."!cursor_from"(rx1269_pos)
    ge rx1269_pos, rx1269_eos, rxscan1272_done
  rxscan1272_scan:
    set_addr $I10, rxscan1272_loop
    rx1269_cur."!mark_push"(0, rx1269_pos, $I10)
  rxscan1272_done:
.annotate 'line', 576
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1269_pos, rx1269_off
    substr $S10, rx1269_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1269_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."quotemod_check"("c")
    unless $P10, rx1269_fail
  # rx subrule "block" subtype=capture negate=
    rx1269_cur."!cursor_pos"(rx1269_pos)
    $P10 = rx1269_cur."block"()
    unless $P10, rx1269_fail
    rx1269_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1269_pos = $P10."pos"()
  # rx pass
    rx1269_cur."!cursor_pass"(rx1269_pos, "quote_escape:sym<{ }>")
    if_null rx1269_debug, debug_1100
    rx1269_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1269_pos)
  debug_1100:
    .return (rx1269_cur)
  rx1269_restart:
.annotate 'line', 10
    if_null rx1269_debug, debug_1101
    rx1269_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1101:
  rx1269_fail:
    (rx1269_rep, rx1269_pos, $I10, $P10) = rx1269_cur."!mark_fail"(0)
    lt rx1269_pos, -1, rx1269_done
    eq rx1269_pos, -1, rx1269_fail
    jump $I10
  rx1269_done:
    rx1269_cur."!cursor_fail"()
    if_null rx1269_debug, debug_1102
    rx1269_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1102:
    .return (rx1269_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("256_1303391609.928") :method
.annotate 'line', 10
    new $P1271, "ResizablePMCArray"
    push $P1271, "{"
    .return ($P1271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("257_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1274_tgt
    .local int rx1274_pos
    .local int rx1274_off
    .local int rx1274_eos
    .local int rx1274_rep
    .local pmc rx1274_cur
    .local pmc rx1274_debug
    (rx1274_cur, rx1274_pos, rx1274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1274_cur
    .local pmc match
    .lex "$/", match
    length rx1274_eos, rx1274_tgt
    gt rx1274_pos, rx1274_eos, rx1274_done
    set rx1274_off, 0
    lt rx1274_pos, 2, rx1274_start
    sub rx1274_off, rx1274_pos, 1
    substr rx1274_tgt, rx1274_tgt, rx1274_off
  rx1274_start:
    eq $I10, 1, rx1274_restart
    if_null rx1274_debug, debug_1103
    rx1274_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1103:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1277_done
    goto rxscan1277_scan
  rxscan1277_loop:
    (rx1274_pos) = rx1274_cur."from"()
    inc rx1274_pos
    rx1274_cur."!cursor_from"(rx1274_pos)
    ge rx1274_pos, rx1274_eos, rxscan1277_done
  rxscan1277_scan:
    set_addr $I10, rxscan1277_loop
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
  rxscan1277_done:
.annotate 'line', 577
  # rx literal  "\\e"
    add $I11, rx1274_pos, 2
    gt $I11, rx1274_eos, rx1274_fail
    sub $I11, rx1274_pos, rx1274_off
    substr $S10, rx1274_tgt, $I11, 2
    ne $S10, "\\e", rx1274_fail
    add rx1274_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."quotemod_check"("b")
    unless $P10, rx1274_fail
  # rx pass
    rx1274_cur."!cursor_pass"(rx1274_pos, "quote_escape:sym<esc>")
    if_null rx1274_debug, debug_1104
    rx1274_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1274_pos)
  debug_1104:
    .return (rx1274_cur)
  rx1274_restart:
.annotate 'line', 10
    if_null rx1274_debug, debug_1105
    rx1274_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1105:
  rx1274_fail:
    (rx1274_rep, rx1274_pos, $I10, $P10) = rx1274_cur."!mark_fail"(0)
    lt rx1274_pos, -1, rx1274_done
    eq rx1274_pos, -1, rx1274_fail
    jump $I10
  rx1274_done:
    rx1274_cur."!cursor_fail"()
    if_null rx1274_debug, debug_1106
    rx1274_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1106:
    .return (rx1274_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("258_1303391609.928") :method
.annotate 'line', 10
    new $P1276, "ResizablePMCArray"
    push $P1276, "\\e"
    .return ($P1276)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("259_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1279_tgt
    .local int rx1279_pos
    .local int rx1279_off
    .local int rx1279_eos
    .local int rx1279_rep
    .local pmc rx1279_cur
    .local pmc rx1279_debug
    (rx1279_cur, rx1279_pos, rx1279_tgt, $I10) = self."!cursor_start"()
    rx1279_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1279_cur
    .local pmc match
    .lex "$/", match
    length rx1279_eos, rx1279_tgt
    gt rx1279_pos, rx1279_eos, rx1279_done
    set rx1279_off, 0
    lt rx1279_pos, 2, rx1279_start
    sub rx1279_off, rx1279_pos, 1
    substr rx1279_tgt, rx1279_tgt, rx1279_off
  rx1279_start:
    eq $I10, 1, rx1279_restart
    if_null rx1279_debug, debug_1107
    rx1279_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1107:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1283_done
    goto rxscan1283_scan
  rxscan1283_loop:
    (rx1279_pos) = rx1279_cur."from"()
    inc rx1279_pos
    rx1279_cur."!cursor_from"(rx1279_pos)
    ge rx1279_pos, rx1279_eos, rxscan1283_done
  rxscan1283_scan:
    set_addr $I10, rxscan1283_loop
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  rxscan1283_done:
.annotate 'line', 579
  # rx literal  "("
    add $I11, rx1279_pos, 1
    gt $I11, rx1279_eos, rx1279_fail
    sub $I11, rx1279_pos, rx1279_off
    ord $I11, rx1279_tgt, $I11
    ne $I11, 40, rx1279_fail
    add rx1279_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."ws"()
    unless $P10, rx1279_fail
    rx1279_pos = $P10."pos"()
  # rx rxquantr1284 ** 0..1
    set_addr $I10, rxquantr1284_done
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  rxquantr1284_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."EXPR"()
    unless $P10, rx1279_fail
    goto rxsubrule1285_pass
  rxsubrule1285_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1279_fail
  rxsubrule1285_pass:
    set_addr $I10, rxsubrule1285_back
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1279_pos = $P10."pos"()
    set_addr $I10, rxquantr1284_done
    (rx1279_rep) = rx1279_cur."!mark_commit"($I10)
  rxquantr1284_done:
  # rx literal  ")"
    add $I11, rx1279_pos, 1
    gt $I11, rx1279_eos, rx1279_fail
    sub $I11, rx1279_pos, rx1279_off
    ord $I11, rx1279_tgt, $I11
    ne $I11, 41, rx1279_fail
    add rx1279_pos, 1
  # rx pass
    rx1279_cur."!cursor_pass"(rx1279_pos, "circumfix:sym<( )>")
    if_null rx1279_debug, debug_1108
    rx1279_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1279_pos)
  debug_1108:
    .return (rx1279_cur)
  rx1279_restart:
.annotate 'line', 10
    if_null rx1279_debug, debug_1109
    rx1279_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1109:
  rx1279_fail:
    (rx1279_rep, rx1279_pos, $I10, $P10) = rx1279_cur."!mark_fail"(0)
    lt rx1279_pos, -1, rx1279_done
    eq rx1279_pos, -1, rx1279_fail
    jump $I10
  rx1279_done:
    rx1279_cur."!cursor_fail"()
    if_null rx1279_debug, debug_1110
    rx1279_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1110:
    .return (rx1279_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("260_1303391609.928") :method
.annotate 'line', 10
    $P1281 = self."!PREFIX__!subrule"("ws", "(")
    new $P1282, "ResizablePMCArray"
    push $P1282, $P1281
    .return ($P1282)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("261_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1287_tgt
    .local int rx1287_pos
    .local int rx1287_off
    .local int rx1287_eos
    .local int rx1287_rep
    .local pmc rx1287_cur
    .local pmc rx1287_debug
    (rx1287_cur, rx1287_pos, rx1287_tgt, $I10) = self."!cursor_start"()
    rx1287_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1287_cur
    .local pmc match
    .lex "$/", match
    length rx1287_eos, rx1287_tgt
    gt rx1287_pos, rx1287_eos, rx1287_done
    set rx1287_off, 0
    lt rx1287_pos, 2, rx1287_start
    sub rx1287_off, rx1287_pos, 1
    substr rx1287_tgt, rx1287_tgt, rx1287_off
  rx1287_start:
    eq $I10, 1, rx1287_restart
    if_null rx1287_debug, debug_1111
    rx1287_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1111:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1291_done
    goto rxscan1291_scan
  rxscan1291_loop:
    (rx1287_pos) = rx1287_cur."from"()
    inc rx1287_pos
    rx1287_cur."!cursor_from"(rx1287_pos)
    ge rx1287_pos, rx1287_eos, rxscan1291_done
  rxscan1291_scan:
    set_addr $I10, rxscan1291_loop
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  rxscan1291_done:
.annotate 'line', 580
  # rx literal  "["
    add $I11, rx1287_pos, 1
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    ord $I11, rx1287_tgt, $I11
    ne $I11, 91, rx1287_fail
    add rx1287_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."ws"()
    unless $P10, rx1287_fail
    rx1287_pos = $P10."pos"()
  # rx rxquantr1292 ** 0..1
    set_addr $I10, rxquantr1292_done
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10)
  rxquantr1292_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1287_cur."!cursor_pos"(rx1287_pos)
    $P10 = rx1287_cur."EXPR"()
    unless $P10, rx1287_fail
    goto rxsubrule1293_pass
  rxsubrule1293_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1287_fail
  rxsubrule1293_pass:
    set_addr $I10, rxsubrule1293_back
    rx1287_cur."!mark_push"(0, rx1287_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1287_pos = $P10."pos"()
    set_addr $I10, rxquantr1292_done
    (rx1287_rep) = rx1287_cur."!mark_commit"($I10)
  rxquantr1292_done:
  # rx literal  "]"
    add $I11, rx1287_pos, 1
    gt $I11, rx1287_eos, rx1287_fail
    sub $I11, rx1287_pos, rx1287_off
    ord $I11, rx1287_tgt, $I11
    ne $I11, 93, rx1287_fail
    add rx1287_pos, 1
  # rx pass
    rx1287_cur."!cursor_pass"(rx1287_pos, "circumfix:sym<[ ]>")
    if_null rx1287_debug, debug_1112
    rx1287_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1287_pos)
  debug_1112:
    .return (rx1287_cur)
  rx1287_restart:
.annotate 'line', 10
    if_null rx1287_debug, debug_1113
    rx1287_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1113:
  rx1287_fail:
    (rx1287_rep, rx1287_pos, $I10, $P10) = rx1287_cur."!mark_fail"(0)
    lt rx1287_pos, -1, rx1287_done
    eq rx1287_pos, -1, rx1287_fail
    jump $I10
  rx1287_done:
    rx1287_cur."!cursor_fail"()
    if_null rx1287_debug, debug_1114
    rx1287_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1114:
    .return (rx1287_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("262_1303391609.928") :method
.annotate 'line', 10
    $P1289 = self."!PREFIX__!subrule"("ws", "[")
    new $P1290, "ResizablePMCArray"
    push $P1290, $P1289
    .return ($P1290)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("263_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1295_tgt
    .local int rx1295_pos
    .local int rx1295_off
    .local int rx1295_eos
    .local int rx1295_rep
    .local pmc rx1295_cur
    .local pmc rx1295_debug
    (rx1295_cur, rx1295_pos, rx1295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1295_cur
    .local pmc match
    .lex "$/", match
    length rx1295_eos, rx1295_tgt
    gt rx1295_pos, rx1295_eos, rx1295_done
    set rx1295_off, 0
    lt rx1295_pos, 2, rx1295_start
    sub rx1295_off, rx1295_pos, 1
    substr rx1295_tgt, rx1295_tgt, rx1295_off
  rx1295_start:
    eq $I10, 1, rx1295_restart
    if_null rx1295_debug, debug_1115
    rx1295_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1115:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1298_done
    goto rxscan1298_scan
  rxscan1298_loop:
    (rx1295_pos) = rx1295_cur."from"()
    inc rx1295_pos
    rx1295_cur."!cursor_from"(rx1295_pos)
    ge rx1295_pos, rx1295_eos, rxscan1298_done
  rxscan1298_scan:
    set_addr $I10, rxscan1298_loop
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  rxscan1298_done:
.annotate 'line', 581
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1295_pos, rx1295_off
    substr $S10, rx1295_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1295_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1295_fail
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1295_pos = $P10."pos"()
  # rx pass
    rx1295_cur."!cursor_pass"(rx1295_pos, "circumfix:sym<ang>")
    if_null rx1295_debug, debug_1116
    rx1295_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1295_pos)
  debug_1116:
    .return (rx1295_cur)
  rx1295_restart:
.annotate 'line', 10
    if_null rx1295_debug, debug_1117
    rx1295_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1117:
  rx1295_fail:
    (rx1295_rep, rx1295_pos, $I10, $P10) = rx1295_cur."!mark_fail"(0)
    lt rx1295_pos, -1, rx1295_done
    eq rx1295_pos, -1, rx1295_fail
    jump $I10
  rx1295_done:
    rx1295_cur."!cursor_fail"()
    if_null rx1295_debug, debug_1118
    rx1295_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1118:
    .return (rx1295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("264_1303391609.928") :method
.annotate 'line', 10
    new $P1297, "ResizablePMCArray"
    push $P1297, "<"
    .return ($P1297)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("265_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1300_tgt
    .local int rx1300_pos
    .local int rx1300_off
    .local int rx1300_eos
    .local int rx1300_rep
    .local pmc rx1300_cur
    .local pmc rx1300_debug
    (rx1300_cur, rx1300_pos, rx1300_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1300_cur
    .local pmc match
    .lex "$/", match
    length rx1300_eos, rx1300_tgt
    gt rx1300_pos, rx1300_eos, rx1300_done
    set rx1300_off, 0
    lt rx1300_pos, 2, rx1300_start
    sub rx1300_off, rx1300_pos, 1
    substr rx1300_tgt, rx1300_tgt, rx1300_off
  rx1300_start:
    eq $I10, 1, rx1300_restart
    if_null rx1300_debug, debug_1119
    rx1300_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1119:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1303_done
    goto rxscan1303_scan
  rxscan1303_loop:
    (rx1300_pos) = rx1300_cur."from"()
    inc rx1300_pos
    rx1300_cur."!cursor_from"(rx1300_pos)
    ge rx1300_pos, rx1300_eos, rxscan1303_done
  rxscan1303_scan:
    set_addr $I10, rxscan1303_loop
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  rxscan1303_done:
.annotate 'line', 582
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1300_pos, rx1300_off
    substr $S10, rx1300_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1300_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1300_fail
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1300_pos = $P10."pos"()
  # rx pass
    rx1300_cur."!cursor_pass"(rx1300_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1300_debug, debug_1120
    rx1300_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1300_pos)
  debug_1120:
    .return (rx1300_cur)
  rx1300_restart:
.annotate 'line', 10
    if_null rx1300_debug, debug_1121
    rx1300_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1121:
  rx1300_fail:
    (rx1300_rep, rx1300_pos, $I10, $P10) = rx1300_cur."!mark_fail"(0)
    lt rx1300_pos, -1, rx1300_done
    eq rx1300_pos, -1, rx1300_fail
    jump $I10
  rx1300_done:
    rx1300_cur."!cursor_fail"()
    if_null rx1300_debug, debug_1122
    rx1300_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1122:
    .return (rx1300_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("266_1303391609.928") :method
.annotate 'line', 10
    new $P1302, "ResizablePMCArray"
    push $P1302, unicode:"\x{ab}"
    .return ($P1302)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("267_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1305_tgt
    .local int rx1305_pos
    .local int rx1305_off
    .local int rx1305_eos
    .local int rx1305_rep
    .local pmc rx1305_cur
    .local pmc rx1305_debug
    (rx1305_cur, rx1305_pos, rx1305_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1305_cur
    .local pmc match
    .lex "$/", match
    length rx1305_eos, rx1305_tgt
    gt rx1305_pos, rx1305_eos, rx1305_done
    set rx1305_off, 0
    lt rx1305_pos, 2, rx1305_start
    sub rx1305_off, rx1305_pos, 1
    substr rx1305_tgt, rx1305_tgt, rx1305_off
  rx1305_start:
    eq $I10, 1, rx1305_restart
    if_null rx1305_debug, debug_1123
    rx1305_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1123:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1308_done
    goto rxscan1308_scan
  rxscan1308_loop:
    (rx1305_pos) = rx1305_cur."from"()
    inc rx1305_pos
    rx1305_cur."!cursor_from"(rx1305_pos)
    ge rx1305_pos, rx1305_eos, rxscan1308_done
  rxscan1308_scan:
    set_addr $I10, rxscan1308_loop
    rx1305_cur."!mark_push"(0, rx1305_pos, $I10)
  rxscan1308_done:
.annotate 'line', 583
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1305_pos, rx1305_off
    substr $S10, rx1305_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1305_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1305_cur."!cursor_pos"(rx1305_pos)
    $P10 = rx1305_cur."pblock"()
    unless $P10, rx1305_fail
    rx1305_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1305_pos = $P10."pos"()
  # rx pass
    rx1305_cur."!cursor_pass"(rx1305_pos, "circumfix:sym<{ }>")
    if_null rx1305_debug, debug_1124
    rx1305_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1305_pos)
  debug_1124:
    .return (rx1305_cur)
  rx1305_restart:
.annotate 'line', 10
    if_null rx1305_debug, debug_1125
    rx1305_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1125:
  rx1305_fail:
    (rx1305_rep, rx1305_pos, $I10, $P10) = rx1305_cur."!mark_fail"(0)
    lt rx1305_pos, -1, rx1305_done
    eq rx1305_pos, -1, rx1305_fail
    jump $I10
  rx1305_done:
    rx1305_cur."!cursor_fail"()
    if_null rx1305_debug, debug_1126
    rx1305_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1126:
    .return (rx1305_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("268_1303391609.928") :method
.annotate 'line', 10
    new $P1307, "ResizablePMCArray"
    push $P1307, "{"
    .return ($P1307)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("269_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1310_tgt
    .local int rx1310_pos
    .local int rx1310_off
    .local int rx1310_eos
    .local int rx1310_rep
    .local pmc rx1310_cur
    .local pmc rx1310_debug
    (rx1310_cur, rx1310_pos, rx1310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1310_cur
    .local pmc match
    .lex "$/", match
    length rx1310_eos, rx1310_tgt
    gt rx1310_pos, rx1310_eos, rx1310_done
    set rx1310_off, 0
    lt rx1310_pos, 2, rx1310_start
    sub rx1310_off, rx1310_pos, 1
    substr rx1310_tgt, rx1310_tgt, rx1310_off
  rx1310_start:
    eq $I10, 1, rx1310_restart
    if_null rx1310_debug, debug_1127
    rx1310_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1127:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1314_done
    goto rxscan1314_scan
  rxscan1314_loop:
    (rx1310_pos) = rx1310_cur."from"()
    inc rx1310_pos
    rx1310_cur."!cursor_from"(rx1310_pos)
    ge rx1310_pos, rx1310_eos, rxscan1314_done
  rxscan1314_scan:
    set_addr $I10, rxscan1314_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  rxscan1314_done:
.annotate 'line', 584
  # rx subrule "sigil" subtype=capture negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."sigil"()
    unless $P10, rx1310_fail
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1310_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1310_pos, 1
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    ord $I11, rx1310_tgt, $I11
    ne $I11, 40, rx1310_fail
    add rx1310_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."semilist"()
    unless $P10, rx1310_fail
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1310_pos = $P10."pos"()
  alt1315_0:
    set_addr $I10, alt1315_1
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  # rx literal  ")"
    add $I11, rx1310_pos, 1
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    ord $I11, rx1310_tgt, $I11
    ne $I11, 41, rx1310_fail
    add rx1310_pos, 1
    goto alt1315_end
  alt1315_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."FAILGOAL"("')'")
    unless $P10, rx1310_fail
    goto rxsubrule1317_pass
  rxsubrule1317_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1310_fail
  rxsubrule1317_pass:
    set_addr $I10, rxsubrule1317_back
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10, $P10)
    rx1310_pos = $P10."pos"()
  alt1315_end:
  # rx pass
    rx1310_cur."!cursor_pass"(rx1310_pos, "circumfix:sym<sigil>")
    if_null rx1310_debug, debug_1128
    rx1310_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1310_pos)
  debug_1128:
    .return (rx1310_cur)
  rx1310_restart:
.annotate 'line', 10
    if_null rx1310_debug, debug_1129
    rx1310_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1129:
  rx1310_fail:
    (rx1310_rep, rx1310_pos, $I10, $P10) = rx1310_cur."!mark_fail"(0)
    lt rx1310_pos, -1, rx1310_done
    eq rx1310_pos, -1, rx1310_fail
    jump $I10
  rx1310_done:
    rx1310_cur."!cursor_fail"()
    if_null rx1310_debug, debug_1130
    rx1310_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1130:
    .return (rx1310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("270_1303391609.928") :method
.annotate 'line', 10
    $P1312 = self."!PREFIX__!subrule"("sigil", "")
    new $P1313, "ResizablePMCArray"
    push $P1313, $P1312
    .return ($P1313)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("271_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1319_tgt
    .local int rx1319_pos
    .local int rx1319_off
    .local int rx1319_eos
    .local int rx1319_rep
    .local pmc rx1319_cur
    .local pmc rx1319_debug
    (rx1319_cur, rx1319_pos, rx1319_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1319_cur
    .local pmc match
    .lex "$/", match
    length rx1319_eos, rx1319_tgt
    gt rx1319_pos, rx1319_eos, rx1319_done
    set rx1319_off, 0
    lt rx1319_pos, 2, rx1319_start
    sub rx1319_off, rx1319_pos, 1
    substr rx1319_tgt, rx1319_tgt, rx1319_off
  rx1319_start:
    eq $I10, 1, rx1319_restart
    if_null rx1319_debug, debug_1131
    rx1319_cur."!cursor_debug"("START", "semilist")
  debug_1131:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1323_done
    goto rxscan1323_scan
  rxscan1323_loop:
    (rx1319_pos) = rx1319_cur."from"()
    inc rx1319_pos
    rx1319_cur."!cursor_from"(rx1319_pos)
    ge rx1319_pos, rx1319_eos, rxscan1323_done
  rxscan1323_scan:
    set_addr $I10, rxscan1323_loop
    rx1319_cur."!mark_push"(0, rx1319_pos, $I10)
  rxscan1323_done:
.annotate 'line', 586
  # rx subrule "ws" subtype=method negate=
    rx1319_cur."!cursor_pos"(rx1319_pos)
    $P10 = rx1319_cur."ws"()
    unless $P10, rx1319_fail
    rx1319_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1319_cur."!cursor_pos"(rx1319_pos)
    $P10 = rx1319_cur."statement"()
    unless $P10, rx1319_fail
    rx1319_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1319_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1319_cur."!cursor_pos"(rx1319_pos)
    $P10 = rx1319_cur."ws"()
    unless $P10, rx1319_fail
    rx1319_pos = $P10."pos"()
  # rx pass
    rx1319_cur."!cursor_pass"(rx1319_pos, "semilist")
    if_null rx1319_debug, debug_1132
    rx1319_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1319_pos)
  debug_1132:
    .return (rx1319_cur)
  rx1319_restart:
.annotate 'line', 10
    if_null rx1319_debug, debug_1133
    rx1319_cur."!cursor_debug"("NEXT", "semilist")
  debug_1133:
  rx1319_fail:
    (rx1319_rep, rx1319_pos, $I10, $P10) = rx1319_cur."!mark_fail"(0)
    lt rx1319_pos, -1, rx1319_done
    eq rx1319_pos, -1, rx1319_fail
    jump $I10
  rx1319_done:
    rx1319_cur."!cursor_fail"()
    if_null rx1319_debug, debug_1134
    rx1319_cur."!cursor_debug"("FAIL", "semilist")
  debug_1134:
    .return (rx1319_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("272_1303391609.928") :method
.annotate 'line', 10
    $P1321 = self."!PREFIX__!subrule"("ws", "")
    new $P1322, "ResizablePMCArray"
    push $P1322, $P1321
    .return ($P1322)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("273_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1327_tgt
    .local int rx1327_pos
    .local int rx1327_off
    .local int rx1327_eos
    .local int rx1327_rep
    .local pmc rx1327_cur
    .local pmc rx1327_debug
    (rx1327_cur, rx1327_pos, rx1327_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1327_cur
    .local pmc match
    .lex "$/", match
    length rx1327_eos, rx1327_tgt
    gt rx1327_pos, rx1327_eos, rx1327_done
    set rx1327_off, 0
    lt rx1327_pos, 2, rx1327_start
    sub rx1327_off, rx1327_pos, 1
    substr rx1327_tgt, rx1327_tgt, rx1327_off
  rx1327_start:
    eq $I10, 1, rx1327_restart
    if_null rx1327_debug, debug_1135
    rx1327_cur."!cursor_debug"("START", "infixish")
  debug_1135:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1330_done
    goto rxscan1330_scan
  rxscan1330_loop:
    (rx1327_pos) = rx1327_cur."from"()
    inc rx1327_pos
    rx1327_cur."!cursor_from"(rx1327_pos)
    ge rx1327_pos, rx1327_eos, rxscan1330_done
  rxscan1330_scan:
    set_addr $I10, rxscan1330_loop
    rx1327_cur."!mark_push"(0, rx1327_pos, $I10)
  rxscan1330_done:
.annotate 'line', 609
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1327_cur."!cursor_pos"(rx1327_pos)
    $P10 = rx1327_cur."infixstopper"()
    if $P10, rx1327_fail
  # rx subrule "infix" subtype=capture negate=
    rx1327_cur."!cursor_pos"(rx1327_pos)
    $P10 = rx1327_cur."infix"()
    unless $P10, rx1327_fail
    rx1327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1327_pos = $P10."pos"()
  # rx pass
    rx1327_cur."!cursor_pass"(rx1327_pos, "infixish")
    if_null rx1327_debug, debug_1136
    rx1327_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1327_pos)
  debug_1136:
    .return (rx1327_cur)
  rx1327_restart:
.annotate 'line', 10
    if_null rx1327_debug, debug_1137
    rx1327_cur."!cursor_debug"("NEXT", "infixish")
  debug_1137:
  rx1327_fail:
    (rx1327_rep, rx1327_pos, $I10, $P10) = rx1327_cur."!mark_fail"(0)
    lt rx1327_pos, -1, rx1327_done
    eq rx1327_pos, -1, rx1327_fail
    jump $I10
  rx1327_done:
    rx1327_cur."!cursor_fail"()
    if_null rx1327_debug, debug_1138
    rx1327_cur."!cursor_debug"("FAIL", "infixish")
  debug_1138:
    .return (rx1327_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("274_1303391609.928") :method
.annotate 'line', 10
    new $P1329, "ResizablePMCArray"
    push $P1329, ""
    .return ($P1329)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("275_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1332_tgt
    .local int rx1332_pos
    .local int rx1332_off
    .local int rx1332_eos
    .local int rx1332_rep
    .local pmc rx1332_cur
    .local pmc rx1332_debug
    (rx1332_cur, rx1332_pos, rx1332_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1332_cur
    .local pmc match
    .lex "$/", match
    length rx1332_eos, rx1332_tgt
    gt rx1332_pos, rx1332_eos, rx1332_done
    set rx1332_off, 0
    lt rx1332_pos, 2, rx1332_start
    sub rx1332_off, rx1332_pos, 1
    substr rx1332_tgt, rx1332_tgt, rx1332_off
  rx1332_start:
    eq $I10, 1, rx1332_restart
    if_null rx1332_debug, debug_1139
    rx1332_cur."!cursor_debug"("START", "infixstopper")
  debug_1139:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1335_done
    goto rxscan1335_scan
  rxscan1335_loop:
    (rx1332_pos) = rx1332_cur."from"()
    inc rx1332_pos
    rx1332_cur."!cursor_from"(rx1332_pos)
    ge rx1332_pos, rx1332_eos, rxscan1335_done
  rxscan1335_scan:
    set_addr $I10, rxscan1335_loop
    rx1332_cur."!mark_push"(0, rx1332_pos, $I10)
  rxscan1335_done:
.annotate 'line', 610
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1332_cur."!cursor_pos"(rx1332_pos)
    $P10 = rx1332_cur."lambda"()
    unless $P10, rx1332_fail
  # rx pass
    rx1332_cur."!cursor_pass"(rx1332_pos, "infixstopper")
    if_null rx1332_debug, debug_1140
    rx1332_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1332_pos)
  debug_1140:
    .return (rx1332_cur)
  rx1332_restart:
.annotate 'line', 10
    if_null rx1332_debug, debug_1141
    rx1332_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1141:
  rx1332_fail:
    (rx1332_rep, rx1332_pos, $I10, $P10) = rx1332_cur."!mark_fail"(0)
    lt rx1332_pos, -1, rx1332_done
    eq rx1332_pos, -1, rx1332_fail
    jump $I10
  rx1332_done:
    rx1332_cur."!cursor_fail"()
    if_null rx1332_debug, debug_1142
    rx1332_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1142:
    .return (rx1332_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("276_1303391609.928") :method
.annotate 'line', 10
    new $P1334, "ResizablePMCArray"
    push $P1334, ""
    .return ($P1334)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("277_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1337_tgt
    .local int rx1337_pos
    .local int rx1337_off
    .local int rx1337_eos
    .local int rx1337_rep
    .local pmc rx1337_cur
    .local pmc rx1337_debug
    (rx1337_cur, rx1337_pos, rx1337_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1337_cur
    .local pmc match
    .lex "$/", match
    length rx1337_eos, rx1337_tgt
    gt rx1337_pos, rx1337_eos, rx1337_done
    set rx1337_off, 0
    lt rx1337_pos, 2, rx1337_start
    sub rx1337_off, rx1337_pos, 1
    substr rx1337_tgt, rx1337_tgt, rx1337_off
  rx1337_start:
    eq $I10, 1, rx1337_restart
    if_null rx1337_debug, debug_1143
    rx1337_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1143:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1341_done
    goto rxscan1341_scan
  rxscan1341_loop:
    (rx1337_pos) = rx1337_cur."from"()
    inc rx1337_pos
    rx1337_cur."!cursor_from"(rx1337_pos)
    ge rx1337_pos, rx1337_eos, rxscan1341_done
  rxscan1341_scan:
    set_addr $I10, rxscan1341_loop
    rx1337_cur."!mark_push"(0, rx1337_pos, $I10)
  rxscan1341_done:
.annotate 'line', 613
  # rx literal  "["
    add $I11, rx1337_pos, 1
    gt $I11, rx1337_eos, rx1337_fail
    sub $I11, rx1337_pos, rx1337_off
    ord $I11, rx1337_tgt, $I11
    ne $I11, 91, rx1337_fail
    add rx1337_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1337_cur."!cursor_pos"(rx1337_pos)
    $P10 = rx1337_cur."ws"()
    unless $P10, rx1337_fail
    rx1337_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1337_cur."!cursor_pos"(rx1337_pos)
    $P10 = rx1337_cur."EXPR"()
    unless $P10, rx1337_fail
    rx1337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1337_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1337_pos, 1
    gt $I11, rx1337_eos, rx1337_fail
    sub $I11, rx1337_pos, rx1337_off
    ord $I11, rx1337_tgt, $I11
    ne $I11, 93, rx1337_fail
    add rx1337_pos, 1
.annotate 'line', 614
  # rx subrule "O" subtype=capture negate=
    rx1337_cur."!cursor_pos"(rx1337_pos)
    $P10 = rx1337_cur."O"("%methodop")
    unless $P10, rx1337_fail
    rx1337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1337_pos = $P10."pos"()
.annotate 'line', 612
  # rx pass
    rx1337_cur."!cursor_pass"(rx1337_pos, "postcircumfix:sym<[ ]>")
    if_null rx1337_debug, debug_1144
    rx1337_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1337_pos)
  debug_1144:
    .return (rx1337_cur)
  rx1337_restart:
.annotate 'line', 10
    if_null rx1337_debug, debug_1145
    rx1337_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1145:
  rx1337_fail:
    (rx1337_rep, rx1337_pos, $I10, $P10) = rx1337_cur."!mark_fail"(0)
    lt rx1337_pos, -1, rx1337_done
    eq rx1337_pos, -1, rx1337_fail
    jump $I10
  rx1337_done:
    rx1337_cur."!cursor_fail"()
    if_null rx1337_debug, debug_1146
    rx1337_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1146:
    .return (rx1337_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("278_1303391609.928") :method
.annotate 'line', 10
    $P1339 = self."!PREFIX__!subrule"("ws", "[")
    new $P1340, "ResizablePMCArray"
    push $P1340, $P1339
    .return ($P1340)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("279_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1343_tgt
    .local int rx1343_pos
    .local int rx1343_off
    .local int rx1343_eos
    .local int rx1343_rep
    .local pmc rx1343_cur
    .local pmc rx1343_debug
    (rx1343_cur, rx1343_pos, rx1343_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1343_cur
    .local pmc match
    .lex "$/", match
    length rx1343_eos, rx1343_tgt
    gt rx1343_pos, rx1343_eos, rx1343_done
    set rx1343_off, 0
    lt rx1343_pos, 2, rx1343_start
    sub rx1343_off, rx1343_pos, 1
    substr rx1343_tgt, rx1343_tgt, rx1343_off
  rx1343_start:
    eq $I10, 1, rx1343_restart
    if_null rx1343_debug, debug_1147
    rx1343_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1147:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1343_pos) = rx1343_cur."from"()
    inc rx1343_pos
    rx1343_cur."!cursor_from"(rx1343_pos)
    ge rx1343_pos, rx1343_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxscan1347_done:
.annotate 'line', 618
  # rx literal  "{"
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 123, rx1343_fail
    add rx1343_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."ws"()
    unless $P10, rx1343_fail
    rx1343_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."EXPR"()
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1343_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 125, rx1343_fail
    add rx1343_pos, 1
.annotate 'line', 619
  # rx subrule "O" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."O"("%methodop")
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1343_pos = $P10."pos"()
.annotate 'line', 617
  # rx pass
    rx1343_cur."!cursor_pass"(rx1343_pos, "postcircumfix:sym<{ }>")
    if_null rx1343_debug, debug_1148
    rx1343_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1343_pos)
  debug_1148:
    .return (rx1343_cur)
  rx1343_restart:
.annotate 'line', 10
    if_null rx1343_debug, debug_1149
    rx1343_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1149:
  rx1343_fail:
    (rx1343_rep, rx1343_pos, $I10, $P10) = rx1343_cur."!mark_fail"(0)
    lt rx1343_pos, -1, rx1343_done
    eq rx1343_pos, -1, rx1343_fail
    jump $I10
  rx1343_done:
    rx1343_cur."!cursor_fail"()
    if_null rx1343_debug, debug_1150
    rx1343_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1150:
    .return (rx1343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("280_1303391609.928") :method
.annotate 'line', 10
    $P1345 = self."!PREFIX__!subrule"("ws", "{")
    new $P1346, "ResizablePMCArray"
    push $P1346, $P1345
    .return ($P1346)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("281_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1349_tgt
    .local int rx1349_pos
    .local int rx1349_off
    .local int rx1349_eos
    .local int rx1349_rep
    .local pmc rx1349_cur
    .local pmc rx1349_debug
    (rx1349_cur, rx1349_pos, rx1349_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1349_cur
    .local pmc match
    .lex "$/", match
    length rx1349_eos, rx1349_tgt
    gt rx1349_pos, rx1349_eos, rx1349_done
    set rx1349_off, 0
    lt rx1349_pos, 2, rx1349_start
    sub rx1349_off, rx1349_pos, 1
    substr rx1349_tgt, rx1349_tgt, rx1349_off
  rx1349_start:
    eq $I10, 1, rx1349_restart
    if_null rx1349_debug, debug_1151
    rx1349_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1151:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1352_done
    goto rxscan1352_scan
  rxscan1352_loop:
    (rx1349_pos) = rx1349_cur."from"()
    inc rx1349_pos
    rx1349_cur."!cursor_from"(rx1349_pos)
    ge rx1349_pos, rx1349_eos, rxscan1352_done
  rxscan1352_scan:
    set_addr $I10, rxscan1352_loop
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  rxscan1352_done:
.annotate 'line', 623
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1349_pos, rx1349_off
    substr $S10, rx1349_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1349_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."quote_EXPR"(":q")
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1349_pos = $P10."pos"()
.annotate 'line', 624
  # rx subrule "O" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."O"("%methodop")
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1349_pos = $P10."pos"()
.annotate 'line', 622
  # rx pass
    rx1349_cur."!cursor_pass"(rx1349_pos, "postcircumfix:sym<ang>")
    if_null rx1349_debug, debug_1152
    rx1349_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1349_pos)
  debug_1152:
    .return (rx1349_cur)
  rx1349_restart:
.annotate 'line', 10
    if_null rx1349_debug, debug_1153
    rx1349_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1153:
  rx1349_fail:
    (rx1349_rep, rx1349_pos, $I10, $P10) = rx1349_cur."!mark_fail"(0)
    lt rx1349_pos, -1, rx1349_done
    eq rx1349_pos, -1, rx1349_fail
    jump $I10
  rx1349_done:
    rx1349_cur."!cursor_fail"()
    if_null rx1349_debug, debug_1154
    rx1349_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1154:
    .return (rx1349_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("282_1303391609.928") :method
.annotate 'line', 10
    new $P1351, "ResizablePMCArray"
    push $P1351, "<"
    .return ($P1351)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("283_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1354_tgt
    .local int rx1354_pos
    .local int rx1354_off
    .local int rx1354_eos
    .local int rx1354_rep
    .local pmc rx1354_cur
    .local pmc rx1354_debug
    (rx1354_cur, rx1354_pos, rx1354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1354_cur
    .local pmc match
    .lex "$/", match
    length rx1354_eos, rx1354_tgt
    gt rx1354_pos, rx1354_eos, rx1354_done
    set rx1354_off, 0
    lt rx1354_pos, 2, rx1354_start
    sub rx1354_off, rx1354_pos, 1
    substr rx1354_tgt, rx1354_tgt, rx1354_off
  rx1354_start:
    eq $I10, 1, rx1354_restart
    if_null rx1354_debug, debug_1155
    rx1354_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1155:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1358_done
    goto rxscan1358_scan
  rxscan1358_loop:
    (rx1354_pos) = rx1354_cur."from"()
    inc rx1354_pos
    rx1354_cur."!cursor_from"(rx1354_pos)
    ge rx1354_pos, rx1354_eos, rxscan1358_done
  rxscan1358_scan:
    set_addr $I10, rxscan1358_loop
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
  rxscan1358_done:
.annotate 'line', 628
  # rx literal  "("
    add $I11, rx1354_pos, 1
    gt $I11, rx1354_eos, rx1354_fail
    sub $I11, rx1354_pos, rx1354_off
    ord $I11, rx1354_tgt, $I11
    ne $I11, 40, rx1354_fail
    add rx1354_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1354_cur."!cursor_pos"(rx1354_pos)
    $P10 = rx1354_cur."ws"()
    unless $P10, rx1354_fail
    rx1354_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1354_cur."!cursor_pos"(rx1354_pos)
    $P10 = rx1354_cur."arglist"()
    unless $P10, rx1354_fail
    rx1354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1354_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1354_pos, 1
    gt $I11, rx1354_eos, rx1354_fail
    sub $I11, rx1354_pos, rx1354_off
    ord $I11, rx1354_tgt, $I11
    ne $I11, 41, rx1354_fail
    add rx1354_pos, 1
.annotate 'line', 629
  # rx subrule "O" subtype=capture negate=
    rx1354_cur."!cursor_pos"(rx1354_pos)
    $P10 = rx1354_cur."O"("%methodop")
    unless $P10, rx1354_fail
    rx1354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1354_pos = $P10."pos"()
.annotate 'line', 627
  # rx pass
    rx1354_cur."!cursor_pass"(rx1354_pos, "postcircumfix:sym<( )>")
    if_null rx1354_debug, debug_1156
    rx1354_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1354_pos)
  debug_1156:
    .return (rx1354_cur)
  rx1354_restart:
.annotate 'line', 10
    if_null rx1354_debug, debug_1157
    rx1354_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1157:
  rx1354_fail:
    (rx1354_rep, rx1354_pos, $I10, $P10) = rx1354_cur."!mark_fail"(0)
    lt rx1354_pos, -1, rx1354_done
    eq rx1354_pos, -1, rx1354_fail
    jump $I10
  rx1354_done:
    rx1354_cur."!cursor_fail"()
    if_null rx1354_debug, debug_1158
    rx1354_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1158:
    .return (rx1354_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("284_1303391609.928") :method
.annotate 'line', 10
    $P1356 = self."!PREFIX__!subrule"("ws", "(")
    new $P1357, "ResizablePMCArray"
    push $P1357, $P1356
    .return ($P1357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("285_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1360_tgt
    .local int rx1360_pos
    .local int rx1360_off
    .local int rx1360_eos
    .local int rx1360_rep
    .local pmc rx1360_cur
    .local pmc rx1360_debug
    (rx1360_cur, rx1360_pos, rx1360_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1360_cur
    .local pmc match
    .lex "$/", match
    length rx1360_eos, rx1360_tgt
    gt rx1360_pos, rx1360_eos, rx1360_done
    set rx1360_off, 0
    lt rx1360_pos, 2, rx1360_start
    sub rx1360_off, rx1360_pos, 1
    substr rx1360_tgt, rx1360_tgt, rx1360_off
  rx1360_start:
    eq $I10, 1, rx1360_restart
    if_null rx1360_debug, debug_1159
    rx1360_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1159:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1364_done
    goto rxscan1364_scan
  rxscan1364_loop:
    (rx1360_pos) = rx1360_cur."from"()
    inc rx1360_pos
    rx1360_cur."!cursor_from"(rx1360_pos)
    ge rx1360_pos, rx1360_eos, rxscan1364_done
  rxscan1364_scan:
    set_addr $I10, rxscan1364_loop
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10)
  rxscan1364_done:
.annotate 'line', 632
  # rx subrule "dotty" subtype=capture negate=
    rx1360_cur."!cursor_pos"(rx1360_pos)
    $P10 = rx1360_cur."dotty"()
    unless $P10, rx1360_fail
    rx1360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1360_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1360_cur."!cursor_pos"(rx1360_pos)
    $P10 = rx1360_cur."O"("%methodop")
    unless $P10, rx1360_fail
    rx1360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1360_pos = $P10."pos"()
  # rx pass
    rx1360_cur."!cursor_pass"(rx1360_pos, "postfix:sym<.>")
    if_null rx1360_debug, debug_1160
    rx1360_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1360_pos)
  debug_1160:
    .return (rx1360_cur)
  rx1360_restart:
.annotate 'line', 10
    if_null rx1360_debug, debug_1161
    rx1360_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1161:
  rx1360_fail:
    (rx1360_rep, rx1360_pos, $I10, $P10) = rx1360_cur."!mark_fail"(0)
    lt rx1360_pos, -1, rx1360_done
    eq rx1360_pos, -1, rx1360_fail
    jump $I10
  rx1360_done:
    rx1360_cur."!cursor_fail"()
    if_null rx1360_debug, debug_1162
    rx1360_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1162:
    .return (rx1360_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("286_1303391609.928") :method
.annotate 'line', 10
    $P1362 = self."!PREFIX__!subrule"("dotty", "")
    new $P1363, "ResizablePMCArray"
    push $P1363, $P1362
    .return ($P1363)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("287_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1366_tgt
    .local int rx1366_pos
    .local int rx1366_off
    .local int rx1366_eos
    .local int rx1366_rep
    .local pmc rx1366_cur
    .local pmc rx1366_debug
    (rx1366_cur, rx1366_pos, rx1366_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1366_cur
    .local pmc match
    .lex "$/", match
    length rx1366_eos, rx1366_tgt
    gt rx1366_pos, rx1366_eos, rx1366_done
    set rx1366_off, 0
    lt rx1366_pos, 2, rx1366_start
    sub rx1366_off, rx1366_pos, 1
    substr rx1366_tgt, rx1366_tgt, rx1366_off
  rx1366_start:
    eq $I10, 1, rx1366_restart
    if_null rx1366_debug, debug_1163
    rx1366_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1163:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1370_done
    goto rxscan1370_scan
  rxscan1370_loop:
    (rx1366_pos) = rx1366_cur."from"()
    inc rx1366_pos
    rx1366_cur."!cursor_from"(rx1366_pos)
    ge rx1366_pos, rx1366_eos, rxscan1370_done
  rxscan1370_scan:
    set_addr $I10, rxscan1370_loop
    rx1366_cur."!mark_push"(0, rx1366_pos, $I10)
  rxscan1370_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1371_fail
    rx1366_cur."!mark_push"(0, rx1366_pos, $I10)
  # rx literal  "++"
    add $I11, rx1366_pos, 2
    gt $I11, rx1366_eos, rx1366_fail
    sub $I11, rx1366_pos, rx1366_off
    substr $S10, rx1366_tgt, $I11, 2
    ne $S10, "++", rx1366_fail
    add rx1366_pos, 2
    set_addr $I10, rxcap_1371_fail
    ($I12, $I11) = rx1366_cur."!mark_peek"($I10)
    rx1366_cur."!cursor_pos"($I11)
    ($P10) = rx1366_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1366_pos, "")
    rx1366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1371_done
  rxcap_1371_fail:
    goto rx1366_fail
  rxcap_1371_done:
  # rx subrule "O" subtype=capture negate=
    rx1366_cur."!cursor_pos"(rx1366_pos)
    $P10 = rx1366_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1366_fail
    rx1366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1366_pos = $P10."pos"()
  # rx pass
    rx1366_cur."!cursor_pass"(rx1366_pos, "prefix:sym<++>")
    if_null rx1366_debug, debug_1164
    rx1366_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1366_pos)
  debug_1164:
    .return (rx1366_cur)
  rx1366_restart:
.annotate 'line', 10
    if_null rx1366_debug, debug_1165
    rx1366_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1165:
  rx1366_fail:
    (rx1366_rep, rx1366_pos, $I10, $P10) = rx1366_cur."!mark_fail"(0)
    lt rx1366_pos, -1, rx1366_done
    eq rx1366_pos, -1, rx1366_fail
    jump $I10
  rx1366_done:
    rx1366_cur."!cursor_fail"()
    if_null rx1366_debug, debug_1166
    rx1366_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1166:
    .return (rx1366_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("288_1303391609.928") :method
.annotate 'line', 10
    $P1368 = self."!PREFIX__!subrule"("O", "++")
    new $P1369, "ResizablePMCArray"
    push $P1369, $P1368
    .return ($P1369)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("289_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1373_tgt
    .local int rx1373_pos
    .local int rx1373_off
    .local int rx1373_eos
    .local int rx1373_rep
    .local pmc rx1373_cur
    .local pmc rx1373_debug
    (rx1373_cur, rx1373_pos, rx1373_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1373_cur
    .local pmc match
    .lex "$/", match
    length rx1373_eos, rx1373_tgt
    gt rx1373_pos, rx1373_eos, rx1373_done
    set rx1373_off, 0
    lt rx1373_pos, 2, rx1373_start
    sub rx1373_off, rx1373_pos, 1
    substr rx1373_tgt, rx1373_tgt, rx1373_off
  rx1373_start:
    eq $I10, 1, rx1373_restart
    if_null rx1373_debug, debug_1167
    rx1373_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1167:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1377_done
    goto rxscan1377_scan
  rxscan1377_loop:
    (rx1373_pos) = rx1373_cur."from"()
    inc rx1373_pos
    rx1373_cur."!cursor_from"(rx1373_pos)
    ge rx1373_pos, rx1373_eos, rxscan1377_done
  rxscan1377_scan:
    set_addr $I10, rxscan1377_loop
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  rxscan1377_done:
.annotate 'line', 635
  # rx subcapture "sym"
    set_addr $I10, rxcap_1378_fail
    rx1373_cur."!mark_push"(0, rx1373_pos, $I10)
  # rx literal  "--"
    add $I11, rx1373_pos, 2
    gt $I11, rx1373_eos, rx1373_fail
    sub $I11, rx1373_pos, rx1373_off
    substr $S10, rx1373_tgt, $I11, 2
    ne $S10, "--", rx1373_fail
    add rx1373_pos, 2
    set_addr $I10, rxcap_1378_fail
    ($I12, $I11) = rx1373_cur."!mark_peek"($I10)
    rx1373_cur."!cursor_pos"($I11)
    ($P10) = rx1373_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1373_pos, "")
    rx1373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1378_done
  rxcap_1378_fail:
    goto rx1373_fail
  rxcap_1378_done:
  # rx subrule "O" subtype=capture negate=
    rx1373_cur."!cursor_pos"(rx1373_pos)
    $P10 = rx1373_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1373_fail
    rx1373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1373_pos = $P10."pos"()
  # rx pass
    rx1373_cur."!cursor_pass"(rx1373_pos, "prefix:sym<-->")
    if_null rx1373_debug, debug_1168
    rx1373_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1373_pos)
  debug_1168:
    .return (rx1373_cur)
  rx1373_restart:
.annotate 'line', 10
    if_null rx1373_debug, debug_1169
    rx1373_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1169:
  rx1373_fail:
    (rx1373_rep, rx1373_pos, $I10, $P10) = rx1373_cur."!mark_fail"(0)
    lt rx1373_pos, -1, rx1373_done
    eq rx1373_pos, -1, rx1373_fail
    jump $I10
  rx1373_done:
    rx1373_cur."!cursor_fail"()
    if_null rx1373_debug, debug_1170
    rx1373_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1170:
    .return (rx1373_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("290_1303391609.928") :method
.annotate 'line', 10
    $P1375 = self."!PREFIX__!subrule"("O", "--")
    new $P1376, "ResizablePMCArray"
    push $P1376, $P1375
    .return ($P1376)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("291_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1380_tgt
    .local int rx1380_pos
    .local int rx1380_off
    .local int rx1380_eos
    .local int rx1380_rep
    .local pmc rx1380_cur
    .local pmc rx1380_debug
    (rx1380_cur, rx1380_pos, rx1380_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1380_cur
    .local pmc match
    .lex "$/", match
    length rx1380_eos, rx1380_tgt
    gt rx1380_pos, rx1380_eos, rx1380_done
    set rx1380_off, 0
    lt rx1380_pos, 2, rx1380_start
    sub rx1380_off, rx1380_pos, 1
    substr rx1380_tgt, rx1380_tgt, rx1380_off
  rx1380_start:
    eq $I10, 1, rx1380_restart
    if_null rx1380_debug, debug_1171
    rx1380_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1171:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1384_done
    goto rxscan1384_scan
  rxscan1384_loop:
    (rx1380_pos) = rx1380_cur."from"()
    inc rx1380_pos
    rx1380_cur."!cursor_from"(rx1380_pos)
    ge rx1380_pos, rx1380_eos, rxscan1384_done
  rxscan1384_scan:
    set_addr $I10, rxscan1384_loop
    rx1380_cur."!mark_push"(0, rx1380_pos, $I10)
  rxscan1384_done:
.annotate 'line', 638
  # rx subcapture "sym"
    set_addr $I10, rxcap_1385_fail
    rx1380_cur."!mark_push"(0, rx1380_pos, $I10)
  # rx literal  "++"
    add $I11, rx1380_pos, 2
    gt $I11, rx1380_eos, rx1380_fail
    sub $I11, rx1380_pos, rx1380_off
    substr $S10, rx1380_tgt, $I11, 2
    ne $S10, "++", rx1380_fail
    add rx1380_pos, 2
    set_addr $I10, rxcap_1385_fail
    ($I12, $I11) = rx1380_cur."!mark_peek"($I10)
    rx1380_cur."!cursor_pos"($I11)
    ($P10) = rx1380_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1380_pos, "")
    rx1380_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1385_done
  rxcap_1385_fail:
    goto rx1380_fail
  rxcap_1385_done:
  # rx subrule "O" subtype=capture negate=
    rx1380_cur."!cursor_pos"(rx1380_pos)
    $P10 = rx1380_cur."O"("%autoincrement")
    unless $P10, rx1380_fail
    rx1380_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1380_pos = $P10."pos"()
  # rx pass
    rx1380_cur."!cursor_pass"(rx1380_pos, "postfix:sym<++>")
    if_null rx1380_debug, debug_1172
    rx1380_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1380_pos)
  debug_1172:
    .return (rx1380_cur)
  rx1380_restart:
.annotate 'line', 10
    if_null rx1380_debug, debug_1173
    rx1380_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1173:
  rx1380_fail:
    (rx1380_rep, rx1380_pos, $I10, $P10) = rx1380_cur."!mark_fail"(0)
    lt rx1380_pos, -1, rx1380_done
    eq rx1380_pos, -1, rx1380_fail
    jump $I10
  rx1380_done:
    rx1380_cur."!cursor_fail"()
    if_null rx1380_debug, debug_1174
    rx1380_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1174:
    .return (rx1380_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("292_1303391609.928") :method
.annotate 'line', 10
    $P1382 = self."!PREFIX__!subrule"("O", "++")
    new $P1383, "ResizablePMCArray"
    push $P1383, $P1382
    .return ($P1383)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("293_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1387_tgt
    .local int rx1387_pos
    .local int rx1387_off
    .local int rx1387_eos
    .local int rx1387_rep
    .local pmc rx1387_cur
    .local pmc rx1387_debug
    (rx1387_cur, rx1387_pos, rx1387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1387_cur
    .local pmc match
    .lex "$/", match
    length rx1387_eos, rx1387_tgt
    gt rx1387_pos, rx1387_eos, rx1387_done
    set rx1387_off, 0
    lt rx1387_pos, 2, rx1387_start
    sub rx1387_off, rx1387_pos, 1
    substr rx1387_tgt, rx1387_tgt, rx1387_off
  rx1387_start:
    eq $I10, 1, rx1387_restart
    if_null rx1387_debug, debug_1175
    rx1387_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1175:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1391_done
    goto rxscan1391_scan
  rxscan1391_loop:
    (rx1387_pos) = rx1387_cur."from"()
    inc rx1387_pos
    rx1387_cur."!cursor_from"(rx1387_pos)
    ge rx1387_pos, rx1387_eos, rxscan1391_done
  rxscan1391_scan:
    set_addr $I10, rxscan1391_loop
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  rxscan1391_done:
.annotate 'line', 639
  # rx subcapture "sym"
    set_addr $I10, rxcap_1392_fail
    rx1387_cur."!mark_push"(0, rx1387_pos, $I10)
  # rx literal  "--"
    add $I11, rx1387_pos, 2
    gt $I11, rx1387_eos, rx1387_fail
    sub $I11, rx1387_pos, rx1387_off
    substr $S10, rx1387_tgt, $I11, 2
    ne $S10, "--", rx1387_fail
    add rx1387_pos, 2
    set_addr $I10, rxcap_1392_fail
    ($I12, $I11) = rx1387_cur."!mark_peek"($I10)
    rx1387_cur."!cursor_pos"($I11)
    ($P10) = rx1387_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1387_pos, "")
    rx1387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1392_done
  rxcap_1392_fail:
    goto rx1387_fail
  rxcap_1392_done:
  # rx subrule "O" subtype=capture negate=
    rx1387_cur."!cursor_pos"(rx1387_pos)
    $P10 = rx1387_cur."O"("%autoincrement")
    unless $P10, rx1387_fail
    rx1387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1387_pos = $P10."pos"()
  # rx pass
    rx1387_cur."!cursor_pass"(rx1387_pos, "postfix:sym<-->")
    if_null rx1387_debug, debug_1176
    rx1387_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1387_pos)
  debug_1176:
    .return (rx1387_cur)
  rx1387_restart:
.annotate 'line', 10
    if_null rx1387_debug, debug_1177
    rx1387_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1177:
  rx1387_fail:
    (rx1387_rep, rx1387_pos, $I10, $P10) = rx1387_cur."!mark_fail"(0)
    lt rx1387_pos, -1, rx1387_done
    eq rx1387_pos, -1, rx1387_fail
    jump $I10
  rx1387_done:
    rx1387_cur."!cursor_fail"()
    if_null rx1387_debug, debug_1178
    rx1387_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1178:
    .return (rx1387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("294_1303391609.928") :method
.annotate 'line', 10
    $P1389 = self."!PREFIX__!subrule"("O", "--")
    new $P1390, "ResizablePMCArray"
    push $P1390, $P1389
    .return ($P1390)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("295_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1394_tgt
    .local int rx1394_pos
    .local int rx1394_off
    .local int rx1394_eos
    .local int rx1394_rep
    .local pmc rx1394_cur
    .local pmc rx1394_debug
    (rx1394_cur, rx1394_pos, rx1394_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1394_cur
    .local pmc match
    .lex "$/", match
    length rx1394_eos, rx1394_tgt
    gt rx1394_pos, rx1394_eos, rx1394_done
    set rx1394_off, 0
    lt rx1394_pos, 2, rx1394_start
    sub rx1394_off, rx1394_pos, 1
    substr rx1394_tgt, rx1394_tgt, rx1394_off
  rx1394_start:
    eq $I10, 1, rx1394_restart
    if_null rx1394_debug, debug_1179
    rx1394_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1179:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1398_done
    goto rxscan1398_scan
  rxscan1398_loop:
    (rx1394_pos) = rx1394_cur."from"()
    inc rx1394_pos
    rx1394_cur."!cursor_from"(rx1394_pos)
    ge rx1394_pos, rx1394_eos, rxscan1398_done
  rxscan1398_scan:
    set_addr $I10, rxscan1398_loop
    rx1394_cur."!mark_push"(0, rx1394_pos, $I10)
  rxscan1398_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1399_fail
    rx1394_cur."!mark_push"(0, rx1394_pos, $I10)
  # rx literal  "**"
    add $I11, rx1394_pos, 2
    gt $I11, rx1394_eos, rx1394_fail
    sub $I11, rx1394_pos, rx1394_off
    substr $S10, rx1394_tgt, $I11, 2
    ne $S10, "**", rx1394_fail
    add rx1394_pos, 2
    set_addr $I10, rxcap_1399_fail
    ($I12, $I11) = rx1394_cur."!mark_peek"($I10)
    rx1394_cur."!cursor_pos"($I11)
    ($P10) = rx1394_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1394_pos, "")
    rx1394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1399_done
  rxcap_1399_fail:
    goto rx1394_fail
  rxcap_1399_done:
  # rx subrule "O" subtype=capture negate=
    rx1394_cur."!cursor_pos"(rx1394_pos)
    $P10 = rx1394_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1394_fail
    rx1394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1394_pos = $P10."pos"()
  # rx pass
    rx1394_cur."!cursor_pass"(rx1394_pos, "infix:sym<**>")
    if_null rx1394_debug, debug_1180
    rx1394_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1394_pos)
  debug_1180:
    .return (rx1394_cur)
  rx1394_restart:
.annotate 'line', 10
    if_null rx1394_debug, debug_1181
    rx1394_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1181:
  rx1394_fail:
    (rx1394_rep, rx1394_pos, $I10, $P10) = rx1394_cur."!mark_fail"(0)
    lt rx1394_pos, -1, rx1394_done
    eq rx1394_pos, -1, rx1394_fail
    jump $I10
  rx1394_done:
    rx1394_cur."!cursor_fail"()
    if_null rx1394_debug, debug_1182
    rx1394_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1182:
    .return (rx1394_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("296_1303391609.928") :method
.annotate 'line', 10
    $P1396 = self."!PREFIX__!subrule"("O", "**")
    new $P1397, "ResizablePMCArray"
    push $P1397, $P1396
    .return ($P1397)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("297_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1401_tgt
    .local int rx1401_pos
    .local int rx1401_off
    .local int rx1401_eos
    .local int rx1401_rep
    .local pmc rx1401_cur
    .local pmc rx1401_debug
    (rx1401_cur, rx1401_pos, rx1401_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1401_cur
    .local pmc match
    .lex "$/", match
    length rx1401_eos, rx1401_tgt
    gt rx1401_pos, rx1401_eos, rx1401_done
    set rx1401_off, 0
    lt rx1401_pos, 2, rx1401_start
    sub rx1401_off, rx1401_pos, 1
    substr rx1401_tgt, rx1401_tgt, rx1401_off
  rx1401_start:
    eq $I10, 1, rx1401_restart
    if_null rx1401_debug, debug_1183
    rx1401_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1183:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1405_done
    goto rxscan1405_scan
  rxscan1405_loop:
    (rx1401_pos) = rx1401_cur."from"()
    inc rx1401_pos
    rx1401_cur."!cursor_from"(rx1401_pos)
    ge rx1401_pos, rx1401_eos, rxscan1405_done
  rxscan1405_scan:
    set_addr $I10, rxscan1405_loop
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  rxscan1405_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1406_fail
    rx1401_cur."!mark_push"(0, rx1401_pos, $I10)
  # rx literal  "+"
    add $I11, rx1401_pos, 1
    gt $I11, rx1401_eos, rx1401_fail
    sub $I11, rx1401_pos, rx1401_off
    ord $I11, rx1401_tgt, $I11
    ne $I11, 43, rx1401_fail
    add rx1401_pos, 1
    set_addr $I10, rxcap_1406_fail
    ($I12, $I11) = rx1401_cur."!mark_peek"($I10)
    rx1401_cur."!cursor_pos"($I11)
    ($P10) = rx1401_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1401_pos, "")
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1406_done
  rxcap_1406_fail:
    goto rx1401_fail
  rxcap_1406_done:
  # rx subrule "O" subtype=capture negate=
    rx1401_cur."!cursor_pos"(rx1401_pos)
    $P10 = rx1401_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1401_fail
    rx1401_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1401_pos = $P10."pos"()
  # rx pass
    rx1401_cur."!cursor_pass"(rx1401_pos, "prefix:sym<+>")
    if_null rx1401_debug, debug_1184
    rx1401_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1401_pos)
  debug_1184:
    .return (rx1401_cur)
  rx1401_restart:
.annotate 'line', 10
    if_null rx1401_debug, debug_1185
    rx1401_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1185:
  rx1401_fail:
    (rx1401_rep, rx1401_pos, $I10, $P10) = rx1401_cur."!mark_fail"(0)
    lt rx1401_pos, -1, rx1401_done
    eq rx1401_pos, -1, rx1401_fail
    jump $I10
  rx1401_done:
    rx1401_cur."!cursor_fail"()
    if_null rx1401_debug, debug_1186
    rx1401_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1186:
    .return (rx1401_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("298_1303391609.928") :method
.annotate 'line', 10
    $P1403 = self."!PREFIX__!subrule"("O", "+")
    new $P1404, "ResizablePMCArray"
    push $P1404, $P1403
    .return ($P1404)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("299_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1408_tgt
    .local int rx1408_pos
    .local int rx1408_off
    .local int rx1408_eos
    .local int rx1408_rep
    .local pmc rx1408_cur
    .local pmc rx1408_debug
    (rx1408_cur, rx1408_pos, rx1408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1408_cur
    .local pmc match
    .lex "$/", match
    length rx1408_eos, rx1408_tgt
    gt rx1408_pos, rx1408_eos, rx1408_done
    set rx1408_off, 0
    lt rx1408_pos, 2, rx1408_start
    sub rx1408_off, rx1408_pos, 1
    substr rx1408_tgt, rx1408_tgt, rx1408_off
  rx1408_start:
    eq $I10, 1, rx1408_restart
    if_null rx1408_debug, debug_1187
    rx1408_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1187:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1412_done
    goto rxscan1412_scan
  rxscan1412_loop:
    (rx1408_pos) = rx1408_cur."from"()
    inc rx1408_pos
    rx1408_cur."!cursor_from"(rx1408_pos)
    ge rx1408_pos, rx1408_eos, rxscan1412_done
  rxscan1412_scan:
    set_addr $I10, rxscan1412_loop
    rx1408_cur."!mark_push"(0, rx1408_pos, $I10)
  rxscan1412_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1413_fail
    rx1408_cur."!mark_push"(0, rx1408_pos, $I10)
  # rx literal  "~"
    add $I11, rx1408_pos, 1
    gt $I11, rx1408_eos, rx1408_fail
    sub $I11, rx1408_pos, rx1408_off
    ord $I11, rx1408_tgt, $I11
    ne $I11, 126, rx1408_fail
    add rx1408_pos, 1
    set_addr $I10, rxcap_1413_fail
    ($I12, $I11) = rx1408_cur."!mark_peek"($I10)
    rx1408_cur."!cursor_pos"($I11)
    ($P10) = rx1408_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1408_pos, "")
    rx1408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1413_done
  rxcap_1413_fail:
    goto rx1408_fail
  rxcap_1413_done:
  # rx subrule "O" subtype=capture negate=
    rx1408_cur."!cursor_pos"(rx1408_pos)
    $P10 = rx1408_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1408_fail
    rx1408_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1408_pos = $P10."pos"()
  # rx pass
    rx1408_cur."!cursor_pass"(rx1408_pos, "prefix:sym<~>")
    if_null rx1408_debug, debug_1188
    rx1408_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1408_pos)
  debug_1188:
    .return (rx1408_cur)
  rx1408_restart:
.annotate 'line', 10
    if_null rx1408_debug, debug_1189
    rx1408_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1189:
  rx1408_fail:
    (rx1408_rep, rx1408_pos, $I10, $P10) = rx1408_cur."!mark_fail"(0)
    lt rx1408_pos, -1, rx1408_done
    eq rx1408_pos, -1, rx1408_fail
    jump $I10
  rx1408_done:
    rx1408_cur."!cursor_fail"()
    if_null rx1408_debug, debug_1190
    rx1408_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1190:
    .return (rx1408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("300_1303391609.928") :method
.annotate 'line', 10
    $P1410 = self."!PREFIX__!subrule"("O", "~")
    new $P1411, "ResizablePMCArray"
    push $P1411, $P1410
    .return ($P1411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("301_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1415_tgt
    .local int rx1415_pos
    .local int rx1415_off
    .local int rx1415_eos
    .local int rx1415_rep
    .local pmc rx1415_cur
    .local pmc rx1415_debug
    (rx1415_cur, rx1415_pos, rx1415_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1415_cur
    .local pmc match
    .lex "$/", match
    length rx1415_eos, rx1415_tgt
    gt rx1415_pos, rx1415_eos, rx1415_done
    set rx1415_off, 0
    lt rx1415_pos, 2, rx1415_start
    sub rx1415_off, rx1415_pos, 1
    substr rx1415_tgt, rx1415_tgt, rx1415_off
  rx1415_start:
    eq $I10, 1, rx1415_restart
    if_null rx1415_debug, debug_1191
    rx1415_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1191:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1418_done
    goto rxscan1418_scan
  rxscan1418_loop:
    (rx1415_pos) = rx1415_cur."from"()
    inc rx1415_pos
    rx1415_cur."!cursor_from"(rx1415_pos)
    ge rx1415_pos, rx1415_eos, rxscan1418_done
  rxscan1418_scan:
    set_addr $I10, rxscan1418_loop
    rx1415_cur."!mark_push"(0, rx1415_pos, $I10)
  rxscan1418_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1419_fail
    rx1415_cur."!mark_push"(0, rx1415_pos, $I10)
  # rx literal  "-"
    add $I11, rx1415_pos, 1
    gt $I11, rx1415_eos, rx1415_fail
    sub $I11, rx1415_pos, rx1415_off
    ord $I11, rx1415_tgt, $I11
    ne $I11, 45, rx1415_fail
    add rx1415_pos, 1
    set_addr $I10, rxcap_1419_fail
    ($I12, $I11) = rx1415_cur."!mark_peek"($I10)
    rx1415_cur."!cursor_pos"($I11)
    ($P10) = rx1415_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1415_pos, "")
    rx1415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1419_done
  rxcap_1419_fail:
    goto rx1415_fail
  rxcap_1419_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1415_pos, rx1415_off
    substr $S10, rx1415_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1415_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1415_cur."!cursor_pos"(rx1415_pos)
    $P10 = rx1415_cur."number"()
    if $P10, rx1415_fail
  # rx subrule "O" subtype=capture negate=
    rx1415_cur."!cursor_pos"(rx1415_pos)
    $P10 = rx1415_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1415_fail
    rx1415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1415_pos = $P10."pos"()
  # rx pass
    rx1415_cur."!cursor_pass"(rx1415_pos, "prefix:sym<->")
    if_null rx1415_debug, debug_1192
    rx1415_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1415_pos)
  debug_1192:
    .return (rx1415_cur)
  rx1415_restart:
.annotate 'line', 10
    if_null rx1415_debug, debug_1193
    rx1415_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1193:
  rx1415_fail:
    (rx1415_rep, rx1415_pos, $I10, $P10) = rx1415_cur."!mark_fail"(0)
    lt rx1415_pos, -1, rx1415_done
    eq rx1415_pos, -1, rx1415_fail
    jump $I10
  rx1415_done:
    rx1415_cur."!cursor_fail"()
    if_null rx1415_debug, debug_1194
    rx1415_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1194:
    .return (rx1415_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("302_1303391609.928") :method
.annotate 'line', 10
    new $P1417, "ResizablePMCArray"
    push $P1417, "-"
    .return ($P1417)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("303_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1421_tgt
    .local int rx1421_pos
    .local int rx1421_off
    .local int rx1421_eos
    .local int rx1421_rep
    .local pmc rx1421_cur
    .local pmc rx1421_debug
    (rx1421_cur, rx1421_pos, rx1421_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1421_cur
    .local pmc match
    .lex "$/", match
    length rx1421_eos, rx1421_tgt
    gt rx1421_pos, rx1421_eos, rx1421_done
    set rx1421_off, 0
    lt rx1421_pos, 2, rx1421_start
    sub rx1421_off, rx1421_pos, 1
    substr rx1421_tgt, rx1421_tgt, rx1421_off
  rx1421_start:
    eq $I10, 1, rx1421_restart
    if_null rx1421_debug, debug_1195
    rx1421_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1195:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1425_done
    goto rxscan1425_scan
  rxscan1425_loop:
    (rx1421_pos) = rx1421_cur."from"()
    inc rx1421_pos
    rx1421_cur."!cursor_from"(rx1421_pos)
    ge rx1421_pos, rx1421_eos, rxscan1425_done
  rxscan1425_scan:
    set_addr $I10, rxscan1425_loop
    rx1421_cur."!mark_push"(0, rx1421_pos, $I10)
  rxscan1425_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1426_fail
    rx1421_cur."!mark_push"(0, rx1421_pos, $I10)
  # rx literal  "?"
    add $I11, rx1421_pos, 1
    gt $I11, rx1421_eos, rx1421_fail
    sub $I11, rx1421_pos, rx1421_off
    ord $I11, rx1421_tgt, $I11
    ne $I11, 63, rx1421_fail
    add rx1421_pos, 1
    set_addr $I10, rxcap_1426_fail
    ($I12, $I11) = rx1421_cur."!mark_peek"($I10)
    rx1421_cur."!cursor_pos"($I11)
    ($P10) = rx1421_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1421_pos, "")
    rx1421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1426_done
  rxcap_1426_fail:
    goto rx1421_fail
  rxcap_1426_done:
  # rx subrule "O" subtype=capture negate=
    rx1421_cur."!cursor_pos"(rx1421_pos)
    $P10 = rx1421_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1421_fail
    rx1421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1421_pos = $P10."pos"()
  # rx pass
    rx1421_cur."!cursor_pass"(rx1421_pos, "prefix:sym<?>")
    if_null rx1421_debug, debug_1196
    rx1421_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1421_pos)
  debug_1196:
    .return (rx1421_cur)
  rx1421_restart:
.annotate 'line', 10
    if_null rx1421_debug, debug_1197
    rx1421_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1197:
  rx1421_fail:
    (rx1421_rep, rx1421_pos, $I10, $P10) = rx1421_cur."!mark_fail"(0)
    lt rx1421_pos, -1, rx1421_done
    eq rx1421_pos, -1, rx1421_fail
    jump $I10
  rx1421_done:
    rx1421_cur."!cursor_fail"()
    if_null rx1421_debug, debug_1198
    rx1421_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1198:
    .return (rx1421_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("304_1303391609.928") :method
.annotate 'line', 10
    $P1423 = self."!PREFIX__!subrule"("O", "?")
    new $P1424, "ResizablePMCArray"
    push $P1424, $P1423
    .return ($P1424)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("305_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1428_tgt
    .local int rx1428_pos
    .local int rx1428_off
    .local int rx1428_eos
    .local int rx1428_rep
    .local pmc rx1428_cur
    .local pmc rx1428_debug
    (rx1428_cur, rx1428_pos, rx1428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1428_cur
    .local pmc match
    .lex "$/", match
    length rx1428_eos, rx1428_tgt
    gt rx1428_pos, rx1428_eos, rx1428_done
    set rx1428_off, 0
    lt rx1428_pos, 2, rx1428_start
    sub rx1428_off, rx1428_pos, 1
    substr rx1428_tgt, rx1428_tgt, rx1428_off
  rx1428_start:
    eq $I10, 1, rx1428_restart
    if_null rx1428_debug, debug_1199
    rx1428_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1199:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1432_done
    goto rxscan1432_scan
  rxscan1432_loop:
    (rx1428_pos) = rx1428_cur."from"()
    inc rx1428_pos
    rx1428_cur."!cursor_from"(rx1428_pos)
    ge rx1428_pos, rx1428_eos, rxscan1432_done
  rxscan1432_scan:
    set_addr $I10, rxscan1432_loop
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  rxscan1432_done:
.annotate 'line', 647
  # rx subcapture "sym"
    set_addr $I10, rxcap_1433_fail
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  # rx literal  "!"
    add $I11, rx1428_pos, 1
    gt $I11, rx1428_eos, rx1428_fail
    sub $I11, rx1428_pos, rx1428_off
    ord $I11, rx1428_tgt, $I11
    ne $I11, 33, rx1428_fail
    add rx1428_pos, 1
    set_addr $I10, rxcap_1433_fail
    ($I12, $I11) = rx1428_cur."!mark_peek"($I10)
    rx1428_cur."!cursor_pos"($I11)
    ($P10) = rx1428_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1428_pos, "")
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1433_done
  rxcap_1433_fail:
    goto rx1428_fail
  rxcap_1433_done:
  # rx subrule "O" subtype=capture negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1428_fail
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1428_pos = $P10."pos"()
  # rx pass
    rx1428_cur."!cursor_pass"(rx1428_pos, "prefix:sym<!>")
    if_null rx1428_debug, debug_1200
    rx1428_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1428_pos)
  debug_1200:
    .return (rx1428_cur)
  rx1428_restart:
.annotate 'line', 10
    if_null rx1428_debug, debug_1201
    rx1428_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1201:
  rx1428_fail:
    (rx1428_rep, rx1428_pos, $I10, $P10) = rx1428_cur."!mark_fail"(0)
    lt rx1428_pos, -1, rx1428_done
    eq rx1428_pos, -1, rx1428_fail
    jump $I10
  rx1428_done:
    rx1428_cur."!cursor_fail"()
    if_null rx1428_debug, debug_1202
    rx1428_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1202:
    .return (rx1428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("306_1303391609.928") :method
.annotate 'line', 10
    $P1430 = self."!PREFIX__!subrule"("O", "!")
    new $P1431, "ResizablePMCArray"
    push $P1431, $P1430
    .return ($P1431)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("307_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1435_tgt
    .local int rx1435_pos
    .local int rx1435_off
    .local int rx1435_eos
    .local int rx1435_rep
    .local pmc rx1435_cur
    .local pmc rx1435_debug
    (rx1435_cur, rx1435_pos, rx1435_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1435_cur
    .local pmc match
    .lex "$/", match
    length rx1435_eos, rx1435_tgt
    gt rx1435_pos, rx1435_eos, rx1435_done
    set rx1435_off, 0
    lt rx1435_pos, 2, rx1435_start
    sub rx1435_off, rx1435_pos, 1
    substr rx1435_tgt, rx1435_tgt, rx1435_off
  rx1435_start:
    eq $I10, 1, rx1435_restart
    if_null rx1435_debug, debug_1203
    rx1435_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1203:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1439_done
    goto rxscan1439_scan
  rxscan1439_loop:
    (rx1435_pos) = rx1435_cur."from"()
    inc rx1435_pos
    rx1435_cur."!cursor_from"(rx1435_pos)
    ge rx1435_pos, rx1435_eos, rxscan1439_done
  rxscan1439_scan:
    set_addr $I10, rxscan1439_loop
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  rxscan1439_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1440_fail
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  # rx literal  "|"
    add $I11, rx1435_pos, 1
    gt $I11, rx1435_eos, rx1435_fail
    sub $I11, rx1435_pos, rx1435_off
    ord $I11, rx1435_tgt, $I11
    ne $I11, 124, rx1435_fail
    add rx1435_pos, 1
    set_addr $I10, rxcap_1440_fail
    ($I12, $I11) = rx1435_cur."!mark_peek"($I10)
    rx1435_cur."!cursor_pos"($I11)
    ($P10) = rx1435_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1435_pos, "")
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1440_done
  rxcap_1440_fail:
    goto rx1435_fail
  rxcap_1440_done:
  # rx subrule "O" subtype=capture negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."O"("%symbolic_unary")
    unless $P10, rx1435_fail
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1435_pos = $P10."pos"()
  # rx pass
    rx1435_cur."!cursor_pass"(rx1435_pos, "prefix:sym<|>")
    if_null rx1435_debug, debug_1204
    rx1435_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1435_pos)
  debug_1204:
    .return (rx1435_cur)
  rx1435_restart:
.annotate 'line', 10
    if_null rx1435_debug, debug_1205
    rx1435_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1205:
  rx1435_fail:
    (rx1435_rep, rx1435_pos, $I10, $P10) = rx1435_cur."!mark_fail"(0)
    lt rx1435_pos, -1, rx1435_done
    eq rx1435_pos, -1, rx1435_fail
    jump $I10
  rx1435_done:
    rx1435_cur."!cursor_fail"()
    if_null rx1435_debug, debug_1206
    rx1435_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1206:
    .return (rx1435_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("308_1303391609.928") :method
.annotate 'line', 10
    $P1437 = self."!PREFIX__!subrule"("O", "|")
    new $P1438, "ResizablePMCArray"
    push $P1438, $P1437
    .return ($P1438)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("309_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1442_tgt
    .local int rx1442_pos
    .local int rx1442_off
    .local int rx1442_eos
    .local int rx1442_rep
    .local pmc rx1442_cur
    .local pmc rx1442_debug
    (rx1442_cur, rx1442_pos, rx1442_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1442_cur
    .local pmc match
    .lex "$/", match
    length rx1442_eos, rx1442_tgt
    gt rx1442_pos, rx1442_eos, rx1442_done
    set rx1442_off, 0
    lt rx1442_pos, 2, rx1442_start
    sub rx1442_off, rx1442_pos, 1
    substr rx1442_tgt, rx1442_tgt, rx1442_off
  rx1442_start:
    eq $I10, 1, rx1442_restart
    if_null rx1442_debug, debug_1207
    rx1442_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1207:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1446_done
    goto rxscan1446_scan
  rxscan1446_loop:
    (rx1442_pos) = rx1442_cur."from"()
    inc rx1442_pos
    rx1442_cur."!cursor_from"(rx1442_pos)
    ge rx1442_pos, rx1442_eos, rxscan1446_done
  rxscan1446_scan:
    set_addr $I10, rxscan1446_loop
    rx1442_cur."!mark_push"(0, rx1442_pos, $I10)
  rxscan1446_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1447_fail
    rx1442_cur."!mark_push"(0, rx1442_pos, $I10)
  # rx literal  "*"
    add $I11, rx1442_pos, 1
    gt $I11, rx1442_eos, rx1442_fail
    sub $I11, rx1442_pos, rx1442_off
    ord $I11, rx1442_tgt, $I11
    ne $I11, 42, rx1442_fail
    add rx1442_pos, 1
    set_addr $I10, rxcap_1447_fail
    ($I12, $I11) = rx1442_cur."!mark_peek"($I10)
    rx1442_cur."!cursor_pos"($I11)
    ($P10) = rx1442_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1442_pos, "")
    rx1442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1447_done
  rxcap_1447_fail:
    goto rx1442_fail
  rxcap_1447_done:
  # rx subrule "O" subtype=capture negate=
    rx1442_cur."!cursor_pos"(rx1442_pos)
    $P10 = rx1442_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1442_fail
    rx1442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1442_pos = $P10."pos"()
  # rx pass
    rx1442_cur."!cursor_pass"(rx1442_pos, "infix:sym<*>")
    if_null rx1442_debug, debug_1208
    rx1442_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1442_pos)
  debug_1208:
    .return (rx1442_cur)
  rx1442_restart:
.annotate 'line', 10
    if_null rx1442_debug, debug_1209
    rx1442_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1209:
  rx1442_fail:
    (rx1442_rep, rx1442_pos, $I10, $P10) = rx1442_cur."!mark_fail"(0)
    lt rx1442_pos, -1, rx1442_done
    eq rx1442_pos, -1, rx1442_fail
    jump $I10
  rx1442_done:
    rx1442_cur."!cursor_fail"()
    if_null rx1442_debug, debug_1210
    rx1442_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1210:
    .return (rx1442_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("310_1303391609.928") :method
.annotate 'line', 10
    $P1444 = self."!PREFIX__!subrule"("O", "*")
    new $P1445, "ResizablePMCArray"
    push $P1445, $P1444
    .return ($P1445)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("311_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1449_tgt
    .local int rx1449_pos
    .local int rx1449_off
    .local int rx1449_eos
    .local int rx1449_rep
    .local pmc rx1449_cur
    .local pmc rx1449_debug
    (rx1449_cur, rx1449_pos, rx1449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1449_cur
    .local pmc match
    .lex "$/", match
    length rx1449_eos, rx1449_tgt
    gt rx1449_pos, rx1449_eos, rx1449_done
    set rx1449_off, 0
    lt rx1449_pos, 2, rx1449_start
    sub rx1449_off, rx1449_pos, 1
    substr rx1449_tgt, rx1449_tgt, rx1449_off
  rx1449_start:
    eq $I10, 1, rx1449_restart
    if_null rx1449_debug, debug_1211
    rx1449_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1211:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1453_done
    goto rxscan1453_scan
  rxscan1453_loop:
    (rx1449_pos) = rx1449_cur."from"()
    inc rx1449_pos
    rx1449_cur."!cursor_from"(rx1449_pos)
    ge rx1449_pos, rx1449_eos, rxscan1453_done
  rxscan1453_scan:
    set_addr $I10, rxscan1453_loop
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxscan1453_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1454_fail
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  # rx literal  "/"
    add $I11, rx1449_pos, 1
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    ord $I11, rx1449_tgt, $I11
    ne $I11, 47, rx1449_fail
    add rx1449_pos, 1
    set_addr $I10, rxcap_1454_fail
    ($I12, $I11) = rx1449_cur."!mark_peek"($I10)
    rx1449_cur."!cursor_pos"($I11)
    ($P10) = rx1449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1449_pos, "")
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1454_done
  rxcap_1454_fail:
    goto rx1449_fail
  rxcap_1454_done:
  # rx subrule "O" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1449_pos = $P10."pos"()
  # rx pass
    rx1449_cur."!cursor_pass"(rx1449_pos, "infix:sym</>")
    if_null rx1449_debug, debug_1212
    rx1449_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1449_pos)
  debug_1212:
    .return (rx1449_cur)
  rx1449_restart:
.annotate 'line', 10
    if_null rx1449_debug, debug_1213
    rx1449_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1213:
  rx1449_fail:
    (rx1449_rep, rx1449_pos, $I10, $P10) = rx1449_cur."!mark_fail"(0)
    lt rx1449_pos, -1, rx1449_done
    eq rx1449_pos, -1, rx1449_fail
    jump $I10
  rx1449_done:
    rx1449_cur."!cursor_fail"()
    if_null rx1449_debug, debug_1214
    rx1449_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1214:
    .return (rx1449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("312_1303391609.928") :method
.annotate 'line', 10
    $P1451 = self."!PREFIX__!subrule"("O", "/")
    new $P1452, "ResizablePMCArray"
    push $P1452, $P1451
    .return ($P1452)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("313_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1456_tgt
    .local int rx1456_pos
    .local int rx1456_off
    .local int rx1456_eos
    .local int rx1456_rep
    .local pmc rx1456_cur
    .local pmc rx1456_debug
    (rx1456_cur, rx1456_pos, rx1456_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1456_cur
    .local pmc match
    .lex "$/", match
    length rx1456_eos, rx1456_tgt
    gt rx1456_pos, rx1456_eos, rx1456_done
    set rx1456_off, 0
    lt rx1456_pos, 2, rx1456_start
    sub rx1456_off, rx1456_pos, 1
    substr rx1456_tgt, rx1456_tgt, rx1456_off
  rx1456_start:
    eq $I10, 1, rx1456_restart
    if_null rx1456_debug, debug_1215
    rx1456_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1215:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1460_done
    goto rxscan1460_scan
  rxscan1460_loop:
    (rx1456_pos) = rx1456_cur."from"()
    inc rx1456_pos
    rx1456_cur."!cursor_from"(rx1456_pos)
    ge rx1456_pos, rx1456_eos, rxscan1460_done
  rxscan1460_scan:
    set_addr $I10, rxscan1460_loop
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  rxscan1460_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1461_fail
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  # rx literal  "%"
    add $I11, rx1456_pos, 1
    gt $I11, rx1456_eos, rx1456_fail
    sub $I11, rx1456_pos, rx1456_off
    ord $I11, rx1456_tgt, $I11
    ne $I11, 37, rx1456_fail
    add rx1456_pos, 1
    set_addr $I10, rxcap_1461_fail
    ($I12, $I11) = rx1456_cur."!mark_peek"($I10)
    rx1456_cur."!cursor_pos"($I11)
    ($P10) = rx1456_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1456_pos, "")
    rx1456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1461_done
  rxcap_1461_fail:
    goto rx1456_fail
  rxcap_1461_done:
  # rx subrule "O" subtype=capture negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1456_fail
    rx1456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1456_pos = $P10."pos"()
  # rx pass
    rx1456_cur."!cursor_pass"(rx1456_pos, "infix:sym<%>")
    if_null rx1456_debug, debug_1216
    rx1456_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1456_pos)
  debug_1216:
    .return (rx1456_cur)
  rx1456_restart:
.annotate 'line', 10
    if_null rx1456_debug, debug_1217
    rx1456_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1217:
  rx1456_fail:
    (rx1456_rep, rx1456_pos, $I10, $P10) = rx1456_cur."!mark_fail"(0)
    lt rx1456_pos, -1, rx1456_done
    eq rx1456_pos, -1, rx1456_fail
    jump $I10
  rx1456_done:
    rx1456_cur."!cursor_fail"()
    if_null rx1456_debug, debug_1218
    rx1456_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1218:
    .return (rx1456_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("314_1303391609.928") :method
.annotate 'line', 10
    $P1458 = self."!PREFIX__!subrule"("O", "%")
    new $P1459, "ResizablePMCArray"
    push $P1459, $P1458
    .return ($P1459)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("315_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1463_tgt
    .local int rx1463_pos
    .local int rx1463_off
    .local int rx1463_eos
    .local int rx1463_rep
    .local pmc rx1463_cur
    .local pmc rx1463_debug
    (rx1463_cur, rx1463_pos, rx1463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1463_cur
    .local pmc match
    .lex "$/", match
    length rx1463_eos, rx1463_tgt
    gt rx1463_pos, rx1463_eos, rx1463_done
    set rx1463_off, 0
    lt rx1463_pos, 2, rx1463_start
    sub rx1463_off, rx1463_pos, 1
    substr rx1463_tgt, rx1463_tgt, rx1463_off
  rx1463_start:
    eq $I10, 1, rx1463_restart
    if_null rx1463_debug, debug_1219
    rx1463_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1219:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1467_done
    goto rxscan1467_scan
  rxscan1467_loop:
    (rx1463_pos) = rx1463_cur."from"()
    inc rx1463_pos
    rx1463_cur."!cursor_from"(rx1463_pos)
    ge rx1463_pos, rx1463_eos, rxscan1467_done
  rxscan1467_scan:
    set_addr $I10, rxscan1467_loop
    rx1463_cur."!mark_push"(0, rx1463_pos, $I10)
  rxscan1467_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1468_fail
    rx1463_cur."!mark_push"(0, rx1463_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1463_pos, 2
    gt $I11, rx1463_eos, rx1463_fail
    sub $I11, rx1463_pos, rx1463_off
    substr $S10, rx1463_tgt, $I11, 2
    ne $S10, "+&", rx1463_fail
    add rx1463_pos, 2
    set_addr $I10, rxcap_1468_fail
    ($I12, $I11) = rx1463_cur."!mark_peek"($I10)
    rx1463_cur."!cursor_pos"($I11)
    ($P10) = rx1463_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1463_pos, "")
    rx1463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1468_done
  rxcap_1468_fail:
    goto rx1463_fail
  rxcap_1468_done:
  # rx subrule "O" subtype=capture negate=
    rx1463_cur."!cursor_pos"(rx1463_pos)
    $P10 = rx1463_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1463_fail
    rx1463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1463_pos = $P10."pos"()
  # rx pass
    rx1463_cur."!cursor_pass"(rx1463_pos, "infix:sym<+&>")
    if_null rx1463_debug, debug_1220
    rx1463_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1463_pos)
  debug_1220:
    .return (rx1463_cur)
  rx1463_restart:
.annotate 'line', 10
    if_null rx1463_debug, debug_1221
    rx1463_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1221:
  rx1463_fail:
    (rx1463_rep, rx1463_pos, $I10, $P10) = rx1463_cur."!mark_fail"(0)
    lt rx1463_pos, -1, rx1463_done
    eq rx1463_pos, -1, rx1463_fail
    jump $I10
  rx1463_done:
    rx1463_cur."!cursor_fail"()
    if_null rx1463_debug, debug_1222
    rx1463_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1222:
    .return (rx1463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("316_1303391609.928") :method
.annotate 'line', 10
    $P1465 = self."!PREFIX__!subrule"("O", "+&")
    new $P1466, "ResizablePMCArray"
    push $P1466, $P1465
    .return ($P1466)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("317_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1470_tgt
    .local int rx1470_pos
    .local int rx1470_off
    .local int rx1470_eos
    .local int rx1470_rep
    .local pmc rx1470_cur
    .local pmc rx1470_debug
    (rx1470_cur, rx1470_pos, rx1470_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1470_cur
    .local pmc match
    .lex "$/", match
    length rx1470_eos, rx1470_tgt
    gt rx1470_pos, rx1470_eos, rx1470_done
    set rx1470_off, 0
    lt rx1470_pos, 2, rx1470_start
    sub rx1470_off, rx1470_pos, 1
    substr rx1470_tgt, rx1470_tgt, rx1470_off
  rx1470_start:
    eq $I10, 1, rx1470_restart
    if_null rx1470_debug, debug_1223
    rx1470_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1223:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1474_done
    goto rxscan1474_scan
  rxscan1474_loop:
    (rx1470_pos) = rx1470_cur."from"()
    inc rx1470_pos
    rx1470_cur."!cursor_from"(rx1470_pos)
    ge rx1470_pos, rx1470_eos, rxscan1474_done
  rxscan1474_scan:
    set_addr $I10, rxscan1474_loop
    rx1470_cur."!mark_push"(0, rx1470_pos, $I10)
  rxscan1474_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1475_fail
    rx1470_cur."!mark_push"(0, rx1470_pos, $I10)
  # rx literal  "+"
    add $I11, rx1470_pos, 1
    gt $I11, rx1470_eos, rx1470_fail
    sub $I11, rx1470_pos, rx1470_off
    ord $I11, rx1470_tgt, $I11
    ne $I11, 43, rx1470_fail
    add rx1470_pos, 1
    set_addr $I10, rxcap_1475_fail
    ($I12, $I11) = rx1470_cur."!mark_peek"($I10)
    rx1470_cur."!cursor_pos"($I11)
    ($P10) = rx1470_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1470_pos, "")
    rx1470_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1475_done
  rxcap_1475_fail:
    goto rx1470_fail
  rxcap_1475_done:
  # rx subrule "O" subtype=capture negate=
    rx1470_cur."!cursor_pos"(rx1470_pos)
    $P10 = rx1470_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1470_fail
    rx1470_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1470_pos = $P10."pos"()
  # rx pass
    rx1470_cur."!cursor_pass"(rx1470_pos, "infix:sym<+>")
    if_null rx1470_debug, debug_1224
    rx1470_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1470_pos)
  debug_1224:
    .return (rx1470_cur)
  rx1470_restart:
.annotate 'line', 10
    if_null rx1470_debug, debug_1225
    rx1470_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1225:
  rx1470_fail:
    (rx1470_rep, rx1470_pos, $I10, $P10) = rx1470_cur."!mark_fail"(0)
    lt rx1470_pos, -1, rx1470_done
    eq rx1470_pos, -1, rx1470_fail
    jump $I10
  rx1470_done:
    rx1470_cur."!cursor_fail"()
    if_null rx1470_debug, debug_1226
    rx1470_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1226:
    .return (rx1470_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("318_1303391609.928") :method
.annotate 'line', 10
    $P1472 = self."!PREFIX__!subrule"("O", "+")
    new $P1473, "ResizablePMCArray"
    push $P1473, $P1472
    .return ($P1473)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("319_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1477_tgt
    .local int rx1477_pos
    .local int rx1477_off
    .local int rx1477_eos
    .local int rx1477_rep
    .local pmc rx1477_cur
    .local pmc rx1477_debug
    (rx1477_cur, rx1477_pos, rx1477_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1477_cur
    .local pmc match
    .lex "$/", match
    length rx1477_eos, rx1477_tgt
    gt rx1477_pos, rx1477_eos, rx1477_done
    set rx1477_off, 0
    lt rx1477_pos, 2, rx1477_start
    sub rx1477_off, rx1477_pos, 1
    substr rx1477_tgt, rx1477_tgt, rx1477_off
  rx1477_start:
    eq $I10, 1, rx1477_restart
    if_null rx1477_debug, debug_1227
    rx1477_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1227:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1481_done
    goto rxscan1481_scan
  rxscan1481_loop:
    (rx1477_pos) = rx1477_cur."from"()
    inc rx1477_pos
    rx1477_cur."!cursor_from"(rx1477_pos)
    ge rx1477_pos, rx1477_eos, rxscan1481_done
  rxscan1481_scan:
    set_addr $I10, rxscan1481_loop
    rx1477_cur."!mark_push"(0, rx1477_pos, $I10)
  rxscan1481_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1482_fail
    rx1477_cur."!mark_push"(0, rx1477_pos, $I10)
  # rx literal  "-"
    add $I11, rx1477_pos, 1
    gt $I11, rx1477_eos, rx1477_fail
    sub $I11, rx1477_pos, rx1477_off
    ord $I11, rx1477_tgt, $I11
    ne $I11, 45, rx1477_fail
    add rx1477_pos, 1
    set_addr $I10, rxcap_1482_fail
    ($I12, $I11) = rx1477_cur."!mark_peek"($I10)
    rx1477_cur."!cursor_pos"($I11)
    ($P10) = rx1477_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1477_pos, "")
    rx1477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1482_done
  rxcap_1482_fail:
    goto rx1477_fail
  rxcap_1482_done:
  # rx subrule "O" subtype=capture negate=
    rx1477_cur."!cursor_pos"(rx1477_pos)
    $P10 = rx1477_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1477_fail
    rx1477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1477_pos = $P10."pos"()
  # rx pass
    rx1477_cur."!cursor_pass"(rx1477_pos, "infix:sym<->")
    if_null rx1477_debug, debug_1228
    rx1477_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1477_pos)
  debug_1228:
    .return (rx1477_cur)
  rx1477_restart:
.annotate 'line', 10
    if_null rx1477_debug, debug_1229
    rx1477_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1229:
  rx1477_fail:
    (rx1477_rep, rx1477_pos, $I10, $P10) = rx1477_cur."!mark_fail"(0)
    lt rx1477_pos, -1, rx1477_done
    eq rx1477_pos, -1, rx1477_fail
    jump $I10
  rx1477_done:
    rx1477_cur."!cursor_fail"()
    if_null rx1477_debug, debug_1230
    rx1477_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1230:
    .return (rx1477_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("320_1303391609.928") :method
.annotate 'line', 10
    $P1479 = self."!PREFIX__!subrule"("O", "-")
    new $P1480, "ResizablePMCArray"
    push $P1480, $P1479
    .return ($P1480)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("321_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1484_tgt
    .local int rx1484_pos
    .local int rx1484_off
    .local int rx1484_eos
    .local int rx1484_rep
    .local pmc rx1484_cur
    .local pmc rx1484_debug
    (rx1484_cur, rx1484_pos, rx1484_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1484_cur
    .local pmc match
    .lex "$/", match
    length rx1484_eos, rx1484_tgt
    gt rx1484_pos, rx1484_eos, rx1484_done
    set rx1484_off, 0
    lt rx1484_pos, 2, rx1484_start
    sub rx1484_off, rx1484_pos, 1
    substr rx1484_tgt, rx1484_tgt, rx1484_off
  rx1484_start:
    eq $I10, 1, rx1484_restart
    if_null rx1484_debug, debug_1231
    rx1484_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1231:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1488_done
    goto rxscan1488_scan
  rxscan1488_loop:
    (rx1484_pos) = rx1484_cur."from"()
    inc rx1484_pos
    rx1484_cur."!cursor_from"(rx1484_pos)
    ge rx1484_pos, rx1484_eos, rxscan1488_done
  rxscan1488_scan:
    set_addr $I10, rxscan1488_loop
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10)
  rxscan1488_done:
.annotate 'line', 657
  # rx subcapture "sym"
    set_addr $I10, rxcap_1489_fail
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1484_pos, 2
    gt $I11, rx1484_eos, rx1484_fail
    sub $I11, rx1484_pos, rx1484_off
    substr $S10, rx1484_tgt, $I11, 2
    ne $S10, "+|", rx1484_fail
    add rx1484_pos, 2
    set_addr $I10, rxcap_1489_fail
    ($I12, $I11) = rx1484_cur."!mark_peek"($I10)
    rx1484_cur."!cursor_pos"($I11)
    ($P10) = rx1484_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1484_pos, "")
    rx1484_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1489_done
  rxcap_1489_fail:
    goto rx1484_fail
  rxcap_1489_done:
  # rx subrule "O" subtype=capture negate=
    rx1484_cur."!cursor_pos"(rx1484_pos)
    $P10 = rx1484_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1484_fail
    rx1484_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1484_pos = $P10."pos"()
  # rx pass
    rx1484_cur."!cursor_pass"(rx1484_pos, "infix:sym<+|>")
    if_null rx1484_debug, debug_1232
    rx1484_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1484_pos)
  debug_1232:
    .return (rx1484_cur)
  rx1484_restart:
.annotate 'line', 10
    if_null rx1484_debug, debug_1233
    rx1484_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1233:
  rx1484_fail:
    (rx1484_rep, rx1484_pos, $I10, $P10) = rx1484_cur."!mark_fail"(0)
    lt rx1484_pos, -1, rx1484_done
    eq rx1484_pos, -1, rx1484_fail
    jump $I10
  rx1484_done:
    rx1484_cur."!cursor_fail"()
    if_null rx1484_debug, debug_1234
    rx1484_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1234:
    .return (rx1484_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("322_1303391609.928") :method
.annotate 'line', 10
    $P1486 = self."!PREFIX__!subrule"("O", "+|")
    new $P1487, "ResizablePMCArray"
    push $P1487, $P1486
    .return ($P1487)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("323_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1491_tgt
    .local int rx1491_pos
    .local int rx1491_off
    .local int rx1491_eos
    .local int rx1491_rep
    .local pmc rx1491_cur
    .local pmc rx1491_debug
    (rx1491_cur, rx1491_pos, rx1491_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1491_cur
    .local pmc match
    .lex "$/", match
    length rx1491_eos, rx1491_tgt
    gt rx1491_pos, rx1491_eos, rx1491_done
    set rx1491_off, 0
    lt rx1491_pos, 2, rx1491_start
    sub rx1491_off, rx1491_pos, 1
    substr rx1491_tgt, rx1491_tgt, rx1491_off
  rx1491_start:
    eq $I10, 1, rx1491_restart
    if_null rx1491_debug, debug_1235
    rx1491_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1235:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1495_done
    goto rxscan1495_scan
  rxscan1495_loop:
    (rx1491_pos) = rx1491_cur."from"()
    inc rx1491_pos
    rx1491_cur."!cursor_from"(rx1491_pos)
    ge rx1491_pos, rx1491_eos, rxscan1495_done
  rxscan1495_scan:
    set_addr $I10, rxscan1495_loop
    rx1491_cur."!mark_push"(0, rx1491_pos, $I10)
  rxscan1495_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1496_fail
    rx1491_cur."!mark_push"(0, rx1491_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1491_pos, 2
    gt $I11, rx1491_eos, rx1491_fail
    sub $I11, rx1491_pos, rx1491_off
    substr $S10, rx1491_tgt, $I11, 2
    ne $S10, "+^", rx1491_fail
    add rx1491_pos, 2
    set_addr $I10, rxcap_1496_fail
    ($I12, $I11) = rx1491_cur."!mark_peek"($I10)
    rx1491_cur."!cursor_pos"($I11)
    ($P10) = rx1491_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1491_pos, "")
    rx1491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1496_done
  rxcap_1496_fail:
    goto rx1491_fail
  rxcap_1496_done:
  # rx subrule "O" subtype=capture negate=
    rx1491_cur."!cursor_pos"(rx1491_pos)
    $P10 = rx1491_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1491_fail
    rx1491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1491_pos = $P10."pos"()
  # rx pass
    rx1491_cur."!cursor_pass"(rx1491_pos, "infix:sym<+^>")
    if_null rx1491_debug, debug_1236
    rx1491_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1491_pos)
  debug_1236:
    .return (rx1491_cur)
  rx1491_restart:
.annotate 'line', 10
    if_null rx1491_debug, debug_1237
    rx1491_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1237:
  rx1491_fail:
    (rx1491_rep, rx1491_pos, $I10, $P10) = rx1491_cur."!mark_fail"(0)
    lt rx1491_pos, -1, rx1491_done
    eq rx1491_pos, -1, rx1491_fail
    jump $I10
  rx1491_done:
    rx1491_cur."!cursor_fail"()
    if_null rx1491_debug, debug_1238
    rx1491_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1238:
    .return (rx1491_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("324_1303391609.928") :method
.annotate 'line', 10
    $P1493 = self."!PREFIX__!subrule"("O", "+^")
    new $P1494, "ResizablePMCArray"
    push $P1494, $P1493
    .return ($P1494)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("325_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1498_tgt
    .local int rx1498_pos
    .local int rx1498_off
    .local int rx1498_eos
    .local int rx1498_rep
    .local pmc rx1498_cur
    .local pmc rx1498_debug
    (rx1498_cur, rx1498_pos, rx1498_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1498_cur
    .local pmc match
    .lex "$/", match
    length rx1498_eos, rx1498_tgt
    gt rx1498_pos, rx1498_eos, rx1498_done
    set rx1498_off, 0
    lt rx1498_pos, 2, rx1498_start
    sub rx1498_off, rx1498_pos, 1
    substr rx1498_tgt, rx1498_tgt, rx1498_off
  rx1498_start:
    eq $I10, 1, rx1498_restart
    if_null rx1498_debug, debug_1239
    rx1498_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1239:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1502_done
    goto rxscan1502_scan
  rxscan1502_loop:
    (rx1498_pos) = rx1498_cur."from"()
    inc rx1498_pos
    rx1498_cur."!cursor_from"(rx1498_pos)
    ge rx1498_pos, rx1498_eos, rxscan1502_done
  rxscan1502_scan:
    set_addr $I10, rxscan1502_loop
    rx1498_cur."!mark_push"(0, rx1498_pos, $I10)
  rxscan1502_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1503_fail
    rx1498_cur."!mark_push"(0, rx1498_pos, $I10)
  # rx literal  "~"
    add $I11, rx1498_pos, 1
    gt $I11, rx1498_eos, rx1498_fail
    sub $I11, rx1498_pos, rx1498_off
    ord $I11, rx1498_tgt, $I11
    ne $I11, 126, rx1498_fail
    add rx1498_pos, 1
    set_addr $I10, rxcap_1503_fail
    ($I12, $I11) = rx1498_cur."!mark_peek"($I10)
    rx1498_cur."!cursor_pos"($I11)
    ($P10) = rx1498_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1498_pos, "")
    rx1498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1503_done
  rxcap_1503_fail:
    goto rx1498_fail
  rxcap_1503_done:
  # rx subrule "O" subtype=capture negate=
    rx1498_cur."!cursor_pos"(rx1498_pos)
    $P10 = rx1498_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1498_fail
    rx1498_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1498_pos = $P10."pos"()
  # rx pass
    rx1498_cur."!cursor_pass"(rx1498_pos, "infix:sym<~>")
    if_null rx1498_debug, debug_1240
    rx1498_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1498_pos)
  debug_1240:
    .return (rx1498_cur)
  rx1498_restart:
.annotate 'line', 10
    if_null rx1498_debug, debug_1241
    rx1498_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1241:
  rx1498_fail:
    (rx1498_rep, rx1498_pos, $I10, $P10) = rx1498_cur."!mark_fail"(0)
    lt rx1498_pos, -1, rx1498_done
    eq rx1498_pos, -1, rx1498_fail
    jump $I10
  rx1498_done:
    rx1498_cur."!cursor_fail"()
    if_null rx1498_debug, debug_1242
    rx1498_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1242:
    .return (rx1498_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("326_1303391609.928") :method
.annotate 'line', 10
    $P1500 = self."!PREFIX__!subrule"("O", "~")
    new $P1501, "ResizablePMCArray"
    push $P1501, $P1500
    .return ($P1501)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("327_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1505_tgt
    .local int rx1505_pos
    .local int rx1505_off
    .local int rx1505_eos
    .local int rx1505_rep
    .local pmc rx1505_cur
    .local pmc rx1505_debug
    (rx1505_cur, rx1505_pos, rx1505_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1505_cur
    .local pmc match
    .lex "$/", match
    length rx1505_eos, rx1505_tgt
    gt rx1505_pos, rx1505_eos, rx1505_done
    set rx1505_off, 0
    lt rx1505_pos, 2, rx1505_start
    sub rx1505_off, rx1505_pos, 1
    substr rx1505_tgt, rx1505_tgt, rx1505_off
  rx1505_start:
    eq $I10, 1, rx1505_restart
    if_null rx1505_debug, debug_1243
    rx1505_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1243:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1509_done
    goto rxscan1509_scan
  rxscan1509_loop:
    (rx1505_pos) = rx1505_cur."from"()
    inc rx1505_pos
    rx1505_cur."!cursor_from"(rx1505_pos)
    ge rx1505_pos, rx1505_eos, rxscan1509_done
  rxscan1509_scan:
    set_addr $I10, rxscan1509_loop
    rx1505_cur."!mark_push"(0, rx1505_pos, $I10)
  rxscan1509_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1510_fail
    rx1505_cur."!mark_push"(0, rx1505_pos, $I10)
  # rx literal  "=="
    add $I11, rx1505_pos, 2
    gt $I11, rx1505_eos, rx1505_fail
    sub $I11, rx1505_pos, rx1505_off
    substr $S10, rx1505_tgt, $I11, 2
    ne $S10, "==", rx1505_fail
    add rx1505_pos, 2
    set_addr $I10, rxcap_1510_fail
    ($I12, $I11) = rx1505_cur."!mark_peek"($I10)
    rx1505_cur."!cursor_pos"($I11)
    ($P10) = rx1505_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1505_pos, "")
    rx1505_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1510_done
  rxcap_1510_fail:
    goto rx1505_fail
  rxcap_1510_done:
  # rx subrule "O" subtype=capture negate=
    rx1505_cur."!cursor_pos"(rx1505_pos)
    $P10 = rx1505_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1505_fail
    rx1505_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1505_pos = $P10."pos"()
  # rx pass
    rx1505_cur."!cursor_pass"(rx1505_pos, "infix:sym<==>")
    if_null rx1505_debug, debug_1244
    rx1505_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1505_pos)
  debug_1244:
    .return (rx1505_cur)
  rx1505_restart:
.annotate 'line', 10
    if_null rx1505_debug, debug_1245
    rx1505_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1245:
  rx1505_fail:
    (rx1505_rep, rx1505_pos, $I10, $P10) = rx1505_cur."!mark_fail"(0)
    lt rx1505_pos, -1, rx1505_done
    eq rx1505_pos, -1, rx1505_fail
    jump $I10
  rx1505_done:
    rx1505_cur."!cursor_fail"()
    if_null rx1505_debug, debug_1246
    rx1505_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1246:
    .return (rx1505_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("328_1303391609.928") :method
.annotate 'line', 10
    $P1507 = self."!PREFIX__!subrule"("O", "==")
    new $P1508, "ResizablePMCArray"
    push $P1508, $P1507
    .return ($P1508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("329_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1512_tgt
    .local int rx1512_pos
    .local int rx1512_off
    .local int rx1512_eos
    .local int rx1512_rep
    .local pmc rx1512_cur
    .local pmc rx1512_debug
    (rx1512_cur, rx1512_pos, rx1512_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1512_cur
    .local pmc match
    .lex "$/", match
    length rx1512_eos, rx1512_tgt
    gt rx1512_pos, rx1512_eos, rx1512_done
    set rx1512_off, 0
    lt rx1512_pos, 2, rx1512_start
    sub rx1512_off, rx1512_pos, 1
    substr rx1512_tgt, rx1512_tgt, rx1512_off
  rx1512_start:
    eq $I10, 1, rx1512_restart
    if_null rx1512_debug, debug_1247
    rx1512_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1247:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1516_done
    goto rxscan1516_scan
  rxscan1516_loop:
    (rx1512_pos) = rx1512_cur."from"()
    inc rx1512_pos
    rx1512_cur."!cursor_from"(rx1512_pos)
    ge rx1512_pos, rx1512_eos, rxscan1516_done
  rxscan1516_scan:
    set_addr $I10, rxscan1516_loop
    rx1512_cur."!mark_push"(0, rx1512_pos, $I10)
  rxscan1516_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1517_fail
    rx1512_cur."!mark_push"(0, rx1512_pos, $I10)
  # rx literal  "!="
    add $I11, rx1512_pos, 2
    gt $I11, rx1512_eos, rx1512_fail
    sub $I11, rx1512_pos, rx1512_off
    substr $S10, rx1512_tgt, $I11, 2
    ne $S10, "!=", rx1512_fail
    add rx1512_pos, 2
    set_addr $I10, rxcap_1517_fail
    ($I12, $I11) = rx1512_cur."!mark_peek"($I10)
    rx1512_cur."!cursor_pos"($I11)
    ($P10) = rx1512_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1512_pos, "")
    rx1512_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1517_done
  rxcap_1517_fail:
    goto rx1512_fail
  rxcap_1517_done:
  # rx subrule "O" subtype=capture negate=
    rx1512_cur."!cursor_pos"(rx1512_pos)
    $P10 = rx1512_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1512_fail
    rx1512_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1512_pos = $P10."pos"()
  # rx pass
    rx1512_cur."!cursor_pass"(rx1512_pos, "infix:sym<!=>")
    if_null rx1512_debug, debug_1248
    rx1512_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1512_pos)
  debug_1248:
    .return (rx1512_cur)
  rx1512_restart:
.annotate 'line', 10
    if_null rx1512_debug, debug_1249
    rx1512_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1249:
  rx1512_fail:
    (rx1512_rep, rx1512_pos, $I10, $P10) = rx1512_cur."!mark_fail"(0)
    lt rx1512_pos, -1, rx1512_done
    eq rx1512_pos, -1, rx1512_fail
    jump $I10
  rx1512_done:
    rx1512_cur."!cursor_fail"()
    if_null rx1512_debug, debug_1250
    rx1512_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1250:
    .return (rx1512_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("330_1303391609.928") :method
.annotate 'line', 10
    $P1514 = self."!PREFIX__!subrule"("O", "!=")
    new $P1515, "ResizablePMCArray"
    push $P1515, $P1514
    .return ($P1515)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("331_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1519_tgt
    .local int rx1519_pos
    .local int rx1519_off
    .local int rx1519_eos
    .local int rx1519_rep
    .local pmc rx1519_cur
    .local pmc rx1519_debug
    (rx1519_cur, rx1519_pos, rx1519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1519_cur
    .local pmc match
    .lex "$/", match
    length rx1519_eos, rx1519_tgt
    gt rx1519_pos, rx1519_eos, rx1519_done
    set rx1519_off, 0
    lt rx1519_pos, 2, rx1519_start
    sub rx1519_off, rx1519_pos, 1
    substr rx1519_tgt, rx1519_tgt, rx1519_off
  rx1519_start:
    eq $I10, 1, rx1519_restart
    if_null rx1519_debug, debug_1251
    rx1519_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1251:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1523_done
    goto rxscan1523_scan
  rxscan1523_loop:
    (rx1519_pos) = rx1519_cur."from"()
    inc rx1519_pos
    rx1519_cur."!cursor_from"(rx1519_pos)
    ge rx1519_pos, rx1519_eos, rxscan1523_done
  rxscan1523_scan:
    set_addr $I10, rxscan1523_loop
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  rxscan1523_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1524_fail
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  # rx literal  "<="
    add $I11, rx1519_pos, 2
    gt $I11, rx1519_eos, rx1519_fail
    sub $I11, rx1519_pos, rx1519_off
    substr $S10, rx1519_tgt, $I11, 2
    ne $S10, "<=", rx1519_fail
    add rx1519_pos, 2
    set_addr $I10, rxcap_1524_fail
    ($I12, $I11) = rx1519_cur."!mark_peek"($I10)
    rx1519_cur."!cursor_pos"($I11)
    ($P10) = rx1519_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1519_pos, "")
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1524_done
  rxcap_1524_fail:
    goto rx1519_fail
  rxcap_1524_done:
  # rx subrule "O" subtype=capture negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1519_fail
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1519_pos = $P10."pos"()
  # rx pass
    rx1519_cur."!cursor_pass"(rx1519_pos, "infix:sym<<=>")
    if_null rx1519_debug, debug_1252
    rx1519_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1519_pos)
  debug_1252:
    .return (rx1519_cur)
  rx1519_restart:
.annotate 'line', 10
    if_null rx1519_debug, debug_1253
    rx1519_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1253:
  rx1519_fail:
    (rx1519_rep, rx1519_pos, $I10, $P10) = rx1519_cur."!mark_fail"(0)
    lt rx1519_pos, -1, rx1519_done
    eq rx1519_pos, -1, rx1519_fail
    jump $I10
  rx1519_done:
    rx1519_cur."!cursor_fail"()
    if_null rx1519_debug, debug_1254
    rx1519_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1254:
    .return (rx1519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("332_1303391609.928") :method
.annotate 'line', 10
    $P1521 = self."!PREFIX__!subrule"("O", "<=")
    new $P1522, "ResizablePMCArray"
    push $P1522, $P1521
    .return ($P1522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("333_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1526_tgt
    .local int rx1526_pos
    .local int rx1526_off
    .local int rx1526_eos
    .local int rx1526_rep
    .local pmc rx1526_cur
    .local pmc rx1526_debug
    (rx1526_cur, rx1526_pos, rx1526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1526_cur
    .local pmc match
    .lex "$/", match
    length rx1526_eos, rx1526_tgt
    gt rx1526_pos, rx1526_eos, rx1526_done
    set rx1526_off, 0
    lt rx1526_pos, 2, rx1526_start
    sub rx1526_off, rx1526_pos, 1
    substr rx1526_tgt, rx1526_tgt, rx1526_off
  rx1526_start:
    eq $I10, 1, rx1526_restart
    if_null rx1526_debug, debug_1255
    rx1526_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1255:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1530_done
    goto rxscan1530_scan
  rxscan1530_loop:
    (rx1526_pos) = rx1526_cur."from"()
    inc rx1526_pos
    rx1526_cur."!cursor_from"(rx1526_pos)
    ge rx1526_pos, rx1526_eos, rxscan1530_done
  rxscan1530_scan:
    set_addr $I10, rxscan1530_loop
    rx1526_cur."!mark_push"(0, rx1526_pos, $I10)
  rxscan1530_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1531_fail
    rx1526_cur."!mark_push"(0, rx1526_pos, $I10)
  # rx literal  ">="
    add $I11, rx1526_pos, 2
    gt $I11, rx1526_eos, rx1526_fail
    sub $I11, rx1526_pos, rx1526_off
    substr $S10, rx1526_tgt, $I11, 2
    ne $S10, ">=", rx1526_fail
    add rx1526_pos, 2
    set_addr $I10, rxcap_1531_fail
    ($I12, $I11) = rx1526_cur."!mark_peek"($I10)
    rx1526_cur."!cursor_pos"($I11)
    ($P10) = rx1526_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1526_pos, "")
    rx1526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1531_done
  rxcap_1531_fail:
    goto rx1526_fail
  rxcap_1531_done:
  # rx subrule "O" subtype=capture negate=
    rx1526_cur."!cursor_pos"(rx1526_pos)
    $P10 = rx1526_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1526_fail
    rx1526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1526_pos = $P10."pos"()
  # rx pass
    rx1526_cur."!cursor_pass"(rx1526_pos, "infix:sym<>=>")
    if_null rx1526_debug, debug_1256
    rx1526_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1526_pos)
  debug_1256:
    .return (rx1526_cur)
  rx1526_restart:
.annotate 'line', 10
    if_null rx1526_debug, debug_1257
    rx1526_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1257:
  rx1526_fail:
    (rx1526_rep, rx1526_pos, $I10, $P10) = rx1526_cur."!mark_fail"(0)
    lt rx1526_pos, -1, rx1526_done
    eq rx1526_pos, -1, rx1526_fail
    jump $I10
  rx1526_done:
    rx1526_cur."!cursor_fail"()
    if_null rx1526_debug, debug_1258
    rx1526_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1258:
    .return (rx1526_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("334_1303391609.928") :method
.annotate 'line', 10
    $P1528 = self."!PREFIX__!subrule"("O", ">=")
    new $P1529, "ResizablePMCArray"
    push $P1529, $P1528
    .return ($P1529)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("335_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1533_tgt
    .local int rx1533_pos
    .local int rx1533_off
    .local int rx1533_eos
    .local int rx1533_rep
    .local pmc rx1533_cur
    .local pmc rx1533_debug
    (rx1533_cur, rx1533_pos, rx1533_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1533_cur
    .local pmc match
    .lex "$/", match
    length rx1533_eos, rx1533_tgt
    gt rx1533_pos, rx1533_eos, rx1533_done
    set rx1533_off, 0
    lt rx1533_pos, 2, rx1533_start
    sub rx1533_off, rx1533_pos, 1
    substr rx1533_tgt, rx1533_tgt, rx1533_off
  rx1533_start:
    eq $I10, 1, rx1533_restart
    if_null rx1533_debug, debug_1259
    rx1533_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1259:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1537_done
    goto rxscan1537_scan
  rxscan1537_loop:
    (rx1533_pos) = rx1533_cur."from"()
    inc rx1533_pos
    rx1533_cur."!cursor_from"(rx1533_pos)
    ge rx1533_pos, rx1533_eos, rxscan1537_done
  rxscan1537_scan:
    set_addr $I10, rxscan1537_loop
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  rxscan1537_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_1538_fail
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  # rx literal  "<"
    add $I11, rx1533_pos, 1
    gt $I11, rx1533_eos, rx1533_fail
    sub $I11, rx1533_pos, rx1533_off
    ord $I11, rx1533_tgt, $I11
    ne $I11, 60, rx1533_fail
    add rx1533_pos, 1
    set_addr $I10, rxcap_1538_fail
    ($I12, $I11) = rx1533_cur."!mark_peek"($I10)
    rx1533_cur."!cursor_pos"($I11)
    ($P10) = rx1533_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1533_pos, "")
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1538_done
  rxcap_1538_fail:
    goto rx1533_fail
  rxcap_1538_done:
  # rx subrule "O" subtype=capture negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1533_fail
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1533_pos = $P10."pos"()
  # rx pass
    rx1533_cur."!cursor_pass"(rx1533_pos, "infix:sym<<>")
    if_null rx1533_debug, debug_1260
    rx1533_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1533_pos)
  debug_1260:
    .return (rx1533_cur)
  rx1533_restart:
.annotate 'line', 10
    if_null rx1533_debug, debug_1261
    rx1533_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1261:
  rx1533_fail:
    (rx1533_rep, rx1533_pos, $I10, $P10) = rx1533_cur."!mark_fail"(0)
    lt rx1533_pos, -1, rx1533_done
    eq rx1533_pos, -1, rx1533_fail
    jump $I10
  rx1533_done:
    rx1533_cur."!cursor_fail"()
    if_null rx1533_debug, debug_1262
    rx1533_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1262:
    .return (rx1533_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("336_1303391609.928") :method
.annotate 'line', 10
    $P1535 = self."!PREFIX__!subrule"("O", "<")
    new $P1536, "ResizablePMCArray"
    push $P1536, $P1535
    .return ($P1536)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("337_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1540_tgt
    .local int rx1540_pos
    .local int rx1540_off
    .local int rx1540_eos
    .local int rx1540_rep
    .local pmc rx1540_cur
    .local pmc rx1540_debug
    (rx1540_cur, rx1540_pos, rx1540_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1540_cur
    .local pmc match
    .lex "$/", match
    length rx1540_eos, rx1540_tgt
    gt rx1540_pos, rx1540_eos, rx1540_done
    set rx1540_off, 0
    lt rx1540_pos, 2, rx1540_start
    sub rx1540_off, rx1540_pos, 1
    substr rx1540_tgt, rx1540_tgt, rx1540_off
  rx1540_start:
    eq $I10, 1, rx1540_restart
    if_null rx1540_debug, debug_1263
    rx1540_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1263:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1544_done
    goto rxscan1544_scan
  rxscan1544_loop:
    (rx1540_pos) = rx1540_cur."from"()
    inc rx1540_pos
    rx1540_cur."!cursor_from"(rx1540_pos)
    ge rx1540_pos, rx1540_eos, rxscan1544_done
  rxscan1544_scan:
    set_addr $I10, rxscan1544_loop
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  rxscan1544_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1545_fail
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  # rx literal  ">"
    add $I11, rx1540_pos, 1
    gt $I11, rx1540_eos, rx1540_fail
    sub $I11, rx1540_pos, rx1540_off
    ord $I11, rx1540_tgt, $I11
    ne $I11, 62, rx1540_fail
    add rx1540_pos, 1
    set_addr $I10, rxcap_1545_fail
    ($I12, $I11) = rx1540_cur."!mark_peek"($I10)
    rx1540_cur."!cursor_pos"($I11)
    ($P10) = rx1540_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1540_pos, "")
    rx1540_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1545_done
  rxcap_1545_fail:
    goto rx1540_fail
  rxcap_1545_done:
  # rx subrule "O" subtype=capture negate=
    rx1540_cur."!cursor_pos"(rx1540_pos)
    $P10 = rx1540_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1540_fail
    rx1540_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1540_pos = $P10."pos"()
  # rx pass
    rx1540_cur."!cursor_pass"(rx1540_pos, "infix:sym<>>")
    if_null rx1540_debug, debug_1264
    rx1540_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1540_pos)
  debug_1264:
    .return (rx1540_cur)
  rx1540_restart:
.annotate 'line', 10
    if_null rx1540_debug, debug_1265
    rx1540_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1265:
  rx1540_fail:
    (rx1540_rep, rx1540_pos, $I10, $P10) = rx1540_cur."!mark_fail"(0)
    lt rx1540_pos, -1, rx1540_done
    eq rx1540_pos, -1, rx1540_fail
    jump $I10
  rx1540_done:
    rx1540_cur."!cursor_fail"()
    if_null rx1540_debug, debug_1266
    rx1540_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1266:
    .return (rx1540_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("338_1303391609.928") :method
.annotate 'line', 10
    $P1542 = self."!PREFIX__!subrule"("O", ">")
    new $P1543, "ResizablePMCArray"
    push $P1543, $P1542
    .return ($P1543)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("339_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1547_tgt
    .local int rx1547_pos
    .local int rx1547_off
    .local int rx1547_eos
    .local int rx1547_rep
    .local pmc rx1547_cur
    .local pmc rx1547_debug
    (rx1547_cur, rx1547_pos, rx1547_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1547_cur
    .local pmc match
    .lex "$/", match
    length rx1547_eos, rx1547_tgt
    gt rx1547_pos, rx1547_eos, rx1547_done
    set rx1547_off, 0
    lt rx1547_pos, 2, rx1547_start
    sub rx1547_off, rx1547_pos, 1
    substr rx1547_tgt, rx1547_tgt, rx1547_off
  rx1547_start:
    eq $I10, 1, rx1547_restart
    if_null rx1547_debug, debug_1267
    rx1547_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1267:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1551_done
    goto rxscan1551_scan
  rxscan1551_loop:
    (rx1547_pos) = rx1547_cur."from"()
    inc rx1547_pos
    rx1547_cur."!cursor_from"(rx1547_pos)
    ge rx1547_pos, rx1547_eos, rxscan1551_done
  rxscan1551_scan:
    set_addr $I10, rxscan1551_loop
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  rxscan1551_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1552_fail
    rx1547_cur."!mark_push"(0, rx1547_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1547_pos, 2
    gt $I11, rx1547_eos, rx1547_fail
    sub $I11, rx1547_pos, rx1547_off
    substr $S10, rx1547_tgt, $I11, 2
    ne $S10, "eq", rx1547_fail
    add rx1547_pos, 2
    set_addr $I10, rxcap_1552_fail
    ($I12, $I11) = rx1547_cur."!mark_peek"($I10)
    rx1547_cur."!cursor_pos"($I11)
    ($P10) = rx1547_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1547_pos, "")
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1552_done
  rxcap_1552_fail:
    goto rx1547_fail
  rxcap_1552_done:
  # rx subrule "O" subtype=capture negate=
    rx1547_cur."!cursor_pos"(rx1547_pos)
    $P10 = rx1547_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1547_fail
    rx1547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1547_pos = $P10."pos"()
  # rx pass
    rx1547_cur."!cursor_pass"(rx1547_pos, "infix:sym<eq>")
    if_null rx1547_debug, debug_1268
    rx1547_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1547_pos)
  debug_1268:
    .return (rx1547_cur)
  rx1547_restart:
.annotate 'line', 10
    if_null rx1547_debug, debug_1269
    rx1547_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1269:
  rx1547_fail:
    (rx1547_rep, rx1547_pos, $I10, $P10) = rx1547_cur."!mark_fail"(0)
    lt rx1547_pos, -1, rx1547_done
    eq rx1547_pos, -1, rx1547_fail
    jump $I10
  rx1547_done:
    rx1547_cur."!cursor_fail"()
    if_null rx1547_debug, debug_1270
    rx1547_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1270:
    .return (rx1547_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("340_1303391609.928") :method
.annotate 'line', 10
    $P1549 = self."!PREFIX__!subrule"("O", "eq")
    new $P1550, "ResizablePMCArray"
    push $P1550, $P1549
    .return ($P1550)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("341_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1554_tgt
    .local int rx1554_pos
    .local int rx1554_off
    .local int rx1554_eos
    .local int rx1554_rep
    .local pmc rx1554_cur
    .local pmc rx1554_debug
    (rx1554_cur, rx1554_pos, rx1554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1554_cur
    .local pmc match
    .lex "$/", match
    length rx1554_eos, rx1554_tgt
    gt rx1554_pos, rx1554_eos, rx1554_done
    set rx1554_off, 0
    lt rx1554_pos, 2, rx1554_start
    sub rx1554_off, rx1554_pos, 1
    substr rx1554_tgt, rx1554_tgt, rx1554_off
  rx1554_start:
    eq $I10, 1, rx1554_restart
    if_null rx1554_debug, debug_1271
    rx1554_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1271:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1558_done
    goto rxscan1558_scan
  rxscan1558_loop:
    (rx1554_pos) = rx1554_cur."from"()
    inc rx1554_pos
    rx1554_cur."!cursor_from"(rx1554_pos)
    ge rx1554_pos, rx1554_eos, rxscan1558_done
  rxscan1558_scan:
    set_addr $I10, rxscan1558_loop
    rx1554_cur."!mark_push"(0, rx1554_pos, $I10)
  rxscan1558_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1559_fail
    rx1554_cur."!mark_push"(0, rx1554_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1554_pos, 2
    gt $I11, rx1554_eos, rx1554_fail
    sub $I11, rx1554_pos, rx1554_off
    substr $S10, rx1554_tgt, $I11, 2
    ne $S10, "ne", rx1554_fail
    add rx1554_pos, 2
    set_addr $I10, rxcap_1559_fail
    ($I12, $I11) = rx1554_cur."!mark_peek"($I10)
    rx1554_cur."!cursor_pos"($I11)
    ($P10) = rx1554_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1554_pos, "")
    rx1554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1559_done
  rxcap_1559_fail:
    goto rx1554_fail
  rxcap_1559_done:
  # rx subrule "O" subtype=capture negate=
    rx1554_cur."!cursor_pos"(rx1554_pos)
    $P10 = rx1554_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1554_fail
    rx1554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1554_pos = $P10."pos"()
  # rx pass
    rx1554_cur."!cursor_pass"(rx1554_pos, "infix:sym<ne>")
    if_null rx1554_debug, debug_1272
    rx1554_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1554_pos)
  debug_1272:
    .return (rx1554_cur)
  rx1554_restart:
.annotate 'line', 10
    if_null rx1554_debug, debug_1273
    rx1554_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1273:
  rx1554_fail:
    (rx1554_rep, rx1554_pos, $I10, $P10) = rx1554_cur."!mark_fail"(0)
    lt rx1554_pos, -1, rx1554_done
    eq rx1554_pos, -1, rx1554_fail
    jump $I10
  rx1554_done:
    rx1554_cur."!cursor_fail"()
    if_null rx1554_debug, debug_1274
    rx1554_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1274:
    .return (rx1554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("342_1303391609.928") :method
.annotate 'line', 10
    $P1556 = self."!PREFIX__!subrule"("O", "ne")
    new $P1557, "ResizablePMCArray"
    push $P1557, $P1556
    .return ($P1557)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("343_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1561_tgt
    .local int rx1561_pos
    .local int rx1561_off
    .local int rx1561_eos
    .local int rx1561_rep
    .local pmc rx1561_cur
    .local pmc rx1561_debug
    (rx1561_cur, rx1561_pos, rx1561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1561_cur
    .local pmc match
    .lex "$/", match
    length rx1561_eos, rx1561_tgt
    gt rx1561_pos, rx1561_eos, rx1561_done
    set rx1561_off, 0
    lt rx1561_pos, 2, rx1561_start
    sub rx1561_off, rx1561_pos, 1
    substr rx1561_tgt, rx1561_tgt, rx1561_off
  rx1561_start:
    eq $I10, 1, rx1561_restart
    if_null rx1561_debug, debug_1275
    rx1561_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1275:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1565_done
    goto rxscan1565_scan
  rxscan1565_loop:
    (rx1561_pos) = rx1561_cur."from"()
    inc rx1561_pos
    rx1561_cur."!cursor_from"(rx1561_pos)
    ge rx1561_pos, rx1561_eos, rxscan1565_done
  rxscan1565_scan:
    set_addr $I10, rxscan1565_loop
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  rxscan1565_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1566_fail
    rx1561_cur."!mark_push"(0, rx1561_pos, $I10)
  # rx literal  "le"
    add $I11, rx1561_pos, 2
    gt $I11, rx1561_eos, rx1561_fail
    sub $I11, rx1561_pos, rx1561_off
    substr $S10, rx1561_tgt, $I11, 2
    ne $S10, "le", rx1561_fail
    add rx1561_pos, 2
    set_addr $I10, rxcap_1566_fail
    ($I12, $I11) = rx1561_cur."!mark_peek"($I10)
    rx1561_cur."!cursor_pos"($I11)
    ($P10) = rx1561_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1561_pos, "")
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1566_done
  rxcap_1566_fail:
    goto rx1561_fail
  rxcap_1566_done:
  # rx subrule "O" subtype=capture negate=
    rx1561_cur."!cursor_pos"(rx1561_pos)
    $P10 = rx1561_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1561_fail
    rx1561_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1561_pos = $P10."pos"()
  # rx pass
    rx1561_cur."!cursor_pass"(rx1561_pos, "infix:sym<le>")
    if_null rx1561_debug, debug_1276
    rx1561_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1561_pos)
  debug_1276:
    .return (rx1561_cur)
  rx1561_restart:
.annotate 'line', 10
    if_null rx1561_debug, debug_1277
    rx1561_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1277:
  rx1561_fail:
    (rx1561_rep, rx1561_pos, $I10, $P10) = rx1561_cur."!mark_fail"(0)
    lt rx1561_pos, -1, rx1561_done
    eq rx1561_pos, -1, rx1561_fail
    jump $I10
  rx1561_done:
    rx1561_cur."!cursor_fail"()
    if_null rx1561_debug, debug_1278
    rx1561_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1278:
    .return (rx1561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("344_1303391609.928") :method
.annotate 'line', 10
    $P1563 = self."!PREFIX__!subrule"("O", "le")
    new $P1564, "ResizablePMCArray"
    push $P1564, $P1563
    .return ($P1564)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("345_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1568_tgt
    .local int rx1568_pos
    .local int rx1568_off
    .local int rx1568_eos
    .local int rx1568_rep
    .local pmc rx1568_cur
    .local pmc rx1568_debug
    (rx1568_cur, rx1568_pos, rx1568_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1568_cur
    .local pmc match
    .lex "$/", match
    length rx1568_eos, rx1568_tgt
    gt rx1568_pos, rx1568_eos, rx1568_done
    set rx1568_off, 0
    lt rx1568_pos, 2, rx1568_start
    sub rx1568_off, rx1568_pos, 1
    substr rx1568_tgt, rx1568_tgt, rx1568_off
  rx1568_start:
    eq $I10, 1, rx1568_restart
    if_null rx1568_debug, debug_1279
    rx1568_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1279:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1572_done
    goto rxscan1572_scan
  rxscan1572_loop:
    (rx1568_pos) = rx1568_cur."from"()
    inc rx1568_pos
    rx1568_cur."!cursor_from"(rx1568_pos)
    ge rx1568_pos, rx1568_eos, rxscan1572_done
  rxscan1572_scan:
    set_addr $I10, rxscan1572_loop
    rx1568_cur."!mark_push"(0, rx1568_pos, $I10)
  rxscan1572_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1573_fail
    rx1568_cur."!mark_push"(0, rx1568_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1568_pos, 2
    gt $I11, rx1568_eos, rx1568_fail
    sub $I11, rx1568_pos, rx1568_off
    substr $S10, rx1568_tgt, $I11, 2
    ne $S10, "ge", rx1568_fail
    add rx1568_pos, 2
    set_addr $I10, rxcap_1573_fail
    ($I12, $I11) = rx1568_cur."!mark_peek"($I10)
    rx1568_cur."!cursor_pos"($I11)
    ($P10) = rx1568_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1568_pos, "")
    rx1568_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1573_done
  rxcap_1573_fail:
    goto rx1568_fail
  rxcap_1573_done:
  # rx subrule "O" subtype=capture negate=
    rx1568_cur."!cursor_pos"(rx1568_pos)
    $P10 = rx1568_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1568_fail
    rx1568_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1568_pos = $P10."pos"()
  # rx pass
    rx1568_cur."!cursor_pass"(rx1568_pos, "infix:sym<ge>")
    if_null rx1568_debug, debug_1280
    rx1568_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1568_pos)
  debug_1280:
    .return (rx1568_cur)
  rx1568_restart:
.annotate 'line', 10
    if_null rx1568_debug, debug_1281
    rx1568_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1281:
  rx1568_fail:
    (rx1568_rep, rx1568_pos, $I10, $P10) = rx1568_cur."!mark_fail"(0)
    lt rx1568_pos, -1, rx1568_done
    eq rx1568_pos, -1, rx1568_fail
    jump $I10
  rx1568_done:
    rx1568_cur."!cursor_fail"()
    if_null rx1568_debug, debug_1282
    rx1568_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1282:
    .return (rx1568_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("346_1303391609.928") :method
.annotate 'line', 10
    $P1570 = self."!PREFIX__!subrule"("O", "ge")
    new $P1571, "ResizablePMCArray"
    push $P1571, $P1570
    .return ($P1571)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("347_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1575_tgt
    .local int rx1575_pos
    .local int rx1575_off
    .local int rx1575_eos
    .local int rx1575_rep
    .local pmc rx1575_cur
    .local pmc rx1575_debug
    (rx1575_cur, rx1575_pos, rx1575_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1575_cur
    .local pmc match
    .lex "$/", match
    length rx1575_eos, rx1575_tgt
    gt rx1575_pos, rx1575_eos, rx1575_done
    set rx1575_off, 0
    lt rx1575_pos, 2, rx1575_start
    sub rx1575_off, rx1575_pos, 1
    substr rx1575_tgt, rx1575_tgt, rx1575_off
  rx1575_start:
    eq $I10, 1, rx1575_restart
    if_null rx1575_debug, debug_1283
    rx1575_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1283:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1579_done
    goto rxscan1579_scan
  rxscan1579_loop:
    (rx1575_pos) = rx1575_cur."from"()
    inc rx1575_pos
    rx1575_cur."!cursor_from"(rx1575_pos)
    ge rx1575_pos, rx1575_eos, rxscan1579_done
  rxscan1579_scan:
    set_addr $I10, rxscan1579_loop
    rx1575_cur."!mark_push"(0, rx1575_pos, $I10)
  rxscan1579_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1580_fail
    rx1575_cur."!mark_push"(0, rx1575_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1575_pos, 2
    gt $I11, rx1575_eos, rx1575_fail
    sub $I11, rx1575_pos, rx1575_off
    substr $S10, rx1575_tgt, $I11, 2
    ne $S10, "lt", rx1575_fail
    add rx1575_pos, 2
    set_addr $I10, rxcap_1580_fail
    ($I12, $I11) = rx1575_cur."!mark_peek"($I10)
    rx1575_cur."!cursor_pos"($I11)
    ($P10) = rx1575_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1575_pos, "")
    rx1575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1580_done
  rxcap_1580_fail:
    goto rx1575_fail
  rxcap_1580_done:
  # rx subrule "O" subtype=capture negate=
    rx1575_cur."!cursor_pos"(rx1575_pos)
    $P10 = rx1575_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1575_fail
    rx1575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1575_pos = $P10."pos"()
  # rx pass
    rx1575_cur."!cursor_pass"(rx1575_pos, "infix:sym<lt>")
    if_null rx1575_debug, debug_1284
    rx1575_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1575_pos)
  debug_1284:
    .return (rx1575_cur)
  rx1575_restart:
.annotate 'line', 10
    if_null rx1575_debug, debug_1285
    rx1575_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1285:
  rx1575_fail:
    (rx1575_rep, rx1575_pos, $I10, $P10) = rx1575_cur."!mark_fail"(0)
    lt rx1575_pos, -1, rx1575_done
    eq rx1575_pos, -1, rx1575_fail
    jump $I10
  rx1575_done:
    rx1575_cur."!cursor_fail"()
    if_null rx1575_debug, debug_1286
    rx1575_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1286:
    .return (rx1575_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("348_1303391609.928") :method
.annotate 'line', 10
    $P1577 = self."!PREFIX__!subrule"("O", "lt")
    new $P1578, "ResizablePMCArray"
    push $P1578, $P1577
    .return ($P1578)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("349_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1582_tgt
    .local int rx1582_pos
    .local int rx1582_off
    .local int rx1582_eos
    .local int rx1582_rep
    .local pmc rx1582_cur
    .local pmc rx1582_debug
    (rx1582_cur, rx1582_pos, rx1582_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1582_cur
    .local pmc match
    .lex "$/", match
    length rx1582_eos, rx1582_tgt
    gt rx1582_pos, rx1582_eos, rx1582_done
    set rx1582_off, 0
    lt rx1582_pos, 2, rx1582_start
    sub rx1582_off, rx1582_pos, 1
    substr rx1582_tgt, rx1582_tgt, rx1582_off
  rx1582_start:
    eq $I10, 1, rx1582_restart
    if_null rx1582_debug, debug_1287
    rx1582_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1287:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1586_done
    goto rxscan1586_scan
  rxscan1586_loop:
    (rx1582_pos) = rx1582_cur."from"()
    inc rx1582_pos
    rx1582_cur."!cursor_from"(rx1582_pos)
    ge rx1582_pos, rx1582_eos, rxscan1586_done
  rxscan1586_scan:
    set_addr $I10, rxscan1586_loop
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  rxscan1586_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1587_fail
    rx1582_cur."!mark_push"(0, rx1582_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1582_pos, 2
    gt $I11, rx1582_eos, rx1582_fail
    sub $I11, rx1582_pos, rx1582_off
    substr $S10, rx1582_tgt, $I11, 2
    ne $S10, "gt", rx1582_fail
    add rx1582_pos, 2
    set_addr $I10, rxcap_1587_fail
    ($I12, $I11) = rx1582_cur."!mark_peek"($I10)
    rx1582_cur."!cursor_pos"($I11)
    ($P10) = rx1582_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1582_pos, "")
    rx1582_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1587_done
  rxcap_1587_fail:
    goto rx1582_fail
  rxcap_1587_done:
  # rx subrule "O" subtype=capture negate=
    rx1582_cur."!cursor_pos"(rx1582_pos)
    $P10 = rx1582_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1582_fail
    rx1582_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1582_pos = $P10."pos"()
  # rx pass
    rx1582_cur."!cursor_pass"(rx1582_pos, "infix:sym<gt>")
    if_null rx1582_debug, debug_1288
    rx1582_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1582_pos)
  debug_1288:
    .return (rx1582_cur)
  rx1582_restart:
.annotate 'line', 10
    if_null rx1582_debug, debug_1289
    rx1582_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1289:
  rx1582_fail:
    (rx1582_rep, rx1582_pos, $I10, $P10) = rx1582_cur."!mark_fail"(0)
    lt rx1582_pos, -1, rx1582_done
    eq rx1582_pos, -1, rx1582_fail
    jump $I10
  rx1582_done:
    rx1582_cur."!cursor_fail"()
    if_null rx1582_debug, debug_1290
    rx1582_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1290:
    .return (rx1582_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("350_1303391609.928") :method
.annotate 'line', 10
    $P1584 = self."!PREFIX__!subrule"("O", "gt")
    new $P1585, "ResizablePMCArray"
    push $P1585, $P1584
    .return ($P1585)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("351_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1589_tgt
    .local int rx1589_pos
    .local int rx1589_off
    .local int rx1589_eos
    .local int rx1589_rep
    .local pmc rx1589_cur
    .local pmc rx1589_debug
    (rx1589_cur, rx1589_pos, rx1589_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1589_cur
    .local pmc match
    .lex "$/", match
    length rx1589_eos, rx1589_tgt
    gt rx1589_pos, rx1589_eos, rx1589_done
    set rx1589_off, 0
    lt rx1589_pos, 2, rx1589_start
    sub rx1589_off, rx1589_pos, 1
    substr rx1589_tgt, rx1589_tgt, rx1589_off
  rx1589_start:
    eq $I10, 1, rx1589_restart
    if_null rx1589_debug, debug_1291
    rx1589_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1291:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1593_done
    goto rxscan1593_scan
  rxscan1593_loop:
    (rx1589_pos) = rx1589_cur."from"()
    inc rx1589_pos
    rx1589_cur."!cursor_from"(rx1589_pos)
    ge rx1589_pos, rx1589_eos, rxscan1593_done
  rxscan1593_scan:
    set_addr $I10, rxscan1593_loop
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  rxscan1593_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1594_fail
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1589_pos, 3
    gt $I11, rx1589_eos, rx1589_fail
    sub $I11, rx1589_pos, rx1589_off
    substr $S10, rx1589_tgt, $I11, 3
    ne $S10, "=:=", rx1589_fail
    add rx1589_pos, 3
    set_addr $I10, rxcap_1594_fail
    ($I12, $I11) = rx1589_cur."!mark_peek"($I10)
    rx1589_cur."!cursor_pos"($I11)
    ($P10) = rx1589_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1589_pos, "")
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1594_done
  rxcap_1594_fail:
    goto rx1589_fail
  rxcap_1594_done:
  # rx subrule "O" subtype=capture negate=
    rx1589_cur."!cursor_pos"(rx1589_pos)
    $P10 = rx1589_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1589_fail
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1589_pos = $P10."pos"()
  # rx pass
    rx1589_cur."!cursor_pass"(rx1589_pos, "infix:sym<=:=>")
    if_null rx1589_debug, debug_1292
    rx1589_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1589_pos)
  debug_1292:
    .return (rx1589_cur)
  rx1589_restart:
.annotate 'line', 10
    if_null rx1589_debug, debug_1293
    rx1589_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1293:
  rx1589_fail:
    (rx1589_rep, rx1589_pos, $I10, $P10) = rx1589_cur."!mark_fail"(0)
    lt rx1589_pos, -1, rx1589_done
    eq rx1589_pos, -1, rx1589_fail
    jump $I10
  rx1589_done:
    rx1589_cur."!cursor_fail"()
    if_null rx1589_debug, debug_1294
    rx1589_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1294:
    .return (rx1589_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("352_1303391609.928") :method
.annotate 'line', 10
    $P1591 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1592, "ResizablePMCArray"
    push $P1592, $P1591
    .return ($P1592)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("353_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1596_tgt
    .local int rx1596_pos
    .local int rx1596_off
    .local int rx1596_eos
    .local int rx1596_rep
    .local pmc rx1596_cur
    .local pmc rx1596_debug
    (rx1596_cur, rx1596_pos, rx1596_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1596_cur
    .local pmc match
    .lex "$/", match
    length rx1596_eos, rx1596_tgt
    gt rx1596_pos, rx1596_eos, rx1596_done
    set rx1596_off, 0
    lt rx1596_pos, 2, rx1596_start
    sub rx1596_off, rx1596_pos, 1
    substr rx1596_tgt, rx1596_tgt, rx1596_off
  rx1596_start:
    eq $I10, 1, rx1596_restart
    if_null rx1596_debug, debug_1295
    rx1596_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1295:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1600_done
    goto rxscan1600_scan
  rxscan1600_loop:
    (rx1596_pos) = rx1596_cur."from"()
    inc rx1596_pos
    rx1596_cur."!cursor_from"(rx1596_pos)
    ge rx1596_pos, rx1596_eos, rxscan1600_done
  rxscan1600_scan:
    set_addr $I10, rxscan1600_loop
    rx1596_cur."!mark_push"(0, rx1596_pos, $I10)
  rxscan1600_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1601_fail
    rx1596_cur."!mark_push"(0, rx1596_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1596_pos, 2
    gt $I11, rx1596_eos, rx1596_fail
    sub $I11, rx1596_pos, rx1596_off
    substr $S10, rx1596_tgt, $I11, 2
    ne $S10, "~~", rx1596_fail
    add rx1596_pos, 2
    set_addr $I10, rxcap_1601_fail
    ($I12, $I11) = rx1596_cur."!mark_peek"($I10)
    rx1596_cur."!cursor_pos"($I11)
    ($P10) = rx1596_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1596_pos, "")
    rx1596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1601_done
  rxcap_1601_fail:
    goto rx1596_fail
  rxcap_1601_done:
  # rx subrule "O" subtype=capture negate=
    rx1596_cur."!cursor_pos"(rx1596_pos)
    $P10 = rx1596_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1596_fail
    rx1596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1596_pos = $P10."pos"()
  # rx pass
    rx1596_cur."!cursor_pass"(rx1596_pos, "infix:sym<~~>")
    if_null rx1596_debug, debug_1296
    rx1596_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1596_pos)
  debug_1296:
    .return (rx1596_cur)
  rx1596_restart:
.annotate 'line', 10
    if_null rx1596_debug, debug_1297
    rx1596_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1297:
  rx1596_fail:
    (rx1596_rep, rx1596_pos, $I10, $P10) = rx1596_cur."!mark_fail"(0)
    lt rx1596_pos, -1, rx1596_done
    eq rx1596_pos, -1, rx1596_fail
    jump $I10
  rx1596_done:
    rx1596_cur."!cursor_fail"()
    if_null rx1596_debug, debug_1298
    rx1596_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1298:
    .return (rx1596_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("354_1303391609.928") :method
.annotate 'line', 10
    $P1598 = self."!PREFIX__!subrule"("O", "~~")
    new $P1599, "ResizablePMCArray"
    push $P1599, $P1598
    .return ($P1599)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("355_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1603_tgt
    .local int rx1603_pos
    .local int rx1603_off
    .local int rx1603_eos
    .local int rx1603_rep
    .local pmc rx1603_cur
    .local pmc rx1603_debug
    (rx1603_cur, rx1603_pos, rx1603_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1603_cur
    .local pmc match
    .lex "$/", match
    length rx1603_eos, rx1603_tgt
    gt rx1603_pos, rx1603_eos, rx1603_done
    set rx1603_off, 0
    lt rx1603_pos, 2, rx1603_start
    sub rx1603_off, rx1603_pos, 1
    substr rx1603_tgt, rx1603_tgt, rx1603_off
  rx1603_start:
    eq $I10, 1, rx1603_restart
    if_null rx1603_debug, debug_1299
    rx1603_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1299:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1607_done
    goto rxscan1607_scan
  rxscan1607_loop:
    (rx1603_pos) = rx1603_cur."from"()
    inc rx1603_pos
    rx1603_cur."!cursor_from"(rx1603_pos)
    ge rx1603_pos, rx1603_eos, rxscan1607_done
  rxscan1607_scan:
    set_addr $I10, rxscan1607_loop
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  rxscan1607_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1608_fail
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1603_pos, 2
    gt $I11, rx1603_eos, rx1603_fail
    sub $I11, rx1603_pos, rx1603_off
    substr $S10, rx1603_tgt, $I11, 2
    ne $S10, "&&", rx1603_fail
    add rx1603_pos, 2
    set_addr $I10, rxcap_1608_fail
    ($I12, $I11) = rx1603_cur."!mark_peek"($I10)
    rx1603_cur."!cursor_pos"($I11)
    ($P10) = rx1603_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1603_pos, "")
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1608_done
  rxcap_1608_fail:
    goto rx1603_fail
  rxcap_1608_done:
  # rx subrule "O" subtype=capture negate=
    rx1603_cur."!cursor_pos"(rx1603_pos)
    $P10 = rx1603_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1603_fail
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1603_pos = $P10."pos"()
  # rx pass
    rx1603_cur."!cursor_pass"(rx1603_pos, "infix:sym<&&>")
    if_null rx1603_debug, debug_1300
    rx1603_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1603_pos)
  debug_1300:
    .return (rx1603_cur)
  rx1603_restart:
.annotate 'line', 10
    if_null rx1603_debug, debug_1301
    rx1603_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1301:
  rx1603_fail:
    (rx1603_rep, rx1603_pos, $I10, $P10) = rx1603_cur."!mark_fail"(0)
    lt rx1603_pos, -1, rx1603_done
    eq rx1603_pos, -1, rx1603_fail
    jump $I10
  rx1603_done:
    rx1603_cur."!cursor_fail"()
    if_null rx1603_debug, debug_1302
    rx1603_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1302:
    .return (rx1603_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("356_1303391609.928") :method
.annotate 'line', 10
    $P1605 = self."!PREFIX__!subrule"("O", "&&")
    new $P1606, "ResizablePMCArray"
    push $P1606, $P1605
    .return ($P1606)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("357_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1610_tgt
    .local int rx1610_pos
    .local int rx1610_off
    .local int rx1610_eos
    .local int rx1610_rep
    .local pmc rx1610_cur
    .local pmc rx1610_debug
    (rx1610_cur, rx1610_pos, rx1610_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1610_cur
    .local pmc match
    .lex "$/", match
    length rx1610_eos, rx1610_tgt
    gt rx1610_pos, rx1610_eos, rx1610_done
    set rx1610_off, 0
    lt rx1610_pos, 2, rx1610_start
    sub rx1610_off, rx1610_pos, 1
    substr rx1610_tgt, rx1610_tgt, rx1610_off
  rx1610_start:
    eq $I10, 1, rx1610_restart
    if_null rx1610_debug, debug_1303
    rx1610_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1303:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1614_done
    goto rxscan1614_scan
  rxscan1614_loop:
    (rx1610_pos) = rx1610_cur."from"()
    inc rx1610_pos
    rx1610_cur."!cursor_from"(rx1610_pos)
    ge rx1610_pos, rx1610_eos, rxscan1614_done
  rxscan1614_scan:
    set_addr $I10, rxscan1614_loop
    rx1610_cur."!mark_push"(0, rx1610_pos, $I10)
  rxscan1614_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1615_fail
    rx1610_cur."!mark_push"(0, rx1610_pos, $I10)
  # rx literal  "||"
    add $I11, rx1610_pos, 2
    gt $I11, rx1610_eos, rx1610_fail
    sub $I11, rx1610_pos, rx1610_off
    substr $S10, rx1610_tgt, $I11, 2
    ne $S10, "||", rx1610_fail
    add rx1610_pos, 2
    set_addr $I10, rxcap_1615_fail
    ($I12, $I11) = rx1610_cur."!mark_peek"($I10)
    rx1610_cur."!cursor_pos"($I11)
    ($P10) = rx1610_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1610_pos, "")
    rx1610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1615_done
  rxcap_1615_fail:
    goto rx1610_fail
  rxcap_1615_done:
  # rx subrule "O" subtype=capture negate=
    rx1610_cur."!cursor_pos"(rx1610_pos)
    $P10 = rx1610_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1610_fail
    rx1610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1610_pos = $P10."pos"()
  # rx pass
    rx1610_cur."!cursor_pass"(rx1610_pos, "infix:sym<||>")
    if_null rx1610_debug, debug_1304
    rx1610_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1610_pos)
  debug_1304:
    .return (rx1610_cur)
  rx1610_restart:
.annotate 'line', 10
    if_null rx1610_debug, debug_1305
    rx1610_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1305:
  rx1610_fail:
    (rx1610_rep, rx1610_pos, $I10, $P10) = rx1610_cur."!mark_fail"(0)
    lt rx1610_pos, -1, rx1610_done
    eq rx1610_pos, -1, rx1610_fail
    jump $I10
  rx1610_done:
    rx1610_cur."!cursor_fail"()
    if_null rx1610_debug, debug_1306
    rx1610_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1306:
    .return (rx1610_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("358_1303391609.928") :method
.annotate 'line', 10
    $P1612 = self."!PREFIX__!subrule"("O", "||")
    new $P1613, "ResizablePMCArray"
    push $P1613, $P1612
    .return ($P1613)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("359_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1617_tgt
    .local int rx1617_pos
    .local int rx1617_off
    .local int rx1617_eos
    .local int rx1617_rep
    .local pmc rx1617_cur
    .local pmc rx1617_debug
    (rx1617_cur, rx1617_pos, rx1617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1617_cur
    .local pmc match
    .lex "$/", match
    length rx1617_eos, rx1617_tgt
    gt rx1617_pos, rx1617_eos, rx1617_done
    set rx1617_off, 0
    lt rx1617_pos, 2, rx1617_start
    sub rx1617_off, rx1617_pos, 1
    substr rx1617_tgt, rx1617_tgt, rx1617_off
  rx1617_start:
    eq $I10, 1, rx1617_restart
    if_null rx1617_debug, debug_1307
    rx1617_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1307:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1621_done
    goto rxscan1621_scan
  rxscan1621_loop:
    (rx1617_pos) = rx1617_cur."from"()
    inc rx1617_pos
    rx1617_cur."!cursor_from"(rx1617_pos)
    ge rx1617_pos, rx1617_eos, rxscan1621_done
  rxscan1621_scan:
    set_addr $I10, rxscan1621_loop
    rx1617_cur."!mark_push"(0, rx1617_pos, $I10)
  rxscan1621_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1622_fail
    rx1617_cur."!mark_push"(0, rx1617_pos, $I10)
  # rx literal  "//"
    add $I11, rx1617_pos, 2
    gt $I11, rx1617_eos, rx1617_fail
    sub $I11, rx1617_pos, rx1617_off
    substr $S10, rx1617_tgt, $I11, 2
    ne $S10, "//", rx1617_fail
    add rx1617_pos, 2
    set_addr $I10, rxcap_1622_fail
    ($I12, $I11) = rx1617_cur."!mark_peek"($I10)
    rx1617_cur."!cursor_pos"($I11)
    ($P10) = rx1617_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1617_pos, "")
    rx1617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1622_done
  rxcap_1622_fail:
    goto rx1617_fail
  rxcap_1622_done:
  # rx subrule "O" subtype=capture negate=
    rx1617_cur."!cursor_pos"(rx1617_pos)
    $P10 = rx1617_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1617_fail
    rx1617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1617_pos = $P10."pos"()
  # rx pass
    rx1617_cur."!cursor_pass"(rx1617_pos, "infix:sym<//>")
    if_null rx1617_debug, debug_1308
    rx1617_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1617_pos)
  debug_1308:
    .return (rx1617_cur)
  rx1617_restart:
.annotate 'line', 10
    if_null rx1617_debug, debug_1309
    rx1617_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1309:
  rx1617_fail:
    (rx1617_rep, rx1617_pos, $I10, $P10) = rx1617_cur."!mark_fail"(0)
    lt rx1617_pos, -1, rx1617_done
    eq rx1617_pos, -1, rx1617_fail
    jump $I10
  rx1617_done:
    rx1617_cur."!cursor_fail"()
    if_null rx1617_debug, debug_1310
    rx1617_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1310:
    .return (rx1617_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("360_1303391609.928") :method
.annotate 'line', 10
    $P1619 = self."!PREFIX__!subrule"("O", "//")
    new $P1620, "ResizablePMCArray"
    push $P1620, $P1619
    .return ($P1620)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("361_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1624_tgt
    .local int rx1624_pos
    .local int rx1624_off
    .local int rx1624_eos
    .local int rx1624_rep
    .local pmc rx1624_cur
    .local pmc rx1624_debug
    (rx1624_cur, rx1624_pos, rx1624_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1624_cur
    .local pmc match
    .lex "$/", match
    length rx1624_eos, rx1624_tgt
    gt rx1624_pos, rx1624_eos, rx1624_done
    set rx1624_off, 0
    lt rx1624_pos, 2, rx1624_start
    sub rx1624_off, rx1624_pos, 1
    substr rx1624_tgt, rx1624_tgt, rx1624_off
  rx1624_start:
    eq $I10, 1, rx1624_restart
    if_null rx1624_debug, debug_1311
    rx1624_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1311:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1628_done
    goto rxscan1628_scan
  rxscan1628_loop:
    (rx1624_pos) = rx1624_cur."from"()
    inc rx1624_pos
    rx1624_cur."!cursor_from"(rx1624_pos)
    ge rx1624_pos, rx1624_eos, rxscan1628_done
  rxscan1628_scan:
    set_addr $I10, rxscan1628_loop
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  rxscan1628_done:
.annotate 'line', 683
  # rx literal  "??"
    add $I11, rx1624_pos, 2
    gt $I11, rx1624_eos, rx1624_fail
    sub $I11, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I11, 2
    ne $S10, "??", rx1624_fail
    add rx1624_pos, 2
.annotate 'line', 684
  # rx subrule "ws" subtype=method negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."ws"()
    unless $P10, rx1624_fail
    rx1624_pos = $P10."pos"()
.annotate 'line', 685
  # rx subrule "EXPR" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."EXPR"("i=")
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1624_pos = $P10."pos"()
.annotate 'line', 686
  # rx literal  "!!"
    add $I11, rx1624_pos, 2
    gt $I11, rx1624_eos, rx1624_fail
    sub $I11, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I11, 2
    ne $S10, "!!", rx1624_fail
    add rx1624_pos, 2
.annotate 'line', 687
  # rx subrule "O" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1624_pos = $P10."pos"()
.annotate 'line', 682
  # rx pass
    rx1624_cur."!cursor_pass"(rx1624_pos, "infix:sym<?? !!>")
    if_null rx1624_debug, debug_1312
    rx1624_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1624_pos)
  debug_1312:
    .return (rx1624_cur)
  rx1624_restart:
.annotate 'line', 10
    if_null rx1624_debug, debug_1313
    rx1624_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1313:
  rx1624_fail:
    (rx1624_rep, rx1624_pos, $I10, $P10) = rx1624_cur."!mark_fail"(0)
    lt rx1624_pos, -1, rx1624_done
    eq rx1624_pos, -1, rx1624_fail
    jump $I10
  rx1624_done:
    rx1624_cur."!cursor_fail"()
    if_null rx1624_debug, debug_1314
    rx1624_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1314:
    .return (rx1624_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("362_1303391609.928") :method
.annotate 'line', 10
    $P1626 = self."!PREFIX__!subrule"("ws", "??")
    new $P1627, "ResizablePMCArray"
    push $P1627, $P1626
    .return ($P1627)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("363_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1630_tgt
    .local int rx1630_pos
    .local int rx1630_off
    .local int rx1630_eos
    .local int rx1630_rep
    .local pmc rx1630_cur
    .local pmc rx1630_debug
    (rx1630_cur, rx1630_pos, rx1630_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1630_cur
    .local pmc match
    .lex "$/", match
    length rx1630_eos, rx1630_tgt
    gt rx1630_pos, rx1630_eos, rx1630_done
    set rx1630_off, 0
    lt rx1630_pos, 2, rx1630_start
    sub rx1630_off, rx1630_pos, 1
    substr rx1630_tgt, rx1630_tgt, rx1630_off
  rx1630_start:
    eq $I10, 1, rx1630_restart
    if_null rx1630_debug, debug_1315
    rx1630_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1315:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1634_done
    goto rxscan1634_scan
  rxscan1634_loop:
    (rx1630_pos) = rx1630_cur."from"()
    inc rx1630_pos
    rx1630_cur."!cursor_from"(rx1630_pos)
    ge rx1630_pos, rx1630_eos, rxscan1634_done
  rxscan1634_scan:
    set_addr $I10, rxscan1634_loop
    rx1630_cur."!mark_push"(0, rx1630_pos, $I10)
  rxscan1634_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1635_fail
    rx1630_cur."!mark_push"(0, rx1630_pos, $I10)
  # rx literal  "="
    add $I11, rx1630_pos, 1
    gt $I11, rx1630_eos, rx1630_fail
    sub $I11, rx1630_pos, rx1630_off
    ord $I11, rx1630_tgt, $I11
    ne $I11, 61, rx1630_fail
    add rx1630_pos, 1
    set_addr $I10, rxcap_1635_fail
    ($I12, $I11) = rx1630_cur."!mark_peek"($I10)
    rx1630_cur."!cursor_pos"($I11)
    ($P10) = rx1630_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1630_pos, "")
    rx1630_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1635_done
  rxcap_1635_fail:
    goto rx1630_fail
  rxcap_1635_done:
  # rx subrule "panic" subtype=method negate=
    rx1630_cur."!cursor_pos"(rx1630_pos)
    $P10 = rx1630_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1630_fail
    rx1630_pos = $P10."pos"()
.annotate 'line', 690
  # rx pass
    rx1630_cur."!cursor_pass"(rx1630_pos, "infix:sym<=>")
    if_null rx1630_debug, debug_1316
    rx1630_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1630_pos)
  debug_1316:
    .return (rx1630_cur)
  rx1630_restart:
.annotate 'line', 10
    if_null rx1630_debug, debug_1317
    rx1630_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1317:
  rx1630_fail:
    (rx1630_rep, rx1630_pos, $I10, $P10) = rx1630_cur."!mark_fail"(0)
    lt rx1630_pos, -1, rx1630_done
    eq rx1630_pos, -1, rx1630_fail
    jump $I10
  rx1630_done:
    rx1630_cur."!cursor_fail"()
    if_null rx1630_debug, debug_1318
    rx1630_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1318:
    .return (rx1630_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("364_1303391609.928") :method
.annotate 'line', 10
    $P1632 = self."!PREFIX__!subrule"("panic", "=")
    new $P1633, "ResizablePMCArray"
    push $P1633, $P1632
    .return ($P1633)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("365_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1637_tgt
    .local int rx1637_pos
    .local int rx1637_off
    .local int rx1637_eos
    .local int rx1637_rep
    .local pmc rx1637_cur
    .local pmc rx1637_debug
    (rx1637_cur, rx1637_pos, rx1637_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1637_cur
    .local pmc match
    .lex "$/", match
    length rx1637_eos, rx1637_tgt
    gt rx1637_pos, rx1637_eos, rx1637_done
    set rx1637_off, 0
    lt rx1637_pos, 2, rx1637_start
    sub rx1637_off, rx1637_pos, 1
    substr rx1637_tgt, rx1637_tgt, rx1637_off
  rx1637_start:
    eq $I10, 1, rx1637_restart
    if_null rx1637_debug, debug_1319
    rx1637_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1319:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1641_done
    goto rxscan1641_scan
  rxscan1641_loop:
    (rx1637_pos) = rx1637_cur."from"()
    inc rx1637_pos
    rx1637_cur."!cursor_from"(rx1637_pos)
    ge rx1637_pos, rx1637_eos, rxscan1641_done
  rxscan1641_scan:
    set_addr $I10, rxscan1641_loop
    rx1637_cur."!mark_push"(0, rx1637_pos, $I10)
  rxscan1641_done:
.annotate 'line', 693
  # rx subcapture "sym"
    set_addr $I10, rxcap_1642_fail
    rx1637_cur."!mark_push"(0, rx1637_pos, $I10)
  # rx literal  ":="
    add $I11, rx1637_pos, 2
    gt $I11, rx1637_eos, rx1637_fail
    sub $I11, rx1637_pos, rx1637_off
    substr $S10, rx1637_tgt, $I11, 2
    ne $S10, ":=", rx1637_fail
    add rx1637_pos, 2
    set_addr $I10, rxcap_1642_fail
    ($I12, $I11) = rx1637_cur."!mark_peek"($I10)
    rx1637_cur."!cursor_pos"($I11)
    ($P10) = rx1637_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1637_pos, "")
    rx1637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1642_done
  rxcap_1642_fail:
    goto rx1637_fail
  rxcap_1642_done:
  # rx subrule "O" subtype=capture negate=
    rx1637_cur."!cursor_pos"(rx1637_pos)
    $P10 = rx1637_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1637_fail
    rx1637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1637_pos = $P10."pos"()
  # rx pass
    rx1637_cur."!cursor_pass"(rx1637_pos, "infix:sym<:=>")
    if_null rx1637_debug, debug_1320
    rx1637_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1637_pos)
  debug_1320:
    .return (rx1637_cur)
  rx1637_restart:
.annotate 'line', 10
    if_null rx1637_debug, debug_1321
    rx1637_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1321:
  rx1637_fail:
    (rx1637_rep, rx1637_pos, $I10, $P10) = rx1637_cur."!mark_fail"(0)
    lt rx1637_pos, -1, rx1637_done
    eq rx1637_pos, -1, rx1637_fail
    jump $I10
  rx1637_done:
    rx1637_cur."!cursor_fail"()
    if_null rx1637_debug, debug_1322
    rx1637_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1322:
    .return (rx1637_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("366_1303391609.928") :method
.annotate 'line', 10
    $P1639 = self."!PREFIX__!subrule"("O", ":=")
    new $P1640, "ResizablePMCArray"
    push $P1640, $P1639
    .return ($P1640)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("367_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1644_tgt
    .local int rx1644_pos
    .local int rx1644_off
    .local int rx1644_eos
    .local int rx1644_rep
    .local pmc rx1644_cur
    .local pmc rx1644_debug
    (rx1644_cur, rx1644_pos, rx1644_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1644_cur
    .local pmc match
    .lex "$/", match
    length rx1644_eos, rx1644_tgt
    gt rx1644_pos, rx1644_eos, rx1644_done
    set rx1644_off, 0
    lt rx1644_pos, 2, rx1644_start
    sub rx1644_off, rx1644_pos, 1
    substr rx1644_tgt, rx1644_tgt, rx1644_off
  rx1644_start:
    eq $I10, 1, rx1644_restart
    if_null rx1644_debug, debug_1323
    rx1644_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1323:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1648_done
    goto rxscan1648_scan
  rxscan1648_loop:
    (rx1644_pos) = rx1644_cur."from"()
    inc rx1644_pos
    rx1644_cur."!cursor_from"(rx1644_pos)
    ge rx1644_pos, rx1644_eos, rxscan1648_done
  rxscan1648_scan:
    set_addr $I10, rxscan1648_loop
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  rxscan1648_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1649_fail
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  # rx literal  "::="
    add $I11, rx1644_pos, 3
    gt $I11, rx1644_eos, rx1644_fail
    sub $I11, rx1644_pos, rx1644_off
    substr $S10, rx1644_tgt, $I11, 3
    ne $S10, "::=", rx1644_fail
    add rx1644_pos, 3
    set_addr $I10, rxcap_1649_fail
    ($I12, $I11) = rx1644_cur."!mark_peek"($I10)
    rx1644_cur."!cursor_pos"($I11)
    ($P10) = rx1644_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1644_pos, "")
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1649_done
  rxcap_1649_fail:
    goto rx1644_fail
  rxcap_1649_done:
  # rx subrule "O" subtype=capture negate=
    rx1644_cur."!cursor_pos"(rx1644_pos)
    $P10 = rx1644_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1644_fail
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1644_pos = $P10."pos"()
  # rx pass
    rx1644_cur."!cursor_pass"(rx1644_pos, "infix:sym<::=>")
    if_null rx1644_debug, debug_1324
    rx1644_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1644_pos)
  debug_1324:
    .return (rx1644_cur)
  rx1644_restart:
.annotate 'line', 10
    if_null rx1644_debug, debug_1325
    rx1644_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1325:
  rx1644_fail:
    (rx1644_rep, rx1644_pos, $I10, $P10) = rx1644_cur."!mark_fail"(0)
    lt rx1644_pos, -1, rx1644_done
    eq rx1644_pos, -1, rx1644_fail
    jump $I10
  rx1644_done:
    rx1644_cur."!cursor_fail"()
    if_null rx1644_debug, debug_1326
    rx1644_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1326:
    .return (rx1644_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("368_1303391609.928") :method
.annotate 'line', 10
    $P1646 = self."!PREFIX__!subrule"("O", "::=")
    new $P1647, "ResizablePMCArray"
    push $P1647, $P1646
    .return ($P1647)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("369_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1651_tgt
    .local int rx1651_pos
    .local int rx1651_off
    .local int rx1651_eos
    .local int rx1651_rep
    .local pmc rx1651_cur
    .local pmc rx1651_debug
    (rx1651_cur, rx1651_pos, rx1651_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1651_cur
    .local pmc match
    .lex "$/", match
    length rx1651_eos, rx1651_tgt
    gt rx1651_pos, rx1651_eos, rx1651_done
    set rx1651_off, 0
    lt rx1651_pos, 2, rx1651_start
    sub rx1651_off, rx1651_pos, 1
    substr rx1651_tgt, rx1651_tgt, rx1651_off
  rx1651_start:
    eq $I10, 1, rx1651_restart
    if_null rx1651_debug, debug_1327
    rx1651_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1327:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1655_done
    goto rxscan1655_scan
  rxscan1655_loop:
    (rx1651_pos) = rx1651_cur."from"()
    inc rx1651_pos
    rx1651_cur."!cursor_from"(rx1651_pos)
    ge rx1651_pos, rx1651_eos, rxscan1655_done
  rxscan1655_scan:
    set_addr $I10, rxscan1655_loop
    rx1651_cur."!mark_push"(0, rx1651_pos, $I10)
  rxscan1655_done:
.annotate 'line', 696
  # rx subcapture "sym"
    set_addr $I10, rxcap_1656_fail
    rx1651_cur."!mark_push"(0, rx1651_pos, $I10)
  # rx literal  ","
    add $I11, rx1651_pos, 1
    gt $I11, rx1651_eos, rx1651_fail
    sub $I11, rx1651_pos, rx1651_off
    ord $I11, rx1651_tgt, $I11
    ne $I11, 44, rx1651_fail
    add rx1651_pos, 1
    set_addr $I10, rxcap_1656_fail
    ($I12, $I11) = rx1651_cur."!mark_peek"($I10)
    rx1651_cur."!cursor_pos"($I11)
    ($P10) = rx1651_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1651_pos, "")
    rx1651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1656_done
  rxcap_1656_fail:
    goto rx1651_fail
  rxcap_1656_done:
  # rx subrule "O" subtype=capture negate=
    rx1651_cur."!cursor_pos"(rx1651_pos)
    $P10 = rx1651_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1651_fail
    rx1651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1651_pos = $P10."pos"()
  # rx pass
    rx1651_cur."!cursor_pass"(rx1651_pos, "infix:sym<,>")
    if_null rx1651_debug, debug_1328
    rx1651_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1651_pos)
  debug_1328:
    .return (rx1651_cur)
  rx1651_restart:
.annotate 'line', 10
    if_null rx1651_debug, debug_1329
    rx1651_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1329:
  rx1651_fail:
    (rx1651_rep, rx1651_pos, $I10, $P10) = rx1651_cur."!mark_fail"(0)
    lt rx1651_pos, -1, rx1651_done
    eq rx1651_pos, -1, rx1651_fail
    jump $I10
  rx1651_done:
    rx1651_cur."!cursor_fail"()
    if_null rx1651_debug, debug_1330
    rx1651_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1330:
    .return (rx1651_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("370_1303391609.928") :method
.annotate 'line', 10
    $P1653 = self."!PREFIX__!subrule"("O", ",")
    new $P1654, "ResizablePMCArray"
    push $P1654, $P1653
    .return ($P1654)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("371_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .const 'Sub' $P1666 = "373_1303391609.928" 
    capture_lex $P1666
    .local string rx1658_tgt
    .local int rx1658_pos
    .local int rx1658_off
    .local int rx1658_eos
    .local int rx1658_rep
    .local pmc rx1658_cur
    .local pmc rx1658_debug
    (rx1658_cur, rx1658_pos, rx1658_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1658_cur
    .local pmc match
    .lex "$/", match
    length rx1658_eos, rx1658_tgt
    gt rx1658_pos, rx1658_eos, rx1658_done
    set rx1658_off, 0
    lt rx1658_pos, 2, rx1658_start
    sub rx1658_off, rx1658_pos, 1
    substr rx1658_tgt, rx1658_tgt, rx1658_off
  rx1658_start:
    eq $I10, 1, rx1658_restart
    if_null rx1658_debug, debug_1331
    rx1658_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1331:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1661_done
    goto rxscan1661_scan
  rxscan1661_loop:
    (rx1658_pos) = rx1658_cur."from"()
    inc rx1658_pos
    rx1658_cur."!cursor_from"(rx1658_pos)
    ge rx1658_pos, rx1658_eos, rxscan1661_done
  rxscan1661_scan:
    set_addr $I10, rxscan1661_loop
    rx1658_cur."!mark_push"(0, rx1658_pos, $I10)
  rxscan1661_done:
.annotate 'line', 698
  # rx subcapture "sym"
    set_addr $I10, rxcap_1662_fail
    rx1658_cur."!mark_push"(0, rx1658_pos, $I10)
  # rx literal  "return"
    add $I11, rx1658_pos, 6
    gt $I11, rx1658_eos, rx1658_fail
    sub $I11, rx1658_pos, rx1658_off
    substr $S10, rx1658_tgt, $I11, 6
    ne $S10, "return", rx1658_fail
    add rx1658_pos, 6
    set_addr $I10, rxcap_1662_fail
    ($I12, $I11) = rx1658_cur."!mark_peek"($I10)
    rx1658_cur."!cursor_pos"($I11)
    ($P10) = rx1658_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1658_pos, "")
    rx1658_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1662_done
  rxcap_1662_fail:
    goto rx1658_fail
  rxcap_1662_done:
  # rx charclass s
    ge rx1658_pos, rx1658_eos, rx1658_fail
    sub $I10, rx1658_pos, rx1658_off
    is_cclass $I11, 32, rx1658_tgt, $I10
    unless $I11, rx1658_fail
    inc rx1658_pos
  # rx subrule "O" subtype=capture negate=
    rx1658_cur."!cursor_pos"(rx1658_pos)
    $P10 = rx1658_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1658_fail
    rx1658_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1658_pos = $P10."pos"()
    rx1658_cur."!cursor_pos"(rx1658_pos)
    find_lex $P1663, unicode:"$\x{a2}"
    $P1664 = $P1663."MATCH"()
    store_lex "$/", $P1664
    .const 'Sub' $P1666 = "373_1303391609.928" 
    capture_lex $P1666
    $P1668 = $P1666()
  # rx pass
    rx1658_cur."!cursor_pass"(rx1658_pos, "prefix:sym<return>")
    if_null rx1658_debug, debug_1332
    rx1658_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1658_pos)
  debug_1332:
    .return (rx1658_cur)
  rx1658_restart:
.annotate 'line', 10
    if_null rx1658_debug, debug_1333
    rx1658_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1333:
  rx1658_fail:
    (rx1658_rep, rx1658_pos, $I10, $P10) = rx1658_cur."!mark_fail"(0)
    lt rx1658_pos, -1, rx1658_done
    eq rx1658_pos, -1, rx1658_fail
    jump $I10
  rx1658_done:
    rx1658_cur."!cursor_fail"()
    if_null rx1658_debug, debug_1334
    rx1658_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1334:
    .return (rx1658_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("372_1303391609.928") :method
.annotate 'line', 10
    new $P1660, "ResizablePMCArray"
    push $P1660, "return"
    .return ($P1660)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1665"  :anon :subid("373_1303391609.928") :outer("371_1303391609.928")
.annotate 'line', 698
    new $P1667, "Integer"
    assign $P1667, 1
    store_dynamic_lex "$*RETURN_USED", $P1667
    .return ($P1667)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("374_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1670_tgt
    .local int rx1670_pos
    .local int rx1670_off
    .local int rx1670_eos
    .local int rx1670_rep
    .local pmc rx1670_cur
    .local pmc rx1670_debug
    (rx1670_cur, rx1670_pos, rx1670_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1670_cur
    .local pmc match
    .lex "$/", match
    length rx1670_eos, rx1670_tgt
    gt rx1670_pos, rx1670_eos, rx1670_done
    set rx1670_off, 0
    lt rx1670_pos, 2, rx1670_start
    sub rx1670_off, rx1670_pos, 1
    substr rx1670_tgt, rx1670_tgt, rx1670_off
  rx1670_start:
    eq $I10, 1, rx1670_restart
    if_null rx1670_debug, debug_1335
    rx1670_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1335:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1673_done
    goto rxscan1673_scan
  rxscan1673_loop:
    (rx1670_pos) = rx1670_cur."from"()
    inc rx1670_pos
    rx1670_cur."!cursor_from"(rx1670_pos)
    ge rx1670_pos, rx1670_eos, rxscan1673_done
  rxscan1673_scan:
    set_addr $I10, rxscan1673_loop
    rx1670_cur."!mark_push"(0, rx1670_pos, $I10)
  rxscan1673_done:
.annotate 'line', 699
  # rx subcapture "sym"
    set_addr $I10, rxcap_1674_fail
    rx1670_cur."!mark_push"(0, rx1670_pos, $I10)
  # rx literal  "make"
    add $I11, rx1670_pos, 4
    gt $I11, rx1670_eos, rx1670_fail
    sub $I11, rx1670_pos, rx1670_off
    substr $S10, rx1670_tgt, $I11, 4
    ne $S10, "make", rx1670_fail
    add rx1670_pos, 4
    set_addr $I10, rxcap_1674_fail
    ($I12, $I11) = rx1670_cur."!mark_peek"($I10)
    rx1670_cur."!cursor_pos"($I11)
    ($P10) = rx1670_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1670_pos, "")
    rx1670_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1674_done
  rxcap_1674_fail:
    goto rx1670_fail
  rxcap_1674_done:
  # rx charclass s
    ge rx1670_pos, rx1670_eos, rx1670_fail
    sub $I10, rx1670_pos, rx1670_off
    is_cclass $I11, 32, rx1670_tgt, $I10
    unless $I11, rx1670_fail
    inc rx1670_pos
  # rx subrule "O" subtype=capture negate=
    rx1670_cur."!cursor_pos"(rx1670_pos)
    $P10 = rx1670_cur."O"("%list_prefix")
    unless $P10, rx1670_fail
    rx1670_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1670_pos = $P10."pos"()
  # rx pass
    rx1670_cur."!cursor_pass"(rx1670_pos, "prefix:sym<make>")
    if_null rx1670_debug, debug_1336
    rx1670_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1670_pos)
  debug_1336:
    .return (rx1670_cur)
  rx1670_restart:
.annotate 'line', 10
    if_null rx1670_debug, debug_1337
    rx1670_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1337:
  rx1670_fail:
    (rx1670_rep, rx1670_pos, $I10, $P10) = rx1670_cur."!mark_fail"(0)
    lt rx1670_pos, -1, rx1670_done
    eq rx1670_pos, -1, rx1670_fail
    jump $I10
  rx1670_done:
    rx1670_cur."!cursor_fail"()
    if_null rx1670_debug, debug_1338
    rx1670_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1338:
    .return (rx1670_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("375_1303391609.928") :method
.annotate 'line', 10
    new $P1672, "ResizablePMCArray"
    push $P1672, "make"
    .return ($P1672)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("376_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1676_tgt
    .local int rx1676_pos
    .local int rx1676_off
    .local int rx1676_eos
    .local int rx1676_rep
    .local pmc rx1676_cur
    .local pmc rx1676_debug
    (rx1676_cur, rx1676_pos, rx1676_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1676_cur
    .local pmc match
    .lex "$/", match
    length rx1676_eos, rx1676_tgt
    gt rx1676_pos, rx1676_eos, rx1676_done
    set rx1676_off, 0
    lt rx1676_pos, 2, rx1676_start
    sub rx1676_off, rx1676_pos, 1
    substr rx1676_tgt, rx1676_tgt, rx1676_off
  rx1676_start:
    eq $I10, 1, rx1676_restart
    if_null rx1676_debug, debug_1339
    rx1676_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1339:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1679_done
    goto rxscan1679_scan
  rxscan1679_loop:
    (rx1676_pos) = rx1676_cur."from"()
    inc rx1676_pos
    rx1676_cur."!cursor_from"(rx1676_pos)
    ge rx1676_pos, rx1676_eos, rxscan1679_done
  rxscan1679_scan:
    set_addr $I10, rxscan1679_loop
    rx1676_cur."!mark_push"(0, rx1676_pos, $I10)
  rxscan1679_done:
.annotate 'line', 700
  # rx subcapture "sym"
    set_addr $I10, rxcap_1680_fail
    rx1676_cur."!mark_push"(0, rx1676_pos, $I10)
  # rx literal  "last"
    add $I11, rx1676_pos, 4
    gt $I11, rx1676_eos, rx1676_fail
    sub $I11, rx1676_pos, rx1676_off
    substr $S10, rx1676_tgt, $I11, 4
    ne $S10, "last", rx1676_fail
    add rx1676_pos, 4
    set_addr $I10, rxcap_1680_fail
    ($I12, $I11) = rx1676_cur."!mark_peek"($I10)
    rx1676_cur."!cursor_pos"($I11)
    ($P10) = rx1676_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1676_pos, "")
    rx1676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1680_done
  rxcap_1680_fail:
    goto rx1676_fail
  rxcap_1680_done:
  # rx pass
    rx1676_cur."!cursor_pass"(rx1676_pos, "term:sym<last>")
    if_null rx1676_debug, debug_1340
    rx1676_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1676_pos)
  debug_1340:
    .return (rx1676_cur)
  rx1676_restart:
.annotate 'line', 10
    if_null rx1676_debug, debug_1341
    rx1676_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1341:
  rx1676_fail:
    (rx1676_rep, rx1676_pos, $I10, $P10) = rx1676_cur."!mark_fail"(0)
    lt rx1676_pos, -1, rx1676_done
    eq rx1676_pos, -1, rx1676_fail
    jump $I10
  rx1676_done:
    rx1676_cur."!cursor_fail"()
    if_null rx1676_debug, debug_1342
    rx1676_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1342:
    .return (rx1676_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("377_1303391609.928") :method
.annotate 'line', 10
    new $P1678, "ResizablePMCArray"
    push $P1678, "last"
    .return ($P1678)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("378_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1682_tgt
    .local int rx1682_pos
    .local int rx1682_off
    .local int rx1682_eos
    .local int rx1682_rep
    .local pmc rx1682_cur
    .local pmc rx1682_debug
    (rx1682_cur, rx1682_pos, rx1682_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1682_cur
    .local pmc match
    .lex "$/", match
    length rx1682_eos, rx1682_tgt
    gt rx1682_pos, rx1682_eos, rx1682_done
    set rx1682_off, 0
    lt rx1682_pos, 2, rx1682_start
    sub rx1682_off, rx1682_pos, 1
    substr rx1682_tgt, rx1682_tgt, rx1682_off
  rx1682_start:
    eq $I10, 1, rx1682_restart
    if_null rx1682_debug, debug_1343
    rx1682_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1343:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1685_done
    goto rxscan1685_scan
  rxscan1685_loop:
    (rx1682_pos) = rx1682_cur."from"()
    inc rx1682_pos
    rx1682_cur."!cursor_from"(rx1682_pos)
    ge rx1682_pos, rx1682_eos, rxscan1685_done
  rxscan1685_scan:
    set_addr $I10, rxscan1685_loop
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  rxscan1685_done:
.annotate 'line', 701
  # rx subcapture "sym"
    set_addr $I10, rxcap_1686_fail
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  # rx literal  "next"
    add $I11, rx1682_pos, 4
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    substr $S10, rx1682_tgt, $I11, 4
    ne $S10, "next", rx1682_fail
    add rx1682_pos, 4
    set_addr $I10, rxcap_1686_fail
    ($I12, $I11) = rx1682_cur."!mark_peek"($I10)
    rx1682_cur."!cursor_pos"($I11)
    ($P10) = rx1682_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1682_pos, "")
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1686_done
  rxcap_1686_fail:
    goto rx1682_fail
  rxcap_1686_done:
  # rx pass
    rx1682_cur."!cursor_pass"(rx1682_pos, "term:sym<next>")
    if_null rx1682_debug, debug_1344
    rx1682_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1682_pos)
  debug_1344:
    .return (rx1682_cur)
  rx1682_restart:
.annotate 'line', 10
    if_null rx1682_debug, debug_1345
    rx1682_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1345:
  rx1682_fail:
    (rx1682_rep, rx1682_pos, $I10, $P10) = rx1682_cur."!mark_fail"(0)
    lt rx1682_pos, -1, rx1682_done
    eq rx1682_pos, -1, rx1682_fail
    jump $I10
  rx1682_done:
    rx1682_cur."!cursor_fail"()
    if_null rx1682_debug, debug_1346
    rx1682_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1346:
    .return (rx1682_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("379_1303391609.928") :method
.annotate 'line', 10
    new $P1684, "ResizablePMCArray"
    push $P1684, "next"
    .return ($P1684)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("380_1303391609.928") :method :outer("12_1303391609.928")
.annotate 'line', 10
    .local string rx1688_tgt
    .local int rx1688_pos
    .local int rx1688_off
    .local int rx1688_eos
    .local int rx1688_rep
    .local pmc rx1688_cur
    .local pmc rx1688_debug
    (rx1688_cur, rx1688_pos, rx1688_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1688_cur
    .local pmc match
    .lex "$/", match
    length rx1688_eos, rx1688_tgt
    gt rx1688_pos, rx1688_eos, rx1688_done
    set rx1688_off, 0
    lt rx1688_pos, 2, rx1688_start
    sub rx1688_off, rx1688_pos, 1
    substr rx1688_tgt, rx1688_tgt, rx1688_off
  rx1688_start:
    eq $I10, 1, rx1688_restart
    if_null rx1688_debug, debug_1347
    rx1688_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1347:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1691_done
    goto rxscan1691_scan
  rxscan1691_loop:
    (rx1688_pos) = rx1688_cur."from"()
    inc rx1688_pos
    rx1688_cur."!cursor_from"(rx1688_pos)
    ge rx1688_pos, rx1688_eos, rxscan1691_done
  rxscan1691_scan:
    set_addr $I10, rxscan1691_loop
    rx1688_cur."!mark_push"(0, rx1688_pos, $I10)
  rxscan1691_done:
.annotate 'line', 702
  # rx subcapture "sym"
    set_addr $I10, rxcap_1692_fail
    rx1688_cur."!mark_push"(0, rx1688_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1688_pos, 4
    gt $I11, rx1688_eos, rx1688_fail
    sub $I11, rx1688_pos, rx1688_off
    substr $S10, rx1688_tgt, $I11, 4
    ne $S10, "redo", rx1688_fail
    add rx1688_pos, 4
    set_addr $I10, rxcap_1692_fail
    ($I12, $I11) = rx1688_cur."!mark_peek"($I10)
    rx1688_cur."!cursor_pos"($I11)
    ($P10) = rx1688_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1688_pos, "")
    rx1688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1692_done
  rxcap_1692_fail:
    goto rx1688_fail
  rxcap_1692_done:
  # rx pass
    rx1688_cur."!cursor_pass"(rx1688_pos, "term:sym<redo>")
    if_null rx1688_debug, debug_1348
    rx1688_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1688_pos)
  debug_1348:
    .return (rx1688_cur)
  rx1688_restart:
.annotate 'line', 10
    if_null rx1688_debug, debug_1349
    rx1688_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1349:
  rx1688_fail:
    (rx1688_rep, rx1688_pos, $I10, $P10) = rx1688_cur."!mark_fail"(0)
    lt rx1688_pos, -1, rx1688_done
    eq rx1688_pos, -1, rx1688_fail
    jump $I10
  rx1688_done:
    rx1688_cur."!cursor_fail"()
    if_null rx1688_debug, debug_1350
    rx1688_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1350:
    .return (rx1688_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("381_1303391609.928") :method
.annotate 'line', 10
    new $P1690, "ResizablePMCArray"
    push $P1690, "redo"
    .return ($P1690)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("382_1303391609.928") :outer("12_1303391609.928")
    .param pmc param_1694
    .param pmc param_1695
.annotate 'line', 704
    .lex "self", param_1694
    .lex "$/", param_1695
.annotate 'line', 706
    new $P1696, "Undef"
    .lex "$t", $P1696
    find_lex $P1697, "$/"
    unless_null $P1697, vivify_1351
    $P1697 = root_new ['parrot';'ResizablePMCArray']
  vivify_1351:
    set $P1698, $P1697[0]
    unless_null $P1698, vivify_1352
    new $P1698, "Undef"
  vivify_1352:
    store_lex "$t", $P1698
    find_lex $P1699, "$/"
    unless_null $P1699, vivify_1353
    $P1699 = root_new ['parrot';'ResizablePMCArray']
  vivify_1353:
    set $P1700, $P1699[1]
    unless_null $P1700, vivify_1354
    new $P1700, "Undef"
  vivify_1354:
    find_lex $P1701, "$/"
    unless_null $P1701, vivify_1355
    $P1701 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1701
  vivify_1355:
    set $P1701[0], $P1700
    find_lex $P1702, "$t"
    unless_null $P1702, vivify_1356
    new $P1702, "Undef"
  vivify_1356:
    find_lex $P1703, "$/"
    unless_null $P1703, vivify_1357
    $P1703 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1703
  vivify_1357:
    set $P1703[1], $P1702
.annotate 'line', 704
    .return ($P1702)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2428"  :subid("384_1303391609.928") :outer("10_1303391609.928")
.annotate 'line', 710
    .const 'Sub' $P2494 = "405_1303391609.928" 
    capture_lex $P2494
    .const 'Sub' $P2487 = "403_1303391609.928" 
    capture_lex $P2487
    .const 'Sub' $P2482 = "401_1303391609.928" 
    capture_lex $P2482
    .const 'Sub' $P2470 = "398_1303391609.928" 
    capture_lex $P2470
    .const 'Sub' $P2460 = "395_1303391609.928" 
    capture_lex $P2460
    .const 'Sub' $P2455 = "393_1303391609.928" 
    capture_lex $P2455
    .const 'Sub' $P2446 = "390_1303391609.928" 
    capture_lex $P2446
    .const 'Sub' $P2441 = "388_1303391609.928" 
    capture_lex $P2441
    .const 'Sub' $P2432 = "385_1303391609.928" 
    capture_lex $P2432
    .lex "$?PACKAGE", $P2430
    .lex "$?CLASS", $P2431
    .const 'Sub' $P2487 = "403_1303391609.928" 
    capture_lex $P2487
    .return ($P2487)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1358") :outer("384_1303391609.928")
.annotate 'line', 710
    get_hll_global $P2429, ["NQP";"Regex"], "_block2428" 
    .local pmc block
    set block, $P2429
    .const 'Sub' $P2494 = "405_1303391609.928" 
    capture_lex $P2494
    $P2494()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2493"  :anon :subid("405_1303391609.928") :outer("384_1303391609.928")
.annotate 'line', 710
    nqp_get_sc_object $P2495, "1303391598.821", 2
    .local pmc type_obj
    set type_obj, $P2495
    get_how $P2496, type_obj
    .const 'Sub' $P2497 = "385_1303391609.928" 
    $P2496."add_method"(type_obj, "metachar:sym<:my>", $P2497)
    get_how $P2498, type_obj
    get_global $P2499, "!PREFIX__metachar:sym<:my>"
    $P2498."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2499)
    get_how $P2500, type_obj
    .const 'Sub' $P2501 = "388_1303391609.928" 
    $P2500."add_method"(type_obj, "metachar:sym<{ }>", $P2501)
    get_how $P2502, type_obj
    get_global $P2503, "!PREFIX__metachar:sym<{ }>"
    $P2502."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2503)
    get_how $P2504, type_obj
    .const 'Sub' $P2505 = "390_1303391609.928" 
    $P2504."add_method"(type_obj, "metachar:sym<nqpvar>", $P2505)
    get_how $P2506, type_obj
    get_global $P2507, "!PREFIX__metachar:sym<nqpvar>"
    $P2506."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2507)
    get_how $P2508, type_obj
    .const 'Sub' $P2509 = "393_1303391609.928" 
    $P2508."add_method"(type_obj, "assertion:sym<{ }>", $P2509)
    get_how $P2510, type_obj
    get_global $P2511, "!PREFIX__assertion:sym<{ }>"
    $P2510."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2511)
    get_how $P2512, type_obj
    .const 'Sub' $P2513 = "395_1303391609.928" 
    $P2512."add_method"(type_obj, "assertion:sym<?{ }>", $P2513)
    get_how $P2514, type_obj
    get_global $P2515, "!PREFIX__assertion:sym<?{ }>"
    $P2514."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2515)
    get_how $P2516, type_obj
    .const 'Sub' $P2517 = "398_1303391609.928" 
    $P2516."add_method"(type_obj, "assertion:sym<name>", $P2517)
    get_how $P2518, type_obj
    get_global $P2519, "!PREFIX__assertion:sym<name>"
    $P2518."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2519)
    get_how $P2520, type_obj
    .const 'Sub' $P2521 = "401_1303391609.928" 
    $P2520."add_method"(type_obj, "assertion:sym<var>", $P2521)
    get_how $P2522, type_obj
    get_global $P2523, "!PREFIX__assertion:sym<var>"
    $P2522."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2523)
    get_how $P2524, type_obj
    .const 'Sub' $P2525 = "403_1303391609.928" 
    $P2524."add_method"(type_obj, "codeblock", $P2525)
    get_how $P2526, type_obj
    get_global $P2527, "!PREFIX__codeblock"
    $P2526."add_method"(type_obj, "!PREFIX__codeblock", $P2527)
    get_how $P2528, type_obj
    get_hll_global $P2529, ["Regex";"P6Regex"], "Grammar"
    $P2528."add_parent"(type_obj, $P2529)
    get_how $P2530, type_obj
    $P2531 = $P2530."compose"(type_obj)
    .return ($P2531)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("385_1303391609.928") :method :outer("384_1303391609.928")
.annotate 'line', 710
    .const 'Sub' $P2438 = "387_1303391609.928" 
    capture_lex $P2438
    .local string rx2433_tgt
    .local int rx2433_pos
    .local int rx2433_off
    .local int rx2433_eos
    .local int rx2433_rep
    .local pmc rx2433_cur
    .local pmc rx2433_debug
    (rx2433_cur, rx2433_pos, rx2433_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2433_cur
    .local pmc match
    .lex "$/", match
    length rx2433_eos, rx2433_tgt
    gt rx2433_pos, rx2433_eos, rx2433_done
    set rx2433_off, 0
    lt rx2433_pos, 2, rx2433_start
    sub rx2433_off, rx2433_pos, 1
    substr rx2433_tgt, rx2433_tgt, rx2433_off
  rx2433_start:
    eq $I10, 1, rx2433_restart
    if_null rx2433_debug, debug_1359
    rx2433_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1359:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2436_done
    goto rxscan2436_scan
  rxscan2436_loop:
    (rx2433_pos) = rx2433_cur."from"()
    inc rx2433_pos
    rx2433_cur."!cursor_from"(rx2433_pos)
    ge rx2433_pos, rx2433_eos, rxscan2436_done
  rxscan2436_scan:
    set_addr $I10, rxscan2436_loop
    rx2433_cur."!mark_push"(0, rx2433_pos, $I10)
  rxscan2436_done:
.annotate 'line', 712
  # rx literal  ":"
    add $I11, rx2433_pos, 1
    gt $I11, rx2433_eos, rx2433_fail
    sub $I11, rx2433_pos, rx2433_off
    ord $I11, rx2433_tgt, $I11
    ne $I11, 58, rx2433_fail
    add rx2433_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2433_cur."!cursor_pos"(rx2433_pos)
    .const 'Sub' $P2438 = "387_1303391609.928" 
    capture_lex $P2438
    $P10 = rx2433_cur."before"($P2438)
    unless $P10, rx2433_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2433_cur."!cursor_pos"(rx2433_pos)
    $P10 = rx2433_cur."LANG"("MAIN", "statement")
    unless $P10, rx2433_fail
    rx2433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2433_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2433_cur."!cursor_pos"(rx2433_pos)
    $P10 = rx2433_cur."ws"()
    unless $P10, rx2433_fail
    rx2433_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2433_pos, 1
    gt $I11, rx2433_eos, rx2433_fail
    sub $I11, rx2433_pos, rx2433_off
    ord $I11, rx2433_tgt, $I11
    ne $I11, 59, rx2433_fail
    add rx2433_pos, 1
.annotate 'line', 711
  # rx pass
    rx2433_cur."!cursor_pass"(rx2433_pos, "metachar:sym<:my>")
    if_null rx2433_debug, debug_1364
    rx2433_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2433_pos)
  debug_1364:
    .return (rx2433_cur)
  rx2433_restart:
.annotate 'line', 710
    if_null rx2433_debug, debug_1365
    rx2433_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1365:
  rx2433_fail:
    (rx2433_rep, rx2433_pos, $I10, $P10) = rx2433_cur."!mark_fail"(0)
    lt rx2433_pos, -1, rx2433_done
    eq rx2433_pos, -1, rx2433_fail
    jump $I10
  rx2433_done:
    rx2433_cur."!cursor_fail"()
    if_null rx2433_debug, debug_1366
    rx2433_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1366:
    .return (rx2433_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("386_1303391609.928") :method
.annotate 'line', 710
    new $P2435, "ResizablePMCArray"
    push $P2435, ":"
    .return ($P2435)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2437"  :anon :subid("387_1303391609.928") :method :outer("385_1303391609.928")
.annotate 'line', 712
    .local string rx2439_tgt
    .local int rx2439_pos
    .local int rx2439_off
    .local int rx2439_eos
    .local int rx2439_rep
    .local pmc rx2439_cur
    .local pmc rx2439_debug
    (rx2439_cur, rx2439_pos, rx2439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2439_cur
    .local pmc match
    .lex "$/", match
    length rx2439_eos, rx2439_tgt
    gt rx2439_pos, rx2439_eos, rx2439_done
    set rx2439_off, 0
    lt rx2439_pos, 2, rx2439_start
    sub rx2439_off, rx2439_pos, 1
    substr rx2439_tgt, rx2439_tgt, rx2439_off
  rx2439_start:
    eq $I10, 1, rx2439_restart
    if_null rx2439_debug, debug_1360
    rx2439_cur."!cursor_debug"("START", "")
  debug_1360:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2440_done
    goto rxscan2440_scan
  rxscan2440_loop:
    (rx2439_pos) = rx2439_cur."from"()
    inc rx2439_pos
    rx2439_cur."!cursor_from"(rx2439_pos)
    ge rx2439_pos, rx2439_eos, rxscan2440_done
  rxscan2440_scan:
    set_addr $I10, rxscan2440_loop
    rx2439_cur."!mark_push"(0, rx2439_pos, $I10)
  rxscan2440_done:
  # rx literal  "my"
    add $I11, rx2439_pos, 2
    gt $I11, rx2439_eos, rx2439_fail
    sub $I11, rx2439_pos, rx2439_off
    substr $S10, rx2439_tgt, $I11, 2
    ne $S10, "my", rx2439_fail
    add rx2439_pos, 2
  # rx pass
    rx2439_cur."!cursor_pass"(rx2439_pos, "")
    if_null rx2439_debug, debug_1361
    rx2439_cur."!cursor_debug"("PASS", "", " at pos=", rx2439_pos)
  debug_1361:
    .return (rx2439_cur)
  rx2439_restart:
    if_null rx2439_debug, debug_1362
    rx2439_cur."!cursor_debug"("NEXT", "")
  debug_1362:
  rx2439_fail:
    (rx2439_rep, rx2439_pos, $I10, $P10) = rx2439_cur."!mark_fail"(0)
    lt rx2439_pos, -1, rx2439_done
    eq rx2439_pos, -1, rx2439_fail
    jump $I10
  rx2439_done:
    rx2439_cur."!cursor_fail"()
    if_null rx2439_debug, debug_1363
    rx2439_cur."!cursor_debug"("FAIL", "")
  debug_1363:
    .return (rx2439_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("388_1303391609.928") :method :outer("384_1303391609.928")
.annotate 'line', 710
    .local string rx2442_tgt
    .local int rx2442_pos
    .local int rx2442_off
    .local int rx2442_eos
    .local int rx2442_rep
    .local pmc rx2442_cur
    .local pmc rx2442_debug
    (rx2442_cur, rx2442_pos, rx2442_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2442_cur
    .local pmc match
    .lex "$/", match
    length rx2442_eos, rx2442_tgt
    gt rx2442_pos, rx2442_eos, rx2442_done
    set rx2442_off, 0
    lt rx2442_pos, 2, rx2442_start
    sub rx2442_off, rx2442_pos, 1
    substr rx2442_tgt, rx2442_tgt, rx2442_off
  rx2442_start:
    eq $I10, 1, rx2442_restart
    if_null rx2442_debug, debug_1367
    rx2442_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1367:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2445_done
    goto rxscan2445_scan
  rxscan2445_loop:
    (rx2442_pos) = rx2442_cur."from"()
    inc rx2442_pos
    rx2442_cur."!cursor_from"(rx2442_pos)
    ge rx2442_pos, rx2442_eos, rxscan2445_done
  rxscan2445_scan:
    set_addr $I10, rxscan2445_loop
    rx2442_cur."!mark_push"(0, rx2442_pos, $I10)
  rxscan2445_done:
.annotate 'line', 716
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2442_pos, rx2442_off
    substr $S10, rx2442_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2442_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2442_cur."!cursor_pos"(rx2442_pos)
    $P10 = rx2442_cur."codeblock"()
    unless $P10, rx2442_fail
    rx2442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2442_pos = $P10."pos"()
.annotate 'line', 715
  # rx pass
    rx2442_cur."!cursor_pass"(rx2442_pos, "metachar:sym<{ }>")
    if_null rx2442_debug, debug_1368
    rx2442_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2442_pos)
  debug_1368:
    .return (rx2442_cur)
  rx2442_restart:
.annotate 'line', 710
    if_null rx2442_debug, debug_1369
    rx2442_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1369:
  rx2442_fail:
    (rx2442_rep, rx2442_pos, $I10, $P10) = rx2442_cur."!mark_fail"(0)
    lt rx2442_pos, -1, rx2442_done
    eq rx2442_pos, -1, rx2442_fail
    jump $I10
  rx2442_done:
    rx2442_cur."!cursor_fail"()
    if_null rx2442_debug, debug_1370
    rx2442_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1370:
    .return (rx2442_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("389_1303391609.928") :method
.annotate 'line', 710
    new $P2444, "ResizablePMCArray"
    push $P2444, "{"
    .return ($P2444)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("390_1303391609.928") :method :outer("384_1303391609.928")
.annotate 'line', 710
    .const 'Sub' $P2452 = "392_1303391609.928" 
    capture_lex $P2452
    .local string rx2447_tgt
    .local int rx2447_pos
    .local int rx2447_off
    .local int rx2447_eos
    .local int rx2447_rep
    .local pmc rx2447_cur
    .local pmc rx2447_debug
    (rx2447_cur, rx2447_pos, rx2447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2447_cur
    .local pmc match
    .lex "$/", match
    length rx2447_eos, rx2447_tgt
    gt rx2447_pos, rx2447_eos, rx2447_done
    set rx2447_off, 0
    lt rx2447_pos, 2, rx2447_start
    sub rx2447_off, rx2447_pos, 1
    substr rx2447_tgt, rx2447_tgt, rx2447_off
  rx2447_start:
    eq $I10, 1, rx2447_restart
    if_null rx2447_debug, debug_1371
    rx2447_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1371:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2450_done
    goto rxscan2450_scan
  rxscan2450_loop:
    (rx2447_pos) = rx2447_cur."from"()
    inc rx2447_pos
    rx2447_cur."!cursor_from"(rx2447_pos)
    ge rx2447_pos, rx2447_eos, rxscan2450_done
  rxscan2450_scan:
    set_addr $I10, rxscan2450_loop
    rx2447_cur."!mark_push"(0, rx2447_pos, $I10)
  rxscan2450_done:
.annotate 'line', 720
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2447_pos, rx2447_off
    substr $S10, rx2447_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2447_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2447_cur."!cursor_pos"(rx2447_pos)
    .const 'Sub' $P2452 = "392_1303391609.928" 
    capture_lex $P2452
    $P10 = rx2447_cur."before"($P2452)
    unless $P10, rx2447_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2447_cur."!cursor_pos"(rx2447_pos)
    $P10 = rx2447_cur."LANG"("MAIN", "variable")
    unless $P10, rx2447_fail
    rx2447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2447_pos = $P10."pos"()
.annotate 'line', 719
  # rx pass
    rx2447_cur."!cursor_pass"(rx2447_pos, "metachar:sym<nqpvar>")
    if_null rx2447_debug, debug_1376
    rx2447_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2447_pos)
  debug_1376:
    .return (rx2447_cur)
  rx2447_restart:
.annotate 'line', 710
    if_null rx2447_debug, debug_1377
    rx2447_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1377:
  rx2447_fail:
    (rx2447_rep, rx2447_pos, $I10, $P10) = rx2447_cur."!mark_fail"(0)
    lt rx2447_pos, -1, rx2447_done
    eq rx2447_pos, -1, rx2447_fail
    jump $I10
  rx2447_done:
    rx2447_cur."!cursor_fail"()
    if_null rx2447_debug, debug_1378
    rx2447_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1378:
    .return (rx2447_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("391_1303391609.928") :method
.annotate 'line', 710
    new $P2449, "ResizablePMCArray"
    push $P2449, "$"
    push $P2449, "@"
    .return ($P2449)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2451"  :anon :subid("392_1303391609.928") :method :outer("390_1303391609.928")
.annotate 'line', 720
    .local string rx2453_tgt
    .local int rx2453_pos
    .local int rx2453_off
    .local int rx2453_eos
    .local int rx2453_rep
    .local pmc rx2453_cur
    .local pmc rx2453_debug
    (rx2453_cur, rx2453_pos, rx2453_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2453_cur
    .local pmc match
    .lex "$/", match
    length rx2453_eos, rx2453_tgt
    gt rx2453_pos, rx2453_eos, rx2453_done
    set rx2453_off, 0
    lt rx2453_pos, 2, rx2453_start
    sub rx2453_off, rx2453_pos, 1
    substr rx2453_tgt, rx2453_tgt, rx2453_off
  rx2453_start:
    eq $I10, 1, rx2453_restart
    if_null rx2453_debug, debug_1372
    rx2453_cur."!cursor_debug"("START", "")
  debug_1372:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2454_done
    goto rxscan2454_scan
  rxscan2454_loop:
    (rx2453_pos) = rx2453_cur."from"()
    inc rx2453_pos
    rx2453_cur."!cursor_from"(rx2453_pos)
    ge rx2453_pos, rx2453_eos, rxscan2454_done
  rxscan2454_scan:
    set_addr $I10, rxscan2454_loop
    rx2453_cur."!mark_push"(0, rx2453_pos, $I10)
  rxscan2454_done:
  # rx charclass .
    ge rx2453_pos, rx2453_eos, rx2453_fail
    inc rx2453_pos
  # rx charclass w
    ge rx2453_pos, rx2453_eos, rx2453_fail
    sub $I10, rx2453_pos, rx2453_off
    is_cclass $I11, 8192, rx2453_tgt, $I10
    unless $I11, rx2453_fail
    inc rx2453_pos
  # rx pass
    rx2453_cur."!cursor_pass"(rx2453_pos, "")
    if_null rx2453_debug, debug_1373
    rx2453_cur."!cursor_debug"("PASS", "", " at pos=", rx2453_pos)
  debug_1373:
    .return (rx2453_cur)
  rx2453_restart:
    if_null rx2453_debug, debug_1374
    rx2453_cur."!cursor_debug"("NEXT", "")
  debug_1374:
  rx2453_fail:
    (rx2453_rep, rx2453_pos, $I10, $P10) = rx2453_cur."!mark_fail"(0)
    lt rx2453_pos, -1, rx2453_done
    eq rx2453_pos, -1, rx2453_fail
    jump $I10
  rx2453_done:
    rx2453_cur."!cursor_fail"()
    if_null rx2453_debug, debug_1375
    rx2453_cur."!cursor_debug"("FAIL", "")
  debug_1375:
    .return (rx2453_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("393_1303391609.928") :method :outer("384_1303391609.928")
.annotate 'line', 710
    .local string rx2456_tgt
    .local int rx2456_pos
    .local int rx2456_off
    .local int rx2456_eos
    .local int rx2456_rep
    .local pmc rx2456_cur
    .local pmc rx2456_debug
    (rx2456_cur, rx2456_pos, rx2456_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2456_cur
    .local pmc match
    .lex "$/", match
    length rx2456_eos, rx2456_tgt
    gt rx2456_pos, rx2456_eos, rx2456_done
    set rx2456_off, 0
    lt rx2456_pos, 2, rx2456_start
    sub rx2456_off, rx2456_pos, 1
    substr rx2456_tgt, rx2456_tgt, rx2456_off
  rx2456_start:
    eq $I10, 1, rx2456_restart
    if_null rx2456_debug, debug_1379
    rx2456_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1379:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2459_done
    goto rxscan2459_scan
  rxscan2459_loop:
    (rx2456_pos) = rx2456_cur."from"()
    inc rx2456_pos
    rx2456_cur."!cursor_from"(rx2456_pos)
    ge rx2456_pos, rx2456_eos, rxscan2459_done
  rxscan2459_scan:
    set_addr $I10, rxscan2459_loop
    rx2456_cur."!mark_push"(0, rx2456_pos, $I10)
  rxscan2459_done:
.annotate 'line', 724
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2456_pos, rx2456_off
    substr $S10, rx2456_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2456_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2456_cur."!cursor_pos"(rx2456_pos)
    $P10 = rx2456_cur."codeblock"()
    unless $P10, rx2456_fail
    rx2456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2456_pos = $P10."pos"()
.annotate 'line', 723
  # rx pass
    rx2456_cur."!cursor_pass"(rx2456_pos, "assertion:sym<{ }>")
    if_null rx2456_debug, debug_1380
    rx2456_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2456_pos)
  debug_1380:
    .return (rx2456_cur)
  rx2456_restart:
.annotate 'line', 710
    if_null rx2456_debug, debug_1381
    rx2456_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1381:
  rx2456_fail:
    (rx2456_rep, rx2456_pos, $I10, $P10) = rx2456_cur."!mark_fail"(0)
    lt rx2456_pos, -1, rx2456_done
    eq rx2456_pos, -1, rx2456_fail
    jump $I10
  rx2456_done:
    rx2456_cur."!cursor_fail"()
    if_null rx2456_debug, debug_1382
    rx2456_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1382:
    .return (rx2456_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("394_1303391609.928") :method
.annotate 'line', 710
    new $P2458, "ResizablePMCArray"
    push $P2458, "{"
    .return ($P2458)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("395_1303391609.928") :method :outer("384_1303391609.928")
.annotate 'line', 710
    .const 'Sub' $P2466 = "397_1303391609.928" 
    capture_lex $P2466
    .local string rx2461_tgt
    .local int rx2461_pos
    .local int rx2461_off
    .local int rx2461_eos
    .local int rx2461_rep
    .local pmc rx2461_cur
    .local pmc rx2461_debug
    (rx2461_cur, rx2461_pos, rx2461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2461_cur
    .local pmc match
    .lex "$/", match
    length rx2461_eos, rx2461_tgt
    gt rx2461_pos, rx2461_eos, rx2461_done
    set rx2461_off, 0
    lt rx2461_pos, 2, rx2461_start
    sub rx2461_off, rx2461_pos, 1
    substr rx2461_tgt, rx2461_tgt, rx2461_off
  rx2461_start:
    eq $I10, 1, rx2461_restart
    if_null rx2461_debug, debug_1383
    rx2461_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1383:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2464_done
    goto rxscan2464_scan
  rxscan2464_loop:
    (rx2461_pos) = rx2461_cur."from"()
    inc rx2461_pos
    rx2461_cur."!cursor_from"(rx2461_pos)
    ge rx2461_pos, rx2461_eos, rxscan2464_done
  rxscan2464_scan:
    set_addr $I10, rxscan2464_loop
    rx2461_cur."!mark_push"(0, rx2461_pos, $I10)
  rxscan2464_done:
.annotate 'line', 728
  # rx subcapture "zw"
    set_addr $I10, rxcap_2469_fail
    rx2461_cur."!mark_push"(0, rx2461_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2461_pos, rx2461_eos, rx2461_fail
    sub $I10, rx2461_pos, rx2461_off
    substr $S10, rx2461_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2461_fail
    inc rx2461_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2461_cur."!cursor_pos"(rx2461_pos)
    .const 'Sub' $P2466 = "397_1303391609.928" 
    capture_lex $P2466
    $P10 = rx2461_cur."before"($P2466)
    unless $P10, rx2461_fail
    set_addr $I10, rxcap_2469_fail
    ($I12, $I11) = rx2461_cur."!mark_peek"($I10)
    rx2461_cur."!cursor_pos"($I11)
    ($P10) = rx2461_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2461_pos, "")
    rx2461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2469_done
  rxcap_2469_fail:
    goto rx2461_fail
  rxcap_2469_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2461_cur."!cursor_pos"(rx2461_pos)
    $P10 = rx2461_cur."codeblock"()
    unless $P10, rx2461_fail
    rx2461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2461_pos = $P10."pos"()
.annotate 'line', 727
  # rx pass
    rx2461_cur."!cursor_pass"(rx2461_pos, "assertion:sym<?{ }>")
    if_null rx2461_debug, debug_1388
    rx2461_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2461_pos)
  debug_1388:
    .return (rx2461_cur)
  rx2461_restart:
.annotate 'line', 710
    if_null rx2461_debug, debug_1389
    rx2461_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1389:
  rx2461_fail:
    (rx2461_rep, rx2461_pos, $I10, $P10) = rx2461_cur."!mark_fail"(0)
    lt rx2461_pos, -1, rx2461_done
    eq rx2461_pos, -1, rx2461_fail
    jump $I10
  rx2461_done:
    rx2461_cur."!cursor_fail"()
    if_null rx2461_debug, debug_1390
    rx2461_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1390:
    .return (rx2461_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("396_1303391609.928") :method
.annotate 'line', 710
    new $P2463, "ResizablePMCArray"
    push $P2463, "!"
    push $P2463, "?"
    .return ($P2463)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2465"  :anon :subid("397_1303391609.928") :method :outer("395_1303391609.928")
.annotate 'line', 728
    .local string rx2467_tgt
    .local int rx2467_pos
    .local int rx2467_off
    .local int rx2467_eos
    .local int rx2467_rep
    .local pmc rx2467_cur
    .local pmc rx2467_debug
    (rx2467_cur, rx2467_pos, rx2467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2467_cur
    .local pmc match
    .lex "$/", match
    length rx2467_eos, rx2467_tgt
    gt rx2467_pos, rx2467_eos, rx2467_done
    set rx2467_off, 0
    lt rx2467_pos, 2, rx2467_start
    sub rx2467_off, rx2467_pos, 1
    substr rx2467_tgt, rx2467_tgt, rx2467_off
  rx2467_start:
    eq $I10, 1, rx2467_restart
    if_null rx2467_debug, debug_1384
    rx2467_cur."!cursor_debug"("START", "")
  debug_1384:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2468_done
    goto rxscan2468_scan
  rxscan2468_loop:
    (rx2467_pos) = rx2467_cur."from"()
    inc rx2467_pos
    rx2467_cur."!cursor_from"(rx2467_pos)
    ge rx2467_pos, rx2467_eos, rxscan2468_done
  rxscan2468_scan:
    set_addr $I10, rxscan2468_loop
    rx2467_cur."!mark_push"(0, rx2467_pos, $I10)
  rxscan2468_done:
  # rx literal  "{"
    add $I11, rx2467_pos, 1
    gt $I11, rx2467_eos, rx2467_fail
    sub $I11, rx2467_pos, rx2467_off
    ord $I11, rx2467_tgt, $I11
    ne $I11, 123, rx2467_fail
    add rx2467_pos, 1
  # rx pass
    rx2467_cur."!cursor_pass"(rx2467_pos, "")
    if_null rx2467_debug, debug_1385
    rx2467_cur."!cursor_debug"("PASS", "", " at pos=", rx2467_pos)
  debug_1385:
    .return (rx2467_cur)
  rx2467_restart:
    if_null rx2467_debug, debug_1386
    rx2467_cur."!cursor_debug"("NEXT", "")
  debug_1386:
  rx2467_fail:
    (rx2467_rep, rx2467_pos, $I10, $P10) = rx2467_cur."!mark_fail"(0)
    lt rx2467_pos, -1, rx2467_done
    eq rx2467_pos, -1, rx2467_fail
    jump $I10
  rx2467_done:
    rx2467_cur."!cursor_fail"()
    if_null rx2467_debug, debug_1387
    rx2467_cur."!cursor_debug"("FAIL", "")
  debug_1387:
    .return (rx2467_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("398_1303391609.928") :method :outer("384_1303391609.928")
.annotate 'line', 710
    .const 'Sub' $P2479 = "400_1303391609.928" 
    capture_lex $P2479
    .local string rx2471_tgt
    .local int rx2471_pos
    .local int rx2471_off
    .local int rx2471_eos
    .local int rx2471_rep
    .local pmc rx2471_cur
    .local pmc rx2471_debug
    (rx2471_cur, rx2471_pos, rx2471_tgt, $I10) = self."!cursor_start"()
    rx2471_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2471_cur
    .local pmc match
    .lex "$/", match
    length rx2471_eos, rx2471_tgt
    gt rx2471_pos, rx2471_eos, rx2471_done
    set rx2471_off, 0
    lt rx2471_pos, 2, rx2471_start
    sub rx2471_off, rx2471_pos, 1
    substr rx2471_tgt, rx2471_tgt, rx2471_off
  rx2471_start:
    eq $I10, 1, rx2471_restart
    if_null rx2471_debug, debug_1391
    rx2471_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1391:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2475_done
    goto rxscan2475_scan
  rxscan2475_loop:
    (rx2471_pos) = rx2471_cur."from"()
    inc rx2471_pos
    rx2471_cur."!cursor_from"(rx2471_pos)
    ge rx2471_pos, rx2471_eos, rxscan2475_done
  rxscan2475_scan:
    set_addr $I10, rxscan2475_loop
    rx2471_cur."!mark_push"(0, rx2471_pos, $I10)
  rxscan2475_done:
.annotate 'line', 732
  # rx subrule "identifier" subtype=capture negate=
    rx2471_cur."!cursor_pos"(rx2471_pos)
    $P10 = rx2471_cur."identifier"()
    unless $P10, rx2471_fail
    rx2471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2471_pos = $P10."pos"()
.annotate 'line', 739
  # rx rxquantr2476 ** 0..1
    set_addr $I10, rxquantr2476_done
    rx2471_cur."!mark_push"(0, rx2471_pos, $I10)
  rxquantr2476_loop:
  alt2477_0:
.annotate 'line', 733
    set_addr $I10, alt2477_1
    rx2471_cur."!mark_push"(0, rx2471_pos, $I10)
.annotate 'line', 734
  # rx subrule "before" subtype=zerowidth negate=
    rx2471_cur."!cursor_pos"(rx2471_pos)
    .const 'Sub' $P2479 = "400_1303391609.928" 
    capture_lex $P2479
    $P10 = rx2471_cur."before"($P2479)
    unless $P10, rx2471_fail
    goto alt2477_end
  alt2477_1:
    set_addr $I10, alt2477_2
    rx2471_cur."!mark_push"(0, rx2471_pos, $I10)
.annotate 'line', 735
  # rx literal  "="
    add $I11, rx2471_pos, 1
    gt $I11, rx2471_eos, rx2471_fail
    sub $I11, rx2471_pos, rx2471_off
    ord $I11, rx2471_tgt, $I11
    ne $I11, 61, rx2471_fail
    add rx2471_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2471_cur."!cursor_pos"(rx2471_pos)
    $P10 = rx2471_cur."assertion"()
    unless $P10, rx2471_fail
    rx2471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2471_pos = $P10."pos"()
    goto alt2477_end
  alt2477_2:
    set_addr $I10, alt2477_3
    rx2471_cur."!mark_push"(0, rx2471_pos, $I10)
.annotate 'line', 736
  # rx literal  ":"
    add $I11, rx2471_pos, 1
    gt $I11, rx2471_eos, rx2471_fail
    sub $I11, rx2471_pos, rx2471_off
    ord $I11, rx2471_tgt, $I11
    ne $I11, 58, rx2471_fail
    add rx2471_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2471_cur."!cursor_pos"(rx2471_pos)
    $P10 = rx2471_cur."arglist"()
    unless $P10, rx2471_fail
    rx2471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2471_pos = $P10."pos"()
    goto alt2477_end
  alt2477_3:
    set_addr $I10, alt2477_4
    rx2471_cur."!mark_push"(0, rx2471_pos, $I10)
.annotate 'line', 737
  # rx literal  "("
    add $I11, rx2471_pos, 1
    gt $I11, rx2471_eos, rx2471_fail
    sub $I11, rx2471_pos, rx2471_off
    ord $I11, rx2471_tgt, $I11
    ne $I11, 40, rx2471_fail
    add rx2471_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2471_cur."!cursor_pos"(rx2471_pos)
    $P10 = rx2471_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2471_fail
    rx2471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2471_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2471_pos, 1
    gt $I11, rx2471_eos, rx2471_fail
    sub $I11, rx2471_pos, rx2471_off
    ord $I11, rx2471_tgt, $I11
    ne $I11, 41, rx2471_fail
    add rx2471_pos, 1
    goto alt2477_end
  alt2477_4:
.annotate 'line', 738
  # rx subrule "normspace" subtype=method negate=
    rx2471_cur."!cursor_pos"(rx2471_pos)
    $P10 = rx2471_cur."normspace"()
    unless $P10, rx2471_fail
    rx2471_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2471_cur."!cursor_pos"(rx2471_pos)
    $P10 = rx2471_cur."nibbler"()
    unless $P10, rx2471_fail
    rx2471_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2471_pos = $P10."pos"()
  alt2477_end:
.annotate 'line', 739
    set_addr $I10, rxquantr2476_done
    (rx2471_rep) = rx2471_cur."!mark_commit"($I10)
  rxquantr2476_done:
.annotate 'line', 731
  # rx pass
    rx2471_cur."!cursor_pass"(rx2471_pos, "assertion:sym<name>")
    if_null rx2471_debug, debug_1396
    rx2471_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2471_pos)
  debug_1396:
    .return (rx2471_cur)
  rx2471_restart:
.annotate 'line', 710
    if_null rx2471_debug, debug_1397
    rx2471_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1397:
  rx2471_fail:
    (rx2471_rep, rx2471_pos, $I10, $P10) = rx2471_cur."!mark_fail"(0)
    lt rx2471_pos, -1, rx2471_done
    eq rx2471_pos, -1, rx2471_fail
    jump $I10
  rx2471_done:
    rx2471_cur."!cursor_fail"()
    if_null rx2471_debug, debug_1398
    rx2471_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1398:
    .return (rx2471_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("399_1303391609.928") :method
.annotate 'line', 710
    $P2473 = self."!PREFIX__!subrule"("identifier", "")
    new $P2474, "ResizablePMCArray"
    push $P2474, $P2473
    .return ($P2474)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2478"  :anon :subid("400_1303391609.928") :method :outer("398_1303391609.928")
.annotate 'line', 734
    .local string rx2480_tgt
    .local int rx2480_pos
    .local int rx2480_off
    .local int rx2480_eos
    .local int rx2480_rep
    .local pmc rx2480_cur
    .local pmc rx2480_debug
    (rx2480_cur, rx2480_pos, rx2480_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2480_cur
    .local pmc match
    .lex "$/", match
    length rx2480_eos, rx2480_tgt
    gt rx2480_pos, rx2480_eos, rx2480_done
    set rx2480_off, 0
    lt rx2480_pos, 2, rx2480_start
    sub rx2480_off, rx2480_pos, 1
    substr rx2480_tgt, rx2480_tgt, rx2480_off
  rx2480_start:
    eq $I10, 1, rx2480_restart
    if_null rx2480_debug, debug_1392
    rx2480_cur."!cursor_debug"("START", "")
  debug_1392:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2481_done
    goto rxscan2481_scan
  rxscan2481_loop:
    (rx2480_pos) = rx2480_cur."from"()
    inc rx2480_pos
    rx2480_cur."!cursor_from"(rx2480_pos)
    ge rx2480_pos, rx2480_eos, rxscan2481_done
  rxscan2481_scan:
    set_addr $I10, rxscan2481_loop
    rx2480_cur."!mark_push"(0, rx2480_pos, $I10)
  rxscan2481_done:
  # rx literal  ">"
    add $I11, rx2480_pos, 1
    gt $I11, rx2480_eos, rx2480_fail
    sub $I11, rx2480_pos, rx2480_off
    ord $I11, rx2480_tgt, $I11
    ne $I11, 62, rx2480_fail
    add rx2480_pos, 1
  # rx pass
    rx2480_cur."!cursor_pass"(rx2480_pos, "")
    if_null rx2480_debug, debug_1393
    rx2480_cur."!cursor_debug"("PASS", "", " at pos=", rx2480_pos)
  debug_1393:
    .return (rx2480_cur)
  rx2480_restart:
    if_null rx2480_debug, debug_1394
    rx2480_cur."!cursor_debug"("NEXT", "")
  debug_1394:
  rx2480_fail:
    (rx2480_rep, rx2480_pos, $I10, $P10) = rx2480_cur."!mark_fail"(0)
    lt rx2480_pos, -1, rx2480_done
    eq rx2480_pos, -1, rx2480_fail
    jump $I10
  rx2480_done:
    rx2480_cur."!cursor_fail"()
    if_null rx2480_debug, debug_1395
    rx2480_cur."!cursor_debug"("FAIL", "")
  debug_1395:
    .return (rx2480_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("401_1303391609.928") :method :outer("384_1303391609.928")
.annotate 'line', 710
    .local string rx2483_tgt
    .local int rx2483_pos
    .local int rx2483_off
    .local int rx2483_eos
    .local int rx2483_rep
    .local pmc rx2483_cur
    .local pmc rx2483_debug
    (rx2483_cur, rx2483_pos, rx2483_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2483_cur
    .local pmc match
    .lex "$/", match
    length rx2483_eos, rx2483_tgt
    gt rx2483_pos, rx2483_eos, rx2483_done
    set rx2483_off, 0
    lt rx2483_pos, 2, rx2483_start
    sub rx2483_off, rx2483_pos, 1
    substr rx2483_tgt, rx2483_tgt, rx2483_off
  rx2483_start:
    eq $I10, 1, rx2483_restart
    if_null rx2483_debug, debug_1399
    rx2483_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1399:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2486_done
    goto rxscan2486_scan
  rxscan2486_loop:
    (rx2483_pos) = rx2483_cur."from"()
    inc rx2483_pos
    rx2483_cur."!cursor_from"(rx2483_pos)
    ge rx2483_pos, rx2483_eos, rxscan2486_done
  rxscan2486_scan:
    set_addr $I10, rxscan2486_loop
    rx2483_cur."!mark_push"(0, rx2483_pos, $I10)
  rxscan2486_done:
.annotate 'line', 743
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2483_pos, rx2483_off
    substr $S10, rx2483_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2483_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2483_cur."!cursor_pos"(rx2483_pos)
    $P10 = rx2483_cur."LANG"("MAIN", "variable")
    unless $P10, rx2483_fail
    rx2483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2483_pos = $P10."pos"()
.annotate 'line', 742
  # rx pass
    rx2483_cur."!cursor_pass"(rx2483_pos, "assertion:sym<var>")
    if_null rx2483_debug, debug_1400
    rx2483_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2483_pos)
  debug_1400:
    .return (rx2483_cur)
  rx2483_restart:
.annotate 'line', 710
    if_null rx2483_debug, debug_1401
    rx2483_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1401:
  rx2483_fail:
    (rx2483_rep, rx2483_pos, $I10, $P10) = rx2483_cur."!mark_fail"(0)
    lt rx2483_pos, -1, rx2483_done
    eq rx2483_pos, -1, rx2483_fail
    jump $I10
  rx2483_done:
    rx2483_cur."!cursor_fail"()
    if_null rx2483_debug, debug_1402
    rx2483_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1402:
    .return (rx2483_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("402_1303391609.928") :method
.annotate 'line', 710
    new $P2485, "ResizablePMCArray"
    push $P2485, "$"
    push $P2485, "@"
    .return ($P2485)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("403_1303391609.928") :method :outer("384_1303391609.928")
.annotate 'line', 710
    .local string rx2488_tgt
    .local int rx2488_pos
    .local int rx2488_off
    .local int rx2488_eos
    .local int rx2488_rep
    .local pmc rx2488_cur
    .local pmc rx2488_debug
    (rx2488_cur, rx2488_pos, rx2488_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2488_cur
    .local pmc match
    .lex "$/", match
    length rx2488_eos, rx2488_tgt
    gt rx2488_pos, rx2488_eos, rx2488_done
    set rx2488_off, 0
    lt rx2488_pos, 2, rx2488_start
    sub rx2488_off, rx2488_pos, 1
    substr rx2488_tgt, rx2488_tgt, rx2488_off
  rx2488_start:
    eq $I10, 1, rx2488_restart
    if_null rx2488_debug, debug_1403
    rx2488_cur."!cursor_debug"("START", "codeblock")
  debug_1403:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2492_done
    goto rxscan2492_scan
  rxscan2492_loop:
    (rx2488_pos) = rx2488_cur."from"()
    inc rx2488_pos
    rx2488_cur."!cursor_from"(rx2488_pos)
    ge rx2488_pos, rx2488_eos, rxscan2492_done
  rxscan2492_scan:
    set_addr $I10, rxscan2492_loop
    rx2488_cur."!mark_push"(0, rx2488_pos, $I10)
  rxscan2492_done:
.annotate 'line', 747
  # rx subrule "LANG" subtype=capture negate=
    rx2488_cur."!cursor_pos"(rx2488_pos)
    $P10 = rx2488_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2488_fail
    rx2488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2488_pos = $P10."pos"()
.annotate 'line', 746
  # rx pass
    rx2488_cur."!cursor_pass"(rx2488_pos, "codeblock")
    if_null rx2488_debug, debug_1404
    rx2488_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2488_pos)
  debug_1404:
    .return (rx2488_cur)
  rx2488_restart:
.annotate 'line', 710
    if_null rx2488_debug, debug_1405
    rx2488_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1405:
  rx2488_fail:
    (rx2488_rep, rx2488_pos, $I10, $P10) = rx2488_cur."!mark_fail"(0)
    lt rx2488_pos, -1, rx2488_done
    eq rx2488_pos, -1, rx2488_fail
    jump $I10
  rx2488_done:
    rx2488_cur."!cursor_fail"()
    if_null rx2488_debug, debug_1406
    rx2488_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1406:
    .return (rx2488_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("404_1303391609.928") :method
.annotate 'line', 710
    $P2490 = self."!PREFIX__!subrule"("LANG", "")
    new $P2491, "ResizablePMCArray"
    push $P2491, $P2490
    .return ($P2491)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2532"  :subid("406_1303391609.928") :outer("10_1303391609.928")
.annotate 'line', 753
    .const 'Sub' $P5761 = "561_1303391609.928" 
    capture_lex $P5761
    .const 'Sub' $P5748 = "560_1303391609.928" 
    capture_lex $P5748
    .const 'Sub' $P5743 = "559_1303391609.928" 
    capture_lex $P5743
    .const 'Sub' $P5738 = "558_1303391609.928" 
    capture_lex $P5738
    .const 'Sub' $P5733 = "557_1303391609.928" 
    capture_lex $P5733
    .const 'Sub' $P5722 = "556_1303391609.928" 
    capture_lex $P5722
    .const 'Sub' $P5714 = "555_1303391609.928" 
    capture_lex $P5714
    .const 'Sub' $P5706 = "554_1303391609.928" 
    capture_lex $P5706
    .const 'Sub' $P5698 = "553_1303391609.928" 
    capture_lex $P5698
    .const 'Sub' $P5693 = "552_1303391609.928" 
    capture_lex $P5693
    .const 'Sub' $P5681 = "551_1303391609.928" 
    capture_lex $P5681
    .const 'Sub' $P5673 = "550_1303391609.928" 
    capture_lex $P5673
    .const 'Sub' $P5626 = "549_1303391609.928" 
    capture_lex $P5626
    .const 'Sub' $P5614 = "548_1303391609.928" 
    capture_lex $P5614
    .const 'Sub' $P5606 = "547_1303391609.928" 
    capture_lex $P5606
    .const 'Sub' $P5598 = "546_1303391609.928" 
    capture_lex $P5598
    .const 'Sub' $P5590 = "545_1303391609.928" 
    capture_lex $P5590
    .const 'Sub' $P5582 = "544_1303391609.928" 
    capture_lex $P5582
    .const 'Sub' $P5574 = "543_1303391609.928" 
    capture_lex $P5574
    .const 'Sub' $P5548 = "542_1303391609.928" 
    capture_lex $P5548
    .const 'Sub' $P5533 = "541_1303391609.928" 
    capture_lex $P5533
    .const 'Sub' $P5525 = "540_1303391609.928" 
    capture_lex $P5525
    .const 'Sub' $P5514 = "539_1303391609.928" 
    capture_lex $P5514
    .const 'Sub' $P5503 = "538_1303391609.928" 
    capture_lex $P5503
    .const 'Sub' $P5492 = "537_1303391609.928" 
    capture_lex $P5492
    .const 'Sub' $P5484 = "536_1303391609.928" 
    capture_lex $P5484
    .const 'Sub' $P5457 = "535_1303391609.928" 
    capture_lex $P5457
    .const 'Sub' $P5419 = "533_1303391609.928" 
    capture_lex $P5419
    .const 'Sub' $P5411 = "532_1303391609.928" 
    capture_lex $P5411
    .const 'Sub' $P5403 = "531_1303391609.928" 
    capture_lex $P5403
    .const 'Sub' $P5378 = "530_1303391609.928" 
    capture_lex $P5378
    .const 'Sub' $P5362 = "529_1303391609.928" 
    capture_lex $P5362
    .const 'Sub' $P5354 = "528_1303391609.928" 
    capture_lex $P5354
    .const 'Sub' $P5346 = "527_1303391609.928" 
    capture_lex $P5346
    .const 'Sub' $P5244 = "524_1303391609.928" 
    capture_lex $P5244
    .const 'Sub' $P5236 = "523_1303391609.928" 
    capture_lex $P5236
    .const 'Sub' $P5229 = "522_1303391609.928" 
    capture_lex $P5229
    .const 'Sub' $P5198 = "521_1303391609.928" 
    capture_lex $P5198
    .const 'Sub' $P5145 = "519_1303391609.928" 
    capture_lex $P5145
    .const 'Sub' $P5131 = "518_1303391609.928" 
    capture_lex $P5131
    .const 'Sub' $P5124 = "517_1303391609.928" 
    capture_lex $P5124
    .const 'Sub' $P5075 = "516_1303391609.928" 
    capture_lex $P5075
    .const 'Sub' $P4899 = "512_1303391609.928" 
    capture_lex $P4899
    .const 'Sub' $P4836 = "510_1303391609.928" 
    capture_lex $P4836
    .const 'Sub' $P4828 = "509_1303391609.928" 
    capture_lex $P4828
    .const 'Sub' $P4813 = "508_1303391609.928" 
    capture_lex $P4813
    .const 'Sub' $P4798 = "507_1303391609.928" 
    capture_lex $P4798
    .const 'Sub' $P4778 = "506_1303391609.928" 
    capture_lex $P4778
    .const 'Sub' $P4675 = "505_1303391609.928" 
    capture_lex $P4675
    .const 'Sub' $P4627 = "502_1303391609.928" 
    capture_lex $P4627
    .const 'Sub' $P4502 = "499_1303391609.928" 
    capture_lex $P4502
    .const 'Sub' $P4229 = "492_1303391609.928" 
    capture_lex $P4229
    .const 'Sub' $P4221 = "491_1303391609.928" 
    capture_lex $P4221
    .const 'Sub' $P4213 = "490_1303391609.928" 
    capture_lex $P4213
    .const 'Sub' $P4105 = "487_1303391609.928" 
    capture_lex $P4105
    .const 'Sub' $P4097 = "486_1303391609.928" 
    capture_lex $P4097
    .const 'Sub' $P4082 = "485_1303391609.928" 
    capture_lex $P4082
    .const 'Sub' $P4067 = "484_1303391609.928" 
    capture_lex $P4067
    .const 'Sub' $P4052 = "483_1303391609.928" 
    capture_lex $P4052
    .const 'Sub' $P4030 = "482_1303391609.928" 
    capture_lex $P4030
    .const 'Sub' $P4022 = "481_1303391609.928" 
    capture_lex $P4022
    .const 'Sub' $P4014 = "480_1303391609.928" 
    capture_lex $P4014
    .const 'Sub' $P4006 = "479_1303391609.928" 
    capture_lex $P4006
    .const 'Sub' $P3783 = "476_1303391609.928" 
    capture_lex $P3783
    .const 'Sub' $P3775 = "475_1303391609.928" 
    capture_lex $P3775
    .const 'Sub' $P3767 = "474_1303391609.928" 
    capture_lex $P3767
    .const 'Sub' $P3759 = "473_1303391609.928" 
    capture_lex $P3759
    .const 'Sub' $P3751 = "472_1303391609.928" 
    capture_lex $P3751
    .const 'Sub' $P3743 = "471_1303391609.928" 
    capture_lex $P3743
    .const 'Sub' $P3735 = "470_1303391609.928" 
    capture_lex $P3735
    .const 'Sub' $P3624 = "468_1303391609.928" 
    capture_lex $P3624
    .const 'Sub' $P3600 = "467_1303391609.928" 
    capture_lex $P3600
    .const 'Sub' $P3586 = "466_1303391609.928" 
    capture_lex $P3586
    .const 'Sub' $P3578 = "465_1303391609.928" 
    capture_lex $P3578
    .const 'Sub' $P3570 = "464_1303391609.928" 
    capture_lex $P3570
    .const 'Sub' $P3562 = "463_1303391609.928" 
    capture_lex $P3562
    .const 'Sub' $P3554 = "462_1303391609.928" 
    capture_lex $P3554
    .const 'Sub' $P3546 = "461_1303391609.928" 
    capture_lex $P3546
    .const 'Sub' $P3538 = "460_1303391609.928" 
    capture_lex $P3538
    .const 'Sub' $P3530 = "459_1303391609.928" 
    capture_lex $P3530
    .const 'Sub' $P3522 = "458_1303391609.928" 
    capture_lex $P3522
    .const 'Sub' $P3514 = "457_1303391609.928" 
    capture_lex $P3514
    .const 'Sub' $P3506 = "456_1303391609.928" 
    capture_lex $P3506
    .const 'Sub' $P3498 = "455_1303391609.928" 
    capture_lex $P3498
    .const 'Sub' $P3490 = "454_1303391609.928" 
    capture_lex $P3490
    .const 'Sub' $P3482 = "453_1303391609.928" 
    capture_lex $P3482
    .const 'Sub' $P3466 = "452_1303391609.928" 
    capture_lex $P3466
    .const 'Sub' $P3433 = "451_1303391609.928" 
    capture_lex $P3433
    .const 'Sub' $P3419 = "450_1303391609.928" 
    capture_lex $P3419
    .const 'Sub' $P3398 = "449_1303391609.928" 
    capture_lex $P3398
    .const 'Sub' $P3378 = "448_1303391609.928" 
    capture_lex $P3378
    .const 'Sub' $P3354 = "447_1303391609.928" 
    capture_lex $P3354
    .const 'Sub' $P3320 = "446_1303391609.928" 
    capture_lex $P3320
    .const 'Sub' $P3305 = "445_1303391609.928" 
    capture_lex $P3305
    .const 'Sub' $P3293 = "444_1303391609.928" 
    capture_lex $P3293
    .const 'Sub' $P3242 = "442_1303391609.928" 
    capture_lex $P3242
    .const 'Sub' $P3231 = "441_1303391609.928" 
    capture_lex $P3231
    .const 'Sub' $P3224 = "440_1303391609.928" 
    capture_lex $P3224
    .const 'Sub' $P3201 = "439_1303391609.928" 
    capture_lex $P3201
    .const 'Sub' $P3179 = "438_1303391609.928" 
    capture_lex $P3179
    .const 'Sub' $P3168 = "437_1303391609.928" 
    capture_lex $P3168
    .const 'Sub' $P3131 = "435_1303391609.928" 
    capture_lex $P3131
    .const 'Sub' $P3123 = "434_1303391609.928" 
    capture_lex $P3123
    .const 'Sub' $P3115 = "433_1303391609.928" 
    capture_lex $P3115
    .const 'Sub' $P3101 = "432_1303391609.928" 
    capture_lex $P3101
    .const 'Sub' $P3020 = "430_1303391609.928" 
    capture_lex $P3020
    .const 'Sub' $P2979 = "428_1303391609.928" 
    capture_lex $P2979
    .const 'Sub' $P2912 = "427_1303391609.928" 
    capture_lex $P2912
    .const 'Sub' $P2881 = "426_1303391609.928" 
    capture_lex $P2881
    .const 'Sub' $P2873 = "425_1303391609.928" 
    capture_lex $P2873
    .const 'Sub' $P2830 = "423_1303391609.928" 
    capture_lex $P2830
    .const 'Sub' $P2825 = "422_1303391609.928" 
    capture_lex $P2825
    .const 'Sub' $P2820 = "421_1303391609.928" 
    capture_lex $P2820
    .const 'Sub' $P2749 = "418_1303391609.928" 
    capture_lex $P2749
    .const 'Sub' $P2737 = "417_1303391609.928" 
    capture_lex $P2737
    .const 'Sub' $P2672 = "415_1303391609.928" 
    capture_lex $P2672
    .const 'Sub' $P2660 = "414_1303391609.928" 
    capture_lex $P2660
    .const 'Sub' $P2606 = "413_1303391609.928" 
    capture_lex $P2606
    .const 'Sub' $P2593 = "412_1303391609.928" 
    capture_lex $P2593
    .const 'Sub' $P2575 = "411_1303391609.928" 
    capture_lex $P2575
    .const 'Sub' $P2542 = "408_1303391609.928" 
    capture_lex $P2542
    .const 'Sub' $P2534 = "407_1303391609.928" 
    capture_lex $P2534
.annotate 'line', 757
    .const 'Sub' $P2534 = "407_1303391609.928" 
    newclosure $P2541, $P2534
    .lex "xblock_immediate", $P2541
.annotate 'line', 762
    .const 'Sub' $P2542 = "408_1303391609.928" 
    newclosure $P2574, $P2542
    .lex "block_immediate", $P2574
.annotate 'line', 772
    .const 'Sub' $P2575 = "411_1303391609.928" 
    newclosure $P2592, $P2575
    .lex "vivitype", $P2592
.annotate 'line', 791
    .const 'Sub' $P2593 = "412_1303391609.928" 
    newclosure $P2605, $P2593
    .lex "colonpair_str", $P2605
.annotate 'line', 1039
    .const 'Sub' $P2606 = "413_1303391609.928" 
    newclosure $P2659, $P2606
    .lex "push_block_handler", $P2659
.annotate 'line', 1605
    .const 'Sub' $P2660 = "414_1303391609.928" 
    newclosure $P2671, $P2660
    .lex "only_star_block", $P2671
.annotate 'line', 1614
    .const 'Sub' $P2672 = "415_1303391609.928" 
    newclosure $P2736, $P2672
    .lex "attach_multi_signature", $P2736
.annotate 'line', 2086
    .const 'Sub' $P2737 = "417_1303391609.928" 
    newclosure $P2748, $P2737
    .lex "control", $P2748
.annotate 'line', 2105
    .const 'Sub' $P2749 = "418_1303391609.928" 
    newclosure $P2819, $P2749
    .lex "lexical_package_lookup", $P2819
.annotate 'line', 2150
    .const 'Sub' $P2820 = "421_1303391609.928" 
    newclosure $P2824, $P2820
    .lex "is_lexical", $P2824
.annotate 'line', 2156
    .const 'Sub' $P2825 = "422_1303391609.928" 
    newclosure $P2829, $P2825
    .lex "is_package", $P2829
.annotate 'line', 2162
    .const 'Sub' $P2830 = "423_1303391609.928" 
    newclosure $P2864, $P2830
    .lex "is_scope", $P2864
.annotate 'line', 753
    .lex "$?PACKAGE", $P2865
    .lex "$?CLASS", $P2866
.annotate 'line', 755
    new $P2867, "ResizablePMCArray"
    find_lex $P2868, "$?PACKAGE"
    get_who $P2869, $P2868
    set $P2869["@BLOCK"], $P2867
    find_lex $P2870, "xblock_immediate"
    find_lex $P2871, "block_immediate"
    find_lex $P2872, "vivitype"
.annotate 'line', 783
    find_lex $P2911, "colonpair_str"
.annotate 'line', 1032
    find_lex $P3418, "push_block_handler"
.annotate 'line', 1533
    find_lex $P4625, "only_star_block"
    find_lex $P4626, "attach_multi_signature"
.annotate 'line', 2077
    find_lex $P5732, "control"
.annotate 'line', 2099
    find_lex $P5756, "lexical_package_lookup"
    find_lex $P5757, "is_lexical"
    find_lex $P5758, "is_package"
    find_lex $P5759, "is_scope"
.annotate 'line', 753
    .return ($P5759)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1407") :outer("406_1303391609.928")
.annotate 'line', 753
    get_hll_global $P2533, ["NQP";"Actions"], "_block2532" 
    .local pmc block
    set block, $P2533
    .const 'Sub' $P5761 = "561_1303391609.928" 
    capture_lex $P5761
    $P5761()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5760"  :anon :subid("561_1303391609.928") :outer("406_1303391609.928")
.annotate 'line', 753
    nqp_get_sc_object $P5762, "1303391598.821", 3
    .local pmc type_obj
    set type_obj, $P5762
    get_how $P5763, type_obj
    .const 'Sub' $P5764 = "425_1303391609.928" 
    $P5763."add_method"(type_obj, "TOP", $P5764)
    get_how $P5765, type_obj
    .const 'Sub' $P5766 = "426_1303391609.928" 
    $P5765."add_method"(type_obj, "deflongname", $P5766)
    get_how $P5767, type_obj
    .const 'Sub' $P5768 = "427_1303391609.928" 
    $P5767."add_method"(type_obj, "comp_unit", $P5768)
    get_how $P5769, type_obj
    .const 'Sub' $P5770 = "428_1303391609.928" 
    $P5769."add_method"(type_obj, "statementlist", $P5770)
    get_how $P5771, type_obj
    .const 'Sub' $P5772 = "430_1303391609.928" 
    $P5771."add_method"(type_obj, "statement", $P5772)
    get_how $P5773, type_obj
    .const 'Sub' $P5774 = "432_1303391609.928" 
    $P5773."add_method"(type_obj, "xblock", $P5774)
    get_how $P5775, type_obj
    .const 'Sub' $P5776 = "433_1303391609.928" 
    $P5775."add_method"(type_obj, "pblock", $P5776)
    get_how $P5777, type_obj
    .const 'Sub' $P5778 = "434_1303391609.928" 
    $P5777."add_method"(type_obj, "block", $P5778)
    get_how $P5779, type_obj
    .const 'Sub' $P5780 = "435_1303391609.928" 
    $P5779."add_method"(type_obj, "blockoid", $P5780)
    get_how $P5781, type_obj
    .const 'Sub' $P5782 = "437_1303391609.928" 
    $P5781."add_method"(type_obj, "newpad", $P5782)
    get_how $P5783, type_obj
    .const 'Sub' $P5784 = "438_1303391609.928" 
    $P5783."add_method"(type_obj, "outerctx", $P5784)
    get_how $P5785, type_obj
    .const 'Sub' $P5786 = "439_1303391609.928" 
    $P5785."add_method"(type_obj, "GLOBALish", $P5786)
    get_how $P5787, type_obj
    .const 'Sub' $P5788 = "440_1303391609.928" 
    $P5787."add_method"(type_obj, "you_are_here", $P5788)
    get_how $P5789, type_obj
    .const 'Sub' $P5790 = "441_1303391609.928" 
    $P5789."add_method"(type_obj, "statement_control:sym<use>", $P5790)
    get_how $P5791, type_obj
    .const 'Sub' $P5792 = "442_1303391609.928" 
    $P5791."add_method"(type_obj, "statement_control:sym<if>", $P5792)
    get_how $P5793, type_obj
    .const 'Sub' $P5794 = "444_1303391609.928" 
    $P5793."add_method"(type_obj, "statement_control:sym<unless>", $P5794)
    get_how $P5795, type_obj
    .const 'Sub' $P5796 = "445_1303391609.928" 
    $P5795."add_method"(type_obj, "statement_control:sym<while>", $P5796)
    get_how $P5797, type_obj
    .const 'Sub' $P5798 = "446_1303391609.928" 
    $P5797."add_method"(type_obj, "statement_control:sym<repeat>", $P5798)
    get_how $P5799, type_obj
    .const 'Sub' $P5800 = "447_1303391609.928" 
    $P5799."add_method"(type_obj, "statement_control:sym<for>", $P5800)
    get_how $P5801, type_obj
    .const 'Sub' $P5802 = "448_1303391609.928" 
    $P5801."add_method"(type_obj, "statement_control:sym<CATCH>", $P5802)
    get_how $P5803, type_obj
    .const 'Sub' $P5804 = "449_1303391609.928" 
    $P5803."add_method"(type_obj, "statement_control:sym<CONTROL>", $P5804)
    get_how $P5805, type_obj
    .const 'Sub' $P5806 = "450_1303391609.928" 
    $P5805."add_method"(type_obj, "statement_prefix:sym<INIT>", $P5806)
    get_how $P5807, type_obj
    .const 'Sub' $P5808 = "451_1303391609.928" 
    $P5807."add_method"(type_obj, "statement_prefix:sym<try>", $P5808)
    get_how $P5809, type_obj
    .const 'Sub' $P5810 = "452_1303391609.928" 
    $P5809."add_method"(type_obj, "blorst", $P5810)
    get_how $P5811, type_obj
    .const 'Sub' $P5812 = "453_1303391609.928" 
    $P5811."add_method"(type_obj, "statement_mod_cond:sym<if>", $P5812)
    get_how $P5813, type_obj
    .const 'Sub' $P5814 = "454_1303391609.928" 
    $P5813."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P5814)
    get_how $P5815, type_obj
    .const 'Sub' $P5816 = "455_1303391609.928" 
    $P5815."add_method"(type_obj, "statement_mod_loop:sym<while>", $P5816)
    get_how $P5817, type_obj
    .const 'Sub' $P5818 = "456_1303391609.928" 
    $P5817."add_method"(type_obj, "statement_mod_loop:sym<until>", $P5818)
    get_how $P5819, type_obj
    .const 'Sub' $P5820 = "457_1303391609.928" 
    $P5819."add_method"(type_obj, "term:sym<fatarrow>", $P5820)
    get_how $P5821, type_obj
    .const 'Sub' $P5822 = "458_1303391609.928" 
    $P5821."add_method"(type_obj, "term:sym<colonpair>", $P5822)
    get_how $P5823, type_obj
    .const 'Sub' $P5824 = "459_1303391609.928" 
    $P5823."add_method"(type_obj, "term:sym<variable>", $P5824)
    get_how $P5825, type_obj
    .const 'Sub' $P5826 = "460_1303391609.928" 
    $P5825."add_method"(type_obj, "term:sym<package_declarator>", $P5826)
    get_how $P5827, type_obj
    .const 'Sub' $P5828 = "461_1303391609.928" 
    $P5827."add_method"(type_obj, "term:sym<scope_declarator>", $P5828)
    get_how $P5829, type_obj
    .const 'Sub' $P5830 = "462_1303391609.928" 
    $P5829."add_method"(type_obj, "term:sym<routine_declarator>", $P5830)
    get_how $P5831, type_obj
    .const 'Sub' $P5832 = "463_1303391609.928" 
    $P5831."add_method"(type_obj, "term:sym<regex_declarator>", $P5832)
    get_how $P5833, type_obj
    .const 'Sub' $P5834 = "464_1303391609.928" 
    $P5833."add_method"(type_obj, "term:sym<statement_prefix>", $P5834)
    get_how $P5835, type_obj
    .const 'Sub' $P5836 = "465_1303391609.928" 
    $P5835."add_method"(type_obj, "term:sym<lambda>", $P5836)
    get_how $P5837, type_obj
    .const 'Sub' $P5838 = "466_1303391609.928" 
    $P5837."add_method"(type_obj, "fatarrow", $P5838)
    get_how $P5839, type_obj
    .const 'Sub' $P5840 = "467_1303391609.928" 
    $P5839."add_method"(type_obj, "colonpair", $P5840)
    get_how $P5841, type_obj
    .const 'Sub' $P5842 = "468_1303391609.928" 
    $P5841."add_method"(type_obj, "variable", $P5842)
    get_how $P5843, type_obj
    .const 'Sub' $P5844 = "470_1303391609.928" 
    $P5843."add_method"(type_obj, "package_declarator:sym<module>", $P5844)
    get_how $P5845, type_obj
    .const 'Sub' $P5846 = "471_1303391609.928" 
    $P5845."add_method"(type_obj, "package_declarator:sym<knowhow>", $P5846)
    get_how $P5847, type_obj
    .const 'Sub' $P5848 = "472_1303391609.928" 
    $P5847."add_method"(type_obj, "package_declarator:sym<class>", $P5848)
    get_how $P5849, type_obj
    .const 'Sub' $P5850 = "473_1303391609.928" 
    $P5849."add_method"(type_obj, "package_declarator:sym<grammar>", $P5850)
    get_how $P5851, type_obj
    .const 'Sub' $P5852 = "474_1303391609.928" 
    $P5851."add_method"(type_obj, "package_declarator:sym<role>", $P5852)
    get_how $P5853, type_obj
    .const 'Sub' $P5854 = "475_1303391609.928" 
    $P5853."add_method"(type_obj, "package_declarator:sym<native>", $P5854)
    get_how $P5855, type_obj
    .const 'Sub' $P5856 = "476_1303391609.928" 
    $P5855."add_method"(type_obj, "package_def", $P5856)
    get_how $P5857, type_obj
    .const 'Sub' $P5858 = "479_1303391609.928" 
    $P5857."add_method"(type_obj, "scope_declarator:sym<my>", $P5858)
    get_how $P5859, type_obj
    .const 'Sub' $P5860 = "480_1303391609.928" 
    $P5859."add_method"(type_obj, "scope_declarator:sym<our>", $P5860)
    get_how $P5861, type_obj
    .const 'Sub' $P5862 = "481_1303391609.928" 
    $P5861."add_method"(type_obj, "scope_declarator:sym<has>", $P5862)
    get_how $P5863, type_obj
    .const 'Sub' $P5864 = "482_1303391609.928" 
    $P5863."add_method"(type_obj, "scoped", $P5864)
    get_how $P5865, type_obj
    .const 'Sub' $P5866 = "483_1303391609.928" 
    $P5865."add_method"(type_obj, "declarator", $P5866)
    get_how $P5867, type_obj
    .const 'Sub' $P5868 = "484_1303391609.928" 
    $P5867."add_method"(type_obj, "multi_declarator:sym<multi>", $P5868)
    get_how $P5869, type_obj
    .const 'Sub' $P5870 = "485_1303391609.928" 
    $P5869."add_method"(type_obj, "multi_declarator:sym<proto>", $P5870)
    get_how $P5871, type_obj
    .const 'Sub' $P5872 = "486_1303391609.928" 
    $P5871."add_method"(type_obj, "multi_declarator:sym<null>", $P5872)
    get_how $P5873, type_obj
    .const 'Sub' $P5874 = "487_1303391609.928" 
    $P5873."add_method"(type_obj, "variable_declarator", $P5874)
    get_how $P5875, type_obj
    .const 'Sub' $P5876 = "490_1303391609.928" 
    $P5875."add_method"(type_obj, "routine_declarator:sym<sub>", $P5876)
    get_how $P5877, type_obj
    .const 'Sub' $P5878 = "491_1303391609.928" 
    $P5877."add_method"(type_obj, "routine_declarator:sym<method>", $P5878)
    get_how $P5879, type_obj
    .const 'Sub' $P5880 = "492_1303391609.928" 
    $P5879."add_method"(type_obj, "routine_def", $P5880)
    get_how $P5881, type_obj
    .const 'Sub' $P5882 = "499_1303391609.928" 
    $P5881."add_method"(type_obj, "method_def", $P5882)
    get_how $P5883, type_obj
    .const 'Sub' $P5884 = "502_1303391609.928" 
    $P5883."add_method"(type_obj, "signature", $P5884)
    get_how $P5885, type_obj
    .const 'Sub' $P5886 = "505_1303391609.928" 
    $P5885."add_method"(type_obj, "parameter", $P5886)
    get_how $P5887, type_obj
    .const 'Sub' $P5888 = "506_1303391609.928" 
    $P5887."add_method"(type_obj, "param_var", $P5888)
    get_how $P5889, type_obj
    .const 'Sub' $P5890 = "507_1303391609.928" 
    $P5889."add_method"(type_obj, "named_param", $P5890)
    get_how $P5891, type_obj
    .const 'Sub' $P5892 = "508_1303391609.928" 
    $P5891."add_method"(type_obj, "typename", $P5892)
    get_how $P5893, type_obj
    .const 'Sub' $P5894 = "509_1303391609.928" 
    $P5893."add_method"(type_obj, "trait", $P5894)
    get_how $P5895, type_obj
    .const 'Sub' $P5896 = "510_1303391609.928" 
    $P5895."add_method"(type_obj, "trait_mod:sym<is>", $P5896)
    get_how $P5897, type_obj
    .const 'Sub' $P5898 = "512_1303391609.928" 
    $P5897."add_method"(type_obj, "regex_declarator", $P5898)
    get_how $P5899, type_obj
    .const 'Sub' $P5900 = "516_1303391609.928" 
    $P5899."add_method"(type_obj, "dotty", $P5900)
    get_how $P5901, type_obj
    .const 'Sub' $P5902 = "517_1303391609.928" 
    $P5901."add_method"(type_obj, "term:sym<self>", $P5902)
    get_how $P5903, type_obj
    .const 'Sub' $P5904 = "518_1303391609.928" 
    $P5903."add_method"(type_obj, "term:sym<identifier>", $P5904)
    get_how $P5905, type_obj
    .const 'Sub' $P5906 = "519_1303391609.928" 
    $P5905."add_method"(type_obj, "term:sym<name>", $P5906)
    get_how $P5907, type_obj
    .const 'Sub' $P5908 = "521_1303391609.928" 
    $P5907."add_method"(type_obj, "term:sym<pir::op>", $P5908)
    get_how $P5909, type_obj
    .const 'Sub' $P5910 = "522_1303391609.928" 
    $P5909."add_method"(type_obj, "term:sym<onlystar>", $P5910)
    get_how $P5911, type_obj
    .const 'Sub' $P5912 = "523_1303391609.928" 
    $P5911."add_method"(type_obj, "args", $P5912)
    get_how $P5913, type_obj
    .const 'Sub' $P5914 = "524_1303391609.928" 
    $P5913."add_method"(type_obj, "arglist", $P5914)
    get_how $P5915, type_obj
    .const 'Sub' $P5916 = "527_1303391609.928" 
    $P5915."add_method"(type_obj, "term:sym<multi_declarator>", $P5916)
    get_how $P5917, type_obj
    .const 'Sub' $P5918 = "528_1303391609.928" 
    $P5917."add_method"(type_obj, "term:sym<value>", $P5918)
    get_how $P5919, type_obj
    .const 'Sub' $P5920 = "529_1303391609.928" 
    $P5919."add_method"(type_obj, "circumfix:sym<( )>", $P5920)
    get_how $P5921, type_obj
    .const 'Sub' $P5922 = "530_1303391609.928" 
    $P5921."add_method"(type_obj, "circumfix:sym<[ ]>", $P5922)
    get_how $P5923, type_obj
    .const 'Sub' $P5924 = "531_1303391609.928" 
    $P5923."add_method"(type_obj, "circumfix:sym<ang>", $P5924)
    get_how $P5925, type_obj
    .const 'Sub' $P5926 = "532_1303391609.928" 
    $P5925."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P5926)
    get_how $P5927, type_obj
    .const 'Sub' $P5928 = "533_1303391609.928" 
    $P5927."add_method"(type_obj, "circumfix:sym<{ }>", $P5928)
    get_how $P5929, type_obj
    .const 'Sub' $P5930 = "535_1303391609.928" 
    $P5929."add_method"(type_obj, "circumfix:sym<sigil>", $P5930)
    get_how $P5931, type_obj
    .const 'Sub' $P5932 = "536_1303391609.928" 
    $P5931."add_method"(type_obj, "semilist", $P5932)
    get_how $P5933, type_obj
    .const 'Sub' $P5934 = "537_1303391609.928" 
    $P5933."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P5934)
    get_how $P5935, type_obj
    .const 'Sub' $P5936 = "538_1303391609.928" 
    $P5935."add_method"(type_obj, "postcircumfix:sym<{ }>", $P5936)
    get_how $P5937, type_obj
    .const 'Sub' $P5938 = "539_1303391609.928" 
    $P5937."add_method"(type_obj, "postcircumfix:sym<ang>", $P5938)
    get_how $P5939, type_obj
    .const 'Sub' $P5940 = "540_1303391609.928" 
    $P5939."add_method"(type_obj, "postcircumfix:sym<( )>", $P5940)
    get_how $P5941, type_obj
    .const 'Sub' $P5942 = "541_1303391609.928" 
    $P5941."add_method"(type_obj, "value", $P5942)
    get_how $P5943, type_obj
    .const 'Sub' $P5944 = "542_1303391609.928" 
    $P5943."add_method"(type_obj, "number", $P5944)
    get_how $P5945, type_obj
    .const 'Sub' $P5946 = "543_1303391609.928" 
    $P5945."add_method"(type_obj, "quote:sym<apos>", $P5946)
    get_how $P5947, type_obj
    .const 'Sub' $P5948 = "544_1303391609.928" 
    $P5947."add_method"(type_obj, "quote:sym<dblq>", $P5948)
    get_how $P5949, type_obj
    .const 'Sub' $P5950 = "545_1303391609.928" 
    $P5949."add_method"(type_obj, "quote:sym<qq>", $P5950)
    get_how $P5951, type_obj
    .const 'Sub' $P5952 = "546_1303391609.928" 
    $P5951."add_method"(type_obj, "quote:sym<q>", $P5952)
    get_how $P5953, type_obj
    .const 'Sub' $P5954 = "547_1303391609.928" 
    $P5953."add_method"(type_obj, "quote:sym<Q>", $P5954)
    get_how $P5955, type_obj
    .const 'Sub' $P5956 = "548_1303391609.928" 
    $P5955."add_method"(type_obj, "quote:sym<Q:PIR>", $P5956)
    get_how $P5957, type_obj
    .const 'Sub' $P5958 = "549_1303391609.928" 
    $P5957."add_method"(type_obj, "quote:sym</ />", $P5958)
    get_how $P5959, type_obj
    .const 'Sub' $P5960 = "550_1303391609.928" 
    $P5959."add_method"(type_obj, "quote_escape:sym<$>", $P5960)
    get_how $P5961, type_obj
    .const 'Sub' $P5962 = "551_1303391609.928" 
    $P5961."add_method"(type_obj, "quote_escape:sym<{ }>", $P5962)
    get_how $P5963, type_obj
    .const 'Sub' $P5964 = "552_1303391609.928" 
    $P5963."add_method"(type_obj, "quote_escape:sym<esc>", $P5964)
    get_how $P5965, type_obj
    .const 'Sub' $P5966 = "553_1303391609.928" 
    $P5965."add_method"(type_obj, "postfix:sym<.>", $P5966)
    get_how $P5967, type_obj
    .const 'Sub' $P5968 = "554_1303391609.928" 
    $P5967."add_method"(type_obj, "postfix:sym<++>", $P5968)
    get_how $P5969, type_obj
    .const 'Sub' $P5970 = "555_1303391609.928" 
    $P5969."add_method"(type_obj, "postfix:sym<-->", $P5970)
    get_how $P5971, type_obj
    .const 'Sub' $P5972 = "556_1303391609.928" 
    $P5971."add_method"(type_obj, "prefix:sym<make>", $P5972)
    get_how $P5973, type_obj
    .const 'Sub' $P5974 = "557_1303391609.928" 
    $P5973."add_method"(type_obj, "term:sym<next>", $P5974)
    get_how $P5975, type_obj
    .const 'Sub' $P5976 = "558_1303391609.928" 
    $P5975."add_method"(type_obj, "term:sym<last>", $P5976)
    get_how $P5977, type_obj
    .const 'Sub' $P5978 = "559_1303391609.928" 
    $P5977."add_method"(type_obj, "term:sym<redo>", $P5978)
    get_how $P5979, type_obj
    .const 'Sub' $P5980 = "560_1303391609.928" 
    $P5979."add_method"(type_obj, "infix:sym<~~>", $P5980)
    get_how $P5981, type_obj
    get_hll_global $P5982, ["HLL"], "Actions"
    $P5981."add_parent"(type_obj, $P5982)
    get_how $P5983, type_obj
    $P5984 = $P5983."compose"(type_obj)
    .return ($P5984)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("407_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2535
.annotate 'line', 757
    .lex "$xblock", param_2535
.annotate 'line', 758
    find_lex $P2536, "$xblock"
    unless_null $P2536, vivify_1408
    $P2536 = root_new ['parrot';'ResizablePMCArray']
  vivify_1408:
    set $P2537, $P2536[1]
    unless_null $P2537, vivify_1409
    new $P2537, "Undef"
  vivify_1409:
    $P2538 = "block_immediate"($P2537)
    find_lex $P2539, "$xblock"
    unless_null $P2539, vivify_1410
    $P2539 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2539
  vivify_1410:
    set $P2539[1], $P2538
    find_lex $P2540, "$xblock"
    unless_null $P2540, vivify_1411
    new $P2540, "Undef"
  vivify_1411:
.annotate 'line', 757
    .return ($P2540)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("408_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2543
.annotate 'line', 762
    .const 'Sub' $P2553 = "409_1303391609.928" 
    capture_lex $P2553
    .lex "$block", param_2543
.annotate 'line', 763
    find_lex $P2544, "$block"
    unless_null $P2544, vivify_1412
    new $P2544, "Undef"
  vivify_1412:
    $P2544."blocktype"("immediate")
.annotate 'line', 764
    find_lex $P2548, "$block"
    unless_null $P2548, vivify_1413
    new $P2548, "Undef"
  vivify_1413:
    $P2549 = $P2548."symtable"()
    unless $P2549, unless_2547
    set $P2546, $P2549
    goto unless_2547_end
  unless_2547:
    find_lex $P2550, "$block"
    unless_null $P2550, vivify_1414
    new $P2550, "Undef"
  vivify_1414:
    $P2551 = $P2550."handlers"()
    set $P2546, $P2551
  unless_2547_end:
    if $P2546, unless_2545_end
    .const 'Sub' $P2553 = "409_1303391609.928" 
    capture_lex $P2553
    $P2553()
  unless_2545_end:
    find_lex $P2573, "$block"
    unless_null $P2573, vivify_1421
    new $P2573, "Undef"
  vivify_1421:
.annotate 'line', 762
    .return ($P2573)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2552"  :anon :subid("409_1303391609.928") :outer("408_1303391609.928")
.annotate 'line', 764
    .const 'Sub' $P2564 = "410_1303391609.928" 
    capture_lex $P2564
.annotate 'line', 765
    new $P2554, "Undef"
    .lex "$stmts", $P2554
    get_hll_global $P2555, ["PAST"], "Stmts"
    find_lex $P2556, "$block"
    unless_null $P2556, vivify_1415
    new $P2556, "Undef"
  vivify_1415:
    $P2557 = $P2555."new"($P2556 :named("node"))
    store_lex "$stmts", $P2557
.annotate 'line', 766
    find_lex $P2559, "$block"
    unless_null $P2559, vivify_1416
    new $P2559, "Undef"
  vivify_1416:
    $P2560 = $P2559."list"()
    defined $I2561, $P2560
    unless $I2561, for_undef_1417
    iter $P2558, $P2560
    new $P2570, 'ExceptionHandler'
    set_label $P2570, loop2569_handler
    $P2570."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2570
  loop2569_test:
    unless $P2558, loop2569_done
    shift $P2562, $P2558
  loop2569_redo:
    .const 'Sub' $P2564 = "410_1303391609.928" 
    capture_lex $P2564
    $P2564($P2562)
  loop2569_next:
    goto loop2569_test
  loop2569_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2571, exception, 'type'
    eq $P2571, .CONTROL_LOOP_NEXT, loop2569_next
    eq $P2571, .CONTROL_LOOP_REDO, loop2569_redo
  loop2569_done:
    pop_eh 
  for_undef_1417:
.annotate 'line', 767
    find_lex $P2572, "$stmts"
    unless_null $P2572, vivify_1420
    new $P2572, "Undef"
  vivify_1420:
    store_lex "$block", $P2572
.annotate 'line', 764
    .return ($P2572)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2563"  :anon :subid("410_1303391609.928") :outer("409_1303391609.928")
    .param pmc param_2565
.annotate 'line', 766
    .lex "$_", param_2565
    find_lex $P2566, "$stmts"
    unless_null $P2566, vivify_1418
    new $P2566, "Undef"
  vivify_1418:
    find_lex $P2567, "$_"
    unless_null $P2567, vivify_1419
    new $P2567, "Undef"
  vivify_1419:
    $P2568 = $P2566."push"($P2567)
    .return ($P2568)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("411_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2576
.annotate 'line', 772
    .lex "$sigil", param_2576
.annotate 'line', 773
    find_lex $P2579, "$sigil"
    unless_null $P2579, vivify_1422
    new $P2579, "Undef"
  vivify_1422:
    set $S2580, $P2579
    iseq $I2581, $S2580, "%"
    if $I2581, if_2578
.annotate 'line', 775
    find_lex $P2586, "$sigil"
    unless_null $P2586, vivify_1423
    new $P2586, "Undef"
  vivify_1423:
    set $S2587, $P2586
    iseq $I2588, $S2587, "@"
    if $I2588, if_2585
    new $P2591, "String"
    assign $P2591, "Undef"
    set $P2584, $P2591
    goto if_2585_end
  if_2585:
.annotate 'line', 776
    get_hll_global $P2589, ["PAST"], "Op"
    $P2590 = $P2589."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2584, $P2590
  if_2585_end:
    set $P2577, $P2584
.annotate 'line', 773
    goto if_2578_end
  if_2578:
.annotate 'line', 774
    get_hll_global $P2582, ["PAST"], "Op"
    $P2583 = $P2582."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2577, $P2583
  if_2578_end:
.annotate 'line', 772
    .return ($P2577)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("412_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2594
.annotate 'line', 791
    .lex "$ast", param_2594
.annotate 'line', 792
    get_hll_global $P2597, ["PAST"], "Op"
    find_lex $P2598, "$ast"
    unless_null $P2598, vivify_1424
    new $P2598, "Undef"
  vivify_1424:
    $P2599 = $P2597."ACCEPTS"($P2598)
    if $P2599, if_2596
.annotate 'line', 794
    find_lex $P2603, "$ast"
    unless_null $P2603, vivify_1425
    new $P2603, "Undef"
  vivify_1425:
    $P2604 = $P2603."value"()
    set $P2595, $P2604
.annotate 'line', 792
    goto if_2596_end
  if_2596:
.annotate 'line', 793
    find_lex $P2600, "$ast"
    unless_null $P2600, vivify_1426
    new $P2600, "Undef"
  vivify_1426:
    $P2601 = $P2600."list"()
    join $S2602, " ", $P2601
    new $P2595, 'String'
    set $P2595, $S2602
  if_2596_end:
.annotate 'line', 791
    .return ($P2595)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("413_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2607
    .param pmc param_2608
.annotate 'line', 1039
    .lex "$/", param_2607
    .lex "$block", param_2608
.annotate 'line', 1040
    find_lex $P2610, "$?PACKAGE"
    get_who $P2611, $P2610
    set $P2612, $P2611["@BLOCK"]
    unless_null $P2612, vivify_1427
    $P2612 = root_new ['parrot';'ResizablePMCArray']
  vivify_1427:
    set $P2613, $P2612[0]
    unless_null $P2613, vivify_1428
    new $P2613, "Undef"
  vivify_1428:
    $P2614 = $P2613."handlers"()
    if $P2614, unless_2609_end
.annotate 'line', 1041
    find_lex $P2615, "$?PACKAGE"
    get_who $P2616, $P2615
    set $P2617, $P2616["@BLOCK"]
    unless_null $P2617, vivify_1429
    $P2617 = root_new ['parrot';'ResizablePMCArray']
  vivify_1429:
    set $P2618, $P2617[0]
    unless_null $P2618, vivify_1430
    new $P2618, "Undef"
  vivify_1430:
    new $P2619, "ResizablePMCArray"
    $P2618."handlers"($P2619)
  unless_2609_end:
.annotate 'line', 1043
    find_lex $P2621, "$block"
    unless_null $P2621, vivify_1431
    new $P2621, "Undef"
  vivify_1431:
    $P2622 = $P2621."arity"()
    if $P2622, unless_2620_end
.annotate 'line', 1044
    find_lex $P2623, "$block"
    unless_null $P2623, vivify_1432
    new $P2623, "Undef"
  vivify_1432:
.annotate 'line', 1045
    get_hll_global $P2624, ["PAST"], "Op"
.annotate 'line', 1046
    get_hll_global $P2625, ["PAST"], "Var"
    $P2626 = $P2625."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1047
    get_hll_global $P2627, ["PAST"], "Var"
    $P2628 = $P2627."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2629 = $P2624."new"($P2626, $P2628, "bind" :named("pasttype"))
.annotate 'line', 1045
    $P2623."unshift"($P2629)
.annotate 'line', 1050
    find_lex $P2630, "$block"
    unless_null $P2630, vivify_1433
    new $P2630, "Undef"
  vivify_1433:
    get_hll_global $P2631, ["PAST"], "Var"
    $P2632 = $P2631."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2630."unshift"($P2632)
.annotate 'line', 1051
    find_lex $P2633, "$block"
    unless_null $P2633, vivify_1434
    new $P2633, "Undef"
  vivify_1434:
    $P2633."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1052
    find_lex $P2634, "$block"
    unless_null $P2634, vivify_1435
    new $P2634, "Undef"
  vivify_1435:
    $P2634."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1053
    find_lex $P2635, "$block"
    unless_null $P2635, vivify_1436
    new $P2635, "Undef"
  vivify_1436:
    $P2635."arity"(1)
  unless_2620_end:
.annotate 'line', 1055
    find_lex $P2636, "$block"
    unless_null $P2636, vivify_1437
    new $P2636, "Undef"
  vivify_1437:
    $P2636."blocktype"("declaration")
.annotate 'line', 1056
    find_lex $P2637, "$?PACKAGE"
    get_who $P2638, $P2637
    set $P2639, $P2638["@BLOCK"]
    unless_null $P2639, vivify_1438
    $P2639 = root_new ['parrot';'ResizablePMCArray']
  vivify_1438:
    set $P2640, $P2639[0]
    unless_null $P2640, vivify_1439
    new $P2640, "Undef"
  vivify_1439:
    $P2641 = $P2640."handlers"()
.annotate 'line', 1057
    get_hll_global $P2642, ["PAST"], "Control"
    find_lex $P2643, "$/"
    unless_null $P2643, vivify_1440
    new $P2643, "Undef"
  vivify_1440:
.annotate 'line', 1059
    get_hll_global $P2644, ["PAST"], "Stmts"
.annotate 'line', 1060
    get_hll_global $P2645, ["PAST"], "Op"
    find_lex $P2646, "$block"
    unless_null $P2646, vivify_1441
    new $P2646, "Undef"
  vivify_1441:
.annotate 'line', 1062
    get_hll_global $P2647, ["PAST"], "Var"
    $P2648 = $P2647."new"("register" :named("scope"), "exception" :named("name"))
    $P2649 = $P2645."new"($P2646, $P2648, "call" :named("pasttype"))
.annotate 'line', 1064
    get_hll_global $P2650, ["PAST"], "Op"
.annotate 'line', 1065
    get_hll_global $P2651, ["PAST"], "Var"
.annotate 'line', 1066
    get_hll_global $P2652, ["PAST"], "Var"
    $P2653 = $P2652."new"("register" :named("scope"), "exception" :named("name"))
    $P2654 = $P2651."new"($P2653, "handled", "keyed" :named("scope"))
.annotate 'line', 1065
    $P2655 = $P2650."new"($P2654, 1, "bind" :named("pasttype"))
.annotate 'line', 1064
    $P2656 = $P2644."new"($P2649, $P2655)
.annotate 'line', 1059
    $P2657 = $P2642."new"($P2656, $P2643 :named("node"))
.annotate 'line', 1057
    $P2658 = $P2641."unshift"($P2657)
.annotate 'line', 1039
    .return ($P2658)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("414_1303391609.928") :outer("406_1303391609.928")
.annotate 'line', 1606
    new $P2661, "Undef"
    .lex "$past", $P2661
    find_lex $P2662, "$?PACKAGE"
    get_who $P2663, $P2662
    set $P2664, $P2663["@BLOCK"]
    unless_null $P2664, vivify_1442
    $P2664 = root_new ['parrot';'ResizablePMCArray']
  vivify_1442:
    $P2665 = $P2664."shift"()
    store_lex "$past", $P2665
.annotate 'line', 1607
    find_lex $P2666, "$past"
    unless_null $P2666, vivify_1443
    new $P2666, "Undef"
  vivify_1443:
    $P2666."closure"(1)
.annotate 'line', 1608
    find_lex $P2667, "$past"
    unless_null $P2667, vivify_1444
    new $P2667, "Undef"
  vivify_1444:
    get_hll_global $P2668, ["PAST"], "Op"
    $P2669 = $P2668."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2667."push"($P2669)
    find_lex $P2670, "$past"
    unless_null $P2670, vivify_1445
    new $P2670, "Undef"
  vivify_1445:
.annotate 'line', 1605
    .return ($P2670)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("415_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2673
.annotate 'line', 1614
    .const 'Sub' $P2687 = "416_1303391609.928" 
    capture_lex $P2687
    .lex "$routine", param_2673
.annotate 'line', 1618
    new $P2674, "Undef"
    .lex "$types", $P2674
.annotate 'line', 1619
    new $P2675, "Undef"
    .lex "$definednesses", $P2675
.annotate 'line', 1618
    get_hll_global $P2676, ["PAST"], "Op"
    $P2677 = $P2676."new"("list" :named("pasttype"))
    store_lex "$types", $P2677
.annotate 'line', 1619
    get_hll_global $P2678, ["PAST"], "Op"
    $P2679 = $P2678."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2679
.annotate 'line', 1620
    find_lex $P2681, "$routine"
    unless_null $P2681, vivify_1446
    $P2681 = root_new ['parrot';'ResizablePMCArray']
  vivify_1446:
    set $P2682, $P2681[0]
    unless_null $P2682, vivify_1447
    new $P2682, "Undef"
  vivify_1447:
    $P2683 = $P2682."list"()
    defined $I2684, $P2683
    unless $I2684, for_undef_1448
    iter $P2680, $P2683
    new $P2725, 'ExceptionHandler'
    set_label $P2725, loop2724_handler
    $P2725."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2725
  loop2724_test:
    unless $P2680, loop2724_done
    shift $P2685, $P2680
  loop2724_redo:
    .const 'Sub' $P2687 = "416_1303391609.928" 
    capture_lex $P2687
    $P2687($P2685)
  loop2724_next:
    goto loop2724_test
  loop2724_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2726, exception, 'type'
    eq $P2726, .CONTROL_LOOP_NEXT, loop2724_next
    eq $P2726, .CONTROL_LOOP_REDO, loop2724_redo
  loop2724_done:
    pop_eh 
  for_undef_1448:
.annotate 'line', 1627
    find_lex $P2727, "$routine"
    unless_null $P2727, vivify_1458
    new $P2727, "Undef"
  vivify_1458:
    $P2728 = $P2727."loadinit"()
    get_hll_global $P2729, ["PAST"], "Op"
.annotate 'line', 1628
    get_hll_global $P2730, ["PAST"], "Var"
    $P2731 = $P2730."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P2732, "$types"
    unless_null $P2732, vivify_1459
    new $P2732, "Undef"
  vivify_1459:
    find_lex $P2733, "$definednesses"
    unless_null $P2733, vivify_1460
    new $P2733, "Undef"
  vivify_1460:
    $P2734 = $P2729."new"($P2731, $P2732, $P2733, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1627
    $P2735 = $P2728."push"($P2734)
.annotate 'line', 1614
    .return ($P2735)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2686"  :anon :subid("416_1303391609.928") :outer("415_1303391609.928")
    .param pmc param_2688
.annotate 'line', 1620
    .lex "$_", param_2688
.annotate 'line', 1621
    get_hll_global $P2693, ["PAST"], "Var"
    find_lex $P2694, "$_"
    unless_null $P2694, vivify_1449
    new $P2694, "Undef"
  vivify_1449:
    $P2695 = $P2693."ACCEPTS"($P2694)
    if $P2695, if_2692
    set $P2691, $P2695
    goto if_2692_end
  if_2692:
    find_lex $P2696, "$_"
    unless_null $P2696, vivify_1450
    new $P2696, "Undef"
  vivify_1450:
    $S2697 = $P2696."scope"()
    iseq $I2698, $S2697, "parameter"
    new $P2691, 'Integer'
    set $P2691, $I2698
  if_2692_end:
    if $P2691, if_2690
    set $P2689, $P2691
    goto if_2690_end
  if_2690:
.annotate 'line', 1622
    find_lex $P2699, "$types"
    unless_null $P2699, vivify_1451
    new $P2699, "Undef"
  vivify_1451:
    find_lex $P2701, "$_"
    unless_null $P2701, vivify_1452
    new $P2701, "Undef"
  vivify_1452:
    $P2702 = $P2701."multitype"()
    set $P2700, $P2702
    defined $I2704, $P2700
    if $I2704, default_2703
    get_hll_global $P2705, ["PAST"], "Op"
    $P2706 = $P2705."new"("null P" :named("pirop"))
    set $P2700, $P2706
  default_2703:
    $P2699."push"($P2700)
.annotate 'line', 1623
    find_lex $P2707, "$definednesses"
    unless_null $P2707, vivify_1453
    new $P2707, "Undef"
  vivify_1453:
    find_lex $P2710, "$_"
    unless_null $P2710, vivify_1454
    $P2710 = root_new ['parrot';'Hash']
  vivify_1454:
    set $P2711, $P2710["definedness"]
    unless_null $P2711, vivify_1455
    new $P2711, "Undef"
  vivify_1455:
    set $S2712, $P2711
    iseq $I2713, $S2712, "D"
    if $I2713, if_2709
.annotate 'line', 1624
    find_lex $P2717, "$_"
    unless_null $P2717, vivify_1456
    $P2717 = root_new ['parrot';'Hash']
  vivify_1456:
    set $P2718, $P2717["definedness"]
    unless_null $P2718, vivify_1457
    new $P2718, "Undef"
  vivify_1457:
    set $S2719, $P2718
    iseq $I2720, $S2719, "U"
    if $I2720, if_2716
    new $P2722, "Integer"
    assign $P2722, 0
    set $P2715, $P2722
    goto if_2716_end
  if_2716:
    new $P2721, "Integer"
    assign $P2721, 2
    set $P2715, $P2721
  if_2716_end:
    set $P2708, $P2715
.annotate 'line', 1623
    goto if_2709_end
  if_2709:
    new $P2714, "Integer"
    assign $P2714, 1
    set $P2708, $P2714
  if_2709_end:
    $P2723 = $P2707."push"($P2708)
.annotate 'line', 1621
    set $P2689, $P2723
  if_2690_end:
.annotate 'line', 1620
    .return ($P2689)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("417_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2738
    .param pmc param_2739
.annotate 'line', 2086
    .lex "$/", param_2738
    .lex "$type", param_2739
.annotate 'line', 2087
    find_lex $P2740, "$/"
    get_hll_global $P2741, ["PAST"], "Op"
    find_lex $P2742, "$/"
    unless_null $P2742, vivify_1461
    new $P2742, "Undef"
  vivify_1461:
.annotate 'line', 2091
    get_hll_global $P2743, ["PAST"], "Val"
    find_lex $P2744, "$type"
    unless_null $P2744, vivify_1462
    new $P2744, "Undef"
  vivify_1462:
    $P2745 = $P2743."new"($P2744 :named("value"), "!except_types" :named("returns"))
    $P2746 = $P2741."new"(0, $P2745, $P2742 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2087
    $P2747 = $P2740."!make"($P2746)
.annotate 'line', 2086
    .return ($P2747)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("418_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2752
    .param pmc param_2753
.annotate 'line', 2105
    .const 'Sub' $P2782 = "419_1303391609.928" 
    capture_lex $P2782
    new $P2751, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2751, control_2750
    push_eh $P2751
    .lex "@name", param_2752
    .lex "$/", param_2753
.annotate 'line', 2111
    new $P2754, "Undef"
    .lex "$final_name", $P2754
.annotate 'line', 2112
    new $P2755, "Undef"
    .lex "$lookup", $P2755
.annotate 'line', 2107
    find_lex $P2757, "@name"
    unless_null $P2757, vivify_1463
    $P2757 = root_new ['parrot';'ResizablePMCArray']
  vivify_1463:
    set $N2758, $P2757
    iseq $I2759, $N2758, 0.0
    unless $I2759, if_2756_end
    find_lex $P2760, "$/"
    unless_null $P2760, vivify_1464
    new $P2760, "Undef"
  vivify_1464:
    $P2761 = $P2760."CURSOR"()
    $P2761."panic"("Cannot compile empty name")
  if_2756_end:
.annotate 'line', 2111
    find_lex $P2762, "@name"
    unless_null $P2762, vivify_1465
    $P2762 = root_new ['parrot';'ResizablePMCArray']
  vivify_1465:
    $P2763 = $P2762."pop"()
    store_lex "$final_name", $P2763
.annotate 'line', 2112
    get_hll_global $P2764, ["PAST"], "Var"
    find_lex $P2765, "$final_name"
    unless_null $P2765, vivify_1466
    new $P2765, "Undef"
  vivify_1466:
    set $S2766, $P2765
    $P2767 = $P2764."new"($S2766, "keyed" :named("scope"))
    store_lex "$lookup", $P2767
.annotate 'line', 2116
    find_lex $P2769, "@name"
    unless_null $P2769, vivify_1467
    $P2769 = root_new ['parrot';'ResizablePMCArray']
  vivify_1467:
    set $N2770, $P2769
    iseq $I2771, $N2770, 0.0
    if $I2771, if_2768
.annotate 'line', 2125
    find_lex $P2778, "@name"
    unless_null $P2778, vivify_1468
    $P2778 = root_new ['parrot';'ResizablePMCArray']
  vivify_1468:
    set $P2779, $P2778[0]
    unless_null $P2779, vivify_1469
    new $P2779, "Undef"
  vivify_1469:
    $P2780 = "is_lexical"($P2779)
    if $P2780, if_2777
.annotate 'line', 2139
    find_lex $P2808, "$lookup"
    unless_null $P2808, vivify_1470
    new $P2808, "Undef"
  vivify_1470:
    get_hll_global $P2809, ["PAST"], "Op"
.annotate 'line', 2141
    get_hll_global $P2810, ["PAST"], "Var"
    find_lex $P2811, "@name"
    unless_null $P2811, vivify_1471
    $P2811 = root_new ['parrot';'ResizablePMCArray']
  vivify_1471:
    $P2812 = $P2811."pop"()
    find_lex $P2813, "@name"
    unless_null $P2813, vivify_1472
    $P2813 = root_new ['parrot';'ResizablePMCArray']
  vivify_1472:
    $P2814 = $P2810."new"($P2812 :named("name"), $P2813 :named("namespace"), "package" :named("scope"))
    $P2815 = $P2809."new"($P2814, "get_who PP" :named("pirop"))
.annotate 'line', 2139
    $P2808."unshift"($P2815)
.annotate 'line', 2134
    goto if_2777_end
  if_2777:
.annotate 'line', 2125
    .const 'Sub' $P2782 = "419_1303391609.928" 
    capture_lex $P2782
    $P2782()
  if_2777_end:
    goto if_2768_end
  if_2768:
.annotate 'line', 2117
    find_lex $P2772, "$lookup"
    unless_null $P2772, vivify_1480
    new $P2772, "Undef"
  vivify_1480:
    get_hll_global $P2773, ["PAST"], "Op"
.annotate 'line', 2119
    get_hll_global $P2774, ["PAST"], "Var"
    $P2775 = $P2774."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P2776 = $P2773."new"($P2775, "get_who PP" :named("pirop"))
.annotate 'line', 2117
    $P2772."unshift"($P2776)
  if_2768_end:
.annotate 'line', 2145
    new $P2816, "Exception"
    set $P2816['type'], .CONTROL_RETURN
    find_lex $P2817, "$lookup"
    unless_null $P2817, vivify_1481
    new $P2817, "Undef"
  vivify_1481:
    setattribute $P2816, 'payload', $P2817
    throw $P2816
.annotate 'line', 2105
    .return ()
  control_2750:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2818, exception, "payload"
    .return ($P2818)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2781"  :anon :subid("419_1303391609.928") :outer("418_1303391609.928")
.annotate 'line', 2125
    .const 'Sub' $P2793 = "420_1303391609.928" 
    capture_lex $P2793
.annotate 'line', 2126
    new $P2783, "Undef"
    .lex "$path", $P2783
    get_hll_global $P2784, ["PAST"], "Var"
    find_lex $P2785, "@name"
    unless_null $P2785, vivify_1473
    $P2785 = root_new ['parrot';'ResizablePMCArray']
  vivify_1473:
    $P2786 = $P2785."shift"()
    $P2787 = $P2784."new"($P2786 :named("name"), "lexical" :named("scope"))
    store_lex "$path", $P2787
.annotate 'line', 2127
    find_lex $P2789, "@name"
    unless_null $P2789, vivify_1474
    $P2789 = root_new ['parrot';'ResizablePMCArray']
  vivify_1474:
    defined $I2790, $P2789
    unless $I2790, for_undef_1475
    iter $P2788, $P2789
    new $P2801, 'ExceptionHandler'
    set_label $P2801, loop2800_handler
    $P2801."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2801
  loop2800_test:
    unless $P2788, loop2800_done
    shift $P2791, $P2788
  loop2800_redo:
    .const 'Sub' $P2793 = "420_1303391609.928" 
    capture_lex $P2793
    $P2793($P2791)
  loop2800_next:
    goto loop2800_test
  loop2800_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2802, exception, 'type'
    eq $P2802, .CONTROL_LOOP_NEXT, loop2800_next
    eq $P2802, .CONTROL_LOOP_REDO, loop2800_redo
  loop2800_done:
    pop_eh 
  for_undef_1475:
.annotate 'line', 2132
    find_lex $P2803, "$lookup"
    unless_null $P2803, vivify_1478
    new $P2803, "Undef"
  vivify_1478:
    get_hll_global $P2804, ["PAST"], "Op"
    find_lex $P2805, "$path"
    unless_null $P2805, vivify_1479
    new $P2805, "Undef"
  vivify_1479:
    $P2806 = $P2804."new"($P2805, "get_who PP" :named("pirop"))
    $P2807 = $P2803."unshift"($P2806)
.annotate 'line', 2125
    .return ($P2807)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2792"  :anon :subid("420_1303391609.928") :outer("419_1303391609.928")
    .param pmc param_2794
.annotate 'line', 2127
    .lex "$_", param_2794
.annotate 'line', 2128
    get_hll_global $P2795, ["PAST"], "Op"
    find_lex $P2796, "$path"
    unless_null $P2796, vivify_1476
    new $P2796, "Undef"
  vivify_1476:
.annotate 'line', 2130
    find_lex $P2797, "$_"
    unless_null $P2797, vivify_1477
    new $P2797, "Undef"
  vivify_1477:
    set $S2798, $P2797
    $P2799 = $P2795."new"($P2796, $S2798, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2128
    store_lex "$path", $P2799
.annotate 'line', 2127
    .return ($P2799)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("421_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2821
.annotate 'line', 2150
    .lex "$name", param_2821
.annotate 'line', 2151
    find_lex $P2822, "$name"
    unless_null $P2822, vivify_1482
    new $P2822, "Undef"
  vivify_1482:
    $P2823 = "is_scope"($P2822, "lexical")
.annotate 'line', 2150
    .return ($P2823)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("422_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2826
.annotate 'line', 2156
    .lex "$name", param_2826
.annotate 'line', 2157
    find_lex $P2827, "$name"
    unless_null $P2827, vivify_1483
    new $P2827, "Undef"
  vivify_1483:
    $P2828 = "is_scope"($P2827, "package")
.annotate 'line', 2156
    .return ($P2828)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("423_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2833
    .param pmc param_2834
.annotate 'line', 2162
    .const 'Sub' $P2842 = "424_1303391609.928" 
    capture_lex $P2842
    new $P2832, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2832, control_2831
    push_eh $P2832
    .lex "$name", param_2833
    .lex "$wanted_scope", param_2834
.annotate 'line', 2163
    find_lex $P2836, "$?PACKAGE"
    get_who $P2837, $P2836
    set $P2838, $P2837["@BLOCK"]
    unless_null $P2838, vivify_1484
    $P2838 = root_new ['parrot';'ResizablePMCArray']
  vivify_1484:
    defined $I2839, $P2838
    unless $I2839, for_undef_1485
    iter $P2835, $P2838
    new $P2861, 'ExceptionHandler'
    set_label $P2861, loop2860_handler
    $P2861."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2861
  loop2860_test:
    unless $P2835, loop2860_done
    shift $P2840, $P2835
  loop2860_redo:
    .const 'Sub' $P2842 = "424_1303391609.928" 
    capture_lex $P2842
    $P2842($P2840)
  loop2860_next:
    goto loop2860_test
  loop2860_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2862, exception, 'type'
    eq $P2862, .CONTROL_LOOP_NEXT, loop2860_next
    eq $P2862, .CONTROL_LOOP_REDO, loop2860_redo
  loop2860_done:
    pop_eh 
  for_undef_1485:
.annotate 'line', 2162
    .return (0)
  control_2831:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2863, exception, "payload"
    .return ($P2863)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2841"  :anon :subid("424_1303391609.928") :outer("423_1303391609.928")
    .param pmc param_2844
.annotate 'line', 2164
    $P2843 = root_new ['parrot';'Hash']
    .lex "%sym", $P2843
    .lex "$_", param_2844
    find_lex $P2845, "$_"
    unless_null $P2845, vivify_1486
    new $P2845, "Undef"
  vivify_1486:
    find_lex $P2846, "$name"
    unless_null $P2846, vivify_1487
    new $P2846, "Undef"
  vivify_1487:
    $P2847 = $P2845."symbol"($P2846)
    store_lex "%sym", $P2847
.annotate 'line', 2165
    find_lex $P2850, "%sym"
    unless_null $P2850, vivify_1488
    $P2850 = root_new ['parrot';'Hash']
  vivify_1488:
    set $N2851, $P2850
    if $N2851, if_2849
    new $P2848, 'Float'
    set $P2848, $N2851
    goto if_2849_end
  if_2849:
.annotate 'line', 2166
    new $P2852, "Exception"
    set $P2852['type'], .CONTROL_RETURN
    find_lex $P2853, "%sym"
    unless_null $P2853, vivify_1489
    $P2853 = root_new ['parrot';'Hash']
  vivify_1489:
    set $P2854, $P2853["scope"]
    unless_null $P2854, vivify_1490
    new $P2854, "Undef"
  vivify_1490:
    set $S2855, $P2854
    find_lex $P2856, "$wanted_scope"
    unless_null $P2856, vivify_1491
    new $P2856, "Undef"
  vivify_1491:
    set $S2857, $P2856
    iseq $I2858, $S2855, $S2857
    new $P2859, 'Integer'
    set $P2859, $I2858
    setattribute $P2852, 'payload', $P2859
    throw $P2852
  if_2849_end:
.annotate 'line', 2163
    .return ($P2848)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("425_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2874
    .param pmc param_2875
.annotate 'line', 781
    .lex "self", param_2874
    .lex "$/", param_2875
    find_lex $P2876, "$/"
    find_lex $P2877, "$/"
    unless_null $P2877, vivify_1492
    $P2877 = root_new ['parrot';'Hash']
  vivify_1492:
    set $P2878, $P2877["comp_unit"]
    unless_null $P2878, vivify_1493
    new $P2878, "Undef"
  vivify_1493:
    $P2879 = $P2878."ast"()
    $P2880 = $P2876."!make"($P2879)
    .return ($P2880)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("426_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2882
    .param pmc param_2883
.annotate 'line', 783
    .lex "self", param_2882
    .lex "$/", param_2883
.annotate 'line', 784
    find_lex $P2884, "$/"
.annotate 'line', 785
    find_lex $P2887, "$/"
    unless_null $P2887, vivify_1494
    $P2887 = root_new ['parrot';'Hash']
  vivify_1494:
    set $P2888, $P2887["colonpair"]
    unless_null $P2888, vivify_1495
    new $P2888, "Undef"
  vivify_1495:
    if $P2888, if_2886
.annotate 'line', 787
    find_lex $P2908, "$/"
    unless_null $P2908, vivify_1496
    new $P2908, "Undef"
  vivify_1496:
    set $S2909, $P2908
    new $P2885, 'String'
    set $P2885, $S2909
.annotate 'line', 785
    goto if_2886_end
  if_2886:
    find_lex $P2889, "$/"
    unless_null $P2889, vivify_1497
    $P2889 = root_new ['parrot';'Hash']
  vivify_1497:
    set $P2890, $P2889["identifier"]
    unless_null $P2890, vivify_1498
    new $P2890, "Undef"
  vivify_1498:
    set $S2891, $P2890
    new $P2892, 'String'
    set $P2892, $S2891
    concat $P2893, $P2892, ":"
    find_lex $P2894, "$/"
    unless_null $P2894, vivify_1499
    $P2894 = root_new ['parrot';'Hash']
  vivify_1499:
    set $P2895, $P2894["colonpair"]
    unless_null $P2895, vivify_1500
    $P2895 = root_new ['parrot';'ResizablePMCArray']
  vivify_1500:
    set $P2896, $P2895[0]
    unless_null $P2896, vivify_1501
    new $P2896, "Undef"
  vivify_1501:
    $P2897 = $P2896."ast"()
    $S2898 = $P2897."named"()
    concat $P2899, $P2893, $S2898
    concat $P2900, $P2899, "<"
.annotate 'line', 786
    find_lex $P2901, "$/"
    unless_null $P2901, vivify_1502
    $P2901 = root_new ['parrot';'Hash']
  vivify_1502:
    set $P2902, $P2901["colonpair"]
    unless_null $P2902, vivify_1503
    $P2902 = root_new ['parrot';'ResizablePMCArray']
  vivify_1503:
    set $P2903, $P2902[0]
    unless_null $P2903, vivify_1504
    new $P2903, "Undef"
  vivify_1504:
    $P2904 = $P2903."ast"()
    $S2905 = "colonpair_str"($P2904)
    concat $P2906, $P2900, $S2905
    concat $P2907, $P2906, ">"
    set $P2885, $P2907
  if_2886_end:
.annotate 'line', 785
    $P2910 = $P2884."!make"($P2885)
.annotate 'line', 783
    .return ($P2910)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("427_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2913
    .param pmc param_2914
.annotate 'line', 797
    .lex "self", param_2913
    .lex "$/", param_2914
.annotate 'line', 798
    new $P2915, "Undef"
    .lex "$mainline", $P2915
.annotate 'line', 799
    new $P2916, "Undef"
    .lex "$unit", $P2916
.annotate 'line', 798
    find_lex $P2917, "$/"
    unless_null $P2917, vivify_1505
    $P2917 = root_new ['parrot';'Hash']
  vivify_1505:
    set $P2918, $P2917["statementlist"]
    unless_null $P2918, vivify_1506
    new $P2918, "Undef"
  vivify_1506:
    $P2919 = $P2918."ast"()
    store_lex "$mainline", $P2919
.annotate 'line', 799
    find_lex $P2920, "$?PACKAGE"
    get_who $P2921, $P2920
    set $P2922, $P2921["@BLOCK"]
    unless_null $P2922, vivify_1507
    $P2922 = root_new ['parrot';'ResizablePMCArray']
  vivify_1507:
    $P2923 = $P2922."shift"()
    store_lex "$unit", $P2923
.annotate 'line', 803
    find_lex $P2924, "$unit"
    unless_null $P2924, vivify_1508
    new $P2924, "Undef"
  vivify_1508:
    $P2925 = $P2924."loadinit"()
    find_dynamic_lex $P2926, "$*SC"
    unless_null $P2926, vivify_1509
    get_hll_global $P2926, "$SC"
    unless_null $P2926, vivify_1510
    die "Contextual $*SC not found"
  vivify_1510:
  vivify_1509:
    $P2927 = $P2926."to_past"()
    $P2925."push"($P2927)
.annotate 'line', 809
    find_lex $P2928, "$unit"
    unless_null $P2928, vivify_1511
    new $P2928, "Undef"
  vivify_1511:
    $P2929 = $P2928."loadinit"()
    get_hll_global $P2930, ["PAST"], "Op"
.annotate 'line', 811
    get_hll_global $P2931, ["PAST"], "Var"
    new $P2932, "ResizablePMCArray"
    $P2933 = $P2931."new"("GLOBAL" :named("name"), $P2932 :named("namespace"), "package" :named("scope"))
.annotate 'line', 812
    find_dynamic_lex $P2934, "$*SC"
    unless_null $P2934, vivify_1512
    get_hll_global $P2934, "$SC"
    unless_null $P2934, vivify_1513
    die "Contextual $*SC not found"
  vivify_1513:
  vivify_1512:
    find_dynamic_lex $P2935, "$*PACKAGE"
    unless_null $P2935, vivify_1514
    get_hll_global $P2935, "$PACKAGE"
    unless_null $P2935, vivify_1515
    die "Contextual $*PACKAGE not found"
  vivify_1515:
  vivify_1514:
    $P2936 = $P2934."get_slot_past_for_object"($P2935)
    $P2937 = $P2930."new"($P2933, $P2936, "bind" :named("pasttype"))
.annotate 'line', 809
    $P2929."push"($P2937)
.annotate 'line', 818
    find_dynamic_lex $P2939, "$*HAS_YOU_ARE_HERE"
    unless_null $P2939, vivify_1516
    get_hll_global $P2939, "$HAS_YOU_ARE_HERE"
    unless_null $P2939, vivify_1517
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1517:
  vivify_1516:
    if $P2939, unless_2938_end
.annotate 'line', 819
    find_lex $P2940, "$unit"
    unless_null $P2940, vivify_1518
    new $P2940, "Undef"
  vivify_1518:
    find_lex $P2941, "self"
    $P2942 = $P2941."CTXSAVE"()
    $P2940."push"($P2942)
  unless_2938_end:
.annotate 'line', 823
    find_lex $P2943, "$unit"
    unless_null $P2943, vivify_1519
    new $P2943, "Undef"
  vivify_1519:
    $P2943."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 827
    find_dynamic_lex $P2945, "$*MAIN_SUB"
    unless_null $P2945, vivify_1520
    get_hll_global $P2945, "$MAIN_SUB"
    unless_null $P2945, vivify_1521
    die "Contextual $*MAIN_SUB not found"
  vivify_1521:
  vivify_1520:
    unless $P2945, if_2944_end
.annotate 'line', 828
    find_lex $P2946, "$unit"
    unless_null $P2946, vivify_1522
    new $P2946, "Undef"
  vivify_1522:
    get_hll_global $P2947, ["PAST"], "Var"
    $P2948 = $P2947."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P2946."unshift"($P2948)
.annotate 'line', 829
    find_lex $P2949, "$mainline"
    unless_null $P2949, vivify_1523
    new $P2949, "Undef"
  vivify_1523:
    get_hll_global $P2950, ["PAST"], "Op"
.annotate 'line', 831
    get_hll_global $P2951, ["PAST"], "Var"
    $P2952 = $P2951."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 832
    get_hll_global $P2953, ["PAST"], "Op"
.annotate 'line', 833
    get_hll_global $P2954, ["PAST"], "Val"
    find_dynamic_lex $P2955, "$*MAIN_SUB"
    unless_null $P2955, vivify_1524
    get_hll_global $P2955, "$MAIN_SUB"
    unless_null $P2955, vivify_1525
    die "Contextual $*MAIN_SUB not found"
  vivify_1525:
  vivify_1524:
    $P2956 = $P2954."new"($P2955 :named("value"))
.annotate 'line', 834
    get_hll_global $P2957, ["PAST"], "Var"
    $P2958 = $P2957."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P2959 = $P2953."new"($P2956, $P2958, "call" :named("pasttype"))
.annotate 'line', 832
    $P2960 = $P2950."new"($P2952, $P2959, "if" :named("pasttype"))
.annotate 'line', 829
    $P2949."push"($P2960)
  if_2944_end:
.annotate 'line', 842
    find_lex $P2961, "$unit"
    unless_null $P2961, vivify_1526
    new $P2961, "Undef"
  vivify_1526:
.annotate 'line', 843
    get_hll_global $P2962, ["PAST"], "Op"
    find_lex $P2963, "$mainline"
    unless_null $P2963, vivify_1527
    new $P2963, "Undef"
  vivify_1527:
    $P2964 = $P2962."new"($P2963, "return" :named("pirop"))
    $P2961."push"($P2964)
.annotate 'line', 848
    find_lex $P2965, "$unit"
    unless_null $P2965, vivify_1528
    new $P2965, "Undef"
  vivify_1528:
.annotate 'line', 849
    get_hll_global $P2966, ["PAST"], "Block"
.annotate 'line', 851
    get_hll_global $P2967, ["PAST"], "Op"
    get_hll_global $P2968, ["PAST"], "Val"
    find_lex $P2969, "$unit"
    unless_null $P2969, vivify_1529
    new $P2969, "Undef"
  vivify_1529:
    $P2970 = $P2968."new"($P2969 :named("value"))
    $P2971 = $P2967."new"($P2970, "call" :named("pasttype"))
    $P2972 = $P2966."new"($P2971, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 849
    $P2965."push"($P2972)
.annotate 'line', 854
    find_lex $P2973, "$unit"
    unless_null $P2973, vivify_1530
    new $P2973, "Undef"
  vivify_1530:
    find_lex $P2974, "$/"
    unless_null $P2974, vivify_1531
    new $P2974, "Undef"
  vivify_1531:
    $P2973."node"($P2974)
.annotate 'line', 857
    find_lex $P2975, "$unit"
    unless_null $P2975, vivify_1532
    new $P2975, "Undef"
  vivify_1532:
    $P2975."hll"("nqp")
.annotate 'line', 859
    find_lex $P2976, "$/"
    find_lex $P2977, "$unit"
    unless_null $P2977, vivify_1533
    new $P2977, "Undef"
  vivify_1533:
    $P2978 = $P2976."!make"($P2977)
.annotate 'line', 797
    .return ($P2978)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("428_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_2980
    .param pmc param_2981
.annotate 'line', 862
    .const 'Sub' $P2995 = "429_1303391609.928" 
    capture_lex $P2995
    .lex "self", param_2980
    .lex "$/", param_2981
.annotate 'line', 863
    new $P2982, "Undef"
    .lex "$past", $P2982
    get_hll_global $P2983, ["PAST"], "Stmts"
    find_lex $P2984, "$/"
    unless_null $P2984, vivify_1534
    new $P2984, "Undef"
  vivify_1534:
    $P2985 = $P2983."new"($P2984 :named("node"))
    store_lex "$past", $P2985
.annotate 'line', 864
    find_lex $P2987, "$/"
    unless_null $P2987, vivify_1535
    $P2987 = root_new ['parrot';'Hash']
  vivify_1535:
    set $P2988, $P2987["statement"]
    unless_null $P2988, vivify_1536
    new $P2988, "Undef"
  vivify_1536:
    unless $P2988, if_2986_end
.annotate 'line', 865
    find_lex $P2990, "$/"
    unless_null $P2990, vivify_1537
    $P2990 = root_new ['parrot';'Hash']
  vivify_1537:
    set $P2991, $P2990["statement"]
    unless_null $P2991, vivify_1538
    new $P2991, "Undef"
  vivify_1538:
    defined $I2992, $P2991
    unless $I2992, for_undef_1539
    iter $P2989, $P2991
    new $P3015, 'ExceptionHandler'
    set_label $P3015, loop3014_handler
    $P3015."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3015
  loop3014_test:
    unless $P2989, loop3014_done
    shift $P2993, $P2989
  loop3014_redo:
    .const 'Sub' $P2995 = "429_1303391609.928" 
    capture_lex $P2995
    $P2995($P2993)
  loop3014_next:
    goto loop3014_test
  loop3014_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3016, exception, 'type'
    eq $P3016, .CONTROL_LOOP_NEXT, loop3014_next
    eq $P3016, .CONTROL_LOOP_REDO, loop3014_redo
  loop3014_done:
    pop_eh 
  for_undef_1539:
  if_2986_end:
.annotate 'line', 872
    find_lex $P3017, "$/"
    find_lex $P3018, "$past"
    unless_null $P3018, vivify_1550
    new $P3018, "Undef"
  vivify_1550:
    $P3019 = $P3017."!make"($P3018)
.annotate 'line', 862
    .return ($P3019)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2994"  :anon :subid("429_1303391609.928") :outer("428_1303391609.928")
    .param pmc param_2997
.annotate 'line', 866
    new $P2996, "Undef"
    .lex "$ast", $P2996
    .lex "$_", param_2997
    find_lex $P2998, "$_"
    unless_null $P2998, vivify_1540
    new $P2998, "Undef"
  vivify_1540:
    $P2999 = $P2998."ast"()
    store_lex "$ast", $P2999
.annotate 'line', 867
    find_lex $P3001, "$ast"
    unless_null $P3001, vivify_1541
    $P3001 = root_new ['parrot';'Hash']
  vivify_1541:
    set $P3002, $P3001["sink"]
    unless_null $P3002, vivify_1542
    new $P3002, "Undef"
  vivify_1542:
    defined $I3003, $P3002
    unless $I3003, if_3000_end
    find_lex $P3004, "$ast"
    unless_null $P3004, vivify_1543
    $P3004 = root_new ['parrot';'Hash']
  vivify_1543:
    set $P3005, $P3004["sink"]
    unless_null $P3005, vivify_1544
    new $P3005, "Undef"
  vivify_1544:
    store_lex "$ast", $P3005
  if_3000_end:
.annotate 'line', 868
    find_lex $P3007, "$ast"
    unless_null $P3007, vivify_1545
    $P3007 = root_new ['parrot';'Hash']
  vivify_1545:
    set $P3008, $P3007["bareblock"]
    unless_null $P3008, vivify_1546
    new $P3008, "Undef"
  vivify_1546:
    unless $P3008, if_3006_end
    find_lex $P3009, "$ast"
    unless_null $P3009, vivify_1547
    new $P3009, "Undef"
  vivify_1547:
    $P3010 = "block_immediate"($P3009)
    store_lex "$ast", $P3010
  if_3006_end:
.annotate 'line', 869
    find_lex $P3011, "$past"
    unless_null $P3011, vivify_1548
    new $P3011, "Undef"
  vivify_1548:
    find_lex $P3012, "$ast"
    unless_null $P3012, vivify_1549
    new $P3012, "Undef"
  vivify_1549:
    $P3013 = $P3011."push"($P3012)
.annotate 'line', 865
    .return ($P3013)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("430_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3021
    .param pmc param_3022
    .param pmc param_3023 :optional
    .param int has_param_3023 :opt_flag
.annotate 'line', 875
    .const 'Sub' $P3031 = "431_1303391609.928" 
    capture_lex $P3031
    .lex "self", param_3021
    .lex "$/", param_3022
    if has_param_3023, optparam_1551
    new $P3024, "Undef"
    set param_3023, $P3024
  optparam_1551:
    .lex "$key", param_3023
.annotate 'line', 876
    new $P3025, "Undef"
    .lex "$past", $P3025
.annotate 'line', 875
    find_lex $P3026, "$past"
    unless_null $P3026, vivify_1552
    new $P3026, "Undef"
  vivify_1552:
.annotate 'line', 877
    find_lex $P3028, "$/"
    unless_null $P3028, vivify_1553
    $P3028 = root_new ['parrot';'Hash']
  vivify_1553:
    set $P3029, $P3028["EXPR"]
    unless_null $P3029, vivify_1554
    new $P3029, "Undef"
  vivify_1554:
    if $P3029, if_3027
.annotate 'line', 898
    find_lex $P3092, "$/"
    unless_null $P3092, vivify_1555
    $P3092 = root_new ['parrot';'Hash']
  vivify_1555:
    set $P3093, $P3092["statement_control"]
    unless_null $P3093, vivify_1556
    new $P3093, "Undef"
  vivify_1556:
    if $P3093, if_3091
.annotate 'line', 899
    new $P3097, "Integer"
    assign $P3097, 0
    store_lex "$past", $P3097
    goto if_3091_end
  if_3091:
.annotate 'line', 898
    find_lex $P3094, "$/"
    unless_null $P3094, vivify_1557
    $P3094 = root_new ['parrot';'Hash']
  vivify_1557:
    set $P3095, $P3094["statement_control"]
    unless_null $P3095, vivify_1558
    new $P3095, "Undef"
  vivify_1558:
    $P3096 = $P3095."ast"()
    store_lex "$past", $P3096
  if_3091_end:
    goto if_3027_end
  if_3027:
.annotate 'line', 877
    .const 'Sub' $P3031 = "431_1303391609.928" 
    capture_lex $P3031
    $P3031()
  if_3027_end:
.annotate 'line', 900
    find_lex $P3098, "$/"
    find_lex $P3099, "$past"
    unless_null $P3099, vivify_1592
    new $P3099, "Undef"
  vivify_1592:
    $P3100 = $P3098."!make"($P3099)
.annotate 'line', 875
    .return ($P3100)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3030"  :anon :subid("431_1303391609.928") :outer("430_1303391609.928")
.annotate 'line', 878
    new $P3032, "Undef"
    .lex "$mc", $P3032
.annotate 'line', 879
    new $P3033, "Undef"
    .lex "$ml", $P3033
.annotate 'line', 878
    find_lex $P3034, "$/"
    unless_null $P3034, vivify_1559
    $P3034 = root_new ['parrot';'Hash']
  vivify_1559:
    set $P3035, $P3034["statement_mod_cond"]
    unless_null $P3035, vivify_1560
    $P3035 = root_new ['parrot';'ResizablePMCArray']
  vivify_1560:
    set $P3036, $P3035[0]
    unless_null $P3036, vivify_1561
    new $P3036, "Undef"
  vivify_1561:
    store_lex "$mc", $P3036
.annotate 'line', 879
    find_lex $P3037, "$/"
    unless_null $P3037, vivify_1562
    $P3037 = root_new ['parrot';'Hash']
  vivify_1562:
    set $P3038, $P3037["statement_mod_loop"]
    unless_null $P3038, vivify_1563
    $P3038 = root_new ['parrot';'ResizablePMCArray']
  vivify_1563:
    set $P3039, $P3038[0]
    unless_null $P3039, vivify_1564
    new $P3039, "Undef"
  vivify_1564:
    store_lex "$ml", $P3039
.annotate 'line', 880
    find_lex $P3040, "$/"
    unless_null $P3040, vivify_1565
    $P3040 = root_new ['parrot';'Hash']
  vivify_1565:
    set $P3041, $P3040["EXPR"]
    unless_null $P3041, vivify_1566
    new $P3041, "Undef"
  vivify_1566:
    $P3042 = $P3041."ast"()
    store_lex "$past", $P3042
.annotate 'line', 881
    find_lex $P3044, "$mc"
    unless_null $P3044, vivify_1567
    new $P3044, "Undef"
  vivify_1567:
    unless $P3044, if_3043_end
.annotate 'line', 882
    get_hll_global $P3045, ["PAST"], "Op"
    find_lex $P3046, "$mc"
    unless_null $P3046, vivify_1568
    $P3046 = root_new ['parrot';'Hash']
  vivify_1568:
    set $P3047, $P3046["cond"]
    unless_null $P3047, vivify_1569
    new $P3047, "Undef"
  vivify_1569:
    $P3048 = $P3047."ast"()
    find_lex $P3049, "$past"
    unless_null $P3049, vivify_1570
    new $P3049, "Undef"
  vivify_1570:
    find_lex $P3050, "$mc"
    unless_null $P3050, vivify_1571
    $P3050 = root_new ['parrot';'Hash']
  vivify_1571:
    set $P3051, $P3050["sym"]
    unless_null $P3051, vivify_1572
    new $P3051, "Undef"
  vivify_1572:
    set $S3052, $P3051
    find_lex $P3053, "$/"
    unless_null $P3053, vivify_1573
    new $P3053, "Undef"
  vivify_1573:
    $P3054 = $P3045."new"($P3048, $P3049, $S3052 :named("pasttype"), $P3053 :named("node"))
    store_lex "$past", $P3054
  if_3043_end:
.annotate 'line', 884
    find_lex $P3057, "$ml"
    unless_null $P3057, vivify_1574
    new $P3057, "Undef"
  vivify_1574:
    if $P3057, if_3056
    set $P3055, $P3057
    goto if_3056_end
  if_3056:
.annotate 'line', 885
    find_lex $P3060, "$ml"
    unless_null $P3060, vivify_1575
    $P3060 = root_new ['parrot';'Hash']
  vivify_1575:
    set $P3061, $P3060["sym"]
    unless_null $P3061, vivify_1576
    new $P3061, "Undef"
  vivify_1576:
    set $S3062, $P3061
    iseq $I3063, $S3062, "for"
    if $I3063, if_3059
.annotate 'line', 894
    get_hll_global $P3081, ["PAST"], "Op"
    find_lex $P3082, "$ml"
    unless_null $P3082, vivify_1577
    $P3082 = root_new ['parrot';'Hash']
  vivify_1577:
    set $P3083, $P3082["cond"]
    unless_null $P3083, vivify_1578
    new $P3083, "Undef"
  vivify_1578:
    $P3084 = $P3083."ast"()
    find_lex $P3085, "$past"
    unless_null $P3085, vivify_1579
    new $P3085, "Undef"
  vivify_1579:
    find_lex $P3086, "$ml"
    unless_null $P3086, vivify_1580
    $P3086 = root_new ['parrot';'Hash']
  vivify_1580:
    set $P3087, $P3086["sym"]
    unless_null $P3087, vivify_1581
    new $P3087, "Undef"
  vivify_1581:
    set $S3088, $P3087
    find_lex $P3089, "$/"
    unless_null $P3089, vivify_1582
    new $P3089, "Undef"
  vivify_1582:
    $P3090 = $P3081."new"($P3084, $P3085, $S3088 :named("pasttype"), $P3089 :named("node"))
    store_lex "$past", $P3090
.annotate 'line', 893
    set $P3058, $P3090
.annotate 'line', 885
    goto if_3059_end
  if_3059:
.annotate 'line', 886
    get_hll_global $P3064, ["PAST"], "Block"
.annotate 'line', 887
    get_hll_global $P3065, ["PAST"], "Var"
    $P3066 = $P3065."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3067, "$past"
    unless_null $P3067, vivify_1583
    new $P3067, "Undef"
  vivify_1583:
    $P3068 = $P3064."new"($P3066, $P3067, "immediate" :named("blocktype"))
.annotate 'line', 886
    store_lex "$past", $P3068
.annotate 'line', 889
    find_lex $P3069, "$past"
    unless_null $P3069, vivify_1584
    new $P3069, "Undef"
  vivify_1584:
    $P3069."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 890
    find_lex $P3070, "$past"
    unless_null $P3070, vivify_1585
    new $P3070, "Undef"
  vivify_1585:
    $P3070."arity"(1)
.annotate 'line', 891
    get_hll_global $P3071, ["PAST"], "Op"
    find_lex $P3072, "$ml"
    unless_null $P3072, vivify_1586
    $P3072 = root_new ['parrot';'Hash']
  vivify_1586:
    set $P3073, $P3072["cond"]
    unless_null $P3073, vivify_1587
    new $P3073, "Undef"
  vivify_1587:
    $P3074 = $P3073."ast"()
    find_lex $P3075, "$past"
    unless_null $P3075, vivify_1588
    new $P3075, "Undef"
  vivify_1588:
    find_lex $P3076, "$ml"
    unless_null $P3076, vivify_1589
    $P3076 = root_new ['parrot';'Hash']
  vivify_1589:
    set $P3077, $P3076["sym"]
    unless_null $P3077, vivify_1590
    new $P3077, "Undef"
  vivify_1590:
    set $S3078, $P3077
    find_lex $P3079, "$/"
    unless_null $P3079, vivify_1591
    new $P3079, "Undef"
  vivify_1591:
    $P3080 = $P3071."new"($P3074, $P3075, $S3078 :named("pasttype"), $P3079 :named("node"))
    store_lex "$past", $P3080
.annotate 'line', 885
    set $P3058, $P3080
  if_3059_end:
.annotate 'line', 884
    set $P3055, $P3058
  if_3056_end:
.annotate 'line', 877
    .return ($P3055)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("432_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3102
    .param pmc param_3103
.annotate 'line', 903
    .lex "self", param_3102
    .lex "$/", param_3103
.annotate 'line', 904
    find_lex $P3104, "$/"
    get_hll_global $P3105, ["PAST"], "Op"
    find_lex $P3106, "$/"
    unless_null $P3106, vivify_1593
    $P3106 = root_new ['parrot';'Hash']
  vivify_1593:
    set $P3107, $P3106["EXPR"]
    unless_null $P3107, vivify_1594
    new $P3107, "Undef"
  vivify_1594:
    $P3108 = $P3107."ast"()
    find_lex $P3109, "$/"
    unless_null $P3109, vivify_1595
    $P3109 = root_new ['parrot';'Hash']
  vivify_1595:
    set $P3110, $P3109["pblock"]
    unless_null $P3110, vivify_1596
    new $P3110, "Undef"
  vivify_1596:
    $P3111 = $P3110."ast"()
    find_lex $P3112, "$/"
    unless_null $P3112, vivify_1597
    new $P3112, "Undef"
  vivify_1597:
    $P3113 = $P3105."new"($P3108, $P3111, "if" :named("pasttype"), $P3112 :named("node"))
    $P3114 = $P3104."!make"($P3113)
.annotate 'line', 903
    .return ($P3114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("433_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3116
    .param pmc param_3117
.annotate 'line', 907
    .lex "self", param_3116
    .lex "$/", param_3117
.annotate 'line', 908
    find_lex $P3118, "$/"
    find_lex $P3119, "$/"
    unless_null $P3119, vivify_1598
    $P3119 = root_new ['parrot';'Hash']
  vivify_1598:
    set $P3120, $P3119["blockoid"]
    unless_null $P3120, vivify_1599
    new $P3120, "Undef"
  vivify_1599:
    $P3121 = $P3120."ast"()
    $P3122 = $P3118."!make"($P3121)
.annotate 'line', 907
    .return ($P3122)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("434_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3124
    .param pmc param_3125
.annotate 'line', 911
    .lex "self", param_3124
    .lex "$/", param_3125
.annotate 'line', 912
    find_lex $P3126, "$/"
    find_lex $P3127, "$/"
    unless_null $P3127, vivify_1600
    $P3127 = root_new ['parrot';'Hash']
  vivify_1600:
    set $P3128, $P3127["blockoid"]
    unless_null $P3128, vivify_1601
    new $P3128, "Undef"
  vivify_1601:
    $P3129 = $P3128."ast"()
    $P3130 = $P3126."!make"($P3129)
.annotate 'line', 911
    .return ($P3130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("435_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3132
    .param pmc param_3133
.annotate 'line', 915
    .const 'Sub' $P3144 = "436_1303391609.928" 
    capture_lex $P3144
    .lex "self", param_3132
    .lex "$/", param_3133
.annotate 'line', 916
    new $P3134, "Undef"
    .lex "$BLOCK", $P3134
    find_lex $P3135, "$?PACKAGE"
    get_who $P3136, $P3135
    set $P3137, $P3136["@BLOCK"]
    unless_null $P3137, vivify_1602
    $P3137 = root_new ['parrot';'ResizablePMCArray']
  vivify_1602:
    $P3138 = $P3137."shift"()
    store_lex "$BLOCK", $P3138
.annotate 'line', 917
    find_lex $P3141, "$/"
    unless_null $P3141, vivify_1603
    $P3141 = root_new ['parrot';'Hash']
  vivify_1603:
    set $P3142, $P3141["statementlist"]
    unless_null $P3142, vivify_1604
    new $P3142, "Undef"
  vivify_1604:
    if $P3142, if_3140
.annotate 'line', 925
    find_dynamic_lex $P3159, "$*HAS_YOU_ARE_HERE"
    unless_null $P3159, vivify_1605
    get_hll_global $P3159, "$HAS_YOU_ARE_HERE"
    unless_null $P3159, vivify_1606
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1606:
  vivify_1605:
    unless $P3159, if_3158_end
.annotate 'line', 926
    find_lex $P3160, "$/"
    unless_null $P3160, vivify_1607
    new $P3160, "Undef"
  vivify_1607:
    $P3161 = $P3160."CURSOR"()
    $P3161."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3158_end:
.annotate 'line', 928
    new $P3162, "Integer"
    assign $P3162, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3162
.annotate 'line', 929
    find_lex $P3163, "$/"
    find_lex $P3164, "$/"
    unless_null $P3164, vivify_1608
    $P3164 = root_new ['parrot';'Hash']
  vivify_1608:
    set $P3165, $P3164["you_are_here"]
    unless_null $P3165, vivify_1609
    new $P3165, "Undef"
  vivify_1609:
    $P3166 = $P3165."ast"()
    $P3167 = $P3163."!make"($P3166)
.annotate 'line', 924
    set $P3139, $P3167
.annotate 'line', 917
    goto if_3140_end
  if_3140:
    .const 'Sub' $P3144 = "436_1303391609.928" 
    capture_lex $P3144
    $P3157 = $P3144()
    set $P3139, $P3157
  if_3140_end:
.annotate 'line', 915
    .return ($P3139)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3143"  :anon :subid("436_1303391609.928") :outer("435_1303391609.928")
.annotate 'line', 918
    new $P3145, "Undef"
    .lex "$past", $P3145
    find_lex $P3146, "$/"
    unless_null $P3146, vivify_1610
    $P3146 = root_new ['parrot';'Hash']
  vivify_1610:
    set $P3147, $P3146["statementlist"]
    unless_null $P3147, vivify_1611
    new $P3147, "Undef"
  vivify_1611:
    $P3148 = $P3147."ast"()
    store_lex "$past", $P3148
.annotate 'line', 919
    find_lex $P3149, "$BLOCK"
    unless_null $P3149, vivify_1612
    new $P3149, "Undef"
  vivify_1612:
    find_lex $P3150, "$past"
    unless_null $P3150, vivify_1613
    new $P3150, "Undef"
  vivify_1613:
    $P3149."push"($P3150)
.annotate 'line', 920
    find_lex $P3151, "$BLOCK"
    unless_null $P3151, vivify_1614
    new $P3151, "Undef"
  vivify_1614:
    find_lex $P3152, "$/"
    unless_null $P3152, vivify_1615
    new $P3152, "Undef"
  vivify_1615:
    $P3151."node"($P3152)
.annotate 'line', 921
    find_lex $P3153, "$BLOCK"
    unless_null $P3153, vivify_1616
    new $P3153, "Undef"
  vivify_1616:
    $P3153."closure"(1)
.annotate 'line', 922
    find_dynamic_lex $P3154, "$/"
    find_lex $P3155, "$BLOCK"
    unless_null $P3155, vivify_1617
    new $P3155, "Undef"
  vivify_1617:
    $P3156 = $P3154."!make"($P3155)
.annotate 'line', 917
    .return ($P3156)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("437_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3169
    .param pmc param_3170
.annotate 'line', 933
    .lex "self", param_3169
    .lex "$/", param_3170
.annotate 'line', 934
    find_lex $P3171, "$?PACKAGE"
    get_who $P3172, $P3171
    set $P3173, $P3172["@BLOCK"]
    unless_null $P3173, vivify_1618
    $P3173 = root_new ['parrot';'ResizablePMCArray']
  vivify_1618:
    get_hll_global $P3174, ["PAST"], "Block"
    get_hll_global $P3175, ["PAST"], "Stmts"
    $P3176 = $P3175."new"()
    $P3177 = $P3174."new"($P3176)
    $P3178 = $P3173."unshift"($P3177)
.annotate 'line', 933
    .return ($P3178)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("438_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3180
    .param pmc param_3181
.annotate 'line', 937
    .lex "self", param_3180
    .lex "$/", param_3181
.annotate 'line', 938
    find_dynamic_lex $P3183, "%*COMPILING"
    unless_null $P3183, vivify_1619
    get_hll_global $P3183, "%COMPILING"
    unless_null $P3183, vivify_1620
    die "Contextual %*COMPILING not found"
  vivify_1620:
  vivify_1619:
    set $P3184, $P3183["%?OPTIONS"]
    unless_null $P3184, vivify_1621
    $P3184 = root_new ['parrot';'Hash']
  vivify_1621:
    set $P3185, $P3184["outer_ctx"]
    unless_null $P3185, vivify_1622
    new $P3185, "Undef"
  vivify_1622:
    defined $I3186, $P3185
    if $I3186, unless_3182_end
.annotate 'line', 941
    find_dynamic_lex $P3187, "$*SC"
    unless_null $P3187, vivify_1623
    get_hll_global $P3187, "$SC"
    unless_null $P3187, vivify_1624
    die "Contextual $*SC not found"
  vivify_1624:
  vivify_1623:
    find_dynamic_lex $P3189, "%*COMPILING"
    unless_null $P3189, vivify_1625
    get_hll_global $P3189, "%COMPILING"
    unless_null $P3189, vivify_1626
    die "Contextual %*COMPILING not found"
  vivify_1626:
  vivify_1625:
    set $P3190, $P3189["%?OPTIONS"]
    unless_null $P3190, vivify_1627
    $P3190 = root_new ['parrot';'Hash']
  vivify_1627:
    set $P3191, $P3190["setting"]
    unless_null $P3191, vivify_1628
    new $P3191, "Undef"
  vivify_1628:
    set $P3188, $P3191
    defined $I3193, $P3188
    if $I3193, default_3192
    new $P3194, "String"
    assign $P3194, "NQPCORE"
    set $P3188, $P3194
  default_3192:
    $P3187."load_setting"($P3188)
  unless_3182_end:
.annotate 'line', 943
    find_lex $P3195, "self"
    find_lex $P3196, "$?PACKAGE"
    get_who $P3197, $P3196
    set $P3198, $P3197["@BLOCK"]
    unless_null $P3198, vivify_1629
    $P3198 = root_new ['parrot';'ResizablePMCArray']
  vivify_1629:
    set $P3199, $P3198[0]
    unless_null $P3199, vivify_1630
    new $P3199, "Undef"
  vivify_1630:
    $P3200 = $P3195."SET_BLOCK_OUTER_CTX"($P3199)
.annotate 'line', 937
    .return ($P3200)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("439_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3202
    .param pmc param_3203
.annotate 'line', 946
    .lex "self", param_3202
    .lex "$/", param_3203
.annotate 'line', 950
    find_dynamic_lex $P3204, "$*SC"
    unless_null $P3204, vivify_1631
    get_hll_global $P3204, "$SC"
    unless_null $P3204, vivify_1632
    die "Contextual $*SC not found"
  vivify_1632:
  vivify_1631:
    get_hll_global $P3205, "KnowHOW"
    $P3206 = $P3204."pkg_create_mo"($P3205, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3206
.annotate 'line', 951
    find_dynamic_lex $P3207, "$*GLOBALish"
    unless_null $P3207, vivify_1633
    get_hll_global $P3207, "$GLOBALish"
    unless_null $P3207, vivify_1634
    die "Contextual $*GLOBALish not found"
  vivify_1634:
  vivify_1633:
    get_how $P3208, $P3207
    find_dynamic_lex $P3209, "$*GLOBALish"
    unless_null $P3209, vivify_1635
    get_hll_global $P3209, "$GLOBALish"
    unless_null $P3209, vivify_1636
    die "Contextual $*GLOBALish not found"
  vivify_1636:
  vivify_1635:
    $P3208."compose"($P3209)
.annotate 'line', 952
    find_dynamic_lex $P3210, "$*SC"
    unless_null $P3210, vivify_1637
    get_hll_global $P3210, "$SC"
    unless_null $P3210, vivify_1638
    die "Contextual $*SC not found"
  vivify_1638:
  vivify_1637:
    find_lex $P3211, "$?PACKAGE"
    get_who $P3212, $P3211
    set $P3213, $P3212["@BLOCK"]
    unless_null $P3213, vivify_1639
    $P3213 = root_new ['parrot';'ResizablePMCArray']
  vivify_1639:
    set $P3214, $P3213[0]
    unless_null $P3214, vivify_1640
    new $P3214, "Undef"
  vivify_1640:
    find_dynamic_lex $P3215, "$*GLOBALish"
    unless_null $P3215, vivify_1641
    get_hll_global $P3215, "$GLOBALish"
    unless_null $P3215, vivify_1642
    die "Contextual $*GLOBALish not found"
  vivify_1642:
  vivify_1641:
    $P3210."install_lexical_symbol"($P3214, "GLOBALish", $P3215)
.annotate 'line', 955
    find_dynamic_lex $P3216, "$*GLOBALish"
    unless_null $P3216, vivify_1643
    get_hll_global $P3216, "$GLOBALish"
    unless_null $P3216, vivify_1644
    die "Contextual $*GLOBALish not found"
  vivify_1644:
  vivify_1643:
    store_dynamic_lex "$*PACKAGE", $P3216
.annotate 'line', 956
    find_dynamic_lex $P3217, "$*SC"
    unless_null $P3217, vivify_1645
    get_hll_global $P3217, "$SC"
    unless_null $P3217, vivify_1646
    die "Contextual $*SC not found"
  vivify_1646:
  vivify_1645:
    find_lex $P3218, "$?PACKAGE"
    get_who $P3219, $P3218
    set $P3220, $P3219["@BLOCK"]
    unless_null $P3220, vivify_1647
    $P3220 = root_new ['parrot';'ResizablePMCArray']
  vivify_1647:
    set $P3221, $P3220[0]
    unless_null $P3221, vivify_1648
    new $P3221, "Undef"
  vivify_1648:
    find_dynamic_lex $P3222, "$*PACKAGE"
    unless_null $P3222, vivify_1649
    get_hll_global $P3222, "$PACKAGE"
    unless_null $P3222, vivify_1650
    die "Contextual $*PACKAGE not found"
  vivify_1650:
  vivify_1649:
    $P3223 = $P3217."install_lexical_symbol"($P3221, "$?PACKAGE", $P3222)
.annotate 'line', 946
    .return ($P3223)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("440_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3225
    .param pmc param_3226
.annotate 'line', 959
    .lex "self", param_3225
    .lex "$/", param_3226
.annotate 'line', 960
    find_lex $P3227, "$/"
    find_lex $P3228, "self"
    $P3229 = $P3228."CTXSAVE"()
    $P3230 = $P3227."!make"($P3229)
.annotate 'line', 959
    .return ($P3230)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("441_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3232
    .param pmc param_3233
.annotate 'line', 965
    .lex "self", param_3232
    .lex "$/", param_3233
.annotate 'line', 966
    find_dynamic_lex $P3234, "$*SC"
    unless_null $P3234, vivify_1651
    get_hll_global $P3234, "$SC"
    unless_null $P3234, vivify_1652
    die "Contextual $*SC not found"
  vivify_1652:
  vivify_1651:
    find_lex $P3235, "$/"
    unless_null $P3235, vivify_1653
    $P3235 = root_new ['parrot';'Hash']
  vivify_1653:
    set $P3236, $P3235["name"]
    unless_null $P3236, vivify_1654
    new $P3236, "Undef"
  vivify_1654:
    set $S3237, $P3236
    $P3234."load_module"($S3237)
.annotate 'line', 967
    find_lex $P3238, "$/"
    get_hll_global $P3239, ["PAST"], "Stmts"
    $P3240 = $P3239."new"()
    $P3241 = $P3238."!make"($P3240)
.annotate 'line', 965
    .return ($P3241)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("442_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3243
    .param pmc param_3244
.annotate 'line', 970
    .const 'Sub' $P3272 = "443_1303391609.928" 
    capture_lex $P3272
    .lex "self", param_3243
    .lex "$/", param_3244
.annotate 'line', 971
    new $P3245, "Undef"
    .lex "$count", $P3245
.annotate 'line', 972
    new $P3246, "Undef"
    .lex "$past", $P3246
.annotate 'line', 971
    find_lex $P3247, "$/"
    unless_null $P3247, vivify_1655
    $P3247 = root_new ['parrot';'Hash']
  vivify_1655:
    set $P3248, $P3247["xblock"]
    unless_null $P3248, vivify_1656
    new $P3248, "Undef"
  vivify_1656:
    set $N3249, $P3248
    new $P3250, 'Float'
    set $P3250, $N3249
    sub $P3251, $P3250, 1
    store_lex "$count", $P3251
.annotate 'line', 972
    find_lex $P3252, "$count"
    unless_null $P3252, vivify_1657
    new $P3252, "Undef"
  vivify_1657:
    set $I3253, $P3252
    find_lex $P3254, "$/"
    unless_null $P3254, vivify_1658
    $P3254 = root_new ['parrot';'Hash']
  vivify_1658:
    set $P3255, $P3254["xblock"]
    unless_null $P3255, vivify_1659
    $P3255 = root_new ['parrot';'ResizablePMCArray']
  vivify_1659:
    set $P3256, $P3255[$I3253]
    unless_null $P3256, vivify_1660
    new $P3256, "Undef"
  vivify_1660:
    $P3257 = $P3256."ast"()
    $P3258 = "xblock_immediate"($P3257)
    store_lex "$past", $P3258
.annotate 'line', 973
    find_lex $P3260, "$/"
    unless_null $P3260, vivify_1661
    $P3260 = root_new ['parrot';'Hash']
  vivify_1661:
    set $P3261, $P3260["else"]
    unless_null $P3261, vivify_1662
    new $P3261, "Undef"
  vivify_1662:
    unless $P3261, if_3259_end
.annotate 'line', 974
    find_lex $P3262, "$past"
    unless_null $P3262, vivify_1663
    new $P3262, "Undef"
  vivify_1663:
    find_lex $P3263, "$/"
    unless_null $P3263, vivify_1664
    $P3263 = root_new ['parrot';'Hash']
  vivify_1664:
    set $P3264, $P3263["else"]
    unless_null $P3264, vivify_1665
    $P3264 = root_new ['parrot';'ResizablePMCArray']
  vivify_1665:
    set $P3265, $P3264[0]
    unless_null $P3265, vivify_1666
    new $P3265, "Undef"
  vivify_1666:
    $P3266 = $P3265."ast"()
    $P3267 = "block_immediate"($P3266)
    $P3262."push"($P3267)
  if_3259_end:
.annotate 'line', 977
    new $P3288, 'ExceptionHandler'
    set_label $P3288, loop3287_handler
    $P3288."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3288
  loop3287_test:
    find_lex $P3268, "$count"
    unless_null $P3268, vivify_1667
    new $P3268, "Undef"
  vivify_1667:
    set $N3269, $P3268
    isgt $I3270, $N3269, 0.0
    unless $I3270, loop3287_done
  loop3287_redo:
    .const 'Sub' $P3272 = "443_1303391609.928" 
    capture_lex $P3272
    $P3272()
  loop3287_next:
    goto loop3287_test
  loop3287_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3289, exception, 'type'
    eq $P3289, .CONTROL_LOOP_NEXT, loop3287_next
    eq $P3289, .CONTROL_LOOP_REDO, loop3287_redo
  loop3287_done:
    pop_eh 
.annotate 'line', 983
    find_lex $P3290, "$/"
    find_lex $P3291, "$past"
    unless_null $P3291, vivify_1676
    new $P3291, "Undef"
  vivify_1676:
    $P3292 = $P3290."!make"($P3291)
.annotate 'line', 970
    .return ($P3292)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3271"  :anon :subid("443_1303391609.928") :outer("442_1303391609.928")
.annotate 'line', 979
    new $P3273, "Undef"
    .lex "$else", $P3273
.annotate 'line', 977
    find_lex $P3274, "$count"
    unless_null $P3274, vivify_1668
    new $P3274, "Undef"
  vivify_1668:
    clone $P3275, $P3274
    dec $P3274
.annotate 'line', 979
    find_lex $P3276, "$past"
    unless_null $P3276, vivify_1669
    new $P3276, "Undef"
  vivify_1669:
    store_lex "$else", $P3276
.annotate 'line', 980
    find_lex $P3277, "$count"
    unless_null $P3277, vivify_1670
    new $P3277, "Undef"
  vivify_1670:
    set $I3278, $P3277
    find_lex $P3279, "$/"
    unless_null $P3279, vivify_1671
    $P3279 = root_new ['parrot';'Hash']
  vivify_1671:
    set $P3280, $P3279["xblock"]
    unless_null $P3280, vivify_1672
    $P3280 = root_new ['parrot';'ResizablePMCArray']
  vivify_1672:
    set $P3281, $P3280[$I3278]
    unless_null $P3281, vivify_1673
    new $P3281, "Undef"
  vivify_1673:
    $P3282 = $P3281."ast"()
    $P3283 = "xblock_immediate"($P3282)
    store_lex "$past", $P3283
.annotate 'line', 981
    find_lex $P3284, "$past"
    unless_null $P3284, vivify_1674
    new $P3284, "Undef"
  vivify_1674:
    find_lex $P3285, "$else"
    unless_null $P3285, vivify_1675
    new $P3285, "Undef"
  vivify_1675:
    $P3286 = $P3284."push"($P3285)
.annotate 'line', 977
    .return ($P3286)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("444_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3294
    .param pmc param_3295
.annotate 'line', 986
    .lex "self", param_3294
    .lex "$/", param_3295
.annotate 'line', 987
    new $P3296, "Undef"
    .lex "$past", $P3296
    find_lex $P3297, "$/"
    unless_null $P3297, vivify_1677
    $P3297 = root_new ['parrot';'Hash']
  vivify_1677:
    set $P3298, $P3297["xblock"]
    unless_null $P3298, vivify_1678
    new $P3298, "Undef"
  vivify_1678:
    $P3299 = $P3298."ast"()
    $P3300 = "xblock_immediate"($P3299)
    store_lex "$past", $P3300
.annotate 'line', 988
    find_lex $P3301, "$past"
    unless_null $P3301, vivify_1679
    new $P3301, "Undef"
  vivify_1679:
    $P3301."pasttype"("unless")
.annotate 'line', 989
    find_lex $P3302, "$/"
    find_lex $P3303, "$past"
    unless_null $P3303, vivify_1680
    new $P3303, "Undef"
  vivify_1680:
    $P3304 = $P3302."!make"($P3303)
.annotate 'line', 986
    .return ($P3304)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("445_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3306
    .param pmc param_3307
.annotate 'line', 992
    .lex "self", param_3306
    .lex "$/", param_3307
.annotate 'line', 993
    new $P3308, "Undef"
    .lex "$past", $P3308
    find_lex $P3309, "$/"
    unless_null $P3309, vivify_1681
    $P3309 = root_new ['parrot';'Hash']
  vivify_1681:
    set $P3310, $P3309["xblock"]
    unless_null $P3310, vivify_1682
    new $P3310, "Undef"
  vivify_1682:
    $P3311 = $P3310."ast"()
    $P3312 = "xblock_immediate"($P3311)
    store_lex "$past", $P3312
.annotate 'line', 994
    find_lex $P3313, "$past"
    unless_null $P3313, vivify_1683
    new $P3313, "Undef"
  vivify_1683:
    find_lex $P3314, "$/"
    unless_null $P3314, vivify_1684
    $P3314 = root_new ['parrot';'Hash']
  vivify_1684:
    set $P3315, $P3314["sym"]
    unless_null $P3315, vivify_1685
    new $P3315, "Undef"
  vivify_1685:
    set $S3316, $P3315
    $P3313."pasttype"($S3316)
.annotate 'line', 995
    find_lex $P3317, "$/"
    find_lex $P3318, "$past"
    unless_null $P3318, vivify_1686
    new $P3318, "Undef"
  vivify_1686:
    $P3319 = $P3317."!make"($P3318)
.annotate 'line', 992
    .return ($P3319)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("446_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3321
    .param pmc param_3322
.annotate 'line', 998
    .lex "self", param_3321
    .lex "$/", param_3322
.annotate 'line', 999
    new $P3323, "Undef"
    .lex "$pasttype", $P3323
.annotate 'line', 1000
    new $P3324, "Undef"
    .lex "$past", $P3324
.annotate 'line', 999
    new $P3325, "String"
    assign $P3325, "repeat_"
    find_lex $P3326, "$/"
    unless_null $P3326, vivify_1687
    $P3326 = root_new ['parrot';'Hash']
  vivify_1687:
    set $P3327, $P3326["wu"]
    unless_null $P3327, vivify_1688
    new $P3327, "Undef"
  vivify_1688:
    set $S3328, $P3327
    concat $P3329, $P3325, $S3328
    store_lex "$pasttype", $P3329
    find_lex $P3330, "$past"
    unless_null $P3330, vivify_1689
    new $P3330, "Undef"
  vivify_1689:
.annotate 'line', 1001
    find_lex $P3332, "$/"
    unless_null $P3332, vivify_1690
    $P3332 = root_new ['parrot';'Hash']
  vivify_1690:
    set $P3333, $P3332["xblock"]
    unless_null $P3333, vivify_1691
    new $P3333, "Undef"
  vivify_1691:
    if $P3333, if_3331
.annotate 'line', 1006
    get_hll_global $P3340, ["PAST"], "Op"
    find_lex $P3341, "$/"
    unless_null $P3341, vivify_1692
    $P3341 = root_new ['parrot';'Hash']
  vivify_1692:
    set $P3342, $P3341["EXPR"]
    unless_null $P3342, vivify_1693
    new $P3342, "Undef"
  vivify_1693:
    $P3343 = $P3342."ast"()
    find_lex $P3344, "$/"
    unless_null $P3344, vivify_1694
    $P3344 = root_new ['parrot';'Hash']
  vivify_1694:
    set $P3345, $P3344["pblock"]
    unless_null $P3345, vivify_1695
    new $P3345, "Undef"
  vivify_1695:
    $P3346 = $P3345."ast"()
    $P3347 = "block_immediate"($P3346)
    find_lex $P3348, "$pasttype"
    unless_null $P3348, vivify_1696
    new $P3348, "Undef"
  vivify_1696:
    find_lex $P3349, "$/"
    unless_null $P3349, vivify_1697
    new $P3349, "Undef"
  vivify_1697:
    $P3350 = $P3340."new"($P3343, $P3347, $P3348 :named("pasttype"), $P3349 :named("node"))
    store_lex "$past", $P3350
.annotate 'line', 1005
    goto if_3331_end
  if_3331:
.annotate 'line', 1002
    find_lex $P3334, "$/"
    unless_null $P3334, vivify_1698
    $P3334 = root_new ['parrot';'Hash']
  vivify_1698:
    set $P3335, $P3334["xblock"]
    unless_null $P3335, vivify_1699
    new $P3335, "Undef"
  vivify_1699:
    $P3336 = $P3335."ast"()
    $P3337 = "xblock_immediate"($P3336)
    store_lex "$past", $P3337
.annotate 'line', 1003
    find_lex $P3338, "$past"
    unless_null $P3338, vivify_1700
    new $P3338, "Undef"
  vivify_1700:
    find_lex $P3339, "$pasttype"
    unless_null $P3339, vivify_1701
    new $P3339, "Undef"
  vivify_1701:
    $P3338."pasttype"($P3339)
  if_3331_end:
.annotate 'line', 1009
    find_lex $P3351, "$/"
    find_lex $P3352, "$past"
    unless_null $P3352, vivify_1702
    new $P3352, "Undef"
  vivify_1702:
    $P3353 = $P3351."!make"($P3352)
.annotate 'line', 998
    .return ($P3353)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("447_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3355
    .param pmc param_3356
.annotate 'line', 1012
    .lex "self", param_3355
    .lex "$/", param_3356
.annotate 'line', 1013
    new $P3357, "Undef"
    .lex "$past", $P3357
.annotate 'line', 1015
    new $P3358, "Undef"
    .lex "$block", $P3358
.annotate 'line', 1013
    find_lex $P3359, "$/"
    unless_null $P3359, vivify_1703
    $P3359 = root_new ['parrot';'Hash']
  vivify_1703:
    set $P3360, $P3359["xblock"]
    unless_null $P3360, vivify_1704
    new $P3360, "Undef"
  vivify_1704:
    $P3361 = $P3360."ast"()
    store_lex "$past", $P3361
.annotate 'line', 1014
    find_lex $P3362, "$past"
    unless_null $P3362, vivify_1705
    new $P3362, "Undef"
  vivify_1705:
    $P3362."pasttype"("for")
.annotate 'line', 1015
    find_lex $P3363, "$past"
    unless_null $P3363, vivify_1706
    $P3363 = root_new ['parrot';'ResizablePMCArray']
  vivify_1706:
    set $P3364, $P3363[1]
    unless_null $P3364, vivify_1707
    new $P3364, "Undef"
  vivify_1707:
    store_lex "$block", $P3364
.annotate 'line', 1016
    find_lex $P3366, "$block"
    unless_null $P3366, vivify_1708
    new $P3366, "Undef"
  vivify_1708:
    $P3367 = $P3366."arity"()
    if $P3367, unless_3365_end
.annotate 'line', 1017
    find_lex $P3368, "$block"
    unless_null $P3368, vivify_1709
    $P3368 = root_new ['parrot';'ResizablePMCArray']
  vivify_1709:
    set $P3369, $P3368[0]
    unless_null $P3369, vivify_1710
    new $P3369, "Undef"
  vivify_1710:
    get_hll_global $P3370, ["PAST"], "Var"
    $P3371 = $P3370."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3369."push"($P3371)
.annotate 'line', 1018
    find_lex $P3372, "$block"
    unless_null $P3372, vivify_1711
    new $P3372, "Undef"
  vivify_1711:
    $P3372."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1019
    find_lex $P3373, "$block"
    unless_null $P3373, vivify_1712
    new $P3373, "Undef"
  vivify_1712:
    $P3373."arity"(1)
  unless_3365_end:
.annotate 'line', 1021
    find_lex $P3374, "$block"
    unless_null $P3374, vivify_1713
    new $P3374, "Undef"
  vivify_1713:
    $P3374."blocktype"("immediate")
.annotate 'line', 1022
    find_lex $P3375, "$/"
    find_lex $P3376, "$past"
    unless_null $P3376, vivify_1714
    new $P3376, "Undef"
  vivify_1714:
    $P3377 = $P3375."!make"($P3376)
.annotate 'line', 1012
    .return ($P3377)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("448_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3379
    .param pmc param_3380
.annotate 'line', 1025
    .lex "self", param_3379
    .lex "$/", param_3380
.annotate 'line', 1026
    new $P3381, "Undef"
    .lex "$block", $P3381
    find_lex $P3382, "$/"
    unless_null $P3382, vivify_1715
    $P3382 = root_new ['parrot';'Hash']
  vivify_1715:
    set $P3383, $P3382["block"]
    unless_null $P3383, vivify_1716
    new $P3383, "Undef"
  vivify_1716:
    $P3384 = $P3383."ast"()
    store_lex "$block", $P3384
.annotate 'line', 1027
    find_lex $P3385, "$/"
    unless_null $P3385, vivify_1717
    new $P3385, "Undef"
  vivify_1717:
    find_lex $P3386, "$block"
    unless_null $P3386, vivify_1718
    new $P3386, "Undef"
  vivify_1718:
    "push_block_handler"($P3385, $P3386)
.annotate 'line', 1028
    find_lex $P3387, "$?PACKAGE"
    get_who $P3388, $P3387
    set $P3389, $P3388["@BLOCK"]
    unless_null $P3389, vivify_1719
    $P3389 = root_new ['parrot';'ResizablePMCArray']
  vivify_1719:
    set $P3390, $P3389[0]
    unless_null $P3390, vivify_1720
    new $P3390, "Undef"
  vivify_1720:
    $P3391 = $P3390."handlers"()
    set $P3392, $P3391[0]
    unless_null $P3392, vivify_1721
    new $P3392, "Undef"
  vivify_1721:
    $P3392."handle_types_except"("CONTROL")
.annotate 'line', 1029
    find_lex $P3393, "$/"
    get_hll_global $P3394, ["PAST"], "Stmts"
    find_lex $P3395, "$/"
    unless_null $P3395, vivify_1722
    new $P3395, "Undef"
  vivify_1722:
    $P3396 = $P3394."new"($P3395 :named("node"))
    $P3397 = $P3393."!make"($P3396)
.annotate 'line', 1025
    .return ($P3397)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("449_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3399
    .param pmc param_3400
.annotate 'line', 1032
    .lex "self", param_3399
    .lex "$/", param_3400
.annotate 'line', 1033
    new $P3401, "Undef"
    .lex "$block", $P3401
    find_lex $P3402, "$/"
    unless_null $P3402, vivify_1723
    $P3402 = root_new ['parrot';'Hash']
  vivify_1723:
    set $P3403, $P3402["block"]
    unless_null $P3403, vivify_1724
    new $P3403, "Undef"
  vivify_1724:
    $P3404 = $P3403."ast"()
    store_lex "$block", $P3404
.annotate 'line', 1034
    find_lex $P3405, "$/"
    unless_null $P3405, vivify_1725
    new $P3405, "Undef"
  vivify_1725:
    find_lex $P3406, "$block"
    unless_null $P3406, vivify_1726
    new $P3406, "Undef"
  vivify_1726:
    "push_block_handler"($P3405, $P3406)
.annotate 'line', 1035
    find_lex $P3407, "$?PACKAGE"
    get_who $P3408, $P3407
    set $P3409, $P3408["@BLOCK"]
    unless_null $P3409, vivify_1727
    $P3409 = root_new ['parrot';'ResizablePMCArray']
  vivify_1727:
    set $P3410, $P3409[0]
    unless_null $P3410, vivify_1728
    new $P3410, "Undef"
  vivify_1728:
    $P3411 = $P3410."handlers"()
    set $P3412, $P3411[0]
    unless_null $P3412, vivify_1729
    new $P3412, "Undef"
  vivify_1729:
    $P3412."handle_types"("CONTROL")
.annotate 'line', 1036
    find_lex $P3413, "$/"
    get_hll_global $P3414, ["PAST"], "Stmts"
    find_lex $P3415, "$/"
    unless_null $P3415, vivify_1730
    new $P3415, "Undef"
  vivify_1730:
    $P3416 = $P3414."new"($P3415 :named("node"))
    $P3417 = $P3413."!make"($P3416)
.annotate 'line', 1032
    .return ($P3417)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("450_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3420
    .param pmc param_3421
.annotate 'line', 1076
    .lex "self", param_3420
    .lex "$/", param_3421
.annotate 'line', 1077
    find_lex $P3422, "$?PACKAGE"
    get_who $P3423, $P3422
    set $P3424, $P3423["@BLOCK"]
    unless_null $P3424, vivify_1731
    $P3424 = root_new ['parrot';'ResizablePMCArray']
  vivify_1731:
    set $P3425, $P3424[0]
    unless_null $P3425, vivify_1732
    new $P3425, "Undef"
  vivify_1732:
    find_lex $P3426, "$/"
    unless_null $P3426, vivify_1733
    $P3426 = root_new ['parrot';'Hash']
  vivify_1733:
    set $P3427, $P3426["blorst"]
    unless_null $P3427, vivify_1734
    new $P3427, "Undef"
  vivify_1734:
    $P3428 = $P3427."ast"()
    $P3425."push"($P3428)
.annotate 'line', 1078
    find_lex $P3429, "$/"
    get_hll_global $P3430, ["PAST"], "Stmts"
    $P3431 = $P3430."new"()
    $P3432 = $P3429."!make"($P3431)
.annotate 'line', 1076
    .return ($P3432)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("451_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3434
    .param pmc param_3435
.annotate 'line', 1081
    .lex "self", param_3434
    .lex "$/", param_3435
.annotate 'line', 1082
    new $P3436, "Undef"
    .lex "$past", $P3436
    find_lex $P3437, "$/"
    unless_null $P3437, vivify_1735
    $P3437 = root_new ['parrot';'Hash']
  vivify_1735:
    set $P3438, $P3437["blorst"]
    unless_null $P3438, vivify_1736
    new $P3438, "Undef"
  vivify_1736:
    $P3439 = $P3438."ast"()
    store_lex "$past", $P3439
.annotate 'line', 1083
    get_hll_global $P3441, ["PAST"], "Block"
    find_lex $P3442, "$past"
    unless_null $P3442, vivify_1737
    new $P3442, "Undef"
  vivify_1737:
    $P3443 = $P3441."ACCEPTS"($P3442)
    if $P3443, unless_3440_end
.annotate 'line', 1084
    get_hll_global $P3444, ["PAST"], "Block"
    find_lex $P3445, "$past"
    unless_null $P3445, vivify_1738
    new $P3445, "Undef"
  vivify_1738:
    find_lex $P3446, "$/"
    unless_null $P3446, vivify_1739
    new $P3446, "Undef"
  vivify_1739:
    $P3447 = $P3444."new"($P3445, "immediate" :named("blocktype"), $P3446 :named("node"))
    store_lex "$past", $P3447
  unless_3440_end:
.annotate 'line', 1086
    find_lex $P3449, "$past"
    unless_null $P3449, vivify_1740
    new $P3449, "Undef"
  vivify_1740:
    $P3450 = $P3449."handlers"()
    if $P3450, unless_3448_end
.annotate 'line', 1087
    find_lex $P3451, "$past"
    unless_null $P3451, vivify_1741
    new $P3451, "Undef"
  vivify_1741:
    get_hll_global $P3452, ["PAST"], "Control"
.annotate 'line', 1089
    get_hll_global $P3453, ["PAST"], "Stmts"
.annotate 'line', 1090
    get_hll_global $P3454, ["PAST"], "Op"
.annotate 'line', 1091
    get_hll_global $P3455, ["PAST"], "Var"
.annotate 'line', 1092
    get_hll_global $P3456, ["PAST"], "Var"
    $P3457 = $P3456."new"("register" :named("scope"), "exception" :named("name"))
    $P3458 = $P3455."new"($P3457, "handled", "keyed" :named("scope"))
.annotate 'line', 1091
    $P3459 = $P3454."new"($P3458, 1, "bind" :named("pasttype"))
.annotate 'line', 1090
    $P3460 = $P3453."new"($P3459)
.annotate 'line', 1089
    $P3461 = $P3452."new"($P3460, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1087
    new $P3462, "ResizablePMCArray"
    push $P3462, $P3461
    $P3451."handlers"($P3462)
  unless_3448_end:
.annotate 'line', 1101
    find_lex $P3463, "$/"
    find_lex $P3464, "$past"
    unless_null $P3464, vivify_1742
    new $P3464, "Undef"
  vivify_1742:
    $P3465 = $P3463."!make"($P3464)
.annotate 'line', 1081
    .return ($P3465)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("452_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3467
    .param pmc param_3468
.annotate 'line', 1104
    .lex "self", param_3467
    .lex "$/", param_3468
.annotate 'line', 1105
    find_lex $P3469, "$/"
.annotate 'line', 1106
    find_lex $P3472, "$/"
    unless_null $P3472, vivify_1743
    $P3472 = root_new ['parrot';'Hash']
  vivify_1743:
    set $P3473, $P3472["block"]
    unless_null $P3473, vivify_1744
    new $P3473, "Undef"
  vivify_1744:
    if $P3473, if_3471
.annotate 'line', 1107
    find_lex $P3478, "$/"
    unless_null $P3478, vivify_1745
    $P3478 = root_new ['parrot';'Hash']
  vivify_1745:
    set $P3479, $P3478["statement"]
    unless_null $P3479, vivify_1746
    new $P3479, "Undef"
  vivify_1746:
    $P3480 = $P3479."ast"()
    set $P3470, $P3480
.annotate 'line', 1106
    goto if_3471_end
  if_3471:
    find_lex $P3474, "$/"
    unless_null $P3474, vivify_1747
    $P3474 = root_new ['parrot';'Hash']
  vivify_1747:
    set $P3475, $P3474["block"]
    unless_null $P3475, vivify_1748
    new $P3475, "Undef"
  vivify_1748:
    $P3476 = $P3475."ast"()
    $P3477 = "block_immediate"($P3476)
    set $P3470, $P3477
  if_3471_end:
    $P3481 = $P3469."!make"($P3470)
.annotate 'line', 1104
    .return ($P3481)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("453_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3483
    .param pmc param_3484
.annotate 'line', 1112
    .lex "self", param_3483
    .lex "$/", param_3484
    find_lex $P3485, "$/"
    find_lex $P3486, "$/"
    unless_null $P3486, vivify_1749
    $P3486 = root_new ['parrot';'Hash']
  vivify_1749:
    set $P3487, $P3486["cond"]
    unless_null $P3487, vivify_1750
    new $P3487, "Undef"
  vivify_1750:
    $P3488 = $P3487."ast"()
    $P3489 = $P3485."!make"($P3488)
    .return ($P3489)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("454_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3491
    .param pmc param_3492
.annotate 'line', 1113
    .lex "self", param_3491
    .lex "$/", param_3492
    find_lex $P3493, "$/"
    find_lex $P3494, "$/"
    unless_null $P3494, vivify_1751
    $P3494 = root_new ['parrot';'Hash']
  vivify_1751:
    set $P3495, $P3494["cond"]
    unless_null $P3495, vivify_1752
    new $P3495, "Undef"
  vivify_1752:
    $P3496 = $P3495."ast"()
    $P3497 = $P3493."!make"($P3496)
    .return ($P3497)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("455_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3499
    .param pmc param_3500
.annotate 'line', 1115
    .lex "self", param_3499
    .lex "$/", param_3500
    find_lex $P3501, "$/"
    find_lex $P3502, "$/"
    unless_null $P3502, vivify_1753
    $P3502 = root_new ['parrot';'Hash']
  vivify_1753:
    set $P3503, $P3502["cond"]
    unless_null $P3503, vivify_1754
    new $P3503, "Undef"
  vivify_1754:
    $P3504 = $P3503."ast"()
    $P3505 = $P3501."!make"($P3504)
    .return ($P3505)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("456_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3507
    .param pmc param_3508
.annotate 'line', 1116
    .lex "self", param_3507
    .lex "$/", param_3508
    find_lex $P3509, "$/"
    find_lex $P3510, "$/"
    unless_null $P3510, vivify_1755
    $P3510 = root_new ['parrot';'Hash']
  vivify_1755:
    set $P3511, $P3510["cond"]
    unless_null $P3511, vivify_1756
    new $P3511, "Undef"
  vivify_1756:
    $P3512 = $P3511."ast"()
    $P3513 = $P3509."!make"($P3512)
    .return ($P3513)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("457_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3515
    .param pmc param_3516
.annotate 'line', 1120
    .lex "self", param_3515
    .lex "$/", param_3516
    find_lex $P3517, "$/"
    find_lex $P3518, "$/"
    unless_null $P3518, vivify_1757
    $P3518 = root_new ['parrot';'Hash']
  vivify_1757:
    set $P3519, $P3518["fatarrow"]
    unless_null $P3519, vivify_1758
    new $P3519, "Undef"
  vivify_1758:
    $P3520 = $P3519."ast"()
    $P3521 = $P3517."!make"($P3520)
    .return ($P3521)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("458_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3523
    .param pmc param_3524
.annotate 'line', 1121
    .lex "self", param_3523
    .lex "$/", param_3524
    find_lex $P3525, "$/"
    find_lex $P3526, "$/"
    unless_null $P3526, vivify_1759
    $P3526 = root_new ['parrot';'Hash']
  vivify_1759:
    set $P3527, $P3526["colonpair"]
    unless_null $P3527, vivify_1760
    new $P3527, "Undef"
  vivify_1760:
    $P3528 = $P3527."ast"()
    $P3529 = $P3525."!make"($P3528)
    .return ($P3529)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("459_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3531
    .param pmc param_3532
.annotate 'line', 1122
    .lex "self", param_3531
    .lex "$/", param_3532
    find_lex $P3533, "$/"
    find_lex $P3534, "$/"
    unless_null $P3534, vivify_1761
    $P3534 = root_new ['parrot';'Hash']
  vivify_1761:
    set $P3535, $P3534["variable"]
    unless_null $P3535, vivify_1762
    new $P3535, "Undef"
  vivify_1762:
    $P3536 = $P3535."ast"()
    $P3537 = $P3533."!make"($P3536)
    .return ($P3537)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("460_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3539
    .param pmc param_3540
.annotate 'line', 1123
    .lex "self", param_3539
    .lex "$/", param_3540
    find_lex $P3541, "$/"
    find_lex $P3542, "$/"
    unless_null $P3542, vivify_1763
    $P3542 = root_new ['parrot';'Hash']
  vivify_1763:
    set $P3543, $P3542["package_declarator"]
    unless_null $P3543, vivify_1764
    new $P3543, "Undef"
  vivify_1764:
    $P3544 = $P3543."ast"()
    $P3545 = $P3541."!make"($P3544)
    .return ($P3545)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("461_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3547
    .param pmc param_3548
.annotate 'line', 1124
    .lex "self", param_3547
    .lex "$/", param_3548
    find_lex $P3549, "$/"
    find_lex $P3550, "$/"
    unless_null $P3550, vivify_1765
    $P3550 = root_new ['parrot';'Hash']
  vivify_1765:
    set $P3551, $P3550["scope_declarator"]
    unless_null $P3551, vivify_1766
    new $P3551, "Undef"
  vivify_1766:
    $P3552 = $P3551."ast"()
    $P3553 = $P3549."!make"($P3552)
    .return ($P3553)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("462_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3555
    .param pmc param_3556
.annotate 'line', 1125
    .lex "self", param_3555
    .lex "$/", param_3556
    find_lex $P3557, "$/"
    find_lex $P3558, "$/"
    unless_null $P3558, vivify_1767
    $P3558 = root_new ['parrot';'Hash']
  vivify_1767:
    set $P3559, $P3558["routine_declarator"]
    unless_null $P3559, vivify_1768
    new $P3559, "Undef"
  vivify_1768:
    $P3560 = $P3559."ast"()
    $P3561 = $P3557."!make"($P3560)
    .return ($P3561)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("463_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3563
    .param pmc param_3564
.annotate 'line', 1126
    .lex "self", param_3563
    .lex "$/", param_3564
    find_lex $P3565, "$/"
    find_lex $P3566, "$/"
    unless_null $P3566, vivify_1769
    $P3566 = root_new ['parrot';'Hash']
  vivify_1769:
    set $P3567, $P3566["regex_declarator"]
    unless_null $P3567, vivify_1770
    new $P3567, "Undef"
  vivify_1770:
    $P3568 = $P3567."ast"()
    $P3569 = $P3565."!make"($P3568)
    .return ($P3569)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("464_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3571
    .param pmc param_3572
.annotate 'line', 1127
    .lex "self", param_3571
    .lex "$/", param_3572
    find_lex $P3573, "$/"
    find_lex $P3574, "$/"
    unless_null $P3574, vivify_1771
    $P3574 = root_new ['parrot';'Hash']
  vivify_1771:
    set $P3575, $P3574["statement_prefix"]
    unless_null $P3575, vivify_1772
    new $P3575, "Undef"
  vivify_1772:
    $P3576 = $P3575."ast"()
    $P3577 = $P3573."!make"($P3576)
    .return ($P3577)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("465_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3579
    .param pmc param_3580
.annotate 'line', 1128
    .lex "self", param_3579
    .lex "$/", param_3580
    find_lex $P3581, "$/"
    find_lex $P3582, "$/"
    unless_null $P3582, vivify_1773
    $P3582 = root_new ['parrot';'Hash']
  vivify_1773:
    set $P3583, $P3582["pblock"]
    unless_null $P3583, vivify_1774
    new $P3583, "Undef"
  vivify_1774:
    $P3584 = $P3583."ast"()
    $P3585 = $P3581."!make"($P3584)
    .return ($P3585)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("466_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3587
    .param pmc param_3588
.annotate 'line', 1130
    .lex "self", param_3587
    .lex "$/", param_3588
.annotate 'line', 1131
    new $P3589, "Undef"
    .lex "$past", $P3589
    find_lex $P3590, "$/"
    unless_null $P3590, vivify_1775
    $P3590 = root_new ['parrot';'Hash']
  vivify_1775:
    set $P3591, $P3590["val"]
    unless_null $P3591, vivify_1776
    new $P3591, "Undef"
  vivify_1776:
    $P3592 = $P3591."ast"()
    store_lex "$past", $P3592
.annotate 'line', 1132
    find_lex $P3593, "$past"
    unless_null $P3593, vivify_1777
    new $P3593, "Undef"
  vivify_1777:
    find_lex $P3594, "$/"
    unless_null $P3594, vivify_1778
    $P3594 = root_new ['parrot';'Hash']
  vivify_1778:
    set $P3595, $P3594["key"]
    unless_null $P3595, vivify_1779
    new $P3595, "Undef"
  vivify_1779:
    $P3596 = $P3595."Str"()
    $P3593."named"($P3596)
.annotate 'line', 1133
    find_lex $P3597, "$/"
    find_lex $P3598, "$past"
    unless_null $P3598, vivify_1780
    new $P3598, "Undef"
  vivify_1780:
    $P3599 = $P3597."!make"($P3598)
.annotate 'line', 1130
    .return ($P3599)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("467_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3601
    .param pmc param_3602
.annotate 'line', 1136
    .lex "self", param_3601
    .lex "$/", param_3602
.annotate 'line', 1137
    new $P3603, "Undef"
    .lex "$past", $P3603
.annotate 'line', 1138
    find_lex $P3606, "$/"
    unless_null $P3606, vivify_1781
    $P3606 = root_new ['parrot';'Hash']
  vivify_1781:
    set $P3607, $P3606["circumfix"]
    unless_null $P3607, vivify_1782
    new $P3607, "Undef"
  vivify_1782:
    if $P3607, if_3605
.annotate 'line', 1139
    get_hll_global $P3612, ["PAST"], "Val"
    find_lex $P3613, "$/"
    unless_null $P3613, vivify_1783
    $P3613 = root_new ['parrot';'Hash']
  vivify_1783:
    set $P3614, $P3613["not"]
    unless_null $P3614, vivify_1784
    new $P3614, "Undef"
  vivify_1784:
    isfalse $I3615, $P3614
    $P3616 = $P3612."new"($I3615 :named("value"))
    set $P3604, $P3616
.annotate 'line', 1138
    goto if_3605_end
  if_3605:
    find_lex $P3608, "$/"
    unless_null $P3608, vivify_1785
    $P3608 = root_new ['parrot';'Hash']
  vivify_1785:
    set $P3609, $P3608["circumfix"]
    unless_null $P3609, vivify_1786
    $P3609 = root_new ['parrot';'ResizablePMCArray']
  vivify_1786:
    set $P3610, $P3609[0]
    unless_null $P3610, vivify_1787
    new $P3610, "Undef"
  vivify_1787:
    $P3611 = $P3610."ast"()
    set $P3604, $P3611
  if_3605_end:
    store_lex "$past", $P3604
.annotate 'line', 1140
    find_lex $P3617, "$past"
    unless_null $P3617, vivify_1788
    new $P3617, "Undef"
  vivify_1788:
    find_lex $P3618, "$/"
    unless_null $P3618, vivify_1789
    $P3618 = root_new ['parrot';'Hash']
  vivify_1789:
    set $P3619, $P3618["identifier"]
    unless_null $P3619, vivify_1790
    new $P3619, "Undef"
  vivify_1790:
    set $S3620, $P3619
    $P3617."named"($S3620)
.annotate 'line', 1141
    find_lex $P3621, "$/"
    find_lex $P3622, "$past"
    unless_null $P3622, vivify_1791
    new $P3622, "Undef"
  vivify_1791:
    $P3623 = $P3621."!make"($P3622)
.annotate 'line', 1136
    .return ($P3623)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("468_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3625
    .param pmc param_3626
.annotate 'line', 1144
    .const 'Sub' $P3639 = "469_1303391609.928" 
    capture_lex $P3639
    .lex "self", param_3625
    .lex "$/", param_3626
.annotate 'line', 1145
    new $P3627, "Undef"
    .lex "$past", $P3627
.annotate 'line', 1144
    find_lex $P3628, "$past"
    unless_null $P3628, vivify_1792
    new $P3628, "Undef"
  vivify_1792:
.annotate 'line', 1146
    find_lex $P3630, "$/"
    unless_null $P3630, vivify_1793
    $P3630 = root_new ['parrot';'Hash']
  vivify_1793:
    set $P3631, $P3630["postcircumfix"]
    unless_null $P3631, vivify_1794
    new $P3631, "Undef"
  vivify_1794:
    if $P3631, if_3629
.annotate 'line', 1150
    .const 'Sub' $P3639 = "469_1303391609.928" 
    capture_lex $P3639
    $P3639()
    goto if_3629_end
  if_3629:
.annotate 'line', 1147
    find_lex $P3632, "$/"
    unless_null $P3632, vivify_1830
    $P3632 = root_new ['parrot';'Hash']
  vivify_1830:
    set $P3633, $P3632["postcircumfix"]
    unless_null $P3633, vivify_1831
    new $P3633, "Undef"
  vivify_1831:
    $P3634 = $P3633."ast"()
    store_lex "$past", $P3634
.annotate 'line', 1148
    find_lex $P3635, "$past"
    unless_null $P3635, vivify_1832
    new $P3635, "Undef"
  vivify_1832:
    get_hll_global $P3636, ["PAST"], "Var"
    $P3637 = $P3636."new"("$/" :named("name"))
    $P3635."unshift"($P3637)
  if_3629_end:
.annotate 'line', 1192
    find_lex $P3732, "$/"
    find_lex $P3733, "$past"
    unless_null $P3733, vivify_1833
    new $P3733, "Undef"
  vivify_1833:
    $P3734 = $P3732."!make"($P3733)
.annotate 'line', 1144
    .return ($P3734)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3638"  :anon :subid("469_1303391609.928") :outer("468_1303391609.928")
.annotate 'line', 1151
    $P3640 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3640
    get_hll_global $P3641, ["NQP"], "Compiler"
    find_lex $P3642, "$/"
    unless_null $P3642, vivify_1795
    new $P3642, "Undef"
  vivify_1795:
    set $S3643, $P3642
    $P3644 = $P3641."parse_name"($S3643)
    store_lex "@name", $P3644
.annotate 'line', 1152
    find_lex $P3647, "@name"
    unless_null $P3647, vivify_1796
    $P3647 = root_new ['parrot';'ResizablePMCArray']
  vivify_1796:
    set $N3648, $P3647
    isgt $I3649, $N3648, 1.0
    if $I3649, if_3646
.annotate 'line', 1159
    find_lex $P3665, "$/"
    unless_null $P3665, vivify_1797
    $P3665 = root_new ['parrot';'Hash']
  vivify_1797:
    set $P3666, $P3665["twigil"]
    unless_null $P3666, vivify_1798
    $P3666 = root_new ['parrot';'ResizablePMCArray']
  vivify_1798:
    set $P3667, $P3666[0]
    unless_null $P3667, vivify_1799
    new $P3667, "Undef"
  vivify_1799:
    set $S3668, $P3667
    iseq $I3669, $S3668, "*"
    if $I3669, if_3664
.annotate 'line', 1174
    find_lex $P3693, "$/"
    unless_null $P3693, vivify_1800
    $P3693 = root_new ['parrot';'Hash']
  vivify_1800:
    set $P3694, $P3693["twigil"]
    unless_null $P3694, vivify_1801
    $P3694 = root_new ['parrot';'ResizablePMCArray']
  vivify_1801:
    set $P3695, $P3694[0]
    unless_null $P3695, vivify_1802
    new $P3695, "Undef"
  vivify_1802:
    set $S3696, $P3695
    iseq $I3697, $S3696, "!"
    if $I3697, if_3692
.annotate 'line', 1182
    find_lex $P3712, "@name"
    unless_null $P3712, vivify_1803
    $P3712 = root_new ['parrot';'ResizablePMCArray']
  vivify_1803:
    set $P3713, $P3712[0]
    unless_null $P3713, vivify_1804
    new $P3713, "Undef"
  vivify_1804:
    set $S3714, $P3713
    $P3715 = "is_package"($S3714)
    if $P3715, if_3711
.annotate 'line', 1187
    get_hll_global $P3724, ["PAST"], "Var"
.annotate 'line', 1188
    find_lex $P3725, "@name"
    unless_null $P3725, vivify_1805
    $P3725 = root_new ['parrot';'ResizablePMCArray']
  vivify_1805:
    $P3726 = $P3725."pop"()
    set $S3727, $P3726
    find_lex $P3728, "$/"
    unless_null $P3728, vivify_1806
    $P3728 = root_new ['parrot';'Hash']
  vivify_1806:
    set $P3729, $P3728["sigil"]
    unless_null $P3729, vivify_1807
    new $P3729, "Undef"
  vivify_1807:
    $P3730 = "vivitype"($P3729)
    $P3731 = $P3724."new"($S3727 :named("name"), $P3730 :named("viviself"))
.annotate 'line', 1187
    store_lex "$past", $P3731
.annotate 'line', 1186
    set $P3710, $P3731
.annotate 'line', 1182
    goto if_3711_end
  if_3711:
.annotate 'line', 1183
    find_lex $P3716, "@name"
    unless_null $P3716, vivify_1808
    $P3716 = root_new ['parrot';'ResizablePMCArray']
  vivify_1808:
    find_lex $P3717, "$/"
    unless_null $P3717, vivify_1809
    new $P3717, "Undef"
  vivify_1809:
    $P3718 = "lexical_package_lookup"($P3716, $P3717)
    store_lex "$past", $P3718
.annotate 'line', 1184
    find_lex $P3719, "$past"
    unless_null $P3719, vivify_1810
    new $P3719, "Undef"
  vivify_1810:
    find_lex $P3720, "$/"
    unless_null $P3720, vivify_1811
    $P3720 = root_new ['parrot';'Hash']
  vivify_1811:
    set $P3721, $P3720["sigil"]
    unless_null $P3721, vivify_1812
    new $P3721, "Undef"
  vivify_1812:
    $P3722 = "vivitype"($P3721)
    $P3723 = $P3719."viviself"($P3722)
.annotate 'line', 1182
    set $P3710, $P3723
  if_3711_end:
    set $P3691, $P3710
.annotate 'line', 1174
    goto if_3692_end
  if_3692:
.annotate 'line', 1175
    get_hll_global $P3698, ["PAST"], "Var"
.annotate 'line', 1176
    find_lex $P3699, "@name"
    unless_null $P3699, vivify_1813
    $P3699 = root_new ['parrot';'ResizablePMCArray']
  vivify_1813:
    $P3700 = $P3699."pop"()
    set $S3701, $P3700
.annotate 'line', 1177
    find_lex $P3702, "$/"
    unless_null $P3702, vivify_1814
    $P3702 = root_new ['parrot';'Hash']
  vivify_1814:
    set $P3703, $P3702["sigil"]
    unless_null $P3703, vivify_1815
    new $P3703, "Undef"
  vivify_1815:
    $P3704 = "vivitype"($P3703)
.annotate 'line', 1178
    get_hll_global $P3705, ["PAST"], "Var"
    $P3706 = $P3705."new"("self" :named("name"))
.annotate 'line', 1179
    get_hll_global $P3707, ["PAST"], "Var"
    $P3708 = $P3707."new"("$?CLASS" :named("name"))
    $P3709 = $P3698."new"($P3706, $P3708, $S3701 :named("name"), "attribute" :named("scope"), $P3704 :named("viviself"))
.annotate 'line', 1175
    store_lex "$past", $P3709
.annotate 'line', 1174
    set $P3691, $P3709
  if_3692_end:
    set $P3663, $P3691
.annotate 'line', 1159
    goto if_3664_end
  if_3664:
.annotate 'line', 1160
    get_hll_global $P3670, ["PAST"], "Var"
.annotate 'line', 1161
    find_lex $P3671, "@name"
    unless_null $P3671, vivify_1816
    $P3671 = root_new ['parrot';'ResizablePMCArray']
  vivify_1816:
    $P3672 = $P3671."pop"()
    set $S3673, $P3672
.annotate 'line', 1163
    get_hll_global $P3674, ["PAST"], "Var"
.annotate 'line', 1165
    find_lex $P3675, "$/"
    unless_null $P3675, vivify_1817
    $P3675 = root_new ['parrot';'Hash']
  vivify_1817:
    set $P3676, $P3675["sigil"]
    unless_null $P3676, vivify_1818
    new $P3676, "Undef"
  vivify_1818:
    set $S3677, $P3676
    new $P3678, 'String'
    set $P3678, $S3677
    find_lex $P3679, "$/"
    unless_null $P3679, vivify_1819
    $P3679 = root_new ['parrot';'Hash']
  vivify_1819:
    set $P3680, $P3679["desigilname"]
    unless_null $P3680, vivify_1820
    new $P3680, "Undef"
  vivify_1820:
    concat $P3681, $P3678, $P3680
.annotate 'line', 1167
    get_hll_global $P3682, ["PAST"], "Op"
    new $P3683, "String"
    assign $P3683, "Contextual "
    find_lex $P3684, "$/"
    unless_null $P3684, vivify_1821
    new $P3684, "Undef"
  vivify_1821:
    set $S3685, $P3684
    concat $P3686, $P3683, $S3685
    concat $P3687, $P3686, " not found"
    $P3688 = $P3682."new"($P3687, "die" :named("pirop"))
    $P3689 = $P3674."new"("package" :named("scope"), "" :named("namespace"), $P3681 :named("name"), $P3688 :named("viviself"))
.annotate 'line', 1163
    $P3690 = $P3670."new"($S3673 :named("name"), "contextual" :named("scope"), $P3689 :named("viviself"))
.annotate 'line', 1160
    store_lex "$past", $P3690
.annotate 'line', 1159
    set $P3663, $P3690
  if_3664_end:
    set $P3645, $P3663
.annotate 'line', 1152
    goto if_3646_end
  if_3646:
.annotate 'line', 1153
    find_lex $P3651, "$/"
    unless_null $P3651, vivify_1822
    $P3651 = root_new ['parrot';'Hash']
  vivify_1822:
    set $P3652, $P3651["twigil"]
    unless_null $P3652, vivify_1823
    new $P3652, "Undef"
  vivify_1823:
    unless $P3652, if_3650_end
.annotate 'line', 1154
    find_lex $P3653, "$/"
    unless_null $P3653, vivify_1824
    new $P3653, "Undef"
  vivify_1824:
    $P3654 = $P3653."CURSOR"()
    $P3654."panic"("Twigil not allowed on multi-part name")
  if_3650_end:
.annotate 'line', 1156
    find_lex $P3655, "@name"
    unless_null $P3655, vivify_1825
    $P3655 = root_new ['parrot';'ResizablePMCArray']
  vivify_1825:
    find_lex $P3656, "$/"
    unless_null $P3656, vivify_1826
    new $P3656, "Undef"
  vivify_1826:
    $P3657 = "lexical_package_lookup"($P3655, $P3656)
    store_lex "$past", $P3657
.annotate 'line', 1157
    find_lex $P3658, "$past"
    unless_null $P3658, vivify_1827
    new $P3658, "Undef"
  vivify_1827:
    find_lex $P3659, "$/"
    unless_null $P3659, vivify_1828
    $P3659 = root_new ['parrot';'Hash']
  vivify_1828:
    set $P3660, $P3659["sigil"]
    unless_null $P3660, vivify_1829
    new $P3660, "Undef"
  vivify_1829:
    $P3661 = "vivitype"($P3660)
    $P3662 = $P3658."viviself"($P3661)
.annotate 'line', 1152
    set $P3645, $P3662
  if_3646_end:
.annotate 'line', 1150
    .return ($P3645)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("470_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3736
    .param pmc param_3737
.annotate 'line', 1195
    .lex "self", param_3736
    .lex "$/", param_3737
    find_lex $P3738, "$/"
    find_lex $P3739, "$/"
    unless_null $P3739, vivify_1834
    $P3739 = root_new ['parrot';'Hash']
  vivify_1834:
    set $P3740, $P3739["package_def"]
    unless_null $P3740, vivify_1835
    new $P3740, "Undef"
  vivify_1835:
    $P3741 = $P3740."ast"()
    $P3742 = $P3738."!make"($P3741)
    .return ($P3742)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("471_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3744
    .param pmc param_3745
.annotate 'line', 1196
    .lex "self", param_3744
    .lex "$/", param_3745
    find_lex $P3746, "$/"
    find_lex $P3747, "$/"
    unless_null $P3747, vivify_1836
    $P3747 = root_new ['parrot';'Hash']
  vivify_1836:
    set $P3748, $P3747["package_def"]
    unless_null $P3748, vivify_1837
    new $P3748, "Undef"
  vivify_1837:
    $P3749 = $P3748."ast"()
    $P3750 = $P3746."!make"($P3749)
    .return ($P3750)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("472_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3752
    .param pmc param_3753
.annotate 'line', 1197
    .lex "self", param_3752
    .lex "$/", param_3753
    find_lex $P3754, "$/"
    find_lex $P3755, "$/"
    unless_null $P3755, vivify_1838
    $P3755 = root_new ['parrot';'Hash']
  vivify_1838:
    set $P3756, $P3755["package_def"]
    unless_null $P3756, vivify_1839
    new $P3756, "Undef"
  vivify_1839:
    $P3757 = $P3756."ast"()
    $P3758 = $P3754."!make"($P3757)
    .return ($P3758)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("473_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3760
    .param pmc param_3761
.annotate 'line', 1198
    .lex "self", param_3760
    .lex "$/", param_3761
    find_lex $P3762, "$/"
    find_lex $P3763, "$/"
    unless_null $P3763, vivify_1840
    $P3763 = root_new ['parrot';'Hash']
  vivify_1840:
    set $P3764, $P3763["package_def"]
    unless_null $P3764, vivify_1841
    new $P3764, "Undef"
  vivify_1841:
    $P3765 = $P3764."ast"()
    $P3766 = $P3762."!make"($P3765)
    .return ($P3766)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("474_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3768
    .param pmc param_3769
.annotate 'line', 1199
    .lex "self", param_3768
    .lex "$/", param_3769
    find_lex $P3770, "$/"
    find_lex $P3771, "$/"
    unless_null $P3771, vivify_1842
    $P3771 = root_new ['parrot';'Hash']
  vivify_1842:
    set $P3772, $P3771["package_def"]
    unless_null $P3772, vivify_1843
    new $P3772, "Undef"
  vivify_1843:
    $P3773 = $P3772."ast"()
    $P3774 = $P3770."!make"($P3773)
    .return ($P3774)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("475_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3776
    .param pmc param_3777
.annotate 'line', 1200
    .lex "self", param_3776
    .lex "$/", param_3777
    find_lex $P3778, "$/"
    find_lex $P3779, "$/"
    unless_null $P3779, vivify_1844
    $P3779 = root_new ['parrot';'Hash']
  vivify_1844:
    set $P3780, $P3779["package_def"]
    unless_null $P3780, vivify_1845
    new $P3780, "Undef"
  vivify_1845:
    $P3781 = $P3780."ast"()
    $P3782 = $P3778."!make"($P3781)
    .return ($P3782)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("476_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_3784
    .param pmc param_3785
.annotate 'line', 1202
    .const 'Sub' $P3960 = "478_1303391609.928" 
    capture_lex $P3960
    .const 'Sub' $P3909 = "477_1303391609.928" 
    capture_lex $P3909
    .lex "self", param_3784
    .lex "$/", param_3785
.annotate 'line', 1204
    $P3786 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3786
.annotate 'line', 1205
    new $P3787, "Undef"
    .lex "$name", $P3787
.annotate 'line', 1206
    new $P3788, "Undef"
    .lex "$how", $P3788
.annotate 'line', 1209
    new $P3789, "Undef"
    .lex "$past", $P3789
.annotate 'line', 1204
    find_lex $P3790, "$/"
    unless_null $P3790, vivify_1846
    $P3790 = root_new ['parrot';'Hash']
  vivify_1846:
    set $P3791, $P3790["name"]
    unless_null $P3791, vivify_1847
    $P3791 = root_new ['parrot';'Hash']
  vivify_1847:
    set $P3792, $P3791["identifier"]
    unless_null $P3792, vivify_1848
    new $P3792, "Undef"
  vivify_1848:
    clone $P3793, $P3792
    store_lex "@ns", $P3793
.annotate 'line', 1205
    find_lex $P3794, "@ns"
    unless_null $P3794, vivify_1849
    $P3794 = root_new ['parrot';'ResizablePMCArray']
  vivify_1849:
    $P3795 = $P3794."pop"()
    set $S3796, $P3795
    new $P3797, 'String'
    set $P3797, $S3796
    store_lex "$name", $P3797
.annotate 'line', 1206
    find_dynamic_lex $P3798, "$*PKGDECL"
    unless_null $P3798, vivify_1850
    get_hll_global $P3798, "$PKGDECL"
    unless_null $P3798, vivify_1851
    die "Contextual $*PKGDECL not found"
  vivify_1851:
  vivify_1850:
    find_dynamic_lex $P3799, "%*HOW"
    unless_null $P3799, vivify_1852
    get_hll_global $P3799, "%HOW"
    unless_null $P3799, vivify_1853
    die "Contextual %*HOW not found"
  vivify_1853:
  vivify_1852:
    set $P3800, $P3799[$P3798]
    unless_null $P3800, vivify_1854
    new $P3800, "Undef"
  vivify_1854:
    store_lex "$how", $P3800
.annotate 'line', 1209
    find_lex $P3803, "$/"
    unless_null $P3803, vivify_1855
    $P3803 = root_new ['parrot';'Hash']
  vivify_1855:
    set $P3804, $P3803["block"]
    unless_null $P3804, vivify_1856
    new $P3804, "Undef"
  vivify_1856:
    if $P3804, if_3802
    find_lex $P3808, "$/"
    unless_null $P3808, vivify_1857
    $P3808 = root_new ['parrot';'Hash']
  vivify_1857:
    set $P3809, $P3808["comp_unit"]
    unless_null $P3809, vivify_1858
    new $P3809, "Undef"
  vivify_1858:
    $P3810 = $P3809."ast"()
    set $P3801, $P3810
    goto if_3802_end
  if_3802:
    find_lex $P3805, "$/"
    unless_null $P3805, vivify_1859
    $P3805 = root_new ['parrot';'Hash']
  vivify_1859:
    set $P3806, $P3805["block"]
    unless_null $P3806, vivify_1860
    new $P3806, "Undef"
  vivify_1860:
    $P3807 = $P3806."ast"()
    set $P3801, $P3807
  if_3802_end:
    store_lex "$past", $P3801
.annotate 'line', 1212
    find_dynamic_lex $P3814, "$*SCOPE"
    unless_null $P3814, vivify_1861
    get_hll_global $P3814, "$SCOPE"
    unless_null $P3814, vivify_1862
    die "Contextual $*SCOPE not found"
  vivify_1862:
  vivify_1861:
    set $S3815, $P3814
    iseq $I3816, $S3815, "our"
    unless $I3816, unless_3813
    new $P3812, 'Integer'
    set $P3812, $I3816
    goto unless_3813_end
  unless_3813:
    find_dynamic_lex $P3817, "$*SCOPE"
    unless_null $P3817, vivify_1863
    get_hll_global $P3817, "$SCOPE"
    unless_null $P3817, vivify_1864
    die "Contextual $*SCOPE not found"
  vivify_1864:
  vivify_1863:
    set $S3818, $P3817
    iseq $I3819, $S3818, ""
    new $P3812, 'Integer'
    set $P3812, $I3819
  unless_3813_end:
    if $P3812, if_3811
.annotate 'line', 1216
    find_dynamic_lex $P3831, "$*SCOPE"
    unless_null $P3831, vivify_1865
    get_hll_global $P3831, "$SCOPE"
    unless_null $P3831, vivify_1866
    die "Contextual $*SCOPE not found"
  vivify_1866:
  vivify_1865:
    set $S3832, $P3831
    iseq $I3833, $S3832, "my"
    if $I3833, if_3830
.annotate 'line', 1223
    find_lex $P3853, "$/"
    unless_null $P3853, vivify_1867
    new $P3853, "Undef"
  vivify_1867:
    $P3854 = $P3853."CURSOR"()
    find_dynamic_lex $P3855, "$*SCOPE"
    unless_null $P3855, vivify_1868
    get_hll_global $P3855, "$SCOPE"
    unless_null $P3855, vivify_1869
    die "Contextual $*SCOPE not found"
  vivify_1869:
  vivify_1868:
    concat $P3856, $P3855, " scoped packages are not supported"
    $P3854."panic"($P3856)
.annotate 'line', 1222
    goto if_3830_end
  if_3830:
.annotate 'line', 1217
    find_lex $P3835, "$/"
    unless_null $P3835, vivify_1870
    $P3835 = root_new ['parrot';'Hash']
  vivify_1870:
    set $P3836, $P3835["name"]
    unless_null $P3836, vivify_1871
    $P3836 = root_new ['parrot';'Hash']
  vivify_1871:
    set $P3837, $P3836["identifier"]
    unless_null $P3837, vivify_1872
    new $P3837, "Undef"
  vivify_1872:
    set $N3838, $P3837
    isne $I3839, $N3838, 1.0
    unless $I3839, if_3834_end
.annotate 'line', 1218
    find_lex $P3840, "$/"
    unless_null $P3840, vivify_1873
    $P3840 = root_new ['parrot';'Hash']
  vivify_1873:
    set $P3841, $P3840["name"]
    unless_null $P3841, vivify_1874
    new $P3841, "Undef"
  vivify_1874:
    $P3842 = $P3841."CURSOR"()
    $P3842."panic"("A my scoped package cannot have a multi-part name yet")
  if_3834_end:
.annotate 'line', 1220
    find_dynamic_lex $P3843, "$*SC"
    unless_null $P3843, vivify_1875
    get_hll_global $P3843, "$SC"
    unless_null $P3843, vivify_1876
    die "Contextual $*SC not found"
  vivify_1876:
  vivify_1875:
    find_lex $P3844, "$?PACKAGE"
    get_who $P3845, $P3844
    set $P3846, $P3845["@BLOCK"]
    unless_null $P3846, vivify_1877
    $P3846 = root_new ['parrot';'ResizablePMCArray']
  vivify_1877:
    set $P3847, $P3846[0]
    unless_null $P3847, vivify_1878
    new $P3847, "Undef"
  vivify_1878:
    find_lex $P3848, "$/"
    unless_null $P3848, vivify_1879
    $P3848 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P3849, $P3848["name"]
    unless_null $P3849, vivify_1880
    $P3849 = root_new ['parrot';'Hash']
  vivify_1880:
    set $P3850, $P3849["identifier"]
    unless_null $P3850, vivify_1881
    $P3850 = root_new ['parrot';'ResizablePMCArray']
  vivify_1881:
    set $P3851, $P3850[0]
    unless_null $P3851, vivify_1882
    new $P3851, "Undef"
  vivify_1882:
    find_dynamic_lex $P3852, "$*PACKAGE"
    unless_null $P3852, vivify_1883
    get_hll_global $P3852, "$PACKAGE"
    unless_null $P3852, vivify_1884
    die "Contextual $*PACKAGE not found"
  vivify_1884:
  vivify_1883:
    $P3843."install_lexical_symbol"($P3847, $P3851, $P3852)
  if_3830_end:
.annotate 'line', 1216
    goto if_3811_end
  if_3811:
.annotate 'line', 1213
    find_lex $P3820, "$past"
    unless_null $P3820, vivify_1885
    new $P3820, "Undef"
  vivify_1885:
    find_lex $P3821, "$/"
    unless_null $P3821, vivify_1886
    $P3821 = root_new ['parrot';'Hash']
  vivify_1886:
    set $P3822, $P3821["name"]
    unless_null $P3822, vivify_1887
    $P3822 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P3823, $P3822["identifier"]
    unless_null $P3823, vivify_1888
    new $P3823, "Undef"
  vivify_1888:
    $P3820."namespace"($P3823)
.annotate 'line', 1214
    find_dynamic_lex $P3824, "$*SC"
    unless_null $P3824, vivify_1889
    get_hll_global $P3824, "$SC"
    unless_null $P3824, vivify_1890
    die "Contextual $*SC not found"
  vivify_1890:
  vivify_1889:
    find_dynamic_lex $P3825, "$*OUTERPACKAGE"
    unless_null $P3825, vivify_1891
    get_hll_global $P3825, "$OUTERPACKAGE"
    unless_null $P3825, vivify_1892
    die "Contextual $*OUTERPACKAGE not found"
  vivify_1892:
  vivify_1891:
    find_lex $P3826, "$/"
    unless_null $P3826, vivify_1893
    $P3826 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P3827, $P3826["name"]
    unless_null $P3827, vivify_1894
    $P3827 = root_new ['parrot';'Hash']
  vivify_1894:
    set $P3828, $P3827["identifier"]
    unless_null $P3828, vivify_1895
    new $P3828, "Undef"
  vivify_1895:
    find_dynamic_lex $P3829, "$*PACKAGE"
    unless_null $P3829, vivify_1896
    get_hll_global $P3829, "$PACKAGE"
    unless_null $P3829, vivify_1897
    die "Contextual $*PACKAGE not found"
  vivify_1897:
  vivify_1896:
    $P3824."install_package_symbol"($P3825, $P3828, $P3829)
  if_3811_end:
.annotate 'line', 1227
    find_dynamic_lex $P3857, "$*PACKAGE-SETUP"
    unless_null $P3857, vivify_1898
    get_hll_global $P3857, "$PACKAGE-SETUP"
    unless_null $P3857, vivify_1899
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1899:
  vivify_1898:
    get_hll_global $P3858, ["PAST"], "Stmts"
.annotate 'line', 1228
    get_hll_global $P3859, ["PAST"], "Op"
.annotate 'line', 1229
    get_hll_global $P3860, ["PAST"], "Var"
    $P3861 = $P3860."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1230
    find_dynamic_lex $P3862, "$*SC"
    unless_null $P3862, vivify_1900
    get_hll_global $P3862, "$SC"
    unless_null $P3862, vivify_1901
    die "Contextual $*SC not found"
  vivify_1901:
  vivify_1900:
    find_dynamic_lex $P3863, "$*PACKAGE"
    unless_null $P3863, vivify_1902
    get_hll_global $P3863, "$PACKAGE"
    unless_null $P3863, vivify_1903
    die "Contextual $*PACKAGE not found"
  vivify_1903:
  vivify_1902:
    $P3864 = $P3862."get_slot_past_for_object"($P3863)
    $P3865 = $P3859."new"($P3861, $P3864, "bind" :named("pasttype"))
.annotate 'line', 1228
    $P3866 = $P3858."new"($P3865)
.annotate 'line', 1227
    $P3857."unshift"($P3866)
.annotate 'line', 1239
    find_lex $P3870, "$how"
    unless_null $P3870, vivify_1904
    new $P3870, "Undef"
  vivify_1904:
    can $I3871, $P3870, "parametric"
    if $I3871, if_3869
    new $P3868, 'Integer'
    set $P3868, $I3871
    goto if_3869_end
  if_3869:
    find_lex $P3872, "$how"
    unless_null $P3872, vivify_1905
    new $P3872, "Undef"
  vivify_1905:
    find_lex $P3873, "$how"
    unless_null $P3873, vivify_1906
    new $P3873, "Undef"
  vivify_1906:
    $P3874 = $P3872."parametric"($P3873)
    set $P3868, $P3874
  if_3869_end:
    if $P3868, if_3867
.annotate 'line', 1257
    find_lex $P3898, "$past"
    unless_null $P3898, vivify_1907
    new $P3898, "Undef"
  vivify_1907:
    $P3898."blocktype"("immediate")
.annotate 'line', 1258
    find_dynamic_lex $P3899, "$*SC"
    unless_null $P3899, vivify_1908
    get_hll_global $P3899, "$SC"
    unless_null $P3899, vivify_1909
    die "Contextual $*SC not found"
  vivify_1909:
  vivify_1908:
    find_lex $P3900, "$past"
    unless_null $P3900, vivify_1910
    new $P3900, "Undef"
  vivify_1910:
    find_dynamic_lex $P3901, "$*PACKAGE"
    unless_null $P3901, vivify_1911
    get_hll_global $P3901, "$PACKAGE"
    unless_null $P3901, vivify_1912
    die "Contextual $*PACKAGE not found"
  vivify_1912:
  vivify_1911:
    $P3899."install_lexical_symbol"($P3900, "$?PACKAGE", $P3901)
.annotate 'line', 1259
    find_dynamic_lex $P3902, "$*SC"
    unless_null $P3902, vivify_1913
    get_hll_global $P3902, "$SC"
    unless_null $P3902, vivify_1914
    die "Contextual $*SC not found"
  vivify_1914:
  vivify_1913:
    find_lex $P3903, "$past"
    unless_null $P3903, vivify_1915
    new $P3903, "Undef"
  vivify_1915:
    find_dynamic_lex $P3904, "$*PACKAGE"
    unless_null $P3904, vivify_1916
    get_hll_global $P3904, "$PACKAGE"
    unless_null $P3904, vivify_1917
    die "Contextual $*PACKAGE not found"
  vivify_1917:
  vivify_1916:
    $P3902."install_lexical_symbol"($P3903, "$?CLASS", $P3904)
.annotate 'line', 1256
    goto if_3867_end
  if_3867:
.annotate 'line', 1240
    find_lex $P3875, "$past"
    unless_null $P3875, vivify_1918
    new $P3875, "Undef"
  vivify_1918:
    $P3875."blocktype"("declaration")
.annotate 'line', 1241
    find_lex $P3876, "$past"
    unless_null $P3876, vivify_1919
    new $P3876, "Undef"
  vivify_1919:
    get_hll_global $P3877, ["PAST"], "Var"
    $P3878 = $P3877."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P3876."unshift"($P3878)
.annotate 'line', 1242
    find_lex $P3879, "$past"
    unless_null $P3879, vivify_1920
    new $P3879, "Undef"
  vivify_1920:
    $P3879."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1243
    find_dynamic_lex $P3880, "$*PACKAGE-SETUP"
    unless_null $P3880, vivify_1921
    get_hll_global $P3880, "$PACKAGE-SETUP"
    unless_null $P3880, vivify_1922
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1922:
  vivify_1921:
    get_hll_global $P3881, ["PAST"], "Op"
.annotate 'line', 1245
    get_hll_global $P3882, ["PAST"], "Op"
.annotate 'line', 1248
    get_hll_global $P3883, ["PAST"], "Var"
    $P3884 = $P3883."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3885 = $P3882."new"($P3884, "get_how PP" :named("pirop"))
.annotate 'line', 1250
    get_hll_global $P3886, ["PAST"], "Var"
    $P3887 = $P3886."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1251
    get_hll_global $P3888, ["PAST"], "Val"
    find_lex $P3889, "$past"
    unless_null $P3889, vivify_1923
    new $P3889, "Undef"
  vivify_1923:
    $P3890 = $P3888."new"($P3889 :named("value"))
    $P3891 = $P3881."new"($P3885, $P3887, $P3890, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1243
    $P3880."push"($P3891)
.annotate 'line', 1253
    find_dynamic_lex $P3892, "$*SC"
    unless_null $P3892, vivify_1924
    get_hll_global $P3892, "$SC"
    unless_null $P3892, vivify_1925
    die "Contextual $*SC not found"
  vivify_1925:
  vivify_1924:
    find_lex $P3893, "$past"
    unless_null $P3893, vivify_1926
    new $P3893, "Undef"
  vivify_1926:
    find_dynamic_lex $P3894, "$*PACKAGE"
    unless_null $P3894, vivify_1927
    get_hll_global $P3894, "$PACKAGE"
    unless_null $P3894, vivify_1928
    die "Contextual $*PACKAGE not found"
  vivify_1928:
  vivify_1927:
    $P3892."install_lexical_symbol"($P3893, "$?PACKAGE", $P3894)
.annotate 'line', 1254
    find_dynamic_lex $P3895, "$*SC"
    unless_null $P3895, vivify_1929
    get_hll_global $P3895, "$SC"
    unless_null $P3895, vivify_1930
    die "Contextual $*SC not found"
  vivify_1930:
  vivify_1929:
    find_lex $P3896, "$past"
    unless_null $P3896, vivify_1931
    new $P3896, "Undef"
  vivify_1931:
    find_dynamic_lex $P3897, "$*PACKAGE"
    unless_null $P3897, vivify_1932
    get_hll_global $P3897, "$PACKAGE"
    unless_null $P3897, vivify_1933
    die "Contextual $*PACKAGE not found"
  vivify_1933:
  vivify_1932:
    $P3895."install_lexical_symbol"($P3896, "$?ROLE", $P3897)
  if_3867_end:
.annotate 'line', 1264
    find_lex $P3906, "$/"
    unless_null $P3906, vivify_1934
    $P3906 = root_new ['parrot';'Hash']
  vivify_1934:
    set $P3907, $P3906["parent"]
    unless_null $P3907, vivify_1935
    new $P3907, "Undef"
  vivify_1935:
    if $P3907, if_3905
.annotate 'line', 1278
    find_dynamic_lex $P3937, "$*PKGDECL"
    unless_null $P3937, vivify_1936
    get_hll_global $P3937, "$PKGDECL"
    unless_null $P3937, vivify_1937
    die "Contextual $*PKGDECL not found"
  vivify_1937:
  vivify_1936:
    set $S3938, $P3937
    iseq $I3939, $S3938, "grammar"
    unless $I3939, if_3936_end
.annotate 'line', 1279
    find_dynamic_lex $P3940, "$*PACKAGE-SETUP"
    unless_null $P3940, vivify_1938
    get_hll_global $P3940, "$PACKAGE-SETUP"
    unless_null $P3940, vivify_1939
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1939:
  vivify_1938:
    get_hll_global $P3941, ["PAST"], "Op"
.annotate 'line', 1281
    get_hll_global $P3942, ["PAST"], "Op"
.annotate 'line', 1284
    get_hll_global $P3943, ["PAST"], "Var"
    $P3944 = $P3943."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3945 = $P3942."new"($P3944, "get_how PP" :named("pirop"))
.annotate 'line', 1286
    get_hll_global $P3946, ["PAST"], "Var"
    $P3947 = $P3946."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1287
    get_hll_global $P3948, ["PAST"], "Var"
    $P3949 = $P3948."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P3950 = $P3941."new"($P3945, $P3947, $P3949, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1279
    $P3940."push"($P3950)
  if_3936_end:
.annotate 'line', 1278
    goto if_3905_end
  if_3905:
.annotate 'line', 1264
    .const 'Sub' $P3909 = "477_1303391609.928" 
    capture_lex $P3909
    $P3909()
  if_3905_end:
.annotate 'line', 1292
    find_lex $P3952, "$/"
    unless_null $P3952, vivify_1949
    $P3952 = root_new ['parrot';'Hash']
  vivify_1949:
    set $P3953, $P3952["role"]
    unless_null $P3953, vivify_1950
    new $P3953, "Undef"
  vivify_1950:
    unless $P3953, if_3951_end
.annotate 'line', 1293
    find_lex $P3955, "$/"
    unless_null $P3955, vivify_1951
    $P3955 = root_new ['parrot';'Hash']
  vivify_1951:
    set $P3956, $P3955["role"]
    unless_null $P3956, vivify_1952
    new $P3956, "Undef"
  vivify_1952:
    defined $I3957, $P3956
    unless $I3957, for_undef_1953
    iter $P3954, $P3956
    new $P3987, 'ExceptionHandler'
    set_label $P3987, loop3986_handler
    $P3987."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3987
  loop3986_test:
    unless $P3954, loop3986_done
    shift $P3958, $P3954
  loop3986_redo:
    .const 'Sub' $P3960 = "478_1303391609.928" 
    capture_lex $P3960
    $P3960($P3958)
  loop3986_next:
    goto loop3986_test
  loop3986_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3988, exception, 'type'
    eq $P3988, .CONTROL_LOOP_NEXT, loop3986_next
    eq $P3988, .CONTROL_LOOP_REDO, loop3986_redo
  loop3986_done:
    pop_eh 
  for_undef_1953:
  if_3951_end:
.annotate 'line', 1310
    find_dynamic_lex $P3989, "$*PACKAGE-SETUP"
    unless_null $P3989, vivify_1961
    get_hll_global $P3989, "$PACKAGE-SETUP"
    unless_null $P3989, vivify_1962
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1962:
  vivify_1961:
    get_hll_global $P3990, ["PAST"], "Op"
.annotate 'line', 1312
    get_hll_global $P3991, ["PAST"], "Op"
.annotate 'line', 1315
    get_hll_global $P3992, ["PAST"], "Var"
    $P3993 = $P3992."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3994 = $P3991."new"($P3993, "get_how PP" :named("pirop"))
.annotate 'line', 1317
    get_hll_global $P3995, ["PAST"], "Var"
    $P3996 = $P3995."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3997 = $P3990."new"($P3994, $P3996, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1310
    $P3989."push"($P3997)
.annotate 'line', 1321
    find_lex $P3998, "$past"
    unless_null $P3998, vivify_1963
    new $P3998, "Undef"
  vivify_1963:
    $P3999 = $P3998."loadinit"()
    get_hll_global $P4000, ["PAST"], "Block"
    find_dynamic_lex $P4001, "$*PACKAGE-SETUP"
    unless_null $P4001, vivify_1964
    get_hll_global $P4001, "$PACKAGE-SETUP"
    unless_null $P4001, vivify_1965
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1965:
  vivify_1964:
    $P4002 = $P4000."new"($P4001, "immediate" :named("blocktype"))
    $P3999."push"($P4002)
.annotate 'line', 1323
    find_lex $P4003, "$/"
    find_lex $P4004, "$past"
    unless_null $P4004, vivify_1966
    new $P4004, "Undef"
  vivify_1966:
    $P4005 = $P4003."!make"($P4004)
.annotate 'line', 1202
    .return ($P4005)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3908"  :anon :subid("477_1303391609.928") :outer("476_1303391609.928")
.annotate 'line', 1265
    $P3910 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3910
.annotate 'line', 1266
    new $P3911, "Undef"
    .lex "$name", $P3911
.annotate 'line', 1265
    find_lex $P3912, "$/"
    unless_null $P3912, vivify_1940
    $P3912 = root_new ['parrot';'Hash']
  vivify_1940:
    set $P3913, $P3912["parent"]
    unless_null $P3913, vivify_1941
    $P3913 = root_new ['parrot';'ResizablePMCArray']
  vivify_1941:
    set $P3914, $P3913[0]
    unless_null $P3914, vivify_1942
    $P3914 = root_new ['parrot';'Hash']
  vivify_1942:
    set $P3915, $P3914["identifier"]
    unless_null $P3915, vivify_1943
    new $P3915, "Undef"
  vivify_1943:
    clone $P3916, $P3915
    store_lex "@ns", $P3916
.annotate 'line', 1266
    find_lex $P3917, "@ns"
    unless_null $P3917, vivify_1944
    $P3917 = root_new ['parrot';'ResizablePMCArray']
  vivify_1944:
    $P3918 = $P3917."pop"()
    set $S3919, $P3918
    new $P3920, 'String'
    set $P3920, $S3919
    store_lex "$name", $P3920
.annotate 'line', 1267
    find_dynamic_lex $P3921, "$*PACKAGE-SETUP"
    unless_null $P3921, vivify_1945
    get_hll_global $P3921, "$PACKAGE-SETUP"
    unless_null $P3921, vivify_1946
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1946:
  vivify_1945:
    get_hll_global $P3922, ["PAST"], "Op"
.annotate 'line', 1269
    get_hll_global $P3923, ["PAST"], "Op"
.annotate 'line', 1272
    get_hll_global $P3924, ["PAST"], "Var"
    $P3925 = $P3924."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3926 = $P3923."new"($P3925, "get_how PP" :named("pirop"))
.annotate 'line', 1274
    get_hll_global $P3927, ["PAST"], "Var"
    $P3928 = $P3927."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1275
    get_hll_global $P3929, ["PAST"], "Var"
    find_lex $P3930, "$name"
    unless_null $P3930, vivify_1947
    new $P3930, "Undef"
  vivify_1947:
    set $S3931, $P3930
    find_lex $P3932, "@ns"
    unless_null $P3932, vivify_1948
    $P3932 = root_new ['parrot';'ResizablePMCArray']
  vivify_1948:
    $P3933 = $P3929."new"($S3931 :named("name"), $P3932 :named("namespace"), "package" :named("scope"))
    $P3934 = $P3922."new"($P3926, $P3928, $P3933, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1267
    $P3935 = $P3921."push"($P3934)
.annotate 'line', 1264
    .return ($P3935)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3959"  :anon :subid("478_1303391609.928") :outer("476_1303391609.928")
    .param pmc param_3963
.annotate 'line', 1294
    $P3961 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3961
.annotate 'line', 1295
    new $P3962, "Undef"
    .lex "$name", $P3962
    .lex "$_", param_3963
.annotate 'line', 1294
    find_lex $P3964, "$_"
    unless_null $P3964, vivify_1954
    $P3964 = root_new ['parrot';'Hash']
  vivify_1954:
    set $P3965, $P3964["identifier"]
    unless_null $P3965, vivify_1955
    new $P3965, "Undef"
  vivify_1955:
    clone $P3966, $P3965
    store_lex "@ns", $P3966
.annotate 'line', 1295
    find_lex $P3967, "@ns"
    unless_null $P3967, vivify_1956
    $P3967 = root_new ['parrot';'ResizablePMCArray']
  vivify_1956:
    $P3968 = $P3967."pop"()
    set $S3969, $P3968
    new $P3970, 'String'
    set $P3970, $S3969
    store_lex "$name", $P3970
.annotate 'line', 1296
    find_dynamic_lex $P3971, "$*PACKAGE-SETUP"
    unless_null $P3971, vivify_1957
    get_hll_global $P3971, "$PACKAGE-SETUP"
    unless_null $P3971, vivify_1958
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1958:
  vivify_1957:
    get_hll_global $P3972, ["PAST"], "Op"
.annotate 'line', 1298
    get_hll_global $P3973, ["PAST"], "Op"
.annotate 'line', 1301
    get_hll_global $P3974, ["PAST"], "Var"
    $P3975 = $P3974."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3976 = $P3973."new"($P3975, "get_how PP" :named("pirop"))
.annotate 'line', 1303
    get_hll_global $P3977, ["PAST"], "Var"
    $P3978 = $P3977."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1304
    get_hll_global $P3979, ["PAST"], "Var"
    find_lex $P3980, "$name"
    unless_null $P3980, vivify_1959
    new $P3980, "Undef"
  vivify_1959:
    set $S3981, $P3980
    find_lex $P3982, "@ns"
    unless_null $P3982, vivify_1960
    $P3982 = root_new ['parrot';'ResizablePMCArray']
  vivify_1960:
    $P3983 = $P3979."new"($S3981 :named("name"), $P3982 :named("namespace"), "package" :named("scope"))
    $P3984 = $P3972."new"($P3976, $P3978, $P3983, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1296
    $P3985 = $P3971."push"($P3984)
.annotate 'line', 1293
    .return ($P3985)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("479_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4007
    .param pmc param_4008
.annotate 'line', 1326
    .lex "self", param_4007
    .lex "$/", param_4008
    find_lex $P4009, "$/"
    find_lex $P4010, "$/"
    unless_null $P4010, vivify_1967
    $P4010 = root_new ['parrot';'Hash']
  vivify_1967:
    set $P4011, $P4010["scoped"]
    unless_null $P4011, vivify_1968
    new $P4011, "Undef"
  vivify_1968:
    $P4012 = $P4011."ast"()
    $P4013 = $P4009."!make"($P4012)
    .return ($P4013)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("480_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4015
    .param pmc param_4016
.annotate 'line', 1327
    .lex "self", param_4015
    .lex "$/", param_4016
    find_lex $P4017, "$/"
    find_lex $P4018, "$/"
    unless_null $P4018, vivify_1969
    $P4018 = root_new ['parrot';'Hash']
  vivify_1969:
    set $P4019, $P4018["scoped"]
    unless_null $P4019, vivify_1970
    new $P4019, "Undef"
  vivify_1970:
    $P4020 = $P4019."ast"()
    $P4021 = $P4017."!make"($P4020)
    .return ($P4021)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("481_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4023
    .param pmc param_4024
.annotate 'line', 1328
    .lex "self", param_4023
    .lex "$/", param_4024
    find_lex $P4025, "$/"
    find_lex $P4026, "$/"
    unless_null $P4026, vivify_1971
    $P4026 = root_new ['parrot';'Hash']
  vivify_1971:
    set $P4027, $P4026["scoped"]
    unless_null $P4027, vivify_1972
    new $P4027, "Undef"
  vivify_1972:
    $P4028 = $P4027."ast"()
    $P4029 = $P4025."!make"($P4028)
    .return ($P4029)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("482_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4031
    .param pmc param_4032
.annotate 'line', 1330
    .lex "self", param_4031
    .lex "$/", param_4032
.annotate 'line', 1331
    find_lex $P4033, "$/"
    find_lex $P4036, "$/"
    unless_null $P4036, vivify_1973
    $P4036 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P4037, $P4036["declarator"]
    unless_null $P4037, vivify_1974
    new $P4037, "Undef"
  vivify_1974:
    if $P4037, if_4035
.annotate 'line', 1332
    find_lex $P4043, "$/"
    unless_null $P4043, vivify_1975
    $P4043 = root_new ['parrot';'Hash']
  vivify_1975:
    set $P4044, $P4043["multi_declarator"]
    unless_null $P4044, vivify_1976
    new $P4044, "Undef"
  vivify_1976:
    if $P4044, if_4042
.annotate 'line', 1333
    find_lex $P4048, "$/"
    unless_null $P4048, vivify_1977
    $P4048 = root_new ['parrot';'Hash']
  vivify_1977:
    set $P4049, $P4048["package_declarator"]
    unless_null $P4049, vivify_1978
    new $P4049, "Undef"
  vivify_1978:
    $P4050 = $P4049."ast"()
    set $P4041, $P4050
.annotate 'line', 1332
    goto if_4042_end
  if_4042:
    find_lex $P4045, "$/"
    unless_null $P4045, vivify_1979
    $P4045 = root_new ['parrot';'Hash']
  vivify_1979:
    set $P4046, $P4045["multi_declarator"]
    unless_null $P4046, vivify_1980
    new $P4046, "Undef"
  vivify_1980:
    $P4047 = $P4046."ast"()
    set $P4041, $P4047
  if_4042_end:
    set $P4034, $P4041
.annotate 'line', 1331
    goto if_4035_end
  if_4035:
    find_lex $P4038, "$/"
    unless_null $P4038, vivify_1981
    $P4038 = root_new ['parrot';'Hash']
  vivify_1981:
    set $P4039, $P4038["declarator"]
    unless_null $P4039, vivify_1982
    new $P4039, "Undef"
  vivify_1982:
    $P4040 = $P4039."ast"()
    set $P4034, $P4040
  if_4035_end:
    $P4051 = $P4033."!make"($P4034)
.annotate 'line', 1330
    .return ($P4051)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("483_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4053
    .param pmc param_4054
.annotate 'line', 1336
    .lex "self", param_4053
    .lex "$/", param_4054
.annotate 'line', 1337
    find_lex $P4055, "$/"
.annotate 'line', 1338
    find_lex $P4058, "$/"
    unless_null $P4058, vivify_1983
    $P4058 = root_new ['parrot';'Hash']
  vivify_1983:
    set $P4059, $P4058["routine_declarator"]
    unless_null $P4059, vivify_1984
    new $P4059, "Undef"
  vivify_1984:
    if $P4059, if_4057
.annotate 'line', 1339
    find_lex $P4063, "$/"
    unless_null $P4063, vivify_1985
    $P4063 = root_new ['parrot';'Hash']
  vivify_1985:
    set $P4064, $P4063["variable_declarator"]
    unless_null $P4064, vivify_1986
    new $P4064, "Undef"
  vivify_1986:
    $P4065 = $P4064."ast"()
    set $P4056, $P4065
.annotate 'line', 1338
    goto if_4057_end
  if_4057:
    find_lex $P4060, "$/"
    unless_null $P4060, vivify_1987
    $P4060 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P4061, $P4060["routine_declarator"]
    unless_null $P4061, vivify_1988
    new $P4061, "Undef"
  vivify_1988:
    $P4062 = $P4061."ast"()
    set $P4056, $P4062
  if_4057_end:
    $P4066 = $P4055."!make"($P4056)
.annotate 'line', 1336
    .return ($P4066)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("484_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4068
    .param pmc param_4069
.annotate 'line', 1342
    .lex "self", param_4068
    .lex "$/", param_4069
    find_lex $P4070, "$/"
    find_lex $P4073, "$/"
    unless_null $P4073, vivify_1989
    $P4073 = root_new ['parrot';'Hash']
  vivify_1989:
    set $P4074, $P4073["declarator"]
    unless_null $P4074, vivify_1990
    new $P4074, "Undef"
  vivify_1990:
    if $P4074, if_4072
    find_lex $P4078, "$/"
    unless_null $P4078, vivify_1991
    $P4078 = root_new ['parrot';'Hash']
  vivify_1991:
    set $P4079, $P4078["routine_def"]
    unless_null $P4079, vivify_1992
    new $P4079, "Undef"
  vivify_1992:
    $P4080 = $P4079."ast"()
    set $P4071, $P4080
    goto if_4072_end
  if_4072:
    find_lex $P4075, "$/"
    unless_null $P4075, vivify_1993
    $P4075 = root_new ['parrot';'Hash']
  vivify_1993:
    set $P4076, $P4075["declarator"]
    unless_null $P4076, vivify_1994
    new $P4076, "Undef"
  vivify_1994:
    $P4077 = $P4076."ast"()
    set $P4071, $P4077
  if_4072_end:
    $P4081 = $P4070."!make"($P4071)
    .return ($P4081)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("485_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4083
    .param pmc param_4084
.annotate 'line', 1343
    .lex "self", param_4083
    .lex "$/", param_4084
    find_lex $P4085, "$/"
    find_lex $P4088, "$/"
    unless_null $P4088, vivify_1995
    $P4088 = root_new ['parrot';'Hash']
  vivify_1995:
    set $P4089, $P4088["declarator"]
    unless_null $P4089, vivify_1996
    new $P4089, "Undef"
  vivify_1996:
    if $P4089, if_4087
    find_lex $P4093, "$/"
    unless_null $P4093, vivify_1997
    $P4093 = root_new ['parrot';'Hash']
  vivify_1997:
    set $P4094, $P4093["routine_def"]
    unless_null $P4094, vivify_1998
    new $P4094, "Undef"
  vivify_1998:
    $P4095 = $P4094."ast"()
    set $P4086, $P4095
    goto if_4087_end
  if_4087:
    find_lex $P4090, "$/"
    unless_null $P4090, vivify_1999
    $P4090 = root_new ['parrot';'Hash']
  vivify_1999:
    set $P4091, $P4090["declarator"]
    unless_null $P4091, vivify_2000
    new $P4091, "Undef"
  vivify_2000:
    $P4092 = $P4091."ast"()
    set $P4086, $P4092
  if_4087_end:
    $P4096 = $P4085."!make"($P4086)
    .return ($P4096)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("486_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4098
    .param pmc param_4099
.annotate 'line', 1344
    .lex "self", param_4098
    .lex "$/", param_4099
    find_lex $P4100, "$/"
    find_lex $P4101, "$/"
    unless_null $P4101, vivify_2001
    $P4101 = root_new ['parrot';'Hash']
  vivify_2001:
    set $P4102, $P4101["declarator"]
    unless_null $P4102, vivify_2002
    new $P4102, "Undef"
  vivify_2002:
    $P4103 = $P4102."ast"()
    $P4104 = $P4100."!make"($P4103)
    .return ($P4104)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("487_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4106
    .param pmc param_4107
.annotate 'line', 1347
    .const 'Sub' $P4139 = "488_1303391609.928" 
    capture_lex $P4139
    .lex "self", param_4106
    .lex "$/", param_4107
.annotate 'line', 1348
    new $P4108, "Undef"
    .lex "$past", $P4108
.annotate 'line', 1349
    new $P4109, "Undef"
    .lex "$sigil", $P4109
.annotate 'line', 1350
    new $P4110, "Undef"
    .lex "$name", $P4110
.annotate 'line', 1351
    new $P4111, "Undef"
    .lex "$BLOCK", $P4111
.annotate 'line', 1348
    find_lex $P4112, "$/"
    unless_null $P4112, vivify_2003
    $P4112 = root_new ['parrot';'Hash']
  vivify_2003:
    set $P4113, $P4112["variable"]
    unless_null $P4113, vivify_2004
    new $P4113, "Undef"
  vivify_2004:
    $P4114 = $P4113."ast"()
    store_lex "$past", $P4114
.annotate 'line', 1349
    find_lex $P4115, "$/"
    unless_null $P4115, vivify_2005
    $P4115 = root_new ['parrot';'Hash']
  vivify_2005:
    set $P4116, $P4115["variable"]
    unless_null $P4116, vivify_2006
    $P4116 = root_new ['parrot';'Hash']
  vivify_2006:
    set $P4117, $P4116["sigil"]
    unless_null $P4117, vivify_2007
    new $P4117, "Undef"
  vivify_2007:
    store_lex "$sigil", $P4117
.annotate 'line', 1350
    find_lex $P4118, "$past"
    unless_null $P4118, vivify_2008
    new $P4118, "Undef"
  vivify_2008:
    $P4119 = $P4118."name"()
    store_lex "$name", $P4119
.annotate 'line', 1351
    find_lex $P4120, "$?PACKAGE"
    get_who $P4121, $P4120
    set $P4122, $P4121["@BLOCK"]
    unless_null $P4122, vivify_2009
    $P4122 = root_new ['parrot';'ResizablePMCArray']
  vivify_2009:
    set $P4123, $P4122[0]
    unless_null $P4123, vivify_2010
    new $P4123, "Undef"
  vivify_2010:
    store_lex "$BLOCK", $P4123
.annotate 'line', 1352
    find_lex $P4127, "$name"
    unless_null $P4127, vivify_2011
    new $P4127, "Undef"
  vivify_2011:
    if $P4127, if_4126
    set $P4125, $P4127
    goto if_4126_end
  if_4126:
    find_lex $P4128, "$BLOCK"
    unless_null $P4128, vivify_2012
    new $P4128, "Undef"
  vivify_2012:
    find_lex $P4129, "$name"
    unless_null $P4129, vivify_2013
    new $P4129, "Undef"
  vivify_2013:
    $P4130 = $P4128."symbol"($P4129)
    set $P4125, $P4130
  if_4126_end:
    unless $P4125, if_4124_end
.annotate 'line', 1353
    find_lex $P4131, "$/"
    unless_null $P4131, vivify_2014
    new $P4131, "Undef"
  vivify_2014:
    $P4132 = $P4131."CURSOR"()
    find_lex $P4133, "$name"
    unless_null $P4133, vivify_2015
    new $P4133, "Undef"
  vivify_2015:
    $P4132."panic"("Redeclaration of symbol ", $P4133)
  if_4124_end:
.annotate 'line', 1355
    find_dynamic_lex $P4135, "$*SCOPE"
    unless_null $P4135, vivify_2016
    get_hll_global $P4135, "$SCOPE"
    unless_null $P4135, vivify_2017
    die "Contextual $*SCOPE not found"
  vivify_2017:
  vivify_2016:
    set $S4136, $P4135
    iseq $I4137, $S4136, "has"
    if $I4137, if_4134
.annotate 'line', 1380
    find_dynamic_lex $P4184, "$*SCOPE"
    unless_null $P4184, vivify_2018
    get_hll_global $P4184, "$SCOPE"
    unless_null $P4184, vivify_2019
    die "Contextual $*SCOPE not found"
  vivify_2019:
  vivify_2018:
    set $S4185, $P4184
    iseq $I4186, $S4185, "our"
    if $I4186, if_4183
.annotate 'line', 1390
    find_lex $P4200, "$BLOCK"
    unless_null $P4200, vivify_2020
    $P4200 = root_new ['parrot';'ResizablePMCArray']
  vivify_2020:
    set $P4201, $P4200[0]
    unless_null $P4201, vivify_2021
    new $P4201, "Undef"
  vivify_2021:
    get_hll_global $P4202, ["PAST"], "Var"
    find_lex $P4203, "$name"
    unless_null $P4203, vivify_2022
    new $P4203, "Undef"
  vivify_2022:
.annotate 'line', 1392
    find_lex $P4204, "$sigil"
    unless_null $P4204, vivify_2023
    new $P4204, "Undef"
  vivify_2023:
    $P4205 = "vivitype"($P4204)
    find_lex $P4206, "$/"
    unless_null $P4206, vivify_2024
    new $P4206, "Undef"
  vivify_2024:
    $P4207 = $P4202."new"($P4203 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P4205 :named("viviself"), $P4206 :named("node"))
.annotate 'line', 1390
    $P4201."push"($P4207)
.annotate 'line', 1395
    find_lex $P4208, "$BLOCK"
    unless_null $P4208, vivify_2025
    new $P4208, "Undef"
  vivify_2025:
    find_lex $P4209, "$name"
    unless_null $P4209, vivify_2026
    new $P4209, "Undef"
  vivify_2026:
    $P4208."symbol"($P4209, "lexical" :named("scope"))
.annotate 'line', 1389
    goto if_4183_end
  if_4183:
.annotate 'line', 1384
    find_lex $P4187, "$/"
    unless_null $P4187, vivify_2027
    $P4187 = root_new ['parrot';'Hash']
  vivify_2027:
    set $P4188, $P4187["variable"]
    unless_null $P4188, vivify_2028
    new $P4188, "Undef"
  vivify_2028:
    set $S4189, $P4188
    new $P4190, 'String'
    set $P4190, $S4189
    store_lex "$name", $P4190
.annotate 'line', 1385
    find_lex $P4191, "$name"
    unless_null $P4191, vivify_2029
    new $P4191, "Undef"
  vivify_2029:
    new $P4192, "ResizablePMCArray"
    push $P4192, $P4191
    find_lex $P4193, "$/"
    unless_null $P4193, vivify_2030
    new $P4193, "Undef"
  vivify_2030:
    $P4194 = "lexical_package_lookup"($P4192, $P4193)
    store_lex "$past", $P4194
.annotate 'line', 1386
    find_lex $P4195, "$past"
    unless_null $P4195, vivify_2031
    new $P4195, "Undef"
  vivify_2031:
    find_lex $P4196, "$sigil"
    unless_null $P4196, vivify_2032
    new $P4196, "Undef"
  vivify_2032:
    $P4197 = "vivitype"($P4196)
    $P4195."viviself"($P4197)
.annotate 'line', 1387
    find_lex $P4198, "$BLOCK"
    unless_null $P4198, vivify_2033
    new $P4198, "Undef"
  vivify_2033:
    find_lex $P4199, "$name"
    unless_null $P4199, vivify_2034
    new $P4199, "Undef"
  vivify_2034:
    $P4198."symbol"($P4199, "package" :named("scope"))
  if_4183_end:
.annotate 'line', 1380
    goto if_4134_end
  if_4134:
.annotate 'line', 1355
    .const 'Sub' $P4139 = "488_1303391609.928" 
    capture_lex $P4139
    $P4139()
  if_4134_end:
.annotate 'line', 1397
    find_lex $P4210, "$/"
    find_lex $P4211, "$past"
    unless_null $P4211, vivify_2056
    new $P4211, "Undef"
  vivify_2056:
    $P4212 = $P4210."!make"($P4211)
.annotate 'line', 1347
    .return ($P4212)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4138"  :anon :subid("488_1303391609.928") :outer("487_1303391609.928")
.annotate 'line', 1355
    .const 'Sub' $P4169 = "489_1303391609.928" 
    capture_lex $P4169
.annotate 'line', 1357
    new $P4140, "Undef"
    .lex "$meta-attr-type", $P4140
.annotate 'line', 1365
    new $P4141, "Undef"
    .lex "$meta_args", $P4141
.annotate 'line', 1357
    find_dynamic_lex $P4144, "$*PKGDECL"
    unless_null $P4144, vivify_2035
    get_hll_global $P4144, "$PKGDECL"
    unless_null $P4144, vivify_2036
    die "Contextual $*PKGDECL not found"
  vivify_2036:
  vivify_2035:
    find_dynamic_lex $P4145, "%*HOW-METAATTR"
    unless_null $P4145, vivify_2037
    get_hll_global $P4145, "%HOW-METAATTR"
    unless_null $P4145, vivify_2038
    die "Contextual %*HOW-METAATTR not found"
  vivify_2038:
  vivify_2037:
    set $P4146, $P4145[$P4144]
    unless_null $P4146, vivify_2039
    new $P4146, "Undef"
  vivify_2039:
    unless $P4146, unless_4143
    set $P4142, $P4146
    goto unless_4143_end
  unless_4143:
    find_dynamic_lex $P4147, "$*DEFAULT-METAATTR"
    unless_null $P4147, vivify_2040
    get_hll_global $P4147, "$DEFAULT-METAATTR"
    unless_null $P4147, vivify_2041
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_2041:
  vivify_2040:
    set $P4142, $P4147
  unless_4143_end:
    store_lex "$meta-attr-type", $P4142
.annotate 'line', 1358
    find_dynamic_lex $P4148, "$*PACKAGE-SETUP"
    unless_null $P4148, vivify_2042
    get_hll_global $P4148, "$PACKAGE-SETUP"
    unless_null $P4148, vivify_2043
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2043:
  vivify_2042:
    get_hll_global $P4149, ["PAST"], "Op"
.annotate 'line', 1360
    get_hll_global $P4150, ["PAST"], "Op"
.annotate 'line', 1362
    get_hll_global $P4151, ["PAST"], "Var"
    $P4152 = $P4151."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4153 = $P4150."new"($P4152, "get_how PP" :named("pirop"))
.annotate 'line', 1364
    get_hll_global $P4154, ["PAST"], "Var"
    $P4155 = $P4154."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1365
    get_hll_global $P4156, ["PAST"], "Op"
.annotate 'line', 1367
    get_hll_global $P4157, ["PAST"], "Var"
    find_lex $P4158, "$meta-attr-type"
    unless_null $P4158, vivify_2044
    new $P4158, "Undef"
  vivify_2044:
    $P4159 = $P4157."new"($P4158 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1368
    get_hll_global $P4160, ["PAST"], "Val"
    find_lex $P4161, "$name"
    unless_null $P4161, vivify_2045
    new $P4161, "Undef"
  vivify_2045:
    $P4162 = $P4160."new"($P4161 :named("value"), "name" :named("named"))
    $P4163 = $P4156."new"($P4159, $P4162, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1365
    store_lex "$meta_args", $P4163
    $P4164 = $P4149."new"($P4153, $P4155, $P4163, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1358
    $P4148."push"($P4164)
.annotate 'line', 1371
    find_lex $P4166, "$/"
    unless_null $P4166, vivify_2046
    $P4166 = root_new ['parrot';'Hash']
  vivify_2046:
    set $P4167, $P4166["typename"]
    unless_null $P4167, vivify_2047
    new $P4167, "Undef"
  vivify_2047:
    unless $P4167, if_4165_end
    .const 'Sub' $P4169 = "489_1303391609.928" 
    capture_lex $P4169
    $P4169()
  if_4165_end:
.annotate 'line', 1377
    find_lex $P4179, "$BLOCK"
    unless_null $P4179, vivify_2054
    new $P4179, "Undef"
  vivify_2054:
    find_lex $P4180, "$name"
    unless_null $P4180, vivify_2055
    new $P4180, "Undef"
  vivify_2055:
    $P4179."symbol"($P4180, "attribute" :named("scope"))
.annotate 'line', 1378
    get_hll_global $P4181, ["PAST"], "Stmts"
    $P4182 = $P4181."new"()
    store_lex "$past", $P4182
.annotate 'line', 1355
    .return ($P4182)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4168"  :anon :subid("489_1303391609.928") :outer("488_1303391609.928")
.annotate 'line', 1372
    new $P4170, "Undef"
    .lex "$type", $P4170
    find_lex $P4171, "$/"
    unless_null $P4171, vivify_2048
    $P4171 = root_new ['parrot';'Hash']
  vivify_2048:
    set $P4172, $P4171["typename"]
    unless_null $P4172, vivify_2049
    $P4172 = root_new ['parrot';'ResizablePMCArray']
  vivify_2049:
    set $P4173, $P4172[0]
    unless_null $P4173, vivify_2050
    new $P4173, "Undef"
  vivify_2050:
    $P4174 = $P4173."ast"()
    store_lex "$type", $P4174
.annotate 'line', 1373
    find_lex $P4175, "$type"
    unless_null $P4175, vivify_2051
    new $P4175, "Undef"
  vivify_2051:
    $P4175."named"("type")
.annotate 'line', 1374
    find_lex $P4176, "$meta_args"
    unless_null $P4176, vivify_2052
    new $P4176, "Undef"
  vivify_2052:
    find_lex $P4177, "$type"
    unless_null $P4177, vivify_2053
    new $P4177, "Undef"
  vivify_2053:
    $P4178 = $P4176."push"($P4177)
.annotate 'line', 1371
    .return ($P4178)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("490_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4214
    .param pmc param_4215
.annotate 'line', 1400
    .lex "self", param_4214
    .lex "$/", param_4215
    find_lex $P4216, "$/"
    find_lex $P4217, "$/"
    unless_null $P4217, vivify_2057
    $P4217 = root_new ['parrot';'Hash']
  vivify_2057:
    set $P4218, $P4217["routine_def"]
    unless_null $P4218, vivify_2058
    new $P4218, "Undef"
  vivify_2058:
    $P4219 = $P4218."ast"()
    $P4220 = $P4216."!make"($P4219)
    .return ($P4220)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("491_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4222
    .param pmc param_4223
.annotate 'line', 1401
    .lex "self", param_4222
    .lex "$/", param_4223
    find_lex $P4224, "$/"
    find_lex $P4225, "$/"
    unless_null $P4225, vivify_2059
    $P4225 = root_new ['parrot';'Hash']
  vivify_2059:
    set $P4226, $P4225["method_def"]
    unless_null $P4226, vivify_2060
    new $P4226, "Undef"
  vivify_2060:
    $P4227 = $P4226."ast"()
    $P4228 = $P4224."!make"($P4227)
    .return ($P4228)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("492_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4230
    .param pmc param_4231
.annotate 'line', 1403
    .const 'Sub' $P4490 = "498_1303391609.928" 
    capture_lex $P4490
    .const 'Sub' $P4251 = "493_1303391609.928" 
    capture_lex $P4251
    .lex "self", param_4230
    .lex "$/", param_4231
.annotate 'line', 1406
    new $P4232, "Undef"
    .lex "$past", $P4232
.annotate 'line', 1417
    new $P4233, "Undef"
    .lex "$block", $P4233
.annotate 'line', 1403
    find_lex $P4234, "$past"
    unless_null $P4234, vivify_2061
    new $P4234, "Undef"
  vivify_2061:
.annotate 'line', 1407
    find_lex $P4236, "$/"
    unless_null $P4236, vivify_2062
    $P4236 = root_new ['parrot';'Hash']
  vivify_2062:
    set $P4237, $P4236["onlystar"]
    unless_null $P4237, vivify_2063
    new $P4237, "Undef"
  vivify_2063:
    if $P4237, if_4235
.annotate 'line', 1411
    find_lex $P4239, "$/"
    unless_null $P4239, vivify_2064
    $P4239 = root_new ['parrot';'Hash']
  vivify_2064:
    set $P4240, $P4239["blockoid"]
    unless_null $P4240, vivify_2065
    new $P4240, "Undef"
  vivify_2065:
    $P4241 = $P4240."ast"()
    store_lex "$past", $P4241
.annotate 'line', 1412
    find_lex $P4242, "$past"
    unless_null $P4242, vivify_2066
    new $P4242, "Undef"
  vivify_2066:
    $P4242."blocktype"("declaration")
.annotate 'line', 1413
    find_dynamic_lex $P4244, "$*RETURN_USED"
    unless_null $P4244, vivify_2067
    get_hll_global $P4244, "$RETURN_USED"
    unless_null $P4244, vivify_2068
    die "Contextual $*RETURN_USED not found"
  vivify_2068:
  vivify_2067:
    unless $P4244, if_4243_end
.annotate 'line', 1414
    find_lex $P4245, "$past"
    unless_null $P4245, vivify_2069
    new $P4245, "Undef"
  vivify_2069:
    $P4245."control"("return_pir")
  if_4243_end:
.annotate 'line', 1410
    goto if_4235_end
  if_4235:
.annotate 'line', 1408
    $P4238 = "only_star_block"()
    store_lex "$past", $P4238
  if_4235_end:
.annotate 'line', 1417
    find_lex $P4246, "$past"
    unless_null $P4246, vivify_2070
    new $P4246, "Undef"
  vivify_2070:
    store_lex "$block", $P4246
.annotate 'line', 1419
    find_lex $P4248, "$/"
    unless_null $P4248, vivify_2071
    $P4248 = root_new ['parrot';'Hash']
  vivify_2071:
    set $P4249, $P4248["deflongname"]
    unless_null $P4249, vivify_2072
    new $P4249, "Undef"
  vivify_2072:
    unless $P4249, if_4247_end
    .const 'Sub' $P4251 = "493_1303391609.928" 
    capture_lex $P4251
    $P4251()
  if_4247_end:
.annotate 'line', 1524
    find_lex $P4479, "$block"
    unless_null $P4479, vivify_2175
    new $P4479, "Undef"
  vivify_2175:
    find_lex $P4480, "$past"
    unless_null $P4480, vivify_2176
    $P4480 = root_new ['parrot';'Hash']
    store_lex "$past", $P4480
  vivify_2176:
    set $P4480["block_past"], $P4479
.annotate 'line', 1525
    find_lex $P4482, "$/"
    unless_null $P4482, vivify_2177
    $P4482 = root_new ['parrot';'Hash']
  vivify_2177:
    set $P4483, $P4482["trait"]
    unless_null $P4483, vivify_2178
    new $P4483, "Undef"
  vivify_2178:
    unless $P4483, if_4481_end
.annotate 'line', 1526
    find_lex $P4485, "$/"
    unless_null $P4485, vivify_2179
    $P4485 = root_new ['parrot';'Hash']
  vivify_2179:
    set $P4486, $P4485["trait"]
    unless_null $P4486, vivify_2180
    new $P4486, "Undef"
  vivify_2180:
    defined $I4487, $P4486
    unless $I4487, for_undef_2181
    iter $P4484, $P4486
    new $P4497, 'ExceptionHandler'
    set_label $P4497, loop4496_handler
    $P4497."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4497
  loop4496_test:
    unless $P4484, loop4496_done
    shift $P4488, $P4484
  loop4496_redo:
    .const 'Sub' $P4490 = "498_1303391609.928" 
    capture_lex $P4490
    $P4490($P4488)
  loop4496_next:
    goto loop4496_test
  loop4496_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4498, exception, 'type'
    eq $P4498, .CONTROL_LOOP_NEXT, loop4496_next
    eq $P4498, .CONTROL_LOOP_REDO, loop4496_redo
  loop4496_done:
    pop_eh 
  for_undef_2181:
  if_4481_end:
.annotate 'line', 1529
    find_lex $P4499, "$/"
    find_lex $P4500, "$past"
    unless_null $P4500, vivify_2184
    new $P4500, "Undef"
  vivify_2184:
    $P4501 = $P4499."!make"($P4500)
.annotate 'line', 1403
    .return ($P4501)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4250"  :anon :subid("493_1303391609.928") :outer("492_1303391609.928")
.annotate 'line', 1419
    .const 'Sub' $P4381 = "497_1303391609.928" 
    capture_lex $P4381
    .const 'Sub' $P4284 = "494_1303391609.928" 
    capture_lex $P4284
.annotate 'line', 1420
    new $P4252, "Undef"
    .lex "$name", $P4252
    find_lex $P4253, "$/"
    unless_null $P4253, vivify_2073
    $P4253 = root_new ['parrot';'Hash']
  vivify_2073:
    set $P4254, $P4253["sigil"]
    unless_null $P4254, vivify_2074
    $P4254 = root_new ['parrot';'ResizablePMCArray']
  vivify_2074:
    set $P4255, $P4254[0]
    unless_null $P4255, vivify_2075
    new $P4255, "Undef"
  vivify_2075:
    set $S4256, $P4255
    new $P4257, 'String'
    set $P4257, $S4256
    find_lex $P4258, "$/"
    unless_null $P4258, vivify_2076
    $P4258 = root_new ['parrot';'Hash']
  vivify_2076:
    set $P4259, $P4258["deflongname"]
    unless_null $P4259, vivify_2077
    $P4259 = root_new ['parrot';'ResizablePMCArray']
  vivify_2077:
    set $P4260, $P4259[0]
    unless_null $P4260, vivify_2078
    new $P4260, "Undef"
  vivify_2078:
    $S4261 = $P4260."ast"()
    concat $P4262, $P4257, $S4261
    store_lex "$name", $P4262
.annotate 'line', 1421
    find_lex $P4263, "$past"
    unless_null $P4263, vivify_2079
    new $P4263, "Undef"
  vivify_2079:
    find_lex $P4264, "$name"
    unless_null $P4264, vivify_2080
    new $P4264, "Undef"
  vivify_2080:
    $P4263."name"($P4264)
.annotate 'line', 1422
    find_dynamic_lex $P4270, "$*SCOPE"
    unless_null $P4270, vivify_2081
    get_hll_global $P4270, "$SCOPE"
    unless_null $P4270, vivify_2082
    die "Contextual $*SCOPE not found"
  vivify_2082:
  vivify_2081:
    set $S4271, $P4270
    iseq $I4272, $S4271, ""
    unless $I4272, unless_4269
    new $P4268, 'Integer'
    set $P4268, $I4272
    goto unless_4269_end
  unless_4269:
    find_dynamic_lex $P4273, "$*SCOPE"
    unless_null $P4273, vivify_2083
    get_hll_global $P4273, "$SCOPE"
    unless_null $P4273, vivify_2084
    die "Contextual $*SCOPE not found"
  vivify_2084:
  vivify_2083:
    set $S4274, $P4273
    iseq $I4275, $S4274, "my"
    new $P4268, 'Integer'
    set $P4268, $I4275
  unless_4269_end:
    unless $P4268, unless_4267
    set $P4266, $P4268
    goto unless_4267_end
  unless_4267:
    find_dynamic_lex $P4276, "$*SCOPE"
    unless_null $P4276, vivify_2085
    get_hll_global $P4276, "$SCOPE"
    unless_null $P4276, vivify_2086
    die "Contextual $*SCOPE not found"
  vivify_2086:
  vivify_2085:
    set $S4277, $P4276
    iseq $I4278, $S4277, "our"
    new $P4266, 'Integer'
    set $P4266, $I4278
  unless_4267_end:
    if $P4266, if_4265
.annotate 'line', 1514
    find_lex $P4464, "$/"
    unless_null $P4464, vivify_2087
    new $P4464, "Undef"
  vivify_2087:
    $P4465 = $P4464."CURSOR"()
    find_dynamic_lex $P4466, "$*SCOPE"
    unless_null $P4466, vivify_2088
    get_hll_global $P4466, "$SCOPE"
    unless_null $P4466, vivify_2089
    die "Contextual $*SCOPE not found"
  vivify_2089:
  vivify_2088:
    concat $P4467, $P4466, " scoped routines are not supported yet"
    $P4465."panic"($P4467)
.annotate 'line', 1513
    goto if_4265_end
  if_4265:
.annotate 'line', 1423
    find_dynamic_lex $P4280, "$*MULTINESS"
    unless_null $P4280, vivify_2090
    get_hll_global $P4280, "$MULTINESS"
    unless_null $P4280, vivify_2091
    die "Contextual $*MULTINESS not found"
  vivify_2091:
  vivify_2090:
    set $S4281, $P4280
    iseq $I4282, $S4281, "multi"
    if $I4282, if_4279
.annotate 'line', 1474
    find_dynamic_lex $P4377, "$*MULTINESS"
    unless_null $P4377, vivify_2092
    get_hll_global $P4377, "$MULTINESS"
    unless_null $P4377, vivify_2093
    die "Contextual $*MULTINESS not found"
  vivify_2093:
  vivify_2092:
    set $S4378, $P4377
    iseq $I4379, $S4378, "proto"
    if $I4379, if_4376
.annotate 'line', 1493
    find_lex $P4417, "$?PACKAGE"
    get_who $P4418, $P4417
    set $P4419, $P4418["@BLOCK"]
    unless_null $P4419, vivify_2094
    $P4419 = root_new ['parrot';'ResizablePMCArray']
  vivify_2094:
    set $P4420, $P4419[0]
    unless_null $P4420, vivify_2095
    $P4420 = root_new ['parrot';'ResizablePMCArray']
  vivify_2095:
    set $P4421, $P4420[0]
    unless_null $P4421, vivify_2096
    new $P4421, "Undef"
  vivify_2096:
    get_hll_global $P4422, ["PAST"], "Var"
    find_lex $P4423, "$name"
    unless_null $P4423, vivify_2097
    new $P4423, "Undef"
  vivify_2097:
    find_lex $P4424, "$past"
    unless_null $P4424, vivify_2098
    new $P4424, "Undef"
  vivify_2098:
    $P4425 = $P4422."new"($P4423 :named("name"), 1 :named("isdecl"), $P4424 :named("viviself"), "lexical" :named("scope"))
    $P4421."push"($P4425)
.annotate 'line', 1495
    find_lex $P4426, "$?PACKAGE"
    get_who $P4427, $P4426
    set $P4428, $P4427["@BLOCK"]
    unless_null $P4428, vivify_2099
    $P4428 = root_new ['parrot';'ResizablePMCArray']
  vivify_2099:
    set $P4429, $P4428[0]
    unless_null $P4429, vivify_2100
    new $P4429, "Undef"
  vivify_2100:
    find_lex $P4430, "$name"
    unless_null $P4430, vivify_2101
    new $P4430, "Undef"
  vivify_2101:
    $P4429."symbol"($P4430, "lexical" :named("scope"))
.annotate 'line', 1496
    find_dynamic_lex $P4432, "$*SCOPE"
    unless_null $P4432, vivify_2102
    get_hll_global $P4432, "$SCOPE"
    unless_null $P4432, vivify_2103
    die "Contextual $*SCOPE not found"
  vivify_2103:
  vivify_2102:
    set $S4433, $P4432
    iseq $I4434, $S4433, "our"
    unless $I4434, if_4431_end
.annotate 'line', 1499
    find_lex $P4435, "$?PACKAGE"
    get_who $P4436, $P4435
    set $P4437, $P4436["@BLOCK"]
    unless_null $P4437, vivify_2104
    $P4437 = root_new ['parrot';'ResizablePMCArray']
  vivify_2104:
    set $P4438, $P4437[0]
    unless_null $P4438, vivify_2105
    $P4438 = root_new ['parrot';'ResizablePMCArray']
  vivify_2105:
    set $P4439, $P4438[0]
    unless_null $P4439, vivify_2106
    new $P4439, "Undef"
  vivify_2106:
    get_hll_global $P4440, ["PAST"], "Op"
.annotate 'line', 1501
    get_hll_global $P4441, ["PAST"], "Var"
    find_lex $P4442, "$name"
    unless_null $P4442, vivify_2107
    new $P4442, "Undef"
  vivify_2107:
    $P4443 = $P4441."new"($P4442 :named("name"), "package" :named("scope"))
.annotate 'line', 1502
    get_hll_global $P4444, ["PAST"], "Var"
    find_lex $P4445, "$name"
    unless_null $P4445, vivify_2108
    new $P4445, "Undef"
  vivify_2108:
    $P4446 = $P4444."new"($P4445 :named("name"), "lexical" :named("scope"))
    $P4447 = $P4440."new"($P4443, $P4446, "bind" :named("pasttype"))
.annotate 'line', 1499
    $P4439."push"($P4447)
.annotate 'line', 1504
    find_lex $P4448, "$?PACKAGE"
    get_who $P4449, $P4448
    set $P4450, $P4449["@BLOCK"]
    unless_null $P4450, vivify_2109
    $P4450 = root_new ['parrot';'ResizablePMCArray']
  vivify_2109:
    set $P4451, $P4450[0]
    unless_null $P4451, vivify_2110
    new $P4451, "Undef"
  vivify_2110:
    $P4452 = $P4451."loadinit"()
    get_hll_global $P4453, ["PAST"], "Op"
.annotate 'line', 1506
    get_hll_global $P4454, ["PAST"], "Var"
    find_lex $P4455, "$name"
    unless_null $P4455, vivify_2111
    new $P4455, "Undef"
  vivify_2111:
    $P4456 = $P4454."new"($P4455 :named("name"), "package" :named("scope"))
.annotate 'line', 1507
    get_hll_global $P4457, ["PAST"], "Val"
    find_lex $P4458, "$past"
    unless_null $P4458, vivify_2112
    new $P4458, "Undef"
  vivify_2112:
    $P4459 = $P4457."new"($P4458 :named("value"))
    $P4460 = $P4453."new"($P4456, $P4459, "bind" :named("pasttype"))
.annotate 'line', 1504
    $P4452."push"($P4460)
  if_4431_end:
.annotate 'line', 1492
    goto if_4376_end
  if_4376:
.annotate 'line', 1474
    .const 'Sub' $P4381 = "497_1303391609.928" 
    capture_lex $P4381
    $P4381()
  if_4376_end:
    goto if_4279_end
  if_4279:
.annotate 'line', 1423
    .const 'Sub' $P4284 = "494_1303391609.928" 
    capture_lex $P4284
    $P4284()
  if_4279_end:
.annotate 'line', 1511
    get_hll_global $P4461, ["PAST"], "Var"
    find_lex $P4462, "$name"
    unless_null $P4462, vivify_2170
    new $P4462, "Undef"
  vivify_2170:
    $P4463 = $P4461."new"($P4462 :named("name"))
    store_lex "$past", $P4463
  if_4265_end:
.annotate 'line', 1518
    find_lex $P4472, "$name"
    unless_null $P4472, vivify_2171
    new $P4472, "Undef"
  vivify_2171:
    set $S4473, $P4472
    iseq $I4474, $S4473, "MAIN"
    if $I4474, if_4471
    new $P4470, 'Integer'
    set $P4470, $I4474
    goto if_4471_end
  if_4471:
    find_dynamic_lex $P4475, "$*MULTINESS"
    unless_null $P4475, vivify_2172
    get_hll_global $P4475, "$MULTINESS"
    unless_null $P4475, vivify_2173
    die "Contextual $*MULTINESS not found"
  vivify_2173:
  vivify_2172:
    set $S4476, $P4475
    isne $I4477, $S4476, "multi"
    new $P4470, 'Integer'
    set $P4470, $I4477
  if_4471_end:
    if $P4470, if_4469
    set $P4468, $P4470
    goto if_4469_end
  if_4469:
.annotate 'line', 1519
    find_lex $P4478, "$block"
    unless_null $P4478, vivify_2174
    new $P4478, "Undef"
  vivify_2174:
    store_dynamic_lex "$*MAIN_SUB", $P4478
.annotate 'line', 1518
    set $P4468, $P4478
  if_4469_end:
.annotate 'line', 1419
    .return ($P4468)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4380"  :anon :subid("497_1303391609.928") :outer("493_1303391609.928")
.annotate 'line', 1479
    new $P4382, "Undef"
    .lex "$cholder", $P4382
.annotate 'line', 1478
    find_dynamic_lex $P4384, "$*SCOPE"
    unless_null $P4384, vivify_2113
    get_hll_global $P4384, "$SCOPE"
    unless_null $P4384, vivify_2114
    die "Contextual $*SCOPE not found"
  vivify_2114:
  vivify_2113:
    set $S4385, $P4384
    iseq $I4386, $S4385, "our"
    unless $I4386, if_4383_end
    die "our-scoped protos not yet implemented"
  if_4383_end:
.annotate 'line', 1479
    get_hll_global $P4387, ["PAST"], "Op"
    $P4388 = $P4387."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4388
.annotate 'line', 1480
    find_lex $P4389, "$?PACKAGE"
    get_who $P4390, $P4389
    set $P4391, $P4390["@BLOCK"]
    unless_null $P4391, vivify_2115
    $P4391 = root_new ['parrot';'ResizablePMCArray']
  vivify_2115:
    set $P4392, $P4391[0]
    unless_null $P4392, vivify_2116
    $P4392 = root_new ['parrot';'ResizablePMCArray']
  vivify_2116:
    set $P4393, $P4392[0]
    unless_null $P4393, vivify_2117
    new $P4393, "Undef"
  vivify_2117:
    get_hll_global $P4394, ["PAST"], "Var"
    find_lex $P4395, "$name"
    unless_null $P4395, vivify_2118
    new $P4395, "Undef"
  vivify_2118:
    find_lex $P4396, "$past"
    unless_null $P4396, vivify_2119
    new $P4396, "Undef"
  vivify_2119:
    $P4397 = $P4394."new"($P4395 :named("name"), 1 :named("isdecl"), $P4396 :named("viviself"), "lexical" :named("scope"))
    $P4393."push"($P4397)
.annotate 'line', 1482
    find_lex $P4398, "$?PACKAGE"
    get_who $P4399, $P4398
    set $P4400, $P4399["@BLOCK"]
    unless_null $P4400, vivify_2120
    $P4400 = root_new ['parrot';'ResizablePMCArray']
  vivify_2120:
    set $P4401, $P4400[0]
    unless_null $P4401, vivify_2121
    $P4401 = root_new ['parrot';'ResizablePMCArray']
  vivify_2121:
    set $P4402, $P4401[0]
    unless_null $P4402, vivify_2122
    new $P4402, "Undef"
  vivify_2122:
    get_hll_global $P4403, ["PAST"], "Op"
.annotate 'line', 1484
    get_hll_global $P4404, ["PAST"], "Var"
    find_lex $P4405, "$name"
    unless_null $P4405, vivify_2123
    new $P4405, "Undef"
  vivify_2123:
    $P4406 = $P4404."new"($P4405 :named("name"))
    find_lex $P4407, "$cholder"
    unless_null $P4407, vivify_2124
    new $P4407, "Undef"
  vivify_2124:
    $P4408 = $P4403."new"($P4406, $P4407, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1482
    $P4402."push"($P4408)
.annotate 'line', 1487
    find_lex $P4409, "$?PACKAGE"
    get_who $P4410, $P4409
    set $P4411, $P4410["@BLOCK"]
    unless_null $P4411, vivify_2125
    $P4411 = root_new ['parrot';'ResizablePMCArray']
  vivify_2125:
    set $P4412, $P4411[0]
    unless_null $P4412, vivify_2126
    new $P4412, "Undef"
  vivify_2126:
    find_lex $P4413, "$name"
    unless_null $P4413, vivify_2127
    new $P4413, "Undef"
  vivify_2127:
    find_lex $P4414, "$cholder"
    unless_null $P4414, vivify_2128
    new $P4414, "Undef"
  vivify_2128:
    $P4412."symbol"($P4413, "lexical" :named("scope"), 1 :named("proto"), $P4414 :named("cholder"))
.annotate 'line', 1490
    find_lex $P4415, "$past"
    unless_null $P4415, vivify_2129
    new $P4415, "Undef"
  vivify_2129:
    $P4416 = $P4415."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1474
    .return ($P4416)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4283"  :anon :subid("494_1303391609.928") :outer("493_1303391609.928")
.annotate 'line', 1423
    .const 'Sub' $P4304 = "495_1303391609.928" 
    capture_lex $P4304
.annotate 'line', 1426
    new $P4285, "Undef"
    .lex "$cholder", $P4285
.annotate 'line', 1427
    $P4286 = root_new ['parrot';'Hash']
    .lex "%sym", $P4286
.annotate 'line', 1425
    find_dynamic_lex $P4288, "$*SCOPE"
    unless_null $P4288, vivify_2130
    get_hll_global $P4288, "$SCOPE"
    unless_null $P4288, vivify_2131
    die "Contextual $*SCOPE not found"
  vivify_2131:
  vivify_2130:
    set $S4289, $P4288
    iseq $I4290, $S4289, "our"
    unless $I4290, if_4287_end
    die "our-scoped multis not yet implemented"
  if_4287_end:
    find_lex $P4291, "$cholder"
    unless_null $P4291, vivify_2132
    new $P4291, "Undef"
  vivify_2132:
.annotate 'line', 1427
    find_lex $P4292, "$?PACKAGE"
    get_who $P4293, $P4292
    set $P4294, $P4293["@BLOCK"]
    unless_null $P4294, vivify_2133
    $P4294 = root_new ['parrot';'ResizablePMCArray']
  vivify_2133:
    set $P4295, $P4294[0]
    unless_null $P4295, vivify_2134
    new $P4295, "Undef"
  vivify_2134:
    find_lex $P4296, "$name"
    unless_null $P4296, vivify_2135
    new $P4296, "Undef"
  vivify_2135:
    $P4297 = $P4295."symbol"($P4296)
    store_lex "%sym", $P4297
.annotate 'line', 1428
    find_lex $P4299, "%sym"
    unless_null $P4299, vivify_2136
    $P4299 = root_new ['parrot';'Hash']
  vivify_2136:
    set $P4300, $P4299["cholder"]
    unless_null $P4300, vivify_2137
    new $P4300, "Undef"
  vivify_2137:
    if $P4300, if_4298
.annotate 'line', 1433
    .const 'Sub' $P4304 = "495_1303391609.928" 
    capture_lex $P4304
    $P4304()
    goto if_4298_end
  if_4298:
.annotate 'line', 1429
    find_lex $P4301, "%sym"
    unless_null $P4301, vivify_2165
    $P4301 = root_new ['parrot';'Hash']
  vivify_2165:
    set $P4302, $P4301["cholder"]
    unless_null $P4302, vivify_2166
    new $P4302, "Undef"
  vivify_2166:
    store_lex "$cholder", $P4302
  if_4298_end:
.annotate 'line', 1469
    find_lex $P4372, "$cholder"
    unless_null $P4372, vivify_2167
    new $P4372, "Undef"
  vivify_2167:
    find_lex $P4373, "$past"
    unless_null $P4373, vivify_2168
    new $P4373, "Undef"
  vivify_2168:
    $P4372."push"($P4373)
.annotate 'line', 1472
    find_lex $P4374, "$past"
    unless_null $P4374, vivify_2169
    new $P4374, "Undef"
  vivify_2169:
    $P4375 = "attach_multi_signature"($P4374)
.annotate 'line', 1423
    .return ($P4375)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4303"  :anon :subid("495_1303391609.928") :outer("494_1303391609.928")
.annotate 'line', 1433
    .const 'Sub' $P4320 = "496_1303391609.928" 
    capture_lex $P4320
.annotate 'line', 1440
    new $P4305, "Undef"
    .lex "$found_proto", $P4305
.annotate 'line', 1458
    new $P4306, "Undef"
    .lex "$dispatch_setup", $P4306
.annotate 'line', 1435
    find_lex $P4308, "%sym"
    unless_null $P4308, vivify_2138
    $P4308 = root_new ['parrot';'Hash']
  vivify_2138:
    set $P4309, $P4308["proto"]
    unless_null $P4309, vivify_2139
    new $P4309, "Undef"
  vivify_2139:
    unless $P4309, if_4307_end
.annotate 'line', 1438
    find_lex $P4310, "$/"
    unless_null $P4310, vivify_2140
    new $P4310, "Undef"
  vivify_2140:
    $P4311 = $P4310."CURSOR"()
    $P4311."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4307_end:
.annotate 'line', 1435
    find_lex $P4312, "$found_proto"
    unless_null $P4312, vivify_2141
    new $P4312, "Undef"
  vivify_2141:
.annotate 'line', 1441
    find_lex $P4314, "$?PACKAGE"
    get_who $P4315, $P4314
    set $P4316, $P4315["@BLOCK"]
    unless_null $P4316, vivify_2142
    $P4316 = root_new ['parrot';'ResizablePMCArray']
  vivify_2142:
    defined $I4317, $P4316
    unless $I4317, for_undef_2143
    iter $P4313, $P4316
    new $P4342, 'ExceptionHandler'
    set_label $P4342, loop4341_handler
    $P4342."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4342
  loop4341_test:
    unless $P4313, loop4341_done
    shift $P4318, $P4313
  loop4341_redo:
    .const 'Sub' $P4320 = "496_1303391609.928" 
    capture_lex $P4320
    $P4320($P4318)
  loop4341_next:
    goto loop4341_test
  loop4341_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4343, exception, 'type'
    eq $P4343, .CONTROL_LOOP_NEXT, loop4341_next
    eq $P4343, .CONTROL_LOOP_REDO, loop4341_redo
  loop4341_done:
    pop_eh 
  for_undef_2143:
.annotate 'line', 1452
    find_lex $P4345, "$found_proto"
    unless_null $P4345, vivify_2152
    new $P4345, "Undef"
  vivify_2152:
    if $P4345, unless_4344_end
.annotate 'line', 1453
    find_lex $P4346, "$/"
    unless_null $P4346, vivify_2153
    new $P4346, "Undef"
  vivify_2153:
    $P4347 = $P4346."CURSOR"()
    $P4347."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4344_end:
.annotate 'line', 1457
    get_hll_global $P4348, ["PAST"], "Op"
    $P4349 = $P4348."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4349
.annotate 'line', 1458
    get_hll_global $P4350, ["PAST"], "Op"
.annotate 'line', 1460
    get_hll_global $P4351, ["PAST"], "Var"
    find_lex $P4352, "$name"
    unless_null $P4352, vivify_2154
    new $P4352, "Undef"
  vivify_2154:
    $P4353 = $P4351."new"($P4352 :named("name"), "outer" :named("scope"))
    find_lex $P4354, "$cholder"
    unless_null $P4354, vivify_2155
    new $P4354, "Undef"
  vivify_2155:
    $P4355 = $P4350."new"($P4353, $P4354, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1458
    store_lex "$dispatch_setup", $P4355
.annotate 'line', 1463
    find_lex $P4356, "$?PACKAGE"
    get_who $P4357, $P4356
    set $P4358, $P4357["@BLOCK"]
    unless_null $P4358, vivify_2156
    $P4358 = root_new ['parrot';'ResizablePMCArray']
  vivify_2156:
    set $P4359, $P4358[0]
    unless_null $P4359, vivify_2157
    $P4359 = root_new ['parrot';'ResizablePMCArray']
  vivify_2157:
    set $P4360, $P4359[0]
    unless_null $P4360, vivify_2158
    new $P4360, "Undef"
  vivify_2158:
    get_hll_global $P4361, ["PAST"], "Var"
    find_lex $P4362, "$name"
    unless_null $P4362, vivify_2159
    new $P4362, "Undef"
  vivify_2159:
    find_lex $P4363, "$dispatch_setup"
    unless_null $P4363, vivify_2160
    new $P4363, "Undef"
  vivify_2160:
    $P4364 = $P4361."new"($P4362 :named("name"), 1 :named("isdecl"), $P4363 :named("viviself"), "lexical" :named("scope"))
    $P4360."push"($P4364)
.annotate 'line', 1465
    find_lex $P4365, "$?PACKAGE"
    get_who $P4366, $P4365
    set $P4367, $P4366["@BLOCK"]
    unless_null $P4367, vivify_2161
    $P4367 = root_new ['parrot';'ResizablePMCArray']
  vivify_2161:
    set $P4368, $P4367[0]
    unless_null $P4368, vivify_2162
    new $P4368, "Undef"
  vivify_2162:
    find_lex $P4369, "$name"
    unless_null $P4369, vivify_2163
    new $P4369, "Undef"
  vivify_2163:
    find_lex $P4370, "$cholder"
    unless_null $P4370, vivify_2164
    new $P4370, "Undef"
  vivify_2164:
    $P4371 = $P4368."symbol"($P4369, "lexical" :named("scope"), $P4370 :named("cholder"))
.annotate 'line', 1433
    .return ($P4371)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4319"  :anon :subid("496_1303391609.928") :outer("495_1303391609.928")
    .param pmc param_4322
.annotate 'line', 1442
    $P4321 = root_new ['parrot';'Hash']
    .lex "%sym", $P4321
    .lex "$_", param_4322
    find_lex $P4323, "$_"
    unless_null $P4323, vivify_2144
    new $P4323, "Undef"
  vivify_2144:
    find_lex $P4324, "$name"
    unless_null $P4324, vivify_2145
    new $P4324, "Undef"
  vivify_2145:
    $P4325 = $P4323."symbol"($P4324)
    store_lex "%sym", $P4325
.annotate 'line', 1443
    find_lex $P4330, "%sym"
    unless_null $P4330, vivify_2146
    $P4330 = root_new ['parrot';'Hash']
  vivify_2146:
    set $P4331, $P4330["proto"]
    unless_null $P4331, vivify_2147
    new $P4331, "Undef"
  vivify_2147:
    unless $P4331, unless_4329
    set $P4328, $P4331
    goto unless_4329_end
  unless_4329:
    find_lex $P4332, "%sym"
    unless_null $P4332, vivify_2148
    $P4332 = root_new ['parrot';'Hash']
  vivify_2148:
    set $P4333, $P4332["cholder"]
    unless_null $P4333, vivify_2149
    new $P4333, "Undef"
  vivify_2149:
    set $P4328, $P4333
  unless_4329_end:
    if $P4328, if_4327
.annotate 'line', 1446
    find_lex $P4337, "%sym"
    unless_null $P4337, vivify_2150
    $P4337 = root_new ['parrot';'Hash']
  vivify_2150:
    if $P4337, if_4336
    set $P4335, $P4337
    goto if_4336_end
  if_4336:
.annotate 'line', 1447
    find_lex $P4338, "$/"
    unless_null $P4338, vivify_2151
    new $P4338, "Undef"
  vivify_2151:
    $P4339 = $P4338."CURSOR"()
    $P4340 = $P4339."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1446
    set $P4335, $P4340
  if_4336_end:
    set $P4326, $P4335
.annotate 'line', 1443
    goto if_4327_end
  if_4327:
.annotate 'line', 1444
    new $P4334, "Integer"
    assign $P4334, 1
    store_lex "$found_proto", $P4334
.annotate 'line', 1443
    set $P4326, $P4334
  if_4327_end:
.annotate 'line', 1441
    .return ($P4326)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4489"  :anon :subid("498_1303391609.928") :outer("492_1303391609.928")
    .param pmc param_4491
.annotate 'line', 1526
    .lex "$_", param_4491
    find_lex $P4492, "$_"
    unless_null $P4492, vivify_2182
    new $P4492, "Undef"
  vivify_2182:
    $P4493 = $P4492."ast"()
    find_lex $P4494, "$/"
    unless_null $P4494, vivify_2183
    new $P4494, "Undef"
  vivify_2183:
    $P4495 = $P4493($P4494)
    .return ($P4495)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("499_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4503
    .param pmc param_4504
.annotate 'line', 1533
    .const 'Sub' $P4616 = "501_1303391609.928" 
    capture_lex $P4616
    .const 'Sub' $P4532 = "500_1303391609.928" 
    capture_lex $P4532
    .lex "self", param_4503
    .lex "$/", param_4504
.annotate 'line', 1536
    new $P4505, "Undef"
    .lex "$past", $P4505
.annotate 'line', 1533
    find_lex $P4506, "$past"
    unless_null $P4506, vivify_2185
    new $P4506, "Undef"
  vivify_2185:
.annotate 'line', 1537
    find_lex $P4508, "$/"
    unless_null $P4508, vivify_2186
    $P4508 = root_new ['parrot';'Hash']
  vivify_2186:
    set $P4509, $P4508["onlystar"]
    unless_null $P4509, vivify_2187
    new $P4509, "Undef"
  vivify_2187:
    if $P4509, if_4507
.annotate 'line', 1541
    find_lex $P4511, "$/"
    unless_null $P4511, vivify_2188
    $P4511 = root_new ['parrot';'Hash']
  vivify_2188:
    set $P4512, $P4511["blockoid"]
    unless_null $P4512, vivify_2189
    new $P4512, "Undef"
  vivify_2189:
    $P4513 = $P4512."ast"()
    store_lex "$past", $P4513
.annotate 'line', 1542
    find_lex $P4514, "$past"
    unless_null $P4514, vivify_2190
    new $P4514, "Undef"
  vivify_2190:
    $P4514."blocktype"("declaration")
.annotate 'line', 1543
    find_dynamic_lex $P4516, "$*RETURN_USED"
    unless_null $P4516, vivify_2191
    get_hll_global $P4516, "$RETURN_USED"
    unless_null $P4516, vivify_2192
    die "Contextual $*RETURN_USED not found"
  vivify_2192:
  vivify_2191:
    unless $P4516, if_4515_end
.annotate 'line', 1544
    find_lex $P4517, "$past"
    unless_null $P4517, vivify_2193
    new $P4517, "Undef"
  vivify_2193:
    $P4517."control"("return_pir")
  if_4515_end:
.annotate 'line', 1540
    goto if_4507_end
  if_4507:
.annotate 'line', 1538
    $P4510 = "only_star_block"()
    store_lex "$past", $P4510
  if_4507_end:
.annotate 'line', 1549
    find_lex $P4519, "$past"
    unless_null $P4519, vivify_2194
    $P4519 = root_new ['parrot';'Hash']
  vivify_2194:
    set $P4520, $P4519["signature_has_invocant"]
    unless_null $P4520, vivify_2195
    new $P4520, "Undef"
  vivify_2195:
    if $P4520, unless_4518_end
.annotate 'line', 1550
    find_lex $P4521, "$past"
    unless_null $P4521, vivify_2196
    $P4521 = root_new ['parrot';'ResizablePMCArray']
  vivify_2196:
    set $P4522, $P4521[0]
    unless_null $P4522, vivify_2197
    new $P4522, "Undef"
  vivify_2197:
    get_hll_global $P4523, ["PAST"], "Var"
.annotate 'line', 1552
    get_hll_global $P4524, ["PAST"], "Var"
    $P4525 = $P4524."new"("$?CLASS" :named("name"))
    $P4526 = $P4523."new"("self" :named("name"), "parameter" :named("scope"), $P4525 :named("multitype"))
.annotate 'line', 1550
    $P4522."unshift"($P4526)
  unless_4518_end:
.annotate 'line', 1555
    find_lex $P4527, "$past"
    unless_null $P4527, vivify_2198
    new $P4527, "Undef"
  vivify_2198:
    $P4527."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1558
    find_lex $P4529, "$/"
    unless_null $P4529, vivify_2199
    $P4529 = root_new ['parrot';'Hash']
  vivify_2199:
    set $P4530, $P4529["deflongname"]
    unless_null $P4530, vivify_2200
    new $P4530, "Undef"
  vivify_2200:
    unless $P4530, if_4528_end
    .const 'Sub' $P4532 = "500_1303391609.928" 
    capture_lex $P4532
    $P4532()
  if_4528_end:
.annotate 'line', 1593
    find_dynamic_lex $P4598, "$*SCOPE"
    unless_null $P4598, vivify_2226
    get_hll_global $P4598, "$SCOPE"
    unless_null $P4598, vivify_2227
    die "Contextual $*SCOPE not found"
  vivify_2227:
  vivify_2226:
    set $S4599, $P4598
    iseq $I4600, $S4599, "our"
    unless $I4600, if_4597_end
.annotate 'line', 1594
    find_lex $P4601, "$past"
    unless_null $P4601, vivify_2228
    new $P4601, "Undef"
  vivify_2228:
    $P4601."pirflags"(":nsentry")
  if_4597_end:
.annotate 'line', 1598
    find_lex $P4602, "$/"
    find_lex $P4603, "$past"
    unless_null $P4603, vivify_2229
    new $P4603, "Undef"
  vivify_2229:
    $P4602."!make"($P4603)
.annotate 'line', 1599
    find_lex $P4604, "$past"
    unless_null $P4604, vivify_2230
    new $P4604, "Undef"
  vivify_2230:
    find_lex $P4605, "$past"
    unless_null $P4605, vivify_2231
    $P4605 = root_new ['parrot';'Hash']
    store_lex "$past", $P4605
  vivify_2231:
    set $P4605["block_past"], $P4604
.annotate 'line', 1600
    find_lex $P4608, "$/"
    unless_null $P4608, vivify_2232
    $P4608 = root_new ['parrot';'Hash']
  vivify_2232:
    set $P4609, $P4608["trait"]
    unless_null $P4609, vivify_2233
    new $P4609, "Undef"
  vivify_2233:
    if $P4609, if_4607
    set $P4606, $P4609
    goto if_4607_end
  if_4607:
.annotate 'line', 1601
    find_lex $P4611, "$/"
    unless_null $P4611, vivify_2234
    $P4611 = root_new ['parrot';'Hash']
  vivify_2234:
    set $P4612, $P4611["trait"]
    unless_null $P4612, vivify_2235
    new $P4612, "Undef"
  vivify_2235:
    defined $I4613, $P4612
    unless $I4613, for_undef_2236
    iter $P4610, $P4612
    new $P4623, 'ExceptionHandler'
    set_label $P4623, loop4622_handler
    $P4623."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4623
  loop4622_test:
    unless $P4610, loop4622_done
    shift $P4614, $P4610
  loop4622_redo:
    .const 'Sub' $P4616 = "501_1303391609.928" 
    capture_lex $P4616
    $P4616($P4614)
  loop4622_next:
    goto loop4622_test
  loop4622_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4624, exception, 'type'
    eq $P4624, .CONTROL_LOOP_NEXT, loop4622_next
    eq $P4624, .CONTROL_LOOP_REDO, loop4622_redo
  loop4622_done:
    pop_eh 
  for_undef_2236:
.annotate 'line', 1600
    set $P4606, $P4610
  if_4607_end:
.annotate 'line', 1533
    .return ($P4606)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4531"  :anon :subid("500_1303391609.928") :outer("499_1303391609.928")
.annotate 'line', 1560
    new $P4533, "Undef"
    .lex "$name", $P4533
.annotate 'line', 1565
    new $P4534, "Undef"
    .lex "$to_add", $P4534
.annotate 'line', 1560
    find_lex $P4535, "$/"
    unless_null $P4535, vivify_2201
    $P4535 = root_new ['parrot';'Hash']
  vivify_2201:
    set $P4536, $P4535["private"]
    unless_null $P4536, vivify_2202
    new $P4536, "Undef"
  vivify_2202:
    set $S4537, $P4536
    new $P4538, 'String'
    set $P4538, $S4537
    find_lex $P4539, "$/"
    unless_null $P4539, vivify_2203
    $P4539 = root_new ['parrot';'Hash']
  vivify_2203:
    set $P4540, $P4539["deflongname"]
    unless_null $P4540, vivify_2204
    $P4540 = root_new ['parrot';'ResizablePMCArray']
  vivify_2204:
    set $P4541, $P4540[0]
    unless_null $P4541, vivify_2205
    new $P4541, "Undef"
  vivify_2205:
    $P4542 = $P4541."ast"()
    set $S4543, $P4542
    concat $P4544, $P4538, $S4543
    store_lex "$name", $P4544
.annotate 'line', 1561
    find_lex $P4545, "$past"
    unless_null $P4545, vivify_2206
    new $P4545, "Undef"
  vivify_2206:
    find_lex $P4546, "$name"
    unless_null $P4546, vivify_2207
    new $P4546, "Undef"
  vivify_2207:
    $P4545."name"($P4546)
.annotate 'line', 1565
    find_dynamic_lex $P4549, "$*MULTINESS"
    unless_null $P4549, vivify_2208
    get_hll_global $P4549, "$MULTINESS"
    unless_null $P4549, vivify_2209
    die "Contextual $*MULTINESS not found"
  vivify_2209:
  vivify_2208:
    set $S4550, $P4549
    isne $I4551, $S4550, "proto"
    if $I4551, if_4548
.annotate 'line', 1567
    get_hll_global $P4555, ["PAST"], "Op"
.annotate 'line', 1569
    get_hll_global $P4556, ["PAST"], "Val"
    find_lex $P4557, "$past"
    unless_null $P4557, vivify_2210
    new $P4557, "Undef"
  vivify_2210:
    $P4558 = $P4556."new"($P4557 :named("value"))
.annotate 'line', 1570
    get_hll_global $P4559, ["PAST"], "Op"
    $P4560 = $P4559."new"("list" :named("pasttype"))
    $P4561 = $P4555."new"($P4558, $P4560, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1567
    set $P4547, $P4561
.annotate 'line', 1565
    goto if_4548_end
  if_4548:
.annotate 'line', 1566
    get_hll_global $P4552, ["PAST"], "Val"
    find_lex $P4553, "$past"
    unless_null $P4553, vivify_2211
    new $P4553, "Undef"
  vivify_2211:
    $P4554 = $P4552."new"($P4553 :named("value"))
    set $P4547, $P4554
  if_4548_end:
.annotate 'line', 1565
    store_lex "$to_add", $P4547
.annotate 'line', 1572
    find_dynamic_lex $P4563, "$*MULTINESS"
    unless_null $P4563, vivify_2212
    get_hll_global $P4563, "$MULTINESS"
    unless_null $P4563, vivify_2213
    die "Contextual $*MULTINESS not found"
  vivify_2213:
  vivify_2212:
    set $S4564, $P4563
    iseq $I4565, $S4564, "proto"
    unless $I4565, if_4562_end
    find_lex $P4566, "$past"
    unless_null $P4566, vivify_2214
    new $P4566, "Undef"
  vivify_2214:
    $P4566."pirflags"(":instanceof(\"DispatcherSub\")")
  if_4562_end:
.annotate 'line', 1576
    find_dynamic_lex $P4568, "$*MULTINESS"
    unless_null $P4568, vivify_2215
    get_hll_global $P4568, "$MULTINESS"
    unless_null $P4568, vivify_2216
    die "Contextual $*MULTINESS not found"
  vivify_2216:
  vivify_2215:
    set $S4569, $P4568
    iseq $I4570, $S4569, "multi"
    unless $I4570, if_4567_end
    find_lex $P4571, "$past"
    unless_null $P4571, vivify_2217
    new $P4571, "Undef"
  vivify_2217:
    "attach_multi_signature"($P4571)
  if_4567_end:
.annotate 'line', 1579
    find_dynamic_lex $P4574, "$*PACKAGE-SETUP"
    unless_null $P4574, vivify_2218
    get_hll_global $P4574, "$PACKAGE-SETUP"
    unless_null $P4574, vivify_2219
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2219:
  vivify_2218:
    defined $I4575, $P4574
    if $I4575, if_4573
    new $P4572, 'Integer'
    set $P4572, $I4575
    goto if_4573_end
  if_4573:
.annotate 'line', 1580
    find_dynamic_lex $P4576, "$*PACKAGE-SETUP"
    unless_null $P4576, vivify_2220
    get_hll_global $P4576, "$PACKAGE-SETUP"
    unless_null $P4576, vivify_2221
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2221:
  vivify_2220:
    get_hll_global $P4577, ["PAST"], "Op"
.annotate 'line', 1581
    find_dynamic_lex $P4580, "$*MULTINESS"
    unless_null $P4580, vivify_2222
    get_hll_global $P4580, "$MULTINESS"
    unless_null $P4580, vivify_2223
    die "Contextual $*MULTINESS not found"
  vivify_2223:
  vivify_2222:
    set $S4581, $P4580
    iseq $I4582, $S4581, "multi"
    if $I4582, if_4579
    new $P4584, "String"
    assign $P4584, "add_method"
    set $P4578, $P4584
    goto if_4579_end
  if_4579:
    new $P4583, "String"
    assign $P4583, "add_multi_method"
    set $P4578, $P4583
  if_4579_end:
.annotate 'line', 1582
    get_hll_global $P4585, ["PAST"], "Op"
.annotate 'line', 1585
    get_hll_global $P4586, ["PAST"], "Var"
    $P4587 = $P4586."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4588 = $P4585."new"($P4587, "get_how PP" :named("pirop"))
.annotate 'line', 1587
    get_hll_global $P4589, ["PAST"], "Var"
    $P4590 = $P4589."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1588
    get_hll_global $P4591, ["PAST"], "Val"
    find_lex $P4592, "$name"
    unless_null $P4592, vivify_2224
    new $P4592, "Undef"
  vivify_2224:
    $P4593 = $P4591."new"($P4592 :named("value"))
    find_lex $P4594, "$to_add"
    unless_null $P4594, vivify_2225
    new $P4594, "Undef"
  vivify_2225:
    $P4595 = $P4577."new"($P4588, $P4590, $P4593, $P4594, "callmethod" :named("pasttype"), $P4578 :named("name"))
.annotate 'line', 1580
    $P4596 = $P4576."push"($P4595)
.annotate 'line', 1579
    set $P4572, $P4596
  if_4573_end:
.annotate 'line', 1558
    .return ($P4572)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4615"  :anon :subid("501_1303391609.928") :outer("499_1303391609.928")
    .param pmc param_4617
.annotate 'line', 1601
    .lex "$_", param_4617
    find_lex $P4618, "$_"
    unless_null $P4618, vivify_2237
    new $P4618, "Undef"
  vivify_2237:
    $P4619 = $P4618."ast"()
    find_lex $P4620, "$/"
    unless_null $P4620, vivify_2238
    new $P4620, "Undef"
  vivify_2238:
    $P4621 = $P4619($P4620)
    .return ($P4621)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("502_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4628
    .param pmc param_4629
.annotate 'line', 1633
    .const 'Sub' $P4666 = "504_1303391609.928" 
    capture_lex $P4666
    .const 'Sub' $P4640 = "503_1303391609.928" 
    capture_lex $P4640
    .lex "self", param_4628
    .lex "$/", param_4629
.annotate 'line', 1634
    new $P4630, "Undef"
    .lex "$BLOCKINIT", $P4630
    find_lex $P4631, "$?PACKAGE"
    get_who $P4632, $P4631
    set $P4633, $P4632["@BLOCK"]
    unless_null $P4633, vivify_2239
    $P4633 = root_new ['parrot';'ResizablePMCArray']
  vivify_2239:
    set $P4634, $P4633[0]
    unless_null $P4634, vivify_2240
    $P4634 = root_new ['parrot';'ResizablePMCArray']
  vivify_2240:
    set $P4635, $P4634[0]
    unless_null $P4635, vivify_2241
    new $P4635, "Undef"
  vivify_2241:
    store_lex "$BLOCKINIT", $P4635
.annotate 'line', 1635
    find_lex $P4637, "$/"
    unless_null $P4637, vivify_2242
    $P4637 = root_new ['parrot';'Hash']
  vivify_2242:
    set $P4638, $P4637["invocant"]
    unless_null $P4638, vivify_2243
    new $P4638, "Undef"
  vivify_2243:
    unless $P4638, if_4636_end
    .const 'Sub' $P4640 = "503_1303391609.928" 
    capture_lex $P4640
    $P4640()
  if_4636_end:
.annotate 'line', 1644
    find_lex $P4661, "$/"
    unless_null $P4661, vivify_2253
    $P4661 = root_new ['parrot';'Hash']
  vivify_2253:
    set $P4662, $P4661["parameter"]
    unless_null $P4662, vivify_2254
    new $P4662, "Undef"
  vivify_2254:
    defined $I4663, $P4662
    unless $I4663, for_undef_2255
    iter $P4660, $P4662
    new $P4673, 'ExceptionHandler'
    set_label $P4673, loop4672_handler
    $P4673."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4673
  loop4672_test:
    unless $P4660, loop4672_done
    shift $P4664, $P4660
  loop4672_redo:
    .const 'Sub' $P4666 = "504_1303391609.928" 
    capture_lex $P4666
    $P4666($P4664)
  loop4672_next:
    goto loop4672_test
  loop4672_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4674, exception, 'type'
    eq $P4674, .CONTROL_LOOP_NEXT, loop4672_next
    eq $P4674, .CONTROL_LOOP_REDO, loop4672_redo
  loop4672_done:
    pop_eh 
  for_undef_2255:
.annotate 'line', 1633
    .return ($P4660)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4639"  :anon :subid("503_1303391609.928") :outer("502_1303391609.928")
.annotate 'line', 1636
    new $P4641, "Undef"
    .lex "$inv", $P4641
    find_lex $P4642, "$/"
    unless_null $P4642, vivify_2244
    $P4642 = root_new ['parrot';'Hash']
  vivify_2244:
    set $P4643, $P4642["invocant"]
    unless_null $P4643, vivify_2245
    $P4643 = root_new ['parrot';'ResizablePMCArray']
  vivify_2245:
    set $P4644, $P4643[0]
    unless_null $P4644, vivify_2246
    new $P4644, "Undef"
  vivify_2246:
    $P4645 = $P4644."ast"()
    store_lex "$inv", $P4645
.annotate 'line', 1637
    find_lex $P4646, "$BLOCKINIT"
    unless_null $P4646, vivify_2247
    new $P4646, "Undef"
  vivify_2247:
    find_lex $P4647, "$inv"
    unless_null $P4647, vivify_2248
    new $P4647, "Undef"
  vivify_2248:
    $P4646."push"($P4647)
.annotate 'line', 1638
    find_lex $P4648, "$BLOCKINIT"
    unless_null $P4648, vivify_2249
    new $P4648, "Undef"
  vivify_2249:
    get_hll_global $P4649, ["PAST"], "Var"
.annotate 'line', 1640
    get_hll_global $P4650, ["PAST"], "Var"
    find_lex $P4651, "$inv"
    unless_null $P4651, vivify_2250
    new $P4651, "Undef"
  vivify_2250:
    $P4652 = $P4651."name"()
    $P4653 = $P4650."new"("lexical" :named("scope"), $P4652 :named("name"))
    $P4654 = $P4649."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4653 :named("viviself"))
.annotate 'line', 1638
    $P4648."push"($P4654)
.annotate 'line', 1642
    new $P4655, "Integer"
    assign $P4655, 1
    find_lex $P4656, "$?PACKAGE"
    get_who $P4657, $P4656
    set $P4658, $P4657["@BLOCK"]
    unless_null $P4658, vivify_2251
    $P4658 = root_new ['parrot';'ResizablePMCArray']
    set $P4657["@BLOCK"], $P4658
  vivify_2251:
    set $P4659, $P4658[0]
    unless_null $P4659, vivify_2252
    $P4659 = root_new ['parrot';'Hash']
    set $P4658[0], $P4659
  vivify_2252:
    set $P4659["signature_has_invocant"], $P4655
.annotate 'line', 1635
    .return ($P4655)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4665"  :anon :subid("504_1303391609.928") :outer("502_1303391609.928")
    .param pmc param_4667
.annotate 'line', 1644
    .lex "$_", param_4667
    find_lex $P4668, "$BLOCKINIT"
    unless_null $P4668, vivify_2256
    new $P4668, "Undef"
  vivify_2256:
    find_lex $P4669, "$_"
    unless_null $P4669, vivify_2257
    new $P4669, "Undef"
  vivify_2257:
    $P4670 = $P4669."ast"()
    $P4671 = $P4668."push"($P4670)
    .return ($P4671)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("505_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4676
    .param pmc param_4677
.annotate 'line', 1647
    .lex "self", param_4676
    .lex "$/", param_4677
.annotate 'line', 1648
    new $P4678, "Undef"
    .lex "$quant", $P4678
.annotate 'line', 1649
    new $P4679, "Undef"
    .lex "$past", $P4679
.annotate 'line', 1648
    find_lex $P4680, "$/"
    unless_null $P4680, vivify_2258
    $P4680 = root_new ['parrot';'Hash']
  vivify_2258:
    set $P4681, $P4680["quant"]
    unless_null $P4681, vivify_2259
    new $P4681, "Undef"
  vivify_2259:
    store_lex "$quant", $P4681
    find_lex $P4682, "$past"
    unless_null $P4682, vivify_2260
    new $P4682, "Undef"
  vivify_2260:
.annotate 'line', 1650
    find_lex $P4684, "$/"
    unless_null $P4684, vivify_2261
    $P4684 = root_new ['parrot';'Hash']
  vivify_2261:
    set $P4685, $P4684["named_param"]
    unless_null $P4685, vivify_2262
    new $P4685, "Undef"
  vivify_2262:
    if $P4685, if_4683
.annotate 'line', 1657
    find_lex $P4699, "$/"
    unless_null $P4699, vivify_2263
    $P4699 = root_new ['parrot';'Hash']
  vivify_2263:
    set $P4700, $P4699["param_var"]
    unless_null $P4700, vivify_2264
    new $P4700, "Undef"
  vivify_2264:
    $P4701 = $P4700."ast"()
    store_lex "$past", $P4701
.annotate 'line', 1658
    find_lex $P4703, "$quant"
    unless_null $P4703, vivify_2265
    new $P4703, "Undef"
  vivify_2265:
    set $S4704, $P4703
    iseq $I4705, $S4704, "*"
    if $I4705, if_4702
.annotate 'line', 1662
    find_lex $P4714, "$quant"
    unless_null $P4714, vivify_2266
    new $P4714, "Undef"
  vivify_2266:
    set $S4715, $P4714
    iseq $I4716, $S4715, "?"
    unless $I4716, if_4713_end
.annotate 'line', 1663
    find_lex $P4717, "$past"
    unless_null $P4717, vivify_2267
    new $P4717, "Undef"
  vivify_2267:
    find_lex $P4718, "$/"
    unless_null $P4718, vivify_2268
    $P4718 = root_new ['parrot';'Hash']
  vivify_2268:
    set $P4719, $P4718["param_var"]
    unless_null $P4719, vivify_2269
    $P4719 = root_new ['parrot';'Hash']
  vivify_2269:
    set $P4720, $P4719["sigil"]
    unless_null $P4720, vivify_2270
    new $P4720, "Undef"
  vivify_2270:
    $P4721 = "vivitype"($P4720)
    $P4717."viviself"($P4721)
  if_4713_end:
.annotate 'line', 1662
    goto if_4702_end
  if_4702:
.annotate 'line', 1659
    find_lex $P4706, "$past"
    unless_null $P4706, vivify_2271
    new $P4706, "Undef"
  vivify_2271:
    $P4706."slurpy"(1)
.annotate 'line', 1660
    find_lex $P4707, "$past"
    unless_null $P4707, vivify_2272
    new $P4707, "Undef"
  vivify_2272:
    find_lex $P4708, "$/"
    unless_null $P4708, vivify_2273
    $P4708 = root_new ['parrot';'Hash']
  vivify_2273:
    set $P4709, $P4708["param_var"]
    unless_null $P4709, vivify_2274
    $P4709 = root_new ['parrot';'Hash']
  vivify_2274:
    set $P4710, $P4709["sigil"]
    unless_null $P4710, vivify_2275
    new $P4710, "Undef"
  vivify_2275:
    set $S4711, $P4710
    iseq $I4712, $S4711, "%"
    $P4707."named"($I4712)
  if_4702_end:
.annotate 'line', 1656
    goto if_4683_end
  if_4683:
.annotate 'line', 1651
    find_lex $P4686, "$/"
    unless_null $P4686, vivify_2276
    $P4686 = root_new ['parrot';'Hash']
  vivify_2276:
    set $P4687, $P4686["named_param"]
    unless_null $P4687, vivify_2277
    new $P4687, "Undef"
  vivify_2277:
    $P4688 = $P4687."ast"()
    store_lex "$past", $P4688
.annotate 'line', 1652
    find_lex $P4690, "$quant"
    unless_null $P4690, vivify_2278
    new $P4690, "Undef"
  vivify_2278:
    set $S4691, $P4690
    isne $I4692, $S4691, "!"
    unless $I4692, if_4689_end
.annotate 'line', 1653
    find_lex $P4693, "$past"
    unless_null $P4693, vivify_2279
    new $P4693, "Undef"
  vivify_2279:
    find_lex $P4694, "$/"
    unless_null $P4694, vivify_2280
    $P4694 = root_new ['parrot';'Hash']
  vivify_2280:
    set $P4695, $P4694["named_param"]
    unless_null $P4695, vivify_2281
    $P4695 = root_new ['parrot';'Hash']
  vivify_2281:
    set $P4696, $P4695["param_var"]
    unless_null $P4696, vivify_2282
    $P4696 = root_new ['parrot';'Hash']
  vivify_2282:
    set $P4697, $P4696["sigil"]
    unless_null $P4697, vivify_2283
    new $P4697, "Undef"
  vivify_2283:
    $P4698 = "vivitype"($P4697)
    $P4693."viviself"($P4698)
  if_4689_end:
  if_4683_end:
.annotate 'line', 1666
    find_lex $P4723, "$/"
    unless_null $P4723, vivify_2284
    $P4723 = root_new ['parrot';'Hash']
  vivify_2284:
    set $P4724, $P4723["default_value"]
    unless_null $P4724, vivify_2285
    new $P4724, "Undef"
  vivify_2285:
    unless $P4724, if_4722_end
.annotate 'line', 1667
    find_lex $P4726, "$quant"
    unless_null $P4726, vivify_2286
    new $P4726, "Undef"
  vivify_2286:
    set $S4727, $P4726
    iseq $I4728, $S4727, "*"
    unless $I4728, if_4725_end
.annotate 'line', 1668
    find_lex $P4729, "$/"
    unless_null $P4729, vivify_2287
    new $P4729, "Undef"
  vivify_2287:
    $P4730 = $P4729."CURSOR"()
    $P4730."panic"("Can't put default on slurpy parameter")
  if_4725_end:
.annotate 'line', 1670
    find_lex $P4732, "$quant"
    unless_null $P4732, vivify_2288
    new $P4732, "Undef"
  vivify_2288:
    set $S4733, $P4732
    iseq $I4734, $S4733, "!"
    unless $I4734, if_4731_end
.annotate 'line', 1671
    find_lex $P4735, "$/"
    unless_null $P4735, vivify_2289
    new $P4735, "Undef"
  vivify_2289:
    $P4736 = $P4735."CURSOR"()
    $P4736."panic"("Can't put default on required parameter")
  if_4731_end:
.annotate 'line', 1673
    find_lex $P4737, "$past"
    unless_null $P4737, vivify_2290
    new $P4737, "Undef"
  vivify_2290:
    find_lex $P4738, "$/"
    unless_null $P4738, vivify_2291
    $P4738 = root_new ['parrot';'Hash']
  vivify_2291:
    set $P4739, $P4738["default_value"]
    unless_null $P4739, vivify_2292
    $P4739 = root_new ['parrot';'ResizablePMCArray']
  vivify_2292:
    set $P4740, $P4739[0]
    unless_null $P4740, vivify_2293
    $P4740 = root_new ['parrot';'Hash']
  vivify_2293:
    set $P4741, $P4740["EXPR"]
    unless_null $P4741, vivify_2294
    new $P4741, "Undef"
  vivify_2294:
    $P4742 = $P4741."ast"()
    $P4737."viviself"($P4742)
  if_4722_end:
.annotate 'line', 1675
    find_lex $P4744, "$past"
    unless_null $P4744, vivify_2295
    new $P4744, "Undef"
  vivify_2295:
    $P4745 = $P4744."viviself"()
    if $P4745, unless_4743_end
    find_lex $P4746, "$?PACKAGE"
    get_who $P4747, $P4746
    set $P4748, $P4747["@BLOCK"]
    unless_null $P4748, vivify_2296
    $P4748 = root_new ['parrot';'ResizablePMCArray']
  vivify_2296:
    set $P4749, $P4748[0]
    unless_null $P4749, vivify_2297
    new $P4749, "Undef"
  vivify_2297:
    find_lex $P4750, "$?PACKAGE"
    get_who $P4751, $P4750
    set $P4752, $P4751["@BLOCK"]
    unless_null $P4752, vivify_2298
    $P4752 = root_new ['parrot';'ResizablePMCArray']
  vivify_2298:
    set $P4753, $P4752[0]
    unless_null $P4753, vivify_2299
    new $P4753, "Undef"
  vivify_2299:
    $P4754 = $P4753."arity"()
    set $N4755, $P4754
    new $P4756, 'Float'
    set $P4756, $N4755
    add $P4757, $P4756, 1
    $P4749."arity"($P4757)
  unless_4743_end:
.annotate 'line', 1679
    find_lex $P4759, "$/"
    unless_null $P4759, vivify_2300
    $P4759 = root_new ['parrot';'Hash']
  vivify_2300:
    set $P4760, $P4759["typename"]
    unless_null $P4760, vivify_2301
    new $P4760, "Undef"
  vivify_2301:
    unless $P4760, if_4758_end
.annotate 'line', 1680
    find_lex $P4761, "$past"
    unless_null $P4761, vivify_2302
    new $P4761, "Undef"
  vivify_2302:
    find_lex $P4762, "$/"
    unless_null $P4762, vivify_2303
    $P4762 = root_new ['parrot';'Hash']
  vivify_2303:
    set $P4763, $P4762["typename"]
    unless_null $P4763, vivify_2304
    $P4763 = root_new ['parrot';'ResizablePMCArray']
  vivify_2304:
    set $P4764, $P4763[0]
    unless_null $P4764, vivify_2305
    new $P4764, "Undef"
  vivify_2305:
    $P4765 = $P4764."ast"()
    $P4761."multitype"($P4765)
  if_4758_end:
.annotate 'line', 1684
    find_lex $P4767, "$/"
    unless_null $P4767, vivify_2306
    $P4767 = root_new ['parrot';'Hash']
  vivify_2306:
    set $P4768, $P4767["definedness"]
    unless_null $P4768, vivify_2307
    new $P4768, "Undef"
  vivify_2307:
    unless $P4768, if_4766_end
.annotate 'line', 1685
    find_lex $P4769, "$/"
    unless_null $P4769, vivify_2308
    $P4769 = root_new ['parrot';'Hash']
  vivify_2308:
    set $P4770, $P4769["definedness"]
    unless_null $P4770, vivify_2309
    $P4770 = root_new ['parrot';'ResizablePMCArray']
  vivify_2309:
    set $P4771, $P4770[0]
    unless_null $P4771, vivify_2310
    new $P4771, "Undef"
  vivify_2310:
    set $S4772, $P4771
    new $P4773, 'String'
    set $P4773, $S4772
    find_lex $P4774, "$past"
    unless_null $P4774, vivify_2311
    $P4774 = root_new ['parrot';'Hash']
    store_lex "$past", $P4774
  vivify_2311:
    set $P4774["definedness"], $P4773
  if_4766_end:
.annotate 'line', 1688
    find_lex $P4775, "$/"
    find_lex $P4776, "$past"
    unless_null $P4776, vivify_2312
    new $P4776, "Undef"
  vivify_2312:
    $P4777 = $P4775."!make"($P4776)
.annotate 'line', 1647
    .return ($P4777)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("506_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4779
    .param pmc param_4780
.annotate 'line', 1691
    .lex "self", param_4779
    .lex "$/", param_4780
.annotate 'line', 1692
    new $P4781, "Undef"
    .lex "$name", $P4781
.annotate 'line', 1693
    new $P4782, "Undef"
    .lex "$past", $P4782
.annotate 'line', 1692
    find_lex $P4783, "$/"
    unless_null $P4783, vivify_2313
    new $P4783, "Undef"
  vivify_2313:
    set $S4784, $P4783
    new $P4785, 'String'
    set $P4785, $S4784
    store_lex "$name", $P4785
.annotate 'line', 1693
    get_hll_global $P4786, ["PAST"], "Var"
    find_lex $P4787, "$name"
    unless_null $P4787, vivify_2314
    new $P4787, "Undef"
  vivify_2314:
    find_lex $P4788, "$/"
    unless_null $P4788, vivify_2315
    new $P4788, "Undef"
  vivify_2315:
    $P4789 = $P4786."new"($P4787 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4788 :named("node"))
    store_lex "$past", $P4789
.annotate 'line', 1695
    find_lex $P4790, "$?PACKAGE"
    get_who $P4791, $P4790
    set $P4792, $P4791["@BLOCK"]
    unless_null $P4792, vivify_2316
    $P4792 = root_new ['parrot';'ResizablePMCArray']
  vivify_2316:
    set $P4793, $P4792[0]
    unless_null $P4793, vivify_2317
    new $P4793, "Undef"
  vivify_2317:
    find_lex $P4794, "$name"
    unless_null $P4794, vivify_2318
    new $P4794, "Undef"
  vivify_2318:
    $P4793."symbol"($P4794, "lexical" :named("scope"))
.annotate 'line', 1696
    find_lex $P4795, "$/"
    find_lex $P4796, "$past"
    unless_null $P4796, vivify_2319
    new $P4796, "Undef"
  vivify_2319:
    $P4797 = $P4795."!make"($P4796)
.annotate 'line', 1691
    .return ($P4797)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("507_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4799
    .param pmc param_4800
.annotate 'line', 1699
    .lex "self", param_4799
    .lex "$/", param_4800
.annotate 'line', 1700
    new $P4801, "Undef"
    .lex "$past", $P4801
    find_lex $P4802, "$/"
    unless_null $P4802, vivify_2320
    $P4802 = root_new ['parrot';'Hash']
  vivify_2320:
    set $P4803, $P4802["param_var"]
    unless_null $P4803, vivify_2321
    new $P4803, "Undef"
  vivify_2321:
    $P4804 = $P4803."ast"()
    store_lex "$past", $P4804
.annotate 'line', 1701
    find_lex $P4805, "$past"
    unless_null $P4805, vivify_2322
    new $P4805, "Undef"
  vivify_2322:
    find_lex $P4806, "$/"
    unless_null $P4806, vivify_2323
    $P4806 = root_new ['parrot';'Hash']
  vivify_2323:
    set $P4807, $P4806["param_var"]
    unless_null $P4807, vivify_2324
    $P4807 = root_new ['parrot';'Hash']
  vivify_2324:
    set $P4808, $P4807["name"]
    unless_null $P4808, vivify_2325
    new $P4808, "Undef"
  vivify_2325:
    set $S4809, $P4808
    $P4805."named"($S4809)
.annotate 'line', 1702
    find_lex $P4810, "$/"
    find_lex $P4811, "$past"
    unless_null $P4811, vivify_2326
    new $P4811, "Undef"
  vivify_2326:
    $P4812 = $P4810."!make"($P4811)
.annotate 'line', 1699
    .return ($P4812)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("508_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4814
    .param pmc param_4815
.annotate 'line', 1705
    .lex "self", param_4814
    .lex "$/", param_4815
.annotate 'line', 1706
    $P4816 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4816
    get_hll_global $P4817, ["HLL"], "Compiler"
    find_lex $P4818, "$/"
    unless_null $P4818, vivify_2327
    new $P4818, "Undef"
  vivify_2327:
    set $S4819, $P4818
    $P4820 = $P4817."parse_name"($S4819)
    store_lex "@name", $P4820
.annotate 'line', 1707
    find_lex $P4821, "$/"
    get_hll_global $P4822, ["PAST"], "Var"
.annotate 'line', 1708
    find_lex $P4823, "@name"
    unless_null $P4823, vivify_2328
    $P4823 = root_new ['parrot';'ResizablePMCArray']
  vivify_2328:
    $P4824 = $P4823."pop"()
    find_lex $P4825, "@name"
    unless_null $P4825, vivify_2329
    $P4825 = root_new ['parrot';'ResizablePMCArray']
  vivify_2329:
    $P4826 = $P4822."new"($P4824 :named("name"), $P4825 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1707
    $P4827 = $P4821."!make"($P4826)
.annotate 'line', 1705
    .return ($P4827)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("509_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4829
    .param pmc param_4830
.annotate 'line', 1714
    .lex "self", param_4829
    .lex "$/", param_4830
.annotate 'line', 1715
    find_lex $P4831, "$/"
    find_lex $P4832, "$/"
    unless_null $P4832, vivify_2330
    $P4832 = root_new ['parrot';'Hash']
  vivify_2330:
    set $P4833, $P4832["trait_mod"]
    unless_null $P4833, vivify_2331
    new $P4833, "Undef"
  vivify_2331:
    $P4834 = $P4833."ast"()
    $P4835 = $P4831."!make"($P4834)
.annotate 'line', 1714
    .return ($P4835)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("510_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4837
    .param pmc param_4838
.annotate 'line', 1718
    .const 'Sub' $P4858 = "511_1303391609.928" 
    capture_lex $P4858
    .lex "self", param_4837
    .lex "$/", param_4838
.annotate 'line', 1719
    new $P4839, "Undef"
    .lex "$cpast", $P4839
    find_lex $P4840, "$/"
    unless_null $P4840, vivify_2332
    $P4840 = root_new ['parrot';'Hash']
  vivify_2332:
    set $P4841, $P4840["circumfix"]
    unless_null $P4841, vivify_2333
    $P4841 = root_new ['parrot';'ResizablePMCArray']
  vivify_2333:
    set $P4842, $P4841[0]
    unless_null $P4842, vivify_2334
    new $P4842, "Undef"
  vivify_2334:
    $P4843 = $P4842."ast"()
    store_lex "$cpast", $P4843
.annotate 'line', 1720
    find_lex $P4846, "$/"
    unless_null $P4846, vivify_2335
    $P4846 = root_new ['parrot';'Hash']
  vivify_2335:
    set $P4847, $P4846["longname"]
    unless_null $P4847, vivify_2336
    new $P4847, "Undef"
  vivify_2336:
    set $S4848, $P4847
    iseq $I4849, $S4848, "parrot_vtable"
    if $I4849, if_4845
.annotate 'line', 1740
    find_lex $P4884, "$/"
    unless_null $P4884, vivify_2337
    $P4884 = root_new ['parrot';'Hash']
  vivify_2337:
    set $P4885, $P4884["longname"]
    unless_null $P4885, vivify_2338
    new $P4885, "Undef"
  vivify_2338:
    set $S4886, $P4885
    iseq $I4887, $S4886, "pirflags"
    if $I4887, if_4883
.annotate 'line', 1744
    find_lex $P4891, "$/"
    unless_null $P4891, vivify_2339
    new $P4891, "Undef"
  vivify_2339:
    $P4892 = $P4891."CURSOR"()
    new $P4893, 'String'
    set $P4893, "Trait '"
    find_lex $P4894, "$/"
    unless_null $P4894, vivify_2340
    $P4894 = root_new ['parrot';'Hash']
  vivify_2340:
    set $P4895, $P4894["longname"]
    unless_null $P4895, vivify_2341
    new $P4895, "Undef"
  vivify_2341:
    concat $P4896, $P4893, $P4895
    concat $P4897, $P4896, "' not implemented"
    $P4898 = $P4892."panic"($P4897)
.annotate 'line', 1743
    set $P4882, $P4898
.annotate 'line', 1740
    goto if_4883_end
  if_4883:
.annotate 'line', 1741
    find_lex $P4888, "$/"
    unless_null $P4888, vivify_2342
    new $P4888, "Undef"
  vivify_2342:
    $P4889 = $P4888."CURSOR"()
    $P4890 = $P4889."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1740
    set $P4882, $P4890
  if_4883_end:
    set $P4844, $P4882
.annotate 'line', 1720
    goto if_4845_end
  if_4845:
.annotate 'line', 1723
    get_hll_global $P4851, ["PAST"], "Val"
    find_lex $P4852, "$cpast"
    unless_null $P4852, vivify_2343
    new $P4852, "Undef"
  vivify_2343:
    $P4853 = $P4851."ACCEPTS"($P4852)
    if $P4853, unless_4850_end
.annotate 'line', 1722
    find_lex $P4854, "$/"
    unless_null $P4854, vivify_2344
    new $P4854, "Undef"
  vivify_2344:
    $P4855 = $P4854."CURSOR"()
    $P4855."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_4850_end:
.annotate 'line', 1724
    find_lex $P4856, "$/"
    .const 'Sub' $P4858 = "511_1303391609.928" 
    newclosure $P4880, $P4858
    $P4881 = $P4856."!make"($P4880)
.annotate 'line', 1720
    set $P4844, $P4881
  if_4845_end:
.annotate 'line', 1718
    .return ($P4844)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4857"  :anon :subid("511_1303391609.928") :outer("510_1303391609.928")
    .param pmc param_4859
.annotate 'line', 1724
    .lex "$match", param_4859
.annotate 'line', 1725
    new $P4860, "Undef"
    .lex "$meth", $P4860
    find_lex $P4861, "$match"
    unless_null $P4861, vivify_2345
    new $P4861, "Undef"
  vivify_2345:
    $P4862 = $P4861."ast"()
    set $P4863, $P4862["block_past"]
    unless_null $P4863, vivify_2346
    new $P4863, "Undef"
  vivify_2346:
    store_lex "$meth", $P4863
.annotate 'line', 1726
    find_dynamic_lex $P4866, "$*PACKAGE-SETUP"
    unless_null $P4866, vivify_2347
    get_hll_global $P4866, "$PACKAGE-SETUP"
    unless_null $P4866, vivify_2348
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2348:
  vivify_2347:
    defined $I4867, $P4866
    if $I4867, if_4865
    new $P4864, 'Integer'
    set $P4864, $I4867
    goto if_4865_end
  if_4865:
.annotate 'line', 1727
    find_dynamic_lex $P4868, "$*PACKAGE-SETUP"
    unless_null $P4868, vivify_2349
    get_hll_global $P4868, "$PACKAGE-SETUP"
    unless_null $P4868, vivify_2350
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2350:
  vivify_2349:
    get_hll_global $P4869, ["PAST"], "Op"
.annotate 'line', 1729
    get_hll_global $P4870, ["PAST"], "Op"
.annotate 'line', 1732
    get_hll_global $P4871, ["PAST"], "Var"
    $P4872 = $P4871."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4873 = $P4870."new"($P4872, "get_how PP" :named("pirop"))
.annotate 'line', 1734
    get_hll_global $P4874, ["PAST"], "Var"
    $P4875 = $P4874."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P4876, "$cpast"
    unless_null $P4876, vivify_2351
    new $P4876, "Undef"
  vivify_2351:
    find_lex $P4877, "$meth"
    unless_null $P4877, vivify_2352
    new $P4877, "Undef"
  vivify_2352:
    $P4878 = $P4869."new"($P4873, $P4875, $P4876, $P4877, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1727
    $P4879 = $P4868."push"($P4878)
.annotate 'line', 1726
    set $P4864, $P4879
  if_4865_end:
.annotate 'line', 1724
    .return ($P4864)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("512_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_4902
    .param pmc param_4903
    .param pmc param_4904 :optional
    .param int has_param_4904 :opt_flag
.annotate 'line', 1748
    .const 'Sub' $P5011 = "515_1303391609.928" 
    capture_lex $P5011
    .const 'Sub' $P4976 = "514_1303391609.928" 
    capture_lex $P4976
    .const 'Sub' $P4949 = "513_1303391609.928" 
    capture_lex $P4949
    new $P4901, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P4901, control_4900
    push_eh $P4901
    .lex "self", param_4902
    .lex "$/", param_4903
    if has_param_4904, optparam_2353
    new $P4905, "Undef"
    set param_4904, $P4905
  optparam_2353:
    .lex "$key", param_4904
.annotate 'line', 1749
    $P4906 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P4906
.annotate 'line', 1750
    new $P4907, "Undef"
    .lex "$name", $P4907
.annotate 'line', 1751
    new $P4908, "Undef"
    .lex "$past", $P4908
.annotate 'line', 1749
    get_hll_global $P4909, ["Regex";"P6Regex"], "Actions"
    get_who $P4910, $P4909
    set $P4911, $P4910["@MODIFIERS"]
    unless_null $P4911, vivify_2354
    $P4911 = root_new ['parrot';'ResizablePMCArray']
  vivify_2354:
    store_lex "@MODIFIERS", $P4911
.annotate 'line', 1750
    find_lex $P4912, "$/"
    unless_null $P4912, vivify_2355
    $P4912 = root_new ['parrot';'Hash']
  vivify_2355:
    set $P4913, $P4912["deflongname"]
    unless_null $P4913, vivify_2356
    new $P4913, "Undef"
  vivify_2356:
    $P4914 = $P4913."ast"()
    set $S4915, $P4914
    new $P4916, 'String'
    set $P4916, $S4915
    store_lex "$name", $P4916
    find_lex $P4917, "$past"
    unless_null $P4917, vivify_2357
    new $P4917, "Undef"
  vivify_2357:
.annotate 'line', 1752
    find_lex $P4919, "$/"
    unless_null $P4919, vivify_2358
    $P4919 = root_new ['parrot';'Hash']
  vivify_2358:
    set $P4920, $P4919["proto"]
    unless_null $P4920, vivify_2359
    new $P4920, "Undef"
  vivify_2359:
    if $P4920, if_4918
.annotate 'line', 1791
    find_lex $P4972, "$key"
    unless_null $P4972, vivify_2360
    new $P4972, "Undef"
  vivify_2360:
    set $S4973, $P4972
    iseq $I4974, $S4973, "open"
    if $I4974, if_4971
.annotate 'line', 1801
    .const 'Sub' $P5011 = "515_1303391609.928" 
    capture_lex $P5011
    $P5011()
    goto if_4971_end
  if_4971:
.annotate 'line', 1791
    .const 'Sub' $P4976 = "514_1303391609.928" 
    capture_lex $P4976
    $P4976()
  if_4971_end:
    goto if_4918_end
  if_4918:
.annotate 'line', 1754
    get_hll_global $P4921, ["PAST"], "Stmts"
.annotate 'line', 1755
    get_hll_global $P4922, ["PAST"], "Block"
    find_lex $P4923, "$name"
    unless_null $P4923, vivify_2395
    new $P4923, "Undef"
  vivify_2395:
.annotate 'line', 1756
    get_hll_global $P4924, ["PAST"], "Op"
.annotate 'line', 1757
    get_hll_global $P4925, ["PAST"], "Var"
    $P4926 = $P4925."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4927, "$name"
    unless_null $P4927, vivify_2396
    new $P4927, "Undef"
  vivify_2396:
    $P4928 = $P4924."new"($P4926, $P4927, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1756
    find_lex $P4929, "$/"
    unless_null $P4929, vivify_2397
    new $P4929, "Undef"
  vivify_2397:
    $P4930 = $P4922."new"($P4928, $P4923 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4929 :named("node"))
.annotate 'line', 1766
    get_hll_global $P4931, ["PAST"], "Block"
    new $P4932, "String"
    assign $P4932, "!PREFIX__"
    find_lex $P4933, "$name"
    unless_null $P4933, vivify_2398
    new $P4933, "Undef"
  vivify_2398:
    concat $P4934, $P4932, $P4933
.annotate 'line', 1767
    get_hll_global $P4935, ["PAST"], "Op"
.annotate 'line', 1768
    get_hll_global $P4936, ["PAST"], "Var"
    $P4937 = $P4936."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4938, "$name"
    unless_null $P4938, vivify_2399
    new $P4938, "Undef"
  vivify_2399:
    $P4939 = $P4935."new"($P4937, $P4938, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1767
    find_lex $P4940, "$/"
    unless_null $P4940, vivify_2400
    new $P4940, "Undef"
  vivify_2400:
    $P4941 = $P4931."new"($P4939, $P4934 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4940 :named("node"))
.annotate 'line', 1766
    $P4942 = $P4921."new"($P4930, $P4941)
.annotate 'line', 1754
    store_lex "$past", $P4942
.annotate 'line', 1778
    find_lex $P4944, "$past"
    unless_null $P4944, vivify_2401
    new $P4944, "Undef"
  vivify_2401:
    $P4945 = $P4944."list"()
    defined $I4946, $P4945
    unless $I4946, for_undef_2402
    iter $P4943, $P4945
    new $P4969, 'ExceptionHandler'
    set_label $P4969, loop4968_handler
    $P4969."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4969
  loop4968_test:
    unless $P4943, loop4968_done
    shift $P4947, $P4943
  loop4968_redo:
    .const 'Sub' $P4949 = "513_1303391609.928" 
    capture_lex $P4949
    $P4949($P4947)
  loop4968_next:
    goto loop4968_test
  loop4968_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4970, exception, 'type'
    eq $P4970, .CONTROL_LOOP_NEXT, loop4968_next
    eq $P4970, .CONTROL_LOOP_REDO, loop4968_redo
  loop4968_done:
    pop_eh 
  for_undef_2402:
  if_4918_end:
.annotate 'line', 1837
    find_lex $P5071, "$/"
    find_lex $P5072, "$past"
    unless_null $P5072, vivify_2407
    new $P5072, "Undef"
  vivify_2407:
    $P5073 = $P5071."!make"($P5072)
.annotate 'line', 1748
    .return ($P5073)
  control_4900:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5074, exception, "payload"
    .return ($P5074)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5010"  :anon :subid("515_1303391609.928") :outer("512_1303391609.928")
.annotate 'line', 1802
    new $P5012, "Undef"
    .lex "$regex", $P5012
.annotate 'line', 1803
    get_hll_global $P5013, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5014, "$/"
    unless_null $P5014, vivify_2361
    $P5014 = root_new ['parrot';'Hash']
  vivify_2361:
    set $P5015, $P5014["p6regex"]
    unless_null $P5015, vivify_2362
    new $P5015, "Undef"
  vivify_2362:
    $P5016 = $P5015."ast"()
    find_lex $P5017, "$?PACKAGE"
    get_who $P5018, $P5017
    set $P5019, $P5018["@BLOCK"]
    unless_null $P5019, vivify_2363
    $P5019 = root_new ['parrot';'ResizablePMCArray']
  vivify_2363:
    $P5020 = $P5019."shift"()
    $P5021 = $P5013($P5016, $P5020)
    store_lex "$regex", $P5021
.annotate 'line', 1804
    find_lex $P5022, "$regex"
    unless_null $P5022, vivify_2364
    new $P5022, "Undef"
  vivify_2364:
    find_lex $P5023, "$name"
    unless_null $P5023, vivify_2365
    new $P5023, "Undef"
  vivify_2365:
    $P5022."name"($P5023)
.annotate 'line', 1806
    get_hll_global $P5024, ["PAST"], "Op"
.annotate 'line', 1808
    get_hll_global $P5025, ["PAST"], "Var"
    new $P5026, "ResizablePMCArray"
    push $P5026, "Regex"
    $P5027 = $P5025."new"("Method" :named("name"), $P5026 :named("namespace"), "package" :named("scope"))
    find_lex $P5028, "$regex"
    unless_null $P5028, vivify_2366
    new $P5028, "Undef"
  vivify_2366:
    $P5029 = $P5024."new"($P5027, $P5028, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1806
    store_lex "$past", $P5029
.annotate 'line', 1811
    find_dynamic_lex $P5031, "$*PACKAGE-SETUP"
    unless_null $P5031, vivify_2367
    get_hll_global $P5031, "$PACKAGE-SETUP"
    unless_null $P5031, vivify_2368
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2368:
  vivify_2367:
    defined $I5032, $P5031
    unless $I5032, if_5030_end
.annotate 'line', 1812
    find_dynamic_lex $P5033, "$*PACKAGE-SETUP"
    unless_null $P5033, vivify_2369
    get_hll_global $P5033, "$PACKAGE-SETUP"
    unless_null $P5033, vivify_2370
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2370:
  vivify_2369:
    get_hll_global $P5034, ["PAST"], "Op"
.annotate 'line', 1814
    get_hll_global $P5035, ["PAST"], "Op"
.annotate 'line', 1816
    get_hll_global $P5036, ["PAST"], "Var"
    $P5037 = $P5036."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5038 = $P5035."new"($P5037, "get_how PP" :named("pirop"))
.annotate 'line', 1818
    get_hll_global $P5039, ["PAST"], "Var"
    $P5040 = $P5039."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1819
    get_hll_global $P5041, ["PAST"], "Val"
    find_lex $P5042, "$name"
    unless_null $P5042, vivify_2371
    new $P5042, "Undef"
  vivify_2371:
    $P5043 = $P5041."new"($P5042 :named("value"))
.annotate 'line', 1820
    get_hll_global $P5044, ["PAST"], "Val"
    find_lex $P5045, "$regex"
    unless_null $P5045, vivify_2372
    new $P5045, "Undef"
  vivify_2372:
    $P5046 = $P5044."new"($P5045 :named("value"))
    $P5047 = $P5034."new"($P5038, $P5040, $P5043, $P5046, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1812
    $P5033."push"($P5047)
.annotate 'line', 1822
    find_dynamic_lex $P5048, "$*PACKAGE-SETUP"
    unless_null $P5048, vivify_2373
    get_hll_global $P5048, "$PACKAGE-SETUP"
    unless_null $P5048, vivify_2374
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2374:
  vivify_2373:
    get_hll_global $P5049, ["PAST"], "Op"
.annotate 'line', 1824
    get_hll_global $P5050, ["PAST"], "Op"
.annotate 'line', 1826
    get_hll_global $P5051, ["PAST"], "Var"
    $P5052 = $P5051."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5053 = $P5050."new"($P5052, "get_how PP" :named("pirop"))
.annotate 'line', 1828
    get_hll_global $P5054, ["PAST"], "Var"
    $P5055 = $P5054."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1829
    get_hll_global $P5056, ["PAST"], "Val"
    new $P5057, "String"
    assign $P5057, "!PREFIX__"
    find_lex $P5058, "$name"
    unless_null $P5058, vivify_2375
    new $P5058, "Undef"
  vivify_2375:
    concat $P5059, $P5057, $P5058
    $P5060 = $P5056."new"($P5059 :named("value"))
.annotate 'line', 1830
    get_hll_global $P5061, ["PAST"], "Var"
    new $P5062, "String"
    assign $P5062, "!PREFIX__"
    find_lex $P5063, "$name"
    unless_null $P5063, vivify_2376
    new $P5063, "Undef"
  vivify_2376:
    concat $P5064, $P5062, $P5063
    $P5065 = $P5061."new"($P5064 :named("name"), "package" :named("scope"))
    $P5066 = $P5049."new"($P5053, $P5055, $P5060, $P5065, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1822
    $P5048."push"($P5066)
  if_5030_end:
.annotate 'line', 1834
    find_lex $P5067, "$regex"
    unless_null $P5067, vivify_2377
    new $P5067, "Undef"
  vivify_2377:
    find_lex $P5068, "$past"
    unless_null $P5068, vivify_2378
    $P5068 = root_new ['parrot';'Hash']
    store_lex "$past", $P5068
  vivify_2378:
    set $P5068["sink"], $P5067
.annotate 'line', 1835
    find_lex $P5069, "@MODIFIERS"
    unless_null $P5069, vivify_2379
    $P5069 = root_new ['parrot';'ResizablePMCArray']
  vivify_2379:
    $P5070 = $P5069."shift"()
.annotate 'line', 1801
    .return ($P5070)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4975"  :anon :subid("514_1303391609.928") :outer("512_1303391609.928")
.annotate 'line', 1792
    $P4977 = root_new ['parrot';'Hash']
    .lex "%h", $P4977
.annotate 'line', 1791
    find_lex $P4978, "%h"
    unless_null $P4978, vivify_2380
    $P4978 = root_new ['parrot';'Hash']
  vivify_2380:
.annotate 'line', 1793
    find_lex $P4980, "$/"
    unless_null $P4980, vivify_2381
    $P4980 = root_new ['parrot';'Hash']
  vivify_2381:
    set $P4981, $P4980["sym"]
    unless_null $P4981, vivify_2382
    new $P4981, "Undef"
  vivify_2382:
    set $S4982, $P4981
    iseq $I4983, $S4982, "token"
    unless $I4983, if_4979_end
    new $P4984, "Integer"
    assign $P4984, 1
    find_lex $P4985, "%h"
    unless_null $P4985, vivify_2383
    $P4985 = root_new ['parrot';'Hash']
    store_lex "%h", $P4985
  vivify_2383:
    set $P4985["r"], $P4984
  if_4979_end:
.annotate 'line', 1794
    find_lex $P4987, "$/"
    unless_null $P4987, vivify_2384
    $P4987 = root_new ['parrot';'Hash']
  vivify_2384:
    set $P4988, $P4987["sym"]
    unless_null $P4988, vivify_2385
    new $P4988, "Undef"
  vivify_2385:
    set $S4989, $P4988
    iseq $I4990, $S4989, "rule"
    unless $I4990, if_4986_end
    new $P4991, "Integer"
    assign $P4991, 1
    find_lex $P4992, "%h"
    unless_null $P4992, vivify_2386
    $P4992 = root_new ['parrot';'Hash']
    store_lex "%h", $P4992
  vivify_2386:
    set $P4992["r"], $P4991
    new $P4993, "Integer"
    assign $P4993, 1
    find_lex $P4994, "%h"
    unless_null $P4994, vivify_2387
    $P4994 = root_new ['parrot';'Hash']
    store_lex "%h", $P4994
  vivify_2387:
    set $P4994["s"], $P4993
  if_4986_end:
.annotate 'line', 1795
    find_lex $P4995, "@MODIFIERS"
    unless_null $P4995, vivify_2388
    $P4995 = root_new ['parrot';'ResizablePMCArray']
  vivify_2388:
    find_lex $P4996, "%h"
    unless_null $P4996, vivify_2389
    $P4996 = root_new ['parrot';'Hash']
  vivify_2389:
    $P4995."unshift"($P4996)
.annotate 'line', 1796
    find_lex $P4997, "$name"
    unless_null $P4997, vivify_2390
    new $P4997, "Undef"
  vivify_2390:
    get_hll_global $P4998, ["Regex";"P6Regex"], "Actions"
    get_who $P4999, $P4998
    set $P4999["$REGEXNAME"], $P4997
.annotate 'line', 1797
    find_lex $P5000, "$?PACKAGE"
    get_who $P5001, $P5000
    set $P5002, $P5001["@BLOCK"]
    unless_null $P5002, vivify_2391
    $P5002 = root_new ['parrot';'ResizablePMCArray']
  vivify_2391:
    set $P5003, $P5002[0]
    unless_null $P5003, vivify_2392
    new $P5003, "Undef"
  vivify_2392:
    $P5003."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1798
    find_lex $P5004, "$?PACKAGE"
    get_who $P5005, $P5004
    set $P5006, $P5005["@BLOCK"]
    unless_null $P5006, vivify_2393
    $P5006 = root_new ['parrot';'ResizablePMCArray']
  vivify_2393:
    set $P5007, $P5006[0]
    unless_null $P5007, vivify_2394
    new $P5007, "Undef"
  vivify_2394:
    $P5007."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1799
    new $P5008, "Exception"
    set $P5008['type'], .CONTROL_RETURN
    new $P5009, "Integer"
    assign $P5009, 0
    setattribute $P5008, 'payload', $P5009
    throw $P5008
.annotate 'line', 1791
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4948"  :anon :subid("513_1303391609.928") :outer("512_1303391609.928")
    .param pmc param_4950
.annotate 'line', 1778
    .lex "$_", param_4950
.annotate 'line', 1779
    find_dynamic_lex $P4951, "$*PACKAGE-SETUP"
    unless_null $P4951, vivify_2403
    get_hll_global $P4951, "$PACKAGE-SETUP"
    unless_null $P4951, vivify_2404
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2404:
  vivify_2403:
    get_hll_global $P4952, ["PAST"], "Op"
.annotate 'line', 1781
    get_hll_global $P4953, ["PAST"], "Op"
.annotate 'line', 1783
    get_hll_global $P4954, ["PAST"], "Var"
    $P4955 = $P4954."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4956 = $P4953."new"($P4955, "get_how PP" :named("pirop"))
.annotate 'line', 1785
    get_hll_global $P4957, ["PAST"], "Var"
    $P4958 = $P4957."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1786
    get_hll_global $P4959, ["PAST"], "Val"
    find_lex $P4960, "$_"
    unless_null $P4960, vivify_2405
    new $P4960, "Undef"
  vivify_2405:
    $P4961 = $P4960."name"()
    $P4962 = $P4959."new"($P4961 :named("value"))
.annotate 'line', 1787
    get_hll_global $P4963, ["PAST"], "Val"
    find_lex $P4964, "$_"
    unless_null $P4964, vivify_2406
    new $P4964, "Undef"
  vivify_2406:
    $P4965 = $P4963."new"($P4964 :named("value"))
    $P4966 = $P4952."new"($P4956, $P4958, $P4962, $P4965, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1779
    $P4967 = $P4951."push"($P4966)
.annotate 'line', 1778
    .return ($P4967)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("516_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5076
    .param pmc param_5077
.annotate 'line', 1841
    .lex "self", param_5076
    .lex "$/", param_5077
.annotate 'line', 1842
    new $P5078, "Undef"
    .lex "$past", $P5078
    find_lex $P5081, "$/"
    unless_null $P5081, vivify_2408
    $P5081 = root_new ['parrot';'Hash']
  vivify_2408:
    set $P5082, $P5081["args"]
    unless_null $P5082, vivify_2409
    new $P5082, "Undef"
  vivify_2409:
    if $P5082, if_5080
    get_hll_global $P5087, ["PAST"], "Op"
    find_lex $P5088, "$/"
    unless_null $P5088, vivify_2410
    new $P5088, "Undef"
  vivify_2410:
    $P5089 = $P5087."new"($P5088 :named("node"))
    set $P5079, $P5089
    goto if_5080_end
  if_5080:
    find_lex $P5083, "$/"
    unless_null $P5083, vivify_2411
    $P5083 = root_new ['parrot';'Hash']
  vivify_2411:
    set $P5084, $P5083["args"]
    unless_null $P5084, vivify_2412
    $P5084 = root_new ['parrot';'ResizablePMCArray']
  vivify_2412:
    set $P5085, $P5084[0]
    unless_null $P5085, vivify_2413
    new $P5085, "Undef"
  vivify_2413:
    $P5086 = $P5085."ast"()
    set $P5079, $P5086
  if_5080_end:
    store_lex "$past", $P5079
.annotate 'line', 1843
    find_lex $P5091, "$/"
    unless_null $P5091, vivify_2414
    $P5091 = root_new ['parrot';'Hash']
  vivify_2414:
    set $P5092, $P5091["quote"]
    unless_null $P5092, vivify_2415
    new $P5092, "Undef"
  vivify_2415:
    if $P5092, if_5090
.annotate 'line', 1847
    find_lex $P5099, "$/"
    unless_null $P5099, vivify_2416
    $P5099 = root_new ['parrot';'Hash']
  vivify_2416:
    set $P5100, $P5099["longname"]
    unless_null $P5100, vivify_2417
    new $P5100, "Undef"
  vivify_2417:
    set $S5101, $P5100
    iseq $I5102, $S5101, "HOW"
    if $I5102, if_5098
.annotate 'line', 1850
    find_lex $P5105, "$/"
    unless_null $P5105, vivify_2418
    $P5105 = root_new ['parrot';'Hash']
  vivify_2418:
    set $P5106, $P5105["longname"]
    unless_null $P5106, vivify_2419
    new $P5106, "Undef"
  vivify_2419:
    set $S5107, $P5106
    iseq $I5108, $S5107, "WHAT"
    if $I5108, if_5104
.annotate 'line', 1853
    find_lex $P5111, "$/"
    unless_null $P5111, vivify_2420
    $P5111 = root_new ['parrot';'Hash']
  vivify_2420:
    set $P5112, $P5111["longname"]
    unless_null $P5112, vivify_2421
    new $P5112, "Undef"
  vivify_2421:
    set $S5113, $P5112
    iseq $I5114, $S5113, "WHO"
    if $I5114, if_5110
.annotate 'line', 1857
    find_lex $P5116, "$past"
    unless_null $P5116, vivify_2422
    new $P5116, "Undef"
  vivify_2422:
    find_lex $P5117, "$/"
    unless_null $P5117, vivify_2423
    $P5117 = root_new ['parrot';'Hash']
  vivify_2423:
    set $P5118, $P5117["longname"]
    unless_null $P5118, vivify_2424
    new $P5118, "Undef"
  vivify_2424:
    set $S5119, $P5118
    $P5116."name"($S5119)
.annotate 'line', 1858
    find_lex $P5120, "$past"
    unless_null $P5120, vivify_2425
    new $P5120, "Undef"
  vivify_2425:
    $P5120."pasttype"("callmethod")
.annotate 'line', 1856
    goto if_5110_end
  if_5110:
.annotate 'line', 1854
    find_lex $P5115, "$past"
    unless_null $P5115, vivify_2426
    new $P5115, "Undef"
  vivify_2426:
    $P5115."pirop"("get_who PP")
  if_5110_end:
.annotate 'line', 1853
    goto if_5104_end
  if_5104:
.annotate 'line', 1851
    find_lex $P5109, "$past"
    unless_null $P5109, vivify_2427
    new $P5109, "Undef"
  vivify_2427:
    $P5109."pirop"("get_what PP")
  if_5104_end:
.annotate 'line', 1850
    goto if_5098_end
  if_5098:
.annotate 'line', 1848
    find_lex $P5103, "$past"
    unless_null $P5103, vivify_2428
    new $P5103, "Undef"
  vivify_2428:
    $P5103."pirop"("get_how PP")
  if_5098_end:
.annotate 'line', 1847
    goto if_5090_end
  if_5090:
.annotate 'line', 1844
    find_lex $P5093, "$past"
    unless_null $P5093, vivify_2429
    new $P5093, "Undef"
  vivify_2429:
    find_lex $P5094, "$/"
    unless_null $P5094, vivify_2430
    $P5094 = root_new ['parrot';'Hash']
  vivify_2430:
    set $P5095, $P5094["quote"]
    unless_null $P5095, vivify_2431
    new $P5095, "Undef"
  vivify_2431:
    $P5096 = $P5095."ast"()
    $P5093."name"($P5096)
.annotate 'line', 1845
    find_lex $P5097, "$past"
    unless_null $P5097, vivify_2432
    new $P5097, "Undef"
  vivify_2432:
    $P5097."pasttype"("callmethod")
  if_5090_end:
.annotate 'line', 1860
    find_lex $P5121, "$/"
    find_lex $P5122, "$past"
    unless_null $P5122, vivify_2433
    new $P5122, "Undef"
  vivify_2433:
    $P5123 = $P5121."!make"($P5122)
.annotate 'line', 1841
    .return ($P5123)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("517_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5125
    .param pmc param_5126
.annotate 'line', 1865
    .lex "self", param_5125
    .lex "$/", param_5126
.annotate 'line', 1866
    find_lex $P5127, "$/"
    get_hll_global $P5128, ["PAST"], "Var"
    $P5129 = $P5128."new"("self" :named("name"))
    $P5130 = $P5127."!make"($P5129)
.annotate 'line', 1865
    .return ($P5130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("518_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5132
    .param pmc param_5133
.annotate 'line', 1869
    .lex "self", param_5132
    .lex "$/", param_5133
.annotate 'line', 1870
    new $P5134, "Undef"
    .lex "$past", $P5134
    find_lex $P5135, "$/"
    unless_null $P5135, vivify_2434
    $P5135 = root_new ['parrot';'Hash']
  vivify_2434:
    set $P5136, $P5135["args"]
    unless_null $P5136, vivify_2435
    new $P5136, "Undef"
  vivify_2435:
    $P5137 = $P5136."ast"()
    store_lex "$past", $P5137
.annotate 'line', 1871
    find_lex $P5138, "$past"
    unless_null $P5138, vivify_2436
    new $P5138, "Undef"
  vivify_2436:
    find_lex $P5139, "$/"
    unless_null $P5139, vivify_2437
    $P5139 = root_new ['parrot';'Hash']
  vivify_2437:
    set $P5140, $P5139["deflongname"]
    unless_null $P5140, vivify_2438
    new $P5140, "Undef"
  vivify_2438:
    set $S5141, $P5140
    $P5138."name"($S5141)
.annotate 'line', 1872
    find_lex $P5142, "$/"
    find_lex $P5143, "$past"
    unless_null $P5143, vivify_2439
    new $P5143, "Undef"
  vivify_2439:
    $P5144 = $P5142."!make"($P5143)
.annotate 'line', 1869
    .return ($P5144)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("519_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5146
    .param pmc param_5147
.annotate 'line', 1875
    .const 'Sub' $P5162 = "520_1303391609.928" 
    capture_lex $P5162
    .lex "self", param_5146
    .lex "$/", param_5147
.annotate 'line', 1877
    new $P5148, "Undef"
    .lex "$var", $P5148
.annotate 'line', 1889
    new $P5149, "Undef"
    .lex "$past", $P5149
.annotate 'line', 1875
    find_lex $P5150, "$var"
    unless_null $P5150, vivify_2440
    new $P5150, "Undef"
  vivify_2440:
.annotate 'line', 1878
    find_lex $P5152, "$/"
    unless_null $P5152, vivify_2441
    $P5152 = root_new ['parrot';'Hash']
  vivify_2441:
    set $P5153, $P5152["name"]
    unless_null $P5153, vivify_2442
    new $P5153, "Undef"
  vivify_2442:
    set $S5154, $P5153
    $P5155 = "is_lexical"($S5154)
    if $P5155, if_5151
.annotate 'line', 1881
    .const 'Sub' $P5162 = "520_1303391609.928" 
    capture_lex $P5162
    $P5162()
    goto if_5151_end
  if_5151:
.annotate 'line', 1879
    get_hll_global $P5156, ["PAST"], "Var"
    find_lex $P5157, "$/"
    unless_null $P5157, vivify_2453
    $P5157 = root_new ['parrot';'Hash']
  vivify_2453:
    set $P5158, $P5157["name"]
    unless_null $P5158, vivify_2454
    new $P5158, "Undef"
  vivify_2454:
    set $S5159, $P5158
    $P5160 = $P5156."new"($S5159 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P5160
  if_5151_end:
.annotate 'line', 1889
    find_lex $P5185, "$var"
    unless_null $P5185, vivify_2455
    new $P5185, "Undef"
  vivify_2455:
    store_lex "$past", $P5185
.annotate 'line', 1890
    find_lex $P5187, "$/"
    unless_null $P5187, vivify_2456
    $P5187 = root_new ['parrot';'Hash']
  vivify_2456:
    set $P5188, $P5187["args"]
    unless_null $P5188, vivify_2457
    new $P5188, "Undef"
  vivify_2457:
    unless $P5188, if_5186_end
.annotate 'line', 1891
    find_lex $P5189, "$/"
    unless_null $P5189, vivify_2458
    $P5189 = root_new ['parrot';'Hash']
  vivify_2458:
    set $P5190, $P5189["args"]
    unless_null $P5190, vivify_2459
    $P5190 = root_new ['parrot';'ResizablePMCArray']
  vivify_2459:
    set $P5191, $P5190[0]
    unless_null $P5191, vivify_2460
    new $P5191, "Undef"
  vivify_2460:
    $P5192 = $P5191."ast"()
    store_lex "$past", $P5192
.annotate 'line', 1892
    find_lex $P5193, "$past"
    unless_null $P5193, vivify_2461
    new $P5193, "Undef"
  vivify_2461:
    find_lex $P5194, "$var"
    unless_null $P5194, vivify_2462
    new $P5194, "Undef"
  vivify_2462:
    $P5193."unshift"($P5194)
  if_5186_end:
.annotate 'line', 1894
    find_lex $P5195, "$/"
    find_lex $P5196, "$past"
    unless_null $P5196, vivify_2463
    new $P5196, "Undef"
  vivify_2463:
    $P5197 = $P5195."!make"($P5196)
.annotate 'line', 1875
    .return ($P5197)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5161"  :anon :subid("520_1303391609.928") :outer("519_1303391609.928")
.annotate 'line', 1882
    $P5163 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P5163
.annotate 'line', 1883
    new $P5164, "Undef"
    .lex "$name", $P5164
.annotate 'line', 1882
    find_lex $P5165, "$/"
    unless_null $P5165, vivify_2443
    $P5165 = root_new ['parrot';'Hash']
  vivify_2443:
    set $P5166, $P5165["name"]
    unless_null $P5166, vivify_2444
    $P5166 = root_new ['parrot';'Hash']
  vivify_2444:
    set $P5167, $P5166["identifier"]
    unless_null $P5167, vivify_2445
    new $P5167, "Undef"
  vivify_2445:
    clone $P5168, $P5167
    store_lex "@ns", $P5168
.annotate 'line', 1883
    find_lex $P5169, "@ns"
    unless_null $P5169, vivify_2446
    $P5169 = root_new ['parrot';'ResizablePMCArray']
  vivify_2446:
    $P5170 = $P5169."pop"()
    store_lex "$name", $P5170
.annotate 'line', 1884
    find_lex $P5174, "@ns"
    unless_null $P5174, vivify_2447
    $P5174 = root_new ['parrot';'ResizablePMCArray']
  vivify_2447:
    if $P5174, if_5173
    set $P5172, $P5174
    goto if_5173_end
  if_5173:
    find_lex $P5175, "@ns"
    unless_null $P5175, vivify_2448
    $P5175 = root_new ['parrot';'ResizablePMCArray']
  vivify_2448:
    set $P5176, $P5175[0]
    unless_null $P5176, vivify_2449
    new $P5176, "Undef"
  vivify_2449:
    set $S5177, $P5176
    iseq $I5178, $S5177, "GLOBAL"
    new $P5172, 'Integer'
    set $P5172, $I5178
  if_5173_end:
    unless $P5172, if_5171_end
    find_lex $P5179, "@ns"
    unless_null $P5179, vivify_2450
    $P5179 = root_new ['parrot';'ResizablePMCArray']
  vivify_2450:
    $P5179."shift"()
  if_5171_end:
.annotate 'line', 1885
    get_hll_global $P5180, ["PAST"], "Var"
    find_lex $P5181, "$name"
    unless_null $P5181, vivify_2451
    new $P5181, "Undef"
  vivify_2451:
    set $S5182, $P5181
    find_lex $P5183, "@ns"
    unless_null $P5183, vivify_2452
    $P5183 = root_new ['parrot';'ResizablePMCArray']
  vivify_2452:
    $P5184 = $P5180."new"($S5182 :named("name"), $P5183 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P5184
.annotate 'line', 1881
    .return ($P5184)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("521_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5199
    .param pmc param_5200
.annotate 'line', 1897
    .lex "self", param_5199
    .lex "$/", param_5200
.annotate 'line', 1898
    new $P5201, "Undef"
    .lex "$past", $P5201
.annotate 'line', 1899
    new $P5202, "Undef"
    .lex "$pirop", $P5202
.annotate 'line', 1898
    find_lex $P5205, "$/"
    unless_null $P5205, vivify_2464
    $P5205 = root_new ['parrot';'Hash']
  vivify_2464:
    set $P5206, $P5205["args"]
    unless_null $P5206, vivify_2465
    new $P5206, "Undef"
  vivify_2465:
    if $P5206, if_5204
    get_hll_global $P5211, ["PAST"], "Op"
    find_lex $P5212, "$/"
    unless_null $P5212, vivify_2466
    new $P5212, "Undef"
  vivify_2466:
    $P5213 = $P5211."new"($P5212 :named("node"))
    set $P5203, $P5213
    goto if_5204_end
  if_5204:
    find_lex $P5207, "$/"
    unless_null $P5207, vivify_2467
    $P5207 = root_new ['parrot';'Hash']
  vivify_2467:
    set $P5208, $P5207["args"]
    unless_null $P5208, vivify_2468
    $P5208 = root_new ['parrot';'ResizablePMCArray']
  vivify_2468:
    set $P5209, $P5208[0]
    unless_null $P5209, vivify_2469
    new $P5209, "Undef"
  vivify_2469:
    $P5210 = $P5209."ast"()
    set $P5203, $P5210
  if_5204_end:
    store_lex "$past", $P5203
.annotate 'line', 1899
    find_lex $P5214, "$/"
    unless_null $P5214, vivify_2470
    $P5214 = root_new ['parrot';'Hash']
  vivify_2470:
    set $P5215, $P5214["op"]
    unless_null $P5215, vivify_2471
    new $P5215, "Undef"
  vivify_2471:
    set $S5216, $P5215
    new $P5217, 'String'
    set $P5217, $S5216
    store_lex "$pirop", $P5217
.annotate 'line', 1900
    find_lex $P5218, "$pirop"
    unless_null $P5218, vivify_2472
    new $P5218, "Undef"
  vivify_2472:
    set $S5219, $P5218
    split $P5220, "__", $S5219
    join $S5221, " ", $P5220
    new $P5222, 'String'
    set $P5222, $S5221
    store_lex "$pirop", $P5222
.annotate 'line', 1901
    find_lex $P5223, "$past"
    unless_null $P5223, vivify_2473
    new $P5223, "Undef"
  vivify_2473:
    find_lex $P5224, "$pirop"
    unless_null $P5224, vivify_2474
    new $P5224, "Undef"
  vivify_2474:
    $P5223."pirop"($P5224)
.annotate 'line', 1902
    find_lex $P5225, "$past"
    unless_null $P5225, vivify_2475
    new $P5225, "Undef"
  vivify_2475:
    $P5225."pasttype"("pirop")
.annotate 'line', 1903
    find_lex $P5226, "$/"
    find_lex $P5227, "$past"
    unless_null $P5227, vivify_2476
    new $P5227, "Undef"
  vivify_2476:
    $P5228 = $P5226."!make"($P5227)
.annotate 'line', 1897
    .return ($P5228)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("522_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5230
    .param pmc param_5231
.annotate 'line', 1906
    .lex "self", param_5230
    .lex "$/", param_5231
.annotate 'line', 1907
    find_lex $P5232, "$/"
    get_hll_global $P5233, ["PAST"], "Op"
    $P5234 = $P5233."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P5235 = $P5232."!make"($P5234)
.annotate 'line', 1906
    .return ($P5235)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("523_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5237
    .param pmc param_5238
.annotate 'line', 1912
    .lex "self", param_5237
    .lex "$/", param_5238
    find_lex $P5239, "$/"
    find_lex $P5240, "$/"
    unless_null $P5240, vivify_2477
    $P5240 = root_new ['parrot';'Hash']
  vivify_2477:
    set $P5241, $P5240["arglist"]
    unless_null $P5241, vivify_2478
    new $P5241, "Undef"
  vivify_2478:
    $P5242 = $P5241."ast"()
    $P5243 = $P5239."!make"($P5242)
    .return ($P5243)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("524_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5245
    .param pmc param_5246
.annotate 'line', 1914
    .const 'Sub' $P5257 = "525_1303391609.928" 
    capture_lex $P5257
    .lex "self", param_5245
    .lex "$/", param_5246
.annotate 'line', 1915
    new $P5247, "Undef"
    .lex "$past", $P5247
.annotate 'line', 1923
    new $P5248, "Undef"
    .lex "$i", $P5248
.annotate 'line', 1924
    new $P5249, "Undef"
    .lex "$n", $P5249
.annotate 'line', 1915
    get_hll_global $P5250, ["PAST"], "Op"
    find_lex $P5251, "$/"
    unless_null $P5251, vivify_2479
    new $P5251, "Undef"
  vivify_2479:
    $P5252 = $P5250."new"("call" :named("pasttype"), $P5251 :named("node"))
    store_lex "$past", $P5252
.annotate 'line', 1916
    find_lex $P5254, "$/"
    unless_null $P5254, vivify_2480
    $P5254 = root_new ['parrot';'Hash']
  vivify_2480:
    set $P5255, $P5254["EXPR"]
    unless_null $P5255, vivify_2481
    new $P5255, "Undef"
  vivify_2481:
    unless $P5255, if_5253_end
    .const 'Sub' $P5257 = "525_1303391609.928" 
    capture_lex $P5257
    $P5257()
  if_5253_end:
.annotate 'line', 1923
    new $P5289, "Integer"
    assign $P5289, 0
    store_lex "$i", $P5289
.annotate 'line', 1924
    find_lex $P5290, "$past"
    unless_null $P5290, vivify_2492
    new $P5290, "Undef"
  vivify_2492:
    $P5291 = $P5290."list"()
    set $N5292, $P5291
    new $P5293, 'Float'
    set $P5293, $N5292
    store_lex "$n", $P5293
.annotate 'line', 1925
    new $P5341, 'ExceptionHandler'
    set_label $P5341, loop5340_handler
    $P5341."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5341
  loop5340_test:
    find_lex $P5294, "$i"
    unless_null $P5294, vivify_2493
    new $P5294, "Undef"
  vivify_2493:
    set $N5295, $P5294
    find_lex $P5296, "$n"
    unless_null $P5296, vivify_2494
    new $P5296, "Undef"
  vivify_2494:
    set $N5297, $P5296
    islt $I5298, $N5295, $N5297
    unless $I5298, loop5340_done
  loop5340_redo:
.annotate 'line', 1926
    find_lex $P5300, "$i"
    unless_null $P5300, vivify_2495
    new $P5300, "Undef"
  vivify_2495:
    set $I5301, $P5300
    find_lex $P5302, "$past"
    unless_null $P5302, vivify_2496
    $P5302 = root_new ['parrot';'ResizablePMCArray']
  vivify_2496:
    set $P5303, $P5302[$I5301]
    unless_null $P5303, vivify_2497
    new $P5303, "Undef"
  vivify_2497:
    $S5304 = $P5303."name"()
    iseq $I5305, $S5304, "&prefix:<|>"
    unless $I5305, if_5299_end
.annotate 'line', 1927
    find_lex $P5306, "$i"
    unless_null $P5306, vivify_2498
    new $P5306, "Undef"
  vivify_2498:
    set $I5307, $P5306
    find_lex $P5308, "$past"
    unless_null $P5308, vivify_2499
    $P5308 = root_new ['parrot';'ResizablePMCArray']
  vivify_2499:
    set $P5309, $P5308[$I5307]
    unless_null $P5309, vivify_2500
    $P5309 = root_new ['parrot';'ResizablePMCArray']
  vivify_2500:
    set $P5310, $P5309[0]
    unless_null $P5310, vivify_2501
    new $P5310, "Undef"
  vivify_2501:
    find_lex $P5311, "$i"
    unless_null $P5311, vivify_2502
    new $P5311, "Undef"
  vivify_2502:
    set $I5312, $P5311
    find_lex $P5313, "$past"
    unless_null $P5313, vivify_2503
    $P5313 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5313
  vivify_2503:
    set $P5313[$I5312], $P5310
.annotate 'line', 1928
    find_lex $P5314, "$i"
    unless_null $P5314, vivify_2504
    new $P5314, "Undef"
  vivify_2504:
    set $I5315, $P5314
    find_lex $P5316, "$past"
    unless_null $P5316, vivify_2505
    $P5316 = root_new ['parrot';'ResizablePMCArray']
  vivify_2505:
    set $P5317, $P5316[$I5315]
    unless_null $P5317, vivify_2506
    new $P5317, "Undef"
  vivify_2506:
    $P5317."flat"(1)
.annotate 'line', 1929
    find_lex $P5321, "$i"
    unless_null $P5321, vivify_2507
    new $P5321, "Undef"
  vivify_2507:
    set $I5322, $P5321
    find_lex $P5323, "$past"
    unless_null $P5323, vivify_2508
    $P5323 = root_new ['parrot';'ResizablePMCArray']
  vivify_2508:
    set $P5324, $P5323[$I5322]
    unless_null $P5324, vivify_2509
    new $P5324, "Undef"
  vivify_2509:
    get_hll_global $P5325, ["PAST"], "Val"
    $P5326 = $P5324."isa"($P5325)
    if $P5326, if_5320
    set $P5319, $P5326
    goto if_5320_end
  if_5320:
.annotate 'line', 1930
    find_lex $P5327, "$i"
    unless_null $P5327, vivify_2510
    new $P5327, "Undef"
  vivify_2510:
    set $I5328, $P5327
    find_lex $P5329, "$past"
    unless_null $P5329, vivify_2511
    $P5329 = root_new ['parrot';'ResizablePMCArray']
  vivify_2511:
    set $P5330, $P5329[$I5328]
    unless_null $P5330, vivify_2512
    new $P5330, "Undef"
  vivify_2512:
    $S5331 = $P5330."name"()
    substr $S5332, $S5331, 0, 1
    iseq $I5333, $S5332, "%"
    new $P5319, 'Integer'
    set $P5319, $I5333
  if_5320_end:
    unless $P5319, if_5318_end
.annotate 'line', 1931
    find_lex $P5334, "$i"
    unless_null $P5334, vivify_2513
    new $P5334, "Undef"
  vivify_2513:
    set $I5335, $P5334
    find_lex $P5336, "$past"
    unless_null $P5336, vivify_2514
    $P5336 = root_new ['parrot';'ResizablePMCArray']
  vivify_2514:
    set $P5337, $P5336[$I5335]
    unless_null $P5337, vivify_2515
    new $P5337, "Undef"
  vivify_2515:
    $P5337."named"(1)
  if_5318_end:
  if_5299_end:
.annotate 'line', 1926
    find_lex $P5338, "$i"
    unless_null $P5338, vivify_2516
    new $P5338, "Undef"
  vivify_2516:
    clone $P5339, $P5338
    inc $P5338
  loop5340_next:
.annotate 'line', 1925
    goto loop5340_test
  loop5340_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5342, exception, 'type'
    eq $P5342, .CONTROL_LOOP_NEXT, loop5340_next
    eq $P5342, .CONTROL_LOOP_REDO, loop5340_redo
  loop5340_done:
    pop_eh 
.annotate 'line', 1936
    find_lex $P5343, "$/"
    find_lex $P5344, "$past"
    unless_null $P5344, vivify_2517
    new $P5344, "Undef"
  vivify_2517:
    $P5345 = $P5343."!make"($P5344)
.annotate 'line', 1914
    .return ($P5345)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5256"  :anon :subid("525_1303391609.928") :outer("524_1303391609.928")
.annotate 'line', 1916
    .const 'Sub' $P5278 = "526_1303391609.928" 
    capture_lex $P5278
.annotate 'line', 1917
    new $P5258, "Undef"
    .lex "$expr", $P5258
    find_lex $P5259, "$/"
    unless_null $P5259, vivify_2482
    $P5259 = root_new ['parrot';'Hash']
  vivify_2482:
    set $P5260, $P5259["EXPR"]
    unless_null $P5260, vivify_2483
    new $P5260, "Undef"
  vivify_2483:
    $P5261 = $P5260."ast"()
    store_lex "$expr", $P5261
.annotate 'line', 1918
    find_lex $P5266, "$expr"
    unless_null $P5266, vivify_2484
    new $P5266, "Undef"
  vivify_2484:
    $S5267 = $P5266."name"()
    iseq $I5268, $S5267, "&infix:<,>"
    if $I5268, if_5265
    new $P5264, 'Integer'
    set $P5264, $I5268
    goto if_5265_end
  if_5265:
    find_lex $P5269, "$expr"
    unless_null $P5269, vivify_2485
    new $P5269, "Undef"
  vivify_2485:
    $P5270 = $P5269."named"()
    isfalse $I5271, $P5270
    new $P5264, 'Integer'
    set $P5264, $I5271
  if_5265_end:
    if $P5264, if_5263
.annotate 'line', 1921
    find_lex $P5286, "$past"
    unless_null $P5286, vivify_2486
    new $P5286, "Undef"
  vivify_2486:
    find_lex $P5287, "$expr"
    unless_null $P5287, vivify_2487
    new $P5287, "Undef"
  vivify_2487:
    $P5288 = $P5286."push"($P5287)
    set $P5262, $P5288
.annotate 'line', 1918
    goto if_5263_end
  if_5263:
.annotate 'line', 1919
    find_lex $P5273, "$expr"
    unless_null $P5273, vivify_2488
    new $P5273, "Undef"
  vivify_2488:
    $P5274 = $P5273."list"()
    defined $I5275, $P5274
    unless $I5275, for_undef_2489
    iter $P5272, $P5274
    new $P5284, 'ExceptionHandler'
    set_label $P5284, loop5283_handler
    $P5284."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5284
  loop5283_test:
    unless $P5272, loop5283_done
    shift $P5276, $P5272
  loop5283_redo:
    .const 'Sub' $P5278 = "526_1303391609.928" 
    capture_lex $P5278
    $P5278($P5276)
  loop5283_next:
    goto loop5283_test
  loop5283_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5285, exception, 'type'
    eq $P5285, .CONTROL_LOOP_NEXT, loop5283_next
    eq $P5285, .CONTROL_LOOP_REDO, loop5283_redo
  loop5283_done:
    pop_eh 
  for_undef_2489:
.annotate 'line', 1918
    set $P5262, $P5272
  if_5263_end:
.annotate 'line', 1916
    .return ($P5262)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5277"  :anon :subid("526_1303391609.928") :outer("525_1303391609.928")
    .param pmc param_5279
.annotate 'line', 1919
    .lex "$_", param_5279
    find_lex $P5280, "$past"
    unless_null $P5280, vivify_2490
    new $P5280, "Undef"
  vivify_2490:
    find_lex $P5281, "$_"
    unless_null $P5281, vivify_2491
    new $P5281, "Undef"
  vivify_2491:
    $P5282 = $P5280."push"($P5281)
    .return ($P5282)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("527_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5347
    .param pmc param_5348
.annotate 'line', 1939
    .lex "self", param_5347
    .lex "$/", param_5348
    find_lex $P5349, "$/"
    find_lex $P5350, "$/"
    unless_null $P5350, vivify_2518
    $P5350 = root_new ['parrot';'Hash']
  vivify_2518:
    set $P5351, $P5350["multi_declarator"]
    unless_null $P5351, vivify_2519
    new $P5351, "Undef"
  vivify_2519:
    $P5352 = $P5351."ast"()
    $P5353 = $P5349."!make"($P5352)
    .return ($P5353)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("528_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5355
    .param pmc param_5356
.annotate 'line', 1941
    .lex "self", param_5355
    .lex "$/", param_5356
    find_lex $P5357, "$/"
    find_lex $P5358, "$/"
    unless_null $P5358, vivify_2520
    $P5358 = root_new ['parrot';'Hash']
  vivify_2520:
    set $P5359, $P5358["value"]
    unless_null $P5359, vivify_2521
    new $P5359, "Undef"
  vivify_2521:
    $P5360 = $P5359."ast"()
    $P5361 = $P5357."!make"($P5360)
    .return ($P5361)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("529_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5363
    .param pmc param_5364
.annotate 'line', 1943
    .lex "self", param_5363
    .lex "$/", param_5364
.annotate 'line', 1944
    find_lex $P5365, "$/"
.annotate 'line', 1945
    find_lex $P5368, "$/"
    unless_null $P5368, vivify_2522
    $P5368 = root_new ['parrot';'Hash']
  vivify_2522:
    set $P5369, $P5368["EXPR"]
    unless_null $P5369, vivify_2523
    new $P5369, "Undef"
  vivify_2523:
    if $P5369, if_5367
.annotate 'line', 1946
    get_hll_global $P5374, ["PAST"], "Op"
    find_lex $P5375, "$/"
    unless_null $P5375, vivify_2524
    new $P5375, "Undef"
  vivify_2524:
    $P5376 = $P5374."new"("list" :named("pasttype"), $P5375 :named("node"))
    set $P5366, $P5376
.annotate 'line', 1945
    goto if_5367_end
  if_5367:
    find_lex $P5370, "$/"
    unless_null $P5370, vivify_2525
    $P5370 = root_new ['parrot';'Hash']
  vivify_2525:
    set $P5371, $P5370["EXPR"]
    unless_null $P5371, vivify_2526
    $P5371 = root_new ['parrot';'ResizablePMCArray']
  vivify_2526:
    set $P5372, $P5371[0]
    unless_null $P5372, vivify_2527
    new $P5372, "Undef"
  vivify_2527:
    $P5373 = $P5372."ast"()
    set $P5366, $P5373
  if_5367_end:
    $P5377 = $P5365."!make"($P5366)
.annotate 'line', 1943
    .return ($P5377)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("530_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5379
    .param pmc param_5380
.annotate 'line', 1949
    .lex "self", param_5379
    .lex "$/", param_5380
.annotate 'line', 1950
    new $P5381, "Undef"
    .lex "$past", $P5381
.annotate 'line', 1949
    find_lex $P5382, "$past"
    unless_null $P5382, vivify_2528
    new $P5382, "Undef"
  vivify_2528:
.annotate 'line', 1951
    find_lex $P5384, "$/"
    unless_null $P5384, vivify_2529
    $P5384 = root_new ['parrot';'Hash']
  vivify_2529:
    set $P5385, $P5384["EXPR"]
    unless_null $P5385, vivify_2530
    new $P5385, "Undef"
  vivify_2530:
    if $P5385, if_5383
.annotate 'line', 1958
    get_hll_global $P5397, ["PAST"], "Op"
    $P5398 = $P5397."new"("list" :named("pasttype"))
    store_lex "$past", $P5398
.annotate 'line', 1957
    goto if_5383_end
  if_5383:
.annotate 'line', 1952
    find_lex $P5386, "$/"
    unless_null $P5386, vivify_2531
    $P5386 = root_new ['parrot';'Hash']
  vivify_2531:
    set $P5387, $P5386["EXPR"]
    unless_null $P5387, vivify_2532
    $P5387 = root_new ['parrot';'ResizablePMCArray']
  vivify_2532:
    set $P5388, $P5387[0]
    unless_null $P5388, vivify_2533
    new $P5388, "Undef"
  vivify_2533:
    $P5389 = $P5388."ast"()
    store_lex "$past", $P5389
.annotate 'line', 1953
    find_lex $P5391, "$past"
    unless_null $P5391, vivify_2534
    new $P5391, "Undef"
  vivify_2534:
    $S5392 = $P5391."name"()
    isne $I5393, $S5392, "&infix:<,>"
    unless $I5393, if_5390_end
.annotate 'line', 1954
    get_hll_global $P5394, ["PAST"], "Op"
    find_lex $P5395, "$past"
    unless_null $P5395, vivify_2535
    new $P5395, "Undef"
  vivify_2535:
    $P5396 = $P5394."new"($P5395, "list" :named("pasttype"))
    store_lex "$past", $P5396
  if_5390_end:
  if_5383_end:
.annotate 'line', 1960
    find_lex $P5399, "$past"
    unless_null $P5399, vivify_2536
    new $P5399, "Undef"
  vivify_2536:
    $P5399."name"("&circumfix:<[ ]>")
.annotate 'line', 1961
    find_lex $P5400, "$/"
    find_lex $P5401, "$past"
    unless_null $P5401, vivify_2537
    new $P5401, "Undef"
  vivify_2537:
    $P5402 = $P5400."!make"($P5401)
.annotate 'line', 1949
    .return ($P5402)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("531_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5404
    .param pmc param_5405
.annotate 'line', 1964
    .lex "self", param_5404
    .lex "$/", param_5405
    find_lex $P5406, "$/"
    find_lex $P5407, "$/"
    unless_null $P5407, vivify_2538
    $P5407 = root_new ['parrot';'Hash']
  vivify_2538:
    set $P5408, $P5407["quote_EXPR"]
    unless_null $P5408, vivify_2539
    new $P5408, "Undef"
  vivify_2539:
    $P5409 = $P5408."ast"()
    $P5410 = $P5406."!make"($P5409)
    .return ($P5410)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("532_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5412
    .param pmc param_5413
.annotate 'line', 1965
    .lex "self", param_5412
    .lex "$/", param_5413
    find_lex $P5414, "$/"
    find_lex $P5415, "$/"
    unless_null $P5415, vivify_2540
    $P5415 = root_new ['parrot';'Hash']
  vivify_2540:
    set $P5416, $P5415["quote_EXPR"]
    unless_null $P5416, vivify_2541
    new $P5416, "Undef"
  vivify_2541:
    $P5417 = $P5416."ast"()
    $P5418 = $P5414."!make"($P5417)
    .return ($P5418)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("533_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5420
    .param pmc param_5421
.annotate 'line', 1967
    .const 'Sub' $P5432 = "534_1303391609.928" 
    capture_lex $P5432
    .lex "self", param_5420
    .lex "$/", param_5421
.annotate 'line', 1968
    find_lex $P5424, "$/"
    unless_null $P5424, vivify_2542
    $P5424 = root_new ['parrot';'Hash']
  vivify_2542:
    set $P5425, $P5424["pblock"]
    unless_null $P5425, vivify_2543
    $P5425 = root_new ['parrot';'Hash']
  vivify_2543:
    set $P5426, $P5425["blockoid"]
    unless_null $P5426, vivify_2544
    $P5426 = root_new ['parrot';'Hash']
  vivify_2544:
    set $P5427, $P5426["statementlist"]
    unless_null $P5427, vivify_2545
    $P5427 = root_new ['parrot';'Hash']
  vivify_2545:
    set $P5428, $P5427["statement"]
    unless_null $P5428, vivify_2546
    new $P5428, "Undef"
  vivify_2546:
    set $N5429, $P5428
    isgt $I5430, $N5429, 0.0
    if $I5430, if_5423
.annotate 'line', 1973
    find_lex $P5445, "$/"
    unless_null $P5445, vivify_2547
    $P5445 = root_new ['parrot';'Hash']
  vivify_2547:
    set $P5446, $P5445["pblock"]
    unless_null $P5446, vivify_2548
    $P5446 = root_new ['parrot';'Hash']
  vivify_2548:
    set $P5447, $P5446["blockoid"]
    unless_null $P5447, vivify_2549
    $P5447 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P5448, $P5447["you_are_here"]
    unless_null $P5448, vivify_2550
    new $P5448, "Undef"
  vivify_2550:
    if $P5448, if_5444
.annotate 'line', 1977
    find_lex $P5454, "$/"
    $P5455 = "vivitype"("%")
    $P5456 = $P5454."!make"($P5455)
.annotate 'line', 1976
    set $P5443, $P5456
.annotate 'line', 1973
    goto if_5444_end
  if_5444:
.annotate 'line', 1974
    find_lex $P5449, "$/"
    find_lex $P5450, "$/"
    unless_null $P5450, vivify_2551
    $P5450 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P5451, $P5450["pblock"]
    unless_null $P5451, vivify_2552
    new $P5451, "Undef"
  vivify_2552:
    $P5452 = $P5451."ast"()
    $P5453 = $P5449."!make"($P5452)
.annotate 'line', 1973
    set $P5443, $P5453
  if_5444_end:
    set $P5422, $P5443
.annotate 'line', 1968
    goto if_5423_end
  if_5423:
    .const 'Sub' $P5432 = "534_1303391609.928" 
    capture_lex $P5432
    $P5442 = $P5432()
    set $P5422, $P5442
  if_5423_end:
.annotate 'line', 1967
    .return ($P5422)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5431"  :anon :subid("534_1303391609.928") :outer("533_1303391609.928")
.annotate 'line', 1969
    new $P5433, "Undef"
    .lex "$past", $P5433
    find_lex $P5434, "$/"
    unless_null $P5434, vivify_2553
    $P5434 = root_new ['parrot';'Hash']
  vivify_2553:
    set $P5435, $P5434["pblock"]
    unless_null $P5435, vivify_2554
    new $P5435, "Undef"
  vivify_2554:
    $P5436 = $P5435."ast"()
    store_lex "$past", $P5436
.annotate 'line', 1970
    new $P5437, "Integer"
    assign $P5437, 1
    find_lex $P5438, "$past"
    unless_null $P5438, vivify_2555
    $P5438 = root_new ['parrot';'Hash']
    store_lex "$past", $P5438
  vivify_2555:
    set $P5438["bareblock"], $P5437
.annotate 'line', 1971
    find_dynamic_lex $P5439, "$/"
    find_lex $P5440, "$past"
    unless_null $P5440, vivify_2556
    new $P5440, "Undef"
  vivify_2556:
    $P5441 = $P5439."!make"($P5440)
.annotate 'line', 1968
    .return ($P5441)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("535_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5458
    .param pmc param_5459
.annotate 'line', 1981
    .lex "self", param_5458
    .lex "$/", param_5459
.annotate 'line', 1982
    new $P5460, "Undef"
    .lex "$name", $P5460
    find_lex $P5463, "$/"
    unless_null $P5463, vivify_2557
    $P5463 = root_new ['parrot';'Hash']
  vivify_2557:
    set $P5464, $P5463["sigil"]
    unless_null $P5464, vivify_2558
    new $P5464, "Undef"
  vivify_2558:
    set $S5465, $P5464
    iseq $I5466, $S5465, "@"
    if $I5466, if_5462
.annotate 'line', 1983
    find_lex $P5470, "$/"
    unless_null $P5470, vivify_2559
    $P5470 = root_new ['parrot';'Hash']
  vivify_2559:
    set $P5471, $P5470["sigil"]
    unless_null $P5471, vivify_2560
    new $P5471, "Undef"
  vivify_2560:
    set $S5472, $P5471
    iseq $I5473, $S5472, "%"
    if $I5473, if_5469
    new $P5475, "String"
    assign $P5475, "item"
    set $P5468, $P5475
    goto if_5469_end
  if_5469:
    new $P5474, "String"
    assign $P5474, "hash"
    set $P5468, $P5474
  if_5469_end:
    set $P5461, $P5468
.annotate 'line', 1982
    goto if_5462_end
  if_5462:
    new $P5467, "String"
    assign $P5467, "list"
    set $P5461, $P5467
  if_5462_end:
    store_lex "$name", $P5461
.annotate 'line', 1985
    find_lex $P5476, "$/"
    get_hll_global $P5477, ["PAST"], "Op"
    find_lex $P5478, "$name"
    unless_null $P5478, vivify_2561
    new $P5478, "Undef"
  vivify_2561:
    find_lex $P5479, "$/"
    unless_null $P5479, vivify_2562
    $P5479 = root_new ['parrot';'Hash']
  vivify_2562:
    set $P5480, $P5479["semilist"]
    unless_null $P5480, vivify_2563
    new $P5480, "Undef"
  vivify_2563:
    $P5481 = $P5480."ast"()
    $P5482 = $P5477."new"($P5481, "callmethod" :named("pasttype"), $P5478 :named("name"))
    $P5483 = $P5476."!make"($P5482)
.annotate 'line', 1981
    .return ($P5483)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("536_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5485
    .param pmc param_5486
.annotate 'line', 1988
    .lex "self", param_5485
    .lex "$/", param_5486
    find_lex $P5487, "$/"
    find_lex $P5488, "$/"
    unless_null $P5488, vivify_2564
    $P5488 = root_new ['parrot';'Hash']
  vivify_2564:
    set $P5489, $P5488["statement"]
    unless_null $P5489, vivify_2565
    new $P5489, "Undef"
  vivify_2565:
    $P5490 = $P5489."ast"()
    $P5491 = $P5487."!make"($P5490)
    .return ($P5491)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("537_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5493
    .param pmc param_5494
.annotate 'line', 1990
    .lex "self", param_5493
    .lex "$/", param_5494
.annotate 'line', 1991
    find_lex $P5495, "$/"
    get_hll_global $P5496, ["PAST"], "Var"
    find_lex $P5497, "$/"
    unless_null $P5497, vivify_2566
    $P5497 = root_new ['parrot';'Hash']
  vivify_2566:
    set $P5498, $P5497["EXPR"]
    unless_null $P5498, vivify_2567
    new $P5498, "Undef"
  vivify_2567:
    $P5499 = $P5498."ast"()
.annotate 'line', 1993
    $P5500 = "vivitype"("@")
    $P5501 = $P5496."new"($P5499, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5500 :named("vivibase"))
.annotate 'line', 1991
    $P5502 = $P5495."!make"($P5501)
.annotate 'line', 1990
    .return ($P5502)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("538_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5504
    .param pmc param_5505
.annotate 'line', 1996
    .lex "self", param_5504
    .lex "$/", param_5505
.annotate 'line', 1997
    find_lex $P5506, "$/"
    get_hll_global $P5507, ["PAST"], "Var"
    find_lex $P5508, "$/"
    unless_null $P5508, vivify_2568
    $P5508 = root_new ['parrot';'Hash']
  vivify_2568:
    set $P5509, $P5508["EXPR"]
    unless_null $P5509, vivify_2569
    new $P5509, "Undef"
  vivify_2569:
    $P5510 = $P5509."ast"()
.annotate 'line', 1999
    $P5511 = "vivitype"("%")
    $P5512 = $P5507."new"($P5510, "keyed" :named("scope"), "Undef" :named("viviself"), $P5511 :named("vivibase"))
.annotate 'line', 1997
    $P5513 = $P5506."!make"($P5512)
.annotate 'line', 1996
    .return ($P5513)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("539_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5515
    .param pmc param_5516
.annotate 'line', 2002
    .lex "self", param_5515
    .lex "$/", param_5516
.annotate 'line', 2003
    find_lex $P5517, "$/"
    get_hll_global $P5518, ["PAST"], "Var"
    find_lex $P5519, "$/"
    unless_null $P5519, vivify_2570
    $P5519 = root_new ['parrot';'Hash']
  vivify_2570:
    set $P5520, $P5519["quote_EXPR"]
    unless_null $P5520, vivify_2571
    new $P5520, "Undef"
  vivify_2571:
    $P5521 = $P5520."ast"()
.annotate 'line', 2005
    $P5522 = "vivitype"("%")
    $P5523 = $P5518."new"($P5521, "keyed" :named("scope"), "Undef" :named("viviself"), $P5522 :named("vivibase"))
.annotate 'line', 2003
    $P5524 = $P5517."!make"($P5523)
.annotate 'line', 2002
    .return ($P5524)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("540_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5526
    .param pmc param_5527
.annotate 'line', 2008
    .lex "self", param_5526
    .lex "$/", param_5527
.annotate 'line', 2009
    find_lex $P5528, "$/"
    find_lex $P5529, "$/"
    unless_null $P5529, vivify_2572
    $P5529 = root_new ['parrot';'Hash']
  vivify_2572:
    set $P5530, $P5529["arglist"]
    unless_null $P5530, vivify_2573
    new $P5530, "Undef"
  vivify_2573:
    $P5531 = $P5530."ast"()
    $P5532 = $P5528."!make"($P5531)
.annotate 'line', 2008
    .return ($P5532)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("541_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5534
    .param pmc param_5535
.annotate 'line', 2012
    .lex "self", param_5534
    .lex "$/", param_5535
.annotate 'line', 2013
    find_lex $P5536, "$/"
    find_lex $P5539, "$/"
    unless_null $P5539, vivify_2574
    $P5539 = root_new ['parrot';'Hash']
  vivify_2574:
    set $P5540, $P5539["quote"]
    unless_null $P5540, vivify_2575
    new $P5540, "Undef"
  vivify_2575:
    if $P5540, if_5538
    find_lex $P5544, "$/"
    unless_null $P5544, vivify_2576
    $P5544 = root_new ['parrot';'Hash']
  vivify_2576:
    set $P5545, $P5544["number"]
    unless_null $P5545, vivify_2577
    new $P5545, "Undef"
  vivify_2577:
    $P5546 = $P5545."ast"()
    set $P5537, $P5546
    goto if_5538_end
  if_5538:
    find_lex $P5541, "$/"
    unless_null $P5541, vivify_2578
    $P5541 = root_new ['parrot';'Hash']
  vivify_2578:
    set $P5542, $P5541["quote"]
    unless_null $P5542, vivify_2579
    new $P5542, "Undef"
  vivify_2579:
    $P5543 = $P5542."ast"()
    set $P5537, $P5543
  if_5538_end:
    $P5547 = $P5536."!make"($P5537)
.annotate 'line', 2012
    .return ($P5547)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("542_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5549
    .param pmc param_5550
.annotate 'line', 2016
    .lex "self", param_5549
    .lex "$/", param_5550
.annotate 'line', 2017
    new $P5551, "Undef"
    .lex "$value", $P5551
    find_lex $P5554, "$/"
    unless_null $P5554, vivify_2580
    $P5554 = root_new ['parrot';'Hash']
  vivify_2580:
    set $P5555, $P5554["dec_number"]
    unless_null $P5555, vivify_2581
    new $P5555, "Undef"
  vivify_2581:
    if $P5555, if_5553
    find_lex $P5559, "$/"
    unless_null $P5559, vivify_2582
    $P5559 = root_new ['parrot';'Hash']
  vivify_2582:
    set $P5560, $P5559["integer"]
    unless_null $P5560, vivify_2583
    new $P5560, "Undef"
  vivify_2583:
    $P5561 = $P5560."ast"()
    set $P5552, $P5561
    goto if_5553_end
  if_5553:
    find_lex $P5556, "$/"
    unless_null $P5556, vivify_2584
    $P5556 = root_new ['parrot';'Hash']
  vivify_2584:
    set $P5557, $P5556["dec_number"]
    unless_null $P5557, vivify_2585
    new $P5557, "Undef"
  vivify_2585:
    $P5558 = $P5557."ast"()
    set $P5552, $P5558
  if_5553_end:
    store_lex "$value", $P5552
.annotate 'line', 2018
    find_lex $P5563, "$/"
    unless_null $P5563, vivify_2586
    $P5563 = root_new ['parrot';'Hash']
  vivify_2586:
    set $P5564, $P5563["sign"]
    unless_null $P5564, vivify_2587
    new $P5564, "Undef"
  vivify_2587:
    set $S5565, $P5564
    iseq $I5566, $S5565, "-"
    unless $I5566, if_5562_end
    find_lex $P5567, "$value"
    unless_null $P5567, vivify_2588
    new $P5567, "Undef"
  vivify_2588:
    neg $P5568, $P5567
    store_lex "$value", $P5568
  if_5562_end:
.annotate 'line', 2019
    find_lex $P5569, "$/"
    get_hll_global $P5570, ["PAST"], "Val"
    find_lex $P5571, "$value"
    unless_null $P5571, vivify_2589
    new $P5571, "Undef"
  vivify_2589:
    $P5572 = $P5570."new"($P5571 :named("value"))
    $P5573 = $P5569."!make"($P5572)
.annotate 'line', 2016
    .return ($P5573)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("543_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5575
    .param pmc param_5576
.annotate 'line', 2022
    .lex "self", param_5575
    .lex "$/", param_5576
    find_lex $P5577, "$/"
    find_lex $P5578, "$/"
    unless_null $P5578, vivify_2590
    $P5578 = root_new ['parrot';'Hash']
  vivify_2590:
    set $P5579, $P5578["quote_EXPR"]
    unless_null $P5579, vivify_2591
    new $P5579, "Undef"
  vivify_2591:
    $P5580 = $P5579."ast"()
    $P5581 = $P5577."!make"($P5580)
    .return ($P5581)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("544_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5583
    .param pmc param_5584
.annotate 'line', 2023
    .lex "self", param_5583
    .lex "$/", param_5584
    find_lex $P5585, "$/"
    find_lex $P5586, "$/"
    unless_null $P5586, vivify_2592
    $P5586 = root_new ['parrot';'Hash']
  vivify_2592:
    set $P5587, $P5586["quote_EXPR"]
    unless_null $P5587, vivify_2593
    new $P5587, "Undef"
  vivify_2593:
    $P5588 = $P5587."ast"()
    $P5589 = $P5585."!make"($P5588)
    .return ($P5589)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("545_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5591
    .param pmc param_5592
.annotate 'line', 2024
    .lex "self", param_5591
    .lex "$/", param_5592
    find_lex $P5593, "$/"
    find_lex $P5594, "$/"
    unless_null $P5594, vivify_2594
    $P5594 = root_new ['parrot';'Hash']
  vivify_2594:
    set $P5595, $P5594["quote_EXPR"]
    unless_null $P5595, vivify_2595
    new $P5595, "Undef"
  vivify_2595:
    $P5596 = $P5595."ast"()
    $P5597 = $P5593."!make"($P5596)
    .return ($P5597)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("546_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5599
    .param pmc param_5600
.annotate 'line', 2025
    .lex "self", param_5599
    .lex "$/", param_5600
    find_lex $P5601, "$/"
    find_lex $P5602, "$/"
    unless_null $P5602, vivify_2596
    $P5602 = root_new ['parrot';'Hash']
  vivify_2596:
    set $P5603, $P5602["quote_EXPR"]
    unless_null $P5603, vivify_2597
    new $P5603, "Undef"
  vivify_2597:
    $P5604 = $P5603."ast"()
    $P5605 = $P5601."!make"($P5604)
    .return ($P5605)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("547_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5607
    .param pmc param_5608
.annotate 'line', 2026
    .lex "self", param_5607
    .lex "$/", param_5608
    find_lex $P5609, "$/"
    find_lex $P5610, "$/"
    unless_null $P5610, vivify_2598
    $P5610 = root_new ['parrot';'Hash']
  vivify_2598:
    set $P5611, $P5610["quote_EXPR"]
    unless_null $P5611, vivify_2599
    new $P5611, "Undef"
  vivify_2599:
    $P5612 = $P5611."ast"()
    $P5613 = $P5609."!make"($P5612)
    .return ($P5613)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("548_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5615
    .param pmc param_5616
.annotate 'line', 2027
    .lex "self", param_5615
    .lex "$/", param_5616
.annotate 'line', 2028
    find_lex $P5617, "$/"
    get_hll_global $P5618, ["PAST"], "Op"
    find_lex $P5619, "$/"
    unless_null $P5619, vivify_2600
    $P5619 = root_new ['parrot';'Hash']
  vivify_2600:
    set $P5620, $P5619["quote_EXPR"]
    unless_null $P5620, vivify_2601
    new $P5620, "Undef"
  vivify_2601:
    $P5621 = $P5620."ast"()
    $P5622 = $P5621."value"()
    find_lex $P5623, "$/"
    unless_null $P5623, vivify_2602
    new $P5623, "Undef"
  vivify_2602:
    $P5624 = $P5618."new"($P5622 :named("inline"), "inline" :named("pasttype"), $P5623 :named("node"))
    $P5625 = $P5617."!make"($P5624)
.annotate 'line', 2027
    .return ($P5625)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("549_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5629
    .param pmc param_5630
    .param pmc param_5631 :optional
    .param int has_param_5631 :opt_flag
.annotate 'line', 2033
    new $P5628, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5628, control_5627
    push_eh $P5628
    .lex "self", param_5629
    .lex "$/", param_5630
    if has_param_5631, optparam_2603
    new $P5632, "Undef"
    set param_5631, $P5632
  optparam_2603:
    .lex "$key", param_5631
.annotate 'line', 2040
    new $P5633, "Undef"
    .lex "$regex", $P5633
.annotate 'line', 2042
    new $P5634, "Undef"
    .lex "$past", $P5634
.annotate 'line', 2034
    find_lex $P5636, "$key"
    unless_null $P5636, vivify_2604
    new $P5636, "Undef"
  vivify_2604:
    set $S5637, $P5636
    iseq $I5638, $S5637, "open"
    unless $I5638, if_5635_end
.annotate 'line', 2035
    null $P5639
    get_hll_global $P5640, ["Regex";"P6Regex"], "Actions"
    get_who $P5641, $P5640
    set $P5641["$REGEXNAME"], $P5639
.annotate 'line', 2036
    find_lex $P5642, "$?PACKAGE"
    get_who $P5643, $P5642
    set $P5644, $P5643["@BLOCK"]
    unless_null $P5644, vivify_2605
    $P5644 = root_new ['parrot';'ResizablePMCArray']
  vivify_2605:
    set $P5645, $P5644[0]
    unless_null $P5645, vivify_2606
    new $P5645, "Undef"
  vivify_2606:
    $P5645."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2037
    find_lex $P5646, "$?PACKAGE"
    get_who $P5647, $P5646
    set $P5648, $P5647["@BLOCK"]
    unless_null $P5648, vivify_2607
    $P5648 = root_new ['parrot';'ResizablePMCArray']
  vivify_2607:
    set $P5649, $P5648[0]
    unless_null $P5649, vivify_2608
    new $P5649, "Undef"
  vivify_2608:
    $P5649."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2038
    new $P5650, "Exception"
    set $P5650['type'], .CONTROL_RETURN
    new $P5651, "Integer"
    assign $P5651, 0
    setattribute $P5650, 'payload', $P5651
    throw $P5650
  if_5635_end:
.annotate 'line', 2041
    get_hll_global $P5652, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5653, "$/"
    unless_null $P5653, vivify_2609
    $P5653 = root_new ['parrot';'Hash']
  vivify_2609:
    set $P5654, $P5653["p6regex"]
    unless_null $P5654, vivify_2610
    new $P5654, "Undef"
  vivify_2610:
    $P5655 = $P5654."ast"()
    find_lex $P5656, "$?PACKAGE"
    get_who $P5657, $P5656
    set $P5658, $P5657["@BLOCK"]
    unless_null $P5658, vivify_2611
    $P5658 = root_new ['parrot';'ResizablePMCArray']
  vivify_2611:
    $P5659 = $P5658."shift"()
    $P5660 = $P5652($P5655, $P5659)
    store_lex "$regex", $P5660
.annotate 'line', 2043
    get_hll_global $P5661, ["PAST"], "Op"
.annotate 'line', 2045
    get_hll_global $P5662, ["PAST"], "Var"
    new $P5663, "ResizablePMCArray"
    push $P5663, "Regex"
    $P5664 = $P5662."new"("Regex" :named("name"), $P5663 :named("namespace"), "package" :named("scope"))
    find_lex $P5665, "$regex"
    unless_null $P5665, vivify_2612
    new $P5665, "Undef"
  vivify_2612:
    $P5666 = $P5661."new"($P5664, $P5665, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2043
    store_lex "$past", $P5666
.annotate 'line', 2049
    find_lex $P5667, "$regex"
    unless_null $P5667, vivify_2613
    new $P5667, "Undef"
  vivify_2613:
    find_lex $P5668, "$past"
    unless_null $P5668, vivify_2614
    $P5668 = root_new ['parrot';'Hash']
    store_lex "$past", $P5668
  vivify_2614:
    set $P5668["sink"], $P5667
.annotate 'line', 2050
    find_lex $P5669, "$/"
    find_lex $P5670, "$past"
    unless_null $P5670, vivify_2615
    new $P5670, "Undef"
  vivify_2615:
    $P5671 = $P5669."!make"($P5670)
.annotate 'line', 2033
    .return ($P5671)
  control_5627:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5672, exception, "payload"
    .return ($P5672)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("550_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5674
    .param pmc param_5675
.annotate 'line', 2053
    .lex "self", param_5674
    .lex "$/", param_5675
    find_lex $P5676, "$/"
    find_lex $P5677, "$/"
    unless_null $P5677, vivify_2616
    $P5677 = root_new ['parrot';'Hash']
  vivify_2616:
    set $P5678, $P5677["variable"]
    unless_null $P5678, vivify_2617
    new $P5678, "Undef"
  vivify_2617:
    $P5679 = $P5678."ast"()
    $P5680 = $P5676."!make"($P5679)
    .return ($P5680)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("551_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5682
    .param pmc param_5683
.annotate 'line', 2054
    .lex "self", param_5682
    .lex "$/", param_5683
.annotate 'line', 2055
    find_lex $P5684, "$/"
    get_hll_global $P5685, ["PAST"], "Op"
.annotate 'line', 2056
    find_lex $P5686, "$/"
    unless_null $P5686, vivify_2618
    $P5686 = root_new ['parrot';'Hash']
  vivify_2618:
    set $P5687, $P5686["block"]
    unless_null $P5687, vivify_2619
    new $P5687, "Undef"
  vivify_2619:
    $P5688 = $P5687."ast"()
    $P5689 = "block_immediate"($P5688)
    find_lex $P5690, "$/"
    unless_null $P5690, vivify_2620
    new $P5690, "Undef"
  vivify_2620:
    $P5691 = $P5685."new"($P5689, "set S*" :named("pirop"), $P5690 :named("node"))
.annotate 'line', 2055
    $P5692 = $P5684."!make"($P5691)
.annotate 'line', 2054
    .return ($P5692)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("552_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5694
    .param pmc param_5695
.annotate 'line', 2059
    .lex "self", param_5694
    .lex "$/", param_5695
    find_lex $P5696, "$/"
    $P5697 = $P5696."!make"("\e")
    .return ($P5697)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("553_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5699
    .param pmc param_5700
.annotate 'line', 2063
    .lex "self", param_5699
    .lex "$/", param_5700
    find_lex $P5701, "$/"
    find_lex $P5702, "$/"
    unless_null $P5702, vivify_2621
    $P5702 = root_new ['parrot';'Hash']
  vivify_2621:
    set $P5703, $P5702["dotty"]
    unless_null $P5703, vivify_2622
    new $P5703, "Undef"
  vivify_2622:
    $P5704 = $P5703."ast"()
    $P5705 = $P5701."!make"($P5704)
    .return ($P5705)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("554_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5707
    .param pmc param_5708
.annotate 'line', 2065
    .lex "self", param_5707
    .lex "$/", param_5708
.annotate 'line', 2066
    find_lex $P5709, "$/"
    get_hll_global $P5710, ["PAST"], "Op"
.annotate 'line', 2067
    new $P5711, "ResizablePMCArray"
    push $P5711, "    clone %r, %0"
    push $P5711, "    inc %0"
    $P5712 = $P5710."new"("postfix:<++>" :named("name"), $P5711 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2066
    $P5713 = $P5709."!make"($P5712)
.annotate 'line', 2065
    .return ($P5713)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("555_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5715
    .param pmc param_5716
.annotate 'line', 2071
    .lex "self", param_5715
    .lex "$/", param_5716
.annotate 'line', 2072
    find_lex $P5717, "$/"
    get_hll_global $P5718, ["PAST"], "Op"
.annotate 'line', 2073
    new $P5719, "ResizablePMCArray"
    push $P5719, "    clone %r, %0"
    push $P5719, "    dec %0"
    $P5720 = $P5718."new"("postfix:<-->" :named("name"), $P5719 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2072
    $P5721 = $P5717."!make"($P5720)
.annotate 'line', 2071
    .return ($P5721)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("556_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5723
    .param pmc param_5724
.annotate 'line', 2077
    .lex "self", param_5723
    .lex "$/", param_5724
.annotate 'line', 2078
    find_lex $P5725, "$/"
    get_hll_global $P5726, ["PAST"], "Op"
.annotate 'line', 2079
    get_hll_global $P5727, ["PAST"], "Var"
    $P5728 = $P5727."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5729, "$/"
    unless_null $P5729, vivify_2623
    new $P5729, "Undef"
  vivify_2623:
    $P5730 = $P5726."new"($P5728, "callmethod" :named("pasttype"), "!make" :named("name"), $P5729 :named("node"))
.annotate 'line', 2078
    $P5731 = $P5725."!make"($P5730)
.annotate 'line', 2077
    .return ($P5731)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("557_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5734
    .param pmc param_5735
.annotate 'line', 2095
    .lex "self", param_5734
    .lex "$/", param_5735
    find_lex $P5736, "$/"
    unless_null $P5736, vivify_2624
    new $P5736, "Undef"
  vivify_2624:
    $P5737 = "control"($P5736, "CONTROL_LOOP_NEXT")
    .return ($P5737)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("558_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5739
    .param pmc param_5740
.annotate 'line', 2096
    .lex "self", param_5739
    .lex "$/", param_5740
    find_lex $P5741, "$/"
    unless_null $P5741, vivify_2625
    new $P5741, "Undef"
  vivify_2625:
    $P5742 = "control"($P5741, "CONTROL_LOOP_LAST")
    .return ($P5742)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("559_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5744
    .param pmc param_5745
.annotate 'line', 2097
    .lex "self", param_5744
    .lex "$/", param_5745
    find_lex $P5746, "$/"
    unless_null $P5746, vivify_2626
    new $P5746, "Undef"
  vivify_2626:
    $P5747 = "control"($P5746, "CONTROL_LOOP_REDO")
    .return ($P5747)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("560_1303391609.928") :outer("406_1303391609.928")
    .param pmc param_5749
    .param pmc param_5750
.annotate 'line', 2099
    .lex "self", param_5749
    .lex "$/", param_5750
.annotate 'line', 2100
    find_lex $P5751, "$/"
    get_hll_global $P5752, ["PAST"], "Op"
    find_lex $P5753, "$/"
    unless_null $P5753, vivify_2627
    new $P5753, "Undef"
  vivify_2627:
    $P5754 = $P5752."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P5753 :named("node"))
    $P5755 = $P5751."!make"($P5754)
.annotate 'line', 2099
    .return ($P5755)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block5985"  :subid("562_1303391609.928") :outer("10_1303391609.928")
.annotate 'line', 2173
    .const 'Sub' $P6086 = "570_1303391609.928" 
    capture_lex $P6086
    .const 'Sub' $P6061 = "569_1303391609.928" 
    capture_lex $P6061
    .const 'Sub' $P6050 = "568_1303391609.928" 
    capture_lex $P6050
    .const 'Sub' $P6035 = "567_1303391609.928" 
    capture_lex $P6035
    .const 'Sub' $P6024 = "566_1303391609.928" 
    capture_lex $P6024
    .const 'Sub' $P6013 = "565_1303391609.928" 
    capture_lex $P6013
    .const 'Sub' $P6002 = "564_1303391609.928" 
    capture_lex $P6002
    .const 'Sub' $P5989 = "563_1303391609.928" 
    capture_lex $P5989
    .lex "$?PACKAGE", $P5987
    .lex "$?CLASS", $P5988
.annotate 'line', 2207
    .const 'Sub' $P6061 = "569_1303391609.928" 
    newclosure $P6084, $P6061
.annotate 'line', 2173
    .return ($P6084)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2628") :outer("562_1303391609.928")
.annotate 'line', 2173
    get_hll_global $P5986, ["NQP";"RegexActions"], "_block5985" 
    .local pmc block
    set block, $P5986
    .const 'Sub' $P6086 = "570_1303391609.928" 
    capture_lex $P6086
    $P6086()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6085"  :anon :subid("570_1303391609.928") :outer("562_1303391609.928")
.annotate 'line', 2173
    nqp_get_sc_object $P6087, "1303391598.821", 4
    .local pmc type_obj
    set type_obj, $P6087
    get_how $P6088, type_obj
    .const 'Sub' $P6089 = "563_1303391609.928" 
    $P6088."add_method"(type_obj, "metachar:sym<:my>", $P6089)
    get_how $P6090, type_obj
    .const 'Sub' $P6091 = "564_1303391609.928" 
    $P6090."add_method"(type_obj, "metachar:sym<{ }>", $P6091)
    get_how $P6092, type_obj
    .const 'Sub' $P6093 = "565_1303391609.928" 
    $P6092."add_method"(type_obj, "metachar:sym<nqpvar>", $P6093)
    get_how $P6094, type_obj
    .const 'Sub' $P6095 = "566_1303391609.928" 
    $P6094."add_method"(type_obj, "assertion:sym<{ }>", $P6095)
    get_how $P6096, type_obj
    .const 'Sub' $P6097 = "567_1303391609.928" 
    $P6096."add_method"(type_obj, "assertion:sym<?{ }>", $P6097)
    get_how $P6098, type_obj
    .const 'Sub' $P6099 = "568_1303391609.928" 
    $P6098."add_method"(type_obj, "assertion:sym<var>", $P6099)
    get_how $P6100, type_obj
    .const 'Sub' $P6101 = "569_1303391609.928" 
    $P6100."add_method"(type_obj, "codeblock", $P6101)
    get_how $P6102, type_obj
    get_hll_global $P6103, ["Regex";"P6Regex"], "Actions"
    $P6102."add_parent"(type_obj, $P6103)
    get_how $P6104, type_obj
    $P6105 = $P6104."compose"(type_obj)
    .return ($P6105)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("563_1303391609.928") :outer("562_1303391609.928")
    .param pmc param_5990
    .param pmc param_5991
.annotate 'line', 2175
    .lex "self", param_5990
    .lex "$/", param_5991
.annotate 'line', 2176
    new $P5992, "Undef"
    .lex "$past", $P5992
    find_lex $P5993, "$/"
    unless_null $P5993, vivify_2629
    $P5993 = root_new ['parrot';'Hash']
  vivify_2629:
    set $P5994, $P5993["statement"]
    unless_null $P5994, vivify_2630
    new $P5994, "Undef"
  vivify_2630:
    $P5995 = $P5994."ast"()
    store_lex "$past", $P5995
.annotate 'line', 2177
    find_lex $P5996, "$/"
    get_hll_global $P5997, ["PAST"], "Regex"
    find_lex $P5998, "$past"
    unless_null $P5998, vivify_2631
    new $P5998, "Undef"
  vivify_2631:
    find_lex $P5999, "$/"
    unless_null $P5999, vivify_2632
    new $P5999, "Undef"
  vivify_2632:
    $P6000 = $P5997."new"($P5998, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P5999 :named("node"))
    $P6001 = $P5996."!make"($P6000)
.annotate 'line', 2175
    .return ($P6001)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("564_1303391609.928") :outer("562_1303391609.928")
    .param pmc param_6003
    .param pmc param_6004
.annotate 'line', 2181
    .lex "self", param_6003
    .lex "$/", param_6004
.annotate 'line', 2182
    find_lex $P6005, "$/"
    get_hll_global $P6006, ["PAST"], "Regex"
    find_lex $P6007, "$/"
    unless_null $P6007, vivify_2633
    $P6007 = root_new ['parrot';'Hash']
  vivify_2633:
    set $P6008, $P6007["codeblock"]
    unless_null $P6008, vivify_2634
    new $P6008, "Undef"
  vivify_2634:
    $P6009 = $P6008."ast"()
    find_lex $P6010, "$/"
    unless_null $P6010, vivify_2635
    new $P6010, "Undef"
  vivify_2635:
    $P6011 = $P6006."new"($P6009, "pastnode" :named("pasttype"), $P6010 :named("node"))
    $P6012 = $P6005."!make"($P6011)
.annotate 'line', 2181
    .return ($P6012)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("565_1303391609.928") :outer("562_1303391609.928")
    .param pmc param_6014
    .param pmc param_6015
.annotate 'line', 2186
    .lex "self", param_6014
    .lex "$/", param_6015
.annotate 'line', 2187
    find_lex $P6016, "$/"
    get_hll_global $P6017, ["PAST"], "Regex"
    find_lex $P6018, "$/"
    unless_null $P6018, vivify_2636
    $P6018 = root_new ['parrot';'Hash']
  vivify_2636:
    set $P6019, $P6018["var"]
    unless_null $P6019, vivify_2637
    new $P6019, "Undef"
  vivify_2637:
    $P6020 = $P6019."ast"()
    find_lex $P6021, "$/"
    unless_null $P6021, vivify_2638
    new $P6021, "Undef"
  vivify_2638:
    $P6022 = $P6017."new"("!INTERPOLATE", $P6020, "subrule" :named("pasttype"), "method" :named("subtype"), $P6021 :named("node"))
    $P6023 = $P6016."!make"($P6022)
.annotate 'line', 2186
    .return ($P6023)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("566_1303391609.928") :outer("562_1303391609.928")
    .param pmc param_6025
    .param pmc param_6026
.annotate 'line', 2191
    .lex "self", param_6025
    .lex "$/", param_6026
.annotate 'line', 2192
    find_lex $P6027, "$/"
    get_hll_global $P6028, ["PAST"], "Regex"
    find_lex $P6029, "$/"
    unless_null $P6029, vivify_2639
    $P6029 = root_new ['parrot';'Hash']
  vivify_2639:
    set $P6030, $P6029["codeblock"]
    unless_null $P6030, vivify_2640
    new $P6030, "Undef"
  vivify_2640:
    $P6031 = $P6030."ast"()
    find_lex $P6032, "$/"
    unless_null $P6032, vivify_2641
    new $P6032, "Undef"
  vivify_2641:
    $P6033 = $P6028."new"("!INTERPOLATE_REGEX", $P6031, "subrule" :named("pasttype"), "method" :named("subtype"), $P6032 :named("node"))
    $P6034 = $P6027."!make"($P6033)
.annotate 'line', 2191
    .return ($P6034)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("567_1303391609.928") :outer("562_1303391609.928")
    .param pmc param_6036
    .param pmc param_6037
.annotate 'line', 2196
    .lex "self", param_6036
    .lex "$/", param_6037
.annotate 'line', 2197
    find_lex $P6038, "$/"
    get_hll_global $P6039, ["PAST"], "Regex"
    find_lex $P6040, "$/"
    unless_null $P6040, vivify_2642
    $P6040 = root_new ['parrot';'Hash']
  vivify_2642:
    set $P6041, $P6040["codeblock"]
    unless_null $P6041, vivify_2643
    new $P6041, "Undef"
  vivify_2643:
    $P6042 = $P6041."ast"()
.annotate 'line', 2198
    find_lex $P6043, "$/"
    unless_null $P6043, vivify_2644
    $P6043 = root_new ['parrot';'Hash']
  vivify_2644:
    set $P6044, $P6043["zw"]
    unless_null $P6044, vivify_2645
    new $P6044, "Undef"
  vivify_2645:
    set $S6045, $P6044
    iseq $I6046, $S6045, "!"
    find_lex $P6047, "$/"
    unless_null $P6047, vivify_2646
    new $P6047, "Undef"
  vivify_2646:
    $P6048 = $P6039."new"($P6042, "zerowidth" :named("subtype"), $I6046 :named("negate"), "pastnode" :named("pasttype"), $P6047 :named("node"))
.annotate 'line', 2197
    $P6049 = $P6038."!make"($P6048)
.annotate 'line', 2196
    .return ($P6049)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("568_1303391609.928") :outer("562_1303391609.928")
    .param pmc param_6051
    .param pmc param_6052
.annotate 'line', 2202
    .lex "self", param_6051
    .lex "$/", param_6052
.annotate 'line', 2203
    find_lex $P6053, "$/"
    get_hll_global $P6054, ["PAST"], "Regex"
    find_lex $P6055, "$/"
    unless_null $P6055, vivify_2647
    $P6055 = root_new ['parrot';'Hash']
  vivify_2647:
    set $P6056, $P6055["var"]
    unless_null $P6056, vivify_2648
    new $P6056, "Undef"
  vivify_2648:
    $P6057 = $P6056."ast"()
    find_lex $P6058, "$/"
    unless_null $P6058, vivify_2649
    new $P6058, "Undef"
  vivify_2649:
    $P6059 = $P6054."new"("!INTERPOLATE_REGEX", $P6057, "subrule" :named("pasttype"), "method" :named("subtype"), $P6058 :named("node"))
    $P6060 = $P6053."!make"($P6059)
.annotate 'line', 2202
    .return ($P6060)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("569_1303391609.928") :outer("562_1303391609.928")
    .param pmc param_6062
    .param pmc param_6063
.annotate 'line', 2207
    .lex "self", param_6062
    .lex "$/", param_6063
.annotate 'line', 2208
    new $P6064, "Undef"
    .lex "$block", $P6064
.annotate 'line', 2210
    new $P6065, "Undef"
    .lex "$past", $P6065
.annotate 'line', 2208
    find_lex $P6066, "$/"
    unless_null $P6066, vivify_2650
    $P6066 = root_new ['parrot';'Hash']
  vivify_2650:
    set $P6067, $P6066["block"]
    unless_null $P6067, vivify_2651
    new $P6067, "Undef"
  vivify_2651:
    $P6068 = $P6067."ast"()
    store_lex "$block", $P6068
.annotate 'line', 2209
    find_lex $P6069, "$block"
    unless_null $P6069, vivify_2652
    new $P6069, "Undef"
  vivify_2652:
    $P6069."blocktype"("immediate")
.annotate 'line', 2211
    get_hll_global $P6070, ["PAST"], "Stmts"
.annotate 'line', 2212
    get_hll_global $P6071, ["PAST"], "Op"
.annotate 'line', 2213
    get_hll_global $P6072, ["PAST"], "Var"
    $P6073 = $P6072."new"("$/" :named("name"))
.annotate 'line', 2214
    get_hll_global $P6074, ["PAST"], "Op"
.annotate 'line', 2215
    get_hll_global $P6075, ["PAST"], "Var"
    $P6076 = $P6075."new"(unicode:"$\x{a2}" :named("name"))
    $P6077 = $P6074."new"($P6076, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2214
    $P6078 = $P6071."new"($P6073, $P6077, "bind" :named("pasttype"))
.annotate 'line', 2212
    find_lex $P6079, "$block"
    unless_null $P6079, vivify_2653
    new $P6079, "Undef"
  vivify_2653:
    $P6080 = $P6070."new"($P6078, $P6079)
.annotate 'line', 2211
    store_lex "$past", $P6080
.annotate 'line', 2223
    find_lex $P6081, "$/"
    find_lex $P6082, "$past"
    unless_null $P6082, vivify_2654
    new $P6082, "Undef"
  vivify_2654:
    $P6083 = $P6081."!make"($P6082)
.annotate 'line', 2207
    .return ($P6083)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6106"  :subid("571_1303391609.928") :outer("10_1303391609.928")
.annotate 'line', 2228
    .const 'Sub' $P6111 = "572_1303391609.928" 
    capture_lex $P6111
    .lex "$?PACKAGE", $P6108
    .lex "$?CLASS", $P6109
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2655") :outer("571_1303391609.928")
.annotate 'line', 2228
    get_hll_global $P6107, ["NQP";"Compiler"], "_block6106" 
    .local pmc block
    set block, $P6107
    .const 'Sub' $P6111 = "572_1303391609.928" 
    capture_lex $P6111
    $P6111()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6110"  :anon :subid("572_1303391609.928") :outer("571_1303391609.928")
.annotate 'line', 2228
    nqp_get_sc_object $P6112, "1303391598.821", 5
    .local pmc type_obj
    set type_obj, $P6112
    get_how $P6113, type_obj
    get_hll_global $P6114, ["HLL"], "Compiler"
    $P6113."add_parent"(type_obj, $P6114)
    get_how $P6115, type_obj
    $P6116 = $P6115."compose"(type_obj)
    .return ($P6116)
.end


.HLL "nqp"

.namespace []
.sub "_block6124" :load :anon :subid("573_1303391609.928")
.annotate 'line', 1
    .const 'Sub' $P6126 = "10_1303391609.928" 
    $P6127 = $P6126()
    .return ($P6127)
.end

