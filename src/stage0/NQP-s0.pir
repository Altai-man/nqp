# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup
.end
### .include 'gen/nqp-how.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1295307687.218")
.annotate 'line', 0
    get_hll_global $P977, ["NQPMu"], "_block976" 
    capture_lex $P977
    get_hll_global $P928, ["NQPAttribute"], "_block927" 
    capture_lex $P928
    get_hll_global $P50, ["NQPClassHOW"], "_block49" 
    capture_lex $P50
    get_hll_global $P18, ["KnowHOWAttribute"], "_block17" 
    capture_lex $P18
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, "NQPMu"
    get_hll_global $P14, "NQPAttribute"
    get_hll_global $P15, "NQPClassHOW"
    get_hll_global $P16, "KnowHOWAttribute"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 10
    get_hll_global $P18, ["KnowHOWAttribute"], "_block17" 
    capture_lex $P18
    $P18()
.annotate 'line', 26
    get_hll_global $P50, ["NQPClassHOW"], "_block49" 
    capture_lex $P50
    $P50()
.annotate 'line', 394
    get_hll_global $P928, ["NQPAttribute"], "_block927" 
    capture_lex $P928
    $P928()
.annotate 'line', 413
    get_hll_global $P977, ["NQPMu"], "_block976" 
    capture_lex $P977
    $P1028 = $P977()
.annotate 'line', 1
    .return ($P1028)
    .const 'Sub' $P1030 = "70_1295307687.218" 
    .return ($P1030)
.end


.namespace ["KnowHOWAttribute"]
.sub "_block17"  :subid("11_1295307687.218") :outer("10_1295307687.218")
.annotate 'line', 10
    .const 'Sub' $P40 = "14_1295307687.218" 
    capture_lex $P40
    .const 'Sub' $P31 = "13_1295307687.218" 
    capture_lex $P31
    .const 'Sub' $P20 = "12_1295307687.218" 
    capture_lex $P20
    get_global $P19, "$?CLASS"
.annotate 'line', 14
    .const 'Sub' $P31 = "13_1295307687.218" 
    newclosure $P38, $P31
.annotate 'line', 10
    .return ($P38)
.end


.namespace ["KnowHOWAttribute"]
.sub "" :load :init :subid("post71") :outer("11_1295307687.218")
.annotate 'line', 10
    get_hll_global $P18, ["KnowHOWAttribute"], "_block17" 
    .local pmc block
    set block, $P18
    .const 'Sub' $P40 = "14_1295307687.218" 
    capture_lex $P40
    $P40()
.end


.namespace ["KnowHOWAttribute"]
.sub "_block39"  :anon :subid("14_1295307687.218") :outer("11_1295307687.218")
.annotate 'line', 10
    get_hll_global $P41, "KnowHOW"
    $P42 = $P41."new_type"("KnowHOWAttribute" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P42
    set_hll_global "KnowHOWAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P43, type_obj
    .const 'Sub' $P44 = "12_1295307687.218" 
    $P43."add_method"(type_obj, "new", $P44)
    get_how $P45, type_obj
    .const 'Sub' $P46 = "13_1295307687.218" 
    $P45."add_method"(type_obj, "name", $P46)
    get_how $P47, type_obj
    $P48 = $P47."compose"(type_obj)
    .return ($P48)
.end


.namespace ["KnowHOWAttribute"]
.include "except_types.pasm"
.sub "new"  :subid("12_1295307687.218") :outer("11_1295307687.218")
    .param pmc param_23
    .param pmc param_24 :optional :named("name")
    .param int has_param_24 :opt_flag
.annotate 'line', 11
    new $P22, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P22, control_21
    push_eh $P22
    .lex "self", param_23
    if has_param_24, optparam_72
    new $P25, "Undef"
    set param_24, $P25
  optparam_72:
    .lex "$name", param_24
.annotate 'line', 12
    find_lex $P26, "$name"
    set $S27, $P26
    get_hll_global $P28, "KnowHOWAttribute"
    repr_box_str $P29, $S27, $P28
.annotate 'line', 11
    .return ($P29)
  control_21:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P30, exception, "payload"
    .return ($P30)
.end


.namespace ["KnowHOWAttribute"]
.include "except_types.pasm"
.sub "name"  :subid("13_1295307687.218") :outer("11_1295307687.218")
    .param pmc param_34
.annotate 'line', 14
    new $P33, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P33, control_32
    push_eh $P33
    .lex "self", param_34
.annotate 'line', 15
    find_lex $P35, "self"
    repr_unbox_str $S36, $P35
.annotate 'line', 14
    .return ($S36)
  control_32:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P37, exception, "payload"
    .return ($P37)
.end


.namespace ["NQPClassHOW"]
.sub "_block49"  :subid("15_1295307687.218") :outer("10_1295307687.218")
.annotate 'line', 26
    .const 'Sub' $P847 = "58_1295307687.218" 
    capture_lex $P847
    .const 'Sub' $P810 = "56_1295307687.218" 
    capture_lex $P810
    .const 'Sub' $P774 = "54_1295307687.218" 
    capture_lex $P774
    .const 'Sub' $P740 = "53_1295307687.218" 
    capture_lex $P740
    .const 'Sub' $P703 = "52_1295307687.218" 
    capture_lex $P703
    .const 'Sub' $P677 = "50_1295307687.218" 
    capture_lex $P677
    .const 'Sub' $P668 = "49_1295307687.218" 
    capture_lex $P668
    .const 'Sub' $P659 = "48_1295307687.218" 
    capture_lex $P659
    .const 'Sub' $P633 = "46_1295307687.218" 
    capture_lex $P633
    .const 'Sub' $P623 = "45_1295307687.218" 
    capture_lex $P623
    .const 'Sub' $P613 = "44_1295307687.218" 
    capture_lex $P613
    .const 'Sub' $P565 = "41_1295307687.218" 
    capture_lex $P565
    .const 'Sub' $P555 = "40_1295307687.218" 
    capture_lex $P555
    .const 'Sub' $P422 = "35_1295307687.218" 
    capture_lex $P422
    .const 'Sub' $P382 = "34_1295307687.218" 
    capture_lex $P382
    .const 'Sub' $P341 = "32_1295307687.218" 
    capture_lex $P341
    .const 'Sub' $P317 = "31_1295307687.218" 
    capture_lex $P317
    .const 'Sub' $P293 = "30_1295307687.218" 
    capture_lex $P293
    .const 'Sub' $P271 = "29_1295307687.218" 
    capture_lex $P271
    .const 'Sub' $P254 = "28_1295307687.218" 
    capture_lex $P254
    .const 'Sub' $P244 = "27_1295307687.218" 
    capture_lex $P244
    .const 'Sub' $P231 = "26_1295307687.218" 
    capture_lex $P231
    .const 'Sub' $P94 = "19_1295307687.218" 
    capture_lex $P94
    .const 'Sub' $P52 = "16_1295307687.218" 
    capture_lex $P52
    get_global $P51, "$?CLASS"
.annotate 'line', 196
    .const 'Sub' $P52 = "16_1295307687.218" 
    newclosure $P93, $P52
    .lex "compute_c3_mro", $P93
.annotate 'line', 218
    .const 'Sub' $P94 = "19_1295307687.218" 
    newclosure $P230, $P94
    .lex "c3_merge", $P230
.annotate 'line', 142
    find_lex $P553, "compute_c3_mro"
    find_lex $P554, "c3_merge"
.annotate 'line', 381
    .const 'Sub' $P810 = "56_1295307687.218" 
    newclosure $P845, $P810
.annotate 'line', 26
    .return ($P845)
.end


.namespace ["NQPClassHOW"]
.sub "" :load :init :subid("post73") :outer("15_1295307687.218")
.annotate 'line', 26
    get_hll_global $P50, ["NQPClassHOW"], "_block49" 
    .local pmc block
    set block, $P50
    .const 'Sub' $P847 = "58_1295307687.218" 
    capture_lex $P847
    $P847()
.end


.namespace ["NQPClassHOW"]
.sub "_block846"  :anon :subid("58_1295307687.218") :outer("15_1295307687.218")
.annotate 'line', 26
    get_hll_global $P848, "KnowHOW"
    $P849 = $P848."new_type"("NQPClassHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P849
    set_hll_global "NQPClassHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P850, type_obj
    get_hll_global $P851, "KnowHOWAttribute"
    $P852 = $P851."new"("$!name" :named("name"))
    $P850."add_attribute"(type_obj, $P852)
    get_how $P853, type_obj
    get_hll_global $P854, "KnowHOWAttribute"
    $P855 = $P854."new"("%!attributes" :named("name"))
    $P853."add_attribute"(type_obj, $P855)
    get_how $P856, type_obj
    get_hll_global $P857, "KnowHOWAttribute"
    $P858 = $P857."new"("%!methods" :named("name"))
    $P856."add_attribute"(type_obj, $P858)
    get_how $P859, type_obj
    get_hll_global $P860, "KnowHOWAttribute"
    $P861 = $P860."new"("@!multi_methods_to_incorporate" :named("name"))
    $P859."add_attribute"(type_obj, $P861)
    get_how $P862, type_obj
    get_hll_global $P863, "KnowHOWAttribute"
    $P864 = $P863."new"("@!parents" :named("name"))
    $P862."add_attribute"(type_obj, $P864)
    get_how $P865, type_obj
    get_hll_global $P866, "KnowHOWAttribute"
    $P867 = $P866."new"("@!roles" :named("name"))
    $P865."add_attribute"(type_obj, $P867)
    get_how $P868, type_obj
    get_hll_global $P869, "KnowHOWAttribute"
    $P870 = $P869."new"("@!vtable" :named("name"))
    $P868."add_attribute"(type_obj, $P870)
    get_how $P871, type_obj
    get_hll_global $P872, "KnowHOWAttribute"
    $P873 = $P872."new"("%!method-vtable-slots" :named("name"))
    $P871."add_attribute"(type_obj, $P873)
    get_how $P874, type_obj
    get_hll_global $P875, "KnowHOWAttribute"
    $P876 = $P875."new"("$!composed" :named("name"))
    $P874."add_attribute"(type_obj, $P876)
    get_how $P877, type_obj
    get_hll_global $P878, "KnowHOWAttribute"
    $P879 = $P878."new"("@!mro" :named("name"))
    $P877."add_attribute"(type_obj, $P879)
    get_how $P880, type_obj
    get_hll_global $P881, "KnowHOWAttribute"
    $P882 = $P881."new"("@!done" :named("name"))
    $P880."add_attribute"(type_obj, $P882)
    get_how $P883, type_obj
    .const 'Sub' $P884 = "26_1295307687.218" 
    $P883."add_method"(type_obj, "new", $P884)
    get_how $P885, type_obj
    .const 'Sub' $P886 = "27_1295307687.218" 
    $P885."add_method"(type_obj, "BUILD", $P886)
    get_how $P887, type_obj
    .const 'Sub' $P888 = "28_1295307687.218" 
    $P887."add_method"(type_obj, "new_type", $P888)
    get_how $P889, type_obj
    .const 'Sub' $P890 = "29_1295307687.218" 
    $P889."add_method"(type_obj, "add_method", $P890)
    get_how $P891, type_obj
    .const 'Sub' $P892 = "30_1295307687.218" 
    $P891."add_method"(type_obj, "add_multi_method", $P892)
    get_how $P893, type_obj
    .const 'Sub' $P894 = "31_1295307687.218" 
    $P893."add_method"(type_obj, "add_attribute", $P894)
    get_how $P895, type_obj
    .const 'Sub' $P896 = "32_1295307687.218" 
    $P895."add_method"(type_obj, "add_parent", $P896)
    get_how $P897, type_obj
    .const 'Sub' $P898 = "34_1295307687.218" 
    $P897."add_method"(type_obj, "compose", $P898)
    get_how $P899, type_obj
    .const 'Sub' $P900 = "35_1295307687.218" 
    $P899."add_method"(type_obj, "incorporate_multi_candidates", $P900)
    get_how $P901, type_obj
    .const 'Sub' $P902 = "40_1295307687.218" 
    $P901."add_method"(type_obj, "publish_type_cache", $P902)
    get_how $P903, type_obj
    .const 'Sub' $P904 = "41_1295307687.218" 
    $P903."add_method"(type_obj, "publish_method_cache", $P904)
    get_how $P905, type_obj
    .const 'Sub' $P906 = "44_1295307687.218" 
    $P905."add_method"(type_obj, "parents", $P906)
    get_how $P907, type_obj
    .const 'Sub' $P908 = "45_1295307687.218" 
    $P907."add_method"(type_obj, "roles", $P908)
    get_how $P909, type_obj
    .const 'Sub' $P910 = "46_1295307687.218" 
    $P909."add_method"(type_obj, "methods", $P910)
    get_how $P911, type_obj
    .const 'Sub' $P912 = "48_1295307687.218" 
    $P911."add_method"(type_obj, "method_table", $P912)
    get_how $P913, type_obj
    .const 'Sub' $P914 = "49_1295307687.218" 
    $P913."add_method"(type_obj, "name", $P914)
    get_how $P915, type_obj
    .const 'Sub' $P916 = "50_1295307687.218" 
    $P915."add_method"(type_obj, "attributes", $P916)
    get_how $P917, type_obj
    .const 'Sub' $P918 = "52_1295307687.218" 
    $P917."add_method"(type_obj, "isa", $P918)
    get_how $P919, type_obj
    .const 'Sub' $P920 = "53_1295307687.218" 
    $P919."add_method"(type_obj, "does", $P920)
    get_how $P921, type_obj
    .const 'Sub' $P922 = "54_1295307687.218" 
    $P921."add_method"(type_obj, "can", $P922)
    get_how $P923, type_obj
    .const 'Sub' $P924 = "56_1295307687.218" 
    $P923."add_method"(type_obj, "find_method", $P924)
    get_how $P925, type_obj
    $P926 = $P925."compose"(type_obj)
    .return ($P926)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compute_c3_mro"  :subid("16_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_55
.annotate 'line', 196
    .const 'Sub' $P67 = "17_1295307687.218" 
    capture_lex $P67
    new $P54, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P54, control_53
    push_eh $P54
    .lex "$class", param_55
.annotate 'line', 197
    $P56 = root_new ['parrot';'ResizablePMCArray']
    .lex "@immediate_parents", $P56
.annotate 'line', 200
    $P57 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P57
.annotate 'line', 197
    find_lex $P58, "$class"
    get_how $P59, $P58
    find_lex $P60, "$class"
    $P61 = $P59."parents"($P60, 1 :named("local"))
    store_lex "@immediate_parents", $P61
    find_lex $P62, "@result"
.annotate 'line', 201
    find_lex $P64, "@immediate_parents"
    set $N65, $P64
    unless $N65, if_63_end
    .const 'Sub' $P67 = "17_1295307687.218" 
    capture_lex $P67
    $P67()
  if_63_end:
.annotate 'line', 213
    find_lex $P88, "@result"
    find_lex $P89, "$class"
    $P88."unshift"($P89)
.annotate 'line', 214
    new $P90, "Exception"
    set $P90['type'], .CONTROL_RETURN
    find_lex $P91, "@result"
    setattribute $P90, 'payload', $P91
    throw $P90
.annotate 'line', 196
    .return ()
  control_53:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P92, exception, "payload"
    .return ($P92)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block66"  :anon :subid("17_1295307687.218") :outer("16_1295307687.218")
.annotate 'line', 201
    .const 'Sub' $P75 = "18_1295307687.218" 
    capture_lex $P75
.annotate 'line', 204
    $P68 = root_new ['parrot';'ResizablePMCArray']
    .lex "@merge_list", $P68
.annotate 'line', 201
    find_lex $P69, "@merge_list"
.annotate 'line', 205
    find_lex $P71, "@immediate_parents"
    defined $I72, $P71
    unless $I72, for_undef_74
    iter $P70, $P71
    new $P82, 'ExceptionHandler'
    set_addr $P82, loop81_handler
    $P82."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P82
  loop81_test:
    unless $P70, loop81_done
    shift $P73, $P70
  loop81_redo:
    .const 'Sub' $P75 = "18_1295307687.218" 
    capture_lex $P75
    $P75($P73)
  loop81_next:
    goto loop81_test
  loop81_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P83, exception, 'type'
    eq $P83, .CONTROL_LOOP_NEXT, loop81_next
    eq $P83, .CONTROL_LOOP_REDO, loop81_redo
  loop81_done:
    pop_eh 
  for_undef_74:
.annotate 'line', 208
    find_lex $P84, "@merge_list"
    find_lex $P85, "@immediate_parents"
    $P84."push"($P85)
.annotate 'line', 209
    find_lex $P86, "@merge_list"
    $P87 = "c3_merge"($P86)
    store_lex "@result", $P87
.annotate 'line', 201
    .return ($P87)
.end


.namespace ["NQPClassHOW"]
.sub "_block74"  :anon :subid("18_1295307687.218") :outer("17_1295307687.218")
    .param pmc param_76
.annotate 'line', 205
    .lex "$_", param_76
.annotate 'line', 206
    find_lex $P77, "@merge_list"
    find_lex $P78, "$_"
    $P79 = "compute_c3_mro"($P78)
    $P80 = $P77."push"($P79)
.annotate 'line', 205
    .return ($P80)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "c3_merge"  :subid("19_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_97
.annotate 'line', 218
    .const 'Sub' $P190 = "24_1295307687.218" 
    capture_lex $P190
    .const 'Sub' $P112 = "20_1295307687.218" 
    capture_lex $P112
    new $P96, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P96, control_95
    push_eh $P96
    .lex "@merge_list", param_97
.annotate 'line', 219
    $P98 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P98
.annotate 'line', 220
    new $P99, "Undef"
    .lex "$accepted", $P99
.annotate 'line', 221
    new $P100, "Undef"
    .lex "$something_accepted", $P100
.annotate 'line', 222
    new $P101, "Undef"
    .lex "$cand_count", $P101
.annotate 'line', 265
    new $P102, "Undef"
    .lex "$i", $P102
.annotate 'line', 218
    find_lex $P103, "@result"
    find_lex $P104, "$accepted"
.annotate 'line', 221
    new $P105, "Integer"
    assign $P105, 0
    store_lex "$something_accepted", $P105
.annotate 'line', 222
    new $P106, "Integer"
    assign $P106, 0
    store_lex "$cand_count", $P106
.annotate 'line', 225
    find_lex $P108, "@merge_list"
    defined $I109, $P108
    unless $I109, for_undef_75
    iter $P107, $P108
    new $P173, 'ExceptionHandler'
    set_addr $P173, loop172_handler
    $P173."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P173
  loop172_test:
    unless $P107, loop172_done
    shift $P110, $P107
  loop172_redo:
    .const 'Sub' $P112 = "20_1295307687.218" 
    capture_lex $P112
    $P112($P110)
  loop172_next:
    goto loop172_test
  loop172_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P174, exception, 'type'
    eq $P174, .CONTROL_LOOP_NEXT, loop172_next
    eq $P174, .CONTROL_LOOP_REDO, loop172_redo
  loop172_done:
    pop_eh 
  for_undef_75:
.annotate 'line', 255
    find_lex $P176, "$cand_count"
    set $N177, $P176
    iseq $I178, $N177, 0.0
    unless $I178, if_175_end
.annotate 'line', 256
    new $P179, "Exception"
    set $P179['type'], .CONTROL_RETURN
    find_lex $P180, "@result"
    setattribute $P179, 'payload', $P180
    throw $P179
  if_175_end:
.annotate 'line', 260
    find_lex $P182, "$something_accepted"
    if $P182, unless_181_end
.annotate 'line', 261
    die "Could not build C3 linearization: ambiguous hierarchy"
  unless_181_end:
.annotate 'line', 265
    new $P183, "Integer"
    assign $P183, 0
    store_lex "$i", $P183
.annotate 'line', 266
    new $P221, 'ExceptionHandler'
    set_addr $P221, loop220_handler
    $P221."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P221
  loop220_test:
    find_lex $P184, "$i"
    set $N185, $P184
    find_lex $P186, "@merge_list"
    set $N187, $P186
    islt $I188, $N185, $N187
    unless $I188, loop220_done
  loop220_redo:
    .const 'Sub' $P190 = "24_1295307687.218" 
    capture_lex $P190
    $P190()
  loop220_next:
    goto loop220_test
  loop220_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P222, exception, 'type'
    eq $P222, .CONTROL_LOOP_NEXT, loop220_next
    eq $P222, .CONTROL_LOOP_REDO, loop220_redo
  loop220_done:
    pop_eh 
.annotate 'line', 279
    find_lex $P223, "@merge_list"
    $P224 = "c3_merge"($P223)
    store_lex "@result", $P224
.annotate 'line', 280
    find_lex $P225, "@result"
    find_lex $P226, "$accepted"
    $P225."unshift"($P226)
.annotate 'line', 281
    new $P227, "Exception"
    set $P227['type'], .CONTROL_RETURN
    find_lex $P228, "@result"
    setattribute $P227, 'payload', $P228
    throw $P227
.annotate 'line', 218
    .return ()
  control_95:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P229, exception, "payload"
    .return ($P229)
.end


.namespace ["NQPClassHOW"]
.sub "_block111"  :anon :subid("20_1295307687.218") :outer("19_1295307687.218")
    .param pmc param_114
.annotate 'line', 225
    .const 'Sub' $P121 = "21_1295307687.218" 
    capture_lex $P121
.annotate 'line', 226
    $P113 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cand_list", $P113
    .lex "$_", param_114
    find_lex $P115, "$_"
    store_lex "@cand_list", $P115
.annotate 'line', 227
    find_lex $P118, "@cand_list"
    set $N119, $P118
    if $N119, if_117
    new $P116, 'Float'
    set $P116, $N119
    goto if_117_end
  if_117:
    .const 'Sub' $P121 = "21_1295307687.218" 
    capture_lex $P121
    $P171 = $P121()
    set $P116, $P171
  if_117_end:
.annotate 'line', 225
    .return ($P116)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block120"  :anon :subid("21_1295307687.218") :outer("20_1295307687.218")
.annotate 'line', 227
    .const 'Sub' $P134 = "22_1295307687.218" 
    capture_lex $P134
.annotate 'line', 228
    new $P122, "Undef"
    .lex "$rejected", $P122
.annotate 'line', 229
    new $P123, "Undef"
    .lex "$cand_class", $P123
.annotate 'line', 228
    new $P124, "Integer"
    assign $P124, 0
    store_lex "$rejected", $P124
.annotate 'line', 229
    find_lex $P125, "@cand_list"
    unless_null $P125, vivify_76
    $P125 = root_new ['parrot';'ResizablePMCArray']
  vivify_76:
    set $P126, $P125[0]
    unless_null $P126, vivify_77
    new $P126, "Undef"
  vivify_77:
    store_lex "$cand_class", $P126
.annotate 'line', 230
    find_lex $P127, "$cand_count"
    add $P128, $P127, 1
    store_lex "$cand_count", $P128
.annotate 'line', 231
    find_lex $P130, "@merge_list"
    defined $I131, $P130
    unless $I131, for_undef_78
    iter $P129, $P130
    new $P169, 'ExceptionHandler'
    set_addr $P169, loop168_handler
    $P169."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P169
  loop168_test:
    unless $P129, loop168_done
    shift $P132, $P129
  loop168_redo:
    .const 'Sub' $P134 = "22_1295307687.218" 
    capture_lex $P134
    $P134($P132)
  loop168_next:
    goto loop168_test
  loop168_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P170, exception, 'type'
    eq $P170, .CONTROL_LOOP_NEXT, loop168_next
    eq $P170, .CONTROL_LOOP_REDO, loop168_redo
  loop168_done:
    pop_eh 
  for_undef_78:
.annotate 'line', 227
    .return ($P129)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block133"  :anon :subid("22_1295307687.218") :outer("21_1295307687.218")
    .param pmc param_135
.annotate 'line', 231
    .const 'Sub' $P141 = "23_1295307687.218" 
    capture_lex $P141
    .lex "$_", param_135
.annotate 'line', 233
    find_lex $P137, "$_"
    find_lex $P138, "@cand_list"
    issame $I139, $P137, $P138
    if $I139, unless_136_end
    .const 'Sub' $P141 = "23_1295307687.218" 
    capture_lex $P141
    $P141()
  unless_136_end:
.annotate 'line', 245
    find_lex $P164, "$rejected"
    unless $P164, unless_163
    set $P162, $P164
    goto unless_163_end
  unless_163:
.annotate 'line', 246
    find_lex $P165, "$cand_class"
    store_lex "$accepted", $P165
.annotate 'line', 247
    new $P166, "Integer"
    assign $P166, 1
    store_lex "$something_accepted", $P166
.annotate 'line', 248
    set $I167, .CONTROL_LOOP_LAST
    die 0, $I167
  unless_163_end:
.annotate 'line', 231
    .return ($P162)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block140"  :anon :subid("23_1295307687.218") :outer("22_1295307687.218")
.annotate 'line', 235
    new $P142, "Undef"
    .lex "$cur_pos", $P142
    new $P143, "Integer"
    assign $P143, 1
    store_lex "$cur_pos", $P143
.annotate 'line', 236
    new $P160, 'ExceptionHandler'
    set_addr $P160, loop159_handler
    $P160."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P160
  loop159_test:
    find_lex $P144, "$cur_pos"
    set $N145, $P144
    find_lex $P146, "$_"
    set $N147, $P146
    isle $I148, $N145, $N147
    unless $I148, loop159_done
  loop159_redo:
.annotate 'line', 237
    find_lex $P150, "$cur_pos"
    set $I151, $P150
    find_lex $P152, "$_"
    unless_null $P152, vivify_79
    $P152 = root_new ['parrot';'ResizablePMCArray']
  vivify_79:
    set $P153, $P152[$I151]
    unless_null $P153, vivify_80
    new $P153, "Undef"
  vivify_80:
    find_lex $P154, "$cand_class"
    issame $I155, $P153, $P154
    unless $I155, if_149_end
.annotate 'line', 238
    new $P156, "Integer"
    assign $P156, 1
    store_lex "$rejected", $P156
  if_149_end:
.annotate 'line', 240
    find_lex $P157, "$cur_pos"
    add $P158, $P157, 1
    store_lex "$cur_pos", $P158
  loop159_next:
.annotate 'line', 236
    goto loop159_test
  loop159_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P161, exception, 'type'
    eq $P161, .CONTROL_LOOP_NEXT, loop159_next
    eq $P161, .CONTROL_LOOP_REDO, loop159_redo
  loop159_done:
    pop_eh 
.annotate 'line', 233
    .return ($I148)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block189"  :anon :subid("24_1295307687.218") :outer("19_1295307687.218")
.annotate 'line', 266
    .const 'Sub' $P201 = "25_1295307687.218" 
    capture_lex $P201
.annotate 'line', 267
    $P191 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_list", $P191
.annotate 'line', 266
    find_lex $P192, "@new_list"
.annotate 'line', 268
    find_lex $P194, "$i"
    set $I195, $P194
    find_lex $P196, "@merge_list"
    unless_null $P196, vivify_81
    $P196 = root_new ['parrot';'ResizablePMCArray']
  vivify_81:
    set $P197, $P196[$I195]
    unless_null $P197, vivify_82
    new $P197, "Undef"
  vivify_82:
    defined $I198, $P197
    unless $I198, for_undef_83
    iter $P193, $P197
    new $P212, 'ExceptionHandler'
    set_addr $P212, loop211_handler
    $P212."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P212
  loop211_test:
    unless $P193, loop211_done
    shift $P199, $P193
  loop211_redo:
    .const 'Sub' $P201 = "25_1295307687.218" 
    capture_lex $P201
    $P201($P199)
  loop211_next:
    goto loop211_test
  loop211_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P213, exception, 'type'
    eq $P213, .CONTROL_LOOP_NEXT, loop211_next
    eq $P213, .CONTROL_LOOP_REDO, loop211_redo
  loop211_done:
    pop_eh 
  for_undef_83:
.annotate 'line', 273
    find_lex $P214, "@new_list"
    find_lex $P215, "$i"
    set $I216, $P215
    find_lex $P217, "@merge_list"
    unless_null $P217, vivify_84
    $P217 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@merge_list", $P217
  vivify_84:
    set $P217[$I216], $P214
.annotate 'line', 274
    find_lex $P218, "$i"
    add $P219, $P218, 1
    store_lex "$i", $P219
.annotate 'line', 266
    .return ($P219)
.end


.namespace ["NQPClassHOW"]
.sub "_block200"  :anon :subid("25_1295307687.218") :outer("24_1295307687.218")
    .param pmc param_202
.annotate 'line', 268
    .lex "$_", param_202
.annotate 'line', 269
    find_lex $P205, "$_"
    find_lex $P206, "$accepted"
    issame $I207, $P205, $P206
    unless $I207, unless_204
    new $P203, 'Integer'
    set $P203, $I207
    goto unless_204_end
  unless_204:
.annotate 'line', 270
    find_lex $P208, "@new_list"
    find_lex $P209, "$_"
    $P210 = $P208."push"($P209)
.annotate 'line', 269
    set $P203, $P210
  unless_204_end:
.annotate 'line', 268
    .return ($P203)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "new"  :subid("26_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_234
    .param pmc param_235 :optional :named("name")
    .param int has_param_235 :opt_flag
.annotate 'line', 59
    new $P233, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P233, control_232
    push_eh $P233
    .lex "self", param_234
    if has_param_235, optparam_85
    new $P236, "Undef"
    set param_235, $P236
  optparam_85:
    .lex "$name", param_235
.annotate 'line', 60
    new $P237, "Undef"
    .lex "$obj", $P237
    find_lex $P238, "self"
    repr_instance_of $P239, $P238
    store_lex "$obj", $P239
.annotate 'line', 61
    find_lex $P240, "$obj"
    find_lex $P241, "$name"
    $P240."BUILD"($P241 :named("name"))
    find_lex $P242, "$obj"
.annotate 'line', 59
    .return ($P242)
  control_232:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P243, exception, "payload"
    .return ($P243)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "BUILD"  :subid("27_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_247
    .param pmc param_248 :optional :named("name")
    .param int has_param_248 :opt_flag
.annotate 'line', 65
    new $P246, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P246, control_245
    push_eh $P246
    .lex "self", param_247
    if has_param_248, optparam_86
    new $P249, "Undef"
    set param_248, $P249
  optparam_86:
    .lex "$name", param_248
.annotate 'line', 66
    find_lex $P250, "$name"
    find_lex $P251, "self"
    get_global $P252, "$?CLASS"
    setattribute $P251, $P252, "$!name", $P250
.annotate 'line', 65
    .return ($P250)
  control_245:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P253, exception, "payload"
    .return ($P253)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "new_type"  :subid("28_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_257
    .param pmc param_258 :optional :named("name")
    .param int has_param_258 :opt_flag
    .param pmc param_260 :optional :named("repr")
    .param int has_param_260 :opt_flag
.annotate 'line', 71
    new $P256, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P256, control_255
    push_eh $P256
    .lex "self", param_257
    if has_param_258, optparam_87
    new $P259, "String"
    assign $P259, "<anon>"
    set param_258, $P259
  optparam_87:
    .lex "$name", param_258
    if has_param_260, optparam_88
    new $P261, "String"
    assign $P261, "P6opaque"
    set param_260, $P261
  optparam_88:
    .lex "$repr", param_260
.annotate 'line', 72
    new $P262, "Undef"
    .lex "$metaclass", $P262
    find_lex $P263, "self"
    find_lex $P264, "$name"
    $P265 = $P263."new"($P264 :named("name"))
    store_lex "$metaclass", $P265
.annotate 'line', 73
    find_lex $P266, "$metaclass"
    find_lex $P267, "$repr"
    set $S268, $P267
    repr_type_object_for $P269, $P266, $S268
.annotate 'line', 71
    .return ($P269)
  control_255:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P270, exception, "payload"
    .return ($P270)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_method"  :subid("29_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_274
    .param pmc param_275
    .param pmc param_276
    .param pmc param_277
.annotate 'line', 76
    new $P273, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P273, control_272
    push_eh $P273
    .lex "self", param_274
    .lex "$obj", param_275
    .lex "$name", param_276
    .lex "$code_obj", param_277
.annotate 'line', 77
    find_lex $P279, "$name"
    find_lex $P280, "self"
    get_global $P281, "$?CLASS"
    getattribute $P282, $P280, $P281, "%!methods"
    unless_null $P282, vivify_89
    $P282 = root_new ['parrot';'Hash']
  vivify_89:
    set $P283, $P282[$P279]
    unless_null $P283, vivify_90
    new $P283, "Undef"
  vivify_90:
    unless $P283, if_278_end
.annotate 'line', 78
    new $P284, "String"
    assign $P284, "This class already has a method named "
    find_lex $P285, "$name"
    concat $P286, $P284, $P285
    die $P286
  if_278_end:
.annotate 'line', 80
    find_lex $P287, "$code_obj"
    find_lex $P288, "$name"
    find_lex $P289, "self"
    get_global $P290, "$?CLASS"
    getattribute $P291, $P289, $P290, "%!methods"
    unless_null $P291, vivify_91
    $P291 = root_new ['parrot';'Hash']
    setattribute $P289, $P290, "%!methods", $P291
  vivify_91:
    set $P291[$P288], $P287
.annotate 'line', 76
    .return ($P287)
  control_272:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P292, exception, "payload"
    .return ($P292)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_multi_method"  :subid("30_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_296
    .param pmc param_297
    .param pmc param_298
    .param pmc param_299
.annotate 'line', 83
    new $P295, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P295, control_294
    push_eh $P295
    .lex "self", param_296
    .lex "$obj", param_297
    .lex "$name", param_298
    .lex "$code_obj", param_299
.annotate 'line', 89
    $P300 = root_new ['parrot';'Hash']
    .lex "%todo", $P300
.annotate 'line', 83
    find_lex $P301, "%todo"
.annotate 'line', 90
    find_lex $P302, "$name"
    find_lex $P303, "%todo"
    unless_null $P303, vivify_92
    $P303 = root_new ['parrot';'Hash']
    store_lex "%todo", $P303
  vivify_92:
    set $P303["name"], $P302
.annotate 'line', 91
    find_lex $P304, "$code_obj"
    find_lex $P305, "%todo"
    unless_null $P305, vivify_93
    $P305 = root_new ['parrot';'Hash']
    store_lex "%todo", $P305
  vivify_93:
    set $P305["code"], $P304
.annotate 'line', 92
    find_lex $P306, "%todo"
    find_lex $P307, "self"
    get_global $P308, "$?CLASS"
    getattribute $P309, $P307, $P308, "@!multi_methods_to_incorporate"
    unless_null $P309, vivify_94
    $P309 = root_new ['parrot';'ResizablePMCArray']
  vivify_94:
    set $N310, $P309
    set $I311, $N310
    find_lex $P312, "self"
    get_global $P313, "$?CLASS"
    getattribute $P314, $P312, $P313, "@!multi_methods_to_incorporate"
    unless_null $P314, vivify_95
    $P314 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P312, $P313, "@!multi_methods_to_incorporate", $P314
  vivify_95:
    set $P314[$I311], $P306
    find_lex $P315, "$code_obj"
.annotate 'line', 83
    .return ($P315)
  control_294:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P316, exception, "payload"
    .return ($P316)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_attribute"  :subid("31_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_320
    .param pmc param_321
    .param pmc param_322
.annotate 'line', 96
    new $P319, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P319, control_318
    push_eh $P319
    .lex "self", param_320
    .lex "$obj", param_321
    .lex "$meta_attr", param_322
.annotate 'line', 97
    new $P323, "Undef"
    .lex "$name", $P323
    find_lex $P324, "$meta_attr"
    $P325 = $P324."name"()
    store_lex "$name", $P325
.annotate 'line', 98
    find_lex $P327, "$name"
    find_lex $P328, "self"
    get_global $P329, "$?CLASS"
    getattribute $P330, $P328, $P329, "%!attributes"
    unless_null $P330, vivify_96
    $P330 = root_new ['parrot';'Hash']
  vivify_96:
    set $P331, $P330[$P327]
    unless_null $P331, vivify_97
    new $P331, "Undef"
  vivify_97:
    unless $P331, if_326_end
.annotate 'line', 99
    new $P332, "String"
    assign $P332, "This class already has an attribute named "
    find_lex $P333, "$name"
    concat $P334, $P332, $P333
    die $P334
  if_326_end:
.annotate 'line', 101
    find_lex $P335, "$meta_attr"
    find_lex $P336, "$name"
    find_lex $P337, "self"
    get_global $P338, "$?CLASS"
    getattribute $P339, $P337, $P338, "%!attributes"
    unless_null $P339, vivify_98
    $P339 = root_new ['parrot';'Hash']
    setattribute $P337, $P338, "%!attributes", $P339
  vivify_98:
    set $P339[$P336], $P335
.annotate 'line', 96
    .return ($P335)
  control_318:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P340, exception, "payload"
    .return ($P340)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_parent"  :subid("32_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_344
    .param pmc param_345
    .param pmc param_346
.annotate 'line', 104
    .const 'Sub' $P358 = "33_1295307687.218" 
    capture_lex $P358
    new $P343, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P343, control_342
    push_eh $P343
    .lex "self", param_344
    .lex "$obj", param_345
    .lex "$parent", param_346
.annotate 'line', 105
    find_lex $P348, "self"
    get_global $P349, "$?CLASS"
    getattribute $P350, $P348, $P349, "$!composed"
    unless_null $P350, vivify_99
    new $P350, "Undef"
  vivify_99:
    unless $P350, if_347_end
.annotate 'line', 106
    die "NQPClassHOW does not support adding parents after being composed."
  if_347_end:
.annotate 'line', 108
    find_lex $P352, "self"
    get_global $P353, "$?CLASS"
    getattribute $P354, $P352, $P353, "@!parents"
    unless_null $P354, vivify_100
    $P354 = root_new ['parrot';'ResizablePMCArray']
  vivify_100:
    defined $I355, $P354
    unless $I355, for_undef_101
    iter $P351, $P354
    new $P370, 'ExceptionHandler'
    set_addr $P370, loop369_handler
    $P370."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P370
  loop369_test:
    unless $P351, loop369_done
    shift $P356, $P351
  loop369_redo:
    .const 'Sub' $P358 = "33_1295307687.218" 
    capture_lex $P358
    $P358($P356)
  loop369_next:
    goto loop369_test
  loop369_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P371, exception, 'type'
    eq $P371, .CONTROL_LOOP_NEXT, loop369_next
    eq $P371, .CONTROL_LOOP_REDO, loop369_redo
  loop369_done:
    pop_eh 
  for_undef_101:
.annotate 'line', 113
    find_lex $P372, "$parent"
    find_lex $P373, "self"
    get_global $P374, "$?CLASS"
    getattribute $P375, $P373, $P374, "@!parents"
    unless_null $P375, vivify_102
    $P375 = root_new ['parrot';'ResizablePMCArray']
  vivify_102:
    set $N376, $P375
    set $I377, $N376
    find_lex $P378, "self"
    get_global $P379, "$?CLASS"
    getattribute $P380, $P378, $P379, "@!parents"
    unless_null $P380, vivify_103
    $P380 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P378, $P379, "@!parents", $P380
  vivify_103:
    set $P380[$I377], $P372
.annotate 'line', 104
    .return ($P372)
  control_342:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P381, exception, "payload"
    .return ($P381)
.end


.namespace ["NQPClassHOW"]
.sub "_block357"  :anon :subid("33_1295307687.218") :outer("32_1295307687.218")
    .param pmc param_359
.annotate 'line', 108
    .lex "$_", param_359
.annotate 'line', 109
    find_lex $P362, "$_"
    find_lex $P363, "$parent"
    issame $I364, $P362, $P363
    if $I364, if_361
    new $P360, 'Integer'
    set $P360, $I364
    goto if_361_end
  if_361:
.annotate 'line', 110
    new $P365, "String"
    assign $P365, "Already have "
    find_lex $P366, "$parent"
    concat $P367, $P365, $P366
    concat $P368, $P367, " as a parent class."
    die $P368
  if_361_end:
.annotate 'line', 108
    .return ($P360)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compose"  :subid("34_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_385
    .param pmc param_386
.annotate 'line', 116
    new $P384, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P384, control_383
    push_eh $P384
    .lex "self", param_385
    .lex "$obj", param_386
.annotate 'line', 121
    find_lex $P390, "self"
    get_global $P391, "$?CLASS"
    getattribute $P392, $P390, $P391, "@!parents"
    unless_null $P392, vivify_104
    $P392 = root_new ['parrot';'ResizablePMCArray']
  vivify_104:
    set $N393, $P392
    iseq $I394, $N393, 0.0
    if $I394, if_389
    new $P388, 'Integer'
    set $P388, $I394
    goto if_389_end
  if_389:
    find_lex $P395, "self"
    get_global $P396, "$?CLASS"
    getattribute $P397, $P395, $P396, "$!name"
    unless_null $P397, vivify_105
    new $P397, "Undef"
  vivify_105:
    set $S398, $P397
    isne $I399, $S398, "NQPMu"
    new $P388, 'Integer'
    set $P388, $I399
  if_389_end:
    unless $P388, if_387_end
.annotate 'line', 122
    find_lex $P400, "self"
    find_lex $P401, "$obj"
    get_hll_global $P402, "NQPMu"
    $P400."add_parent"($P401, $P402)
  if_387_end:
.annotate 'line', 127
    find_lex $P404, "self"
    get_global $P405, "$?CLASS"
    getattribute $P406, $P404, $P405, "$!composed"
    unless_null $P406, vivify_106
    new $P406, "Undef"
  vivify_106:
    if $P406, unless_403_end
.annotate 'line', 128
    find_lex $P407, "$obj"
    $P408 = "compute_c3_mro"($P407)
    find_lex $P409, "self"
    get_global $P410, "$?CLASS"
    setattribute $P409, $P410, "@!mro", $P408
.annotate 'line', 129
    new $P411, "Integer"
    assign $P411, 1
    find_lex $P412, "self"
    get_global $P413, "$?CLASS"
    setattribute $P412, $P413, "$!composed", $P411
  unless_403_end:
.annotate 'line', 133
    find_lex $P414, "self"
    find_lex $P415, "$obj"
    $P414."incorporate_multi_candidates"($P415)
.annotate 'line', 136
    find_lex $P416, "self"
    find_lex $P417, "$obj"
    $P416."publish_type_cache"($P417)
.annotate 'line', 137
    find_lex $P418, "self"
    find_lex $P419, "$obj"
    $P418."publish_method_cache"($P419)
    find_lex $P420, "$obj"
.annotate 'line', 116
    .return ($P420)
  control_383:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P421, exception, "payload"
    .return ($P421)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "incorporate_multi_candidates"  :subid("35_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_425
    .param pmc param_426
.annotate 'line', 142
    .const 'Sub' $P441 = "36_1295307687.218" 
    capture_lex $P441
    new $P424, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P424, control_423
    push_eh $P424
    .lex "self", param_425
    .lex "$obj", param_426
.annotate 'line', 143
    new $P427, "Undef"
    .lex "$num_todo", $P427
.annotate 'line', 144
    new $P428, "Undef"
    .lex "$i", $P428
.annotate 'line', 143
    find_lex $P429, "self"
    get_global $P430, "$?CLASS"
    getattribute $P431, $P429, $P430, "@!multi_methods_to_incorporate"
    unless_null $P431, vivify_107
    $P431 = root_new ['parrot';'ResizablePMCArray']
  vivify_107:
    set $N432, $P431
    new $P433, 'Float'
    set $P433, $N432
    store_lex "$num_todo", $P433
.annotate 'line', 144
    new $P434, "Integer"
    assign $P434, 0
    store_lex "$i", $P434
.annotate 'line', 145
    new $P550, 'ExceptionHandler'
    set_addr $P550, loop549_handler
    $P550."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P550
  loop549_test:
    find_lex $P435, "$i"
    set $N436, $P435
    find_lex $P437, "$num_todo"
    set $N438, $P437
    isne $I439, $N436, $N438
    unless $I439, loop549_done
  loop549_redo:
    .const 'Sub' $P441 = "36_1295307687.218" 
    capture_lex $P441
    $P441()
  loop549_next:
    goto loop549_test
  loop549_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P551, exception, 'type'
    eq $P551, .CONTROL_LOOP_NEXT, loop549_next
    eq $P551, .CONTROL_LOOP_REDO, loop549_redo
  loop549_done:
    pop_eh 
.annotate 'line', 142
    .return ($I439)
  control_423:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P552, exception, "payload"
    .return ($P552)
.end


.namespace ["NQPClassHOW"]
.sub "_block440"  :anon :subid("36_1295307687.218") :outer("35_1295307687.218")
.annotate 'line', 145
    .const 'Sub' $P477 = "37_1295307687.218" 
    capture_lex $P477
.annotate 'line', 147
    new $P442, "Undef"
    .lex "$name", $P442
.annotate 'line', 148
    new $P443, "Undef"
    .lex "$code", $P443
.annotate 'line', 152
    new $P444, "Undef"
    .lex "$dispatcher", $P444
.annotate 'line', 147
    find_lex $P445, "$i"
    set $I446, $P445
    find_lex $P447, "self"
    get_global $P448, "$?CLASS"
    getattribute $P449, $P447, $P448, "@!multi_methods_to_incorporate"
    unless_null $P449, vivify_108
    $P449 = root_new ['parrot';'ResizablePMCArray']
  vivify_108:
    set $P450, $P449[$I446]
    unless_null $P450, vivify_109
    $P450 = root_new ['parrot';'Hash']
  vivify_109:
    set $P451, $P450["name"]
    unless_null $P451, vivify_110
    new $P451, "Undef"
  vivify_110:
    store_lex "$name", $P451
.annotate 'line', 148
    find_lex $P452, "$i"
    set $I453, $P452
    find_lex $P454, "self"
    get_global $P455, "$?CLASS"
    getattribute $P456, $P454, $P455, "@!multi_methods_to_incorporate"
    unless_null $P456, vivify_111
    $P456 = root_new ['parrot';'ResizablePMCArray']
  vivify_111:
    set $P457, $P456[$I453]
    unless_null $P457, vivify_112
    $P457 = root_new ['parrot';'Hash']
  vivify_112:
    set $P458, $P457["code"]
    unless_null $P458, vivify_113
    new $P458, "Undef"
  vivify_113:
    store_lex "$code", $P458
.annotate 'line', 152
    find_lex $P459, "$name"
    find_lex $P460, "self"
    get_global $P461, "$?CLASS"
    getattribute $P462, $P460, $P461, "%!methods"
    unless_null $P462, vivify_114
    $P462 = root_new ['parrot';'Hash']
  vivify_114:
    set $P463, $P462[$P459]
    unless_null $P463, vivify_115
    new $P463, "Undef"
  vivify_115:
    store_lex "$dispatcher", $P463
.annotate 'line', 153
    find_lex $P465, "$dispatcher"
    defined $I466, $P465
    if $I466, if_464
.annotate 'line', 163
    .const 'Sub' $P477 = "37_1295307687.218" 
    capture_lex $P477
    $P477()
    goto if_464_end
  if_464:
.annotate 'line', 156
    find_lex $P468, "$dispatcher"
    is_dispatcher $I469, $P468
    if $I469, if_467
.annotate 'line', 160
    new $P472, 'String'
    set $P472, "Cannot have a multi candidate for "
    find_lex $P473, "$name"
    concat $P474, $P472, $P473
    concat $P475, $P474, " when an only method is also in the class"
    die $P475
.annotate 'line', 159
    goto if_467_end
  if_467:
.annotate 'line', 157
    find_lex $P470, "$dispatcher"
    find_lex $P471, "$code"
    push_dispatchee $P470, $P471
  if_467_end:
  if_464_end:
.annotate 'line', 191
    find_lex $P547, "$i"
    add $P548, $P547, 1
    store_lex "$i", $P548
.annotate 'line', 145
    .return ($P548)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block476"  :anon :subid("37_1295307687.218") :outer("36_1295307687.218")
.annotate 'line', 163
    .const 'Sub' $P494 = "38_1295307687.218" 
    capture_lex $P494
.annotate 'line', 165
    new $P478, "Undef"
    .lex "$j", $P478
.annotate 'line', 166
    new $P479, "Undef"
    .lex "$found", $P479
.annotate 'line', 165
    new $P480, "Integer"
    assign $P480, 1
    store_lex "$j", $P480
.annotate 'line', 166
    new $P481, "Integer"
    assign $P481, 0
    store_lex "$found", $P481
.annotate 'line', 167
    new $P538, 'ExceptionHandler'
    set_addr $P538, loop537_handler
    $P538."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P538
  loop537_test:
    find_lex $P484, "$j"
    set $N485, $P484
    find_lex $P486, "self"
    get_global $P487, "$?CLASS"
    getattribute $P488, $P486, $P487, "@!mro"
    unless_null $P488, vivify_116
    $P488 = root_new ['parrot';'ResizablePMCArray']
  vivify_116:
    set $N489, $P488
    isne $I490, $N485, $N489
    if $I490, if_483
    new $P482, 'Integer'
    set $P482, $I490
    goto if_483_end
  if_483:
    find_lex $P491, "$found"
    isfalse $I492, $P491
    new $P482, 'Integer'
    set $P482, $I492
  if_483_end:
    unless $P482, loop537_done
  loop537_redo:
    .const 'Sub' $P494 = "38_1295307687.218" 
    capture_lex $P494
    $P494()
  loop537_next:
    goto loop537_test
  loop537_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P539, exception, 'type'
    eq $P539, .CONTROL_LOOP_NEXT, loop537_next
    eq $P539, .CONTROL_LOOP_REDO, loop537_redo
  loop537_done:
    pop_eh 
.annotate 'line', 187
    find_lex $P542, "$found"
    unless $P542, unless_541
    set $P540, $P542
    goto unless_541_end
  unless_541:
.annotate 'line', 188
    new $P543, 'String'
    set $P543, "Could not find a proto for multi "
    find_lex $P544, "$name"
    concat $P545, $P543, $P544
    concat $P546, $P545, ", and proto generation is NYI"
    die $P546
  unless_541_end:
.annotate 'line', 163
    .return ($P540)
.end


.namespace ["NQPClassHOW"]
.sub "_block493"  :anon :subid("38_1295307687.218") :outer("37_1295307687.218")
.annotate 'line', 167
    .const 'Sub' $P518 = "39_1295307687.218" 
    capture_lex $P518
.annotate 'line', 168
    new $P495, "Undef"
    .lex "$parent", $P495
.annotate 'line', 169
    $P496 = root_new ['parrot';'Hash']
    .lex "%meths", $P496
.annotate 'line', 170
    new $P497, "Undef"
    .lex "$dispatcher", $P497
.annotate 'line', 168
    find_lex $P498, "$j"
    set $I499, $P498
    find_lex $P500, "self"
    get_global $P501, "$?CLASS"
    getattribute $P502, $P500, $P501, "@!mro"
    unless_null $P502, vivify_117
    $P502 = root_new ['parrot';'ResizablePMCArray']
  vivify_117:
    set $P503, $P502[$I499]
    unless_null $P503, vivify_118
    new $P503, "Undef"
  vivify_118:
    store_lex "$parent", $P503
.annotate 'line', 169
    find_lex $P504, "$parent"
    get_how $P505, $P504
    find_lex $P506, "$parent"
    $P507 = $P505."method_table"($P506)
    store_lex "%meths", $P507
.annotate 'line', 170
    find_lex $P508, "$name"
    find_lex $P509, "%meths"
    unless_null $P509, vivify_119
    $P509 = root_new ['parrot';'Hash']
  vivify_119:
    set $P510, $P509[$P508]
    unless_null $P510, vivify_120
    new $P510, "Undef"
  vivify_120:
    store_lex "$dispatcher", $P510
.annotate 'line', 171
    find_lex $P512, "$dispatcher"
    defined $I513, $P512
    unless $I513, if_511_end
.annotate 'line', 174
    find_lex $P515, "$dispatcher"
    is_dispatcher $I516, $P515
    if $I516, if_514
.annotate 'line', 182
    new $P531, 'String'
    set $P531, "Could not find a proto for multi "
    find_lex $P532, "$name"
    concat $P533, $P531, $P532
    concat $P534, $P533, " (it may exist, but an only is hiding it if so)"
    die $P534
.annotate 'line', 181
    goto if_514_end
  if_514:
.annotate 'line', 174
    .const 'Sub' $P518 = "39_1295307687.218" 
    capture_lex $P518
    $P518()
  if_514_end:
  if_511_end:
.annotate 'line', 185
    find_lex $P535, "$j"
    add $P536, $P535, 1
    store_lex "$j", $P536
.annotate 'line', 167
    .return ($P536)
.end


.namespace ["NQPClassHOW"]
.sub "_block517"  :anon :subid("39_1295307687.218") :outer("38_1295307687.218")
.annotate 'line', 176
    $P519 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_dispatchees", $P519
.annotate 'line', 174
    find_lex $P520, "@new_dispatchees"
.annotate 'line', 177
    find_lex $P521, "$code"
    find_lex $P522, "@new_dispatchees"
    unless_null $P522, vivify_121
    $P522 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@new_dispatchees", $P522
  vivify_121:
    set $P522[0], $P521
.annotate 'line', 178
    find_lex $P523, "$dispatcher"
    find_lex $P524, "@new_dispatchees"
    create_dispatch_and_add_candidates $P525, $P523, $P524
    find_lex $P526, "$name"
    find_lex $P527, "self"
    get_global $P528, "$?CLASS"
    getattribute $P529, $P527, $P528, "%!methods"
    unless_null $P529, vivify_122
    $P529 = root_new ['parrot';'Hash']
    setattribute $P527, $P528, "%!methods", $P529
  vivify_122:
    set $P529[$P526], $P525
.annotate 'line', 179
    new $P530, "Integer"
    assign $P530, 1
    store_lex "$found", $P530
.annotate 'line', 174
    .return ($P530)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_type_cache"  :subid("40_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_558
    .param pmc param_559
.annotate 'line', 284
    new $P557, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P557, control_556
    push_eh $P557
    .lex "self", param_558
    .lex "$obj", param_559
.annotate 'line', 286
    find_lex $P560, "$obj"
    find_lex $P561, "self"
    get_global $P562, "$?CLASS"
    getattribute $P563, $P561, $P562, "@!mro"
    unless_null $P563, vivify_123
    $P563 = root_new ['parrot';'ResizablePMCArray']
  vivify_123:
    publish_type_check_cache $P560, $P563
.annotate 'line', 284
    .return ()
  control_556:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P564, exception, "payload"
    .return ($P564)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_method_cache"  :subid("41_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_568
    .param pmc param_569
.annotate 'line', 289
    .const 'Sub' $P579 = "42_1295307687.218" 
    capture_lex $P579
    new $P567, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P567, control_566
    push_eh $P567
    .lex "self", param_568
    .lex "$obj", param_569
.annotate 'line', 292
    $P570 = root_new ['parrot';'Hash']
    .lex "%cache", $P570
.annotate 'line', 289
    find_lex $P571, "%cache"
.annotate 'line', 293
    find_lex $P573, "self"
    get_global $P574, "$?CLASS"
    getattribute $P575, $P573, $P574, "@!mro"
    unless_null $P575, vivify_124
    $P575 = root_new ['parrot';'ResizablePMCArray']
  vivify_124:
    defined $I576, $P575
    unless $I576, for_undef_125
    iter $P572, $P575
    new $P608, 'ExceptionHandler'
    set_addr $P608, loop607_handler
    $P608."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P608
  loop607_test:
    unless $P572, loop607_done
    shift $P577, $P572
  loop607_redo:
    .const 'Sub' $P579 = "42_1295307687.218" 
    capture_lex $P579
    $P579($P577)
  loop607_next:
    goto loop607_test
  loop607_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P609, exception, 'type'
    eq $P609, .CONTROL_LOOP_NEXT, loop607_next
    eq $P609, .CONTROL_LOOP_REDO, loop607_redo
  loop607_done:
    pop_eh 
  for_undef_125:
.annotate 'line', 301
    find_lex $P610, "$obj"
    find_lex $P611, "%cache"
    publish_method_cache $P610, $P611
.annotate 'line', 289
    .return ()
  control_566:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P612, exception, "payload"
    .return ($P612)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block578"  :anon :subid("42_1295307687.218") :outer("41_1295307687.218")
    .param pmc param_581
.annotate 'line', 293
    .const 'Sub' $P591 = "43_1295307687.218" 
    capture_lex $P591
.annotate 'line', 294
    $P580 = root_new ['parrot';'Hash']
    .lex "%methods", $P580
    .lex "$_", param_581
    find_lex $P582, "$_"
    get_how $P583, $P582
    find_lex $P584, "$_"
    $P585 = $P583."method_table"($P584)
    store_lex "%methods", $P585
.annotate 'line', 295
    find_lex $P587, "%methods"
    defined $I588, $P587
    unless $I588, for_undef_126
    iter $P586, $P587
    new $P605, 'ExceptionHandler'
    set_addr $P605, loop604_handler
    $P605."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P605
  loop604_test:
    unless $P586, loop604_done
    shift $P589, $P586
  loop604_redo:
    .const 'Sub' $P591 = "43_1295307687.218" 
    capture_lex $P591
    $P591($P589)
  loop604_next:
    goto loop604_test
  loop604_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P606, exception, 'type'
    eq $P606, .CONTROL_LOOP_NEXT, loop604_next
    eq $P606, .CONTROL_LOOP_REDO, loop604_redo
  loop604_done:
    pop_eh 
  for_undef_126:
.annotate 'line', 293
    .return ($P586)
.end


.namespace ["NQPClassHOW"]
.sub "_block590"  :anon :subid("43_1295307687.218") :outer("42_1295307687.218")
    .param pmc param_592
.annotate 'line', 295
    .lex "$_", param_592
.annotate 'line', 296
    find_lex $P595, "$_"
    $P596 = $P595."key"()
    find_lex $P597, "%methods"
    unless_null $P597, vivify_127
    $P597 = root_new ['parrot';'Hash']
  vivify_127:
    set $P598, $P597[$P596]
    unless_null $P598, vivify_128
    new $P598, "Undef"
  vivify_128:
    unless $P598, unless_594
    set $P593, $P598
    goto unless_594_end
  unless_594:
.annotate 'line', 297
    find_lex $P599, "$_"
    $P600 = $P599."value"()
    find_lex $P601, "$_"
    $P602 = $P601."key"()
    find_lex $P603, "%methods"
    unless_null $P603, vivify_129
    $P603 = root_new ['parrot';'Hash']
    store_lex "%methods", $P603
  vivify_129:
    set $P603[$P602], $P600
.annotate 'line', 296
    set $P593, $P600
  unless_594_end:
.annotate 'line', 295
    .return ($P593)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "parents"  :subid("44_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_616
    .param pmc param_617
    .param pmc param_618 :named("local")
.annotate 'line', 308
    new $P615, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P615, control_614
    push_eh $P615
    .lex "self", param_616
    .lex "$obj", param_617
    .lex "$local", param_618
    find_lex $P619, "self"
    get_global $P620, "$?CLASS"
    getattribute $P621, $P619, $P620, "@!parents"
    unless_null $P621, vivify_130
    $P621 = root_new ['parrot';'ResizablePMCArray']
  vivify_130:
    .return ($P621)
  control_614:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P622, exception, "payload"
    .return ($P622)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "roles"  :subid("45_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_626
    .param pmc param_627
    .param pmc param_628 :named("local")
.annotate 'line', 312
    new $P625, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P625, control_624
    push_eh $P625
    .lex "self", param_626
    .lex "$obj", param_627
    .lex "$local", param_628
    find_lex $P629, "self"
    get_global $P630, "$?CLASS"
    getattribute $P631, $P629, $P630, "@!roles"
    unless_null $P631, vivify_131
    $P631 = root_new ['parrot';'ResizablePMCArray']
  vivify_131:
    .return ($P631)
  control_624:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P632, exception, "payload"
    .return ($P632)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("46_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_636
    .param pmc param_637
    .param pmc param_638 :named("local")
.annotate 'line', 316
    .const 'Sub' $P648 = "47_1295307687.218" 
    capture_lex $P648
    new $P635, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P635, control_634
    push_eh $P635
    .lex "self", param_636
    .lex "$obj", param_637
    .lex "$local", param_638
.annotate 'line', 317
    $P639 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P639
.annotate 'line', 316
    find_lex $P640, "@meths"
.annotate 'line', 318
    find_lex $P642, "self"
    get_global $P643, "$?CLASS"
    getattribute $P644, $P642, $P643, "%!methods"
    unless_null $P644, vivify_132
    $P644 = root_new ['parrot';'Hash']
  vivify_132:
    defined $I645, $P644
    unless $I645, for_undef_133
    iter $P641, $P644
    new $P655, 'ExceptionHandler'
    set_addr $P655, loop654_handler
    $P655."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P655
  loop654_test:
    unless $P641, loop654_done
    shift $P646, $P641
  loop654_redo:
    .const 'Sub' $P648 = "47_1295307687.218" 
    capture_lex $P648
    $P648($P646)
  loop654_next:
    goto loop654_test
  loop654_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P656, exception, 'type'
    eq $P656, .CONTROL_LOOP_NEXT, loop654_next
    eq $P656, .CONTROL_LOOP_REDO, loop654_redo
  loop654_done:
    pop_eh 
  for_undef_133:
    find_lex $P657, "@meths"
.annotate 'line', 316
    .return ($P657)
  control_634:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P658, exception, "payload"
    .return ($P658)
.end


.namespace ["NQPClassHOW"]
.sub "_block647"  :anon :subid("47_1295307687.218") :outer("46_1295307687.218")
    .param pmc param_649
.annotate 'line', 318
    .lex "$_", param_649
.annotate 'line', 319
    find_lex $P650, "@meths"
    find_lex $P651, "$_"
    $P652 = $P651."value"()
    $P653 = $P650."push"($P652)
.annotate 'line', 318
    .return ($P653)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "method_table"  :subid("48_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_662
    .param pmc param_663
.annotate 'line', 324
    new $P661, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P661, control_660
    push_eh $P661
    .lex "self", param_662
    .lex "$obj", param_663
    find_lex $P664, "self"
    get_global $P665, "$?CLASS"
    getattribute $P666, $P664, $P665, "%!methods"
    unless_null $P666, vivify_134
    $P666 = root_new ['parrot';'Hash']
  vivify_134:
    .return ($P666)
  control_660:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P667, exception, "payload"
    .return ($P667)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "name"  :subid("49_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_671
    .param pmc param_672
.annotate 'line', 328
    new $P670, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P670, control_669
    push_eh $P670
    .lex "self", param_671
    .lex "$obj", param_672
    find_lex $P673, "self"
    get_global $P674, "$?CLASS"
    getattribute $P675, $P673, $P674, "$!name"
    unless_null $P675, vivify_135
    new $P675, "Undef"
  vivify_135:
    .return ($P675)
  control_669:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P676, exception, "payload"
    .return ($P676)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("50_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_680
    .param pmc param_681
    .param pmc param_682 :named("local")
.annotate 'line', 332
    .const 'Sub' $P692 = "51_1295307687.218" 
    capture_lex $P692
    new $P679, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P679, control_678
    push_eh $P679
    .lex "self", param_680
    .lex "$obj", param_681
    .lex "$local", param_682
.annotate 'line', 333
    $P683 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P683
.annotate 'line', 332
    find_lex $P684, "@attrs"
.annotate 'line', 334
    find_lex $P686, "self"
    get_global $P687, "$?CLASS"
    getattribute $P688, $P686, $P687, "%!attributes"
    unless_null $P688, vivify_136
    $P688 = root_new ['parrot';'Hash']
  vivify_136:
    defined $I689, $P688
    unless $I689, for_undef_137
    iter $P685, $P688
    new $P699, 'ExceptionHandler'
    set_addr $P699, loop698_handler
    $P699."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P699
  loop698_test:
    unless $P685, loop698_done
    shift $P690, $P685
  loop698_redo:
    .const 'Sub' $P692 = "51_1295307687.218" 
    capture_lex $P692
    $P692($P690)
  loop698_next:
    goto loop698_test
  loop698_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P700, exception, 'type'
    eq $P700, .CONTROL_LOOP_NEXT, loop698_next
    eq $P700, .CONTROL_LOOP_REDO, loop698_redo
  loop698_done:
    pop_eh 
  for_undef_137:
    find_lex $P701, "@attrs"
.annotate 'line', 332
    .return ($P701)
  control_678:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P702, exception, "payload"
    .return ($P702)
.end


.namespace ["NQPClassHOW"]
.sub "_block691"  :anon :subid("51_1295307687.218") :outer("50_1295307687.218")
    .param pmc param_693
.annotate 'line', 334
    .lex "$_", param_693
.annotate 'line', 335
    find_lex $P694, "@attrs"
    find_lex $P695, "$_"
    $P696 = $P695."value"()
    $P697 = $P694."push"($P696)
.annotate 'line', 334
    .return ($P697)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "isa"  :subid("52_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_706
    .param pmc param_707
    .param pmc param_708
.annotate 'line', 344
    new $P705, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P705, control_704
    push_eh $P705
    .lex "self", param_706
    .lex "$obj", param_707
    .lex "$check", param_708
.annotate 'line', 345
    new $P709, "Undef"
    .lex "$check-class", $P709
.annotate 'line', 346
    new $P710, "Undef"
    .lex "$i", $P710
.annotate 'line', 345
    find_lex $P711, "$check"
    get_what $P712, $P711
    store_lex "$check-class", $P712
.annotate 'line', 346
    find_lex $P713, "self"
    get_global $P714, "$?CLASS"
    getattribute $P715, $P713, $P714, "@!mro"
    unless_null $P715, vivify_138
    $P715 = root_new ['parrot';'ResizablePMCArray']
  vivify_138:
    set $N716, $P715
    new $P717, 'Float'
    set $P717, $N716
    store_lex "$i", $P717
.annotate 'line', 347
    new $P735, 'ExceptionHandler'
    set_addr $P735, loop734_handler
    $P735."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P735
  loop734_test:
    find_lex $P718, "$i"
    set $N719, $P718
    isgt $I720, $N719, 0.0
    unless $I720, loop734_done
  loop734_redo:
.annotate 'line', 348
    find_lex $P721, "$i"
    sub $P722, $P721, 1
    store_lex "$i", $P722
.annotate 'line', 349
    find_lex $P724, "$i"
    set $I725, $P724
    find_lex $P726, "self"
    get_global $P727, "$?CLASS"
    getattribute $P728, $P726, $P727, "@!mro"
    unless_null $P728, vivify_139
    $P728 = root_new ['parrot';'ResizablePMCArray']
  vivify_139:
    set $P729, $P728[$I725]
    unless_null $P729, vivify_140
    new $P729, "Undef"
  vivify_140:
    find_lex $P730, "$check-class"
    issame $I731, $P729, $P730
    unless $I731, if_723_end
.annotate 'line', 350
    new $P732, "Exception"
    set $P732['type'], .CONTROL_RETURN
    new $P733, "Integer"
    assign $P733, 1
    setattribute $P732, 'payload', $P733
    throw $P732
  if_723_end:
  loop734_next:
.annotate 'line', 347
    goto loop734_test
  loop734_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P736, exception, 'type'
    eq $P736, .CONTROL_LOOP_NEXT, loop734_next
    eq $P736, .CONTROL_LOOP_REDO, loop734_redo
  loop734_done:
    pop_eh 
.annotate 'line', 353
    new $P737, "Exception"
    set $P737['type'], .CONTROL_RETURN
    new $P738, "Integer"
    assign $P738, 0
    setattribute $P737, 'payload', $P738
    throw $P737
.annotate 'line', 344
    .return ()
  control_704:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P739, exception, "payload"
    .return ($P739)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "does"  :subid("53_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_743
    .param pmc param_744
    .param pmc param_745
.annotate 'line', 356
    new $P742, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P742, control_741
    push_eh $P742
    .lex "self", param_743
    .lex "$obj", param_744
    .lex "$check", param_745
.annotate 'line', 357
    new $P746, "Undef"
    .lex "$i", $P746
    find_lex $P747, "self"
    get_global $P748, "$?CLASS"
    getattribute $P749, $P747, $P748, "@!done"
    unless_null $P749, vivify_141
    $P749 = root_new ['parrot';'ResizablePMCArray']
  vivify_141:
    set $N750, $P749
    new $P751, 'Float'
    set $P751, $N750
    store_lex "$i", $P751
.annotate 'line', 358
    new $P769, 'ExceptionHandler'
    set_addr $P769, loop768_handler
    $P769."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P769
  loop768_test:
    find_lex $P752, "$i"
    set $N753, $P752
    isgt $I754, $N753, 0.0
    unless $I754, loop768_done
  loop768_redo:
.annotate 'line', 359
    find_lex $P755, "$i"
    sub $P756, $P755, 1
    store_lex "$i", $P756
.annotate 'line', 360
    find_lex $P758, "$i"
    set $I759, $P758
    find_lex $P760, "self"
    get_global $P761, "$?CLASS"
    getattribute $P762, $P760, $P761, "@!done"
    unless_null $P762, vivify_142
    $P762 = root_new ['parrot';'ResizablePMCArray']
  vivify_142:
    set $P763, $P762[$I759]
    unless_null $P763, vivify_143
    new $P763, "Undef"
  vivify_143:
    find_lex $P764, "$check"
    issame $I765, $P763, $P764
    unless $I765, if_757_end
.annotate 'line', 361
    new $P766, "Exception"
    set $P766['type'], .CONTROL_RETURN
    new $P767, "Integer"
    assign $P767, 1
    setattribute $P766, 'payload', $P767
    throw $P766
  if_757_end:
  loop768_next:
.annotate 'line', 358
    goto loop768_test
  loop768_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P770, exception, 'type'
    eq $P770, .CONTROL_LOOP_NEXT, loop768_next
    eq $P770, .CONTROL_LOOP_REDO, loop768_redo
  loop768_done:
    pop_eh 
.annotate 'line', 364
    new $P771, "Exception"
    set $P771['type'], .CONTROL_RETURN
    new $P772, "Integer"
    assign $P772, 0
    setattribute $P771, 'payload', $P772
    throw $P771
.annotate 'line', 356
    .return ()
  control_741:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P773, exception, "payload"
    .return ($P773)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "can"  :subid("54_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_777
    .param pmc param_778
    .param pmc param_779
.annotate 'line', 367
    .const 'Sub' $P787 = "55_1295307687.218" 
    capture_lex $P787
    new $P776, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P776, control_775
    push_eh $P776
    .lex "self", param_777
    .lex "$obj", param_778
    .lex "$name", param_779
.annotate 'line', 368
    find_lex $P781, "self"
    get_global $P782, "$?CLASS"
    getattribute $P783, $P781, $P782, "@!mro"
    unless_null $P783, vivify_144
    $P783 = root_new ['parrot';'ResizablePMCArray']
  vivify_144:
    defined $I784, $P783
    unless $I784, for_undef_145
    iter $P780, $P783
    new $P805, 'ExceptionHandler'
    set_addr $P805, loop804_handler
    $P805."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P805
  loop804_test:
    unless $P780, loop804_done
    shift $P785, $P780
  loop804_redo:
    .const 'Sub' $P787 = "55_1295307687.218" 
    capture_lex $P787
    $P787($P785)
  loop804_next:
    goto loop804_test
  loop804_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P806, exception, 'type'
    eq $P806, .CONTROL_LOOP_NEXT, loop804_next
    eq $P806, .CONTROL_LOOP_REDO, loop804_redo
  loop804_done:
    pop_eh 
  for_undef_145:
.annotate 'line', 375
    new $P807, "Exception"
    set $P807['type'], .CONTROL_RETURN
    new $P808, "Integer"
    assign $P808, 0
    setattribute $P807, 'payload', $P808
    throw $P807
.annotate 'line', 367
    .return ()
  control_775:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P809, exception, "payload"
    .return ($P809)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block786"  :anon :subid("55_1295307687.218") :outer("54_1295307687.218")
    .param pmc param_790
.annotate 'line', 369
    $P788 = root_new ['parrot';'Hash']
    .lex "%meths", $P788
.annotate 'line', 370
    new $P789, "Undef"
    .lex "$can", $P789
    .lex "$_", param_790
.annotate 'line', 369
    find_lex $P791, "$_"
    get_how $P792, $P791
    find_lex $P793, "$obj"
    $P794 = $P792."method_table"($P793)
    store_lex "%meths", $P794
.annotate 'line', 370
    find_lex $P795, "$name"
    find_lex $P796, "%meths"
    unless_null $P796, vivify_146
    $P796 = root_new ['parrot';'Hash']
  vivify_146:
    set $P797, $P796[$P795]
    unless_null $P797, vivify_147
    new $P797, "Undef"
  vivify_147:
    store_lex "$can", $P797
.annotate 'line', 371
    find_lex $P800, "$can"
    defined $I801, $P800
    if $I801, if_799
    new $P798, 'Integer'
    set $P798, $I801
    goto if_799_end
  if_799:
.annotate 'line', 372
    new $P802, "Exception"
    set $P802['type'], .CONTROL_RETURN
    find_lex $P803, "$can"
    setattribute $P802, 'payload', $P803
    throw $P802
  if_799_end:
.annotate 'line', 368
    .return ($P798)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "find_method"  :subid("56_1295307687.218") :outer("15_1295307687.218")
    .param pmc param_813
    .param pmc param_814
    .param pmc param_815
.annotate 'line', 381
    .const 'Sub' $P823 = "57_1295307687.218" 
    capture_lex $P823
    new $P812, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P812, control_811
    push_eh $P812
    .lex "self", param_813
    .lex "$obj", param_814
    .lex "$name", param_815
.annotate 'line', 382
    find_lex $P817, "self"
    get_global $P818, "$?CLASS"
    getattribute $P819, $P817, $P818, "@!mro"
    unless_null $P819, vivify_148
    $P819 = root_new ['parrot';'ResizablePMCArray']
  vivify_148:
    defined $I820, $P819
    unless $I820, for_undef_149
    iter $P816, $P819
    new $P841, 'ExceptionHandler'
    set_addr $P841, loop840_handler
    $P841."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P841
  loop840_test:
    unless $P816, loop840_done
    shift $P821, $P816
  loop840_redo:
    .const 'Sub' $P823 = "57_1295307687.218" 
    capture_lex $P823
    $P823($P821)
  loop840_next:
    goto loop840_test
  loop840_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P842, exception, 'type'
    eq $P842, .CONTROL_LOOP_NEXT, loop840_next
    eq $P842, .CONTROL_LOOP_REDO, loop840_redo
  loop840_done:
    pop_eh 
  for_undef_149:
.annotate 'line', 389
    null $P843
.annotate 'line', 381
    .return ($P843)
  control_811:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P844, exception, "payload"
    .return ($P844)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block822"  :anon :subid("57_1295307687.218") :outer("56_1295307687.218")
    .param pmc param_826
.annotate 'line', 383
    $P824 = root_new ['parrot';'Hash']
    .lex "%meths", $P824
.annotate 'line', 384
    new $P825, "Undef"
    .lex "$found", $P825
    .lex "$_", param_826
.annotate 'line', 383
    find_lex $P827, "$_"
    get_how $P828, $P827
    find_lex $P829, "$obj"
    $P830 = $P828."method_table"($P829)
    store_lex "%meths", $P830
.annotate 'line', 384
    find_lex $P831, "$name"
    find_lex $P832, "%meths"
    unless_null $P832, vivify_150
    $P832 = root_new ['parrot';'Hash']
  vivify_150:
    set $P833, $P832[$P831]
    unless_null $P833, vivify_151
    new $P833, "Undef"
  vivify_151:
    store_lex "$found", $P833
.annotate 'line', 385
    find_lex $P836, "$found"
    defined $I837, $P836
    if $I837, if_835
    new $P834, 'Integer'
    set $P834, $I837
    goto if_835_end
  if_835:
.annotate 'line', 386
    new $P838, "Exception"
    set $P838['type'], .CONTROL_RETURN
    find_lex $P839, "$found"
    setattribute $P838, 'payload', $P839
    throw $P838
  if_835_end:
.annotate 'line', 382
    .return ($P834)
.end


.namespace ["NQPAttribute"]
.sub "_block927"  :subid("59_1295307687.218") :outer("10_1295307687.218")
.annotate 'line', 394
    .const 'Sub' $P962 = "63_1295307687.218" 
    capture_lex $P962
    .const 'Sub' $P952 = "62_1295307687.218" 
    capture_lex $P952
    .const 'Sub' $P942 = "61_1295307687.218" 
    capture_lex $P942
    .const 'Sub' $P930 = "60_1295307687.218" 
    capture_lex $P930
    get_global $P929, "$?CLASS"
.annotate 'line', 407
    .const 'Sub' $P952 = "62_1295307687.218" 
    newclosure $P960, $P952
.annotate 'line', 394
    .return ($P960)
.end


.namespace ["NQPAttribute"]
.sub "" :load :init :subid("post152") :outer("59_1295307687.218")
.annotate 'line', 394
    get_hll_global $P928, ["NQPAttribute"], "_block927" 
    .local pmc block
    set block, $P928
    .const 'Sub' $P962 = "63_1295307687.218" 
    capture_lex $P962
    $P962()
.end


.namespace ["NQPAttribute"]
.sub "_block961"  :anon :subid("63_1295307687.218") :outer("59_1295307687.218")
.annotate 'line', 394
    get_hll_global $P963, "KnowHOW"
    $P964 = $P963."new_type"("NQPAttribute" :named("name"))
    .local pmc type_obj
    set type_obj, $P964
    set_hll_global "NQPAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P965, type_obj
    get_hll_global $P966, "KnowHOWAttribute"
    $P967 = $P966."new"("$!name" :named("name"))
    $P965."add_attribute"(type_obj, $P967)
    get_how $P968, type_obj
    .const 'Sub' $P969 = "60_1295307687.218" 
    $P968."add_method"(type_obj, "new", $P969)
    get_how $P970, type_obj
    .const 'Sub' $P971 = "61_1295307687.218" 
    $P970."add_method"(type_obj, "BUILD", $P971)
    get_how $P972, type_obj
    .const 'Sub' $P973 = "62_1295307687.218" 
    $P972."add_method"(type_obj, "name", $P973)
    get_how $P974, type_obj
    $P975 = $P974."compose"(type_obj)
    .return ($P975)
.end


.namespace ["NQPAttribute"]
.include "except_types.pasm"
.sub "new"  :subid("60_1295307687.218") :outer("59_1295307687.218")
    .param pmc param_933
    .param pmc param_934 :named("name")
.annotate 'line', 397
    new $P932, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P932, control_931
    push_eh $P932
    .lex "self", param_933
    .lex "$name", param_934
.annotate 'line', 398
    new $P935, "Undef"
    .lex "$attr", $P935
    find_lex $P936, "self"
    repr_instance_of $P937, $P936
    store_lex "$attr", $P937
.annotate 'line', 399
    find_lex $P938, "$attr"
    find_lex $P939, "$name"
    $P938."BUILD"($P939 :named("name"))
    find_lex $P940, "$attr"
.annotate 'line', 397
    .return ($P940)
  control_931:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P941, exception, "payload"
    .return ($P941)
.end


.namespace ["NQPAttribute"]
.include "except_types.pasm"
.sub "BUILD"  :subid("61_1295307687.218") :outer("59_1295307687.218")
    .param pmc param_945
    .param pmc param_946 :optional :named("name")
    .param int has_param_946 :opt_flag
.annotate 'line', 403
    new $P944, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P944, control_943
    push_eh $P944
    .lex "self", param_945
    if has_param_946, optparam_153
    new $P947, "Undef"
    set param_946, $P947
  optparam_153:
    .lex "$name", param_946
.annotate 'line', 404
    find_lex $P948, "$name"
    find_lex $P949, "self"
    get_global $P950, "$?CLASS"
    setattribute $P949, $P950, "$!name", $P948
.annotate 'line', 403
    .return ($P948)
  control_943:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P951, exception, "payload"
    .return ($P951)
.end


.namespace ["NQPAttribute"]
.include "except_types.pasm"
.sub "name"  :subid("62_1295307687.218") :outer("59_1295307687.218")
    .param pmc param_955
.annotate 'line', 407
    new $P954, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P954, control_953
    push_eh $P954
    .lex "self", param_955
    find_lex $P956, "self"
    get_global $P957, "$?CLASS"
    getattribute $P958, $P956, $P957, "$!name"
    unless_null $P958, vivify_154
    new $P958, "Undef"
  vivify_154:
    .return ($P958)
  control_953:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P959, exception, "payload"
    .return ($P959)
.end


.namespace ["NQPMu"]
.sub "_block976"  :subid("64_1295307687.218") :outer("10_1295307687.218")
.annotate 'line', 413
    .const 'Sub' $P1014 = "69_1295307687.218" 
    capture_lex $P1014
    .const 'Sub' $P997 = "68_1295307687.218" 
    capture_lex $P997
    .const 'Sub' $P993 = "67_1295307687.218" 
    capture_lex $P993
    .const 'Sub' $P986 = "66_1295307687.218" 
    capture_lex $P986
    .const 'Sub' $P979 = "65_1295307687.218" 
    capture_lex $P979
    get_global $P978, "$?CLASS"
.annotate 'line', 423
    .const 'Sub' $P997 = "68_1295307687.218" 
    newclosure $P1012, $P997
.annotate 'line', 413
    .return ($P1012)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post155") :outer("64_1295307687.218")
.annotate 'line', 413
    get_hll_global $P977, ["NQPMu"], "_block976" 
    .local pmc block
    set block, $P977
    .const 'Sub' $P1014 = "69_1295307687.218" 
    capture_lex $P1014
    $P1014()
.end


.namespace ["NQPMu"]
.sub "_block1013"  :anon :subid("69_1295307687.218") :outer("64_1295307687.218")
.annotate 'line', 413
    get_hll_global $P1015, "NQPClassHOW"
    $P1016 = $P1015."new_type"("NQPMu" :named("name"))
    .local pmc type_obj
    set type_obj, $P1016
    set_hll_global "NQPMu", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1017, type_obj
    .const 'Sub' $P1018 = "65_1295307687.218" 
    $P1017."add_method"(type_obj, "CREATE", $P1018)
    get_how $P1019, type_obj
    .const 'Sub' $P1020 = "66_1295307687.218" 
    $P1019."add_method"(type_obj, "new", $P1020)
    get_how $P1021, type_obj
    .const 'Sub' $P1022 = "67_1295307687.218" 
    new $P1023, "ResizablePMCArray"
    set_dispatchees $P1022, $P1023
    $P1021."add_method"(type_obj, "ACCEPTS", $P1022)
    get_how $P1024, type_obj
    .const 'Sub' $P1025 = "68_1295307687.218" 
    $P1024."add_multi_method"(type_obj, "ACCEPTS", $P1025)
    get_how $P1026, type_obj
    $P1027 = $P1026."compose"(type_obj)
    .return ($P1027)
.end


.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "CREATE"  :subid("65_1295307687.218") :outer("64_1295307687.218")
    .param pmc param_982
.annotate 'line', 414
    new $P981, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P981, control_980
    push_eh $P981
    .lex "self", param_982
.annotate 'line', 415
    find_lex $P983, "self"
    repr_instance_of $P984, $P983
.annotate 'line', 414
    .return ($P984)
  control_980:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P985, exception, "payload"
    .return ($P985)
.end


.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "new"  :subid("66_1295307687.218") :outer("64_1295307687.218")
    .param pmc param_989
.annotate 'line', 418
    new $P988, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P988, control_987
    push_eh $P988
    .lex "self", param_989
.annotate 'line', 419
    find_lex $P990, "self"
    $P991 = $P990."CREATE"()
.annotate 'line', 418
    .return ($P991)
  control_987:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P992, exception, "payload"
    .return ($P992)
.end


.namespace ["NQPMu"]
.sub "ACCEPTS" :instanceof("DispatcherSub") :subid("67_1295307687.218") :outer("64_1295307687.218")
    .param pmc param_994
    .param pmc param_995
.annotate 'line', 418
    .lex "self", param_994
.annotate 'line', 422
    .lex "$topic", param_995
.annotate 'line', 418
    multi_dispatch_over_lexical_candidates $P996
    .return ($P996)
.end


.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "ACCEPTS"  :subid("68_1295307687.218") :outer("64_1295307687.218")
    .param pmc param_1000
    .param pmc param_1002
.annotate 'line', 423
    new $P999, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P999, control_998
    push_eh $P999
    .lex "$self", param_1000
    find_lex $P1001, "$self"
    .lex "self", $P1001
    .lex "$topic", param_1002
.annotate 'line', 424
    find_lex $P1003, "$topic"
    find_lex $P1004, "self"
    get_what $P1005, $P1004
    type_check $I1006, $P1003, $P1005
.annotate 'line', 423
    .return ($I1006)
  control_998:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1007, exception, "payload"
    .return ($P1007)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post156") :outer("68_1295307687.218")
.annotate 'line', 423
    .const 'Sub' $P997 = "68_1295307687.218" 
    .local pmc block
    set block, $P997
    get_hll_global $P1008, "NQPMu"
    null $P1009
    new $P1010, "ResizablePMCArray"
    push $P1010, $P1008
    push $P1010, $P1009
    new $P1011, "ResizablePMCArray"
    push $P1011, 2
    push $P1011, 0
    set_sub_multisig block, $P1010, $P1011
.end


.namespace []
.sub "_block1029" :load :anon :subid("70_1295307687.218")
.annotate 'line', 1
    .const 'Sub' $P1031 = "10_1295307687.218" 
    $P1032 = $P1031()
    .return ($P1032)
.end


.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
.end

### .include 'gen/nqp-grammar.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1295307698.031")
.annotate 'line', 0
    get_hll_global $P14, ["NQP";"Grammar"], "_block13" 
    capture_lex $P14
.annotate 'line', 1
    nqp_dynop_setup 
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P14, ["NQP";"Grammar"], "_block13" 
    capture_lex $P14
    $P1586 = $P14()
.annotate 'line', 1
    .return ($P1586)
    .const 'Sub' $P1588 = "394_1295307698.031" 
    .return ($P1588)
.end


.namespace []
.sub "" :load :init :subid("post395") :outer("10_1295307698.031")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1295307698.031" 
    .local pmc block
    set block, $P12
    $P1591 = get_root_global ["parrot"], "P6metaclass"
    $P1591."new_class"("NQP::Grammar", "HLL::Grammar" :named("parent"))
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block13"  :subid("11_1295307698.031") :outer("10_1295307698.031")
.annotate 'line', 4
    get_hll_global $P1503, ["NQP";"Regex"], "_block1502" 
    capture_lex $P1503
    .const 'Sub' $P1489 = "371_1295307698.031" 
    capture_lex $P1489
    .const 'Sub' $P1483 = "369_1295307698.031" 
    capture_lex $P1483
    .const 'Sub' $P1477 = "367_1295307698.031" 
    capture_lex $P1477
    .const 'Sub' $P1471 = "365_1295307698.031" 
    capture_lex $P1471
    .const 'Sub' $P1465 = "363_1295307698.031" 
    capture_lex $P1465
    .const 'Sub' $P1459 = "361_1295307698.031" 
    capture_lex $P1459
    .const 'Sub' $P1452 = "359_1295307698.031" 
    capture_lex $P1452
    .const 'Sub' $P1445 = "357_1295307698.031" 
    capture_lex $P1445
    .const 'Sub' $P1438 = "355_1295307698.031" 
    capture_lex $P1438
    .const 'Sub' $P1431 = "353_1295307698.031" 
    capture_lex $P1431
    .const 'Sub' $P1425 = "351_1295307698.031" 
    capture_lex $P1425
    .const 'Sub' $P1418 = "349_1295307698.031" 
    capture_lex $P1418
    .const 'Sub' $P1411 = "347_1295307698.031" 
    capture_lex $P1411
    .const 'Sub' $P1404 = "345_1295307698.031" 
    capture_lex $P1404
    .const 'Sub' $P1397 = "343_1295307698.031" 
    capture_lex $P1397
    .const 'Sub' $P1390 = "341_1295307698.031" 
    capture_lex $P1390
    .const 'Sub' $P1383 = "339_1295307698.031" 
    capture_lex $P1383
    .const 'Sub' $P1376 = "337_1295307698.031" 
    capture_lex $P1376
    .const 'Sub' $P1369 = "335_1295307698.031" 
    capture_lex $P1369
    .const 'Sub' $P1362 = "333_1295307698.031" 
    capture_lex $P1362
    .const 'Sub' $P1355 = "331_1295307698.031" 
    capture_lex $P1355
    .const 'Sub' $P1348 = "329_1295307698.031" 
    capture_lex $P1348
    .const 'Sub' $P1341 = "327_1295307698.031" 
    capture_lex $P1341
    .const 'Sub' $P1334 = "325_1295307698.031" 
    capture_lex $P1334
    .const 'Sub' $P1327 = "323_1295307698.031" 
    capture_lex $P1327
    .const 'Sub' $P1320 = "321_1295307698.031" 
    capture_lex $P1320
    .const 'Sub' $P1313 = "319_1295307698.031" 
    capture_lex $P1313
    .const 'Sub' $P1306 = "317_1295307698.031" 
    capture_lex $P1306
    .const 'Sub' $P1299 = "315_1295307698.031" 
    capture_lex $P1299
    .const 'Sub' $P1292 = "313_1295307698.031" 
    capture_lex $P1292
    .const 'Sub' $P1285 = "311_1295307698.031" 
    capture_lex $P1285
    .const 'Sub' $P1278 = "309_1295307698.031" 
    capture_lex $P1278
    .const 'Sub' $P1271 = "307_1295307698.031" 
    capture_lex $P1271
    .const 'Sub' $P1264 = "305_1295307698.031" 
    capture_lex $P1264
    .const 'Sub' $P1257 = "303_1295307698.031" 
    capture_lex $P1257
    .const 'Sub' $P1250 = "301_1295307698.031" 
    capture_lex $P1250
    .const 'Sub' $P1243 = "299_1295307698.031" 
    capture_lex $P1243
    .const 'Sub' $P1236 = "297_1295307698.031" 
    capture_lex $P1236
    .const 'Sub' $P1229 = "295_1295307698.031" 
    capture_lex $P1229
    .const 'Sub' $P1222 = "293_1295307698.031" 
    capture_lex $P1222
    .const 'Sub' $P1216 = "291_1295307698.031" 
    capture_lex $P1216
    .const 'Sub' $P1209 = "289_1295307698.031" 
    capture_lex $P1209
    .const 'Sub' $P1202 = "287_1295307698.031" 
    capture_lex $P1202
    .const 'Sub' $P1195 = "285_1295307698.031" 
    capture_lex $P1195
    .const 'Sub' $P1188 = "283_1295307698.031" 
    capture_lex $P1188
    .const 'Sub' $P1181 = "281_1295307698.031" 
    capture_lex $P1181
    .const 'Sub' $P1174 = "279_1295307698.031" 
    capture_lex $P1174
    .const 'Sub' $P1167 = "277_1295307698.031" 
    capture_lex $P1167
    .const 'Sub' $P1161 = "275_1295307698.031" 
    capture_lex $P1161
    .const 'Sub' $P1155 = "273_1295307698.031" 
    capture_lex $P1155
    .const 'Sub' $P1150 = "271_1295307698.031" 
    capture_lex $P1150
    .const 'Sub' $P1144 = "269_1295307698.031" 
    capture_lex $P1144
    .const 'Sub' $P1138 = "267_1295307698.031" 
    capture_lex $P1138
    .const 'Sub' $P1133 = "265_1295307698.031" 
    capture_lex $P1133
    .const 'Sub' $P1128 = "263_1295307698.031" 
    capture_lex $P1128
    .const 'Sub' $P1120 = "261_1295307698.031" 
    capture_lex $P1120
    .const 'Sub' $P1111 = "259_1295307698.031" 
    capture_lex $P1111
    .const 'Sub' $P1106 = "257_1295307698.031" 
    capture_lex $P1106
    .const 'Sub' $P1101 = "255_1295307698.031" 
    capture_lex $P1101
    .const 'Sub' $P1096 = "253_1295307698.031" 
    capture_lex $P1096
    .const 'Sub' $P1088 = "251_1295307698.031" 
    capture_lex $P1088
    .const 'Sub' $P1080 = "249_1295307698.031" 
    capture_lex $P1080
    .const 'Sub' $P1075 = "247_1295307698.031" 
    capture_lex $P1075
    .const 'Sub' $P1070 = "245_1295307698.031" 
    capture_lex $P1070
    .const 'Sub' $P1065 = "243_1295307698.031" 
    capture_lex $P1065
    .const 'Sub' $P1059 = "241_1295307698.031" 
    capture_lex $P1059
    .const 'Sub' $P1053 = "239_1295307698.031" 
    capture_lex $P1053
    .const 'Sub' $P1047 = "237_1295307698.031" 
    capture_lex $P1047
    .const 'Sub' $P1041 = "235_1295307698.031" 
    capture_lex $P1041
    .const 'Sub' $P1035 = "233_1295307698.031" 
    capture_lex $P1035
    .const 'Sub' $P1030 = "231_1295307698.031" 
    capture_lex $P1030
    .const 'Sub' $P1025 = "229_1295307698.031" 
    capture_lex $P1025
    .const 'Sub' $P1013 = "225_1295307698.031" 
    capture_lex $P1013
    .const 'Sub' $P1005 = "223_1295307698.031" 
    capture_lex $P1005
    .const 'Sub' $P999 = "221_1295307698.031" 
    capture_lex $P999
    .const 'Sub' $P992 = "219_1295307698.031" 
    capture_lex $P992
    .const 'Sub' $P986 = "217_1295307698.031" 
    capture_lex $P986
    .const 'Sub' $P972 = "214_1295307698.031" 
    capture_lex $P972
    .const 'Sub' $P964 = "212_1295307698.031" 
    capture_lex $P964
    .const 'Sub' $P956 = "210_1295307698.031" 
    capture_lex $P956
    .const 'Sub' $P950 = "208_1295307698.031" 
    capture_lex $P950
    .const 'Sub' $P944 = "206_1295307698.031" 
    capture_lex $P944
    .const 'Sub' $P930 = "202_1295307698.031" 
    capture_lex $P930
    .const 'Sub' $P893 = "200_1295307698.031" 
    capture_lex $P893
    .const 'Sub' $P882 = "198_1295307698.031" 
    capture_lex $P882
    .const 'Sub' $P870 = "194_1295307698.031" 
    capture_lex $P870
    .const 'Sub' $P861 = "192_1295307698.031" 
    capture_lex $P861
    .const 'Sub' $P855 = "190_1295307698.031" 
    capture_lex $P855
    .const 'Sub' $P845 = "188_1295307698.031" 
    capture_lex $P845
    .const 'Sub' $P830 = "186_1295307698.031" 
    capture_lex $P830
    .const 'Sub' $P816 = "183_1295307698.031" 
    capture_lex $P816
    .const 'Sub' $P808 = "181_1295307698.031" 
    capture_lex $P808
    .const 'Sub' $P798 = "179_1295307698.031" 
    capture_lex $P798
    .const 'Sub' $P788 = "177_1295307698.031" 
    capture_lex $P788
    .const 'Sub' $P771 = "172_1295307698.031" 
    capture_lex $P771
    .const 'Sub' $P733 = "169_1295307698.031" 
    capture_lex $P733
    .const 'Sub' $P702 = "167_1295307698.031" 
    capture_lex $P702
    .const 'Sub' $P695 = "165_1295307698.031" 
    capture_lex $P695
    .const 'Sub' $P688 = "163_1295307698.031" 
    capture_lex $P688
    .const 'Sub' $P678 = "159_1295307698.031" 
    capture_lex $P678
    .const 'Sub' $P670 = "157_1295307698.031" 
    capture_lex $P670
    .const 'Sub' $P664 = "155_1295307698.031" 
    capture_lex $P664
    .const 'Sub' $P651 = "153_1295307698.031" 
    capture_lex $P651
    .const 'Sub' $P644 = "151_1295307698.031" 
    capture_lex $P644
    .const 'Sub' $P637 = "149_1295307698.031" 
    capture_lex $P637
    .const 'Sub' $P630 = "147_1295307698.031" 
    capture_lex $P630
    .const 'Sub' $P596 = "143_1295307698.031" 
    capture_lex $P596
    .const 'Sub' $P584 = "141_1295307698.031" 
    capture_lex $P584
    .const 'Sub' $P575 = "139_1295307698.031" 
    capture_lex $P575
    .const 'Sub' $P563 = "137_1295307698.031" 
    capture_lex $P563
    .const 'Sub' $P551 = "135_1295307698.031" 
    capture_lex $P551
    .const 'Sub' $P544 = "133_1295307698.031" 
    capture_lex $P544
    .const 'Sub' $P535 = "129_1295307698.031" 
    capture_lex $P535
    .const 'Sub' $P530 = "127_1295307698.031" 
    capture_lex $P530
    .const 'Sub' $P518 = "125_1295307698.031" 
    capture_lex $P518
    .const 'Sub' $P506 = "123_1295307698.031" 
    capture_lex $P506
    .const 'Sub' $P499 = "121_1295307698.031" 
    capture_lex $P499
    .const 'Sub' $P494 = "119_1295307698.031" 
    capture_lex $P494
    .const 'Sub' $P488 = "117_1295307698.031" 
    capture_lex $P488
    .const 'Sub' $P482 = "115_1295307698.031" 
    capture_lex $P482
    .const 'Sub' $P467 = "111_1295307698.031" 
    capture_lex $P467
    .const 'Sub' $P461 = "109_1295307698.031" 
    capture_lex $P461
    .const 'Sub' $P455 = "107_1295307698.031" 
    capture_lex $P455
    .const 'Sub' $P449 = "105_1295307698.031" 
    capture_lex $P449
    .const 'Sub' $P443 = "103_1295307698.031" 
    capture_lex $P443
    .const 'Sub' $P437 = "101_1295307698.031" 
    capture_lex $P437
    .const 'Sub' $P431 = "99_1295307698.031" 
    capture_lex $P431
    .const 'Sub' $P422 = "97_1295307698.031" 
    capture_lex $P422
    .const 'Sub' $P413 = "95_1295307698.031" 
    capture_lex $P413
    .const 'Sub' $P404 = "93_1295307698.031" 
    capture_lex $P404
    .const 'Sub' $P391 = "89_1295307698.031" 
    capture_lex $P391
    .const 'Sub' $P382 = "87_1295307698.031" 
    capture_lex $P382
    .const 'Sub' $P372 = "83_1295307698.031" 
    capture_lex $P372
    .const 'Sub' $P365 = "81_1295307698.031" 
    capture_lex $P365
    .const 'Sub' $P358 = "79_1295307698.031" 
    capture_lex $P358
    .const 'Sub' $P346 = "75_1295307698.031" 
    capture_lex $P346
    .const 'Sub' $P338 = "73_1295307698.031" 
    capture_lex $P338
    .const 'Sub' $P330 = "71_1295307698.031" 
    capture_lex $P330
    .const 'Sub' $P310 = "69_1295307698.031" 
    capture_lex $P310
    .const 'Sub' $P301 = "67_1295307698.031" 
    capture_lex $P301
    .const 'Sub' $P283 = "64_1295307698.031" 
    capture_lex $P283
    .const 'Sub' $P265 = "62_1295307698.031" 
    capture_lex $P265
    .const 'Sub' $P256 = "58_1295307698.031" 
    capture_lex $P256
    .const 'Sub' $P251 = "56_1295307698.031" 
    capture_lex $P251
    .const 'Sub' $P242 = "52_1295307698.031" 
    capture_lex $P242
    .const 'Sub' $P237 = "50_1295307698.031" 
    capture_lex $P237
    .const 'Sub' $P232 = "48_1295307698.031" 
    capture_lex $P232
    .const 'Sub' $P223 = "46_1295307698.031" 
    capture_lex $P223
    .const 'Sub' $P216 = "44_1295307698.031" 
    capture_lex $P216
    .const 'Sub' $P210 = "42_1295307698.031" 
    capture_lex $P210
    .const 'Sub' $P202 = "40_1295307698.031" 
    capture_lex $P202
    .const 'Sub' $P196 = "38_1295307698.031" 
    capture_lex $P196
    .const 'Sub' $P190 = "36_1295307698.031" 
    capture_lex $P190
    .const 'Sub' $P175 = "33_1295307698.031" 
    capture_lex $P175
    .const 'Sub' $P161 = "31_1295307698.031" 
    capture_lex $P161
    .const 'Sub' $P154 = "29_1295307698.031" 
    capture_lex $P154
    .const 'Sub' $P115 = "26_1295307698.031" 
    capture_lex $P115
    .const 'Sub' $P100 = "23_1295307698.031" 
    capture_lex $P100
    .const 'Sub' $P89 = "21_1295307698.031" 
    capture_lex $P89
    .const 'Sub' $P77 = "19_1295307698.031" 
    capture_lex $P77
    .const 'Sub' $P69 = "17_1295307698.031" 
    capture_lex $P69
    .const 'Sub' $P62 = "15_1295307698.031" 
    capture_lex $P62
    .const 'Sub' $P55 = "13_1295307698.031" 
    capture_lex $P55
    .const 'Sub' $P15 = "12_1295307698.031" 
    capture_lex $P15
    nqp_dynop_setup 
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 640
    get_hll_global $P1503, ["NQP";"Regex"], "_block1502" 
    capture_lex $P1503
    $P1565 = $P1503()
.annotate 'line', 4
    .return ($P1565)
    .const 'Sub' $P1567 = "393_1295307698.031" 
    .return ($P1567)
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post396") :outer("11_1295307698.031")
.annotate 'line', 4
    get_hll_global $P14, ["NQP";"Grammar"], "_block13" 
    .local pmc block
    set block, $P14
.annotate 'line', 521
    get_hll_global $P1570, ["NQP"], "Grammar"
    $P1570."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 522
    get_hll_global $P1571, ["NQP"], "Grammar"
    $P1571."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 523
    get_hll_global $P1572, ["NQP"], "Grammar"
    $P1572."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 524
    get_hll_global $P1573, ["NQP"], "Grammar"
    $P1573."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 525
    get_hll_global $P1574, ["NQP"], "Grammar"
    $P1574."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 526
    get_hll_global $P1575, ["NQP"], "Grammar"
    $P1575."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 527
    get_hll_global $P1576, ["NQP"], "Grammar"
    $P1576."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 528
    get_hll_global $P1577, ["NQP"], "Grammar"
    $P1577."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 529
    get_hll_global $P1578, ["NQP"], "Grammar"
    $P1578."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 530
    get_hll_global $P1579, ["NQP"], "Grammar"
    $P1579."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 531
    get_hll_global $P1580, ["NQP"], "Grammar"
    $P1580."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 532
    get_hll_global $P1581, ["NQP"], "Grammar"
    $P1581."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 533
    get_hll_global $P1582, ["NQP"], "Grammar"
    $P1582."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 534
    get_hll_global $P1583, ["NQP"], "Grammar"
    $P1583."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 535
    get_hll_global $P1584, ["NQP"], "Grammar"
    $P1584."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 520
    $P1585 = get_root_global ["parrot"], "P6metaclass"
    $P1585."new_class"("NQP::Regex", "Regex::P6Regex::Grammar" :named("parent"))
.end


.namespace ["NQP";"Grammar"]
.include "except_types.pasm"
.sub "TOP"  :subid("12_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    new $P17, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P17, control_16
    push_eh $P17
    .lex "self", self
.annotate 'line', 5
    $P18 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P18
.annotate 'line', 12
    $P19 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P19
.annotate 'line', 19
    new $P20, "Undef"
    .lex "$*DEFAULT-METAATTR", $P20
.annotate 'line', 20
    $P21 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P21
.annotate 'line', 23
    new $P22, "Undef"
    .lex "$*SCOPE", $P22
.annotate 'line', 24
    new $P23, "Undef"
    .lex "$*MULTINESS", $P23
.annotate 'line', 25
    new $P24, "Undef"
    .lex "$*INVOCANT_OK", $P24
.annotate 'line', 26
    new $P25, "Undef"
    .lex "$*PACKAGE-SETUP", $P25
.annotate 'line', 4
    find_lex $P26, "%*LANG"
    unless_null $P26, vivify_397
    get_hll_global $P26, "%LANG"
    unless_null $P26, vivify_398
    die "Contextual %*LANG not found"
  vivify_398:
  vivify_397:
.annotate 'line', 6
    get_hll_global $P27, ["NQP"], "Regex"
    find_lex $P28, "%*LANG"
    unless_null $P28, vivify_399
    get_hll_global $P28, "%LANG"
    unless_null $P28, vivify_400
    die "Contextual %*LANG not found"
  vivify_400:
    store_lex "%*LANG", $P28
  vivify_399:
    set $P28["Regex"], $P27
.annotate 'line', 7
    get_hll_global $P29, ["NQP"], "RegexActions"
    find_lex $P30, "%*LANG"
    unless_null $P30, vivify_401
    get_hll_global $P30, "%LANG"
    unless_null $P30, vivify_402
    die "Contextual %*LANG not found"
  vivify_402:
    store_lex "%*LANG", $P30
  vivify_401:
    set $P30["Regex-actions"], $P29
.annotate 'line', 8
    get_hll_global $P31, ["NQP"], "Grammar"
    find_lex $P32, "%*LANG"
    unless_null $P32, vivify_403
    get_hll_global $P32, "%LANG"
    unless_null $P32, vivify_404
    die "Contextual %*LANG not found"
  vivify_404:
    store_lex "%*LANG", $P32
  vivify_403:
    set $P32["MAIN"], $P31
.annotate 'line', 9
    get_hll_global $P33, ["NQP"], "Actions"
    find_lex $P34, "%*LANG"
    unless_null $P34, vivify_405
    get_hll_global $P34, "%LANG"
    unless_null $P34, vivify_406
    die "Contextual %*LANG not found"
  vivify_406:
    store_lex "%*LANG", $P34
  vivify_405:
    set $P34["MAIN-actions"], $P33
    find_lex $P35, "%*HOW"
    unless_null $P35, vivify_407
    get_hll_global $P35, "%HOW"
    unless_null $P35, vivify_408
    die "Contextual %*HOW not found"
  vivify_408:
  vivify_407:
.annotate 'line', 13
    new $P36, "String"
    assign $P36, "KnowHOW"
    find_lex $P37, "%*HOW"
    unless_null $P37, vivify_409
    get_hll_global $P37, "%HOW"
    unless_null $P37, vivify_410
    die "Contextual %*HOW not found"
  vivify_410:
    store_lex "%*HOW", $P37
  vivify_409:
    set $P37["knowhow"], $P36
.annotate 'line', 14
    new $P38, "String"
    assign $P38, "NQPClassHOW"
    find_lex $P39, "%*HOW"
    unless_null $P39, vivify_411
    get_hll_global $P39, "%HOW"
    unless_null $P39, vivify_412
    die "Contextual %*HOW not found"
  vivify_412:
    store_lex "%*HOW", $P39
  vivify_411:
    set $P39["class"], $P38
.annotate 'line', 15
    new $P40, "String"
    assign $P40, "NQPGrammarHOW"
    find_lex $P41, "%*HOW"
    unless_null $P41, vivify_413
    get_hll_global $P41, "%HOW"
    unless_null $P41, vivify_414
    die "Contextual %*HOW not found"
  vivify_414:
    store_lex "%*HOW", $P41
  vivify_413:
    set $P41["grammar"], $P40
.annotate 'line', 16
    new $P42, "String"
    assign $P42, "NQPRoleHOW"
    find_lex $P43, "%*HOW"
    unless_null $P43, vivify_415
    get_hll_global $P43, "%HOW"
    unless_null $P43, vivify_416
    die "Contextual %*HOW not found"
  vivify_416:
    store_lex "%*HOW", $P43
  vivify_415:
    set $P43["role"], $P42
.annotate 'line', 19
    new $P44, "String"
    assign $P44, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P44
    find_lex $P45, "%*HOW-METAATTR"
    unless_null $P45, vivify_417
    get_hll_global $P45, "%HOW-METAATTR"
    unless_null $P45, vivify_418
    die "Contextual %*HOW-METAATTR not found"
  vivify_418:
  vivify_417:
.annotate 'line', 21
    new $P46, "String"
    assign $P46, "KnowHOWAttribute"
    find_lex $P47, "%*HOW-METAATTR"
    unless_null $P47, vivify_419
    get_hll_global $P47, "%HOW-METAATTR"
    unless_null $P47, vivify_420
    die "Contextual %*HOW-METAATTR not found"
  vivify_420:
    store_lex "%*HOW-METAATTR", $P47
  vivify_419:
    set $P47["knowhow"], $P46
.annotate 'line', 23
    new $P48, "String"
    assign $P48, ""
    store_lex "$*SCOPE", $P48
.annotate 'line', 24
    new $P49, "String"
    assign $P49, ""
    store_lex "$*MULTINESS", $P49
.annotate 'line', 25
    new $P50, "Integer"
    assign $P50, 0
    store_lex "$*INVOCANT_OK", $P50
    find_lex $P51, "$*PACKAGE-SETUP"
    unless_null $P51, vivify_421
    get_hll_global $P51, "$PACKAGE-SETUP"
    unless_null $P51, vivify_422
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_422:
  vivify_421:
.annotate 'line', 27
    find_lex $P52, "self"
    $P53 = $P52."comp_unit"()
.annotate 'line', 4
    .return ($P53)
  control_16:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P54, exception, "payload"
    .return ($P54)
.end


.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx56_tgt
    .local int rx56_pos
    .local int rx56_off
    .local int rx56_eos
    .local int rx56_rep
    .local pmc rx56_cur
    .local pmc rx56_debug
    (rx56_cur, rx56_pos, rx56_tgt, $I10) = self."!cursor_start"()
    getattribute rx56_debug, rx56_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx56_cur
    .local pmc match
    .lex "$/", match
    length rx56_eos, rx56_tgt
    gt rx56_pos, rx56_eos, rx56_done
    set rx56_off, 0
    lt rx56_pos, 2, rx56_start
    sub rx56_off, rx56_pos, 1
    substr rx56_tgt, rx56_tgt, rx56_off
  rx56_start:
    eq $I10, 1, rx56_restart
    if_null rx56_debug, debug_423
    rx56_cur."!cursor_debug"("START", "identifier")
  debug_423:
    $I10 = self.'from'()
    ne $I10, -1, rxscan60_done
    goto rxscan60_scan
  rxscan60_loop:
    ($P10) = rx56_cur."from"()
    inc $P10
    set rx56_pos, $P10
    ge rx56_pos, rx56_eos, rxscan60_done
  rxscan60_scan:
    set_addr $I10, rxscan60_loop
    rx56_cur."!mark_push"(0, rx56_pos, $I10)
  rxscan60_done:
.annotate 'line', 32
  # rx subrule "ident" subtype=method negate=
    rx56_cur."!cursor_pos"(rx56_pos)
    $P10 = rx56_cur."ident"()
    unless $P10, rx56_fail
    rx56_pos = $P10."pos"()
  # rx rxquantr61 ** 0..*
    set_addr $I10, rxquantr61_done
    rx56_cur."!mark_push"(0, rx56_pos, $I10)
  rxquantr61_loop:
  # rx enumcharlist negate=0 
    ge rx56_pos, rx56_eos, rx56_fail
    sub $I10, rx56_pos, rx56_off
    substr $S10, rx56_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx56_fail
    inc rx56_pos
  # rx subrule "ident" subtype=method negate=
    rx56_cur."!cursor_pos"(rx56_pos)
    $P10 = rx56_cur."ident"()
    unless $P10, rx56_fail
    rx56_pos = $P10."pos"()
    set_addr $I10, rxquantr61_done
    (rx56_rep) = rx56_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr61_done
    rx56_cur."!mark_push"(rx56_rep, rx56_pos, $I10)
    goto rxquantr61_loop
  rxquantr61_done:
  # rx pass
    rx56_cur."!cursor_pass"(rx56_pos, "identifier")
    if_null rx56_debug, debug_424
    rx56_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx56_pos)
  debug_424:
    .return (rx56_cur)
  rx56_restart:
.annotate 'line', 4
    if_null rx56_debug, debug_425
    rx56_cur."!cursor_debug"("NEXT", "identifier")
  debug_425:
  rx56_fail:
    (rx56_rep, rx56_pos, $I10, $P10) = rx56_cur."!mark_fail"(0)
    lt rx56_pos, -1, rx56_done
    eq rx56_pos, -1, rx56_fail
    jump $I10
  rx56_done:
    rx56_cur."!cursor_fail"()
    if_null rx56_debug, debug_426
    rx56_cur."!cursor_debug"("FAIL", "identifier")
  debug_426:
    .return (rx56_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("14_1295307698.031") :method
.annotate 'line', 4
    $P58 = self."!PREFIX__!subrule"("ident", "")
    new $P59, "ResizablePMCArray"
    push $P59, $P58
    .return ($P59)
.end


.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx63_tgt
    .local int rx63_pos
    .local int rx63_off
    .local int rx63_eos
    .local int rx63_rep
    .local pmc rx63_cur
    .local pmc rx63_debug
    (rx63_cur, rx63_pos, rx63_tgt, $I10) = self."!cursor_start"()
    rx63_cur."!cursor_caparray"("identifier")
    getattribute rx63_debug, rx63_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx63_cur
    .local pmc match
    .lex "$/", match
    length rx63_eos, rx63_tgt
    gt rx63_pos, rx63_eos, rx63_done
    set rx63_off, 0
    lt rx63_pos, 2, rx63_start
    sub rx63_off, rx63_pos, 1
    substr rx63_tgt, rx63_tgt, rx63_off
  rx63_start:
    eq $I10, 1, rx63_restart
    if_null rx63_debug, debug_427
    rx63_cur."!cursor_debug"("START", "name")
  debug_427:
    $I10 = self.'from'()
    ne $I10, -1, rxscan66_done
    goto rxscan66_scan
  rxscan66_loop:
    ($P10) = rx63_cur."from"()
    inc $P10
    set rx63_pos, $P10
    ge rx63_pos, rx63_eos, rxscan66_done
  rxscan66_scan:
    set_addr $I10, rxscan66_loop
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxscan66_done:
.annotate 'line', 34
  # rx rxquantr67 ** 1..*
    set_addr $I10, rxquantr67_done
    rx63_cur."!mark_push"(0, -1, $I10)
  rxquantr67_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."identifier"()
    unless $P10, rx63_fail
    goto rxsubrule68_pass
  rxsubrule68_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx63_fail
  rxsubrule68_pass:
    set_addr $I10, rxsubrule68_back
    rx63_cur."!mark_push"(0, rx63_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx63_pos = $P10."pos"()
    set_addr $I10, rxquantr67_done
    (rx63_rep) = rx63_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr67_done
    rx63_cur."!mark_push"(rx63_rep, rx63_pos, $I10)
  # rx literal  "::"
    add $I11, rx63_pos, 2
    gt $I11, rx63_eos, rx63_fail
    sub $I11, rx63_pos, rx63_off
    substr $S10, rx63_tgt, $I11, 2
    ne $S10, "::", rx63_fail
    add rx63_pos, 2
    goto rxquantr67_loop
  rxquantr67_done:
  # rx pass
    rx63_cur."!cursor_pass"(rx63_pos, "name")
    if_null rx63_debug, debug_428
    rx63_cur."!cursor_debug"("PASS", "name", " at pos=", rx63_pos)
  debug_428:
    .return (rx63_cur)
  rx63_restart:
.annotate 'line', 4
    if_null rx63_debug, debug_429
    rx63_cur."!cursor_debug"("NEXT", "name")
  debug_429:
  rx63_fail:
    (rx63_rep, rx63_pos, $I10, $P10) = rx63_cur."!mark_fail"(0)
    lt rx63_pos, -1, rx63_done
    eq rx63_pos, -1, rx63_fail
    jump $I10
  rx63_done:
    rx63_cur."!cursor_fail"()
    if_null rx63_debug, debug_430
    rx63_cur."!cursor_debug"("FAIL", "name")
  debug_430:
    .return (rx63_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("16_1295307698.031") :method
.annotate 'line', 4
    new $P65, "ResizablePMCArray"
    push $P65, ""
    .return ($P65)
.end


.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx70_tgt
    .local int rx70_pos
    .local int rx70_off
    .local int rx70_eos
    .local int rx70_rep
    .local pmc rx70_cur
    .local pmc rx70_debug
    (rx70_cur, rx70_pos, rx70_tgt, $I10) = self."!cursor_start"()
    rx70_cur."!cursor_caparray"("colonpair")
    getattribute rx70_debug, rx70_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx70_cur
    .local pmc match
    .lex "$/", match
    length rx70_eos, rx70_tgt
    gt rx70_pos, rx70_eos, rx70_done
    set rx70_off, 0
    lt rx70_pos, 2, rx70_start
    sub rx70_off, rx70_pos, 1
    substr rx70_tgt, rx70_tgt, rx70_off
  rx70_start:
    eq $I10, 1, rx70_restart
    if_null rx70_debug, debug_431
    rx70_cur."!cursor_debug"("START", "deflongname")
  debug_431:
    $I10 = self.'from'()
    ne $I10, -1, rxscan74_done
    goto rxscan74_scan
  rxscan74_loop:
    ($P10) = rx70_cur."from"()
    inc $P10
    set rx70_pos, $P10
    ge rx70_pos, rx70_eos, rxscan74_done
  rxscan74_scan:
    set_addr $I10, rxscan74_loop
    rx70_cur."!mark_push"(0, rx70_pos, $I10)
  rxscan74_done:
.annotate 'line', 37
  # rx subrule "identifier" subtype=capture negate=
    rx70_cur."!cursor_pos"(rx70_pos)
    $P10 = rx70_cur."identifier"()
    unless $P10, rx70_fail
    rx70_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx70_pos = $P10."pos"()
  # rx rxquantr75 ** 0..1
    set_addr $I10, rxquantr75_done
    rx70_cur."!mark_push"(0, rx70_pos, $I10)
  rxquantr75_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx70_cur."!cursor_pos"(rx70_pos)
    $P10 = rx70_cur."colonpair"()
    unless $P10, rx70_fail
    goto rxsubrule76_pass
  rxsubrule76_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx70_fail
  rxsubrule76_pass:
    set_addr $I10, rxsubrule76_back
    rx70_cur."!mark_push"(0, rx70_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx70_pos = $P10."pos"()
    set_addr $I10, rxquantr75_done
    (rx70_rep) = rx70_cur."!mark_commit"($I10)
  rxquantr75_done:
.annotate 'line', 36
  # rx pass
    rx70_cur."!cursor_pass"(rx70_pos, "deflongname")
    if_null rx70_debug, debug_432
    rx70_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx70_pos)
  debug_432:
    .return (rx70_cur)
  rx70_restart:
.annotate 'line', 4
    if_null rx70_debug, debug_433
    rx70_cur."!cursor_debug"("NEXT", "deflongname")
  debug_433:
  rx70_fail:
    (rx70_rep, rx70_pos, $I10, $P10) = rx70_cur."!mark_fail"(0)
    lt rx70_pos, -1, rx70_done
    eq rx70_pos, -1, rx70_fail
    jump $I10
  rx70_done:
    rx70_cur."!cursor_fail"()
    if_null rx70_debug, debug_434
    rx70_cur."!cursor_debug"("FAIL", "deflongname")
  debug_434:
    .return (rx70_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("18_1295307698.031") :method
.annotate 'line', 4
    $P72 = self."!PREFIX__!subrule"("identifier", "")
    new $P73, "ResizablePMCArray"
    push $P73, $P72
    .return ($P73)
.end


.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx78_tgt
    .local int rx78_pos
    .local int rx78_off
    .local int rx78_eos
    .local int rx78_rep
    .local pmc rx78_cur
    .local pmc rx78_debug
    (rx78_cur, rx78_pos, rx78_tgt, $I10) = self."!cursor_start"()
    getattribute rx78_debug, rx78_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx78_cur
    .local pmc match
    .lex "$/", match
    length rx78_eos, rx78_tgt
    gt rx78_pos, rx78_eos, rx78_done
    set rx78_off, 0
    lt rx78_pos, 2, rx78_start
    sub rx78_off, rx78_pos, 1
    substr rx78_tgt, rx78_tgt, rx78_off
  rx78_start:
    eq $I10, 1, rx78_restart
    if_null rx78_debug, debug_435
    rx78_cur."!cursor_debug"("START", "ENDSTMT")
  debug_435:
    $I10 = self.'from'()
    ne $I10, -1, rxscan81_done
    goto rxscan81_scan
  rxscan81_loop:
    ($P10) = rx78_cur."from"()
    inc $P10
    set rx78_pos, $P10
    ge rx78_pos, rx78_eos, rxscan81_done
  rxscan81_scan:
    set_addr $I10, rxscan81_loop
    rx78_cur."!mark_push"(0, rx78_pos, $I10)
  rxscan81_done:
.annotate 'line', 44
  # rx rxquantr82 ** 0..1
    set_addr $I10, rxquantr82_done
    rx78_cur."!mark_push"(0, rx78_pos, $I10)
  rxquantr82_loop:
  alt83_0:
.annotate 'line', 41
    set_addr $I10, alt83_1
    rx78_cur."!mark_push"(0, rx78_pos, $I10)
.annotate 'line', 42
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx78_pos, rx78_off
    set rx78_rep, 0
    sub $I12, rx78_eos, rx78_pos
  rxenumcharlistq84_loop:
    le $I12, 0, rxenumcharlistq84_done
    substr $S10, rx78_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq84_done
    inc rx78_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq84_loop
  rxenumcharlistq84_done:
    add rx78_pos, rx78_pos, rx78_rep
  # rxanchor eol
    sub $I10, rx78_pos, rx78_off
    is_cclass $I11, 4096, rx78_tgt, $I10
    if $I11, rxanchor85_done
    ne rx78_pos, rx78_eos, rx78_fail
    eq rx78_pos, 0, rxanchor85_done
    dec $I10
    is_cclass $I11, 4096, rx78_tgt, $I10
    if $I11, rx78_fail
  rxanchor85_done:
  # rx subrule "ws" subtype=method negate=
    rx78_cur."!cursor_pos"(rx78_pos)
    $P10 = rx78_cur."ws"()
    unless $P10, rx78_fail
    rx78_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx78_cur."!cursor_pos"(rx78_pos)
    $P10 = rx78_cur."MARKER"("endstmt")
    unless $P10, rx78_fail
    goto alt83_end
  alt83_1:
.annotate 'line', 43
  # rx rxquantr86 ** 0..1
    set_addr $I10, rxquantr86_done
    rx78_cur."!mark_push"(0, rx78_pos, $I10)
  rxquantr86_loop:
  # rx subrule "unv" subtype=method negate=
    rx78_cur."!cursor_pos"(rx78_pos)
    $P10 = rx78_cur."unv"()
    unless $P10, rx78_fail
    goto rxsubrule87_pass
  rxsubrule87_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx78_fail
  rxsubrule87_pass:
    set_addr $I10, rxsubrule87_back
    rx78_cur."!mark_push"(0, rx78_pos, $I10, $P10)
    rx78_pos = $P10."pos"()
    set_addr $I10, rxquantr86_done
    (rx78_rep) = rx78_cur."!mark_commit"($I10)
  rxquantr86_done:
  # rxanchor eol
    sub $I10, rx78_pos, rx78_off
    is_cclass $I11, 4096, rx78_tgt, $I10
    if $I11, rxanchor88_done
    ne rx78_pos, rx78_eos, rx78_fail
    eq rx78_pos, 0, rxanchor88_done
    dec $I10
    is_cclass $I11, 4096, rx78_tgt, $I10
    if $I11, rx78_fail
  rxanchor88_done:
  # rx subrule "ws" subtype=method negate=
    rx78_cur."!cursor_pos"(rx78_pos)
    $P10 = rx78_cur."ws"()
    unless $P10, rx78_fail
    rx78_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx78_cur."!cursor_pos"(rx78_pos)
    $P10 = rx78_cur."MARKER"("endstmt")
    unless $P10, rx78_fail
  alt83_end:
.annotate 'line', 44
    set_addr $I10, rxquantr82_done
    (rx78_rep) = rx78_cur."!mark_commit"($I10)
  rxquantr82_done:
.annotate 'line', 40
  # rx pass
    rx78_cur."!cursor_pass"(rx78_pos, "ENDSTMT")
    if_null rx78_debug, debug_436
    rx78_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx78_pos)
  debug_436:
    .return (rx78_cur)
  rx78_restart:
.annotate 'line', 4
    if_null rx78_debug, debug_437
    rx78_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_437:
  rx78_fail:
    (rx78_rep, rx78_pos, $I10, $P10) = rx78_cur."!mark_fail"(0)
    lt rx78_pos, -1, rx78_done
    eq rx78_pos, -1, rx78_fail
    jump $I10
  rx78_done:
    rx78_cur."!cursor_fail"()
    if_null rx78_debug, debug_438
    rx78_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_438:
    .return (rx78_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("20_1295307698.031") :method
.annotate 'line', 4
    new $P80, "ResizablePMCArray"
    push $P80, ""
    .return ($P80)
.end


.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx90_tgt
    .local int rx90_pos
    .local int rx90_off
    .local int rx90_eos
    .local int rx90_rep
    .local pmc rx90_cur
    .local pmc rx90_debug
    (rx90_cur, rx90_pos, rx90_tgt, $I10) = self."!cursor_start"()
    getattribute rx90_debug, rx90_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx90_cur
    .local pmc match
    .lex "$/", match
    length rx90_eos, rx90_tgt
    gt rx90_pos, rx90_eos, rx90_done
    set rx90_off, 0
    lt rx90_pos, 2, rx90_start
    sub rx90_off, rx90_pos, 1
    substr rx90_tgt, rx90_tgt, rx90_off
  rx90_start:
    eq $I10, 1, rx90_restart
    if_null rx90_debug, debug_439
    rx90_cur."!cursor_debug"("START", "ws")
  debug_439:
    $I10 = self.'from'()
    ne $I10, -1, rxscan93_done
    goto rxscan93_scan
  rxscan93_loop:
    ($P10) = rx90_cur."from"()
    inc $P10
    set rx90_pos, $P10
    ge rx90_pos, rx90_eos, rxscan93_done
  rxscan93_scan:
    set_addr $I10, rxscan93_loop
    rx90_cur."!mark_push"(0, rx90_pos, $I10)
  rxscan93_done:
  alt94_0:
.annotate 'line', 47
    set_addr $I10, alt94_1
    rx90_cur."!mark_push"(0, rx90_pos, $I10)
.annotate 'line', 48
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx90_cur."!cursor_pos"(rx90_pos)
    $P10 = rx90_cur."MARKED"("ws")
    unless $P10, rx90_fail
    goto alt94_end
  alt94_1:
.annotate 'line', 49
  # rx subrule "ww" subtype=zerowidth negate=1
    rx90_cur."!cursor_pos"(rx90_pos)
    $P10 = rx90_cur."ww"()
    if $P10, rx90_fail
.annotate 'line', 54
  # rx rxquantr95 ** 0..*
    set_addr $I10, rxquantr95_done
    rx90_cur."!mark_push"(0, rx90_pos, $I10)
  rxquantr95_loop:
  alt96_0:
.annotate 'line', 50
    set_addr $I10, alt96_1
    rx90_cur."!mark_push"(0, rx90_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx90_pos, rx90_off
    set rx90_rep, 0
    sub $I12, rx90_eos, rx90_pos
  rxenumcharlistq97_loop:
    le $I12, 0, rxenumcharlistq97_done
    substr $S10, rx90_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq97_done
    inc rx90_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq97_loop
  rxenumcharlistq97_done:
    lt rx90_rep, 1, rx90_fail
    add rx90_pos, rx90_pos, rx90_rep
    goto alt96_end
  alt96_1:
    set_addr $I10, alt96_2
    rx90_cur."!mark_push"(0, rx90_pos, $I10)
.annotate 'line', 51
  # rx literal  "#"
    add $I11, rx90_pos, 1
    gt $I11, rx90_eos, rx90_fail
    sub $I11, rx90_pos, rx90_off
    ord $I11, rx90_tgt, $I11
    ne $I11, 35, rx90_fail
    add rx90_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx90_pos, rx90_off
    find_cclass $I11, 4096, rx90_tgt, $I10, rx90_eos
    add rx90_pos, rx90_off, $I11
    goto alt96_end
  alt96_2:
    set_addr $I10, alt96_3
    rx90_cur."!mark_push"(0, rx90_pos, $I10)
.annotate 'line', 52
  # rxanchor bol
    eq rx90_pos, 0, rxanchor98_done
    ge rx90_pos, rx90_eos, rx90_fail
    sub $I10, rx90_pos, rx90_off
    dec $I10
    is_cclass $I11, 4096, rx90_tgt, $I10
    unless $I11, rx90_fail
  rxanchor98_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx90_cur."!cursor_pos"(rx90_pos)
    $P10 = rx90_cur."pod_comment"()
    unless $P10, rx90_fail
    rx90_pos = $P10."pos"()
    goto alt96_end
  alt96_3:
.annotate 'line', 53
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx90_pos, rx90_off
    set rx90_rep, 0
    sub $I12, rx90_eos, rx90_pos
  rxenumcharlistq99_loop:
    le $I12, 0, rxenumcharlistq99_done
    substr $S10, rx90_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq99_done
    inc rx90_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq99_loop
  rxenumcharlistq99_done:
    lt rx90_rep, 1, rx90_fail
    add rx90_pos, rx90_pos, rx90_rep
  alt96_end:
.annotate 'line', 54
    set_addr $I10, rxquantr95_done
    (rx90_rep) = rx90_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr95_done
    rx90_cur."!mark_push"(rx90_rep, rx90_pos, $I10)
    goto rxquantr95_loop
  rxquantr95_done:
.annotate 'line', 55
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx90_cur."!cursor_pos"(rx90_pos)
    $P10 = rx90_cur."MARKER"("ws")
    unless $P10, rx90_fail
  alt94_end:
.annotate 'line', 47
  # rx pass
    rx90_cur."!cursor_pass"(rx90_pos, "ws")
    if_null rx90_debug, debug_440
    rx90_cur."!cursor_debug"("PASS", "ws", " at pos=", rx90_pos)
  debug_440:
    .return (rx90_cur)
  rx90_restart:
.annotate 'line', 4
    if_null rx90_debug, debug_441
    rx90_cur."!cursor_debug"("NEXT", "ws")
  debug_441:
  rx90_fail:
    (rx90_rep, rx90_pos, $I10, $P10) = rx90_cur."!mark_fail"(0)
    lt rx90_pos, -1, rx90_done
    eq rx90_pos, -1, rx90_fail
    jump $I10
  rx90_done:
    rx90_cur."!cursor_fail"()
    if_null rx90_debug, debug_442
    rx90_cur."!cursor_debug"("FAIL", "ws")
  debug_442:
    .return (rx90_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("22_1295307698.031") :method
.annotate 'line', 4
    new $P92, "ResizablePMCArray"
    push $P92, ""
    push $P92, ""
    .return ($P92)
.end


.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .const 'Sub' $P108 = "25_1295307698.031" 
    capture_lex $P108
    .local string rx101_tgt
    .local int rx101_pos
    .local int rx101_off
    .local int rx101_eos
    .local int rx101_rep
    .local pmc rx101_cur
    .local pmc rx101_debug
    (rx101_cur, rx101_pos, rx101_tgt, $I10) = self."!cursor_start"()
    getattribute rx101_debug, rx101_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx101_cur
    .local pmc match
    .lex "$/", match
    length rx101_eos, rx101_tgt
    gt rx101_pos, rx101_eos, rx101_done
    set rx101_off, 0
    lt rx101_pos, 2, rx101_start
    sub rx101_off, rx101_pos, 1
    substr rx101_tgt, rx101_tgt, rx101_off
  rx101_start:
    eq $I10, 1, rx101_restart
    if_null rx101_debug, debug_443
    rx101_cur."!cursor_debug"("START", "unv")
  debug_443:
    $I10 = self.'from'()
    ne $I10, -1, rxscan104_done
    goto rxscan104_scan
  rxscan104_loop:
    ($P10) = rx101_cur."from"()
    inc $P10
    set rx101_pos, $P10
    ge rx101_pos, rx101_eos, rxscan104_done
  rxscan104_scan:
    set_addr $I10, rxscan104_loop
    rx101_cur."!mark_push"(0, rx101_pos, $I10)
  rxscan104_done:
  alt105_0:
.annotate 'line', 60
    set_addr $I10, alt105_1
    rx101_cur."!mark_push"(0, rx101_pos, $I10)
.annotate 'line', 61
  # rxanchor bol
    eq rx101_pos, 0, rxanchor106_done
    ge rx101_pos, rx101_eos, rx101_fail
    sub $I10, rx101_pos, rx101_off
    dec $I10
    is_cclass $I11, 4096, rx101_tgt, $I10
    unless $I11, rx101_fail
  rxanchor106_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx101_cur."!cursor_pos"(rx101_pos)
    .const 'Sub' $P108 = "25_1295307698.031" 
    capture_lex $P108
    $P10 = rx101_cur."before"($P108)
    unless $P10, rx101_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx101_cur."!cursor_pos"(rx101_pos)
    $P10 = rx101_cur."pod_comment"()
    unless $P10, rx101_fail
    rx101_pos = $P10."pos"()
    goto alt105_end
  alt105_1:
    set_addr $I10, alt105_2
    rx101_cur."!mark_push"(0, rx101_pos, $I10)
.annotate 'line', 62
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx101_pos, rx101_off
    set rx101_rep, 0
    sub $I12, rx101_eos, rx101_pos
  rxenumcharlistq113_loop:
    le $I12, 0, rxenumcharlistq113_done
    substr $S10, rx101_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq113_done
    inc rx101_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq113_loop
  rxenumcharlistq113_done:
    add rx101_pos, rx101_pos, rx101_rep
  # rx literal  "#"
    add $I11, rx101_pos, 1
    gt $I11, rx101_eos, rx101_fail
    sub $I11, rx101_pos, rx101_off
    ord $I11, rx101_tgt, $I11
    ne $I11, 35, rx101_fail
    add rx101_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx101_pos, rx101_off
    find_cclass $I11, 4096, rx101_tgt, $I10, rx101_eos
    add rx101_pos, rx101_off, $I11
    goto alt105_end
  alt105_2:
.annotate 'line', 63
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx101_pos, rx101_off
    set rx101_rep, 0
    sub $I12, rx101_eos, rx101_pos
  rxenumcharlistq114_loop:
    le $I12, 0, rxenumcharlistq114_done
    substr $S10, rx101_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq114_done
    inc rx101_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq114_loop
  rxenumcharlistq114_done:
    lt rx101_rep, 1, rx101_fail
    add rx101_pos, rx101_pos, rx101_rep
  alt105_end:
.annotate 'line', 58
  # rx pass
    rx101_cur."!cursor_pass"(rx101_pos, "unv")
    if_null rx101_debug, debug_448
    rx101_cur."!cursor_debug"("PASS", "unv", " at pos=", rx101_pos)
  debug_448:
    .return (rx101_cur)
  rx101_restart:
.annotate 'line', 4
    if_null rx101_debug, debug_449
    rx101_cur."!cursor_debug"("NEXT", "unv")
  debug_449:
  rx101_fail:
    (rx101_rep, rx101_pos, $I10, $P10) = rx101_cur."!mark_fail"(0)
    lt rx101_pos, -1, rx101_done
    eq rx101_pos, -1, rx101_fail
    jump $I10
  rx101_done:
    rx101_cur."!cursor_fail"()
    if_null rx101_debug, debug_450
    rx101_cur."!cursor_debug"("FAIL", "unv")
  debug_450:
    .return (rx101_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("24_1295307698.031") :method
.annotate 'line', 4
    new $P103, "ResizablePMCArray"
    push $P103, ""
    push $P103, ""
    push $P103, ""
    .return ($P103)
.end


.namespace ["NQP";"Grammar"]
.sub "_block107"  :anon :subid("25_1295307698.031") :method :outer("23_1295307698.031")
.annotate 'line', 61
    .local string rx109_tgt
    .local int rx109_pos
    .local int rx109_off
    .local int rx109_eos
    .local int rx109_rep
    .local pmc rx109_cur
    .local pmc rx109_debug
    (rx109_cur, rx109_pos, rx109_tgt, $I10) = self."!cursor_start"()
    getattribute rx109_debug, rx109_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx109_cur
    .local pmc match
    .lex "$/", match
    length rx109_eos, rx109_tgt
    gt rx109_pos, rx109_eos, rx109_done
    set rx109_off, 0
    lt rx109_pos, 2, rx109_start
    sub rx109_off, rx109_pos, 1
    substr rx109_tgt, rx109_tgt, rx109_off
  rx109_start:
    eq $I10, 1, rx109_restart
    if_null rx109_debug, debug_444
    rx109_cur."!cursor_debug"("START", "")
  debug_444:
    $I10 = self.'from'()
    ne $I10, -1, rxscan110_done
    goto rxscan110_scan
  rxscan110_loop:
    ($P10) = rx109_cur."from"()
    inc $P10
    set rx109_pos, $P10
    ge rx109_pos, rx109_eos, rxscan110_done
  rxscan110_scan:
    set_addr $I10, rxscan110_loop
    rx109_cur."!mark_push"(0, rx109_pos, $I10)
  rxscan110_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx109_pos, rx109_off
    set rx109_rep, 0
    sub $I12, rx109_eos, rx109_pos
  rxenumcharlistq111_loop:
    le $I12, 0, rxenumcharlistq111_done
    substr $S10, rx109_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq111_done
    inc rx109_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq111_loop
  rxenumcharlistq111_done:
    add rx109_pos, rx109_pos, rx109_rep
  # rx literal  "="
    add $I11, rx109_pos, 1
    gt $I11, rx109_eos, rx109_fail
    sub $I11, rx109_pos, rx109_off
    ord $I11, rx109_tgt, $I11
    ne $I11, 61, rx109_fail
    add rx109_pos, 1
  alt112_0:
    set_addr $I10, alt112_1
    rx109_cur."!mark_push"(0, rx109_pos, $I10)
  # rx charclass w
    ge rx109_pos, rx109_eos, rx109_fail
    sub $I10, rx109_pos, rx109_off
    is_cclass $I11, 8192, rx109_tgt, $I10
    unless $I11, rx109_fail
    inc rx109_pos
    goto alt112_end
  alt112_1:
  # rx literal  "\\"
    add $I11, rx109_pos, 1
    gt $I11, rx109_eos, rx109_fail
    sub $I11, rx109_pos, rx109_off
    ord $I11, rx109_tgt, $I11
    ne $I11, 92, rx109_fail
    add rx109_pos, 1
  alt112_end:
  # rx pass
    rx109_cur."!cursor_pass"(rx109_pos, "")
    if_null rx109_debug, debug_445
    rx109_cur."!cursor_debug"("PASS", "", " at pos=", rx109_pos)
  debug_445:
    .return (rx109_cur)
  rx109_restart:
    if_null rx109_debug, debug_446
    rx109_cur."!cursor_debug"("NEXT", "")
  debug_446:
  rx109_fail:
    (rx109_rep, rx109_pos, $I10, $P10) = rx109_cur."!mark_fail"(0)
    lt rx109_pos, -1, rx109_done
    eq rx109_pos, -1, rx109_fail
    jump $I10
  rx109_done:
    rx109_cur."!cursor_fail"()
    if_null rx109_debug, debug_447
    rx109_cur."!cursor_debug"("FAIL", "")
  debug_447:
    .return (rx109_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .const 'Sub' $P147 = "28_1295307698.031" 
    capture_lex $P147
    .local string rx116_tgt
    .local int rx116_pos
    .local int rx116_off
    .local int rx116_eos
    .local int rx116_rep
    .local pmc rx116_cur
    .local pmc rx116_debug
    (rx116_cur, rx116_pos, rx116_tgt, $I10) = self."!cursor_start"()
    getattribute rx116_debug, rx116_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx116_cur
    .local pmc match
    .lex "$/", match
    length rx116_eos, rx116_tgt
    gt rx116_pos, rx116_eos, rx116_done
    set rx116_off, 0
    lt rx116_pos, 2, rx116_start
    sub rx116_off, rx116_pos, 1
    substr rx116_tgt, rx116_tgt, rx116_off
  rx116_start:
    eq $I10, 1, rx116_restart
    if_null rx116_debug, debug_451
    rx116_cur."!cursor_debug"("START", "pod_comment")
  debug_451:
    $I10 = self.'from'()
    ne $I10, -1, rxscan119_done
    goto rxscan119_scan
  rxscan119_loop:
    ($P10) = rx116_cur."from"()
    inc $P10
    set rx116_pos, $P10
    ge rx116_pos, rx116_eos, rxscan119_done
  rxscan119_scan:
    set_addr $I10, rxscan119_loop
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  rxscan119_done:
.annotate 'line', 68
  # rxanchor bol
    eq rx116_pos, 0, rxanchor120_done
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    dec $I10
    is_cclass $I11, 4096, rx116_tgt, $I10
    unless $I11, rx116_fail
  rxanchor120_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq121_loop:
    le $I12, 0, rxenumcharlistq121_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq121_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq121_loop
  rxenumcharlistq121_done:
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "="
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 61, rx116_fail
    add rx116_pos, 1
  alt122_0:
.annotate 'line', 69
    set_addr $I10, alt122_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
.annotate 'line', 70
  # rx literal  "begin"
    add $I11, rx116_pos, 5
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    substr $S10, rx116_tgt, $I11, 5
    ne $S10, "begin", rx116_fail
    add rx116_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq123_loop:
    le $I12, 0, rxenumcharlistq123_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq123_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq123_loop
  rxenumcharlistq123_done:
    lt rx116_rep, 1, rx116_fail
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "END"
    add $I11, rx116_pos, 3
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    substr $S10, rx116_tgt, $I11, 3
    ne $S10, "END", rx116_fail
    add rx116_pos, 3
  # rxanchor rwb
    le rx116_pos, 0, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 8192, rx116_tgt, $I10
    if $I11, rx116_fail
    dec $I10
    is_cclass $I11, 8192, rx116_tgt, $I10
    unless $I11, rx116_fail
  alt124_0:
.annotate 'line', 71
    set_addr $I10, alt124_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  # rx rxquantf125 ** 0..*
    set_addr $I10, rxquantf125_loop
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
    goto rxquantf125_done
  rxquantf125_loop:
  # rx charclass .
    ge rx116_pos, rx116_eos, rx116_fail
    inc rx116_pos
    set_addr $I10, rxquantf125_loop
    rx116_cur."!mark_push"(rx116_rep, rx116_pos, $I10)
  rxquantf125_done:
  # rx charclass nl
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 4096, rx116_tgt, $I10
    unless $I11, rx116_fail
    substr $S10, rx116_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx116_pos, $I11
    inc rx116_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq127_loop:
    le $I12, 0, rxenumcharlistq127_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq127_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq127_loop
  rxenumcharlistq127_done:
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "=end"
    add $I11, rx116_pos, 4
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    substr $S10, rx116_tgt, $I11, 4
    ne $S10, "=end", rx116_fail
    add rx116_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq128_loop:
    le $I12, 0, rxenumcharlistq128_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq128_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq128_loop
  rxenumcharlistq128_done:
    lt rx116_rep, 1, rx116_fail
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "END"
    add $I11, rx116_pos, 3
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    substr $S10, rx116_tgt, $I11, 3
    ne $S10, "END", rx116_fail
    add rx116_pos, 3
  # rxanchor rwb
    le rx116_pos, 0, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 8192, rx116_tgt, $I10
    if $I11, rx116_fail
    dec $I10
    is_cclass $I11, 8192, rx116_tgt, $I10
    unless $I11, rx116_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx116_pos, rx116_off
    find_cclass $I11, 4096, rx116_tgt, $I10, rx116_eos
    add rx116_pos, rx116_off, $I11
    goto alt124_end
  alt124_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx116_pos, rx116_off
    find_not_cclass $I11, 65535, rx116_tgt, $I10, rx116_eos
    add rx116_pos, rx116_off, $I11
  alt124_end:
.annotate 'line', 70
    goto alt122_end
  alt122_1:
    set_addr $I10, alt122_2
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
.annotate 'line', 72
  # rx literal  "begin"
    add $I11, rx116_pos, 5
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    substr $S10, rx116_tgt, $I11, 5
    ne $S10, "begin", rx116_fail
    add rx116_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq129_loop:
    le $I12, 0, rxenumcharlistq129_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq129_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq129_loop
  rxenumcharlistq129_done:
    lt rx116_rep, 1, rx116_fail
    add rx116_pos, rx116_pos, rx116_rep
  # rx subrule "identifier" subtype=capture negate=
    rx116_cur."!cursor_pos"(rx116_pos)
    $P10 = rx116_cur."identifier"()
    unless $P10, rx116_fail
    rx116_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx116_pos = $P10."pos"()
  alt130_0:
.annotate 'line', 73
    set_addr $I10, alt130_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
.annotate 'line', 74
  # rx rxquantf131 ** 0..*
    set_addr $I10, rxquantf131_loop
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
    goto rxquantf131_done
  rxquantf131_loop:
  # rx charclass .
    ge rx116_pos, rx116_eos, rx116_fail
    inc rx116_pos
    set_addr $I10, rxquantf131_loop
    rx116_cur."!mark_push"(rx116_rep, rx116_pos, $I10)
  rxquantf131_done:
  # rx charclass nl
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 4096, rx116_tgt, $I10
    unless $I11, rx116_fail
    substr $S10, rx116_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx116_pos, $I11
    inc rx116_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq133_loop:
    le $I12, 0, rxenumcharlistq133_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq133_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq133_loop
  rxenumcharlistq133_done:
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "=end"
    add $I11, rx116_pos, 4
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    substr $S10, rx116_tgt, $I11, 4
    ne $S10, "=end", rx116_fail
    add rx116_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq134_loop:
    le $I12, 0, rxenumcharlistq134_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq134_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq134_loop
  rxenumcharlistq134_done:
    lt rx116_rep, 1, rx116_fail
    add rx116_pos, rx116_pos, rx116_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx116_cur."!cursor_pos"(rx116_pos)
    $P10 = rx116_cur."!BACKREF"("identifier")
    unless $P10, rx116_fail
    rx116_pos = $P10."pos"()
  # rxanchor rwb
    le rx116_pos, 0, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 8192, rx116_tgt, $I10
    if $I11, rx116_fail
    dec $I10
    is_cclass $I11, 8192, rx116_tgt, $I10
    unless $I11, rx116_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx116_pos, rx116_off
    find_cclass $I11, 4096, rx116_tgt, $I10, rx116_eos
    add rx116_pos, rx116_off, $I11
    goto alt130_end
  alt130_1:
.annotate 'line', 75
  # rx subrule "panic" subtype=method negate=
    rx116_cur."!cursor_pos"(rx116_pos)
    $P10 = rx116_cur."panic"("=begin without matching =end")
    unless $P10, rx116_fail
    rx116_pos = $P10."pos"()
  alt130_end:
.annotate 'line', 72
    goto alt122_end
  alt122_2:
    set_addr $I10, alt122_3
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
.annotate 'line', 77
  # rx literal  "begin"
    add $I11, rx116_pos, 5
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    substr $S10, rx116_tgt, $I11, 5
    ne $S10, "begin", rx116_fail
    add rx116_pos, 5
  # rxanchor rwb
    le rx116_pos, 0, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 8192, rx116_tgt, $I10
    if $I11, rx116_fail
    dec $I10
    is_cclass $I11, 8192, rx116_tgt, $I10
    unless $I11, rx116_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq136_loop:
    le $I12, 0, rxenumcharlistq136_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq136_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq136_loop
  rxenumcharlistq136_done:
    add rx116_pos, rx116_pos, rx116_rep
  alt137_0:
.annotate 'line', 78
    set_addr $I10, alt137_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  # rxanchor eol
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 4096, rx116_tgt, $I10
    if $I11, rxanchor138_done
    ne rx116_pos, rx116_eos, rx116_fail
    eq rx116_pos, 0, rxanchor138_done
    dec $I10
    is_cclass $I11, 4096, rx116_tgt, $I10
    if $I11, rx116_fail
  rxanchor138_done:
    goto alt137_end
  alt137_1:
    set_addr $I10, alt137_2
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  # rx literal  "#"
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 35, rx116_fail
    add rx116_pos, 1
    goto alt137_end
  alt137_2:
  # rx subrule "panic" subtype=method negate=
    rx116_cur."!cursor_pos"(rx116_pos)
    $P10 = rx116_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx116_fail
    rx116_pos = $P10."pos"()
  alt137_end:
  alt139_0:
.annotate 'line', 79
    set_addr $I10, alt139_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
.annotate 'line', 80
  # rx rxquantf140 ** 0..*
    set_addr $I10, rxquantf140_loop
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
    goto rxquantf140_done
  rxquantf140_loop:
  # rx charclass .
    ge rx116_pos, rx116_eos, rx116_fail
    inc rx116_pos
    set_addr $I10, rxquantf140_loop
    rx116_cur."!mark_push"(rx116_rep, rx116_pos, $I10)
  rxquantf140_done:
  # rx charclass nl
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 4096, rx116_tgt, $I10
    unless $I11, rx116_fail
    substr $S10, rx116_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx116_pos, $I11
    inc rx116_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq142_loop:
    le $I12, 0, rxenumcharlistq142_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq142_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq142_loop
  rxenumcharlistq142_done:
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "=end"
    add $I11, rx116_pos, 4
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    substr $S10, rx116_tgt, $I11, 4
    ne $S10, "=end", rx116_fail
    add rx116_pos, 4
  # rxanchor rwb
    le rx116_pos, 0, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 8192, rx116_tgt, $I10
    if $I11, rx116_fail
    dec $I10
    is_cclass $I11, 8192, rx116_tgt, $I10
    unless $I11, rx116_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx116_pos, rx116_off
    find_cclass $I11, 4096, rx116_tgt, $I10, rx116_eos
    add rx116_pos, rx116_off, $I11
    goto alt139_end
  alt139_1:
.annotate 'line', 81
  # rx subrule "panic" subtype=method negate=
    rx116_cur."!cursor_pos"(rx116_pos)
    $P10 = rx116_cur."panic"("=begin without matching =end")
    unless $P10, rx116_fail
    rx116_pos = $P10."pos"()
  alt139_end:
.annotate 'line', 77
    goto alt122_end
  alt122_3:
    set_addr $I10, alt122_4
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
.annotate 'line', 83
  # rx subrule "identifier" subtype=capture negate=
    rx116_cur."!cursor_pos"(rx116_pos)
    $P10 = rx116_cur."identifier"()
    unless $P10, rx116_fail
    rx116_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx116_pos = $P10."pos"()
.annotate 'line', 84
  # rx rxquantf143 ** 0..*
    set_addr $I10, rxquantf143_loop
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
    goto rxquantf143_done
  rxquantf143_loop:
  # rx charclass .
    ge rx116_pos, rx116_eos, rx116_fail
    inc rx116_pos
    set_addr $I10, rxquantf143_loop
    rx116_cur."!mark_push"(rx116_rep, rx116_pos, $I10)
  rxquantf143_done:
  # rxanchor bol
    eq rx116_pos, 0, rxanchor145_done
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    dec $I10
    is_cclass $I11, 4096, rx116_tgt, $I10
    unless $I11, rx116_fail
  rxanchor145_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx116_cur."!cursor_pos"(rx116_pos)
    .const 'Sub' $P147 = "28_1295307698.031" 
    capture_lex $P147
    $P10 = rx116_cur."before"($P147)
    unless $P10, rx116_fail
.annotate 'line', 83
    goto alt122_end
  alt122_4:
  alt153_0:
.annotate 'line', 90
    set_addr $I10, alt153_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  # rx charclass s
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 32, rx116_tgt, $I10
    unless $I11, rx116_fail
    inc rx116_pos
    goto alt153_end
  alt153_1:
  # rx subrule "panic" subtype=method negate=
    rx116_cur."!cursor_pos"(rx116_pos)
    $P10 = rx116_cur."panic"("Illegal pod directive")
    unless $P10, rx116_fail
    rx116_pos = $P10."pos"()
  alt153_end:
.annotate 'line', 91
  # rx charclass_q N r 0..-1
    sub $I10, rx116_pos, rx116_off
    find_cclass $I11, 4096, rx116_tgt, $I10, rx116_eos
    add rx116_pos, rx116_off, $I11
  alt122_end:
.annotate 'line', 67
  # rx pass
    rx116_cur."!cursor_pass"(rx116_pos, "pod_comment")
    if_null rx116_debug, debug_456
    rx116_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx116_pos)
  debug_456:
    .return (rx116_cur)
  rx116_restart:
.annotate 'line', 4
    if_null rx116_debug, debug_457
    rx116_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_457:
  rx116_fail:
    (rx116_rep, rx116_pos, $I10, $P10) = rx116_cur."!mark_fail"(0)
    lt rx116_pos, -1, rx116_done
    eq rx116_pos, -1, rx116_fail
    jump $I10
  rx116_done:
    rx116_cur."!cursor_fail"()
    if_null rx116_debug, debug_458
    rx116_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_458:
    .return (rx116_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("27_1295307698.031") :method
.annotate 'line', 4
    new $P118, "ResizablePMCArray"
    push $P118, ""
    .return ($P118)
.end


.namespace ["NQP";"Grammar"]
.sub "_block146"  :anon :subid("28_1295307698.031") :method :outer("26_1295307698.031")
.annotate 'line', 84
    .local string rx148_tgt
    .local int rx148_pos
    .local int rx148_off
    .local int rx148_eos
    .local int rx148_rep
    .local pmc rx148_cur
    .local pmc rx148_debug
    (rx148_cur, rx148_pos, rx148_tgt, $I10) = self."!cursor_start"()
    getattribute rx148_debug, rx148_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx148_cur
    .local pmc match
    .lex "$/", match
    length rx148_eos, rx148_tgt
    gt rx148_pos, rx148_eos, rx148_done
    set rx148_off, 0
    lt rx148_pos, 2, rx148_start
    sub rx148_off, rx148_pos, 1
    substr rx148_tgt, rx148_tgt, rx148_off
  rx148_start:
    eq $I10, 1, rx148_restart
    if_null rx148_debug, debug_452
    rx148_cur."!cursor_debug"("START", "")
  debug_452:
    $I10 = self.'from'()
    ne $I10, -1, rxscan149_done
    goto rxscan149_scan
  rxscan149_loop:
    ($P10) = rx148_cur."from"()
    inc $P10
    set rx148_pos, $P10
    ge rx148_pos, rx148_eos, rxscan149_done
  rxscan149_scan:
    set_addr $I10, rxscan149_loop
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
  rxscan149_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx148_pos, rx148_off
    set rx148_rep, 0
    sub $I12, rx148_eos, rx148_pos
  rxenumcharlistq150_loop:
    le $I12, 0, rxenumcharlistq150_done
    substr $S10, rx148_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq150_done
    inc rx148_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq150_loop
  rxenumcharlistq150_done:
    add rx148_pos, rx148_pos, rx148_rep
  alt151_0:
    set_addr $I10, alt151_1
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
.annotate 'line', 85
  # rx literal  "="
    add $I11, rx148_pos, 1
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    ord $I11, rx148_tgt, $I11
    ne $I11, 61, rx148_fail
    add rx148_pos, 1
.annotate 'line', 87
  # rx rxquantr152 ** 0..1
    set_addr $I10, rxquantr152_done
    rx148_cur."!mark_push"(0, rx148_pos, $I10)
  rxquantr152_loop:
.annotate 'line', 86
  # rx literal  "cut"
    add $I11, rx148_pos, 3
    gt $I11, rx148_eos, rx148_fail
    sub $I11, rx148_pos, rx148_off
    substr $S10, rx148_tgt, $I11, 3
    ne $S10, "cut", rx148_fail
    add rx148_pos, 3
  # rxanchor rwb
    le rx148_pos, 0, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 8192, rx148_tgt, $I10
    if $I11, rx148_fail
    dec $I10
    is_cclass $I11, 8192, rx148_tgt, $I10
    unless $I11, rx148_fail
.annotate 'line', 87
  # rx subrule "panic" subtype=method negate=
    rx148_cur."!cursor_pos"(rx148_pos)
    $P10 = rx148_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx148_fail
    rx148_pos = $P10."pos"()
    set_addr $I10, rxquantr152_done
    (rx148_rep) = rx148_cur."!mark_commit"($I10)
  rxquantr152_done:
.annotate 'line', 84
    goto alt151_end
  alt151_1:
.annotate 'line', 88
  # rx charclass nl
    ge rx148_pos, rx148_eos, rx148_fail
    sub $I10, rx148_pos, rx148_off
    is_cclass $I11, 4096, rx148_tgt, $I10
    unless $I11, rx148_fail
    substr $S10, rx148_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx148_pos, $I11
    inc rx148_pos
  alt151_end:
.annotate 'line', 84
  # rx pass
    rx148_cur."!cursor_pass"(rx148_pos, "")
    if_null rx148_debug, debug_453
    rx148_cur."!cursor_debug"("PASS", "", " at pos=", rx148_pos)
  debug_453:
    .return (rx148_cur)
  rx148_restart:
    if_null rx148_debug, debug_454
    rx148_cur."!cursor_debug"("NEXT", "")
  debug_454:
  rx148_fail:
    (rx148_rep, rx148_pos, $I10, $P10) = rx148_cur."!mark_fail"(0)
    lt rx148_pos, -1, rx148_done
    eq rx148_pos, -1, rx148_fail
    jump $I10
  rx148_done:
    rx148_cur."!cursor_fail"()
    if_null rx148_debug, debug_455
    rx148_cur."!cursor_debug"("FAIL", "")
  debug_455:
    .return (rx148_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx155_tgt
    .local int rx155_pos
    .local int rx155_off
    .local int rx155_eos
    .local int rx155_rep
    .local pmc rx155_cur
    .local pmc rx155_debug
    (rx155_cur, rx155_pos, rx155_tgt, $I10) = self."!cursor_start"()
    getattribute rx155_debug, rx155_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx155_cur
    .local pmc match
    .lex "$/", match
    length rx155_eos, rx155_tgt
    gt rx155_pos, rx155_eos, rx155_done
    set rx155_off, 0
    lt rx155_pos, 2, rx155_start
    sub rx155_off, rx155_pos, 1
    substr rx155_tgt, rx155_tgt, rx155_off
  rx155_start:
    eq $I10, 1, rx155_restart
    if_null rx155_debug, debug_459
    rx155_cur."!cursor_debug"("START", "comp_unit")
  debug_459:
    $I10 = self.'from'()
    ne $I10, -1, rxscan159_done
    goto rxscan159_scan
  rxscan159_loop:
    ($P10) = rx155_cur."from"()
    inc $P10
    set rx155_pos, $P10
    ge rx155_pos, rx155_eos, rxscan159_done
  rxscan159_scan:
    set_addr $I10, rxscan159_loop
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxscan159_done:
.annotate 'line', 99
  # rx subrule "newpad" subtype=method negate=
    rx155_cur."!cursor_pos"(rx155_pos)
    $P10 = rx155_cur."newpad"()
    unless $P10, rx155_fail
    rx155_pos = $P10."pos"()
.annotate 'line', 100
  # rx subrule "outerctx" subtype=method negate=
    rx155_cur."!cursor_pos"(rx155_pos)
    $P10 = rx155_cur."outerctx"()
    unless $P10, rx155_fail
    rx155_pos = $P10."pos"()
.annotate 'line', 101
  # rx subrule "statementlist" subtype=capture negate=
    rx155_cur."!cursor_pos"(rx155_pos)
    $P10 = rx155_cur."statementlist"()
    unless $P10, rx155_fail
    rx155_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx155_pos = $P10."pos"()
  alt160_0:
.annotate 'line', 102
    set_addr $I10, alt160_1
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  # rxanchor eos
    ne rx155_pos, rx155_eos, rx155_fail
    goto alt160_end
  alt160_1:
  # rx subrule "panic" subtype=method negate=
    rx155_cur."!cursor_pos"(rx155_pos)
    $P10 = rx155_cur."panic"("Confused")
    unless $P10, rx155_fail
    rx155_pos = $P10."pos"()
  alt160_end:
.annotate 'line', 98
  # rx pass
    rx155_cur."!cursor_pass"(rx155_pos, "comp_unit")
    if_null rx155_debug, debug_460
    rx155_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx155_pos)
  debug_460:
    .return (rx155_cur)
  rx155_restart:
.annotate 'line', 4
    if_null rx155_debug, debug_461
    rx155_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_461:
  rx155_fail:
    (rx155_rep, rx155_pos, $I10, $P10) = rx155_cur."!mark_fail"(0)
    lt rx155_pos, -1, rx155_done
    eq rx155_pos, -1, rx155_fail
    jump $I10
  rx155_done:
    rx155_cur."!cursor_fail"()
    if_null rx155_debug, debug_462
    rx155_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_462:
    .return (rx155_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("30_1295307698.031") :method
.annotate 'line', 4
    $P157 = self."!PREFIX__!subrule"("newpad", "")
    new $P158, "ResizablePMCArray"
    push $P158, $P157
    .return ($P158)
.end


.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx162_tgt
    .local int rx162_pos
    .local int rx162_off
    .local int rx162_eos
    .local int rx162_rep
    .local pmc rx162_cur
    .local pmc rx162_debug
    (rx162_cur, rx162_pos, rx162_tgt, $I10) = self."!cursor_start"()
    rx162_cur."!cursor_caparray"("statement")
    getattribute rx162_debug, rx162_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx162_cur
    .local pmc match
    .lex "$/", match
    length rx162_eos, rx162_tgt
    gt rx162_pos, rx162_eos, rx162_done
    set rx162_off, 0
    lt rx162_pos, 2, rx162_start
    sub rx162_off, rx162_pos, 1
    substr rx162_tgt, rx162_tgt, rx162_off
  rx162_start:
    eq $I10, 1, rx162_restart
    if_null rx162_debug, debug_463
    rx162_cur."!cursor_debug"("START", "statementlist")
  debug_463:
    $I10 = self.'from'()
    ne $I10, -1, rxscan167_done
    goto rxscan167_scan
  rxscan167_loop:
    ($P10) = rx162_cur."from"()
    inc $P10
    set rx162_pos, $P10
    ge rx162_pos, rx162_eos, rxscan167_done
  rxscan167_scan:
    set_addr $I10, rxscan167_loop
    rx162_cur."!mark_push"(0, rx162_pos, $I10)
  rxscan167_done:
  alt168_0:
.annotate 'line', 105
    set_addr $I10, alt168_1
    rx162_cur."!mark_push"(0, rx162_pos, $I10)
.annotate 'line', 106
  # rx subrule "ws" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."ws"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
  # rxanchor eos
    ne rx162_pos, rx162_eos, rx162_fail
  # rx subrule "ws" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."ws"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
    goto alt168_end
  alt168_1:
.annotate 'line', 107
  # rx subrule "ws" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."ws"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
  # rx rxquantr172 ** 0..*
    set_addr $I10, rxquantr172_done
    rx162_cur."!mark_push"(0, rx162_pos, $I10)
  rxquantr172_loop:
  # rx subrule "statement" subtype=capture negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."statement"()
    unless $P10, rx162_fail
    rx162_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx162_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."eat_terminator"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."ws"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
    set_addr $I10, rxquantr172_done
    (rx162_rep) = rx162_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr172_done
    rx162_cur."!mark_push"(rx162_rep, rx162_pos, $I10)
    goto rxquantr172_loop
  rxquantr172_done:
  # rx subrule "ws" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."ws"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
  alt168_end:
.annotate 'line', 105
  # rx pass
    rx162_cur."!cursor_pass"(rx162_pos, "statementlist")
    if_null rx162_debug, debug_464
    rx162_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx162_pos)
  debug_464:
    .return (rx162_cur)
  rx162_restart:
.annotate 'line', 4
    if_null rx162_debug, debug_465
    rx162_cur."!cursor_debug"("NEXT", "statementlist")
  debug_465:
  rx162_fail:
    (rx162_rep, rx162_pos, $I10, $P10) = rx162_cur."!mark_fail"(0)
    lt rx162_pos, -1, rx162_done
    eq rx162_pos, -1, rx162_fail
    jump $I10
  rx162_done:
    rx162_cur."!cursor_fail"()
    if_null rx162_debug, debug_466
    rx162_cur."!cursor_debug"("FAIL", "statementlist")
  debug_466:
    .return (rx162_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("32_1295307698.031") :method
.annotate 'line', 4
    $P164 = self."!PREFIX__!subrule"("ws", "")
    $P165 = self."!PREFIX__!subrule"("ws", "")
    new $P166, "ResizablePMCArray"
    push $P166, $P164
    push $P166, $P165
    .return ($P166)
.end


.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .const 'Sub' $P181 = "35_1295307698.031" 
    capture_lex $P181
    .local string rx176_tgt
    .local int rx176_pos
    .local int rx176_off
    .local int rx176_eos
    .local int rx176_rep
    .local pmc rx176_cur
    .local pmc rx176_debug
    (rx176_cur, rx176_pos, rx176_tgt, $I10) = self."!cursor_start"()
    rx176_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    getattribute rx176_debug, rx176_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx176_cur
    .local pmc match
    .lex "$/", match
    length rx176_eos, rx176_tgt
    gt rx176_pos, rx176_eos, rx176_done
    set rx176_off, 0
    lt rx176_pos, 2, rx176_start
    sub rx176_off, rx176_pos, 1
    substr rx176_tgt, rx176_tgt, rx176_off
  rx176_start:
    eq $I10, 1, rx176_restart
    if_null rx176_debug, debug_467
    rx176_cur."!cursor_debug"("START", "statement")
  debug_467:
    $I10 = self.'from'()
    ne $I10, -1, rxscan179_done
    goto rxscan179_scan
  rxscan179_loop:
    ($P10) = rx176_cur."from"()
    inc $P10
    set rx176_pos, $P10
    ge rx176_pos, rx176_eos, rxscan179_done
  rxscan179_scan:
    set_addr $I10, rxscan179_loop
    rx176_cur."!mark_push"(0, rx176_pos, $I10)
  rxscan179_done:
.annotate 'line', 111
  # rx subrule "before" subtype=zerowidth negate=1
    rx176_cur."!cursor_pos"(rx176_pos)
    .const 'Sub' $P181 = "35_1295307698.031" 
    capture_lex $P181
    $P10 = rx176_cur."before"($P181)
    if $P10, rx176_fail
  alt185_0:
.annotate 'line', 112
    set_addr $I10, alt185_1
    rx176_cur."!mark_push"(0, rx176_pos, $I10)
.annotate 'line', 113
  # rx subrule "statement_control" subtype=capture negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."statement_control"()
    unless $P10, rx176_fail
    rx176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx176_pos = $P10."pos"()
    goto alt185_end
  alt185_1:
.annotate 'line', 114
  # rx subrule "EXPR" subtype=capture negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."EXPR"()
    unless $P10, rx176_fail
    rx176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx176_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."ws"()
    unless $P10, rx176_fail
    rx176_pos = $P10."pos"()
.annotate 'line', 119
  # rx rxquantr186 ** 0..1
    set_addr $I10, rxquantr186_done
    rx176_cur."!mark_push"(0, rx176_pos, $I10)
  rxquantr186_loop:
  alt187_0:
.annotate 'line', 115
    set_addr $I10, alt187_1
    rx176_cur."!mark_push"(0, rx176_pos, $I10)
.annotate 'line', 116
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."MARKED"("endstmt")
    unless $P10, rx176_fail
    goto alt187_end
  alt187_1:
    set_addr $I10, alt187_2
    rx176_cur."!mark_push"(0, rx176_pos, $I10)
.annotate 'line', 117
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."statement_mod_cond"()
    unless $P10, rx176_fail
    rx176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx176_pos = $P10."pos"()
  # rx rxquantr188 ** 0..1
    set_addr $I10, rxquantr188_done
    rx176_cur."!mark_push"(0, rx176_pos, $I10)
  rxquantr188_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."statement_mod_loop"()
    unless $P10, rx176_fail
    goto rxsubrule189_pass
  rxsubrule189_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx176_fail
  rxsubrule189_pass:
    set_addr $I10, rxsubrule189_back
    rx176_cur."!mark_push"(0, rx176_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx176_pos = $P10."pos"()
    set_addr $I10, rxquantr188_done
    (rx176_rep) = rx176_cur."!mark_commit"($I10)
  rxquantr188_done:
    goto alt187_end
  alt187_2:
.annotate 'line', 118
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx176_cur."!cursor_pos"(rx176_pos)
    $P10 = rx176_cur."statement_mod_loop"()
    unless $P10, rx176_fail
    rx176_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx176_pos = $P10."pos"()
  alt187_end:
.annotate 'line', 119
    set_addr $I10, rxquantr186_done
    (rx176_rep) = rx176_cur."!mark_commit"($I10)
  rxquantr186_done:
  alt185_end:
.annotate 'line', 110
  # rx pass
    rx176_cur."!cursor_pass"(rx176_pos, "statement")
    if_null rx176_debug, debug_472
    rx176_cur."!cursor_debug"("PASS", "statement", " at pos=", rx176_pos)
  debug_472:
    .return (rx176_cur)
  rx176_restart:
.annotate 'line', 4
    if_null rx176_debug, debug_473
    rx176_cur."!cursor_debug"("NEXT", "statement")
  debug_473:
  rx176_fail:
    (rx176_rep, rx176_pos, $I10, $P10) = rx176_cur."!mark_fail"(0)
    lt rx176_pos, -1, rx176_done
    eq rx176_pos, -1, rx176_fail
    jump $I10
  rx176_done:
    rx176_cur."!cursor_fail"()
    if_null rx176_debug, debug_474
    rx176_cur."!cursor_debug"("FAIL", "statement")
  debug_474:
    .return (rx176_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("34_1295307698.031") :method
.annotate 'line', 4
    new $P178, "ResizablePMCArray"
    push $P178, ""
    .return ($P178)
.end


.namespace ["NQP";"Grammar"]
.sub "_block180"  :anon :subid("35_1295307698.031") :method :outer("33_1295307698.031")
.annotate 'line', 111
    .local string rx182_tgt
    .local int rx182_pos
    .local int rx182_off
    .local int rx182_eos
    .local int rx182_rep
    .local pmc rx182_cur
    .local pmc rx182_debug
    (rx182_cur, rx182_pos, rx182_tgt, $I10) = self."!cursor_start"()
    getattribute rx182_debug, rx182_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx182_cur
    .local pmc match
    .lex "$/", match
    length rx182_eos, rx182_tgt
    gt rx182_pos, rx182_eos, rx182_done
    set rx182_off, 0
    lt rx182_pos, 2, rx182_start
    sub rx182_off, rx182_pos, 1
    substr rx182_tgt, rx182_tgt, rx182_off
  rx182_start:
    eq $I10, 1, rx182_restart
    if_null rx182_debug, debug_468
    rx182_cur."!cursor_debug"("START", "")
  debug_468:
    $I10 = self.'from'()
    ne $I10, -1, rxscan183_done
    goto rxscan183_scan
  rxscan183_loop:
    ($P10) = rx182_cur."from"()
    inc $P10
    set rx182_pos, $P10
    ge rx182_pos, rx182_eos, rxscan183_done
  rxscan183_scan:
    set_addr $I10, rxscan183_loop
    rx182_cur."!mark_push"(0, rx182_pos, $I10)
  rxscan183_done:
  alt184_0:
    set_addr $I10, alt184_1
    rx182_cur."!mark_push"(0, rx182_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx182_pos, rx182_eos, rx182_fail
    sub $I10, rx182_pos, rx182_off
    substr $S10, rx182_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx182_fail
    inc rx182_pos
    goto alt184_end
  alt184_1:
  # rxanchor eos
    ne rx182_pos, rx182_eos, rx182_fail
  alt184_end:
  # rx pass
    rx182_cur."!cursor_pass"(rx182_pos, "")
    if_null rx182_debug, debug_469
    rx182_cur."!cursor_debug"("PASS", "", " at pos=", rx182_pos)
  debug_469:
    .return (rx182_cur)
  rx182_restart:
    if_null rx182_debug, debug_470
    rx182_cur."!cursor_debug"("NEXT", "")
  debug_470:
  rx182_fail:
    (rx182_rep, rx182_pos, $I10, $P10) = rx182_cur."!mark_fail"(0)
    lt rx182_pos, -1, rx182_done
    eq rx182_pos, -1, rx182_fail
    jump $I10
  rx182_done:
    rx182_cur."!cursor_fail"()
    if_null rx182_debug, debug_471
    rx182_cur."!cursor_debug"("FAIL", "")
  debug_471:
    .return (rx182_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx191_tgt
    .local int rx191_pos
    .local int rx191_off
    .local int rx191_eos
    .local int rx191_rep
    .local pmc rx191_cur
    .local pmc rx191_debug
    (rx191_cur, rx191_pos, rx191_tgt, $I10) = self."!cursor_start"()
    getattribute rx191_debug, rx191_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx191_cur
    .local pmc match
    .lex "$/", match
    length rx191_eos, rx191_tgt
    gt rx191_pos, rx191_eos, rx191_done
    set rx191_off, 0
    lt rx191_pos, 2, rx191_start
    sub rx191_off, rx191_pos, 1
    substr rx191_tgt, rx191_tgt, rx191_off
  rx191_start:
    eq $I10, 1, rx191_restart
    if_null rx191_debug, debug_475
    rx191_cur."!cursor_debug"("START", "eat_terminator")
  debug_475:
    $I10 = self.'from'()
    ne $I10, -1, rxscan194_done
    goto rxscan194_scan
  rxscan194_loop:
    ($P10) = rx191_cur."from"()
    inc $P10
    set rx191_pos, $P10
    ge rx191_pos, rx191_eos, rxscan194_done
  rxscan194_scan:
    set_addr $I10, rxscan194_loop
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
  rxscan194_done:
  alt195_0:
.annotate 'line', 123
    set_addr $I10, alt195_1
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
.annotate 'line', 124
  # rx literal  ";"
    add $I11, rx191_pos, 1
    gt $I11, rx191_eos, rx191_fail
    sub $I11, rx191_pos, rx191_off
    ord $I11, rx191_tgt, $I11
    ne $I11, 59, rx191_fail
    add rx191_pos, 1
    goto alt195_end
  alt195_1:
    set_addr $I10, alt195_2
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
.annotate 'line', 125
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx191_cur."!cursor_pos"(rx191_pos)
    $P10 = rx191_cur."MARKED"("endstmt")
    unless $P10, rx191_fail
    goto alt195_end
  alt195_2:
    set_addr $I10, alt195_3
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
.annotate 'line', 126
  # rx subrule "terminator" subtype=zerowidth negate=
    rx191_cur."!cursor_pos"(rx191_pos)
    $P10 = rx191_cur."terminator"()
    unless $P10, rx191_fail
    goto alt195_end
  alt195_3:
.annotate 'line', 127
  # rxanchor eos
    ne rx191_pos, rx191_eos, rx191_fail
  alt195_end:
.annotate 'line', 123
  # rx pass
    rx191_cur."!cursor_pass"(rx191_pos, "eat_terminator")
    if_null rx191_debug, debug_476
    rx191_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx191_pos)
  debug_476:
    .return (rx191_cur)
  rx191_restart:
.annotate 'line', 4
    if_null rx191_debug, debug_477
    rx191_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_477:
  rx191_fail:
    (rx191_rep, rx191_pos, $I10, $P10) = rx191_cur."!mark_fail"(0)
    lt rx191_pos, -1, rx191_done
    eq rx191_pos, -1, rx191_fail
    jump $I10
  rx191_done:
    rx191_cur."!cursor_fail"()
    if_null rx191_debug, debug_478
    rx191_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_478:
    .return (rx191_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("37_1295307698.031") :method
.annotate 'line', 4
    new $P193, "ResizablePMCArray"
    push $P193, ""
    push $P193, ""
    push $P193, ""
    push $P193, ";"
    .return ($P193)
.end


.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx197_tgt
    .local int rx197_pos
    .local int rx197_off
    .local int rx197_eos
    .local int rx197_rep
    .local pmc rx197_cur
    .local pmc rx197_debug
    (rx197_cur, rx197_pos, rx197_tgt, $I10) = self."!cursor_start"()
    getattribute rx197_debug, rx197_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx197_cur
    .local pmc match
    .lex "$/", match
    length rx197_eos, rx197_tgt
    gt rx197_pos, rx197_eos, rx197_done
    set rx197_off, 0
    lt rx197_pos, 2, rx197_start
    sub rx197_off, rx197_pos, 1
    substr rx197_tgt, rx197_tgt, rx197_off
  rx197_start:
    eq $I10, 1, rx197_restart
    if_null rx197_debug, debug_479
    rx197_cur."!cursor_debug"("START", "xblock")
  debug_479:
    $I10 = self.'from'()
    ne $I10, -1, rxscan201_done
    goto rxscan201_scan
  rxscan201_loop:
    ($P10) = rx197_cur."from"()
    inc $P10
    set rx197_pos, $P10
    ge rx197_pos, rx197_eos, rxscan201_done
  rxscan201_scan:
    set_addr $I10, rxscan201_loop
    rx197_cur."!mark_push"(0, rx197_pos, $I10)
  rxscan201_done:
.annotate 'line', 131
  # rx subrule "EXPR" subtype=capture negate=
    rx197_cur."!cursor_pos"(rx197_pos)
    $P10 = rx197_cur."EXPR"()
    unless $P10, rx197_fail
    rx197_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx197_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx197_cur."!cursor_pos"(rx197_pos)
    $P10 = rx197_cur."ws"()
    unless $P10, rx197_fail
    rx197_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx197_cur."!cursor_pos"(rx197_pos)
    $P10 = rx197_cur."pblock"()
    unless $P10, rx197_fail
    rx197_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx197_pos = $P10."pos"()
.annotate 'line', 130
  # rx pass
    rx197_cur."!cursor_pass"(rx197_pos, "xblock")
    if_null rx197_debug, debug_480
    rx197_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx197_pos)
  debug_480:
    .return (rx197_cur)
  rx197_restart:
.annotate 'line', 4
    if_null rx197_debug, debug_481
    rx197_cur."!cursor_debug"("NEXT", "xblock")
  debug_481:
  rx197_fail:
    (rx197_rep, rx197_pos, $I10, $P10) = rx197_cur."!mark_fail"(0)
    lt rx197_pos, -1, rx197_done
    eq rx197_pos, -1, rx197_fail
    jump $I10
  rx197_done:
    rx197_cur."!cursor_fail"()
    if_null rx197_debug, debug_482
    rx197_cur."!cursor_debug"("FAIL", "xblock")
  debug_482:
    .return (rx197_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("39_1295307698.031") :method
.annotate 'line', 4
    $P199 = self."!PREFIX__!subrule"("EXPR", "")
    new $P200, "ResizablePMCArray"
    push $P200, $P199
    .return ($P200)
.end


.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx203_tgt
    .local int rx203_pos
    .local int rx203_off
    .local int rx203_eos
    .local int rx203_rep
    .local pmc rx203_cur
    .local pmc rx203_debug
    (rx203_cur, rx203_pos, rx203_tgt, $I10) = self."!cursor_start"()
    getattribute rx203_debug, rx203_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx203_cur
    .local pmc match
    .lex "$/", match
    length rx203_eos, rx203_tgt
    gt rx203_pos, rx203_eos, rx203_done
    set rx203_off, 0
    lt rx203_pos, 2, rx203_start
    sub rx203_off, rx203_pos, 1
    substr rx203_tgt, rx203_tgt, rx203_off
  rx203_start:
    eq $I10, 1, rx203_restart
    if_null rx203_debug, debug_483
    rx203_cur."!cursor_debug"("START", "pblock")
  debug_483:
    $I10 = self.'from'()
    ne $I10, -1, rxscan208_done
    goto rxscan208_scan
  rxscan208_loop:
    ($P10) = rx203_cur."from"()
    inc $P10
    set rx203_pos, $P10
    ge rx203_pos, rx203_eos, rxscan208_done
  rxscan208_scan:
    set_addr $I10, rxscan208_loop
    rx203_cur."!mark_push"(0, rx203_pos, $I10)
  rxscan208_done:
  alt209_0:
.annotate 'line', 134
    set_addr $I10, alt209_1
    rx203_cur."!mark_push"(0, rx203_pos, $I10)
.annotate 'line', 135
  # rx subrule "lambda" subtype=method negate=
    rx203_cur."!cursor_pos"(rx203_pos)
    $P10 = rx203_cur."lambda"()
    unless $P10, rx203_fail
    rx203_pos = $P10."pos"()
.annotate 'line', 136
  # rx subrule "newpad" subtype=method negate=
    rx203_cur."!cursor_pos"(rx203_pos)
    $P10 = rx203_cur."newpad"()
    unless $P10, rx203_fail
    rx203_pos = $P10."pos"()
.annotate 'line', 137
  # rx subrule "signature" subtype=capture negate=
    rx203_cur."!cursor_pos"(rx203_pos)
    $P10 = rx203_cur."signature"()
    unless $P10, rx203_fail
    rx203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx203_pos = $P10."pos"()
.annotate 'line', 138
  # rx subrule "blockoid" subtype=capture negate=
    rx203_cur."!cursor_pos"(rx203_pos)
    $P10 = rx203_cur."blockoid"()
    unless $P10, rx203_fail
    rx203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx203_pos = $P10."pos"()
.annotate 'line', 135
    goto alt209_end
  alt209_1:
    set_addr $I10, alt209_2
    rx203_cur."!mark_push"(0, rx203_pos, $I10)
.annotate 'line', 139
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx203_pos, rx203_off
    substr $S10, rx203_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx203_fail
.annotate 'line', 140
  # rx subrule "newpad" subtype=method negate=
    rx203_cur."!cursor_pos"(rx203_pos)
    $P10 = rx203_cur."newpad"()
    unless $P10, rx203_fail
    rx203_pos = $P10."pos"()
.annotate 'line', 141
  # rx subrule "blockoid" subtype=capture negate=
    rx203_cur."!cursor_pos"(rx203_pos)
    $P10 = rx203_cur."blockoid"()
    unless $P10, rx203_fail
    rx203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx203_pos = $P10."pos"()
.annotate 'line', 139
    goto alt209_end
  alt209_2:
.annotate 'line', 142
  # rx subrule "panic" subtype=method negate=
    rx203_cur."!cursor_pos"(rx203_pos)
    $P10 = rx203_cur."panic"("Missing block")
    unless $P10, rx203_fail
    rx203_pos = $P10."pos"()
  alt209_end:
.annotate 'line', 134
  # rx pass
    rx203_cur."!cursor_pass"(rx203_pos, "pblock")
    if_null rx203_debug, debug_484
    rx203_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx203_pos)
  debug_484:
    .return (rx203_cur)
  rx203_restart:
.annotate 'line', 4
    if_null rx203_debug, debug_485
    rx203_cur."!cursor_debug"("NEXT", "pblock")
  debug_485:
  rx203_fail:
    (rx203_rep, rx203_pos, $I10, $P10) = rx203_cur."!mark_fail"(0)
    lt rx203_pos, -1, rx203_done
    eq rx203_pos, -1, rx203_fail
    jump $I10
  rx203_done:
    rx203_cur."!cursor_fail"()
    if_null rx203_debug, debug_486
    rx203_cur."!cursor_debug"("FAIL", "pblock")
  debug_486:
    .return (rx203_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("41_1295307698.031") :method
.annotate 'line', 4
    $P205 = self."!PREFIX__!subrule"("panic", "")
    $P206 = self."!PREFIX__!subrule"("lambda", "")
    new $P207, "ResizablePMCArray"
    push $P207, $P205
    push $P207, "{"
    push $P207, $P206
    .return ($P207)
.end


.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx211_tgt
    .local int rx211_pos
    .local int rx211_off
    .local int rx211_eos
    .local int rx211_rep
    .local pmc rx211_cur
    .local pmc rx211_debug
    (rx211_cur, rx211_pos, rx211_tgt, $I10) = self."!cursor_start"()
    getattribute rx211_debug, rx211_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx211_cur
    .local pmc match
    .lex "$/", match
    length rx211_eos, rx211_tgt
    gt rx211_pos, rx211_eos, rx211_done
    set rx211_off, 0
    lt rx211_pos, 2, rx211_start
    sub rx211_off, rx211_pos, 1
    substr rx211_tgt, rx211_tgt, rx211_off
  rx211_start:
    eq $I10, 1, rx211_restart
    if_null rx211_debug, debug_487
    rx211_cur."!cursor_debug"("START", "lambda")
  debug_487:
    $I10 = self.'from'()
    ne $I10, -1, rxscan214_done
    goto rxscan214_scan
  rxscan214_loop:
    ($P10) = rx211_cur."from"()
    inc $P10
    set rx211_pos, $P10
    ge rx211_pos, rx211_eos, rxscan214_done
  rxscan214_scan:
    set_addr $I10, rxscan214_loop
    rx211_cur."!mark_push"(0, rx211_pos, $I10)
  rxscan214_done:
  alt215_0:
.annotate 'line', 145
    set_addr $I10, alt215_1
    rx211_cur."!mark_push"(0, rx211_pos, $I10)
  # rx literal  "->"
    add $I11, rx211_pos, 2
    gt $I11, rx211_eos, rx211_fail
    sub $I11, rx211_pos, rx211_off
    substr $S10, rx211_tgt, $I11, 2
    ne $S10, "->", rx211_fail
    add rx211_pos, 2
    goto alt215_end
  alt215_1:
  # rx literal  "<->"
    add $I11, rx211_pos, 3
    gt $I11, rx211_eos, rx211_fail
    sub $I11, rx211_pos, rx211_off
    substr $S10, rx211_tgt, $I11, 3
    ne $S10, "<->", rx211_fail
    add rx211_pos, 3
  alt215_end:
  # rx pass
    rx211_cur."!cursor_pass"(rx211_pos, "lambda")
    if_null rx211_debug, debug_488
    rx211_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx211_pos)
  debug_488:
    .return (rx211_cur)
  rx211_restart:
.annotate 'line', 4
    if_null rx211_debug, debug_489
    rx211_cur."!cursor_debug"("NEXT", "lambda")
  debug_489:
  rx211_fail:
    (rx211_rep, rx211_pos, $I10, $P10) = rx211_cur."!mark_fail"(0)
    lt rx211_pos, -1, rx211_done
    eq rx211_pos, -1, rx211_fail
    jump $I10
  rx211_done:
    rx211_cur."!cursor_fail"()
    if_null rx211_debug, debug_490
    rx211_cur."!cursor_debug"("FAIL", "lambda")
  debug_490:
    .return (rx211_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("43_1295307698.031") :method
.annotate 'line', 4
    new $P213, "ResizablePMCArray"
    push $P213, "<->"
    push $P213, "->"
    .return ($P213)
.end


.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx217_tgt
    .local int rx217_pos
    .local int rx217_off
    .local int rx217_eos
    .local int rx217_rep
    .local pmc rx217_cur
    .local pmc rx217_debug
    (rx217_cur, rx217_pos, rx217_tgt, $I10) = self."!cursor_start"()
    getattribute rx217_debug, rx217_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx217_cur
    .local pmc match
    .lex "$/", match
    length rx217_eos, rx217_tgt
    gt rx217_pos, rx217_eos, rx217_done
    set rx217_off, 0
    lt rx217_pos, 2, rx217_start
    sub rx217_off, rx217_pos, 1
    substr rx217_tgt, rx217_tgt, rx217_off
  rx217_start:
    eq $I10, 1, rx217_restart
    if_null rx217_debug, debug_491
    rx217_cur."!cursor_debug"("START", "block")
  debug_491:
    $I10 = self.'from'()
    ne $I10, -1, rxscan221_done
    goto rxscan221_scan
  rxscan221_loop:
    ($P10) = rx217_cur."from"()
    inc $P10
    set rx217_pos, $P10
    ge rx217_pos, rx217_eos, rxscan221_done
  rxscan221_scan:
    set_addr $I10, rxscan221_loop
    rx217_cur."!mark_push"(0, rx217_pos, $I10)
  rxscan221_done:
  alt222_0:
.annotate 'line', 148
    set_addr $I10, alt222_1
    rx217_cur."!mark_push"(0, rx217_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx217_pos, rx217_off
    substr $S10, rx217_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx217_fail
    goto alt222_end
  alt222_1:
  # rx subrule "panic" subtype=method negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."panic"("Missing block")
    unless $P10, rx217_fail
    rx217_pos = $P10."pos"()
  alt222_end:
.annotate 'line', 149
  # rx subrule "newpad" subtype=method negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."newpad"()
    unless $P10, rx217_fail
    rx217_pos = $P10."pos"()
.annotate 'line', 150
  # rx subrule "blockoid" subtype=capture negate=
    rx217_cur."!cursor_pos"(rx217_pos)
    $P10 = rx217_cur."blockoid"()
    unless $P10, rx217_fail
    rx217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx217_pos = $P10."pos"()
.annotate 'line', 147
  # rx pass
    rx217_cur."!cursor_pass"(rx217_pos, "block")
    if_null rx217_debug, debug_492
    rx217_cur."!cursor_debug"("PASS", "block", " at pos=", rx217_pos)
  debug_492:
    .return (rx217_cur)
  rx217_restart:
.annotate 'line', 4
    if_null rx217_debug, debug_493
    rx217_cur."!cursor_debug"("NEXT", "block")
  debug_493:
  rx217_fail:
    (rx217_rep, rx217_pos, $I10, $P10) = rx217_cur."!mark_fail"(0)
    lt rx217_pos, -1, rx217_done
    eq rx217_pos, -1, rx217_fail
    jump $I10
  rx217_done:
    rx217_cur."!cursor_fail"()
    if_null rx217_debug, debug_494
    rx217_cur."!cursor_debug"("FAIL", "block")
  debug_494:
    .return (rx217_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("45_1295307698.031") :method
.annotate 'line', 4
    $P219 = self."!PREFIX__!subrule"("panic", "")
    new $P220, "ResizablePMCArray"
    push $P220, $P219
    push $P220, "{"
    .return ($P220)
.end


.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx224_tgt
    .local int rx224_pos
    .local int rx224_off
    .local int rx224_eos
    .local int rx224_rep
    .local pmc rx224_cur
    .local pmc rx224_debug
    (rx224_cur, rx224_pos, rx224_tgt, $I10) = self."!cursor_start"()
    getattribute rx224_debug, rx224_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx224_cur
    .local pmc match
    .lex "$/", match
    length rx224_eos, rx224_tgt
    gt rx224_pos, rx224_eos, rx224_done
    set rx224_off, 0
    lt rx224_pos, 2, rx224_start
    sub rx224_off, rx224_pos, 1
    substr rx224_tgt, rx224_tgt, rx224_off
  rx224_start:
    eq $I10, 1, rx224_restart
    if_null rx224_debug, debug_495
    rx224_cur."!cursor_debug"("START", "blockoid")
  debug_495:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    ($P10) = rx224_cur."from"()
    inc $P10
    set rx224_pos, $P10
    ge rx224_pos, rx224_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  rxscan228_done:
.annotate 'line', 154
  # rx subrule "finishpad" subtype=method negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."finishpad"()
    unless $P10, rx224_fail
    rx224_pos = $P10."pos"()
.annotate 'line', 155
  # rx literal  "{"
    add $I11, rx224_pos, 1
    gt $I11, rx224_eos, rx224_fail
    sub $I11, rx224_pos, rx224_off
    ord $I11, rx224_tgt, $I11
    ne $I11, 123, rx224_fail
    add rx224_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."statementlist"()
    unless $P10, rx224_fail
    rx224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx224_pos = $P10."pos"()
  alt229_0:
    set_addr $I10, alt229_1
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  # rx literal  "}"
    add $I11, rx224_pos, 1
    gt $I11, rx224_eos, rx224_fail
    sub $I11, rx224_pos, rx224_off
    ord $I11, rx224_tgt, $I11
    ne $I11, 125, rx224_fail
    add rx224_pos, 1
    goto alt229_end
  alt229_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."FAILGOAL"("'}'")
    unless $P10, rx224_fail
    goto rxsubrule231_pass
  rxsubrule231_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx224_fail
  rxsubrule231_pass:
    set_addr $I10, rxsubrule231_back
    rx224_cur."!mark_push"(0, rx224_pos, $I10, $P10)
    rx224_pos = $P10."pos"()
  alt229_end:
.annotate 'line', 156
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."ENDSTMT"()
    unless $P10, rx224_fail
.annotate 'line', 153
  # rx pass
    rx224_cur."!cursor_pass"(rx224_pos, "blockoid")
    if_null rx224_debug, debug_496
    rx224_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx224_pos)
  debug_496:
    .return (rx224_cur)
  rx224_restart:
.annotate 'line', 4
    if_null rx224_debug, debug_497
    rx224_cur."!cursor_debug"("NEXT", "blockoid")
  debug_497:
  rx224_fail:
    (rx224_rep, rx224_pos, $I10, $P10) = rx224_cur."!mark_fail"(0)
    lt rx224_pos, -1, rx224_done
    eq rx224_pos, -1, rx224_fail
    jump $I10
  rx224_done:
    rx224_cur."!cursor_fail"()
    if_null rx224_debug, debug_498
    rx224_cur."!cursor_debug"("FAIL", "blockoid")
  debug_498:
    .return (rx224_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("47_1295307698.031") :method
.annotate 'line', 4
    $P226 = self."!PREFIX__!subrule"("finishpad", "")
    new $P227, "ResizablePMCArray"
    push $P227, $P226
    .return ($P227)
.end


.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx233_tgt
    .local int rx233_pos
    .local int rx233_off
    .local int rx233_eos
    .local int rx233_rep
    .local pmc rx233_cur
    .local pmc rx233_debug
    (rx233_cur, rx233_pos, rx233_tgt, $I10) = self."!cursor_start"()
    getattribute rx233_debug, rx233_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx233_cur
    .local pmc match
    .lex "$/", match
    length rx233_eos, rx233_tgt
    gt rx233_pos, rx233_eos, rx233_done
    set rx233_off, 0
    lt rx233_pos, 2, rx233_start
    sub rx233_off, rx233_pos, 1
    substr rx233_tgt, rx233_tgt, rx233_off
  rx233_start:
    eq $I10, 1, rx233_restart
    if_null rx233_debug, debug_499
    rx233_cur."!cursor_debug"("START", "newpad")
  debug_499:
    $I10 = self.'from'()
    ne $I10, -1, rxscan236_done
    goto rxscan236_scan
  rxscan236_loop:
    ($P10) = rx233_cur."from"()
    inc $P10
    set rx233_pos, $P10
    ge rx233_pos, rx233_eos, rxscan236_done
  rxscan236_scan:
    set_addr $I10, rxscan236_loop
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxscan236_done:
.annotate 'line', 159
  # rx pass
    rx233_cur."!cursor_pass"(rx233_pos, "newpad")
    if_null rx233_debug, debug_500
    rx233_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx233_pos)
  debug_500:
    .return (rx233_cur)
  rx233_restart:
.annotate 'line', 4
    if_null rx233_debug, debug_501
    rx233_cur."!cursor_debug"("NEXT", "newpad")
  debug_501:
  rx233_fail:
    (rx233_rep, rx233_pos, $I10, $P10) = rx233_cur."!mark_fail"(0)
    lt rx233_pos, -1, rx233_done
    eq rx233_pos, -1, rx233_fail
    jump $I10
  rx233_done:
    rx233_cur."!cursor_fail"()
    if_null rx233_debug, debug_502
    rx233_cur."!cursor_debug"("FAIL", "newpad")
  debug_502:
    .return (rx233_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("49_1295307698.031") :method
.annotate 'line', 4
    new $P235, "ResizablePMCArray"
    push $P235, ""
    .return ($P235)
.end


.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx238_tgt
    .local int rx238_pos
    .local int rx238_off
    .local int rx238_eos
    .local int rx238_rep
    .local pmc rx238_cur
    .local pmc rx238_debug
    (rx238_cur, rx238_pos, rx238_tgt, $I10) = self."!cursor_start"()
    getattribute rx238_debug, rx238_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx238_cur
    .local pmc match
    .lex "$/", match
    length rx238_eos, rx238_tgt
    gt rx238_pos, rx238_eos, rx238_done
    set rx238_off, 0
    lt rx238_pos, 2, rx238_start
    sub rx238_off, rx238_pos, 1
    substr rx238_tgt, rx238_tgt, rx238_off
  rx238_start:
    eq $I10, 1, rx238_restart
    if_null rx238_debug, debug_503
    rx238_cur."!cursor_debug"("START", "outerctx")
  debug_503:
    $I10 = self.'from'()
    ne $I10, -1, rxscan241_done
    goto rxscan241_scan
  rxscan241_loop:
    ($P10) = rx238_cur."from"()
    inc $P10
    set rx238_pos, $P10
    ge rx238_pos, rx238_eos, rxscan241_done
  rxscan241_scan:
    set_addr $I10, rxscan241_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  rxscan241_done:
.annotate 'line', 160
  # rx pass
    rx238_cur."!cursor_pass"(rx238_pos, "outerctx")
    if_null rx238_debug, debug_504
    rx238_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx238_pos)
  debug_504:
    .return (rx238_cur)
  rx238_restart:
.annotate 'line', 4
    if_null rx238_debug, debug_505
    rx238_cur."!cursor_debug"("NEXT", "outerctx")
  debug_505:
  rx238_fail:
    (rx238_rep, rx238_pos, $I10, $P10) = rx238_cur."!mark_fail"(0)
    lt rx238_pos, -1, rx238_done
    eq rx238_pos, -1, rx238_fail
    jump $I10
  rx238_done:
    rx238_cur."!cursor_fail"()
    if_null rx238_debug, debug_506
    rx238_cur."!cursor_debug"("FAIL", "outerctx")
  debug_506:
    .return (rx238_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("51_1295307698.031") :method
.annotate 'line', 4
    new $P240, "ResizablePMCArray"
    push $P240, ""
    .return ($P240)
.end


.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx243_tgt
    .local int rx243_pos
    .local int rx243_off
    .local int rx243_eos
    .local int rx243_rep
    .local pmc rx243_cur
    .local pmc rx243_debug
    (rx243_cur, rx243_pos, rx243_tgt, $I10) = self."!cursor_start"()
    getattribute rx243_debug, rx243_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx243_cur
    .local pmc match
    .lex "$/", match
    length rx243_eos, rx243_tgt
    gt rx243_pos, rx243_eos, rx243_done
    set rx243_off, 0
    lt rx243_pos, 2, rx243_start
    sub rx243_off, rx243_pos, 1
    substr rx243_tgt, rx243_tgt, rx243_off
  rx243_start:
    eq $I10, 1, rx243_restart
    if_null rx243_debug, debug_507
    rx243_cur."!cursor_debug"("START", "finishpad")
  debug_507:
    $I10 = self.'from'()
    ne $I10, -1, rxscan246_done
    goto rxscan246_scan
  rxscan246_loop:
    ($P10) = rx243_cur."from"()
    inc $P10
    set rx243_pos, $P10
    ge rx243_pos, rx243_eos, rxscan246_done
  rxscan246_scan:
    set_addr $I10, rxscan246_loop
    rx243_cur."!mark_push"(0, rx243_pos, $I10)
  rxscan246_done:
.annotate 'line', 161
  # rx pass
    rx243_cur."!cursor_pass"(rx243_pos, "finishpad")
    if_null rx243_debug, debug_508
    rx243_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx243_pos)
  debug_508:
    .return (rx243_cur)
  rx243_restart:
.annotate 'line', 4
    if_null rx243_debug, debug_509
    rx243_cur."!cursor_debug"("NEXT", "finishpad")
  debug_509:
  rx243_fail:
    (rx243_rep, rx243_pos, $I10, $P10) = rx243_cur."!mark_fail"(0)
    lt rx243_pos, -1, rx243_done
    eq rx243_pos, -1, rx243_fail
    jump $I10
  rx243_done:
    rx243_cur."!cursor_fail"()
    if_null rx243_debug, debug_510
    rx243_cur."!cursor_debug"("FAIL", "finishpad")
  debug_510:
    .return (rx243_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("53_1295307698.031") :method
.annotate 'line', 4
    new $P245, "ResizablePMCArray"
    push $P245, ""
    .return ($P245)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("54_1295307698.031") :method
.annotate 'line', 163
    $P248 = self."!protoregex"("terminator")
    .return ($P248)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("55_1295307698.031") :method
.annotate 'line', 163
    $P250 = self."!PREFIX__!protoregex"("terminator")
    .return ($P250)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("56_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx252_tgt
    .local int rx252_pos
    .local int rx252_off
    .local int rx252_eos
    .local int rx252_rep
    .local pmc rx252_cur
    .local pmc rx252_debug
    (rx252_cur, rx252_pos, rx252_tgt, $I10) = self."!cursor_start"()
    getattribute rx252_debug, rx252_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx252_cur
    .local pmc match
    .lex "$/", match
    length rx252_eos, rx252_tgt
    gt rx252_pos, rx252_eos, rx252_done
    set rx252_off, 0
    lt rx252_pos, 2, rx252_start
    sub rx252_off, rx252_pos, 1
    substr rx252_tgt, rx252_tgt, rx252_off
  rx252_start:
    eq $I10, 1, rx252_restart
    if_null rx252_debug, debug_511
    rx252_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_511:
    $I10 = self.'from'()
    ne $I10, -1, rxscan255_done
    goto rxscan255_scan
  rxscan255_loop:
    ($P10) = rx252_cur."from"()
    inc $P10
    set rx252_pos, $P10
    ge rx252_pos, rx252_eos, rxscan255_done
  rxscan255_scan:
    set_addr $I10, rxscan255_loop
    rx252_cur."!mark_push"(0, rx252_pos, $I10)
  rxscan255_done:
.annotate 'line', 165
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx252_pos, rx252_off
    substr $S10, rx252_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx252_fail
  # rx pass
    rx252_cur."!cursor_pass"(rx252_pos, "terminator:sym<;>")
    if_null rx252_debug, debug_512
    rx252_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx252_pos)
  debug_512:
    .return (rx252_cur)
  rx252_restart:
.annotate 'line', 4
    if_null rx252_debug, debug_513
    rx252_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_513:
  rx252_fail:
    (rx252_rep, rx252_pos, $I10, $P10) = rx252_cur."!mark_fail"(0)
    lt rx252_pos, -1, rx252_done
    eq rx252_pos, -1, rx252_fail
    jump $I10
  rx252_done:
    rx252_cur."!cursor_fail"()
    if_null rx252_debug, debug_514
    rx252_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_514:
    .return (rx252_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("57_1295307698.031") :method
.annotate 'line', 4
    new $P254, "ResizablePMCArray"
    push $P254, ";"
    .return ($P254)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("58_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx257_tgt
    .local int rx257_pos
    .local int rx257_off
    .local int rx257_eos
    .local int rx257_rep
    .local pmc rx257_cur
    .local pmc rx257_debug
    (rx257_cur, rx257_pos, rx257_tgt, $I10) = self."!cursor_start"()
    getattribute rx257_debug, rx257_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx257_cur
    .local pmc match
    .lex "$/", match
    length rx257_eos, rx257_tgt
    gt rx257_pos, rx257_eos, rx257_done
    set rx257_off, 0
    lt rx257_pos, 2, rx257_start
    sub rx257_off, rx257_pos, 1
    substr rx257_tgt, rx257_tgt, rx257_off
  rx257_start:
    eq $I10, 1, rx257_restart
    if_null rx257_debug, debug_515
    rx257_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_515:
    $I10 = self.'from'()
    ne $I10, -1, rxscan260_done
    goto rxscan260_scan
  rxscan260_loop:
    ($P10) = rx257_cur."from"()
    inc $P10
    set rx257_pos, $P10
    ge rx257_pos, rx257_eos, rxscan260_done
  rxscan260_scan:
    set_addr $I10, rxscan260_loop
    rx257_cur."!mark_push"(0, rx257_pos, $I10)
  rxscan260_done:
.annotate 'line', 166
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx257_pos, rx257_off
    substr $S10, rx257_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx257_fail
  # rx pass
    rx257_cur."!cursor_pass"(rx257_pos, "terminator:sym<}>")
    if_null rx257_debug, debug_516
    rx257_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx257_pos)
  debug_516:
    .return (rx257_cur)
  rx257_restart:
.annotate 'line', 4
    if_null rx257_debug, debug_517
    rx257_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_517:
  rx257_fail:
    (rx257_rep, rx257_pos, $I10, $P10) = rx257_cur."!mark_fail"(0)
    lt rx257_pos, -1, rx257_done
    eq rx257_pos, -1, rx257_fail
    jump $I10
  rx257_done:
    rx257_cur."!cursor_fail"()
    if_null rx257_debug, debug_518
    rx257_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_518:
    .return (rx257_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("59_1295307698.031") :method
.annotate 'line', 4
    new $P259, "ResizablePMCArray"
    push $P259, "}"
    .return ($P259)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("60_1295307698.031") :method
.annotate 'line', 170
    $P262 = self."!protoregex"("statement_control")
    .return ($P262)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("61_1295307698.031") :method
.annotate 'line', 170
    $P264 = self."!PREFIX__!protoregex"("statement_control")
    .return ($P264)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("62_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx266_tgt
    .local int rx266_pos
    .local int rx266_off
    .local int rx266_eos
    .local int rx266_rep
    .local pmc rx266_cur
    .local pmc rx266_debug
    (rx266_cur, rx266_pos, rx266_tgt, $I10) = self."!cursor_start"()
    rx266_cur."!cursor_caparray"("xblock", "else")
    getattribute rx266_debug, rx266_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx266_cur
    .local pmc match
    .lex "$/", match
    length rx266_eos, rx266_tgt
    gt rx266_pos, rx266_eos, rx266_done
    set rx266_off, 0
    lt rx266_pos, 2, rx266_start
    sub rx266_off, rx266_pos, 1
    substr rx266_tgt, rx266_tgt, rx266_off
  rx266_start:
    eq $I10, 1, rx266_restart
    if_null rx266_debug, debug_519
    rx266_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_519:
    $I10 = self.'from'()
    ne $I10, -1, rxscan269_done
    goto rxscan269_scan
  rxscan269_loop:
    ($P10) = rx266_cur."from"()
    inc $P10
    set rx266_pos, $P10
    ge rx266_pos, rx266_eos, rxscan269_done
  rxscan269_scan:
    set_addr $I10, rxscan269_loop
    rx266_cur."!mark_push"(0, rx266_pos, $I10)
  rxscan269_done:
.annotate 'line', 173
  # rx subcapture "sym"
    set_addr $I10, rxcap_270_fail
    rx266_cur."!mark_push"(0, rx266_pos, $I10)
  # rx literal  "if"
    add $I11, rx266_pos, 2
    gt $I11, rx266_eos, rx266_fail
    sub $I11, rx266_pos, rx266_off
    substr $S10, rx266_tgt, $I11, 2
    ne $S10, "if", rx266_fail
    add rx266_pos, 2
    set_addr $I10, rxcap_270_fail
    ($I12, $I11) = rx266_cur."!mark_peek"($I10)
    rx266_cur."!cursor_pos"($I11)
    ($P10) = rx266_cur."!cursor_start"()
    $P10."!cursor_pass"(rx266_pos, "")
    rx266_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_270_done
  rxcap_270_fail:
    goto rx266_fail
  rxcap_270_done:
  # rx charclass s
    ge rx266_pos, rx266_eos, rx266_fail
    sub $I10, rx266_pos, rx266_off
    is_cclass $I11, 32, rx266_tgt, $I10
    unless $I11, rx266_fail
    inc rx266_pos
  # rx subrule "ws" subtype=method negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."ws"()
    unless $P10, rx266_fail
    rx266_pos = $P10."pos"()
.annotate 'line', 174
  # rx subrule "xblock" subtype=capture negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."xblock"()
    unless $P10, rx266_fail
    rx266_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx266_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."ws"()
    unless $P10, rx266_fail
    rx266_pos = $P10."pos"()
.annotate 'line', 175
  # rx rxquantr273 ** 0..*
    set_addr $I10, rxquantr273_done
    rx266_cur."!mark_push"(0, rx266_pos, $I10)
  rxquantr273_loop:
  # rx subrule "ws" subtype=method negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."ws"()
    unless $P10, rx266_fail
    rx266_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx266_pos, 5
    gt $I11, rx266_eos, rx266_fail
    sub $I11, rx266_pos, rx266_off
    substr $S10, rx266_tgt, $I11, 5
    ne $S10, "elsif", rx266_fail
    add rx266_pos, 5
  # rx charclass s
    ge rx266_pos, rx266_eos, rx266_fail
    sub $I10, rx266_pos, rx266_off
    is_cclass $I11, 32, rx266_tgt, $I10
    unless $I11, rx266_fail
    inc rx266_pos
  # rx subrule "ws" subtype=method negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."ws"()
    unless $P10, rx266_fail
    rx266_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."xblock"()
    unless $P10, rx266_fail
    rx266_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx266_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."ws"()
    unless $P10, rx266_fail
    rx266_pos = $P10."pos"()
    set_addr $I10, rxquantr273_done
    (rx266_rep) = rx266_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr273_done
    rx266_cur."!mark_push"(rx266_rep, rx266_pos, $I10)
    goto rxquantr273_loop
  rxquantr273_done:
  # rx subrule "ws" subtype=method negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."ws"()
    unless $P10, rx266_fail
    rx266_pos = $P10."pos"()
.annotate 'line', 176
  # rx rxquantr278 ** 0..1
    set_addr $I10, rxquantr278_done
    rx266_cur."!mark_push"(0, rx266_pos, $I10)
  rxquantr278_loop:
  # rx subrule "ws" subtype=method negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."ws"()
    unless $P10, rx266_fail
    rx266_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx266_pos, 4
    gt $I11, rx266_eos, rx266_fail
    sub $I11, rx266_pos, rx266_off
    substr $S10, rx266_tgt, $I11, 4
    ne $S10, "else", rx266_fail
    add rx266_pos, 4
  # rx charclass s
    ge rx266_pos, rx266_eos, rx266_fail
    sub $I10, rx266_pos, rx266_off
    is_cclass $I11, 32, rx266_tgt, $I10
    unless $I11, rx266_fail
    inc rx266_pos
  # rx subrule "ws" subtype=method negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."ws"()
    unless $P10, rx266_fail
    rx266_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."pblock"()
    unless $P10, rx266_fail
    rx266_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx266_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."ws"()
    unless $P10, rx266_fail
    rx266_pos = $P10."pos"()
    set_addr $I10, rxquantr278_done
    (rx266_rep) = rx266_cur."!mark_commit"($I10)
  rxquantr278_done:
  # rx subrule "ws" subtype=method negate=
    rx266_cur."!cursor_pos"(rx266_pos)
    $P10 = rx266_cur."ws"()
    unless $P10, rx266_fail
    rx266_pos = $P10."pos"()
.annotate 'line', 172
  # rx pass
    rx266_cur."!cursor_pass"(rx266_pos, "statement_control:sym<if>")
    if_null rx266_debug, debug_520
    rx266_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx266_pos)
  debug_520:
    .return (rx266_cur)
  rx266_restart:
.annotate 'line', 4
    if_null rx266_debug, debug_521
    rx266_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_521:
  rx266_fail:
    (rx266_rep, rx266_pos, $I10, $P10) = rx266_cur."!mark_fail"(0)
    lt rx266_pos, -1, rx266_done
    eq rx266_pos, -1, rx266_fail
    jump $I10
  rx266_done:
    rx266_cur."!cursor_fail"()
    if_null rx266_debug, debug_522
    rx266_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_522:
    .return (rx266_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("63_1295307698.031") :method
.annotate 'line', 4
    new $P268, "ResizablePMCArray"
    push $P268, "if"
    .return ($P268)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("64_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .const 'Sub' $P294 = "66_1295307698.031" 
    capture_lex $P294
    .local string rx284_tgt
    .local int rx284_pos
    .local int rx284_off
    .local int rx284_eos
    .local int rx284_rep
    .local pmc rx284_cur
    .local pmc rx284_debug
    (rx284_cur, rx284_pos, rx284_tgt, $I10) = self."!cursor_start"()
    getattribute rx284_debug, rx284_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx284_cur
    .local pmc match
    .lex "$/", match
    length rx284_eos, rx284_tgt
    gt rx284_pos, rx284_eos, rx284_done
    set rx284_off, 0
    lt rx284_pos, 2, rx284_start
    sub rx284_off, rx284_pos, 1
    substr rx284_tgt, rx284_tgt, rx284_off
  rx284_start:
    eq $I10, 1, rx284_restart
    if_null rx284_debug, debug_523
    rx284_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_523:
    $I10 = self.'from'()
    ne $I10, -1, rxscan287_done
    goto rxscan287_scan
  rxscan287_loop:
    ($P10) = rx284_cur."from"()
    inc $P10
    set rx284_pos, $P10
    ge rx284_pos, rx284_eos, rxscan287_done
  rxscan287_scan:
    set_addr $I10, rxscan287_loop
    rx284_cur."!mark_push"(0, rx284_pos, $I10)
  rxscan287_done:
.annotate 'line', 180
  # rx subcapture "sym"
    set_addr $I10, rxcap_288_fail
    rx284_cur."!mark_push"(0, rx284_pos, $I10)
  # rx literal  "unless"
    add $I11, rx284_pos, 6
    gt $I11, rx284_eos, rx284_fail
    sub $I11, rx284_pos, rx284_off
    substr $S10, rx284_tgt, $I11, 6
    ne $S10, "unless", rx284_fail
    add rx284_pos, 6
    set_addr $I10, rxcap_288_fail
    ($I12, $I11) = rx284_cur."!mark_peek"($I10)
    rx284_cur."!cursor_pos"($I11)
    ($P10) = rx284_cur."!cursor_start"()
    $P10."!cursor_pass"(rx284_pos, "")
    rx284_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_288_done
  rxcap_288_fail:
    goto rx284_fail
  rxcap_288_done:
  # rx charclass s
    ge rx284_pos, rx284_eos, rx284_fail
    sub $I10, rx284_pos, rx284_off
    is_cclass $I11, 32, rx284_tgt, $I10
    unless $I11, rx284_fail
    inc rx284_pos
  # rx subrule "ws" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."ws"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
.annotate 'line', 181
  # rx subrule "xblock" subtype=capture negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."xblock"()
    unless $P10, rx284_fail
    rx284_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx284_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."ws"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
  alt291_0:
.annotate 'line', 182
    set_addr $I10, alt291_1
    rx284_cur."!mark_push"(0, rx284_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."ws"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx284_cur."!cursor_pos"(rx284_pos)
    .const 'Sub' $P294 = "66_1295307698.031" 
    capture_lex $P294
    $P10 = rx284_cur."before"($P294)
    if $P10, rx284_fail
  # rx subrule "ws" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."ws"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
    goto alt291_end
  alt291_1:
  # rx subrule "ws" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."ws"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."ws"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
  alt291_end:
  # rx subrule "ws" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."ws"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
.annotate 'line', 179
  # rx pass
    rx284_cur."!cursor_pass"(rx284_pos, "statement_control:sym<unless>")
    if_null rx284_debug, debug_528
    rx284_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx284_pos)
  debug_528:
    .return (rx284_cur)
  rx284_restart:
.annotate 'line', 4
    if_null rx284_debug, debug_529
    rx284_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_529:
  rx284_fail:
    (rx284_rep, rx284_pos, $I10, $P10) = rx284_cur."!mark_fail"(0)
    lt rx284_pos, -1, rx284_done
    eq rx284_pos, -1, rx284_fail
    jump $I10
  rx284_done:
    rx284_cur."!cursor_fail"()
    if_null rx284_debug, debug_530
    rx284_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_530:
    .return (rx284_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("65_1295307698.031") :method
.annotate 'line', 4
    new $P286, "ResizablePMCArray"
    push $P286, "unless"
    .return ($P286)
.end


.namespace ["NQP";"Grammar"]
.sub "_block293"  :anon :subid("66_1295307698.031") :method :outer("64_1295307698.031")
.annotate 'line', 182
    .local string rx295_tgt
    .local int rx295_pos
    .local int rx295_off
    .local int rx295_eos
    .local int rx295_rep
    .local pmc rx295_cur
    .local pmc rx295_debug
    (rx295_cur, rx295_pos, rx295_tgt, $I10) = self."!cursor_start"()
    getattribute rx295_debug, rx295_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx295_cur
    .local pmc match
    .lex "$/", match
    length rx295_eos, rx295_tgt
    gt rx295_pos, rx295_eos, rx295_done
    set rx295_off, 0
    lt rx295_pos, 2, rx295_start
    sub rx295_off, rx295_pos, 1
    substr rx295_tgt, rx295_tgt, rx295_off
  rx295_start:
    eq $I10, 1, rx295_restart
    if_null rx295_debug, debug_524
    rx295_cur."!cursor_debug"("START", "")
  debug_524:
    $I10 = self.'from'()
    ne $I10, -1, rxscan296_done
    goto rxscan296_scan
  rxscan296_loop:
    ($P10) = rx295_cur."from"()
    inc $P10
    set rx295_pos, $P10
    ge rx295_pos, rx295_eos, rxscan296_done
  rxscan296_scan:
    set_addr $I10, rxscan296_loop
    rx295_cur."!mark_push"(0, rx295_pos, $I10)
  rxscan296_done:
  # rx literal  "else"
    add $I11, rx295_pos, 4
    gt $I11, rx295_eos, rx295_fail
    sub $I11, rx295_pos, rx295_off
    substr $S10, rx295_tgt, $I11, 4
    ne $S10, "else", rx295_fail
    add rx295_pos, 4
  # rx pass
    rx295_cur."!cursor_pass"(rx295_pos, "")
    if_null rx295_debug, debug_525
    rx295_cur."!cursor_debug"("PASS", "", " at pos=", rx295_pos)
  debug_525:
    .return (rx295_cur)
  rx295_restart:
    if_null rx295_debug, debug_526
    rx295_cur."!cursor_debug"("NEXT", "")
  debug_526:
  rx295_fail:
    (rx295_rep, rx295_pos, $I10, $P10) = rx295_cur."!mark_fail"(0)
    lt rx295_pos, -1, rx295_done
    eq rx295_pos, -1, rx295_fail
    jump $I10
  rx295_done:
    rx295_cur."!cursor_fail"()
    if_null rx295_debug, debug_527
    rx295_cur."!cursor_debug"("FAIL", "")
  debug_527:
    .return (rx295_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("67_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx302_tgt
    .local int rx302_pos
    .local int rx302_off
    .local int rx302_eos
    .local int rx302_rep
    .local pmc rx302_cur
    .local pmc rx302_debug
    (rx302_cur, rx302_pos, rx302_tgt, $I10) = self."!cursor_start"()
    getattribute rx302_debug, rx302_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx302_cur
    .local pmc match
    .lex "$/", match
    length rx302_eos, rx302_tgt
    gt rx302_pos, rx302_eos, rx302_done
    set rx302_off, 0
    lt rx302_pos, 2, rx302_start
    sub rx302_off, rx302_pos, 1
    substr rx302_tgt, rx302_tgt, rx302_off
  rx302_start:
    eq $I10, 1, rx302_restart
    if_null rx302_debug, debug_531
    rx302_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_531:
    $I10 = self.'from'()
    ne $I10, -1, rxscan305_done
    goto rxscan305_scan
  rxscan305_loop:
    ($P10) = rx302_cur."from"()
    inc $P10
    set rx302_pos, $P10
    ge rx302_pos, rx302_eos, rxscan305_done
  rxscan305_scan:
    set_addr $I10, rxscan305_loop
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  rxscan305_done:
.annotate 'line', 186
  # rx subcapture "sym"
    set_addr $I10, rxcap_307_fail
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  alt306_0:
    set_addr $I10, alt306_1
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  # rx literal  "while"
    add $I11, rx302_pos, 5
    gt $I11, rx302_eos, rx302_fail
    sub $I11, rx302_pos, rx302_off
    substr $S10, rx302_tgt, $I11, 5
    ne $S10, "while", rx302_fail
    add rx302_pos, 5
    goto alt306_end
  alt306_1:
  # rx literal  "until"
    add $I11, rx302_pos, 5
    gt $I11, rx302_eos, rx302_fail
    sub $I11, rx302_pos, rx302_off
    substr $S10, rx302_tgt, $I11, 5
    ne $S10, "until", rx302_fail
    add rx302_pos, 5
  alt306_end:
    set_addr $I10, rxcap_307_fail
    ($I12, $I11) = rx302_cur."!mark_peek"($I10)
    rx302_cur."!cursor_pos"($I11)
    ($P10) = rx302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx302_pos, "")
    rx302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_307_done
  rxcap_307_fail:
    goto rx302_fail
  rxcap_307_done:
  # rx charclass s
    ge rx302_pos, rx302_eos, rx302_fail
    sub $I10, rx302_pos, rx302_off
    is_cclass $I11, 32, rx302_tgt, $I10
    unless $I11, rx302_fail
    inc rx302_pos
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
.annotate 'line', 187
  # rx subrule "xblock" subtype=capture negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."xblock"()
    unless $P10, rx302_fail
    rx302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
.annotate 'line', 185
  # rx pass
    rx302_cur."!cursor_pass"(rx302_pos, "statement_control:sym<while>")
    if_null rx302_debug, debug_532
    rx302_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx302_pos)
  debug_532:
    .return (rx302_cur)
  rx302_restart:
.annotate 'line', 4
    if_null rx302_debug, debug_533
    rx302_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_533:
  rx302_fail:
    (rx302_rep, rx302_pos, $I10, $P10) = rx302_cur."!mark_fail"(0)
    lt rx302_pos, -1, rx302_done
    eq rx302_pos, -1, rx302_fail
    jump $I10
  rx302_done:
    rx302_cur."!cursor_fail"()
    if_null rx302_debug, debug_534
    rx302_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_534:
    .return (rx302_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("68_1295307698.031") :method
.annotate 'line', 4
    new $P304, "ResizablePMCArray"
    push $P304, "until"
    push $P304, "while"
    .return ($P304)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("69_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx311_tgt
    .local int rx311_pos
    .local int rx311_off
    .local int rx311_eos
    .local int rx311_rep
    .local pmc rx311_cur
    .local pmc rx311_debug
    (rx311_cur, rx311_pos, rx311_tgt, $I10) = self."!cursor_start"()
    getattribute rx311_debug, rx311_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx311_cur
    .local pmc match
    .lex "$/", match
    length rx311_eos, rx311_tgt
    gt rx311_pos, rx311_eos, rx311_done
    set rx311_off, 0
    lt rx311_pos, 2, rx311_start
    sub rx311_off, rx311_pos, 1
    substr rx311_tgt, rx311_tgt, rx311_off
  rx311_start:
    eq $I10, 1, rx311_restart
    if_null rx311_debug, debug_535
    rx311_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_535:
    $I10 = self.'from'()
    ne $I10, -1, rxscan314_done
    goto rxscan314_scan
  rxscan314_loop:
    ($P10) = rx311_cur."from"()
    inc $P10
    set rx311_pos, $P10
    ge rx311_pos, rx311_eos, rxscan314_done
  rxscan314_scan:
    set_addr $I10, rxscan314_loop
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  rxscan314_done:
.annotate 'line', 191
  # rx subcapture "sym"
    set_addr $I10, rxcap_315_fail
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx311_pos, 6
    gt $I11, rx311_eos, rx311_fail
    sub $I11, rx311_pos, rx311_off
    substr $S10, rx311_tgt, $I11, 6
    ne $S10, "repeat", rx311_fail
    add rx311_pos, 6
    set_addr $I10, rxcap_315_fail
    ($I12, $I11) = rx311_cur."!mark_peek"($I10)
    rx311_cur."!cursor_pos"($I11)
    ($P10) = rx311_cur."!cursor_start"()
    $P10."!cursor_pass"(rx311_pos, "")
    rx311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_315_done
  rxcap_315_fail:
    goto rx311_fail
  rxcap_315_done:
  # rx charclass s
    ge rx311_pos, rx311_eos, rx311_fail
    sub $I10, rx311_pos, rx311_off
    is_cclass $I11, 32, rx311_tgt, $I10
    unless $I11, rx311_fail
    inc rx311_pos
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
  alt317_0:
.annotate 'line', 192
    set_addr $I10, alt317_1
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
.annotate 'line', 193
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_320_fail
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  alt319_0:
    set_addr $I10, alt319_1
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  # rx literal  "while"
    add $I11, rx311_pos, 5
    gt $I11, rx311_eos, rx311_fail
    sub $I11, rx311_pos, rx311_off
    substr $S10, rx311_tgt, $I11, 5
    ne $S10, "while", rx311_fail
    add rx311_pos, 5
    goto alt319_end
  alt319_1:
  # rx literal  "until"
    add $I11, rx311_pos, 5
    gt $I11, rx311_eos, rx311_fail
    sub $I11, rx311_pos, rx311_off
    substr $S10, rx311_tgt, $I11, 5
    ne $S10, "until", rx311_fail
    add rx311_pos, 5
  alt319_end:
    set_addr $I10, rxcap_320_fail
    ($I12, $I11) = rx311_cur."!mark_peek"($I10)
    rx311_cur."!cursor_pos"($I11)
    ($P10) = rx311_cur."!cursor_start"()
    $P10."!cursor_pass"(rx311_pos, "")
    rx311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_320_done
  rxcap_320_fail:
    goto rx311_fail
  rxcap_320_done:
  # rx charclass s
    ge rx311_pos, rx311_eos, rx311_fail
    sub $I10, rx311_pos, rx311_off
    is_cclass $I11, 32, rx311_tgt, $I10
    unless $I11, rx311_fail
    inc rx311_pos
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."xblock"()
    unless $P10, rx311_fail
    rx311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx311_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
    goto alt317_end
  alt317_1:
.annotate 'line', 194
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."pblock"()
    unless $P10, rx311_fail
    rx311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx311_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_326_fail
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  alt325_0:
    set_addr $I10, alt325_1
    rx311_cur."!mark_push"(0, rx311_pos, $I10)
  # rx literal  "while"
    add $I11, rx311_pos, 5
    gt $I11, rx311_eos, rx311_fail
    sub $I11, rx311_pos, rx311_off
    substr $S10, rx311_tgt, $I11, 5
    ne $S10, "while", rx311_fail
    add rx311_pos, 5
    goto alt325_end
  alt325_1:
  # rx literal  "until"
    add $I11, rx311_pos, 5
    gt $I11, rx311_eos, rx311_fail
    sub $I11, rx311_pos, rx311_off
    substr $S10, rx311_tgt, $I11, 5
    ne $S10, "until", rx311_fail
    add rx311_pos, 5
  alt325_end:
    set_addr $I10, rxcap_326_fail
    ($I12, $I11) = rx311_cur."!mark_peek"($I10)
    rx311_cur."!cursor_pos"($I11)
    ($P10) = rx311_cur."!cursor_start"()
    $P10."!cursor_pass"(rx311_pos, "")
    rx311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_326_done
  rxcap_326_fail:
    goto rx311_fail
  rxcap_326_done:
  # rx charclass s
    ge rx311_pos, rx311_eos, rx311_fail
    sub $I10, rx311_pos, rx311_off
    is_cclass $I11, 32, rx311_tgt, $I10
    unless $I11, rx311_fail
    inc rx311_pos
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."EXPR"()
    unless $P10, rx311_fail
    rx311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx311_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
  alt317_end:
.annotate 'line', 195
  # rx subrule "ws" subtype=method negate=
    rx311_cur."!cursor_pos"(rx311_pos)
    $P10 = rx311_cur."ws"()
    unless $P10, rx311_fail
    rx311_pos = $P10."pos"()
.annotate 'line', 190
  # rx pass
    rx311_cur."!cursor_pass"(rx311_pos, "statement_control:sym<repeat>")
    if_null rx311_debug, debug_536
    rx311_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx311_pos)
  debug_536:
    .return (rx311_cur)
  rx311_restart:
.annotate 'line', 4
    if_null rx311_debug, debug_537
    rx311_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_537:
  rx311_fail:
    (rx311_rep, rx311_pos, $I10, $P10) = rx311_cur."!mark_fail"(0)
    lt rx311_pos, -1, rx311_done
    eq rx311_pos, -1, rx311_fail
    jump $I10
  rx311_done:
    rx311_cur."!cursor_fail"()
    if_null rx311_debug, debug_538
    rx311_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_538:
    .return (rx311_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("70_1295307698.031") :method
.annotate 'line', 4
    new $P313, "ResizablePMCArray"
    push $P313, "repeat"
    .return ($P313)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("71_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx331_tgt
    .local int rx331_pos
    .local int rx331_off
    .local int rx331_eos
    .local int rx331_rep
    .local pmc rx331_cur
    .local pmc rx331_debug
    (rx331_cur, rx331_pos, rx331_tgt, $I10) = self."!cursor_start"()
    getattribute rx331_debug, rx331_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx331_cur
    .local pmc match
    .lex "$/", match
    length rx331_eos, rx331_tgt
    gt rx331_pos, rx331_eos, rx331_done
    set rx331_off, 0
    lt rx331_pos, 2, rx331_start
    sub rx331_off, rx331_pos, 1
    substr rx331_tgt, rx331_tgt, rx331_off
  rx331_start:
    eq $I10, 1, rx331_restart
    if_null rx331_debug, debug_539
    rx331_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_539:
    $I10 = self.'from'()
    ne $I10, -1, rxscan334_done
    goto rxscan334_scan
  rxscan334_loop:
    ($P10) = rx331_cur."from"()
    inc $P10
    set rx331_pos, $P10
    ge rx331_pos, rx331_eos, rxscan334_done
  rxscan334_scan:
    set_addr $I10, rxscan334_loop
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
  rxscan334_done:
.annotate 'line', 199
  # rx subcapture "sym"
    set_addr $I10, rxcap_335_fail
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
  # rx literal  "for"
    add $I11, rx331_pos, 3
    gt $I11, rx331_eos, rx331_fail
    sub $I11, rx331_pos, rx331_off
    substr $S10, rx331_tgt, $I11, 3
    ne $S10, "for", rx331_fail
    add rx331_pos, 3
    set_addr $I10, rxcap_335_fail
    ($I12, $I11) = rx331_cur."!mark_peek"($I10)
    rx331_cur."!cursor_pos"($I11)
    ($P10) = rx331_cur."!cursor_start"()
    $P10."!cursor_pass"(rx331_pos, "")
    rx331_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_335_done
  rxcap_335_fail:
    goto rx331_fail
  rxcap_335_done:
  # rx charclass s
    ge rx331_pos, rx331_eos, rx331_fail
    sub $I10, rx331_pos, rx331_off
    is_cclass $I11, 32, rx331_tgt, $I10
    unless $I11, rx331_fail
    inc rx331_pos
  # rx subrule "ws" subtype=method negate=
    rx331_cur."!cursor_pos"(rx331_pos)
    $P10 = rx331_cur."ws"()
    unless $P10, rx331_fail
    rx331_pos = $P10."pos"()
.annotate 'line', 200
  # rx subrule "xblock" subtype=capture negate=
    rx331_cur."!cursor_pos"(rx331_pos)
    $P10 = rx331_cur."xblock"()
    unless $P10, rx331_fail
    rx331_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx331_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx331_cur."!cursor_pos"(rx331_pos)
    $P10 = rx331_cur."ws"()
    unless $P10, rx331_fail
    rx331_pos = $P10."pos"()
.annotate 'line', 198
  # rx pass
    rx331_cur."!cursor_pass"(rx331_pos, "statement_control:sym<for>")
    if_null rx331_debug, debug_540
    rx331_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx331_pos)
  debug_540:
    .return (rx331_cur)
  rx331_restart:
.annotate 'line', 4
    if_null rx331_debug, debug_541
    rx331_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_541:
  rx331_fail:
    (rx331_rep, rx331_pos, $I10, $P10) = rx331_cur."!mark_fail"(0)
    lt rx331_pos, -1, rx331_done
    eq rx331_pos, -1, rx331_fail
    jump $I10
  rx331_done:
    rx331_cur."!cursor_fail"()
    if_null rx331_debug, debug_542
    rx331_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_542:
    .return (rx331_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("72_1295307698.031") :method
.annotate 'line', 4
    new $P333, "ResizablePMCArray"
    push $P333, "for"
    .return ($P333)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("73_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx339_tgt
    .local int rx339_pos
    .local int rx339_off
    .local int rx339_eos
    .local int rx339_rep
    .local pmc rx339_cur
    .local pmc rx339_debug
    (rx339_cur, rx339_pos, rx339_tgt, $I10) = self."!cursor_start"()
    getattribute rx339_debug, rx339_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx339_cur
    .local pmc match
    .lex "$/", match
    length rx339_eos, rx339_tgt
    gt rx339_pos, rx339_eos, rx339_done
    set rx339_off, 0
    lt rx339_pos, 2, rx339_start
    sub rx339_off, rx339_pos, 1
    substr rx339_tgt, rx339_tgt, rx339_off
  rx339_start:
    eq $I10, 1, rx339_restart
    if_null rx339_debug, debug_543
    rx339_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_543:
    $I10 = self.'from'()
    ne $I10, -1, rxscan342_done
    goto rxscan342_scan
  rxscan342_loop:
    ($P10) = rx339_cur."from"()
    inc $P10
    set rx339_pos, $P10
    ge rx339_pos, rx339_eos, rxscan342_done
  rxscan342_scan:
    set_addr $I10, rxscan342_loop
    rx339_cur."!mark_push"(0, rx339_pos, $I10)
  rxscan342_done:
.annotate 'line', 204
  # rx subcapture "sym"
    set_addr $I10, rxcap_343_fail
    rx339_cur."!mark_push"(0, rx339_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx339_pos, 5
    gt $I11, rx339_eos, rx339_fail
    sub $I11, rx339_pos, rx339_off
    substr $S10, rx339_tgt, $I11, 5
    ne $S10, "CATCH", rx339_fail
    add rx339_pos, 5
    set_addr $I10, rxcap_343_fail
    ($I12, $I11) = rx339_cur."!mark_peek"($I10)
    rx339_cur."!cursor_pos"($I11)
    ($P10) = rx339_cur."!cursor_start"()
    $P10."!cursor_pass"(rx339_pos, "")
    rx339_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_343_done
  rxcap_343_fail:
    goto rx339_fail
  rxcap_343_done:
  # rx charclass s
    ge rx339_pos, rx339_eos, rx339_fail
    sub $I10, rx339_pos, rx339_off
    is_cclass $I11, 32, rx339_tgt, $I10
    unless $I11, rx339_fail
    inc rx339_pos
  # rx subrule "ws" subtype=method negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."ws"()
    unless $P10, rx339_fail
    rx339_pos = $P10."pos"()
.annotate 'line', 205
  # rx subrule "block" subtype=capture negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."block"()
    unless $P10, rx339_fail
    rx339_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx339_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."ws"()
    unless $P10, rx339_fail
    rx339_pos = $P10."pos"()
.annotate 'line', 203
  # rx pass
    rx339_cur."!cursor_pass"(rx339_pos, "statement_control:sym<CATCH>")
    if_null rx339_debug, debug_544
    rx339_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx339_pos)
  debug_544:
    .return (rx339_cur)
  rx339_restart:
.annotate 'line', 4
    if_null rx339_debug, debug_545
    rx339_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_545:
  rx339_fail:
    (rx339_rep, rx339_pos, $I10, $P10) = rx339_cur."!mark_fail"(0)
    lt rx339_pos, -1, rx339_done
    eq rx339_pos, -1, rx339_fail
    jump $I10
  rx339_done:
    rx339_cur."!cursor_fail"()
    if_null rx339_debug, debug_546
    rx339_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_546:
    .return (rx339_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("74_1295307698.031") :method
.annotate 'line', 4
    new $P341, "ResizablePMCArray"
    push $P341, "CATCH"
    .return ($P341)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("75_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx347_tgt
    .local int rx347_pos
    .local int rx347_off
    .local int rx347_eos
    .local int rx347_rep
    .local pmc rx347_cur
    .local pmc rx347_debug
    (rx347_cur, rx347_pos, rx347_tgt, $I10) = self."!cursor_start"()
    getattribute rx347_debug, rx347_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx347_cur
    .local pmc match
    .lex "$/", match
    length rx347_eos, rx347_tgt
    gt rx347_pos, rx347_eos, rx347_done
    set rx347_off, 0
    lt rx347_pos, 2, rx347_start
    sub rx347_off, rx347_pos, 1
    substr rx347_tgt, rx347_tgt, rx347_off
  rx347_start:
    eq $I10, 1, rx347_restart
    if_null rx347_debug, debug_547
    rx347_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_547:
    $I10 = self.'from'()
    ne $I10, -1, rxscan350_done
    goto rxscan350_scan
  rxscan350_loop:
    ($P10) = rx347_cur."from"()
    inc $P10
    set rx347_pos, $P10
    ge rx347_pos, rx347_eos, rxscan350_done
  rxscan350_scan:
    set_addr $I10, rxscan350_loop
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxscan350_done:
.annotate 'line', 209
  # rx subcapture "sym"
    set_addr $I10, rxcap_351_fail
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx347_pos, 7
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 7
    ne $S10, "CONTROL", rx347_fail
    add rx347_pos, 7
    set_addr $I10, rxcap_351_fail
    ($I12, $I11) = rx347_cur."!mark_peek"($I10)
    rx347_cur."!cursor_pos"($I11)
    ($P10) = rx347_cur."!cursor_start"()
    $P10."!cursor_pass"(rx347_pos, "")
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_351_done
  rxcap_351_fail:
    goto rx347_fail
  rxcap_351_done:
  # rx charclass s
    ge rx347_pos, rx347_eos, rx347_fail
    sub $I10, rx347_pos, rx347_off
    is_cclass $I11, 32, rx347_tgt, $I10
    unless $I11, rx347_fail
    inc rx347_pos
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 210
  # rx subrule "block" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."block"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx347_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 208
  # rx pass
    rx347_cur."!cursor_pass"(rx347_pos, "statement_control:sym<CONTROL>")
    if_null rx347_debug, debug_548
    rx347_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx347_pos)
  debug_548:
    .return (rx347_cur)
  rx347_restart:
.annotate 'line', 4
    if_null rx347_debug, debug_549
    rx347_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_549:
  rx347_fail:
    (rx347_rep, rx347_pos, $I10, $P10) = rx347_cur."!mark_fail"(0)
    lt rx347_pos, -1, rx347_done
    eq rx347_pos, -1, rx347_fail
    jump $I10
  rx347_done:
    rx347_cur."!cursor_fail"()
    if_null rx347_debug, debug_550
    rx347_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_550:
    .return (rx347_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("76_1295307698.031") :method
.annotate 'line', 4
    new $P349, "ResizablePMCArray"
    push $P349, "CONTROL"
    .return ($P349)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("77_1295307698.031") :method
.annotate 'line', 213
    $P355 = self."!protoregex"("statement_prefix")
    .return ($P355)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("78_1295307698.031") :method
.annotate 'line', 213
    $P357 = self."!PREFIX__!protoregex"("statement_prefix")
    .return ($P357)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("79_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx359_tgt
    .local int rx359_pos
    .local int rx359_off
    .local int rx359_eos
    .local int rx359_rep
    .local pmc rx359_cur
    .local pmc rx359_debug
    (rx359_cur, rx359_pos, rx359_tgt, $I10) = self."!cursor_start"()
    getattribute rx359_debug, rx359_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx359_cur
    .local pmc match
    .lex "$/", match
    length rx359_eos, rx359_tgt
    gt rx359_pos, rx359_eos, rx359_done
    set rx359_off, 0
    lt rx359_pos, 2, rx359_start
    sub rx359_off, rx359_pos, 1
    substr rx359_tgt, rx359_tgt, rx359_off
  rx359_start:
    eq $I10, 1, rx359_restart
    if_null rx359_debug, debug_551
    rx359_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_551:
    $I10 = self.'from'()
    ne $I10, -1, rxscan363_done
    goto rxscan363_scan
  rxscan363_loop:
    ($P10) = rx359_cur."from"()
    inc $P10
    set rx359_pos, $P10
    ge rx359_pos, rx359_eos, rxscan363_done
  rxscan363_scan:
    set_addr $I10, rxscan363_loop
    rx359_cur."!mark_push"(0, rx359_pos, $I10)
  rxscan363_done:
.annotate 'line', 214
  # rx subcapture "sym"
    set_addr $I10, rxcap_364_fail
    rx359_cur."!mark_push"(0, rx359_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx359_pos, 4
    gt $I11, rx359_eos, rx359_fail
    sub $I11, rx359_pos, rx359_off
    substr $S10, rx359_tgt, $I11, 4
    ne $S10, "INIT", rx359_fail
    add rx359_pos, 4
    set_addr $I10, rxcap_364_fail
    ($I12, $I11) = rx359_cur."!mark_peek"($I10)
    rx359_cur."!cursor_pos"($I11)
    ($P10) = rx359_cur."!cursor_start"()
    $P10."!cursor_pass"(rx359_pos, "")
    rx359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_364_done
  rxcap_364_fail:
    goto rx359_fail
  rxcap_364_done:
  # rx subrule "blorst" subtype=capture negate=
    rx359_cur."!cursor_pos"(rx359_pos)
    $P10 = rx359_cur."blorst"()
    unless $P10, rx359_fail
    rx359_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx359_pos = $P10."pos"()
  # rx pass
    rx359_cur."!cursor_pass"(rx359_pos, "statement_prefix:sym<INIT>")
    if_null rx359_debug, debug_552
    rx359_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx359_pos)
  debug_552:
    .return (rx359_cur)
  rx359_restart:
.annotate 'line', 4
    if_null rx359_debug, debug_553
    rx359_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_553:
  rx359_fail:
    (rx359_rep, rx359_pos, $I10, $P10) = rx359_cur."!mark_fail"(0)
    lt rx359_pos, -1, rx359_done
    eq rx359_pos, -1, rx359_fail
    jump $I10
  rx359_done:
    rx359_cur."!cursor_fail"()
    if_null rx359_debug, debug_554
    rx359_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_554:
    .return (rx359_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("80_1295307698.031") :method
.annotate 'line', 4
    $P361 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P362, "ResizablePMCArray"
    push $P362, $P361
    .return ($P362)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("81_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx366_tgt
    .local int rx366_pos
    .local int rx366_off
    .local int rx366_eos
    .local int rx366_rep
    .local pmc rx366_cur
    .local pmc rx366_debug
    (rx366_cur, rx366_pos, rx366_tgt, $I10) = self."!cursor_start"()
    getattribute rx366_debug, rx366_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx366_cur
    .local pmc match
    .lex "$/", match
    length rx366_eos, rx366_tgt
    gt rx366_pos, rx366_eos, rx366_done
    set rx366_off, 0
    lt rx366_pos, 2, rx366_start
    sub rx366_off, rx366_pos, 1
    substr rx366_tgt, rx366_tgt, rx366_off
  rx366_start:
    eq $I10, 1, rx366_restart
    if_null rx366_debug, debug_555
    rx366_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_555:
    $I10 = self.'from'()
    ne $I10, -1, rxscan370_done
    goto rxscan370_scan
  rxscan370_loop:
    ($P10) = rx366_cur."from"()
    inc $P10
    set rx366_pos, $P10
    ge rx366_pos, rx366_eos, rxscan370_done
  rxscan370_scan:
    set_addr $I10, rxscan370_loop
    rx366_cur."!mark_push"(0, rx366_pos, $I10)
  rxscan370_done:
.annotate 'line', 217
  # rx subcapture "sym"
    set_addr $I10, rxcap_371_fail
    rx366_cur."!mark_push"(0, rx366_pos, $I10)
  # rx literal  "try"
    add $I11, rx366_pos, 3
    gt $I11, rx366_eos, rx366_fail
    sub $I11, rx366_pos, rx366_off
    substr $S10, rx366_tgt, $I11, 3
    ne $S10, "try", rx366_fail
    add rx366_pos, 3
    set_addr $I10, rxcap_371_fail
    ($I12, $I11) = rx366_cur."!mark_peek"($I10)
    rx366_cur."!cursor_pos"($I11)
    ($P10) = rx366_cur."!cursor_start"()
    $P10."!cursor_pass"(rx366_pos, "")
    rx366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_371_done
  rxcap_371_fail:
    goto rx366_fail
  rxcap_371_done:
.annotate 'line', 218
  # rx subrule "blorst" subtype=capture negate=
    rx366_cur."!cursor_pos"(rx366_pos)
    $P10 = rx366_cur."blorst"()
    unless $P10, rx366_fail
    rx366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx366_pos = $P10."pos"()
.annotate 'line', 216
  # rx pass
    rx366_cur."!cursor_pass"(rx366_pos, "statement_prefix:sym<try>")
    if_null rx366_debug, debug_556
    rx366_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx366_pos)
  debug_556:
    .return (rx366_cur)
  rx366_restart:
.annotate 'line', 4
    if_null rx366_debug, debug_557
    rx366_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_557:
  rx366_fail:
    (rx366_rep, rx366_pos, $I10, $P10) = rx366_cur."!mark_fail"(0)
    lt rx366_pos, -1, rx366_done
    eq rx366_pos, -1, rx366_fail
    jump $I10
  rx366_done:
    rx366_cur."!cursor_fail"()
    if_null rx366_debug, debug_558
    rx366_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_558:
    .return (rx366_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("82_1295307698.031") :method
.annotate 'line', 4
    $P368 = self."!PREFIX__!subrule"("blorst", "try")
    new $P369, "ResizablePMCArray"
    push $P369, $P368
    .return ($P369)
.end


.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("83_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx373_tgt
    .local int rx373_pos
    .local int rx373_off
    .local int rx373_eos
    .local int rx373_rep
    .local pmc rx373_cur
    .local pmc rx373_debug
    (rx373_cur, rx373_pos, rx373_tgt, $I10) = self."!cursor_start"()
    getattribute rx373_debug, rx373_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx373_cur
    .local pmc match
    .lex "$/", match
    length rx373_eos, rx373_tgt
    gt rx373_pos, rx373_eos, rx373_done
    set rx373_off, 0
    lt rx373_pos, 2, rx373_start
    sub rx373_off, rx373_pos, 1
    substr rx373_tgt, rx373_tgt, rx373_off
  rx373_start:
    eq $I10, 1, rx373_restart
    if_null rx373_debug, debug_559
    rx373_cur."!cursor_debug"("START", "blorst")
  debug_559:
    $I10 = self.'from'()
    ne $I10, -1, rxscan376_done
    goto rxscan376_scan
  rxscan376_loop:
    ($P10) = rx373_cur."from"()
    inc $P10
    set rx373_pos, $P10
    ge rx373_pos, rx373_eos, rxscan376_done
  rxscan376_scan:
    set_addr $I10, rxscan376_loop
    rx373_cur."!mark_push"(0, rx373_pos, $I10)
  rxscan376_done:
.annotate 'line', 222
  # rx charclass s
    ge rx373_pos, rx373_eos, rx373_fail
    sub $I10, rx373_pos, rx373_off
    is_cclass $I11, 32, rx373_tgt, $I10
    unless $I11, rx373_fail
    inc rx373_pos
  # rx subrule "ws" subtype=method negate=
    rx373_cur."!cursor_pos"(rx373_pos)
    $P10 = rx373_cur."ws"()
    unless $P10, rx373_fail
    rx373_pos = $P10."pos"()
  alt377_0:
    set_addr $I10, alt377_1
    rx373_cur."!mark_push"(0, rx373_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx373_pos, rx373_off
    substr $S10, rx373_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx373_fail
  # rx subrule "block" subtype=capture negate=
    rx373_cur."!cursor_pos"(rx373_pos)
    $P10 = rx373_cur."block"()
    unless $P10, rx373_fail
    rx373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx373_pos = $P10."pos"()
    goto alt377_end
  alt377_1:
  # rx subrule "statement" subtype=capture negate=
    rx373_cur."!cursor_pos"(rx373_pos)
    $P10 = rx373_cur."statement"()
    unless $P10, rx373_fail
    rx373_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx373_pos = $P10."pos"()
  alt377_end:
.annotate 'line', 221
  # rx pass
    rx373_cur."!cursor_pass"(rx373_pos, "blorst")
    if_null rx373_debug, debug_560
    rx373_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx373_pos)
  debug_560:
    .return (rx373_cur)
  rx373_restart:
.annotate 'line', 4
    if_null rx373_debug, debug_561
    rx373_cur."!cursor_debug"("NEXT", "blorst")
  debug_561:
  rx373_fail:
    (rx373_rep, rx373_pos, $I10, $P10) = rx373_cur."!mark_fail"(0)
    lt rx373_pos, -1, rx373_done
    eq rx373_pos, -1, rx373_fail
    jump $I10
  rx373_done:
    rx373_cur."!cursor_fail"()
    if_null rx373_debug, debug_562
    rx373_cur."!cursor_debug"("FAIL", "blorst")
  debug_562:
    .return (rx373_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("84_1295307698.031") :method
.annotate 'line', 4
    new $P375, "ResizablePMCArray"
    push $P375, ""
    .return ($P375)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("85_1295307698.031") :method
.annotate 'line', 227
    $P379 = self."!protoregex"("statement_mod_cond")
    .return ($P379)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("86_1295307698.031") :method
.annotate 'line', 227
    $P381 = self."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P381)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("87_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx383_tgt
    .local int rx383_pos
    .local int rx383_off
    .local int rx383_eos
    .local int rx383_rep
    .local pmc rx383_cur
    .local pmc rx383_debug
    (rx383_cur, rx383_pos, rx383_tgt, $I10) = self."!cursor_start"()
    getattribute rx383_debug, rx383_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx383_cur
    .local pmc match
    .lex "$/", match
    length rx383_eos, rx383_tgt
    gt rx383_pos, rx383_eos, rx383_done
    set rx383_off, 0
    lt rx383_pos, 2, rx383_start
    sub rx383_off, rx383_pos, 1
    substr rx383_tgt, rx383_tgt, rx383_off
  rx383_start:
    eq $I10, 1, rx383_restart
    if_null rx383_debug, debug_563
    rx383_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_563:
    $I10 = self.'from'()
    ne $I10, -1, rxscan387_done
    goto rxscan387_scan
  rxscan387_loop:
    ($P10) = rx383_cur."from"()
    inc $P10
    set rx383_pos, $P10
    ge rx383_pos, rx383_eos, rxscan387_done
  rxscan387_scan:
    set_addr $I10, rxscan387_loop
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  rxscan387_done:
.annotate 'line', 229
  # rx subcapture "sym"
    set_addr $I10, rxcap_388_fail
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  # rx literal  "if"
    add $I11, rx383_pos, 2
    gt $I11, rx383_eos, rx383_fail
    sub $I11, rx383_pos, rx383_off
    substr $S10, rx383_tgt, $I11, 2
    ne $S10, "if", rx383_fail
    add rx383_pos, 2
    set_addr $I10, rxcap_388_fail
    ($I12, $I11) = rx383_cur."!mark_peek"($I10)
    rx383_cur."!cursor_pos"($I11)
    ($P10) = rx383_cur."!cursor_start"()
    $P10."!cursor_pass"(rx383_pos, "")
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_388_done
  rxcap_388_fail:
    goto rx383_fail
  rxcap_388_done:
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."EXPR"()
    unless $P10, rx383_fail
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
  # rx pass
    rx383_cur."!cursor_pass"(rx383_pos, "statement_mod_cond:sym<if>")
    if_null rx383_debug, debug_564
    rx383_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx383_pos)
  debug_564:
    .return (rx383_cur)
  rx383_restart:
.annotate 'line', 4
    if_null rx383_debug, debug_565
    rx383_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_565:
  rx383_fail:
    (rx383_rep, rx383_pos, $I10, $P10) = rx383_cur."!mark_fail"(0)
    lt rx383_pos, -1, rx383_done
    eq rx383_pos, -1, rx383_fail
    jump $I10
  rx383_done:
    rx383_cur."!cursor_fail"()
    if_null rx383_debug, debug_566
    rx383_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_566:
    .return (rx383_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("88_1295307698.031") :method
.annotate 'line', 4
    $P385 = self."!PREFIX__!subrule"("ws", "if")
    new $P386, "ResizablePMCArray"
    push $P386, $P385
    .return ($P386)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("89_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx392_tgt
    .local int rx392_pos
    .local int rx392_off
    .local int rx392_eos
    .local int rx392_rep
    .local pmc rx392_cur
    .local pmc rx392_debug
    (rx392_cur, rx392_pos, rx392_tgt, $I10) = self."!cursor_start"()
    getattribute rx392_debug, rx392_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx392_cur
    .local pmc match
    .lex "$/", match
    length rx392_eos, rx392_tgt
    gt rx392_pos, rx392_eos, rx392_done
    set rx392_off, 0
    lt rx392_pos, 2, rx392_start
    sub rx392_off, rx392_pos, 1
    substr rx392_tgt, rx392_tgt, rx392_off
  rx392_start:
    eq $I10, 1, rx392_restart
    if_null rx392_debug, debug_567
    rx392_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_567:
    $I10 = self.'from'()
    ne $I10, -1, rxscan396_done
    goto rxscan396_scan
  rxscan396_loop:
    ($P10) = rx392_cur."from"()
    inc $P10
    set rx392_pos, $P10
    ge rx392_pos, rx392_eos, rxscan396_done
  rxscan396_scan:
    set_addr $I10, rxscan396_loop
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  rxscan396_done:
.annotate 'line', 230
  # rx subcapture "sym"
    set_addr $I10, rxcap_397_fail
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  # rx literal  "unless"
    add $I11, rx392_pos, 6
    gt $I11, rx392_eos, rx392_fail
    sub $I11, rx392_pos, rx392_off
    substr $S10, rx392_tgt, $I11, 6
    ne $S10, "unless", rx392_fail
    add rx392_pos, 6
    set_addr $I10, rxcap_397_fail
    ($I12, $I11) = rx392_cur."!mark_peek"($I10)
    rx392_cur."!cursor_pos"($I11)
    ($P10) = rx392_cur."!cursor_start"()
    $P10."!cursor_pass"(rx392_pos, "")
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_397_done
  rxcap_397_fail:
    goto rx392_fail
  rxcap_397_done:
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."EXPR"()
    unless $P10, rx392_fail
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx392_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
  # rx pass
    rx392_cur."!cursor_pass"(rx392_pos, "statement_mod_cond:sym<unless>")
    if_null rx392_debug, debug_568
    rx392_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx392_pos)
  debug_568:
    .return (rx392_cur)
  rx392_restart:
.annotate 'line', 4
    if_null rx392_debug, debug_569
    rx392_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_569:
  rx392_fail:
    (rx392_rep, rx392_pos, $I10, $P10) = rx392_cur."!mark_fail"(0)
    lt rx392_pos, -1, rx392_done
    eq rx392_pos, -1, rx392_fail
    jump $I10
  rx392_done:
    rx392_cur."!cursor_fail"()
    if_null rx392_debug, debug_570
    rx392_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_570:
    .return (rx392_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("90_1295307698.031") :method
.annotate 'line', 4
    $P394 = self."!PREFIX__!subrule"("ws", "unless")
    new $P395, "ResizablePMCArray"
    push $P395, $P394
    .return ($P395)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("91_1295307698.031") :method
.annotate 'line', 232
    $P401 = self."!protoregex"("statement_mod_loop")
    .return ($P401)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("92_1295307698.031") :method
.annotate 'line', 232
    $P403 = self."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P403)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("93_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx405_tgt
    .local int rx405_pos
    .local int rx405_off
    .local int rx405_eos
    .local int rx405_rep
    .local pmc rx405_cur
    .local pmc rx405_debug
    (rx405_cur, rx405_pos, rx405_tgt, $I10) = self."!cursor_start"()
    getattribute rx405_debug, rx405_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx405_cur
    .local pmc match
    .lex "$/", match
    length rx405_eos, rx405_tgt
    gt rx405_pos, rx405_eos, rx405_done
    set rx405_off, 0
    lt rx405_pos, 2, rx405_start
    sub rx405_off, rx405_pos, 1
    substr rx405_tgt, rx405_tgt, rx405_off
  rx405_start:
    eq $I10, 1, rx405_restart
    if_null rx405_debug, debug_571
    rx405_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_571:
    $I10 = self.'from'()
    ne $I10, -1, rxscan409_done
    goto rxscan409_scan
  rxscan409_loop:
    ($P10) = rx405_cur."from"()
    inc $P10
    set rx405_pos, $P10
    ge rx405_pos, rx405_eos, rxscan409_done
  rxscan409_scan:
    set_addr $I10, rxscan409_loop
    rx405_cur."!mark_push"(0, rx405_pos, $I10)
  rxscan409_done:
.annotate 'line', 234
  # rx subcapture "sym"
    set_addr $I10, rxcap_410_fail
    rx405_cur."!mark_push"(0, rx405_pos, $I10)
  # rx literal  "while"
    add $I11, rx405_pos, 5
    gt $I11, rx405_eos, rx405_fail
    sub $I11, rx405_pos, rx405_off
    substr $S10, rx405_tgt, $I11, 5
    ne $S10, "while", rx405_fail
    add rx405_pos, 5
    set_addr $I10, rxcap_410_fail
    ($I12, $I11) = rx405_cur."!mark_peek"($I10)
    rx405_cur."!cursor_pos"($I11)
    ($P10) = rx405_cur."!cursor_start"()
    $P10."!cursor_pass"(rx405_pos, "")
    rx405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_410_done
  rxcap_410_fail:
    goto rx405_fail
  rxcap_410_done:
  # rx subrule "ws" subtype=method negate=
    rx405_cur."!cursor_pos"(rx405_pos)
    $P10 = rx405_cur."ws"()
    unless $P10, rx405_fail
    rx405_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx405_cur."!cursor_pos"(rx405_pos)
    $P10 = rx405_cur."EXPR"()
    unless $P10, rx405_fail
    rx405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx405_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx405_cur."!cursor_pos"(rx405_pos)
    $P10 = rx405_cur."ws"()
    unless $P10, rx405_fail
    rx405_pos = $P10."pos"()
  # rx pass
    rx405_cur."!cursor_pass"(rx405_pos, "statement_mod_loop:sym<while>")
    if_null rx405_debug, debug_572
    rx405_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx405_pos)
  debug_572:
    .return (rx405_cur)
  rx405_restart:
.annotate 'line', 4
    if_null rx405_debug, debug_573
    rx405_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_573:
  rx405_fail:
    (rx405_rep, rx405_pos, $I10, $P10) = rx405_cur."!mark_fail"(0)
    lt rx405_pos, -1, rx405_done
    eq rx405_pos, -1, rx405_fail
    jump $I10
  rx405_done:
    rx405_cur."!cursor_fail"()
    if_null rx405_debug, debug_574
    rx405_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_574:
    .return (rx405_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("94_1295307698.031") :method
.annotate 'line', 4
    $P407 = self."!PREFIX__!subrule"("ws", "while")
    new $P408, "ResizablePMCArray"
    push $P408, $P407
    .return ($P408)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("95_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx414_tgt
    .local int rx414_pos
    .local int rx414_off
    .local int rx414_eos
    .local int rx414_rep
    .local pmc rx414_cur
    .local pmc rx414_debug
    (rx414_cur, rx414_pos, rx414_tgt, $I10) = self."!cursor_start"()
    getattribute rx414_debug, rx414_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx414_cur
    .local pmc match
    .lex "$/", match
    length rx414_eos, rx414_tgt
    gt rx414_pos, rx414_eos, rx414_done
    set rx414_off, 0
    lt rx414_pos, 2, rx414_start
    sub rx414_off, rx414_pos, 1
    substr rx414_tgt, rx414_tgt, rx414_off
  rx414_start:
    eq $I10, 1, rx414_restart
    if_null rx414_debug, debug_575
    rx414_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_575:
    $I10 = self.'from'()
    ne $I10, -1, rxscan418_done
    goto rxscan418_scan
  rxscan418_loop:
    ($P10) = rx414_cur."from"()
    inc $P10
    set rx414_pos, $P10
    ge rx414_pos, rx414_eos, rxscan418_done
  rxscan418_scan:
    set_addr $I10, rxscan418_loop
    rx414_cur."!mark_push"(0, rx414_pos, $I10)
  rxscan418_done:
.annotate 'line', 235
  # rx subcapture "sym"
    set_addr $I10, rxcap_419_fail
    rx414_cur."!mark_push"(0, rx414_pos, $I10)
  # rx literal  "until"
    add $I11, rx414_pos, 5
    gt $I11, rx414_eos, rx414_fail
    sub $I11, rx414_pos, rx414_off
    substr $S10, rx414_tgt, $I11, 5
    ne $S10, "until", rx414_fail
    add rx414_pos, 5
    set_addr $I10, rxcap_419_fail
    ($I12, $I11) = rx414_cur."!mark_peek"($I10)
    rx414_cur."!cursor_pos"($I11)
    ($P10) = rx414_cur."!cursor_start"()
    $P10."!cursor_pass"(rx414_pos, "")
    rx414_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_419_done
  rxcap_419_fail:
    goto rx414_fail
  rxcap_419_done:
  # rx subrule "ws" subtype=method negate=
    rx414_cur."!cursor_pos"(rx414_pos)
    $P10 = rx414_cur."ws"()
    unless $P10, rx414_fail
    rx414_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx414_cur."!cursor_pos"(rx414_pos)
    $P10 = rx414_cur."EXPR"()
    unless $P10, rx414_fail
    rx414_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx414_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx414_cur."!cursor_pos"(rx414_pos)
    $P10 = rx414_cur."ws"()
    unless $P10, rx414_fail
    rx414_pos = $P10."pos"()
  # rx pass
    rx414_cur."!cursor_pass"(rx414_pos, "statement_mod_loop:sym<until>")
    if_null rx414_debug, debug_576
    rx414_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx414_pos)
  debug_576:
    .return (rx414_cur)
  rx414_restart:
.annotate 'line', 4
    if_null rx414_debug, debug_577
    rx414_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_577:
  rx414_fail:
    (rx414_rep, rx414_pos, $I10, $P10) = rx414_cur."!mark_fail"(0)
    lt rx414_pos, -1, rx414_done
    eq rx414_pos, -1, rx414_fail
    jump $I10
  rx414_done:
    rx414_cur."!cursor_fail"()
    if_null rx414_debug, debug_578
    rx414_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_578:
    .return (rx414_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("96_1295307698.031") :method
.annotate 'line', 4
    $P416 = self."!PREFIX__!subrule"("ws", "until")
    new $P417, "ResizablePMCArray"
    push $P417, $P416
    .return ($P417)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("97_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx423_tgt
    .local int rx423_pos
    .local int rx423_off
    .local int rx423_eos
    .local int rx423_rep
    .local pmc rx423_cur
    .local pmc rx423_debug
    (rx423_cur, rx423_pos, rx423_tgt, $I10) = self."!cursor_start"()
    getattribute rx423_debug, rx423_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx423_cur
    .local pmc match
    .lex "$/", match
    length rx423_eos, rx423_tgt
    gt rx423_pos, rx423_eos, rx423_done
    set rx423_off, 0
    lt rx423_pos, 2, rx423_start
    sub rx423_off, rx423_pos, 1
    substr rx423_tgt, rx423_tgt, rx423_off
  rx423_start:
    eq $I10, 1, rx423_restart
    if_null rx423_debug, debug_579
    rx423_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_579:
    $I10 = self.'from'()
    ne $I10, -1, rxscan427_done
    goto rxscan427_scan
  rxscan427_loop:
    ($P10) = rx423_cur."from"()
    inc $P10
    set rx423_pos, $P10
    ge rx423_pos, rx423_eos, rxscan427_done
  rxscan427_scan:
    set_addr $I10, rxscan427_loop
    rx423_cur."!mark_push"(0, rx423_pos, $I10)
  rxscan427_done:
.annotate 'line', 236
  # rx subcapture "sym"
    set_addr $I10, rxcap_428_fail
    rx423_cur."!mark_push"(0, rx423_pos, $I10)
  # rx literal  "for"
    add $I11, rx423_pos, 3
    gt $I11, rx423_eos, rx423_fail
    sub $I11, rx423_pos, rx423_off
    substr $S10, rx423_tgt, $I11, 3
    ne $S10, "for", rx423_fail
    add rx423_pos, 3
    set_addr $I10, rxcap_428_fail
    ($I12, $I11) = rx423_cur."!mark_peek"($I10)
    rx423_cur."!cursor_pos"($I11)
    ($P10) = rx423_cur."!cursor_start"()
    $P10."!cursor_pass"(rx423_pos, "")
    rx423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_428_done
  rxcap_428_fail:
    goto rx423_fail
  rxcap_428_done:
  # rx subrule "ws" subtype=method negate=
    rx423_cur."!cursor_pos"(rx423_pos)
    $P10 = rx423_cur."ws"()
    unless $P10, rx423_fail
    rx423_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx423_cur."!cursor_pos"(rx423_pos)
    $P10 = rx423_cur."EXPR"()
    unless $P10, rx423_fail
    rx423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx423_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx423_cur."!cursor_pos"(rx423_pos)
    $P10 = rx423_cur."ws"()
    unless $P10, rx423_fail
    rx423_pos = $P10."pos"()
  # rx pass
    rx423_cur."!cursor_pass"(rx423_pos, "statement_mod_loop:sym<for>")
    if_null rx423_debug, debug_580
    rx423_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx423_pos)
  debug_580:
    .return (rx423_cur)
  rx423_restart:
.annotate 'line', 4
    if_null rx423_debug, debug_581
    rx423_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_581:
  rx423_fail:
    (rx423_rep, rx423_pos, $I10, $P10) = rx423_cur."!mark_fail"(0)
    lt rx423_pos, -1, rx423_done
    eq rx423_pos, -1, rx423_fail
    jump $I10
  rx423_done:
    rx423_cur."!cursor_fail"()
    if_null rx423_debug, debug_582
    rx423_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_582:
    .return (rx423_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("98_1295307698.031") :method
.annotate 'line', 4
    $P425 = self."!PREFIX__!subrule"("ws", "for")
    new $P426, "ResizablePMCArray"
    push $P426, $P425
    .return ($P426)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("99_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx432_tgt
    .local int rx432_pos
    .local int rx432_off
    .local int rx432_eos
    .local int rx432_rep
    .local pmc rx432_cur
    .local pmc rx432_debug
    (rx432_cur, rx432_pos, rx432_tgt, $I10) = self."!cursor_start"()
    getattribute rx432_debug, rx432_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx432_cur
    .local pmc match
    .lex "$/", match
    length rx432_eos, rx432_tgt
    gt rx432_pos, rx432_eos, rx432_done
    set rx432_off, 0
    lt rx432_pos, 2, rx432_start
    sub rx432_off, rx432_pos, 1
    substr rx432_tgt, rx432_tgt, rx432_off
  rx432_start:
    eq $I10, 1, rx432_restart
    if_null rx432_debug, debug_583
    rx432_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_583:
    $I10 = self.'from'()
    ne $I10, -1, rxscan436_done
    goto rxscan436_scan
  rxscan436_loop:
    ($P10) = rx432_cur."from"()
    inc $P10
    set rx432_pos, $P10
    ge rx432_pos, rx432_eos, rxscan436_done
  rxscan436_scan:
    set_addr $I10, rxscan436_loop
    rx432_cur."!mark_push"(0, rx432_pos, $I10)
  rxscan436_done:
.annotate 'line', 240
  # rx subrule "fatarrow" subtype=capture negate=
    rx432_cur."!cursor_pos"(rx432_pos)
    $P10 = rx432_cur."fatarrow"()
    unless $P10, rx432_fail
    rx432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx432_pos = $P10."pos"()
  # rx pass
    rx432_cur."!cursor_pass"(rx432_pos, "term:sym<fatarrow>")
    if_null rx432_debug, debug_584
    rx432_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx432_pos)
  debug_584:
    .return (rx432_cur)
  rx432_restart:
.annotate 'line', 4
    if_null rx432_debug, debug_585
    rx432_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_585:
  rx432_fail:
    (rx432_rep, rx432_pos, $I10, $P10) = rx432_cur."!mark_fail"(0)
    lt rx432_pos, -1, rx432_done
    eq rx432_pos, -1, rx432_fail
    jump $I10
  rx432_done:
    rx432_cur."!cursor_fail"()
    if_null rx432_debug, debug_586
    rx432_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_586:
    .return (rx432_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("100_1295307698.031") :method
.annotate 'line', 4
    $P434 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P435, "ResizablePMCArray"
    push $P435, $P434
    .return ($P435)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("101_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx438_tgt
    .local int rx438_pos
    .local int rx438_off
    .local int rx438_eos
    .local int rx438_rep
    .local pmc rx438_cur
    .local pmc rx438_debug
    (rx438_cur, rx438_pos, rx438_tgt, $I10) = self."!cursor_start"()
    getattribute rx438_debug, rx438_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx438_cur
    .local pmc match
    .lex "$/", match
    length rx438_eos, rx438_tgt
    gt rx438_pos, rx438_eos, rx438_done
    set rx438_off, 0
    lt rx438_pos, 2, rx438_start
    sub rx438_off, rx438_pos, 1
    substr rx438_tgt, rx438_tgt, rx438_off
  rx438_start:
    eq $I10, 1, rx438_restart
    if_null rx438_debug, debug_587
    rx438_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_587:
    $I10 = self.'from'()
    ne $I10, -1, rxscan442_done
    goto rxscan442_scan
  rxscan442_loop:
    ($P10) = rx438_cur."from"()
    inc $P10
    set rx438_pos, $P10
    ge rx438_pos, rx438_eos, rxscan442_done
  rxscan442_scan:
    set_addr $I10, rxscan442_loop
    rx438_cur."!mark_push"(0, rx438_pos, $I10)
  rxscan442_done:
.annotate 'line', 241
  # rx subrule "colonpair" subtype=capture negate=
    rx438_cur."!cursor_pos"(rx438_pos)
    $P10 = rx438_cur."colonpair"()
    unless $P10, rx438_fail
    rx438_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx438_pos = $P10."pos"()
  # rx pass
    rx438_cur."!cursor_pass"(rx438_pos, "term:sym<colonpair>")
    if_null rx438_debug, debug_588
    rx438_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx438_pos)
  debug_588:
    .return (rx438_cur)
  rx438_restart:
.annotate 'line', 4
    if_null rx438_debug, debug_589
    rx438_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_589:
  rx438_fail:
    (rx438_rep, rx438_pos, $I10, $P10) = rx438_cur."!mark_fail"(0)
    lt rx438_pos, -1, rx438_done
    eq rx438_pos, -1, rx438_fail
    jump $I10
  rx438_done:
    rx438_cur."!cursor_fail"()
    if_null rx438_debug, debug_590
    rx438_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_590:
    .return (rx438_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("102_1295307698.031") :method
.annotate 'line', 4
    $P440 = self."!PREFIX__!subrule"("colonpair", "")
    new $P441, "ResizablePMCArray"
    push $P441, $P440
    .return ($P441)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("103_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx444_tgt
    .local int rx444_pos
    .local int rx444_off
    .local int rx444_eos
    .local int rx444_rep
    .local pmc rx444_cur
    .local pmc rx444_debug
    (rx444_cur, rx444_pos, rx444_tgt, $I10) = self."!cursor_start"()
    getattribute rx444_debug, rx444_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx444_cur
    .local pmc match
    .lex "$/", match
    length rx444_eos, rx444_tgt
    gt rx444_pos, rx444_eos, rx444_done
    set rx444_off, 0
    lt rx444_pos, 2, rx444_start
    sub rx444_off, rx444_pos, 1
    substr rx444_tgt, rx444_tgt, rx444_off
  rx444_start:
    eq $I10, 1, rx444_restart
    if_null rx444_debug, debug_591
    rx444_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_591:
    $I10 = self.'from'()
    ne $I10, -1, rxscan448_done
    goto rxscan448_scan
  rxscan448_loop:
    ($P10) = rx444_cur."from"()
    inc $P10
    set rx444_pos, $P10
    ge rx444_pos, rx444_eos, rxscan448_done
  rxscan448_scan:
    set_addr $I10, rxscan448_loop
    rx444_cur."!mark_push"(0, rx444_pos, $I10)
  rxscan448_done:
.annotate 'line', 242
  # rx subrule "variable" subtype=capture negate=
    rx444_cur."!cursor_pos"(rx444_pos)
    $P10 = rx444_cur."variable"()
    unless $P10, rx444_fail
    rx444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx444_pos = $P10."pos"()
  # rx pass
    rx444_cur."!cursor_pass"(rx444_pos, "term:sym<variable>")
    if_null rx444_debug, debug_592
    rx444_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx444_pos)
  debug_592:
    .return (rx444_cur)
  rx444_restart:
.annotate 'line', 4
    if_null rx444_debug, debug_593
    rx444_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_593:
  rx444_fail:
    (rx444_rep, rx444_pos, $I10, $P10) = rx444_cur."!mark_fail"(0)
    lt rx444_pos, -1, rx444_done
    eq rx444_pos, -1, rx444_fail
    jump $I10
  rx444_done:
    rx444_cur."!cursor_fail"()
    if_null rx444_debug, debug_594
    rx444_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_594:
    .return (rx444_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("104_1295307698.031") :method
.annotate 'line', 4
    $P446 = self."!PREFIX__!subrule"("variable", "")
    new $P447, "ResizablePMCArray"
    push $P447, $P446
    .return ($P447)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("105_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx450_tgt
    .local int rx450_pos
    .local int rx450_off
    .local int rx450_eos
    .local int rx450_rep
    .local pmc rx450_cur
    .local pmc rx450_debug
    (rx450_cur, rx450_pos, rx450_tgt, $I10) = self."!cursor_start"()
    getattribute rx450_debug, rx450_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx450_cur
    .local pmc match
    .lex "$/", match
    length rx450_eos, rx450_tgt
    gt rx450_pos, rx450_eos, rx450_done
    set rx450_off, 0
    lt rx450_pos, 2, rx450_start
    sub rx450_off, rx450_pos, 1
    substr rx450_tgt, rx450_tgt, rx450_off
  rx450_start:
    eq $I10, 1, rx450_restart
    if_null rx450_debug, debug_595
    rx450_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_595:
    $I10 = self.'from'()
    ne $I10, -1, rxscan454_done
    goto rxscan454_scan
  rxscan454_loop:
    ($P10) = rx450_cur."from"()
    inc $P10
    set rx450_pos, $P10
    ge rx450_pos, rx450_eos, rxscan454_done
  rxscan454_scan:
    set_addr $I10, rxscan454_loop
    rx450_cur."!mark_push"(0, rx450_pos, $I10)
  rxscan454_done:
.annotate 'line', 243
  # rx subrule "package_declarator" subtype=capture negate=
    rx450_cur."!cursor_pos"(rx450_pos)
    $P10 = rx450_cur."package_declarator"()
    unless $P10, rx450_fail
    rx450_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx450_pos = $P10."pos"()
  # rx pass
    rx450_cur."!cursor_pass"(rx450_pos, "term:sym<package_declarator>")
    if_null rx450_debug, debug_596
    rx450_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx450_pos)
  debug_596:
    .return (rx450_cur)
  rx450_restart:
.annotate 'line', 4
    if_null rx450_debug, debug_597
    rx450_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_597:
  rx450_fail:
    (rx450_rep, rx450_pos, $I10, $P10) = rx450_cur."!mark_fail"(0)
    lt rx450_pos, -1, rx450_done
    eq rx450_pos, -1, rx450_fail
    jump $I10
  rx450_done:
    rx450_cur."!cursor_fail"()
    if_null rx450_debug, debug_598
    rx450_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_598:
    .return (rx450_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("106_1295307698.031") :method
.annotate 'line', 4
    $P452 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P453, "ResizablePMCArray"
    push $P453, $P452
    .return ($P453)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("107_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx456_tgt
    .local int rx456_pos
    .local int rx456_off
    .local int rx456_eos
    .local int rx456_rep
    .local pmc rx456_cur
    .local pmc rx456_debug
    (rx456_cur, rx456_pos, rx456_tgt, $I10) = self."!cursor_start"()
    getattribute rx456_debug, rx456_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx456_cur
    .local pmc match
    .lex "$/", match
    length rx456_eos, rx456_tgt
    gt rx456_pos, rx456_eos, rx456_done
    set rx456_off, 0
    lt rx456_pos, 2, rx456_start
    sub rx456_off, rx456_pos, 1
    substr rx456_tgt, rx456_tgt, rx456_off
  rx456_start:
    eq $I10, 1, rx456_restart
    if_null rx456_debug, debug_599
    rx456_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_599:
    $I10 = self.'from'()
    ne $I10, -1, rxscan460_done
    goto rxscan460_scan
  rxscan460_loop:
    ($P10) = rx456_cur."from"()
    inc $P10
    set rx456_pos, $P10
    ge rx456_pos, rx456_eos, rxscan460_done
  rxscan460_scan:
    set_addr $I10, rxscan460_loop
    rx456_cur."!mark_push"(0, rx456_pos, $I10)
  rxscan460_done:
.annotate 'line', 244
  # rx subrule "scope_declarator" subtype=capture negate=
    rx456_cur."!cursor_pos"(rx456_pos)
    $P10 = rx456_cur."scope_declarator"()
    unless $P10, rx456_fail
    rx456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx456_pos = $P10."pos"()
  # rx pass
    rx456_cur."!cursor_pass"(rx456_pos, "term:sym<scope_declarator>")
    if_null rx456_debug, debug_600
    rx456_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx456_pos)
  debug_600:
    .return (rx456_cur)
  rx456_restart:
.annotate 'line', 4
    if_null rx456_debug, debug_601
    rx456_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_601:
  rx456_fail:
    (rx456_rep, rx456_pos, $I10, $P10) = rx456_cur."!mark_fail"(0)
    lt rx456_pos, -1, rx456_done
    eq rx456_pos, -1, rx456_fail
    jump $I10
  rx456_done:
    rx456_cur."!cursor_fail"()
    if_null rx456_debug, debug_602
    rx456_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_602:
    .return (rx456_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("108_1295307698.031") :method
.annotate 'line', 4
    $P458 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P459, "ResizablePMCArray"
    push $P459, $P458
    .return ($P459)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("109_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx462_tgt
    .local int rx462_pos
    .local int rx462_off
    .local int rx462_eos
    .local int rx462_rep
    .local pmc rx462_cur
    .local pmc rx462_debug
    (rx462_cur, rx462_pos, rx462_tgt, $I10) = self."!cursor_start"()
    getattribute rx462_debug, rx462_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx462_cur
    .local pmc match
    .lex "$/", match
    length rx462_eos, rx462_tgt
    gt rx462_pos, rx462_eos, rx462_done
    set rx462_off, 0
    lt rx462_pos, 2, rx462_start
    sub rx462_off, rx462_pos, 1
    substr rx462_tgt, rx462_tgt, rx462_off
  rx462_start:
    eq $I10, 1, rx462_restart
    if_null rx462_debug, debug_603
    rx462_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_603:
    $I10 = self.'from'()
    ne $I10, -1, rxscan466_done
    goto rxscan466_scan
  rxscan466_loop:
    ($P10) = rx462_cur."from"()
    inc $P10
    set rx462_pos, $P10
    ge rx462_pos, rx462_eos, rxscan466_done
  rxscan466_scan:
    set_addr $I10, rxscan466_loop
    rx462_cur."!mark_push"(0, rx462_pos, $I10)
  rxscan466_done:
.annotate 'line', 245
  # rx subrule "routine_declarator" subtype=capture negate=
    rx462_cur."!cursor_pos"(rx462_pos)
    $P10 = rx462_cur."routine_declarator"()
    unless $P10, rx462_fail
    rx462_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx462_pos = $P10."pos"()
  # rx pass
    rx462_cur."!cursor_pass"(rx462_pos, "term:sym<routine_declarator>")
    if_null rx462_debug, debug_604
    rx462_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx462_pos)
  debug_604:
    .return (rx462_cur)
  rx462_restart:
.annotate 'line', 4
    if_null rx462_debug, debug_605
    rx462_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_605:
  rx462_fail:
    (rx462_rep, rx462_pos, $I10, $P10) = rx462_cur."!mark_fail"(0)
    lt rx462_pos, -1, rx462_done
    eq rx462_pos, -1, rx462_fail
    jump $I10
  rx462_done:
    rx462_cur."!cursor_fail"()
    if_null rx462_debug, debug_606
    rx462_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_606:
    .return (rx462_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("110_1295307698.031") :method
.annotate 'line', 4
    $P464 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P465, "ResizablePMCArray"
    push $P465, $P464
    .return ($P465)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("111_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .const 'Sub' $P478 = "114_1295307698.031" 
    capture_lex $P478
    .const 'Sub' $P473 = "113_1295307698.031" 
    capture_lex $P473
    .local string rx468_tgt
    .local int rx468_pos
    .local int rx468_off
    .local int rx468_eos
    .local int rx468_rep
    .local pmc rx468_cur
    .local pmc rx468_debug
    (rx468_cur, rx468_pos, rx468_tgt, $I10) = self."!cursor_start"()
    getattribute rx468_debug, rx468_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx468_cur
    .local pmc match
    .lex "$/", match
    length rx468_eos, rx468_tgt
    gt rx468_pos, rx468_eos, rx468_done
    set rx468_off, 0
    lt rx468_pos, 2, rx468_start
    sub rx468_off, rx468_pos, 1
    substr rx468_tgt, rx468_tgt, rx468_off
  rx468_start:
    eq $I10, 1, rx468_restart
    if_null rx468_debug, debug_607
    rx468_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_607:
    $I10 = self.'from'()
    ne $I10, -1, rxscan471_done
    goto rxscan471_scan
  rxscan471_loop:
    ($P10) = rx468_cur."from"()
    inc $P10
    set rx468_pos, $P10
    ge rx468_pos, rx468_eos, rxscan471_done
  rxscan471_scan:
    set_addr $I10, rxscan471_loop
    rx468_cur."!mark_push"(0, rx468_pos, $I10)
  rxscan471_done:
.annotate 'line', 247
  # rx subrule "before" subtype=zerowidth negate=
    rx468_cur."!cursor_pos"(rx468_pos)
    .const 'Sub' $P473 = "113_1295307698.031" 
    capture_lex $P473
    $P10 = rx468_cur."before"($P473)
    unless $P10, rx468_fail
.annotate 'line', 248
  # rx subrule "before" subtype=zerowidth negate=1
    rx468_cur."!cursor_pos"(rx468_pos)
    .const 'Sub' $P478 = "114_1295307698.031" 
    capture_lex $P478
    $P10 = rx468_cur."before"($P478)
    if $P10, rx468_fail
.annotate 'line', 249
  # rx subrule "multi_declarator" subtype=capture negate=
    rx468_cur."!cursor_pos"(rx468_pos)
    $P10 = rx468_cur."multi_declarator"()
    unless $P10, rx468_fail
    rx468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx468_pos = $P10."pos"()
.annotate 'line', 246
  # rx pass
    rx468_cur."!cursor_pass"(rx468_pos, "term:sym<multi_declarator>")
    if_null rx468_debug, debug_616
    rx468_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx468_pos)
  debug_616:
    .return (rx468_cur)
  rx468_restart:
.annotate 'line', 4
    if_null rx468_debug, debug_617
    rx468_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_617:
  rx468_fail:
    (rx468_rep, rx468_pos, $I10, $P10) = rx468_cur."!mark_fail"(0)
    lt rx468_pos, -1, rx468_done
    eq rx468_pos, -1, rx468_fail
    jump $I10
  rx468_done:
    rx468_cur."!cursor_fail"()
    if_null rx468_debug, debug_618
    rx468_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_618:
    .return (rx468_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("112_1295307698.031") :method
.annotate 'line', 4
    new $P470, "ResizablePMCArray"
    push $P470, ""
    .return ($P470)
.end


.namespace ["NQP";"Grammar"]
.sub "_block472"  :anon :subid("113_1295307698.031") :method :outer("111_1295307698.031")
.annotate 'line', 247
    .local string rx474_tgt
    .local int rx474_pos
    .local int rx474_off
    .local int rx474_eos
    .local int rx474_rep
    .local pmc rx474_cur
    .local pmc rx474_debug
    (rx474_cur, rx474_pos, rx474_tgt, $I10) = self."!cursor_start"()
    getattribute rx474_debug, rx474_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx474_cur
    .local pmc match
    .lex "$/", match
    length rx474_eos, rx474_tgt
    gt rx474_pos, rx474_eos, rx474_done
    set rx474_off, 0
    lt rx474_pos, 2, rx474_start
    sub rx474_off, rx474_pos, 1
    substr rx474_tgt, rx474_tgt, rx474_off
  rx474_start:
    eq $I10, 1, rx474_restart
    if_null rx474_debug, debug_608
    rx474_cur."!cursor_debug"("START", "")
  debug_608:
    $I10 = self.'from'()
    ne $I10, -1, rxscan475_done
    goto rxscan475_scan
  rxscan475_loop:
    ($P10) = rx474_cur."from"()
    inc $P10
    set rx474_pos, $P10
    ge rx474_pos, rx474_eos, rxscan475_done
  rxscan475_scan:
    set_addr $I10, rxscan475_loop
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  rxscan475_done:
  alt476_0:
    set_addr $I10, alt476_1
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  # rx literal  "multi"
    add $I11, rx474_pos, 5
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 5
    ne $S10, "multi", rx474_fail
    add rx474_pos, 5
    goto alt476_end
  alt476_1:
    set_addr $I10, alt476_2
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  # rx literal  "proto"
    add $I11, rx474_pos, 5
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 5
    ne $S10, "proto", rx474_fail
    add rx474_pos, 5
    goto alt476_end
  alt476_2:
  # rx literal  "only"
    add $I11, rx474_pos, 4
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 4
    ne $S10, "only", rx474_fail
    add rx474_pos, 4
  alt476_end:
  # rx pass
    rx474_cur."!cursor_pass"(rx474_pos, "")
    if_null rx474_debug, debug_609
    rx474_cur."!cursor_debug"("PASS", "", " at pos=", rx474_pos)
  debug_609:
    .return (rx474_cur)
  rx474_restart:
    if_null rx474_debug, debug_610
    rx474_cur."!cursor_debug"("NEXT", "")
  debug_610:
  rx474_fail:
    (rx474_rep, rx474_pos, $I10, $P10) = rx474_cur."!mark_fail"(0)
    lt rx474_pos, -1, rx474_done
    eq rx474_pos, -1, rx474_fail
    jump $I10
  rx474_done:
    rx474_cur."!cursor_fail"()
    if_null rx474_debug, debug_611
    rx474_cur."!cursor_debug"("FAIL", "")
  debug_611:
    .return (rx474_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "_block477"  :anon :subid("114_1295307698.031") :method :outer("111_1295307698.031")
.annotate 'line', 248
    .local string rx479_tgt
    .local int rx479_pos
    .local int rx479_off
    .local int rx479_eos
    .local int rx479_rep
    .local pmc rx479_cur
    .local pmc rx479_debug
    (rx479_cur, rx479_pos, rx479_tgt, $I10) = self."!cursor_start"()
    getattribute rx479_debug, rx479_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx479_cur
    .local pmc match
    .lex "$/", match
    length rx479_eos, rx479_tgt
    gt rx479_pos, rx479_eos, rx479_done
    set rx479_off, 0
    lt rx479_pos, 2, rx479_start
    sub rx479_off, rx479_pos, 1
    substr rx479_tgt, rx479_tgt, rx479_off
  rx479_start:
    eq $I10, 1, rx479_restart
    if_null rx479_debug, debug_612
    rx479_cur."!cursor_debug"("START", "")
  debug_612:
    $I10 = self.'from'()
    ne $I10, -1, rxscan480_done
    goto rxscan480_scan
  rxscan480_loop:
    ($P10) = rx479_cur."from"()
    inc $P10
    set rx479_pos, $P10
    ge rx479_pos, rx479_eos, rxscan480_done
  rxscan480_scan:
    set_addr $I10, rxscan480_loop
    rx479_cur."!mark_push"(0, rx479_pos, $I10)
  rxscan480_done:
  # rx literal  "proto"
    add $I11, rx479_pos, 5
    gt $I11, rx479_eos, rx479_fail
    sub $I11, rx479_pos, rx479_off
    substr $S10, rx479_tgt, $I11, 5
    ne $S10, "proto", rx479_fail
    add rx479_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx479_cur."!cursor_pos"(rx479_pos)
    $P10 = rx479_cur."ws"()
    unless $P10, rx479_fail
    rx479_pos = $P10."pos"()
  alt481_0:
    set_addr $I10, alt481_1
    rx479_cur."!mark_push"(0, rx479_pos, $I10)
  # rx literal  "regex"
    add $I11, rx479_pos, 5
    gt $I11, rx479_eos, rx479_fail
    sub $I11, rx479_pos, rx479_off
    substr $S10, rx479_tgt, $I11, 5
    ne $S10, "regex", rx479_fail
    add rx479_pos, 5
    goto alt481_end
  alt481_1:
    set_addr $I10, alt481_2
    rx479_cur."!mark_push"(0, rx479_pos, $I10)
  # rx literal  "token"
    add $I11, rx479_pos, 5
    gt $I11, rx479_eos, rx479_fail
    sub $I11, rx479_pos, rx479_off
    substr $S10, rx479_tgt, $I11, 5
    ne $S10, "token", rx479_fail
    add rx479_pos, 5
    goto alt481_end
  alt481_2:
  # rx literal  "rule"
    add $I11, rx479_pos, 4
    gt $I11, rx479_eos, rx479_fail
    sub $I11, rx479_pos, rx479_off
    substr $S10, rx479_tgt, $I11, 4
    ne $S10, "rule", rx479_fail
    add rx479_pos, 4
  alt481_end:
  # rx pass
    rx479_cur."!cursor_pass"(rx479_pos, "")
    if_null rx479_debug, debug_613
    rx479_cur."!cursor_debug"("PASS", "", " at pos=", rx479_pos)
  debug_613:
    .return (rx479_cur)
  rx479_restart:
    if_null rx479_debug, debug_614
    rx479_cur."!cursor_debug"("NEXT", "")
  debug_614:
  rx479_fail:
    (rx479_rep, rx479_pos, $I10, $P10) = rx479_cur."!mark_fail"(0)
    lt rx479_pos, -1, rx479_done
    eq rx479_pos, -1, rx479_fail
    jump $I10
  rx479_done:
    rx479_cur."!cursor_fail"()
    if_null rx479_debug, debug_615
    rx479_cur."!cursor_debug"("FAIL", "")
  debug_615:
    .return (rx479_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("115_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx483_tgt
    .local int rx483_pos
    .local int rx483_off
    .local int rx483_eos
    .local int rx483_rep
    .local pmc rx483_cur
    .local pmc rx483_debug
    (rx483_cur, rx483_pos, rx483_tgt, $I10) = self."!cursor_start"()
    getattribute rx483_debug, rx483_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx483_cur
    .local pmc match
    .lex "$/", match
    length rx483_eos, rx483_tgt
    gt rx483_pos, rx483_eos, rx483_done
    set rx483_off, 0
    lt rx483_pos, 2, rx483_start
    sub rx483_off, rx483_pos, 1
    substr rx483_tgt, rx483_tgt, rx483_off
  rx483_start:
    eq $I10, 1, rx483_restart
    if_null rx483_debug, debug_619
    rx483_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_619:
    $I10 = self.'from'()
    ne $I10, -1, rxscan487_done
    goto rxscan487_scan
  rxscan487_loop:
    ($P10) = rx483_cur."from"()
    inc $P10
    set rx483_pos, $P10
    ge rx483_pos, rx483_eos, rxscan487_done
  rxscan487_scan:
    set_addr $I10, rxscan487_loop
    rx483_cur."!mark_push"(0, rx483_pos, $I10)
  rxscan487_done:
.annotate 'line', 251
  # rx subrule "regex_declarator" subtype=capture negate=
    rx483_cur."!cursor_pos"(rx483_pos)
    $P10 = rx483_cur."regex_declarator"()
    unless $P10, rx483_fail
    rx483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx483_pos = $P10."pos"()
  # rx pass
    rx483_cur."!cursor_pass"(rx483_pos, "term:sym<regex_declarator>")
    if_null rx483_debug, debug_620
    rx483_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx483_pos)
  debug_620:
    .return (rx483_cur)
  rx483_restart:
.annotate 'line', 4
    if_null rx483_debug, debug_621
    rx483_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_621:
  rx483_fail:
    (rx483_rep, rx483_pos, $I10, $P10) = rx483_cur."!mark_fail"(0)
    lt rx483_pos, -1, rx483_done
    eq rx483_pos, -1, rx483_fail
    jump $I10
  rx483_done:
    rx483_cur."!cursor_fail"()
    if_null rx483_debug, debug_622
    rx483_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_622:
    .return (rx483_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("116_1295307698.031") :method
.annotate 'line', 4
    $P485 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P486, "ResizablePMCArray"
    push $P486, $P485
    .return ($P486)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("117_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx489_tgt
    .local int rx489_pos
    .local int rx489_off
    .local int rx489_eos
    .local int rx489_rep
    .local pmc rx489_cur
    .local pmc rx489_debug
    (rx489_cur, rx489_pos, rx489_tgt, $I10) = self."!cursor_start"()
    getattribute rx489_debug, rx489_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx489_cur
    .local pmc match
    .lex "$/", match
    length rx489_eos, rx489_tgt
    gt rx489_pos, rx489_eos, rx489_done
    set rx489_off, 0
    lt rx489_pos, 2, rx489_start
    sub rx489_off, rx489_pos, 1
    substr rx489_tgt, rx489_tgt, rx489_off
  rx489_start:
    eq $I10, 1, rx489_restart
    if_null rx489_debug, debug_623
    rx489_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan493_done
    goto rxscan493_scan
  rxscan493_loop:
    ($P10) = rx489_cur."from"()
    inc $P10
    set rx489_pos, $P10
    ge rx489_pos, rx489_eos, rxscan493_done
  rxscan493_scan:
    set_addr $I10, rxscan493_loop
    rx489_cur."!mark_push"(0, rx489_pos, $I10)
  rxscan493_done:
.annotate 'line', 252
  # rx subrule "statement_prefix" subtype=capture negate=
    rx489_cur."!cursor_pos"(rx489_pos)
    $P10 = rx489_cur."statement_prefix"()
    unless $P10, rx489_fail
    rx489_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx489_pos = $P10."pos"()
  # rx pass
    rx489_cur."!cursor_pass"(rx489_pos, "term:sym<statement_prefix>")
    if_null rx489_debug, debug_624
    rx489_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx489_pos)
  debug_624:
    .return (rx489_cur)
  rx489_restart:
.annotate 'line', 4
    if_null rx489_debug, debug_625
    rx489_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_625:
  rx489_fail:
    (rx489_rep, rx489_pos, $I10, $P10) = rx489_cur."!mark_fail"(0)
    lt rx489_pos, -1, rx489_done
    eq rx489_pos, -1, rx489_fail
    jump $I10
  rx489_done:
    rx489_cur."!cursor_fail"()
    if_null rx489_debug, debug_626
    rx489_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_626:
    .return (rx489_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("118_1295307698.031") :method
.annotate 'line', 4
    $P491 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P492, "ResizablePMCArray"
    push $P492, $P491
    .return ($P492)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("119_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx495_tgt
    .local int rx495_pos
    .local int rx495_off
    .local int rx495_eos
    .local int rx495_rep
    .local pmc rx495_cur
    .local pmc rx495_debug
    (rx495_cur, rx495_pos, rx495_tgt, $I10) = self."!cursor_start"()
    getattribute rx495_debug, rx495_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx495_cur
    .local pmc match
    .lex "$/", match
    length rx495_eos, rx495_tgt
    gt rx495_pos, rx495_eos, rx495_done
    set rx495_off, 0
    lt rx495_pos, 2, rx495_start
    sub rx495_off, rx495_pos, 1
    substr rx495_tgt, rx495_tgt, rx495_off
  rx495_start:
    eq $I10, 1, rx495_restart
    if_null rx495_debug, debug_627
    rx495_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_627:
    $I10 = self.'from'()
    ne $I10, -1, rxscan498_done
    goto rxscan498_scan
  rxscan498_loop:
    ($P10) = rx495_cur."from"()
    inc $P10
    set rx495_pos, $P10
    ge rx495_pos, rx495_eos, rxscan498_done
  rxscan498_scan:
    set_addr $I10, rxscan498_loop
    rx495_cur."!mark_push"(0, rx495_pos, $I10)
  rxscan498_done:
.annotate 'line', 253
  # rx subrule "lambda" subtype=zerowidth negate=
    rx495_cur."!cursor_pos"(rx495_pos)
    $P10 = rx495_cur."lambda"()
    unless $P10, rx495_fail
  # rx subrule "pblock" subtype=capture negate=
    rx495_cur."!cursor_pos"(rx495_pos)
    $P10 = rx495_cur."pblock"()
    unless $P10, rx495_fail
    rx495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx495_pos = $P10."pos"()
  # rx pass
    rx495_cur."!cursor_pass"(rx495_pos, "term:sym<lambda>")
    if_null rx495_debug, debug_628
    rx495_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx495_pos)
  debug_628:
    .return (rx495_cur)
  rx495_restart:
.annotate 'line', 4
    if_null rx495_debug, debug_629
    rx495_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_629:
  rx495_fail:
    (rx495_rep, rx495_pos, $I10, $P10) = rx495_cur."!mark_fail"(0)
    lt rx495_pos, -1, rx495_done
    eq rx495_pos, -1, rx495_fail
    jump $I10
  rx495_done:
    rx495_cur."!cursor_fail"()
    if_null rx495_debug, debug_630
    rx495_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_630:
    .return (rx495_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("120_1295307698.031") :method
.annotate 'line', 4
    new $P497, "ResizablePMCArray"
    push $P497, ""
    .return ($P497)
.end


.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("121_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx500_tgt
    .local int rx500_pos
    .local int rx500_off
    .local int rx500_eos
    .local int rx500_rep
    .local pmc rx500_cur
    .local pmc rx500_debug
    (rx500_cur, rx500_pos, rx500_tgt, $I10) = self."!cursor_start"()
    getattribute rx500_debug, rx500_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx500_cur
    .local pmc match
    .lex "$/", match
    length rx500_eos, rx500_tgt
    gt rx500_pos, rx500_eos, rx500_done
    set rx500_off, 0
    lt rx500_pos, 2, rx500_start
    sub rx500_off, rx500_pos, 1
    substr rx500_tgt, rx500_tgt, rx500_off
  rx500_start:
    eq $I10, 1, rx500_restart
    if_null rx500_debug, debug_631
    rx500_cur."!cursor_debug"("START", "fatarrow")
  debug_631:
    $I10 = self.'from'()
    ne $I10, -1, rxscan504_done
    goto rxscan504_scan
  rxscan504_loop:
    ($P10) = rx500_cur."from"()
    inc $P10
    set rx500_pos, $P10
    ge rx500_pos, rx500_eos, rxscan504_done
  rxscan504_scan:
    set_addr $I10, rxscan504_loop
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  rxscan504_done:
.annotate 'line', 256
  # rx subrule "identifier" subtype=capture negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."identifier"()
    unless $P10, rx500_fail
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx500_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx500_pos, rx500_off
    set rx500_rep, 0
    sub $I12, rx500_eos, rx500_pos
  rxenumcharlistq505_loop:
    le $I12, 0, rxenumcharlistq505_done
    substr $S10, rx500_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq505_done
    inc rx500_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq505_loop
  rxenumcharlistq505_done:
    add rx500_pos, rx500_pos, rx500_rep
  # rx literal  "=>"
    add $I11, rx500_pos, 2
    gt $I11, rx500_eos, rx500_fail
    sub $I11, rx500_pos, rx500_off
    substr $S10, rx500_tgt, $I11, 2
    ne $S10, "=>", rx500_fail
    add rx500_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."ws"()
    unless $P10, rx500_fail
    rx500_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."EXPR"("i=")
    unless $P10, rx500_fail
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx500_pos = $P10."pos"()
.annotate 'line', 255
  # rx pass
    rx500_cur."!cursor_pass"(rx500_pos, "fatarrow")
    if_null rx500_debug, debug_632
    rx500_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx500_pos)
  debug_632:
    .return (rx500_cur)
  rx500_restart:
.annotate 'line', 4
    if_null rx500_debug, debug_633
    rx500_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_633:
  rx500_fail:
    (rx500_rep, rx500_pos, $I10, $P10) = rx500_cur."!mark_fail"(0)
    lt rx500_pos, -1, rx500_done
    eq rx500_pos, -1, rx500_fail
    jump $I10
  rx500_done:
    rx500_cur."!cursor_fail"()
    if_null rx500_debug, debug_634
    rx500_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_634:
    .return (rx500_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("122_1295307698.031") :method
.annotate 'line', 4
    $P502 = self."!PREFIX__!subrule"("identifier", "")
    new $P503, "ResizablePMCArray"
    push $P503, $P502
    .return ($P503)
.end


.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("123_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx507_tgt
    .local int rx507_pos
    .local int rx507_off
    .local int rx507_eos
    .local int rx507_rep
    .local pmc rx507_cur
    .local pmc rx507_debug
    (rx507_cur, rx507_pos, rx507_tgt, $I10) = self."!cursor_start"()
    rx507_cur."!cursor_caparray"("circumfix")
    getattribute rx507_debug, rx507_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx507_cur
    .local pmc match
    .lex "$/", match
    length rx507_eos, rx507_tgt
    gt rx507_pos, rx507_eos, rx507_done
    set rx507_off, 0
    lt rx507_pos, 2, rx507_start
    sub rx507_off, rx507_pos, 1
    substr rx507_tgt, rx507_tgt, rx507_off
  rx507_start:
    eq $I10, 1, rx507_restart
    if_null rx507_debug, debug_635
    rx507_cur."!cursor_debug"("START", "colonpair")
  debug_635:
    $I10 = self.'from'()
    ne $I10, -1, rxscan513_done
    goto rxscan513_scan
  rxscan513_loop:
    ($P10) = rx507_cur."from"()
    inc $P10
    set rx507_pos, $P10
    ge rx507_pos, rx507_eos, rxscan513_done
  rxscan513_scan:
    set_addr $I10, rxscan513_loop
    rx507_cur."!mark_push"(0, rx507_pos, $I10)
  rxscan513_done:
.annotate 'line', 260
  # rx literal  ":"
    add $I11, rx507_pos, 1
    gt $I11, rx507_eos, rx507_fail
    sub $I11, rx507_pos, rx507_off
    ord $I11, rx507_tgt, $I11
    ne $I11, 58, rx507_fail
    add rx507_pos, 1
  alt514_0:
.annotate 'line', 261
    set_addr $I10, alt514_1
    rx507_cur."!mark_push"(0, rx507_pos, $I10)
.annotate 'line', 262
  # rx subcapture "not"
    set_addr $I10, rxcap_515_fail
    rx507_cur."!mark_push"(0, rx507_pos, $I10)
  # rx literal  "!"
    add $I11, rx507_pos, 1
    gt $I11, rx507_eos, rx507_fail
    sub $I11, rx507_pos, rx507_off
    ord $I11, rx507_tgt, $I11
    ne $I11, 33, rx507_fail
    add rx507_pos, 1
    set_addr $I10, rxcap_515_fail
    ($I12, $I11) = rx507_cur."!mark_peek"($I10)
    rx507_cur."!cursor_pos"($I11)
    ($P10) = rx507_cur."!cursor_start"()
    $P10."!cursor_pass"(rx507_pos, "")
    rx507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_515_done
  rxcap_515_fail:
    goto rx507_fail
  rxcap_515_done:
  # rx subrule "identifier" subtype=capture negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."identifier"()
    unless $P10, rx507_fail
    rx507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx507_pos = $P10."pos"()
    goto alt514_end
  alt514_1:
    set_addr $I10, alt514_2
    rx507_cur."!mark_push"(0, rx507_pos, $I10)
.annotate 'line', 263
  # rx subrule "identifier" subtype=capture negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."identifier"()
    unless $P10, rx507_fail
    rx507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx507_pos = $P10."pos"()
  # rx rxquantr516 ** 0..1
    set_addr $I10, rxquantr516_done
    rx507_cur."!mark_push"(0, rx507_pos, $I10)
  rxquantr516_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."circumfix"()
    unless $P10, rx507_fail
    goto rxsubrule517_pass
  rxsubrule517_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx507_fail
  rxsubrule517_pass:
    set_addr $I10, rxsubrule517_back
    rx507_cur."!mark_push"(0, rx507_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx507_pos = $P10."pos"()
    set_addr $I10, rxquantr516_done
    (rx507_rep) = rx507_cur."!mark_commit"($I10)
  rxquantr516_done:
    goto alt514_end
  alt514_2:
.annotate 'line', 264
  # rx subrule "circumfix" subtype=capture negate=
    rx507_cur."!cursor_pos"(rx507_pos)
    $P10 = rx507_cur."circumfix"()
    unless $P10, rx507_fail
    rx507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx507_pos = $P10."pos"()
  alt514_end:
.annotate 'line', 259
  # rx pass
    rx507_cur."!cursor_pass"(rx507_pos, "colonpair")
    if_null rx507_debug, debug_636
    rx507_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx507_pos)
  debug_636:
    .return (rx507_cur)
  rx507_restart:
.annotate 'line', 4
    if_null rx507_debug, debug_637
    rx507_cur."!cursor_debug"("NEXT", "colonpair")
  debug_637:
  rx507_fail:
    (rx507_rep, rx507_pos, $I10, $P10) = rx507_cur."!mark_fail"(0)
    lt rx507_pos, -1, rx507_done
    eq rx507_pos, -1, rx507_fail
    jump $I10
  rx507_done:
    rx507_cur."!cursor_fail"()
    if_null rx507_debug, debug_638
    rx507_cur."!cursor_debug"("FAIL", "colonpair")
  debug_638:
    .return (rx507_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("124_1295307698.031") :method
.annotate 'line', 4
    $P509 = self."!PREFIX__!subrule"("circumfix", ":")
    $P510 = self."!PREFIX__!subrule"("identifier", ":")
    $P511 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P512, "ResizablePMCArray"
    push $P512, $P509
    push $P512, $P510
    push $P512, $P511
    .return ($P512)
.end


.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("125_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx519_tgt
    .local int rx519_pos
    .local int rx519_off
    .local int rx519_eos
    .local int rx519_rep
    .local pmc rx519_cur
    .local pmc rx519_debug
    (rx519_cur, rx519_pos, rx519_tgt, $I10) = self."!cursor_start"()
    rx519_cur."!cursor_caparray"("twigil")
    getattribute rx519_debug, rx519_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx519_cur
    .local pmc match
    .lex "$/", match
    length rx519_eos, rx519_tgt
    gt rx519_pos, rx519_eos, rx519_done
    set rx519_off, 0
    lt rx519_pos, 2, rx519_start
    sub rx519_off, rx519_pos, 1
    substr rx519_tgt, rx519_tgt, rx519_off
  rx519_start:
    eq $I10, 1, rx519_restart
    if_null rx519_debug, debug_639
    rx519_cur."!cursor_debug"("START", "variable")
  debug_639:
    $I10 = self.'from'()
    ne $I10, -1, rxscan524_done
    goto rxscan524_scan
  rxscan524_loop:
    ($P10) = rx519_cur."from"()
    inc $P10
    set rx519_pos, $P10
    ge rx519_pos, rx519_eos, rxscan524_done
  rxscan524_scan:
    set_addr $I10, rxscan524_loop
    rx519_cur."!mark_push"(0, rx519_pos, $I10)
  rxscan524_done:
  alt525_0:
.annotate 'line', 268
    set_addr $I10, alt525_1
    rx519_cur."!mark_push"(0, rx519_pos, $I10)
.annotate 'line', 269
  # rx subrule "sigil" subtype=capture negate=
    rx519_cur."!cursor_pos"(rx519_pos)
    $P10 = rx519_cur."sigil"()
    unless $P10, rx519_fail
    rx519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx519_pos = $P10."pos"()
  # rx rxquantr526 ** 0..1
    set_addr $I10, rxquantr526_done
    rx519_cur."!mark_push"(0, rx519_pos, $I10)
  rxquantr526_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx519_cur."!cursor_pos"(rx519_pos)
    $P10 = rx519_cur."twigil"()
    unless $P10, rx519_fail
    goto rxsubrule527_pass
  rxsubrule527_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx519_fail
  rxsubrule527_pass:
    set_addr $I10, rxsubrule527_back
    rx519_cur."!mark_push"(0, rx519_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx519_pos = $P10."pos"()
    set_addr $I10, rxquantr526_done
    (rx519_rep) = rx519_cur."!mark_commit"($I10)
  rxquantr526_done:
  # rx subrule "name" subtype=capture negate=
    rx519_cur."!cursor_pos"(rx519_pos)
    $P10 = rx519_cur."name"()
    unless $P10, rx519_fail
    rx519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx519_pos = $P10."pos"()
    goto alt525_end
  alt525_1:
    set_addr $I10, alt525_2
    rx519_cur."!mark_push"(0, rx519_pos, $I10)
.annotate 'line', 270
  # rx subrule "sigil" subtype=capture negate=
    rx519_cur."!cursor_pos"(rx519_pos)
    $P10 = rx519_cur."sigil"()
    unless $P10, rx519_fail
    rx519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx519_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx519_pos, rx519_off
    substr $S10, rx519_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx519_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx519_cur."!cursor_pos"(rx519_pos)
    $P10 = rx519_cur."postcircumfix"()
    unless $P10, rx519_fail
    rx519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx519_pos = $P10."pos"()
    goto alt525_end
  alt525_2:
.annotate 'line', 271
  # rx subcapture "sigil"
    set_addr $I10, rxcap_528_fail
    rx519_cur."!mark_push"(0, rx519_pos, $I10)
  # rx literal  "$"
    add $I11, rx519_pos, 1
    gt $I11, rx519_eos, rx519_fail
    sub $I11, rx519_pos, rx519_off
    ord $I11, rx519_tgt, $I11
    ne $I11, 36, rx519_fail
    add rx519_pos, 1
    set_addr $I10, rxcap_528_fail
    ($I12, $I11) = rx519_cur."!mark_peek"($I10)
    rx519_cur."!cursor_pos"($I11)
    ($P10) = rx519_cur."!cursor_start"()
    $P10."!cursor_pass"(rx519_pos, "")
    rx519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_528_done
  rxcap_528_fail:
    goto rx519_fail
  rxcap_528_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_529_fail
    rx519_cur."!mark_push"(0, rx519_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx519_pos, rx519_eos, rx519_fail
    sub $I10, rx519_pos, rx519_off
    substr $S10, rx519_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx519_fail
    inc rx519_pos
    set_addr $I10, rxcap_529_fail
    ($I12, $I11) = rx519_cur."!mark_peek"($I10)
    rx519_cur."!cursor_pos"($I11)
    ($P10) = rx519_cur."!cursor_start"()
    $P10."!cursor_pass"(rx519_pos, "")
    rx519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_529_done
  rxcap_529_fail:
    goto rx519_fail
  rxcap_529_done:
  alt525_end:
.annotate 'line', 268
  # rx pass
    rx519_cur."!cursor_pass"(rx519_pos, "variable")
    if_null rx519_debug, debug_640
    rx519_cur."!cursor_debug"("PASS", "variable", " at pos=", rx519_pos)
  debug_640:
    .return (rx519_cur)
  rx519_restart:
.annotate 'line', 4
    if_null rx519_debug, debug_641
    rx519_cur."!cursor_debug"("NEXT", "variable")
  debug_641:
  rx519_fail:
    (rx519_rep, rx519_pos, $I10, $P10) = rx519_cur."!mark_fail"(0)
    lt rx519_pos, -1, rx519_done
    eq rx519_pos, -1, rx519_fail
    jump $I10
  rx519_done:
    rx519_cur."!cursor_fail"()
    if_null rx519_debug, debug_642
    rx519_cur."!cursor_debug"("FAIL", "variable")
  debug_642:
    .return (rx519_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("126_1295307698.031") :method
.annotate 'line', 4
    $P521 = self."!PREFIX__!subrule"("sigil", "")
    $P522 = self."!PREFIX__!subrule"("sigil", "")
    new $P523, "ResizablePMCArray"
    push $P523, "$!"
    push $P523, "$_"
    push $P523, "$/"
    push $P523, $P521
    push $P523, $P522
    .return ($P523)
.end


.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("127_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx531_tgt
    .local int rx531_pos
    .local int rx531_off
    .local int rx531_eos
    .local int rx531_rep
    .local pmc rx531_cur
    .local pmc rx531_debug
    (rx531_cur, rx531_pos, rx531_tgt, $I10) = self."!cursor_start"()
    getattribute rx531_debug, rx531_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx531_cur
    .local pmc match
    .lex "$/", match
    length rx531_eos, rx531_tgt
    gt rx531_pos, rx531_eos, rx531_done
    set rx531_off, 0
    lt rx531_pos, 2, rx531_start
    sub rx531_off, rx531_pos, 1
    substr rx531_tgt, rx531_tgt, rx531_off
  rx531_start:
    eq $I10, 1, rx531_restart
    if_null rx531_debug, debug_643
    rx531_cur."!cursor_debug"("START", "sigil")
  debug_643:
    $I10 = self.'from'()
    ne $I10, -1, rxscan534_done
    goto rxscan534_scan
  rxscan534_loop:
    ($P10) = rx531_cur."from"()
    inc $P10
    set rx531_pos, $P10
    ge rx531_pos, rx531_eos, rxscan534_done
  rxscan534_scan:
    set_addr $I10, rxscan534_loop
    rx531_cur."!mark_push"(0, rx531_pos, $I10)
  rxscan534_done:
.annotate 'line', 274
  # rx enumcharlist negate=0 
    ge rx531_pos, rx531_eos, rx531_fail
    sub $I10, rx531_pos, rx531_off
    substr $S10, rx531_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx531_fail
    inc rx531_pos
  # rx pass
    rx531_cur."!cursor_pass"(rx531_pos, "sigil")
    if_null rx531_debug, debug_644
    rx531_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx531_pos)
  debug_644:
    .return (rx531_cur)
  rx531_restart:
.annotate 'line', 4
    if_null rx531_debug, debug_645
    rx531_cur."!cursor_debug"("NEXT", "sigil")
  debug_645:
  rx531_fail:
    (rx531_rep, rx531_pos, $I10, $P10) = rx531_cur."!mark_fail"(0)
    lt rx531_pos, -1, rx531_done
    eq rx531_pos, -1, rx531_fail
    jump $I10
  rx531_done:
    rx531_cur."!cursor_fail"()
    if_null rx531_debug, debug_646
    rx531_cur."!cursor_debug"("FAIL", "sigil")
  debug_646:
    .return (rx531_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("128_1295307698.031") :method
.annotate 'line', 4
    new $P533, "ResizablePMCArray"
    push $P533, "&"
    push $P533, "%"
    push $P533, "@"
    push $P533, "$"
    .return ($P533)
.end


.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("129_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx536_tgt
    .local int rx536_pos
    .local int rx536_off
    .local int rx536_eos
    .local int rx536_rep
    .local pmc rx536_cur
    .local pmc rx536_debug
    (rx536_cur, rx536_pos, rx536_tgt, $I10) = self."!cursor_start"()
    getattribute rx536_debug, rx536_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx536_cur
    .local pmc match
    .lex "$/", match
    length rx536_eos, rx536_tgt
    gt rx536_pos, rx536_eos, rx536_done
    set rx536_off, 0
    lt rx536_pos, 2, rx536_start
    sub rx536_off, rx536_pos, 1
    substr rx536_tgt, rx536_tgt, rx536_off
  rx536_start:
    eq $I10, 1, rx536_restart
    if_null rx536_debug, debug_647
    rx536_cur."!cursor_debug"("START", "twigil")
  debug_647:
    $I10 = self.'from'()
    ne $I10, -1, rxscan539_done
    goto rxscan539_scan
  rxscan539_loop:
    ($P10) = rx536_cur."from"()
    inc $P10
    set rx536_pos, $P10
    ge rx536_pos, rx536_eos, rxscan539_done
  rxscan539_scan:
    set_addr $I10, rxscan539_loop
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  rxscan539_done:
.annotate 'line', 276
  # rx enumcharlist negate=0 
    ge rx536_pos, rx536_eos, rx536_fail
    sub $I10, rx536_pos, rx536_off
    substr $S10, rx536_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx536_fail
    inc rx536_pos
  # rx pass
    rx536_cur."!cursor_pass"(rx536_pos, "twigil")
    if_null rx536_debug, debug_648
    rx536_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx536_pos)
  debug_648:
    .return (rx536_cur)
  rx536_restart:
.annotate 'line', 4
    if_null rx536_debug, debug_649
    rx536_cur."!cursor_debug"("NEXT", "twigil")
  debug_649:
  rx536_fail:
    (rx536_rep, rx536_pos, $I10, $P10) = rx536_cur."!mark_fail"(0)
    lt rx536_pos, -1, rx536_done
    eq rx536_pos, -1, rx536_fail
    jump $I10
  rx536_done:
    rx536_cur."!cursor_fail"()
    if_null rx536_debug, debug_650
    rx536_cur."!cursor_debug"("FAIL", "twigil")
  debug_650:
    .return (rx536_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("130_1295307698.031") :method
.annotate 'line', 4
    new $P538, "ResizablePMCArray"
    push $P538, "?"
    push $P538, "!"
    push $P538, "*"
    .return ($P538)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("131_1295307698.031") :method
.annotate 'line', 278
    $P541 = self."!protoregex"("package_declarator")
    .return ($P541)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("132_1295307698.031") :method
.annotate 'line', 278
    $P543 = self."!PREFIX__!protoregex"("package_declarator")
    .return ($P543)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("133_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx545_tgt
    .local int rx545_pos
    .local int rx545_off
    .local int rx545_eos
    .local int rx545_rep
    .local pmc rx545_cur
    .local pmc rx545_debug
    (rx545_cur, rx545_pos, rx545_tgt, $I10) = self."!cursor_start"()
    getattribute rx545_debug, rx545_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx545_cur
    .local pmc match
    .lex "$/", match
    length rx545_eos, rx545_tgt
    gt rx545_pos, rx545_eos, rx545_done
    set rx545_off, 0
    lt rx545_pos, 2, rx545_start
    sub rx545_off, rx545_pos, 1
    substr rx545_tgt, rx545_tgt, rx545_off
  rx545_start:
    eq $I10, 1, rx545_restart
    if_null rx545_debug, debug_651
    rx545_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_651:
    $I10 = self.'from'()
    ne $I10, -1, rxscan549_done
    goto rxscan549_scan
  rxscan549_loop:
    ($P10) = rx545_cur."from"()
    inc $P10
    set rx545_pos, $P10
    ge rx545_pos, rx545_eos, rxscan549_done
  rxscan549_scan:
    set_addr $I10, rxscan549_loop
    rx545_cur."!mark_push"(0, rx545_pos, $I10)
  rxscan549_done:
.annotate 'line', 279
  # rx subcapture "sym"
    set_addr $I10, rxcap_550_fail
    rx545_cur."!mark_push"(0, rx545_pos, $I10)
  # rx literal  "module"
    add $I11, rx545_pos, 6
    gt $I11, rx545_eos, rx545_fail
    sub $I11, rx545_pos, rx545_off
    substr $S10, rx545_tgt, $I11, 6
    ne $S10, "module", rx545_fail
    add rx545_pos, 6
    set_addr $I10, rxcap_550_fail
    ($I12, $I11) = rx545_cur."!mark_peek"($I10)
    rx545_cur."!cursor_pos"($I11)
    ($P10) = rx545_cur."!cursor_start"()
    $P10."!cursor_pass"(rx545_pos, "")
    rx545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_550_done
  rxcap_550_fail:
    goto rx545_fail
  rxcap_550_done:
  # rx subrule "package_def" subtype=capture negate=
    rx545_cur."!cursor_pos"(rx545_pos)
    $P10 = rx545_cur."package_def"()
    unless $P10, rx545_fail
    rx545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx545_pos = $P10."pos"()
  # rx pass
    rx545_cur."!cursor_pass"(rx545_pos, "package_declarator:sym<module>")
    if_null rx545_debug, debug_652
    rx545_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx545_pos)
  debug_652:
    .return (rx545_cur)
  rx545_restart:
.annotate 'line', 4
    if_null rx545_debug, debug_653
    rx545_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_653:
  rx545_fail:
    (rx545_rep, rx545_pos, $I10, $P10) = rx545_cur."!mark_fail"(0)
    lt rx545_pos, -1, rx545_done
    eq rx545_pos, -1, rx545_fail
    jump $I10
  rx545_done:
    rx545_cur."!cursor_fail"()
    if_null rx545_debug, debug_654
    rx545_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_654:
    .return (rx545_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("134_1295307698.031") :method
.annotate 'line', 4
    $P547 = self."!PREFIX__!subrule"("package_def", "module")
    new $P548, "ResizablePMCArray"
    push $P548, $P547
    .return ($P548)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("135_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 281
    new $P552, "Undef"
    .lex "$*PACKAGE-SETUP", $P552
.annotate 'line', 282
    new $P553, "Undef"
    .lex "$*PKGDECL", $P553
.annotate 'line', 4
    .local string rx554_tgt
    .local int rx554_pos
    .local int rx554_off
    .local int rx554_eos
    .local int rx554_rep
    .local pmc rx554_cur
    .local pmc rx554_debug
    (rx554_cur, rx554_pos, rx554_tgt, $I10) = self."!cursor_start"()
    getattribute rx554_debug, rx554_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx554_cur
    .local pmc match
    .lex "$/", match
    length rx554_eos, rx554_tgt
    gt rx554_pos, rx554_eos, rx554_done
    set rx554_off, 0
    lt rx554_pos, 2, rx554_start
    sub rx554_off, rx554_pos, 1
    substr rx554_tgt, rx554_tgt, rx554_off
  rx554_start:
    eq $I10, 1, rx554_restart
    if_null rx554_debug, debug_655
    rx554_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_655:
    $I10 = self.'from'()
    ne $I10, -1, rxscan558_done
    goto rxscan558_scan
  rxscan558_loop:
    ($P10) = rx554_cur."from"()
    inc $P10
    set rx554_pos, $P10
    ge rx554_pos, rx554_eos, rxscan558_done
  rxscan558_scan:
    set_addr $I10, rxscan558_loop
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  rxscan558_done:
.annotate 'line', 281
    rx554_cur."!cursor_pos"(rx554_pos)
    get_hll_global $P559, ["PAST"], "Stmts"
    $P560 = $P559."new"()
    store_lex "$*PACKAGE-SETUP", $P560
.annotate 'line', 282
    rx554_cur."!cursor_pos"(rx554_pos)
    new $P561, "String"
    assign $P561, "knowhow"
    store_lex "$*PKGDECL", $P561
.annotate 'line', 283
  # rx subcapture "sym"
    set_addr $I10, rxcap_562_fail
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx554_pos, 7
    gt $I11, rx554_eos, rx554_fail
    sub $I11, rx554_pos, rx554_off
    substr $S10, rx554_tgt, $I11, 7
    ne $S10, "knowhow", rx554_fail
    add rx554_pos, 7
    set_addr $I10, rxcap_562_fail
    ($I12, $I11) = rx554_cur."!mark_peek"($I10)
    rx554_cur."!cursor_pos"($I11)
    ($P10) = rx554_cur."!cursor_start"()
    $P10."!cursor_pass"(rx554_pos, "")
    rx554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_562_done
  rxcap_562_fail:
    goto rx554_fail
  rxcap_562_done:
  # rx subrule "package_def" subtype=capture negate=
    rx554_cur."!cursor_pos"(rx554_pos)
    $P10 = rx554_cur."package_def"()
    unless $P10, rx554_fail
    rx554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx554_pos = $P10."pos"()
.annotate 'line', 280
  # rx pass
    rx554_cur."!cursor_pass"(rx554_pos, "package_declarator:sym<knowhow>")
    if_null rx554_debug, debug_656
    rx554_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx554_pos)
  debug_656:
    .return (rx554_cur)
  rx554_restart:
.annotate 'line', 4
    if_null rx554_debug, debug_657
    rx554_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_657:
  rx554_fail:
    (rx554_rep, rx554_pos, $I10, $P10) = rx554_cur."!mark_fail"(0)
    lt rx554_pos, -1, rx554_done
    eq rx554_pos, -1, rx554_fail
    jump $I10
  rx554_done:
    rx554_cur."!cursor_fail"()
    if_null rx554_debug, debug_658
    rx554_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_658:
    .return (rx554_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("136_1295307698.031") :method
.annotate 'line', 4
    $P556 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P557, "ResizablePMCArray"
    push $P557, $P556
    .return ($P557)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("137_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 286
    new $P564, "Undef"
    .lex "$*PACKAGE-SETUP", $P564
.annotate 'line', 287
    new $P565, "Undef"
    .lex "$*PKGDECL", $P565
.annotate 'line', 4
    .local string rx566_tgt
    .local int rx566_pos
    .local int rx566_off
    .local int rx566_eos
    .local int rx566_rep
    .local pmc rx566_cur
    .local pmc rx566_debug
    (rx566_cur, rx566_pos, rx566_tgt, $I10) = self."!cursor_start"()
    getattribute rx566_debug, rx566_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx566_cur
    .local pmc match
    .lex "$/", match
    length rx566_eos, rx566_tgt
    gt rx566_pos, rx566_eos, rx566_done
    set rx566_off, 0
    lt rx566_pos, 2, rx566_start
    sub rx566_off, rx566_pos, 1
    substr rx566_tgt, rx566_tgt, rx566_off
  rx566_start:
    eq $I10, 1, rx566_restart
    if_null rx566_debug, debug_659
    rx566_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_659:
    $I10 = self.'from'()
    ne $I10, -1, rxscan570_done
    goto rxscan570_scan
  rxscan570_loop:
    ($P10) = rx566_cur."from"()
    inc $P10
    set rx566_pos, $P10
    ge rx566_pos, rx566_eos, rxscan570_done
  rxscan570_scan:
    set_addr $I10, rxscan570_loop
    rx566_cur."!mark_push"(0, rx566_pos, $I10)
  rxscan570_done:
.annotate 'line', 286
    rx566_cur."!cursor_pos"(rx566_pos)
    get_hll_global $P571, ["PAST"], "Stmts"
    $P572 = $P571."new"()
    store_lex "$*PACKAGE-SETUP", $P572
.annotate 'line', 287
    rx566_cur."!cursor_pos"(rx566_pos)
    new $P573, "String"
    assign $P573, "class"
    store_lex "$*PKGDECL", $P573
.annotate 'line', 288
  # rx subcapture "sym"
    set_addr $I10, rxcap_574_fail
    rx566_cur."!mark_push"(0, rx566_pos, $I10)
  # rx literal  "class"
    add $I11, rx566_pos, 5
    gt $I11, rx566_eos, rx566_fail
    sub $I11, rx566_pos, rx566_off
    substr $S10, rx566_tgt, $I11, 5
    ne $S10, "class", rx566_fail
    add rx566_pos, 5
    set_addr $I10, rxcap_574_fail
    ($I12, $I11) = rx566_cur."!mark_peek"($I10)
    rx566_cur."!cursor_pos"($I11)
    ($P10) = rx566_cur."!cursor_start"()
    $P10."!cursor_pass"(rx566_pos, "")
    rx566_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_574_done
  rxcap_574_fail:
    goto rx566_fail
  rxcap_574_done:
  # rx subrule "package_def" subtype=capture negate=
    rx566_cur."!cursor_pos"(rx566_pos)
    $P10 = rx566_cur."package_def"()
    unless $P10, rx566_fail
    rx566_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx566_pos = $P10."pos"()
.annotate 'line', 285
  # rx pass
    rx566_cur."!cursor_pass"(rx566_pos, "package_declarator:sym<class>")
    if_null rx566_debug, debug_660
    rx566_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx566_pos)
  debug_660:
    .return (rx566_cur)
  rx566_restart:
.annotate 'line', 4
    if_null rx566_debug, debug_661
    rx566_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_661:
  rx566_fail:
    (rx566_rep, rx566_pos, $I10, $P10) = rx566_cur."!mark_fail"(0)
    lt rx566_pos, -1, rx566_done
    eq rx566_pos, -1, rx566_fail
    jump $I10
  rx566_done:
    rx566_cur."!cursor_fail"()
    if_null rx566_debug, debug_662
    rx566_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_662:
    .return (rx566_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("138_1295307698.031") :method
.annotate 'line', 4
    $P568 = self."!PREFIX__!subrule"("package_def", "class")
    new $P569, "ResizablePMCArray"
    push $P569, $P568
    .return ($P569)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("139_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 291
    new $P576, "Undef"
    .lex "$*PKGDECL", $P576
.annotate 'line', 4
    .local string rx577_tgt
    .local int rx577_pos
    .local int rx577_off
    .local int rx577_eos
    .local int rx577_rep
    .local pmc rx577_cur
    .local pmc rx577_debug
    (rx577_cur, rx577_pos, rx577_tgt, $I10) = self."!cursor_start"()
    getattribute rx577_debug, rx577_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx577_cur
    .local pmc match
    .lex "$/", match
    length rx577_eos, rx577_tgt
    gt rx577_pos, rx577_eos, rx577_done
    set rx577_off, 0
    lt rx577_pos, 2, rx577_start
    sub rx577_off, rx577_pos, 1
    substr rx577_tgt, rx577_tgt, rx577_off
  rx577_start:
    eq $I10, 1, rx577_restart
    if_null rx577_debug, debug_663
    rx577_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_663:
    $I10 = self.'from'()
    ne $I10, -1, rxscan581_done
    goto rxscan581_scan
  rxscan581_loop:
    ($P10) = rx577_cur."from"()
    inc $P10
    set rx577_pos, $P10
    ge rx577_pos, rx577_eos, rxscan581_done
  rxscan581_scan:
    set_addr $I10, rxscan581_loop
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  rxscan581_done:
.annotate 'line', 291
    rx577_cur."!cursor_pos"(rx577_pos)
    new $P582, "String"
    assign $P582, "grammar"
    store_lex "$*PKGDECL", $P582
.annotate 'line', 292
  # rx subcapture "sym"
    set_addr $I10, rxcap_583_fail
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx577_pos, 7
    gt $I11, rx577_eos, rx577_fail
    sub $I11, rx577_pos, rx577_off
    substr $S10, rx577_tgt, $I11, 7
    ne $S10, "grammar", rx577_fail
    add rx577_pos, 7
    set_addr $I10, rxcap_583_fail
    ($I12, $I11) = rx577_cur."!mark_peek"($I10)
    rx577_cur."!cursor_pos"($I11)
    ($P10) = rx577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx577_pos, "")
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_583_done
  rxcap_583_fail:
    goto rx577_fail
  rxcap_583_done:
  # rx subrule "package_def" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."package_def"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx577_pos = $P10."pos"()
.annotate 'line', 290
  # rx pass
    rx577_cur."!cursor_pass"(rx577_pos, "package_declarator:sym<grammar>")
    if_null rx577_debug, debug_664
    rx577_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx577_pos)
  debug_664:
    .return (rx577_cur)
  rx577_restart:
.annotate 'line', 4
    if_null rx577_debug, debug_665
    rx577_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_665:
  rx577_fail:
    (rx577_rep, rx577_pos, $I10, $P10) = rx577_cur."!mark_fail"(0)
    lt rx577_pos, -1, rx577_done
    eq rx577_pos, -1, rx577_fail
    jump $I10
  rx577_done:
    rx577_cur."!cursor_fail"()
    if_null rx577_debug, debug_666
    rx577_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_666:
    .return (rx577_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("140_1295307698.031") :method
.annotate 'line', 4
    $P579 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P580, "ResizablePMCArray"
    push $P580, $P579
    .return ($P580)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("141_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 295
    new $P585, "Undef"
    .lex "$*PACKAGE-SETUP", $P585
.annotate 'line', 296
    new $P586, "Undef"
    .lex "$*PKGDECL", $P586
.annotate 'line', 4
    .local string rx587_tgt
    .local int rx587_pos
    .local int rx587_off
    .local int rx587_eos
    .local int rx587_rep
    .local pmc rx587_cur
    .local pmc rx587_debug
    (rx587_cur, rx587_pos, rx587_tgt, $I10) = self."!cursor_start"()
    getattribute rx587_debug, rx587_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx587_cur
    .local pmc match
    .lex "$/", match
    length rx587_eos, rx587_tgt
    gt rx587_pos, rx587_eos, rx587_done
    set rx587_off, 0
    lt rx587_pos, 2, rx587_start
    sub rx587_off, rx587_pos, 1
    substr rx587_tgt, rx587_tgt, rx587_off
  rx587_start:
    eq $I10, 1, rx587_restart
    if_null rx587_debug, debug_667
    rx587_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_667:
    $I10 = self.'from'()
    ne $I10, -1, rxscan591_done
    goto rxscan591_scan
  rxscan591_loop:
    ($P10) = rx587_cur."from"()
    inc $P10
    set rx587_pos, $P10
    ge rx587_pos, rx587_eos, rxscan591_done
  rxscan591_scan:
    set_addr $I10, rxscan591_loop
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  rxscan591_done:
.annotate 'line', 295
    rx587_cur."!cursor_pos"(rx587_pos)
    get_hll_global $P592, ["PAST"], "Stmts"
    $P593 = $P592."new"()
    store_lex "$*PACKAGE-SETUP", $P593
.annotate 'line', 296
    rx587_cur."!cursor_pos"(rx587_pos)
    new $P594, "String"
    assign $P594, "role"
    store_lex "$*PKGDECL", $P594
.annotate 'line', 297
  # rx subcapture "sym"
    set_addr $I10, rxcap_595_fail
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  # rx literal  "role"
    add $I11, rx587_pos, 4
    gt $I11, rx587_eos, rx587_fail
    sub $I11, rx587_pos, rx587_off
    substr $S10, rx587_tgt, $I11, 4
    ne $S10, "role", rx587_fail
    add rx587_pos, 4
    set_addr $I10, rxcap_595_fail
    ($I12, $I11) = rx587_cur."!mark_peek"($I10)
    rx587_cur."!cursor_pos"($I11)
    ($P10) = rx587_cur."!cursor_start"()
    $P10."!cursor_pass"(rx587_pos, "")
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_595_done
  rxcap_595_fail:
    goto rx587_fail
  rxcap_595_done:
  # rx subrule "package_def" subtype=capture negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."package_def"()
    unless $P10, rx587_fail
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx587_pos = $P10."pos"()
.annotate 'line', 294
  # rx pass
    rx587_cur."!cursor_pass"(rx587_pos, "package_declarator:sym<role>")
    if_null rx587_debug, debug_668
    rx587_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx587_pos)
  debug_668:
    .return (rx587_cur)
  rx587_restart:
.annotate 'line', 4
    if_null rx587_debug, debug_669
    rx587_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_669:
  rx587_fail:
    (rx587_rep, rx587_pos, $I10, $P10) = rx587_cur."!mark_fail"(0)
    lt rx587_pos, -1, rx587_done
    eq rx587_pos, -1, rx587_fail
    jump $I10
  rx587_done:
    rx587_cur."!cursor_fail"()
    if_null rx587_debug, debug_670
    rx587_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_670:
    .return (rx587_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("142_1295307698.031") :method
.annotate 'line', 4
    $P589 = self."!PREFIX__!subrule"("package_def", "role")
    new $P590, "ResizablePMCArray"
    push $P590, $P589
    .return ($P590)
.end


.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("143_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx597_tgt
    .local int rx597_pos
    .local int rx597_off
    .local int rx597_eos
    .local int rx597_rep
    .local pmc rx597_cur
    .local pmc rx597_debug
    (rx597_cur, rx597_pos, rx597_tgt, $I10) = self."!cursor_start"()
    rx597_cur."!cursor_caparray"("repr", "parent")
    getattribute rx597_debug, rx597_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx597_cur
    .local pmc match
    .lex "$/", match
    length rx597_eos, rx597_tgt
    gt rx597_pos, rx597_eos, rx597_done
    set rx597_off, 0
    lt rx597_pos, 2, rx597_start
    sub rx597_off, rx597_pos, 1
    substr rx597_tgt, rx597_tgt, rx597_off
  rx597_start:
    eq $I10, 1, rx597_restart
    if_null rx597_debug, debug_671
    rx597_cur."!cursor_debug"("START", "package_def")
  debug_671:
    $I10 = self.'from'()
    ne $I10, -1, rxscan601_done
    goto rxscan601_scan
  rxscan601_loop:
    ($P10) = rx597_cur."from"()
    inc $P10
    set rx597_pos, $P10
    ge rx597_pos, rx597_eos, rxscan601_done
  rxscan601_scan:
    set_addr $I10, rxscan601_loop
    rx597_cur."!mark_push"(0, rx597_pos, $I10)
  rxscan601_done:
.annotate 'line', 300
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
.annotate 'line', 301
  # rx subrule "name" subtype=capture negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."name"()
    unless $P10, rx597_fail
    rx597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx597_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
.annotate 'line', 302
  # rx rxquantr604 ** 0..1
    set_addr $I10, rxquantr604_done
    rx597_cur."!mark_push"(0, rx597_pos, $I10)
  rxquantr604_loop:
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx597_pos, 2
    gt $I11, rx597_eos, rx597_fail
    sub $I11, rx597_pos, rx597_off
    substr $S10, rx597_tgt, $I11, 2
    ne $S10, "is", rx597_fail
    add rx597_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx597_pos, 5
    gt $I11, rx597_eos, rx597_fail
    sub $I11, rx597_pos, rx597_off
    substr $S10, rx597_tgt, $I11, 5
    ne $S10, "repr(", rx597_fail
    add rx597_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."quote_EXPR"()
    unless $P10, rx597_fail
    rx597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx597_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx597_pos, 1
    gt $I11, rx597_eos, rx597_fail
    sub $I11, rx597_pos, rx597_off
    ord $I11, rx597_tgt, $I11
    ne $I11, 41, rx597_fail
    add rx597_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
    set_addr $I10, rxquantr604_done
    (rx597_rep) = rx597_cur."!mark_commit"($I10)
  rxquantr604_done:
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
.annotate 'line', 303
  # rx rxquantr611 ** 0..1
    set_addr $I10, rxquantr611_done
    rx597_cur."!mark_push"(0, rx597_pos, $I10)
  rxquantr611_loop:
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx597_pos, 2
    gt $I11, rx597_eos, rx597_fail
    sub $I11, rx597_pos, rx597_off
    substr $S10, rx597_tgt, $I11, 2
    ne $S10, "is", rx597_fail
    add rx597_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."name"()
    unless $P10, rx597_fail
    rx597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx597_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
    set_addr $I10, rxquantr611_done
    (rx597_rep) = rx597_cur."!mark_commit"($I10)
  rxquantr611_done:
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  alt616_0:
.annotate 'line', 304
    set_addr $I10, alt616_1
    rx597_cur."!mark_push"(0, rx597_pos, $I10)
.annotate 'line', 305
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx597_pos, 1
    gt $I11, rx597_eos, rx597_fail
    sub $I11, rx597_pos, rx597_off
    ord $I11, rx597_tgt, $I11
    ne $I11, 59, rx597_fail
    add rx597_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."comp_unit"()
    unless $P10, rx597_fail
    rx597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx597_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
    goto alt616_end
  alt616_1:
    set_addr $I10, alt616_2
    rx597_cur."!mark_push"(0, rx597_pos, $I10)
.annotate 'line', 306
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx597_pos, rx597_off
    substr $S10, rx597_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx597_fail
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."block"()
    unless $P10, rx597_fail
    rx597_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx597_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
    goto alt616_end
  alt616_2:
.annotate 'line', 307
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."panic"("Malformed package declaration")
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
  alt616_end:
.annotate 'line', 308
  # rx subrule "ws" subtype=method negate=
    rx597_cur."!cursor_pos"(rx597_pos)
    $P10 = rx597_cur."ws"()
    unless $P10, rx597_fail
    rx597_pos = $P10."pos"()
.annotate 'line', 300
  # rx pass
    rx597_cur."!cursor_pass"(rx597_pos, "package_def")
    if_null rx597_debug, debug_672
    rx597_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx597_pos)
  debug_672:
    .return (rx597_cur)
  rx597_restart:
.annotate 'line', 4
    if_null rx597_debug, debug_673
    rx597_cur."!cursor_debug"("NEXT", "package_def")
  debug_673:
  rx597_fail:
    (rx597_rep, rx597_pos, $I10, $P10) = rx597_cur."!mark_fail"(0)
    lt rx597_pos, -1, rx597_done
    eq rx597_pos, -1, rx597_fail
    jump $I10
  rx597_done:
    rx597_cur."!cursor_fail"()
    if_null rx597_debug, debug_674
    rx597_cur."!cursor_debug"("FAIL", "package_def")
  debug_674:
    .return (rx597_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("144_1295307698.031") :method
.annotate 'line', 4
    $P599 = self."!PREFIX__!subrule"("ws", "")
    new $P600, "ResizablePMCArray"
    push $P600, $P599
    .return ($P600)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("145_1295307698.031") :method
.annotate 'line', 311
    $P627 = self."!protoregex"("scope_declarator")
    .return ($P627)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("146_1295307698.031") :method
.annotate 'line', 311
    $P629 = self."!PREFIX__!protoregex"("scope_declarator")
    .return ($P629)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("147_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx631_tgt
    .local int rx631_pos
    .local int rx631_off
    .local int rx631_eos
    .local int rx631_rep
    .local pmc rx631_cur
    .local pmc rx631_debug
    (rx631_cur, rx631_pos, rx631_tgt, $I10) = self."!cursor_start"()
    getattribute rx631_debug, rx631_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx631_cur
    .local pmc match
    .lex "$/", match
    length rx631_eos, rx631_tgt
    gt rx631_pos, rx631_eos, rx631_done
    set rx631_off, 0
    lt rx631_pos, 2, rx631_start
    sub rx631_off, rx631_pos, 1
    substr rx631_tgt, rx631_tgt, rx631_off
  rx631_start:
    eq $I10, 1, rx631_restart
    if_null rx631_debug, debug_675
    rx631_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_675:
    $I10 = self.'from'()
    ne $I10, -1, rxscan635_done
    goto rxscan635_scan
  rxscan635_loop:
    ($P10) = rx631_cur."from"()
    inc $P10
    set rx631_pos, $P10
    ge rx631_pos, rx631_eos, rxscan635_done
  rxscan635_scan:
    set_addr $I10, rxscan635_loop
    rx631_cur."!mark_push"(0, rx631_pos, $I10)
  rxscan635_done:
.annotate 'line', 312
  # rx subcapture "sym"
    set_addr $I10, rxcap_636_fail
    rx631_cur."!mark_push"(0, rx631_pos, $I10)
  # rx literal  "my"
    add $I11, rx631_pos, 2
    gt $I11, rx631_eos, rx631_fail
    sub $I11, rx631_pos, rx631_off
    substr $S10, rx631_tgt, $I11, 2
    ne $S10, "my", rx631_fail
    add rx631_pos, 2
    set_addr $I10, rxcap_636_fail
    ($I12, $I11) = rx631_cur."!mark_peek"($I10)
    rx631_cur."!cursor_pos"($I11)
    ($P10) = rx631_cur."!cursor_start"()
    $P10."!cursor_pass"(rx631_pos, "")
    rx631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_636_done
  rxcap_636_fail:
    goto rx631_fail
  rxcap_636_done:
  # rx subrule "scoped" subtype=capture negate=
    rx631_cur."!cursor_pos"(rx631_pos)
    $P10 = rx631_cur."scoped"("my")
    unless $P10, rx631_fail
    rx631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx631_pos = $P10."pos"()
  # rx pass
    rx631_cur."!cursor_pass"(rx631_pos, "scope_declarator:sym<my>")
    if_null rx631_debug, debug_676
    rx631_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx631_pos)
  debug_676:
    .return (rx631_cur)
  rx631_restart:
.annotate 'line', 4
    if_null rx631_debug, debug_677
    rx631_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_677:
  rx631_fail:
    (rx631_rep, rx631_pos, $I10, $P10) = rx631_cur."!mark_fail"(0)
    lt rx631_pos, -1, rx631_done
    eq rx631_pos, -1, rx631_fail
    jump $I10
  rx631_done:
    rx631_cur."!cursor_fail"()
    if_null rx631_debug, debug_678
    rx631_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_678:
    .return (rx631_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("148_1295307698.031") :method
.annotate 'line', 4
    $P633 = self."!PREFIX__!subrule"("scoped", "my")
    new $P634, "ResizablePMCArray"
    push $P634, $P633
    .return ($P634)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("149_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx638_tgt
    .local int rx638_pos
    .local int rx638_off
    .local int rx638_eos
    .local int rx638_rep
    .local pmc rx638_cur
    .local pmc rx638_debug
    (rx638_cur, rx638_pos, rx638_tgt, $I10) = self."!cursor_start"()
    getattribute rx638_debug, rx638_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx638_cur
    .local pmc match
    .lex "$/", match
    length rx638_eos, rx638_tgt
    gt rx638_pos, rx638_eos, rx638_done
    set rx638_off, 0
    lt rx638_pos, 2, rx638_start
    sub rx638_off, rx638_pos, 1
    substr rx638_tgt, rx638_tgt, rx638_off
  rx638_start:
    eq $I10, 1, rx638_restart
    if_null rx638_debug, debug_679
    rx638_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_679:
    $I10 = self.'from'()
    ne $I10, -1, rxscan642_done
    goto rxscan642_scan
  rxscan642_loop:
    ($P10) = rx638_cur."from"()
    inc $P10
    set rx638_pos, $P10
    ge rx638_pos, rx638_eos, rxscan642_done
  rxscan642_scan:
    set_addr $I10, rxscan642_loop
    rx638_cur."!mark_push"(0, rx638_pos, $I10)
  rxscan642_done:
.annotate 'line', 313
  # rx subcapture "sym"
    set_addr $I10, rxcap_643_fail
    rx638_cur."!mark_push"(0, rx638_pos, $I10)
  # rx literal  "our"
    add $I11, rx638_pos, 3
    gt $I11, rx638_eos, rx638_fail
    sub $I11, rx638_pos, rx638_off
    substr $S10, rx638_tgt, $I11, 3
    ne $S10, "our", rx638_fail
    add rx638_pos, 3
    set_addr $I10, rxcap_643_fail
    ($I12, $I11) = rx638_cur."!mark_peek"($I10)
    rx638_cur."!cursor_pos"($I11)
    ($P10) = rx638_cur."!cursor_start"()
    $P10."!cursor_pass"(rx638_pos, "")
    rx638_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_643_done
  rxcap_643_fail:
    goto rx638_fail
  rxcap_643_done:
  # rx subrule "scoped" subtype=capture negate=
    rx638_cur."!cursor_pos"(rx638_pos)
    $P10 = rx638_cur."scoped"("our")
    unless $P10, rx638_fail
    rx638_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx638_pos = $P10."pos"()
  # rx pass
    rx638_cur."!cursor_pass"(rx638_pos, "scope_declarator:sym<our>")
    if_null rx638_debug, debug_680
    rx638_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx638_pos)
  debug_680:
    .return (rx638_cur)
  rx638_restart:
.annotate 'line', 4
    if_null rx638_debug, debug_681
    rx638_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_681:
  rx638_fail:
    (rx638_rep, rx638_pos, $I10, $P10) = rx638_cur."!mark_fail"(0)
    lt rx638_pos, -1, rx638_done
    eq rx638_pos, -1, rx638_fail
    jump $I10
  rx638_done:
    rx638_cur."!cursor_fail"()
    if_null rx638_debug, debug_682
    rx638_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_682:
    .return (rx638_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("150_1295307698.031") :method
.annotate 'line', 4
    $P640 = self."!PREFIX__!subrule"("scoped", "our")
    new $P641, "ResizablePMCArray"
    push $P641, $P640
    .return ($P641)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("151_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx645_tgt
    .local int rx645_pos
    .local int rx645_off
    .local int rx645_eos
    .local int rx645_rep
    .local pmc rx645_cur
    .local pmc rx645_debug
    (rx645_cur, rx645_pos, rx645_tgt, $I10) = self."!cursor_start"()
    getattribute rx645_debug, rx645_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx645_cur
    .local pmc match
    .lex "$/", match
    length rx645_eos, rx645_tgt
    gt rx645_pos, rx645_eos, rx645_done
    set rx645_off, 0
    lt rx645_pos, 2, rx645_start
    sub rx645_off, rx645_pos, 1
    substr rx645_tgt, rx645_tgt, rx645_off
  rx645_start:
    eq $I10, 1, rx645_restart
    if_null rx645_debug, debug_683
    rx645_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_683:
    $I10 = self.'from'()
    ne $I10, -1, rxscan649_done
    goto rxscan649_scan
  rxscan649_loop:
    ($P10) = rx645_cur."from"()
    inc $P10
    set rx645_pos, $P10
    ge rx645_pos, rx645_eos, rxscan649_done
  rxscan649_scan:
    set_addr $I10, rxscan649_loop
    rx645_cur."!mark_push"(0, rx645_pos, $I10)
  rxscan649_done:
.annotate 'line', 314
  # rx subcapture "sym"
    set_addr $I10, rxcap_650_fail
    rx645_cur."!mark_push"(0, rx645_pos, $I10)
  # rx literal  "has"
    add $I11, rx645_pos, 3
    gt $I11, rx645_eos, rx645_fail
    sub $I11, rx645_pos, rx645_off
    substr $S10, rx645_tgt, $I11, 3
    ne $S10, "has", rx645_fail
    add rx645_pos, 3
    set_addr $I10, rxcap_650_fail
    ($I12, $I11) = rx645_cur."!mark_peek"($I10)
    rx645_cur."!cursor_pos"($I11)
    ($P10) = rx645_cur."!cursor_start"()
    $P10."!cursor_pass"(rx645_pos, "")
    rx645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_650_done
  rxcap_650_fail:
    goto rx645_fail
  rxcap_650_done:
  # rx subrule "scoped" subtype=capture negate=
    rx645_cur."!cursor_pos"(rx645_pos)
    $P10 = rx645_cur."scoped"("has")
    unless $P10, rx645_fail
    rx645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx645_pos = $P10."pos"()
  # rx pass
    rx645_cur."!cursor_pass"(rx645_pos, "scope_declarator:sym<has>")
    if_null rx645_debug, debug_684
    rx645_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx645_pos)
  debug_684:
    .return (rx645_cur)
  rx645_restart:
.annotate 'line', 4
    if_null rx645_debug, debug_685
    rx645_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_685:
  rx645_fail:
    (rx645_rep, rx645_pos, $I10, $P10) = rx645_cur."!mark_fail"(0)
    lt rx645_pos, -1, rx645_done
    eq rx645_pos, -1, rx645_fail
    jump $I10
  rx645_done:
    rx645_cur."!cursor_fail"()
    if_null rx645_debug, debug_686
    rx645_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_686:
    .return (rx645_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("152_1295307698.031") :method
.annotate 'line', 4
    $P647 = self."!PREFIX__!subrule"("scoped", "has")
    new $P648, "ResizablePMCArray"
    push $P648, $P647
    .return ($P648)
.end


.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("153_1295307698.031") :method :outer("11_1295307698.031")
    .param pmc param_652
.annotate 'line', 316
    .lex "$*SCOPE", param_652
.annotate 'line', 4
    .local string rx653_tgt
    .local int rx653_pos
    .local int rx653_off
    .local int rx653_eos
    .local int rx653_rep
    .local pmc rx653_cur
    .local pmc rx653_debug
    (rx653_cur, rx653_pos, rx653_tgt, $I10) = self."!cursor_start"()
    getattribute rx653_debug, rx653_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx653_cur
    .local pmc match
    .lex "$/", match
    length rx653_eos, rx653_tgt
    gt rx653_pos, rx653_eos, rx653_done
    set rx653_off, 0
    lt rx653_pos, 2, rx653_start
    sub rx653_off, rx653_pos, 1
    substr rx653_tgt, rx653_tgt, rx653_off
  rx653_start:
    eq $I10, 1, rx653_restart
    if_null rx653_debug, debug_687
    rx653_cur."!cursor_debug"("START", "scoped")
  debug_687:
    $I10 = self.'from'()
    ne $I10, -1, rxscan658_done
    goto rxscan658_scan
  rxscan658_loop:
    ($P10) = rx653_cur."from"()
    inc $P10
    set rx653_pos, $P10
    ge rx653_pos, rx653_eos, rxscan658_done
  rxscan658_scan:
    set_addr $I10, rxscan658_loop
    rx653_cur."!mark_push"(0, rx653_pos, $I10)
  rxscan658_done:
  alt659_0:
.annotate 'line', 316
    set_addr $I10, alt659_1
    rx653_cur."!mark_push"(0, rx653_pos, $I10)
.annotate 'line', 317
  # rx subrule "ws" subtype=method negate=
    rx653_cur."!cursor_pos"(rx653_pos)
    $P10 = rx653_cur."ws"()
    unless $P10, rx653_fail
    rx653_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx653_cur."!cursor_pos"(rx653_pos)
    $P10 = rx653_cur."declarator"()
    unless $P10, rx653_fail
    rx653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx653_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx653_cur."!cursor_pos"(rx653_pos)
    $P10 = rx653_cur."ws"()
    unless $P10, rx653_fail
    rx653_pos = $P10."pos"()
    goto alt659_end
  alt659_1:
.annotate 'line', 318
  # rx subrule "ws" subtype=method negate=
    rx653_cur."!cursor_pos"(rx653_pos)
    $P10 = rx653_cur."ws"()
    unless $P10, rx653_fail
    rx653_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx653_cur."!cursor_pos"(rx653_pos)
    $P10 = rx653_cur."multi_declarator"()
    unless $P10, rx653_fail
    rx653_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx653_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx653_cur."!cursor_pos"(rx653_pos)
    $P10 = rx653_cur."ws"()
    unless $P10, rx653_fail
    rx653_pos = $P10."pos"()
  alt659_end:
.annotate 'line', 316
  # rx pass
    rx653_cur."!cursor_pass"(rx653_pos, "scoped")
    if_null rx653_debug, debug_688
    rx653_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx653_pos)
  debug_688:
    .return (rx653_cur)
  rx653_restart:
.annotate 'line', 4
    if_null rx653_debug, debug_689
    rx653_cur."!cursor_debug"("NEXT", "scoped")
  debug_689:
  rx653_fail:
    (rx653_rep, rx653_pos, $I10, $P10) = rx653_cur."!mark_fail"(0)
    lt rx653_pos, -1, rx653_done
    eq rx653_pos, -1, rx653_fail
    jump $I10
  rx653_done:
    rx653_cur."!cursor_fail"()
    if_null rx653_debug, debug_690
    rx653_cur."!cursor_debug"("FAIL", "scoped")
  debug_690:
    .return (rx653_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("154_1295307698.031") :method
.annotate 'line', 4
    $P655 = self."!PREFIX__!subrule"("ws", "")
    $P656 = self."!PREFIX__!subrule"("ws", "")
    new $P657, "ResizablePMCArray"
    push $P657, $P655
    push $P657, $P656
    .return ($P657)
.end


.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("155_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx665_tgt
    .local int rx665_pos
    .local int rx665_off
    .local int rx665_eos
    .local int rx665_rep
    .local pmc rx665_cur
    .local pmc rx665_debug
    (rx665_cur, rx665_pos, rx665_tgt, $I10) = self."!cursor_start"()
    getattribute rx665_debug, rx665_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx665_cur
    .local pmc match
    .lex "$/", match
    length rx665_eos, rx665_tgt
    gt rx665_pos, rx665_eos, rx665_done
    set rx665_off, 0
    lt rx665_pos, 2, rx665_start
    sub rx665_off, rx665_pos, 1
    substr rx665_tgt, rx665_tgt, rx665_off
  rx665_start:
    eq $I10, 1, rx665_restart
    if_null rx665_debug, debug_691
    rx665_cur."!cursor_debug"("START", "typename")
  debug_691:
    $I10 = self.'from'()
    ne $I10, -1, rxscan669_done
    goto rxscan669_scan
  rxscan669_loop:
    ($P10) = rx665_cur."from"()
    inc $P10
    set rx665_pos, $P10
    ge rx665_pos, rx665_eos, rxscan669_done
  rxscan669_scan:
    set_addr $I10, rxscan669_loop
    rx665_cur."!mark_push"(0, rx665_pos, $I10)
  rxscan669_done:
.annotate 'line', 321
  # rx subrule "name" subtype=capture negate=
    rx665_cur."!cursor_pos"(rx665_pos)
    $P10 = rx665_cur."name"()
    unless $P10, rx665_fail
    rx665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx665_pos = $P10."pos"()
  # rx pass
    rx665_cur."!cursor_pass"(rx665_pos, "typename")
    if_null rx665_debug, debug_692
    rx665_cur."!cursor_debug"("PASS", "typename", " at pos=", rx665_pos)
  debug_692:
    .return (rx665_cur)
  rx665_restart:
.annotate 'line', 4
    if_null rx665_debug, debug_693
    rx665_cur."!cursor_debug"("NEXT", "typename")
  debug_693:
  rx665_fail:
    (rx665_rep, rx665_pos, $I10, $P10) = rx665_cur."!mark_fail"(0)
    lt rx665_pos, -1, rx665_done
    eq rx665_pos, -1, rx665_fail
    jump $I10
  rx665_done:
    rx665_cur."!cursor_fail"()
    if_null rx665_debug, debug_694
    rx665_cur."!cursor_debug"("FAIL", "typename")
  debug_694:
    .return (rx665_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("156_1295307698.031") :method
.annotate 'line', 4
    $P667 = self."!PREFIX__!subrule"("name", "")
    new $P668, "ResizablePMCArray"
    push $P668, $P667
    .return ($P668)
.end


.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("157_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx671_tgt
    .local int rx671_pos
    .local int rx671_off
    .local int rx671_eos
    .local int rx671_rep
    .local pmc rx671_cur
    .local pmc rx671_debug
    (rx671_cur, rx671_pos, rx671_tgt, $I10) = self."!cursor_start"()
    getattribute rx671_debug, rx671_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx671_cur
    .local pmc match
    .lex "$/", match
    length rx671_eos, rx671_tgt
    gt rx671_pos, rx671_eos, rx671_done
    set rx671_off, 0
    lt rx671_pos, 2, rx671_start
    sub rx671_off, rx671_pos, 1
    substr rx671_tgt, rx671_tgt, rx671_off
  rx671_start:
    eq $I10, 1, rx671_restart
    if_null rx671_debug, debug_695
    rx671_cur."!cursor_debug"("START", "declarator")
  debug_695:
    $I10 = self.'from'()
    ne $I10, -1, rxscan676_done
    goto rxscan676_scan
  rxscan676_loop:
    ($P10) = rx671_cur."from"()
    inc $P10
    set rx671_pos, $P10
    ge rx671_pos, rx671_eos, rxscan676_done
  rxscan676_scan:
    set_addr $I10, rxscan676_loop
    rx671_cur."!mark_push"(0, rx671_pos, $I10)
  rxscan676_done:
  alt677_0:
.annotate 'line', 323
    set_addr $I10, alt677_1
    rx671_cur."!mark_push"(0, rx671_pos, $I10)
.annotate 'line', 324
  # rx subrule "variable_declarator" subtype=capture negate=
    rx671_cur."!cursor_pos"(rx671_pos)
    $P10 = rx671_cur."variable_declarator"()
    unless $P10, rx671_fail
    rx671_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx671_pos = $P10."pos"()
    goto alt677_end
  alt677_1:
.annotate 'line', 325
  # rx subrule "routine_declarator" subtype=capture negate=
    rx671_cur."!cursor_pos"(rx671_pos)
    $P10 = rx671_cur."routine_declarator"()
    unless $P10, rx671_fail
    rx671_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx671_pos = $P10."pos"()
  alt677_end:
.annotate 'line', 323
  # rx pass
    rx671_cur."!cursor_pass"(rx671_pos, "declarator")
    if_null rx671_debug, debug_696
    rx671_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx671_pos)
  debug_696:
    .return (rx671_cur)
  rx671_restart:
.annotate 'line', 4
    if_null rx671_debug, debug_697
    rx671_cur."!cursor_debug"("NEXT", "declarator")
  debug_697:
  rx671_fail:
    (rx671_rep, rx671_pos, $I10, $P10) = rx671_cur."!mark_fail"(0)
    lt rx671_pos, -1, rx671_done
    eq rx671_pos, -1, rx671_fail
    jump $I10
  rx671_done:
    rx671_cur."!cursor_fail"()
    if_null rx671_debug, debug_698
    rx671_cur."!cursor_debug"("FAIL", "declarator")
  debug_698:
    .return (rx671_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("158_1295307698.031") :method
.annotate 'line', 4
    $P673 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P674 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P675, "ResizablePMCArray"
    push $P675, $P673
    push $P675, $P674
    .return ($P675)
.end


.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("159_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx679_tgt
    .local int rx679_pos
    .local int rx679_off
    .local int rx679_eos
    .local int rx679_rep
    .local pmc rx679_cur
    .local pmc rx679_debug
    (rx679_cur, rx679_pos, rx679_tgt, $I10) = self."!cursor_start"()
    getattribute rx679_debug, rx679_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx679_cur
    .local pmc match
    .lex "$/", match
    length rx679_eos, rx679_tgt
    gt rx679_pos, rx679_eos, rx679_done
    set rx679_off, 0
    lt rx679_pos, 2, rx679_start
    sub rx679_off, rx679_pos, 1
    substr rx679_tgt, rx679_tgt, rx679_off
  rx679_start:
    eq $I10, 1, rx679_restart
    if_null rx679_debug, debug_699
    rx679_cur."!cursor_debug"("START", "variable_declarator")
  debug_699:
    $I10 = self.'from'()
    ne $I10, -1, rxscan683_done
    goto rxscan683_scan
  rxscan683_loop:
    ($P10) = rx679_cur."from"()
    inc $P10
    set rx679_pos, $P10
    ge rx679_pos, rx679_eos, rxscan683_done
  rxscan683_scan:
    set_addr $I10, rxscan683_loop
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxscan683_done:
.annotate 'line', 328
  # rx subrule "variable" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."variable"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx679_pos = $P10."pos"()
  # rx pass
    rx679_cur."!cursor_pass"(rx679_pos, "variable_declarator")
    if_null rx679_debug, debug_700
    rx679_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx679_pos)
  debug_700:
    .return (rx679_cur)
  rx679_restart:
.annotate 'line', 4
    if_null rx679_debug, debug_701
    rx679_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_701:
  rx679_fail:
    (rx679_rep, rx679_pos, $I10, $P10) = rx679_cur."!mark_fail"(0)
    lt rx679_pos, -1, rx679_done
    eq rx679_pos, -1, rx679_fail
    jump $I10
  rx679_done:
    rx679_cur."!cursor_fail"()
    if_null rx679_debug, debug_702
    rx679_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_702:
    .return (rx679_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("160_1295307698.031") :method
.annotate 'line', 4
    $P681 = self."!PREFIX__!subrule"("variable", "")
    new $P682, "ResizablePMCArray"
    push $P682, $P681
    .return ($P682)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("161_1295307698.031") :method
.annotate 'line', 330
    $P685 = self."!protoregex"("routine_declarator")
    .return ($P685)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("162_1295307698.031") :method
.annotate 'line', 330
    $P687 = self."!PREFIX__!protoregex"("routine_declarator")
    .return ($P687)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("163_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx689_tgt
    .local int rx689_pos
    .local int rx689_off
    .local int rx689_eos
    .local int rx689_rep
    .local pmc rx689_cur
    .local pmc rx689_debug
    (rx689_cur, rx689_pos, rx689_tgt, $I10) = self."!cursor_start"()
    getattribute rx689_debug, rx689_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx689_cur
    .local pmc match
    .lex "$/", match
    length rx689_eos, rx689_tgt
    gt rx689_pos, rx689_eos, rx689_done
    set rx689_off, 0
    lt rx689_pos, 2, rx689_start
    sub rx689_off, rx689_pos, 1
    substr rx689_tgt, rx689_tgt, rx689_off
  rx689_start:
    eq $I10, 1, rx689_restart
    if_null rx689_debug, debug_703
    rx689_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_703:
    $I10 = self.'from'()
    ne $I10, -1, rxscan693_done
    goto rxscan693_scan
  rxscan693_loop:
    ($P10) = rx689_cur."from"()
    inc $P10
    set rx689_pos, $P10
    ge rx689_pos, rx689_eos, rxscan693_done
  rxscan693_scan:
    set_addr $I10, rxscan693_loop
    rx689_cur."!mark_push"(0, rx689_pos, $I10)
  rxscan693_done:
.annotate 'line', 331
  # rx subcapture "sym"
    set_addr $I10, rxcap_694_fail
    rx689_cur."!mark_push"(0, rx689_pos, $I10)
  # rx literal  "sub"
    add $I11, rx689_pos, 3
    gt $I11, rx689_eos, rx689_fail
    sub $I11, rx689_pos, rx689_off
    substr $S10, rx689_tgt, $I11, 3
    ne $S10, "sub", rx689_fail
    add rx689_pos, 3
    set_addr $I10, rxcap_694_fail
    ($I12, $I11) = rx689_cur."!mark_peek"($I10)
    rx689_cur."!cursor_pos"($I11)
    ($P10) = rx689_cur."!cursor_start"()
    $P10."!cursor_pass"(rx689_pos, "")
    rx689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_694_done
  rxcap_694_fail:
    goto rx689_fail
  rxcap_694_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx689_cur."!cursor_pos"(rx689_pos)
    $P10 = rx689_cur."routine_def"()
    unless $P10, rx689_fail
    rx689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx689_pos = $P10."pos"()
  # rx pass
    rx689_cur."!cursor_pass"(rx689_pos, "routine_declarator:sym<sub>")
    if_null rx689_debug, debug_704
    rx689_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx689_pos)
  debug_704:
    .return (rx689_cur)
  rx689_restart:
.annotate 'line', 4
    if_null rx689_debug, debug_705
    rx689_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_705:
  rx689_fail:
    (rx689_rep, rx689_pos, $I10, $P10) = rx689_cur."!mark_fail"(0)
    lt rx689_pos, -1, rx689_done
    eq rx689_pos, -1, rx689_fail
    jump $I10
  rx689_done:
    rx689_cur."!cursor_fail"()
    if_null rx689_debug, debug_706
    rx689_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_706:
    .return (rx689_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("164_1295307698.031") :method
.annotate 'line', 4
    $P691 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P692, "ResizablePMCArray"
    push $P692, $P691
    .return ($P692)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("165_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx696_tgt
    .local int rx696_pos
    .local int rx696_off
    .local int rx696_eos
    .local int rx696_rep
    .local pmc rx696_cur
    .local pmc rx696_debug
    (rx696_cur, rx696_pos, rx696_tgt, $I10) = self."!cursor_start"()
    getattribute rx696_debug, rx696_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx696_cur
    .local pmc match
    .lex "$/", match
    length rx696_eos, rx696_tgt
    gt rx696_pos, rx696_eos, rx696_done
    set rx696_off, 0
    lt rx696_pos, 2, rx696_start
    sub rx696_off, rx696_pos, 1
    substr rx696_tgt, rx696_tgt, rx696_off
  rx696_start:
    eq $I10, 1, rx696_restart
    if_null rx696_debug, debug_707
    rx696_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_707:
    $I10 = self.'from'()
    ne $I10, -1, rxscan700_done
    goto rxscan700_scan
  rxscan700_loop:
    ($P10) = rx696_cur."from"()
    inc $P10
    set rx696_pos, $P10
    ge rx696_pos, rx696_eos, rxscan700_done
  rxscan700_scan:
    set_addr $I10, rxscan700_loop
    rx696_cur."!mark_push"(0, rx696_pos, $I10)
  rxscan700_done:
.annotate 'line', 332
  # rx subcapture "sym"
    set_addr $I10, rxcap_701_fail
    rx696_cur."!mark_push"(0, rx696_pos, $I10)
  # rx literal  "method"
    add $I11, rx696_pos, 6
    gt $I11, rx696_eos, rx696_fail
    sub $I11, rx696_pos, rx696_off
    substr $S10, rx696_tgt, $I11, 6
    ne $S10, "method", rx696_fail
    add rx696_pos, 6
    set_addr $I10, rxcap_701_fail
    ($I12, $I11) = rx696_cur."!mark_peek"($I10)
    rx696_cur."!cursor_pos"($I11)
    ($P10) = rx696_cur."!cursor_start"()
    $P10."!cursor_pass"(rx696_pos, "")
    rx696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_701_done
  rxcap_701_fail:
    goto rx696_fail
  rxcap_701_done:
  # rx subrule "method_def" subtype=capture negate=
    rx696_cur."!cursor_pos"(rx696_pos)
    $P10 = rx696_cur."method_def"()
    unless $P10, rx696_fail
    rx696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx696_pos = $P10."pos"()
  # rx pass
    rx696_cur."!cursor_pass"(rx696_pos, "routine_declarator:sym<method>")
    if_null rx696_debug, debug_708
    rx696_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx696_pos)
  debug_708:
    .return (rx696_cur)
  rx696_restart:
.annotate 'line', 4
    if_null rx696_debug, debug_709
    rx696_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_709:
  rx696_fail:
    (rx696_rep, rx696_pos, $I10, $P10) = rx696_cur."!mark_fail"(0)
    lt rx696_pos, -1, rx696_done
    eq rx696_pos, -1, rx696_fail
    jump $I10
  rx696_done:
    rx696_cur."!cursor_fail"()
    if_null rx696_debug, debug_710
    rx696_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_710:
    .return (rx696_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("166_1295307698.031") :method
.annotate 'line', 4
    $P698 = self."!PREFIX__!subrule"("method_def", "method")
    new $P699, "ResizablePMCArray"
    push $P699, $P698
    .return ($P699)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("167_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx703_tgt
    .local int rx703_pos
    .local int rx703_off
    .local int rx703_eos
    .local int rx703_rep
    .local pmc rx703_cur
    .local pmc rx703_debug
    (rx703_cur, rx703_pos, rx703_tgt, $I10) = self."!cursor_start"()
    rx703_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    getattribute rx703_debug, rx703_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx703_cur
    .local pmc match
    .lex "$/", match
    length rx703_eos, rx703_tgt
    gt rx703_pos, rx703_eos, rx703_done
    set rx703_off, 0
    lt rx703_pos, 2, rx703_start
    sub rx703_off, rx703_pos, 1
    substr rx703_tgt, rx703_tgt, rx703_off
  rx703_start:
    eq $I10, 1, rx703_restart
    if_null rx703_debug, debug_711
    rx703_cur."!cursor_debug"("START", "routine_def")
  debug_711:
    $I10 = self.'from'()
    ne $I10, -1, rxscan707_done
    goto rxscan707_scan
  rxscan707_loop:
    ($P10) = rx703_cur."from"()
    inc $P10
    set rx703_pos, $P10
    ge rx703_pos, rx703_eos, rxscan707_done
  rxscan707_scan:
    set_addr $I10, rxscan707_loop
    rx703_cur."!mark_push"(0, rx703_pos, $I10)
  rxscan707_done:
.annotate 'line', 334
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
.annotate 'line', 335
  # rx rxquantr709 ** 0..1
    set_addr $I10, rxquantr709_done
    rx703_cur."!mark_push"(0, rx703_pos, $I10)
  rxquantr709_loop:
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_712_fail
    rx703_cur."!mark_push"(0, rx703_pos, $I10)
  # rx rxquantr711 ** 0..1
    set_addr $I10, rxquantr711_done
    rx703_cur."!mark_push"(0, rx703_pos, $I10)
  rxquantr711_loop:
  # rx literal  "&"
    add $I11, rx703_pos, 1
    gt $I11, rx703_eos, rx703_fail
    sub $I11, rx703_pos, rx703_off
    ord $I11, rx703_tgt, $I11
    ne $I11, 38, rx703_fail
    add rx703_pos, 1
    set_addr $I10, rxquantr711_done
    (rx703_rep) = rx703_cur."!mark_commit"($I10)
  rxquantr711_done:
    set_addr $I10, rxcap_712_fail
    ($I12, $I11) = rx703_cur."!mark_peek"($I10)
    rx703_cur."!cursor_pos"($I11)
    ($P10) = rx703_cur."!cursor_start"()
    $P10."!cursor_pass"(rx703_pos, "")
    rx703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_712_done
  rxcap_712_fail:
    goto rx703_fail
  rxcap_712_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."deflongname"()
    unless $P10, rx703_fail
    rx703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx703_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
    set_addr $I10, rxquantr709_done
    (rx703_rep) = rx703_cur."!mark_commit"($I10)
  rxquantr709_done:
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
.annotate 'line', 336
  # rx subrule "newpad" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."newpad"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  alt716_0:
.annotate 'line', 337
    set_addr $I10, alt716_1
    rx703_cur."!mark_push"(0, rx703_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx703_pos, 1
    gt $I11, rx703_eos, rx703_fail
    sub $I11, rx703_pos, rx703_off
    ord $I11, rx703_tgt, $I11
    ne $I11, 40, rx703_fail
    add rx703_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."signature"()
    unless $P10, rx703_fail
    rx703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx703_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx703_pos, 1
    gt $I11, rx703_eos, rx703_fail
    sub $I11, rx703_pos, rx703_off
    ord $I11, rx703_tgt, $I11
    ne $I11, 41, rx703_fail
    add rx703_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
    goto alt716_end
  alt716_1:
.annotate 'line', 338
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  alt716_end:
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
.annotate 'line', 339
  # rx rxquantr724 ** 0..*
    set_addr $I10, rxquantr724_done
    rx703_cur."!mark_push"(0, rx703_pos, $I10)
  rxquantr724_loop:
  # rx subrule "trait" subtype=capture negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."trait"()
    unless $P10, rx703_fail
    goto rxsubrule725_pass
  rxsubrule725_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx703_fail
  rxsubrule725_pass:
    set_addr $I10, rxsubrule725_back
    rx703_cur."!mark_push"(0, rx703_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx703_pos = $P10."pos"()
    set_addr $I10, rxquantr724_done
    (rx703_rep) = rx703_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr724_done
    rx703_cur."!mark_push"(rx703_rep, rx703_pos, $I10)
    goto rxquantr724_loop
  rxquantr724_done:
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  alt727_0:
.annotate 'line', 340
    set_addr $I10, alt727_1
    rx703_cur."!mark_push"(0, rx703_pos, $I10)
.annotate 'line', 341
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."onlystar"()
    unless $P10, rx703_fail
    rx703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx703_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
    goto alt727_end
  alt727_1:
.annotate 'line', 342
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."blockoid"()
    unless $P10, rx703_fail
    rx703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx703_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
  alt727_end:
.annotate 'line', 343
  # rx subrule "ws" subtype=method negate=
    rx703_cur."!cursor_pos"(rx703_pos)
    $P10 = rx703_cur."ws"()
    unless $P10, rx703_fail
    rx703_pos = $P10."pos"()
.annotate 'line', 334
  # rx pass
    rx703_cur."!cursor_pass"(rx703_pos, "routine_def")
    if_null rx703_debug, debug_712
    rx703_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx703_pos)
  debug_712:
    .return (rx703_cur)
  rx703_restart:
.annotate 'line', 4
    if_null rx703_debug, debug_713
    rx703_cur."!cursor_debug"("NEXT", "routine_def")
  debug_713:
  rx703_fail:
    (rx703_rep, rx703_pos, $I10, $P10) = rx703_cur."!mark_fail"(0)
    lt rx703_pos, -1, rx703_done
    eq rx703_pos, -1, rx703_fail
    jump $I10
  rx703_done:
    rx703_cur."!cursor_fail"()
    if_null rx703_debug, debug_714
    rx703_cur."!cursor_debug"("FAIL", "routine_def")
  debug_714:
    .return (rx703_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("168_1295307698.031") :method
.annotate 'line', 4
    $P705 = self."!PREFIX__!subrule"("ws", "")
    new $P706, "ResizablePMCArray"
    push $P706, $P705
    .return ($P706)
.end


.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("169_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .const 'Sub' $P758 = "171_1295307698.031" 
    capture_lex $P758
.annotate 'line', 347
    new $P734, "Undef"
    .lex "$*INVOCANT_OK", $P734
.annotate 'line', 4
    .local string rx735_tgt
    .local int rx735_pos
    .local int rx735_off
    .local int rx735_eos
    .local int rx735_rep
    .local pmc rx735_cur
    .local pmc rx735_debug
    (rx735_cur, rx735_pos, rx735_tgt, $I10) = self."!cursor_start"()
    rx735_cur."!cursor_caparray"("deflongname", "trait")
    getattribute rx735_debug, rx735_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx735_cur
    .local pmc match
    .lex "$/", match
    length rx735_eos, rx735_tgt
    gt rx735_pos, rx735_eos, rx735_done
    set rx735_off, 0
    lt rx735_pos, 2, rx735_start
    sub rx735_off, rx735_pos, 1
    substr rx735_tgt, rx735_tgt, rx735_off
  rx735_start:
    eq $I10, 1, rx735_restart
    if_null rx735_debug, debug_715
    rx735_cur."!cursor_debug"("START", "method_def")
  debug_715:
    $I10 = self.'from'()
    ne $I10, -1, rxscan739_done
    goto rxscan739_scan
  rxscan739_loop:
    ($P10) = rx735_cur."from"()
    inc $P10
    set rx735_pos, $P10
    ge rx735_pos, rx735_eos, rxscan739_done
  rxscan739_scan:
    set_addr $I10, rxscan739_loop
    rx735_cur."!mark_push"(0, rx735_pos, $I10)
  rxscan739_done:
.annotate 'line', 346
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
.annotate 'line', 347
    rx735_cur."!cursor_pos"(rx735_pos)
    new $P741, "Integer"
    assign $P741, 1
    store_lex "$*INVOCANT_OK", $P741
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
.annotate 'line', 348
  # rx rxquantr743 ** 0..1
    set_addr $I10, rxquantr743_done
    rx735_cur."!mark_push"(0, rx735_pos, $I10)
  rxquantr743_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."deflongname"()
    unless $P10, rx735_fail
    goto rxsubrule744_pass
  rxsubrule744_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx735_fail
  rxsubrule744_pass:
    set_addr $I10, rxsubrule744_back
    rx735_cur."!mark_push"(0, rx735_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx735_pos = $P10."pos"()
    set_addr $I10, rxquantr743_done
    (rx735_rep) = rx735_cur."!mark_commit"($I10)
  rxquantr743_done:
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
.annotate 'line', 349
  # rx subrule "newpad" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."newpad"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  alt747_0:
.annotate 'line', 350
    set_addr $I10, alt747_1
    rx735_cur."!mark_push"(0, rx735_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx735_pos, 1
    gt $I11, rx735_eos, rx735_fail
    sub $I11, rx735_pos, rx735_off
    ord $I11, rx735_tgt, $I11
    ne $I11, 40, rx735_fail
    add rx735_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."signature"()
    unless $P10, rx735_fail
    rx735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx735_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx735_pos, 1
    gt $I11, rx735_eos, rx735_fail
    sub $I11, rx735_pos, rx735_off
    ord $I11, rx735_tgt, $I11
    ne $I11, 41, rx735_fail
    add rx735_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
    goto alt747_end
  alt747_1:
.annotate 'line', 351
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  alt747_end:
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
.annotate 'line', 352
    rx735_cur."!cursor_pos"(rx735_pos)
    find_lex $P755, unicode:"$\x{a2}"
    $P756 = $P755."MATCH"()
    store_lex "$/", $P756
    .const 'Sub' $P758 = "171_1295307698.031" 
    capture_lex $P758
    $P760 = $P758()
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
.annotate 'line', 353
  # rx rxquantr762 ** 0..*
    set_addr $I10, rxquantr762_done
    rx735_cur."!mark_push"(0, rx735_pos, $I10)
  rxquantr762_loop:
  # rx subrule "trait" subtype=capture negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."trait"()
    unless $P10, rx735_fail
    goto rxsubrule763_pass
  rxsubrule763_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx735_fail
  rxsubrule763_pass:
    set_addr $I10, rxsubrule763_back
    rx735_cur."!mark_push"(0, rx735_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx735_pos = $P10."pos"()
    set_addr $I10, rxquantr762_done
    (rx735_rep) = rx735_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr762_done
    rx735_cur."!mark_push"(rx735_rep, rx735_pos, $I10)
    goto rxquantr762_loop
  rxquantr762_done:
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  alt765_0:
.annotate 'line', 354
    set_addr $I10, alt765_1
    rx735_cur."!mark_push"(0, rx735_pos, $I10)
.annotate 'line', 355
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."onlystar"()
    unless $P10, rx735_fail
    rx735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx735_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
    goto alt765_end
  alt765_1:
.annotate 'line', 356
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."blockoid"()
    unless $P10, rx735_fail
    rx735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx735_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
  alt765_end:
.annotate 'line', 357
  # rx subrule "ws" subtype=method negate=
    rx735_cur."!cursor_pos"(rx735_pos)
    $P10 = rx735_cur."ws"()
    unless $P10, rx735_fail
    rx735_pos = $P10."pos"()
.annotate 'line', 346
  # rx pass
    rx735_cur."!cursor_pass"(rx735_pos, "method_def")
    if_null rx735_debug, debug_716
    rx735_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx735_pos)
  debug_716:
    .return (rx735_cur)
  rx735_restart:
.annotate 'line', 4
    if_null rx735_debug, debug_717
    rx735_cur."!cursor_debug"("NEXT", "method_def")
  debug_717:
  rx735_fail:
    (rx735_rep, rx735_pos, $I10, $P10) = rx735_cur."!mark_fail"(0)
    lt rx735_pos, -1, rx735_done
    eq rx735_pos, -1, rx735_fail
    jump $I10
  rx735_done:
    rx735_cur."!cursor_fail"()
    if_null rx735_debug, debug_718
    rx735_cur."!cursor_debug"("FAIL", "method_def")
  debug_718:
    .return (rx735_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("170_1295307698.031") :method
.annotate 'line', 4
    $P737 = self."!PREFIX__!subrule"("ws", "")
    new $P738, "ResizablePMCArray"
    push $P738, $P737
    .return ($P738)
.end


.namespace ["NQP";"Grammar"]
.sub "_block757"  :anon :subid("171_1295307698.031") :outer("169_1295307698.031")
.annotate 'line', 352
    new $P759, "Integer"
    assign $P759, 0
    store_dynamic_lex "$*INVOCANT_OK", $P759
    .return ($P759)
.end


.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("172_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .const 'Sub' $P779 = "174_1295307698.031" 
    capture_lex $P779
    .local string rx772_tgt
    .local int rx772_pos
    .local int rx772_off
    .local int rx772_eos
    .local int rx772_rep
    .local pmc rx772_cur
    .local pmc rx772_debug
    (rx772_cur, rx772_pos, rx772_tgt, $I10) = self."!cursor_start"()
    getattribute rx772_debug, rx772_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx772_cur
    .local pmc match
    .lex "$/", match
    length rx772_eos, rx772_tgt
    gt rx772_pos, rx772_eos, rx772_done
    set rx772_off, 0
    lt rx772_pos, 2, rx772_start
    sub rx772_off, rx772_pos, 1
    substr rx772_tgt, rx772_tgt, rx772_off
  rx772_start:
    eq $I10, 1, rx772_restart
    if_null rx772_debug, debug_719
    rx772_cur."!cursor_debug"("START", "onlystar")
  debug_719:
    $I10 = self.'from'()
    ne $I10, -1, rxscan775_done
    goto rxscan775_scan
  rxscan775_loop:
    ($P10) = rx772_cur."from"()
    inc $P10
    set rx772_pos, $P10
    ge rx772_pos, rx772_eos, rxscan775_done
  rxscan775_scan:
    set_addr $I10, rxscan775_loop
    rx772_cur."!mark_push"(0, rx772_pos, $I10)
  rxscan775_done:
.annotate 'line', 361
    rx772_cur."!cursor_pos"(rx772_pos)
    find_lex $P776, unicode:"$\x{a2}"
    $P777 = $P776."MATCH"()
    store_lex "$/", $P777
    .const 'Sub' $P779 = "174_1295307698.031" 
    capture_lex $P779
    $P783 = $P779()
    unless $P783, rx772_fail
.annotate 'line', 362
  # rx literal  "{"
    add $I11, rx772_pos, 1
    gt $I11, rx772_eos, rx772_fail
    sub $I11, rx772_pos, rx772_off
    ord $I11, rx772_tgt, $I11
    ne $I11, 123, rx772_fail
    add rx772_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx772_cur."!cursor_pos"(rx772_pos)
    $P10 = rx772_cur."ws"()
    unless $P10, rx772_fail
    rx772_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx772_pos, 1
    gt $I11, rx772_eos, rx772_fail
    sub $I11, rx772_pos, rx772_off
    ord $I11, rx772_tgt, $I11
    ne $I11, 42, rx772_fail
    add rx772_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx772_cur."!cursor_pos"(rx772_pos)
    $P10 = rx772_cur."ws"()
    unless $P10, rx772_fail
    rx772_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx772_pos, 1
    gt $I11, rx772_eos, rx772_fail
    sub $I11, rx772_pos, rx772_off
    ord $I11, rx772_tgt, $I11
    ne $I11, 125, rx772_fail
    add rx772_pos, 1
.annotate 'line', 363
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx772_cur."!cursor_pos"(rx772_pos)
    $P10 = rx772_cur."ENDSTMT"()
    unless $P10, rx772_fail
.annotate 'line', 364
  # rx subrule "finishpad" subtype=method negate=
    rx772_cur."!cursor_pos"(rx772_pos)
    $P10 = rx772_cur."finishpad"()
    unless $P10, rx772_fail
    rx772_pos = $P10."pos"()
.annotate 'line', 360
  # rx pass
    rx772_cur."!cursor_pass"(rx772_pos, "onlystar")
    if_null rx772_debug, debug_722
    rx772_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx772_pos)
  debug_722:
    .return (rx772_cur)
  rx772_restart:
.annotate 'line', 4
    if_null rx772_debug, debug_723
    rx772_cur."!cursor_debug"("NEXT", "onlystar")
  debug_723:
  rx772_fail:
    (rx772_rep, rx772_pos, $I10, $P10) = rx772_cur."!mark_fail"(0)
    lt rx772_pos, -1, rx772_done
    eq rx772_pos, -1, rx772_fail
    jump $I10
  rx772_done:
    rx772_cur."!cursor_fail"()
    if_null rx772_debug, debug_724
    rx772_cur."!cursor_debug"("FAIL", "onlystar")
  debug_724:
    .return (rx772_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("173_1295307698.031") :method
.annotate 'line', 4
    new $P774, "ResizablePMCArray"
    push $P774, ""
    .return ($P774)
.end


.namespace ["NQP";"Grammar"]
.sub "_block778"  :anon :subid("174_1295307698.031") :outer("172_1295307698.031")
.annotate 'line', 361
    find_dynamic_lex $P780, "$*MULTINESS"
    unless_null $P780, vivify_720
    get_hll_global $P780, "$MULTINESS"
    unless_null $P780, vivify_721
    die "Contextual $*MULTINESS not found"
  vivify_721:
  vivify_720:
    set $S781, $P780
    iseq $I782, $S781, "proto"
    .return ($I782)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("175_1295307698.031") :method
.annotate 'line', 367
    $P785 = self."!protoregex"("multi_declarator")
    .return ($P785)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("176_1295307698.031") :method
.annotate 'line', 367
    $P787 = self."!PREFIX__!protoregex"("multi_declarator")
    .return ($P787)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("177_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 369
    new $P789, "Undef"
    .lex "$*MULTINESS", $P789
.annotate 'line', 4
    .local string rx790_tgt
    .local int rx790_pos
    .local int rx790_off
    .local int rx790_eos
    .local int rx790_rep
    .local pmc rx790_cur
    .local pmc rx790_debug
    (rx790_cur, rx790_pos, rx790_tgt, $I10) = self."!cursor_start"()
    getattribute rx790_debug, rx790_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx790_cur
    .local pmc match
    .lex "$/", match
    length rx790_eos, rx790_tgt
    gt rx790_pos, rx790_eos, rx790_done
    set rx790_off, 0
    lt rx790_pos, 2, rx790_start
    sub rx790_off, rx790_pos, 1
    substr rx790_tgt, rx790_tgt, rx790_off
  rx790_start:
    eq $I10, 1, rx790_restart
    if_null rx790_debug, debug_725
    rx790_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_725:
    $I10 = self.'from'()
    ne $I10, -1, rxscan794_done
    goto rxscan794_scan
  rxscan794_loop:
    ($P10) = rx790_cur."from"()
    inc $P10
    set rx790_pos, $P10
    ge rx790_pos, rx790_eos, rxscan794_done
  rxscan794_scan:
    set_addr $I10, rxscan794_loop
    rx790_cur."!mark_push"(0, rx790_pos, $I10)
  rxscan794_done:
.annotate 'line', 369
    rx790_cur."!cursor_pos"(rx790_pos)
    new $P795, "String"
    assign $P795, "multi"
    store_lex "$*MULTINESS", $P795
.annotate 'line', 370
  # rx subcapture "sym"
    set_addr $I10, rxcap_796_fail
    rx790_cur."!mark_push"(0, rx790_pos, $I10)
  # rx literal  "multi"
    add $I11, rx790_pos, 5
    gt $I11, rx790_eos, rx790_fail
    sub $I11, rx790_pos, rx790_off
    substr $S10, rx790_tgt, $I11, 5
    ne $S10, "multi", rx790_fail
    add rx790_pos, 5
    set_addr $I10, rxcap_796_fail
    ($I12, $I11) = rx790_cur."!mark_peek"($I10)
    rx790_cur."!cursor_pos"($I11)
    ($P10) = rx790_cur."!cursor_start"()
    $P10."!cursor_pass"(rx790_pos, "")
    rx790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_796_done
  rxcap_796_fail:
    goto rx790_fail
  rxcap_796_done:
.annotate 'line', 371
  # rx subrule "ws" subtype=method negate=
    rx790_cur."!cursor_pos"(rx790_pos)
    $P10 = rx790_cur."ws"()
    unless $P10, rx790_fail
    rx790_pos = $P10."pos"()
  alt797_0:
    set_addr $I10, alt797_1
    rx790_cur."!mark_push"(0, rx790_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx790_cur."!cursor_pos"(rx790_pos)
    $P10 = rx790_cur."declarator"()
    unless $P10, rx790_fail
    rx790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx790_pos = $P10."pos"()
    goto alt797_end
  alt797_1:
    set_addr $I10, alt797_2
    rx790_cur."!mark_push"(0, rx790_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx790_cur."!cursor_pos"(rx790_pos)
    $P10 = rx790_cur."routine_def"()
    unless $P10, rx790_fail
    rx790_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx790_pos = $P10."pos"()
    goto alt797_end
  alt797_2:
  # rx subrule "panic" subtype=method negate=
    rx790_cur."!cursor_pos"(rx790_pos)
    $P10 = rx790_cur."panic"("Malformed multi")
    unless $P10, rx790_fail
    rx790_pos = $P10."pos"()
  alt797_end:
.annotate 'line', 368
  # rx pass
    rx790_cur."!cursor_pass"(rx790_pos, "multi_declarator:sym<multi>")
    if_null rx790_debug, debug_726
    rx790_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx790_pos)
  debug_726:
    .return (rx790_cur)
  rx790_restart:
.annotate 'line', 4
    if_null rx790_debug, debug_727
    rx790_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_727:
  rx790_fail:
    (rx790_rep, rx790_pos, $I10, $P10) = rx790_cur."!mark_fail"(0)
    lt rx790_pos, -1, rx790_done
    eq rx790_pos, -1, rx790_fail
    jump $I10
  rx790_done:
    rx790_cur."!cursor_fail"()
    if_null rx790_debug, debug_728
    rx790_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_728:
    .return (rx790_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("178_1295307698.031") :method
.annotate 'line', 4
    $P792 = self."!PREFIX__!subrule"("ws", "multi")
    new $P793, "ResizablePMCArray"
    push $P793, $P792
    .return ($P793)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("179_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 374
    new $P799, "Undef"
    .lex "$*MULTINESS", $P799
.annotate 'line', 4
    .local string rx800_tgt
    .local int rx800_pos
    .local int rx800_off
    .local int rx800_eos
    .local int rx800_rep
    .local pmc rx800_cur
    .local pmc rx800_debug
    (rx800_cur, rx800_pos, rx800_tgt, $I10) = self."!cursor_start"()
    getattribute rx800_debug, rx800_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx800_cur
    .local pmc match
    .lex "$/", match
    length rx800_eos, rx800_tgt
    gt rx800_pos, rx800_eos, rx800_done
    set rx800_off, 0
    lt rx800_pos, 2, rx800_start
    sub rx800_off, rx800_pos, 1
    substr rx800_tgt, rx800_tgt, rx800_off
  rx800_start:
    eq $I10, 1, rx800_restart
    if_null rx800_debug, debug_729
    rx800_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_729:
    $I10 = self.'from'()
    ne $I10, -1, rxscan804_done
    goto rxscan804_scan
  rxscan804_loop:
    ($P10) = rx800_cur."from"()
    inc $P10
    set rx800_pos, $P10
    ge rx800_pos, rx800_eos, rxscan804_done
  rxscan804_scan:
    set_addr $I10, rxscan804_loop
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  rxscan804_done:
.annotate 'line', 374
    rx800_cur."!cursor_pos"(rx800_pos)
    new $P805, "String"
    assign $P805, "proto"
    store_lex "$*MULTINESS", $P805
.annotate 'line', 375
  # rx subcapture "sym"
    set_addr $I10, rxcap_806_fail
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  # rx literal  "proto"
    add $I11, rx800_pos, 5
    gt $I11, rx800_eos, rx800_fail
    sub $I11, rx800_pos, rx800_off
    substr $S10, rx800_tgt, $I11, 5
    ne $S10, "proto", rx800_fail
    add rx800_pos, 5
    set_addr $I10, rxcap_806_fail
    ($I12, $I11) = rx800_cur."!mark_peek"($I10)
    rx800_cur."!cursor_pos"($I11)
    ($P10) = rx800_cur."!cursor_start"()
    $P10."!cursor_pass"(rx800_pos, "")
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_806_done
  rxcap_806_fail:
    goto rx800_fail
  rxcap_806_done:
.annotate 'line', 376
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  alt807_0:
    set_addr $I10, alt807_1
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."declarator"()
    unless $P10, rx800_fail
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx800_pos = $P10."pos"()
    goto alt807_end
  alt807_1:
    set_addr $I10, alt807_2
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."routine_def"()
    unless $P10, rx800_fail
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx800_pos = $P10."pos"()
    goto alt807_end
  alt807_2:
  # rx subrule "panic" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."panic"("Malformed proto")
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  alt807_end:
.annotate 'line', 373
  # rx pass
    rx800_cur."!cursor_pass"(rx800_pos, "multi_declarator:sym<proto>")
    if_null rx800_debug, debug_730
    rx800_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx800_pos)
  debug_730:
    .return (rx800_cur)
  rx800_restart:
.annotate 'line', 4
    if_null rx800_debug, debug_731
    rx800_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_731:
  rx800_fail:
    (rx800_rep, rx800_pos, $I10, $P10) = rx800_cur."!mark_fail"(0)
    lt rx800_pos, -1, rx800_done
    eq rx800_pos, -1, rx800_fail
    jump $I10
  rx800_done:
    rx800_cur."!cursor_fail"()
    if_null rx800_debug, debug_732
    rx800_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_732:
    .return (rx800_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("180_1295307698.031") :method
.annotate 'line', 4
    $P802 = self."!PREFIX__!subrule"("ws", "proto")
    new $P803, "ResizablePMCArray"
    push $P803, $P802
    .return ($P803)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("181_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 379
    new $P809, "Undef"
    .lex "$*MULTINESS", $P809
.annotate 'line', 4
    .local string rx810_tgt
    .local int rx810_pos
    .local int rx810_off
    .local int rx810_eos
    .local int rx810_rep
    .local pmc rx810_cur
    .local pmc rx810_debug
    (rx810_cur, rx810_pos, rx810_tgt, $I10) = self."!cursor_start"()
    getattribute rx810_debug, rx810_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx810_cur
    .local pmc match
    .lex "$/", match
    length rx810_eos, rx810_tgt
    gt rx810_pos, rx810_eos, rx810_done
    set rx810_off, 0
    lt rx810_pos, 2, rx810_start
    sub rx810_off, rx810_pos, 1
    substr rx810_tgt, rx810_tgt, rx810_off
  rx810_start:
    eq $I10, 1, rx810_restart
    if_null rx810_debug, debug_733
    rx810_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_733:
    $I10 = self.'from'()
    ne $I10, -1, rxscan814_done
    goto rxscan814_scan
  rxscan814_loop:
    ($P10) = rx810_cur."from"()
    inc $P10
    set rx810_pos, $P10
    ge rx810_pos, rx810_eos, rxscan814_done
  rxscan814_scan:
    set_addr $I10, rxscan814_loop
    rx810_cur."!mark_push"(0, rx810_pos, $I10)
  rxscan814_done:
.annotate 'line', 379
    rx810_cur."!cursor_pos"(rx810_pos)
    new $P815, "String"
    assign $P815, ""
    store_lex "$*MULTINESS", $P815
.annotate 'line', 380
  # rx subrule "declarator" subtype=capture negate=
    rx810_cur."!cursor_pos"(rx810_pos)
    $P10 = rx810_cur."declarator"()
    unless $P10, rx810_fail
    rx810_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx810_pos = $P10."pos"()
.annotate 'line', 378
  # rx pass
    rx810_cur."!cursor_pass"(rx810_pos, "multi_declarator:sym<null>")
    if_null rx810_debug, debug_734
    rx810_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx810_pos)
  debug_734:
    .return (rx810_cur)
  rx810_restart:
.annotate 'line', 4
    if_null rx810_debug, debug_735
    rx810_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_735:
  rx810_fail:
    (rx810_rep, rx810_pos, $I10, $P10) = rx810_cur."!mark_fail"(0)
    lt rx810_pos, -1, rx810_done
    eq rx810_pos, -1, rx810_fail
    jump $I10
  rx810_done:
    rx810_cur."!cursor_fail"()
    if_null rx810_debug, debug_736
    rx810_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_736:
    .return (rx810_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("182_1295307698.031") :method
.annotate 'line', 4
    $P812 = self."!PREFIX__!subrule"("declarator", "")
    new $P813, "ResizablePMCArray"
    push $P813, $P812
    .return ($P813)
.end


.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("183_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .const 'Sub' $P825 = "185_1295307698.031" 
    capture_lex $P825
    .local string rx817_tgt
    .local int rx817_pos
    .local int rx817_off
    .local int rx817_eos
    .local int rx817_rep
    .local pmc rx817_cur
    .local pmc rx817_debug
    (rx817_cur, rx817_pos, rx817_tgt, $I10) = self."!cursor_start"()
    rx817_cur."!cursor_caparray"("invocant", "parameter")
    getattribute rx817_debug, rx817_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx817_cur
    .local pmc match
    .lex "$/", match
    length rx817_eos, rx817_tgt
    gt rx817_pos, rx817_eos, rx817_done
    set rx817_off, 0
    lt rx817_pos, 2, rx817_start
    sub rx817_off, rx817_pos, 1
    substr rx817_tgt, rx817_tgt, rx817_off
  rx817_start:
    eq $I10, 1, rx817_restart
    if_null rx817_debug, debug_737
    rx817_cur."!cursor_debug"("START", "signature")
  debug_737:
    $I10 = self.'from'()
    ne $I10, -1, rxscan820_done
    goto rxscan820_scan
  rxscan820_loop:
    ($P10) = rx817_cur."from"()
    inc $P10
    set rx817_pos, $P10
    ge rx817_pos, rx817_eos, rxscan820_done
  rxscan820_scan:
    set_addr $I10, rxscan820_loop
    rx817_cur."!mark_push"(0, rx817_pos, $I10)
  rxscan820_done:
.annotate 'line', 384
  # rx rxquantr821 ** 0..1
    set_addr $I10, rxquantr821_done
    rx817_cur."!mark_push"(0, rx817_pos, $I10)
  rxquantr821_loop:
    rx817_cur."!cursor_pos"(rx817_pos)
    find_lex $P822, unicode:"$\x{a2}"
    $P823 = $P822."MATCH"()
    store_lex "$/", $P823
    .const 'Sub' $P825 = "185_1295307698.031" 
    capture_lex $P825
    $P827 = $P825()
    unless $P827, rx817_fail
  # rx subrule "ws" subtype=method negate=
    rx817_cur."!cursor_pos"(rx817_pos)
    $P10 = rx817_cur."ws"()
    unless $P10, rx817_fail
    rx817_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx817_cur."!cursor_pos"(rx817_pos)
    $P10 = rx817_cur."parameter"()
    unless $P10, rx817_fail
    rx817_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx817_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx817_cur."!cursor_pos"(rx817_pos)
    $P10 = rx817_cur."ws"()
    unless $P10, rx817_fail
    rx817_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx817_pos, 1
    gt $I11, rx817_eos, rx817_fail
    sub $I11, rx817_pos, rx817_off
    ord $I11, rx817_tgt, $I11
    ne $I11, 58, rx817_fail
    add rx817_pos, 1
    set_addr $I10, rxquantr821_done
    (rx817_rep) = rx817_cur."!mark_commit"($I10)
  rxquantr821_done:
.annotate 'line', 385
  # rx rxquantr828 ** 0..1
    set_addr $I10, rxquantr828_done
    rx817_cur."!mark_push"(0, rx817_pos, $I10)
  rxquantr828_loop:
  # rx rxquantr829 ** 1..*
    set_addr $I10, rxquantr829_done
    rx817_cur."!mark_push"(0, -1, $I10)
  rxquantr829_loop:
  # rx subrule "ws" subtype=method negate=
    rx817_cur."!cursor_pos"(rx817_pos)
    $P10 = rx817_cur."ws"()
    unless $P10, rx817_fail
    rx817_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx817_cur."!cursor_pos"(rx817_pos)
    $P10 = rx817_cur."parameter"()
    unless $P10, rx817_fail
    rx817_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx817_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx817_cur."!cursor_pos"(rx817_pos)
    $P10 = rx817_cur."ws"()
    unless $P10, rx817_fail
    rx817_pos = $P10."pos"()
    set_addr $I10, rxquantr829_done
    (rx817_rep) = rx817_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr829_done
    rx817_cur."!mark_push"(rx817_rep, rx817_pos, $I10)
  # rx literal  ","
    add $I11, rx817_pos, 1
    gt $I11, rx817_eos, rx817_fail
    sub $I11, rx817_pos, rx817_off
    ord $I11, rx817_tgt, $I11
    ne $I11, 44, rx817_fail
    add rx817_pos, 1
    goto rxquantr829_loop
  rxquantr829_done:
    set_addr $I10, rxquantr828_done
    (rx817_rep) = rx817_cur."!mark_commit"($I10)
  rxquantr828_done:
.annotate 'line', 383
  # rx pass
    rx817_cur."!cursor_pass"(rx817_pos, "signature")
    if_null rx817_debug, debug_740
    rx817_cur."!cursor_debug"("PASS", "signature", " at pos=", rx817_pos)
  debug_740:
    .return (rx817_cur)
  rx817_restart:
.annotate 'line', 4
    if_null rx817_debug, debug_741
    rx817_cur."!cursor_debug"("NEXT", "signature")
  debug_741:
  rx817_fail:
    (rx817_rep, rx817_pos, $I10, $P10) = rx817_cur."!mark_fail"(0)
    lt rx817_pos, -1, rx817_done
    eq rx817_pos, -1, rx817_fail
    jump $I10
  rx817_done:
    rx817_cur."!cursor_fail"()
    if_null rx817_debug, debug_742
    rx817_cur."!cursor_debug"("FAIL", "signature")
  debug_742:
    .return (rx817_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("184_1295307698.031") :method
.annotate 'line', 4
    new $P819, "ResizablePMCArray"
    push $P819, ""
    .return ($P819)
.end


.namespace ["NQP";"Grammar"]
.sub "_block824"  :anon :subid("185_1295307698.031") :outer("183_1295307698.031")
.annotate 'line', 384
    find_dynamic_lex $P826, "$*INVOCANT_OK"
    unless_null $P826, vivify_738
    get_hll_global $P826, "$INVOCANT_OK"
    unless_null $P826, vivify_739
    die "Contextual $*INVOCANT_OK not found"
  vivify_739:
  vivify_738:
    .return ($P826)
.end


.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("186_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx831_tgt
    .local int rx831_pos
    .local int rx831_off
    .local int rx831_eos
    .local int rx831_rep
    .local pmc rx831_cur
    .local pmc rx831_debug
    (rx831_cur, rx831_pos, rx831_tgt, $I10) = self."!cursor_start"()
    rx831_cur."!cursor_caparray"("typename", "definedness", "default_value")
    getattribute rx831_debug, rx831_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx831_cur
    .local pmc match
    .lex "$/", match
    length rx831_eos, rx831_tgt
    gt rx831_pos, rx831_eos, rx831_done
    set rx831_off, 0
    lt rx831_pos, 2, rx831_start
    sub rx831_off, rx831_pos, 1
    substr rx831_tgt, rx831_tgt, rx831_off
  rx831_start:
    eq $I10, 1, rx831_restart
    if_null rx831_debug, debug_743
    rx831_cur."!cursor_debug"("START", "parameter")
  debug_743:
    $I10 = self.'from'()
    ne $I10, -1, rxscan834_done
    goto rxscan834_scan
  rxscan834_loop:
    ($P10) = rx831_cur."from"()
    inc $P10
    set rx831_pos, $P10
    ge rx831_pos, rx831_eos, rxscan834_done
  rxscan834_scan:
    set_addr $I10, rxscan834_loop
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  rxscan834_done:
.annotate 'line', 389
  # rx rxquantr835 ** 0..*
    set_addr $I10, rxquantr835_done
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  rxquantr835_loop:
  # rx subrule "typename" subtype=capture negate=
    rx831_cur."!cursor_pos"(rx831_pos)
    $P10 = rx831_cur."typename"()
    unless $P10, rx831_fail
    rx831_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx831_pos = $P10."pos"()
  # rx rxquantr836 ** 0..1
    set_addr $I10, rxquantr836_done
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  rxquantr836_loop:
  # rx literal  ":"
    add $I11, rx831_pos, 1
    gt $I11, rx831_eos, rx831_fail
    sub $I11, rx831_pos, rx831_off
    ord $I11, rx831_tgt, $I11
    ne $I11, 58, rx831_fail
    add rx831_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_837_fail
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx831_pos, rx831_eos, rx831_fail
    sub $I10, rx831_pos, rx831_off
    substr $S10, rx831_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx831_fail
    inc rx831_pos
    set_addr $I10, rxcap_837_fail
    ($I12, $I11) = rx831_cur."!mark_peek"($I10)
    rx831_cur."!cursor_pos"($I11)
    ($P10) = rx831_cur."!cursor_start"()
    $P10."!cursor_pass"(rx831_pos, "")
    rx831_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_837_done
  rxcap_837_fail:
    goto rx831_fail
  rxcap_837_done:
    set_addr $I10, rxquantr836_done
    (rx831_rep) = rx831_cur."!mark_commit"($I10)
  rxquantr836_done:
  # rx subrule "ws" subtype=method negate=
    rx831_cur."!cursor_pos"(rx831_pos)
    $P10 = rx831_cur."ws"()
    unless $P10, rx831_fail
    rx831_pos = $P10."pos"()
    set_addr $I10, rxquantr835_done
    (rx831_rep) = rx831_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr835_done
    rx831_cur."!mark_push"(rx831_rep, rx831_pos, $I10)
    goto rxquantr835_loop
  rxquantr835_done:
  alt838_0:
.annotate 'line', 390
    set_addr $I10, alt838_1
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
.annotate 'line', 391
  # rx subcapture "quant"
    set_addr $I10, rxcap_839_fail
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  # rx literal  "*"
    add $I11, rx831_pos, 1
    gt $I11, rx831_eos, rx831_fail
    sub $I11, rx831_pos, rx831_off
    ord $I11, rx831_tgt, $I11
    ne $I11, 42, rx831_fail
    add rx831_pos, 1
    set_addr $I10, rxcap_839_fail
    ($I12, $I11) = rx831_cur."!mark_peek"($I10)
    rx831_cur."!cursor_pos"($I11)
    ($P10) = rx831_cur."!cursor_start"()
    $P10."!cursor_pass"(rx831_pos, "")
    rx831_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_839_done
  rxcap_839_fail:
    goto rx831_fail
  rxcap_839_done:
  # rx subrule "param_var" subtype=capture negate=
    rx831_cur."!cursor_pos"(rx831_pos)
    $P10 = rx831_cur."param_var"()
    unless $P10, rx831_fail
    rx831_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx831_pos = $P10."pos"()
    goto alt838_end
  alt838_1:
  alt840_0:
.annotate 'line', 392
    set_addr $I10, alt840_1
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx831_cur."!cursor_pos"(rx831_pos)
    $P10 = rx831_cur."param_var"()
    unless $P10, rx831_fail
    rx831_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx831_pos = $P10."pos"()
    goto alt840_end
  alt840_1:
  # rx subrule "named_param" subtype=capture negate=
    rx831_cur."!cursor_pos"(rx831_pos)
    $P10 = rx831_cur."named_param"()
    unless $P10, rx831_fail
    rx831_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx831_pos = $P10."pos"()
  alt840_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_842_fail
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  alt841_0:
    set_addr $I10, alt841_1
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  # rx literal  "?"
    add $I11, rx831_pos, 1
    gt $I11, rx831_eos, rx831_fail
    sub $I11, rx831_pos, rx831_off
    ord $I11, rx831_tgt, $I11
    ne $I11, 63, rx831_fail
    add rx831_pos, 1
    goto alt841_end
  alt841_1:
    set_addr $I10, alt841_2
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  # rx literal  "!"
    add $I11, rx831_pos, 1
    gt $I11, rx831_eos, rx831_fail
    sub $I11, rx831_pos, rx831_off
    ord $I11, rx831_tgt, $I11
    ne $I11, 33, rx831_fail
    add rx831_pos, 1
    goto alt841_end
  alt841_2:
  alt841_end:
    set_addr $I10, rxcap_842_fail
    ($I12, $I11) = rx831_cur."!mark_peek"($I10)
    rx831_cur."!cursor_pos"($I11)
    ($P10) = rx831_cur."!cursor_start"()
    $P10."!cursor_pass"(rx831_pos, "")
    rx831_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_842_done
  rxcap_842_fail:
    goto rx831_fail
  rxcap_842_done:
  alt838_end:
.annotate 'line', 394
  # rx rxquantr843 ** 0..1
    set_addr $I10, rxquantr843_done
    rx831_cur."!mark_push"(0, rx831_pos, $I10)
  rxquantr843_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx831_cur."!cursor_pos"(rx831_pos)
    $P10 = rx831_cur."default_value"()
    unless $P10, rx831_fail
    goto rxsubrule844_pass
  rxsubrule844_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx831_fail
  rxsubrule844_pass:
    set_addr $I10, rxsubrule844_back
    rx831_cur."!mark_push"(0, rx831_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx831_pos = $P10."pos"()
    set_addr $I10, rxquantr843_done
    (rx831_rep) = rx831_cur."!mark_commit"($I10)
  rxquantr843_done:
.annotate 'line', 388
  # rx pass
    rx831_cur."!cursor_pass"(rx831_pos, "parameter")
    if_null rx831_debug, debug_744
    rx831_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx831_pos)
  debug_744:
    .return (rx831_cur)
  rx831_restart:
.annotate 'line', 4
    if_null rx831_debug, debug_745
    rx831_cur."!cursor_debug"("NEXT", "parameter")
  debug_745:
  rx831_fail:
    (rx831_rep, rx831_pos, $I10, $P10) = rx831_cur."!mark_fail"(0)
    lt rx831_pos, -1, rx831_done
    eq rx831_pos, -1, rx831_fail
    jump $I10
  rx831_done:
    rx831_cur."!cursor_fail"()
    if_null rx831_debug, debug_746
    rx831_cur."!cursor_debug"("FAIL", "parameter")
  debug_746:
    .return (rx831_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("187_1295307698.031") :method
.annotate 'line', 4
    new $P833, "ResizablePMCArray"
    push $P833, ""
    .return ($P833)
.end


.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("188_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx846_tgt
    .local int rx846_pos
    .local int rx846_off
    .local int rx846_eos
    .local int rx846_rep
    .local pmc rx846_cur
    .local pmc rx846_debug
    (rx846_cur, rx846_pos, rx846_tgt, $I10) = self."!cursor_start"()
    rx846_cur."!cursor_caparray"("twigil")
    getattribute rx846_debug, rx846_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx846_cur
    .local pmc match
    .lex "$/", match
    length rx846_eos, rx846_tgt
    gt rx846_pos, rx846_eos, rx846_done
    set rx846_off, 0
    lt rx846_pos, 2, rx846_start
    sub rx846_off, rx846_pos, 1
    substr rx846_tgt, rx846_tgt, rx846_off
  rx846_start:
    eq $I10, 1, rx846_restart
    if_null rx846_debug, debug_747
    rx846_cur."!cursor_debug"("START", "param_var")
  debug_747:
    $I10 = self.'from'()
    ne $I10, -1, rxscan850_done
    goto rxscan850_scan
  rxscan850_loop:
    ($P10) = rx846_cur."from"()
    inc $P10
    set rx846_pos, $P10
    ge rx846_pos, rx846_eos, rxscan850_done
  rxscan850_scan:
    set_addr $I10, rxscan850_loop
    rx846_cur."!mark_push"(0, rx846_pos, $I10)
  rxscan850_done:
.annotate 'line', 398
  # rx subrule "sigil" subtype=capture negate=
    rx846_cur."!cursor_pos"(rx846_pos)
    $P10 = rx846_cur."sigil"()
    unless $P10, rx846_fail
    rx846_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx846_pos = $P10."pos"()
  # rx rxquantr851 ** 0..1
    set_addr $I10, rxquantr851_done
    rx846_cur."!mark_push"(0, rx846_pos, $I10)
  rxquantr851_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx846_cur."!cursor_pos"(rx846_pos)
    $P10 = rx846_cur."twigil"()
    unless $P10, rx846_fail
    goto rxsubrule852_pass
  rxsubrule852_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx846_fail
  rxsubrule852_pass:
    set_addr $I10, rxsubrule852_back
    rx846_cur."!mark_push"(0, rx846_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx846_pos = $P10."pos"()
    set_addr $I10, rxquantr851_done
    (rx846_rep) = rx846_cur."!mark_commit"($I10)
  rxquantr851_done:
  alt853_0:
.annotate 'line', 399
    set_addr $I10, alt853_1
    rx846_cur."!mark_push"(0, rx846_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx846_cur."!cursor_pos"(rx846_pos)
    $P10 = rx846_cur."ident"()
    unless $P10, rx846_fail
    rx846_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx846_pos = $P10."pos"()
    goto alt853_end
  alt853_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_854_fail
    rx846_cur."!mark_push"(0, rx846_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx846_pos, rx846_eos, rx846_fail
    sub $I10, rx846_pos, rx846_off
    substr $S10, rx846_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx846_fail
    inc rx846_pos
    set_addr $I10, rxcap_854_fail
    ($I12, $I11) = rx846_cur."!mark_peek"($I10)
    rx846_cur."!cursor_pos"($I11)
    ($P10) = rx846_cur."!cursor_start"()
    $P10."!cursor_pass"(rx846_pos, "")
    rx846_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_854_done
  rxcap_854_fail:
    goto rx846_fail
  rxcap_854_done:
  alt853_end:
.annotate 'line', 397
  # rx pass
    rx846_cur."!cursor_pass"(rx846_pos, "param_var")
    if_null rx846_debug, debug_748
    rx846_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx846_pos)
  debug_748:
    .return (rx846_cur)
  rx846_restart:
.annotate 'line', 4
    if_null rx846_debug, debug_749
    rx846_cur."!cursor_debug"("NEXT", "param_var")
  debug_749:
  rx846_fail:
    (rx846_rep, rx846_pos, $I10, $P10) = rx846_cur."!mark_fail"(0)
    lt rx846_pos, -1, rx846_done
    eq rx846_pos, -1, rx846_fail
    jump $I10
  rx846_done:
    rx846_cur."!cursor_fail"()
    if_null rx846_debug, debug_750
    rx846_cur."!cursor_debug"("FAIL", "param_var")
  debug_750:
    .return (rx846_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("189_1295307698.031") :method
.annotate 'line', 4
    $P848 = self."!PREFIX__!subrule"("sigil", "")
    new $P849, "ResizablePMCArray"
    push $P849, $P848
    .return ($P849)
.end


.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("190_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx856_tgt
    .local int rx856_pos
    .local int rx856_off
    .local int rx856_eos
    .local int rx856_rep
    .local pmc rx856_cur
    .local pmc rx856_debug
    (rx856_cur, rx856_pos, rx856_tgt, $I10) = self."!cursor_start"()
    getattribute rx856_debug, rx856_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx856_cur
    .local pmc match
    .lex "$/", match
    length rx856_eos, rx856_tgt
    gt rx856_pos, rx856_eos, rx856_done
    set rx856_off, 0
    lt rx856_pos, 2, rx856_start
    sub rx856_off, rx856_pos, 1
    substr rx856_tgt, rx856_tgt, rx856_off
  rx856_start:
    eq $I10, 1, rx856_restart
    if_null rx856_debug, debug_751
    rx856_cur."!cursor_debug"("START", "named_param")
  debug_751:
    $I10 = self.'from'()
    ne $I10, -1, rxscan860_done
    goto rxscan860_scan
  rxscan860_loop:
    ($P10) = rx856_cur."from"()
    inc $P10
    set rx856_pos, $P10
    ge rx856_pos, rx856_eos, rxscan860_done
  rxscan860_scan:
    set_addr $I10, rxscan860_loop
    rx856_cur."!mark_push"(0, rx856_pos, $I10)
  rxscan860_done:
.annotate 'line', 403
  # rx literal  ":"
    add $I11, rx856_pos, 1
    gt $I11, rx856_eos, rx856_fail
    sub $I11, rx856_pos, rx856_off
    ord $I11, rx856_tgt, $I11
    ne $I11, 58, rx856_fail
    add rx856_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx856_cur."!cursor_pos"(rx856_pos)
    $P10 = rx856_cur."param_var"()
    unless $P10, rx856_fail
    rx856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx856_pos = $P10."pos"()
.annotate 'line', 402
  # rx pass
    rx856_cur."!cursor_pass"(rx856_pos, "named_param")
    if_null rx856_debug, debug_752
    rx856_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx856_pos)
  debug_752:
    .return (rx856_cur)
  rx856_restart:
.annotate 'line', 4
    if_null rx856_debug, debug_753
    rx856_cur."!cursor_debug"("NEXT", "named_param")
  debug_753:
  rx856_fail:
    (rx856_rep, rx856_pos, $I10, $P10) = rx856_cur."!mark_fail"(0)
    lt rx856_pos, -1, rx856_done
    eq rx856_pos, -1, rx856_fail
    jump $I10
  rx856_done:
    rx856_cur."!cursor_fail"()
    if_null rx856_debug, debug_754
    rx856_cur."!cursor_debug"("FAIL", "named_param")
  debug_754:
    .return (rx856_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("191_1295307698.031") :method
.annotate 'line', 4
    $P858 = self."!PREFIX__!subrule"("param_var", ":")
    new $P859, "ResizablePMCArray"
    push $P859, $P858
    .return ($P859)
.end


.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("192_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx862_tgt
    .local int rx862_pos
    .local int rx862_off
    .local int rx862_eos
    .local int rx862_rep
    .local pmc rx862_cur
    .local pmc rx862_debug
    (rx862_cur, rx862_pos, rx862_tgt, $I10) = self."!cursor_start"()
    getattribute rx862_debug, rx862_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx862_cur
    .local pmc match
    .lex "$/", match
    length rx862_eos, rx862_tgt
    gt rx862_pos, rx862_eos, rx862_done
    set rx862_off, 0
    lt rx862_pos, 2, rx862_start
    sub rx862_off, rx862_pos, 1
    substr rx862_tgt, rx862_tgt, rx862_off
  rx862_start:
    eq $I10, 1, rx862_restart
    if_null rx862_debug, debug_755
    rx862_cur."!cursor_debug"("START", "default_value")
  debug_755:
    $I10 = self.'from'()
    ne $I10, -1, rxscan866_done
    goto rxscan866_scan
  rxscan866_loop:
    ($P10) = rx862_cur."from"()
    inc $P10
    set rx862_pos, $P10
    ge rx862_pos, rx862_eos, rxscan866_done
  rxscan866_scan:
    set_addr $I10, rxscan866_loop
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  rxscan866_done:
.annotate 'line', 406
  # rx subrule "ws" subtype=method negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."ws"()
    unless $P10, rx862_fail
    rx862_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx862_pos, 1
    gt $I11, rx862_eos, rx862_fail
    sub $I11, rx862_pos, rx862_off
    ord $I11, rx862_tgt, $I11
    ne $I11, 61, rx862_fail
    add rx862_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."ws"()
    unless $P10, rx862_fail
    rx862_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."EXPR"("i=")
    unless $P10, rx862_fail
    rx862_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx862_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."ws"()
    unless $P10, rx862_fail
    rx862_pos = $P10."pos"()
  # rx pass
    rx862_cur."!cursor_pass"(rx862_pos, "default_value")
    if_null rx862_debug, debug_756
    rx862_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx862_pos)
  debug_756:
    .return (rx862_cur)
  rx862_restart:
.annotate 'line', 4
    if_null rx862_debug, debug_757
    rx862_cur."!cursor_debug"("NEXT", "default_value")
  debug_757:
  rx862_fail:
    (rx862_rep, rx862_pos, $I10, $P10) = rx862_cur."!mark_fail"(0)
    lt rx862_pos, -1, rx862_done
    eq rx862_pos, -1, rx862_fail
    jump $I10
  rx862_done:
    rx862_cur."!cursor_fail"()
    if_null rx862_debug, debug_758
    rx862_cur."!cursor_debug"("FAIL", "default_value")
  debug_758:
    .return (rx862_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("193_1295307698.031") :method
.annotate 'line', 4
    $P864 = self."!PREFIX__!subrule"("ws", "")
    new $P865, "ResizablePMCArray"
    push $P865, $P864
    .return ($P865)
.end


.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("194_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx871_tgt
    .local int rx871_pos
    .local int rx871_off
    .local int rx871_eos
    .local int rx871_rep
    .local pmc rx871_cur
    .local pmc rx871_debug
    (rx871_cur, rx871_pos, rx871_tgt, $I10) = self."!cursor_start"()
    getattribute rx871_debug, rx871_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx871_cur
    .local pmc match
    .lex "$/", match
    length rx871_eos, rx871_tgt
    gt rx871_pos, rx871_eos, rx871_done
    set rx871_off, 0
    lt rx871_pos, 2, rx871_start
    sub rx871_off, rx871_pos, 1
    substr rx871_tgt, rx871_tgt, rx871_off
  rx871_start:
    eq $I10, 1, rx871_restart
    if_null rx871_debug, debug_759
    rx871_cur."!cursor_debug"("START", "trait")
  debug_759:
    $I10 = self.'from'()
    ne $I10, -1, rxscan875_done
    goto rxscan875_scan
  rxscan875_loop:
    ($P10) = rx871_cur."from"()
    inc $P10
    set rx871_pos, $P10
    ge rx871_pos, rx871_eos, rxscan875_done
  rxscan875_scan:
    set_addr $I10, rxscan875_loop
    rx871_cur."!mark_push"(0, rx871_pos, $I10)
  rxscan875_done:
.annotate 'line', 408
  # rx subrule "ws" subtype=method negate=
    rx871_cur."!cursor_pos"(rx871_pos)
    $P10 = rx871_cur."ws"()
    unless $P10, rx871_fail
    rx871_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx871_cur."!cursor_pos"(rx871_pos)
    $P10 = rx871_cur."trait_mod"()
    unless $P10, rx871_fail
    rx871_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx871_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx871_cur."!cursor_pos"(rx871_pos)
    $P10 = rx871_cur."ws"()
    unless $P10, rx871_fail
    rx871_pos = $P10."pos"()
  # rx pass
    rx871_cur."!cursor_pass"(rx871_pos, "trait")
    if_null rx871_debug, debug_760
    rx871_cur."!cursor_debug"("PASS", "trait", " at pos=", rx871_pos)
  debug_760:
    .return (rx871_cur)
  rx871_restart:
.annotate 'line', 4
    if_null rx871_debug, debug_761
    rx871_cur."!cursor_debug"("NEXT", "trait")
  debug_761:
  rx871_fail:
    (rx871_rep, rx871_pos, $I10, $P10) = rx871_cur."!mark_fail"(0)
    lt rx871_pos, -1, rx871_done
    eq rx871_pos, -1, rx871_fail
    jump $I10
  rx871_done:
    rx871_cur."!cursor_fail"()
    if_null rx871_debug, debug_762
    rx871_cur."!cursor_debug"("FAIL", "trait")
  debug_762:
    .return (rx871_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("195_1295307698.031") :method
.annotate 'line', 4
    $P873 = self."!PREFIX__!subrule"("ws", "")
    new $P874, "ResizablePMCArray"
    push $P874, $P873
    .return ($P874)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("196_1295307698.031") :method
.annotate 'line', 410
    $P879 = self."!protoregex"("trait_mod")
    .return ($P879)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("197_1295307698.031") :method
.annotate 'line', 410
    $P881 = self."!PREFIX__!protoregex"("trait_mod")
    .return ($P881)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("198_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx883_tgt
    .local int rx883_pos
    .local int rx883_off
    .local int rx883_eos
    .local int rx883_rep
    .local pmc rx883_cur
    .local pmc rx883_debug
    (rx883_cur, rx883_pos, rx883_tgt, $I10) = self."!cursor_start"()
    rx883_cur."!cursor_caparray"("circumfix")
    getattribute rx883_debug, rx883_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx883_cur
    .local pmc match
    .lex "$/", match
    length rx883_eos, rx883_tgt
    gt rx883_pos, rx883_eos, rx883_done
    set rx883_off, 0
    lt rx883_pos, 2, rx883_start
    sub rx883_off, rx883_pos, 1
    substr rx883_tgt, rx883_tgt, rx883_off
  rx883_start:
    eq $I10, 1, rx883_restart
    if_null rx883_debug, debug_763
    rx883_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_763:
    $I10 = self.'from'()
    ne $I10, -1, rxscan887_done
    goto rxscan887_scan
  rxscan887_loop:
    ($P10) = rx883_cur."from"()
    inc $P10
    set rx883_pos, $P10
    ge rx883_pos, rx883_eos, rxscan887_done
  rxscan887_scan:
    set_addr $I10, rxscan887_loop
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  rxscan887_done:
.annotate 'line', 411
  # rx subcapture "sym"
    set_addr $I10, rxcap_888_fail
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  # rx literal  "is"
    add $I11, rx883_pos, 2
    gt $I11, rx883_eos, rx883_fail
    sub $I11, rx883_pos, rx883_off
    substr $S10, rx883_tgt, $I11, 2
    ne $S10, "is", rx883_fail
    add rx883_pos, 2
    set_addr $I10, rxcap_888_fail
    ($I12, $I11) = rx883_cur."!mark_peek"($I10)
    rx883_cur."!cursor_pos"($I11)
    ($P10) = rx883_cur."!cursor_start"()
    $P10."!cursor_pass"(rx883_pos, "")
    rx883_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_888_done
  rxcap_888_fail:
    goto rx883_fail
  rxcap_888_done:
  # rx subrule "ws" subtype=method negate=
    rx883_cur."!cursor_pos"(rx883_pos)
    $P10 = rx883_cur."ws"()
    unless $P10, rx883_fail
    rx883_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx883_cur."!cursor_pos"(rx883_pos)
    $P10 = rx883_cur."deflongname"()
    unless $P10, rx883_fail
    rx883_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx883_pos = $P10."pos"()
  # rx rxquantr890 ** 0..1
    set_addr $I10, rxquantr890_done
    rx883_cur."!mark_push"(0, rx883_pos, $I10)
  rxquantr890_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx883_cur."!cursor_pos"(rx883_pos)
    $P10 = rx883_cur."circumfix"()
    unless $P10, rx883_fail
    goto rxsubrule891_pass
  rxsubrule891_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx883_fail
  rxsubrule891_pass:
    set_addr $I10, rxsubrule891_back
    rx883_cur."!mark_push"(0, rx883_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx883_pos = $P10."pos"()
    set_addr $I10, rxquantr890_done
    (rx883_rep) = rx883_cur."!mark_commit"($I10)
  rxquantr890_done:
  # rx subrule "ws" subtype=method negate=
    rx883_cur."!cursor_pos"(rx883_pos)
    $P10 = rx883_cur."ws"()
    unless $P10, rx883_fail
    rx883_pos = $P10."pos"()
  # rx pass
    rx883_cur."!cursor_pass"(rx883_pos, "trait_mod:sym<is>")
    if_null rx883_debug, debug_764
    rx883_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx883_pos)
  debug_764:
    .return (rx883_cur)
  rx883_restart:
.annotate 'line', 4
    if_null rx883_debug, debug_765
    rx883_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_765:
  rx883_fail:
    (rx883_rep, rx883_pos, $I10, $P10) = rx883_cur."!mark_fail"(0)
    lt rx883_pos, -1, rx883_done
    eq rx883_pos, -1, rx883_fail
    jump $I10
  rx883_done:
    rx883_cur."!cursor_fail"()
    if_null rx883_debug, debug_766
    rx883_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_766:
    .return (rx883_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("199_1295307698.031") :method
.annotate 'line', 4
    $P885 = self."!PREFIX__!subrule"("ws", "is")
    new $P886, "ResizablePMCArray"
    push $P886, $P885
    .return ($P886)
.end


.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("200_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx894_tgt
    .local int rx894_pos
    .local int rx894_off
    .local int rx894_eos
    .local int rx894_rep
    .local pmc rx894_cur
    .local pmc rx894_debug
    (rx894_cur, rx894_pos, rx894_tgt, $I10) = self."!cursor_start"()
    rx894_cur."!cursor_caparray"("signature")
    getattribute rx894_debug, rx894_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx894_cur
    .local pmc match
    .lex "$/", match
    length rx894_eos, rx894_tgt
    gt rx894_pos, rx894_eos, rx894_done
    set rx894_off, 0
    lt rx894_pos, 2, rx894_start
    sub rx894_off, rx894_pos, 1
    substr rx894_tgt, rx894_tgt, rx894_off
  rx894_start:
    eq $I10, 1, rx894_restart
    if_null rx894_debug, debug_767
    rx894_cur."!cursor_debug"("START", "regex_declarator")
  debug_767:
    $I10 = self.'from'()
    ne $I10, -1, rxscan898_done
    goto rxscan898_scan
  rxscan898_loop:
    ($P10) = rx894_cur."from"()
    inc $P10
    set rx894_pos, $P10
    ge rx894_pos, rx894_eos, rxscan898_done
  rxscan898_scan:
    set_addr $I10, rxscan898_loop
    rx894_cur."!mark_push"(0, rx894_pos, $I10)
  rxscan898_done:
.annotate 'line', 413
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  alt900_0:
.annotate 'line', 414
    set_addr $I10, alt900_1
    rx894_cur."!mark_push"(0, rx894_pos, $I10)
.annotate 'line', 415
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_902_fail
    rx894_cur."!mark_push"(0, rx894_pos, $I10)
  # rx literal  "proto"
    add $I11, rx894_pos, 5
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    substr $S10, rx894_tgt, $I11, 5
    ne $S10, "proto", rx894_fail
    add rx894_pos, 5
    set_addr $I10, rxcap_902_fail
    ($I12, $I11) = rx894_cur."!mark_peek"($I10)
    rx894_cur."!cursor_pos"($I11)
    ($P10) = rx894_cur."!cursor_start"()
    $P10."!cursor_pass"(rx894_pos, "")
    rx894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_902_done
  rxcap_902_fail:
    goto rx894_fail
  rxcap_902_done:
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  alt904_0:
    set_addr $I10, alt904_1
    rx894_cur."!mark_push"(0, rx894_pos, $I10)
  # rx literal  "regex"
    add $I11, rx894_pos, 5
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    substr $S10, rx894_tgt, $I11, 5
    ne $S10, "regex", rx894_fail
    add rx894_pos, 5
    goto alt904_end
  alt904_1:
    set_addr $I10, alt904_2
    rx894_cur."!mark_push"(0, rx894_pos, $I10)
  # rx literal  "token"
    add $I11, rx894_pos, 5
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    substr $S10, rx894_tgt, $I11, 5
    ne $S10, "token", rx894_fail
    add rx894_pos, 5
    goto alt904_end
  alt904_2:
  # rx literal  "rule"
    add $I11, rx894_pos, 4
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    substr $S10, rx894_tgt, $I11, 4
    ne $S10, "rule", rx894_fail
    add rx894_pos, 4
  alt904_end:
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
.annotate 'line', 416
  # rx subrule "deflongname" subtype=capture negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."deflongname"()
    unless $P10, rx894_fail
    rx894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx894_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  alt907_0:
.annotate 'line', 417
    set_addr $I10, alt907_1
    rx894_cur."!mark_push"(0, rx894_pos, $I10)
.annotate 'line', 418
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx894_pos, 1
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    ord $I11, rx894_tgt, $I11
    ne $I11, 123, rx894_fail
    add rx894_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx894_pos, 5
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    substr $S10, rx894_tgt, $I11, 5
    ne $S10, "<...>", rx894_fail
    add rx894_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx894_pos, 1
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    ord $I11, rx894_tgt, $I11
    ne $I11, 125, rx894_fail
    add rx894_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ENDSTMT"()
    unless $P10, rx894_fail
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
    goto alt907_end
  alt907_1:
.annotate 'line', 419
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."panic"("Proto regex body must be <...>")
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  alt907_end:
.annotate 'line', 420
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
.annotate 'line', 415
    goto alt900_end
  alt900_1:
.annotate 'line', 421
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_917_fail
    rx894_cur."!mark_push"(0, rx894_pos, $I10)
  alt916_0:
    set_addr $I10, alt916_1
    rx894_cur."!mark_push"(0, rx894_pos, $I10)
  # rx literal  "regex"
    add $I11, rx894_pos, 5
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    substr $S10, rx894_tgt, $I11, 5
    ne $S10, "regex", rx894_fail
    add rx894_pos, 5
    goto alt916_end
  alt916_1:
    set_addr $I10, alt916_2
    rx894_cur."!mark_push"(0, rx894_pos, $I10)
  # rx literal  "token"
    add $I11, rx894_pos, 5
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    substr $S10, rx894_tgt, $I11, 5
    ne $S10, "token", rx894_fail
    add rx894_pos, 5
    goto alt916_end
  alt916_2:
  # rx literal  "rule"
    add $I11, rx894_pos, 4
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    substr $S10, rx894_tgt, $I11, 4
    ne $S10, "rule", rx894_fail
    add rx894_pos, 4
  alt916_end:
    set_addr $I10, rxcap_917_fail
    ($I12, $I11) = rx894_cur."!mark_peek"($I10)
    rx894_cur."!cursor_pos"($I11)
    ($P10) = rx894_cur."!cursor_start"()
    $P10."!cursor_pass"(rx894_pos, "")
    rx894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_917_done
  rxcap_917_fail:
    goto rx894_fail
  rxcap_917_done:
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
.annotate 'line', 422
  # rx subrule "deflongname" subtype=capture negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."deflongname"()
    unless $P10, rx894_fail
    rx894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx894_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
.annotate 'line', 423
  # rx subrule "newpad" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."newpad"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
.annotate 'line', 424
  # rx rxquantr921 ** 0..1
    set_addr $I10, rxquantr921_done
    rx894_cur."!mark_push"(0, rx894_pos, $I10)
  rxquantr921_loop:
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx894_pos, 1
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    ord $I11, rx894_tgt, $I11
    ne $I11, 40, rx894_fail
    add rx894_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."signature"()
    unless $P10, rx894_fail
    rx894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx894_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx894_pos, 1
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    ord $I11, rx894_tgt, $I11
    ne $I11, 41, rx894_fail
    add rx894_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
    set_addr $I10, rxquantr921_done
    (rx894_rep) = rx894_cur."!mark_commit"($I10)
  rxquantr921_done:
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
.annotate 'line', 425
  # rx reduce name="regex_declarator" key="open"
    rx894_cur."!cursor_pos"(rx894_pos)
    rx894_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
.annotate 'line', 426
  # rx literal  "{"
    add $I11, rx894_pos, 1
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    ord $I11, rx894_tgt, $I11
    ne $I11, 123, rx894_fail
    add rx894_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."LANG"("Regex", "nibbler")
    unless $P10, rx894_fail
    rx894_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx894_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx894_pos, 1
    gt $I11, rx894_eos, rx894_fail
    sub $I11, rx894_pos, rx894_off
    ord $I11, rx894_tgt, $I11
    ne $I11, 125, rx894_fail
    add rx894_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ENDSTMT"()
    unless $P10, rx894_fail
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
  alt900_end:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx894_cur."!cursor_pos"(rx894_pos)
    $P10 = rx894_cur."ws"()
    unless $P10, rx894_fail
    rx894_pos = $P10."pos"()
.annotate 'line', 413
  # rx pass
    rx894_cur."!cursor_pass"(rx894_pos, "regex_declarator")
    if_null rx894_debug, debug_768
    rx894_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx894_pos)
  debug_768:
    .return (rx894_cur)
  rx894_restart:
.annotate 'line', 4
    if_null rx894_debug, debug_769
    rx894_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_769:
  rx894_fail:
    (rx894_rep, rx894_pos, $I10, $P10) = rx894_cur."!mark_fail"(0)
    lt rx894_pos, -1, rx894_done
    eq rx894_pos, -1, rx894_fail
    jump $I10
  rx894_done:
    rx894_cur."!cursor_fail"()
    if_null rx894_debug, debug_770
    rx894_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_770:
    .return (rx894_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("201_1295307698.031") :method
.annotate 'line', 4
    $P896 = self."!PREFIX__!subrule"("ws", "")
    new $P897, "ResizablePMCArray"
    push $P897, $P896
    .return ($P897)
.end


.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("202_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx931_tgt
    .local int rx931_pos
    .local int rx931_off
    .local int rx931_eos
    .local int rx931_rep
    .local pmc rx931_cur
    .local pmc rx931_debug
    (rx931_cur, rx931_pos, rx931_tgt, $I10) = self."!cursor_start"()
    rx931_cur."!cursor_caparray"("args")
    getattribute rx931_debug, rx931_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx931_cur
    .local pmc match
    .lex "$/", match
    length rx931_eos, rx931_tgt
    gt rx931_pos, rx931_eos, rx931_done
    set rx931_off, 0
    lt rx931_pos, 2, rx931_start
    sub rx931_off, rx931_pos, 1
    substr rx931_tgt, rx931_tgt, rx931_off
  rx931_start:
    eq $I10, 1, rx931_restart
    if_null rx931_debug, debug_771
    rx931_cur."!cursor_debug"("START", "dotty")
  debug_771:
    $I10 = self.'from'()
    ne $I10, -1, rxscan935_done
    goto rxscan935_scan
  rxscan935_loop:
    ($P10) = rx931_cur."from"()
    inc $P10
    set rx931_pos, $P10
    ge rx931_pos, rx931_eos, rxscan935_done
  rxscan935_scan:
    set_addr $I10, rxscan935_loop
    rx931_cur."!mark_push"(0, rx931_pos, $I10)
  rxscan935_done:
.annotate 'line', 431
  # rx literal  "."
    add $I11, rx931_pos, 1
    gt $I11, rx931_eos, rx931_fail
    sub $I11, rx931_pos, rx931_off
    ord $I11, rx931_tgt, $I11
    ne $I11, 46, rx931_fail
    add rx931_pos, 1
  alt936_0:
.annotate 'line', 432
    set_addr $I10, alt936_1
    rx931_cur."!mark_push"(0, rx931_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx931_cur."!cursor_pos"(rx931_pos)
    $P10 = rx931_cur."deflongname"()
    unless $P10, rx931_fail
    rx931_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx931_pos = $P10."pos"()
    goto alt936_end
  alt936_1:
.annotate 'line', 433
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx931_pos, rx931_off
    substr $S10, rx931_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx931_fail
  # rx subrule "quote" subtype=capture negate=
    rx931_cur."!cursor_pos"(rx931_pos)
    $P10 = rx931_cur."quote"()
    unless $P10, rx931_fail
    rx931_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx931_pos = $P10."pos"()
  alt937_0:
.annotate 'line', 434
    set_addr $I10, alt937_1
    rx931_cur."!mark_push"(0, rx931_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx931_pos, rx931_off
    substr $S10, rx931_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx931_fail
    goto alt937_end
  alt937_1:
  # rx subrule "panic" subtype=method negate=
    rx931_cur."!cursor_pos"(rx931_pos)
    $P10 = rx931_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx931_fail
    rx931_pos = $P10."pos"()
  alt937_end:
  alt936_end:
.annotate 'line', 440
  # rx rxquantr938 ** 0..1
    set_addr $I10, rxquantr938_done
    rx931_cur."!mark_push"(0, rx931_pos, $I10)
  rxquantr938_loop:
  alt939_0:
.annotate 'line', 437
    set_addr $I10, alt939_1
    rx931_cur."!mark_push"(0, rx931_pos, $I10)
.annotate 'line', 438
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx931_pos, rx931_off
    substr $S10, rx931_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx931_fail
  # rx subrule "args" subtype=capture negate=
    rx931_cur."!cursor_pos"(rx931_pos)
    $P10 = rx931_cur."args"()
    unless $P10, rx931_fail
    rx931_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx931_pos = $P10."pos"()
    goto alt939_end
  alt939_1:
.annotate 'line', 439
  # rx literal  ":"
    add $I11, rx931_pos, 1
    gt $I11, rx931_eos, rx931_fail
    sub $I11, rx931_pos, rx931_off
    ord $I11, rx931_tgt, $I11
    ne $I11, 58, rx931_fail
    add rx931_pos, 1
  # rx charclass s
    ge rx931_pos, rx931_eos, rx931_fail
    sub $I10, rx931_pos, rx931_off
    is_cclass $I11, 32, rx931_tgt, $I10
    unless $I11, rx931_fail
    inc rx931_pos
  # rx subrule "arglist" subtype=capture negate=
    rx931_cur."!cursor_pos"(rx931_pos)
    $P10 = rx931_cur."arglist"()
    unless $P10, rx931_fail
    rx931_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx931_pos = $P10."pos"()
  alt939_end:
.annotate 'line', 440
    set_addr $I10, rxquantr938_done
    (rx931_rep) = rx931_cur."!mark_commit"($I10)
  rxquantr938_done:
.annotate 'line', 430
  # rx pass
    rx931_cur."!cursor_pass"(rx931_pos, "dotty")
    if_null rx931_debug, debug_772
    rx931_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx931_pos)
  debug_772:
    .return (rx931_cur)
  rx931_restart:
.annotate 'line', 4
    if_null rx931_debug, debug_773
    rx931_cur."!cursor_debug"("NEXT", "dotty")
  debug_773:
  rx931_fail:
    (rx931_rep, rx931_pos, $I10, $P10) = rx931_cur."!mark_fail"(0)
    lt rx931_pos, -1, rx931_done
    eq rx931_pos, -1, rx931_fail
    jump $I10
  rx931_done:
    rx931_cur."!cursor_fail"()
    if_null rx931_debug, debug_774
    rx931_cur."!cursor_debug"("FAIL", "dotty")
  debug_774:
    .return (rx931_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("203_1295307698.031") :method
.annotate 'line', 4
    $P933 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P934, "ResizablePMCArray"
    push $P934, "'"
    push $P934, "\""
    push $P934, $P933
    .return ($P934)
.end


.namespace ["NQP";"Grammar"]
.sub "term"  :subid("204_1295307698.031") :method
.annotate 'line', 444
    $P941 = self."!protoregex"("term")
    .return ($P941)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("205_1295307698.031") :method
.annotate 'line', 444
    $P943 = self."!PREFIX__!protoregex"("term")
    .return ($P943)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("206_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx945_tgt
    .local int rx945_pos
    .local int rx945_off
    .local int rx945_eos
    .local int rx945_rep
    .local pmc rx945_cur
    .local pmc rx945_debug
    (rx945_cur, rx945_pos, rx945_tgt, $I10) = self."!cursor_start"()
    getattribute rx945_debug, rx945_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx945_cur
    .local pmc match
    .lex "$/", match
    length rx945_eos, rx945_tgt
    gt rx945_pos, rx945_eos, rx945_done
    set rx945_off, 0
    lt rx945_pos, 2, rx945_start
    sub rx945_off, rx945_pos, 1
    substr rx945_tgt, rx945_tgt, rx945_off
  rx945_start:
    eq $I10, 1, rx945_restart
    if_null rx945_debug, debug_775
    rx945_cur."!cursor_debug"("START", "term:sym<self>")
  debug_775:
    $I10 = self.'from'()
    ne $I10, -1, rxscan948_done
    goto rxscan948_scan
  rxscan948_loop:
    ($P10) = rx945_cur."from"()
    inc $P10
    set rx945_pos, $P10
    ge rx945_pos, rx945_eos, rxscan948_done
  rxscan948_scan:
    set_addr $I10, rxscan948_loop
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  rxscan948_done:
.annotate 'line', 446
  # rx subcapture "sym"
    set_addr $I10, rxcap_949_fail
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  # rx literal  "self"
    add $I11, rx945_pos, 4
    gt $I11, rx945_eos, rx945_fail
    sub $I11, rx945_pos, rx945_off
    substr $S10, rx945_tgt, $I11, 4
    ne $S10, "self", rx945_fail
    add rx945_pos, 4
    set_addr $I10, rxcap_949_fail
    ($I12, $I11) = rx945_cur."!mark_peek"($I10)
    rx945_cur."!cursor_pos"($I11)
    ($P10) = rx945_cur."!cursor_start"()
    $P10."!cursor_pass"(rx945_pos, "")
    rx945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_949_done
  rxcap_949_fail:
    goto rx945_fail
  rxcap_949_done:
  # rxanchor rwb
    le rx945_pos, 0, rx945_fail
    sub $I10, rx945_pos, rx945_off
    is_cclass $I11, 8192, rx945_tgt, $I10
    if $I11, rx945_fail
    dec $I10
    is_cclass $I11, 8192, rx945_tgt, $I10
    unless $I11, rx945_fail
  # rx pass
    rx945_cur."!cursor_pass"(rx945_pos, "term:sym<self>")
    if_null rx945_debug, debug_776
    rx945_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx945_pos)
  debug_776:
    .return (rx945_cur)
  rx945_restart:
.annotate 'line', 4
    if_null rx945_debug, debug_777
    rx945_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_777:
  rx945_fail:
    (rx945_rep, rx945_pos, $I10, $P10) = rx945_cur."!mark_fail"(0)
    lt rx945_pos, -1, rx945_done
    eq rx945_pos, -1, rx945_fail
    jump $I10
  rx945_done:
    rx945_cur."!cursor_fail"()
    if_null rx945_debug, debug_778
    rx945_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_778:
    .return (rx945_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("207_1295307698.031") :method
.annotate 'line', 4
    new $P947, "ResizablePMCArray"
    push $P947, "self"
    .return ($P947)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("208_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx951_tgt
    .local int rx951_pos
    .local int rx951_off
    .local int rx951_eos
    .local int rx951_rep
    .local pmc rx951_cur
    .local pmc rx951_debug
    (rx951_cur, rx951_pos, rx951_tgt, $I10) = self."!cursor_start"()
    getattribute rx951_debug, rx951_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx951_cur
    .local pmc match
    .lex "$/", match
    length rx951_eos, rx951_tgt
    gt rx951_pos, rx951_eos, rx951_done
    set rx951_off, 0
    lt rx951_pos, 2, rx951_start
    sub rx951_off, rx951_pos, 1
    substr rx951_tgt, rx951_tgt, rx951_off
  rx951_start:
    eq $I10, 1, rx951_restart
    if_null rx951_debug, debug_779
    rx951_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_779:
    $I10 = self.'from'()
    ne $I10, -1, rxscan955_done
    goto rxscan955_scan
  rxscan955_loop:
    ($P10) = rx951_cur."from"()
    inc $P10
    set rx951_pos, $P10
    ge rx951_pos, rx951_eos, rxscan955_done
  rxscan955_scan:
    set_addr $I10, rxscan955_loop
    rx951_cur."!mark_push"(0, rx951_pos, $I10)
  rxscan955_done:
.annotate 'line', 449
  # rx subrule "deflongname" subtype=capture negate=
    rx951_cur."!cursor_pos"(rx951_pos)
    $P10 = rx951_cur."deflongname"()
    unless $P10, rx951_fail
    rx951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx951_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx951_pos, rx951_off
    substr $S10, rx951_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx951_fail
  # rx subrule "args" subtype=capture negate=
    rx951_cur."!cursor_pos"(rx951_pos)
    $P10 = rx951_cur."args"()
    unless $P10, rx951_fail
    rx951_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx951_pos = $P10."pos"()
.annotate 'line', 448
  # rx pass
    rx951_cur."!cursor_pass"(rx951_pos, "term:sym<identifier>")
    if_null rx951_debug, debug_780
    rx951_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx951_pos)
  debug_780:
    .return (rx951_cur)
  rx951_restart:
.annotate 'line', 4
    if_null rx951_debug, debug_781
    rx951_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_781:
  rx951_fail:
    (rx951_rep, rx951_pos, $I10, $P10) = rx951_cur."!mark_fail"(0)
    lt rx951_pos, -1, rx951_done
    eq rx951_pos, -1, rx951_fail
    jump $I10
  rx951_done:
    rx951_cur."!cursor_fail"()
    if_null rx951_debug, debug_782
    rx951_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_782:
    .return (rx951_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("209_1295307698.031") :method
.annotate 'line', 4
    $P953 = self."!PREFIX__!subrule"("deflongname", "")
    new $P954, "ResizablePMCArray"
    push $P954, $P953
    .return ($P954)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("210_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx957_tgt
    .local int rx957_pos
    .local int rx957_off
    .local int rx957_eos
    .local int rx957_rep
    .local pmc rx957_cur
    .local pmc rx957_debug
    (rx957_cur, rx957_pos, rx957_tgt, $I10) = self."!cursor_start"()
    rx957_cur."!cursor_caparray"("args")
    getattribute rx957_debug, rx957_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx957_cur
    .local pmc match
    .lex "$/", match
    length rx957_eos, rx957_tgt
    gt rx957_pos, rx957_eos, rx957_done
    set rx957_off, 0
    lt rx957_pos, 2, rx957_start
    sub rx957_off, rx957_pos, 1
    substr rx957_tgt, rx957_tgt, rx957_off
  rx957_start:
    eq $I10, 1, rx957_restart
    if_null rx957_debug, debug_783
    rx957_cur."!cursor_debug"("START", "term:sym<name>")
  debug_783:
    $I10 = self.'from'()
    ne $I10, -1, rxscan961_done
    goto rxscan961_scan
  rxscan961_loop:
    ($P10) = rx957_cur."from"()
    inc $P10
    set rx957_pos, $P10
    ge rx957_pos, rx957_eos, rxscan961_done
  rxscan961_scan:
    set_addr $I10, rxscan961_loop
    rx957_cur."!mark_push"(0, rx957_pos, $I10)
  rxscan961_done:
.annotate 'line', 453
  # rx subrule "name" subtype=capture negate=
    rx957_cur."!cursor_pos"(rx957_pos)
    $P10 = rx957_cur."name"()
    unless $P10, rx957_fail
    rx957_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx957_pos = $P10."pos"()
  # rx rxquantr962 ** 0..1
    set_addr $I10, rxquantr962_done
    rx957_cur."!mark_push"(0, rx957_pos, $I10)
  rxquantr962_loop:
  # rx subrule "args" subtype=capture negate=
    rx957_cur."!cursor_pos"(rx957_pos)
    $P10 = rx957_cur."args"()
    unless $P10, rx957_fail
    goto rxsubrule963_pass
  rxsubrule963_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx957_fail
  rxsubrule963_pass:
    set_addr $I10, rxsubrule963_back
    rx957_cur."!mark_push"(0, rx957_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx957_pos = $P10."pos"()
    set_addr $I10, rxquantr962_done
    (rx957_rep) = rx957_cur."!mark_commit"($I10)
  rxquantr962_done:
.annotate 'line', 452
  # rx pass
    rx957_cur."!cursor_pass"(rx957_pos, "term:sym<name>")
    if_null rx957_debug, debug_784
    rx957_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx957_pos)
  debug_784:
    .return (rx957_cur)
  rx957_restart:
.annotate 'line', 4
    if_null rx957_debug, debug_785
    rx957_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_785:
  rx957_fail:
    (rx957_rep, rx957_pos, $I10, $P10) = rx957_cur."!mark_fail"(0)
    lt rx957_pos, -1, rx957_done
    eq rx957_pos, -1, rx957_fail
    jump $I10
  rx957_done:
    rx957_cur."!cursor_fail"()
    if_null rx957_debug, debug_786
    rx957_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_786:
    .return (rx957_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("211_1295307698.031") :method
.annotate 'line', 4
    $P959 = self."!PREFIX__!subrule"("name", "")
    new $P960, "ResizablePMCArray"
    push $P960, $P959
    .return ($P960)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("212_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx965_tgt
    .local int rx965_pos
    .local int rx965_off
    .local int rx965_eos
    .local int rx965_rep
    .local pmc rx965_cur
    .local pmc rx965_debug
    (rx965_cur, rx965_pos, rx965_tgt, $I10) = self."!cursor_start"()
    rx965_cur."!cursor_caparray"("args")
    getattribute rx965_debug, rx965_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx965_cur
    .local pmc match
    .lex "$/", match
    length rx965_eos, rx965_tgt
    gt rx965_pos, rx965_eos, rx965_done
    set rx965_off, 0
    lt rx965_pos, 2, rx965_start
    sub rx965_off, rx965_pos, 1
    substr rx965_tgt, rx965_tgt, rx965_off
  rx965_start:
    eq $I10, 1, rx965_restart
    if_null rx965_debug, debug_787
    rx965_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_787:
    $I10 = self.'from'()
    ne $I10, -1, rxscan968_done
    goto rxscan968_scan
  rxscan968_loop:
    ($P10) = rx965_cur."from"()
    inc $P10
    set rx965_pos, $P10
    ge rx965_pos, rx965_eos, rxscan968_done
  rxscan968_scan:
    set_addr $I10, rxscan968_loop
    rx965_cur."!mark_push"(0, rx965_pos, $I10)
  rxscan968_done:
.annotate 'line', 457
  # rx literal  "pir::"
    add $I11, rx965_pos, 5
    gt $I11, rx965_eos, rx965_fail
    sub $I11, rx965_pos, rx965_off
    substr $S10, rx965_tgt, $I11, 5
    ne $S10, "pir::", rx965_fail
    add rx965_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_969_fail
    rx965_cur."!mark_push"(0, rx965_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx965_pos, rx965_off
    find_not_cclass $I11, 8192, rx965_tgt, $I10, rx965_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx965_fail
    add rx965_pos, rx965_off, $I11
    set_addr $I10, rxcap_969_fail
    ($I12, $I11) = rx965_cur."!mark_peek"($I10)
    rx965_cur."!cursor_pos"($I11)
    ($P10) = rx965_cur."!cursor_start"()
    $P10."!cursor_pass"(rx965_pos, "")
    rx965_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_969_done
  rxcap_969_fail:
    goto rx965_fail
  rxcap_969_done:
  # rx rxquantr970 ** 0..1
    set_addr $I10, rxquantr970_done
    rx965_cur."!mark_push"(0, rx965_pos, $I10)
  rxquantr970_loop:
  # rx subrule "args" subtype=capture negate=
    rx965_cur."!cursor_pos"(rx965_pos)
    $P10 = rx965_cur."args"()
    unless $P10, rx965_fail
    goto rxsubrule971_pass
  rxsubrule971_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx965_fail
  rxsubrule971_pass:
    set_addr $I10, rxsubrule971_back
    rx965_cur."!mark_push"(0, rx965_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx965_pos = $P10."pos"()
    set_addr $I10, rxquantr970_done
    (rx965_rep) = rx965_cur."!mark_commit"($I10)
  rxquantr970_done:
.annotate 'line', 456
  # rx pass
    rx965_cur."!cursor_pass"(rx965_pos, "term:sym<pir::op>")
    if_null rx965_debug, debug_788
    rx965_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx965_pos)
  debug_788:
    .return (rx965_cur)
  rx965_restart:
.annotate 'line', 4
    if_null rx965_debug, debug_789
    rx965_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_789:
  rx965_fail:
    (rx965_rep, rx965_pos, $I10, $P10) = rx965_cur."!mark_fail"(0)
    lt rx965_pos, -1, rx965_done
    eq rx965_pos, -1, rx965_fail
    jump $I10
  rx965_done:
    rx965_cur."!cursor_fail"()
    if_null rx965_debug, debug_790
    rx965_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_790:
    .return (rx965_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("213_1295307698.031") :method
.annotate 'line', 4
    new $P967, "ResizablePMCArray"
    push $P967, "pir::"
    .return ($P967)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("214_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .const 'Sub' $P981 = "216_1295307698.031" 
    capture_lex $P981
    .local string rx973_tgt
    .local int rx973_pos
    .local int rx973_off
    .local int rx973_eos
    .local int rx973_rep
    .local pmc rx973_cur
    .local pmc rx973_debug
    (rx973_cur, rx973_pos, rx973_tgt, $I10) = self."!cursor_start"()
    getattribute rx973_debug, rx973_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx973_cur
    .local pmc match
    .lex "$/", match
    length rx973_eos, rx973_tgt
    gt rx973_pos, rx973_eos, rx973_done
    set rx973_off, 0
    lt rx973_pos, 2, rx973_start
    sub rx973_off, rx973_pos, 1
    substr rx973_tgt, rx973_tgt, rx973_off
  rx973_start:
    eq $I10, 1, rx973_restart
    if_null rx973_debug, debug_791
    rx973_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_791:
    $I10 = self.'from'()
    ne $I10, -1, rxscan976_done
    goto rxscan976_scan
  rxscan976_loop:
    ($P10) = rx973_cur."from"()
    inc $P10
    set rx973_pos, $P10
    ge rx973_pos, rx973_eos, rxscan976_done
  rxscan976_scan:
    set_addr $I10, rxscan976_loop
    rx973_cur."!mark_push"(0, rx973_pos, $I10)
  rxscan976_done:
.annotate 'line', 461
  # rx literal  "{*}"
    add $I11, rx973_pos, 3
    gt $I11, rx973_eos, rx973_fail
    sub $I11, rx973_pos, rx973_off
    substr $S10, rx973_tgt, $I11, 3
    ne $S10, "{*}", rx973_fail
    add rx973_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx973_cur."!cursor_pos"(rx973_pos)
    $P10 = rx973_cur."ENDSTMT"()
    unless $P10, rx973_fail
  alt977_0:
.annotate 'line', 462
    set_addr $I10, alt977_1
    rx973_cur."!mark_push"(0, rx973_pos, $I10)
    rx973_cur."!cursor_pos"(rx973_pos)
    find_lex $P978, unicode:"$\x{a2}"
    $P979 = $P978."MATCH"()
    store_lex "$/", $P979
    .const 'Sub' $P981 = "216_1295307698.031" 
    capture_lex $P981
    $P985 = $P981()
    unless $P985, rx973_fail
    goto alt977_end
  alt977_1:
  # rx subrule "panic" subtype=method negate=
    rx973_cur."!cursor_pos"(rx973_pos)
    $P10 = rx973_cur."panic"("{*} may only appear in proto")
    unless $P10, rx973_fail
    rx973_pos = $P10."pos"()
  alt977_end:
.annotate 'line', 460
  # rx pass
    rx973_cur."!cursor_pass"(rx973_pos, "term:sym<onlystar>")
    if_null rx973_debug, debug_794
    rx973_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx973_pos)
  debug_794:
    .return (rx973_cur)
  rx973_restart:
.annotate 'line', 4
    if_null rx973_debug, debug_795
    rx973_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_795:
  rx973_fail:
    (rx973_rep, rx973_pos, $I10, $P10) = rx973_cur."!mark_fail"(0)
    lt rx973_pos, -1, rx973_done
    eq rx973_pos, -1, rx973_fail
    jump $I10
  rx973_done:
    rx973_cur."!cursor_fail"()
    if_null rx973_debug, debug_796
    rx973_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_796:
    .return (rx973_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("215_1295307698.031") :method
.annotate 'line', 4
    new $P975, "ResizablePMCArray"
    push $P975, "{*}"
    .return ($P975)
.end


.namespace ["NQP";"Grammar"]
.sub "_block980"  :anon :subid("216_1295307698.031") :outer("214_1295307698.031")
.annotate 'line', 462
    find_dynamic_lex $P982, "$*MULTINESS"
    unless_null $P982, vivify_792
    get_hll_global $P982, "$MULTINESS"
    unless_null $P982, vivify_793
    die "Contextual $*MULTINESS not found"
  vivify_793:
  vivify_792:
    set $S983, $P982
    iseq $I984, $S983, "proto"
    .return ($I984)
.end


.namespace ["NQP";"Grammar"]
.sub "args"  :subid("217_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx987_tgt
    .local int rx987_pos
    .local int rx987_off
    .local int rx987_eos
    .local int rx987_rep
    .local pmc rx987_cur
    .local pmc rx987_debug
    (rx987_cur, rx987_pos, rx987_tgt, $I10) = self."!cursor_start"()
    getattribute rx987_debug, rx987_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx987_cur
    .local pmc match
    .lex "$/", match
    length rx987_eos, rx987_tgt
    gt rx987_pos, rx987_eos, rx987_done
    set rx987_off, 0
    lt rx987_pos, 2, rx987_start
    sub rx987_off, rx987_pos, 1
    substr rx987_tgt, rx987_tgt, rx987_off
  rx987_start:
    eq $I10, 1, rx987_restart
    if_null rx987_debug, debug_797
    rx987_cur."!cursor_debug"("START", "args")
  debug_797:
    $I10 = self.'from'()
    ne $I10, -1, rxscan991_done
    goto rxscan991_scan
  rxscan991_loop:
    ($P10) = rx987_cur."from"()
    inc $P10
    set rx987_pos, $P10
    ge rx987_pos, rx987_eos, rxscan991_done
  rxscan991_scan:
    set_addr $I10, rxscan991_loop
    rx987_cur."!mark_push"(0, rx987_pos, $I10)
  rxscan991_done:
.annotate 'line', 466
  # rx literal  "("
    add $I11, rx987_pos, 1
    gt $I11, rx987_eos, rx987_fail
    sub $I11, rx987_pos, rx987_off
    ord $I11, rx987_tgt, $I11
    ne $I11, 40, rx987_fail
    add rx987_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx987_cur."!cursor_pos"(rx987_pos)
    $P10 = rx987_cur."arglist"()
    unless $P10, rx987_fail
    rx987_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx987_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx987_pos, 1
    gt $I11, rx987_eos, rx987_fail
    sub $I11, rx987_pos, rx987_off
    ord $I11, rx987_tgt, $I11
    ne $I11, 41, rx987_fail
    add rx987_pos, 1
  # rx pass
    rx987_cur."!cursor_pass"(rx987_pos, "args")
    if_null rx987_debug, debug_798
    rx987_cur."!cursor_debug"("PASS", "args", " at pos=", rx987_pos)
  debug_798:
    .return (rx987_cur)
  rx987_restart:
.annotate 'line', 4
    if_null rx987_debug, debug_799
    rx987_cur."!cursor_debug"("NEXT", "args")
  debug_799:
  rx987_fail:
    (rx987_rep, rx987_pos, $I10, $P10) = rx987_cur."!mark_fail"(0)
    lt rx987_pos, -1, rx987_done
    eq rx987_pos, -1, rx987_fail
    jump $I10
  rx987_done:
    rx987_cur."!cursor_fail"()
    if_null rx987_debug, debug_800
    rx987_cur."!cursor_debug"("FAIL", "args")
  debug_800:
    .return (rx987_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("218_1295307698.031") :method
.annotate 'line', 4
    $P989 = self."!PREFIX__!subrule"("arglist", "(")
    new $P990, "ResizablePMCArray"
    push $P990, $P989
    .return ($P990)
.end


.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("219_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx993_tgt
    .local int rx993_pos
    .local int rx993_off
    .local int rx993_eos
    .local int rx993_rep
    .local pmc rx993_cur
    .local pmc rx993_debug
    (rx993_cur, rx993_pos, rx993_tgt, $I10) = self."!cursor_start"()
    getattribute rx993_debug, rx993_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx993_cur
    .local pmc match
    .lex "$/", match
    length rx993_eos, rx993_tgt
    gt rx993_pos, rx993_eos, rx993_done
    set rx993_off, 0
    lt rx993_pos, 2, rx993_start
    sub rx993_off, rx993_pos, 1
    substr rx993_tgt, rx993_tgt, rx993_off
  rx993_start:
    eq $I10, 1, rx993_restart
    if_null rx993_debug, debug_801
    rx993_cur."!cursor_debug"("START", "arglist")
  debug_801:
    $I10 = self.'from'()
    ne $I10, -1, rxscan997_done
    goto rxscan997_scan
  rxscan997_loop:
    ($P10) = rx993_cur."from"()
    inc $P10
    set rx993_pos, $P10
    ge rx993_pos, rx993_eos, rxscan997_done
  rxscan997_scan:
    set_addr $I10, rxscan997_loop
    rx993_cur."!mark_push"(0, rx993_pos, $I10)
  rxscan997_done:
.annotate 'line', 470
  # rx subrule "ws" subtype=method negate=
    rx993_cur."!cursor_pos"(rx993_pos)
    $P10 = rx993_cur."ws"()
    unless $P10, rx993_fail
    rx993_pos = $P10."pos"()
  alt998_0:
.annotate 'line', 471
    set_addr $I10, alt998_1
    rx993_cur."!mark_push"(0, rx993_pos, $I10)
.annotate 'line', 472
  # rx subrule "EXPR" subtype=capture negate=
    rx993_cur."!cursor_pos"(rx993_pos)
    $P10 = rx993_cur."EXPR"("f=")
    unless $P10, rx993_fail
    rx993_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx993_pos = $P10."pos"()
    goto alt998_end
  alt998_1:
  alt998_end:
.annotate 'line', 469
  # rx pass
    rx993_cur."!cursor_pass"(rx993_pos, "arglist")
    if_null rx993_debug, debug_802
    rx993_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx993_pos)
  debug_802:
    .return (rx993_cur)
  rx993_restart:
.annotate 'line', 4
    if_null rx993_debug, debug_803
    rx993_cur."!cursor_debug"("NEXT", "arglist")
  debug_803:
  rx993_fail:
    (rx993_rep, rx993_pos, $I10, $P10) = rx993_cur."!mark_fail"(0)
    lt rx993_pos, -1, rx993_done
    eq rx993_pos, -1, rx993_fail
    jump $I10
  rx993_done:
    rx993_cur."!cursor_fail"()
    if_null rx993_debug, debug_804
    rx993_cur."!cursor_debug"("FAIL", "arglist")
  debug_804:
    .return (rx993_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("220_1295307698.031") :method
.annotate 'line', 4
    $P995 = self."!PREFIX__!subrule"("ws", "")
    new $P996, "ResizablePMCArray"
    push $P996, $P995
    .return ($P996)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("221_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1000_tgt
    .local int rx1000_pos
    .local int rx1000_off
    .local int rx1000_eos
    .local int rx1000_rep
    .local pmc rx1000_cur
    .local pmc rx1000_debug
    (rx1000_cur, rx1000_pos, rx1000_tgt, $I10) = self."!cursor_start"()
    getattribute rx1000_debug, rx1000_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1000_cur
    .local pmc match
    .lex "$/", match
    length rx1000_eos, rx1000_tgt
    gt rx1000_pos, rx1000_eos, rx1000_done
    set rx1000_off, 0
    lt rx1000_pos, 2, rx1000_start
    sub rx1000_off, rx1000_pos, 1
    substr rx1000_tgt, rx1000_tgt, rx1000_off
  rx1000_start:
    eq $I10, 1, rx1000_restart
    if_null rx1000_debug, debug_805
    rx1000_cur."!cursor_debug"("START", "term:sym<value>")
  debug_805:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1004_done
    goto rxscan1004_scan
  rxscan1004_loop:
    ($P10) = rx1000_cur."from"()
    inc $P10
    set rx1000_pos, $P10
    ge rx1000_pos, rx1000_eos, rxscan1004_done
  rxscan1004_scan:
    set_addr $I10, rxscan1004_loop
    rx1000_cur."!mark_push"(0, rx1000_pos, $I10)
  rxscan1004_done:
.annotate 'line', 478
  # rx subrule "value" subtype=capture negate=
    rx1000_cur."!cursor_pos"(rx1000_pos)
    $P10 = rx1000_cur."value"()
    unless $P10, rx1000_fail
    rx1000_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1000_pos = $P10."pos"()
  # rx pass
    rx1000_cur."!cursor_pass"(rx1000_pos, "term:sym<value>")
    if_null rx1000_debug, debug_806
    rx1000_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1000_pos)
  debug_806:
    .return (rx1000_cur)
  rx1000_restart:
.annotate 'line', 4
    if_null rx1000_debug, debug_807
    rx1000_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_807:
  rx1000_fail:
    (rx1000_rep, rx1000_pos, $I10, $P10) = rx1000_cur."!mark_fail"(0)
    lt rx1000_pos, -1, rx1000_done
    eq rx1000_pos, -1, rx1000_fail
    jump $I10
  rx1000_done:
    rx1000_cur."!cursor_fail"()
    if_null rx1000_debug, debug_808
    rx1000_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_808:
    .return (rx1000_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("222_1295307698.031") :method
.annotate 'line', 4
    $P1002 = self."!PREFIX__!subrule"("value", "")
    new $P1003, "ResizablePMCArray"
    push $P1003, $P1002
    .return ($P1003)
.end


.namespace ["NQP";"Grammar"]
.sub "value"  :subid("223_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1006_tgt
    .local int rx1006_pos
    .local int rx1006_off
    .local int rx1006_eos
    .local int rx1006_rep
    .local pmc rx1006_cur
    .local pmc rx1006_debug
    (rx1006_cur, rx1006_pos, rx1006_tgt, $I10) = self."!cursor_start"()
    getattribute rx1006_debug, rx1006_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1006_cur
    .local pmc match
    .lex "$/", match
    length rx1006_eos, rx1006_tgt
    gt rx1006_pos, rx1006_eos, rx1006_done
    set rx1006_off, 0
    lt rx1006_pos, 2, rx1006_start
    sub rx1006_off, rx1006_pos, 1
    substr rx1006_tgt, rx1006_tgt, rx1006_off
  rx1006_start:
    eq $I10, 1, rx1006_restart
    if_null rx1006_debug, debug_809
    rx1006_cur."!cursor_debug"("START", "value")
  debug_809:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1011_done
    goto rxscan1011_scan
  rxscan1011_loop:
    ($P10) = rx1006_cur."from"()
    inc $P10
    set rx1006_pos, $P10
    ge rx1006_pos, rx1006_eos, rxscan1011_done
  rxscan1011_scan:
    set_addr $I10, rxscan1011_loop
    rx1006_cur."!mark_push"(0, rx1006_pos, $I10)
  rxscan1011_done:
  alt1012_0:
.annotate 'line', 480
    set_addr $I10, alt1012_1
    rx1006_cur."!mark_push"(0, rx1006_pos, $I10)
.annotate 'line', 481
  # rx subrule "quote" subtype=capture negate=
    rx1006_cur."!cursor_pos"(rx1006_pos)
    $P10 = rx1006_cur."quote"()
    unless $P10, rx1006_fail
    rx1006_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1006_pos = $P10."pos"()
    goto alt1012_end
  alt1012_1:
.annotate 'line', 482
  # rx subrule "number" subtype=capture negate=
    rx1006_cur."!cursor_pos"(rx1006_pos)
    $P10 = rx1006_cur."number"()
    unless $P10, rx1006_fail
    rx1006_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1006_pos = $P10."pos"()
  alt1012_end:
.annotate 'line', 480
  # rx pass
    rx1006_cur."!cursor_pass"(rx1006_pos, "value")
    if_null rx1006_debug, debug_810
    rx1006_cur."!cursor_debug"("PASS", "value", " at pos=", rx1006_pos)
  debug_810:
    .return (rx1006_cur)
  rx1006_restart:
.annotate 'line', 4
    if_null rx1006_debug, debug_811
    rx1006_cur."!cursor_debug"("NEXT", "value")
  debug_811:
  rx1006_fail:
    (rx1006_rep, rx1006_pos, $I10, $P10) = rx1006_cur."!mark_fail"(0)
    lt rx1006_pos, -1, rx1006_done
    eq rx1006_pos, -1, rx1006_fail
    jump $I10
  rx1006_done:
    rx1006_cur."!cursor_fail"()
    if_null rx1006_debug, debug_812
    rx1006_cur."!cursor_debug"("FAIL", "value")
  debug_812:
    .return (rx1006_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("224_1295307698.031") :method
.annotate 'line', 4
    $P1008 = self."!PREFIX__!subrule"("number", "")
    $P1009 = self."!PREFIX__!subrule"("quote", "")
    new $P1010, "ResizablePMCArray"
    push $P1010, $P1008
    push $P1010, $P1009
    .return ($P1010)
.end


.namespace ["NQP";"Grammar"]
.sub "number"  :subid("225_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1014_tgt
    .local int rx1014_pos
    .local int rx1014_off
    .local int rx1014_eos
    .local int rx1014_rep
    .local pmc rx1014_cur
    .local pmc rx1014_debug
    (rx1014_cur, rx1014_pos, rx1014_tgt, $I10) = self."!cursor_start"()
    getattribute rx1014_debug, rx1014_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1014_cur
    .local pmc match
    .lex "$/", match
    length rx1014_eos, rx1014_tgt
    gt rx1014_pos, rx1014_eos, rx1014_done
    set rx1014_off, 0
    lt rx1014_pos, 2, rx1014_start
    sub rx1014_off, rx1014_pos, 1
    substr rx1014_tgt, rx1014_tgt, rx1014_off
  rx1014_start:
    eq $I10, 1, rx1014_restart
    if_null rx1014_debug, debug_813
    rx1014_cur."!cursor_debug"("START", "number")
  debug_813:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1017_done
    goto rxscan1017_scan
  rxscan1017_loop:
    ($P10) = rx1014_cur."from"()
    inc $P10
    set rx1014_pos, $P10
    ge rx1014_pos, rx1014_eos, rxscan1017_done
  rxscan1017_scan:
    set_addr $I10, rxscan1017_loop
    rx1014_cur."!mark_push"(0, rx1014_pos, $I10)
  rxscan1017_done:
.annotate 'line', 486
  # rx subcapture "sign"
    set_addr $I10, rxcap_1019_fail
    rx1014_cur."!mark_push"(0, rx1014_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1014_pos, rx1014_off
    set rx1014_rep, 0
    sub $I12, rx1014_eos, rx1014_pos
    le $I12, 1, rxenumcharlistq1018_loop
    set $I12, 1
  rxenumcharlistq1018_loop:
    le $I12, 0, rxenumcharlistq1018_done
    substr $S10, rx1014_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1018_done
    inc rx1014_rep
  rxenumcharlistq1018_done:
    add rx1014_pos, rx1014_pos, rx1014_rep
    set_addr $I10, rxcap_1019_fail
    ($I12, $I11) = rx1014_cur."!mark_peek"($I10)
    rx1014_cur."!cursor_pos"($I11)
    ($P10) = rx1014_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1014_pos, "")
    rx1014_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1019_done
  rxcap_1019_fail:
    goto rx1014_fail
  rxcap_1019_done:
  alt1020_0:
.annotate 'line', 487
    set_addr $I10, alt1020_1
    rx1014_cur."!mark_push"(0, rx1014_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1014_cur."!cursor_pos"(rx1014_pos)
    $P10 = rx1014_cur."dec_number"()
    unless $P10, rx1014_fail
    rx1014_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1014_pos = $P10."pos"()
    goto alt1020_end
  alt1020_1:
  # rx subrule "integer" subtype=capture negate=
    rx1014_cur."!cursor_pos"(rx1014_pos)
    $P10 = rx1014_cur."integer"()
    unless $P10, rx1014_fail
    rx1014_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1014_pos = $P10."pos"()
  alt1020_end:
.annotate 'line', 485
  # rx pass
    rx1014_cur."!cursor_pass"(rx1014_pos, "number")
    if_null rx1014_debug, debug_814
    rx1014_cur."!cursor_debug"("PASS", "number", " at pos=", rx1014_pos)
  debug_814:
    .return (rx1014_cur)
  rx1014_restart:
.annotate 'line', 4
    if_null rx1014_debug, debug_815
    rx1014_cur."!cursor_debug"("NEXT", "number")
  debug_815:
  rx1014_fail:
    (rx1014_rep, rx1014_pos, $I10, $P10) = rx1014_cur."!mark_fail"(0)
    lt rx1014_pos, -1, rx1014_done
    eq rx1014_pos, -1, rx1014_fail
    jump $I10
  rx1014_done:
    rx1014_cur."!cursor_fail"()
    if_null rx1014_debug, debug_816
    rx1014_cur."!cursor_debug"("FAIL", "number")
  debug_816:
    .return (rx1014_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("226_1295307698.031") :method
.annotate 'line', 4
    new $P1016, "ResizablePMCArray"
    push $P1016, ""
    .return ($P1016)
.end


.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("227_1295307698.031") :method
.annotate 'line', 490
    $P1022 = self."!protoregex"("quote")
    .return ($P1022)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("228_1295307698.031") :method
.annotate 'line', 490
    $P1024 = self."!PREFIX__!protoregex"("quote")
    .return ($P1024)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("229_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1026_tgt
    .local int rx1026_pos
    .local int rx1026_off
    .local int rx1026_eos
    .local int rx1026_rep
    .local pmc rx1026_cur
    .local pmc rx1026_debug
    (rx1026_cur, rx1026_pos, rx1026_tgt, $I10) = self."!cursor_start"()
    getattribute rx1026_debug, rx1026_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1026_cur
    .local pmc match
    .lex "$/", match
    length rx1026_eos, rx1026_tgt
    gt rx1026_pos, rx1026_eos, rx1026_done
    set rx1026_off, 0
    lt rx1026_pos, 2, rx1026_start
    sub rx1026_off, rx1026_pos, 1
    substr rx1026_tgt, rx1026_tgt, rx1026_off
  rx1026_start:
    eq $I10, 1, rx1026_restart
    if_null rx1026_debug, debug_817
    rx1026_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_817:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1029_done
    goto rxscan1029_scan
  rxscan1029_loop:
    ($P10) = rx1026_cur."from"()
    inc $P10
    set rx1026_pos, $P10
    ge rx1026_pos, rx1026_eos, rxscan1029_done
  rxscan1029_scan:
    set_addr $I10, rxscan1029_loop
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
  rxscan1029_done:
.annotate 'line', 491
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1026_pos, rx1026_off
    substr $S10, rx1026_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1026_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1026_cur."!cursor_pos"(rx1026_pos)
    $P10 = rx1026_cur."quote_EXPR"(":q")
    unless $P10, rx1026_fail
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1026_pos = $P10."pos"()
  # rx pass
    rx1026_cur."!cursor_pass"(rx1026_pos, "quote:sym<apos>")
    if_null rx1026_debug, debug_818
    rx1026_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1026_pos)
  debug_818:
    .return (rx1026_cur)
  rx1026_restart:
.annotate 'line', 4
    if_null rx1026_debug, debug_819
    rx1026_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_819:
  rx1026_fail:
    (rx1026_rep, rx1026_pos, $I10, $P10) = rx1026_cur."!mark_fail"(0)
    lt rx1026_pos, -1, rx1026_done
    eq rx1026_pos, -1, rx1026_fail
    jump $I10
  rx1026_done:
    rx1026_cur."!cursor_fail"()
    if_null rx1026_debug, debug_820
    rx1026_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_820:
    .return (rx1026_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("230_1295307698.031") :method
.annotate 'line', 4
    new $P1028, "ResizablePMCArray"
    push $P1028, "'"
    .return ($P1028)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("231_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1031_tgt
    .local int rx1031_pos
    .local int rx1031_off
    .local int rx1031_eos
    .local int rx1031_rep
    .local pmc rx1031_cur
    .local pmc rx1031_debug
    (rx1031_cur, rx1031_pos, rx1031_tgt, $I10) = self."!cursor_start"()
    getattribute rx1031_debug, rx1031_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1031_cur
    .local pmc match
    .lex "$/", match
    length rx1031_eos, rx1031_tgt
    gt rx1031_pos, rx1031_eos, rx1031_done
    set rx1031_off, 0
    lt rx1031_pos, 2, rx1031_start
    sub rx1031_off, rx1031_pos, 1
    substr rx1031_tgt, rx1031_tgt, rx1031_off
  rx1031_start:
    eq $I10, 1, rx1031_restart
    if_null rx1031_debug, debug_821
    rx1031_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_821:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1034_done
    goto rxscan1034_scan
  rxscan1034_loop:
    ($P10) = rx1031_cur."from"()
    inc $P10
    set rx1031_pos, $P10
    ge rx1031_pos, rx1031_eos, rxscan1034_done
  rxscan1034_scan:
    set_addr $I10, rxscan1034_loop
    rx1031_cur."!mark_push"(0, rx1031_pos, $I10)
  rxscan1034_done:
.annotate 'line', 492
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1031_pos, rx1031_off
    substr $S10, rx1031_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1031_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1031_cur."!cursor_pos"(rx1031_pos)
    $P10 = rx1031_cur."quote_EXPR"(":qq")
    unless $P10, rx1031_fail
    rx1031_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1031_pos = $P10."pos"()
  # rx pass
    rx1031_cur."!cursor_pass"(rx1031_pos, "quote:sym<dblq>")
    if_null rx1031_debug, debug_822
    rx1031_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1031_pos)
  debug_822:
    .return (rx1031_cur)
  rx1031_restart:
.annotate 'line', 4
    if_null rx1031_debug, debug_823
    rx1031_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_823:
  rx1031_fail:
    (rx1031_rep, rx1031_pos, $I10, $P10) = rx1031_cur."!mark_fail"(0)
    lt rx1031_pos, -1, rx1031_done
    eq rx1031_pos, -1, rx1031_fail
    jump $I10
  rx1031_done:
    rx1031_cur."!cursor_fail"()
    if_null rx1031_debug, debug_824
    rx1031_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_824:
    .return (rx1031_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("232_1295307698.031") :method
.annotate 'line', 4
    new $P1033, "ResizablePMCArray"
    push $P1033, "\""
    .return ($P1033)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("233_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1036_tgt
    .local int rx1036_pos
    .local int rx1036_off
    .local int rx1036_eos
    .local int rx1036_rep
    .local pmc rx1036_cur
    .local pmc rx1036_debug
    (rx1036_cur, rx1036_pos, rx1036_tgt, $I10) = self."!cursor_start"()
    getattribute rx1036_debug, rx1036_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1036_cur
    .local pmc match
    .lex "$/", match
    length rx1036_eos, rx1036_tgt
    gt rx1036_pos, rx1036_eos, rx1036_done
    set rx1036_off, 0
    lt rx1036_pos, 2, rx1036_start
    sub rx1036_off, rx1036_pos, 1
    substr rx1036_tgt, rx1036_tgt, rx1036_off
  rx1036_start:
    eq $I10, 1, rx1036_restart
    if_null rx1036_debug, debug_825
    rx1036_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_825:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1040_done
    goto rxscan1040_scan
  rxscan1040_loop:
    ($P10) = rx1036_cur."from"()
    inc $P10
    set rx1036_pos, $P10
    ge rx1036_pos, rx1036_eos, rxscan1040_done
  rxscan1040_scan:
    set_addr $I10, rxscan1040_loop
    rx1036_cur."!mark_push"(0, rx1036_pos, $I10)
  rxscan1040_done:
.annotate 'line', 493
  # rx literal  "q"
    add $I11, rx1036_pos, 1
    gt $I11, rx1036_eos, rx1036_fail
    sub $I11, rx1036_pos, rx1036_off
    ord $I11, rx1036_tgt, $I11
    ne $I11, 113, rx1036_fail
    add rx1036_pos, 1
  # rxanchor rwb
    le rx1036_pos, 0, rx1036_fail
    sub $I10, rx1036_pos, rx1036_off
    is_cclass $I11, 8192, rx1036_tgt, $I10
    if $I11, rx1036_fail
    dec $I10
    is_cclass $I11, 8192, rx1036_tgt, $I10
    unless $I11, rx1036_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1036_pos, rx1036_off
    substr $S10, rx1036_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1036_fail
  # rx subrule "ws" subtype=method negate=
    rx1036_cur."!cursor_pos"(rx1036_pos)
    $P10 = rx1036_cur."ws"()
    unless $P10, rx1036_fail
    rx1036_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1036_cur."!cursor_pos"(rx1036_pos)
    $P10 = rx1036_cur."quote_EXPR"(":q")
    unless $P10, rx1036_fail
    rx1036_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1036_pos = $P10."pos"()
  # rx pass
    rx1036_cur."!cursor_pass"(rx1036_pos, "quote:sym<q>")
    if_null rx1036_debug, debug_826
    rx1036_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1036_pos)
  debug_826:
    .return (rx1036_cur)
  rx1036_restart:
.annotate 'line', 4
    if_null rx1036_debug, debug_827
    rx1036_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_827:
  rx1036_fail:
    (rx1036_rep, rx1036_pos, $I10, $P10) = rx1036_cur."!mark_fail"(0)
    lt rx1036_pos, -1, rx1036_done
    eq rx1036_pos, -1, rx1036_fail
    jump $I10
  rx1036_done:
    rx1036_cur."!cursor_fail"()
    if_null rx1036_debug, debug_828
    rx1036_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_828:
    .return (rx1036_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("234_1295307698.031") :method
.annotate 'line', 4
    $P1038 = self."!PREFIX__!subrule"("ws", "q")
    new $P1039, "ResizablePMCArray"
    push $P1039, $P1038
    .return ($P1039)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("235_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1042_tgt
    .local int rx1042_pos
    .local int rx1042_off
    .local int rx1042_eos
    .local int rx1042_rep
    .local pmc rx1042_cur
    .local pmc rx1042_debug
    (rx1042_cur, rx1042_pos, rx1042_tgt, $I10) = self."!cursor_start"()
    getattribute rx1042_debug, rx1042_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1042_cur
    .local pmc match
    .lex "$/", match
    length rx1042_eos, rx1042_tgt
    gt rx1042_pos, rx1042_eos, rx1042_done
    set rx1042_off, 0
    lt rx1042_pos, 2, rx1042_start
    sub rx1042_off, rx1042_pos, 1
    substr rx1042_tgt, rx1042_tgt, rx1042_off
  rx1042_start:
    eq $I10, 1, rx1042_restart
    if_null rx1042_debug, debug_829
    rx1042_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_829:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1046_done
    goto rxscan1046_scan
  rxscan1046_loop:
    ($P10) = rx1042_cur."from"()
    inc $P10
    set rx1042_pos, $P10
    ge rx1042_pos, rx1042_eos, rxscan1046_done
  rxscan1046_scan:
    set_addr $I10, rxscan1046_loop
    rx1042_cur."!mark_push"(0, rx1042_pos, $I10)
  rxscan1046_done:
.annotate 'line', 494
  # rx literal  "qq"
    add $I11, rx1042_pos, 2
    gt $I11, rx1042_eos, rx1042_fail
    sub $I11, rx1042_pos, rx1042_off
    substr $S10, rx1042_tgt, $I11, 2
    ne $S10, "qq", rx1042_fail
    add rx1042_pos, 2
  # rxanchor rwb
    le rx1042_pos, 0, rx1042_fail
    sub $I10, rx1042_pos, rx1042_off
    is_cclass $I11, 8192, rx1042_tgt, $I10
    if $I11, rx1042_fail
    dec $I10
    is_cclass $I11, 8192, rx1042_tgt, $I10
    unless $I11, rx1042_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1042_pos, rx1042_off
    substr $S10, rx1042_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1042_fail
  # rx subrule "ws" subtype=method negate=
    rx1042_cur."!cursor_pos"(rx1042_pos)
    $P10 = rx1042_cur."ws"()
    unless $P10, rx1042_fail
    rx1042_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1042_cur."!cursor_pos"(rx1042_pos)
    $P10 = rx1042_cur."quote_EXPR"(":qq")
    unless $P10, rx1042_fail
    rx1042_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1042_pos = $P10."pos"()
  # rx pass
    rx1042_cur."!cursor_pass"(rx1042_pos, "quote:sym<qq>")
    if_null rx1042_debug, debug_830
    rx1042_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1042_pos)
  debug_830:
    .return (rx1042_cur)
  rx1042_restart:
.annotate 'line', 4
    if_null rx1042_debug, debug_831
    rx1042_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_831:
  rx1042_fail:
    (rx1042_rep, rx1042_pos, $I10, $P10) = rx1042_cur."!mark_fail"(0)
    lt rx1042_pos, -1, rx1042_done
    eq rx1042_pos, -1, rx1042_fail
    jump $I10
  rx1042_done:
    rx1042_cur."!cursor_fail"()
    if_null rx1042_debug, debug_832
    rx1042_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_832:
    .return (rx1042_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("236_1295307698.031") :method
.annotate 'line', 4
    $P1044 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1045, "ResizablePMCArray"
    push $P1045, $P1044
    .return ($P1045)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("237_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1048_tgt
    .local int rx1048_pos
    .local int rx1048_off
    .local int rx1048_eos
    .local int rx1048_rep
    .local pmc rx1048_cur
    .local pmc rx1048_debug
    (rx1048_cur, rx1048_pos, rx1048_tgt, $I10) = self."!cursor_start"()
    getattribute rx1048_debug, rx1048_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1048_cur
    .local pmc match
    .lex "$/", match
    length rx1048_eos, rx1048_tgt
    gt rx1048_pos, rx1048_eos, rx1048_done
    set rx1048_off, 0
    lt rx1048_pos, 2, rx1048_start
    sub rx1048_off, rx1048_pos, 1
    substr rx1048_tgt, rx1048_tgt, rx1048_off
  rx1048_start:
    eq $I10, 1, rx1048_restart
    if_null rx1048_debug, debug_833
    rx1048_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_833:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1052_done
    goto rxscan1052_scan
  rxscan1052_loop:
    ($P10) = rx1048_cur."from"()
    inc $P10
    set rx1048_pos, $P10
    ge rx1048_pos, rx1048_eos, rxscan1052_done
  rxscan1052_scan:
    set_addr $I10, rxscan1052_loop
    rx1048_cur."!mark_push"(0, rx1048_pos, $I10)
  rxscan1052_done:
.annotate 'line', 495
  # rx literal  "Q"
    add $I11, rx1048_pos, 1
    gt $I11, rx1048_eos, rx1048_fail
    sub $I11, rx1048_pos, rx1048_off
    ord $I11, rx1048_tgt, $I11
    ne $I11, 81, rx1048_fail
    add rx1048_pos, 1
  # rxanchor rwb
    le rx1048_pos, 0, rx1048_fail
    sub $I10, rx1048_pos, rx1048_off
    is_cclass $I11, 8192, rx1048_tgt, $I10
    if $I11, rx1048_fail
    dec $I10
    is_cclass $I11, 8192, rx1048_tgt, $I10
    unless $I11, rx1048_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1048_pos, rx1048_off
    substr $S10, rx1048_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1048_fail
  # rx subrule "ws" subtype=method negate=
    rx1048_cur."!cursor_pos"(rx1048_pos)
    $P10 = rx1048_cur."ws"()
    unless $P10, rx1048_fail
    rx1048_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1048_cur."!cursor_pos"(rx1048_pos)
    $P10 = rx1048_cur."quote_EXPR"()
    unless $P10, rx1048_fail
    rx1048_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1048_pos = $P10."pos"()
  # rx pass
    rx1048_cur."!cursor_pass"(rx1048_pos, "quote:sym<Q>")
    if_null rx1048_debug, debug_834
    rx1048_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1048_pos)
  debug_834:
    .return (rx1048_cur)
  rx1048_restart:
.annotate 'line', 4
    if_null rx1048_debug, debug_835
    rx1048_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_835:
  rx1048_fail:
    (rx1048_rep, rx1048_pos, $I10, $P10) = rx1048_cur."!mark_fail"(0)
    lt rx1048_pos, -1, rx1048_done
    eq rx1048_pos, -1, rx1048_fail
    jump $I10
  rx1048_done:
    rx1048_cur."!cursor_fail"()
    if_null rx1048_debug, debug_836
    rx1048_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_836:
    .return (rx1048_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("238_1295307698.031") :method
.annotate 'line', 4
    $P1050 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1051, "ResizablePMCArray"
    push $P1051, $P1050
    .return ($P1051)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("239_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1054_tgt
    .local int rx1054_pos
    .local int rx1054_off
    .local int rx1054_eos
    .local int rx1054_rep
    .local pmc rx1054_cur
    .local pmc rx1054_debug
    (rx1054_cur, rx1054_pos, rx1054_tgt, $I10) = self."!cursor_start"()
    getattribute rx1054_debug, rx1054_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1054_cur
    .local pmc match
    .lex "$/", match
    length rx1054_eos, rx1054_tgt
    gt rx1054_pos, rx1054_eos, rx1054_done
    set rx1054_off, 0
    lt rx1054_pos, 2, rx1054_start
    sub rx1054_off, rx1054_pos, 1
    substr rx1054_tgt, rx1054_tgt, rx1054_off
  rx1054_start:
    eq $I10, 1, rx1054_restart
    if_null rx1054_debug, debug_837
    rx1054_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_837:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1058_done
    goto rxscan1058_scan
  rxscan1058_loop:
    ($P10) = rx1054_cur."from"()
    inc $P10
    set rx1054_pos, $P10
    ge rx1054_pos, rx1054_eos, rxscan1058_done
  rxscan1058_scan:
    set_addr $I10, rxscan1058_loop
    rx1054_cur."!mark_push"(0, rx1054_pos, $I10)
  rxscan1058_done:
.annotate 'line', 496
  # rx literal  "Q:PIR"
    add $I11, rx1054_pos, 5
    gt $I11, rx1054_eos, rx1054_fail
    sub $I11, rx1054_pos, rx1054_off
    substr $S10, rx1054_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1054_fail
    add rx1054_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1054_cur."!cursor_pos"(rx1054_pos)
    $P10 = rx1054_cur."ws"()
    unless $P10, rx1054_fail
    rx1054_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1054_cur."!cursor_pos"(rx1054_pos)
    $P10 = rx1054_cur."quote_EXPR"()
    unless $P10, rx1054_fail
    rx1054_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1054_pos = $P10."pos"()
  # rx pass
    rx1054_cur."!cursor_pass"(rx1054_pos, "quote:sym<Q:PIR>")
    if_null rx1054_debug, debug_838
    rx1054_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1054_pos)
  debug_838:
    .return (rx1054_cur)
  rx1054_restart:
.annotate 'line', 4
    if_null rx1054_debug, debug_839
    rx1054_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_839:
  rx1054_fail:
    (rx1054_rep, rx1054_pos, $I10, $P10) = rx1054_cur."!mark_fail"(0)
    lt rx1054_pos, -1, rx1054_done
    eq rx1054_pos, -1, rx1054_fail
    jump $I10
  rx1054_done:
    rx1054_cur."!cursor_fail"()
    if_null rx1054_debug, debug_840
    rx1054_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_840:
    .return (rx1054_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("240_1295307698.031") :method
.annotate 'line', 4
    $P1056 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1057, "ResizablePMCArray"
    push $P1057, $P1056
    .return ($P1057)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("241_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1060_tgt
    .local int rx1060_pos
    .local int rx1060_off
    .local int rx1060_eos
    .local int rx1060_rep
    .local pmc rx1060_cur
    .local pmc rx1060_debug
    (rx1060_cur, rx1060_pos, rx1060_tgt, $I10) = self."!cursor_start"()
    getattribute rx1060_debug, rx1060_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1060_cur
    .local pmc match
    .lex "$/", match
    length rx1060_eos, rx1060_tgt
    gt rx1060_pos, rx1060_eos, rx1060_done
    set rx1060_off, 0
    lt rx1060_pos, 2, rx1060_start
    sub rx1060_off, rx1060_pos, 1
    substr rx1060_tgt, rx1060_tgt, rx1060_off
  rx1060_start:
    eq $I10, 1, rx1060_restart
    if_null rx1060_debug, debug_841
    rx1060_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_841:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1064_done
    goto rxscan1064_scan
  rxscan1064_loop:
    ($P10) = rx1060_cur."from"()
    inc $P10
    set rx1060_pos, $P10
    ge rx1060_pos, rx1060_eos, rxscan1064_done
  rxscan1064_scan:
    set_addr $I10, rxscan1064_loop
    rx1060_cur."!mark_push"(0, rx1060_pos, $I10)
  rxscan1064_done:
.annotate 'line', 498
  # rx literal  "/"
    add $I11, rx1060_pos, 1
    gt $I11, rx1060_eos, rx1060_fail
    sub $I11, rx1060_pos, rx1060_off
    ord $I11, rx1060_tgt, $I11
    ne $I11, 47, rx1060_fail
    add rx1060_pos, 1
.annotate 'line', 499
  # rx subrule "newpad" subtype=method negate=
    rx1060_cur."!cursor_pos"(rx1060_pos)
    $P10 = rx1060_cur."newpad"()
    unless $P10, rx1060_fail
    rx1060_pos = $P10."pos"()
.annotate 'line', 500
  # rx reduce name="quote:sym</ />" key="open"
    rx1060_cur."!cursor_pos"(rx1060_pos)
    rx1060_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 501
  # rx subrule "LANG" subtype=capture negate=
    rx1060_cur."!cursor_pos"(rx1060_pos)
    $P10 = rx1060_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1060_fail
    rx1060_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1060_pos = $P10."pos"()
.annotate 'line', 502
  # rx literal  "/"
    add $I11, rx1060_pos, 1
    gt $I11, rx1060_eos, rx1060_fail
    sub $I11, rx1060_pos, rx1060_off
    ord $I11, rx1060_tgt, $I11
    ne $I11, 47, rx1060_fail
    add rx1060_pos, 1
.annotate 'line', 497
  # rx pass
    rx1060_cur."!cursor_pass"(rx1060_pos, "quote:sym</ />")
    if_null rx1060_debug, debug_842
    rx1060_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1060_pos)
  debug_842:
    .return (rx1060_cur)
  rx1060_restart:
.annotate 'line', 4
    if_null rx1060_debug, debug_843
    rx1060_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_843:
  rx1060_fail:
    (rx1060_rep, rx1060_pos, $I10, $P10) = rx1060_cur."!mark_fail"(0)
    lt rx1060_pos, -1, rx1060_done
    eq rx1060_pos, -1, rx1060_fail
    jump $I10
  rx1060_done:
    rx1060_cur."!cursor_fail"()
    if_null rx1060_debug, debug_844
    rx1060_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_844:
    .return (rx1060_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("242_1295307698.031") :method
.annotate 'line', 4
    $P1062 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1063, "ResizablePMCArray"
    push $P1063, $P1062
    .return ($P1063)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("243_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1066_tgt
    .local int rx1066_pos
    .local int rx1066_off
    .local int rx1066_eos
    .local int rx1066_rep
    .local pmc rx1066_cur
    .local pmc rx1066_debug
    (rx1066_cur, rx1066_pos, rx1066_tgt, $I10) = self."!cursor_start"()
    getattribute rx1066_debug, rx1066_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1066_cur
    .local pmc match
    .lex "$/", match
    length rx1066_eos, rx1066_tgt
    gt rx1066_pos, rx1066_eos, rx1066_done
    set rx1066_off, 0
    lt rx1066_pos, 2, rx1066_start
    sub rx1066_off, rx1066_pos, 1
    substr rx1066_tgt, rx1066_tgt, rx1066_off
  rx1066_start:
    eq $I10, 1, rx1066_restart
    if_null rx1066_debug, debug_845
    rx1066_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_845:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1069_done
    goto rxscan1069_scan
  rxscan1069_loop:
    ($P10) = rx1066_cur."from"()
    inc $P10
    set rx1066_pos, $P10
    ge rx1066_pos, rx1066_eos, rxscan1069_done
  rxscan1069_scan:
    set_addr $I10, rxscan1069_loop
    rx1066_cur."!mark_push"(0, rx1066_pos, $I10)
  rxscan1069_done:
.annotate 'line', 505
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1066_pos, rx1066_off
    substr $S10, rx1066_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1066_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."quotemod_check"("s")
    unless $P10, rx1066_fail
  # rx subrule "variable" subtype=capture negate=
    rx1066_cur."!cursor_pos"(rx1066_pos)
    $P10 = rx1066_cur."variable"()
    unless $P10, rx1066_fail
    rx1066_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1066_pos = $P10."pos"()
  # rx pass
    rx1066_cur."!cursor_pass"(rx1066_pos, "quote_escape:sym<$>")
    if_null rx1066_debug, debug_846
    rx1066_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1066_pos)
  debug_846:
    .return (rx1066_cur)
  rx1066_restart:
.annotate 'line', 4
    if_null rx1066_debug, debug_847
    rx1066_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_847:
  rx1066_fail:
    (rx1066_rep, rx1066_pos, $I10, $P10) = rx1066_cur."!mark_fail"(0)
    lt rx1066_pos, -1, rx1066_done
    eq rx1066_pos, -1, rx1066_fail
    jump $I10
  rx1066_done:
    rx1066_cur."!cursor_fail"()
    if_null rx1066_debug, debug_848
    rx1066_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_848:
    .return (rx1066_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("244_1295307698.031") :method
.annotate 'line', 4
    new $P1068, "ResizablePMCArray"
    push $P1068, "$"
    .return ($P1068)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("245_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1071_tgt
    .local int rx1071_pos
    .local int rx1071_off
    .local int rx1071_eos
    .local int rx1071_rep
    .local pmc rx1071_cur
    .local pmc rx1071_debug
    (rx1071_cur, rx1071_pos, rx1071_tgt, $I10) = self."!cursor_start"()
    getattribute rx1071_debug, rx1071_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1071_cur
    .local pmc match
    .lex "$/", match
    length rx1071_eos, rx1071_tgt
    gt rx1071_pos, rx1071_eos, rx1071_done
    set rx1071_off, 0
    lt rx1071_pos, 2, rx1071_start
    sub rx1071_off, rx1071_pos, 1
    substr rx1071_tgt, rx1071_tgt, rx1071_off
  rx1071_start:
    eq $I10, 1, rx1071_restart
    if_null rx1071_debug, debug_849
    rx1071_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_849:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1074_done
    goto rxscan1074_scan
  rxscan1074_loop:
    ($P10) = rx1071_cur."from"()
    inc $P10
    set rx1071_pos, $P10
    ge rx1071_pos, rx1071_eos, rxscan1074_done
  rxscan1074_scan:
    set_addr $I10, rxscan1074_loop
    rx1071_cur."!mark_push"(0, rx1071_pos, $I10)
  rxscan1074_done:
.annotate 'line', 506
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1071_pos, rx1071_off
    substr $S10, rx1071_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1071_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1071_cur."!cursor_pos"(rx1071_pos)
    $P10 = rx1071_cur."quotemod_check"("c")
    unless $P10, rx1071_fail
  # rx subrule "block" subtype=capture negate=
    rx1071_cur."!cursor_pos"(rx1071_pos)
    $P10 = rx1071_cur."block"()
    unless $P10, rx1071_fail
    rx1071_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1071_pos = $P10."pos"()
  # rx pass
    rx1071_cur."!cursor_pass"(rx1071_pos, "quote_escape:sym<{ }>")
    if_null rx1071_debug, debug_850
    rx1071_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1071_pos)
  debug_850:
    .return (rx1071_cur)
  rx1071_restart:
.annotate 'line', 4
    if_null rx1071_debug, debug_851
    rx1071_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_851:
  rx1071_fail:
    (rx1071_rep, rx1071_pos, $I10, $P10) = rx1071_cur."!mark_fail"(0)
    lt rx1071_pos, -1, rx1071_done
    eq rx1071_pos, -1, rx1071_fail
    jump $I10
  rx1071_done:
    rx1071_cur."!cursor_fail"()
    if_null rx1071_debug, debug_852
    rx1071_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_852:
    .return (rx1071_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("246_1295307698.031") :method
.annotate 'line', 4
    new $P1073, "ResizablePMCArray"
    push $P1073, "{"
    .return ($P1073)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("247_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1076_tgt
    .local int rx1076_pos
    .local int rx1076_off
    .local int rx1076_eos
    .local int rx1076_rep
    .local pmc rx1076_cur
    .local pmc rx1076_debug
    (rx1076_cur, rx1076_pos, rx1076_tgt, $I10) = self."!cursor_start"()
    getattribute rx1076_debug, rx1076_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1076_cur
    .local pmc match
    .lex "$/", match
    length rx1076_eos, rx1076_tgt
    gt rx1076_pos, rx1076_eos, rx1076_done
    set rx1076_off, 0
    lt rx1076_pos, 2, rx1076_start
    sub rx1076_off, rx1076_pos, 1
    substr rx1076_tgt, rx1076_tgt, rx1076_off
  rx1076_start:
    eq $I10, 1, rx1076_restart
    if_null rx1076_debug, debug_853
    rx1076_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_853:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1079_done
    goto rxscan1079_scan
  rxscan1079_loop:
    ($P10) = rx1076_cur."from"()
    inc $P10
    set rx1076_pos, $P10
    ge rx1076_pos, rx1076_eos, rxscan1079_done
  rxscan1079_scan:
    set_addr $I10, rxscan1079_loop
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  rxscan1079_done:
.annotate 'line', 507
  # rx literal  "\\e"
    add $I11, rx1076_pos, 2
    gt $I11, rx1076_eos, rx1076_fail
    sub $I11, rx1076_pos, rx1076_off
    substr $S10, rx1076_tgt, $I11, 2
    ne $S10, "\\e", rx1076_fail
    add rx1076_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."quotemod_check"("b")
    unless $P10, rx1076_fail
  # rx pass
    rx1076_cur."!cursor_pass"(rx1076_pos, "quote_escape:sym<esc>")
    if_null rx1076_debug, debug_854
    rx1076_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1076_pos)
  debug_854:
    .return (rx1076_cur)
  rx1076_restart:
.annotate 'line', 4
    if_null rx1076_debug, debug_855
    rx1076_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_855:
  rx1076_fail:
    (rx1076_rep, rx1076_pos, $I10, $P10) = rx1076_cur."!mark_fail"(0)
    lt rx1076_pos, -1, rx1076_done
    eq rx1076_pos, -1, rx1076_fail
    jump $I10
  rx1076_done:
    rx1076_cur."!cursor_fail"()
    if_null rx1076_debug, debug_856
    rx1076_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_856:
    .return (rx1076_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("248_1295307698.031") :method
.annotate 'line', 4
    new $P1078, "ResizablePMCArray"
    push $P1078, "\\e"
    .return ($P1078)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("249_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1081_tgt
    .local int rx1081_pos
    .local int rx1081_off
    .local int rx1081_eos
    .local int rx1081_rep
    .local pmc rx1081_cur
    .local pmc rx1081_debug
    (rx1081_cur, rx1081_pos, rx1081_tgt, $I10) = self."!cursor_start"()
    rx1081_cur."!cursor_caparray"("EXPR")
    getattribute rx1081_debug, rx1081_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1081_cur
    .local pmc match
    .lex "$/", match
    length rx1081_eos, rx1081_tgt
    gt rx1081_pos, rx1081_eos, rx1081_done
    set rx1081_off, 0
    lt rx1081_pos, 2, rx1081_start
    sub rx1081_off, rx1081_pos, 1
    substr rx1081_tgt, rx1081_tgt, rx1081_off
  rx1081_start:
    eq $I10, 1, rx1081_restart
    if_null rx1081_debug, debug_857
    rx1081_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_857:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1085_done
    goto rxscan1085_scan
  rxscan1085_loop:
    ($P10) = rx1081_cur."from"()
    inc $P10
    set rx1081_pos, $P10
    ge rx1081_pos, rx1081_eos, rxscan1085_done
  rxscan1085_scan:
    set_addr $I10, rxscan1085_loop
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  rxscan1085_done:
.annotate 'line', 509
  # rx literal  "("
    add $I11, rx1081_pos, 1
    gt $I11, rx1081_eos, rx1081_fail
    sub $I11, rx1081_pos, rx1081_off
    ord $I11, rx1081_tgt, $I11
    ne $I11, 40, rx1081_fail
    add rx1081_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1081_cur."!cursor_pos"(rx1081_pos)
    $P10 = rx1081_cur."ws"()
    unless $P10, rx1081_fail
    rx1081_pos = $P10."pos"()
  # rx rxquantr1086 ** 0..1
    set_addr $I10, rxquantr1086_done
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  rxquantr1086_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1081_cur."!cursor_pos"(rx1081_pos)
    $P10 = rx1081_cur."EXPR"()
    unless $P10, rx1081_fail
    goto rxsubrule1087_pass
  rxsubrule1087_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1081_fail
  rxsubrule1087_pass:
    set_addr $I10, rxsubrule1087_back
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1081_pos = $P10."pos"()
    set_addr $I10, rxquantr1086_done
    (rx1081_rep) = rx1081_cur."!mark_commit"($I10)
  rxquantr1086_done:
  # rx literal  ")"
    add $I11, rx1081_pos, 1
    gt $I11, rx1081_eos, rx1081_fail
    sub $I11, rx1081_pos, rx1081_off
    ord $I11, rx1081_tgt, $I11
    ne $I11, 41, rx1081_fail
    add rx1081_pos, 1
  # rx pass
    rx1081_cur."!cursor_pass"(rx1081_pos, "circumfix:sym<( )>")
    if_null rx1081_debug, debug_858
    rx1081_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1081_pos)
  debug_858:
    .return (rx1081_cur)
  rx1081_restart:
.annotate 'line', 4
    if_null rx1081_debug, debug_859
    rx1081_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_859:
  rx1081_fail:
    (rx1081_rep, rx1081_pos, $I10, $P10) = rx1081_cur."!mark_fail"(0)
    lt rx1081_pos, -1, rx1081_done
    eq rx1081_pos, -1, rx1081_fail
    jump $I10
  rx1081_done:
    rx1081_cur."!cursor_fail"()
    if_null rx1081_debug, debug_860
    rx1081_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_860:
    .return (rx1081_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("250_1295307698.031") :method
.annotate 'line', 4
    $P1083 = self."!PREFIX__!subrule"("ws", "(")
    new $P1084, "ResizablePMCArray"
    push $P1084, $P1083
    .return ($P1084)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("251_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1089_tgt
    .local int rx1089_pos
    .local int rx1089_off
    .local int rx1089_eos
    .local int rx1089_rep
    .local pmc rx1089_cur
    .local pmc rx1089_debug
    (rx1089_cur, rx1089_pos, rx1089_tgt, $I10) = self."!cursor_start"()
    rx1089_cur."!cursor_caparray"("EXPR")
    getattribute rx1089_debug, rx1089_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1089_cur
    .local pmc match
    .lex "$/", match
    length rx1089_eos, rx1089_tgt
    gt rx1089_pos, rx1089_eos, rx1089_done
    set rx1089_off, 0
    lt rx1089_pos, 2, rx1089_start
    sub rx1089_off, rx1089_pos, 1
    substr rx1089_tgt, rx1089_tgt, rx1089_off
  rx1089_start:
    eq $I10, 1, rx1089_restart
    if_null rx1089_debug, debug_861
    rx1089_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_861:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1093_done
    goto rxscan1093_scan
  rxscan1093_loop:
    ($P10) = rx1089_cur."from"()
    inc $P10
    set rx1089_pos, $P10
    ge rx1089_pos, rx1089_eos, rxscan1093_done
  rxscan1093_scan:
    set_addr $I10, rxscan1093_loop
    rx1089_cur."!mark_push"(0, rx1089_pos, $I10)
  rxscan1093_done:
.annotate 'line', 510
  # rx literal  "["
    add $I11, rx1089_pos, 1
    gt $I11, rx1089_eos, rx1089_fail
    sub $I11, rx1089_pos, rx1089_off
    ord $I11, rx1089_tgt, $I11
    ne $I11, 91, rx1089_fail
    add rx1089_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1089_cur."!cursor_pos"(rx1089_pos)
    $P10 = rx1089_cur."ws"()
    unless $P10, rx1089_fail
    rx1089_pos = $P10."pos"()
  # rx rxquantr1094 ** 0..1
    set_addr $I10, rxquantr1094_done
    rx1089_cur."!mark_push"(0, rx1089_pos, $I10)
  rxquantr1094_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1089_cur."!cursor_pos"(rx1089_pos)
    $P10 = rx1089_cur."EXPR"()
    unless $P10, rx1089_fail
    goto rxsubrule1095_pass
  rxsubrule1095_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1089_fail
  rxsubrule1095_pass:
    set_addr $I10, rxsubrule1095_back
    rx1089_cur."!mark_push"(0, rx1089_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1089_pos = $P10."pos"()
    set_addr $I10, rxquantr1094_done
    (rx1089_rep) = rx1089_cur."!mark_commit"($I10)
  rxquantr1094_done:
  # rx literal  "]"
    add $I11, rx1089_pos, 1
    gt $I11, rx1089_eos, rx1089_fail
    sub $I11, rx1089_pos, rx1089_off
    ord $I11, rx1089_tgt, $I11
    ne $I11, 93, rx1089_fail
    add rx1089_pos, 1
  # rx pass
    rx1089_cur."!cursor_pass"(rx1089_pos, "circumfix:sym<[ ]>")
    if_null rx1089_debug, debug_862
    rx1089_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1089_pos)
  debug_862:
    .return (rx1089_cur)
  rx1089_restart:
.annotate 'line', 4
    if_null rx1089_debug, debug_863
    rx1089_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_863:
  rx1089_fail:
    (rx1089_rep, rx1089_pos, $I10, $P10) = rx1089_cur."!mark_fail"(0)
    lt rx1089_pos, -1, rx1089_done
    eq rx1089_pos, -1, rx1089_fail
    jump $I10
  rx1089_done:
    rx1089_cur."!cursor_fail"()
    if_null rx1089_debug, debug_864
    rx1089_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_864:
    .return (rx1089_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("252_1295307698.031") :method
.annotate 'line', 4
    $P1091 = self."!PREFIX__!subrule"("ws", "[")
    new $P1092, "ResizablePMCArray"
    push $P1092, $P1091
    .return ($P1092)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("253_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1097_tgt
    .local int rx1097_pos
    .local int rx1097_off
    .local int rx1097_eos
    .local int rx1097_rep
    .local pmc rx1097_cur
    .local pmc rx1097_debug
    (rx1097_cur, rx1097_pos, rx1097_tgt, $I10) = self."!cursor_start"()
    getattribute rx1097_debug, rx1097_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1097_cur
    .local pmc match
    .lex "$/", match
    length rx1097_eos, rx1097_tgt
    gt rx1097_pos, rx1097_eos, rx1097_done
    set rx1097_off, 0
    lt rx1097_pos, 2, rx1097_start
    sub rx1097_off, rx1097_pos, 1
    substr rx1097_tgt, rx1097_tgt, rx1097_off
  rx1097_start:
    eq $I10, 1, rx1097_restart
    if_null rx1097_debug, debug_865
    rx1097_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_865:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1100_done
    goto rxscan1100_scan
  rxscan1100_loop:
    ($P10) = rx1097_cur."from"()
    inc $P10
    set rx1097_pos, $P10
    ge rx1097_pos, rx1097_eos, rxscan1100_done
  rxscan1100_scan:
    set_addr $I10, rxscan1100_loop
    rx1097_cur."!mark_push"(0, rx1097_pos, $I10)
  rxscan1100_done:
.annotate 'line', 511
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1097_pos, rx1097_off
    substr $S10, rx1097_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1097_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1097_cur."!cursor_pos"(rx1097_pos)
    $P10 = rx1097_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1097_fail
    rx1097_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1097_pos = $P10."pos"()
  # rx pass
    rx1097_cur."!cursor_pass"(rx1097_pos, "circumfix:sym<ang>")
    if_null rx1097_debug, debug_866
    rx1097_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1097_pos)
  debug_866:
    .return (rx1097_cur)
  rx1097_restart:
.annotate 'line', 4
    if_null rx1097_debug, debug_867
    rx1097_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_867:
  rx1097_fail:
    (rx1097_rep, rx1097_pos, $I10, $P10) = rx1097_cur."!mark_fail"(0)
    lt rx1097_pos, -1, rx1097_done
    eq rx1097_pos, -1, rx1097_fail
    jump $I10
  rx1097_done:
    rx1097_cur."!cursor_fail"()
    if_null rx1097_debug, debug_868
    rx1097_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_868:
    .return (rx1097_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("254_1295307698.031") :method
.annotate 'line', 4
    new $P1099, "ResizablePMCArray"
    push $P1099, "<"
    .return ($P1099)
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("255_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1102_tgt
    .local int rx1102_pos
    .local int rx1102_off
    .local int rx1102_eos
    .local int rx1102_rep
    .local pmc rx1102_cur
    .local pmc rx1102_debug
    (rx1102_cur, rx1102_pos, rx1102_tgt, $I10) = self."!cursor_start"()
    getattribute rx1102_debug, rx1102_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1102_cur
    .local pmc match
    .lex "$/", match
    length rx1102_eos, rx1102_tgt
    gt rx1102_pos, rx1102_eos, rx1102_done
    set rx1102_off, 0
    lt rx1102_pos, 2, rx1102_start
    sub rx1102_off, rx1102_pos, 1
    substr rx1102_tgt, rx1102_tgt, rx1102_off
  rx1102_start:
    eq $I10, 1, rx1102_restart
    if_null rx1102_debug, debug_869
    rx1102_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_869:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1105_done
    goto rxscan1105_scan
  rxscan1105_loop:
    ($P10) = rx1102_cur."from"()
    inc $P10
    set rx1102_pos, $P10
    ge rx1102_pos, rx1102_eos, rxscan1105_done
  rxscan1105_scan:
    set_addr $I10, rxscan1105_loop
    rx1102_cur."!mark_push"(0, rx1102_pos, $I10)
  rxscan1105_done:
.annotate 'line', 512
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1102_pos, rx1102_off
    substr $S10, rx1102_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1102_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1102_cur."!cursor_pos"(rx1102_pos)
    $P10 = rx1102_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1102_fail
    rx1102_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1102_pos = $P10."pos"()
  # rx pass
    rx1102_cur."!cursor_pass"(rx1102_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1102_debug, debug_870
    rx1102_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1102_pos)
  debug_870:
    .return (rx1102_cur)
  rx1102_restart:
.annotate 'line', 4
    if_null rx1102_debug, debug_871
    rx1102_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_871:
  rx1102_fail:
    (rx1102_rep, rx1102_pos, $I10, $P10) = rx1102_cur."!mark_fail"(0)
    lt rx1102_pos, -1, rx1102_done
    eq rx1102_pos, -1, rx1102_fail
    jump $I10
  rx1102_done:
    rx1102_cur."!cursor_fail"()
    if_null rx1102_debug, debug_872
    rx1102_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_872:
    .return (rx1102_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("256_1295307698.031") :method
.annotate 'line', 4
    new $P1104, "ResizablePMCArray"
    push $P1104, unicode:"\x{ab}"
    .return ($P1104)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("257_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1107_tgt
    .local int rx1107_pos
    .local int rx1107_off
    .local int rx1107_eos
    .local int rx1107_rep
    .local pmc rx1107_cur
    .local pmc rx1107_debug
    (rx1107_cur, rx1107_pos, rx1107_tgt, $I10) = self."!cursor_start"()
    getattribute rx1107_debug, rx1107_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1107_cur
    .local pmc match
    .lex "$/", match
    length rx1107_eos, rx1107_tgt
    gt rx1107_pos, rx1107_eos, rx1107_done
    set rx1107_off, 0
    lt rx1107_pos, 2, rx1107_start
    sub rx1107_off, rx1107_pos, 1
    substr rx1107_tgt, rx1107_tgt, rx1107_off
  rx1107_start:
    eq $I10, 1, rx1107_restart
    if_null rx1107_debug, debug_873
    rx1107_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_873:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1110_done
    goto rxscan1110_scan
  rxscan1110_loop:
    ($P10) = rx1107_cur."from"()
    inc $P10
    set rx1107_pos, $P10
    ge rx1107_pos, rx1107_eos, rxscan1110_done
  rxscan1110_scan:
    set_addr $I10, rxscan1110_loop
    rx1107_cur."!mark_push"(0, rx1107_pos, $I10)
  rxscan1110_done:
.annotate 'line', 513
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1107_pos, rx1107_off
    substr $S10, rx1107_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1107_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1107_cur."!cursor_pos"(rx1107_pos)
    $P10 = rx1107_cur."pblock"()
    unless $P10, rx1107_fail
    rx1107_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1107_pos = $P10."pos"()
  # rx pass
    rx1107_cur."!cursor_pass"(rx1107_pos, "circumfix:sym<{ }>")
    if_null rx1107_debug, debug_874
    rx1107_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1107_pos)
  debug_874:
    .return (rx1107_cur)
  rx1107_restart:
.annotate 'line', 4
    if_null rx1107_debug, debug_875
    rx1107_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_875:
  rx1107_fail:
    (rx1107_rep, rx1107_pos, $I10, $P10) = rx1107_cur."!mark_fail"(0)
    lt rx1107_pos, -1, rx1107_done
    eq rx1107_pos, -1, rx1107_fail
    jump $I10
  rx1107_done:
    rx1107_cur."!cursor_fail"()
    if_null rx1107_debug, debug_876
    rx1107_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_876:
    .return (rx1107_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("258_1295307698.031") :method
.annotate 'line', 4
    new $P1109, "ResizablePMCArray"
    push $P1109, "{"
    .return ($P1109)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("259_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1112_tgt
    .local int rx1112_pos
    .local int rx1112_off
    .local int rx1112_eos
    .local int rx1112_rep
    .local pmc rx1112_cur
    .local pmc rx1112_debug
    (rx1112_cur, rx1112_pos, rx1112_tgt, $I10) = self."!cursor_start"()
    getattribute rx1112_debug, rx1112_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1112_cur
    .local pmc match
    .lex "$/", match
    length rx1112_eos, rx1112_tgt
    gt rx1112_pos, rx1112_eos, rx1112_done
    set rx1112_off, 0
    lt rx1112_pos, 2, rx1112_start
    sub rx1112_off, rx1112_pos, 1
    substr rx1112_tgt, rx1112_tgt, rx1112_off
  rx1112_start:
    eq $I10, 1, rx1112_restart
    if_null rx1112_debug, debug_877
    rx1112_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_877:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1116_done
    goto rxscan1116_scan
  rxscan1116_loop:
    ($P10) = rx1112_cur."from"()
    inc $P10
    set rx1112_pos, $P10
    ge rx1112_pos, rx1112_eos, rxscan1116_done
  rxscan1116_scan:
    set_addr $I10, rxscan1116_loop
    rx1112_cur."!mark_push"(0, rx1112_pos, $I10)
  rxscan1116_done:
.annotate 'line', 514
  # rx subrule "sigil" subtype=capture negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."sigil"()
    unless $P10, rx1112_fail
    rx1112_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1112_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1112_pos, 1
    gt $I11, rx1112_eos, rx1112_fail
    sub $I11, rx1112_pos, rx1112_off
    ord $I11, rx1112_tgt, $I11
    ne $I11, 40, rx1112_fail
    add rx1112_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."semilist"()
    unless $P10, rx1112_fail
    rx1112_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1112_pos = $P10."pos"()
  alt1117_0:
    set_addr $I10, alt1117_1
    rx1112_cur."!mark_push"(0, rx1112_pos, $I10)
  # rx literal  ")"
    add $I11, rx1112_pos, 1
    gt $I11, rx1112_eos, rx1112_fail
    sub $I11, rx1112_pos, rx1112_off
    ord $I11, rx1112_tgt, $I11
    ne $I11, 41, rx1112_fail
    add rx1112_pos, 1
    goto alt1117_end
  alt1117_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."FAILGOAL"("')'")
    unless $P10, rx1112_fail
    goto rxsubrule1119_pass
  rxsubrule1119_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1112_fail
  rxsubrule1119_pass:
    set_addr $I10, rxsubrule1119_back
    rx1112_cur."!mark_push"(0, rx1112_pos, $I10, $P10)
    rx1112_pos = $P10."pos"()
  alt1117_end:
  # rx pass
    rx1112_cur."!cursor_pass"(rx1112_pos, "circumfix:sym<sigil>")
    if_null rx1112_debug, debug_878
    rx1112_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1112_pos)
  debug_878:
    .return (rx1112_cur)
  rx1112_restart:
.annotate 'line', 4
    if_null rx1112_debug, debug_879
    rx1112_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_879:
  rx1112_fail:
    (rx1112_rep, rx1112_pos, $I10, $P10) = rx1112_cur."!mark_fail"(0)
    lt rx1112_pos, -1, rx1112_done
    eq rx1112_pos, -1, rx1112_fail
    jump $I10
  rx1112_done:
    rx1112_cur."!cursor_fail"()
    if_null rx1112_debug, debug_880
    rx1112_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_880:
    .return (rx1112_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("260_1295307698.031") :method
.annotate 'line', 4
    $P1114 = self."!PREFIX__!subrule"("sigil", "")
    new $P1115, "ResizablePMCArray"
    push $P1115, $P1114
    .return ($P1115)
.end


.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("261_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 4
    .local string rx1121_tgt
    .local int rx1121_pos
    .local int rx1121_off
    .local int rx1121_eos
    .local int rx1121_rep
    .local pmc rx1121_cur
    .local pmc rx1121_debug
    (rx1121_cur, rx1121_pos, rx1121_tgt, $I10) = self."!cursor_start"()
    getattribute rx1121_debug, rx1121_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1121_cur
    .local pmc match
    .lex "$/", match
    length rx1121_eos, rx1121_tgt
    gt rx1121_pos, rx1121_eos, rx1121_done
    set rx1121_off, 0
    lt rx1121_pos, 2, rx1121_start
    sub rx1121_off, rx1121_pos, 1
    substr rx1121_tgt, rx1121_tgt, rx1121_off
  rx1121_start:
    eq $I10, 1, rx1121_restart
    if_null rx1121_debug, debug_881
    rx1121_cur."!cursor_debug"("START", "semilist")
  debug_881:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1125_done
    goto rxscan1125_scan
  rxscan1125_loop:
    ($P10) = rx1121_cur."from"()
    inc $P10
    set rx1121_pos, $P10
    ge rx1121_pos, rx1121_eos, rxscan1125_done
  rxscan1125_scan:
    set_addr $I10, rxscan1125_loop
    rx1121_cur."!mark_push"(0, rx1121_pos, $I10)
  rxscan1125_done:
.annotate 'line', 516
  # rx subrule "ws" subtype=method negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."ws"()
    unless $P10, rx1121_fail
    rx1121_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."statement"()
    unless $P10, rx1121_fail
    rx1121_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1121_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."ws"()
    unless $P10, rx1121_fail
    rx1121_pos = $P10."pos"()
  # rx pass
    rx1121_cur."!cursor_pass"(rx1121_pos, "semilist")
    if_null rx1121_debug, debug_882
    rx1121_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1121_pos)
  debug_882:
    .return (rx1121_cur)
  rx1121_restart:
.annotate 'line', 4
    if_null rx1121_debug, debug_883
    rx1121_cur."!cursor_debug"("NEXT", "semilist")
  debug_883:
  rx1121_fail:
    (rx1121_rep, rx1121_pos, $I10, $P10) = rx1121_cur."!mark_fail"(0)
    lt rx1121_pos, -1, rx1121_done
    eq rx1121_pos, -1, rx1121_fail
    jump $I10
  rx1121_done:
    rx1121_cur."!cursor_fail"()
    if_null rx1121_debug, debug_884
    rx1121_cur."!cursor_debug"("FAIL", "semilist")
  debug_884:
    .return (rx1121_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("262_1295307698.031") :method
.annotate 'line', 4
    $P1123 = self."!PREFIX__!subrule"("ws", "")
    new $P1124, "ResizablePMCArray"
    push $P1124, $P1123
    .return ($P1124)
.end


.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("263_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1129_tgt
    .local int rx1129_pos
    .local int rx1129_off
    .local int rx1129_eos
    .local int rx1129_rep
    .local pmc rx1129_cur
    .local pmc rx1129_debug
    (rx1129_cur, rx1129_pos, rx1129_tgt, $I10) = self."!cursor_start"()
    getattribute rx1129_debug, rx1129_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1129_cur
    .local pmc match
    .lex "$/", match
    length rx1129_eos, rx1129_tgt
    gt rx1129_pos, rx1129_eos, rx1129_done
    set rx1129_off, 0
    lt rx1129_pos, 2, rx1129_start
    sub rx1129_off, rx1129_pos, 1
    substr rx1129_tgt, rx1129_tgt, rx1129_off
  rx1129_start:
    eq $I10, 1, rx1129_restart
    if_null rx1129_debug, debug_885
    rx1129_cur."!cursor_debug"("START", "infixish")
  debug_885:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1132_done
    goto rxscan1132_scan
  rxscan1132_loop:
    ($P10) = rx1129_cur."from"()
    inc $P10
    set rx1129_pos, $P10
    ge rx1129_pos, rx1129_eos, rxscan1132_done
  rxscan1132_scan:
    set_addr $I10, rxscan1132_loop
    rx1129_cur."!mark_push"(0, rx1129_pos, $I10)
  rxscan1132_done:
.annotate 'line', 539
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1129_cur."!cursor_pos"(rx1129_pos)
    $P10 = rx1129_cur."infixstopper"()
    if $P10, rx1129_fail
  # rx subrule "infix" subtype=capture negate=
    rx1129_cur."!cursor_pos"(rx1129_pos)
    $P10 = rx1129_cur."infix"()
    unless $P10, rx1129_fail
    rx1129_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1129_pos = $P10."pos"()
  # rx pass
    rx1129_cur."!cursor_pass"(rx1129_pos, "infixish")
    if_null rx1129_debug, debug_886
    rx1129_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1129_pos)
  debug_886:
    .return (rx1129_cur)
  rx1129_restart:
.annotate 'line', 520
    if_null rx1129_debug, debug_887
    rx1129_cur."!cursor_debug"("NEXT", "infixish")
  debug_887:
  rx1129_fail:
    (rx1129_rep, rx1129_pos, $I10, $P10) = rx1129_cur."!mark_fail"(0)
    lt rx1129_pos, -1, rx1129_done
    eq rx1129_pos, -1, rx1129_fail
    jump $I10
  rx1129_done:
    rx1129_cur."!cursor_fail"()
    if_null rx1129_debug, debug_888
    rx1129_cur."!cursor_debug"("FAIL", "infixish")
  debug_888:
    .return (rx1129_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("264_1295307698.031") :method
.annotate 'line', 520
    new $P1131, "ResizablePMCArray"
    push $P1131, ""
    .return ($P1131)
.end


.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("265_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1134_tgt
    .local int rx1134_pos
    .local int rx1134_off
    .local int rx1134_eos
    .local int rx1134_rep
    .local pmc rx1134_cur
    .local pmc rx1134_debug
    (rx1134_cur, rx1134_pos, rx1134_tgt, $I10) = self."!cursor_start"()
    getattribute rx1134_debug, rx1134_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1134_cur
    .local pmc match
    .lex "$/", match
    length rx1134_eos, rx1134_tgt
    gt rx1134_pos, rx1134_eos, rx1134_done
    set rx1134_off, 0
    lt rx1134_pos, 2, rx1134_start
    sub rx1134_off, rx1134_pos, 1
    substr rx1134_tgt, rx1134_tgt, rx1134_off
  rx1134_start:
    eq $I10, 1, rx1134_restart
    if_null rx1134_debug, debug_889
    rx1134_cur."!cursor_debug"("START", "infixstopper")
  debug_889:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1137_done
    goto rxscan1137_scan
  rxscan1137_loop:
    ($P10) = rx1134_cur."from"()
    inc $P10
    set rx1134_pos, $P10
    ge rx1134_pos, rx1134_eos, rxscan1137_done
  rxscan1137_scan:
    set_addr $I10, rxscan1137_loop
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  rxscan1137_done:
.annotate 'line', 540
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."lambda"()
    unless $P10, rx1134_fail
  # rx pass
    rx1134_cur."!cursor_pass"(rx1134_pos, "infixstopper")
    if_null rx1134_debug, debug_890
    rx1134_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1134_pos)
  debug_890:
    .return (rx1134_cur)
  rx1134_restart:
.annotate 'line', 520
    if_null rx1134_debug, debug_891
    rx1134_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_891:
  rx1134_fail:
    (rx1134_rep, rx1134_pos, $I10, $P10) = rx1134_cur."!mark_fail"(0)
    lt rx1134_pos, -1, rx1134_done
    eq rx1134_pos, -1, rx1134_fail
    jump $I10
  rx1134_done:
    rx1134_cur."!cursor_fail"()
    if_null rx1134_debug, debug_892
    rx1134_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_892:
    .return (rx1134_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("266_1295307698.031") :method
.annotate 'line', 520
    new $P1136, "ResizablePMCArray"
    push $P1136, ""
    .return ($P1136)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("267_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1139_tgt
    .local int rx1139_pos
    .local int rx1139_off
    .local int rx1139_eos
    .local int rx1139_rep
    .local pmc rx1139_cur
    .local pmc rx1139_debug
    (rx1139_cur, rx1139_pos, rx1139_tgt, $I10) = self."!cursor_start"()
    getattribute rx1139_debug, rx1139_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1139_cur
    .local pmc match
    .lex "$/", match
    length rx1139_eos, rx1139_tgt
    gt rx1139_pos, rx1139_eos, rx1139_done
    set rx1139_off, 0
    lt rx1139_pos, 2, rx1139_start
    sub rx1139_off, rx1139_pos, 1
    substr rx1139_tgt, rx1139_tgt, rx1139_off
  rx1139_start:
    eq $I10, 1, rx1139_restart
    if_null rx1139_debug, debug_893
    rx1139_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_893:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1143_done
    goto rxscan1143_scan
  rxscan1143_loop:
    ($P10) = rx1139_cur."from"()
    inc $P10
    set rx1139_pos, $P10
    ge rx1139_pos, rx1139_eos, rxscan1143_done
  rxscan1143_scan:
    set_addr $I10, rxscan1143_loop
    rx1139_cur."!mark_push"(0, rx1139_pos, $I10)
  rxscan1143_done:
.annotate 'line', 543
  # rx literal  "["
    add $I11, rx1139_pos, 1
    gt $I11, rx1139_eos, rx1139_fail
    sub $I11, rx1139_pos, rx1139_off
    ord $I11, rx1139_tgt, $I11
    ne $I11, 91, rx1139_fail
    add rx1139_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1139_cur."!cursor_pos"(rx1139_pos)
    $P10 = rx1139_cur."ws"()
    unless $P10, rx1139_fail
    rx1139_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1139_cur."!cursor_pos"(rx1139_pos)
    $P10 = rx1139_cur."EXPR"()
    unless $P10, rx1139_fail
    rx1139_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1139_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1139_pos, 1
    gt $I11, rx1139_eos, rx1139_fail
    sub $I11, rx1139_pos, rx1139_off
    ord $I11, rx1139_tgt, $I11
    ne $I11, 93, rx1139_fail
    add rx1139_pos, 1
.annotate 'line', 544
  # rx subrule "O" subtype=capture negate=
    rx1139_cur."!cursor_pos"(rx1139_pos)
    $P10 = rx1139_cur."O"("%methodop")
    unless $P10, rx1139_fail
    rx1139_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1139_pos = $P10."pos"()
.annotate 'line', 542
  # rx pass
    rx1139_cur."!cursor_pass"(rx1139_pos, "postcircumfix:sym<[ ]>")
    if_null rx1139_debug, debug_894
    rx1139_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1139_pos)
  debug_894:
    .return (rx1139_cur)
  rx1139_restart:
.annotate 'line', 520
    if_null rx1139_debug, debug_895
    rx1139_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_895:
  rx1139_fail:
    (rx1139_rep, rx1139_pos, $I10, $P10) = rx1139_cur."!mark_fail"(0)
    lt rx1139_pos, -1, rx1139_done
    eq rx1139_pos, -1, rx1139_fail
    jump $I10
  rx1139_done:
    rx1139_cur."!cursor_fail"()
    if_null rx1139_debug, debug_896
    rx1139_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_896:
    .return (rx1139_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("268_1295307698.031") :method
.annotate 'line', 520
    $P1141 = self."!PREFIX__!subrule"("ws", "[")
    new $P1142, "ResizablePMCArray"
    push $P1142, $P1141
    .return ($P1142)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("269_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1145_tgt
    .local int rx1145_pos
    .local int rx1145_off
    .local int rx1145_eos
    .local int rx1145_rep
    .local pmc rx1145_cur
    .local pmc rx1145_debug
    (rx1145_cur, rx1145_pos, rx1145_tgt, $I10) = self."!cursor_start"()
    getattribute rx1145_debug, rx1145_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1145_cur
    .local pmc match
    .lex "$/", match
    length rx1145_eos, rx1145_tgt
    gt rx1145_pos, rx1145_eos, rx1145_done
    set rx1145_off, 0
    lt rx1145_pos, 2, rx1145_start
    sub rx1145_off, rx1145_pos, 1
    substr rx1145_tgt, rx1145_tgt, rx1145_off
  rx1145_start:
    eq $I10, 1, rx1145_restart
    if_null rx1145_debug, debug_897
    rx1145_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_897:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1149_done
    goto rxscan1149_scan
  rxscan1149_loop:
    ($P10) = rx1145_cur."from"()
    inc $P10
    set rx1145_pos, $P10
    ge rx1145_pos, rx1145_eos, rxscan1149_done
  rxscan1149_scan:
    set_addr $I10, rxscan1149_loop
    rx1145_cur."!mark_push"(0, rx1145_pos, $I10)
  rxscan1149_done:
.annotate 'line', 548
  # rx literal  "{"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 123, rx1145_fail
    add rx1145_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."ws"()
    unless $P10, rx1145_fail
    rx1145_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."EXPR"()
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1145_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1145_pos, 1
    gt $I11, rx1145_eos, rx1145_fail
    sub $I11, rx1145_pos, rx1145_off
    ord $I11, rx1145_tgt, $I11
    ne $I11, 125, rx1145_fail
    add rx1145_pos, 1
.annotate 'line', 549
  # rx subrule "O" subtype=capture negate=
    rx1145_cur."!cursor_pos"(rx1145_pos)
    $P10 = rx1145_cur."O"("%methodop")
    unless $P10, rx1145_fail
    rx1145_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1145_pos = $P10."pos"()
.annotate 'line', 547
  # rx pass
    rx1145_cur."!cursor_pass"(rx1145_pos, "postcircumfix:sym<{ }>")
    if_null rx1145_debug, debug_898
    rx1145_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1145_pos)
  debug_898:
    .return (rx1145_cur)
  rx1145_restart:
.annotate 'line', 520
    if_null rx1145_debug, debug_899
    rx1145_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_899:
  rx1145_fail:
    (rx1145_rep, rx1145_pos, $I10, $P10) = rx1145_cur."!mark_fail"(0)
    lt rx1145_pos, -1, rx1145_done
    eq rx1145_pos, -1, rx1145_fail
    jump $I10
  rx1145_done:
    rx1145_cur."!cursor_fail"()
    if_null rx1145_debug, debug_900
    rx1145_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_900:
    .return (rx1145_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("270_1295307698.031") :method
.annotate 'line', 520
    $P1147 = self."!PREFIX__!subrule"("ws", "{")
    new $P1148, "ResizablePMCArray"
    push $P1148, $P1147
    .return ($P1148)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("271_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1151_tgt
    .local int rx1151_pos
    .local int rx1151_off
    .local int rx1151_eos
    .local int rx1151_rep
    .local pmc rx1151_cur
    .local pmc rx1151_debug
    (rx1151_cur, rx1151_pos, rx1151_tgt, $I10) = self."!cursor_start"()
    getattribute rx1151_debug, rx1151_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1151_cur
    .local pmc match
    .lex "$/", match
    length rx1151_eos, rx1151_tgt
    gt rx1151_pos, rx1151_eos, rx1151_done
    set rx1151_off, 0
    lt rx1151_pos, 2, rx1151_start
    sub rx1151_off, rx1151_pos, 1
    substr rx1151_tgt, rx1151_tgt, rx1151_off
  rx1151_start:
    eq $I10, 1, rx1151_restart
    if_null rx1151_debug, debug_901
    rx1151_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_901:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1154_done
    goto rxscan1154_scan
  rxscan1154_loop:
    ($P10) = rx1151_cur."from"()
    inc $P10
    set rx1151_pos, $P10
    ge rx1151_pos, rx1151_eos, rxscan1154_done
  rxscan1154_scan:
    set_addr $I10, rxscan1154_loop
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
  rxscan1154_done:
.annotate 'line', 553
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1151_pos, rx1151_off
    substr $S10, rx1151_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1151_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."quote_EXPR"(":q")
    unless $P10, rx1151_fail
    rx1151_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1151_pos = $P10."pos"()
.annotate 'line', 554
  # rx subrule "O" subtype=capture negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."O"("%methodop")
    unless $P10, rx1151_fail
    rx1151_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1151_pos = $P10."pos"()
.annotate 'line', 552
  # rx pass
    rx1151_cur."!cursor_pass"(rx1151_pos, "postcircumfix:sym<ang>")
    if_null rx1151_debug, debug_902
    rx1151_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1151_pos)
  debug_902:
    .return (rx1151_cur)
  rx1151_restart:
.annotate 'line', 520
    if_null rx1151_debug, debug_903
    rx1151_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_903:
  rx1151_fail:
    (rx1151_rep, rx1151_pos, $I10, $P10) = rx1151_cur."!mark_fail"(0)
    lt rx1151_pos, -1, rx1151_done
    eq rx1151_pos, -1, rx1151_fail
    jump $I10
  rx1151_done:
    rx1151_cur."!cursor_fail"()
    if_null rx1151_debug, debug_904
    rx1151_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_904:
    .return (rx1151_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("272_1295307698.031") :method
.annotate 'line', 520
    new $P1153, "ResizablePMCArray"
    push $P1153, "<"
    .return ($P1153)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("273_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1156_tgt
    .local int rx1156_pos
    .local int rx1156_off
    .local int rx1156_eos
    .local int rx1156_rep
    .local pmc rx1156_cur
    .local pmc rx1156_debug
    (rx1156_cur, rx1156_pos, rx1156_tgt, $I10) = self."!cursor_start"()
    getattribute rx1156_debug, rx1156_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1156_cur
    .local pmc match
    .lex "$/", match
    length rx1156_eos, rx1156_tgt
    gt rx1156_pos, rx1156_eos, rx1156_done
    set rx1156_off, 0
    lt rx1156_pos, 2, rx1156_start
    sub rx1156_off, rx1156_pos, 1
    substr rx1156_tgt, rx1156_tgt, rx1156_off
  rx1156_start:
    eq $I10, 1, rx1156_restart
    if_null rx1156_debug, debug_905
    rx1156_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_905:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1160_done
    goto rxscan1160_scan
  rxscan1160_loop:
    ($P10) = rx1156_cur."from"()
    inc $P10
    set rx1156_pos, $P10
    ge rx1156_pos, rx1156_eos, rxscan1160_done
  rxscan1160_scan:
    set_addr $I10, rxscan1160_loop
    rx1156_cur."!mark_push"(0, rx1156_pos, $I10)
  rxscan1160_done:
.annotate 'line', 558
  # rx literal  "("
    add $I11, rx1156_pos, 1
    gt $I11, rx1156_eos, rx1156_fail
    sub $I11, rx1156_pos, rx1156_off
    ord $I11, rx1156_tgt, $I11
    ne $I11, 40, rx1156_fail
    add rx1156_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1156_cur."!cursor_pos"(rx1156_pos)
    $P10 = rx1156_cur."ws"()
    unless $P10, rx1156_fail
    rx1156_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1156_cur."!cursor_pos"(rx1156_pos)
    $P10 = rx1156_cur."arglist"()
    unless $P10, rx1156_fail
    rx1156_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1156_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1156_pos, 1
    gt $I11, rx1156_eos, rx1156_fail
    sub $I11, rx1156_pos, rx1156_off
    ord $I11, rx1156_tgt, $I11
    ne $I11, 41, rx1156_fail
    add rx1156_pos, 1
.annotate 'line', 559
  # rx subrule "O" subtype=capture negate=
    rx1156_cur."!cursor_pos"(rx1156_pos)
    $P10 = rx1156_cur."O"("%methodop")
    unless $P10, rx1156_fail
    rx1156_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1156_pos = $P10."pos"()
.annotate 'line', 557
  # rx pass
    rx1156_cur."!cursor_pass"(rx1156_pos, "postcircumfix:sym<( )>")
    if_null rx1156_debug, debug_906
    rx1156_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1156_pos)
  debug_906:
    .return (rx1156_cur)
  rx1156_restart:
.annotate 'line', 520
    if_null rx1156_debug, debug_907
    rx1156_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_907:
  rx1156_fail:
    (rx1156_rep, rx1156_pos, $I10, $P10) = rx1156_cur."!mark_fail"(0)
    lt rx1156_pos, -1, rx1156_done
    eq rx1156_pos, -1, rx1156_fail
    jump $I10
  rx1156_done:
    rx1156_cur."!cursor_fail"()
    if_null rx1156_debug, debug_908
    rx1156_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_908:
    .return (rx1156_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("274_1295307698.031") :method
.annotate 'line', 520
    $P1158 = self."!PREFIX__!subrule"("ws", "(")
    new $P1159, "ResizablePMCArray"
    push $P1159, $P1158
    .return ($P1159)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("275_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1162_tgt
    .local int rx1162_pos
    .local int rx1162_off
    .local int rx1162_eos
    .local int rx1162_rep
    .local pmc rx1162_cur
    .local pmc rx1162_debug
    (rx1162_cur, rx1162_pos, rx1162_tgt, $I10) = self."!cursor_start"()
    getattribute rx1162_debug, rx1162_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1162_cur
    .local pmc match
    .lex "$/", match
    length rx1162_eos, rx1162_tgt
    gt rx1162_pos, rx1162_eos, rx1162_done
    set rx1162_off, 0
    lt rx1162_pos, 2, rx1162_start
    sub rx1162_off, rx1162_pos, 1
    substr rx1162_tgt, rx1162_tgt, rx1162_off
  rx1162_start:
    eq $I10, 1, rx1162_restart
    if_null rx1162_debug, debug_909
    rx1162_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_909:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1166_done
    goto rxscan1166_scan
  rxscan1166_loop:
    ($P10) = rx1162_cur."from"()
    inc $P10
    set rx1162_pos, $P10
    ge rx1162_pos, rx1162_eos, rxscan1166_done
  rxscan1166_scan:
    set_addr $I10, rxscan1166_loop
    rx1162_cur."!mark_push"(0, rx1162_pos, $I10)
  rxscan1166_done:
.annotate 'line', 562
  # rx subrule "dotty" subtype=capture negate=
    rx1162_cur."!cursor_pos"(rx1162_pos)
    $P10 = rx1162_cur."dotty"()
    unless $P10, rx1162_fail
    rx1162_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1162_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1162_cur."!cursor_pos"(rx1162_pos)
    $P10 = rx1162_cur."O"("%methodop")
    unless $P10, rx1162_fail
    rx1162_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1162_pos = $P10."pos"()
  # rx pass
    rx1162_cur."!cursor_pass"(rx1162_pos, "postfix:sym<.>")
    if_null rx1162_debug, debug_910
    rx1162_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1162_pos)
  debug_910:
    .return (rx1162_cur)
  rx1162_restart:
.annotate 'line', 520
    if_null rx1162_debug, debug_911
    rx1162_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_911:
  rx1162_fail:
    (rx1162_rep, rx1162_pos, $I10, $P10) = rx1162_cur."!mark_fail"(0)
    lt rx1162_pos, -1, rx1162_done
    eq rx1162_pos, -1, rx1162_fail
    jump $I10
  rx1162_done:
    rx1162_cur."!cursor_fail"()
    if_null rx1162_debug, debug_912
    rx1162_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_912:
    .return (rx1162_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("276_1295307698.031") :method
.annotate 'line', 520
    $P1164 = self."!PREFIX__!subrule"("dotty", "")
    new $P1165, "ResizablePMCArray"
    push $P1165, $P1164
    .return ($P1165)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("277_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1168_tgt
    .local int rx1168_pos
    .local int rx1168_off
    .local int rx1168_eos
    .local int rx1168_rep
    .local pmc rx1168_cur
    .local pmc rx1168_debug
    (rx1168_cur, rx1168_pos, rx1168_tgt, $I10) = self."!cursor_start"()
    getattribute rx1168_debug, rx1168_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1168_cur
    .local pmc match
    .lex "$/", match
    length rx1168_eos, rx1168_tgt
    gt rx1168_pos, rx1168_eos, rx1168_done
    set rx1168_off, 0
    lt rx1168_pos, 2, rx1168_start
    sub rx1168_off, rx1168_pos, 1
    substr rx1168_tgt, rx1168_tgt, rx1168_off
  rx1168_start:
    eq $I10, 1, rx1168_restart
    if_null rx1168_debug, debug_913
    rx1168_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_913:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1172_done
    goto rxscan1172_scan
  rxscan1172_loop:
    ($P10) = rx1168_cur."from"()
    inc $P10
    set rx1168_pos, $P10
    ge rx1168_pos, rx1168_eos, rxscan1172_done
  rxscan1172_scan:
    set_addr $I10, rxscan1172_loop
    rx1168_cur."!mark_push"(0, rx1168_pos, $I10)
  rxscan1172_done:
.annotate 'line', 564
  # rx subcapture "sym"
    set_addr $I10, rxcap_1173_fail
    rx1168_cur."!mark_push"(0, rx1168_pos, $I10)
  # rx literal  "++"
    add $I11, rx1168_pos, 2
    gt $I11, rx1168_eos, rx1168_fail
    sub $I11, rx1168_pos, rx1168_off
    substr $S10, rx1168_tgt, $I11, 2
    ne $S10, "++", rx1168_fail
    add rx1168_pos, 2
    set_addr $I10, rxcap_1173_fail
    ($I12, $I11) = rx1168_cur."!mark_peek"($I10)
    rx1168_cur."!cursor_pos"($I11)
    ($P10) = rx1168_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1168_pos, "")
    rx1168_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1173_done
  rxcap_1173_fail:
    goto rx1168_fail
  rxcap_1173_done:
  # rx subrule "O" subtype=capture negate=
    rx1168_cur."!cursor_pos"(rx1168_pos)
    $P10 = rx1168_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1168_fail
    rx1168_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1168_pos = $P10."pos"()
  # rx pass
    rx1168_cur."!cursor_pass"(rx1168_pos, "prefix:sym<++>")
    if_null rx1168_debug, debug_914
    rx1168_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1168_pos)
  debug_914:
    .return (rx1168_cur)
  rx1168_restart:
.annotate 'line', 520
    if_null rx1168_debug, debug_915
    rx1168_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_915:
  rx1168_fail:
    (rx1168_rep, rx1168_pos, $I10, $P10) = rx1168_cur."!mark_fail"(0)
    lt rx1168_pos, -1, rx1168_done
    eq rx1168_pos, -1, rx1168_fail
    jump $I10
  rx1168_done:
    rx1168_cur."!cursor_fail"()
    if_null rx1168_debug, debug_916
    rx1168_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_916:
    .return (rx1168_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("278_1295307698.031") :method
.annotate 'line', 520
    $P1170 = self."!PREFIX__!subrule"("O", "++")
    new $P1171, "ResizablePMCArray"
    push $P1171, $P1170
    .return ($P1171)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("279_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1175_tgt
    .local int rx1175_pos
    .local int rx1175_off
    .local int rx1175_eos
    .local int rx1175_rep
    .local pmc rx1175_cur
    .local pmc rx1175_debug
    (rx1175_cur, rx1175_pos, rx1175_tgt, $I10) = self."!cursor_start"()
    getattribute rx1175_debug, rx1175_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1175_cur
    .local pmc match
    .lex "$/", match
    length rx1175_eos, rx1175_tgt
    gt rx1175_pos, rx1175_eos, rx1175_done
    set rx1175_off, 0
    lt rx1175_pos, 2, rx1175_start
    sub rx1175_off, rx1175_pos, 1
    substr rx1175_tgt, rx1175_tgt, rx1175_off
  rx1175_start:
    eq $I10, 1, rx1175_restart
    if_null rx1175_debug, debug_917
    rx1175_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_917:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1179_done
    goto rxscan1179_scan
  rxscan1179_loop:
    ($P10) = rx1175_cur."from"()
    inc $P10
    set rx1175_pos, $P10
    ge rx1175_pos, rx1175_eos, rxscan1179_done
  rxscan1179_scan:
    set_addr $I10, rxscan1179_loop
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  rxscan1179_done:
.annotate 'line', 565
  # rx subcapture "sym"
    set_addr $I10, rxcap_1180_fail
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  # rx literal  "--"
    add $I11, rx1175_pos, 2
    gt $I11, rx1175_eos, rx1175_fail
    sub $I11, rx1175_pos, rx1175_off
    substr $S10, rx1175_tgt, $I11, 2
    ne $S10, "--", rx1175_fail
    add rx1175_pos, 2
    set_addr $I10, rxcap_1180_fail
    ($I12, $I11) = rx1175_cur."!mark_peek"($I10)
    rx1175_cur."!cursor_pos"($I11)
    ($P10) = rx1175_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1175_pos, "")
    rx1175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1180_done
  rxcap_1180_fail:
    goto rx1175_fail
  rxcap_1180_done:
  # rx subrule "O" subtype=capture negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1175_fail
    rx1175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1175_pos = $P10."pos"()
  # rx pass
    rx1175_cur."!cursor_pass"(rx1175_pos, "prefix:sym<-->")
    if_null rx1175_debug, debug_918
    rx1175_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1175_pos)
  debug_918:
    .return (rx1175_cur)
  rx1175_restart:
.annotate 'line', 520
    if_null rx1175_debug, debug_919
    rx1175_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_919:
  rx1175_fail:
    (rx1175_rep, rx1175_pos, $I10, $P10) = rx1175_cur."!mark_fail"(0)
    lt rx1175_pos, -1, rx1175_done
    eq rx1175_pos, -1, rx1175_fail
    jump $I10
  rx1175_done:
    rx1175_cur."!cursor_fail"()
    if_null rx1175_debug, debug_920
    rx1175_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_920:
    .return (rx1175_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("280_1295307698.031") :method
.annotate 'line', 520
    $P1177 = self."!PREFIX__!subrule"("O", "--")
    new $P1178, "ResizablePMCArray"
    push $P1178, $P1177
    .return ($P1178)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("281_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1182_tgt
    .local int rx1182_pos
    .local int rx1182_off
    .local int rx1182_eos
    .local int rx1182_rep
    .local pmc rx1182_cur
    .local pmc rx1182_debug
    (rx1182_cur, rx1182_pos, rx1182_tgt, $I10) = self."!cursor_start"()
    getattribute rx1182_debug, rx1182_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1182_cur
    .local pmc match
    .lex "$/", match
    length rx1182_eos, rx1182_tgt
    gt rx1182_pos, rx1182_eos, rx1182_done
    set rx1182_off, 0
    lt rx1182_pos, 2, rx1182_start
    sub rx1182_off, rx1182_pos, 1
    substr rx1182_tgt, rx1182_tgt, rx1182_off
  rx1182_start:
    eq $I10, 1, rx1182_restart
    if_null rx1182_debug, debug_921
    rx1182_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_921:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1186_done
    goto rxscan1186_scan
  rxscan1186_loop:
    ($P10) = rx1182_cur."from"()
    inc $P10
    set rx1182_pos, $P10
    ge rx1182_pos, rx1182_eos, rxscan1186_done
  rxscan1186_scan:
    set_addr $I10, rxscan1186_loop
    rx1182_cur."!mark_push"(0, rx1182_pos, $I10)
  rxscan1186_done:
.annotate 'line', 568
  # rx subcapture "sym"
    set_addr $I10, rxcap_1187_fail
    rx1182_cur."!mark_push"(0, rx1182_pos, $I10)
  # rx literal  "++"
    add $I11, rx1182_pos, 2
    gt $I11, rx1182_eos, rx1182_fail
    sub $I11, rx1182_pos, rx1182_off
    substr $S10, rx1182_tgt, $I11, 2
    ne $S10, "++", rx1182_fail
    add rx1182_pos, 2
    set_addr $I10, rxcap_1187_fail
    ($I12, $I11) = rx1182_cur."!mark_peek"($I10)
    rx1182_cur."!cursor_pos"($I11)
    ($P10) = rx1182_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1182_pos, "")
    rx1182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1187_done
  rxcap_1187_fail:
    goto rx1182_fail
  rxcap_1187_done:
  # rx subrule "O" subtype=capture negate=
    rx1182_cur."!cursor_pos"(rx1182_pos)
    $P10 = rx1182_cur."O"("%autoincrement")
    unless $P10, rx1182_fail
    rx1182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1182_pos = $P10."pos"()
  # rx pass
    rx1182_cur."!cursor_pass"(rx1182_pos, "postfix:sym<++>")
    if_null rx1182_debug, debug_922
    rx1182_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1182_pos)
  debug_922:
    .return (rx1182_cur)
  rx1182_restart:
.annotate 'line', 520
    if_null rx1182_debug, debug_923
    rx1182_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_923:
  rx1182_fail:
    (rx1182_rep, rx1182_pos, $I10, $P10) = rx1182_cur."!mark_fail"(0)
    lt rx1182_pos, -1, rx1182_done
    eq rx1182_pos, -1, rx1182_fail
    jump $I10
  rx1182_done:
    rx1182_cur."!cursor_fail"()
    if_null rx1182_debug, debug_924
    rx1182_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_924:
    .return (rx1182_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("282_1295307698.031") :method
.annotate 'line', 520
    $P1184 = self."!PREFIX__!subrule"("O", "++")
    new $P1185, "ResizablePMCArray"
    push $P1185, $P1184
    .return ($P1185)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("283_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1189_tgt
    .local int rx1189_pos
    .local int rx1189_off
    .local int rx1189_eos
    .local int rx1189_rep
    .local pmc rx1189_cur
    .local pmc rx1189_debug
    (rx1189_cur, rx1189_pos, rx1189_tgt, $I10) = self."!cursor_start"()
    getattribute rx1189_debug, rx1189_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1189_cur
    .local pmc match
    .lex "$/", match
    length rx1189_eos, rx1189_tgt
    gt rx1189_pos, rx1189_eos, rx1189_done
    set rx1189_off, 0
    lt rx1189_pos, 2, rx1189_start
    sub rx1189_off, rx1189_pos, 1
    substr rx1189_tgt, rx1189_tgt, rx1189_off
  rx1189_start:
    eq $I10, 1, rx1189_restart
    if_null rx1189_debug, debug_925
    rx1189_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_925:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1193_done
    goto rxscan1193_scan
  rxscan1193_loop:
    ($P10) = rx1189_cur."from"()
    inc $P10
    set rx1189_pos, $P10
    ge rx1189_pos, rx1189_eos, rxscan1193_done
  rxscan1193_scan:
    set_addr $I10, rxscan1193_loop
    rx1189_cur."!mark_push"(0, rx1189_pos, $I10)
  rxscan1193_done:
.annotate 'line', 569
  # rx subcapture "sym"
    set_addr $I10, rxcap_1194_fail
    rx1189_cur."!mark_push"(0, rx1189_pos, $I10)
  # rx literal  "--"
    add $I11, rx1189_pos, 2
    gt $I11, rx1189_eos, rx1189_fail
    sub $I11, rx1189_pos, rx1189_off
    substr $S10, rx1189_tgt, $I11, 2
    ne $S10, "--", rx1189_fail
    add rx1189_pos, 2
    set_addr $I10, rxcap_1194_fail
    ($I12, $I11) = rx1189_cur."!mark_peek"($I10)
    rx1189_cur."!cursor_pos"($I11)
    ($P10) = rx1189_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1189_pos, "")
    rx1189_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1194_done
  rxcap_1194_fail:
    goto rx1189_fail
  rxcap_1194_done:
  # rx subrule "O" subtype=capture negate=
    rx1189_cur."!cursor_pos"(rx1189_pos)
    $P10 = rx1189_cur."O"("%autoincrement")
    unless $P10, rx1189_fail
    rx1189_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1189_pos = $P10."pos"()
  # rx pass
    rx1189_cur."!cursor_pass"(rx1189_pos, "postfix:sym<-->")
    if_null rx1189_debug, debug_926
    rx1189_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1189_pos)
  debug_926:
    .return (rx1189_cur)
  rx1189_restart:
.annotate 'line', 520
    if_null rx1189_debug, debug_927
    rx1189_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_927:
  rx1189_fail:
    (rx1189_rep, rx1189_pos, $I10, $P10) = rx1189_cur."!mark_fail"(0)
    lt rx1189_pos, -1, rx1189_done
    eq rx1189_pos, -1, rx1189_fail
    jump $I10
  rx1189_done:
    rx1189_cur."!cursor_fail"()
    if_null rx1189_debug, debug_928
    rx1189_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_928:
    .return (rx1189_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("284_1295307698.031") :method
.annotate 'line', 520
    $P1191 = self."!PREFIX__!subrule"("O", "--")
    new $P1192, "ResizablePMCArray"
    push $P1192, $P1191
    .return ($P1192)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("285_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1196_tgt
    .local int rx1196_pos
    .local int rx1196_off
    .local int rx1196_eos
    .local int rx1196_rep
    .local pmc rx1196_cur
    .local pmc rx1196_debug
    (rx1196_cur, rx1196_pos, rx1196_tgt, $I10) = self."!cursor_start"()
    getattribute rx1196_debug, rx1196_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1196_cur
    .local pmc match
    .lex "$/", match
    length rx1196_eos, rx1196_tgt
    gt rx1196_pos, rx1196_eos, rx1196_done
    set rx1196_off, 0
    lt rx1196_pos, 2, rx1196_start
    sub rx1196_off, rx1196_pos, 1
    substr rx1196_tgt, rx1196_tgt, rx1196_off
  rx1196_start:
    eq $I10, 1, rx1196_restart
    if_null rx1196_debug, debug_929
    rx1196_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_929:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1200_done
    goto rxscan1200_scan
  rxscan1200_loop:
    ($P10) = rx1196_cur."from"()
    inc $P10
    set rx1196_pos, $P10
    ge rx1196_pos, rx1196_eos, rxscan1200_done
  rxscan1200_scan:
    set_addr $I10, rxscan1200_loop
    rx1196_cur."!mark_push"(0, rx1196_pos, $I10)
  rxscan1200_done:
.annotate 'line', 571
  # rx subcapture "sym"
    set_addr $I10, rxcap_1201_fail
    rx1196_cur."!mark_push"(0, rx1196_pos, $I10)
  # rx literal  "**"
    add $I11, rx1196_pos, 2
    gt $I11, rx1196_eos, rx1196_fail
    sub $I11, rx1196_pos, rx1196_off
    substr $S10, rx1196_tgt, $I11, 2
    ne $S10, "**", rx1196_fail
    add rx1196_pos, 2
    set_addr $I10, rxcap_1201_fail
    ($I12, $I11) = rx1196_cur."!mark_peek"($I10)
    rx1196_cur."!cursor_pos"($I11)
    ($P10) = rx1196_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1196_pos, "")
    rx1196_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1201_done
  rxcap_1201_fail:
    goto rx1196_fail
  rxcap_1201_done:
  # rx subrule "O" subtype=capture negate=
    rx1196_cur."!cursor_pos"(rx1196_pos)
    $P10 = rx1196_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1196_fail
    rx1196_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1196_pos = $P10."pos"()
  # rx pass
    rx1196_cur."!cursor_pass"(rx1196_pos, "infix:sym<**>")
    if_null rx1196_debug, debug_930
    rx1196_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1196_pos)
  debug_930:
    .return (rx1196_cur)
  rx1196_restart:
.annotate 'line', 520
    if_null rx1196_debug, debug_931
    rx1196_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_931:
  rx1196_fail:
    (rx1196_rep, rx1196_pos, $I10, $P10) = rx1196_cur."!mark_fail"(0)
    lt rx1196_pos, -1, rx1196_done
    eq rx1196_pos, -1, rx1196_fail
    jump $I10
  rx1196_done:
    rx1196_cur."!cursor_fail"()
    if_null rx1196_debug, debug_932
    rx1196_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_932:
    .return (rx1196_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("286_1295307698.031") :method
.annotate 'line', 520
    $P1198 = self."!PREFIX__!subrule"("O", "**")
    new $P1199, "ResizablePMCArray"
    push $P1199, $P1198
    .return ($P1199)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("287_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1203_tgt
    .local int rx1203_pos
    .local int rx1203_off
    .local int rx1203_eos
    .local int rx1203_rep
    .local pmc rx1203_cur
    .local pmc rx1203_debug
    (rx1203_cur, rx1203_pos, rx1203_tgt, $I10) = self."!cursor_start"()
    getattribute rx1203_debug, rx1203_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1203_cur
    .local pmc match
    .lex "$/", match
    length rx1203_eos, rx1203_tgt
    gt rx1203_pos, rx1203_eos, rx1203_done
    set rx1203_off, 0
    lt rx1203_pos, 2, rx1203_start
    sub rx1203_off, rx1203_pos, 1
    substr rx1203_tgt, rx1203_tgt, rx1203_off
  rx1203_start:
    eq $I10, 1, rx1203_restart
    if_null rx1203_debug, debug_933
    rx1203_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_933:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1207_done
    goto rxscan1207_scan
  rxscan1207_loop:
    ($P10) = rx1203_cur."from"()
    inc $P10
    set rx1203_pos, $P10
    ge rx1203_pos, rx1203_eos, rxscan1207_done
  rxscan1207_scan:
    set_addr $I10, rxscan1207_loop
    rx1203_cur."!mark_push"(0, rx1203_pos, $I10)
  rxscan1207_done:
.annotate 'line', 573
  # rx subcapture "sym"
    set_addr $I10, rxcap_1208_fail
    rx1203_cur."!mark_push"(0, rx1203_pos, $I10)
  # rx literal  "+"
    add $I11, rx1203_pos, 1
    gt $I11, rx1203_eos, rx1203_fail
    sub $I11, rx1203_pos, rx1203_off
    ord $I11, rx1203_tgt, $I11
    ne $I11, 43, rx1203_fail
    add rx1203_pos, 1
    set_addr $I10, rxcap_1208_fail
    ($I12, $I11) = rx1203_cur."!mark_peek"($I10)
    rx1203_cur."!cursor_pos"($I11)
    ($P10) = rx1203_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1203_pos, "")
    rx1203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1208_done
  rxcap_1208_fail:
    goto rx1203_fail
  rxcap_1208_done:
  # rx subrule "O" subtype=capture negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1203_fail
    rx1203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1203_pos = $P10."pos"()
  # rx pass
    rx1203_cur."!cursor_pass"(rx1203_pos, "prefix:sym<+>")
    if_null rx1203_debug, debug_934
    rx1203_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1203_pos)
  debug_934:
    .return (rx1203_cur)
  rx1203_restart:
.annotate 'line', 520
    if_null rx1203_debug, debug_935
    rx1203_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_935:
  rx1203_fail:
    (rx1203_rep, rx1203_pos, $I10, $P10) = rx1203_cur."!mark_fail"(0)
    lt rx1203_pos, -1, rx1203_done
    eq rx1203_pos, -1, rx1203_fail
    jump $I10
  rx1203_done:
    rx1203_cur."!cursor_fail"()
    if_null rx1203_debug, debug_936
    rx1203_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_936:
    .return (rx1203_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("288_1295307698.031") :method
.annotate 'line', 520
    $P1205 = self."!PREFIX__!subrule"("O", "+")
    new $P1206, "ResizablePMCArray"
    push $P1206, $P1205
    .return ($P1206)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("289_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1210_tgt
    .local int rx1210_pos
    .local int rx1210_off
    .local int rx1210_eos
    .local int rx1210_rep
    .local pmc rx1210_cur
    .local pmc rx1210_debug
    (rx1210_cur, rx1210_pos, rx1210_tgt, $I10) = self."!cursor_start"()
    getattribute rx1210_debug, rx1210_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1210_cur
    .local pmc match
    .lex "$/", match
    length rx1210_eos, rx1210_tgt
    gt rx1210_pos, rx1210_eos, rx1210_done
    set rx1210_off, 0
    lt rx1210_pos, 2, rx1210_start
    sub rx1210_off, rx1210_pos, 1
    substr rx1210_tgt, rx1210_tgt, rx1210_off
  rx1210_start:
    eq $I10, 1, rx1210_restart
    if_null rx1210_debug, debug_937
    rx1210_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_937:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1214_done
    goto rxscan1214_scan
  rxscan1214_loop:
    ($P10) = rx1210_cur."from"()
    inc $P10
    set rx1210_pos, $P10
    ge rx1210_pos, rx1210_eos, rxscan1214_done
  rxscan1214_scan:
    set_addr $I10, rxscan1214_loop
    rx1210_cur."!mark_push"(0, rx1210_pos, $I10)
  rxscan1214_done:
.annotate 'line', 574
  # rx subcapture "sym"
    set_addr $I10, rxcap_1215_fail
    rx1210_cur."!mark_push"(0, rx1210_pos, $I10)
  # rx literal  "~"
    add $I11, rx1210_pos, 1
    gt $I11, rx1210_eos, rx1210_fail
    sub $I11, rx1210_pos, rx1210_off
    ord $I11, rx1210_tgt, $I11
    ne $I11, 126, rx1210_fail
    add rx1210_pos, 1
    set_addr $I10, rxcap_1215_fail
    ($I12, $I11) = rx1210_cur."!mark_peek"($I10)
    rx1210_cur."!cursor_pos"($I11)
    ($P10) = rx1210_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1210_pos, "")
    rx1210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1215_done
  rxcap_1215_fail:
    goto rx1210_fail
  rxcap_1215_done:
  # rx subrule "O" subtype=capture negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1210_fail
    rx1210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1210_pos = $P10."pos"()
  # rx pass
    rx1210_cur."!cursor_pass"(rx1210_pos, "prefix:sym<~>")
    if_null rx1210_debug, debug_938
    rx1210_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1210_pos)
  debug_938:
    .return (rx1210_cur)
  rx1210_restart:
.annotate 'line', 520
    if_null rx1210_debug, debug_939
    rx1210_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_939:
  rx1210_fail:
    (rx1210_rep, rx1210_pos, $I10, $P10) = rx1210_cur."!mark_fail"(0)
    lt rx1210_pos, -1, rx1210_done
    eq rx1210_pos, -1, rx1210_fail
    jump $I10
  rx1210_done:
    rx1210_cur."!cursor_fail"()
    if_null rx1210_debug, debug_940
    rx1210_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_940:
    .return (rx1210_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("290_1295307698.031") :method
.annotate 'line', 520
    $P1212 = self."!PREFIX__!subrule"("O", "~")
    new $P1213, "ResizablePMCArray"
    push $P1213, $P1212
    .return ($P1213)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("291_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1217_tgt
    .local int rx1217_pos
    .local int rx1217_off
    .local int rx1217_eos
    .local int rx1217_rep
    .local pmc rx1217_cur
    .local pmc rx1217_debug
    (rx1217_cur, rx1217_pos, rx1217_tgt, $I10) = self."!cursor_start"()
    getattribute rx1217_debug, rx1217_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1217_cur
    .local pmc match
    .lex "$/", match
    length rx1217_eos, rx1217_tgt
    gt rx1217_pos, rx1217_eos, rx1217_done
    set rx1217_off, 0
    lt rx1217_pos, 2, rx1217_start
    sub rx1217_off, rx1217_pos, 1
    substr rx1217_tgt, rx1217_tgt, rx1217_off
  rx1217_start:
    eq $I10, 1, rx1217_restart
    if_null rx1217_debug, debug_941
    rx1217_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1220_done
    goto rxscan1220_scan
  rxscan1220_loop:
    ($P10) = rx1217_cur."from"()
    inc $P10
    set rx1217_pos, $P10
    ge rx1217_pos, rx1217_eos, rxscan1220_done
  rxscan1220_scan:
    set_addr $I10, rxscan1220_loop
    rx1217_cur."!mark_push"(0, rx1217_pos, $I10)
  rxscan1220_done:
.annotate 'line', 575
  # rx subcapture "sym"
    set_addr $I10, rxcap_1221_fail
    rx1217_cur."!mark_push"(0, rx1217_pos, $I10)
  # rx literal  "-"
    add $I11, rx1217_pos, 1
    gt $I11, rx1217_eos, rx1217_fail
    sub $I11, rx1217_pos, rx1217_off
    ord $I11, rx1217_tgt, $I11
    ne $I11, 45, rx1217_fail
    add rx1217_pos, 1
    set_addr $I10, rxcap_1221_fail
    ($I12, $I11) = rx1217_cur."!mark_peek"($I10)
    rx1217_cur."!cursor_pos"($I11)
    ($P10) = rx1217_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1217_pos, "")
    rx1217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1221_done
  rxcap_1221_fail:
    goto rx1217_fail
  rxcap_1221_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1217_pos, rx1217_off
    substr $S10, rx1217_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1217_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1217_cur."!cursor_pos"(rx1217_pos)
    $P10 = rx1217_cur."number"()
    if $P10, rx1217_fail
  # rx subrule "O" subtype=capture negate=
    rx1217_cur."!cursor_pos"(rx1217_pos)
    $P10 = rx1217_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1217_fail
    rx1217_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1217_pos = $P10."pos"()
  # rx pass
    rx1217_cur."!cursor_pass"(rx1217_pos, "prefix:sym<->")
    if_null rx1217_debug, debug_942
    rx1217_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1217_pos)
  debug_942:
    .return (rx1217_cur)
  rx1217_restart:
.annotate 'line', 520
    if_null rx1217_debug, debug_943
    rx1217_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_943:
  rx1217_fail:
    (rx1217_rep, rx1217_pos, $I10, $P10) = rx1217_cur."!mark_fail"(0)
    lt rx1217_pos, -1, rx1217_done
    eq rx1217_pos, -1, rx1217_fail
    jump $I10
  rx1217_done:
    rx1217_cur."!cursor_fail"()
    if_null rx1217_debug, debug_944
    rx1217_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_944:
    .return (rx1217_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("292_1295307698.031") :method
.annotate 'line', 520
    new $P1219, "ResizablePMCArray"
    push $P1219, "-"
    .return ($P1219)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("293_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1223_tgt
    .local int rx1223_pos
    .local int rx1223_off
    .local int rx1223_eos
    .local int rx1223_rep
    .local pmc rx1223_cur
    .local pmc rx1223_debug
    (rx1223_cur, rx1223_pos, rx1223_tgt, $I10) = self."!cursor_start"()
    getattribute rx1223_debug, rx1223_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1223_cur
    .local pmc match
    .lex "$/", match
    length rx1223_eos, rx1223_tgt
    gt rx1223_pos, rx1223_eos, rx1223_done
    set rx1223_off, 0
    lt rx1223_pos, 2, rx1223_start
    sub rx1223_off, rx1223_pos, 1
    substr rx1223_tgt, rx1223_tgt, rx1223_off
  rx1223_start:
    eq $I10, 1, rx1223_restart
    if_null rx1223_debug, debug_945
    rx1223_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1227_done
    goto rxscan1227_scan
  rxscan1227_loop:
    ($P10) = rx1223_cur."from"()
    inc $P10
    set rx1223_pos, $P10
    ge rx1223_pos, rx1223_eos, rxscan1227_done
  rxscan1227_scan:
    set_addr $I10, rxscan1227_loop
    rx1223_cur."!mark_push"(0, rx1223_pos, $I10)
  rxscan1227_done:
.annotate 'line', 576
  # rx subcapture "sym"
    set_addr $I10, rxcap_1228_fail
    rx1223_cur."!mark_push"(0, rx1223_pos, $I10)
  # rx literal  "?"
    add $I11, rx1223_pos, 1
    gt $I11, rx1223_eos, rx1223_fail
    sub $I11, rx1223_pos, rx1223_off
    ord $I11, rx1223_tgt, $I11
    ne $I11, 63, rx1223_fail
    add rx1223_pos, 1
    set_addr $I10, rxcap_1228_fail
    ($I12, $I11) = rx1223_cur."!mark_peek"($I10)
    rx1223_cur."!cursor_pos"($I11)
    ($P10) = rx1223_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1223_pos, "")
    rx1223_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1228_done
  rxcap_1228_fail:
    goto rx1223_fail
  rxcap_1228_done:
  # rx subrule "O" subtype=capture negate=
    rx1223_cur."!cursor_pos"(rx1223_pos)
    $P10 = rx1223_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1223_fail
    rx1223_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1223_pos = $P10."pos"()
  # rx pass
    rx1223_cur."!cursor_pass"(rx1223_pos, "prefix:sym<?>")
    if_null rx1223_debug, debug_946
    rx1223_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1223_pos)
  debug_946:
    .return (rx1223_cur)
  rx1223_restart:
.annotate 'line', 520
    if_null rx1223_debug, debug_947
    rx1223_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_947:
  rx1223_fail:
    (rx1223_rep, rx1223_pos, $I10, $P10) = rx1223_cur."!mark_fail"(0)
    lt rx1223_pos, -1, rx1223_done
    eq rx1223_pos, -1, rx1223_fail
    jump $I10
  rx1223_done:
    rx1223_cur."!cursor_fail"()
    if_null rx1223_debug, debug_948
    rx1223_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_948:
    .return (rx1223_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("294_1295307698.031") :method
.annotate 'line', 520
    $P1225 = self."!PREFIX__!subrule"("O", "?")
    new $P1226, "ResizablePMCArray"
    push $P1226, $P1225
    .return ($P1226)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("295_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1230_tgt
    .local int rx1230_pos
    .local int rx1230_off
    .local int rx1230_eos
    .local int rx1230_rep
    .local pmc rx1230_cur
    .local pmc rx1230_debug
    (rx1230_cur, rx1230_pos, rx1230_tgt, $I10) = self."!cursor_start"()
    getattribute rx1230_debug, rx1230_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1230_cur
    .local pmc match
    .lex "$/", match
    length rx1230_eos, rx1230_tgt
    gt rx1230_pos, rx1230_eos, rx1230_done
    set rx1230_off, 0
    lt rx1230_pos, 2, rx1230_start
    sub rx1230_off, rx1230_pos, 1
    substr rx1230_tgt, rx1230_tgt, rx1230_off
  rx1230_start:
    eq $I10, 1, rx1230_restart
    if_null rx1230_debug, debug_949
    rx1230_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1234_done
    goto rxscan1234_scan
  rxscan1234_loop:
    ($P10) = rx1230_cur."from"()
    inc $P10
    set rx1230_pos, $P10
    ge rx1230_pos, rx1230_eos, rxscan1234_done
  rxscan1234_scan:
    set_addr $I10, rxscan1234_loop
    rx1230_cur."!mark_push"(0, rx1230_pos, $I10)
  rxscan1234_done:
.annotate 'line', 577
  # rx subcapture "sym"
    set_addr $I10, rxcap_1235_fail
    rx1230_cur."!mark_push"(0, rx1230_pos, $I10)
  # rx literal  "!"
    add $I11, rx1230_pos, 1
    gt $I11, rx1230_eos, rx1230_fail
    sub $I11, rx1230_pos, rx1230_off
    ord $I11, rx1230_tgt, $I11
    ne $I11, 33, rx1230_fail
    add rx1230_pos, 1
    set_addr $I10, rxcap_1235_fail
    ($I12, $I11) = rx1230_cur."!mark_peek"($I10)
    rx1230_cur."!cursor_pos"($I11)
    ($P10) = rx1230_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1230_pos, "")
    rx1230_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1235_done
  rxcap_1235_fail:
    goto rx1230_fail
  rxcap_1235_done:
  # rx subrule "O" subtype=capture negate=
    rx1230_cur."!cursor_pos"(rx1230_pos)
    $P10 = rx1230_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1230_fail
    rx1230_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1230_pos = $P10."pos"()
  # rx pass
    rx1230_cur."!cursor_pass"(rx1230_pos, "prefix:sym<!>")
    if_null rx1230_debug, debug_950
    rx1230_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1230_pos)
  debug_950:
    .return (rx1230_cur)
  rx1230_restart:
.annotate 'line', 520
    if_null rx1230_debug, debug_951
    rx1230_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_951:
  rx1230_fail:
    (rx1230_rep, rx1230_pos, $I10, $P10) = rx1230_cur."!mark_fail"(0)
    lt rx1230_pos, -1, rx1230_done
    eq rx1230_pos, -1, rx1230_fail
    jump $I10
  rx1230_done:
    rx1230_cur."!cursor_fail"()
    if_null rx1230_debug, debug_952
    rx1230_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_952:
    .return (rx1230_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("296_1295307698.031") :method
.annotate 'line', 520
    $P1232 = self."!PREFIX__!subrule"("O", "!")
    new $P1233, "ResizablePMCArray"
    push $P1233, $P1232
    .return ($P1233)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("297_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1237_tgt
    .local int rx1237_pos
    .local int rx1237_off
    .local int rx1237_eos
    .local int rx1237_rep
    .local pmc rx1237_cur
    .local pmc rx1237_debug
    (rx1237_cur, rx1237_pos, rx1237_tgt, $I10) = self."!cursor_start"()
    getattribute rx1237_debug, rx1237_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1237_cur
    .local pmc match
    .lex "$/", match
    length rx1237_eos, rx1237_tgt
    gt rx1237_pos, rx1237_eos, rx1237_done
    set rx1237_off, 0
    lt rx1237_pos, 2, rx1237_start
    sub rx1237_off, rx1237_pos, 1
    substr rx1237_tgt, rx1237_tgt, rx1237_off
  rx1237_start:
    eq $I10, 1, rx1237_restart
    if_null rx1237_debug, debug_953
    rx1237_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1241_done
    goto rxscan1241_scan
  rxscan1241_loop:
    ($P10) = rx1237_cur."from"()
    inc $P10
    set rx1237_pos, $P10
    ge rx1237_pos, rx1237_eos, rxscan1241_done
  rxscan1241_scan:
    set_addr $I10, rxscan1241_loop
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  rxscan1241_done:
.annotate 'line', 578
  # rx subcapture "sym"
    set_addr $I10, rxcap_1242_fail
    rx1237_cur."!mark_push"(0, rx1237_pos, $I10)
  # rx literal  "|"
    add $I11, rx1237_pos, 1
    gt $I11, rx1237_eos, rx1237_fail
    sub $I11, rx1237_pos, rx1237_off
    ord $I11, rx1237_tgt, $I11
    ne $I11, 124, rx1237_fail
    add rx1237_pos, 1
    set_addr $I10, rxcap_1242_fail
    ($I12, $I11) = rx1237_cur."!mark_peek"($I10)
    rx1237_cur."!cursor_pos"($I11)
    ($P10) = rx1237_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1237_pos, "")
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1242_done
  rxcap_1242_fail:
    goto rx1237_fail
  rxcap_1242_done:
  # rx subrule "O" subtype=capture negate=
    rx1237_cur."!cursor_pos"(rx1237_pos)
    $P10 = rx1237_cur."O"("%symbolic_unary")
    unless $P10, rx1237_fail
    rx1237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1237_pos = $P10."pos"()
  # rx pass
    rx1237_cur."!cursor_pass"(rx1237_pos, "prefix:sym<|>")
    if_null rx1237_debug, debug_954
    rx1237_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1237_pos)
  debug_954:
    .return (rx1237_cur)
  rx1237_restart:
.annotate 'line', 520
    if_null rx1237_debug, debug_955
    rx1237_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_955:
  rx1237_fail:
    (rx1237_rep, rx1237_pos, $I10, $P10) = rx1237_cur."!mark_fail"(0)
    lt rx1237_pos, -1, rx1237_done
    eq rx1237_pos, -1, rx1237_fail
    jump $I10
  rx1237_done:
    rx1237_cur."!cursor_fail"()
    if_null rx1237_debug, debug_956
    rx1237_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_956:
    .return (rx1237_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("298_1295307698.031") :method
.annotate 'line', 520
    $P1239 = self."!PREFIX__!subrule"("O", "|")
    new $P1240, "ResizablePMCArray"
    push $P1240, $P1239
    .return ($P1240)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("299_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1244_tgt
    .local int rx1244_pos
    .local int rx1244_off
    .local int rx1244_eos
    .local int rx1244_rep
    .local pmc rx1244_cur
    .local pmc rx1244_debug
    (rx1244_cur, rx1244_pos, rx1244_tgt, $I10) = self."!cursor_start"()
    getattribute rx1244_debug, rx1244_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1244_cur
    .local pmc match
    .lex "$/", match
    length rx1244_eos, rx1244_tgt
    gt rx1244_pos, rx1244_eos, rx1244_done
    set rx1244_off, 0
    lt rx1244_pos, 2, rx1244_start
    sub rx1244_off, rx1244_pos, 1
    substr rx1244_tgt, rx1244_tgt, rx1244_off
  rx1244_start:
    eq $I10, 1, rx1244_restart
    if_null rx1244_debug, debug_957
    rx1244_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_957:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1248_done
    goto rxscan1248_scan
  rxscan1248_loop:
    ($P10) = rx1244_cur."from"()
    inc $P10
    set rx1244_pos, $P10
    ge rx1244_pos, rx1244_eos, rxscan1248_done
  rxscan1248_scan:
    set_addr $I10, rxscan1248_loop
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxscan1248_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1249_fail
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  # rx literal  "*"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 42, rx1244_fail
    add rx1244_pos, 1
    set_addr $I10, rxcap_1249_fail
    ($I12, $I11) = rx1244_cur."!mark_peek"($I10)
    rx1244_cur."!cursor_pos"($I11)
    ($P10) = rx1244_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1244_pos, "")
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1249_done
  rxcap_1249_fail:
    goto rx1244_fail
  rxcap_1249_done:
  # rx subrule "O" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1244_fail
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1244_pos = $P10."pos"()
  # rx pass
    rx1244_cur."!cursor_pass"(rx1244_pos, "infix:sym<*>")
    if_null rx1244_debug, debug_958
    rx1244_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1244_pos)
  debug_958:
    .return (rx1244_cur)
  rx1244_restart:
.annotate 'line', 520
    if_null rx1244_debug, debug_959
    rx1244_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_959:
  rx1244_fail:
    (rx1244_rep, rx1244_pos, $I10, $P10) = rx1244_cur."!mark_fail"(0)
    lt rx1244_pos, -1, rx1244_done
    eq rx1244_pos, -1, rx1244_fail
    jump $I10
  rx1244_done:
    rx1244_cur."!cursor_fail"()
    if_null rx1244_debug, debug_960
    rx1244_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_960:
    .return (rx1244_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("300_1295307698.031") :method
.annotate 'line', 520
    $P1246 = self."!PREFIX__!subrule"("O", "*")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("301_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1251_tgt
    .local int rx1251_pos
    .local int rx1251_off
    .local int rx1251_eos
    .local int rx1251_rep
    .local pmc rx1251_cur
    .local pmc rx1251_debug
    (rx1251_cur, rx1251_pos, rx1251_tgt, $I10) = self."!cursor_start"()
    getattribute rx1251_debug, rx1251_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1251_cur
    .local pmc match
    .lex "$/", match
    length rx1251_eos, rx1251_tgt
    gt rx1251_pos, rx1251_eos, rx1251_done
    set rx1251_off, 0
    lt rx1251_pos, 2, rx1251_start
    sub rx1251_off, rx1251_pos, 1
    substr rx1251_tgt, rx1251_tgt, rx1251_off
  rx1251_start:
    eq $I10, 1, rx1251_restart
    if_null rx1251_debug, debug_961
    rx1251_cur."!cursor_debug"("START", "infix:sym</>")
  debug_961:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1255_done
    goto rxscan1255_scan
  rxscan1255_loop:
    ($P10) = rx1251_cur."from"()
    inc $P10
    set rx1251_pos, $P10
    ge rx1251_pos, rx1251_eos, rxscan1255_done
  rxscan1255_scan:
    set_addr $I10, rxscan1255_loop
    rx1251_cur."!mark_push"(0, rx1251_pos, $I10)
  rxscan1255_done:
.annotate 'line', 581
  # rx subcapture "sym"
    set_addr $I10, rxcap_1256_fail
    rx1251_cur."!mark_push"(0, rx1251_pos, $I10)
  # rx literal  "/"
    add $I11, rx1251_pos, 1
    gt $I11, rx1251_eos, rx1251_fail
    sub $I11, rx1251_pos, rx1251_off
    ord $I11, rx1251_tgt, $I11
    ne $I11, 47, rx1251_fail
    add rx1251_pos, 1
    set_addr $I10, rxcap_1256_fail
    ($I12, $I11) = rx1251_cur."!mark_peek"($I10)
    rx1251_cur."!cursor_pos"($I11)
    ($P10) = rx1251_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1251_pos, "")
    rx1251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1256_done
  rxcap_1256_fail:
    goto rx1251_fail
  rxcap_1256_done:
  # rx subrule "O" subtype=capture negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1251_fail
    rx1251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1251_pos = $P10."pos"()
  # rx pass
    rx1251_cur."!cursor_pass"(rx1251_pos, "infix:sym</>")
    if_null rx1251_debug, debug_962
    rx1251_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1251_pos)
  debug_962:
    .return (rx1251_cur)
  rx1251_restart:
.annotate 'line', 520
    if_null rx1251_debug, debug_963
    rx1251_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_963:
  rx1251_fail:
    (rx1251_rep, rx1251_pos, $I10, $P10) = rx1251_cur."!mark_fail"(0)
    lt rx1251_pos, -1, rx1251_done
    eq rx1251_pos, -1, rx1251_fail
    jump $I10
  rx1251_done:
    rx1251_cur."!cursor_fail"()
    if_null rx1251_debug, debug_964
    rx1251_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_964:
    .return (rx1251_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("302_1295307698.031") :method
.annotate 'line', 520
    $P1253 = self."!PREFIX__!subrule"("O", "/")
    new $P1254, "ResizablePMCArray"
    push $P1254, $P1253
    .return ($P1254)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("303_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1258_tgt
    .local int rx1258_pos
    .local int rx1258_off
    .local int rx1258_eos
    .local int rx1258_rep
    .local pmc rx1258_cur
    .local pmc rx1258_debug
    (rx1258_cur, rx1258_pos, rx1258_tgt, $I10) = self."!cursor_start"()
    getattribute rx1258_debug, rx1258_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1258_cur
    .local pmc match
    .lex "$/", match
    length rx1258_eos, rx1258_tgt
    gt rx1258_pos, rx1258_eos, rx1258_done
    set rx1258_off, 0
    lt rx1258_pos, 2, rx1258_start
    sub rx1258_off, rx1258_pos, 1
    substr rx1258_tgt, rx1258_tgt, rx1258_off
  rx1258_start:
    eq $I10, 1, rx1258_restart
    if_null rx1258_debug, debug_965
    rx1258_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_965:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1262_done
    goto rxscan1262_scan
  rxscan1262_loop:
    ($P10) = rx1258_cur."from"()
    inc $P10
    set rx1258_pos, $P10
    ge rx1258_pos, rx1258_eos, rxscan1262_done
  rxscan1262_scan:
    set_addr $I10, rxscan1262_loop
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  rxscan1262_done:
.annotate 'line', 582
  # rx subcapture "sym"
    set_addr $I10, rxcap_1263_fail
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  # rx literal  "%"
    add $I11, rx1258_pos, 1
    gt $I11, rx1258_eos, rx1258_fail
    sub $I11, rx1258_pos, rx1258_off
    ord $I11, rx1258_tgt, $I11
    ne $I11, 37, rx1258_fail
    add rx1258_pos, 1
    set_addr $I10, rxcap_1263_fail
    ($I12, $I11) = rx1258_cur."!mark_peek"($I10)
    rx1258_cur."!cursor_pos"($I11)
    ($P10) = rx1258_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1258_pos, "")
    rx1258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1263_done
  rxcap_1263_fail:
    goto rx1258_fail
  rxcap_1263_done:
  # rx subrule "O" subtype=capture negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1258_fail
    rx1258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1258_pos = $P10."pos"()
  # rx pass
    rx1258_cur."!cursor_pass"(rx1258_pos, "infix:sym<%>")
    if_null rx1258_debug, debug_966
    rx1258_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1258_pos)
  debug_966:
    .return (rx1258_cur)
  rx1258_restart:
.annotate 'line', 520
    if_null rx1258_debug, debug_967
    rx1258_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_967:
  rx1258_fail:
    (rx1258_rep, rx1258_pos, $I10, $P10) = rx1258_cur."!mark_fail"(0)
    lt rx1258_pos, -1, rx1258_done
    eq rx1258_pos, -1, rx1258_fail
    jump $I10
  rx1258_done:
    rx1258_cur."!cursor_fail"()
    if_null rx1258_debug, debug_968
    rx1258_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_968:
    .return (rx1258_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("304_1295307698.031") :method
.annotate 'line', 520
    $P1260 = self."!PREFIX__!subrule"("O", "%")
    new $P1261, "ResizablePMCArray"
    push $P1261, $P1260
    .return ($P1261)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("305_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1265_tgt
    .local int rx1265_pos
    .local int rx1265_off
    .local int rx1265_eos
    .local int rx1265_rep
    .local pmc rx1265_cur
    .local pmc rx1265_debug
    (rx1265_cur, rx1265_pos, rx1265_tgt, $I10) = self."!cursor_start"()
    getattribute rx1265_debug, rx1265_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1265_cur
    .local pmc match
    .lex "$/", match
    length rx1265_eos, rx1265_tgt
    gt rx1265_pos, rx1265_eos, rx1265_done
    set rx1265_off, 0
    lt rx1265_pos, 2, rx1265_start
    sub rx1265_off, rx1265_pos, 1
    substr rx1265_tgt, rx1265_tgt, rx1265_off
  rx1265_start:
    eq $I10, 1, rx1265_restart
    if_null rx1265_debug, debug_969
    rx1265_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_969:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1269_done
    goto rxscan1269_scan
  rxscan1269_loop:
    ($P10) = rx1265_cur."from"()
    inc $P10
    set rx1265_pos, $P10
    ge rx1265_pos, rx1265_eos, rxscan1269_done
  rxscan1269_scan:
    set_addr $I10, rxscan1269_loop
    rx1265_cur."!mark_push"(0, rx1265_pos, $I10)
  rxscan1269_done:
.annotate 'line', 583
  # rx subcapture "sym"
    set_addr $I10, rxcap_1270_fail
    rx1265_cur."!mark_push"(0, rx1265_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1265_pos, 2
    gt $I11, rx1265_eos, rx1265_fail
    sub $I11, rx1265_pos, rx1265_off
    substr $S10, rx1265_tgt, $I11, 2
    ne $S10, "+&", rx1265_fail
    add rx1265_pos, 2
    set_addr $I10, rxcap_1270_fail
    ($I12, $I11) = rx1265_cur."!mark_peek"($I10)
    rx1265_cur."!cursor_pos"($I11)
    ($P10) = rx1265_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1265_pos, "")
    rx1265_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1270_done
  rxcap_1270_fail:
    goto rx1265_fail
  rxcap_1270_done:
  # rx subrule "O" subtype=capture negate=
    rx1265_cur."!cursor_pos"(rx1265_pos)
    $P10 = rx1265_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1265_fail
    rx1265_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1265_pos = $P10."pos"()
  # rx pass
    rx1265_cur."!cursor_pass"(rx1265_pos, "infix:sym<+&>")
    if_null rx1265_debug, debug_970
    rx1265_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1265_pos)
  debug_970:
    .return (rx1265_cur)
  rx1265_restart:
.annotate 'line', 520
    if_null rx1265_debug, debug_971
    rx1265_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_971:
  rx1265_fail:
    (rx1265_rep, rx1265_pos, $I10, $P10) = rx1265_cur."!mark_fail"(0)
    lt rx1265_pos, -1, rx1265_done
    eq rx1265_pos, -1, rx1265_fail
    jump $I10
  rx1265_done:
    rx1265_cur."!cursor_fail"()
    if_null rx1265_debug, debug_972
    rx1265_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_972:
    .return (rx1265_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("306_1295307698.031") :method
.annotate 'line', 520
    $P1267 = self."!PREFIX__!subrule"("O", "+&")
    new $P1268, "ResizablePMCArray"
    push $P1268, $P1267
    .return ($P1268)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("307_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1272_tgt
    .local int rx1272_pos
    .local int rx1272_off
    .local int rx1272_eos
    .local int rx1272_rep
    .local pmc rx1272_cur
    .local pmc rx1272_debug
    (rx1272_cur, rx1272_pos, rx1272_tgt, $I10) = self."!cursor_start"()
    getattribute rx1272_debug, rx1272_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1272_cur
    .local pmc match
    .lex "$/", match
    length rx1272_eos, rx1272_tgt
    gt rx1272_pos, rx1272_eos, rx1272_done
    set rx1272_off, 0
    lt rx1272_pos, 2, rx1272_start
    sub rx1272_off, rx1272_pos, 1
    substr rx1272_tgt, rx1272_tgt, rx1272_off
  rx1272_start:
    eq $I10, 1, rx1272_restart
    if_null rx1272_debug, debug_973
    rx1272_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_973:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1276_done
    goto rxscan1276_scan
  rxscan1276_loop:
    ($P10) = rx1272_cur."from"()
    inc $P10
    set rx1272_pos, $P10
    ge rx1272_pos, rx1272_eos, rxscan1276_done
  rxscan1276_scan:
    set_addr $I10, rxscan1276_loop
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  rxscan1276_done:
.annotate 'line', 585
  # rx subcapture "sym"
    set_addr $I10, rxcap_1277_fail
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  # rx literal  "+"
    add $I11, rx1272_pos, 1
    gt $I11, rx1272_eos, rx1272_fail
    sub $I11, rx1272_pos, rx1272_off
    ord $I11, rx1272_tgt, $I11
    ne $I11, 43, rx1272_fail
    add rx1272_pos, 1
    set_addr $I10, rxcap_1277_fail
    ($I12, $I11) = rx1272_cur."!mark_peek"($I10)
    rx1272_cur."!cursor_pos"($I11)
    ($P10) = rx1272_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1272_pos, "")
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1277_done
  rxcap_1277_fail:
    goto rx1272_fail
  rxcap_1277_done:
  # rx subrule "O" subtype=capture negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1272_fail
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1272_pos = $P10."pos"()
  # rx pass
    rx1272_cur."!cursor_pass"(rx1272_pos, "infix:sym<+>")
    if_null rx1272_debug, debug_974
    rx1272_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1272_pos)
  debug_974:
    .return (rx1272_cur)
  rx1272_restart:
.annotate 'line', 520
    if_null rx1272_debug, debug_975
    rx1272_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_975:
  rx1272_fail:
    (rx1272_rep, rx1272_pos, $I10, $P10) = rx1272_cur."!mark_fail"(0)
    lt rx1272_pos, -1, rx1272_done
    eq rx1272_pos, -1, rx1272_fail
    jump $I10
  rx1272_done:
    rx1272_cur."!cursor_fail"()
    if_null rx1272_debug, debug_976
    rx1272_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_976:
    .return (rx1272_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("308_1295307698.031") :method
.annotate 'line', 520
    $P1274 = self."!PREFIX__!subrule"("O", "+")
    new $P1275, "ResizablePMCArray"
    push $P1275, $P1274
    .return ($P1275)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("309_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1279_tgt
    .local int rx1279_pos
    .local int rx1279_off
    .local int rx1279_eos
    .local int rx1279_rep
    .local pmc rx1279_cur
    .local pmc rx1279_debug
    (rx1279_cur, rx1279_pos, rx1279_tgt, $I10) = self."!cursor_start"()
    getattribute rx1279_debug, rx1279_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1279_cur
    .local pmc match
    .lex "$/", match
    length rx1279_eos, rx1279_tgt
    gt rx1279_pos, rx1279_eos, rx1279_done
    set rx1279_off, 0
    lt rx1279_pos, 2, rx1279_start
    sub rx1279_off, rx1279_pos, 1
    substr rx1279_tgt, rx1279_tgt, rx1279_off
  rx1279_start:
    eq $I10, 1, rx1279_restart
    if_null rx1279_debug, debug_977
    rx1279_cur."!cursor_debug"("START", "infix:sym<->")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1283_done
    goto rxscan1283_scan
  rxscan1283_loop:
    ($P10) = rx1279_cur."from"()
    inc $P10
    set rx1279_pos, $P10
    ge rx1279_pos, rx1279_eos, rxscan1283_done
  rxscan1283_scan:
    set_addr $I10, rxscan1283_loop
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  rxscan1283_done:
.annotate 'line', 586
  # rx subcapture "sym"
    set_addr $I10, rxcap_1284_fail
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  # rx literal  "-"
    add $I11, rx1279_pos, 1
    gt $I11, rx1279_eos, rx1279_fail
    sub $I11, rx1279_pos, rx1279_off
    ord $I11, rx1279_tgt, $I11
    ne $I11, 45, rx1279_fail
    add rx1279_pos, 1
    set_addr $I10, rxcap_1284_fail
    ($I12, $I11) = rx1279_cur."!mark_peek"($I10)
    rx1279_cur."!cursor_pos"($I11)
    ($P10) = rx1279_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1279_pos, "")
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1284_done
  rxcap_1284_fail:
    goto rx1279_fail
  rxcap_1284_done:
  # rx subrule "O" subtype=capture negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1279_fail
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1279_pos = $P10."pos"()
  # rx pass
    rx1279_cur."!cursor_pass"(rx1279_pos, "infix:sym<->")
    if_null rx1279_debug, debug_978
    rx1279_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1279_pos)
  debug_978:
    .return (rx1279_cur)
  rx1279_restart:
.annotate 'line', 520
    if_null rx1279_debug, debug_979
    rx1279_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_979:
  rx1279_fail:
    (rx1279_rep, rx1279_pos, $I10, $P10) = rx1279_cur."!mark_fail"(0)
    lt rx1279_pos, -1, rx1279_done
    eq rx1279_pos, -1, rx1279_fail
    jump $I10
  rx1279_done:
    rx1279_cur."!cursor_fail"()
    if_null rx1279_debug, debug_980
    rx1279_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_980:
    .return (rx1279_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("310_1295307698.031") :method
.annotate 'line', 520
    $P1281 = self."!PREFIX__!subrule"("O", "-")
    new $P1282, "ResizablePMCArray"
    push $P1282, $P1281
    .return ($P1282)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("311_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1286_tgt
    .local int rx1286_pos
    .local int rx1286_off
    .local int rx1286_eos
    .local int rx1286_rep
    .local pmc rx1286_cur
    .local pmc rx1286_debug
    (rx1286_cur, rx1286_pos, rx1286_tgt, $I10) = self."!cursor_start"()
    getattribute rx1286_debug, rx1286_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1286_cur
    .local pmc match
    .lex "$/", match
    length rx1286_eos, rx1286_tgt
    gt rx1286_pos, rx1286_eos, rx1286_done
    set rx1286_off, 0
    lt rx1286_pos, 2, rx1286_start
    sub rx1286_off, rx1286_pos, 1
    substr rx1286_tgt, rx1286_tgt, rx1286_off
  rx1286_start:
    eq $I10, 1, rx1286_restart
    if_null rx1286_debug, debug_981
    rx1286_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1290_done
    goto rxscan1290_scan
  rxscan1290_loop:
    ($P10) = rx1286_cur."from"()
    inc $P10
    set rx1286_pos, $P10
    ge rx1286_pos, rx1286_eos, rxscan1290_done
  rxscan1290_scan:
    set_addr $I10, rxscan1290_loop
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  rxscan1290_done:
.annotate 'line', 587
  # rx subcapture "sym"
    set_addr $I10, rxcap_1291_fail
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1286_pos, 2
    gt $I11, rx1286_eos, rx1286_fail
    sub $I11, rx1286_pos, rx1286_off
    substr $S10, rx1286_tgt, $I11, 2
    ne $S10, "+|", rx1286_fail
    add rx1286_pos, 2
    set_addr $I10, rxcap_1291_fail
    ($I12, $I11) = rx1286_cur."!mark_peek"($I10)
    rx1286_cur."!cursor_pos"($I11)
    ($P10) = rx1286_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1286_pos, "")
    rx1286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1291_done
  rxcap_1291_fail:
    goto rx1286_fail
  rxcap_1291_done:
  # rx subrule "O" subtype=capture negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1286_fail
    rx1286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1286_pos = $P10."pos"()
  # rx pass
    rx1286_cur."!cursor_pass"(rx1286_pos, "infix:sym<+|>")
    if_null rx1286_debug, debug_982
    rx1286_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1286_pos)
  debug_982:
    .return (rx1286_cur)
  rx1286_restart:
.annotate 'line', 520
    if_null rx1286_debug, debug_983
    rx1286_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_983:
  rx1286_fail:
    (rx1286_rep, rx1286_pos, $I10, $P10) = rx1286_cur."!mark_fail"(0)
    lt rx1286_pos, -1, rx1286_done
    eq rx1286_pos, -1, rx1286_fail
    jump $I10
  rx1286_done:
    rx1286_cur."!cursor_fail"()
    if_null rx1286_debug, debug_984
    rx1286_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_984:
    .return (rx1286_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("312_1295307698.031") :method
.annotate 'line', 520
    $P1288 = self."!PREFIX__!subrule"("O", "+|")
    new $P1289, "ResizablePMCArray"
    push $P1289, $P1288
    .return ($P1289)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("313_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1293_tgt
    .local int rx1293_pos
    .local int rx1293_off
    .local int rx1293_eos
    .local int rx1293_rep
    .local pmc rx1293_cur
    .local pmc rx1293_debug
    (rx1293_cur, rx1293_pos, rx1293_tgt, $I10) = self."!cursor_start"()
    getattribute rx1293_debug, rx1293_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1293_cur
    .local pmc match
    .lex "$/", match
    length rx1293_eos, rx1293_tgt
    gt rx1293_pos, rx1293_eos, rx1293_done
    set rx1293_off, 0
    lt rx1293_pos, 2, rx1293_start
    sub rx1293_off, rx1293_pos, 1
    substr rx1293_tgt, rx1293_tgt, rx1293_off
  rx1293_start:
    eq $I10, 1, rx1293_restart
    if_null rx1293_debug, debug_985
    rx1293_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1297_done
    goto rxscan1297_scan
  rxscan1297_loop:
    ($P10) = rx1293_cur."from"()
    inc $P10
    set rx1293_pos, $P10
    ge rx1293_pos, rx1293_eos, rxscan1297_done
  rxscan1297_scan:
    set_addr $I10, rxscan1297_loop
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  rxscan1297_done:
.annotate 'line', 588
  # rx subcapture "sym"
    set_addr $I10, rxcap_1298_fail
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1293_pos, 2
    gt $I11, rx1293_eos, rx1293_fail
    sub $I11, rx1293_pos, rx1293_off
    substr $S10, rx1293_tgt, $I11, 2
    ne $S10, "+^", rx1293_fail
    add rx1293_pos, 2
    set_addr $I10, rxcap_1298_fail
    ($I12, $I11) = rx1293_cur."!mark_peek"($I10)
    rx1293_cur."!cursor_pos"($I11)
    ($P10) = rx1293_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1293_pos, "")
    rx1293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1298_done
  rxcap_1298_fail:
    goto rx1293_fail
  rxcap_1298_done:
  # rx subrule "O" subtype=capture negate=
    rx1293_cur."!cursor_pos"(rx1293_pos)
    $P10 = rx1293_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1293_fail
    rx1293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1293_pos = $P10."pos"()
  # rx pass
    rx1293_cur."!cursor_pass"(rx1293_pos, "infix:sym<+^>")
    if_null rx1293_debug, debug_986
    rx1293_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1293_pos)
  debug_986:
    .return (rx1293_cur)
  rx1293_restart:
.annotate 'line', 520
    if_null rx1293_debug, debug_987
    rx1293_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_987:
  rx1293_fail:
    (rx1293_rep, rx1293_pos, $I10, $P10) = rx1293_cur."!mark_fail"(0)
    lt rx1293_pos, -1, rx1293_done
    eq rx1293_pos, -1, rx1293_fail
    jump $I10
  rx1293_done:
    rx1293_cur."!cursor_fail"()
    if_null rx1293_debug, debug_988
    rx1293_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_988:
    .return (rx1293_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("314_1295307698.031") :method
.annotate 'line', 520
    $P1295 = self."!PREFIX__!subrule"("O", "+^")
    new $P1296, "ResizablePMCArray"
    push $P1296, $P1295
    .return ($P1296)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("315_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1300_tgt
    .local int rx1300_pos
    .local int rx1300_off
    .local int rx1300_eos
    .local int rx1300_rep
    .local pmc rx1300_cur
    .local pmc rx1300_debug
    (rx1300_cur, rx1300_pos, rx1300_tgt, $I10) = self."!cursor_start"()
    getattribute rx1300_debug, rx1300_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1300_cur
    .local pmc match
    .lex "$/", match
    length rx1300_eos, rx1300_tgt
    gt rx1300_pos, rx1300_eos, rx1300_done
    set rx1300_off, 0
    lt rx1300_pos, 2, rx1300_start
    sub rx1300_off, rx1300_pos, 1
    substr rx1300_tgt, rx1300_tgt, rx1300_off
  rx1300_start:
    eq $I10, 1, rx1300_restart
    if_null rx1300_debug, debug_989
    rx1300_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1304_done
    goto rxscan1304_scan
  rxscan1304_loop:
    ($P10) = rx1300_cur."from"()
    inc $P10
    set rx1300_pos, $P10
    ge rx1300_pos, rx1300_eos, rxscan1304_done
  rxscan1304_scan:
    set_addr $I10, rxscan1304_loop
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  rxscan1304_done:
.annotate 'line', 590
  # rx subcapture "sym"
    set_addr $I10, rxcap_1305_fail
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  # rx literal  "~"
    add $I11, rx1300_pos, 1
    gt $I11, rx1300_eos, rx1300_fail
    sub $I11, rx1300_pos, rx1300_off
    ord $I11, rx1300_tgt, $I11
    ne $I11, 126, rx1300_fail
    add rx1300_pos, 1
    set_addr $I10, rxcap_1305_fail
    ($I12, $I11) = rx1300_cur."!mark_peek"($I10)
    rx1300_cur."!cursor_pos"($I11)
    ($P10) = rx1300_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1300_pos, "")
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1305_done
  rxcap_1305_fail:
    goto rx1300_fail
  rxcap_1305_done:
  # rx subrule "O" subtype=capture negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1300_fail
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1300_pos = $P10."pos"()
  # rx pass
    rx1300_cur."!cursor_pass"(rx1300_pos, "infix:sym<~>")
    if_null rx1300_debug, debug_990
    rx1300_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1300_pos)
  debug_990:
    .return (rx1300_cur)
  rx1300_restart:
.annotate 'line', 520
    if_null rx1300_debug, debug_991
    rx1300_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_991:
  rx1300_fail:
    (rx1300_rep, rx1300_pos, $I10, $P10) = rx1300_cur."!mark_fail"(0)
    lt rx1300_pos, -1, rx1300_done
    eq rx1300_pos, -1, rx1300_fail
    jump $I10
  rx1300_done:
    rx1300_cur."!cursor_fail"()
    if_null rx1300_debug, debug_992
    rx1300_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_992:
    .return (rx1300_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("316_1295307698.031") :method
.annotate 'line', 520
    $P1302 = self."!PREFIX__!subrule"("O", "~")
    new $P1303, "ResizablePMCArray"
    push $P1303, $P1302
    .return ($P1303)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("317_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1307_tgt
    .local int rx1307_pos
    .local int rx1307_off
    .local int rx1307_eos
    .local int rx1307_rep
    .local pmc rx1307_cur
    .local pmc rx1307_debug
    (rx1307_cur, rx1307_pos, rx1307_tgt, $I10) = self."!cursor_start"()
    getattribute rx1307_debug, rx1307_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1307_cur
    .local pmc match
    .lex "$/", match
    length rx1307_eos, rx1307_tgt
    gt rx1307_pos, rx1307_eos, rx1307_done
    set rx1307_off, 0
    lt rx1307_pos, 2, rx1307_start
    sub rx1307_off, rx1307_pos, 1
    substr rx1307_tgt, rx1307_tgt, rx1307_off
  rx1307_start:
    eq $I10, 1, rx1307_restart
    if_null rx1307_debug, debug_993
    rx1307_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1311_done
    goto rxscan1311_scan
  rxscan1311_loop:
    ($P10) = rx1307_cur."from"()
    inc $P10
    set rx1307_pos, $P10
    ge rx1307_pos, rx1307_eos, rxscan1311_done
  rxscan1311_scan:
    set_addr $I10, rxscan1311_loop
    rx1307_cur."!mark_push"(0, rx1307_pos, $I10)
  rxscan1311_done:
.annotate 'line', 592
  # rx subcapture "sym"
    set_addr $I10, rxcap_1312_fail
    rx1307_cur."!mark_push"(0, rx1307_pos, $I10)
  # rx literal  "=="
    add $I11, rx1307_pos, 2
    gt $I11, rx1307_eos, rx1307_fail
    sub $I11, rx1307_pos, rx1307_off
    substr $S10, rx1307_tgt, $I11, 2
    ne $S10, "==", rx1307_fail
    add rx1307_pos, 2
    set_addr $I10, rxcap_1312_fail
    ($I12, $I11) = rx1307_cur."!mark_peek"($I10)
    rx1307_cur."!cursor_pos"($I11)
    ($P10) = rx1307_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1307_pos, "")
    rx1307_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1312_done
  rxcap_1312_fail:
    goto rx1307_fail
  rxcap_1312_done:
  # rx subrule "O" subtype=capture negate=
    rx1307_cur."!cursor_pos"(rx1307_pos)
    $P10 = rx1307_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1307_fail
    rx1307_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1307_pos = $P10."pos"()
  # rx pass
    rx1307_cur."!cursor_pass"(rx1307_pos, "infix:sym<==>")
    if_null rx1307_debug, debug_994
    rx1307_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1307_pos)
  debug_994:
    .return (rx1307_cur)
  rx1307_restart:
.annotate 'line', 520
    if_null rx1307_debug, debug_995
    rx1307_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_995:
  rx1307_fail:
    (rx1307_rep, rx1307_pos, $I10, $P10) = rx1307_cur."!mark_fail"(0)
    lt rx1307_pos, -1, rx1307_done
    eq rx1307_pos, -1, rx1307_fail
    jump $I10
  rx1307_done:
    rx1307_cur."!cursor_fail"()
    if_null rx1307_debug, debug_996
    rx1307_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_996:
    .return (rx1307_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("318_1295307698.031") :method
.annotate 'line', 520
    $P1309 = self."!PREFIX__!subrule"("O", "==")
    new $P1310, "ResizablePMCArray"
    push $P1310, $P1309
    .return ($P1310)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("319_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1314_tgt
    .local int rx1314_pos
    .local int rx1314_off
    .local int rx1314_eos
    .local int rx1314_rep
    .local pmc rx1314_cur
    .local pmc rx1314_debug
    (rx1314_cur, rx1314_pos, rx1314_tgt, $I10) = self."!cursor_start"()
    getattribute rx1314_debug, rx1314_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1314_cur
    .local pmc match
    .lex "$/", match
    length rx1314_eos, rx1314_tgt
    gt rx1314_pos, rx1314_eos, rx1314_done
    set rx1314_off, 0
    lt rx1314_pos, 2, rx1314_start
    sub rx1314_off, rx1314_pos, 1
    substr rx1314_tgt, rx1314_tgt, rx1314_off
  rx1314_start:
    eq $I10, 1, rx1314_restart
    if_null rx1314_debug, debug_997
    rx1314_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1318_done
    goto rxscan1318_scan
  rxscan1318_loop:
    ($P10) = rx1314_cur."from"()
    inc $P10
    set rx1314_pos, $P10
    ge rx1314_pos, rx1314_eos, rxscan1318_done
  rxscan1318_scan:
    set_addr $I10, rxscan1318_loop
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  rxscan1318_done:
.annotate 'line', 593
  # rx subcapture "sym"
    set_addr $I10, rxcap_1319_fail
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  # rx literal  "!="
    add $I11, rx1314_pos, 2
    gt $I11, rx1314_eos, rx1314_fail
    sub $I11, rx1314_pos, rx1314_off
    substr $S10, rx1314_tgt, $I11, 2
    ne $S10, "!=", rx1314_fail
    add rx1314_pos, 2
    set_addr $I10, rxcap_1319_fail
    ($I12, $I11) = rx1314_cur."!mark_peek"($I10)
    rx1314_cur."!cursor_pos"($I11)
    ($P10) = rx1314_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1314_pos, "")
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1319_done
  rxcap_1319_fail:
    goto rx1314_fail
  rxcap_1319_done:
  # rx subrule "O" subtype=capture negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1314_fail
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1314_pos = $P10."pos"()
  # rx pass
    rx1314_cur."!cursor_pass"(rx1314_pos, "infix:sym<!=>")
    if_null rx1314_debug, debug_998
    rx1314_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1314_pos)
  debug_998:
    .return (rx1314_cur)
  rx1314_restart:
.annotate 'line', 520
    if_null rx1314_debug, debug_999
    rx1314_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_999:
  rx1314_fail:
    (rx1314_rep, rx1314_pos, $I10, $P10) = rx1314_cur."!mark_fail"(0)
    lt rx1314_pos, -1, rx1314_done
    eq rx1314_pos, -1, rx1314_fail
    jump $I10
  rx1314_done:
    rx1314_cur."!cursor_fail"()
    if_null rx1314_debug, debug_1000
    rx1314_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1000:
    .return (rx1314_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("320_1295307698.031") :method
.annotate 'line', 520
    $P1316 = self."!PREFIX__!subrule"("O", "!=")
    new $P1317, "ResizablePMCArray"
    push $P1317, $P1316
    .return ($P1317)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("321_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1321_tgt
    .local int rx1321_pos
    .local int rx1321_off
    .local int rx1321_eos
    .local int rx1321_rep
    .local pmc rx1321_cur
    .local pmc rx1321_debug
    (rx1321_cur, rx1321_pos, rx1321_tgt, $I10) = self."!cursor_start"()
    getattribute rx1321_debug, rx1321_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1321_cur
    .local pmc match
    .lex "$/", match
    length rx1321_eos, rx1321_tgt
    gt rx1321_pos, rx1321_eos, rx1321_done
    set rx1321_off, 0
    lt rx1321_pos, 2, rx1321_start
    sub rx1321_off, rx1321_pos, 1
    substr rx1321_tgt, rx1321_tgt, rx1321_off
  rx1321_start:
    eq $I10, 1, rx1321_restart
    if_null rx1321_debug, debug_1001
    rx1321_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1325_done
    goto rxscan1325_scan
  rxscan1325_loop:
    ($P10) = rx1321_cur."from"()
    inc $P10
    set rx1321_pos, $P10
    ge rx1321_pos, rx1321_eos, rxscan1325_done
  rxscan1325_scan:
    set_addr $I10, rxscan1325_loop
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  rxscan1325_done:
.annotate 'line', 594
  # rx subcapture "sym"
    set_addr $I10, rxcap_1326_fail
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  # rx literal  "<="
    add $I11, rx1321_pos, 2
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 2
    ne $S10, "<=", rx1321_fail
    add rx1321_pos, 2
    set_addr $I10, rxcap_1326_fail
    ($I12, $I11) = rx1321_cur."!mark_peek"($I10)
    rx1321_cur."!cursor_pos"($I11)
    ($P10) = rx1321_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1321_pos, "")
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1326_done
  rxcap_1326_fail:
    goto rx1321_fail
  rxcap_1326_done:
  # rx subrule "O" subtype=capture negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1321_fail
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1321_pos = $P10."pos"()
  # rx pass
    rx1321_cur."!cursor_pass"(rx1321_pos, "infix:sym<<=>")
    if_null rx1321_debug, debug_1002
    rx1321_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1321_pos)
  debug_1002:
    .return (rx1321_cur)
  rx1321_restart:
.annotate 'line', 520
    if_null rx1321_debug, debug_1003
    rx1321_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1003:
  rx1321_fail:
    (rx1321_rep, rx1321_pos, $I10, $P10) = rx1321_cur."!mark_fail"(0)
    lt rx1321_pos, -1, rx1321_done
    eq rx1321_pos, -1, rx1321_fail
    jump $I10
  rx1321_done:
    rx1321_cur."!cursor_fail"()
    if_null rx1321_debug, debug_1004
    rx1321_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1004:
    .return (rx1321_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("322_1295307698.031") :method
.annotate 'line', 520
    $P1323 = self."!PREFIX__!subrule"("O", "<=")
    new $P1324, "ResizablePMCArray"
    push $P1324, $P1323
    .return ($P1324)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("323_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1328_tgt
    .local int rx1328_pos
    .local int rx1328_off
    .local int rx1328_eos
    .local int rx1328_rep
    .local pmc rx1328_cur
    .local pmc rx1328_debug
    (rx1328_cur, rx1328_pos, rx1328_tgt, $I10) = self."!cursor_start"()
    getattribute rx1328_debug, rx1328_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1328_cur
    .local pmc match
    .lex "$/", match
    length rx1328_eos, rx1328_tgt
    gt rx1328_pos, rx1328_eos, rx1328_done
    set rx1328_off, 0
    lt rx1328_pos, 2, rx1328_start
    sub rx1328_off, rx1328_pos, 1
    substr rx1328_tgt, rx1328_tgt, rx1328_off
  rx1328_start:
    eq $I10, 1, rx1328_restart
    if_null rx1328_debug, debug_1005
    rx1328_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    ($P10) = rx1328_cur."from"()
    inc $P10
    set rx1328_pos, $P10
    ge rx1328_pos, rx1328_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  rxscan1332_done:
.annotate 'line', 595
  # rx subcapture "sym"
    set_addr $I10, rxcap_1333_fail
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  # rx literal  ">="
    add $I11, rx1328_pos, 2
    gt $I11, rx1328_eos, rx1328_fail
    sub $I11, rx1328_pos, rx1328_off
    substr $S10, rx1328_tgt, $I11, 2
    ne $S10, ">=", rx1328_fail
    add rx1328_pos, 2
    set_addr $I10, rxcap_1333_fail
    ($I12, $I11) = rx1328_cur."!mark_peek"($I10)
    rx1328_cur."!cursor_pos"($I11)
    ($P10) = rx1328_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1328_pos, "")
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1333_done
  rxcap_1333_fail:
    goto rx1328_fail
  rxcap_1333_done:
  # rx subrule "O" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1328_pos = $P10."pos"()
  # rx pass
    rx1328_cur."!cursor_pass"(rx1328_pos, "infix:sym<>=>")
    if_null rx1328_debug, debug_1006
    rx1328_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1328_pos)
  debug_1006:
    .return (rx1328_cur)
  rx1328_restart:
.annotate 'line', 520
    if_null rx1328_debug, debug_1007
    rx1328_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1007:
  rx1328_fail:
    (rx1328_rep, rx1328_pos, $I10, $P10) = rx1328_cur."!mark_fail"(0)
    lt rx1328_pos, -1, rx1328_done
    eq rx1328_pos, -1, rx1328_fail
    jump $I10
  rx1328_done:
    rx1328_cur."!cursor_fail"()
    if_null rx1328_debug, debug_1008
    rx1328_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1008:
    .return (rx1328_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("324_1295307698.031") :method
.annotate 'line', 520
    $P1330 = self."!PREFIX__!subrule"("O", ">=")
    new $P1331, "ResizablePMCArray"
    push $P1331, $P1330
    .return ($P1331)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("325_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1335_tgt
    .local int rx1335_pos
    .local int rx1335_off
    .local int rx1335_eos
    .local int rx1335_rep
    .local pmc rx1335_cur
    .local pmc rx1335_debug
    (rx1335_cur, rx1335_pos, rx1335_tgt, $I10) = self."!cursor_start"()
    getattribute rx1335_debug, rx1335_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1335_cur
    .local pmc match
    .lex "$/", match
    length rx1335_eos, rx1335_tgt
    gt rx1335_pos, rx1335_eos, rx1335_done
    set rx1335_off, 0
    lt rx1335_pos, 2, rx1335_start
    sub rx1335_off, rx1335_pos, 1
    substr rx1335_tgt, rx1335_tgt, rx1335_off
  rx1335_start:
    eq $I10, 1, rx1335_restart
    if_null rx1335_debug, debug_1009
    rx1335_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1339_done
    goto rxscan1339_scan
  rxscan1339_loop:
    ($P10) = rx1335_cur."from"()
    inc $P10
    set rx1335_pos, $P10
    ge rx1335_pos, rx1335_eos, rxscan1339_done
  rxscan1339_scan:
    set_addr $I10, rxscan1339_loop
    rx1335_cur."!mark_push"(0, rx1335_pos, $I10)
  rxscan1339_done:
.annotate 'line', 596
  # rx subcapture "sym"
    set_addr $I10, rxcap_1340_fail
    rx1335_cur."!mark_push"(0, rx1335_pos, $I10)
  # rx literal  "<"
    add $I11, rx1335_pos, 1
    gt $I11, rx1335_eos, rx1335_fail
    sub $I11, rx1335_pos, rx1335_off
    ord $I11, rx1335_tgt, $I11
    ne $I11, 60, rx1335_fail
    add rx1335_pos, 1
    set_addr $I10, rxcap_1340_fail
    ($I12, $I11) = rx1335_cur."!mark_peek"($I10)
    rx1335_cur."!cursor_pos"($I11)
    ($P10) = rx1335_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1335_pos, "")
    rx1335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1340_done
  rxcap_1340_fail:
    goto rx1335_fail
  rxcap_1340_done:
  # rx subrule "O" subtype=capture negate=
    rx1335_cur."!cursor_pos"(rx1335_pos)
    $P10 = rx1335_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1335_fail
    rx1335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1335_pos = $P10."pos"()
  # rx pass
    rx1335_cur."!cursor_pass"(rx1335_pos, "infix:sym<<>")
    if_null rx1335_debug, debug_1010
    rx1335_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1335_pos)
  debug_1010:
    .return (rx1335_cur)
  rx1335_restart:
.annotate 'line', 520
    if_null rx1335_debug, debug_1011
    rx1335_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1011:
  rx1335_fail:
    (rx1335_rep, rx1335_pos, $I10, $P10) = rx1335_cur."!mark_fail"(0)
    lt rx1335_pos, -1, rx1335_done
    eq rx1335_pos, -1, rx1335_fail
    jump $I10
  rx1335_done:
    rx1335_cur."!cursor_fail"()
    if_null rx1335_debug, debug_1012
    rx1335_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1012:
    .return (rx1335_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("326_1295307698.031") :method
.annotate 'line', 520
    $P1337 = self."!PREFIX__!subrule"("O", "<")
    new $P1338, "ResizablePMCArray"
    push $P1338, $P1337
    .return ($P1338)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("327_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1342_tgt
    .local int rx1342_pos
    .local int rx1342_off
    .local int rx1342_eos
    .local int rx1342_rep
    .local pmc rx1342_cur
    .local pmc rx1342_debug
    (rx1342_cur, rx1342_pos, rx1342_tgt, $I10) = self."!cursor_start"()
    getattribute rx1342_debug, rx1342_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1342_cur
    .local pmc match
    .lex "$/", match
    length rx1342_eos, rx1342_tgt
    gt rx1342_pos, rx1342_eos, rx1342_done
    set rx1342_off, 0
    lt rx1342_pos, 2, rx1342_start
    sub rx1342_off, rx1342_pos, 1
    substr rx1342_tgt, rx1342_tgt, rx1342_off
  rx1342_start:
    eq $I10, 1, rx1342_restart
    if_null rx1342_debug, debug_1013
    rx1342_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1346_done
    goto rxscan1346_scan
  rxscan1346_loop:
    ($P10) = rx1342_cur."from"()
    inc $P10
    set rx1342_pos, $P10
    ge rx1342_pos, rx1342_eos, rxscan1346_done
  rxscan1346_scan:
    set_addr $I10, rxscan1346_loop
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxscan1346_done:
.annotate 'line', 597
  # rx subcapture "sym"
    set_addr $I10, rxcap_1347_fail
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  # rx literal  ">"
    add $I11, rx1342_pos, 1
    gt $I11, rx1342_eos, rx1342_fail
    sub $I11, rx1342_pos, rx1342_off
    ord $I11, rx1342_tgt, $I11
    ne $I11, 62, rx1342_fail
    add rx1342_pos, 1
    set_addr $I10, rxcap_1347_fail
    ($I12, $I11) = rx1342_cur."!mark_peek"($I10)
    rx1342_cur."!cursor_pos"($I11)
    ($P10) = rx1342_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1342_pos, "")
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1347_done
  rxcap_1347_fail:
    goto rx1342_fail
  rxcap_1347_done:
  # rx subrule "O" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1342_pos = $P10."pos"()
  # rx pass
    rx1342_cur."!cursor_pass"(rx1342_pos, "infix:sym<>>")
    if_null rx1342_debug, debug_1014
    rx1342_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1342_pos)
  debug_1014:
    .return (rx1342_cur)
  rx1342_restart:
.annotate 'line', 520
    if_null rx1342_debug, debug_1015
    rx1342_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1015:
  rx1342_fail:
    (rx1342_rep, rx1342_pos, $I10, $P10) = rx1342_cur."!mark_fail"(0)
    lt rx1342_pos, -1, rx1342_done
    eq rx1342_pos, -1, rx1342_fail
    jump $I10
  rx1342_done:
    rx1342_cur."!cursor_fail"()
    if_null rx1342_debug, debug_1016
    rx1342_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1016:
    .return (rx1342_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("328_1295307698.031") :method
.annotate 'line', 520
    $P1344 = self."!PREFIX__!subrule"("O", ">")
    new $P1345, "ResizablePMCArray"
    push $P1345, $P1344
    .return ($P1345)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("329_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1349_tgt
    .local int rx1349_pos
    .local int rx1349_off
    .local int rx1349_eos
    .local int rx1349_rep
    .local pmc rx1349_cur
    .local pmc rx1349_debug
    (rx1349_cur, rx1349_pos, rx1349_tgt, $I10) = self."!cursor_start"()
    getattribute rx1349_debug, rx1349_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1349_cur
    .local pmc match
    .lex "$/", match
    length rx1349_eos, rx1349_tgt
    gt rx1349_pos, rx1349_eos, rx1349_done
    set rx1349_off, 0
    lt rx1349_pos, 2, rx1349_start
    sub rx1349_off, rx1349_pos, 1
    substr rx1349_tgt, rx1349_tgt, rx1349_off
  rx1349_start:
    eq $I10, 1, rx1349_restart
    if_null rx1349_debug, debug_1017
    rx1349_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1353_done
    goto rxscan1353_scan
  rxscan1353_loop:
    ($P10) = rx1349_cur."from"()
    inc $P10
    set rx1349_pos, $P10
    ge rx1349_pos, rx1349_eos, rxscan1353_done
  rxscan1353_scan:
    set_addr $I10, rxscan1353_loop
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  rxscan1353_done:
.annotate 'line', 598
  # rx subcapture "sym"
    set_addr $I10, rxcap_1354_fail
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1349_pos, 2
    gt $I11, rx1349_eos, rx1349_fail
    sub $I11, rx1349_pos, rx1349_off
    substr $S10, rx1349_tgt, $I11, 2
    ne $S10, "eq", rx1349_fail
    add rx1349_pos, 2
    set_addr $I10, rxcap_1354_fail
    ($I12, $I11) = rx1349_cur."!mark_peek"($I10)
    rx1349_cur."!cursor_pos"($I11)
    ($P10) = rx1349_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1349_pos, "")
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1354_done
  rxcap_1354_fail:
    goto rx1349_fail
  rxcap_1354_done:
  # rx subrule "O" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1349_pos = $P10."pos"()
  # rx pass
    rx1349_cur."!cursor_pass"(rx1349_pos, "infix:sym<eq>")
    if_null rx1349_debug, debug_1018
    rx1349_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1349_pos)
  debug_1018:
    .return (rx1349_cur)
  rx1349_restart:
.annotate 'line', 520
    if_null rx1349_debug, debug_1019
    rx1349_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1019:
  rx1349_fail:
    (rx1349_rep, rx1349_pos, $I10, $P10) = rx1349_cur."!mark_fail"(0)
    lt rx1349_pos, -1, rx1349_done
    eq rx1349_pos, -1, rx1349_fail
    jump $I10
  rx1349_done:
    rx1349_cur."!cursor_fail"()
    if_null rx1349_debug, debug_1020
    rx1349_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1020:
    .return (rx1349_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("330_1295307698.031") :method
.annotate 'line', 520
    $P1351 = self."!PREFIX__!subrule"("O", "eq")
    new $P1352, "ResizablePMCArray"
    push $P1352, $P1351
    .return ($P1352)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("331_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1356_tgt
    .local int rx1356_pos
    .local int rx1356_off
    .local int rx1356_eos
    .local int rx1356_rep
    .local pmc rx1356_cur
    .local pmc rx1356_debug
    (rx1356_cur, rx1356_pos, rx1356_tgt, $I10) = self."!cursor_start"()
    getattribute rx1356_debug, rx1356_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1356_cur
    .local pmc match
    .lex "$/", match
    length rx1356_eos, rx1356_tgt
    gt rx1356_pos, rx1356_eos, rx1356_done
    set rx1356_off, 0
    lt rx1356_pos, 2, rx1356_start
    sub rx1356_off, rx1356_pos, 1
    substr rx1356_tgt, rx1356_tgt, rx1356_off
  rx1356_start:
    eq $I10, 1, rx1356_restart
    if_null rx1356_debug, debug_1021
    rx1356_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1360_done
    goto rxscan1360_scan
  rxscan1360_loop:
    ($P10) = rx1356_cur."from"()
    inc $P10
    set rx1356_pos, $P10
    ge rx1356_pos, rx1356_eos, rxscan1360_done
  rxscan1360_scan:
    set_addr $I10, rxscan1360_loop
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  rxscan1360_done:
.annotate 'line', 599
  # rx subcapture "sym"
    set_addr $I10, rxcap_1361_fail
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1356_pos, 2
    gt $I11, rx1356_eos, rx1356_fail
    sub $I11, rx1356_pos, rx1356_off
    substr $S10, rx1356_tgt, $I11, 2
    ne $S10, "ne", rx1356_fail
    add rx1356_pos, 2
    set_addr $I10, rxcap_1361_fail
    ($I12, $I11) = rx1356_cur."!mark_peek"($I10)
    rx1356_cur."!cursor_pos"($I11)
    ($P10) = rx1356_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1356_pos, "")
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1361_done
  rxcap_1361_fail:
    goto rx1356_fail
  rxcap_1361_done:
  # rx subrule "O" subtype=capture negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1356_fail
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1356_pos = $P10."pos"()
  # rx pass
    rx1356_cur."!cursor_pass"(rx1356_pos, "infix:sym<ne>")
    if_null rx1356_debug, debug_1022
    rx1356_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1356_pos)
  debug_1022:
    .return (rx1356_cur)
  rx1356_restart:
.annotate 'line', 520
    if_null rx1356_debug, debug_1023
    rx1356_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1023:
  rx1356_fail:
    (rx1356_rep, rx1356_pos, $I10, $P10) = rx1356_cur."!mark_fail"(0)
    lt rx1356_pos, -1, rx1356_done
    eq rx1356_pos, -1, rx1356_fail
    jump $I10
  rx1356_done:
    rx1356_cur."!cursor_fail"()
    if_null rx1356_debug, debug_1024
    rx1356_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1024:
    .return (rx1356_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("332_1295307698.031") :method
.annotate 'line', 520
    $P1358 = self."!PREFIX__!subrule"("O", "ne")
    new $P1359, "ResizablePMCArray"
    push $P1359, $P1358
    .return ($P1359)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("333_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1363_tgt
    .local int rx1363_pos
    .local int rx1363_off
    .local int rx1363_eos
    .local int rx1363_rep
    .local pmc rx1363_cur
    .local pmc rx1363_debug
    (rx1363_cur, rx1363_pos, rx1363_tgt, $I10) = self."!cursor_start"()
    getattribute rx1363_debug, rx1363_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1363_cur
    .local pmc match
    .lex "$/", match
    length rx1363_eos, rx1363_tgt
    gt rx1363_pos, rx1363_eos, rx1363_done
    set rx1363_off, 0
    lt rx1363_pos, 2, rx1363_start
    sub rx1363_off, rx1363_pos, 1
    substr rx1363_tgt, rx1363_tgt, rx1363_off
  rx1363_start:
    eq $I10, 1, rx1363_restart
    if_null rx1363_debug, debug_1025
    rx1363_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1367_done
    goto rxscan1367_scan
  rxscan1367_loop:
    ($P10) = rx1363_cur."from"()
    inc $P10
    set rx1363_pos, $P10
    ge rx1363_pos, rx1363_eos, rxscan1367_done
  rxscan1367_scan:
    set_addr $I10, rxscan1367_loop
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  rxscan1367_done:
.annotate 'line', 600
  # rx subcapture "sym"
    set_addr $I10, rxcap_1368_fail
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  # rx literal  "le"
    add $I11, rx1363_pos, 2
    gt $I11, rx1363_eos, rx1363_fail
    sub $I11, rx1363_pos, rx1363_off
    substr $S10, rx1363_tgt, $I11, 2
    ne $S10, "le", rx1363_fail
    add rx1363_pos, 2
    set_addr $I10, rxcap_1368_fail
    ($I12, $I11) = rx1363_cur."!mark_peek"($I10)
    rx1363_cur."!cursor_pos"($I11)
    ($P10) = rx1363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1363_pos, "")
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1368_done
  rxcap_1368_fail:
    goto rx1363_fail
  rxcap_1368_done:
  # rx subrule "O" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1363_pos = $P10."pos"()
  # rx pass
    rx1363_cur."!cursor_pass"(rx1363_pos, "infix:sym<le>")
    if_null rx1363_debug, debug_1026
    rx1363_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1363_pos)
  debug_1026:
    .return (rx1363_cur)
  rx1363_restart:
.annotate 'line', 520
    if_null rx1363_debug, debug_1027
    rx1363_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1027:
  rx1363_fail:
    (rx1363_rep, rx1363_pos, $I10, $P10) = rx1363_cur."!mark_fail"(0)
    lt rx1363_pos, -1, rx1363_done
    eq rx1363_pos, -1, rx1363_fail
    jump $I10
  rx1363_done:
    rx1363_cur."!cursor_fail"()
    if_null rx1363_debug, debug_1028
    rx1363_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1028:
    .return (rx1363_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("334_1295307698.031") :method
.annotate 'line', 520
    $P1365 = self."!PREFIX__!subrule"("O", "le")
    new $P1366, "ResizablePMCArray"
    push $P1366, $P1365
    .return ($P1366)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("335_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1370_tgt
    .local int rx1370_pos
    .local int rx1370_off
    .local int rx1370_eos
    .local int rx1370_rep
    .local pmc rx1370_cur
    .local pmc rx1370_debug
    (rx1370_cur, rx1370_pos, rx1370_tgt, $I10) = self."!cursor_start"()
    getattribute rx1370_debug, rx1370_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1370_cur
    .local pmc match
    .lex "$/", match
    length rx1370_eos, rx1370_tgt
    gt rx1370_pos, rx1370_eos, rx1370_done
    set rx1370_off, 0
    lt rx1370_pos, 2, rx1370_start
    sub rx1370_off, rx1370_pos, 1
    substr rx1370_tgt, rx1370_tgt, rx1370_off
  rx1370_start:
    eq $I10, 1, rx1370_restart
    if_null rx1370_debug, debug_1029
    rx1370_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1374_done
    goto rxscan1374_scan
  rxscan1374_loop:
    ($P10) = rx1370_cur."from"()
    inc $P10
    set rx1370_pos, $P10
    ge rx1370_pos, rx1370_eos, rxscan1374_done
  rxscan1374_scan:
    set_addr $I10, rxscan1374_loop
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  rxscan1374_done:
.annotate 'line', 601
  # rx subcapture "sym"
    set_addr $I10, rxcap_1375_fail
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1370_pos, 2
    gt $I11, rx1370_eos, rx1370_fail
    sub $I11, rx1370_pos, rx1370_off
    substr $S10, rx1370_tgt, $I11, 2
    ne $S10, "ge", rx1370_fail
    add rx1370_pos, 2
    set_addr $I10, rxcap_1375_fail
    ($I12, $I11) = rx1370_cur."!mark_peek"($I10)
    rx1370_cur."!cursor_pos"($I11)
    ($P10) = rx1370_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1370_pos, "")
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1375_done
  rxcap_1375_fail:
    goto rx1370_fail
  rxcap_1375_done:
  # rx subrule "O" subtype=capture negate=
    rx1370_cur."!cursor_pos"(rx1370_pos)
    $P10 = rx1370_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1370_fail
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1370_pos = $P10."pos"()
  # rx pass
    rx1370_cur."!cursor_pass"(rx1370_pos, "infix:sym<ge>")
    if_null rx1370_debug, debug_1030
    rx1370_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1370_pos)
  debug_1030:
    .return (rx1370_cur)
  rx1370_restart:
.annotate 'line', 520
    if_null rx1370_debug, debug_1031
    rx1370_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1031:
  rx1370_fail:
    (rx1370_rep, rx1370_pos, $I10, $P10) = rx1370_cur."!mark_fail"(0)
    lt rx1370_pos, -1, rx1370_done
    eq rx1370_pos, -1, rx1370_fail
    jump $I10
  rx1370_done:
    rx1370_cur."!cursor_fail"()
    if_null rx1370_debug, debug_1032
    rx1370_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1032:
    .return (rx1370_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("336_1295307698.031") :method
.annotate 'line', 520
    $P1372 = self."!PREFIX__!subrule"("O", "ge")
    new $P1373, "ResizablePMCArray"
    push $P1373, $P1372
    .return ($P1373)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("337_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1377_tgt
    .local int rx1377_pos
    .local int rx1377_off
    .local int rx1377_eos
    .local int rx1377_rep
    .local pmc rx1377_cur
    .local pmc rx1377_debug
    (rx1377_cur, rx1377_pos, rx1377_tgt, $I10) = self."!cursor_start"()
    getattribute rx1377_debug, rx1377_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1377_cur
    .local pmc match
    .lex "$/", match
    length rx1377_eos, rx1377_tgt
    gt rx1377_pos, rx1377_eos, rx1377_done
    set rx1377_off, 0
    lt rx1377_pos, 2, rx1377_start
    sub rx1377_off, rx1377_pos, 1
    substr rx1377_tgt, rx1377_tgt, rx1377_off
  rx1377_start:
    eq $I10, 1, rx1377_restart
    if_null rx1377_debug, debug_1033
    rx1377_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1381_done
    goto rxscan1381_scan
  rxscan1381_loop:
    ($P10) = rx1377_cur."from"()
    inc $P10
    set rx1377_pos, $P10
    ge rx1377_pos, rx1377_eos, rxscan1381_done
  rxscan1381_scan:
    set_addr $I10, rxscan1381_loop
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  rxscan1381_done:
.annotate 'line', 602
  # rx subcapture "sym"
    set_addr $I10, rxcap_1382_fail
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1377_pos, 2
    gt $I11, rx1377_eos, rx1377_fail
    sub $I11, rx1377_pos, rx1377_off
    substr $S10, rx1377_tgt, $I11, 2
    ne $S10, "lt", rx1377_fail
    add rx1377_pos, 2
    set_addr $I10, rxcap_1382_fail
    ($I12, $I11) = rx1377_cur."!mark_peek"($I10)
    rx1377_cur."!cursor_pos"($I11)
    ($P10) = rx1377_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1377_pos, "")
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1382_done
  rxcap_1382_fail:
    goto rx1377_fail
  rxcap_1382_done:
  # rx subrule "O" subtype=capture negate=
    rx1377_cur."!cursor_pos"(rx1377_pos)
    $P10 = rx1377_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1377_fail
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1377_pos = $P10."pos"()
  # rx pass
    rx1377_cur."!cursor_pass"(rx1377_pos, "infix:sym<lt>")
    if_null rx1377_debug, debug_1034
    rx1377_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1377_pos)
  debug_1034:
    .return (rx1377_cur)
  rx1377_restart:
.annotate 'line', 520
    if_null rx1377_debug, debug_1035
    rx1377_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1035:
  rx1377_fail:
    (rx1377_rep, rx1377_pos, $I10, $P10) = rx1377_cur."!mark_fail"(0)
    lt rx1377_pos, -1, rx1377_done
    eq rx1377_pos, -1, rx1377_fail
    jump $I10
  rx1377_done:
    rx1377_cur."!cursor_fail"()
    if_null rx1377_debug, debug_1036
    rx1377_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1036:
    .return (rx1377_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("338_1295307698.031") :method
.annotate 'line', 520
    $P1379 = self."!PREFIX__!subrule"("O", "lt")
    new $P1380, "ResizablePMCArray"
    push $P1380, $P1379
    .return ($P1380)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("339_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    getattribute rx1384_debug, rx1384_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_1037
    rx1384_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    ($P10) = rx1384_cur."from"()
    inc $P10
    set rx1384_pos, $P10
    ge rx1384_pos, rx1384_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1388_done:
.annotate 'line', 603
  # rx subcapture "sym"
    set_addr $I10, rxcap_1389_fail
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1384_pos, 2
    gt $I11, rx1384_eos, rx1384_fail
    sub $I11, rx1384_pos, rx1384_off
    substr $S10, rx1384_tgt, $I11, 2
    ne $S10, "gt", rx1384_fail
    add rx1384_pos, 2
    set_addr $I10, rxcap_1389_fail
    ($I12, $I11) = rx1384_cur."!mark_peek"($I10)
    rx1384_cur."!cursor_pos"($I11)
    ($P10) = rx1384_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1384_pos, "")
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1389_done
  rxcap_1389_fail:
    goto rx1384_fail
  rxcap_1389_done:
  # rx subrule "O" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1384_pos = $P10."pos"()
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "infix:sym<gt>")
    if_null rx1384_debug, debug_1038
    rx1384_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1384_pos)
  debug_1038:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 520
    if_null rx1384_debug, debug_1039
    rx1384_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1039:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1040
    rx1384_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1040:
    .return (rx1384_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("340_1295307698.031") :method
.annotate 'line', 520
    $P1386 = self."!PREFIX__!subrule"("O", "gt")
    new $P1387, "ResizablePMCArray"
    push $P1387, $P1386
    .return ($P1387)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("341_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1391_tgt
    .local int rx1391_pos
    .local int rx1391_off
    .local int rx1391_eos
    .local int rx1391_rep
    .local pmc rx1391_cur
    .local pmc rx1391_debug
    (rx1391_cur, rx1391_pos, rx1391_tgt, $I10) = self."!cursor_start"()
    getattribute rx1391_debug, rx1391_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1391_cur
    .local pmc match
    .lex "$/", match
    length rx1391_eos, rx1391_tgt
    gt rx1391_pos, rx1391_eos, rx1391_done
    set rx1391_off, 0
    lt rx1391_pos, 2, rx1391_start
    sub rx1391_off, rx1391_pos, 1
    substr rx1391_tgt, rx1391_tgt, rx1391_off
  rx1391_start:
    eq $I10, 1, rx1391_restart
    if_null rx1391_debug, debug_1041
    rx1391_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1395_done
    goto rxscan1395_scan
  rxscan1395_loop:
    ($P10) = rx1391_cur."from"()
    inc $P10
    set rx1391_pos, $P10
    ge rx1391_pos, rx1391_eos, rxscan1395_done
  rxscan1395_scan:
    set_addr $I10, rxscan1395_loop
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  rxscan1395_done:
.annotate 'line', 604
  # rx subcapture "sym"
    set_addr $I10, rxcap_1396_fail
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1391_pos, 3
    gt $I11, rx1391_eos, rx1391_fail
    sub $I11, rx1391_pos, rx1391_off
    substr $S10, rx1391_tgt, $I11, 3
    ne $S10, "=:=", rx1391_fail
    add rx1391_pos, 3
    set_addr $I10, rxcap_1396_fail
    ($I12, $I11) = rx1391_cur."!mark_peek"($I10)
    rx1391_cur."!cursor_pos"($I11)
    ($P10) = rx1391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1391_pos, "")
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1396_done
  rxcap_1396_fail:
    goto rx1391_fail
  rxcap_1396_done:
  # rx subrule "O" subtype=capture negate=
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1391_fail
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1391_pos = $P10."pos"()
  # rx pass
    rx1391_cur."!cursor_pass"(rx1391_pos, "infix:sym<=:=>")
    if_null rx1391_debug, debug_1042
    rx1391_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1391_pos)
  debug_1042:
    .return (rx1391_cur)
  rx1391_restart:
.annotate 'line', 520
    if_null rx1391_debug, debug_1043
    rx1391_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1043:
  rx1391_fail:
    (rx1391_rep, rx1391_pos, $I10, $P10) = rx1391_cur."!mark_fail"(0)
    lt rx1391_pos, -1, rx1391_done
    eq rx1391_pos, -1, rx1391_fail
    jump $I10
  rx1391_done:
    rx1391_cur."!cursor_fail"()
    if_null rx1391_debug, debug_1044
    rx1391_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1044:
    .return (rx1391_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("342_1295307698.031") :method
.annotate 'line', 520
    $P1393 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1394, "ResizablePMCArray"
    push $P1394, $P1393
    .return ($P1394)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("343_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1398_tgt
    .local int rx1398_pos
    .local int rx1398_off
    .local int rx1398_eos
    .local int rx1398_rep
    .local pmc rx1398_cur
    .local pmc rx1398_debug
    (rx1398_cur, rx1398_pos, rx1398_tgt, $I10) = self."!cursor_start"()
    getattribute rx1398_debug, rx1398_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1398_cur
    .local pmc match
    .lex "$/", match
    length rx1398_eos, rx1398_tgt
    gt rx1398_pos, rx1398_eos, rx1398_done
    set rx1398_off, 0
    lt rx1398_pos, 2, rx1398_start
    sub rx1398_off, rx1398_pos, 1
    substr rx1398_tgt, rx1398_tgt, rx1398_off
  rx1398_start:
    eq $I10, 1, rx1398_restart
    if_null rx1398_debug, debug_1045
    rx1398_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1402_done
    goto rxscan1402_scan
  rxscan1402_loop:
    ($P10) = rx1398_cur."from"()
    inc $P10
    set rx1398_pos, $P10
    ge rx1398_pos, rx1398_eos, rxscan1402_done
  rxscan1402_scan:
    set_addr $I10, rxscan1402_loop
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  rxscan1402_done:
.annotate 'line', 605
  # rx subcapture "sym"
    set_addr $I10, rxcap_1403_fail
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1398_pos, 2
    gt $I11, rx1398_eos, rx1398_fail
    sub $I11, rx1398_pos, rx1398_off
    substr $S10, rx1398_tgt, $I11, 2
    ne $S10, "~~", rx1398_fail
    add rx1398_pos, 2
    set_addr $I10, rxcap_1403_fail
    ($I12, $I11) = rx1398_cur."!mark_peek"($I10)
    rx1398_cur."!cursor_pos"($I11)
    ($P10) = rx1398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1398_pos, "")
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1403_done
  rxcap_1403_fail:
    goto rx1398_fail
  rxcap_1403_done:
  # rx subrule "O" subtype=capture negate=
    rx1398_cur."!cursor_pos"(rx1398_pos)
    $P10 = rx1398_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1398_fail
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1398_pos = $P10."pos"()
  # rx pass
    rx1398_cur."!cursor_pass"(rx1398_pos, "infix:sym<~~>")
    if_null rx1398_debug, debug_1046
    rx1398_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1398_pos)
  debug_1046:
    .return (rx1398_cur)
  rx1398_restart:
.annotate 'line', 520
    if_null rx1398_debug, debug_1047
    rx1398_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1047:
  rx1398_fail:
    (rx1398_rep, rx1398_pos, $I10, $P10) = rx1398_cur."!mark_fail"(0)
    lt rx1398_pos, -1, rx1398_done
    eq rx1398_pos, -1, rx1398_fail
    jump $I10
  rx1398_done:
    rx1398_cur."!cursor_fail"()
    if_null rx1398_debug, debug_1048
    rx1398_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1048:
    .return (rx1398_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("344_1295307698.031") :method
.annotate 'line', 520
    $P1400 = self."!PREFIX__!subrule"("O", "~~")
    new $P1401, "ResizablePMCArray"
    push $P1401, $P1400
    .return ($P1401)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("345_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1405_tgt
    .local int rx1405_pos
    .local int rx1405_off
    .local int rx1405_eos
    .local int rx1405_rep
    .local pmc rx1405_cur
    .local pmc rx1405_debug
    (rx1405_cur, rx1405_pos, rx1405_tgt, $I10) = self."!cursor_start"()
    getattribute rx1405_debug, rx1405_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1405_cur
    .local pmc match
    .lex "$/", match
    length rx1405_eos, rx1405_tgt
    gt rx1405_pos, rx1405_eos, rx1405_done
    set rx1405_off, 0
    lt rx1405_pos, 2, rx1405_start
    sub rx1405_off, rx1405_pos, 1
    substr rx1405_tgt, rx1405_tgt, rx1405_off
  rx1405_start:
    eq $I10, 1, rx1405_restart
    if_null rx1405_debug, debug_1049
    rx1405_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1409_done
    goto rxscan1409_scan
  rxscan1409_loop:
    ($P10) = rx1405_cur."from"()
    inc $P10
    set rx1405_pos, $P10
    ge rx1405_pos, rx1405_eos, rxscan1409_done
  rxscan1409_scan:
    set_addr $I10, rxscan1409_loop
    rx1405_cur."!mark_push"(0, rx1405_pos, $I10)
  rxscan1409_done:
.annotate 'line', 607
  # rx subcapture "sym"
    set_addr $I10, rxcap_1410_fail
    rx1405_cur."!mark_push"(0, rx1405_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1405_pos, 2
    gt $I11, rx1405_eos, rx1405_fail
    sub $I11, rx1405_pos, rx1405_off
    substr $S10, rx1405_tgt, $I11, 2
    ne $S10, "&&", rx1405_fail
    add rx1405_pos, 2
    set_addr $I10, rxcap_1410_fail
    ($I12, $I11) = rx1405_cur."!mark_peek"($I10)
    rx1405_cur."!cursor_pos"($I11)
    ($P10) = rx1405_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1405_pos, "")
    rx1405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1410_done
  rxcap_1410_fail:
    goto rx1405_fail
  rxcap_1410_done:
  # rx subrule "O" subtype=capture negate=
    rx1405_cur."!cursor_pos"(rx1405_pos)
    $P10 = rx1405_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1405_fail
    rx1405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1405_pos = $P10."pos"()
  # rx pass
    rx1405_cur."!cursor_pass"(rx1405_pos, "infix:sym<&&>")
    if_null rx1405_debug, debug_1050
    rx1405_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1405_pos)
  debug_1050:
    .return (rx1405_cur)
  rx1405_restart:
.annotate 'line', 520
    if_null rx1405_debug, debug_1051
    rx1405_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1051:
  rx1405_fail:
    (rx1405_rep, rx1405_pos, $I10, $P10) = rx1405_cur."!mark_fail"(0)
    lt rx1405_pos, -1, rx1405_done
    eq rx1405_pos, -1, rx1405_fail
    jump $I10
  rx1405_done:
    rx1405_cur."!cursor_fail"()
    if_null rx1405_debug, debug_1052
    rx1405_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1052:
    .return (rx1405_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("346_1295307698.031") :method
.annotate 'line', 520
    $P1407 = self."!PREFIX__!subrule"("O", "&&")
    new $P1408, "ResizablePMCArray"
    push $P1408, $P1407
    .return ($P1408)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("347_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1412_tgt
    .local int rx1412_pos
    .local int rx1412_off
    .local int rx1412_eos
    .local int rx1412_rep
    .local pmc rx1412_cur
    .local pmc rx1412_debug
    (rx1412_cur, rx1412_pos, rx1412_tgt, $I10) = self."!cursor_start"()
    getattribute rx1412_debug, rx1412_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1412_cur
    .local pmc match
    .lex "$/", match
    length rx1412_eos, rx1412_tgt
    gt rx1412_pos, rx1412_eos, rx1412_done
    set rx1412_off, 0
    lt rx1412_pos, 2, rx1412_start
    sub rx1412_off, rx1412_pos, 1
    substr rx1412_tgt, rx1412_tgt, rx1412_off
  rx1412_start:
    eq $I10, 1, rx1412_restart
    if_null rx1412_debug, debug_1053
    rx1412_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1416_done
    goto rxscan1416_scan
  rxscan1416_loop:
    ($P10) = rx1412_cur."from"()
    inc $P10
    set rx1412_pos, $P10
    ge rx1412_pos, rx1412_eos, rxscan1416_done
  rxscan1416_scan:
    set_addr $I10, rxscan1416_loop
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  rxscan1416_done:
.annotate 'line', 609
  # rx subcapture "sym"
    set_addr $I10, rxcap_1417_fail
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  # rx literal  "||"
    add $I11, rx1412_pos, 2
    gt $I11, rx1412_eos, rx1412_fail
    sub $I11, rx1412_pos, rx1412_off
    substr $S10, rx1412_tgt, $I11, 2
    ne $S10, "||", rx1412_fail
    add rx1412_pos, 2
    set_addr $I10, rxcap_1417_fail
    ($I12, $I11) = rx1412_cur."!mark_peek"($I10)
    rx1412_cur."!cursor_pos"($I11)
    ($P10) = rx1412_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1412_pos, "")
    rx1412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1417_done
  rxcap_1417_fail:
    goto rx1412_fail
  rxcap_1417_done:
  # rx subrule "O" subtype=capture negate=
    rx1412_cur."!cursor_pos"(rx1412_pos)
    $P10 = rx1412_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1412_fail
    rx1412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1412_pos = $P10."pos"()
  # rx pass
    rx1412_cur."!cursor_pass"(rx1412_pos, "infix:sym<||>")
    if_null rx1412_debug, debug_1054
    rx1412_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1412_pos)
  debug_1054:
    .return (rx1412_cur)
  rx1412_restart:
.annotate 'line', 520
    if_null rx1412_debug, debug_1055
    rx1412_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1055:
  rx1412_fail:
    (rx1412_rep, rx1412_pos, $I10, $P10) = rx1412_cur."!mark_fail"(0)
    lt rx1412_pos, -1, rx1412_done
    eq rx1412_pos, -1, rx1412_fail
    jump $I10
  rx1412_done:
    rx1412_cur."!cursor_fail"()
    if_null rx1412_debug, debug_1056
    rx1412_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1056:
    .return (rx1412_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("348_1295307698.031") :method
.annotate 'line', 520
    $P1414 = self."!PREFIX__!subrule"("O", "||")
    new $P1415, "ResizablePMCArray"
    push $P1415, $P1414
    .return ($P1415)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("349_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1419_tgt
    .local int rx1419_pos
    .local int rx1419_off
    .local int rx1419_eos
    .local int rx1419_rep
    .local pmc rx1419_cur
    .local pmc rx1419_debug
    (rx1419_cur, rx1419_pos, rx1419_tgt, $I10) = self."!cursor_start"()
    getattribute rx1419_debug, rx1419_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1419_cur
    .local pmc match
    .lex "$/", match
    length rx1419_eos, rx1419_tgt
    gt rx1419_pos, rx1419_eos, rx1419_done
    set rx1419_off, 0
    lt rx1419_pos, 2, rx1419_start
    sub rx1419_off, rx1419_pos, 1
    substr rx1419_tgt, rx1419_tgt, rx1419_off
  rx1419_start:
    eq $I10, 1, rx1419_restart
    if_null rx1419_debug, debug_1057
    rx1419_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1423_done
    goto rxscan1423_scan
  rxscan1423_loop:
    ($P10) = rx1419_cur."from"()
    inc $P10
    set rx1419_pos, $P10
    ge rx1419_pos, rx1419_eos, rxscan1423_done
  rxscan1423_scan:
    set_addr $I10, rxscan1423_loop
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  rxscan1423_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1424_fail
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  # rx literal  "//"
    add $I11, rx1419_pos, 2
    gt $I11, rx1419_eos, rx1419_fail
    sub $I11, rx1419_pos, rx1419_off
    substr $S10, rx1419_tgt, $I11, 2
    ne $S10, "//", rx1419_fail
    add rx1419_pos, 2
    set_addr $I10, rxcap_1424_fail
    ($I12, $I11) = rx1419_cur."!mark_peek"($I10)
    rx1419_cur."!cursor_pos"($I11)
    ($P10) = rx1419_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1419_pos, "")
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1424_done
  rxcap_1424_fail:
    goto rx1419_fail
  rxcap_1424_done:
  # rx subrule "O" subtype=capture negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1419_fail
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1419_pos = $P10."pos"()
  # rx pass
    rx1419_cur."!cursor_pass"(rx1419_pos, "infix:sym<//>")
    if_null rx1419_debug, debug_1058
    rx1419_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1419_pos)
  debug_1058:
    .return (rx1419_cur)
  rx1419_restart:
.annotate 'line', 520
    if_null rx1419_debug, debug_1059
    rx1419_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1059:
  rx1419_fail:
    (rx1419_rep, rx1419_pos, $I10, $P10) = rx1419_cur."!mark_fail"(0)
    lt rx1419_pos, -1, rx1419_done
    eq rx1419_pos, -1, rx1419_fail
    jump $I10
  rx1419_done:
    rx1419_cur."!cursor_fail"()
    if_null rx1419_debug, debug_1060
    rx1419_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1060:
    .return (rx1419_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("350_1295307698.031") :method
.annotate 'line', 520
    $P1421 = self."!PREFIX__!subrule"("O", "//")
    new $P1422, "ResizablePMCArray"
    push $P1422, $P1421
    .return ($P1422)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("351_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1426_tgt
    .local int rx1426_pos
    .local int rx1426_off
    .local int rx1426_eos
    .local int rx1426_rep
    .local pmc rx1426_cur
    .local pmc rx1426_debug
    (rx1426_cur, rx1426_pos, rx1426_tgt, $I10) = self."!cursor_start"()
    getattribute rx1426_debug, rx1426_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1426_cur
    .local pmc match
    .lex "$/", match
    length rx1426_eos, rx1426_tgt
    gt rx1426_pos, rx1426_eos, rx1426_done
    set rx1426_off, 0
    lt rx1426_pos, 2, rx1426_start
    sub rx1426_off, rx1426_pos, 1
    substr rx1426_tgt, rx1426_tgt, rx1426_off
  rx1426_start:
    eq $I10, 1, rx1426_restart
    if_null rx1426_debug, debug_1061
    rx1426_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1430_done
    goto rxscan1430_scan
  rxscan1430_loop:
    ($P10) = rx1426_cur."from"()
    inc $P10
    set rx1426_pos, $P10
    ge rx1426_pos, rx1426_eos, rxscan1430_done
  rxscan1430_scan:
    set_addr $I10, rxscan1430_loop
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  rxscan1430_done:
.annotate 'line', 613
  # rx literal  "??"
    add $I11, rx1426_pos, 2
    gt $I11, rx1426_eos, rx1426_fail
    sub $I11, rx1426_pos, rx1426_off
    substr $S10, rx1426_tgt, $I11, 2
    ne $S10, "??", rx1426_fail
    add rx1426_pos, 2
.annotate 'line', 614
  # rx subrule "ws" subtype=method negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."ws"()
    unless $P10, rx1426_fail
    rx1426_pos = $P10."pos"()
.annotate 'line', 615
  # rx subrule "EXPR" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."EXPR"("i=")
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1426_pos = $P10."pos"()
.annotate 'line', 616
  # rx literal  "!!"
    add $I11, rx1426_pos, 2
    gt $I11, rx1426_eos, rx1426_fail
    sub $I11, rx1426_pos, rx1426_off
    substr $S10, rx1426_tgt, $I11, 2
    ne $S10, "!!", rx1426_fail
    add rx1426_pos, 2
.annotate 'line', 617
  # rx subrule "O" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1426_pos = $P10."pos"()
.annotate 'line', 612
  # rx pass
    rx1426_cur."!cursor_pass"(rx1426_pos, "infix:sym<?? !!>")
    if_null rx1426_debug, debug_1062
    rx1426_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1426_pos)
  debug_1062:
    .return (rx1426_cur)
  rx1426_restart:
.annotate 'line', 520
    if_null rx1426_debug, debug_1063
    rx1426_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1063:
  rx1426_fail:
    (rx1426_rep, rx1426_pos, $I10, $P10) = rx1426_cur."!mark_fail"(0)
    lt rx1426_pos, -1, rx1426_done
    eq rx1426_pos, -1, rx1426_fail
    jump $I10
  rx1426_done:
    rx1426_cur."!cursor_fail"()
    if_null rx1426_debug, debug_1064
    rx1426_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1064:
    .return (rx1426_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("352_1295307698.031") :method
.annotate 'line', 520
    $P1428 = self."!PREFIX__!subrule"("ws", "??")
    new $P1429, "ResizablePMCArray"
    push $P1429, $P1428
    .return ($P1429)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("353_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1432_tgt
    .local int rx1432_pos
    .local int rx1432_off
    .local int rx1432_eos
    .local int rx1432_rep
    .local pmc rx1432_cur
    .local pmc rx1432_debug
    (rx1432_cur, rx1432_pos, rx1432_tgt, $I10) = self."!cursor_start"()
    getattribute rx1432_debug, rx1432_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1432_cur
    .local pmc match
    .lex "$/", match
    length rx1432_eos, rx1432_tgt
    gt rx1432_pos, rx1432_eos, rx1432_done
    set rx1432_off, 0
    lt rx1432_pos, 2, rx1432_start
    sub rx1432_off, rx1432_pos, 1
    substr rx1432_tgt, rx1432_tgt, rx1432_off
  rx1432_start:
    eq $I10, 1, rx1432_restart
    if_null rx1432_debug, debug_1065
    rx1432_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1436_done
    goto rxscan1436_scan
  rxscan1436_loop:
    ($P10) = rx1432_cur."from"()
    inc $P10
    set rx1432_pos, $P10
    ge rx1432_pos, rx1432_eos, rxscan1436_done
  rxscan1436_scan:
    set_addr $I10, rxscan1436_loop
    rx1432_cur."!mark_push"(0, rx1432_pos, $I10)
  rxscan1436_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1437_fail
    rx1432_cur."!mark_push"(0, rx1432_pos, $I10)
  # rx literal  "="
    add $I11, rx1432_pos, 1
    gt $I11, rx1432_eos, rx1432_fail
    sub $I11, rx1432_pos, rx1432_off
    ord $I11, rx1432_tgt, $I11
    ne $I11, 61, rx1432_fail
    add rx1432_pos, 1
    set_addr $I10, rxcap_1437_fail
    ($I12, $I11) = rx1432_cur."!mark_peek"($I10)
    rx1432_cur."!cursor_pos"($I11)
    ($P10) = rx1432_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1432_pos, "")
    rx1432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1437_done
  rxcap_1437_fail:
    goto rx1432_fail
  rxcap_1437_done:
  # rx subrule "panic" subtype=method negate=
    rx1432_cur."!cursor_pos"(rx1432_pos)
    $P10 = rx1432_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1432_fail
    rx1432_pos = $P10."pos"()
.annotate 'line', 620
  # rx pass
    rx1432_cur."!cursor_pass"(rx1432_pos, "infix:sym<=>")
    if_null rx1432_debug, debug_1066
    rx1432_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1432_pos)
  debug_1066:
    .return (rx1432_cur)
  rx1432_restart:
.annotate 'line', 520
    if_null rx1432_debug, debug_1067
    rx1432_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1067:
  rx1432_fail:
    (rx1432_rep, rx1432_pos, $I10, $P10) = rx1432_cur."!mark_fail"(0)
    lt rx1432_pos, -1, rx1432_done
    eq rx1432_pos, -1, rx1432_fail
    jump $I10
  rx1432_done:
    rx1432_cur."!cursor_fail"()
    if_null rx1432_debug, debug_1068
    rx1432_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1068:
    .return (rx1432_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("354_1295307698.031") :method
.annotate 'line', 520
    $P1434 = self."!PREFIX__!subrule"("panic", "=")
    new $P1435, "ResizablePMCArray"
    push $P1435, $P1434
    .return ($P1435)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("355_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1439_tgt
    .local int rx1439_pos
    .local int rx1439_off
    .local int rx1439_eos
    .local int rx1439_rep
    .local pmc rx1439_cur
    .local pmc rx1439_debug
    (rx1439_cur, rx1439_pos, rx1439_tgt, $I10) = self."!cursor_start"()
    getattribute rx1439_debug, rx1439_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1439_cur
    .local pmc match
    .lex "$/", match
    length rx1439_eos, rx1439_tgt
    gt rx1439_pos, rx1439_eos, rx1439_done
    set rx1439_off, 0
    lt rx1439_pos, 2, rx1439_start
    sub rx1439_off, rx1439_pos, 1
    substr rx1439_tgt, rx1439_tgt, rx1439_off
  rx1439_start:
    eq $I10, 1, rx1439_restart
    if_null rx1439_debug, debug_1069
    rx1439_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1443_done
    goto rxscan1443_scan
  rxscan1443_loop:
    ($P10) = rx1439_cur."from"()
    inc $P10
    set rx1439_pos, $P10
    ge rx1439_pos, rx1439_eos, rxscan1443_done
  rxscan1443_scan:
    set_addr $I10, rxscan1443_loop
    rx1439_cur."!mark_push"(0, rx1439_pos, $I10)
  rxscan1443_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1444_fail
    rx1439_cur."!mark_push"(0, rx1439_pos, $I10)
  # rx literal  ":="
    add $I11, rx1439_pos, 2
    gt $I11, rx1439_eos, rx1439_fail
    sub $I11, rx1439_pos, rx1439_off
    substr $S10, rx1439_tgt, $I11, 2
    ne $S10, ":=", rx1439_fail
    add rx1439_pos, 2
    set_addr $I10, rxcap_1444_fail
    ($I12, $I11) = rx1439_cur."!mark_peek"($I10)
    rx1439_cur."!cursor_pos"($I11)
    ($P10) = rx1439_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1439_pos, "")
    rx1439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1444_done
  rxcap_1444_fail:
    goto rx1439_fail
  rxcap_1444_done:
  # rx subrule "O" subtype=capture negate=
    rx1439_cur."!cursor_pos"(rx1439_pos)
    $P10 = rx1439_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1439_fail
    rx1439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1439_pos = $P10."pos"()
  # rx pass
    rx1439_cur."!cursor_pass"(rx1439_pos, "infix:sym<:=>")
    if_null rx1439_debug, debug_1070
    rx1439_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1439_pos)
  debug_1070:
    .return (rx1439_cur)
  rx1439_restart:
.annotate 'line', 520
    if_null rx1439_debug, debug_1071
    rx1439_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1071:
  rx1439_fail:
    (rx1439_rep, rx1439_pos, $I10, $P10) = rx1439_cur."!mark_fail"(0)
    lt rx1439_pos, -1, rx1439_done
    eq rx1439_pos, -1, rx1439_fail
    jump $I10
  rx1439_done:
    rx1439_cur."!cursor_fail"()
    if_null rx1439_debug, debug_1072
    rx1439_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1072:
    .return (rx1439_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("356_1295307698.031") :method
.annotate 'line', 520
    $P1441 = self."!PREFIX__!subrule"("O", ":=")
    new $P1442, "ResizablePMCArray"
    push $P1442, $P1441
    .return ($P1442)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("357_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1446_tgt
    .local int rx1446_pos
    .local int rx1446_off
    .local int rx1446_eos
    .local int rx1446_rep
    .local pmc rx1446_cur
    .local pmc rx1446_debug
    (rx1446_cur, rx1446_pos, rx1446_tgt, $I10) = self."!cursor_start"()
    getattribute rx1446_debug, rx1446_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1446_cur
    .local pmc match
    .lex "$/", match
    length rx1446_eos, rx1446_tgt
    gt rx1446_pos, rx1446_eos, rx1446_done
    set rx1446_off, 0
    lt rx1446_pos, 2, rx1446_start
    sub rx1446_off, rx1446_pos, 1
    substr rx1446_tgt, rx1446_tgt, rx1446_off
  rx1446_start:
    eq $I10, 1, rx1446_restart
    if_null rx1446_debug, debug_1073
    rx1446_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1450_done
    goto rxscan1450_scan
  rxscan1450_loop:
    ($P10) = rx1446_cur."from"()
    inc $P10
    set rx1446_pos, $P10
    ge rx1446_pos, rx1446_eos, rxscan1450_done
  rxscan1450_scan:
    set_addr $I10, rxscan1450_loop
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  rxscan1450_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1451_fail
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  # rx literal  "::="
    add $I11, rx1446_pos, 3
    gt $I11, rx1446_eos, rx1446_fail
    sub $I11, rx1446_pos, rx1446_off
    substr $S10, rx1446_tgt, $I11, 3
    ne $S10, "::=", rx1446_fail
    add rx1446_pos, 3
    set_addr $I10, rxcap_1451_fail
    ($I12, $I11) = rx1446_cur."!mark_peek"($I10)
    rx1446_cur."!cursor_pos"($I11)
    ($P10) = rx1446_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1446_pos, "")
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1451_done
  rxcap_1451_fail:
    goto rx1446_fail
  rxcap_1451_done:
  # rx subrule "O" subtype=capture negate=
    rx1446_cur."!cursor_pos"(rx1446_pos)
    $P10 = rx1446_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1446_fail
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1446_pos = $P10."pos"()
  # rx pass
    rx1446_cur."!cursor_pass"(rx1446_pos, "infix:sym<::=>")
    if_null rx1446_debug, debug_1074
    rx1446_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1446_pos)
  debug_1074:
    .return (rx1446_cur)
  rx1446_restart:
.annotate 'line', 520
    if_null rx1446_debug, debug_1075
    rx1446_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1075:
  rx1446_fail:
    (rx1446_rep, rx1446_pos, $I10, $P10) = rx1446_cur."!mark_fail"(0)
    lt rx1446_pos, -1, rx1446_done
    eq rx1446_pos, -1, rx1446_fail
    jump $I10
  rx1446_done:
    rx1446_cur."!cursor_fail"()
    if_null rx1446_debug, debug_1076
    rx1446_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1076:
    .return (rx1446_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("358_1295307698.031") :method
.annotate 'line', 520
    $P1448 = self."!PREFIX__!subrule"("O", "::=")
    new $P1449, "ResizablePMCArray"
    push $P1449, $P1448
    .return ($P1449)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("359_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1453_tgt
    .local int rx1453_pos
    .local int rx1453_off
    .local int rx1453_eos
    .local int rx1453_rep
    .local pmc rx1453_cur
    .local pmc rx1453_debug
    (rx1453_cur, rx1453_pos, rx1453_tgt, $I10) = self."!cursor_start"()
    getattribute rx1453_debug, rx1453_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1453_cur
    .local pmc match
    .lex "$/", match
    length rx1453_eos, rx1453_tgt
    gt rx1453_pos, rx1453_eos, rx1453_done
    set rx1453_off, 0
    lt rx1453_pos, 2, rx1453_start
    sub rx1453_off, rx1453_pos, 1
    substr rx1453_tgt, rx1453_tgt, rx1453_off
  rx1453_start:
    eq $I10, 1, rx1453_restart
    if_null rx1453_debug, debug_1077
    rx1453_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1457_done
    goto rxscan1457_scan
  rxscan1457_loop:
    ($P10) = rx1453_cur."from"()
    inc $P10
    set rx1453_pos, $P10
    ge rx1453_pos, rx1453_eos, rxscan1457_done
  rxscan1457_scan:
    set_addr $I10, rxscan1457_loop
    rx1453_cur."!mark_push"(0, rx1453_pos, $I10)
  rxscan1457_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1458_fail
    rx1453_cur."!mark_push"(0, rx1453_pos, $I10)
  # rx literal  ","
    add $I11, rx1453_pos, 1
    gt $I11, rx1453_eos, rx1453_fail
    sub $I11, rx1453_pos, rx1453_off
    ord $I11, rx1453_tgt, $I11
    ne $I11, 44, rx1453_fail
    add rx1453_pos, 1
    set_addr $I10, rxcap_1458_fail
    ($I12, $I11) = rx1453_cur."!mark_peek"($I10)
    rx1453_cur."!cursor_pos"($I11)
    ($P10) = rx1453_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1453_pos, "")
    rx1453_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1458_done
  rxcap_1458_fail:
    goto rx1453_fail
  rxcap_1458_done:
  # rx subrule "O" subtype=capture negate=
    rx1453_cur."!cursor_pos"(rx1453_pos)
    $P10 = rx1453_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1453_fail
    rx1453_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1453_pos = $P10."pos"()
  # rx pass
    rx1453_cur."!cursor_pass"(rx1453_pos, "infix:sym<,>")
    if_null rx1453_debug, debug_1078
    rx1453_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1453_pos)
  debug_1078:
    .return (rx1453_cur)
  rx1453_restart:
.annotate 'line', 520
    if_null rx1453_debug, debug_1079
    rx1453_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1079:
  rx1453_fail:
    (rx1453_rep, rx1453_pos, $I10, $P10) = rx1453_cur."!mark_fail"(0)
    lt rx1453_pos, -1, rx1453_done
    eq rx1453_pos, -1, rx1453_fail
    jump $I10
  rx1453_done:
    rx1453_cur."!cursor_fail"()
    if_null rx1453_debug, debug_1080
    rx1453_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1080:
    .return (rx1453_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("360_1295307698.031") :method
.annotate 'line', 520
    $P1455 = self."!PREFIX__!subrule"("O", ",")
    new $P1456, "ResizablePMCArray"
    push $P1456, $P1455
    .return ($P1456)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("361_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1460_tgt
    .local int rx1460_pos
    .local int rx1460_off
    .local int rx1460_eos
    .local int rx1460_rep
    .local pmc rx1460_cur
    .local pmc rx1460_debug
    (rx1460_cur, rx1460_pos, rx1460_tgt, $I10) = self."!cursor_start"()
    getattribute rx1460_debug, rx1460_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1460_cur
    .local pmc match
    .lex "$/", match
    length rx1460_eos, rx1460_tgt
    gt rx1460_pos, rx1460_eos, rx1460_done
    set rx1460_off, 0
    lt rx1460_pos, 2, rx1460_start
    sub rx1460_off, rx1460_pos, 1
    substr rx1460_tgt, rx1460_tgt, rx1460_off
  rx1460_start:
    eq $I10, 1, rx1460_restart
    if_null rx1460_debug, debug_1081
    rx1460_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1463_done
    goto rxscan1463_scan
  rxscan1463_loop:
    ($P10) = rx1460_cur."from"()
    inc $P10
    set rx1460_pos, $P10
    ge rx1460_pos, rx1460_eos, rxscan1463_done
  rxscan1463_scan:
    set_addr $I10, rxscan1463_loop
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  rxscan1463_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1464_fail
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  # rx literal  "return"
    add $I11, rx1460_pos, 6
    gt $I11, rx1460_eos, rx1460_fail
    sub $I11, rx1460_pos, rx1460_off
    substr $S10, rx1460_tgt, $I11, 6
    ne $S10, "return", rx1460_fail
    add rx1460_pos, 6
    set_addr $I10, rxcap_1464_fail
    ($I12, $I11) = rx1460_cur."!mark_peek"($I10)
    rx1460_cur."!cursor_pos"($I11)
    ($P10) = rx1460_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1460_pos, "")
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1464_done
  rxcap_1464_fail:
    goto rx1460_fail
  rxcap_1464_done:
  # rx charclass s
    ge rx1460_pos, rx1460_eos, rx1460_fail
    sub $I10, rx1460_pos, rx1460_off
    is_cclass $I11, 32, rx1460_tgt, $I10
    unless $I11, rx1460_fail
    inc rx1460_pos
  # rx subrule "O" subtype=capture negate=
    rx1460_cur."!cursor_pos"(rx1460_pos)
    $P10 = rx1460_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1460_fail
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1460_pos = $P10."pos"()
  # rx pass
    rx1460_cur."!cursor_pass"(rx1460_pos, "prefix:sym<return>")
    if_null rx1460_debug, debug_1082
    rx1460_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1460_pos)
  debug_1082:
    .return (rx1460_cur)
  rx1460_restart:
.annotate 'line', 520
    if_null rx1460_debug, debug_1083
    rx1460_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1083:
  rx1460_fail:
    (rx1460_rep, rx1460_pos, $I10, $P10) = rx1460_cur."!mark_fail"(0)
    lt rx1460_pos, -1, rx1460_done
    eq rx1460_pos, -1, rx1460_fail
    jump $I10
  rx1460_done:
    rx1460_cur."!cursor_fail"()
    if_null rx1460_debug, debug_1084
    rx1460_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1084:
    .return (rx1460_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("362_1295307698.031") :method
.annotate 'line', 520
    new $P1462, "ResizablePMCArray"
    push $P1462, "return"
    .return ($P1462)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("363_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1466_tgt
    .local int rx1466_pos
    .local int rx1466_off
    .local int rx1466_eos
    .local int rx1466_rep
    .local pmc rx1466_cur
    .local pmc rx1466_debug
    (rx1466_cur, rx1466_pos, rx1466_tgt, $I10) = self."!cursor_start"()
    getattribute rx1466_debug, rx1466_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1466_cur
    .local pmc match
    .lex "$/", match
    length rx1466_eos, rx1466_tgt
    gt rx1466_pos, rx1466_eos, rx1466_done
    set rx1466_off, 0
    lt rx1466_pos, 2, rx1466_start
    sub rx1466_off, rx1466_pos, 1
    substr rx1466_tgt, rx1466_tgt, rx1466_off
  rx1466_start:
    eq $I10, 1, rx1466_restart
    if_null rx1466_debug, debug_1085
    rx1466_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1469_done
    goto rxscan1469_scan
  rxscan1469_loop:
    ($P10) = rx1466_cur."from"()
    inc $P10
    set rx1466_pos, $P10
    ge rx1466_pos, rx1466_eos, rxscan1469_done
  rxscan1469_scan:
    set_addr $I10, rxscan1469_loop
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  rxscan1469_done:
.annotate 'line', 629
  # rx subcapture "sym"
    set_addr $I10, rxcap_1470_fail
    rx1466_cur."!mark_push"(0, rx1466_pos, $I10)
  # rx literal  "make"
    add $I11, rx1466_pos, 4
    gt $I11, rx1466_eos, rx1466_fail
    sub $I11, rx1466_pos, rx1466_off
    substr $S10, rx1466_tgt, $I11, 4
    ne $S10, "make", rx1466_fail
    add rx1466_pos, 4
    set_addr $I10, rxcap_1470_fail
    ($I12, $I11) = rx1466_cur."!mark_peek"($I10)
    rx1466_cur."!cursor_pos"($I11)
    ($P10) = rx1466_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1466_pos, "")
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1470_done
  rxcap_1470_fail:
    goto rx1466_fail
  rxcap_1470_done:
  # rx charclass s
    ge rx1466_pos, rx1466_eos, rx1466_fail
    sub $I10, rx1466_pos, rx1466_off
    is_cclass $I11, 32, rx1466_tgt, $I10
    unless $I11, rx1466_fail
    inc rx1466_pos
  # rx subrule "O" subtype=capture negate=
    rx1466_cur."!cursor_pos"(rx1466_pos)
    $P10 = rx1466_cur."O"("%list_prefix")
    unless $P10, rx1466_fail
    rx1466_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1466_pos = $P10."pos"()
  # rx pass
    rx1466_cur."!cursor_pass"(rx1466_pos, "prefix:sym<make>")
    if_null rx1466_debug, debug_1086
    rx1466_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1466_pos)
  debug_1086:
    .return (rx1466_cur)
  rx1466_restart:
.annotate 'line', 520
    if_null rx1466_debug, debug_1087
    rx1466_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1087:
  rx1466_fail:
    (rx1466_rep, rx1466_pos, $I10, $P10) = rx1466_cur."!mark_fail"(0)
    lt rx1466_pos, -1, rx1466_done
    eq rx1466_pos, -1, rx1466_fail
    jump $I10
  rx1466_done:
    rx1466_cur."!cursor_fail"()
    if_null rx1466_debug, debug_1088
    rx1466_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1088:
    .return (rx1466_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("364_1295307698.031") :method
.annotate 'line', 520
    new $P1468, "ResizablePMCArray"
    push $P1468, "make"
    .return ($P1468)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("365_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1472_tgt
    .local int rx1472_pos
    .local int rx1472_off
    .local int rx1472_eos
    .local int rx1472_rep
    .local pmc rx1472_cur
    .local pmc rx1472_debug
    (rx1472_cur, rx1472_pos, rx1472_tgt, $I10) = self."!cursor_start"()
    getattribute rx1472_debug, rx1472_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1472_cur
    .local pmc match
    .lex "$/", match
    length rx1472_eos, rx1472_tgt
    gt rx1472_pos, rx1472_eos, rx1472_done
    set rx1472_off, 0
    lt rx1472_pos, 2, rx1472_start
    sub rx1472_off, rx1472_pos, 1
    substr rx1472_tgt, rx1472_tgt, rx1472_off
  rx1472_start:
    eq $I10, 1, rx1472_restart
    if_null rx1472_debug, debug_1089
    rx1472_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1475_done
    goto rxscan1475_scan
  rxscan1475_loop:
    ($P10) = rx1472_cur."from"()
    inc $P10
    set rx1472_pos, $P10
    ge rx1472_pos, rx1472_eos, rxscan1475_done
  rxscan1475_scan:
    set_addr $I10, rxscan1475_loop
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  rxscan1475_done:
.annotate 'line', 630
  # rx subcapture "sym"
    set_addr $I10, rxcap_1476_fail
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  # rx literal  "last"
    add $I11, rx1472_pos, 4
    gt $I11, rx1472_eos, rx1472_fail
    sub $I11, rx1472_pos, rx1472_off
    substr $S10, rx1472_tgt, $I11, 4
    ne $S10, "last", rx1472_fail
    add rx1472_pos, 4
    set_addr $I10, rxcap_1476_fail
    ($I12, $I11) = rx1472_cur."!mark_peek"($I10)
    rx1472_cur."!cursor_pos"($I11)
    ($P10) = rx1472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1472_pos, "")
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1476_done
  rxcap_1476_fail:
    goto rx1472_fail
  rxcap_1476_done:
  # rx pass
    rx1472_cur."!cursor_pass"(rx1472_pos, "term:sym<last>")
    if_null rx1472_debug, debug_1090
    rx1472_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1472_pos)
  debug_1090:
    .return (rx1472_cur)
  rx1472_restart:
.annotate 'line', 520
    if_null rx1472_debug, debug_1091
    rx1472_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1091:
  rx1472_fail:
    (rx1472_rep, rx1472_pos, $I10, $P10) = rx1472_cur."!mark_fail"(0)
    lt rx1472_pos, -1, rx1472_done
    eq rx1472_pos, -1, rx1472_fail
    jump $I10
  rx1472_done:
    rx1472_cur."!cursor_fail"()
    if_null rx1472_debug, debug_1092
    rx1472_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1092:
    .return (rx1472_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("366_1295307698.031") :method
.annotate 'line', 520
    new $P1474, "ResizablePMCArray"
    push $P1474, "last"
    .return ($P1474)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("367_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1478_tgt
    .local int rx1478_pos
    .local int rx1478_off
    .local int rx1478_eos
    .local int rx1478_rep
    .local pmc rx1478_cur
    .local pmc rx1478_debug
    (rx1478_cur, rx1478_pos, rx1478_tgt, $I10) = self."!cursor_start"()
    getattribute rx1478_debug, rx1478_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1478_cur
    .local pmc match
    .lex "$/", match
    length rx1478_eos, rx1478_tgt
    gt rx1478_pos, rx1478_eos, rx1478_done
    set rx1478_off, 0
    lt rx1478_pos, 2, rx1478_start
    sub rx1478_off, rx1478_pos, 1
    substr rx1478_tgt, rx1478_tgt, rx1478_off
  rx1478_start:
    eq $I10, 1, rx1478_restart
    if_null rx1478_debug, debug_1093
    rx1478_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1481_done
    goto rxscan1481_scan
  rxscan1481_loop:
    ($P10) = rx1478_cur."from"()
    inc $P10
    set rx1478_pos, $P10
    ge rx1478_pos, rx1478_eos, rxscan1481_done
  rxscan1481_scan:
    set_addr $I10, rxscan1481_loop
    rx1478_cur."!mark_push"(0, rx1478_pos, $I10)
  rxscan1481_done:
.annotate 'line', 631
  # rx subcapture "sym"
    set_addr $I10, rxcap_1482_fail
    rx1478_cur."!mark_push"(0, rx1478_pos, $I10)
  # rx literal  "next"
    add $I11, rx1478_pos, 4
    gt $I11, rx1478_eos, rx1478_fail
    sub $I11, rx1478_pos, rx1478_off
    substr $S10, rx1478_tgt, $I11, 4
    ne $S10, "next", rx1478_fail
    add rx1478_pos, 4
    set_addr $I10, rxcap_1482_fail
    ($I12, $I11) = rx1478_cur."!mark_peek"($I10)
    rx1478_cur."!cursor_pos"($I11)
    ($P10) = rx1478_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1478_pos, "")
    rx1478_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1482_done
  rxcap_1482_fail:
    goto rx1478_fail
  rxcap_1482_done:
  # rx pass
    rx1478_cur."!cursor_pass"(rx1478_pos, "term:sym<next>")
    if_null rx1478_debug, debug_1094
    rx1478_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1478_pos)
  debug_1094:
    .return (rx1478_cur)
  rx1478_restart:
.annotate 'line', 520
    if_null rx1478_debug, debug_1095
    rx1478_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1095:
  rx1478_fail:
    (rx1478_rep, rx1478_pos, $I10, $P10) = rx1478_cur."!mark_fail"(0)
    lt rx1478_pos, -1, rx1478_done
    eq rx1478_pos, -1, rx1478_fail
    jump $I10
  rx1478_done:
    rx1478_cur."!cursor_fail"()
    if_null rx1478_debug, debug_1096
    rx1478_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1096:
    .return (rx1478_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("368_1295307698.031") :method
.annotate 'line', 520
    new $P1480, "ResizablePMCArray"
    push $P1480, "next"
    .return ($P1480)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("369_1295307698.031") :method :outer("11_1295307698.031")
.annotate 'line', 520
    .local string rx1484_tgt
    .local int rx1484_pos
    .local int rx1484_off
    .local int rx1484_eos
    .local int rx1484_rep
    .local pmc rx1484_cur
    .local pmc rx1484_debug
    (rx1484_cur, rx1484_pos, rx1484_tgt, $I10) = self."!cursor_start"()
    getattribute rx1484_debug, rx1484_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1484_cur
    .local pmc match
    .lex "$/", match
    length rx1484_eos, rx1484_tgt
    gt rx1484_pos, rx1484_eos, rx1484_done
    set rx1484_off, 0
    lt rx1484_pos, 2, rx1484_start
    sub rx1484_off, rx1484_pos, 1
    substr rx1484_tgt, rx1484_tgt, rx1484_off
  rx1484_start:
    eq $I10, 1, rx1484_restart
    if_null rx1484_debug, debug_1097
    rx1484_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1487_done
    goto rxscan1487_scan
  rxscan1487_loop:
    ($P10) = rx1484_cur."from"()
    inc $P10
    set rx1484_pos, $P10
    ge rx1484_pos, rx1484_eos, rxscan1487_done
  rxscan1487_scan:
    set_addr $I10, rxscan1487_loop
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10)
  rxscan1487_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1488_fail
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1484_pos, 4
    gt $I11, rx1484_eos, rx1484_fail
    sub $I11, rx1484_pos, rx1484_off
    substr $S10, rx1484_tgt, $I11, 4
    ne $S10, "redo", rx1484_fail
    add rx1484_pos, 4
    set_addr $I10, rxcap_1488_fail
    ($I12, $I11) = rx1484_cur."!mark_peek"($I10)
    rx1484_cur."!cursor_pos"($I11)
    ($P10) = rx1484_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1484_pos, "")
    rx1484_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1488_done
  rxcap_1488_fail:
    goto rx1484_fail
  rxcap_1488_done:
  # rx pass
    rx1484_cur."!cursor_pass"(rx1484_pos, "term:sym<redo>")
    if_null rx1484_debug, debug_1098
    rx1484_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1484_pos)
  debug_1098:
    .return (rx1484_cur)
  rx1484_restart:
.annotate 'line', 520
    if_null rx1484_debug, debug_1099
    rx1484_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1099:
  rx1484_fail:
    (rx1484_rep, rx1484_pos, $I10, $P10) = rx1484_cur."!mark_fail"(0)
    lt rx1484_pos, -1, rx1484_done
    eq rx1484_pos, -1, rx1484_fail
    jump $I10
  rx1484_done:
    rx1484_cur."!cursor_fail"()
    if_null rx1484_debug, debug_1100
    rx1484_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1100:
    .return (rx1484_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("370_1295307698.031") :method
.annotate 'line', 520
    new $P1486, "ResizablePMCArray"
    push $P1486, "redo"
    .return ($P1486)
.end


.namespace ["NQP";"Grammar"]
.include "except_types.pasm"
.sub "smartmatch"  :subid("371_1295307698.031") :method :outer("11_1295307698.031")
    .param pmc param_1492
.annotate 'line', 634
    new $P1491, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1491, control_1490
    push_eh $P1491
    .lex "self", self
    .lex "$/", param_1492
.annotate 'line', 636
    new $P1493, "Undef"
    .lex "$t", $P1493
    find_lex $P1494, "$/"
    unless_null $P1494, vivify_1101
    $P1494 = root_new ['parrot';'ResizablePMCArray']
  vivify_1101:
    set $P1495, $P1494[0]
    unless_null $P1495, vivify_1102
    new $P1495, "Undef"
  vivify_1102:
    store_lex "$t", $P1495
    find_lex $P1496, "$/"
    unless_null $P1496, vivify_1103
    $P1496 = root_new ['parrot';'ResizablePMCArray']
  vivify_1103:
    set $P1497, $P1496[1]
    unless_null $P1497, vivify_1104
    new $P1497, "Undef"
  vivify_1104:
    find_lex $P1498, "$/"
    unless_null $P1498, vivify_1105
    $P1498 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1498
  vivify_1105:
    set $P1498[0], $P1497
    find_lex $P1499, "$t"
    find_lex $P1500, "$/"
    unless_null $P1500, vivify_1106
    $P1500 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1500
  vivify_1106:
    set $P1500[1], $P1499
.annotate 'line', 634
    .return ($P1499)
  control_1490:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1501, exception, "payload"
    .return ($P1501)
.end


.namespace ["NQP";"Regex"]
.sub "_block1502"  :subid("372_1295307698.031") :outer("11_1295307698.031")
.annotate 'line', 640
    .const 'Sub' $P1559 = "391_1295307698.031" 
    capture_lex $P1559
    .const 'Sub' $P1554 = "389_1295307698.031" 
    capture_lex $P1554
    .const 'Sub' $P1542 = "386_1295307698.031" 
    capture_lex $P1542
    .const 'Sub' $P1532 = "383_1295307698.031" 
    capture_lex $P1532
    .const 'Sub' $P1527 = "381_1295307698.031" 
    capture_lex $P1527
    .const 'Sub' $P1518 = "378_1295307698.031" 
    capture_lex $P1518
    .const 'Sub' $P1513 = "376_1295307698.031" 
    capture_lex $P1513
    .const 'Sub' $P1504 = "373_1295307698.031" 
    capture_lex $P1504
    .const 'Sub' $P1559 = "391_1295307698.031" 
    capture_lex $P1559
    .return ($P1559)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("373_1295307698.031") :method :outer("372_1295307698.031")
.annotate 'line', 640
    .const 'Sub' $P1510 = "375_1295307698.031" 
    capture_lex $P1510
    .local string rx1505_tgt
    .local int rx1505_pos
    .local int rx1505_off
    .local int rx1505_eos
    .local int rx1505_rep
    .local pmc rx1505_cur
    .local pmc rx1505_debug
    (rx1505_cur, rx1505_pos, rx1505_tgt, $I10) = self."!cursor_start"()
    getattribute rx1505_debug, rx1505_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1505_cur
    .local pmc match
    .lex "$/", match
    length rx1505_eos, rx1505_tgt
    gt rx1505_pos, rx1505_eos, rx1505_done
    set rx1505_off, 0
    lt rx1505_pos, 2, rx1505_start
    sub rx1505_off, rx1505_pos, 1
    substr rx1505_tgt, rx1505_tgt, rx1505_off
  rx1505_start:
    eq $I10, 1, rx1505_restart
    if_null rx1505_debug, debug_1107
    rx1505_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1107:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1508_done
    goto rxscan1508_scan
  rxscan1508_loop:
    ($P10) = rx1505_cur."from"()
    inc $P10
    set rx1505_pos, $P10
    ge rx1505_pos, rx1505_eos, rxscan1508_done
  rxscan1508_scan:
    set_addr $I10, rxscan1508_loop
    rx1505_cur."!mark_push"(0, rx1505_pos, $I10)
  rxscan1508_done:
.annotate 'line', 642
  # rx literal  ":"
    add $I11, rx1505_pos, 1
    gt $I11, rx1505_eos, rx1505_fail
    sub $I11, rx1505_pos, rx1505_off
    ord $I11, rx1505_tgt, $I11
    ne $I11, 58, rx1505_fail
    add rx1505_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1505_cur."!cursor_pos"(rx1505_pos)
    .const 'Sub' $P1510 = "375_1295307698.031" 
    capture_lex $P1510
    $P10 = rx1505_cur."before"($P1510)
    unless $P10, rx1505_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1505_cur."!cursor_pos"(rx1505_pos)
    $P10 = rx1505_cur."LANG"("MAIN", "statement")
    unless $P10, rx1505_fail
    rx1505_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1505_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1505_cur."!cursor_pos"(rx1505_pos)
    $P10 = rx1505_cur."ws"()
    unless $P10, rx1505_fail
    rx1505_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1505_pos, 1
    gt $I11, rx1505_eos, rx1505_fail
    sub $I11, rx1505_pos, rx1505_off
    ord $I11, rx1505_tgt, $I11
    ne $I11, 59, rx1505_fail
    add rx1505_pos, 1
.annotate 'line', 641
  # rx pass
    rx1505_cur."!cursor_pass"(rx1505_pos, "metachar:sym<:my>")
    if_null rx1505_debug, debug_1112
    rx1505_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1505_pos)
  debug_1112:
    .return (rx1505_cur)
  rx1505_restart:
.annotate 'line', 640
    if_null rx1505_debug, debug_1113
    rx1505_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1113:
  rx1505_fail:
    (rx1505_rep, rx1505_pos, $I10, $P10) = rx1505_cur."!mark_fail"(0)
    lt rx1505_pos, -1, rx1505_done
    eq rx1505_pos, -1, rx1505_fail
    jump $I10
  rx1505_done:
    rx1505_cur."!cursor_fail"()
    if_null rx1505_debug, debug_1114
    rx1505_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1114:
    .return (rx1505_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("374_1295307698.031") :method
.annotate 'line', 640
    new $P1507, "ResizablePMCArray"
    push $P1507, ":"
    .return ($P1507)
.end


.namespace ["NQP";"Regex"]
.sub "_block1509"  :anon :subid("375_1295307698.031") :method :outer("373_1295307698.031")
.annotate 'line', 642
    .local string rx1511_tgt
    .local int rx1511_pos
    .local int rx1511_off
    .local int rx1511_eos
    .local int rx1511_rep
    .local pmc rx1511_cur
    .local pmc rx1511_debug
    (rx1511_cur, rx1511_pos, rx1511_tgt, $I10) = self."!cursor_start"()
    getattribute rx1511_debug, rx1511_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1511_cur
    .local pmc match
    .lex "$/", match
    length rx1511_eos, rx1511_tgt
    gt rx1511_pos, rx1511_eos, rx1511_done
    set rx1511_off, 0
    lt rx1511_pos, 2, rx1511_start
    sub rx1511_off, rx1511_pos, 1
    substr rx1511_tgt, rx1511_tgt, rx1511_off
  rx1511_start:
    eq $I10, 1, rx1511_restart
    if_null rx1511_debug, debug_1108
    rx1511_cur."!cursor_debug"("START", "")
  debug_1108:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1512_done
    goto rxscan1512_scan
  rxscan1512_loop:
    ($P10) = rx1511_cur."from"()
    inc $P10
    set rx1511_pos, $P10
    ge rx1511_pos, rx1511_eos, rxscan1512_done
  rxscan1512_scan:
    set_addr $I10, rxscan1512_loop
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxscan1512_done:
  # rx literal  "my"
    add $I11, rx1511_pos, 2
    gt $I11, rx1511_eos, rx1511_fail
    sub $I11, rx1511_pos, rx1511_off
    substr $S10, rx1511_tgt, $I11, 2
    ne $S10, "my", rx1511_fail
    add rx1511_pos, 2
  # rx pass
    rx1511_cur."!cursor_pass"(rx1511_pos, "")
    if_null rx1511_debug, debug_1109
    rx1511_cur."!cursor_debug"("PASS", "", " at pos=", rx1511_pos)
  debug_1109:
    .return (rx1511_cur)
  rx1511_restart:
    if_null rx1511_debug, debug_1110
    rx1511_cur."!cursor_debug"("NEXT", "")
  debug_1110:
  rx1511_fail:
    (rx1511_rep, rx1511_pos, $I10, $P10) = rx1511_cur."!mark_fail"(0)
    lt rx1511_pos, -1, rx1511_done
    eq rx1511_pos, -1, rx1511_fail
    jump $I10
  rx1511_done:
    rx1511_cur."!cursor_fail"()
    if_null rx1511_debug, debug_1111
    rx1511_cur."!cursor_debug"("FAIL", "")
  debug_1111:
    .return (rx1511_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("376_1295307698.031") :method :outer("372_1295307698.031")
.annotate 'line', 640
    .local string rx1514_tgt
    .local int rx1514_pos
    .local int rx1514_off
    .local int rx1514_eos
    .local int rx1514_rep
    .local pmc rx1514_cur
    .local pmc rx1514_debug
    (rx1514_cur, rx1514_pos, rx1514_tgt, $I10) = self."!cursor_start"()
    getattribute rx1514_debug, rx1514_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1514_cur
    .local pmc match
    .lex "$/", match
    length rx1514_eos, rx1514_tgt
    gt rx1514_pos, rx1514_eos, rx1514_done
    set rx1514_off, 0
    lt rx1514_pos, 2, rx1514_start
    sub rx1514_off, rx1514_pos, 1
    substr rx1514_tgt, rx1514_tgt, rx1514_off
  rx1514_start:
    eq $I10, 1, rx1514_restart
    if_null rx1514_debug, debug_1115
    rx1514_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1115:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1517_done
    goto rxscan1517_scan
  rxscan1517_loop:
    ($P10) = rx1514_cur."from"()
    inc $P10
    set rx1514_pos, $P10
    ge rx1514_pos, rx1514_eos, rxscan1517_done
  rxscan1517_scan:
    set_addr $I10, rxscan1517_loop
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  rxscan1517_done:
.annotate 'line', 646
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1514_pos, rx1514_off
    substr $S10, rx1514_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1514_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1514_cur."!cursor_pos"(rx1514_pos)
    $P10 = rx1514_cur."codeblock"()
    unless $P10, rx1514_fail
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1514_pos = $P10."pos"()
.annotate 'line', 645
  # rx pass
    rx1514_cur."!cursor_pass"(rx1514_pos, "metachar:sym<{ }>")
    if_null rx1514_debug, debug_1116
    rx1514_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1514_pos)
  debug_1116:
    .return (rx1514_cur)
  rx1514_restart:
.annotate 'line', 640
    if_null rx1514_debug, debug_1117
    rx1514_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1117:
  rx1514_fail:
    (rx1514_rep, rx1514_pos, $I10, $P10) = rx1514_cur."!mark_fail"(0)
    lt rx1514_pos, -1, rx1514_done
    eq rx1514_pos, -1, rx1514_fail
    jump $I10
  rx1514_done:
    rx1514_cur."!cursor_fail"()
    if_null rx1514_debug, debug_1118
    rx1514_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1118:
    .return (rx1514_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("377_1295307698.031") :method
.annotate 'line', 640
    new $P1516, "ResizablePMCArray"
    push $P1516, "{"
    .return ($P1516)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("378_1295307698.031") :method :outer("372_1295307698.031")
.annotate 'line', 640
    .const 'Sub' $P1524 = "380_1295307698.031" 
    capture_lex $P1524
    .local string rx1519_tgt
    .local int rx1519_pos
    .local int rx1519_off
    .local int rx1519_eos
    .local int rx1519_rep
    .local pmc rx1519_cur
    .local pmc rx1519_debug
    (rx1519_cur, rx1519_pos, rx1519_tgt, $I10) = self."!cursor_start"()
    getattribute rx1519_debug, rx1519_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1519_cur
    .local pmc match
    .lex "$/", match
    length rx1519_eos, rx1519_tgt
    gt rx1519_pos, rx1519_eos, rx1519_done
    set rx1519_off, 0
    lt rx1519_pos, 2, rx1519_start
    sub rx1519_off, rx1519_pos, 1
    substr rx1519_tgt, rx1519_tgt, rx1519_off
  rx1519_start:
    eq $I10, 1, rx1519_restart
    if_null rx1519_debug, debug_1119
    rx1519_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1119:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1522_done
    goto rxscan1522_scan
  rxscan1522_loop:
    ($P10) = rx1519_cur."from"()
    inc $P10
    set rx1519_pos, $P10
    ge rx1519_pos, rx1519_eos, rxscan1522_done
  rxscan1522_scan:
    set_addr $I10, rxscan1522_loop
    rx1519_cur."!mark_push"(0, rx1519_pos, $I10)
  rxscan1522_done:
.annotate 'line', 650
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1519_pos, rx1519_off
    substr $S10, rx1519_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1519_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    .const 'Sub' $P1524 = "380_1295307698.031" 
    capture_lex $P1524
    $P10 = rx1519_cur."before"($P1524)
    unless $P10, rx1519_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1519_cur."!cursor_pos"(rx1519_pos)
    $P10 = rx1519_cur."LANG"("MAIN", "variable")
    unless $P10, rx1519_fail
    rx1519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1519_pos = $P10."pos"()
.annotate 'line', 649
  # rx pass
    rx1519_cur."!cursor_pass"(rx1519_pos, "metachar:sym<nqpvar>")
    if_null rx1519_debug, debug_1124
    rx1519_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1519_pos)
  debug_1124:
    .return (rx1519_cur)
  rx1519_restart:
.annotate 'line', 640
    if_null rx1519_debug, debug_1125
    rx1519_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1125:
  rx1519_fail:
    (rx1519_rep, rx1519_pos, $I10, $P10) = rx1519_cur."!mark_fail"(0)
    lt rx1519_pos, -1, rx1519_done
    eq rx1519_pos, -1, rx1519_fail
    jump $I10
  rx1519_done:
    rx1519_cur."!cursor_fail"()
    if_null rx1519_debug, debug_1126
    rx1519_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1126:
    .return (rx1519_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("379_1295307698.031") :method
.annotate 'line', 640
    new $P1521, "ResizablePMCArray"
    push $P1521, "$"
    push $P1521, "@"
    .return ($P1521)
.end


.namespace ["NQP";"Regex"]
.sub "_block1523"  :anon :subid("380_1295307698.031") :method :outer("378_1295307698.031")
.annotate 'line', 650
    .local string rx1525_tgt
    .local int rx1525_pos
    .local int rx1525_off
    .local int rx1525_eos
    .local int rx1525_rep
    .local pmc rx1525_cur
    .local pmc rx1525_debug
    (rx1525_cur, rx1525_pos, rx1525_tgt, $I10) = self."!cursor_start"()
    getattribute rx1525_debug, rx1525_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1525_cur
    .local pmc match
    .lex "$/", match
    length rx1525_eos, rx1525_tgt
    gt rx1525_pos, rx1525_eos, rx1525_done
    set rx1525_off, 0
    lt rx1525_pos, 2, rx1525_start
    sub rx1525_off, rx1525_pos, 1
    substr rx1525_tgt, rx1525_tgt, rx1525_off
  rx1525_start:
    eq $I10, 1, rx1525_restart
    if_null rx1525_debug, debug_1120
    rx1525_cur."!cursor_debug"("START", "")
  debug_1120:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1526_done
    goto rxscan1526_scan
  rxscan1526_loop:
    ($P10) = rx1525_cur."from"()
    inc $P10
    set rx1525_pos, $P10
    ge rx1525_pos, rx1525_eos, rxscan1526_done
  rxscan1526_scan:
    set_addr $I10, rxscan1526_loop
    rx1525_cur."!mark_push"(0, rx1525_pos, $I10)
  rxscan1526_done:
  # rx charclass .
    ge rx1525_pos, rx1525_eos, rx1525_fail
    inc rx1525_pos
  # rx charclass w
    ge rx1525_pos, rx1525_eos, rx1525_fail
    sub $I10, rx1525_pos, rx1525_off
    is_cclass $I11, 8192, rx1525_tgt, $I10
    unless $I11, rx1525_fail
    inc rx1525_pos
  # rx pass
    rx1525_cur."!cursor_pass"(rx1525_pos, "")
    if_null rx1525_debug, debug_1121
    rx1525_cur."!cursor_debug"("PASS", "", " at pos=", rx1525_pos)
  debug_1121:
    .return (rx1525_cur)
  rx1525_restart:
    if_null rx1525_debug, debug_1122
    rx1525_cur."!cursor_debug"("NEXT", "")
  debug_1122:
  rx1525_fail:
    (rx1525_rep, rx1525_pos, $I10, $P10) = rx1525_cur."!mark_fail"(0)
    lt rx1525_pos, -1, rx1525_done
    eq rx1525_pos, -1, rx1525_fail
    jump $I10
  rx1525_done:
    rx1525_cur."!cursor_fail"()
    if_null rx1525_debug, debug_1123
    rx1525_cur."!cursor_debug"("FAIL", "")
  debug_1123:
    .return (rx1525_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("381_1295307698.031") :method :outer("372_1295307698.031")
.annotate 'line', 640
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    getattribute rx1528_debug, rx1528_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1127
    rx1528_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1127:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1531_done
    goto rxscan1531_scan
  rxscan1531_loop:
    ($P10) = rx1528_cur."from"()
    inc $P10
    set rx1528_pos, $P10
    ge rx1528_pos, rx1528_eos, rxscan1531_done
  rxscan1531_scan:
    set_addr $I10, rxscan1531_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1531_done:
.annotate 'line', 654
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1528_pos, rx1528_off
    substr $S10, rx1528_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1528_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."codeblock"()
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1528_pos = $P10."pos"()
.annotate 'line', 653
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "assertion:sym<{ }>")
    if_null rx1528_debug, debug_1128
    rx1528_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1528_pos)
  debug_1128:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 640
    if_null rx1528_debug, debug_1129
    rx1528_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1129:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1130
    rx1528_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1130:
    .return (rx1528_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("382_1295307698.031") :method
.annotate 'line', 640
    new $P1530, "ResizablePMCArray"
    push $P1530, "{"
    .return ($P1530)
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("383_1295307698.031") :method :outer("372_1295307698.031")
.annotate 'line', 640
    .const 'Sub' $P1538 = "385_1295307698.031" 
    capture_lex $P1538
    .local string rx1533_tgt
    .local int rx1533_pos
    .local int rx1533_off
    .local int rx1533_eos
    .local int rx1533_rep
    .local pmc rx1533_cur
    .local pmc rx1533_debug
    (rx1533_cur, rx1533_pos, rx1533_tgt, $I10) = self."!cursor_start"()
    getattribute rx1533_debug, rx1533_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1533_cur
    .local pmc match
    .lex "$/", match
    length rx1533_eos, rx1533_tgt
    gt rx1533_pos, rx1533_eos, rx1533_done
    set rx1533_off, 0
    lt rx1533_pos, 2, rx1533_start
    sub rx1533_off, rx1533_pos, 1
    substr rx1533_tgt, rx1533_tgt, rx1533_off
  rx1533_start:
    eq $I10, 1, rx1533_restart
    if_null rx1533_debug, debug_1131
    rx1533_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1131:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1536_done
    goto rxscan1536_scan
  rxscan1536_loop:
    ($P10) = rx1533_cur."from"()
    inc $P10
    set rx1533_pos, $P10
    ge rx1533_pos, rx1533_eos, rxscan1536_done
  rxscan1536_scan:
    set_addr $I10, rxscan1536_loop
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  rxscan1536_done:
.annotate 'line', 658
  # rx subcapture "zw"
    set_addr $I10, rxcap_1541_fail
    rx1533_cur."!mark_push"(0, rx1533_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1533_pos, rx1533_eos, rx1533_fail
    sub $I10, rx1533_pos, rx1533_off
    substr $S10, rx1533_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1533_fail
    inc rx1533_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    .const 'Sub' $P1538 = "385_1295307698.031" 
    capture_lex $P1538
    $P10 = rx1533_cur."before"($P1538)
    unless $P10, rx1533_fail
    set_addr $I10, rxcap_1541_fail
    ($I12, $I11) = rx1533_cur."!mark_peek"($I10)
    rx1533_cur."!cursor_pos"($I11)
    ($P10) = rx1533_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1533_pos, "")
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1541_done
  rxcap_1541_fail:
    goto rx1533_fail
  rxcap_1541_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1533_cur."!cursor_pos"(rx1533_pos)
    $P10 = rx1533_cur."codeblock"()
    unless $P10, rx1533_fail
    rx1533_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1533_pos = $P10."pos"()
.annotate 'line', 657
  # rx pass
    rx1533_cur."!cursor_pass"(rx1533_pos, "assertion:sym<?{ }>")
    if_null rx1533_debug, debug_1136
    rx1533_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1533_pos)
  debug_1136:
    .return (rx1533_cur)
  rx1533_restart:
.annotate 'line', 640
    if_null rx1533_debug, debug_1137
    rx1533_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1137:
  rx1533_fail:
    (rx1533_rep, rx1533_pos, $I10, $P10) = rx1533_cur."!mark_fail"(0)
    lt rx1533_pos, -1, rx1533_done
    eq rx1533_pos, -1, rx1533_fail
    jump $I10
  rx1533_done:
    rx1533_cur."!cursor_fail"()
    if_null rx1533_debug, debug_1138
    rx1533_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1138:
    .return (rx1533_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("384_1295307698.031") :method
.annotate 'line', 640
    new $P1535, "ResizablePMCArray"
    push $P1535, "!"
    push $P1535, "?"
    .return ($P1535)
.end


.namespace ["NQP";"Regex"]
.sub "_block1537"  :anon :subid("385_1295307698.031") :method :outer("383_1295307698.031")
.annotate 'line', 658
    .local string rx1539_tgt
    .local int rx1539_pos
    .local int rx1539_off
    .local int rx1539_eos
    .local int rx1539_rep
    .local pmc rx1539_cur
    .local pmc rx1539_debug
    (rx1539_cur, rx1539_pos, rx1539_tgt, $I10) = self."!cursor_start"()
    getattribute rx1539_debug, rx1539_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1539_cur
    .local pmc match
    .lex "$/", match
    length rx1539_eos, rx1539_tgt
    gt rx1539_pos, rx1539_eos, rx1539_done
    set rx1539_off, 0
    lt rx1539_pos, 2, rx1539_start
    sub rx1539_off, rx1539_pos, 1
    substr rx1539_tgt, rx1539_tgt, rx1539_off
  rx1539_start:
    eq $I10, 1, rx1539_restart
    if_null rx1539_debug, debug_1132
    rx1539_cur."!cursor_debug"("START", "")
  debug_1132:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1540_done
    goto rxscan1540_scan
  rxscan1540_loop:
    ($P10) = rx1539_cur."from"()
    inc $P10
    set rx1539_pos, $P10
    ge rx1539_pos, rx1539_eos, rxscan1540_done
  rxscan1540_scan:
    set_addr $I10, rxscan1540_loop
    rx1539_cur."!mark_push"(0, rx1539_pos, $I10)
  rxscan1540_done:
  # rx literal  "{"
    add $I11, rx1539_pos, 1
    gt $I11, rx1539_eos, rx1539_fail
    sub $I11, rx1539_pos, rx1539_off
    ord $I11, rx1539_tgt, $I11
    ne $I11, 123, rx1539_fail
    add rx1539_pos, 1
  # rx pass
    rx1539_cur."!cursor_pass"(rx1539_pos, "")
    if_null rx1539_debug, debug_1133
    rx1539_cur."!cursor_debug"("PASS", "", " at pos=", rx1539_pos)
  debug_1133:
    .return (rx1539_cur)
  rx1539_restart:
    if_null rx1539_debug, debug_1134
    rx1539_cur."!cursor_debug"("NEXT", "")
  debug_1134:
  rx1539_fail:
    (rx1539_rep, rx1539_pos, $I10, $P10) = rx1539_cur."!mark_fail"(0)
    lt rx1539_pos, -1, rx1539_done
    eq rx1539_pos, -1, rx1539_fail
    jump $I10
  rx1539_done:
    rx1539_cur."!cursor_fail"()
    if_null rx1539_debug, debug_1135
    rx1539_cur."!cursor_debug"("FAIL", "")
  debug_1135:
    .return (rx1539_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("386_1295307698.031") :method :outer("372_1295307698.031")
.annotate 'line', 640
    .const 'Sub' $P1551 = "388_1295307698.031" 
    capture_lex $P1551
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    rx1543_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    getattribute rx1543_debug, rx1543_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1139
    rx1543_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1139:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1547_done
    goto rxscan1547_scan
  rxscan1547_loop:
    ($P10) = rx1543_cur."from"()
    inc $P10
    set rx1543_pos, $P10
    ge rx1543_pos, rx1543_eos, rxscan1547_done
  rxscan1547_scan:
    set_addr $I10, rxscan1547_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1547_done:
.annotate 'line', 662
  # rx subrule "identifier" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."identifier"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1543_pos = $P10."pos"()
.annotate 'line', 669
  # rx rxquantr1548 ** 0..1
    set_addr $I10, rxquantr1548_done
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxquantr1548_loop:
  alt1549_0:
.annotate 'line', 663
    set_addr $I10, alt1549_1
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
.annotate 'line', 664
  # rx subrule "before" subtype=zerowidth negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    .const 'Sub' $P1551 = "388_1295307698.031" 
    capture_lex $P1551
    $P10 = rx1543_cur."before"($P1551)
    unless $P10, rx1543_fail
    goto alt1549_end
  alt1549_1:
    set_addr $I10, alt1549_2
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
.annotate 'line', 665
  # rx literal  "="
    add $I11, rx1543_pos, 1
    gt $I11, rx1543_eos, rx1543_fail
    sub $I11, rx1543_pos, rx1543_off
    ord $I11, rx1543_tgt, $I11
    ne $I11, 61, rx1543_fail
    add rx1543_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."assertion"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1543_pos = $P10."pos"()
    goto alt1549_end
  alt1549_2:
    set_addr $I10, alt1549_3
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
.annotate 'line', 666
  # rx literal  ":"
    add $I11, rx1543_pos, 1
    gt $I11, rx1543_eos, rx1543_fail
    sub $I11, rx1543_pos, rx1543_off
    ord $I11, rx1543_tgt, $I11
    ne $I11, 58, rx1543_fail
    add rx1543_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."arglist"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1543_pos = $P10."pos"()
    goto alt1549_end
  alt1549_3:
    set_addr $I10, alt1549_4
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
.annotate 'line', 667
  # rx literal  "("
    add $I11, rx1543_pos, 1
    gt $I11, rx1543_eos, rx1543_fail
    sub $I11, rx1543_pos, rx1543_off
    ord $I11, rx1543_tgt, $I11
    ne $I11, 40, rx1543_fail
    add rx1543_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1543_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1543_pos, 1
    gt $I11, rx1543_eos, rx1543_fail
    sub $I11, rx1543_pos, rx1543_off
    ord $I11, rx1543_tgt, $I11
    ne $I11, 41, rx1543_fail
    add rx1543_pos, 1
    goto alt1549_end
  alt1549_4:
.annotate 'line', 668
  # rx subrule "normspace" subtype=method negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."normspace"()
    unless $P10, rx1543_fail
    rx1543_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."nibbler"()
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1543_pos = $P10."pos"()
  alt1549_end:
.annotate 'line', 669
    set_addr $I10, rxquantr1548_done
    (rx1543_rep) = rx1543_cur."!mark_commit"($I10)
  rxquantr1548_done:
.annotate 'line', 661
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "assertion:sym<name>")
    if_null rx1543_debug, debug_1144
    rx1543_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1543_pos)
  debug_1144:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 640
    if_null rx1543_debug, debug_1145
    rx1543_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1145:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1146
    rx1543_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1146:
    .return (rx1543_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("387_1295307698.031") :method
.annotate 'line', 640
    $P1545 = self."!PREFIX__!subrule"("identifier", "")
    new $P1546, "ResizablePMCArray"
    push $P1546, $P1545
    .return ($P1546)
.end


.namespace ["NQP";"Regex"]
.sub "_block1550"  :anon :subid("388_1295307698.031") :method :outer("386_1295307698.031")
.annotate 'line', 664
    .local string rx1552_tgt
    .local int rx1552_pos
    .local int rx1552_off
    .local int rx1552_eos
    .local int rx1552_rep
    .local pmc rx1552_cur
    .local pmc rx1552_debug
    (rx1552_cur, rx1552_pos, rx1552_tgt, $I10) = self."!cursor_start"()
    getattribute rx1552_debug, rx1552_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1552_cur
    .local pmc match
    .lex "$/", match
    length rx1552_eos, rx1552_tgt
    gt rx1552_pos, rx1552_eos, rx1552_done
    set rx1552_off, 0
    lt rx1552_pos, 2, rx1552_start
    sub rx1552_off, rx1552_pos, 1
    substr rx1552_tgt, rx1552_tgt, rx1552_off
  rx1552_start:
    eq $I10, 1, rx1552_restart
    if_null rx1552_debug, debug_1140
    rx1552_cur."!cursor_debug"("START", "")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1553_done
    goto rxscan1553_scan
  rxscan1553_loop:
    ($P10) = rx1552_cur."from"()
    inc $P10
    set rx1552_pos, $P10
    ge rx1552_pos, rx1552_eos, rxscan1553_done
  rxscan1553_scan:
    set_addr $I10, rxscan1553_loop
    rx1552_cur."!mark_push"(0, rx1552_pos, $I10)
  rxscan1553_done:
  # rx literal  ">"
    add $I11, rx1552_pos, 1
    gt $I11, rx1552_eos, rx1552_fail
    sub $I11, rx1552_pos, rx1552_off
    ord $I11, rx1552_tgt, $I11
    ne $I11, 62, rx1552_fail
    add rx1552_pos, 1
  # rx pass
    rx1552_cur."!cursor_pass"(rx1552_pos, "")
    if_null rx1552_debug, debug_1141
    rx1552_cur."!cursor_debug"("PASS", "", " at pos=", rx1552_pos)
  debug_1141:
    .return (rx1552_cur)
  rx1552_restart:
    if_null rx1552_debug, debug_1142
    rx1552_cur."!cursor_debug"("NEXT", "")
  debug_1142:
  rx1552_fail:
    (rx1552_rep, rx1552_pos, $I10, $P10) = rx1552_cur."!mark_fail"(0)
    lt rx1552_pos, -1, rx1552_done
    eq rx1552_pos, -1, rx1552_fail
    jump $I10
  rx1552_done:
    rx1552_cur."!cursor_fail"()
    if_null rx1552_debug, debug_1143
    rx1552_cur."!cursor_debug"("FAIL", "")
  debug_1143:
    .return (rx1552_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("389_1295307698.031") :method :outer("372_1295307698.031")
.annotate 'line', 640
    .local string rx1555_tgt
    .local int rx1555_pos
    .local int rx1555_off
    .local int rx1555_eos
    .local int rx1555_rep
    .local pmc rx1555_cur
    .local pmc rx1555_debug
    (rx1555_cur, rx1555_pos, rx1555_tgt, $I10) = self."!cursor_start"()
    getattribute rx1555_debug, rx1555_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1555_cur
    .local pmc match
    .lex "$/", match
    length rx1555_eos, rx1555_tgt
    gt rx1555_pos, rx1555_eos, rx1555_done
    set rx1555_off, 0
    lt rx1555_pos, 2, rx1555_start
    sub rx1555_off, rx1555_pos, 1
    substr rx1555_tgt, rx1555_tgt, rx1555_off
  rx1555_start:
    eq $I10, 1, rx1555_restart
    if_null rx1555_debug, debug_1147
    rx1555_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1147:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1558_done
    goto rxscan1558_scan
  rxscan1558_loop:
    ($P10) = rx1555_cur."from"()
    inc $P10
    set rx1555_pos, $P10
    ge rx1555_pos, rx1555_eos, rxscan1558_done
  rxscan1558_scan:
    set_addr $I10, rxscan1558_loop
    rx1555_cur."!mark_push"(0, rx1555_pos, $I10)
  rxscan1558_done:
.annotate 'line', 673
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1555_pos, rx1555_off
    substr $S10, rx1555_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1555_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1555_cur."!cursor_pos"(rx1555_pos)
    $P10 = rx1555_cur."LANG"("MAIN", "variable")
    unless $P10, rx1555_fail
    rx1555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1555_pos = $P10."pos"()
.annotate 'line', 672
  # rx pass
    rx1555_cur."!cursor_pass"(rx1555_pos, "assertion:sym<var>")
    if_null rx1555_debug, debug_1148
    rx1555_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1555_pos)
  debug_1148:
    .return (rx1555_cur)
  rx1555_restart:
.annotate 'line', 640
    if_null rx1555_debug, debug_1149
    rx1555_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1149:
  rx1555_fail:
    (rx1555_rep, rx1555_pos, $I10, $P10) = rx1555_cur."!mark_fail"(0)
    lt rx1555_pos, -1, rx1555_done
    eq rx1555_pos, -1, rx1555_fail
    jump $I10
  rx1555_done:
    rx1555_cur."!cursor_fail"()
    if_null rx1555_debug, debug_1150
    rx1555_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1150:
    .return (rx1555_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("390_1295307698.031") :method
.annotate 'line', 640
    new $P1557, "ResizablePMCArray"
    push $P1557, "$"
    push $P1557, "@"
    .return ($P1557)
.end


.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("391_1295307698.031") :method :outer("372_1295307698.031")
.annotate 'line', 640
    .local string rx1560_tgt
    .local int rx1560_pos
    .local int rx1560_off
    .local int rx1560_eos
    .local int rx1560_rep
    .local pmc rx1560_cur
    .local pmc rx1560_debug
    (rx1560_cur, rx1560_pos, rx1560_tgt, $I10) = self."!cursor_start"()
    getattribute rx1560_debug, rx1560_cur, "$!debug"
    .lex unicode:"$\x{a2}", rx1560_cur
    .local pmc match
    .lex "$/", match
    length rx1560_eos, rx1560_tgt
    gt rx1560_pos, rx1560_eos, rx1560_done
    set rx1560_off, 0
    lt rx1560_pos, 2, rx1560_start
    sub rx1560_off, rx1560_pos, 1
    substr rx1560_tgt, rx1560_tgt, rx1560_off
  rx1560_start:
    eq $I10, 1, rx1560_restart
    if_null rx1560_debug, debug_1151
    rx1560_cur."!cursor_debug"("START", "codeblock")
  debug_1151:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1564_done
    goto rxscan1564_scan
  rxscan1564_loop:
    ($P10) = rx1560_cur."from"()
    inc $P10
    set rx1560_pos, $P10
    ge rx1560_pos, rx1560_eos, rxscan1564_done
  rxscan1564_scan:
    set_addr $I10, rxscan1564_loop
    rx1560_cur."!mark_push"(0, rx1560_pos, $I10)
  rxscan1564_done:
.annotate 'line', 677
  # rx subrule "LANG" subtype=capture negate=
    rx1560_cur."!cursor_pos"(rx1560_pos)
    $P10 = rx1560_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1560_fail
    rx1560_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1560_pos = $P10."pos"()
.annotate 'line', 676
  # rx pass
    rx1560_cur."!cursor_pass"(rx1560_pos, "codeblock")
    if_null rx1560_debug, debug_1152
    rx1560_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1560_pos)
  debug_1152:
    .return (rx1560_cur)
  rx1560_restart:
.annotate 'line', 640
    if_null rx1560_debug, debug_1153
    rx1560_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1153:
  rx1560_fail:
    (rx1560_rep, rx1560_pos, $I10, $P10) = rx1560_cur."!mark_fail"(0)
    lt rx1560_pos, -1, rx1560_done
    eq rx1560_pos, -1, rx1560_fail
    jump $I10
  rx1560_done:
    rx1560_cur."!cursor_fail"()
    if_null rx1560_debug, debug_1154
    rx1560_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1154:
    .return (rx1560_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("392_1295307698.031") :method
.annotate 'line', 640
    $P1562 = self."!PREFIX__!subrule"("LANG", "")
    new $P1563, "ResizablePMCArray"
    push $P1563, $P1562
    .return ($P1563)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1566" :load :anon :subid("393_1295307698.031")
.annotate 'line', 4
    .const 'Sub' $P1568 = "11_1295307698.031" 
    $P1569 = $P1568()
    .return ($P1569)
.end


.namespace []
.sub "_block1587" :load :anon :subid("394_1295307698.031")
.annotate 'line', 1
    .const 'Sub' $P1589 = "10_1295307698.031" 
    $P1590 = $P1589()
    .return ($P1590)
.end

### .include 'gen/nqp-actions.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1295307719.828")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Actions"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
    $P3535 = $P15()
.annotate 'line', 1
    .return ($P3535)
    .const 'Sub' $P3537 = "169_1295307719.828" 
    .return ($P3537)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block14"  :subid("11_1295307719.828") :outer("10_1295307719.828")
.annotate 'line', 3
    .const 'Sub' $P3316 = "168_1295307719.828" 
    capture_lex $P3316
    .const 'Sub' $P3312 = "167_1295307719.828" 
    capture_lex $P3312
    get_hll_global $P3165, ["NQP";"RegexActions"], "_block3164" 
    capture_lex $P3165
    .const 'Sub' $P3153 = "156_1295307719.828" 
    capture_lex $P3153
    .const 'Sub' $P3145 = "155_1295307719.828" 
    capture_lex $P3145
    .const 'Sub' $P3137 = "154_1295307719.828" 
    capture_lex $P3137
    .const 'Sub' $P3129 = "153_1295307719.828" 
    capture_lex $P3129
    .const 'Sub' $P3115 = "152_1295307719.828" 
    capture_lex $P3115
    .const 'Sub' $P3104 = "151_1295307719.828" 
    capture_lex $P3104
    .const 'Sub' $P3093 = "150_1295307719.828" 
    capture_lex $P3093
    .const 'Sub' $P3082 = "149_1295307719.828" 
    capture_lex $P3082
    .const 'Sub' $P3074 = "148_1295307719.828" 
    capture_lex $P3074
    .const 'Sub' $P3059 = "147_1295307719.828" 
    capture_lex $P3059
    .const 'Sub' $P3048 = "146_1295307719.828" 
    capture_lex $P3048
    .const 'Sub' $P3010 = "145_1295307719.828" 
    capture_lex $P3010
    .const 'Sub' $P2995 = "144_1295307719.828" 
    capture_lex $P2995
    .const 'Sub' $P2984 = "143_1295307719.828" 
    capture_lex $P2984
    .const 'Sub' $P2973 = "142_1295307719.828" 
    capture_lex $P2973
    .const 'Sub' $P2962 = "141_1295307719.828" 
    capture_lex $P2962
    .const 'Sub' $P2951 = "140_1295307719.828" 
    capture_lex $P2951
    .const 'Sub' $P2940 = "139_1295307719.828" 
    capture_lex $P2940
    .const 'Sub' $P2911 = "138_1295307719.828" 
    capture_lex $P2911
    .const 'Sub' $P2893 = "137_1295307719.828" 
    capture_lex $P2893
    .const 'Sub' $P2882 = "136_1295307719.828" 
    capture_lex $P2882
    .const 'Sub' $P2868 = "135_1295307719.828" 
    capture_lex $P2868
    .const 'Sub' $P2854 = "134_1295307719.828" 
    capture_lex $P2854
    .const 'Sub' $P2840 = "133_1295307719.828" 
    capture_lex $P2840
    .const 'Sub' $P2829 = "132_1295307719.828" 
    capture_lex $P2829
    .const 'Sub' $P2799 = "131_1295307719.828" 
    capture_lex $P2799
    .const 'Sub' $P2774 = "130_1295307719.828" 
    capture_lex $P2774
    .const 'Sub' $P2763 = "129_1295307719.828" 
    capture_lex $P2763
    .const 'Sub' $P2752 = "128_1295307719.828" 
    capture_lex $P2752
    .const 'Sub' $P2724 = "127_1295307719.828" 
    capture_lex $P2724
    .const 'Sub' $P2705 = "126_1295307719.828" 
    capture_lex $P2705
    .const 'Sub' $P2694 = "125_1295307719.828" 
    capture_lex $P2694
    .const 'Sub' $P2683 = "124_1295307719.828" 
    capture_lex $P2683
    .const 'Sub' $P2578 = "121_1295307719.828" 
    capture_lex $P2578
    .const 'Sub' $P2567 = "120_1295307719.828" 
    capture_lex $P2567
    .const 'Sub' $P2557 = "119_1295307719.828" 
    capture_lex $P2557
    .const 'Sub' $P2527 = "118_1295307719.828" 
    capture_lex $P2527
    .const 'Sub' $P2484 = "117_1295307719.828" 
    capture_lex $P2484
    .const 'Sub' $P2467 = "116_1295307719.828" 
    capture_lex $P2467
    .const 'Sub' $P2457 = "115_1295307719.828" 
    capture_lex $P2457
    .const 'Sub' $P2410 = "114_1295307719.828" 
    capture_lex $P2410
    .const 'Sub' $P2310 = "111_1295307719.828" 
    capture_lex $P2310
    .const 'Sub' $P2267 = "109_1295307719.828" 
    capture_lex $P2267
    .const 'Sub' $P2256 = "108_1295307719.828" 
    capture_lex $P2256
    .const 'Sub' $P2238 = "107_1295307719.828" 
    capture_lex $P2238
    .const 'Sub' $P2220 = "106_1295307719.828" 
    capture_lex $P2220
    .const 'Sub' $P2199 = "105_1295307719.828" 
    capture_lex $P2199
    .const 'Sub' $P2097 = "104_1295307719.828" 
    capture_lex $P2097
    .const 'Sub' $P2050 = "101_1295307719.828" 
    capture_lex $P2050
    .const 'Sub' $P1926 = "98_1295307719.828" 
    capture_lex $P1926
    .const 'Sub' $P1683 = "91_1295307719.828" 
    capture_lex $P1683
    .const 'Sub' $P1672 = "90_1295307719.828" 
    capture_lex $P1672
    .const 'Sub' $P1661 = "89_1295307719.828" 
    capture_lex $P1661
    .const 'Sub' $P1560 = "86_1295307719.828" 
    capture_lex $P1560
    .const 'Sub' $P1549 = "85_1295307719.828" 
    capture_lex $P1549
    .const 'Sub' $P1531 = "84_1295307719.828" 
    capture_lex $P1531
    .const 'Sub' $P1513 = "83_1295307719.828" 
    capture_lex $P1513
    .const 'Sub' $P1495 = "82_1295307719.828" 
    capture_lex $P1495
    .const 'Sub' $P1477 = "81_1295307719.828" 
    capture_lex $P1477
    .const 'Sub' $P1466 = "80_1295307719.828" 
    capture_lex $P1466
    .const 'Sub' $P1455 = "79_1295307719.828" 
    capture_lex $P1455
    .const 'Sub' $P1444 = "78_1295307719.828" 
    capture_lex $P1444
    .const 'Sub' $P1419 = "77_1295307719.828" 
    capture_lex $P1419
    .const 'Sub' $P1407 = "76_1295307719.828" 
    capture_lex $P1407
    .const 'Sub' $P1397 = "75_1295307719.828" 
    capture_lex $P1397
    .const 'Sub' $P1387 = "74_1295307719.828" 
    capture_lex $P1387
    .const 'Sub' $P1377 = "73_1295307719.828" 
    capture_lex $P1377
    .const 'Sub' $P1366 = "72_1295307719.828" 
    capture_lex $P1366
    .const 'Sub' $P1270 = "70_1295307719.828" 
    capture_lex $P1270
    .const 'Sub' $P1243 = "69_1295307719.828" 
    capture_lex $P1243
    .const 'Sub' $P1226 = "68_1295307719.828" 
    capture_lex $P1226
    .const 'Sub' $P1215 = "67_1295307719.828" 
    capture_lex $P1215
    .const 'Sub' $P1204 = "66_1295307719.828" 
    capture_lex $P1204
    .const 'Sub' $P1193 = "65_1295307719.828" 
    capture_lex $P1193
    .const 'Sub' $P1182 = "64_1295307719.828" 
    capture_lex $P1182
    .const 'Sub' $P1171 = "63_1295307719.828" 
    capture_lex $P1171
    .const 'Sub' $P1160 = "62_1295307719.828" 
    capture_lex $P1160
    .const 'Sub' $P1149 = "61_1295307719.828" 
    capture_lex $P1149
    .const 'Sub' $P1138 = "60_1295307719.828" 
    capture_lex $P1138
    .const 'Sub' $P1127 = "59_1295307719.828" 
    capture_lex $P1127
    .const 'Sub' $P1116 = "58_1295307719.828" 
    capture_lex $P1116
    .const 'Sub' $P1105 = "57_1295307719.828" 
    capture_lex $P1105
    .const 'Sub' $P1094 = "56_1295307719.828" 
    capture_lex $P1094
    .const 'Sub' $P1083 = "55_1295307719.828" 
    capture_lex $P1083
    .const 'Sub' $P1064 = "54_1295307719.828" 
    capture_lex $P1064
    .const 'Sub' $P1028 = "53_1295307719.828" 
    capture_lex $P1028
    .const 'Sub' $P1011 = "52_1295307719.828" 
    capture_lex $P1011
    .const 'Sub' $P989 = "51_1295307719.828" 
    capture_lex $P989
    .const 'Sub' $P968 = "50_1295307719.828" 
    capture_lex $P968
    .const 'Sub' $P954 = "49_1295307719.828" 
    capture_lex $P954
    .const 'Sub' $P927 = "48_1295307719.828" 
    capture_lex $P927
    .const 'Sub' $P890 = "47_1295307719.828" 
    capture_lex $P890
    .const 'Sub' $P872 = "46_1295307719.828" 
    capture_lex $P872
    .const 'Sub' $P857 = "45_1295307719.828" 
    capture_lex $P857
    .const 'Sub' $P803 = "43_1295307719.828" 
    capture_lex $P803
    .const 'Sub' $P791 = "42_1295307719.828" 
    capture_lex $P791
    .const 'Sub' $P777 = "41_1295307719.828" 
    capture_lex $P777
    .const 'Sub' $P756 = "40_1295307719.828" 
    capture_lex $P756
    .const 'Sub' $P745 = "39_1295307719.828" 
    capture_lex $P745
    .const 'Sub' $P734 = "38_1295307719.828" 
    capture_lex $P734
    .const 'Sub' $P717 = "37_1295307719.828" 
    capture_lex $P717
    .const 'Sub' $P633 = "35_1295307719.828" 
    capture_lex $P633
    .const 'Sub' $P589 = "33_1295307719.828" 
    capture_lex $P589
    .const 'Sub' $P552 = "32_1295307719.828" 
    capture_lex $P552
    .const 'Sub' $P518 = "31_1295307719.828" 
    capture_lex $P518
    .const 'Sub' $P507 = "30_1295307719.828" 
    capture_lex $P507
    .const 'Sub' $P488 = "29_1295307719.828" 
    capture_lex $P488
    .const 'Sub' $P420 = "27_1295307719.828" 
    capture_lex $P420
    .const 'Sub' $P407 = "26_1295307719.828" 
    capture_lex $P407
    .const 'Sub' $P341 = "23_1295307719.828" 
    capture_lex $P341
    .const 'Sub' $P287 = "22_1295307719.828" 
    capture_lex $P287
    .const 'Sub' $P154 = "19_1295307719.828" 
    capture_lex $P154
    .const 'Sub' $P103 = "18_1295307719.828" 
    capture_lex $P103
    .const 'Sub' $P87 = "17_1295307719.828" 
    capture_lex $P87
    .const 'Sub' $P66 = "16_1295307719.828" 
    capture_lex $P66
    .const 'Sub' $P30 = "13_1295307719.828" 
    capture_lex $P30
    .const 'Sub' $P19 = "12_1295307719.828" 
    capture_lex $P19
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "RegexActions"
    get_global $P18, "@BLOCK"
    unless_null $P18, vivify_172
    $P18 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P18
  vivify_172:
.annotate 'line', 9
    .const 'Sub' $P19 = "12_1295307719.828" 
    newclosure $P29, $P19
    .lex "xblock_immediate", $P29
.annotate 'line', 14
    .const 'Sub' $P30 = "13_1295307719.828" 
    newclosure $P65, $P30
    .lex "block_immediate", $P65
.annotate 'line', 24
    .const 'Sub' $P66 = "16_1295307719.828" 
    newclosure $P86, $P66
    .lex "vivitype", $P86
.annotate 'line', 43
    .const 'Sub' $P87 = "17_1295307719.828" 
    newclosure $P102, $P87
    .lex "colonpair_str", $P102
.annotate 'line', 227
    .const 'Sub' $P103 = "18_1295307719.828" 
    newclosure $P153, $P103
    .lex "push_block_handler", $P153
.annotate 'line', 381
    .const 'Sub' $P154 = "19_1295307719.828" 
    newclosure $P286, $P154
    .lex "package", $P286
.annotate 'line', 457
    .const 'Sub' $P287 = "22_1295307719.828" 
    newclosure $P340, $P287
    .lex "old_package", $P340
.annotate 'line', 757
    .const 'Sub' $P341 = "23_1295307719.828" 
    newclosure $P406, $P341
    .lex "OLD_method_def", $P406
.annotate 'line', 778
    .const 'Sub' $P407 = "26_1295307719.828" 
    newclosure $P419, $P407
    .lex "only_star_block", $P419
.annotate 'line', 787
    .const 'Sub' $P420 = "27_1295307719.828" 
    newclosure $P487, $P420
    .lex "attach_multi_signature", $P487
.annotate 'line', 1205
    .const 'Sub' $P488 = "29_1295307719.828" 
    newclosure $P502, $P488
    .lex "control", $P502
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P503, "@BLOCK"
.annotate 'line', 5
    find_lex $P504, "xblock_immediate"
    find_lex $P505, "block_immediate"
    find_lex $P506, "vivitype"
.annotate 'line', 35
    find_lex $P551, "colonpair_str"
.annotate 'line', 220
    find_lex $P1010, "push_block_handler"
.annotate 'line', 379
    find_lex $P1417, "package"
    find_lex $P1418, "old_package"
.annotate 'line', 682
    find_lex $P2047, "OLD_method_def"
    find_lex $P2048, "only_star_block"
    find_lex $P2049, "attach_multi_signature"
.annotate 'line', 1196
    find_lex $P3128, "control"
.annotate 'line', 1223
    get_hll_global $P3165, ["NQP";"RegexActions"], "_block3164" 
    capture_lex $P3165
    $P3306 = $P3165()
.annotate 'line', 3
    .return ($P3306)
    .const 'Sub' $P3308 = "166_1295307719.828" 
    .return ($P3308)
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post170") :outer("11_1295307719.828")
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    .local pmc block
    set block, $P15
.annotate 'line', 5
    .const 'Sub' $P3312 = "167_1295307719.828" 
    capture_lex $P3312
    $P3312()
    .const 'Sub' $P3316 = "168_1295307719.828" 
    capture_lex $P3316
    $P3316()
.end


.namespace ["NQP";"Actions"]
.sub "_block3311"  :anon :subid("167_1295307719.828") :outer("11_1295307719.828")
.annotate 'line', 6
    get_global $P3313, "@BLOCK"
    unless_null $P3313, vivify_171
    $P3313 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P3313
  vivify_171:
 $P3314 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P3314
.annotate 'line', 5
    .return ($P3314)
.end


.namespace ["NQP";"Actions"]
.sub "_block3315"  :anon :subid("168_1295307719.828") :outer("11_1295307719.828")
.annotate 'line', 5
    get_hll_global $P3317, "NQPClassHOW"
    $P3318 = $P3317."new_type"("Actions" :named("name"))
    .local pmc type_obj
    set type_obj, $P3318
    set_hll_global ["NQP"], "Actions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3319, type_obj
    .const 'Sub' $P3320 = "30_1295307719.828" 
    $P3319."add_method"(type_obj, "TOP", $P3320)
    get_how $P3321, type_obj
    .const 'Sub' $P3322 = "31_1295307719.828" 
    $P3321."add_method"(type_obj, "deflongname", $P3322)
    get_how $P3323, type_obj
    .const 'Sub' $P3324 = "32_1295307719.828" 
    $P3323."add_method"(type_obj, "comp_unit", $P3324)
    get_how $P3325, type_obj
    .const 'Sub' $P3326 = "33_1295307719.828" 
    $P3325."add_method"(type_obj, "statementlist", $P3326)
    get_how $P3327, type_obj
    .const 'Sub' $P3328 = "35_1295307719.828" 
    $P3327."add_method"(type_obj, "statement", $P3328)
    get_how $P3329, type_obj
    .const 'Sub' $P3330 = "37_1295307719.828" 
    $P3329."add_method"(type_obj, "xblock", $P3330)
    get_how $P3331, type_obj
    .const 'Sub' $P3332 = "38_1295307719.828" 
    $P3331."add_method"(type_obj, "pblock", $P3332)
    get_how $P3333, type_obj
    .const 'Sub' $P3334 = "39_1295307719.828" 
    $P3333."add_method"(type_obj, "block", $P3334)
    get_how $P3335, type_obj
    .const 'Sub' $P3336 = "40_1295307719.828" 
    $P3335."add_method"(type_obj, "blockoid", $P3336)
    get_how $P3337, type_obj
    .const 'Sub' $P3338 = "41_1295307719.828" 
    $P3337."add_method"(type_obj, "newpad", $P3338)
    get_how $P3339, type_obj
    .const 'Sub' $P3340 = "42_1295307719.828" 
    $P3339."add_method"(type_obj, "outerctx", $P3340)
    get_how $P3341, type_obj
    .const 'Sub' $P3342 = "43_1295307719.828" 
    $P3341."add_method"(type_obj, "statement_control:sym<if>", $P3342)
    get_how $P3343, type_obj
    .const 'Sub' $P3344 = "45_1295307719.828" 
    $P3343."add_method"(type_obj, "statement_control:sym<unless>", $P3344)
    get_how $P3345, type_obj
    .const 'Sub' $P3346 = "46_1295307719.828" 
    $P3345."add_method"(type_obj, "statement_control:sym<while>", $P3346)
    get_how $P3347, type_obj
    .const 'Sub' $P3348 = "47_1295307719.828" 
    $P3347."add_method"(type_obj, "statement_control:sym<repeat>", $P3348)
    get_how $P3349, type_obj
    .const 'Sub' $P3350 = "48_1295307719.828" 
    $P3349."add_method"(type_obj, "statement_control:sym<for>", $P3350)
    get_how $P3351, type_obj
    .const 'Sub' $P3352 = "49_1295307719.828" 
    $P3351."add_method"(type_obj, "statement_control:sym<return>", $P3352)
    get_how $P3353, type_obj
    .const 'Sub' $P3354 = "50_1295307719.828" 
    $P3353."add_method"(type_obj, "statement_control:sym<CATCH>", $P3354)
    get_how $P3355, type_obj
    .const 'Sub' $P3356 = "51_1295307719.828" 
    $P3355."add_method"(type_obj, "statement_control:sym<CONTROL>", $P3356)
    get_how $P3357, type_obj
    .const 'Sub' $P3358 = "52_1295307719.828" 
    $P3357."add_method"(type_obj, "statement_prefix:sym<INIT>", $P3358)
    get_how $P3359, type_obj
    .const 'Sub' $P3360 = "53_1295307719.828" 
    $P3359."add_method"(type_obj, "statement_prefix:sym<try>", $P3360)
    get_how $P3361, type_obj
    .const 'Sub' $P3362 = "54_1295307719.828" 
    $P3361."add_method"(type_obj, "blorst", $P3362)
    get_how $P3363, type_obj
    .const 'Sub' $P3364 = "55_1295307719.828" 
    $P3363."add_method"(type_obj, "statement_mod_cond:sym<if>", $P3364)
    get_how $P3365, type_obj
    .const 'Sub' $P3366 = "56_1295307719.828" 
    $P3365."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P3366)
    get_how $P3367, type_obj
    .const 'Sub' $P3368 = "57_1295307719.828" 
    $P3367."add_method"(type_obj, "statement_mod_loop:sym<while>", $P3368)
    get_how $P3369, type_obj
    .const 'Sub' $P3370 = "58_1295307719.828" 
    $P3369."add_method"(type_obj, "statement_mod_loop:sym<until>", $P3370)
    get_how $P3371, type_obj
    .const 'Sub' $P3372 = "59_1295307719.828" 
    $P3371."add_method"(type_obj, "term:sym<fatarrow>", $P3372)
    get_how $P3373, type_obj
    .const 'Sub' $P3374 = "60_1295307719.828" 
    $P3373."add_method"(type_obj, "term:sym<colonpair>", $P3374)
    get_how $P3375, type_obj
    .const 'Sub' $P3376 = "61_1295307719.828" 
    $P3375."add_method"(type_obj, "term:sym<variable>", $P3376)
    get_how $P3377, type_obj
    .const 'Sub' $P3378 = "62_1295307719.828" 
    $P3377."add_method"(type_obj, "term:sym<package_declarator>", $P3378)
    get_how $P3379, type_obj
    .const 'Sub' $P3380 = "63_1295307719.828" 
    $P3379."add_method"(type_obj, "term:sym<scope_declarator>", $P3380)
    get_how $P3381, type_obj
    .const 'Sub' $P3382 = "64_1295307719.828" 
    $P3381."add_method"(type_obj, "term:sym<routine_declarator>", $P3382)
    get_how $P3383, type_obj
    .const 'Sub' $P3384 = "65_1295307719.828" 
    $P3383."add_method"(type_obj, "term:sym<regex_declarator>", $P3384)
    get_how $P3385, type_obj
    .const 'Sub' $P3386 = "66_1295307719.828" 
    $P3385."add_method"(type_obj, "term:sym<statement_prefix>", $P3386)
    get_how $P3387, type_obj
    .const 'Sub' $P3388 = "67_1295307719.828" 
    $P3387."add_method"(type_obj, "term:sym<lambda>", $P3388)
    get_how $P3389, type_obj
    .const 'Sub' $P3390 = "68_1295307719.828" 
    $P3389."add_method"(type_obj, "fatarrow", $P3390)
    get_how $P3391, type_obj
    .const 'Sub' $P3392 = "69_1295307719.828" 
    $P3391."add_method"(type_obj, "colonpair", $P3392)
    get_how $P3393, type_obj
    .const 'Sub' $P3394 = "70_1295307719.828" 
    $P3393."add_method"(type_obj, "variable", $P3394)
    get_how $P3395, type_obj
    .const 'Sub' $P3396 = "72_1295307719.828" 
    $P3395."add_method"(type_obj, "package_declarator:sym<module>", $P3396)
    get_how $P3397, type_obj
    .const 'Sub' $P3398 = "73_1295307719.828" 
    $P3397."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3398)
    get_how $P3399, type_obj
    .const 'Sub' $P3400 = "74_1295307719.828" 
    $P3399."add_method"(type_obj, "package_declarator:sym<class>", $P3400)
    get_how $P3401, type_obj
    .const 'Sub' $P3402 = "75_1295307719.828" 
    $P3401."add_method"(type_obj, "package_declarator:sym<grammar>", $P3402)
    get_how $P3403, type_obj
    .const 'Sub' $P3404 = "76_1295307719.828" 
    $P3403."add_method"(type_obj, "package_declarator:sym<role>", $P3404)
    get_how $P3405, type_obj
    .const 'Sub' $P3406 = "77_1295307719.828" 
    $P3405."add_method"(type_obj, "package_def", $P3406)
    get_how $P3407, type_obj
    .const 'Sub' $P3408 = "78_1295307719.828" 
    $P3407."add_method"(type_obj, "scope_declarator:sym<my>", $P3408)
    get_how $P3409, type_obj
    .const 'Sub' $P3410 = "79_1295307719.828" 
    $P3409."add_method"(type_obj, "scope_declarator:sym<our>", $P3410)
    get_how $P3411, type_obj
    .const 'Sub' $P3412 = "80_1295307719.828" 
    $P3411."add_method"(type_obj, "scope_declarator:sym<has>", $P3412)
    get_how $P3413, type_obj
    .const 'Sub' $P3414 = "81_1295307719.828" 
    $P3413."add_method"(type_obj, "scoped", $P3414)
    get_how $P3415, type_obj
    .const 'Sub' $P3416 = "82_1295307719.828" 
    $P3415."add_method"(type_obj, "declarator", $P3416)
    get_how $P3417, type_obj
    .const 'Sub' $P3418 = "83_1295307719.828" 
    $P3417."add_method"(type_obj, "multi_declarator:sym<multi>", $P3418)
    get_how $P3419, type_obj
    .const 'Sub' $P3420 = "84_1295307719.828" 
    $P3419."add_method"(type_obj, "multi_declarator:sym<proto>", $P3420)
    get_how $P3421, type_obj
    .const 'Sub' $P3422 = "85_1295307719.828" 
    $P3421."add_method"(type_obj, "multi_declarator:sym<null>", $P3422)
    get_how $P3423, type_obj
    .const 'Sub' $P3424 = "86_1295307719.828" 
    $P3423."add_method"(type_obj, "variable_declarator", $P3424)
    get_how $P3425, type_obj
    .const 'Sub' $P3426 = "89_1295307719.828" 
    $P3425."add_method"(type_obj, "routine_declarator:sym<sub>", $P3426)
    get_how $P3427, type_obj
    .const 'Sub' $P3428 = "90_1295307719.828" 
    $P3427."add_method"(type_obj, "routine_declarator:sym<method>", $P3428)
    get_how $P3429, type_obj
    .const 'Sub' $P3430 = "91_1295307719.828" 
    $P3429."add_method"(type_obj, "routine_def", $P3430)
    get_how $P3431, type_obj
    .const 'Sub' $P3432 = "98_1295307719.828" 
    $P3431."add_method"(type_obj, "method_def", $P3432)
    get_how $P3433, type_obj
    .const 'Sub' $P3434 = "101_1295307719.828" 
    $P3433."add_method"(type_obj, "signature", $P3434)
    get_how $P3435, type_obj
    .const 'Sub' $P3436 = "104_1295307719.828" 
    $P3435."add_method"(type_obj, "parameter", $P3436)
    get_how $P3437, type_obj
    .const 'Sub' $P3438 = "105_1295307719.828" 
    $P3437."add_method"(type_obj, "param_var", $P3438)
    get_how $P3439, type_obj
    .const 'Sub' $P3440 = "106_1295307719.828" 
    $P3439."add_method"(type_obj, "named_param", $P3440)
    get_how $P3441, type_obj
    .const 'Sub' $P3442 = "107_1295307719.828" 
    $P3441."add_method"(type_obj, "typename", $P3442)
    get_how $P3443, type_obj
    .const 'Sub' $P3444 = "108_1295307719.828" 
    $P3443."add_method"(type_obj, "trait", $P3444)
    get_how $P3445, type_obj
    .const 'Sub' $P3446 = "109_1295307719.828" 
    $P3445."add_method"(type_obj, "trait_mod:sym<is>", $P3446)
    get_how $P3447, type_obj
    .const 'Sub' $P3448 = "111_1295307719.828" 
    $P3447."add_method"(type_obj, "regex_declarator", $P3448)
    get_how $P3449, type_obj
    .const 'Sub' $P3450 = "114_1295307719.828" 
    $P3449."add_method"(type_obj, "dotty", $P3450)
    get_how $P3451, type_obj
    .const 'Sub' $P3452 = "115_1295307719.828" 
    $P3451."add_method"(type_obj, "term:sym<self>", $P3452)
    get_how $P3453, type_obj
    .const 'Sub' $P3454 = "116_1295307719.828" 
    $P3453."add_method"(type_obj, "term:sym<identifier>", $P3454)
    get_how $P3455, type_obj
    .const 'Sub' $P3456 = "117_1295307719.828" 
    $P3455."add_method"(type_obj, "term:sym<name>", $P3456)
    get_how $P3457, type_obj
    .const 'Sub' $P3458 = "118_1295307719.828" 
    $P3457."add_method"(type_obj, "term:sym<pir::op>", $P3458)
    get_how $P3459, type_obj
    .const 'Sub' $P3460 = "119_1295307719.828" 
    $P3459."add_method"(type_obj, "term:sym<onlystar>", $P3460)
    get_how $P3461, type_obj
    .const 'Sub' $P3462 = "120_1295307719.828" 
    $P3461."add_method"(type_obj, "args", $P3462)
    get_how $P3463, type_obj
    .const 'Sub' $P3464 = "121_1295307719.828" 
    $P3463."add_method"(type_obj, "arglist", $P3464)
    get_how $P3465, type_obj
    .const 'Sub' $P3466 = "124_1295307719.828" 
    $P3465."add_method"(type_obj, "term:sym<multi_declarator>", $P3466)
    get_how $P3467, type_obj
    .const 'Sub' $P3468 = "125_1295307719.828" 
    $P3467."add_method"(type_obj, "term:sym<value>", $P3468)
    get_how $P3469, type_obj
    .const 'Sub' $P3470 = "126_1295307719.828" 
    $P3469."add_method"(type_obj, "circumfix:sym<( )>", $P3470)
    get_how $P3471, type_obj
    .const 'Sub' $P3472 = "127_1295307719.828" 
    $P3471."add_method"(type_obj, "circumfix:sym<[ ]>", $P3472)
    get_how $P3473, type_obj
    .const 'Sub' $P3474 = "128_1295307719.828" 
    $P3473."add_method"(type_obj, "circumfix:sym<ang>", $P3474)
    get_how $P3475, type_obj
    .const 'Sub' $P3476 = "129_1295307719.828" 
    $P3475."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3476)
    get_how $P3477, type_obj
    .const 'Sub' $P3478 = "130_1295307719.828" 
    $P3477."add_method"(type_obj, "circumfix:sym<{ }>", $P3478)
    get_how $P3479, type_obj
    .const 'Sub' $P3480 = "131_1295307719.828" 
    $P3479."add_method"(type_obj, "circumfix:sym<sigil>", $P3480)
    get_how $P3481, type_obj
    .const 'Sub' $P3482 = "132_1295307719.828" 
    $P3481."add_method"(type_obj, "semilist", $P3482)
    get_how $P3483, type_obj
    .const 'Sub' $P3484 = "133_1295307719.828" 
    $P3483."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3484)
    get_how $P3485, type_obj
    .const 'Sub' $P3486 = "134_1295307719.828" 
    $P3485."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3486)
    get_how $P3487, type_obj
    .const 'Sub' $P3488 = "135_1295307719.828" 
    $P3487."add_method"(type_obj, "postcircumfix:sym<ang>", $P3488)
    get_how $P3489, type_obj
    .const 'Sub' $P3490 = "136_1295307719.828" 
    $P3489."add_method"(type_obj, "postcircumfix:sym<( )>", $P3490)
    get_how $P3491, type_obj
    .const 'Sub' $P3492 = "137_1295307719.828" 
    $P3491."add_method"(type_obj, "value", $P3492)
    get_how $P3493, type_obj
    .const 'Sub' $P3494 = "138_1295307719.828" 
    $P3493."add_method"(type_obj, "number", $P3494)
    get_how $P3495, type_obj
    .const 'Sub' $P3496 = "139_1295307719.828" 
    $P3495."add_method"(type_obj, "quote:sym<apos>", $P3496)
    get_how $P3497, type_obj
    .const 'Sub' $P3498 = "140_1295307719.828" 
    $P3497."add_method"(type_obj, "quote:sym<dblq>", $P3498)
    get_how $P3499, type_obj
    .const 'Sub' $P3500 = "141_1295307719.828" 
    $P3499."add_method"(type_obj, "quote:sym<qq>", $P3500)
    get_how $P3501, type_obj
    .const 'Sub' $P3502 = "142_1295307719.828" 
    $P3501."add_method"(type_obj, "quote:sym<q>", $P3502)
    get_how $P3503, type_obj
    .const 'Sub' $P3504 = "143_1295307719.828" 
    $P3503."add_method"(type_obj, "quote:sym<Q>", $P3504)
    get_how $P3505, type_obj
    .const 'Sub' $P3506 = "144_1295307719.828" 
    $P3505."add_method"(type_obj, "quote:sym<Q:PIR>", $P3506)
    get_how $P3507, type_obj
    .const 'Sub' $P3508 = "145_1295307719.828" 
    $P3507."add_method"(type_obj, "quote:sym</ />", $P3508)
    get_how $P3509, type_obj
    .const 'Sub' $P3510 = "146_1295307719.828" 
    $P3509."add_method"(type_obj, "quote_escape:sym<$>", $P3510)
    get_how $P3511, type_obj
    .const 'Sub' $P3512 = "147_1295307719.828" 
    $P3511."add_method"(type_obj, "quote_escape:sym<{ }>", $P3512)
    get_how $P3513, type_obj
    .const 'Sub' $P3514 = "148_1295307719.828" 
    $P3513."add_method"(type_obj, "quote_escape:sym<esc>", $P3514)
    get_how $P3515, type_obj
    .const 'Sub' $P3516 = "149_1295307719.828" 
    $P3515."add_method"(type_obj, "postfix:sym<.>", $P3516)
    get_how $P3517, type_obj
    .const 'Sub' $P3518 = "150_1295307719.828" 
    $P3517."add_method"(type_obj, "postfix:sym<++>", $P3518)
    get_how $P3519, type_obj
    .const 'Sub' $P3520 = "151_1295307719.828" 
    $P3519."add_method"(type_obj, "postfix:sym<-->", $P3520)
    get_how $P3521, type_obj
    .const 'Sub' $P3522 = "152_1295307719.828" 
    $P3521."add_method"(type_obj, "prefix:sym<make>", $P3522)
    get_how $P3523, type_obj
    .const 'Sub' $P3524 = "153_1295307719.828" 
    $P3523."add_method"(type_obj, "term:sym<next>", $P3524)
    get_how $P3525, type_obj
    .const 'Sub' $P3526 = "154_1295307719.828" 
    $P3525."add_method"(type_obj, "term:sym<last>", $P3526)
    get_how $P3527, type_obj
    .const 'Sub' $P3528 = "155_1295307719.828" 
    $P3527."add_method"(type_obj, "term:sym<redo>", $P3528)
    get_how $P3529, type_obj
    .const 'Sub' $P3530 = "156_1295307719.828" 
    $P3529."add_method"(type_obj, "infix:sym<~~>", $P3530)
    get_how $P3531, type_obj
    get_hll_global $P3532, ["HLL"], "Actions"
    $P3531."add_parent"(type_obj, $P3532)
    get_how $P3533, type_obj
    $P3534 = $P3533."compose"(type_obj)
    .return ($P3534)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "xblock_immediate"  :subid("12_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_22
.annotate 'line', 9
    new $P21, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P21, control_20
    push_eh $P21
    .lex "$xblock", param_22
.annotate 'line', 10
    find_lex $P23, "$xblock"
    unless_null $P23, vivify_173
    $P23 = root_new ['parrot';'ResizablePMCArray']
  vivify_173:
    set $P24, $P23[1]
    unless_null $P24, vivify_174
    new $P24, "Undef"
  vivify_174:
    $P25 = "block_immediate"($P24)
    find_lex $P26, "$xblock"
    unless_null $P26, vivify_175
    $P26 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P26
  vivify_175:
    set $P26[1], $P25
    find_lex $P27, "$xblock"
.annotate 'line', 9
    .return ($P27)
  control_20:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P28, exception, "payload"
    .return ($P28)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "block_immediate"  :subid("13_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_33
.annotate 'line', 14
    .const 'Sub' $P43 = "14_1295307719.828" 
    capture_lex $P43
    new $P32, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P32, control_31
    push_eh $P32
    .lex "$block", param_33
.annotate 'line', 15
    find_lex $P34, "$block"
    $P34."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P38, "$block"
    $P39 = $P38."symtable"()
    unless $P39, unless_37
    set $P36, $P39
    goto unless_37_end
  unless_37:
    find_lex $P40, "$block"
    $P41 = $P40."handlers"()
    set $P36, $P41
  unless_37_end:
    if $P36, unless_35_end
    .const 'Sub' $P43 = "14_1295307719.828" 
    capture_lex $P43
    $P43()
  unless_35_end:
    find_lex $P63, "$block"
.annotate 'line', 14
    .return ($P63)
  control_31:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P64, exception, "payload"
    .return ($P64)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block42"  :anon :subid("14_1295307719.828") :outer("13_1295307719.828")
.annotate 'line', 16
    .const 'Sub' $P54 = "15_1295307719.828" 
    capture_lex $P54
.annotate 'line', 17
    new $P44, "Undef"
    .lex "$stmts", $P44
    get_hll_global $P45, ["PAST"], "Stmts"
    find_lex $P46, "$block"
    $P47 = $P45."new"($P46 :named("node"))
    store_lex "$stmts", $P47
.annotate 'line', 18
    find_lex $P49, "$block"
    $P50 = $P49."list"()
    defined $I51, $P50
    unless $I51, for_undef_176
    iter $P48, $P50
    new $P60, 'ExceptionHandler'
    set_addr $P60, loop59_handler
    $P60."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P60
  loop59_test:
    unless $P48, loop59_done
    shift $P52, $P48
  loop59_redo:
    .const 'Sub' $P54 = "15_1295307719.828" 
    capture_lex $P54
    $P54($P52)
  loop59_next:
    goto loop59_test
  loop59_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P61, exception, 'type'
    eq $P61, .CONTROL_LOOP_NEXT, loop59_next
    eq $P61, .CONTROL_LOOP_REDO, loop59_redo
  loop59_done:
    pop_eh 
  for_undef_176:
.annotate 'line', 19
    find_lex $P62, "$stmts"
    store_lex "$block", $P62
.annotate 'line', 16
    .return ($P62)
.end


.namespace ["NQP";"Actions"]
.sub "_block53"  :anon :subid("15_1295307719.828") :outer("14_1295307719.828")
    .param pmc param_55
.annotate 'line', 18
    .lex "$_", param_55
    find_lex $P56, "$stmts"
    find_lex $P57, "$_"
    $P58 = $P56."push"($P57)
    .return ($P58)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "vivitype"  :subid("16_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_69
.annotate 'line', 24
    new $P68, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P68, control_67
    push_eh $P68
    .lex "$sigil", param_69
.annotate 'line', 25
    find_lex $P72, "$sigil"
    set $S73, $P72
    iseq $I74, $S73, "%"
    if $I74, if_71
.annotate 'line', 27
    find_lex $P79, "$sigil"
    set $S80, $P79
    iseq $I81, $S80, "@"
    if $I81, if_78
    new $P84, "String"
    assign $P84, "Undef"
    set $P77, $P84
    goto if_78_end
  if_78:
.annotate 'line', 28
    get_hll_global $P82, ["PAST"], "Op"
    $P83 = $P82."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P77, $P83
  if_78_end:
    set $P70, $P77
.annotate 'line', 25
    goto if_71_end
  if_71:
.annotate 'line', 26
    get_hll_global $P75, ["PAST"], "Op"
    $P76 = $P75."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P70, $P76
  if_71_end:
.annotate 'line', 24
    .return ($P70)
  control_67:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P85, exception, "payload"
    .return ($P85)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "colonpair_str"  :subid("17_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_90
.annotate 'line', 43
    new $P89, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P89, control_88
    push_eh $P89
    .lex "$ast", param_90
.annotate 'line', 44
    get_hll_global $P93, ["PAST"], "Op"
    find_lex $P94, "$ast"
    $P95 = $P93."ACCEPTS"($P94)
    if $P95, if_92
.annotate 'line', 46
    find_lex $P99, "$ast"
    $P100 = $P99."value"()
    set $P91, $P100
.annotate 'line', 44
    goto if_92_end
  if_92:
.annotate 'line', 45
    find_lex $P96, "$ast"
    $P97 = $P96."list"()
    join $S98, " ", $P97
    new $P91, 'String'
    set $P91, $S98
  if_92_end:
.annotate 'line', 43
    .return ($P91)
  control_88:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P101, exception, "payload"
    .return ($P101)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "push_block_handler"  :subid("18_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_106
    .param pmc param_107
.annotate 'line', 227
    new $P105, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P105, control_104
    push_eh $P105
    .lex "$/", param_106
    .lex "$block", param_107
.annotate 'line', 228
    get_global $P109, "@BLOCK"
    unless_null $P109, vivify_177
    $P109 = root_new ['parrot';'ResizablePMCArray']
  vivify_177:
    set $P110, $P109[0]
    unless_null $P110, vivify_178
    new $P110, "Undef"
  vivify_178:
    $P111 = $P110."handlers"()
    if $P111, unless_108_end
.annotate 'line', 229
    get_global $P112, "@BLOCK"
    unless_null $P112, vivify_179
    $P112 = root_new ['parrot';'ResizablePMCArray']
  vivify_179:
    set $P113, $P112[0]
    unless_null $P113, vivify_180
    new $P113, "Undef"
  vivify_180:
    new $P114, "ResizablePMCArray"
    $P113."handlers"($P114)
  unless_108_end:
.annotate 'line', 231
    find_lex $P116, "$block"
    $P117 = $P116."arity"()
    if $P117, unless_115_end
.annotate 'line', 232
    find_lex $P118, "$block"
.annotate 'line', 233
    get_hll_global $P119, ["PAST"], "Op"
.annotate 'line', 234
    get_hll_global $P120, ["PAST"], "Var"
    $P121 = $P120."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 235
    get_hll_global $P122, ["PAST"], "Var"
    $P123 = $P122."new"("lexical" :named("scope"), "$_" :named("name"))
    $P124 = $P119."new"($P121, $P123, "bind" :named("pasttype"))
.annotate 'line', 233
    $P118."unshift"($P124)
.annotate 'line', 238
    find_lex $P125, "$block"
    get_hll_global $P126, ["PAST"], "Var"
    $P127 = $P126."new"("$_" :named("name"), "parameter" :named("scope"))
    $P125."unshift"($P127)
.annotate 'line', 239
    find_lex $P128, "$block"
    $P128."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 240
    find_lex $P129, "$block"
    $P129."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 241
    find_lex $P130, "$block"
    $P130."arity"(1)
  unless_115_end:
.annotate 'line', 243
    find_lex $P131, "$block"
    $P131."blocktype"("declaration")
.annotate 'line', 244
    get_global $P132, "@BLOCK"
    unless_null $P132, vivify_181
    $P132 = root_new ['parrot';'ResizablePMCArray']
  vivify_181:
    set $P133, $P132[0]
    unless_null $P133, vivify_182
    new $P133, "Undef"
  vivify_182:
    $P134 = $P133."handlers"()
.annotate 'line', 245
    get_hll_global $P135, ["PAST"], "Control"
    find_lex $P136, "$/"
.annotate 'line', 247
    get_hll_global $P137, ["PAST"], "Stmts"
.annotate 'line', 248
    get_hll_global $P138, ["PAST"], "Op"
    find_lex $P139, "$block"
.annotate 'line', 250
    get_hll_global $P140, ["PAST"], "Var"
    $P141 = $P140."new"("register" :named("scope"), "exception" :named("name"))
    $P142 = $P138."new"($P139, $P141, "call" :named("pasttype"))
.annotate 'line', 252
    get_hll_global $P143, ["PAST"], "Op"
.annotate 'line', 253
    get_hll_global $P144, ["PAST"], "Var"
.annotate 'line', 254
    get_hll_global $P145, ["PAST"], "Var"
    $P146 = $P145."new"("register" :named("scope"), "exception" :named("name"))
    $P147 = $P144."new"($P146, "handled", "keyed" :named("scope"))
.annotate 'line', 253
    $P148 = $P143."new"($P147, 1, "bind" :named("pasttype"))
.annotate 'line', 252
    $P149 = $P137."new"($P142, $P148)
.annotate 'line', 247
    $P150 = $P135."new"($P149, $P136 :named("node"))
.annotate 'line', 245
    $P151 = $P134."unshift"($P150)
.annotate 'line', 227
    .return ($P151)
  control_104:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P152, exception, "payload"
    .return ($P152)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package"  :subid("19_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_157
.annotate 'line', 381
    .const 'Sub' $P227 = "21_1295307719.828" 
    capture_lex $P227
    .const 'Sub' $P208 = "20_1295307719.828" 
    capture_lex $P208
    new $P156, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P156, control_155
    push_eh $P156
    .lex "$/", param_157
.annotate 'line', 382
    $P158 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P158
.annotate 'line', 383
    new $P159, "Undef"
    .lex "$name", $P159
.annotate 'line', 445
    new $P160, "Undef"
    .lex "$past", $P160
.annotate 'line', 382
    find_lex $P161, "$/"
    unless_null $P161, vivify_183
    $P161 = root_new ['parrot';'Hash']
  vivify_183:
    set $P162, $P161["package_def"]
    unless_null $P162, vivify_184
    $P162 = root_new ['parrot';'Hash']
  vivify_184:
    set $P163, $P162["name"]
    unless_null $P163, vivify_185
    $P163 = root_new ['parrot';'Hash']
  vivify_185:
    set $P164, $P163["identifier"]
    unless_null $P164, vivify_186
    new $P164, "Undef"
  vivify_186:
    clone $P165, $P164
    store_lex "@ns", $P165
.annotate 'line', 383
    find_lex $P166, "@ns"
    $P167 = $P166."pop"()
    set $S168, $P167
    new $P169, 'String'
    set $P169, $S168
    store_lex "$name", $P169
.annotate 'line', 387
    find_dynamic_lex $P170, "$*PACKAGE-SETUP"
    unless_null $P170, vivify_187
    get_hll_global $P170, "$PACKAGE-SETUP"
    unless_null $P170, vivify_188
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_188:
  vivify_187:
    get_hll_global $P171, ["PAST"], "Stmts"
.annotate 'line', 388
    get_hll_global $P172, ["PAST"], "Op"
.annotate 'line', 389
    get_hll_global $P173, ["PAST"], "Var"
    $P174 = $P173."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 390
    get_hll_global $P175, ["PAST"], "Op"
.annotate 'line', 392
    get_hll_global $P176, ["PAST"], "Var"
    find_lex $P177, "$/"
    unless_null $P177, vivify_189
    $P177 = root_new ['parrot';'Hash']
  vivify_189:
    set $P178, $P177["sym"]
    unless_null $P178, vivify_190
    new $P178, "Undef"
  vivify_190:
    set $S179, $P178
    find_dynamic_lex $P180, "%*HOW"
    unless_null $P180, vivify_191
    get_hll_global $P180, "%HOW"
    unless_null $P180, vivify_192
    die "Contextual %*HOW not found"
  vivify_192:
  vivify_191:
    set $P181, $P180[$S179]
    unless_null $P181, vivify_193
    new $P181, "Undef"
  vivify_193:
    $P182 = $P176."new"($P181 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 393
    get_hll_global $P183, ["PAST"], "Val"
    find_lex $P184, "$name"
    $P185 = $P183."new"($P184 :named("value"), "name" :named("named"))
    $P186 = $P175."new"($P182, $P185, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 390
    $P187 = $P172."new"($P174, $P186, "bind" :named("pasttype"))
.annotate 'line', 396
    get_hll_global $P188, ["PAST"], "Op"
.annotate 'line', 397
    get_hll_global $P189, ["PAST"], "Var"
    find_lex $P190, "$name"
    find_lex $P191, "@ns"
    $P192 = $P189."new"($P190 :named("name"), $P191 :named("namespace"), "package" :named("scope"))
.annotate 'line', 398
    get_hll_global $P193, ["PAST"], "Var"
    $P194 = $P193."new"("type_obj" :named("name"), "register" :named("scope"))
    $P195 = $P188."new"($P192, $P194, "bind" :named("pasttype"))
.annotate 'line', 400
    get_hll_global $P196, ["PAST"], "Op"
.annotate 'line', 401
    get_hll_global $P197, ["PAST"], "Var"
    $P198 = $P197."new"("$?CLASS" :named("name"))
.annotate 'line', 402
    get_hll_global $P199, ["PAST"], "Var"
    $P200 = $P199."new"("type_obj" :named("name"), "register" :named("scope"))
    $P201 = $P196."new"($P198, $P200, "bind" :named("pasttype"))
.annotate 'line', 400
    $P202 = $P171."new"($P187, $P195, $P201)
.annotate 'line', 387
    $P170."unshift"($P202)
.annotate 'line', 406
    find_lex $P204, "$/"
    unless_null $P204, vivify_194
    $P204 = root_new ['parrot';'Hash']
  vivify_194:
    set $P205, $P204["package_def"]
    unless_null $P205, vivify_195
    $P205 = root_new ['parrot';'Hash']
  vivify_195:
    set $P206, $P205["repr"]
    unless_null $P206, vivify_196
    new $P206, "Undef"
  vivify_196:
    unless $P206, if_203_end
    .const 'Sub' $P208 = "20_1295307719.828" 
    capture_lex $P208
    $P208()
  if_203_end:
.annotate 'line', 414
    find_lex $P223, "$/"
    unless_null $P223, vivify_206
    $P223 = root_new ['parrot';'Hash']
  vivify_206:
    set $P224, $P223["package_def"]
    unless_null $P224, vivify_207
    $P224 = root_new ['parrot';'Hash']
  vivify_207:
    set $P225, $P224["parent"]
    unless_null $P225, vivify_208
    new $P225, "Undef"
  vivify_208:
    unless $P225, if_222_end
    .const 'Sub' $P227 = "21_1295307719.828" 
    capture_lex $P227
    $P227()
  if_222_end:
.annotate 'line', 430
    find_dynamic_lex $P255, "$*PACKAGE-SETUP"
    unless_null $P255, vivify_216
    get_hll_global $P255, "$PACKAGE-SETUP"
    unless_null $P255, vivify_217
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_217:
  vivify_216:
    get_hll_global $P256, ["PAST"], "Op"
.annotate 'line', 432
    get_hll_global $P257, ["PAST"], "Op"
.annotate 'line', 435
    get_hll_global $P258, ["PAST"], "Var"
    $P259 = $P258."new"("type_obj" :named("name"), "register" :named("scope"))
    $P260 = $P257."new"($P259, "get_how PP" :named("pirop"))
.annotate 'line', 437
    get_hll_global $P261, ["PAST"], "Var"
    $P262 = $P261."new"("type_obj" :named("name"), "register" :named("scope"))
    $P263 = $P256."new"($P260, $P262, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 430
    $P255."push"($P263)
.annotate 'line', 441
    get_global $P264, "@BLOCK"
    unless_null $P264, vivify_218
    $P264 = root_new ['parrot';'ResizablePMCArray']
  vivify_218:
    set $P265, $P264[0]
    unless_null $P265, vivify_219
    $P265 = root_new ['parrot';'ResizablePMCArray']
  vivify_219:
    set $P266, $P265[0]
    unless_null $P266, vivify_220
    new $P266, "Undef"
  vivify_220:
    get_hll_global $P267, ["PAST"], "Var"
    find_lex $P268, "$name"
    find_lex $P269, "@ns"
    $P270 = $P267."new"($P268 :named("name"), $P269 :named("namespace"), "package" :named("scope"), 1 :named("isdecl"))
    $P266."unshift"($P270)
.annotate 'line', 445
    find_lex $P271, "$/"
    unless_null $P271, vivify_221
    $P271 = root_new ['parrot';'Hash']
  vivify_221:
    set $P272, $P271["package_def"]
    unless_null $P272, vivify_222
    new $P272, "Undef"
  vivify_222:
    $P273 = $P272."ast"()
    store_lex "$past", $P273
.annotate 'line', 446
    find_lex $P274, "$past"
    get_hll_global $P275, ["PAST"], "Var"
    $P276 = $P275."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P274."unshift"($P276)
.annotate 'line', 447
    find_lex $P277, "$past"
    $P277."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 450
    find_lex $P278, "$past"
    $P279 = $P278."loadinit"()
    get_hll_global $P280, ["PAST"], "Block"
    find_dynamic_lex $P281, "$*PACKAGE-SETUP"
    unless_null $P281, vivify_223
    get_hll_global $P281, "$PACKAGE-SETUP"
    unless_null $P281, vivify_224
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_224:
  vivify_223:
    $P282 = $P280."new"($P281, "immediate" :named("blocktype"))
    $P279."push"($P282)
.annotate 'line', 452
    new $P283, "Exception"
    set $P283['type'], .CONTROL_RETURN
    find_lex $P284, "$past"
    setattribute $P283, 'payload', $P284
    throw $P283
.annotate 'line', 381
    .return ()
  control_155:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P285, exception, "payload"
    .return ($P285)
.end


.namespace ["NQP";"Actions"]
.sub "_block207"  :anon :subid("20_1295307719.828") :outer("19_1295307719.828")
.annotate 'line', 407
    new $P209, "Undef"
    .lex "$repr_name", $P209
    find_lex $P210, "$/"
    unless_null $P210, vivify_197
    $P210 = root_new ['parrot';'Hash']
  vivify_197:
    set $P211, $P210["package_def"]
    unless_null $P211, vivify_198
    $P211 = root_new ['parrot';'Hash']
  vivify_198:
    set $P212, $P211["repr"]
    unless_null $P212, vivify_199
    $P212 = root_new ['parrot';'ResizablePMCArray']
  vivify_199:
    set $P213, $P212[0]
    unless_null $P213, vivify_200
    new $P213, "Undef"
  vivify_200:
    $P214 = $P213."ast"()
    store_lex "$repr_name", $P214
.annotate 'line', 408
    find_lex $P215, "$repr_name"
    $P215."named"("repr")
.annotate 'line', 409
    find_dynamic_lex $P216, "$*PACKAGE-SETUP"
    unless_null $P216, vivify_201
    get_hll_global $P216, "$PACKAGE-SETUP"
    unless_null $P216, vivify_202
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_202:
  vivify_201:
    set $P217, $P216[0]
    unless_null $P217, vivify_203
    $P217 = root_new ['parrot';'ResizablePMCArray']
  vivify_203:
    set $P218, $P217[0]
    unless_null $P218, vivify_204
    $P218 = root_new ['parrot';'ResizablePMCArray']
  vivify_204:
    set $P219, $P218[1]
    unless_null $P219, vivify_205
    new $P219, "Undef"
  vivify_205:
    find_lex $P220, "$repr_name"
    $P221 = $P219."push"($P220)
.annotate 'line', 406
    .return ($P221)
.end


.namespace ["NQP";"Actions"]
.sub "_block226"  :anon :subid("21_1295307719.828") :outer("19_1295307719.828")
.annotate 'line', 415
    $P228 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P228
.annotate 'line', 416
    new $P229, "Undef"
    .lex "$name", $P229
.annotate 'line', 415
    find_lex $P230, "$/"
    unless_null $P230, vivify_209
    $P230 = root_new ['parrot';'Hash']
  vivify_209:
    set $P231, $P230["package_def"]
    unless_null $P231, vivify_210
    $P231 = root_new ['parrot';'Hash']
  vivify_210:
    set $P232, $P231["parent"]
    unless_null $P232, vivify_211
    $P232 = root_new ['parrot';'ResizablePMCArray']
  vivify_211:
    set $P233, $P232[0]
    unless_null $P233, vivify_212
    $P233 = root_new ['parrot';'Hash']
  vivify_212:
    set $P234, $P233["identifier"]
    unless_null $P234, vivify_213
    new $P234, "Undef"
  vivify_213:
    clone $P235, $P234
    store_lex "@ns", $P235
.annotate 'line', 416
    find_lex $P236, "@ns"
    $P237 = $P236."pop"()
    set $S238, $P237
    new $P239, 'String'
    set $P239, $S238
    store_lex "$name", $P239
.annotate 'line', 417
    find_dynamic_lex $P240, "$*PACKAGE-SETUP"
    unless_null $P240, vivify_214
    get_hll_global $P240, "$PACKAGE-SETUP"
    unless_null $P240, vivify_215
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_215:
  vivify_214:
    get_hll_global $P241, ["PAST"], "Op"
.annotate 'line', 419
    get_hll_global $P242, ["PAST"], "Op"
.annotate 'line', 422
    get_hll_global $P243, ["PAST"], "Var"
    $P244 = $P243."new"("type_obj" :named("name"), "register" :named("scope"))
    $P245 = $P242."new"($P244, "get_how PP" :named("pirop"))
.annotate 'line', 424
    get_hll_global $P246, ["PAST"], "Var"
    $P247 = $P246."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 425
    get_hll_global $P248, ["PAST"], "Var"
    find_lex $P249, "$name"
    set $S250, $P249
    find_lex $P251, "@ns"
    $P252 = $P248."new"($S250 :named("name"), $P251 :named("namespace"), "package" :named("scope"))
    $P253 = $P241."new"($P245, $P247, $P252, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 417
    $P254 = $P240."push"($P253)
.annotate 'line', 414
    .return ($P254)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "old_package"  :subid("22_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_290
.annotate 'line', 457
    new $P289, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P289, control_288
    push_eh $P289
    .lex "$/", param_290
.annotate 'line', 458
    new $P291, "Undef"
    .lex "$past", $P291
.annotate 'line', 459
    new $P292, "Undef"
    .lex "$classinit", $P292
.annotate 'line', 468
    new $P293, "Undef"
    .lex "$parent", $P293
.annotate 'line', 458
    find_lex $P294, "$/"
    unless_null $P294, vivify_225
    $P294 = root_new ['parrot';'Hash']
  vivify_225:
    set $P295, $P294["package_def"]
    unless_null $P295, vivify_226
    new $P295, "Undef"
  vivify_226:
    $P296 = $P295."ast"()
    store_lex "$past", $P296
.annotate 'line', 460
    get_hll_global $P297, ["PAST"], "Op"
.annotate 'line', 461
    get_hll_global $P298, ["PAST"], "Op"
    $P299 = $P298."new"("    %r = get_root_global [\"parrot\"], \"P6metaclass\"" :named("inline"))
.annotate 'line', 464
    find_lex $P300, "$/"
    unless_null $P300, vivify_227
    $P300 = root_new ['parrot';'Hash']
  vivify_227:
    set $P301, $P300["package_def"]
    unless_null $P301, vivify_228
    $P301 = root_new ['parrot';'Hash']
  vivify_228:
    set $P302, $P301["name"]
    unless_null $P302, vivify_229
    new $P302, "Undef"
  vivify_229:
    set $S303, $P302
    $P304 = $P297."new"($P299, $S303, "new_class" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 460
    store_lex "$classinit", $P304
.annotate 'line', 468
    find_lex $P307, "$/"
    unless_null $P307, vivify_230
    $P307 = root_new ['parrot';'Hash']
  vivify_230:
    set $P308, $P307["package_def"]
    unless_null $P308, vivify_231
    $P308 = root_new ['parrot';'Hash']
  vivify_231:
    set $P309, $P308["parent"]
    unless_null $P309, vivify_232
    $P309 = root_new ['parrot';'ResizablePMCArray']
  vivify_232:
    set $P310, $P309[0]
    unless_null $P310, vivify_233
    new $P310, "Undef"
  vivify_233:
    set $S311, $P310
    unless $S311, unless_306
    new $P305, 'String'
    set $P305, $S311
    goto unless_306_end
  unless_306:
.annotate 'line', 469
    find_lex $P314, "$/"
    unless_null $P314, vivify_234
    $P314 = root_new ['parrot';'Hash']
  vivify_234:
    set $P315, $P314["sym"]
    unless_null $P315, vivify_235
    new $P315, "Undef"
  vivify_235:
    set $S316, $P315
    iseq $I317, $S316, "grammar"
    if $I317, if_313
    new $P319, "String"
    assign $P319, ""
    set $P312, $P319
    goto if_313_end
  if_313:
    new $P318, "String"
    assign $P318, "Regex::Cursor"
    set $P312, $P318
  if_313_end:
    set $P305, $P312
  unless_306_end:
    store_lex "$parent", $P305
.annotate 'line', 470
    find_lex $P321, "$parent"
    unless $P321, if_320_end
.annotate 'line', 471
    find_lex $P322, "$classinit"
    get_hll_global $P323, ["PAST"], "Val"
    find_lex $P324, "$parent"
    $P325 = $P323."new"($P324 :named("value"), "parent" :named("named"))
    $P322."push"($P325)
  if_320_end:
.annotate 'line', 473
    find_lex $P327, "$past"
    unless_null $P327, vivify_236
    $P327 = root_new ['parrot';'Hash']
  vivify_236:
    set $P328, $P327["attributes"]
    unless_null $P328, vivify_237
    new $P328, "Undef"
  vivify_237:
    unless $P328, if_326_end
.annotate 'line', 474
    find_lex $P329, "$classinit"
    find_lex $P330, "$past"
    unless_null $P330, vivify_238
    $P330 = root_new ['parrot';'Hash']
  vivify_238:
    set $P331, $P330["attributes"]
    unless_null $P331, vivify_239
    new $P331, "Undef"
  vivify_239:
    $P329."push"($P331)
  if_326_end:
.annotate 'line', 476
    get_global $P332, "@BLOCK"
    unless_null $P332, vivify_240
    $P332 = root_new ['parrot';'ResizablePMCArray']
  vivify_240:
    set $P333, $P332[0]
    unless_null $P333, vivify_241
    new $P333, "Undef"
  vivify_241:
    $P334 = $P333."loadinit"()
    find_lex $P335, "$classinit"
    $P334."push"($P335)
.annotate 'line', 477
    find_lex $P336, "$/"
    find_lex $P337, "$past"
    $P338 = $P336."!make"($P337)
.annotate 'line', 457
    .return ($P338)
  control_288:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P339, exception, "payload"
    .return ($P339)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "OLD_method_def"  :subid("23_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_344
.annotate 'line', 757
    .const 'Sub' $P393 = "25_1295307719.828" 
    capture_lex $P393
    .const 'Sub' $P365 = "24_1295307719.828" 
    capture_lex $P365
    new $P343, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P343, control_342
    push_eh $P343
    .lex "$/", param_344
.annotate 'line', 758
    new $P345, "Undef"
    .lex "$past", $P345
    find_lex $P346, "$/"
    unless_null $P346, vivify_242
    $P346 = root_new ['parrot';'Hash']
  vivify_242:
    set $P347, $P346["blockoid"]
    unless_null $P347, vivify_243
    new $P347, "Undef"
  vivify_243:
    $P348 = $P347."ast"()
    store_lex "$past", $P348
.annotate 'line', 759
    find_lex $P349, "$past"
    $P349."blocktype"("method")
.annotate 'line', 760
    find_dynamic_lex $P351, "$*SCOPE"
    unless_null $P351, vivify_244
    get_hll_global $P351, "$SCOPE"
    unless_null $P351, vivify_245
    die "Contextual $*SCOPE not found"
  vivify_245:
  vivify_244:
    set $S352, $P351
    iseq $I353, $S352, "our"
    unless $I353, if_350_end
.annotate 'line', 761
    find_lex $P354, "$past"
    $P354."pirflags"(":nsentry")
  if_350_end:
.annotate 'line', 763
    find_lex $P355, "$past"
    $P355."control"("return_pir")
.annotate 'line', 764
    find_lex $P356, "$past"
    unless_null $P356, vivify_246
    $P356 = root_new ['parrot';'ResizablePMCArray']
  vivify_246:
    set $P357, $P356[0]
    unless_null $P357, vivify_247
    new $P357, "Undef"
  vivify_247:
    get_hll_global $P358, ["PAST"], "Op"
    $P359 = $P358."new"("    .lex \"self\", self" :named("inline"))
    $P357."unshift"($P359)
.annotate 'line', 765
    find_lex $P360, "$past"
    $P360."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 766
    find_lex $P362, "$/"
    unless_null $P362, vivify_248
    $P362 = root_new ['parrot';'Hash']
  vivify_248:
    set $P363, $P362["deflongname"]
    unless_null $P363, vivify_249
    new $P363, "Undef"
  vivify_249:
    unless $P363, if_361_end
    .const 'Sub' $P365 = "24_1295307719.828" 
    capture_lex $P365
    $P365()
  if_361_end:
.annotate 'line', 770
    find_dynamic_lex $P377, "$*MULTINESS"
    unless_null $P377, vivify_253
    get_hll_global $P377, "$MULTINESS"
    unless_null $P377, vivify_254
    die "Contextual $*MULTINESS not found"
  vivify_254:
  vivify_253:
    set $S378, $P377
    iseq $I379, $S378, "multi"
    unless $I379, if_376_end
    find_lex $P380, "$past"
    $P381 = $P380."multi"()
    $P381."unshift"("_")
  if_376_end:
.annotate 'line', 771
    find_lex $P382, "$past"
    find_lex $P383, "$past"
    unless_null $P383, vivify_255
    $P383 = root_new ['parrot';'Hash']
    store_lex "$past", $P383
  vivify_255:
    set $P383["block_past"], $P382
.annotate 'line', 772
    find_lex $P385, "$/"
    unless_null $P385, vivify_256
    $P385 = root_new ['parrot';'Hash']
  vivify_256:
    set $P386, $P385["trait"]
    unless_null $P386, vivify_257
    new $P386, "Undef"
  vivify_257:
    unless $P386, if_384_end
.annotate 'line', 773
    find_lex $P388, "$/"
    unless_null $P388, vivify_258
    $P388 = root_new ['parrot';'Hash']
  vivify_258:
    set $P389, $P388["trait"]
    unless_null $P389, vivify_259
    new $P389, "Undef"
  vivify_259:
    defined $I390, $P389
    unless $I390, for_undef_260
    iter $P387, $P389
    new $P400, 'ExceptionHandler'
    set_addr $P400, loop399_handler
    $P400."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P400
  loop399_test:
    unless $P387, loop399_done
    shift $P391, $P387
  loop399_redo:
    .const 'Sub' $P393 = "25_1295307719.828" 
    capture_lex $P393
    $P393($P391)
  loop399_next:
    goto loop399_test
  loop399_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P401, exception, 'type'
    eq $P401, .CONTROL_LOOP_NEXT, loop399_next
    eq $P401, .CONTROL_LOOP_REDO, loop399_redo
  loop399_done:
    pop_eh 
  for_undef_260:
  if_384_end:
.annotate 'line', 775
    find_lex $P402, "$/"
    find_lex $P403, "$past"
    $P404 = $P402."!make"($P403)
.annotate 'line', 757
    .return ($P404)
  control_342:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P405, exception, "payload"
    .return ($P405)
.end


.namespace ["NQP";"Actions"]
.sub "_block364"  :anon :subid("24_1295307719.828") :outer("23_1295307719.828")
.annotate 'line', 767
    new $P366, "Undef"
    .lex "$name", $P366
    find_lex $P367, "$/"
    unless_null $P367, vivify_250
    $P367 = root_new ['parrot';'Hash']
  vivify_250:
    set $P368, $P367["deflongname"]
    unless_null $P368, vivify_251
    $P368 = root_new ['parrot';'ResizablePMCArray']
  vivify_251:
    set $P369, $P368[0]
    unless_null $P369, vivify_252
    new $P369, "Undef"
  vivify_252:
    $P370 = $P369."ast"()
    set $S371, $P370
    new $P372, 'String'
    set $P372, $S371
    store_lex "$name", $P372
.annotate 'line', 768
    find_lex $P373, "$past"
    find_lex $P374, "$name"
    $P375 = $P373."name"($P374)
.annotate 'line', 766
    .return ($P375)
.end


.namespace ["NQP";"Actions"]
.sub "_block392"  :anon :subid("25_1295307719.828") :outer("23_1295307719.828")
    .param pmc param_394
.annotate 'line', 773
    .lex "$_", param_394
    find_lex $P395, "$_"
    $P396 = $P395."ast"()
    find_lex $P397, "$/"
    $P398 = $P396($P397)
    .return ($P398)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "only_star_block"  :subid("26_1295307719.828") :outer("11_1295307719.828")
.annotate 'line', 778
    new $P409, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P409, control_408
    push_eh $P409
.annotate 'line', 779
    new $P410, "Undef"
    .lex "$past", $P410
    get_global $P411, "@BLOCK"
    $P412 = $P411."shift"()
    store_lex "$past", $P412
.annotate 'line', 780
    find_lex $P413, "$past"
    $P413."closure"(1)
.annotate 'line', 781
    find_lex $P414, "$past"
    get_hll_global $P415, ["PAST"], "Op"
    $P416 = $P415."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P414."push"($P416)
    find_lex $P417, "$past"
.annotate 'line', 778
    .return ($P417)
  control_408:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P418, exception, "payload"
    .return ($P418)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("27_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_423
.annotate 'line', 787
    .const 'Sub' $P437 = "28_1295307719.828" 
    capture_lex $P437
    new $P422, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P422, control_421
    push_eh $P422
    .lex "$routine", param_423
.annotate 'line', 791
    new $P424, "Undef"
    .lex "$types", $P424
.annotate 'line', 792
    new $P425, "Undef"
    .lex "$definednesses", $P425
.annotate 'line', 791
    get_hll_global $P426, ["PAST"], "Op"
    $P427 = $P426."new"("list" :named("pasttype"))
    store_lex "$types", $P427
.annotate 'line', 792
    get_hll_global $P428, ["PAST"], "Op"
    $P429 = $P428."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P429
.annotate 'line', 793
    find_lex $P431, "$routine"
    unless_null $P431, vivify_261
    $P431 = root_new ['parrot';'ResizablePMCArray']
  vivify_261:
    set $P432, $P431[0]
    unless_null $P432, vivify_262
    new $P432, "Undef"
  vivify_262:
    $P433 = $P432."list"()
    defined $I434, $P433
    unless $I434, for_undef_263
    iter $P430, $P433
    new $P475, 'ExceptionHandler'
    set_addr $P475, loop474_handler
    $P475."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P475
  loop474_test:
    unless $P430, loop474_done
    shift $P435, $P430
  loop474_redo:
    .const 'Sub' $P437 = "28_1295307719.828" 
    capture_lex $P437
    $P437($P435)
  loop474_next:
    goto loop474_test
  loop474_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P476, exception, 'type'
    eq $P476, .CONTROL_LOOP_NEXT, loop474_next
    eq $P476, .CONTROL_LOOP_REDO, loop474_redo
  loop474_done:
    pop_eh 
  for_undef_263:
.annotate 'line', 800
    find_lex $P477, "$routine"
    $P478 = $P477."loadinit"()
    get_hll_global $P479, ["PAST"], "Op"
.annotate 'line', 801
    get_hll_global $P480, ["PAST"], "Var"
    $P481 = $P480."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P482, "$types"
    find_lex $P483, "$definednesses"
    $P484 = $P479."new"($P481, $P482, $P483, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 800
    $P485 = $P478."push"($P484)
.annotate 'line', 787
    .return ($P485)
  control_421:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P486, exception, "payload"
    .return ($P486)
.end


.namespace ["NQP";"Actions"]
.sub "_block436"  :anon :subid("28_1295307719.828") :outer("27_1295307719.828")
    .param pmc param_438
.annotate 'line', 793
    .lex "$_", param_438
.annotate 'line', 794
    get_hll_global $P443, ["PAST"], "Var"
    find_lex $P444, "$_"
    $P445 = $P443."ACCEPTS"($P444)
    if $P445, if_442
    set $P441, $P445
    goto if_442_end
  if_442:
    find_lex $P446, "$_"
    $S447 = $P446."scope"()
    iseq $I448, $S447, "parameter"
    new $P441, 'Integer'
    set $P441, $I448
  if_442_end:
    if $P441, if_440
    set $P439, $P441
    goto if_440_end
  if_440:
.annotate 'line', 795
    find_lex $P449, "$types"
    find_lex $P451, "$_"
    $P452 = $P451."multitype"()
    set $P450, $P452
    defined $I454, $P450
    if $I454, default_453
    get_hll_global $P455, ["PAST"], "Op"
    $P456 = $P455."new"("null P" :named("pirop"))
    set $P450, $P456
  default_453:
    $P449."push"($P450)
.annotate 'line', 796
    find_lex $P457, "$definednesses"
    find_lex $P460, "$_"
    unless_null $P460, vivify_264
    $P460 = root_new ['parrot';'Hash']
  vivify_264:
    set $P461, $P460["definedness"]
    unless_null $P461, vivify_265
    new $P461, "Undef"
  vivify_265:
    set $S462, $P461
    iseq $I463, $S462, "D"
    if $I463, if_459
.annotate 'line', 797
    find_lex $P467, "$_"
    unless_null $P467, vivify_266
    $P467 = root_new ['parrot';'Hash']
  vivify_266:
    set $P468, $P467["definedness"]
    unless_null $P468, vivify_267
    new $P468, "Undef"
  vivify_267:
    set $S469, $P468
    iseq $I470, $S469, "U"
    if $I470, if_466
    new $P472, "Integer"
    assign $P472, 0
    set $P465, $P472
    goto if_466_end
  if_466:
    new $P471, "Integer"
    assign $P471, 2
    set $P465, $P471
  if_466_end:
    set $P458, $P465
.annotate 'line', 796
    goto if_459_end
  if_459:
    new $P464, "Integer"
    assign $P464, 1
    set $P458, $P464
  if_459_end:
    $P473 = $P457."push"($P458)
.annotate 'line', 794
    set $P439, $P473
  if_440_end:
.annotate 'line', 793
    .return ($P439)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "control"  :subid("29_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_491
    .param pmc param_492
.annotate 'line', 1205
    new $P490, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P490, control_489
    push_eh $P490
    .lex "$/", param_491
    .lex "$type", param_492
.annotate 'line', 1206
    find_lex $P493, "$/"
    get_hll_global $P494, ["PAST"], "Op"
    find_lex $P495, "$/"
.annotate 'line', 1210
    get_hll_global $P496, ["PAST"], "Val"
    find_lex $P497, "$type"
    $P498 = $P496."new"($P497 :named("value"), "!except_types" :named("returns"))
    $P499 = $P494."new"(0, $P498, $P495 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1206
    $P500 = $P493."!make"($P499)
.annotate 'line', 1205
    .return ($P500)
  control_489:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P501, exception, "payload"
    .return ($P501)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "TOP"  :subid("30_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_510
    .param pmc param_511
.annotate 'line', 33
    new $P509, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P509, control_508
    push_eh $P509
    .lex "self", param_510
    .lex "$/", param_511
    find_lex $P512, "$/"
    find_lex $P513, "$/"
    unless_null $P513, vivify_268
    $P513 = root_new ['parrot';'Hash']
  vivify_268:
    set $P514, $P513["comp_unit"]
    unless_null $P514, vivify_269
    new $P514, "Undef"
  vivify_269:
    $P515 = $P514."ast"()
    $P516 = $P512."!make"($P515)
    .return ($P516)
  control_508:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P517, exception, "payload"
    .return ($P517)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "deflongname"  :subid("31_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_521
    .param pmc param_522
.annotate 'line', 35
    new $P520, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P520, control_519
    push_eh $P520
    .lex "self", param_521
    .lex "$/", param_522
.annotate 'line', 36
    find_lex $P523, "$/"
.annotate 'line', 37
    find_lex $P526, "$/"
    unless_null $P526, vivify_270
    $P526 = root_new ['parrot';'Hash']
  vivify_270:
    set $P527, $P526["colonpair"]
    unless_null $P527, vivify_271
    new $P527, "Undef"
  vivify_271:
    if $P527, if_525
.annotate 'line', 39
    find_lex $P547, "$/"
    set $S548, $P547
    new $P524, 'String'
    set $P524, $S548
.annotate 'line', 37
    goto if_525_end
  if_525:
    find_lex $P528, "$/"
    unless_null $P528, vivify_272
    $P528 = root_new ['parrot';'Hash']
  vivify_272:
    set $P529, $P528["identifier"]
    unless_null $P529, vivify_273
    new $P529, "Undef"
  vivify_273:
    set $S530, $P529
    new $P531, 'String'
    set $P531, $S530
    concat $P532, $P531, ":"
    find_lex $P533, "$/"
    unless_null $P533, vivify_274
    $P533 = root_new ['parrot';'Hash']
  vivify_274:
    set $P534, $P533["colonpair"]
    unless_null $P534, vivify_275
    $P534 = root_new ['parrot';'ResizablePMCArray']
  vivify_275:
    set $P535, $P534[0]
    unless_null $P535, vivify_276
    new $P535, "Undef"
  vivify_276:
    $P536 = $P535."ast"()
    $S537 = $P536."named"()
    concat $P538, $P532, $S537
    concat $P539, $P538, "<"
.annotate 'line', 38
    find_lex $P540, "$/"
    unless_null $P540, vivify_277
    $P540 = root_new ['parrot';'Hash']
  vivify_277:
    set $P541, $P540["colonpair"]
    unless_null $P541, vivify_278
    $P541 = root_new ['parrot';'ResizablePMCArray']
  vivify_278:
    set $P542, $P541[0]
    unless_null $P542, vivify_279
    new $P542, "Undef"
  vivify_279:
    $P543 = $P542."ast"()
    $S544 = "colonpair_str"($P543)
    concat $P545, $P539, $S544
    concat $P546, $P545, ">"
    set $P524, $P546
  if_525_end:
.annotate 'line', 37
    $P549 = $P523."!make"($P524)
.annotate 'line', 35
    .return ($P549)
  control_519:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P550, exception, "payload"
    .return ($P550)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "comp_unit"  :subid("32_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_555
    .param pmc param_556
.annotate 'line', 49
    new $P554, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P554, control_553
    push_eh $P554
    .lex "self", param_555
    .lex "$/", param_556
.annotate 'line', 50
    new $P557, "Undef"
    .lex "$mainline", $P557
.annotate 'line', 51
    new $P558, "Undef"
    .lex "$unit", $P558
.annotate 'line', 50
    find_lex $P559, "$/"
    unless_null $P559, vivify_280
    $P559 = root_new ['parrot';'Hash']
  vivify_280:
    set $P560, $P559["statementlist"]
    unless_null $P560, vivify_281
    new $P560, "Undef"
  vivify_281:
    $P561 = $P560."ast"()
    store_lex "$mainline", $P561
.annotate 'line', 51
    get_global $P562, "@BLOCK"
    $P563 = $P562."shift"()
    store_lex "$unit", $P563
.annotate 'line', 55
    find_lex $P564, "$unit"
    find_lex $P565, "self"
    $P566 = $P565."CTXSAVE"()
    $P564."push"($P566)
.annotate 'line', 58
    find_lex $P567, "$unit"
    $P567."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 59
    find_lex $P568, "$unit"
    get_hll_global $P569, ["PAST"], "Op"
    $P570 = $P569."new"("nqp_dynop_setup v" :named("pirop"))
    $P568."unshift"($P570)
.annotate 'line', 64
    find_lex $P571, "$unit"
.annotate 'line', 65
    get_hll_global $P572, ["PAST"], "Op"
    find_lex $P573, "$mainline"
    $P574 = $P572."new"($P573, "return" :named("pirop"))
    $P571."push"($P574)
.annotate 'line', 70
    find_lex $P575, "$unit"
.annotate 'line', 71
    get_hll_global $P576, ["PAST"], "Block"
.annotate 'line', 73
    get_hll_global $P577, ["PAST"], "Op"
    get_hll_global $P578, ["PAST"], "Val"
    find_lex $P579, "$unit"
    $P580 = $P578."new"($P579 :named("value"))
    $P581 = $P577."new"($P580, "call" :named("pasttype"))
    $P582 = $P576."new"($P581, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 71
    $P575."push"($P582)
.annotate 'line', 76
    find_lex $P583, "$unit"
    find_lex $P584, "$/"
    $P583."node"($P584)
.annotate 'line', 77
    find_lex $P585, "$/"
    find_lex $P586, "$unit"
    $P587 = $P585."!make"($P586)
.annotate 'line', 49
    .return ($P587)
  control_553:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P588, exception, "payload"
    .return ($P588)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("33_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_592
    .param pmc param_593
.annotate 'line', 80
    .const 'Sub' $P607 = "34_1295307719.828" 
    capture_lex $P607
    new $P591, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P591, control_590
    push_eh $P591
    .lex "self", param_592
    .lex "$/", param_593
.annotate 'line', 81
    new $P594, "Undef"
    .lex "$past", $P594
    get_hll_global $P595, ["PAST"], "Stmts"
    find_lex $P596, "$/"
    $P597 = $P595."new"($P596 :named("node"))
    store_lex "$past", $P597
.annotate 'line', 82
    find_lex $P599, "$/"
    unless_null $P599, vivify_282
    $P599 = root_new ['parrot';'Hash']
  vivify_282:
    set $P600, $P599["statement"]
    unless_null $P600, vivify_283
    new $P600, "Undef"
  vivify_283:
    unless $P600, if_598_end
.annotate 'line', 83
    find_lex $P602, "$/"
    unless_null $P602, vivify_284
    $P602 = root_new ['parrot';'Hash']
  vivify_284:
    set $P603, $P602["statement"]
    unless_null $P603, vivify_285
    new $P603, "Undef"
  vivify_285:
    defined $I604, $P603
    unless $I604, for_undef_286
    iter $P601, $P603
    new $P627, 'ExceptionHandler'
    set_addr $P627, loop626_handler
    $P627."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P627
  loop626_test:
    unless $P601, loop626_done
    shift $P605, $P601
  loop626_redo:
    .const 'Sub' $P607 = "34_1295307719.828" 
    capture_lex $P607
    $P607($P605)
  loop626_next:
    goto loop626_test
  loop626_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P628, exception, 'type'
    eq $P628, .CONTROL_LOOP_NEXT, loop626_next
    eq $P628, .CONTROL_LOOP_REDO, loop626_redo
  loop626_done:
    pop_eh 
  for_undef_286:
  if_598_end:
.annotate 'line', 90
    find_lex $P629, "$/"
    find_lex $P630, "$past"
    $P631 = $P629."!make"($P630)
.annotate 'line', 80
    .return ($P631)
  control_590:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P632, exception, "payload"
    .return ($P632)
.end


.namespace ["NQP";"Actions"]
.sub "_block606"  :anon :subid("34_1295307719.828") :outer("33_1295307719.828")
    .param pmc param_609
.annotate 'line', 84
    new $P608, "Undef"
    .lex "$ast", $P608
    .lex "$_", param_609
    find_lex $P610, "$_"
    $P611 = $P610."ast"()
    store_lex "$ast", $P611
.annotate 'line', 85
    find_lex $P613, "$ast"
    unless_null $P613, vivify_287
    $P613 = root_new ['parrot';'Hash']
  vivify_287:
    set $P614, $P613["sink"]
    unless_null $P614, vivify_288
    new $P614, "Undef"
  vivify_288:
    defined $I615, $P614
    unless $I615, if_612_end
    find_lex $P616, "$ast"
    unless_null $P616, vivify_289
    $P616 = root_new ['parrot';'Hash']
  vivify_289:
    set $P617, $P616["sink"]
    unless_null $P617, vivify_290
    new $P617, "Undef"
  vivify_290:
    store_lex "$ast", $P617
  if_612_end:
.annotate 'line', 86
    find_lex $P619, "$ast"
    unless_null $P619, vivify_291
    $P619 = root_new ['parrot';'Hash']
  vivify_291:
    set $P620, $P619["bareblock"]
    unless_null $P620, vivify_292
    new $P620, "Undef"
  vivify_292:
    unless $P620, if_618_end
    find_lex $P621, "$ast"
    $P622 = "block_immediate"($P621)
    store_lex "$ast", $P622
  if_618_end:
.annotate 'line', 87
    find_lex $P623, "$past"
    find_lex $P624, "$ast"
    $P625 = $P623."push"($P624)
.annotate 'line', 83
    .return ($P625)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement"  :subid("35_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_636
    .param pmc param_637
    .param pmc param_638 :optional
    .param int has_param_638 :opt_flag
.annotate 'line', 93
    .const 'Sub' $P646 = "36_1295307719.828" 
    capture_lex $P646
    new $P635, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P635, control_634
    push_eh $P635
    .lex "self", param_636
    .lex "$/", param_637
    if has_param_638, optparam_293
    new $P639, "Undef"
    set param_638, $P639
  optparam_293:
    .lex "$key", param_638
.annotate 'line', 94
    new $P640, "Undef"
    .lex "$past", $P640
.annotate 'line', 93
    find_lex $P641, "$past"
.annotate 'line', 95
    find_lex $P643, "$/"
    unless_null $P643, vivify_294
    $P643 = root_new ['parrot';'Hash']
  vivify_294:
    set $P644, $P643["EXPR"]
    unless_null $P644, vivify_295
    new $P644, "Undef"
  vivify_295:
    if $P644, if_642
.annotate 'line', 116
    find_lex $P707, "$/"
    unless_null $P707, vivify_296
    $P707 = root_new ['parrot';'Hash']
  vivify_296:
    set $P708, $P707["statement_control"]
    unless_null $P708, vivify_297
    new $P708, "Undef"
  vivify_297:
    if $P708, if_706
.annotate 'line', 117
    new $P712, "Integer"
    assign $P712, 0
    store_lex "$past", $P712
    goto if_706_end
  if_706:
.annotate 'line', 116
    find_lex $P709, "$/"
    unless_null $P709, vivify_298
    $P709 = root_new ['parrot';'Hash']
  vivify_298:
    set $P710, $P709["statement_control"]
    unless_null $P710, vivify_299
    new $P710, "Undef"
  vivify_299:
    $P711 = $P710."ast"()
    store_lex "$past", $P711
  if_706_end:
    goto if_642_end
  if_642:
.annotate 'line', 95
    .const 'Sub' $P646 = "36_1295307719.828" 
    capture_lex $P646
    $P646()
  if_642_end:
.annotate 'line', 118
    find_lex $P713, "$/"
    find_lex $P714, "$past"
    $P715 = $P713."!make"($P714)
.annotate 'line', 93
    .return ($P715)
  control_634:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P716, exception, "payload"
    .return ($P716)
.end


.namespace ["NQP";"Actions"]
.sub "_block645"  :anon :subid("36_1295307719.828") :outer("35_1295307719.828")
.annotate 'line', 96
    new $P647, "Undef"
    .lex "$mc", $P647
.annotate 'line', 97
    new $P648, "Undef"
    .lex "$ml", $P648
.annotate 'line', 96
    find_lex $P649, "$/"
    unless_null $P649, vivify_300
    $P649 = root_new ['parrot';'Hash']
  vivify_300:
    set $P650, $P649["statement_mod_cond"]
    unless_null $P650, vivify_301
    $P650 = root_new ['parrot';'ResizablePMCArray']
  vivify_301:
    set $P651, $P650[0]
    unless_null $P651, vivify_302
    new $P651, "Undef"
  vivify_302:
    store_lex "$mc", $P651
.annotate 'line', 97
    find_lex $P652, "$/"
    unless_null $P652, vivify_303
    $P652 = root_new ['parrot';'Hash']
  vivify_303:
    set $P653, $P652["statement_mod_loop"]
    unless_null $P653, vivify_304
    $P653 = root_new ['parrot';'ResizablePMCArray']
  vivify_304:
    set $P654, $P653[0]
    unless_null $P654, vivify_305
    new $P654, "Undef"
  vivify_305:
    store_lex "$ml", $P654
.annotate 'line', 98
    find_lex $P655, "$/"
    unless_null $P655, vivify_306
    $P655 = root_new ['parrot';'Hash']
  vivify_306:
    set $P656, $P655["EXPR"]
    unless_null $P656, vivify_307
    new $P656, "Undef"
  vivify_307:
    $P657 = $P656."ast"()
    store_lex "$past", $P657
.annotate 'line', 99
    find_lex $P659, "$mc"
    unless $P659, if_658_end
.annotate 'line', 100
    get_hll_global $P660, ["PAST"], "Op"
    find_lex $P661, "$mc"
    unless_null $P661, vivify_308
    $P661 = root_new ['parrot';'Hash']
  vivify_308:
    set $P662, $P661["cond"]
    unless_null $P662, vivify_309
    new $P662, "Undef"
  vivify_309:
    $P663 = $P662."ast"()
    find_lex $P664, "$past"
    find_lex $P665, "$mc"
    unless_null $P665, vivify_310
    $P665 = root_new ['parrot';'Hash']
  vivify_310:
    set $P666, $P665["sym"]
    unless_null $P666, vivify_311
    new $P666, "Undef"
  vivify_311:
    set $S667, $P666
    find_lex $P668, "$/"
    $P669 = $P660."new"($P663, $P664, $S667 :named("pasttype"), $P668 :named("node"))
    store_lex "$past", $P669
  if_658_end:
.annotate 'line', 102
    find_lex $P672, "$ml"
    if $P672, if_671
    set $P670, $P672
    goto if_671_end
  if_671:
.annotate 'line', 103
    find_lex $P675, "$ml"
    unless_null $P675, vivify_312
    $P675 = root_new ['parrot';'Hash']
  vivify_312:
    set $P676, $P675["sym"]
    unless_null $P676, vivify_313
    new $P676, "Undef"
  vivify_313:
    set $S677, $P676
    iseq $I678, $S677, "for"
    if $I678, if_674
.annotate 'line', 112
    get_hll_global $P696, ["PAST"], "Op"
    find_lex $P697, "$ml"
    unless_null $P697, vivify_314
    $P697 = root_new ['parrot';'Hash']
  vivify_314:
    set $P698, $P697["cond"]
    unless_null $P698, vivify_315
    new $P698, "Undef"
  vivify_315:
    $P699 = $P698."ast"()
    find_lex $P700, "$past"
    find_lex $P701, "$ml"
    unless_null $P701, vivify_316
    $P701 = root_new ['parrot';'Hash']
  vivify_316:
    set $P702, $P701["sym"]
    unless_null $P702, vivify_317
    new $P702, "Undef"
  vivify_317:
    set $S703, $P702
    find_lex $P704, "$/"
    $P705 = $P696."new"($P699, $P700, $S703 :named("pasttype"), $P704 :named("node"))
    store_lex "$past", $P705
.annotate 'line', 111
    set $P673, $P705
.annotate 'line', 103
    goto if_674_end
  if_674:
.annotate 'line', 104
    get_hll_global $P679, ["PAST"], "Block"
.annotate 'line', 105
    get_hll_global $P680, ["PAST"], "Var"
    $P681 = $P680."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P682, "$past"
    $P683 = $P679."new"($P681, $P682, "immediate" :named("blocktype"))
.annotate 'line', 104
    store_lex "$past", $P683
.annotate 'line', 107
    find_lex $P684, "$past"
    $P684."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 108
    find_lex $P685, "$past"
    $P685."arity"(1)
.annotate 'line', 109
    get_hll_global $P686, ["PAST"], "Op"
    find_lex $P687, "$ml"
    unless_null $P687, vivify_318
    $P687 = root_new ['parrot';'Hash']
  vivify_318:
    set $P688, $P687["cond"]
    unless_null $P688, vivify_319
    new $P688, "Undef"
  vivify_319:
    $P689 = $P688."ast"()
    find_lex $P690, "$past"
    find_lex $P691, "$ml"
    unless_null $P691, vivify_320
    $P691 = root_new ['parrot';'Hash']
  vivify_320:
    set $P692, $P691["sym"]
    unless_null $P692, vivify_321
    new $P692, "Undef"
  vivify_321:
    set $S693, $P692
    find_lex $P694, "$/"
    $P695 = $P686."new"($P689, $P690, $S693 :named("pasttype"), $P694 :named("node"))
    store_lex "$past", $P695
.annotate 'line', 103
    set $P673, $P695
  if_674_end:
.annotate 'line', 102
    set $P670, $P673
  if_671_end:
.annotate 'line', 95
    .return ($P670)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "xblock"  :subid("37_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_720
    .param pmc param_721
.annotate 'line', 121
    new $P719, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P719, control_718
    push_eh $P719
    .lex "self", param_720
    .lex "$/", param_721
.annotate 'line', 122
    find_lex $P722, "$/"
    get_hll_global $P723, ["PAST"], "Op"
    find_lex $P724, "$/"
    unless_null $P724, vivify_322
    $P724 = root_new ['parrot';'Hash']
  vivify_322:
    set $P725, $P724["EXPR"]
    unless_null $P725, vivify_323
    new $P725, "Undef"
  vivify_323:
    $P726 = $P725."ast"()
    find_lex $P727, "$/"
    unless_null $P727, vivify_324
    $P727 = root_new ['parrot';'Hash']
  vivify_324:
    set $P728, $P727["pblock"]
    unless_null $P728, vivify_325
    new $P728, "Undef"
  vivify_325:
    $P729 = $P728."ast"()
    find_lex $P730, "$/"
    $P731 = $P723."new"($P726, $P729, "if" :named("pasttype"), $P730 :named("node"))
    $P732 = $P722."!make"($P731)
.annotate 'line', 121
    .return ($P732)
  control_718:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P733, exception, "payload"
    .return ($P733)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "pblock"  :subid("38_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_737
    .param pmc param_738
.annotate 'line', 125
    new $P736, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P736, control_735
    push_eh $P736
    .lex "self", param_737
    .lex "$/", param_738
.annotate 'line', 126
    find_lex $P739, "$/"
    find_lex $P740, "$/"
    unless_null $P740, vivify_326
    $P740 = root_new ['parrot';'Hash']
  vivify_326:
    set $P741, $P740["blockoid"]
    unless_null $P741, vivify_327
    new $P741, "Undef"
  vivify_327:
    $P742 = $P741."ast"()
    $P743 = $P739."!make"($P742)
.annotate 'line', 125
    .return ($P743)
  control_735:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P744, exception, "payload"
    .return ($P744)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "block"  :subid("39_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_748
    .param pmc param_749
.annotate 'line', 129
    new $P747, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P747, control_746
    push_eh $P747
    .lex "self", param_748
    .lex "$/", param_749
.annotate 'line', 130
    find_lex $P750, "$/"
    find_lex $P751, "$/"
    unless_null $P751, vivify_328
    $P751 = root_new ['parrot';'Hash']
  vivify_328:
    set $P752, $P751["blockoid"]
    unless_null $P752, vivify_329
    new $P752, "Undef"
  vivify_329:
    $P753 = $P752."ast"()
    $P754 = $P750."!make"($P753)
.annotate 'line', 129
    .return ($P754)
  control_746:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P755, exception, "payload"
    .return ($P755)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "blockoid"  :subid("40_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_759
    .param pmc param_760
.annotate 'line', 133
    new $P758, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P758, control_757
    push_eh $P758
    .lex "self", param_759
    .lex "$/", param_760
.annotate 'line', 134
    new $P761, "Undef"
    .lex "$past", $P761
.annotate 'line', 135
    new $P762, "Undef"
    .lex "$BLOCK", $P762
.annotate 'line', 134
    find_lex $P763, "$/"
    unless_null $P763, vivify_330
    $P763 = root_new ['parrot';'Hash']
  vivify_330:
    set $P764, $P763["statementlist"]
    unless_null $P764, vivify_331
    new $P764, "Undef"
  vivify_331:
    $P765 = $P764."ast"()
    store_lex "$past", $P765
.annotate 'line', 135
    get_global $P766, "@BLOCK"
    $P767 = $P766."shift"()
    store_lex "$BLOCK", $P767
.annotate 'line', 136
    find_lex $P768, "$BLOCK"
    find_lex $P769, "$past"
    $P768."push"($P769)
.annotate 'line', 137
    find_lex $P770, "$BLOCK"
    find_lex $P771, "$/"
    $P770."node"($P771)
.annotate 'line', 138
    find_lex $P772, "$BLOCK"
    $P772."closure"(1)
.annotate 'line', 139
    find_lex $P773, "$/"
    find_lex $P774, "$BLOCK"
    $P775 = $P773."!make"($P774)
.annotate 'line', 133
    .return ($P775)
  control_757:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P776, exception, "payload"
    .return ($P776)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "newpad"  :subid("41_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_780
    .param pmc param_781
.annotate 'line', 142
    new $P779, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P779, control_778
    push_eh $P779
    .lex "self", param_780
    .lex "$/", param_781
.annotate 'line', 143
    get_global $P782, "@BLOCK"
    unless_null $P782, vivify_332
    $P782 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P782
  vivify_332:
.annotate 'line', 142
    get_global $P783, "@BLOCK"
.annotate 'line', 144
    get_global $P784, "@BLOCK"
    get_hll_global $P785, ["PAST"], "Block"
    get_hll_global $P786, ["PAST"], "Stmts"
    $P787 = $P786."new"()
    $P788 = $P785."new"($P787)
    $P789 = $P784."unshift"($P788)
.annotate 'line', 142
    .return ($P789)
  control_778:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P790, exception, "payload"
    .return ($P790)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "outerctx"  :subid("42_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_794
    .param pmc param_795
.annotate 'line', 147
    new $P793, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P793, control_792
    push_eh $P793
    .lex "self", param_794
    .lex "$/", param_795
.annotate 'line', 148
    get_global $P796, "@BLOCK"
    unless_null $P796, vivify_333
    $P796 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P796
  vivify_333:
.annotate 'line', 147
    get_global $P797, "@BLOCK"
.annotate 'line', 149
    find_lex $P798, "self"
    get_global $P799, "@BLOCK"
    unless_null $P799, vivify_334
    $P799 = root_new ['parrot';'ResizablePMCArray']
  vivify_334:
    set $P800, $P799[0]
    unless_null $P800, vivify_335
    new $P800, "Undef"
  vivify_335:
    $P801 = $P798."SET_BLOCK_OUTER_CTX"($P800)
.annotate 'line', 147
    .return ($P801)
  control_792:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P802, exception, "payload"
    .return ($P802)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("43_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_806
    .param pmc param_807
.annotate 'line', 154
    .const 'Sub' $P835 = "44_1295307719.828" 
    capture_lex $P835
    new $P805, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P805, control_804
    push_eh $P805
    .lex "self", param_806
    .lex "$/", param_807
.annotate 'line', 155
    new $P808, "Undef"
    .lex "$count", $P808
.annotate 'line', 156
    new $P809, "Undef"
    .lex "$past", $P809
.annotate 'line', 155
    find_lex $P810, "$/"
    unless_null $P810, vivify_336
    $P810 = root_new ['parrot';'Hash']
  vivify_336:
    set $P811, $P810["xblock"]
    unless_null $P811, vivify_337
    new $P811, "Undef"
  vivify_337:
    set $N812, $P811
    new $P813, 'Float'
    set $P813, $N812
    sub $P814, $P813, 1
    store_lex "$count", $P814
.annotate 'line', 156
    find_lex $P815, "$count"
    set $I816, $P815
    find_lex $P817, "$/"
    unless_null $P817, vivify_338
    $P817 = root_new ['parrot';'Hash']
  vivify_338:
    set $P818, $P817["xblock"]
    unless_null $P818, vivify_339
    $P818 = root_new ['parrot';'ResizablePMCArray']
  vivify_339:
    set $P819, $P818[$I816]
    unless_null $P819, vivify_340
    new $P819, "Undef"
  vivify_340:
    $P820 = $P819."ast"()
    $P821 = "xblock_immediate"($P820)
    store_lex "$past", $P821
.annotate 'line', 157
    find_lex $P823, "$/"
    unless_null $P823, vivify_341
    $P823 = root_new ['parrot';'Hash']
  vivify_341:
    set $P824, $P823["else"]
    unless_null $P824, vivify_342
    new $P824, "Undef"
  vivify_342:
    unless $P824, if_822_end
.annotate 'line', 158
    find_lex $P825, "$past"
    find_lex $P826, "$/"
    unless_null $P826, vivify_343
    $P826 = root_new ['parrot';'Hash']
  vivify_343:
    set $P827, $P826["else"]
    unless_null $P827, vivify_344
    $P827 = root_new ['parrot';'ResizablePMCArray']
  vivify_344:
    set $P828, $P827[0]
    unless_null $P828, vivify_345
    new $P828, "Undef"
  vivify_345:
    $P829 = $P828."ast"()
    $P830 = "block_immediate"($P829)
    $P825."push"($P830)
  if_822_end:
.annotate 'line', 161
    new $P851, 'ExceptionHandler'
    set_addr $P851, loop850_handler
    $P851."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P851
  loop850_test:
    find_lex $P831, "$count"
    set $N832, $P831
    isgt $I833, $N832, 0.0
    unless $I833, loop850_done
  loop850_redo:
    .const 'Sub' $P835 = "44_1295307719.828" 
    capture_lex $P835
    $P835()
  loop850_next:
    goto loop850_test
  loop850_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P852, exception, 'type'
    eq $P852, .CONTROL_LOOP_NEXT, loop850_next
    eq $P852, .CONTROL_LOOP_REDO, loop850_redo
  loop850_done:
    pop_eh 
.annotate 'line', 167
    find_lex $P853, "$/"
    find_lex $P854, "$past"
    $P855 = $P853."!make"($P854)
.annotate 'line', 154
    .return ($P855)
  control_804:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P856, exception, "payload"
    .return ($P856)
.end


.namespace ["NQP";"Actions"]
.sub "_block834"  :anon :subid("44_1295307719.828") :outer("43_1295307719.828")
.annotate 'line', 163
    new $P836, "Undef"
    .lex "$else", $P836
.annotate 'line', 161
    find_lex $P837, "$count"
    clone $P838, $P837
    dec $P837
.annotate 'line', 163
    find_lex $P839, "$past"
    store_lex "$else", $P839
.annotate 'line', 164
    find_lex $P840, "$count"
    set $I841, $P840
    find_lex $P842, "$/"
    unless_null $P842, vivify_346
    $P842 = root_new ['parrot';'Hash']
  vivify_346:
    set $P843, $P842["xblock"]
    unless_null $P843, vivify_347
    $P843 = root_new ['parrot';'ResizablePMCArray']
  vivify_347:
    set $P844, $P843[$I841]
    unless_null $P844, vivify_348
    new $P844, "Undef"
  vivify_348:
    $P845 = $P844."ast"()
    $P846 = "xblock_immediate"($P845)
    store_lex "$past", $P846
.annotate 'line', 165
    find_lex $P847, "$past"
    find_lex $P848, "$else"
    $P849 = $P847."push"($P848)
.annotate 'line', 161
    .return ($P849)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<unless>"  :subid("45_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_860
    .param pmc param_861
.annotate 'line', 170
    new $P859, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P859, control_858
    push_eh $P859
    .lex "self", param_860
    .lex "$/", param_861
.annotate 'line', 171
    new $P862, "Undef"
    .lex "$past", $P862
    find_lex $P863, "$/"
    unless_null $P863, vivify_349
    $P863 = root_new ['parrot';'Hash']
  vivify_349:
    set $P864, $P863["xblock"]
    unless_null $P864, vivify_350
    new $P864, "Undef"
  vivify_350:
    $P865 = $P864."ast"()
    $P866 = "xblock_immediate"($P865)
    store_lex "$past", $P866
.annotate 'line', 172
    find_lex $P867, "$past"
    $P867."pasttype"("unless")
.annotate 'line', 173
    find_lex $P868, "$/"
    find_lex $P869, "$past"
    $P870 = $P868."!make"($P869)
.annotate 'line', 170
    .return ($P870)
  control_858:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P871, exception, "payload"
    .return ($P871)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<while>"  :subid("46_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_875
    .param pmc param_876
.annotate 'line', 176
    new $P874, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P874, control_873
    push_eh $P874
    .lex "self", param_875
    .lex "$/", param_876
.annotate 'line', 177
    new $P877, "Undef"
    .lex "$past", $P877
    find_lex $P878, "$/"
    unless_null $P878, vivify_351
    $P878 = root_new ['parrot';'Hash']
  vivify_351:
    set $P879, $P878["xblock"]
    unless_null $P879, vivify_352
    new $P879, "Undef"
  vivify_352:
    $P880 = $P879."ast"()
    $P881 = "xblock_immediate"($P880)
    store_lex "$past", $P881
.annotate 'line', 178
    find_lex $P882, "$past"
    find_lex $P883, "$/"
    unless_null $P883, vivify_353
    $P883 = root_new ['parrot';'Hash']
  vivify_353:
    set $P884, $P883["sym"]
    unless_null $P884, vivify_354
    new $P884, "Undef"
  vivify_354:
    set $S885, $P884
    $P882."pasttype"($S885)
.annotate 'line', 179
    find_lex $P886, "$/"
    find_lex $P887, "$past"
    $P888 = $P886."!make"($P887)
.annotate 'line', 176
    .return ($P888)
  control_873:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P889, exception, "payload"
    .return ($P889)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<repeat>"  :subid("47_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_893
    .param pmc param_894
.annotate 'line', 182
    new $P892, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P892, control_891
    push_eh $P892
    .lex "self", param_893
    .lex "$/", param_894
.annotate 'line', 183
    new $P895, "Undef"
    .lex "$pasttype", $P895
.annotate 'line', 184
    new $P896, "Undef"
    .lex "$past", $P896
.annotate 'line', 183
    new $P897, "String"
    assign $P897, "repeat_"
    find_lex $P898, "$/"
    unless_null $P898, vivify_355
    $P898 = root_new ['parrot';'Hash']
  vivify_355:
    set $P899, $P898["wu"]
    unless_null $P899, vivify_356
    new $P899, "Undef"
  vivify_356:
    set $S900, $P899
    concat $P901, $P897, $S900
    store_lex "$pasttype", $P901
    find_lex $P902, "$past"
.annotate 'line', 185
    find_lex $P904, "$/"
    unless_null $P904, vivify_357
    $P904 = root_new ['parrot';'Hash']
  vivify_357:
    set $P905, $P904["xblock"]
    unless_null $P905, vivify_358
    new $P905, "Undef"
  vivify_358:
    if $P905, if_903
.annotate 'line', 190
    get_hll_global $P912, ["PAST"], "Op"
    find_lex $P913, "$/"
    unless_null $P913, vivify_359
    $P913 = root_new ['parrot';'Hash']
  vivify_359:
    set $P914, $P913["EXPR"]
    unless_null $P914, vivify_360
    new $P914, "Undef"
  vivify_360:
    $P915 = $P914."ast"()
    find_lex $P916, "$/"
    unless_null $P916, vivify_361
    $P916 = root_new ['parrot';'Hash']
  vivify_361:
    set $P917, $P916["pblock"]
    unless_null $P917, vivify_362
    new $P917, "Undef"
  vivify_362:
    $P918 = $P917."ast"()
    $P919 = "block_immediate"($P918)
    find_lex $P920, "$pasttype"
    find_lex $P921, "$/"
    $P922 = $P912."new"($P915, $P919, $P920 :named("pasttype"), $P921 :named("node"))
    store_lex "$past", $P922
.annotate 'line', 189
    goto if_903_end
  if_903:
.annotate 'line', 186
    find_lex $P906, "$/"
    unless_null $P906, vivify_363
    $P906 = root_new ['parrot';'Hash']
  vivify_363:
    set $P907, $P906["xblock"]
    unless_null $P907, vivify_364
    new $P907, "Undef"
  vivify_364:
    $P908 = $P907."ast"()
    $P909 = "xblock_immediate"($P908)
    store_lex "$past", $P909
.annotate 'line', 187
    find_lex $P910, "$past"
    find_lex $P911, "$pasttype"
    $P910."pasttype"($P911)
  if_903_end:
.annotate 'line', 193
    find_lex $P923, "$/"
    find_lex $P924, "$past"
    $P925 = $P923."!make"($P924)
.annotate 'line', 182
    .return ($P925)
  control_891:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P926, exception, "payload"
    .return ($P926)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<for>"  :subid("48_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_930
    .param pmc param_931
.annotate 'line', 196
    new $P929, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P929, control_928
    push_eh $P929
    .lex "self", param_930
    .lex "$/", param_931
.annotate 'line', 197
    new $P932, "Undef"
    .lex "$past", $P932
.annotate 'line', 199
    new $P933, "Undef"
    .lex "$block", $P933
.annotate 'line', 197
    find_lex $P934, "$/"
    unless_null $P934, vivify_365
    $P934 = root_new ['parrot';'Hash']
  vivify_365:
    set $P935, $P934["xblock"]
    unless_null $P935, vivify_366
    new $P935, "Undef"
  vivify_366:
    $P936 = $P935."ast"()
    store_lex "$past", $P936
.annotate 'line', 198
    find_lex $P937, "$past"
    $P937."pasttype"("for")
.annotate 'line', 199
    find_lex $P938, "$past"
    unless_null $P938, vivify_367
    $P938 = root_new ['parrot';'ResizablePMCArray']
  vivify_367:
    set $P939, $P938[1]
    unless_null $P939, vivify_368
    new $P939, "Undef"
  vivify_368:
    store_lex "$block", $P939
.annotate 'line', 200
    find_lex $P941, "$block"
    $P942 = $P941."arity"()
    if $P942, unless_940_end
.annotate 'line', 201
    find_lex $P943, "$block"
    unless_null $P943, vivify_369
    $P943 = root_new ['parrot';'ResizablePMCArray']
  vivify_369:
    set $P944, $P943[0]
    unless_null $P944, vivify_370
    new $P944, "Undef"
  vivify_370:
    get_hll_global $P945, ["PAST"], "Var"
    $P946 = $P945."new"("$_" :named("name"), "parameter" :named("scope"))
    $P944."push"($P946)
.annotate 'line', 202
    find_lex $P947, "$block"
    $P947."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 203
    find_lex $P948, "$block"
    $P948."arity"(1)
  unless_940_end:
.annotate 'line', 205
    find_lex $P949, "$block"
    $P949."blocktype"("immediate")
.annotate 'line', 206
    find_lex $P950, "$/"
    find_lex $P951, "$past"
    $P952 = $P950."!make"($P951)
.annotate 'line', 196
    .return ($P952)
  control_928:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P953, exception, "payload"
    .return ($P953)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<return>"  :subid("49_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_957
    .param pmc param_958
.annotate 'line', 209
    new $P956, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P956, control_955
    push_eh $P956
    .lex "self", param_957
    .lex "$/", param_958
.annotate 'line', 210
    find_lex $P959, "$/"
    get_hll_global $P960, ["PAST"], "Op"
    find_lex $P961, "$/"
    unless_null $P961, vivify_371
    $P961 = root_new ['parrot';'Hash']
  vivify_371:
    set $P962, $P961["EXPR"]
    unless_null $P962, vivify_372
    new $P962, "Undef"
  vivify_372:
    $P963 = $P962."ast"()
    find_lex $P964, "$/"
    $P965 = $P960."new"($P963, "return" :named("pasttype"), $P964 :named("node"))
    $P966 = $P959."!make"($P965)
.annotate 'line', 209
    .return ($P966)
  control_955:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P967, exception, "payload"
    .return ($P967)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<CATCH>"  :subid("50_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_971
    .param pmc param_972
.annotate 'line', 213
    new $P970, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P970, control_969
    push_eh $P970
    .lex "self", param_971
    .lex "$/", param_972
.annotate 'line', 214
    new $P973, "Undef"
    .lex "$block", $P973
    find_lex $P974, "$/"
    unless_null $P974, vivify_373
    $P974 = root_new ['parrot';'Hash']
  vivify_373:
    set $P975, $P974["block"]
    unless_null $P975, vivify_374
    new $P975, "Undef"
  vivify_374:
    $P976 = $P975."ast"()
    store_lex "$block", $P976
.annotate 'line', 215
    find_lex $P977, "$/"
    find_lex $P978, "$block"
    "push_block_handler"($P977, $P978)
.annotate 'line', 216
    get_global $P979, "@BLOCK"
    unless_null $P979, vivify_375
    $P979 = root_new ['parrot';'ResizablePMCArray']
  vivify_375:
    set $P980, $P979[0]
    unless_null $P980, vivify_376
    new $P980, "Undef"
  vivify_376:
    $P981 = $P980."handlers"()
    set $P982, $P981[0]
    unless_null $P982, vivify_377
    new $P982, "Undef"
  vivify_377:
    $P982."handle_types_except"("CONTROL")
.annotate 'line', 217
    find_lex $P983, "$/"
    get_hll_global $P984, ["PAST"], "Stmts"
    find_lex $P985, "$/"
    $P986 = $P984."new"($P985 :named("node"))
    $P987 = $P983."!make"($P986)
.annotate 'line', 213
    .return ($P987)
  control_969:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P988, exception, "payload"
    .return ($P988)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<CONTROL>"  :subid("51_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_992
    .param pmc param_993
.annotate 'line', 220
    new $P991, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P991, control_990
    push_eh $P991
    .lex "self", param_992
    .lex "$/", param_993
.annotate 'line', 221
    new $P994, "Undef"
    .lex "$block", $P994
    find_lex $P995, "$/"
    unless_null $P995, vivify_378
    $P995 = root_new ['parrot';'Hash']
  vivify_378:
    set $P996, $P995["block"]
    unless_null $P996, vivify_379
    new $P996, "Undef"
  vivify_379:
    $P997 = $P996."ast"()
    store_lex "$block", $P997
.annotate 'line', 222
    find_lex $P998, "$/"
    find_lex $P999, "$block"
    "push_block_handler"($P998, $P999)
.annotate 'line', 223
    get_global $P1000, "@BLOCK"
    unless_null $P1000, vivify_380
    $P1000 = root_new ['parrot';'ResizablePMCArray']
  vivify_380:
    set $P1001, $P1000[0]
    unless_null $P1001, vivify_381
    new $P1001, "Undef"
  vivify_381:
    $P1002 = $P1001."handlers"()
    set $P1003, $P1002[0]
    unless_null $P1003, vivify_382
    new $P1003, "Undef"
  vivify_382:
    $P1003."handle_types"("CONTROL")
.annotate 'line', 224
    find_lex $P1004, "$/"
    get_hll_global $P1005, ["PAST"], "Stmts"
    find_lex $P1006, "$/"
    $P1007 = $P1005."new"($P1006 :named("node"))
    $P1008 = $P1004."!make"($P1007)
.annotate 'line', 220
    .return ($P1008)
  control_990:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1009, exception, "payload"
    .return ($P1009)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_prefix:sym<INIT>"  :subid("52_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1014
    .param pmc param_1015
.annotate 'line', 264
    new $P1013, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1013, control_1012
    push_eh $P1013
    .lex "self", param_1014
    .lex "$/", param_1015
.annotate 'line', 265
    get_global $P1016, "@BLOCK"
    unless_null $P1016, vivify_383
    $P1016 = root_new ['parrot';'ResizablePMCArray']
  vivify_383:
    set $P1017, $P1016[0]
    unless_null $P1017, vivify_384
    new $P1017, "Undef"
  vivify_384:
    $P1018 = $P1017."loadinit"()
    find_lex $P1019, "$/"
    unless_null $P1019, vivify_385
    $P1019 = root_new ['parrot';'Hash']
  vivify_385:
    set $P1020, $P1019["blorst"]
    unless_null $P1020, vivify_386
    new $P1020, "Undef"
  vivify_386:
    $P1021 = $P1020."ast"()
    $P1018."push"($P1021)
.annotate 'line', 266
    find_lex $P1022, "$/"
    get_hll_global $P1023, ["PAST"], "Stmts"
    find_lex $P1024, "$/"
    $P1025 = $P1023."new"($P1024 :named("node"))
    $P1026 = $P1022."!make"($P1025)
.annotate 'line', 264
    .return ($P1026)
  control_1012:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1027, exception, "payload"
    .return ($P1027)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_prefix:sym<try>"  :subid("53_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1031
    .param pmc param_1032
.annotate 'line', 269
    new $P1030, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1030, control_1029
    push_eh $P1030
    .lex "self", param_1031
    .lex "$/", param_1032
.annotate 'line', 270
    new $P1033, "Undef"
    .lex "$past", $P1033
    find_lex $P1034, "$/"
    unless_null $P1034, vivify_387
    $P1034 = root_new ['parrot';'Hash']
  vivify_387:
    set $P1035, $P1034["blorst"]
    unless_null $P1035, vivify_388
    new $P1035, "Undef"
  vivify_388:
    $P1036 = $P1035."ast"()
    store_lex "$past", $P1036
.annotate 'line', 271
    get_hll_global $P1038, ["PAST"], "Block"
    find_lex $P1039, "$past"
    $P1040 = $P1038."ACCEPTS"($P1039)
    if $P1040, unless_1037_end
.annotate 'line', 272
    get_hll_global $P1041, ["PAST"], "Block"
    find_lex $P1042, "$past"
    find_lex $P1043, "$/"
    $P1044 = $P1041."new"($P1042, "immediate" :named("blocktype"), $P1043 :named("node"))
    store_lex "$past", $P1044
  unless_1037_end:
.annotate 'line', 274
    find_lex $P1046, "$past"
    $P1047 = $P1046."handlers"()
    if $P1047, unless_1045_end
.annotate 'line', 275
    find_lex $P1048, "$past"
    get_hll_global $P1049, ["PAST"], "Control"
.annotate 'line', 277
    get_hll_global $P1050, ["PAST"], "Stmts"
.annotate 'line', 278
    get_hll_global $P1051, ["PAST"], "Op"
.annotate 'line', 279
    get_hll_global $P1052, ["PAST"], "Var"
.annotate 'line', 280
    get_hll_global $P1053, ["PAST"], "Var"
    $P1054 = $P1053."new"("register" :named("scope"), "exception" :named("name"))
    $P1055 = $P1052."new"($P1054, "handled", "keyed" :named("scope"))
.annotate 'line', 279
    $P1056 = $P1051."new"($P1055, 1, "bind" :named("pasttype"))
.annotate 'line', 278
    $P1057 = $P1050."new"($P1056)
.annotate 'line', 277
    $P1058 = $P1049."new"($P1057, "CONTROL" :named("handle_types_except"))
.annotate 'line', 275
    new $P1059, "ResizablePMCArray"
    push $P1059, $P1058
    $P1048."handlers"($P1059)
  unless_1045_end:
.annotate 'line', 289
    find_lex $P1060, "$/"
    find_lex $P1061, "$past"
    $P1062 = $P1060."!make"($P1061)
.annotate 'line', 269
    .return ($P1062)
  control_1029:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1063, exception, "payload"
    .return ($P1063)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "blorst"  :subid("54_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1067
    .param pmc param_1068
.annotate 'line', 292
    new $P1066, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1066, control_1065
    push_eh $P1066
    .lex "self", param_1067
    .lex "$/", param_1068
.annotate 'line', 293
    find_lex $P1069, "$/"
.annotate 'line', 294
    find_lex $P1072, "$/"
    unless_null $P1072, vivify_389
    $P1072 = root_new ['parrot';'Hash']
  vivify_389:
    set $P1073, $P1072["block"]
    unless_null $P1073, vivify_390
    new $P1073, "Undef"
  vivify_390:
    if $P1073, if_1071
.annotate 'line', 295
    find_lex $P1078, "$/"
    unless_null $P1078, vivify_391
    $P1078 = root_new ['parrot';'Hash']
  vivify_391:
    set $P1079, $P1078["statement"]
    unless_null $P1079, vivify_392
    new $P1079, "Undef"
  vivify_392:
    $P1080 = $P1079."ast"()
    set $P1070, $P1080
.annotate 'line', 294
    goto if_1071_end
  if_1071:
    find_lex $P1074, "$/"
    unless_null $P1074, vivify_393
    $P1074 = root_new ['parrot';'Hash']
  vivify_393:
    set $P1075, $P1074["block"]
    unless_null $P1075, vivify_394
    new $P1075, "Undef"
  vivify_394:
    $P1076 = $P1075."ast"()
    $P1077 = "block_immediate"($P1076)
    set $P1070, $P1077
  if_1071_end:
    $P1081 = $P1069."!make"($P1070)
.annotate 'line', 292
    .return ($P1081)
  control_1065:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1082, exception, "payload"
    .return ($P1082)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_mod_cond:sym<if>"  :subid("55_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1086
    .param pmc param_1087
.annotate 'line', 300
    new $P1085, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1085, control_1084
    push_eh $P1085
    .lex "self", param_1086
    .lex "$/", param_1087
    find_lex $P1088, "$/"
    find_lex $P1089, "$/"
    unless_null $P1089, vivify_395
    $P1089 = root_new ['parrot';'Hash']
  vivify_395:
    set $P1090, $P1089["cond"]
    unless_null $P1090, vivify_396
    new $P1090, "Undef"
  vivify_396:
    $P1091 = $P1090."ast"()
    $P1092 = $P1088."!make"($P1091)
    .return ($P1092)
  control_1084:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1093, exception, "payload"
    .return ($P1093)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_mod_cond:sym<unless>"  :subid("56_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1097
    .param pmc param_1098
.annotate 'line', 301
    new $P1096, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1096, control_1095
    push_eh $P1096
    .lex "self", param_1097
    .lex "$/", param_1098
    find_lex $P1099, "$/"
    find_lex $P1100, "$/"
    unless_null $P1100, vivify_397
    $P1100 = root_new ['parrot';'Hash']
  vivify_397:
    set $P1101, $P1100["cond"]
    unless_null $P1101, vivify_398
    new $P1101, "Undef"
  vivify_398:
    $P1102 = $P1101."ast"()
    $P1103 = $P1099."!make"($P1102)
    .return ($P1103)
  control_1095:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1104, exception, "payload"
    .return ($P1104)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_mod_loop:sym<while>"  :subid("57_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1108
    .param pmc param_1109
.annotate 'line', 303
    new $P1107, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1107, control_1106
    push_eh $P1107
    .lex "self", param_1108
    .lex "$/", param_1109
    find_lex $P1110, "$/"
    find_lex $P1111, "$/"
    unless_null $P1111, vivify_399
    $P1111 = root_new ['parrot';'Hash']
  vivify_399:
    set $P1112, $P1111["cond"]
    unless_null $P1112, vivify_400
    new $P1112, "Undef"
  vivify_400:
    $P1113 = $P1112."ast"()
    $P1114 = $P1110."!make"($P1113)
    .return ($P1114)
  control_1106:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1115, exception, "payload"
    .return ($P1115)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_mod_loop:sym<until>"  :subid("58_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1119
    .param pmc param_1120
.annotate 'line', 304
    new $P1118, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1118, control_1117
    push_eh $P1118
    .lex "self", param_1119
    .lex "$/", param_1120
    find_lex $P1121, "$/"
    find_lex $P1122, "$/"
    unless_null $P1122, vivify_401
    $P1122 = root_new ['parrot';'Hash']
  vivify_401:
    set $P1123, $P1122["cond"]
    unless_null $P1123, vivify_402
    new $P1123, "Undef"
  vivify_402:
    $P1124 = $P1123."ast"()
    $P1125 = $P1121."!make"($P1124)
    .return ($P1125)
  control_1117:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1126, exception, "payload"
    .return ($P1126)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<fatarrow>"  :subid("59_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1130
    .param pmc param_1131
.annotate 'line', 308
    new $P1129, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1129, control_1128
    push_eh $P1129
    .lex "self", param_1130
    .lex "$/", param_1131
    find_lex $P1132, "$/"
    find_lex $P1133, "$/"
    unless_null $P1133, vivify_403
    $P1133 = root_new ['parrot';'Hash']
  vivify_403:
    set $P1134, $P1133["fatarrow"]
    unless_null $P1134, vivify_404
    new $P1134, "Undef"
  vivify_404:
    $P1135 = $P1134."ast"()
    $P1136 = $P1132."!make"($P1135)
    .return ($P1136)
  control_1128:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1137, exception, "payload"
    .return ($P1137)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<colonpair>"  :subid("60_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1141
    .param pmc param_1142
.annotate 'line', 309
    new $P1140, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1140, control_1139
    push_eh $P1140
    .lex "self", param_1141
    .lex "$/", param_1142
    find_lex $P1143, "$/"
    find_lex $P1144, "$/"
    unless_null $P1144, vivify_405
    $P1144 = root_new ['parrot';'Hash']
  vivify_405:
    set $P1145, $P1144["colonpair"]
    unless_null $P1145, vivify_406
    new $P1145, "Undef"
  vivify_406:
    $P1146 = $P1145."ast"()
    $P1147 = $P1143."!make"($P1146)
    .return ($P1147)
  control_1139:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1148, exception, "payload"
    .return ($P1148)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<variable>"  :subid("61_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1152
    .param pmc param_1153
.annotate 'line', 310
    new $P1151, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1151, control_1150
    push_eh $P1151
    .lex "self", param_1152
    .lex "$/", param_1153
    find_lex $P1154, "$/"
    find_lex $P1155, "$/"
    unless_null $P1155, vivify_407
    $P1155 = root_new ['parrot';'Hash']
  vivify_407:
    set $P1156, $P1155["variable"]
    unless_null $P1156, vivify_408
    new $P1156, "Undef"
  vivify_408:
    $P1157 = $P1156."ast"()
    $P1158 = $P1154."!make"($P1157)
    .return ($P1158)
  control_1150:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1159, exception, "payload"
    .return ($P1159)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<package_declarator>"  :subid("62_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1163
    .param pmc param_1164
.annotate 'line', 311
    new $P1162, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1162, control_1161
    push_eh $P1162
    .lex "self", param_1163
    .lex "$/", param_1164
    find_lex $P1165, "$/"
    find_lex $P1166, "$/"
    unless_null $P1166, vivify_409
    $P1166 = root_new ['parrot';'Hash']
  vivify_409:
    set $P1167, $P1166["package_declarator"]
    unless_null $P1167, vivify_410
    new $P1167, "Undef"
  vivify_410:
    $P1168 = $P1167."ast"()
    $P1169 = $P1165."!make"($P1168)
    .return ($P1169)
  control_1161:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1170, exception, "payload"
    .return ($P1170)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<scope_declarator>"  :subid("63_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1174
    .param pmc param_1175
.annotate 'line', 312
    new $P1173, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1173, control_1172
    push_eh $P1173
    .lex "self", param_1174
    .lex "$/", param_1175
    find_lex $P1176, "$/"
    find_lex $P1177, "$/"
    unless_null $P1177, vivify_411
    $P1177 = root_new ['parrot';'Hash']
  vivify_411:
    set $P1178, $P1177["scope_declarator"]
    unless_null $P1178, vivify_412
    new $P1178, "Undef"
  vivify_412:
    $P1179 = $P1178."ast"()
    $P1180 = $P1176."!make"($P1179)
    .return ($P1180)
  control_1172:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1181, exception, "payload"
    .return ($P1181)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<routine_declarator>"  :subid("64_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1185
    .param pmc param_1186
.annotate 'line', 313
    new $P1184, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1184, control_1183
    push_eh $P1184
    .lex "self", param_1185
    .lex "$/", param_1186
    find_lex $P1187, "$/"
    find_lex $P1188, "$/"
    unless_null $P1188, vivify_413
    $P1188 = root_new ['parrot';'Hash']
  vivify_413:
    set $P1189, $P1188["routine_declarator"]
    unless_null $P1189, vivify_414
    new $P1189, "Undef"
  vivify_414:
    $P1190 = $P1189."ast"()
    $P1191 = $P1187."!make"($P1190)
    .return ($P1191)
  control_1183:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1192, exception, "payload"
    .return ($P1192)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<regex_declarator>"  :subid("65_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1196
    .param pmc param_1197
.annotate 'line', 314
    new $P1195, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1195, control_1194
    push_eh $P1195
    .lex "self", param_1196
    .lex "$/", param_1197
    find_lex $P1198, "$/"
    find_lex $P1199, "$/"
    unless_null $P1199, vivify_415
    $P1199 = root_new ['parrot';'Hash']
  vivify_415:
    set $P1200, $P1199["regex_declarator"]
    unless_null $P1200, vivify_416
    new $P1200, "Undef"
  vivify_416:
    $P1201 = $P1200."ast"()
    $P1202 = $P1198."!make"($P1201)
    .return ($P1202)
  control_1194:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1203, exception, "payload"
    .return ($P1203)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<statement_prefix>"  :subid("66_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1207
    .param pmc param_1208
.annotate 'line', 315
    new $P1206, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1206, control_1205
    push_eh $P1206
    .lex "self", param_1207
    .lex "$/", param_1208
    find_lex $P1209, "$/"
    find_lex $P1210, "$/"
    unless_null $P1210, vivify_417
    $P1210 = root_new ['parrot';'Hash']
  vivify_417:
    set $P1211, $P1210["statement_prefix"]
    unless_null $P1211, vivify_418
    new $P1211, "Undef"
  vivify_418:
    $P1212 = $P1211."ast"()
    $P1213 = $P1209."!make"($P1212)
    .return ($P1213)
  control_1205:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1214, exception, "payload"
    .return ($P1214)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<lambda>"  :subid("67_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1218
    .param pmc param_1219
.annotate 'line', 316
    new $P1217, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1217, control_1216
    push_eh $P1217
    .lex "self", param_1218
    .lex "$/", param_1219
    find_lex $P1220, "$/"
    find_lex $P1221, "$/"
    unless_null $P1221, vivify_419
    $P1221 = root_new ['parrot';'Hash']
  vivify_419:
    set $P1222, $P1221["pblock"]
    unless_null $P1222, vivify_420
    new $P1222, "Undef"
  vivify_420:
    $P1223 = $P1222."ast"()
    $P1224 = $P1220."!make"($P1223)
    .return ($P1224)
  control_1216:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1225, exception, "payload"
    .return ($P1225)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "fatarrow"  :subid("68_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1229
    .param pmc param_1230
.annotate 'line', 318
    new $P1228, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1228, control_1227
    push_eh $P1228
    .lex "self", param_1229
    .lex "$/", param_1230
.annotate 'line', 319
    new $P1231, "Undef"
    .lex "$past", $P1231
    find_lex $P1232, "$/"
    unless_null $P1232, vivify_421
    $P1232 = root_new ['parrot';'Hash']
  vivify_421:
    set $P1233, $P1232["val"]
    unless_null $P1233, vivify_422
    new $P1233, "Undef"
  vivify_422:
    $P1234 = $P1233."ast"()
    store_lex "$past", $P1234
.annotate 'line', 320
    find_lex $P1235, "$past"
    find_lex $P1236, "$/"
    unless_null $P1236, vivify_423
    $P1236 = root_new ['parrot';'Hash']
  vivify_423:
    set $P1237, $P1236["key"]
    unless_null $P1237, vivify_424
    new $P1237, "Undef"
  vivify_424:
    $P1238 = $P1237."Str"()
    $P1235."named"($P1238)
.annotate 'line', 321
    find_lex $P1239, "$/"
    find_lex $P1240, "$past"
    $P1241 = $P1239."!make"($P1240)
.annotate 'line', 318
    .return ($P1241)
  control_1227:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1242, exception, "payload"
    .return ($P1242)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "colonpair"  :subid("69_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1246
    .param pmc param_1247
.annotate 'line', 324
    new $P1245, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1245, control_1244
    push_eh $P1245
    .lex "self", param_1246
    .lex "$/", param_1247
.annotate 'line', 325
    new $P1248, "Undef"
    .lex "$past", $P1248
.annotate 'line', 326
    find_lex $P1251, "$/"
    unless_null $P1251, vivify_425
    $P1251 = root_new ['parrot';'Hash']
  vivify_425:
    set $P1252, $P1251["circumfix"]
    unless_null $P1252, vivify_426
    new $P1252, "Undef"
  vivify_426:
    if $P1252, if_1250
.annotate 'line', 327
    get_hll_global $P1257, ["PAST"], "Val"
    find_lex $P1258, "$/"
    unless_null $P1258, vivify_427
    $P1258 = root_new ['parrot';'Hash']
  vivify_427:
    set $P1259, $P1258["not"]
    unless_null $P1259, vivify_428
    new $P1259, "Undef"
  vivify_428:
    isfalse $I1260, $P1259
    $P1261 = $P1257."new"($I1260 :named("value"))
    set $P1249, $P1261
.annotate 'line', 326
    goto if_1250_end
  if_1250:
    find_lex $P1253, "$/"
    unless_null $P1253, vivify_429
    $P1253 = root_new ['parrot';'Hash']
  vivify_429:
    set $P1254, $P1253["circumfix"]
    unless_null $P1254, vivify_430
    $P1254 = root_new ['parrot';'ResizablePMCArray']
  vivify_430:
    set $P1255, $P1254[0]
    unless_null $P1255, vivify_431
    new $P1255, "Undef"
  vivify_431:
    $P1256 = $P1255."ast"()
    set $P1249, $P1256
  if_1250_end:
    store_lex "$past", $P1249
.annotate 'line', 328
    find_lex $P1262, "$past"
    find_lex $P1263, "$/"
    unless_null $P1263, vivify_432
    $P1263 = root_new ['parrot';'Hash']
  vivify_432:
    set $P1264, $P1263["identifier"]
    unless_null $P1264, vivify_433
    new $P1264, "Undef"
  vivify_433:
    set $S1265, $P1264
    $P1262."named"($S1265)
.annotate 'line', 329
    find_lex $P1266, "$/"
    find_lex $P1267, "$past"
    $P1268 = $P1266."!make"($P1267)
.annotate 'line', 324
    .return ($P1268)
  control_1244:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1269, exception, "payload"
    .return ($P1269)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "variable"  :subid("70_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1273
    .param pmc param_1274
.annotate 'line', 332
    .const 'Sub' $P1287 = "71_1295307719.828" 
    capture_lex $P1287
    new $P1272, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1272, control_1271
    push_eh $P1272
    .lex "self", param_1273
    .lex "$/", param_1274
.annotate 'line', 333
    new $P1275, "Undef"
    .lex "$past", $P1275
.annotate 'line', 332
    find_lex $P1276, "$past"
.annotate 'line', 334
    find_lex $P1278, "$/"
    unless_null $P1278, vivify_434
    $P1278 = root_new ['parrot';'Hash']
  vivify_434:
    set $P1279, $P1278["postcircumfix"]
    unless_null $P1279, vivify_435
    new $P1279, "Undef"
  vivify_435:
    if $P1279, if_1277
.annotate 'line', 338
    .const 'Sub' $P1287 = "71_1295307719.828" 
    capture_lex $P1287
    $P1287()
    goto if_1277_end
  if_1277:
.annotate 'line', 335
    find_lex $P1280, "$/"
    unless_null $P1280, vivify_454
    $P1280 = root_new ['parrot';'Hash']
  vivify_454:
    set $P1281, $P1280["postcircumfix"]
    unless_null $P1281, vivify_455
    new $P1281, "Undef"
  vivify_455:
    $P1282 = $P1281."ast"()
    store_lex "$past", $P1282
.annotate 'line', 336
    find_lex $P1283, "$past"
    get_hll_global $P1284, ["PAST"], "Var"
    $P1285 = $P1284."new"("$/" :named("name"))
    $P1283."unshift"($P1285)
  if_1277_end:
.annotate 'line', 372
    find_lex $P1362, "$/"
    find_lex $P1363, "$past"
    $P1364 = $P1362."!make"($P1363)
.annotate 'line', 332
    .return ($P1364)
  control_1271:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1365, exception, "payload"
    .return ($P1365)
.end


.namespace ["NQP";"Actions"]
.sub "_block1286"  :anon :subid("71_1295307719.828") :outer("70_1295307719.828")
.annotate 'line', 339
    $P1288 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P1288
    get_hll_global $P1289, ["NQP"], "Compiler"
    find_lex $P1290, "$/"
    set $S1291, $P1290
    $P1292 = $P1289."parse_name"($S1291)
    store_lex "@name", $P1292
.annotate 'line', 340
    get_hll_global $P1293, ["PAST"], "Var"
    find_lex $P1294, "@name"
    $P1295 = $P1294."pop"()
    set $S1296, $P1295
    $P1297 = $P1293."new"($S1296 :named("name"))
    store_lex "$past", $P1297
.annotate 'line', 341
    find_lex $P1299, "@name"
    unless $P1299, if_1298_end
.annotate 'line', 342
    find_lex $P1301, "@name"
    unless_null $P1301, vivify_436
    $P1301 = root_new ['parrot';'ResizablePMCArray']
  vivify_436:
    set $P1302, $P1301[0]
    unless_null $P1302, vivify_437
    new $P1302, "Undef"
  vivify_437:
    set $S1303, $P1302
    iseq $I1304, $S1303, "GLOBAL"
    unless $I1304, if_1300_end
    find_lex $P1305, "@name"
    $P1305."shift"()
  if_1300_end:
.annotate 'line', 343
    find_lex $P1306, "$past"
    find_lex $P1307, "@name"
    $P1306."namespace"($P1307)
.annotate 'line', 344
    find_lex $P1308, "$past"
    $P1308."scope"("package")
.annotate 'line', 345
    find_lex $P1309, "$past"
    find_lex $P1310, "$/"
    unless_null $P1310, vivify_438
    $P1310 = root_new ['parrot';'Hash']
  vivify_438:
    set $P1311, $P1310["sigil"]
    unless_null $P1311, vivify_439
    new $P1311, "Undef"
  vivify_439:
    $P1312 = "vivitype"($P1311)
    $P1309."viviself"($P1312)
.annotate 'line', 346
    find_lex $P1313, "$past"
    $P1313."lvalue"(1)
  if_1298_end:
.annotate 'line', 348
    find_lex $P1316, "$/"
    unless_null $P1316, vivify_440
    $P1316 = root_new ['parrot';'Hash']
  vivify_440:
    set $P1317, $P1316["twigil"]
    unless_null $P1317, vivify_441
    $P1317 = root_new ['parrot';'ResizablePMCArray']
  vivify_441:
    set $P1318, $P1317[0]
    unless_null $P1318, vivify_442
    new $P1318, "Undef"
  vivify_442:
    set $S1319, $P1318
    iseq $I1320, $S1319, "*"
    if $I1320, if_1315
.annotate 'line', 361
    find_lex $P1342, "$/"
    unless_null $P1342, vivify_443
    $P1342 = root_new ['parrot';'Hash']
  vivify_443:
    set $P1343, $P1342["twigil"]
    unless_null $P1343, vivify_444
    $P1343 = root_new ['parrot';'ResizablePMCArray']
  vivify_444:
    set $P1344, $P1343[0]
    unless_null $P1344, vivify_445
    new $P1344, "Undef"
  vivify_445:
    set $S1345, $P1344
    iseq $I1346, $S1345, "!"
    if $I1346, if_1341
    new $P1340, 'Integer'
    set $P1340, $I1346
    goto if_1341_end
  if_1341:
.annotate 'line', 362
    find_lex $P1347, "$past"
    get_hll_global $P1348, ["PAST"], "Var"
    $P1349 = $P1348."new"("self" :named("name"))
    $P1347."push"($P1349)
.annotate 'line', 363
    find_lex $P1350, "$past"
    $P1350."scope"("attribute")
.annotate 'line', 364
    find_lex $P1351, "$past"
    find_lex $P1352, "$/"
    unless_null $P1352, vivify_446
    $P1352 = root_new ['parrot';'Hash']
  vivify_446:
    set $P1353, $P1352["sigil"]
    unless_null $P1353, vivify_447
    new $P1353, "Undef"
  vivify_447:
    $P1354 = "vivitype"($P1353)
    $P1351."viviself"($P1354)
.annotate 'line', 365
    find_dynamic_lex $P1357, "$*PACKAGE-SETUP"
    unless_null $P1357, vivify_448
    get_hll_global $P1357, "$PACKAGE-SETUP"
    unless_null $P1357, vivify_449
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_449:
  vivify_448:
    if $P1357, if_1356
    set $P1355, $P1357
    goto if_1356_end
  if_1356:
.annotate 'line', 368
    find_lex $P1358, "$past"
    get_hll_global $P1359, ["PAST"], "Var"
    $P1360 = $P1359."new"("$?CLASS" :named("name"))
    $P1361 = $P1358."push"($P1360)
.annotate 'line', 365
    set $P1355, $P1361
  if_1356_end:
.annotate 'line', 361
    set $P1340, $P1355
  if_1341_end:
    set $P1314, $P1340
.annotate 'line', 348
    goto if_1315_end
  if_1315:
.annotate 'line', 349
    find_lex $P1321, "$past"
    $P1321."scope"("contextual")
.annotate 'line', 350
    find_lex $P1322, "$past"
.annotate 'line', 351
    get_hll_global $P1323, ["PAST"], "Var"
.annotate 'line', 353
    find_lex $P1324, "$/"
    unless_null $P1324, vivify_450
    $P1324 = root_new ['parrot';'Hash']
  vivify_450:
    set $P1325, $P1324["sigil"]
    unless_null $P1325, vivify_451
    new $P1325, "Undef"
  vivify_451:
    set $S1326, $P1325
    new $P1327, 'String'
    set $P1327, $S1326
    find_lex $P1328, "$/"
    unless_null $P1328, vivify_452
    $P1328 = root_new ['parrot';'Hash']
  vivify_452:
    set $P1329, $P1328["desigilname"]
    unless_null $P1329, vivify_453
    new $P1329, "Undef"
  vivify_453:
    concat $P1330, $P1327, $P1329
.annotate 'line', 355
    get_hll_global $P1331, ["PAST"], "Op"
    new $P1332, "String"
    assign $P1332, "Contextual "
    find_lex $P1333, "$/"
    set $S1334, $P1333
    concat $P1335, $P1332, $S1334
    concat $P1336, $P1335, " not found"
    $P1337 = $P1331."new"($P1336, "die" :named("pirop"))
    $P1338 = $P1323."new"("package" :named("scope"), "" :named("namespace"), $P1330 :named("name"), $P1337 :named("viviself"))
.annotate 'line', 351
    $P1339 = $P1322."viviself"($P1338)
.annotate 'line', 348
    set $P1314, $P1339
  if_1315_end:
.annotate 'line', 338
    .return ($P1314)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_declarator:sym<module>"  :subid("72_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1369
    .param pmc param_1370
.annotate 'line', 375
    new $P1368, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1368, control_1367
    push_eh $P1368
    .lex "self", param_1369
    .lex "$/", param_1370
    find_lex $P1371, "$/"
    find_lex $P1372, "$/"
    unless_null $P1372, vivify_456
    $P1372 = root_new ['parrot';'Hash']
  vivify_456:
    set $P1373, $P1372["package_def"]
    unless_null $P1373, vivify_457
    new $P1373, "Undef"
  vivify_457:
    $P1374 = $P1373."ast"()
    $P1375 = $P1371."!make"($P1374)
    .return ($P1375)
  control_1367:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1376, exception, "payload"
    .return ($P1376)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_declarator:sym<knowhow>"  :subid("73_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1380
    .param pmc param_1381
.annotate 'line', 376
    new $P1379, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1379, control_1378
    push_eh $P1379
    .lex "self", param_1380
    .lex "$/", param_1381
    find_lex $P1382, "$/"
    find_lex $P1383, "$/"
    $P1384 = "package"($P1383)
    $P1385 = $P1382."!make"($P1384)
    .return ($P1385)
  control_1378:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1386, exception, "payload"
    .return ($P1386)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_declarator:sym<class>"  :subid("74_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1390
    .param pmc param_1391
.annotate 'line', 377
    new $P1389, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1389, control_1388
    push_eh $P1389
    .lex "self", param_1390
    .lex "$/", param_1391
    find_lex $P1392, "$/"
    find_lex $P1393, "$/"
    $P1394 = "package"($P1393)
    $P1395 = $P1392."!make"($P1394)
    .return ($P1395)
  control_1388:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1396, exception, "payload"
    .return ($P1396)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_declarator:sym<grammar>"  :subid("75_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1400
    .param pmc param_1401
.annotate 'line', 378
    new $P1399, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1399, control_1398
    push_eh $P1399
    .lex "self", param_1400
    .lex "$/", param_1401
    find_lex $P1402, "$/"
    find_lex $P1403, "$/"
    $P1404 = "old_package"($P1403)
    $P1405 = $P1402."!make"($P1404)
    .return ($P1405)
  control_1398:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1406, exception, "payload"
    .return ($P1406)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_declarator:sym<role>"  :subid("76_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1410
    .param pmc param_1411
.annotate 'line', 379
    new $P1409, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1409, control_1408
    push_eh $P1409
    .lex "self", param_1410
    .lex "$/", param_1411
    find_lex $P1412, "$/"
    find_lex $P1413, "$/"
    $P1414 = "package"($P1413)
    $P1415 = $P1412."!make"($P1414)
    .return ($P1415)
  control_1408:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1416, exception, "payload"
    .return ($P1416)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("77_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1422
    .param pmc param_1423
.annotate 'line', 480
    new $P1421, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1421, control_1420
    push_eh $P1421
    .lex "self", param_1422
    .lex "$/", param_1423
.annotate 'line', 481
    new $P1424, "Undef"
    .lex "$past", $P1424
    find_lex $P1427, "$/"
    unless_null $P1427, vivify_458
    $P1427 = root_new ['parrot';'Hash']
  vivify_458:
    set $P1428, $P1427["block"]
    unless_null $P1428, vivify_459
    new $P1428, "Undef"
  vivify_459:
    if $P1428, if_1426
    find_lex $P1432, "$/"
    unless_null $P1432, vivify_460
    $P1432 = root_new ['parrot';'Hash']
  vivify_460:
    set $P1433, $P1432["comp_unit"]
    unless_null $P1433, vivify_461
    new $P1433, "Undef"
  vivify_461:
    $P1434 = $P1433."ast"()
    set $P1425, $P1434
    goto if_1426_end
  if_1426:
    find_lex $P1429, "$/"
    unless_null $P1429, vivify_462
    $P1429 = root_new ['parrot';'Hash']
  vivify_462:
    set $P1430, $P1429["block"]
    unless_null $P1430, vivify_463
    new $P1430, "Undef"
  vivify_463:
    $P1431 = $P1430."ast"()
    set $P1425, $P1431
  if_1426_end:
    store_lex "$past", $P1425
.annotate 'line', 482
    find_lex $P1435, "$past"
    find_lex $P1436, "$/"
    unless_null $P1436, vivify_464
    $P1436 = root_new ['parrot';'Hash']
  vivify_464:
    set $P1437, $P1436["name"]
    unless_null $P1437, vivify_465
    $P1437 = root_new ['parrot';'Hash']
  vivify_465:
    set $P1438, $P1437["identifier"]
    unless_null $P1438, vivify_466
    new $P1438, "Undef"
  vivify_466:
    $P1435."namespace"($P1438)
.annotate 'line', 483
    find_lex $P1439, "$past"
    $P1439."blocktype"("immediate")
.annotate 'line', 484
    find_lex $P1440, "$/"
    find_lex $P1441, "$past"
    $P1442 = $P1440."!make"($P1441)
.annotate 'line', 480
    .return ($P1442)
  control_1420:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1443, exception, "payload"
    .return ($P1443)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "scope_declarator:sym<my>"  :subid("78_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1447
    .param pmc param_1448
.annotate 'line', 487
    new $P1446, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1446, control_1445
    push_eh $P1446
    .lex "self", param_1447
    .lex "$/", param_1448
    find_lex $P1449, "$/"
    find_lex $P1450, "$/"
    unless_null $P1450, vivify_467
    $P1450 = root_new ['parrot';'Hash']
  vivify_467:
    set $P1451, $P1450["scoped"]
    unless_null $P1451, vivify_468
    new $P1451, "Undef"
  vivify_468:
    $P1452 = $P1451."ast"()
    $P1453 = $P1449."!make"($P1452)
    .return ($P1453)
  control_1445:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1454, exception, "payload"
    .return ($P1454)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "scope_declarator:sym<our>"  :subid("79_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1458
    .param pmc param_1459
.annotate 'line', 488
    new $P1457, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1457, control_1456
    push_eh $P1457
    .lex "self", param_1458
    .lex "$/", param_1459
    find_lex $P1460, "$/"
    find_lex $P1461, "$/"
    unless_null $P1461, vivify_469
    $P1461 = root_new ['parrot';'Hash']
  vivify_469:
    set $P1462, $P1461["scoped"]
    unless_null $P1462, vivify_470
    new $P1462, "Undef"
  vivify_470:
    $P1463 = $P1462."ast"()
    $P1464 = $P1460."!make"($P1463)
    .return ($P1464)
  control_1456:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1465, exception, "payload"
    .return ($P1465)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "scope_declarator:sym<has>"  :subid("80_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1469
    .param pmc param_1470
.annotate 'line', 489
    new $P1468, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1468, control_1467
    push_eh $P1468
    .lex "self", param_1469
    .lex "$/", param_1470
    find_lex $P1471, "$/"
    find_lex $P1472, "$/"
    unless_null $P1472, vivify_471
    $P1472 = root_new ['parrot';'Hash']
  vivify_471:
    set $P1473, $P1472["scoped"]
    unless_null $P1473, vivify_472
    new $P1473, "Undef"
  vivify_472:
    $P1474 = $P1473."ast"()
    $P1475 = $P1471."!make"($P1474)
    .return ($P1475)
  control_1467:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1476, exception, "payload"
    .return ($P1476)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "scoped"  :subid("81_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1480
    .param pmc param_1481
.annotate 'line', 491
    new $P1479, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1479, control_1478
    push_eh $P1479
    .lex "self", param_1480
    .lex "$/", param_1481
.annotate 'line', 492
    find_lex $P1482, "$/"
.annotate 'line', 493
    find_lex $P1485, "$/"
    unless_null $P1485, vivify_473
    $P1485 = root_new ['parrot';'Hash']
  vivify_473:
    set $P1486, $P1485["declarator"]
    unless_null $P1486, vivify_474
    new $P1486, "Undef"
  vivify_474:
    if $P1486, if_1484
.annotate 'line', 494
    find_lex $P1490, "$/"
    unless_null $P1490, vivify_475
    $P1490 = root_new ['parrot';'Hash']
  vivify_475:
    set $P1491, $P1490["multi_declarator"]
    unless_null $P1491, vivify_476
    new $P1491, "Undef"
  vivify_476:
    $P1492 = $P1491."ast"()
    set $P1483, $P1492
.annotate 'line', 493
    goto if_1484_end
  if_1484:
    find_lex $P1487, "$/"
    unless_null $P1487, vivify_477
    $P1487 = root_new ['parrot';'Hash']
  vivify_477:
    set $P1488, $P1487["declarator"]
    unless_null $P1488, vivify_478
    new $P1488, "Undef"
  vivify_478:
    $P1489 = $P1488."ast"()
    set $P1483, $P1489
  if_1484_end:
    $P1493 = $P1482."!make"($P1483)
.annotate 'line', 491
    .return ($P1493)
  control_1478:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1494, exception, "payload"
    .return ($P1494)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "declarator"  :subid("82_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1498
    .param pmc param_1499
.annotate 'line', 497
    new $P1497, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1497, control_1496
    push_eh $P1497
    .lex "self", param_1498
    .lex "$/", param_1499
.annotate 'line', 498
    find_lex $P1500, "$/"
.annotate 'line', 499
    find_lex $P1503, "$/"
    unless_null $P1503, vivify_479
    $P1503 = root_new ['parrot';'Hash']
  vivify_479:
    set $P1504, $P1503["routine_declarator"]
    unless_null $P1504, vivify_480
    new $P1504, "Undef"
  vivify_480:
    if $P1504, if_1502
.annotate 'line', 500
    find_lex $P1508, "$/"
    unless_null $P1508, vivify_481
    $P1508 = root_new ['parrot';'Hash']
  vivify_481:
    set $P1509, $P1508["variable_declarator"]
    unless_null $P1509, vivify_482
    new $P1509, "Undef"
  vivify_482:
    $P1510 = $P1509."ast"()
    set $P1501, $P1510
.annotate 'line', 499
    goto if_1502_end
  if_1502:
    find_lex $P1505, "$/"
    unless_null $P1505, vivify_483
    $P1505 = root_new ['parrot';'Hash']
  vivify_483:
    set $P1506, $P1505["routine_declarator"]
    unless_null $P1506, vivify_484
    new $P1506, "Undef"
  vivify_484:
    $P1507 = $P1506."ast"()
    set $P1501, $P1507
  if_1502_end:
    $P1511 = $P1500."!make"($P1501)
.annotate 'line', 497
    .return ($P1511)
  control_1496:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1512, exception, "payload"
    .return ($P1512)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "multi_declarator:sym<multi>"  :subid("83_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1516
    .param pmc param_1517
.annotate 'line', 503
    new $P1515, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1515, control_1514
    push_eh $P1515
    .lex "self", param_1516
    .lex "$/", param_1517
    find_lex $P1518, "$/"
    find_lex $P1521, "$/"
    unless_null $P1521, vivify_485
    $P1521 = root_new ['parrot';'Hash']
  vivify_485:
    set $P1522, $P1521["declarator"]
    unless_null $P1522, vivify_486
    new $P1522, "Undef"
  vivify_486:
    if $P1522, if_1520
    find_lex $P1526, "$/"
    unless_null $P1526, vivify_487
    $P1526 = root_new ['parrot';'Hash']
  vivify_487:
    set $P1527, $P1526["routine_def"]
    unless_null $P1527, vivify_488
    new $P1527, "Undef"
  vivify_488:
    $P1528 = $P1527."ast"()
    set $P1519, $P1528
    goto if_1520_end
  if_1520:
    find_lex $P1523, "$/"
    unless_null $P1523, vivify_489
    $P1523 = root_new ['parrot';'Hash']
  vivify_489:
    set $P1524, $P1523["declarator"]
    unless_null $P1524, vivify_490
    new $P1524, "Undef"
  vivify_490:
    $P1525 = $P1524."ast"()
    set $P1519, $P1525
  if_1520_end:
    $P1529 = $P1518."!make"($P1519)
    .return ($P1529)
  control_1514:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1530, exception, "payload"
    .return ($P1530)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "multi_declarator:sym<proto>"  :subid("84_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1534
    .param pmc param_1535
.annotate 'line', 504
    new $P1533, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1533, control_1532
    push_eh $P1533
    .lex "self", param_1534
    .lex "$/", param_1535
    find_lex $P1536, "$/"
    find_lex $P1539, "$/"
    unless_null $P1539, vivify_491
    $P1539 = root_new ['parrot';'Hash']
  vivify_491:
    set $P1540, $P1539["declarator"]
    unless_null $P1540, vivify_492
    new $P1540, "Undef"
  vivify_492:
    if $P1540, if_1538
    find_lex $P1544, "$/"
    unless_null $P1544, vivify_493
    $P1544 = root_new ['parrot';'Hash']
  vivify_493:
    set $P1545, $P1544["routine_def"]
    unless_null $P1545, vivify_494
    new $P1545, "Undef"
  vivify_494:
    $P1546 = $P1545."ast"()
    set $P1537, $P1546
    goto if_1538_end
  if_1538:
    find_lex $P1541, "$/"
    unless_null $P1541, vivify_495
    $P1541 = root_new ['parrot';'Hash']
  vivify_495:
    set $P1542, $P1541["declarator"]
    unless_null $P1542, vivify_496
    new $P1542, "Undef"
  vivify_496:
    $P1543 = $P1542."ast"()
    set $P1537, $P1543
  if_1538_end:
    $P1547 = $P1536."!make"($P1537)
    .return ($P1547)
  control_1532:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1548, exception, "payload"
    .return ($P1548)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "multi_declarator:sym<null>"  :subid("85_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1552
    .param pmc param_1553
.annotate 'line', 505
    new $P1551, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1551, control_1550
    push_eh $P1551
    .lex "self", param_1552
    .lex "$/", param_1553
    find_lex $P1554, "$/"
    find_lex $P1555, "$/"
    unless_null $P1555, vivify_497
    $P1555 = root_new ['parrot';'Hash']
  vivify_497:
    set $P1556, $P1555["declarator"]
    unless_null $P1556, vivify_498
    new $P1556, "Undef"
  vivify_498:
    $P1557 = $P1556."ast"()
    $P1558 = $P1554."!make"($P1557)
    .return ($P1558)
  control_1550:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1559, exception, "payload"
    .return ($P1559)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "variable_declarator"  :subid("86_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1563
    .param pmc param_1564
.annotate 'line', 508
    .const 'Sub' $P1633 = "88_1295307719.828" 
    capture_lex $P1633
    .const 'Sub' $P1595 = "87_1295307719.828" 
    capture_lex $P1595
    new $P1562, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1562, control_1561
    push_eh $P1562
    .lex "self", param_1563
    .lex "$/", param_1564
.annotate 'line', 509
    new $P1565, "Undef"
    .lex "$past", $P1565
.annotate 'line', 510
    new $P1566, "Undef"
    .lex "$sigil", $P1566
.annotate 'line', 511
    new $P1567, "Undef"
    .lex "$name", $P1567
.annotate 'line', 512
    new $P1568, "Undef"
    .lex "$BLOCK", $P1568
.annotate 'line', 509
    find_lex $P1569, "$/"
    unless_null $P1569, vivify_499
    $P1569 = root_new ['parrot';'Hash']
  vivify_499:
    set $P1570, $P1569["variable"]
    unless_null $P1570, vivify_500
    new $P1570, "Undef"
  vivify_500:
    $P1571 = $P1570."ast"()
    store_lex "$past", $P1571
.annotate 'line', 510
    find_lex $P1572, "$/"
    unless_null $P1572, vivify_501
    $P1572 = root_new ['parrot';'Hash']
  vivify_501:
    set $P1573, $P1572["variable"]
    unless_null $P1573, vivify_502
    $P1573 = root_new ['parrot';'Hash']
  vivify_502:
    set $P1574, $P1573["sigil"]
    unless_null $P1574, vivify_503
    new $P1574, "Undef"
  vivify_503:
    store_lex "$sigil", $P1574
.annotate 'line', 511
    find_lex $P1575, "$past"
    $P1576 = $P1575."name"()
    store_lex "$name", $P1576
.annotate 'line', 512
    get_global $P1577, "@BLOCK"
    unless_null $P1577, vivify_504
    $P1577 = root_new ['parrot';'ResizablePMCArray']
  vivify_504:
    set $P1578, $P1577[0]
    unless_null $P1578, vivify_505
    new $P1578, "Undef"
  vivify_505:
    store_lex "$BLOCK", $P1578
.annotate 'line', 513
    find_lex $P1580, "$BLOCK"
    find_lex $P1581, "$name"
    $P1582 = $P1580."symbol"($P1581)
    unless $P1582, if_1579_end
.annotate 'line', 514
    find_lex $P1583, "$/"
    $P1584 = $P1583."CURSOR"()
    find_lex $P1585, "$name"
    $P1584."panic"("Redeclaration of symbol ", $P1585)
  if_1579_end:
.annotate 'line', 516
    find_dynamic_lex $P1587, "$*SCOPE"
    unless_null $P1587, vivify_506
    get_hll_global $P1587, "$SCOPE"
    unless_null $P1587, vivify_507
    die "Contextual $*SCOPE not found"
  vivify_507:
  vivify_506:
    set $S1588, $P1587
    iseq $I1589, $S1588, "has"
    if $I1589, if_1586
.annotate 'line', 545
    .const 'Sub' $P1633 = "88_1295307719.828" 
    capture_lex $P1633
    $P1633()
    goto if_1586_end
  if_1586:
.annotate 'line', 517
    find_lex $P1590, "$BLOCK"
    find_lex $P1591, "$name"
    $P1590."symbol"($P1591, "attribute" :named("scope"))
.annotate 'line', 518
    find_dynamic_lex $P1593, "$*PACKAGE-SETUP"
    unless_null $P1593, vivify_512
    get_hll_global $P1593, "$PACKAGE-SETUP"
    unless_null $P1593, vivify_513
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_513:
  vivify_512:
    if $P1593, if_1592
.annotate 'line', 537
    find_lex $P1622, "$BLOCK"
    unless_null $P1622, vivify_514
    $P1622 = root_new ['parrot';'Hash']
  vivify_514:
    set $P1623, $P1622["attributes"]
    unless_null $P1623, vivify_515
    new $P1623, "Undef"
  vivify_515:
    if $P1623, unless_1621_end
.annotate 'line', 539
    get_hll_global $P1624, ["PAST"], "Op"
    $P1625 = $P1624."new"("list" :named("pasttype"), "attr" :named("named"))
    find_lex $P1626, "$BLOCK"
    unless_null $P1626, vivify_516
    $P1626 = root_new ['parrot';'Hash']
    store_lex "$BLOCK", $P1626
  vivify_516:
    set $P1626["attributes"], $P1625
  unless_1621_end:
.annotate 'line', 541
    find_lex $P1627, "$BLOCK"
    unless_null $P1627, vivify_517
    $P1627 = root_new ['parrot';'Hash']
  vivify_517:
    set $P1628, $P1627["attributes"]
    unless_null $P1628, vivify_518
    new $P1628, "Undef"
  vivify_518:
    find_lex $P1629, "$name"
    $P1628."push"($P1629)
.annotate 'line', 535
    goto if_1592_end
  if_1592:
.annotate 'line', 518
    .const 'Sub' $P1595 = "87_1295307719.828" 
    capture_lex $P1595
    $P1595()
  if_1592_end:
.annotate 'line', 543
    get_hll_global $P1630, ["PAST"], "Stmts"
    $P1631 = $P1630."new"()
    store_lex "$past", $P1631
  if_1586_end:
.annotate 'line', 553
    find_lex $P1657, "$/"
    find_lex $P1658, "$past"
    $P1659 = $P1657."!make"($P1658)
.annotate 'line', 508
    .return ($P1659)
  control_1561:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1660, exception, "payload"
    .return ($P1660)
.end


.namespace ["NQP";"Actions"]
.sub "_block1632"  :anon :subid("88_1295307719.828") :outer("86_1295307719.828")
.annotate 'line', 546
    new $P1634, "Undef"
    .lex "$scope", $P1634
.annotate 'line', 547
    new $P1635, "Undef"
    .lex "$decl", $P1635
.annotate 'line', 546
    find_dynamic_lex $P1638, "$*SCOPE"
    unless_null $P1638, vivify_508
    get_hll_global $P1638, "$SCOPE"
    unless_null $P1638, vivify_509
    die "Contextual $*SCOPE not found"
  vivify_509:
  vivify_508:
    set $S1639, $P1638
    iseq $I1640, $S1639, "our"
    if $I1640, if_1637
    new $P1642, "String"
    assign $P1642, "lexical"
    set $P1636, $P1642
    goto if_1637_end
  if_1637:
    new $P1641, "String"
    assign $P1641, "package"
    set $P1636, $P1641
  if_1637_end:
    store_lex "$scope", $P1636
.annotate 'line', 547
    get_hll_global $P1643, ["PAST"], "Var"
    find_lex $P1644, "$name"
    find_lex $P1645, "$scope"
.annotate 'line', 548
    find_lex $P1646, "$sigil"
    $P1647 = "vivitype"($P1646)
    find_lex $P1648, "$/"
    $P1649 = $P1643."new"($P1644 :named("name"), $P1645 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1647 :named("viviself"), $P1648 :named("node"))
.annotate 'line', 547
    store_lex "$decl", $P1649
.annotate 'line', 550
    find_lex $P1650, "$BLOCK"
    find_lex $P1651, "$name"
    find_lex $P1652, "$scope"
    $P1650."symbol"($P1651, $P1652 :named("scope"))
.annotate 'line', 551
    find_lex $P1653, "$BLOCK"
    unless_null $P1653, vivify_510
    $P1653 = root_new ['parrot';'ResizablePMCArray']
  vivify_510:
    set $P1654, $P1653[0]
    unless_null $P1654, vivify_511
    new $P1654, "Undef"
  vivify_511:
    find_lex $P1655, "$decl"
    $P1656 = $P1654."push"($P1655)
.annotate 'line', 545
    .return ($P1656)
.end


.namespace ["NQP";"Actions"]
.sub "_block1594"  :anon :subid("87_1295307719.828") :outer("86_1295307719.828")
.annotate 'line', 520
    new $P1596, "Undef"
    .lex "$meta-attr-type", $P1596
    find_dynamic_lex $P1599, "$*PKGDECL"
    unless_null $P1599, vivify_519
    get_hll_global $P1599, "$PKGDECL"
    unless_null $P1599, vivify_520
    die "Contextual $*PKGDECL not found"
  vivify_520:
  vivify_519:
    find_dynamic_lex $P1600, "%*HOW-METAATTR"
    unless_null $P1600, vivify_521
    get_hll_global $P1600, "%HOW-METAATTR"
    unless_null $P1600, vivify_522
    die "Contextual %*HOW-METAATTR not found"
  vivify_522:
  vivify_521:
    set $P1601, $P1600[$P1599]
    unless_null $P1601, vivify_523
    new $P1601, "Undef"
  vivify_523:
    unless $P1601, unless_1598
    set $P1597, $P1601
    goto unless_1598_end
  unless_1598:
    find_dynamic_lex $P1602, "$*DEFAULT-METAATTR"
    unless_null $P1602, vivify_524
    get_hll_global $P1602, "$DEFAULT-METAATTR"
    unless_null $P1602, vivify_525
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_525:
  vivify_524:
    set $P1597, $P1602
  unless_1598_end:
    store_lex "$meta-attr-type", $P1597
.annotate 'line', 521
    find_dynamic_lex $P1603, "$*PACKAGE-SETUP"
    unless_null $P1603, vivify_526
    get_hll_global $P1603, "$PACKAGE-SETUP"
    unless_null $P1603, vivify_527
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_527:
  vivify_526:
    get_hll_global $P1604, ["PAST"], "Op"
.annotate 'line', 523
    get_hll_global $P1605, ["PAST"], "Op"
.annotate 'line', 525
    get_hll_global $P1606, ["PAST"], "Var"
    $P1607 = $P1606."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1608 = $P1605."new"($P1607, "get_how PP" :named("pirop"))
.annotate 'line', 527
    get_hll_global $P1609, ["PAST"], "Var"
    $P1610 = $P1609."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 528
    get_hll_global $P1611, ["PAST"], "Op"
.annotate 'line', 530
    get_hll_global $P1612, ["PAST"], "Var"
    find_lex $P1613, "$meta-attr-type"
    $P1614 = $P1612."new"($P1613 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 531
    get_hll_global $P1615, ["PAST"], "Val"
    find_lex $P1616, "$name"
    $P1617 = $P1615."new"($P1616 :named("value"), "name" :named("named"))
    $P1618 = $P1611."new"($P1614, $P1617, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 528
    $P1619 = $P1604."new"($P1608, $P1610, $P1618, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 521
    $P1620 = $P1603."push"($P1619)
.annotate 'line', 518
    .return ($P1620)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_declarator:sym<sub>"  :subid("89_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1664
    .param pmc param_1665
.annotate 'line', 556
    new $P1663, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1663, control_1662
    push_eh $P1663
    .lex "self", param_1664
    .lex "$/", param_1665
    find_lex $P1666, "$/"
    find_lex $P1667, "$/"
    unless_null $P1667, vivify_528
    $P1667 = root_new ['parrot';'Hash']
  vivify_528:
    set $P1668, $P1667["routine_def"]
    unless_null $P1668, vivify_529
    new $P1668, "Undef"
  vivify_529:
    $P1669 = $P1668."ast"()
    $P1670 = $P1666."!make"($P1669)
    .return ($P1670)
  control_1662:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1671, exception, "payload"
    .return ($P1671)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_declarator:sym<method>"  :subid("90_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1675
    .param pmc param_1676
.annotate 'line', 557
    new $P1674, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1674, control_1673
    push_eh $P1674
    .lex "self", param_1675
    .lex "$/", param_1676
    find_lex $P1677, "$/"
    find_lex $P1678, "$/"
    unless_null $P1678, vivify_530
    $P1678 = root_new ['parrot';'Hash']
  vivify_530:
    set $P1679, $P1678["method_def"]
    unless_null $P1679, vivify_531
    new $P1679, "Undef"
  vivify_531:
    $P1680 = $P1679."ast"()
    $P1681 = $P1677."!make"($P1680)
    .return ($P1681)
  control_1673:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1682, exception, "payload"
    .return ($P1682)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("91_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1686
    .param pmc param_1687
.annotate 'line', 559
    .const 'Sub' $P1913 = "97_1295307719.828" 
    capture_lex $P1913
    .const 'Sub' $P1705 = "92_1295307719.828" 
    capture_lex $P1705
    new $P1685, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1685, control_1684
    push_eh $P1685
    .lex "self", param_1686
    .lex "$/", param_1687
.annotate 'line', 562
    new $P1688, "Undef"
    .lex "$past", $P1688
.annotate 'line', 571
    new $P1689, "Undef"
    .lex "$block", $P1689
.annotate 'line', 559
    find_lex $P1690, "$past"
.annotate 'line', 563
    find_lex $P1692, "$/"
    unless_null $P1692, vivify_532
    $P1692 = root_new ['parrot';'Hash']
  vivify_532:
    set $P1693, $P1692["onlystar"]
    unless_null $P1693, vivify_533
    new $P1693, "Undef"
  vivify_533:
    if $P1693, if_1691
.annotate 'line', 567
    find_lex $P1695, "$/"
    unless_null $P1695, vivify_534
    $P1695 = root_new ['parrot';'Hash']
  vivify_534:
    set $P1696, $P1695["blockoid"]
    unless_null $P1696, vivify_535
    new $P1696, "Undef"
  vivify_535:
    $P1697 = $P1696."ast"()
    store_lex "$past", $P1697
.annotate 'line', 568
    find_lex $P1698, "$past"
    $P1698."blocktype"("declaration")
.annotate 'line', 569
    find_lex $P1699, "$past"
    $P1699."control"("return_pir")
.annotate 'line', 566
    goto if_1691_end
  if_1691:
.annotate 'line', 564
    $P1694 = "only_star_block"()
    store_lex "$past", $P1694
  if_1691_end:
.annotate 'line', 571
    find_lex $P1700, "$past"
    store_lex "$block", $P1700
.annotate 'line', 573
    find_lex $P1702, "$/"
    unless_null $P1702, vivify_536
    $P1702 = root_new ['parrot';'Hash']
  vivify_536:
    set $P1703, $P1702["deflongname"]
    unless_null $P1703, vivify_537
    new $P1703, "Undef"
  vivify_537:
    unless $P1703, if_1701_end
    .const 'Sub' $P1705 = "92_1295307719.828" 
    capture_lex $P1705
    $P1705()
  if_1701_end:
.annotate 'line', 673
    find_lex $P1902, "$block"
    find_lex $P1903, "$past"
    unless_null $P1903, vivify_598
    $P1903 = root_new ['parrot';'Hash']
    store_lex "$past", $P1903
  vivify_598:
    set $P1903["block_past"], $P1902
.annotate 'line', 674
    find_lex $P1905, "$/"
    unless_null $P1905, vivify_599
    $P1905 = root_new ['parrot';'Hash']
  vivify_599:
    set $P1906, $P1905["trait"]
    unless_null $P1906, vivify_600
    new $P1906, "Undef"
  vivify_600:
    unless $P1906, if_1904_end
.annotate 'line', 675
    find_lex $P1908, "$/"
    unless_null $P1908, vivify_601
    $P1908 = root_new ['parrot';'Hash']
  vivify_601:
    set $P1909, $P1908["trait"]
    unless_null $P1909, vivify_602
    new $P1909, "Undef"
  vivify_602:
    defined $I1910, $P1909
    unless $I1910, for_undef_603
    iter $P1907, $P1909
    new $P1920, 'ExceptionHandler'
    set_addr $P1920, loop1919_handler
    $P1920."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1920
  loop1919_test:
    unless $P1907, loop1919_done
    shift $P1911, $P1907
  loop1919_redo:
    .const 'Sub' $P1913 = "97_1295307719.828" 
    capture_lex $P1913
    $P1913($P1911)
  loop1919_next:
    goto loop1919_test
  loop1919_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1921, exception, 'type'
    eq $P1921, .CONTROL_LOOP_NEXT, loop1919_next
    eq $P1921, .CONTROL_LOOP_REDO, loop1919_redo
  loop1919_done:
    pop_eh 
  for_undef_603:
  if_1904_end:
.annotate 'line', 678
    find_lex $P1922, "$/"
    find_lex $P1923, "$past"
    $P1924 = $P1922."!make"($P1923)
.annotate 'line', 559
    .return ($P1924)
  control_1684:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1925, exception, "payload"
    .return ($P1925)
.end


.namespace ["NQP";"Actions"]
.sub "_block1704"  :anon :subid("92_1295307719.828") :outer("91_1295307719.828")
.annotate 'line', 573
    .const 'Sub' $P1828 = "96_1295307719.828" 
    capture_lex $P1828
    .const 'Sub' $P1739 = "93_1295307719.828" 
    capture_lex $P1739
.annotate 'line', 574
    new $P1706, "Undef"
    .lex "$name", $P1706
    find_lex $P1707, "$/"
    unless_null $P1707, vivify_538
    $P1707 = root_new ['parrot';'Hash']
  vivify_538:
    set $P1708, $P1707["sigil"]
    unless_null $P1708, vivify_539
    $P1708 = root_new ['parrot';'ResizablePMCArray']
  vivify_539:
    set $P1709, $P1708[0]
    unless_null $P1709, vivify_540
    new $P1709, "Undef"
  vivify_540:
    set $S1710, $P1709
    new $P1711, 'String'
    set $P1711, $S1710
    find_lex $P1712, "$/"
    unless_null $P1712, vivify_541
    $P1712 = root_new ['parrot';'Hash']
  vivify_541:
    set $P1713, $P1712["deflongname"]
    unless_null $P1713, vivify_542
    $P1713 = root_new ['parrot';'ResizablePMCArray']
  vivify_542:
    set $P1714, $P1713[0]
    unless_null $P1714, vivify_543
    new $P1714, "Undef"
  vivify_543:
    $S1715 = $P1714."ast"()
    concat $P1716, $P1711, $S1715
    store_lex "$name", $P1716
.annotate 'line', 575
    find_lex $P1717, "$past"
    find_lex $P1718, "$name"
    $P1717."name"($P1718)
.annotate 'line', 576
    find_dynamic_lex $P1725, "$*SCOPE"
    unless_null $P1725, vivify_544
    get_hll_global $P1725, "$SCOPE"
    unless_null $P1725, vivify_545
    die "Contextual $*SCOPE not found"
  vivify_545:
  vivify_544:
    set $S1726, $P1725
    iseq $I1727, $S1726, ""
    unless $I1727, unless_1724
    new $P1723, 'Integer'
    set $P1723, $I1727
    goto unless_1724_end
  unless_1724:
    find_dynamic_lex $P1728, "$*SCOPE"
    unless_null $P1728, vivify_546
    get_hll_global $P1728, "$SCOPE"
    unless_null $P1728, vivify_547
    die "Contextual $*SCOPE not found"
  vivify_547:
  vivify_546:
    set $S1729, $P1728
    iseq $I1730, $S1729, "my"
    new $P1723, 'Integer'
    set $P1723, $I1730
  unless_1724_end:
    unless $P1723, unless_1722
    set $P1721, $P1723
    goto unless_1722_end
  unless_1722:
    find_dynamic_lex $P1731, "$*SCOPE"
    unless_null $P1731, vivify_548
    get_hll_global $P1731, "$SCOPE"
    unless_null $P1731, vivify_549
    die "Contextual $*SCOPE not found"
  vivify_549:
  vivify_548:
    set $S1732, $P1731
    iseq $I1733, $S1732, "our"
    new $P1721, 'Integer'
    set $P1721, $I1733
  unless_1722_end:
    if $P1721, if_1720
.annotate 'line', 668
    find_lex $P1897, "$/"
    $P1898 = $P1897."CURSOR"()
    find_dynamic_lex $P1899, "$*SCOPE"
    unless_null $P1899, vivify_550
    get_hll_global $P1899, "$SCOPE"
    unless_null $P1899, vivify_551
    die "Contextual $*SCOPE not found"
  vivify_551:
  vivify_550:
    concat $P1900, $P1899, " scoped routines are not supported yet"
    $P1901 = $P1898."panic"($P1900)
.annotate 'line', 667
    set $P1719, $P1901
.annotate 'line', 576
    goto if_1720_end
  if_1720:
.annotate 'line', 577
    find_dynamic_lex $P1735, "$*MULTINESS"
    unless_null $P1735, vivify_552
    get_hll_global $P1735, "$MULTINESS"
    unless_null $P1735, vivify_553
    die "Contextual $*MULTINESS not found"
  vivify_553:
  vivify_552:
    set $S1736, $P1735
    iseq $I1737, $S1736, "multi"
    if $I1737, if_1734
.annotate 'line', 628
    find_dynamic_lex $P1824, "$*MULTINESS"
    unless_null $P1824, vivify_554
    get_hll_global $P1824, "$MULTINESS"
    unless_null $P1824, vivify_555
    die "Contextual $*MULTINESS not found"
  vivify_555:
  vivify_554:
    set $S1825, $P1824
    iseq $I1826, $S1825, "proto"
    if $I1826, if_1823
.annotate 'line', 647
    get_global $P1858, "@BLOCK"
    unless_null $P1858, vivify_556
    $P1858 = root_new ['parrot';'ResizablePMCArray']
  vivify_556:
    set $P1859, $P1858[0]
    unless_null $P1859, vivify_557
    $P1859 = root_new ['parrot';'ResizablePMCArray']
  vivify_557:
    set $P1860, $P1859[0]
    unless_null $P1860, vivify_558
    new $P1860, "Undef"
  vivify_558:
    get_hll_global $P1861, ["PAST"], "Var"
    find_lex $P1862, "$name"
    find_lex $P1863, "$past"
    $P1864 = $P1861."new"($P1862 :named("name"), 1 :named("isdecl"), $P1863 :named("viviself"), "lexical" :named("scope"))
    $P1860."push"($P1864)
.annotate 'line', 649
    get_global $P1865, "@BLOCK"
    unless_null $P1865, vivify_559
    $P1865 = root_new ['parrot';'ResizablePMCArray']
  vivify_559:
    set $P1866, $P1865[0]
    unless_null $P1866, vivify_560
    new $P1866, "Undef"
  vivify_560:
    find_lex $P1867, "$name"
    $P1866."symbol"($P1867, "lexical" :named("scope"))
.annotate 'line', 650
    find_dynamic_lex $P1869, "$*SCOPE"
    unless_null $P1869, vivify_561
    get_hll_global $P1869, "$SCOPE"
    unless_null $P1869, vivify_562
    die "Contextual $*SCOPE not found"
  vivify_562:
  vivify_561:
    set $S1870, $P1869
    iseq $I1871, $S1870, "our"
    unless $I1871, if_1868_end
.annotate 'line', 653
    get_global $P1872, "@BLOCK"
    unless_null $P1872, vivify_563
    $P1872 = root_new ['parrot';'ResizablePMCArray']
  vivify_563:
    set $P1873, $P1872[0]
    unless_null $P1873, vivify_564
    $P1873 = root_new ['parrot';'ResizablePMCArray']
  vivify_564:
    set $P1874, $P1873[0]
    unless_null $P1874, vivify_565
    new $P1874, "Undef"
  vivify_565:
    get_hll_global $P1875, ["PAST"], "Op"
.annotate 'line', 655
    get_hll_global $P1876, ["PAST"], "Var"
    find_lex $P1877, "$name"
    $P1878 = $P1876."new"($P1877 :named("name"), "package" :named("scope"))
.annotate 'line', 656
    get_hll_global $P1879, ["PAST"], "Var"
    find_lex $P1880, "$name"
    $P1881 = $P1879."new"($P1880 :named("name"), "lexical" :named("scope"))
    $P1882 = $P1875."new"($P1878, $P1881, "bind" :named("pasttype"))
.annotate 'line', 653
    $P1874."push"($P1882)
.annotate 'line', 658
    get_global $P1883, "@BLOCK"
    unless_null $P1883, vivify_566
    $P1883 = root_new ['parrot';'ResizablePMCArray']
  vivify_566:
    set $P1884, $P1883[0]
    unless_null $P1884, vivify_567
    new $P1884, "Undef"
  vivify_567:
    $P1885 = $P1884."loadinit"()
    get_hll_global $P1886, ["PAST"], "Op"
.annotate 'line', 660
    get_hll_global $P1887, ["PAST"], "Var"
    find_lex $P1888, "$name"
    $P1889 = $P1887."new"($P1888 :named("name"), "package" :named("scope"))
.annotate 'line', 661
    get_hll_global $P1890, ["PAST"], "Val"
    find_lex $P1891, "$past"
    $P1892 = $P1890."new"($P1891 :named("value"))
    $P1893 = $P1886."new"($P1889, $P1892, "bind" :named("pasttype"))
.annotate 'line', 658
    $P1885."push"($P1893)
  if_1868_end:
.annotate 'line', 646
    goto if_1823_end
  if_1823:
.annotate 'line', 628
    .const 'Sub' $P1828 = "96_1295307719.828" 
    capture_lex $P1828
    $P1828()
  if_1823_end:
    goto if_1734_end
  if_1734:
.annotate 'line', 577
    .const 'Sub' $P1739 = "93_1295307719.828" 
    capture_lex $P1739
    $P1739()
  if_1734_end:
.annotate 'line', 665
    get_hll_global $P1894, ["PAST"], "Var"
    find_lex $P1895, "$name"
    $P1896 = $P1894."new"($P1895 :named("name"))
    store_lex "$past", $P1896
.annotate 'line', 576
    set $P1719, $P1896
  if_1720_end:
.annotate 'line', 573
    .return ($P1719)
.end


.namespace ["NQP";"Actions"]
.sub "_block1827"  :anon :subid("96_1295307719.828") :outer("92_1295307719.828")
.annotate 'line', 633
    new $P1829, "Undef"
    .lex "$cholder", $P1829
.annotate 'line', 632
    find_dynamic_lex $P1831, "$*SCOPE"
    unless_null $P1831, vivify_568
    get_hll_global $P1831, "$SCOPE"
    unless_null $P1831, vivify_569
    die "Contextual $*SCOPE not found"
  vivify_569:
  vivify_568:
    set $S1832, $P1831
    iseq $I1833, $S1832, "our"
    unless $I1833, if_1830_end
    die "our-scoped protos not yet implemented"
  if_1830_end:
.annotate 'line', 633
    get_hll_global $P1834, ["PAST"], "Op"
    $P1835 = $P1834."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1835
.annotate 'line', 634
    get_global $P1836, "@BLOCK"
    unless_null $P1836, vivify_570
    $P1836 = root_new ['parrot';'ResizablePMCArray']
  vivify_570:
    set $P1837, $P1836[0]
    unless_null $P1837, vivify_571
    $P1837 = root_new ['parrot';'ResizablePMCArray']
  vivify_571:
    set $P1838, $P1837[0]
    unless_null $P1838, vivify_572
    new $P1838, "Undef"
  vivify_572:
    get_hll_global $P1839, ["PAST"], "Var"
    find_lex $P1840, "$name"
    find_lex $P1841, "$past"
    $P1842 = $P1839."new"($P1840 :named("name"), 1 :named("isdecl"), $P1841 :named("viviself"), "lexical" :named("scope"))
    $P1838."push"($P1842)
.annotate 'line', 636
    get_global $P1843, "@BLOCK"
    unless_null $P1843, vivify_573
    $P1843 = root_new ['parrot';'ResizablePMCArray']
  vivify_573:
    set $P1844, $P1843[0]
    unless_null $P1844, vivify_574
    $P1844 = root_new ['parrot';'ResizablePMCArray']
  vivify_574:
    set $P1845, $P1844[0]
    unless_null $P1845, vivify_575
    new $P1845, "Undef"
  vivify_575:
    get_hll_global $P1846, ["PAST"], "Op"
.annotate 'line', 638
    get_hll_global $P1847, ["PAST"], "Var"
    find_lex $P1848, "$name"
    $P1849 = $P1847."new"($P1848 :named("name"))
    find_lex $P1850, "$cholder"
    $P1851 = $P1846."new"($P1849, $P1850, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 636
    $P1845."push"($P1851)
.annotate 'line', 641
    get_global $P1852, "@BLOCK"
    unless_null $P1852, vivify_576
    $P1852 = root_new ['parrot';'ResizablePMCArray']
  vivify_576:
    set $P1853, $P1852[0]
    unless_null $P1853, vivify_577
    new $P1853, "Undef"
  vivify_577:
    find_lex $P1854, "$name"
    find_lex $P1855, "$cholder"
    $P1853."symbol"($P1854, "lexical" :named("scope"), 1 :named("proto"), $P1855 :named("cholder"))
.annotate 'line', 644
    find_lex $P1856, "$past"
    $P1857 = $P1856."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 628
    .return ($P1857)
.end


.namespace ["NQP";"Actions"]
.sub "_block1738"  :anon :subid("93_1295307719.828") :outer("92_1295307719.828")
.annotate 'line', 577
    .const 'Sub' $P1757 = "94_1295307719.828" 
    capture_lex $P1757
.annotate 'line', 580
    new $P1740, "Undef"
    .lex "$cholder", $P1740
.annotate 'line', 581
    $P1741 = root_new ['parrot';'Hash']
    .lex "%sym", $P1741
.annotate 'line', 579
    find_dynamic_lex $P1743, "$*SCOPE"
    unless_null $P1743, vivify_578
    get_hll_global $P1743, "$SCOPE"
    unless_null $P1743, vivify_579
    die "Contextual $*SCOPE not found"
  vivify_579:
  vivify_578:
    set $S1744, $P1743
    iseq $I1745, $S1744, "our"
    unless $I1745, if_1742_end
    die "our-scoped multis not yet implemented"
  if_1742_end:
    find_lex $P1746, "$cholder"
.annotate 'line', 581
    get_global $P1747, "@BLOCK"
    unless_null $P1747, vivify_580
    $P1747 = root_new ['parrot';'ResizablePMCArray']
  vivify_580:
    set $P1748, $P1747[0]
    unless_null $P1748, vivify_581
    new $P1748, "Undef"
  vivify_581:
    find_lex $P1749, "$name"
    $P1750 = $P1748."symbol"($P1749)
    store_lex "%sym", $P1750
.annotate 'line', 582
    find_lex $P1752, "%sym"
    unless_null $P1752, vivify_582
    $P1752 = root_new ['parrot';'Hash']
  vivify_582:
    set $P1753, $P1752["cholder"]
    unless_null $P1753, vivify_583
    new $P1753, "Undef"
  vivify_583:
    if $P1753, if_1751
.annotate 'line', 587
    .const 'Sub' $P1757 = "94_1295307719.828" 
    capture_lex $P1757
    $P1757()
    goto if_1751_end
  if_1751:
.annotate 'line', 583
    find_lex $P1754, "%sym"
    unless_null $P1754, vivify_596
    $P1754 = root_new ['parrot';'Hash']
  vivify_596:
    set $P1755, $P1754["cholder"]
    unless_null $P1755, vivify_597
    new $P1755, "Undef"
  vivify_597:
    store_lex "$cholder", $P1755
  if_1751_end:
.annotate 'line', 623
    find_lex $P1819, "$cholder"
    find_lex $P1820, "$past"
    $P1819."push"($P1820)
.annotate 'line', 626
    find_lex $P1821, "$past"
    $P1822 = "attach_multi_signature"($P1821)
.annotate 'line', 577
    .return ($P1822)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1756"  :anon :subid("94_1295307719.828") :outer("93_1295307719.828")
.annotate 'line', 587
    .const 'Sub' $P1771 = "95_1295307719.828" 
    capture_lex $P1771
.annotate 'line', 594
    new $P1758, "Undef"
    .lex "$found_proto", $P1758
.annotate 'line', 612
    new $P1759, "Undef"
    .lex "$dispatch_setup", $P1759
.annotate 'line', 589
    find_lex $P1761, "%sym"
    unless_null $P1761, vivify_584
    $P1761 = root_new ['parrot';'Hash']
  vivify_584:
    set $P1762, $P1761["proto"]
    unless_null $P1762, vivify_585
    new $P1762, "Undef"
  vivify_585:
    unless $P1762, if_1760_end
.annotate 'line', 592
    find_lex $P1763, "$/"
    $P1764 = $P1763."CURSOR"()
    $P1764."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1760_end:
.annotate 'line', 589
    find_lex $P1765, "$found_proto"
.annotate 'line', 595
    get_global $P1767, "@BLOCK"
    defined $I1768, $P1767
    unless $I1768, for_undef_586
    iter $P1766, $P1767
    new $P1793, 'ExceptionHandler'
    set_addr $P1793, loop1792_handler
    $P1793."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1793
  loop1792_test:
    unless $P1766, loop1792_done
    shift $P1769, $P1766
  loop1792_redo:
    .const 'Sub' $P1771 = "95_1295307719.828" 
    capture_lex $P1771
    $P1771($P1769)
  loop1792_next:
    goto loop1792_test
  loop1792_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1794, exception, 'type'
    eq $P1794, .CONTROL_LOOP_NEXT, loop1792_next
    eq $P1794, .CONTROL_LOOP_REDO, loop1792_redo
  loop1792_done:
    pop_eh 
  for_undef_586:
.annotate 'line', 606
    find_lex $P1796, "$found_proto"
    if $P1796, unless_1795_end
.annotate 'line', 607
    find_lex $P1797, "$/"
    $P1798 = $P1797."CURSOR"()
    $P1798."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1795_end:
.annotate 'line', 611
    get_hll_global $P1799, ["PAST"], "Op"
    $P1800 = $P1799."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1800
.annotate 'line', 612
    get_hll_global $P1801, ["PAST"], "Op"
.annotate 'line', 614
    get_hll_global $P1802, ["PAST"], "Var"
    find_lex $P1803, "$name"
    $P1804 = $P1802."new"($P1803 :named("name"), "outer" :named("scope"))
    find_lex $P1805, "$cholder"
    $P1806 = $P1801."new"($P1804, $P1805, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 612
    store_lex "$dispatch_setup", $P1806
.annotate 'line', 617
    get_global $P1807, "@BLOCK"
    unless_null $P1807, vivify_591
    $P1807 = root_new ['parrot';'ResizablePMCArray']
  vivify_591:
    set $P1808, $P1807[0]
    unless_null $P1808, vivify_592
    $P1808 = root_new ['parrot';'ResizablePMCArray']
  vivify_592:
    set $P1809, $P1808[0]
    unless_null $P1809, vivify_593
    new $P1809, "Undef"
  vivify_593:
    get_hll_global $P1810, ["PAST"], "Var"
    find_lex $P1811, "$name"
    find_lex $P1812, "$dispatch_setup"
    $P1813 = $P1810."new"($P1811 :named("name"), 1 :named("isdecl"), $P1812 :named("viviself"), "lexical" :named("scope"))
    $P1809."push"($P1813)
.annotate 'line', 619
    get_global $P1814, "@BLOCK"
    unless_null $P1814, vivify_594
    $P1814 = root_new ['parrot';'ResizablePMCArray']
  vivify_594:
    set $P1815, $P1814[0]
    unless_null $P1815, vivify_595
    new $P1815, "Undef"
  vivify_595:
    find_lex $P1816, "$name"
    find_lex $P1817, "$cholder"
    $P1818 = $P1815."symbol"($P1816, "lexical" :named("scope"), $P1817 :named("cholder"))
.annotate 'line', 587
    .return ($P1818)
.end


.namespace ["NQP";"Actions"]
.sub "_block1770"  :anon :subid("95_1295307719.828") :outer("94_1295307719.828")
    .param pmc param_1773
.annotate 'line', 596
    $P1772 = root_new ['parrot';'Hash']
    .lex "%sym", $P1772
    .lex "$_", param_1773
    find_lex $P1774, "$_"
    find_lex $P1775, "$name"
    $P1776 = $P1774."symbol"($P1775)
    store_lex "%sym", $P1776
.annotate 'line', 597
    find_lex $P1781, "%sym"
    unless_null $P1781, vivify_587
    $P1781 = root_new ['parrot';'Hash']
  vivify_587:
    set $P1782, $P1781["proto"]
    unless_null $P1782, vivify_588
    new $P1782, "Undef"
  vivify_588:
    unless $P1782, unless_1780
    set $P1779, $P1782
    goto unless_1780_end
  unless_1780:
    find_lex $P1783, "%sym"
    unless_null $P1783, vivify_589
    $P1783 = root_new ['parrot';'Hash']
  vivify_589:
    set $P1784, $P1783["cholder"]
    unless_null $P1784, vivify_590
    new $P1784, "Undef"
  vivify_590:
    set $P1779, $P1784
  unless_1780_end:
    if $P1779, if_1778
.annotate 'line', 600
    find_lex $P1788, "%sym"
    if $P1788, if_1787
    set $P1786, $P1788
    goto if_1787_end
  if_1787:
.annotate 'line', 601
    find_lex $P1789, "$/"
    $P1790 = $P1789."CURSOR"()
    $P1791 = $P1790."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 600
    set $P1786, $P1791
  if_1787_end:
    set $P1777, $P1786
.annotate 'line', 597
    goto if_1778_end
  if_1778:
.annotate 'line', 598
    new $P1785, "Integer"
    assign $P1785, 1
    store_lex "$found_proto", $P1785
.annotate 'line', 597
    set $P1777, $P1785
  if_1778_end:
.annotate 'line', 595
    .return ($P1777)
.end


.namespace ["NQP";"Actions"]
.sub "_block1912"  :anon :subid("97_1295307719.828") :outer("91_1295307719.828")
    .param pmc param_1914
.annotate 'line', 675
    .lex "$_", param_1914
    find_lex $P1915, "$_"
    $P1916 = $P1915."ast"()
    find_lex $P1917, "$/"
    $P1918 = $P1916($P1917)
    .return ($P1918)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("98_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_1929
    .param pmc param_1930
.annotate 'line', 682
    .const 'Sub' $P2034 = "100_1295307719.828" 
    capture_lex $P2034
    .const 'Sub' $P1961 = "99_1295307719.828" 
    capture_lex $P1961
    new $P1928, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1928, control_1927
    push_eh $P1928
    .lex "self", param_1929
    .lex "$/", param_1930
.annotate 'line', 690
    new $P1931, "Undef"
    .lex "$past", $P1931
.annotate 'line', 684
    find_dynamic_lex $P1933, "$*PACKAGE-SETUP"
    unless_null $P1933, vivify_604
    get_hll_global $P1933, "$PACKAGE-SETUP"
    unless_null $P1933, vivify_605
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_605:
  vivify_604:
    if $P1933, unless_1932_end
.annotate 'line', 685
    new $P1934, "Exception"
    set $P1934['type'], .CONTROL_RETURN
    find_lex $P1935, "$/"
    $P1936 = "OLD_method_def"($P1935)
    setattribute $P1934, 'payload', $P1936
    throw $P1934
  unless_1932_end:
.annotate 'line', 684
    find_lex $P1937, "$past"
.annotate 'line', 691
    find_lex $P1939, "$/"
    unless_null $P1939, vivify_606
    $P1939 = root_new ['parrot';'Hash']
  vivify_606:
    set $P1940, $P1939["onlystar"]
    unless_null $P1940, vivify_607
    new $P1940, "Undef"
  vivify_607:
    if $P1940, if_1938
.annotate 'line', 695
    find_lex $P1942, "$/"
    unless_null $P1942, vivify_608
    $P1942 = root_new ['parrot';'Hash']
  vivify_608:
    set $P1943, $P1942["blockoid"]
    unless_null $P1943, vivify_609
    new $P1943, "Undef"
  vivify_609:
    $P1944 = $P1943."ast"()
    store_lex "$past", $P1944
.annotate 'line', 696
    find_lex $P1945, "$past"
    $P1945."blocktype"("declaration")
.annotate 'line', 697
    find_lex $P1946, "$past"
    $P1946."control"("return_pir")
.annotate 'line', 694
    goto if_1938_end
  if_1938:
.annotate 'line', 692
    $P1941 = "only_star_block"()
    store_lex "$past", $P1941
  if_1938_end:
.annotate 'line', 701
    find_lex $P1948, "$past"
    unless_null $P1948, vivify_610
    $P1948 = root_new ['parrot';'Hash']
  vivify_610:
    set $P1949, $P1948["signature_has_invocant"]
    unless_null $P1949, vivify_611
    new $P1949, "Undef"
  vivify_611:
    if $P1949, unless_1947_end
.annotate 'line', 702
    find_lex $P1950, "$past"
    unless_null $P1950, vivify_612
    $P1950 = root_new ['parrot';'ResizablePMCArray']
  vivify_612:
    set $P1951, $P1950[0]
    unless_null $P1951, vivify_613
    new $P1951, "Undef"
  vivify_613:
    get_hll_global $P1952, ["PAST"], "Var"
.annotate 'line', 704
    get_hll_global $P1953, ["PAST"], "Var"
    $P1954 = $P1953."new"("$?CLASS" :named("name"), "package" :named("scope"))
    $P1955 = $P1952."new"("self" :named("name"), "parameter" :named("scope"), $P1954 :named("multitype"))
.annotate 'line', 702
    $P1951."unshift"($P1955)
  unless_1947_end:
.annotate 'line', 707
    find_lex $P1956, "$past"
    $P1956."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 710
    find_lex $P1958, "$/"
    unless_null $P1958, vivify_614
    $P1958 = root_new ['parrot';'Hash']
  vivify_614:
    set $P1959, $P1958["deflongname"]
    unless_null $P1959, vivify_615
    new $P1959, "Undef"
  vivify_615:
    unless $P1959, if_1957_end
    .const 'Sub' $P1961 = "99_1295307719.828" 
    capture_lex $P1961
    $P1961()
  if_1957_end:
.annotate 'line', 743
    find_dynamic_lex $P2019, "$*SCOPE"
    unless_null $P2019, vivify_629
    get_hll_global $P2019, "$SCOPE"
    unless_null $P2019, vivify_630
    die "Contextual $*SCOPE not found"
  vivify_630:
  vivify_629:
    set $S2020, $P2019
    iseq $I2021, $S2020, "our"
    unless $I2021, if_2018_end
.annotate 'line', 744
    find_lex $P2022, "$past"
    $P2022."pirflags"(":nsentry")
  if_2018_end:
.annotate 'line', 748
    find_lex $P2023, "$past"
    find_lex $P2024, "$past"
    unless_null $P2024, vivify_631
    $P2024 = root_new ['parrot';'Hash']
    store_lex "$past", $P2024
  vivify_631:
    set $P2024["block_past"], $P2023
.annotate 'line', 749
    find_lex $P2026, "$/"
    unless_null $P2026, vivify_632
    $P2026 = root_new ['parrot';'Hash']
  vivify_632:
    set $P2027, $P2026["trait"]
    unless_null $P2027, vivify_633
    new $P2027, "Undef"
  vivify_633:
    unless $P2027, if_2025_end
.annotate 'line', 750
    find_lex $P2029, "$/"
    unless_null $P2029, vivify_634
    $P2029 = root_new ['parrot';'Hash']
  vivify_634:
    set $P2030, $P2029["trait"]
    unless_null $P2030, vivify_635
    new $P2030, "Undef"
  vivify_635:
    defined $I2031, $P2030
    unless $I2031, for_undef_636
    iter $P2028, $P2030
    new $P2041, 'ExceptionHandler'
    set_addr $P2041, loop2040_handler
    $P2041."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2041
  loop2040_test:
    unless $P2028, loop2040_done
    shift $P2032, $P2028
  loop2040_redo:
    .const 'Sub' $P2034 = "100_1295307719.828" 
    capture_lex $P2034
    $P2034($P2032)
  loop2040_next:
    goto loop2040_test
  loop2040_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2042, exception, 'type'
    eq $P2042, .CONTROL_LOOP_NEXT, loop2040_next
    eq $P2042, .CONTROL_LOOP_REDO, loop2040_redo
  loop2040_done:
    pop_eh 
  for_undef_636:
  if_2025_end:
.annotate 'line', 753
    find_lex $P2043, "$/"
    find_lex $P2044, "$past"
    $P2045 = $P2043."!make"($P2044)
.annotate 'line', 682
    .return ($P2045)
  control_1927:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2046, exception, "payload"
    .return ($P2046)
.end


.namespace ["NQP";"Actions"]
.sub "_block1960"  :anon :subid("99_1295307719.828") :outer("98_1295307719.828")
.annotate 'line', 712
    new $P1962, "Undef"
    .lex "$name", $P1962
.annotate 'line', 717
    new $P1963, "Undef"
    .lex "$to_add", $P1963
.annotate 'line', 712
    find_lex $P1964, "$/"
    unless_null $P1964, vivify_616
    $P1964 = root_new ['parrot';'Hash']
  vivify_616:
    set $P1965, $P1964["deflongname"]
    unless_null $P1965, vivify_617
    $P1965 = root_new ['parrot';'ResizablePMCArray']
  vivify_617:
    set $P1966, $P1965[0]
    unless_null $P1966, vivify_618
    new $P1966, "Undef"
  vivify_618:
    $P1967 = $P1966."ast"()
    set $S1968, $P1967
    new $P1969, 'String'
    set $P1969, $S1968
    store_lex "$name", $P1969
.annotate 'line', 713
    find_lex $P1970, "$past"
    find_lex $P1971, "$name"
    $P1970."name"($P1971)
.annotate 'line', 717
    find_dynamic_lex $P1974, "$*MULTINESS"
    unless_null $P1974, vivify_619
    get_hll_global $P1974, "$MULTINESS"
    unless_null $P1974, vivify_620
    die "Contextual $*MULTINESS not found"
  vivify_620:
  vivify_619:
    set $S1975, $P1974
    isne $I1976, $S1975, "proto"
    if $I1976, if_1973
.annotate 'line', 719
    get_hll_global $P1980, ["PAST"], "Op"
.annotate 'line', 721
    get_hll_global $P1981, ["PAST"], "Val"
    find_lex $P1982, "$past"
    $P1983 = $P1981."new"($P1982 :named("value"))
.annotate 'line', 722
    get_hll_global $P1984, ["PAST"], "Op"
    $P1985 = $P1984."new"("list" :named("pasttype"))
    $P1986 = $P1980."new"($P1983, $P1985, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 719
    set $P1972, $P1986
.annotate 'line', 717
    goto if_1973_end
  if_1973:
.annotate 'line', 718
    get_hll_global $P1977, ["PAST"], "Val"
    find_lex $P1978, "$past"
    $P1979 = $P1977."new"($P1978 :named("value"))
    set $P1972, $P1979
  if_1973_end:
.annotate 'line', 717
    store_lex "$to_add", $P1972
.annotate 'line', 724
    find_dynamic_lex $P1988, "$*MULTINESS"
    unless_null $P1988, vivify_621
    get_hll_global $P1988, "$MULTINESS"
    unless_null $P1988, vivify_622
    die "Contextual $*MULTINESS not found"
  vivify_622:
  vivify_621:
    set $S1989, $P1988
    iseq $I1990, $S1989, "proto"
    unless $I1990, if_1987_end
    find_lex $P1991, "$past"
    $P1991."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1987_end:
.annotate 'line', 728
    find_dynamic_lex $P1993, "$*MULTINESS"
    unless_null $P1993, vivify_623
    get_hll_global $P1993, "$MULTINESS"
    unless_null $P1993, vivify_624
    die "Contextual $*MULTINESS not found"
  vivify_624:
  vivify_623:
    set $S1994, $P1993
    iseq $I1995, $S1994, "multi"
    unless $I1995, if_1992_end
    find_lex $P1996, "$past"
    "attach_multi_signature"($P1996)
  if_1992_end:
.annotate 'line', 731
    find_dynamic_lex $P1997, "$*PACKAGE-SETUP"
    unless_null $P1997, vivify_625
    get_hll_global $P1997, "$PACKAGE-SETUP"
    unless_null $P1997, vivify_626
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_626:
  vivify_625:
    get_hll_global $P1998, ["PAST"], "Op"
.annotate 'line', 732
    find_dynamic_lex $P2001, "$*MULTINESS"
    unless_null $P2001, vivify_627
    get_hll_global $P2001, "$MULTINESS"
    unless_null $P2001, vivify_628
    die "Contextual $*MULTINESS not found"
  vivify_628:
  vivify_627:
    set $S2002, $P2001
    iseq $I2003, $S2002, "multi"
    if $I2003, if_2000
    new $P2005, "String"
    assign $P2005, "add_method"
    set $P1999, $P2005
    goto if_2000_end
  if_2000:
    new $P2004, "String"
    assign $P2004, "add_multi_method"
    set $P1999, $P2004
  if_2000_end:
.annotate 'line', 733
    get_hll_global $P2006, ["PAST"], "Op"
.annotate 'line', 736
    get_hll_global $P2007, ["PAST"], "Var"
    $P2008 = $P2007."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2009 = $P2006."new"($P2008, "get_how PP" :named("pirop"))
.annotate 'line', 738
    get_hll_global $P2010, ["PAST"], "Var"
    $P2011 = $P2010."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 739
    get_hll_global $P2012, ["PAST"], "Val"
    find_lex $P2013, "$name"
    $P2014 = $P2012."new"($P2013 :named("value"))
    find_lex $P2015, "$to_add"
    $P2016 = $P1998."new"($P2009, $P2011, $P2014, $P2015, "callmethod" :named("pasttype"), $P1999 :named("name"))
.annotate 'line', 731
    $P2017 = $P1997."push"($P2016)
.annotate 'line', 710
    .return ($P2017)
.end


.namespace ["NQP";"Actions"]
.sub "_block2033"  :anon :subid("100_1295307719.828") :outer("98_1295307719.828")
    .param pmc param_2035
.annotate 'line', 750
    .lex "$_", param_2035
    find_lex $P2036, "$_"
    $P2037 = $P2036."ast"()
    find_lex $P2038, "$/"
    $P2039 = $P2037($P2038)
    .return ($P2039)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("101_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2053
    .param pmc param_2054
.annotate 'line', 806
    .const 'Sub' $P2087 = "103_1295307719.828" 
    capture_lex $P2087
    .const 'Sub' $P2063 = "102_1295307719.828" 
    capture_lex $P2063
    new $P2052, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2052, control_2051
    push_eh $P2052
    .lex "self", param_2053
    .lex "$/", param_2054
.annotate 'line', 807
    new $P2055, "Undef"
    .lex "$BLOCKINIT", $P2055
    get_global $P2056, "@BLOCK"
    unless_null $P2056, vivify_637
    $P2056 = root_new ['parrot';'ResizablePMCArray']
  vivify_637:
    set $P2057, $P2056[0]
    unless_null $P2057, vivify_638
    $P2057 = root_new ['parrot';'ResizablePMCArray']
  vivify_638:
    set $P2058, $P2057[0]
    unless_null $P2058, vivify_639
    new $P2058, "Undef"
  vivify_639:
    store_lex "$BLOCKINIT", $P2058
.annotate 'line', 808
    find_lex $P2060, "$/"
    unless_null $P2060, vivify_640
    $P2060 = root_new ['parrot';'Hash']
  vivify_640:
    set $P2061, $P2060["invocant"]
    unless_null $P2061, vivify_641
    new $P2061, "Undef"
  vivify_641:
    unless $P2061, if_2059_end
    .const 'Sub' $P2063 = "102_1295307719.828" 
    capture_lex $P2063
    $P2063()
  if_2059_end:
.annotate 'line', 817
    find_lex $P2082, "$/"
    unless_null $P2082, vivify_647
    $P2082 = root_new ['parrot';'Hash']
  vivify_647:
    set $P2083, $P2082["parameter"]
    unless_null $P2083, vivify_648
    new $P2083, "Undef"
  vivify_648:
    defined $I2084, $P2083
    unless $I2084, for_undef_649
    iter $P2081, $P2083
    new $P2094, 'ExceptionHandler'
    set_addr $P2094, loop2093_handler
    $P2094."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2094
  loop2093_test:
    unless $P2081, loop2093_done
    shift $P2085, $P2081
  loop2093_redo:
    .const 'Sub' $P2087 = "103_1295307719.828" 
    capture_lex $P2087
    $P2087($P2085)
  loop2093_next:
    goto loop2093_test
  loop2093_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2095, exception, 'type'
    eq $P2095, .CONTROL_LOOP_NEXT, loop2093_next
    eq $P2095, .CONTROL_LOOP_REDO, loop2093_redo
  loop2093_done:
    pop_eh 
  for_undef_649:
.annotate 'line', 806
    .return ($P2081)
  control_2051:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2096, exception, "payload"
    .return ($P2096)
.end


.namespace ["NQP";"Actions"]
.sub "_block2062"  :anon :subid("102_1295307719.828") :outer("101_1295307719.828")
.annotate 'line', 809
    new $P2064, "Undef"
    .lex "$inv", $P2064
    find_lex $P2065, "$/"
    unless_null $P2065, vivify_642
    $P2065 = root_new ['parrot';'Hash']
  vivify_642:
    set $P2066, $P2065["invocant"]
    unless_null $P2066, vivify_643
    $P2066 = root_new ['parrot';'ResizablePMCArray']
  vivify_643:
    set $P2067, $P2066[0]
    unless_null $P2067, vivify_644
    new $P2067, "Undef"
  vivify_644:
    $P2068 = $P2067."ast"()
    store_lex "$inv", $P2068
.annotate 'line', 810
    find_lex $P2069, "$BLOCKINIT"
    find_lex $P2070, "$inv"
    $P2069."push"($P2070)
.annotate 'line', 811
    find_lex $P2071, "$BLOCKINIT"
    get_hll_global $P2072, ["PAST"], "Var"
.annotate 'line', 813
    get_hll_global $P2073, ["PAST"], "Var"
    find_lex $P2074, "$inv"
    $P2075 = $P2074."name"()
    $P2076 = $P2073."new"("lexical" :named("scope"), $P2075 :named("name"))
    $P2077 = $P2072."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P2076 :named("viviself"))
.annotate 'line', 811
    $P2071."push"($P2077)
.annotate 'line', 815
    new $P2078, "Integer"
    assign $P2078, 1
    get_global $P2079, "@BLOCK"
    unless_null $P2079, vivify_645
    $P2079 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P2079
  vivify_645:
    set $P2080, $P2079[0]
    unless_null $P2080, vivify_646
    $P2080 = root_new ['parrot';'Hash']
    set $P2079[0], $P2080
  vivify_646:
    set $P2080["signature_has_invocant"], $P2078
.annotate 'line', 808
    .return ($P2078)
.end


.namespace ["NQP";"Actions"]
.sub "_block2086"  :anon :subid("103_1295307719.828") :outer("101_1295307719.828")
    .param pmc param_2088
.annotate 'line', 817
    .lex "$_", param_2088
    find_lex $P2089, "$BLOCKINIT"
    find_lex $P2090, "$_"
    $P2091 = $P2090."ast"()
    $P2092 = $P2089."push"($P2091)
    .return ($P2092)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "parameter"  :subid("104_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2100
    .param pmc param_2101
.annotate 'line', 820
    new $P2099, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2099, control_2098
    push_eh $P2099
    .lex "self", param_2100
    .lex "$/", param_2101
.annotate 'line', 821
    new $P2102, "Undef"
    .lex "$quant", $P2102
.annotate 'line', 822
    new $P2103, "Undef"
    .lex "$past", $P2103
.annotate 'line', 821
    find_lex $P2104, "$/"
    unless_null $P2104, vivify_650
    $P2104 = root_new ['parrot';'Hash']
  vivify_650:
    set $P2105, $P2104["quant"]
    unless_null $P2105, vivify_651
    new $P2105, "Undef"
  vivify_651:
    store_lex "$quant", $P2105
    find_lex $P2106, "$past"
.annotate 'line', 823
    find_lex $P2108, "$/"
    unless_null $P2108, vivify_652
    $P2108 = root_new ['parrot';'Hash']
  vivify_652:
    set $P2109, $P2108["named_param"]
    unless_null $P2109, vivify_653
    new $P2109, "Undef"
  vivify_653:
    if $P2109, if_2107
.annotate 'line', 830
    find_lex $P2123, "$/"
    unless_null $P2123, vivify_654
    $P2123 = root_new ['parrot';'Hash']
  vivify_654:
    set $P2124, $P2123["param_var"]
    unless_null $P2124, vivify_655
    new $P2124, "Undef"
  vivify_655:
    $P2125 = $P2124."ast"()
    store_lex "$past", $P2125
.annotate 'line', 831
    find_lex $P2127, "$quant"
    set $S2128, $P2127
    iseq $I2129, $S2128, "*"
    if $I2129, if_2126
.annotate 'line', 835
    find_lex $P2138, "$quant"
    set $S2139, $P2138
    iseq $I2140, $S2139, "?"
    unless $I2140, if_2137_end
.annotate 'line', 836
    find_lex $P2141, "$past"
    find_lex $P2142, "$/"
    unless_null $P2142, vivify_656
    $P2142 = root_new ['parrot';'Hash']
  vivify_656:
    set $P2143, $P2142["param_var"]
    unless_null $P2143, vivify_657
    $P2143 = root_new ['parrot';'Hash']
  vivify_657:
    set $P2144, $P2143["sigil"]
    unless_null $P2144, vivify_658
    new $P2144, "Undef"
  vivify_658:
    $P2145 = "vivitype"($P2144)
    $P2141."viviself"($P2145)
  if_2137_end:
.annotate 'line', 835
    goto if_2126_end
  if_2126:
.annotate 'line', 832
    find_lex $P2130, "$past"
    $P2130."slurpy"(1)
.annotate 'line', 833
    find_lex $P2131, "$past"
    find_lex $P2132, "$/"
    unless_null $P2132, vivify_659
    $P2132 = root_new ['parrot';'Hash']
  vivify_659:
    set $P2133, $P2132["param_var"]
    unless_null $P2133, vivify_660
    $P2133 = root_new ['parrot';'Hash']
  vivify_660:
    set $P2134, $P2133["sigil"]
    unless_null $P2134, vivify_661
    new $P2134, "Undef"
  vivify_661:
    set $S2135, $P2134
    iseq $I2136, $S2135, "%"
    $P2131."named"($I2136)
  if_2126_end:
.annotate 'line', 829
    goto if_2107_end
  if_2107:
.annotate 'line', 824
    find_lex $P2110, "$/"
    unless_null $P2110, vivify_662
    $P2110 = root_new ['parrot';'Hash']
  vivify_662:
    set $P2111, $P2110["named_param"]
    unless_null $P2111, vivify_663
    new $P2111, "Undef"
  vivify_663:
    $P2112 = $P2111."ast"()
    store_lex "$past", $P2112
.annotate 'line', 825
    find_lex $P2114, "$quant"
    set $S2115, $P2114
    isne $I2116, $S2115, "!"
    unless $I2116, if_2113_end
.annotate 'line', 826
    find_lex $P2117, "$past"
    find_lex $P2118, "$/"
    unless_null $P2118, vivify_664
    $P2118 = root_new ['parrot';'Hash']
  vivify_664:
    set $P2119, $P2118["named_param"]
    unless_null $P2119, vivify_665
    $P2119 = root_new ['parrot';'Hash']
  vivify_665:
    set $P2120, $P2119["param_var"]
    unless_null $P2120, vivify_666
    $P2120 = root_new ['parrot';'Hash']
  vivify_666:
    set $P2121, $P2120["sigil"]
    unless_null $P2121, vivify_667
    new $P2121, "Undef"
  vivify_667:
    $P2122 = "vivitype"($P2121)
    $P2117."viviself"($P2122)
  if_2113_end:
  if_2107_end:
.annotate 'line', 839
    find_lex $P2147, "$/"
    unless_null $P2147, vivify_668
    $P2147 = root_new ['parrot';'Hash']
  vivify_668:
    set $P2148, $P2147["default_value"]
    unless_null $P2148, vivify_669
    new $P2148, "Undef"
  vivify_669:
    unless $P2148, if_2146_end
.annotate 'line', 840
    find_lex $P2150, "$quant"
    set $S2151, $P2150
    iseq $I2152, $S2151, "*"
    unless $I2152, if_2149_end
.annotate 'line', 841
    find_lex $P2153, "$/"
    $P2154 = $P2153."CURSOR"()
    $P2154."panic"("Can't put default on slurpy parameter")
  if_2149_end:
.annotate 'line', 843
    find_lex $P2156, "$quant"
    set $S2157, $P2156
    iseq $I2158, $S2157, "!"
    unless $I2158, if_2155_end
.annotate 'line', 844
    find_lex $P2159, "$/"
    $P2160 = $P2159."CURSOR"()
    $P2160."panic"("Can't put default on required parameter")
  if_2155_end:
.annotate 'line', 846
    find_lex $P2161, "$past"
    find_lex $P2162, "$/"
    unless_null $P2162, vivify_670
    $P2162 = root_new ['parrot';'Hash']
  vivify_670:
    set $P2163, $P2162["default_value"]
    unless_null $P2163, vivify_671
    $P2163 = root_new ['parrot';'ResizablePMCArray']
  vivify_671:
    set $P2164, $P2163[0]
    unless_null $P2164, vivify_672
    $P2164 = root_new ['parrot';'Hash']
  vivify_672:
    set $P2165, $P2164["EXPR"]
    unless_null $P2165, vivify_673
    new $P2165, "Undef"
  vivify_673:
    $P2166 = $P2165."ast"()
    $P2161."viviself"($P2166)
  if_2146_end:
.annotate 'line', 848
    find_lex $P2168, "$past"
    $P2169 = $P2168."viviself"()
    if $P2169, unless_2167_end
    get_global $P2170, "@BLOCK"
    unless_null $P2170, vivify_674
    $P2170 = root_new ['parrot';'ResizablePMCArray']
  vivify_674:
    set $P2171, $P2170[0]
    unless_null $P2171, vivify_675
    new $P2171, "Undef"
  vivify_675:
    get_global $P2172, "@BLOCK"
    unless_null $P2172, vivify_676
    $P2172 = root_new ['parrot';'ResizablePMCArray']
  vivify_676:
    set $P2173, $P2172[0]
    unless_null $P2173, vivify_677
    new $P2173, "Undef"
  vivify_677:
    $P2174 = $P2173."arity"()
    set $N2175, $P2174
    new $P2176, 'Float'
    set $P2176, $N2175
    add $P2177, $P2176, 1
    $P2171."arity"($P2177)
  unless_2167_end:
.annotate 'line', 852
    find_lex $P2179, "$/"
    unless_null $P2179, vivify_678
    $P2179 = root_new ['parrot';'Hash']
  vivify_678:
    set $P2180, $P2179["typename"]
    unless_null $P2180, vivify_679
    new $P2180, "Undef"
  vivify_679:
    unless $P2180, if_2178_end
.annotate 'line', 853
    find_lex $P2181, "$past"
    find_lex $P2182, "$/"
    unless_null $P2182, vivify_680
    $P2182 = root_new ['parrot';'Hash']
  vivify_680:
    set $P2183, $P2182["typename"]
    unless_null $P2183, vivify_681
    $P2183 = root_new ['parrot';'ResizablePMCArray']
  vivify_681:
    set $P2184, $P2183[0]
    unless_null $P2184, vivify_682
    new $P2184, "Undef"
  vivify_682:
    $P2185 = $P2184."ast"()
    $P2181."multitype"($P2185)
  if_2178_end:
.annotate 'line', 857
    find_lex $P2187, "$/"
    unless_null $P2187, vivify_683
    $P2187 = root_new ['parrot';'Hash']
  vivify_683:
    set $P2188, $P2187["definedness"]
    unless_null $P2188, vivify_684
    new $P2188, "Undef"
  vivify_684:
    unless $P2188, if_2186_end
.annotate 'line', 858
    find_lex $P2189, "$/"
    unless_null $P2189, vivify_685
    $P2189 = root_new ['parrot';'Hash']
  vivify_685:
    set $P2190, $P2189["definedness"]
    unless_null $P2190, vivify_686
    $P2190 = root_new ['parrot';'ResizablePMCArray']
  vivify_686:
    set $P2191, $P2190[0]
    unless_null $P2191, vivify_687
    new $P2191, "Undef"
  vivify_687:
    set $S2192, $P2191
    new $P2193, 'String'
    set $P2193, $S2192
    find_lex $P2194, "$past"
    unless_null $P2194, vivify_688
    $P2194 = root_new ['parrot';'Hash']
    store_lex "$past", $P2194
  vivify_688:
    set $P2194["definedness"], $P2193
  if_2186_end:
.annotate 'line', 861
    find_lex $P2195, "$/"
    find_lex $P2196, "$past"
    $P2197 = $P2195."!make"($P2196)
.annotate 'line', 820
    .return ($P2197)
  control_2098:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2198, exception, "payload"
    .return ($P2198)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "param_var"  :subid("105_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2202
    .param pmc param_2203
.annotate 'line', 864
    new $P2201, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2201, control_2200
    push_eh $P2201
    .lex "self", param_2202
    .lex "$/", param_2203
.annotate 'line', 865
    new $P2204, "Undef"
    .lex "$name", $P2204
.annotate 'line', 866
    new $P2205, "Undef"
    .lex "$past", $P2205
.annotate 'line', 865
    find_lex $P2206, "$/"
    set $S2207, $P2206
    new $P2208, 'String'
    set $P2208, $S2207
    store_lex "$name", $P2208
.annotate 'line', 866
    get_hll_global $P2209, ["PAST"], "Var"
    find_lex $P2210, "$name"
    find_lex $P2211, "$/"
    $P2212 = $P2209."new"($P2210 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P2211 :named("node"))
    store_lex "$past", $P2212
.annotate 'line', 868
    get_global $P2213, "@BLOCK"
    unless_null $P2213, vivify_689
    $P2213 = root_new ['parrot';'ResizablePMCArray']
  vivify_689:
    set $P2214, $P2213[0]
    unless_null $P2214, vivify_690
    new $P2214, "Undef"
  vivify_690:
    find_lex $P2215, "$name"
    $P2214."symbol"($P2215, "lexical" :named("scope"))
.annotate 'line', 869
    find_lex $P2216, "$/"
    find_lex $P2217, "$past"
    $P2218 = $P2216."!make"($P2217)
.annotate 'line', 864
    .return ($P2218)
  control_2200:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2219, exception, "payload"
    .return ($P2219)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "named_param"  :subid("106_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2223
    .param pmc param_2224
.annotate 'line', 872
    new $P2222, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2222, control_2221
    push_eh $P2222
    .lex "self", param_2223
    .lex "$/", param_2224
.annotate 'line', 873
    new $P2225, "Undef"
    .lex "$past", $P2225
    find_lex $P2226, "$/"
    unless_null $P2226, vivify_691
    $P2226 = root_new ['parrot';'Hash']
  vivify_691:
    set $P2227, $P2226["param_var"]
    unless_null $P2227, vivify_692
    new $P2227, "Undef"
  vivify_692:
    $P2228 = $P2227."ast"()
    store_lex "$past", $P2228
.annotate 'line', 874
    find_lex $P2229, "$past"
    find_lex $P2230, "$/"
    unless_null $P2230, vivify_693
    $P2230 = root_new ['parrot';'Hash']
  vivify_693:
    set $P2231, $P2230["param_var"]
    unless_null $P2231, vivify_694
    $P2231 = root_new ['parrot';'Hash']
  vivify_694:
    set $P2232, $P2231["name"]
    unless_null $P2232, vivify_695
    new $P2232, "Undef"
  vivify_695:
    set $S2233, $P2232
    $P2229."named"($S2233)
.annotate 'line', 875
    find_lex $P2234, "$/"
    find_lex $P2235, "$past"
    $P2236 = $P2234."!make"($P2235)
.annotate 'line', 872
    .return ($P2236)
  control_2221:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2237, exception, "payload"
    .return ($P2237)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "typename"  :subid("107_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2241
    .param pmc param_2242
.annotate 'line', 878
    new $P2240, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2240, control_2239
    push_eh $P2240
    .lex "self", param_2241
    .lex "$/", param_2242
.annotate 'line', 879
    $P2243 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P2243
    get_hll_global $P2244, ["HLL"], "Compiler"
    find_lex $P2245, "$/"
    set $S2246, $P2245
    $P2247 = $P2244."parse_name"($S2246)
    store_lex "@name", $P2247
.annotate 'line', 880
    find_lex $P2248, "$/"
    get_hll_global $P2249, ["PAST"], "Var"
.annotate 'line', 881
    find_lex $P2250, "@name"
    $P2251 = $P2250."pop"()
    find_lex $P2252, "@name"
    $P2253 = $P2249."new"($P2251 :named("name"), $P2252 :named("namespace"), "package" :named("scope"))
.annotate 'line', 880
    $P2254 = $P2248."!make"($P2253)
.annotate 'line', 878
    .return ($P2254)
  control_2239:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2255, exception, "payload"
    .return ($P2255)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "trait"  :subid("108_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2259
    .param pmc param_2260
.annotate 'line', 887
    new $P2258, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2258, control_2257
    push_eh $P2258
    .lex "self", param_2259
    .lex "$/", param_2260
.annotate 'line', 888
    find_lex $P2261, "$/"
    find_lex $P2262, "$/"
    unless_null $P2262, vivify_696
    $P2262 = root_new ['parrot';'Hash']
  vivify_696:
    set $P2263, $P2262["trait_mod"]
    unless_null $P2263, vivify_697
    new $P2263, "Undef"
  vivify_697:
    $P2264 = $P2263."ast"()
    $P2265 = $P2261."!make"($P2264)
.annotate 'line', 887
    .return ($P2265)
  control_2257:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2266, exception, "payload"
    .return ($P2266)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "trait_mod:sym<is>"  :subid("109_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2270
    .param pmc param_2271
.annotate 'line', 891
    .const 'Sub' $P2291 = "110_1295307719.828" 
    capture_lex $P2291
    new $P2269, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2269, control_2268
    push_eh $P2269
    .lex "self", param_2270
    .lex "$/", param_2271
.annotate 'line', 892
    new $P2272, "Undef"
    .lex "$cpast", $P2272
    find_lex $P2273, "$/"
    unless_null $P2273, vivify_698
    $P2273 = root_new ['parrot';'Hash']
  vivify_698:
    set $P2274, $P2273["circumfix"]
    unless_null $P2274, vivify_699
    $P2274 = root_new ['parrot';'ResizablePMCArray']
  vivify_699:
    set $P2275, $P2274[0]
    unless_null $P2275, vivify_700
    new $P2275, "Undef"
  vivify_700:
    $P2276 = $P2275."ast"()
    store_lex "$cpast", $P2276
.annotate 'line', 893
    find_lex $P2279, "$/"
    unless_null $P2279, vivify_701
    $P2279 = root_new ['parrot';'Hash']
  vivify_701:
    set $P2280, $P2279["longname"]
    unless_null $P2280, vivify_702
    new $P2280, "Undef"
  vivify_702:
    set $S2281, $P2280
    iseq $I2282, $S2281, "pirflags"
    if $I2282, if_2278
.annotate 'line', 899
    find_lex $P2301, "$/"
    $P2302 = $P2301."CURSOR"()
    new $P2303, 'String'
    set $P2303, "Trait '"
    find_lex $P2304, "$/"
    unless_null $P2304, vivify_703
    $P2304 = root_new ['parrot';'Hash']
  vivify_703:
    set $P2305, $P2304["longname"]
    unless_null $P2305, vivify_704
    new $P2305, "Undef"
  vivify_704:
    concat $P2306, $P2303, $P2305
    concat $P2307, $P2306, "' not implemented"
    $P2308 = $P2302."panic"($P2307)
.annotate 'line', 898
    set $P2277, $P2308
.annotate 'line', 893
    goto if_2278_end
  if_2278:
.annotate 'line', 895
    get_hll_global $P2284, ["PAST"], "Val"
    find_lex $P2285, "$cpast"
    $P2286 = $P2284."ACCEPTS"($P2285)
    if $P2286, unless_2283_end
.annotate 'line', 894
    find_lex $P2287, "$/"
    $P2288 = $P2287."CURSOR"()
    $P2288."panic"("Trait 'pirflags' requires constant scalar argument")
  unless_2283_end:
.annotate 'line', 896
    find_lex $P2289, "$/"
    .const 'Sub' $P2291 = "110_1295307719.828" 
    newclosure $P2299, $P2291
    $P2300 = $P2289."!make"($P2299)
.annotate 'line', 893
    set $P2277, $P2300
  if_2278_end:
.annotate 'line', 891
    .return ($P2277)
  control_2268:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2309, exception, "payload"
    .return ($P2309)
.end


.namespace ["NQP";"Actions"]
.sub "_block2290"  :anon :subid("110_1295307719.828") :outer("109_1295307719.828")
    .param pmc param_2292
.annotate 'line', 896
    .lex "$match", param_2292
    find_lex $P2293, "$match"
    $P2294 = $P2293."ast"()
    set $P2295, $P2294["block_past"]
    unless_null $P2295, vivify_705
    new $P2295, "Undef"
  vivify_705:
    find_lex $P2296, "$cpast"
    $P2297 = $P2296."value"()
    $P2298 = $P2295."pirflags"($P2297)
    .return ($P2298)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("111_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2313
    .param pmc param_2314
    .param pmc param_2315 :optional
    .param int has_param_2315 :opt_flag
.annotate 'line', 903
    .const 'Sub' $P2385 = "113_1295307719.828" 
    capture_lex $P2385
    .const 'Sub' $P2357 = "112_1295307719.828" 
    capture_lex $P2357
    new $P2312, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2312, control_2311
    push_eh $P2312
    .lex "self", param_2313
    .lex "$/", param_2314
    if has_param_2315, optparam_706
    new $P2316, "Undef"
    set param_2315, $P2316
  optparam_706:
    .lex "$key", param_2315
.annotate 'line', 904
    $P2317 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2317
.annotate 'line', 907
    new $P2318, "Undef"
    .lex "$name", $P2318
.annotate 'line', 908
    new $P2319, "Undef"
    .lex "$past", $P2319
.annotate 'line', 904

        $P2320 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2320
.annotate 'line', 907
    find_lex $P2321, "$/"
    unless_null $P2321, vivify_707
    $P2321 = root_new ['parrot';'Hash']
  vivify_707:
    set $P2322, $P2321["deflongname"]
    unless_null $P2322, vivify_708
    new $P2322, "Undef"
  vivify_708:
    $P2323 = $P2322."ast"()
    set $S2324, $P2323
    new $P2325, 'String'
    set $P2325, $S2324
    store_lex "$name", $P2325
    find_lex $P2326, "$past"
.annotate 'line', 909
    find_lex $P2328, "$/"
    unless_null $P2328, vivify_709
    $P2328 = root_new ['parrot';'Hash']
  vivify_709:
    set $P2329, $P2328["proto"]
    unless_null $P2329, vivify_710
    new $P2329, "Undef"
  vivify_710:
    if $P2329, if_2327
.annotate 'line', 936
    find_lex $P2353, "$key"
    set $S2354, $P2353
    iseq $I2355, $S2354, "open"
    if $I2355, if_2352
.annotate 'line', 949
    .const 'Sub' $P2385 = "113_1295307719.828" 
    capture_lex $P2385
    $P2385()
    goto if_2352_end
  if_2352:
.annotate 'line', 936
    .const 'Sub' $P2357 = "112_1295307719.828" 
    capture_lex $P2357
    $P2357()
  if_2352_end:
    goto if_2327_end
  if_2327:
.annotate 'line', 911
    get_hll_global $P2330, ["PAST"], "Stmts"
.annotate 'line', 912
    get_hll_global $P2331, ["PAST"], "Block"
    find_lex $P2332, "$name"
.annotate 'line', 913
    get_hll_global $P2333, ["PAST"], "Op"
.annotate 'line', 914
    get_hll_global $P2334, ["PAST"], "Var"
    $P2335 = $P2334."new"("self" :named("name"), "register" :named("scope"))
    find_lex $P2336, "$name"
    $P2337 = $P2333."new"($P2335, $P2336, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 913
    find_lex $P2338, "$/"
    $P2339 = $P2331."new"($P2337, $P2332 :named("name"), "method" :named("blocktype"), 0 :named("lexical"), $P2338 :named("node"))
.annotate 'line', 923
    get_hll_global $P2340, ["PAST"], "Block"
    new $P2341, "String"
    assign $P2341, "!PREFIX__"
    find_lex $P2342, "$name"
    concat $P2343, $P2341, $P2342
.annotate 'line', 924
    get_hll_global $P2344, ["PAST"], "Op"
.annotate 'line', 925
    get_hll_global $P2345, ["PAST"], "Var"
    $P2346 = $P2345."new"("self" :named("name"), "register" :named("scope"))
    find_lex $P2347, "$name"
    $P2348 = $P2344."new"($P2346, $P2347, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 924
    find_lex $P2349, "$/"
    $P2350 = $P2340."new"($P2348, $P2343 :named("name"), "method" :named("blocktype"), 0 :named("lexical"), $P2349 :named("node"))
.annotate 'line', 923
    $P2351 = $P2330."new"($P2339, $P2350)
.annotate 'line', 911
    store_lex "$past", $P2351
  if_2327_end:
.annotate 'line', 963
    find_lex $P2406, "$/"
    find_lex $P2407, "$past"
    $P2408 = $P2406."!make"($P2407)
.annotate 'line', 903
    .return ($P2408)
  control_2311:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2409, exception, "payload"
    .return ($P2409)
.end


.namespace ["NQP";"Actions"]
.sub "_block2384"  :anon :subid("113_1295307719.828") :outer("111_1295307719.828")
.annotate 'line', 950
    new $P2386, "Undef"
    .lex "$regex", $P2386
.annotate 'line', 951
    get_hll_global $P2387, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2388, "$/"
    unless_null $P2388, vivify_711
    $P2388 = root_new ['parrot';'Hash']
  vivify_711:
    set $P2389, $P2388["p6regex"]
    unless_null $P2389, vivify_712
    new $P2389, "Undef"
  vivify_712:
    $P2390 = $P2389."ast"()
    get_global $P2391, "@BLOCK"
    $P2392 = $P2391."shift"()
    $P2393 = $P2387($P2390, $P2392)
    store_lex "$regex", $P2393
.annotate 'line', 952
    find_lex $P2394, "$regex"
    find_lex $P2395, "$name"
    $P2394."name"($P2395)
.annotate 'line', 954
    get_hll_global $P2396, ["PAST"], "Op"
.annotate 'line', 956
    get_hll_global $P2397, ["PAST"], "Var"
    new $P2398, "ResizablePMCArray"
    push $P2398, "Regex"
    $P2399 = $P2397."new"("Method" :named("name"), $P2398 :named("namespace"), "package" :named("scope"))
    find_lex $P2400, "$regex"
    $P2401 = $P2396."new"($P2399, $P2400, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 954
    store_lex "$past", $P2401
.annotate 'line', 960
    find_lex $P2402, "$regex"
    find_lex $P2403, "$past"
    unless_null $P2403, vivify_713
    $P2403 = root_new ['parrot';'Hash']
    store_lex "$past", $P2403
  vivify_713:
    set $P2403["sink"], $P2402
.annotate 'line', 961
    find_lex $P2404, "@MODIFIERS"
    $P2405 = $P2404."shift"()
.annotate 'line', 949
    .return ($P2405)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2356"  :anon :subid("112_1295307719.828") :outer("111_1295307719.828")
.annotate 'line', 937
    $P2358 = root_new ['parrot';'Hash']
    .lex "%h", $P2358
.annotate 'line', 936
    find_lex $P2359, "%h"
.annotate 'line', 938
    find_lex $P2361, "$/"
    unless_null $P2361, vivify_714
    $P2361 = root_new ['parrot';'Hash']
  vivify_714:
    set $P2362, $P2361["sym"]
    unless_null $P2362, vivify_715
    new $P2362, "Undef"
  vivify_715:
    set $S2363, $P2362
    iseq $I2364, $S2363, "token"
    unless $I2364, if_2360_end
    new $P2365, "Integer"
    assign $P2365, 1
    find_lex $P2366, "%h"
    unless_null $P2366, vivify_716
    $P2366 = root_new ['parrot';'Hash']
    store_lex "%h", $P2366
  vivify_716:
    set $P2366["r"], $P2365
  if_2360_end:
.annotate 'line', 939
    find_lex $P2368, "$/"
    unless_null $P2368, vivify_717
    $P2368 = root_new ['parrot';'Hash']
  vivify_717:
    set $P2369, $P2368["sym"]
    unless_null $P2369, vivify_718
    new $P2369, "Undef"
  vivify_718:
    set $S2370, $P2369
    iseq $I2371, $S2370, "rule"
    unless $I2371, if_2367_end
    new $P2372, "Integer"
    assign $P2372, 1
    find_lex $P2373, "%h"
    unless_null $P2373, vivify_719
    $P2373 = root_new ['parrot';'Hash']
    store_lex "%h", $P2373
  vivify_719:
    set $P2373["r"], $P2372
    new $P2374, "Integer"
    assign $P2374, 1
    find_lex $P2375, "%h"
    unless_null $P2375, vivify_720
    $P2375 = root_new ['parrot';'Hash']
    store_lex "%h", $P2375
  vivify_720:
    set $P2375["s"], $P2374
  if_2367_end:
.annotate 'line', 940
    find_lex $P2376, "@MODIFIERS"
    find_lex $P2377, "%h"
    $P2376."unshift"($P2377)
.annotate 'line', 941

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 945
    get_global $P2378, "@BLOCK"
    unless_null $P2378, vivify_721
    $P2378 = root_new ['parrot';'ResizablePMCArray']
  vivify_721:
    set $P2379, $P2378[0]
    unless_null $P2379, vivify_722
    new $P2379, "Undef"
  vivify_722:
    $P2379."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 946
    get_global $P2380, "@BLOCK"
    unless_null $P2380, vivify_723
    $P2380 = root_new ['parrot';'ResizablePMCArray']
  vivify_723:
    set $P2381, $P2380[0]
    unless_null $P2381, vivify_724
    new $P2381, "Undef"
  vivify_724:
    $P2381."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 947
    new $P2382, "Exception"
    set $P2382['type'], .CONTROL_RETURN
    new $P2383, "Integer"
    assign $P2383, 0
    setattribute $P2382, 'payload', $P2383
    throw $P2382
.annotate 'line', 936
    .return ()
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "dotty"  :subid("114_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2413
    .param pmc param_2414
.annotate 'line', 967
    new $P2412, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2412, control_2411
    push_eh $P2412
    .lex "self", param_2413
    .lex "$/", param_2414
.annotate 'line', 968
    new $P2415, "Undef"
    .lex "$past", $P2415
    find_lex $P2418, "$/"
    unless_null $P2418, vivify_725
    $P2418 = root_new ['parrot';'Hash']
  vivify_725:
    set $P2419, $P2418["args"]
    unless_null $P2419, vivify_726
    new $P2419, "Undef"
  vivify_726:
    if $P2419, if_2417
    get_hll_global $P2424, ["PAST"], "Op"
    find_lex $P2425, "$/"
    $P2426 = $P2424."new"($P2425 :named("node"))
    set $P2416, $P2426
    goto if_2417_end
  if_2417:
    find_lex $P2420, "$/"
    unless_null $P2420, vivify_727
    $P2420 = root_new ['parrot';'Hash']
  vivify_727:
    set $P2421, $P2420["args"]
    unless_null $P2421, vivify_728
    $P2421 = root_new ['parrot';'ResizablePMCArray']
  vivify_728:
    set $P2422, $P2421[0]
    unless_null $P2422, vivify_729
    new $P2422, "Undef"
  vivify_729:
    $P2423 = $P2422."ast"()
    set $P2416, $P2423
  if_2417_end:
    store_lex "$past", $P2416
.annotate 'line', 969
    find_lex $P2428, "$/"
    unless_null $P2428, vivify_730
    $P2428 = root_new ['parrot';'Hash']
  vivify_730:
    set $P2429, $P2428["quote"]
    unless_null $P2429, vivify_731
    new $P2429, "Undef"
  vivify_731:
    if $P2429, if_2427
.annotate 'line', 973
    find_lex $P2436, "$/"
    unless_null $P2436, vivify_732
    $P2436 = root_new ['parrot';'Hash']
  vivify_732:
    set $P2437, $P2436["longname"]
    unless_null $P2437, vivify_733
    new $P2437, "Undef"
  vivify_733:
    set $S2438, $P2437
    iseq $I2439, $S2438, "HOW"
    if $I2439, if_2435
.annotate 'line', 977
    find_lex $P2443, "$/"
    unless_null $P2443, vivify_734
    $P2443 = root_new ['parrot';'Hash']
  vivify_734:
    set $P2444, $P2443["longname"]
    unless_null $P2444, vivify_735
    new $P2444, "Undef"
  vivify_735:
    set $S2445, $P2444
    iseq $I2446, $S2445, "WHAT"
    if $I2446, if_2442
.annotate 'line', 981
    find_lex $P2448, "$past"
    find_lex $P2449, "$/"
    unless_null $P2449, vivify_736
    $P2449 = root_new ['parrot';'Hash']
  vivify_736:
    set $P2450, $P2449["longname"]
    unless_null $P2450, vivify_737
    new $P2450, "Undef"
  vivify_737:
    set $S2451, $P2450
    $P2448."name"($S2451)
.annotate 'line', 982
    find_lex $P2452, "$past"
    $P2452."pasttype"("callmethod")
.annotate 'line', 980
    goto if_2442_end
  if_2442:
.annotate 'line', 978
    find_lex $P2447, "$past"
    $P2447."pirop"("get_what PP")
  if_2442_end:
.annotate 'line', 977
    goto if_2435_end
  if_2435:
.annotate 'line', 974
    find_lex $P2440, "$past"
    $P2440."pirop"("get_how PP")
.annotate 'line', 975
    find_lex $P2441, "$past"
    $P2441."pasttype"("pirop")
  if_2435_end:
.annotate 'line', 973
    goto if_2427_end
  if_2427:
.annotate 'line', 970
    find_lex $P2430, "$past"
    find_lex $P2431, "$/"
    unless_null $P2431, vivify_738
    $P2431 = root_new ['parrot';'Hash']
  vivify_738:
    set $P2432, $P2431["quote"]
    unless_null $P2432, vivify_739
    new $P2432, "Undef"
  vivify_739:
    $P2433 = $P2432."ast"()
    $P2430."name"($P2433)
.annotate 'line', 971
    find_lex $P2434, "$past"
    $P2434."pasttype"("callmethod")
  if_2427_end:
.annotate 'line', 984
    find_lex $P2453, "$/"
    find_lex $P2454, "$past"
    $P2455 = $P2453."!make"($P2454)
.annotate 'line', 967
    .return ($P2455)
  control_2411:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2456, exception, "payload"
    .return ($P2456)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<self>"  :subid("115_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2460
    .param pmc param_2461
.annotate 'line', 989
    new $P2459, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2459, control_2458
    push_eh $P2459
    .lex "self", param_2460
    .lex "$/", param_2461
.annotate 'line', 990
    find_lex $P2462, "$/"
    get_hll_global $P2463, ["PAST"], "Var"
    $P2464 = $P2463."new"("self" :named("name"))
    $P2465 = $P2462."!make"($P2464)
.annotate 'line', 989
    .return ($P2465)
  control_2458:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2466, exception, "payload"
    .return ($P2466)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<identifier>"  :subid("116_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2470
    .param pmc param_2471
.annotate 'line', 993
    new $P2469, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2469, control_2468
    push_eh $P2469
    .lex "self", param_2470
    .lex "$/", param_2471
.annotate 'line', 994
    new $P2472, "Undef"
    .lex "$past", $P2472
    find_lex $P2473, "$/"
    unless_null $P2473, vivify_740
    $P2473 = root_new ['parrot';'Hash']
  vivify_740:
    set $P2474, $P2473["args"]
    unless_null $P2474, vivify_741
    new $P2474, "Undef"
  vivify_741:
    $P2475 = $P2474."ast"()
    store_lex "$past", $P2475
.annotate 'line', 995
    find_lex $P2476, "$past"
    find_lex $P2477, "$/"
    unless_null $P2477, vivify_742
    $P2477 = root_new ['parrot';'Hash']
  vivify_742:
    set $P2478, $P2477["deflongname"]
    unless_null $P2478, vivify_743
    new $P2478, "Undef"
  vivify_743:
    set $S2479, $P2478
    $P2476."name"($S2479)
.annotate 'line', 996
    find_lex $P2480, "$/"
    find_lex $P2481, "$past"
    $P2482 = $P2480."!make"($P2481)
.annotate 'line', 993
    .return ($P2482)
  control_2468:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2483, exception, "payload"
    .return ($P2483)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<name>"  :subid("117_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2487
    .param pmc param_2488
.annotate 'line', 999
    new $P2486, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2486, control_2485
    push_eh $P2486
    .lex "self", param_2487
    .lex "$/", param_2488
.annotate 'line', 1000
    $P2489 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2489
.annotate 'line', 1001
    new $P2490, "Undef"
    .lex "$name", $P2490
.annotate 'line', 1003
    new $P2491, "Undef"
    .lex "$var", $P2491
.annotate 'line', 1005
    new $P2492, "Undef"
    .lex "$past", $P2492
.annotate 'line', 1000
    find_lex $P2493, "$/"
    unless_null $P2493, vivify_744
    $P2493 = root_new ['parrot';'Hash']
  vivify_744:
    set $P2494, $P2493["name"]
    unless_null $P2494, vivify_745
    $P2494 = root_new ['parrot';'Hash']
  vivify_745:
    set $P2495, $P2494["identifier"]
    unless_null $P2495, vivify_746
    new $P2495, "Undef"
  vivify_746:
    clone $P2496, $P2495
    store_lex "@ns", $P2496
.annotate 'line', 1001
    find_lex $P2497, "@ns"
    $P2498 = $P2497."pop"()
    store_lex "$name", $P2498
.annotate 'line', 1002
    find_lex $P2502, "@ns"
    if $P2502, if_2501
    set $P2500, $P2502
    goto if_2501_end
  if_2501:
    find_lex $P2503, "@ns"
    unless_null $P2503, vivify_747
    $P2503 = root_new ['parrot';'ResizablePMCArray']
  vivify_747:
    set $P2504, $P2503[0]
    unless_null $P2504, vivify_748
    new $P2504, "Undef"
  vivify_748:
    set $S2505, $P2504
    iseq $I2506, $S2505, "GLOBAL"
    new $P2500, 'Integer'
    set $P2500, $I2506
  if_2501_end:
    unless $P2500, if_2499_end
    find_lex $P2507, "@ns"
    $P2507."shift"()
  if_2499_end:
.annotate 'line', 1004
    get_hll_global $P2508, ["PAST"], "Var"
    find_lex $P2509, "$name"
    set $S2510, $P2509
    find_lex $P2511, "@ns"
    $P2512 = $P2508."new"($S2510 :named("name"), $P2511 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2512
.annotate 'line', 1005
    find_lex $P2513, "$var"
    store_lex "$past", $P2513
.annotate 'line', 1006
    find_lex $P2515, "$/"
    unless_null $P2515, vivify_749
    $P2515 = root_new ['parrot';'Hash']
  vivify_749:
    set $P2516, $P2515["args"]
    unless_null $P2516, vivify_750
    new $P2516, "Undef"
  vivify_750:
    unless $P2516, if_2514_end
.annotate 'line', 1007
    find_lex $P2517, "$/"
    unless_null $P2517, vivify_751
    $P2517 = root_new ['parrot';'Hash']
  vivify_751:
    set $P2518, $P2517["args"]
    unless_null $P2518, vivify_752
    $P2518 = root_new ['parrot';'ResizablePMCArray']
  vivify_752:
    set $P2519, $P2518[0]
    unless_null $P2519, vivify_753
    new $P2519, "Undef"
  vivify_753:
    $P2520 = $P2519."ast"()
    store_lex "$past", $P2520
.annotate 'line', 1008
    find_lex $P2521, "$past"
    find_lex $P2522, "$var"
    $P2521."unshift"($P2522)
  if_2514_end:
.annotate 'line', 1010
    find_lex $P2523, "$/"
    find_lex $P2524, "$past"
    $P2525 = $P2523."!make"($P2524)
.annotate 'line', 999
    .return ($P2525)
  control_2485:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2526, exception, "payload"
    .return ($P2526)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<pir::op>"  :subid("118_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2530
    .param pmc param_2531
.annotate 'line', 1013
    new $P2529, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2529, control_2528
    push_eh $P2529
    .lex "self", param_2530
    .lex "$/", param_2531
.annotate 'line', 1014
    new $P2532, "Undef"
    .lex "$past", $P2532
.annotate 'line', 1015
    new $P2533, "Undef"
    .lex "$pirop", $P2533
.annotate 'line', 1014
    find_lex $P2536, "$/"
    unless_null $P2536, vivify_754
    $P2536 = root_new ['parrot';'Hash']
  vivify_754:
    set $P2537, $P2536["args"]
    unless_null $P2537, vivify_755
    new $P2537, "Undef"
  vivify_755:
    if $P2537, if_2535
    get_hll_global $P2542, ["PAST"], "Op"
    find_lex $P2543, "$/"
    $P2544 = $P2542."new"($P2543 :named("node"))
    set $P2534, $P2544
    goto if_2535_end
  if_2535:
    find_lex $P2538, "$/"
    unless_null $P2538, vivify_756
    $P2538 = root_new ['parrot';'Hash']
  vivify_756:
    set $P2539, $P2538["args"]
    unless_null $P2539, vivify_757
    $P2539 = root_new ['parrot';'ResizablePMCArray']
  vivify_757:
    set $P2540, $P2539[0]
    unless_null $P2540, vivify_758
    new $P2540, "Undef"
  vivify_758:
    $P2541 = $P2540."ast"()
    set $P2534, $P2541
  if_2535_end:
    store_lex "$past", $P2534
.annotate 'line', 1015
    find_lex $P2545, "$/"
    unless_null $P2545, vivify_759
    $P2545 = root_new ['parrot';'Hash']
  vivify_759:
    set $P2546, $P2545["op"]
    unless_null $P2546, vivify_760
    new $P2546, "Undef"
  vivify_760:
    set $S2547, $P2546
    new $P2548, 'String'
    set $P2548, $S2547
    store_lex "$pirop", $P2548
.annotate 'line', 1016

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2549 = box $S0
    
    store_lex "$pirop", $P2549
.annotate 'line', 1023
    find_lex $P2550, "$past"
    find_lex $P2551, "$pirop"
    $P2550."pirop"($P2551)
.annotate 'line', 1024
    find_lex $P2552, "$past"
    $P2552."pasttype"("pirop")
.annotate 'line', 1025
    find_lex $P2553, "$/"
    find_lex $P2554, "$past"
    $P2555 = $P2553."!make"($P2554)
.annotate 'line', 1013
    .return ($P2555)
  control_2528:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2556, exception, "payload"
    .return ($P2556)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<onlystar>"  :subid("119_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2560
    .param pmc param_2561
.annotate 'line', 1028
    new $P2559, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2559, control_2558
    push_eh $P2559
    .lex "self", param_2560
    .lex "$/", param_2561
.annotate 'line', 1029
    find_lex $P2562, "$/"
    get_hll_global $P2563, ["PAST"], "Op"
    $P2564 = $P2563."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2565 = $P2562."!make"($P2564)
.annotate 'line', 1028
    .return ($P2565)
  control_2558:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2566, exception, "payload"
    .return ($P2566)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "args"  :subid("120_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2570
    .param pmc param_2571
.annotate 'line', 1034
    new $P2569, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2569, control_2568
    push_eh $P2569
    .lex "self", param_2570
    .lex "$/", param_2571
    find_lex $P2572, "$/"
    find_lex $P2573, "$/"
    unless_null $P2573, vivify_761
    $P2573 = root_new ['parrot';'Hash']
  vivify_761:
    set $P2574, $P2573["arglist"]
    unless_null $P2574, vivify_762
    new $P2574, "Undef"
  vivify_762:
    $P2575 = $P2574."ast"()
    $P2576 = $P2572."!make"($P2575)
    .return ($P2576)
  control_2568:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2577, exception, "payload"
    .return ($P2577)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("121_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2581
    .param pmc param_2582
.annotate 'line', 1036
    .const 'Sub' $P2593 = "122_1295307719.828" 
    capture_lex $P2593
    new $P2580, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2580, control_2579
    push_eh $P2580
    .lex "self", param_2581
    .lex "$/", param_2582
.annotate 'line', 1037
    new $P2583, "Undef"
    .lex "$past", $P2583
.annotate 'line', 1045
    new $P2584, "Undef"
    .lex "$i", $P2584
.annotate 'line', 1046
    new $P2585, "Undef"
    .lex "$n", $P2585
.annotate 'line', 1037
    get_hll_global $P2586, ["PAST"], "Op"
    find_lex $P2587, "$/"
    $P2588 = $P2586."new"("call" :named("pasttype"), $P2587 :named("node"))
    store_lex "$past", $P2588
.annotate 'line', 1038
    find_lex $P2590, "$/"
    unless_null $P2590, vivify_763
    $P2590 = root_new ['parrot';'Hash']
  vivify_763:
    set $P2591, $P2590["EXPR"]
    unless_null $P2591, vivify_764
    new $P2591, "Undef"
  vivify_764:
    unless $P2591, if_2589_end
    .const 'Sub' $P2593 = "122_1295307719.828" 
    capture_lex $P2593
    $P2593()
  if_2589_end:
.annotate 'line', 1045
    new $P2625, "Integer"
    assign $P2625, 0
    store_lex "$i", $P2625
.annotate 'line', 1046
    find_lex $P2626, "$past"
    $P2627 = $P2626."list"()
    set $N2628, $P2627
    new $P2629, 'Float'
    set $P2629, $N2628
    store_lex "$n", $P2629
.annotate 'line', 1047
    new $P2677, 'ExceptionHandler'
    set_addr $P2677, loop2676_handler
    $P2677."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2677
  loop2676_test:
    find_lex $P2630, "$i"
    set $N2631, $P2630
    find_lex $P2632, "$n"
    set $N2633, $P2632
    islt $I2634, $N2631, $N2633
    unless $I2634, loop2676_done
  loop2676_redo:
.annotate 'line', 1048
    find_lex $P2636, "$i"
    set $I2637, $P2636
    find_lex $P2638, "$past"
    unless_null $P2638, vivify_768
    $P2638 = root_new ['parrot';'ResizablePMCArray']
  vivify_768:
    set $P2639, $P2638[$I2637]
    unless_null $P2639, vivify_769
    new $P2639, "Undef"
  vivify_769:
    $S2640 = $P2639."name"()
    iseq $I2641, $S2640, "&prefix:<|>"
    unless $I2641, if_2635_end
.annotate 'line', 1049
    find_lex $P2642, "$i"
    set $I2643, $P2642
    find_lex $P2644, "$past"
    unless_null $P2644, vivify_770
    $P2644 = root_new ['parrot';'ResizablePMCArray']
  vivify_770:
    set $P2645, $P2644[$I2643]
    unless_null $P2645, vivify_771
    $P2645 = root_new ['parrot';'ResizablePMCArray']
  vivify_771:
    set $P2646, $P2645[0]
    unless_null $P2646, vivify_772
    new $P2646, "Undef"
  vivify_772:
    find_lex $P2647, "$i"
    set $I2648, $P2647
    find_lex $P2649, "$past"
    unless_null $P2649, vivify_773
    $P2649 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2649
  vivify_773:
    set $P2649[$I2648], $P2646
.annotate 'line', 1050
    find_lex $P2650, "$i"
    set $I2651, $P2650
    find_lex $P2652, "$past"
    unless_null $P2652, vivify_774
    $P2652 = root_new ['parrot';'ResizablePMCArray']
  vivify_774:
    set $P2653, $P2652[$I2651]
    unless_null $P2653, vivify_775
    new $P2653, "Undef"
  vivify_775:
    $P2653."flat"(1)
.annotate 'line', 1051
    find_lex $P2657, "$i"
    set $I2658, $P2657
    find_lex $P2659, "$past"
    unless_null $P2659, vivify_776
    $P2659 = root_new ['parrot';'ResizablePMCArray']
  vivify_776:
    set $P2660, $P2659[$I2658]
    unless_null $P2660, vivify_777
    new $P2660, "Undef"
  vivify_777:
    get_hll_global $P2661, ["PAST"], "Val"
    $P2662 = $P2660."isa"($P2661)
    if $P2662, if_2656
    set $P2655, $P2662
    goto if_2656_end
  if_2656:
.annotate 'line', 1052
    find_lex $P2663, "$i"
    set $I2664, $P2663
    find_lex $P2665, "$past"
    unless_null $P2665, vivify_778
    $P2665 = root_new ['parrot';'ResizablePMCArray']
  vivify_778:
    set $P2666, $P2665[$I2664]
    unless_null $P2666, vivify_779
    new $P2666, "Undef"
  vivify_779:
    $S2667 = $P2666."name"()
    substr $S2668, $S2667, 0, 1
    iseq $I2669, $S2668, "%"
    new $P2655, 'Integer'
    set $P2655, $I2669
  if_2656_end:
    unless $P2655, if_2654_end
.annotate 'line', 1053
    find_lex $P2670, "$i"
    set $I2671, $P2670
    find_lex $P2672, "$past"
    unless_null $P2672, vivify_780
    $P2672 = root_new ['parrot';'ResizablePMCArray']
  vivify_780:
    set $P2673, $P2672[$I2671]
    unless_null $P2673, vivify_781
    new $P2673, "Undef"
  vivify_781:
    $P2673."named"(1)
  if_2654_end:
  if_2635_end:
.annotate 'line', 1048
    find_lex $P2674, "$i"
    clone $P2675, $P2674
    inc $P2674
  loop2676_next:
.annotate 'line', 1047
    goto loop2676_test
  loop2676_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2678, exception, 'type'
    eq $P2678, .CONTROL_LOOP_NEXT, loop2676_next
    eq $P2678, .CONTROL_LOOP_REDO, loop2676_redo
  loop2676_done:
    pop_eh 
.annotate 'line', 1058
    find_lex $P2679, "$/"
    find_lex $P2680, "$past"
    $P2681 = $P2679."!make"($P2680)
.annotate 'line', 1036
    .return ($P2681)
  control_2579:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2682, exception, "payload"
    .return ($P2682)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2592"  :anon :subid("122_1295307719.828") :outer("121_1295307719.828")
.annotate 'line', 1038
    .const 'Sub' $P2614 = "123_1295307719.828" 
    capture_lex $P2614
.annotate 'line', 1039
    new $P2594, "Undef"
    .lex "$expr", $P2594
    find_lex $P2595, "$/"
    unless_null $P2595, vivify_765
    $P2595 = root_new ['parrot';'Hash']
  vivify_765:
    set $P2596, $P2595["EXPR"]
    unless_null $P2596, vivify_766
    new $P2596, "Undef"
  vivify_766:
    $P2597 = $P2596."ast"()
    store_lex "$expr", $P2597
.annotate 'line', 1040
    find_lex $P2602, "$expr"
    $S2603 = $P2602."name"()
    iseq $I2604, $S2603, "&infix:<,>"
    if $I2604, if_2601
    new $P2600, 'Integer'
    set $P2600, $I2604
    goto if_2601_end
  if_2601:
    find_lex $P2605, "$expr"
    $P2606 = $P2605."named"()
    isfalse $I2607, $P2606
    new $P2600, 'Integer'
    set $P2600, $I2607
  if_2601_end:
    if $P2600, if_2599
.annotate 'line', 1043
    find_lex $P2622, "$past"
    find_lex $P2623, "$expr"
    $P2624 = $P2622."push"($P2623)
    set $P2598, $P2624
.annotate 'line', 1040
    goto if_2599_end
  if_2599:
.annotate 'line', 1041
    find_lex $P2609, "$expr"
    $P2610 = $P2609."list"()
    defined $I2611, $P2610
    unless $I2611, for_undef_767
    iter $P2608, $P2610
    new $P2620, 'ExceptionHandler'
    set_addr $P2620, loop2619_handler
    $P2620."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2620
  loop2619_test:
    unless $P2608, loop2619_done
    shift $P2612, $P2608
  loop2619_redo:
    .const 'Sub' $P2614 = "123_1295307719.828" 
    capture_lex $P2614
    $P2614($P2612)
  loop2619_next:
    goto loop2619_test
  loop2619_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2621, exception, 'type'
    eq $P2621, .CONTROL_LOOP_NEXT, loop2619_next
    eq $P2621, .CONTROL_LOOP_REDO, loop2619_redo
  loop2619_done:
    pop_eh 
  for_undef_767:
.annotate 'line', 1040
    set $P2598, $P2608
  if_2599_end:
.annotate 'line', 1038
    .return ($P2598)
.end


.namespace ["NQP";"Actions"]
.sub "_block2613"  :anon :subid("123_1295307719.828") :outer("122_1295307719.828")
    .param pmc param_2615
.annotate 'line', 1041
    .lex "$_", param_2615
    find_lex $P2616, "$past"
    find_lex $P2617, "$_"
    $P2618 = $P2616."push"($P2617)
    .return ($P2618)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<multi_declarator>"  :subid("124_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2686
    .param pmc param_2687
.annotate 'line', 1061
    new $P2685, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2685, control_2684
    push_eh $P2685
    .lex "self", param_2686
    .lex "$/", param_2687
    find_lex $P2688, "$/"
    find_lex $P2689, "$/"
    unless_null $P2689, vivify_782
    $P2689 = root_new ['parrot';'Hash']
  vivify_782:
    set $P2690, $P2689["multi_declarator"]
    unless_null $P2690, vivify_783
    new $P2690, "Undef"
  vivify_783:
    $P2691 = $P2690."ast"()
    $P2692 = $P2688."!make"($P2691)
    .return ($P2692)
  control_2684:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2693, exception, "payload"
    .return ($P2693)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<value>"  :subid("125_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2697
    .param pmc param_2698
.annotate 'line', 1063
    new $P2696, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2696, control_2695
    push_eh $P2696
    .lex "self", param_2697
    .lex "$/", param_2698
    find_lex $P2699, "$/"
    find_lex $P2700, "$/"
    unless_null $P2700, vivify_784
    $P2700 = root_new ['parrot';'Hash']
  vivify_784:
    set $P2701, $P2700["value"]
    unless_null $P2701, vivify_785
    new $P2701, "Undef"
  vivify_785:
    $P2702 = $P2701."ast"()
    $P2703 = $P2699."!make"($P2702)
    .return ($P2703)
  control_2695:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2704, exception, "payload"
    .return ($P2704)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "circumfix:sym<( )>"  :subid("126_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2708
    .param pmc param_2709
.annotate 'line', 1065
    new $P2707, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2707, control_2706
    push_eh $P2707
    .lex "self", param_2708
    .lex "$/", param_2709
.annotate 'line', 1066
    find_lex $P2710, "$/"
.annotate 'line', 1067
    find_lex $P2713, "$/"
    unless_null $P2713, vivify_786
    $P2713 = root_new ['parrot';'Hash']
  vivify_786:
    set $P2714, $P2713["EXPR"]
    unless_null $P2714, vivify_787
    new $P2714, "Undef"
  vivify_787:
    if $P2714, if_2712
.annotate 'line', 1068
    get_hll_global $P2719, ["PAST"], "Op"
    find_lex $P2720, "$/"
    $P2721 = $P2719."new"("list" :named("pasttype"), $P2720 :named("node"))
    set $P2711, $P2721
.annotate 'line', 1067
    goto if_2712_end
  if_2712:
    find_lex $P2715, "$/"
    unless_null $P2715, vivify_788
    $P2715 = root_new ['parrot';'Hash']
  vivify_788:
    set $P2716, $P2715["EXPR"]
    unless_null $P2716, vivify_789
    $P2716 = root_new ['parrot';'ResizablePMCArray']
  vivify_789:
    set $P2717, $P2716[0]
    unless_null $P2717, vivify_790
    new $P2717, "Undef"
  vivify_790:
    $P2718 = $P2717."ast"()
    set $P2711, $P2718
  if_2712_end:
    $P2722 = $P2710."!make"($P2711)
.annotate 'line', 1065
    .return ($P2722)
  control_2706:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2723, exception, "payload"
    .return ($P2723)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "circumfix:sym<[ ]>"  :subid("127_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2727
    .param pmc param_2728
.annotate 'line', 1071
    new $P2726, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2726, control_2725
    push_eh $P2726
    .lex "self", param_2727
    .lex "$/", param_2728
.annotate 'line', 1072
    new $P2729, "Undef"
    .lex "$past", $P2729
.annotate 'line', 1071
    find_lex $P2730, "$past"
.annotate 'line', 1073
    find_lex $P2732, "$/"
    unless_null $P2732, vivify_791
    $P2732 = root_new ['parrot';'Hash']
  vivify_791:
    set $P2733, $P2732["EXPR"]
    unless_null $P2733, vivify_792
    new $P2733, "Undef"
  vivify_792:
    if $P2733, if_2731
.annotate 'line', 1080
    get_hll_global $P2745, ["PAST"], "Op"
    $P2746 = $P2745."new"("list" :named("pasttype"))
    store_lex "$past", $P2746
.annotate 'line', 1079
    goto if_2731_end
  if_2731:
.annotate 'line', 1074
    find_lex $P2734, "$/"
    unless_null $P2734, vivify_793
    $P2734 = root_new ['parrot';'Hash']
  vivify_793:
    set $P2735, $P2734["EXPR"]
    unless_null $P2735, vivify_794
    $P2735 = root_new ['parrot';'ResizablePMCArray']
  vivify_794:
    set $P2736, $P2735[0]
    unless_null $P2736, vivify_795
    new $P2736, "Undef"
  vivify_795:
    $P2737 = $P2736."ast"()
    store_lex "$past", $P2737
.annotate 'line', 1075
    find_lex $P2739, "$past"
    $S2740 = $P2739."name"()
    isne $I2741, $S2740, "&infix:<,>"
    unless $I2741, if_2738_end
.annotate 'line', 1076
    get_hll_global $P2742, ["PAST"], "Op"
    find_lex $P2743, "$past"
    $P2744 = $P2742."new"($P2743, "list" :named("pasttype"))
    store_lex "$past", $P2744
  if_2738_end:
  if_2731_end:
.annotate 'line', 1082
    find_lex $P2747, "$past"
    $P2747."name"("&circumfix:<[ ]>")
.annotate 'line', 1083
    find_lex $P2748, "$/"
    find_lex $P2749, "$past"
    $P2750 = $P2748."!make"($P2749)
.annotate 'line', 1071
    .return ($P2750)
  control_2725:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2751, exception, "payload"
    .return ($P2751)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "circumfix:sym<ang>"  :subid("128_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2755
    .param pmc param_2756
.annotate 'line', 1086
    new $P2754, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2754, control_2753
    push_eh $P2754
    .lex "self", param_2755
    .lex "$/", param_2756
    find_lex $P2757, "$/"
    find_lex $P2758, "$/"
    unless_null $P2758, vivify_796
    $P2758 = root_new ['parrot';'Hash']
  vivify_796:
    set $P2759, $P2758["quote_EXPR"]
    unless_null $P2759, vivify_797
    new $P2759, "Undef"
  vivify_797:
    $P2760 = $P2759."ast"()
    $P2761 = $P2757."!make"($P2760)
    .return ($P2761)
  control_2753:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2762, exception, "payload"
    .return ($P2762)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("129_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2766
    .param pmc param_2767
.annotate 'line', 1087
    new $P2765, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2765, control_2764
    push_eh $P2765
    .lex "self", param_2766
    .lex "$/", param_2767
    find_lex $P2768, "$/"
    find_lex $P2769, "$/"
    unless_null $P2769, vivify_798
    $P2769 = root_new ['parrot';'Hash']
  vivify_798:
    set $P2770, $P2769["quote_EXPR"]
    unless_null $P2770, vivify_799
    new $P2770, "Undef"
  vivify_799:
    $P2771 = $P2770."ast"()
    $P2772 = $P2768."!make"($P2771)
    .return ($P2772)
  control_2764:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2773, exception, "payload"
    .return ($P2773)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "circumfix:sym<{ }>"  :subid("130_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2777
    .param pmc param_2778
.annotate 'line', 1089
    new $P2776, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2776, control_2775
    push_eh $P2776
    .lex "self", param_2777
    .lex "$/", param_2778
.annotate 'line', 1090
    new $P2779, "Undef"
    .lex "$past", $P2779
    find_lex $P2782, "$/"
    unless_null $P2782, vivify_800
    $P2782 = root_new ['parrot';'Hash']
  vivify_800:
    set $P2783, $P2782["pblock"]
    unless_null $P2783, vivify_801
    $P2783 = root_new ['parrot';'Hash']
  vivify_801:
    set $P2784, $P2783["blockoid"]
    unless_null $P2784, vivify_802
    $P2784 = root_new ['parrot';'Hash']
  vivify_802:
    set $P2785, $P2784["statementlist"]
    unless_null $P2785, vivify_803
    $P2785 = root_new ['parrot';'Hash']
  vivify_803:
    set $P2786, $P2785["statement"]
    unless_null $P2786, vivify_804
    new $P2786, "Undef"
  vivify_804:
    set $N2787, $P2786
    isgt $I2788, $N2787, 0.0
    if $I2788, if_2781
.annotate 'line', 1092
    $P2792 = "vivitype"("%")
    set $P2780, $P2792
.annotate 'line', 1090
    goto if_2781_end
  if_2781:
.annotate 'line', 1091
    find_lex $P2789, "$/"
    unless_null $P2789, vivify_805
    $P2789 = root_new ['parrot';'Hash']
  vivify_805:
    set $P2790, $P2789["pblock"]
    unless_null $P2790, vivify_806
    new $P2790, "Undef"
  vivify_806:
    $P2791 = $P2790."ast"()
    set $P2780, $P2791
  if_2781_end:
    store_lex "$past", $P2780
.annotate 'line', 1093
    new $P2793, "Integer"
    assign $P2793, 1
    find_lex $P2794, "$past"
    unless_null $P2794, vivify_807
    $P2794 = root_new ['parrot';'Hash']
    store_lex "$past", $P2794
  vivify_807:
    set $P2794["bareblock"], $P2793
.annotate 'line', 1094
    find_lex $P2795, "$/"
    find_lex $P2796, "$past"
    $P2797 = $P2795."!make"($P2796)
.annotate 'line', 1089
    .return ($P2797)
  control_2775:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2798, exception, "payload"
    .return ($P2798)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "circumfix:sym<sigil>"  :subid("131_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2802
    .param pmc param_2803
.annotate 'line', 1097
    new $P2801, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2801, control_2800
    push_eh $P2801
    .lex "self", param_2802
    .lex "$/", param_2803
.annotate 'line', 1098
    new $P2804, "Undef"
    .lex "$name", $P2804
    find_lex $P2807, "$/"
    unless_null $P2807, vivify_808
    $P2807 = root_new ['parrot';'Hash']
  vivify_808:
    set $P2808, $P2807["sigil"]
    unless_null $P2808, vivify_809
    new $P2808, "Undef"
  vivify_809:
    set $S2809, $P2808
    iseq $I2810, $S2809, "@"
    if $I2810, if_2806
.annotate 'line', 1099
    find_lex $P2814, "$/"
    unless_null $P2814, vivify_810
    $P2814 = root_new ['parrot';'Hash']
  vivify_810:
    set $P2815, $P2814["sigil"]
    unless_null $P2815, vivify_811
    new $P2815, "Undef"
  vivify_811:
    set $S2816, $P2815
    iseq $I2817, $S2816, "%"
    if $I2817, if_2813
    new $P2819, "String"
    assign $P2819, "item"
    set $P2812, $P2819
    goto if_2813_end
  if_2813:
    new $P2818, "String"
    assign $P2818, "hash"
    set $P2812, $P2818
  if_2813_end:
    set $P2805, $P2812
.annotate 'line', 1098
    goto if_2806_end
  if_2806:
    new $P2811, "String"
    assign $P2811, "list"
    set $P2805, $P2811
  if_2806_end:
    store_lex "$name", $P2805
.annotate 'line', 1101
    find_lex $P2820, "$/"
    get_hll_global $P2821, ["PAST"], "Op"
    find_lex $P2822, "$name"
    find_lex $P2823, "$/"
    unless_null $P2823, vivify_812
    $P2823 = root_new ['parrot';'Hash']
  vivify_812:
    set $P2824, $P2823["semilist"]
    unless_null $P2824, vivify_813
    new $P2824, "Undef"
  vivify_813:
    $P2825 = $P2824."ast"()
    $P2826 = $P2821."new"($P2825, "callmethod" :named("pasttype"), $P2822 :named("name"))
    $P2827 = $P2820."!make"($P2826)
.annotate 'line', 1097
    .return ($P2827)
  control_2800:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2828, exception, "payload"
    .return ($P2828)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "semilist"  :subid("132_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2832
    .param pmc param_2833
.annotate 'line', 1104
    new $P2831, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2831, control_2830
    push_eh $P2831
    .lex "self", param_2832
    .lex "$/", param_2833
    find_lex $P2834, "$/"
    find_lex $P2835, "$/"
    unless_null $P2835, vivify_814
    $P2835 = root_new ['parrot';'Hash']
  vivify_814:
    set $P2836, $P2835["statement"]
    unless_null $P2836, vivify_815
    new $P2836, "Undef"
  vivify_815:
    $P2837 = $P2836."ast"()
    $P2838 = $P2834."!make"($P2837)
    .return ($P2838)
  control_2830:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2839, exception, "payload"
    .return ($P2839)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "postcircumfix:sym<[ ]>"  :subid("133_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2843
    .param pmc param_2844
.annotate 'line', 1106
    new $P2842, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2842, control_2841
    push_eh $P2842
    .lex "self", param_2843
    .lex "$/", param_2844
.annotate 'line', 1107
    find_lex $P2845, "$/"
    get_hll_global $P2846, ["PAST"], "Var"
    find_lex $P2847, "$/"
    unless_null $P2847, vivify_816
    $P2847 = root_new ['parrot';'Hash']
  vivify_816:
    set $P2848, $P2847["EXPR"]
    unless_null $P2848, vivify_817
    new $P2848, "Undef"
  vivify_817:
    $P2849 = $P2848."ast"()
.annotate 'line', 1109
    $P2850 = "vivitype"("@")
    $P2851 = $P2846."new"($P2849, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2850 :named("vivibase"))
.annotate 'line', 1107
    $P2852 = $P2845."!make"($P2851)
.annotate 'line', 1106
    .return ($P2852)
  control_2841:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2853, exception, "payload"
    .return ($P2853)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "postcircumfix:sym<{ }>"  :subid("134_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2857
    .param pmc param_2858
.annotate 'line', 1112
    new $P2856, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2856, control_2855
    push_eh $P2856
    .lex "self", param_2857
    .lex "$/", param_2858
.annotate 'line', 1113
    find_lex $P2859, "$/"
    get_hll_global $P2860, ["PAST"], "Var"
    find_lex $P2861, "$/"
    unless_null $P2861, vivify_818
    $P2861 = root_new ['parrot';'Hash']
  vivify_818:
    set $P2862, $P2861["EXPR"]
    unless_null $P2862, vivify_819
    new $P2862, "Undef"
  vivify_819:
    $P2863 = $P2862."ast"()
.annotate 'line', 1115
    $P2864 = "vivitype"("%")
    $P2865 = $P2860."new"($P2863, "keyed" :named("scope"), "Undef" :named("viviself"), $P2864 :named("vivibase"))
.annotate 'line', 1113
    $P2866 = $P2859."!make"($P2865)
.annotate 'line', 1112
    .return ($P2866)
  control_2855:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2867, exception, "payload"
    .return ($P2867)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "postcircumfix:sym<ang>"  :subid("135_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2871
    .param pmc param_2872
.annotate 'line', 1118
    new $P2870, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2870, control_2869
    push_eh $P2870
    .lex "self", param_2871
    .lex "$/", param_2872
.annotate 'line', 1119
    find_lex $P2873, "$/"
    get_hll_global $P2874, ["PAST"], "Var"
    find_lex $P2875, "$/"
    unless_null $P2875, vivify_820
    $P2875 = root_new ['parrot';'Hash']
  vivify_820:
    set $P2876, $P2875["quote_EXPR"]
    unless_null $P2876, vivify_821
    new $P2876, "Undef"
  vivify_821:
    $P2877 = $P2876."ast"()
.annotate 'line', 1121
    $P2878 = "vivitype"("%")
    $P2879 = $P2874."new"($P2877, "keyed" :named("scope"), "Undef" :named("viviself"), $P2878 :named("vivibase"))
.annotate 'line', 1119
    $P2880 = $P2873."!make"($P2879)
.annotate 'line', 1118
    .return ($P2880)
  control_2869:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2881, exception, "payload"
    .return ($P2881)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "postcircumfix:sym<( )>"  :subid("136_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2885
    .param pmc param_2886
.annotate 'line', 1124
    new $P2884, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2884, control_2883
    push_eh $P2884
    .lex "self", param_2885
    .lex "$/", param_2886
.annotate 'line', 1125
    find_lex $P2887, "$/"
    find_lex $P2888, "$/"
    unless_null $P2888, vivify_822
    $P2888 = root_new ['parrot';'Hash']
  vivify_822:
    set $P2889, $P2888["arglist"]
    unless_null $P2889, vivify_823
    new $P2889, "Undef"
  vivify_823:
    $P2890 = $P2889."ast"()
    $P2891 = $P2887."!make"($P2890)
.annotate 'line', 1124
    .return ($P2891)
  control_2883:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2892, exception, "payload"
    .return ($P2892)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "value"  :subid("137_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2896
    .param pmc param_2897
.annotate 'line', 1128
    new $P2895, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2895, control_2894
    push_eh $P2895
    .lex "self", param_2896
    .lex "$/", param_2897
.annotate 'line', 1129
    find_lex $P2898, "$/"
    find_lex $P2901, "$/"
    unless_null $P2901, vivify_824
    $P2901 = root_new ['parrot';'Hash']
  vivify_824:
    set $P2902, $P2901["quote"]
    unless_null $P2902, vivify_825
    new $P2902, "Undef"
  vivify_825:
    if $P2902, if_2900
    find_lex $P2906, "$/"
    unless_null $P2906, vivify_826
    $P2906 = root_new ['parrot';'Hash']
  vivify_826:
    set $P2907, $P2906["number"]
    unless_null $P2907, vivify_827
    new $P2907, "Undef"
  vivify_827:
    $P2908 = $P2907."ast"()
    set $P2899, $P2908
    goto if_2900_end
  if_2900:
    find_lex $P2903, "$/"
    unless_null $P2903, vivify_828
    $P2903 = root_new ['parrot';'Hash']
  vivify_828:
    set $P2904, $P2903["quote"]
    unless_null $P2904, vivify_829
    new $P2904, "Undef"
  vivify_829:
    $P2905 = $P2904."ast"()
    set $P2899, $P2905
  if_2900_end:
    $P2909 = $P2898."!make"($P2899)
.annotate 'line', 1128
    .return ($P2909)
  control_2894:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2910, exception, "payload"
    .return ($P2910)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "number"  :subid("138_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2914
    .param pmc param_2915
.annotate 'line', 1132
    new $P2913, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2913, control_2912
    push_eh $P2913
    .lex "self", param_2914
    .lex "$/", param_2915
.annotate 'line', 1133
    new $P2916, "Undef"
    .lex "$value", $P2916
    find_lex $P2919, "$/"
    unless_null $P2919, vivify_830
    $P2919 = root_new ['parrot';'Hash']
  vivify_830:
    set $P2920, $P2919["dec_number"]
    unless_null $P2920, vivify_831
    new $P2920, "Undef"
  vivify_831:
    if $P2920, if_2918
    find_lex $P2924, "$/"
    unless_null $P2924, vivify_832
    $P2924 = root_new ['parrot';'Hash']
  vivify_832:
    set $P2925, $P2924["integer"]
    unless_null $P2925, vivify_833
    new $P2925, "Undef"
  vivify_833:
    $P2926 = $P2925."ast"()
    set $P2917, $P2926
    goto if_2918_end
  if_2918:
    find_lex $P2921, "$/"
    unless_null $P2921, vivify_834
    $P2921 = root_new ['parrot';'Hash']
  vivify_834:
    set $P2922, $P2921["dec_number"]
    unless_null $P2922, vivify_835
    new $P2922, "Undef"
  vivify_835:
    $P2923 = $P2922."ast"()
    set $P2917, $P2923
  if_2918_end:
    store_lex "$value", $P2917
.annotate 'line', 1134
    find_lex $P2928, "$/"
    unless_null $P2928, vivify_836
    $P2928 = root_new ['parrot';'Hash']
  vivify_836:
    set $P2929, $P2928["sign"]
    unless_null $P2929, vivify_837
    new $P2929, "Undef"
  vivify_837:
    set $S2930, $P2929
    iseq $I2931, $S2930, "-"
    unless $I2931, if_2927_end
    find_lex $P2932, "$value"
    neg $P2933, $P2932
    store_lex "$value", $P2933
  if_2927_end:
.annotate 'line', 1135
    find_lex $P2934, "$/"
    get_hll_global $P2935, ["PAST"], "Val"
    find_lex $P2936, "$value"
    $P2937 = $P2935."new"($P2936 :named("value"))
    $P2938 = $P2934."!make"($P2937)
.annotate 'line', 1132
    .return ($P2938)
  control_2912:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2939, exception, "payload"
    .return ($P2939)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym<apos>"  :subid("139_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2943
    .param pmc param_2944
.annotate 'line', 1138
    new $P2942, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2942, control_2941
    push_eh $P2942
    .lex "self", param_2943
    .lex "$/", param_2944
    find_lex $P2945, "$/"
    find_lex $P2946, "$/"
    unless_null $P2946, vivify_838
    $P2946 = root_new ['parrot';'Hash']
  vivify_838:
    set $P2947, $P2946["quote_EXPR"]
    unless_null $P2947, vivify_839
    new $P2947, "Undef"
  vivify_839:
    $P2948 = $P2947."ast"()
    $P2949 = $P2945."!make"($P2948)
    .return ($P2949)
  control_2941:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2950, exception, "payload"
    .return ($P2950)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym<dblq>"  :subid("140_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2954
    .param pmc param_2955
.annotate 'line', 1139
    new $P2953, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2953, control_2952
    push_eh $P2953
    .lex "self", param_2954
    .lex "$/", param_2955
    find_lex $P2956, "$/"
    find_lex $P2957, "$/"
    unless_null $P2957, vivify_840
    $P2957 = root_new ['parrot';'Hash']
  vivify_840:
    set $P2958, $P2957["quote_EXPR"]
    unless_null $P2958, vivify_841
    new $P2958, "Undef"
  vivify_841:
    $P2959 = $P2958."ast"()
    $P2960 = $P2956."!make"($P2959)
    .return ($P2960)
  control_2952:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2961, exception, "payload"
    .return ($P2961)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym<qq>"  :subid("141_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2965
    .param pmc param_2966
.annotate 'line', 1140
    new $P2964, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2964, control_2963
    push_eh $P2964
    .lex "self", param_2965
    .lex "$/", param_2966
    find_lex $P2967, "$/"
    find_lex $P2968, "$/"
    unless_null $P2968, vivify_842
    $P2968 = root_new ['parrot';'Hash']
  vivify_842:
    set $P2969, $P2968["quote_EXPR"]
    unless_null $P2969, vivify_843
    new $P2969, "Undef"
  vivify_843:
    $P2970 = $P2969."ast"()
    $P2971 = $P2967."!make"($P2970)
    .return ($P2971)
  control_2963:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2972, exception, "payload"
    .return ($P2972)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym<q>"  :subid("142_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2976
    .param pmc param_2977
.annotate 'line', 1141
    new $P2975, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2975, control_2974
    push_eh $P2975
    .lex "self", param_2976
    .lex "$/", param_2977
    find_lex $P2978, "$/"
    find_lex $P2979, "$/"
    unless_null $P2979, vivify_844
    $P2979 = root_new ['parrot';'Hash']
  vivify_844:
    set $P2980, $P2979["quote_EXPR"]
    unless_null $P2980, vivify_845
    new $P2980, "Undef"
  vivify_845:
    $P2981 = $P2980."ast"()
    $P2982 = $P2978."!make"($P2981)
    .return ($P2982)
  control_2974:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2983, exception, "payload"
    .return ($P2983)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym<Q>"  :subid("143_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2987
    .param pmc param_2988
.annotate 'line', 1142
    new $P2986, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2986, control_2985
    push_eh $P2986
    .lex "self", param_2987
    .lex "$/", param_2988
    find_lex $P2989, "$/"
    find_lex $P2990, "$/"
    unless_null $P2990, vivify_846
    $P2990 = root_new ['parrot';'Hash']
  vivify_846:
    set $P2991, $P2990["quote_EXPR"]
    unless_null $P2991, vivify_847
    new $P2991, "Undef"
  vivify_847:
    $P2992 = $P2991."ast"()
    $P2993 = $P2989."!make"($P2992)
    .return ($P2993)
  control_2985:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2994, exception, "payload"
    .return ($P2994)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym<Q:PIR>"  :subid("144_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_2998
    .param pmc param_2999
.annotate 'line', 1143
    new $P2997, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2997, control_2996
    push_eh $P2997
    .lex "self", param_2998
    .lex "$/", param_2999
.annotate 'line', 1144
    find_lex $P3000, "$/"
    get_hll_global $P3001, ["PAST"], "Op"
    find_lex $P3002, "$/"
    unless_null $P3002, vivify_848
    $P3002 = root_new ['parrot';'Hash']
  vivify_848:
    set $P3003, $P3002["quote_EXPR"]
    unless_null $P3003, vivify_849
    new $P3003, "Undef"
  vivify_849:
    $P3004 = $P3003."ast"()
    $P3005 = $P3004."value"()
    find_lex $P3006, "$/"
    $P3007 = $P3001."new"($P3005 :named("inline"), "inline" :named("pasttype"), $P3006 :named("node"))
    $P3008 = $P3000."!make"($P3007)
.annotate 'line', 1143
    .return ($P3008)
  control_2996:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3009, exception, "payload"
    .return ($P3009)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("145_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3013
    .param pmc param_3014
    .param pmc param_3015 :optional
    .param int has_param_3015 :opt_flag
.annotate 'line', 1149
    new $P3012, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3012, control_3011
    push_eh $P3012
    .lex "self", param_3013
    .lex "$/", param_3014
    if has_param_3015, optparam_850
    new $P3016, "Undef"
    set param_3015, $P3016
  optparam_850:
    .lex "$key", param_3015
.annotate 'line', 1159
    new $P3017, "Undef"
    .lex "$regex", $P3017
.annotate 'line', 1161
    new $P3018, "Undef"
    .lex "$past", $P3018
.annotate 'line', 1150
    find_lex $P3020, "$key"
    set $S3021, $P3020
    iseq $I3022, $S3021, "open"
    unless $I3022, if_3019_end
.annotate 'line', 1151

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1155
    get_global $P3023, "@BLOCK"
    unless_null $P3023, vivify_851
    $P3023 = root_new ['parrot';'ResizablePMCArray']
  vivify_851:
    set $P3024, $P3023[0]
    unless_null $P3024, vivify_852
    new $P3024, "Undef"
  vivify_852:
    $P3024."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1156
    get_global $P3025, "@BLOCK"
    unless_null $P3025, vivify_853
    $P3025 = root_new ['parrot';'ResizablePMCArray']
  vivify_853:
    set $P3026, $P3025[0]
    unless_null $P3026, vivify_854
    new $P3026, "Undef"
  vivify_854:
    $P3026."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1157
    new $P3027, "Exception"
    set $P3027['type'], .CONTROL_RETURN
    new $P3028, "Integer"
    assign $P3028, 0
    setattribute $P3027, 'payload', $P3028
    throw $P3027
  if_3019_end:
.annotate 'line', 1160
    get_hll_global $P3029, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P3030, "$/"
    unless_null $P3030, vivify_855
    $P3030 = root_new ['parrot';'Hash']
  vivify_855:
    set $P3031, $P3030["p6regex"]
    unless_null $P3031, vivify_856
    new $P3031, "Undef"
  vivify_856:
    $P3032 = $P3031."ast"()
    get_global $P3033, "@BLOCK"
    $P3034 = $P3033."shift"()
    $P3035 = $P3029($P3032, $P3034)
    store_lex "$regex", $P3035
.annotate 'line', 1162
    get_hll_global $P3036, ["PAST"], "Op"
.annotate 'line', 1164
    get_hll_global $P3037, ["PAST"], "Var"
    new $P3038, "ResizablePMCArray"
    push $P3038, "Regex"
    $P3039 = $P3037."new"("Regex" :named("name"), $P3038 :named("namespace"), "package" :named("scope"))
    find_lex $P3040, "$regex"
    $P3041 = $P3036."new"($P3039, $P3040, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1162
    store_lex "$past", $P3041
.annotate 'line', 1168
    find_lex $P3042, "$regex"
    find_lex $P3043, "$past"
    unless_null $P3043, vivify_857
    $P3043 = root_new ['parrot';'Hash']
    store_lex "$past", $P3043
  vivify_857:
    set $P3043["sink"], $P3042
.annotate 'line', 1169
    find_lex $P3044, "$/"
    find_lex $P3045, "$past"
    $P3046 = $P3044."!make"($P3045)
.annotate 'line', 1149
    .return ($P3046)
  control_3011:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3047, exception, "payload"
    .return ($P3047)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote_escape:sym<$>"  :subid("146_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3051
    .param pmc param_3052
.annotate 'line', 1172
    new $P3050, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3050, control_3049
    push_eh $P3050
    .lex "self", param_3051
    .lex "$/", param_3052
    find_lex $P3053, "$/"
    find_lex $P3054, "$/"
    unless_null $P3054, vivify_858
    $P3054 = root_new ['parrot';'Hash']
  vivify_858:
    set $P3055, $P3054["variable"]
    unless_null $P3055, vivify_859
    new $P3055, "Undef"
  vivify_859:
    $P3056 = $P3055."ast"()
    $P3057 = $P3053."!make"($P3056)
    .return ($P3057)
  control_3049:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3058, exception, "payload"
    .return ($P3058)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote_escape:sym<{ }>"  :subid("147_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3062
    .param pmc param_3063
.annotate 'line', 1173
    new $P3061, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3061, control_3060
    push_eh $P3061
    .lex "self", param_3062
    .lex "$/", param_3063
.annotate 'line', 1174
    find_lex $P3064, "$/"
    get_hll_global $P3065, ["PAST"], "Op"
.annotate 'line', 1175
    find_lex $P3066, "$/"
    unless_null $P3066, vivify_860
    $P3066 = root_new ['parrot';'Hash']
  vivify_860:
    set $P3067, $P3066["block"]
    unless_null $P3067, vivify_861
    new $P3067, "Undef"
  vivify_861:
    $P3068 = $P3067."ast"()
    $P3069 = "block_immediate"($P3068)
    find_lex $P3070, "$/"
    $P3071 = $P3065."new"($P3069, "set S*" :named("pirop"), $P3070 :named("node"))
.annotate 'line', 1174
    $P3072 = $P3064."!make"($P3071)
.annotate 'line', 1173
    .return ($P3072)
  control_3060:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3073, exception, "payload"
    .return ($P3073)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote_escape:sym<esc>"  :subid("148_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3077
    .param pmc param_3078
.annotate 'line', 1178
    new $P3076, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3076, control_3075
    push_eh $P3076
    .lex "self", param_3077
    .lex "$/", param_3078
    find_lex $P3079, "$/"
    $P3080 = $P3079."!make"("\e")
    .return ($P3080)
  control_3075:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3081, exception, "payload"
    .return ($P3081)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "postfix:sym<.>"  :subid("149_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3085
    .param pmc param_3086
.annotate 'line', 1182
    new $P3084, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3084, control_3083
    push_eh $P3084
    .lex "self", param_3085
    .lex "$/", param_3086
    find_lex $P3087, "$/"
    find_lex $P3088, "$/"
    unless_null $P3088, vivify_862
    $P3088 = root_new ['parrot';'Hash']
  vivify_862:
    set $P3089, $P3088["dotty"]
    unless_null $P3089, vivify_863
    new $P3089, "Undef"
  vivify_863:
    $P3090 = $P3089."ast"()
    $P3091 = $P3087."!make"($P3090)
    .return ($P3091)
  control_3083:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3092, exception, "payload"
    .return ($P3092)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "postfix:sym<++>"  :subid("150_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3096
    .param pmc param_3097
.annotate 'line', 1184
    new $P3095, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3095, control_3094
    push_eh $P3095
    .lex "self", param_3096
    .lex "$/", param_3097
.annotate 'line', 1185
    find_lex $P3098, "$/"
    get_hll_global $P3099, ["PAST"], "Op"
.annotate 'line', 1186
    new $P3100, "ResizablePMCArray"
    push $P3100, "    clone %r, %0"
    push $P3100, "    inc %0"
    $P3101 = $P3099."new"("postfix:<++>" :named("name"), $P3100 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1185
    $P3102 = $P3098."!make"($P3101)
.annotate 'line', 1184
    .return ($P3102)
  control_3094:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3103, exception, "payload"
    .return ($P3103)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "postfix:sym<-->"  :subid("151_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3107
    .param pmc param_3108
.annotate 'line', 1190
    new $P3106, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3106, control_3105
    push_eh $P3106
    .lex "self", param_3107
    .lex "$/", param_3108
.annotate 'line', 1191
    find_lex $P3109, "$/"
    get_hll_global $P3110, ["PAST"], "Op"
.annotate 'line', 1192
    new $P3111, "ResizablePMCArray"
    push $P3111, "    clone %r, %0"
    push $P3111, "    dec %0"
    $P3112 = $P3110."new"("postfix:<-->" :named("name"), $P3111 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1191
    $P3113 = $P3109."!make"($P3112)
.annotate 'line', 1190
    .return ($P3113)
  control_3105:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3114, exception, "payload"
    .return ($P3114)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "prefix:sym<make>"  :subid("152_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3118
    .param pmc param_3119
.annotate 'line', 1196
    new $P3117, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3117, control_3116
    push_eh $P3117
    .lex "self", param_3118
    .lex "$/", param_3119
.annotate 'line', 1197
    find_lex $P3120, "$/"
    get_hll_global $P3121, ["PAST"], "Op"
.annotate 'line', 1198
    get_hll_global $P3122, ["PAST"], "Var"
    $P3123 = $P3122."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P3124, "$/"
    $P3125 = $P3121."new"($P3123, "callmethod" :named("pasttype"), "!make" :named("name"), $P3124 :named("node"))
.annotate 'line', 1197
    $P3126 = $P3120."!make"($P3125)
.annotate 'line', 1196
    .return ($P3126)
  control_3116:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3127, exception, "payload"
    .return ($P3127)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<next>"  :subid("153_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3132
    .param pmc param_3133
.annotate 'line', 1214
    new $P3131, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3131, control_3130
    push_eh $P3131
    .lex "self", param_3132
    .lex "$/", param_3133
    find_lex $P3134, "$/"
    $P3135 = "control"($P3134, "CONTROL_LOOP_NEXT")
    .return ($P3135)
  control_3130:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3136, exception, "payload"
    .return ($P3136)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<last>"  :subid("154_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3140
    .param pmc param_3141
.annotate 'line', 1215
    new $P3139, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3139, control_3138
    push_eh $P3139
    .lex "self", param_3140
    .lex "$/", param_3141
    find_lex $P3142, "$/"
    $P3143 = "control"($P3142, "CONTROL_LOOP_LAST")
    .return ($P3143)
  control_3138:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3144, exception, "payload"
    .return ($P3144)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "term:sym<redo>"  :subid("155_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3148
    .param pmc param_3149
.annotate 'line', 1216
    new $P3147, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3147, control_3146
    push_eh $P3147
    .lex "self", param_3148
    .lex "$/", param_3149
    find_lex $P3150, "$/"
    $P3151 = "control"($P3150, "CONTROL_LOOP_REDO")
    .return ($P3151)
  control_3146:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3152, exception, "payload"
    .return ($P3152)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "infix:sym<~~>"  :subid("156_1295307719.828") :outer("11_1295307719.828")
    .param pmc param_3156
    .param pmc param_3157
.annotate 'line', 1218
    new $P3155, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3155, control_3154
    push_eh $P3155
    .lex "self", param_3156
    .lex "$/", param_3157
.annotate 'line', 1219
    find_lex $P3158, "$/"
    get_hll_global $P3159, ["PAST"], "Op"
    find_lex $P3160, "$/"
    $P3161 = $P3159."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P3160 :named("node"))
    $P3162 = $P3158."!make"($P3161)
.annotate 'line', 1218
    .return ($P3162)
  control_3154:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3163, exception, "payload"
    .return ($P3163)
.end


.namespace ["NQP";"RegexActions"]
.sub "_block3164"  :subid("157_1295307719.828") :outer("11_1295307719.828")
.annotate 'line', 1223
    .const 'Sub' $P3285 = "165_1295307719.828" 
    capture_lex $P3285
    .const 'Sub' $P3257 = "164_1295307719.828" 
    capture_lex $P3257
    .const 'Sub' $P3243 = "163_1295307719.828" 
    capture_lex $P3243
    .const 'Sub' $P3225 = "162_1295307719.828" 
    capture_lex $P3225
    .const 'Sub' $P3211 = "161_1295307719.828" 
    capture_lex $P3211
    .const 'Sub' $P3197 = "160_1295307719.828" 
    capture_lex $P3197
    .const 'Sub' $P3183 = "159_1295307719.828" 
    capture_lex $P3183
    .const 'Sub' $P3167 = "158_1295307719.828" 
    capture_lex $P3167
    get_global $P3166, "$?CLASS"
.annotate 'line', 1257
    .const 'Sub' $P3257 = "164_1295307719.828" 
    newclosure $P3283, $P3257
.annotate 'line', 1223
    .return ($P3283)
.end


.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post864") :outer("157_1295307719.828")
.annotate 'line', 1223
    get_hll_global $P3165, ["NQP";"RegexActions"], "_block3164" 
    .local pmc block
    set block, $P3165
    .const 'Sub' $P3285 = "165_1295307719.828" 
    capture_lex $P3285
    $P3285()
.end


.namespace ["NQP";"RegexActions"]
.sub "_block3284"  :anon :subid("165_1295307719.828") :outer("157_1295307719.828")
.annotate 'line', 1223
    get_hll_global $P3286, "NQPClassHOW"
    $P3287 = $P3286."new_type"("RegexActions" :named("name"))
    .local pmc type_obj
    set type_obj, $P3287
    set_hll_global ["NQP"], "RegexActions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3288, type_obj
    .const 'Sub' $P3289 = "158_1295307719.828" 
    $P3288."add_method"(type_obj, "metachar:sym<:my>", $P3289)
    get_how $P3290, type_obj
    .const 'Sub' $P3291 = "159_1295307719.828" 
    $P3290."add_method"(type_obj, "metachar:sym<{ }>", $P3291)
    get_how $P3292, type_obj
    .const 'Sub' $P3293 = "160_1295307719.828" 
    $P3292."add_method"(type_obj, "metachar:sym<nqpvar>", $P3293)
    get_how $P3294, type_obj
    .const 'Sub' $P3295 = "161_1295307719.828" 
    $P3294."add_method"(type_obj, "assertion:sym<{ }>", $P3295)
    get_how $P3296, type_obj
    .const 'Sub' $P3297 = "162_1295307719.828" 
    $P3296."add_method"(type_obj, "assertion:sym<?{ }>", $P3297)
    get_how $P3298, type_obj
    .const 'Sub' $P3299 = "163_1295307719.828" 
    $P3298."add_method"(type_obj, "assertion:sym<var>", $P3299)
    get_how $P3300, type_obj
    .const 'Sub' $P3301 = "164_1295307719.828" 
    $P3300."add_method"(type_obj, "codeblock", $P3301)
    get_how $P3302, type_obj
    get_hll_global $P3303, ["Regex";"P6Regex"], "Actions"
    $P3302."add_parent"(type_obj, $P3303)
    get_how $P3304, type_obj
    $P3305 = $P3304."compose"(type_obj)
    .return ($P3305)
.end


.namespace ["NQP";"RegexActions"]
.include "except_types.pasm"
.sub "metachar:sym<:my>"  :subid("158_1295307719.828") :outer("157_1295307719.828")
    .param pmc param_3170
    .param pmc param_3171
.annotate 'line', 1225
    new $P3169, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3169, control_3168
    push_eh $P3169
    .lex "self", param_3170
    .lex "$/", param_3171
.annotate 'line', 1226
    new $P3172, "Undef"
    .lex "$past", $P3172
    find_lex $P3173, "$/"
    unless_null $P3173, vivify_865
    $P3173 = root_new ['parrot';'Hash']
  vivify_865:
    set $P3174, $P3173["statement"]
    unless_null $P3174, vivify_866
    new $P3174, "Undef"
  vivify_866:
    $P3175 = $P3174."ast"()
    store_lex "$past", $P3175
.annotate 'line', 1227
    find_lex $P3176, "$/"
    get_hll_global $P3177, ["PAST"], "Regex"
    find_lex $P3178, "$past"
    find_lex $P3179, "$/"
    $P3180 = $P3177."new"($P3178, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P3179 :named("node"))
    $P3181 = $P3176."!make"($P3180)
.annotate 'line', 1225
    .return ($P3181)
  control_3168:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3182, exception, "payload"
    .return ($P3182)
.end


.namespace ["NQP";"RegexActions"]
.include "except_types.pasm"
.sub "metachar:sym<{ }>"  :subid("159_1295307719.828") :outer("157_1295307719.828")
    .param pmc param_3186
    .param pmc param_3187
.annotate 'line', 1231
    new $P3185, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3185, control_3184
    push_eh $P3185
    .lex "self", param_3186
    .lex "$/", param_3187
.annotate 'line', 1232
    find_lex $P3188, "$/"
    get_hll_global $P3189, ["PAST"], "Regex"
    find_lex $P3190, "$/"
    unless_null $P3190, vivify_867
    $P3190 = root_new ['parrot';'Hash']
  vivify_867:
    set $P3191, $P3190["codeblock"]
    unless_null $P3191, vivify_868
    new $P3191, "Undef"
  vivify_868:
    $P3192 = $P3191."ast"()
    find_lex $P3193, "$/"
    $P3194 = $P3189."new"($P3192, "pastnode" :named("pasttype"), $P3193 :named("node"))
    $P3195 = $P3188."!make"($P3194)
.annotate 'line', 1231
    .return ($P3195)
  control_3184:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3196, exception, "payload"
    .return ($P3196)
.end


.namespace ["NQP";"RegexActions"]
.include "except_types.pasm"
.sub "metachar:sym<nqpvar>"  :subid("160_1295307719.828") :outer("157_1295307719.828")
    .param pmc param_3200
    .param pmc param_3201
.annotate 'line', 1236
    new $P3199, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3199, control_3198
    push_eh $P3199
    .lex "self", param_3200
    .lex "$/", param_3201
.annotate 'line', 1237
    find_lex $P3202, "$/"
    get_hll_global $P3203, ["PAST"], "Regex"
    find_lex $P3204, "$/"
    unless_null $P3204, vivify_869
    $P3204 = root_new ['parrot';'Hash']
  vivify_869:
    set $P3205, $P3204["var"]
    unless_null $P3205, vivify_870
    new $P3205, "Undef"
  vivify_870:
    $P3206 = $P3205."ast"()
    find_lex $P3207, "$/"
    $P3208 = $P3203."new"("!INTERPOLATE", $P3206, "subrule" :named("pasttype"), "method" :named("subtype"), $P3207 :named("node"))
    $P3209 = $P3202."!make"($P3208)
.annotate 'line', 1236
    .return ($P3209)
  control_3198:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3210, exception, "payload"
    .return ($P3210)
.end


.namespace ["NQP";"RegexActions"]
.include "except_types.pasm"
.sub "assertion:sym<{ }>"  :subid("161_1295307719.828") :outer("157_1295307719.828")
    .param pmc param_3214
    .param pmc param_3215
.annotate 'line', 1241
    new $P3213, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3213, control_3212
    push_eh $P3213
    .lex "self", param_3214
    .lex "$/", param_3215
.annotate 'line', 1242
    find_lex $P3216, "$/"
    get_hll_global $P3217, ["PAST"], "Regex"
    find_lex $P3218, "$/"
    unless_null $P3218, vivify_871
    $P3218 = root_new ['parrot';'Hash']
  vivify_871:
    set $P3219, $P3218["codeblock"]
    unless_null $P3219, vivify_872
    new $P3219, "Undef"
  vivify_872:
    $P3220 = $P3219."ast"()
    find_lex $P3221, "$/"
    $P3222 = $P3217."new"("!INTERPOLATE_REGEX", $P3220, "subrule" :named("pasttype"), "method" :named("subtype"), $P3221 :named("node"))
    $P3223 = $P3216."!make"($P3222)
.annotate 'line', 1241
    .return ($P3223)
  control_3212:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3224, exception, "payload"
    .return ($P3224)
.end


.namespace ["NQP";"RegexActions"]
.include "except_types.pasm"
.sub "assertion:sym<?{ }>"  :subid("162_1295307719.828") :outer("157_1295307719.828")
    .param pmc param_3228
    .param pmc param_3229
.annotate 'line', 1246
    new $P3227, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3227, control_3226
    push_eh $P3227
    .lex "self", param_3228
    .lex "$/", param_3229
.annotate 'line', 1247
    find_lex $P3230, "$/"
    get_hll_global $P3231, ["PAST"], "Regex"
    find_lex $P3232, "$/"
    unless_null $P3232, vivify_873
    $P3232 = root_new ['parrot';'Hash']
  vivify_873:
    set $P3233, $P3232["codeblock"]
    unless_null $P3233, vivify_874
    new $P3233, "Undef"
  vivify_874:
    $P3234 = $P3233."ast"()
.annotate 'line', 1248
    find_lex $P3235, "$/"
    unless_null $P3235, vivify_875
    $P3235 = root_new ['parrot';'Hash']
  vivify_875:
    set $P3236, $P3235["zw"]
    unless_null $P3236, vivify_876
    new $P3236, "Undef"
  vivify_876:
    set $S3237, $P3236
    iseq $I3238, $S3237, "!"
    find_lex $P3239, "$/"
    $P3240 = $P3231."new"($P3234, "zerowidth" :named("subtype"), $I3238 :named("negate"), "pastnode" :named("pasttype"), $P3239 :named("node"))
.annotate 'line', 1247
    $P3241 = $P3230."!make"($P3240)
.annotate 'line', 1246
    .return ($P3241)
  control_3226:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3242, exception, "payload"
    .return ($P3242)
.end


.namespace ["NQP";"RegexActions"]
.include "except_types.pasm"
.sub "assertion:sym<var>"  :subid("163_1295307719.828") :outer("157_1295307719.828")
    .param pmc param_3246
    .param pmc param_3247
.annotate 'line', 1252
    new $P3245, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3245, control_3244
    push_eh $P3245
    .lex "self", param_3246
    .lex "$/", param_3247
.annotate 'line', 1253
    find_lex $P3248, "$/"
    get_hll_global $P3249, ["PAST"], "Regex"
    find_lex $P3250, "$/"
    unless_null $P3250, vivify_877
    $P3250 = root_new ['parrot';'Hash']
  vivify_877:
    set $P3251, $P3250["var"]
    unless_null $P3251, vivify_878
    new $P3251, "Undef"
  vivify_878:
    $P3252 = $P3251."ast"()
    find_lex $P3253, "$/"
    $P3254 = $P3249."new"("!INTERPOLATE_REGEX", $P3252, "subrule" :named("pasttype"), "method" :named("subtype"), $P3253 :named("node"))
    $P3255 = $P3248."!make"($P3254)
.annotate 'line', 1252
    .return ($P3255)
  control_3244:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3256, exception, "payload"
    .return ($P3256)
.end


.namespace ["NQP";"RegexActions"]
.include "except_types.pasm"
.sub "codeblock"  :subid("164_1295307719.828") :outer("157_1295307719.828")
    .param pmc param_3260
    .param pmc param_3261
.annotate 'line', 1257
    new $P3259, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P3259, control_3258
    push_eh $P3259
    .lex "self", param_3260
    .lex "$/", param_3261
.annotate 'line', 1258
    new $P3262, "Undef"
    .lex "$block", $P3262
.annotate 'line', 1260
    new $P3263, "Undef"
    .lex "$past", $P3263
.annotate 'line', 1258
    find_lex $P3264, "$/"
    unless_null $P3264, vivify_879
    $P3264 = root_new ['parrot';'Hash']
  vivify_879:
    set $P3265, $P3264["block"]
    unless_null $P3265, vivify_880
    new $P3265, "Undef"
  vivify_880:
    $P3266 = $P3265."ast"()
    store_lex "$block", $P3266
.annotate 'line', 1259
    find_lex $P3267, "$block"
    $P3267."blocktype"("immediate")
.annotate 'line', 1261
    get_hll_global $P3268, ["PAST"], "Stmts"
.annotate 'line', 1262
    get_hll_global $P3269, ["PAST"], "Op"
.annotate 'line', 1263
    get_hll_global $P3270, ["PAST"], "Var"
    $P3271 = $P3270."new"("$/" :named("name"))
.annotate 'line', 1264
    get_hll_global $P3272, ["PAST"], "Op"
.annotate 'line', 1265
    get_hll_global $P3273, ["PAST"], "Var"
    $P3274 = $P3273."new"(unicode:"$\x{a2}" :named("name"))
    $P3275 = $P3272."new"($P3274, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1264
    $P3276 = $P3269."new"($P3271, $P3275, "bind" :named("pasttype"))
.annotate 'line', 1262
    find_lex $P3277, "$block"
    $P3278 = $P3268."new"($P3276, $P3277)
.annotate 'line', 1261
    store_lex "$past", $P3278
.annotate 'line', 1273
    find_lex $P3279, "$/"
    find_lex $P3280, "$past"
    $P3281 = $P3279."!make"($P3280)
.annotate 'line', 1257
    .return ($P3281)
  control_3258:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3282, exception, "payload"
    .return ($P3282)
.end


.namespace ["NQP";"Actions"]
.sub "_block3307" :load :anon :subid("166_1295307719.828")
.annotate 'line', 3
    .const 'Sub' $P3309 = "11_1295307719.828" 
    $P3310 = $P3309()
    .return ($P3310)
.end


.namespace []
.sub "_block3536" :load :anon :subid("169_1295307719.828")
.annotate 'line', 1
    .const 'Sub' $P3538 = "10_1295307719.828" 
    $P3539 = $P3538()
    .return ($P3539)
.end

### .include 'gen/nqp-compiler.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1295307722.453")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Compiler"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
    $P25 = $P15()
    .return ($P25)
    .const 'Sub' $P27 = "13_1295307722.453" 
    .return ($P27)
.end


.namespace ["NQP";"Compiler"]
.sub "_block14"  :subid("11_1295307722.453") :outer("10_1295307722.453")
.annotate 'line', 1
    .const 'Sub' $P18 = "12_1295307722.453" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    .return ()
.end


.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post14") :outer("11_1295307722.453")
.annotate 'line', 1
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P18 = "12_1295307722.453" 
    capture_lex $P18
    $P18()
.end


.namespace ["NQP";"Compiler"]
.sub "_block17"  :anon :subid("12_1295307722.453") :outer("11_1295307722.453")
.annotate 'line', 1
    get_hll_global $P19, "NQPClassHOW"
    $P20 = $P19."new_type"("Compiler" :named("name"))
    .local pmc type_obj
    set type_obj, $P20
    set_hll_global ["NQP"], "Compiler", type_obj
    set_global "$?CLASS", type_obj
    get_how $P21, type_obj
    get_hll_global $P22, ["HLL"], "Compiler"
    $P21."add_parent"(type_obj, $P22)
    get_how $P23, type_obj
    $P24 = $P23."compose"(type_obj)
    .return ($P24)
.end


.namespace []
.sub "_block26" :load :anon :subid("13_1295307722.453")
.annotate 'line', 1
    .const 'Sub' $P28 = "10_1295307722.453" 
    $P29 = $P28()
    .return ($P29)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " # "
        print description
  no_description:
    print "\n"
    .return (1)
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('NQP-rx')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'NQP-rx'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
